<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/aarch64/sharedRuntime_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.hpp&quot;
  28 #include &quot;asm/macroAssembler.inline.hpp&quot;
  29 #include &quot;classfile/symbolTable.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;code/icBuffer.hpp&quot;
  32 #include &quot;code/vtableStubs.hpp&quot;
  33 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  34 #include &quot;interpreter/interpreter.hpp&quot;
  35 #include &quot;interpreter/interp_masm.hpp&quot;
  36 #include &quot;logging/log.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;nativeInst_aarch64.hpp&quot;
  39 #include &quot;oops/compiledICHolder.hpp&quot;
  40 #include &quot;oops/klass.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;runtime/vframeArray.hpp&quot;
  44 #include &quot;utilities/align.hpp&quot;
  45 #include &quot;vmreg_aarch64.inline.hpp&quot;
  46 #ifdef COMPILER1
  47 #include &quot;c1/c1_Runtime1.hpp&quot;
  48 #endif
  49 #ifdef COMPILER2
  50 #include &quot;adfiles/ad_aarch64.hpp&quot;
  51 #include &quot;opto/runtime.hpp&quot;
  52 #endif
  53 #if INCLUDE_JVMCI
  54 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  55 #endif
  56 
  57 #define __ masm-&gt;
  58 
  59 const int StackAlignmentInSlots = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
  60 
  61 class SimpleRuntimeFrame {
  62 
  63   public:
  64 
  65   // Most of the runtime stubs have this simple frame layout.
  66   // This class exists to make the layout shared in one place.
  67   // Offsets are for compiler stack slots, which are jints.
  68   enum layout {
  69     // The frame sender code expects that rbp will be in the &quot;natural&quot; place and
  70     // will override any oopMap setting for it. We must therefore force the layout
  71     // so that it agrees with the frame sender code.
  72     // we don&#39;t expect any arg reg save area so aarch64 asserts that
  73     // frame::arg_reg_save_area_bytes == 0
  74     rbp_off = 0,
  75     rbp_off2,
  76     return_off, return_off2,
  77     framesize
  78   };
  79 };
  80 
  81 // FIXME -- this is used by C1
  82 class RegisterSaver {
  83  public:
  84   static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);
  85   static void restore_live_registers(MacroAssembler* masm, bool restore_vectors = false);
  86 
  87   // Offsets into the register save area
  88   // Used by deoptimization when it is managing result register
  89   // values on its own
  90 
  91   static int r0_offset_in_bytes(void)    { return (32 + r0-&gt;encoding()) * wordSize; }
  92   static int reg_offset_in_bytes(Register r)    { return r0_offset_in_bytes() + r-&gt;encoding() * wordSize; }
  93   static int rmethod_offset_in_bytes(void)    { return reg_offset_in_bytes(rmethod); }
  94   static int rscratch1_offset_in_bytes(void)    { return (32 + rscratch1-&gt;encoding()) * wordSize; }
  95   static int v0_offset_in_bytes(void)   { return 0; }
  96   static int return_offset_in_bytes(void) { return (32 /* floats*/ + 31 /* gregs*/) * wordSize; }
  97 
  98   // During deoptimization only the result registers need to be restored,
  99   // all the other values have already been extracted.
 100   static void restore_result_registers(MacroAssembler* masm);
 101 
 102     // Capture info about frame layout
 103   enum layout {
 104                 fpu_state_off = 0,
 105                 fpu_state_end = fpu_state_off + FPUStateSizeInWords - 1,
 106                 // The frame sender code expects that rfp will be in
 107                 // the &quot;natural&quot; place and will override any oopMap
 108                 // setting for it. We must therefore force the layout
 109                 // so that it agrees with the frame sender code.
 110                 r0_off = fpu_state_off + FPUStateSizeInWords,
 111                 rfp_off = r0_off + (RegisterImpl::number_of_registers - 2) * RegisterImpl::max_slots_per_register,
 112                 return_off = rfp_off + RegisterImpl::max_slots_per_register,      // slot for return address
 113                 reg_save_size = return_off + RegisterImpl::max_slots_per_register};
 114 
 115 };
 116 
 117 OopMap* RegisterSaver::save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors) {
 118 #if COMPILER2_OR_JVMCI
 119   if (save_vectors) {
 120     // Save upper half of vector registers
 121     int vect_words = FloatRegisterImpl::number_of_registers * FloatRegisterImpl::extra_save_slots_per_register /
 122                      VMRegImpl::slots_per_word;
 123     additional_frame_words += vect_words;
 124   }
 125 #else
 126   assert(!save_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 127 #endif
 128 
 129   int frame_size_in_bytes = align_up(additional_frame_words * wordSize +
 130                                      reg_save_size * BytesPerInt, 16);
 131   // OopMap frame size is in compiler stack slots (jint&#39;s) not bytes or words
 132   int frame_size_in_slots = frame_size_in_bytes / BytesPerInt;
 133   // The caller will allocate additional_frame_words
 134   int additional_frame_slots = additional_frame_words * wordSize / BytesPerInt;
 135   // CodeBlob frame size is in words.
 136   int frame_size_in_words = frame_size_in_bytes / wordSize;
 137   *total_frame_words = frame_size_in_words;
 138 
 139   // Save Integer and Float registers.
 140   __ enter();
 141   __ push_CPU_state(save_vectors);
 142 
 143   // Set an oopmap for the call site.  This oopmap will map all
 144   // oop-registers and debug-info registers as callee-saved.  This
 145   // will allow deoptimization at this safepoint to find all possible
 146   // debug-info recordings, as well as let GC find all oops.
 147 
 148   OopMapSet *oop_maps = new OopMapSet();
 149   OopMap* oop_map = new OopMap(frame_size_in_slots, 0);
 150 
 151   for (int i = 0; i &lt; RegisterImpl::number_of_registers; i++) {
 152     Register r = as_Register(i);
 153     if (r &lt;= rfp &amp;&amp; r != rscratch1 &amp;&amp; r != rscratch2) {
 154       // SP offsets are in 4-byte words.
 155       // Register slots are 8 bytes wide, 32 floating-point registers.
 156       int sp_offset = RegisterImpl::max_slots_per_register * i +
 157                       FloatRegisterImpl::save_slots_per_register * FloatRegisterImpl::number_of_registers;
 158       oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset + additional_frame_slots),
 159                                 r-&gt;as_VMReg());
 160     }
 161   }
 162 
 163   for (int i = 0; i &lt; FloatRegisterImpl::number_of_registers; i++) {
 164     FloatRegister r = as_FloatRegister(i);
 165     int sp_offset = save_vectors ? (FloatRegisterImpl::max_slots_per_register * i) :
 166                                    (FloatRegisterImpl::save_slots_per_register * i);
 167     oop_map-&gt;set_callee_saved(VMRegImpl::stack2reg(sp_offset),
 168                               r-&gt;as_VMReg());
 169   }
 170 
 171   return oop_map;
 172 }
 173 
 174 void RegisterSaver::restore_live_registers(MacroAssembler* masm, bool restore_vectors) {
 175 #if !COMPILER2_OR_JVMCI
 176   assert(!restore_vectors, &quot;vectors are generated only by C2 and JVMCI&quot;);
 177 #endif
 178   __ pop_CPU_state(restore_vectors);
 179   __ leave();
 180 
 181 }
 182 
 183 void RegisterSaver::restore_result_registers(MacroAssembler* masm) {
 184 
 185   // Just restore result register. Only used by deoptimization. By
 186   // now any callee save register that needs to be restored to a c2
 187   // caller of the deoptee has been extracted into the vframeArray
 188   // and will be stuffed into the c2i adapter we create for later
 189   // restoration so only result registers need to be restored here.
 190 
 191   // Restore fp result register
 192   __ ldrd(v0, Address(sp, v0_offset_in_bytes()));
 193   // Restore integer result register
 194   __ ldr(r0, Address(sp, r0_offset_in_bytes()));
 195 
 196   // Pop all of the register save are off the stack
 197   __ add(sp, sp, align_up(return_offset_in_bytes(), 16));
 198 }
 199 
 200 // Is vector&#39;s size (in bytes) bigger than a size saved by default?
 201 // 8 bytes vector registers are saved by default on AArch64.
 202 bool SharedRuntime::is_wide_vector(int size) {
 203   return size &gt; 8;
 204 }
 205 
 206 size_t SharedRuntime::trampoline_size() {
 207   return 16;
 208 }
 209 
 210 void SharedRuntime::generate_trampoline(MacroAssembler *masm, address destination) {
 211   __ mov(rscratch1, destination);
 212   __ br(rscratch1);
 213 }
 214 
 215 // The java_calling_convention describes stack locations as ideal slots on
 216 // a frame with no abi restrictions. Since we must observe abi restrictions
 217 // (like the placement of the register window) the slots must be biased by
 218 // the following value.
 219 static int reg2offset_in(VMReg r) {
 220   // Account for saved rfp and lr
 221   // This should really be in_preserve_stack_slots
 222   return (r-&gt;reg2stack() + 4) * VMRegImpl::stack_slot_size;
 223 }
 224 
 225 static int reg2offset_out(VMReg r) {
 226   return (r-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots()) * VMRegImpl::stack_slot_size;
 227 }
 228 
 229 // ---------------------------------------------------------------------------
 230 // Read the array of BasicTypes from a signature, and compute where the
 231 // arguments should go.  Values in the VMRegPair regs array refer to 4-byte
 232 // quantities.  Values less than VMRegImpl::stack0 are registers, those above
 233 // refer to 4-byte stack slots.  All stack slots are based off of the stack pointer
 234 // as framesizes are fixed.
 235 // VMRegImpl::stack0 refers to the first slot 0(sp).
 236 // and VMRegImpl::stack0+1 refers to the memory word 4-byes higher.  Register
 237 // up to RegisterImpl::number_of_registers) are the 64-bit
 238 // integer registers.
 239 
 240 // Note: the INPUTS in sig_bt are in units of Java argument words,
 241 // which are 64-bit.  The OUTPUTS are in 32-bit units.
 242 
 243 // The Java calling convention is a &quot;shifted&quot; version of the C ABI.
 244 // By skipping the first C ABI register we can call non-static jni
 245 // methods with small numbers of arguments without having to shuffle
 246 // the arguments at all. Since we control the java ABI we ought to at
 247 // least get some advantage out of it.
 248 
 249 int SharedRuntime::java_calling_convention(const BasicType *sig_bt,
 250                                            VMRegPair *regs,
 251                                            int total_args_passed,
 252                                            int is_outgoing) {
 253 
 254   // Create the mapping between argument positions and
 255   // registers.
 256   static const Register INT_ArgReg[Argument::n_int_register_parameters_j] = {
 257     j_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4, j_rarg5, j_rarg6, j_rarg7
 258   };
 259   static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_j] = {
 260     j_farg0, j_farg1, j_farg2, j_farg3,
 261     j_farg4, j_farg5, j_farg6, j_farg7
 262   };
 263 
 264 
 265   uint int_args = 0;
 266   uint fp_args = 0;
 267   uint stk_args = 0; // inc by 2 each time
 268 
 269   for (int i = 0; i &lt; total_args_passed; i++) {
 270     switch (sig_bt[i]) {
 271     case T_BOOLEAN:
 272     case T_CHAR:
 273     case T_BYTE:
 274     case T_SHORT:
 275     case T_INT:
 276       if (int_args &lt; Argument::n_int_register_parameters_j) {
 277         regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
 278       } else {
 279         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 280         stk_args += 2;
 281       }
 282       break;
 283     case T_VOID:
 284       // halves of T_LONG or T_DOUBLE
 285       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 286       regs[i].set_bad();
 287       break;
 288     case T_LONG:
 289       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 290       // fall through
 291     case T_OBJECT:
 292     case T_ARRAY:
 293     case T_ADDRESS:
 294     case T_VALUETYPE:
 295       if (int_args &lt; Argument::n_int_register_parameters_j) {
 296         regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
 297       } else {
 298         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 299         stk_args += 2;
 300       }
 301       break;
 302     case T_FLOAT:
 303       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 304         regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 305       } else {
 306         regs[i].set1(VMRegImpl::stack2reg(stk_args));
 307         stk_args += 2;
 308       }
 309       break;
 310     case T_DOUBLE:
 311       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 312       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 313         regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
 314       } else {
 315         regs[i].set2(VMRegImpl::stack2reg(stk_args));
 316         stk_args += 2;
 317       }
 318       break;
 319     default:
 320       ShouldNotReachHere();
 321       break;
 322     }
 323   }
 324 
 325   return align_up(stk_args, 2);
 326 }
 327 
 328 
 329 // const uint SharedRuntime::java_return_convention_max_int = Argument::n_int_register_parameters_j+1;
 330 const uint SharedRuntime::java_return_convention_max_int = 6;
 331 const uint SharedRuntime::java_return_convention_max_float = Argument::n_float_register_parameters_j;
 332 
 333 int SharedRuntime::java_return_convention(const BasicType *sig_bt, VMRegPair *regs, int total_args_passed) {
 334 
 335   // Create the mapping between argument positions and
 336   // registers.
 337   // r1, r2 used to address klasses and states, exclude it from return convention to avoid colision
 338 
 339   static const Register INT_ArgReg[java_return_convention_max_int] = {
 340      r0 /* j_rarg7 */, j_rarg6, j_rarg5, j_rarg4, j_rarg3, j_rarg2
 341   };
 342 
 343   static const FloatRegister FP_ArgReg[java_return_convention_max_float] = {
 344     j_farg0, j_farg1, j_farg2, j_farg3, j_farg4, j_farg5, j_farg6, j_farg7
 345   };
 346 
 347   uint int_args = 0;
 348   uint fp_args = 0;
 349 
 350   for (int i = 0; i &lt; total_args_passed; i++) {
 351     switch (sig_bt[i]) {
 352     case T_BOOLEAN:
 353     case T_CHAR:
 354     case T_BYTE:
 355     case T_SHORT:
 356     case T_INT:
 357       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {
 358         regs[i].set1(INT_ArgReg[int_args]-&gt;as_VMReg());
 359         int_args ++;
 360       } else {
 361         // Should we have gurantee here?
 362         return -1;
 363       }
 364       break;
 365     case T_VOID:
 366       // halves of T_LONG or T_DOUBLE
 367       assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
 368       regs[i].set_bad();
 369       break;
 370     case T_LONG:
 371       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 372       // fall through
 373     case T_OBJECT:
 374     case T_ARRAY:
 375     case T_ADDRESS:
 376       // Should T_METADATA be added to java_calling_convention as well ?
 377     case T_METADATA:
 378     case T_VALUETYPE:
 379       if (int_args &lt; SharedRuntime::java_return_convention_max_int) {
 380         regs[i].set2(INT_ArgReg[int_args]-&gt;as_VMReg());
 381         int_args ++;
 382       } else {
 383         return -1;
 384       }
 385       break;
 386     case T_FLOAT:
 387       if (fp_args &lt; SharedRuntime::java_return_convention_max_float) {
 388         regs[i].set1(FP_ArgReg[fp_args]-&gt;as_VMReg());
 389         fp_args ++;
 390       } else {
 391         return -1;
 392       }
 393       break;
 394     case T_DOUBLE:
 395       assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
 396       if (fp_args &lt; Argument::n_float_register_parameters_j) {
 397         regs[i].set2(FP_ArgReg[fp_args]-&gt;as_VMReg());
 398         fp_args ++;
 399       } else {
 400         return -1;
 401       }
 402       break;
 403     default:
 404       ShouldNotReachHere();
 405       break;
 406     }
 407   }
 408 
 409   return int_args + fp_args;
 410 }
 411 
 412 // Patch the callers callsite with entry to compiled code if it exists.
 413 static void patch_callers_callsite(MacroAssembler *masm) {
 414   Label L;
 415   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 416   __ cbz(rscratch1, L);
 417 
 418   __ enter();
 419   __ push_CPU_state();
 420 
 421   // VM needs caller&#39;s callsite
 422   // VM needs target method
 423   // This needs to be a long call since we will relocate this adapter to
 424   // the codeBuffer and it may not reach
 425 
 426 #ifndef PRODUCT
 427   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
 428 #endif
 429 
 430   __ mov(c_rarg0, rmethod);
 431   __ mov(c_rarg1, lr);
 432   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::fixup_callers_callsite)));
 433   __ blr(rscratch1);
 434   __ maybe_isb();
 435 
 436   __ pop_CPU_state();
 437   // restore sp
 438   __ leave();
 439   __ bind(L);
 440 }
 441 
 442 // For each value type argument, sig includes the list of fields of
 443 // the value type. This utility function computes the number of
 444 // arguments for the call if value types are passed by reference (the
 445 // calling convention the interpreter expects).
 446 static int compute_total_args_passed_int(const GrowableArray&lt;SigEntry&gt;* sig_extended) {
 447   int total_args_passed = 0;
 448   if (InlineTypePassFieldsAsArgs) {
 449      for (int i = 0; i &lt; sig_extended-&gt;length(); i++) {
 450        BasicType bt = sig_extended-&gt;at(i)._bt;
 451        if (SigEntry::is_reserved_entry(sig_extended, i)) {
 452          // Ignore reserved entry
 453        } else if (bt == T_VALUETYPE) {
 454          // In sig_extended, a value type argument starts with:
 455          // T_VALUETYPE, followed by the types of the fields of the
 456          // value type and T_VOID to mark the end of the value
 457          // type. Value types are flattened so, for instance, in the
 458          // case of a value type with an int field and a value type
 459          // field that itself has 2 fields, an int and a long:
 460          // T_VALUETYPE T_INT T_VALUETYPE T_INT T_LONG T_VOID (second
 461          // slot for the T_LONG) T_VOID (inner T_VALUETYPE) T_VOID
 462          // (outer T_VALUETYPE)
 463          total_args_passed++;
 464          int vt = 1;
 465          do {
 466            i++;
 467            BasicType bt = sig_extended-&gt;at(i)._bt;
 468            BasicType prev_bt = sig_extended-&gt;at(i-1)._bt;
 469            if (bt == T_VALUETYPE) {
 470              vt++;
 471            } else if (bt == T_VOID &amp;&amp;
 472                       prev_bt != T_LONG &amp;&amp;
 473                       prev_bt != T_DOUBLE) {
 474              vt--;
 475            }
 476          } while (vt != 0);
 477        } else {
 478          total_args_passed++;
 479        }
 480      }
 481   } else {
 482     total_args_passed = sig_extended-&gt;length();
 483   }
 484 
 485   return total_args_passed;
 486 }
 487 
 488 
 489 static void gen_c2i_adapter_helper(MacroAssembler* masm, BasicType bt, const VMRegPair&amp; reg_pair, int extraspace, const Address&amp; to) {
 490 
 491     assert(bt != T_VALUETYPE || !InlineTypePassFieldsAsArgs, &quot;no inline type here&quot;);
 492 
 493     // Say 4 args:
 494     // i   st_off
 495     // 0   32 T_LONG
 496     // 1   24 T_VOID
 497     // 2   16 T_OBJECT
 498     // 3    8 T_BOOL
 499     // -    0 return address
 500     //
 501     // However to make thing extra confusing. Because we can fit a long/double in
 502     // a single slot on a 64 bt vm and it would be silly to break them up, the interpreter
 503     // leaves one slot empty and only stores to a single slot. In this case the
 504     // slot that is occupied is the T_VOID slot. See I said it was confusing.
 505 
 506     // int next_off = st_off - Interpreter::stackElementSize;
 507 
 508     VMReg r_1 = reg_pair.first();
 509     VMReg r_2 = reg_pair.second();
 510 
 511     if (!r_1-&gt;is_valid()) {
 512       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 513       return;
 514     }
 515 
 516     if (r_1-&gt;is_stack()) {
 517       // memory to memory use rscratch1
 518       // words_pushed is always 0 so we don&#39;t use it.
 519       int ld_off = (r_1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extraspace /* + word_pushed * wordSize */);
 520       if (!r_2-&gt;is_valid()) {
 521         // sign extend??
 522         __ ldrw(rscratch1, Address(sp, ld_off));
 523         __ str(rscratch1, to);
 524 
 525       } else {
 526         __ ldr(rscratch1, Address(sp, ld_off));
 527         __ str(rscratch1, to);
 528       }
 529     } else if (r_1-&gt;is_Register()) {
 530       Register r = r_1-&gt;as_Register();
 531       __ str(r, to);
 532     } else {
 533       assert(r_1-&gt;is_FloatRegister(), &quot;&quot;);
 534       if (!r_2-&gt;is_valid()) {
 535         // only a float use just part of the slot
 536         __ strs(r_1-&gt;as_FloatRegister(), to);
 537       } else {
 538         __ strd(r_1-&gt;as_FloatRegister(), to);
 539       }
 540    }
 541 }
 542 
 543 static void gen_c2i_adapter(MacroAssembler *masm,
 544                             const GrowableArray&lt;SigEntry&gt;* sig_extended,
 545                             const VMRegPair *regs,
 546                             Label&amp; skip_fixup,
 547                             address start,
 548                             OopMapSet* oop_maps,
 549                             int&amp; frame_complete,
 550                             int&amp; frame_size_in_words,
 551                             bool alloc_value_receiver) {
 552 
 553   // Before we get into the guts of the C2I adapter, see if we should be here
 554   // at all.  We&#39;ve come from compiled code and are attempting to jump to the
 555   // interpreter, which means the caller made a static call to get here
 556   // (vcalls always get a compiled target if there is one).  Check for a
 557   // compiled target.  If there is one, we need to patch the caller&#39;s call.
 558   patch_callers_callsite(masm);
 559 
 560   __ bind(skip_fixup);
 561 
 562   bool has_value_argument = false;
 563 
 564   if (InlineTypePassFieldsAsArgs) {
 565       // Is there an inline type argument?
 566      for (int i = 0; i &lt; sig_extended-&gt;length() &amp;&amp; !has_value_argument; i++) {
 567        has_value_argument = (sig_extended-&gt;at(i)._bt == T_VALUETYPE);
 568      }
 569      if (has_value_argument) {
 570       // There is at least a value type argument: we&#39;re coming from
 571       // compiled code so we have no buffers to back the value
 572       // types. Allocate the buffers here with a runtime call.
 573       OopMap* map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
 574 
 575       frame_complete = __ offset();
 576       address the_pc = __ pc();
 577 
 578       __ set_last_Java_frame(noreg, noreg, the_pc, rscratch1);
 579 
 580       __ mov(c_rarg0, rthread);
 581       __ mov(c_rarg1, r1);
 582       __ mov(c_rarg2, (int64_t)alloc_value_receiver);
 583 
 584       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::allocate_value_types)));
 585       __ blr(rscratch1);
 586 
 587       oop_maps-&gt;add_gc_map((int)(__ pc() - start), map);
 588       __ reset_last_Java_frame(false);
 589 
 590       RegisterSaver::restore_live_registers(masm);
 591 
 592       Label no_exception;
 593       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
 594       __ cbz(r0, no_exception);
 595 
 596       __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
 597       __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
 598       __ b(RuntimeAddress(StubRoutines::forward_exception_entry()));
 599 
 600       __ bind(no_exception);
 601 
 602       // We get an array of objects from the runtime call
 603       __ get_vm_result(r10, rthread);
 604       __ get_vm_result_2(r1, rthread); // TODO: required to keep the callee Method live?
 605     }
 606   }
 607 
 608   int words_pushed = 0;
 609 
 610   // Since all args are passed on the stack, total_args_passed *
 611   // Interpreter::stackElementSize is the space we need.
 612 
 613   int total_args_passed = compute_total_args_passed_int(sig_extended);
 614   int extraspace = (total_args_passed * Interpreter::stackElementSize) + wordSize;
 615 
 616   // stack is aligned, keep it that way
 617   extraspace = align_up(extraspace, 2 * wordSize);
 618 
 619   __ mov(r13, sp);
 620 
 621   if (extraspace)
 622     __ sub(sp, sp, extraspace);
 623 
 624   // Now write the args into the outgoing interpreter space
 625 
 626   int ignored = 0, next_vt_arg = 0, next_arg_int = 0;
 627   bool has_oop_field = false;
 628 
 629   for (int next_arg_comp = 0; next_arg_comp &lt; total_args_passed; next_arg_comp++) {
 630     BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 631     // offset to start parameters
 632     int st_off   = (total_args_passed - next_arg_int - 1) * Interpreter::stackElementSize;
 633 
 634     if (!InlineTypePassFieldsAsArgs || bt != T_VALUETYPE) {
 635 
 636             if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 637                continue; // Ignore reserved entry
 638             }
 639 
 640             if (bt == T_VOID) {
 641                assert(next_arg_comp &gt; 0 &amp;&amp; (sig_extended-&gt;at(next_arg_comp - 1)._bt == T_LONG || sig_extended-&gt;at(next_arg_comp - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 642                next_arg_int ++;
 643                continue;
 644              }
 645 
 646              int next_off = st_off - Interpreter::stackElementSize;
 647              int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : st_off;
 648 
 649              gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp], extraspace, Address(sp, offset));
 650              next_arg_int ++;
 651    } else {
 652        ignored++;
 653       // get the buffer from the just allocated pool of buffers
 654       int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + next_vt_arg * type2aelembytes(T_VALUETYPE);
 655       __ load_heap_oop(rscratch1, Address(r10, index));
 656       next_vt_arg++;
 657       next_arg_int++;
 658       int vt = 1;
 659       // write fields we get from compiled code in registers/stack
 660       // slots to the buffer: we know we are done with that value type
 661       // argument when we hit the T_VOID that acts as an end of value
 662       // type delimiter for this value type. Value types are flattened
 663       // so we might encounter embedded value types. Each entry in
 664       // sig_extended contains a field offset in the buffer.
 665       do {
 666         next_arg_comp++;
 667         BasicType bt = sig_extended-&gt;at(next_arg_comp)._bt;
 668         BasicType prev_bt = sig_extended-&gt;at(next_arg_comp - 1)._bt;
 669         if (bt == T_VALUETYPE) {
 670           vt++;
 671           ignored++;
 672         } else if (bt == T_VOID &amp;&amp; prev_bt != T_LONG &amp;&amp; prev_bt != T_DOUBLE) {
 673           vt--;
 674           ignored++;
 675         } else if (SigEntry::is_reserved_entry(sig_extended, next_arg_comp)) {
 676           // Ignore reserved entry
 677         } else {
 678           int off = sig_extended-&gt;at(next_arg_comp)._offset;
 679           assert(off &gt; 0, &quot;offset in object should be positive&quot;);
 680 
 681           bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);
 682           has_oop_field = has_oop_field || is_oop;
 683 
 684           gen_c2i_adapter_helper(masm, bt, regs[next_arg_comp - ignored], extraspace, Address(r11, off));
 685         }
 686       } while (vt != 0);
 687       // pass the buffer to the interpreter
 688       __ str(rscratch1, Address(sp, st_off));
 689    }
 690 
 691   }
 692 
 693 // If a value type was allocated and initialized, apply post barrier to all oop fields
 694   if (has_value_argument &amp;&amp; has_oop_field) {
 695     __ push(r13); // save senderSP
 696     __ push(r1); // save callee
 697     // Allocate argument register save area
 698     if (frame::arg_reg_save_area_bytes != 0) {
 699       __ sub(sp, sp, frame::arg_reg_save_area_bytes);
 700     }
 701     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::apply_post_barriers), rthread, r10);
 702     // De-allocate argument register save area
 703     if (frame::arg_reg_save_area_bytes != 0) {
 704       __ add(sp, sp, frame::arg_reg_save_area_bytes);
 705     }
 706     __ pop(r1); // restore callee
 707     __ pop(r13); // restore sender SP
 708   }
 709 
 710   __ mov(esp, sp); // Interp expects args on caller&#39;s expression stack
 711 
 712   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::interpreter_entry_offset())));
 713   __ br(rscratch1);
 714 }
 715 
 716 void SharedRuntime::gen_i2c_adapter(MacroAssembler *masm, int comp_args_on_stack, const GrowableArray&lt;SigEntry&gt;* sig, const VMRegPair *regs) {
 717 
 718 
 719   // Note: r13 contains the senderSP on entry. We must preserve it since
 720   // we may do a i2c -&gt; c2i transition if we lose a race where compiled
 721   // code goes non-entrant while we get args ready.
 722 
 723   // In addition we use r13 to locate all the interpreter args because
 724   // we must align the stack to 16 bytes.
 725 
 726   // Adapters are frameless.
 727 
 728   // An i2c adapter is frameless because the *caller* frame, which is
 729   // interpreted, routinely repairs its own esp (from
 730   // interpreter_frame_last_sp), even if a callee has modified the
 731   // stack pointer.  It also recalculates and aligns sp.
 732 
 733   // A c2i adapter is frameless because the *callee* frame, which is
 734   // interpreted, routinely repairs its caller&#39;s sp (from sender_sp,
 735   // which is set up via the senderSP register).
 736 
 737   // In other words, if *either* the caller or callee is interpreted, we can
 738   // get the stack pointer repaired after a call.
 739 
 740   // This is why c2i and i2c adapters cannot be indefinitely composed.
 741   // In particular, if a c2i adapter were to somehow call an i2c adapter,
 742   // both caller and callee would be compiled methods, and neither would
 743   // clean up the stack pointer changes performed by the two adapters.
 744   // If this happens, control eventually transfers back to the compiled
 745   // caller, but with an uncorrected stack, causing delayed havoc.
 746 
 747   if (VerifyAdapterCalls &amp;&amp;
 748       (Interpreter::code() != NULL || StubRoutines::code1() != NULL)) {
 749 #if 0
 750     // So, let&#39;s test for cascading c2i/i2c adapters right now.
 751     //  assert(Interpreter::contains($return_addr) ||
 752     //         StubRoutines::contains($return_addr),
 753     //         &quot;i2c adapter must return to an interpreter frame&quot;);
 754     __ block_comment(&quot;verify_i2c { &quot;);
 755     Label L_ok;
 756     if (Interpreter::code() != NULL)
 757       range_check(masm, rax, r11,
 758                   Interpreter::code()-&gt;code_start(), Interpreter::code()-&gt;code_end(),
 759                   L_ok);
 760     if (StubRoutines::code1() != NULL)
 761       range_check(masm, rax, r11,
 762                   StubRoutines::code1()-&gt;code_begin(), StubRoutines::code1()-&gt;code_end(),
 763                   L_ok);
 764     if (StubRoutines::code2() != NULL)
 765       range_check(masm, rax, r11,
 766                   StubRoutines::code2()-&gt;code_begin(), StubRoutines::code2()-&gt;code_end(),
 767                   L_ok);
 768     const char* msg = &quot;i2c adapter must return to an interpreter frame&quot;;
 769     __ block_comment(msg);
 770     __ stop(msg);
 771     __ bind(L_ok);
 772     __ block_comment(&quot;} verify_i2ce &quot;);
 773 #endif
 774   }
 775 
 776   // Cut-out for having no stack args.
 777   int comp_words_on_stack = 0;
 778   if (comp_args_on_stack) {
 779      comp_words_on_stack = align_up(comp_args_on_stack * VMRegImpl::stack_slot_size, wordSize) &gt;&gt; LogBytesPerWord;
 780      __ sub(rscratch1, sp, comp_words_on_stack * wordSize);
 781      __ andr(sp, rscratch1, -16);
 782   }
 783 
 784   // Will jump to the compiled code just as if compiled code was doing it.
 785   // Pre-load the register-jump target early, to schedule it better.
 786   __ ldr(rscratch1, Address(rmethod, in_bytes(Method::from_compiled_offset())));
 787 
 788 #if INCLUDE_JVMCI
 789   if (EnableJVMCI || UseAOT) {
 790     // check if this call should be routed towards a specific entry point
 791     __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 792     Label no_alternative_target;
 793     __ cbz(rscratch2, no_alternative_target);
 794     __ mov(rscratch1, rscratch2);
 795     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));
 796     __ bind(no_alternative_target);
 797   }
 798 #endif // INCLUDE_JVMCI
 799 
 800   int total_args_passed = sig-&gt;length();
 801 
 802   // Now generate the shuffle code.
 803   for (int i = 0; i &lt; total_args_passed; i++) {
 804     BasicType bt = sig-&gt;at(i)._bt;
 805 
 806     assert(bt != T_VALUETYPE, &quot;i2c adapter doesn&#39;t unpack value args&quot;);
 807     if (bt == T_VOID) {
 808       assert(i &gt; 0 &amp;&amp; (sig-&gt;at(i - 1)._bt == T_LONG || sig-&gt;at(i - 1)._bt == T_DOUBLE), &quot;missing half&quot;);
 809       continue;
 810     }
 811 
 812     // Pick up 0, 1 or 2 words from SP+offset.
 813     assert(!regs[i].second()-&gt;is_valid() || regs[i].first()-&gt;next() == regs[i].second(), &quot;scrambled load targets?&quot;);
 814 
 815     // Load in argument order going down.
 816     int ld_off = (total_args_passed - i - 1) * Interpreter::stackElementSize;
 817     // Point to interpreter value (vs. tag)
 818     int next_off = ld_off - Interpreter::stackElementSize;
 819     //
 820     //
 821     //
 822     VMReg r_1 = regs[i].first();
 823     VMReg r_2 = regs[i].second();
 824     if (!r_1-&gt;is_valid()) {
 825       assert(!r_2-&gt;is_valid(), &quot;&quot;);
 826       continue;
 827     }
 828     if (r_1-&gt;is_stack()) {
 829       // Convert stack slot to an SP offset (+ wordSize to account for return address )
 830       int st_off = regs[i].first()-&gt;reg2stack() * VMRegImpl::stack_slot_size;
 831       if (!r_2-&gt;is_valid()) {
 832         // sign extend???
 833         __ ldrsw(rscratch2, Address(esp, ld_off));
 834         __ str(rscratch2, Address(sp, st_off));
 835       } else {
 836         //
 837         // We are using two optoregs. This can be either T_OBJECT,
 838         // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 839         // two slots but only uses one for thr T_LONG or T_DOUBLE case
 840         // So we must adjust where to pick up the data to match the
 841         // interpreter.
 842         //
 843         // Interpreter local[n] == MSW, local[n+1] == LSW however locals
 844         // are accessed as negative so LSW is at LOW address
 845 
 846         // ld_off is MSW so get LSW
 847         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;
 848         __ ldr(rscratch2, Address(esp, offset));
 849         // st_off is LSW (i.e. reg.first())
 850          __ str(rscratch2, Address(sp, st_off));
 851        }
 852      } else if (r_1-&gt;is_Register()) {  // Register argument
 853        Register r = r_1-&gt;as_Register();
 854        if (r_2-&gt;is_valid()) {
 855          //
 856          // We are using two VMRegs. This can be either T_OBJECT,
 857          // T_ADDRESS, T_LONG, or T_DOUBLE the interpreter allocates
 858          // two slots but only uses one for thr T_LONG or T_DOUBLE case
 859          // So we must adjust where to pick up the data to match the
 860          // interpreter.
 861 
 862         const int offset = (bt == T_LONG || bt == T_DOUBLE) ? next_off : ld_off;
 863 
 864          // this can be a misaligned move
 865          __ ldr(r, Address(esp, offset));
 866        } else {
 867          // sign extend and use a full word?
 868          __ ldrw(r, Address(esp, ld_off));
 869        }
 870      } else {
 871        if (!r_2-&gt;is_valid()) {
 872          __ ldrs(r_1-&gt;as_FloatRegister(), Address(esp, ld_off));
 873        } else {
 874          __ ldrd(r_1-&gt;as_FloatRegister(), Address(esp, next_off));
 875        }
 876      }
 877    }
 878 
 879 
 880   // 6243940 We might end up in handle_wrong_method if
 881   // the callee is deoptimized as we race thru here. If that
 882   // happens we don&#39;t want to take a safepoint because the
 883   // caller frame will look interpreted and arguments are now
 884   // &quot;compiled&quot; so it is much better to make this transition
 885   // invisible to the stack walking code. Unfortunately if
 886   // we try and find the callee by normal means a safepoint
 887   // is possible. So we stash the desired callee in the thread
 888   // and the vm will find there should this case occur.
 889 
 890   __ str(rmethod, Address(rthread, JavaThread::callee_target_offset()));
 891   __ br(rscratch1);
 892 }
 893 
 894 static void gen_inline_cache_check(MacroAssembler *masm, Label&amp; skip_fixup) {
 895 
 896   Label ok;
 897 
 898   Register holder = rscratch2;
 899   Register receiver = j_rarg0;
 900   Register tmp = r10;  // A call-clobbered register not used for arg passing
 901 
 902   // -------------------------------------------------------------------------
 903   // Generate a C2I adapter.  On entry we know rmethod holds the Method* during calls
 904   // to the interpreter.  The args start out packed in the compiled layout.  They
 905   // need to be unpacked into the interpreter layout.  This will almost always
 906   // require some stack space.  We grow the current (compiled) stack, then repack
 907   // the args.  We  finally end in a jump to the generic interpreter entry point.
 908   // On exit from the interpreter, the interpreter will restore our SP (lest the
 909   // compiled code, which relys solely on SP and not FP, get sick).
 910 
 911   {
 912     __ block_comment(&quot;c2i_unverified_entry {&quot;);
 913     __ load_klass(rscratch1, receiver);
 914     __ ldr(tmp, Address(holder, CompiledICHolder::holder_klass_offset()));
 915     __ cmp(rscratch1, tmp);
 916     __ ldr(rmethod, Address(holder, CompiledICHolder::holder_metadata_offset()));
 917     __ br(Assembler::EQ, ok);
 918     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 919 
 920     __ bind(ok);
 921     // Method might have been compiled since the call site was patched to
 922     // interpreted; if that is the case treat it as a miss so we can get
 923     // the call site corrected.
 924     __ ldr(rscratch1, Address(rmethod, in_bytes(Method::code_offset())));
 925     __ cbz(rscratch1, skip_fixup);
 926     __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 927     __ block_comment(&quot;} c2i_unverified_entry&quot;);
 928   }
 929 }
 930 
 931 
 932 // ---------------------------------------------------------------
 933 AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,
 934                                                             int comp_args_on_stack,
 935                                                             const GrowableArray&lt;SigEntry&gt;* sig,
 936                                                             const VMRegPair* regs,
 937                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc,
 938                                                             const VMRegPair* regs_cc,
 939                                                             const GrowableArray&lt;SigEntry&gt;* sig_cc_ro,
 940                                                             const VMRegPair* regs_cc_ro,
 941                                                             AdapterFingerPrint* fingerprint,
 942                                                             AdapterBlob*&amp; new_adapter) {
 943 
 944   address i2c_entry = __ pc();
 945   gen_i2c_adapter(masm, comp_args_on_stack, sig, regs);
 946 
 947   address c2i_unverified_entry = __ pc();
 948   Label skip_fixup;
 949 
 950   gen_inline_cache_check(masm, skip_fixup);
 951 
 952   OopMapSet* oop_maps = new OopMapSet();
 953   int frame_complete = CodeOffsets::frame_never_safe;
 954   int frame_size_in_words = 0;
 955 
 956   // Scalarized c2i adapter with non-scalarized receiver (i.e., don&#39;t pack receiver)
 957   address c2i_value_ro_entry = __ pc();
 958   if (regs_cc != regs_cc_ro) {
 959     Label unused;
 960     gen_c2i_adapter(masm, sig_cc_ro, regs_cc_ro, skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);
 961     skip_fixup = unused;
 962   }
 963 
 964   // Scalarized c2i adapter
 965   address c2i_entry = __ pc();
 966 
 967   // Class initialization barrier for static methods
 968   address c2i_no_clinit_check_entry = NULL;
 969 
 970   if (VM_Version::supports_fast_class_init_checks()) {
 971     Label L_skip_barrier;
 972     { // Bypass the barrier for non-static methods
 973         Register flags  = rscratch1;
 974       __ ldrw(flags, Address(rmethod, Method::access_flags_offset()));
 975       __ tst(flags, JVM_ACC_STATIC);
 976       __ br(Assembler::NE, L_skip_barrier); // non-static
 977     }
 978 
 979     Register klass = rscratch1;
 980     __ load_method_holder(klass, rmethod);
 981     // We pass rthread to this function on x86
 982     __ clinit_barrier(klass, rscratch2, &amp;L_skip_barrier /*L_fast_path*/);
 983 
 984     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
 985 
 986     __ bind(L_skip_barrier);
 987     c2i_no_clinit_check_entry = __ pc();
 988   }
 989 
 990   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 991   bs-&gt;c2i_entry_barrier(masm);
 992 
 993   gen_c2i_adapter(masm, total_args_passed, comp_args_on_stack, sig_bt, regs, skip_fixup);
 994 
 995   address c2i_unverified_value_entry = c2i_unverified_entry;
 996 
 997  // Non-scalarized c2i adapter
 998   address c2i_value_entry = c2i_entry;
 999   if (regs != regs_cc) {
1000     Label value_entry_skip_fixup;
1001     c2i_unverified_value_entry = __ pc();
1002     gen_inline_cache_check(masm, value_entry_skip_fixup);
1003 
1004     c2i_value_entry = __ pc();
1005     Label unused;
1006     gen_c2i_adapter(masm, sig, regs, value_entry_skip_fixup, i2c_entry, oop_maps, frame_complete, frame_size_in_words, false);
1007   }
1008 
1009   __ flush();
1010 
1011   // The c2i adapter might safepoint and trigger a GC. The caller must make sure that
1012   // the GC knows about the location of oop argument locations passed to the c2i adapter.
1013 
1014   bool caller_must_gc_arguments = (regs != regs_cc);
1015   new_adapter = AdapterBlob::create(masm-&gt;code(), frame_complete, frame_size_in_words + 10, oop_maps, caller_must_gc_arguments);
1016 
1017   return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry, c2i_unverified_entry, c2i_unverified_value_entry, c2i_no_clinit_check_entry);
1018 }
1019 
1020 int SharedRuntime::c_calling_convention(const BasicType *sig_bt,
1021                                          VMRegPair *regs,
1022                                          VMRegPair *regs2,
1023                                          int total_args_passed) {
1024   assert(regs2 == NULL, &quot;not needed on AArch64&quot;);
1025 
1026 // We return the amount of VMRegImpl stack slots we need to reserve for all
1027 // the arguments NOT counting out_preserve_stack_slots.
1028 
1029     static const Register INT_ArgReg[Argument::n_int_register_parameters_c] = {
1030       c_rarg0, c_rarg1, c_rarg2, c_rarg3, c_rarg4, c_rarg5,  c_rarg6,  c_rarg7
1031     };
1032     static const FloatRegister FP_ArgReg[Argument::n_float_register_parameters_c] = {
1033       c_farg0, c_farg1, c_farg2, c_farg3,
1034       c_farg4, c_farg5, c_farg6, c_farg7
1035     };
1036 
1037     uint int_args = 0;
1038     uint fp_args = 0;
1039     uint stk_args = 0; // inc by 2 each time
1040 
1041     for (int i = 0; i &lt; total_args_passed; i++) {
1042       switch (sig_bt[i]) {
1043       case T_BOOLEAN:
1044       case T_CHAR:
1045       case T_BYTE:
1046       case T_SHORT:
1047       case T_INT:
1048         if (int_args &lt; Argument::n_int_register_parameters_c) {
1049           regs[i].set1(INT_ArgReg[int_args++]-&gt;as_VMReg());
1050         } else {
1051           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1052           stk_args += 2;
1053         }
1054         break;
1055       case T_LONG:
1056         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1057         // fall through
1058       case T_OBJECT:
1059       case T_ARRAY:
1060       case T_VALUETYPE:
1061       case T_ADDRESS:
1062       case T_METADATA:
1063         if (int_args &lt; Argument::n_int_register_parameters_c) {
1064           regs[i].set2(INT_ArgReg[int_args++]-&gt;as_VMReg());
1065         } else {
1066           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1067           stk_args += 2;
1068         }
1069         break;
1070       case T_FLOAT:
1071         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1072           regs[i].set1(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1073         } else {
1074           regs[i].set1(VMRegImpl::stack2reg(stk_args));
1075           stk_args += 2;
1076         }
1077         break;
1078       case T_DOUBLE:
1079         assert((i + 1) &lt; total_args_passed &amp;&amp; sig_bt[i + 1] == T_VOID, &quot;expecting half&quot;);
1080         if (fp_args &lt; Argument::n_float_register_parameters_c) {
1081           regs[i].set2(FP_ArgReg[fp_args++]-&gt;as_VMReg());
1082         } else {
1083           regs[i].set2(VMRegImpl::stack2reg(stk_args));
1084           stk_args += 2;
1085         }
1086         break;
1087       case T_VOID: // Halves of longs and doubles
1088         assert(i != 0 &amp;&amp; (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), &quot;expecting half&quot;);
1089         regs[i].set_bad();
1090         break;
1091       default:
1092         ShouldNotReachHere();
1093         break;
1094       }
1095     }
1096 
1097   return stk_args;
1098 }
1099 
1100 // On 64 bit we will store integer like items to the stack as
1101 // 64 bits items (sparc abi) even though java would only store
1102 // 32bits for a parameter. On 32bit it will simply be 32 bits
1103 // So this routine will do 32-&gt;32 on 32bit and 32-&gt;64 on 64bit
1104 static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1105   if (src.first()-&gt;is_stack()) {
1106     if (dst.first()-&gt;is_stack()) {
1107       // stack to stack
1108       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
1109       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
1110     } else {
1111       // stack to reg
1112       __ ldrsw(dst.first()-&gt;as_Register(), Address(rfp, reg2offset_in(src.first())));
1113     }
1114   } else if (dst.first()-&gt;is_stack()) {
1115     // reg to stack
1116     // Do we really have to sign extend???
1117     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1118     __ str(src.first()-&gt;as_Register(), Address(sp, reg2offset_out(dst.first())));
1119   } else {
1120     if (dst.first() != src.first()) {
1121       __ sxtw(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1122     }
1123   }
1124 }
1125 
1126 // An oop arg. Must pass a handle not the oop itself
1127 static void object_move(MacroAssembler* masm,
1128                         OopMap* map,
1129                         int oop_handle_offset,
1130                         int framesize_in_slots,
1131                         VMRegPair src,
1132                         VMRegPair dst,
1133                         bool is_receiver,
1134                         int* receiver_offset) {
1135 
1136   // must pass a handle. First figure out the location we use as a handle
1137 
1138   Register rHandle = dst.first()-&gt;is_stack() ? rscratch2 : dst.first()-&gt;as_Register();
1139 
1140   // See if oop is NULL if it is we need no handle
1141 
1142   if (src.first()-&gt;is_stack()) {
1143 
1144     // Oop is already on the stack as an argument
1145     int offset_in_older_frame = src.first()-&gt;reg2stack() + SharedRuntime::out_preserve_stack_slots();
1146     map-&gt;set_oop(VMRegImpl::stack2reg(offset_in_older_frame + framesize_in_slots));
1147     if (is_receiver) {
1148       *receiver_offset = (offset_in_older_frame + framesize_in_slots) * VMRegImpl::stack_slot_size;
1149     }
1150 
1151     __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
1152     __ lea(rHandle, Address(rfp, reg2offset_in(src.first())));
1153     // conditionally move a NULL
1154     __ cmp(rscratch1, zr);
1155     __ csel(rHandle, zr, rHandle, Assembler::EQ);
1156   } else {
1157 
1158     // Oop is in an a register we must store it to the space we reserve
1159     // on the stack for oop_handles and pass a handle if oop is non-NULL
1160 
1161     const Register rOop = src.first()-&gt;as_Register();
1162     int oop_slot;
1163     if (rOop == j_rarg0)
1164       oop_slot = 0;
1165     else if (rOop == j_rarg1)
1166       oop_slot = 1;
1167     else if (rOop == j_rarg2)
1168       oop_slot = 2;
1169     else if (rOop == j_rarg3)
1170       oop_slot = 3;
1171     else if (rOop == j_rarg4)
1172       oop_slot = 4;
1173     else if (rOop == j_rarg5)
1174       oop_slot = 5;
1175     else if (rOop == j_rarg6)
1176       oop_slot = 6;
1177     else {
1178       assert(rOop == j_rarg7, &quot;wrong register&quot;);
1179       oop_slot = 7;
1180     }
1181 
1182     oop_slot = oop_slot * VMRegImpl::slots_per_word + oop_handle_offset;
1183     int offset = oop_slot*VMRegImpl::stack_slot_size;
1184 
1185     map-&gt;set_oop(VMRegImpl::stack2reg(oop_slot));
1186     // Store oop in handle area, may be NULL
1187     __ str(rOop, Address(sp, offset));
1188     if (is_receiver) {
1189       *receiver_offset = offset;
1190     }
1191 
1192     __ cmp(rOop, zr);
1193     __ lea(rHandle, Address(sp, offset));
1194     // conditionally move a NULL
1195     __ csel(rHandle, zr, rHandle, Assembler::EQ);
1196   }
1197 
1198   // If arg is on the stack then place it otherwise it is already in correct reg.
1199   if (dst.first()-&gt;is_stack()) {
1200     __ str(rHandle, Address(sp, reg2offset_out(dst.first())));
1201   }
1202 }
1203 
1204 // A float arg may have to do float reg int reg conversion
1205 static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1206   assert(src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack() ||
1207          src.first()-&gt;is_reg() &amp;&amp; dst.first()-&gt;is_reg(), &quot;Unexpected error&quot;);
1208   if (src.first()-&gt;is_stack()) {
1209     if (dst.first()-&gt;is_stack()) {
1210       __ ldrw(rscratch1, Address(rfp, reg2offset_in(src.first())));
1211       __ strw(rscratch1, Address(sp, reg2offset_out(dst.first())));
1212     } else {
1213       ShouldNotReachHere();
1214     }
1215   } else if (src.first() != dst.first()) {
1216     if (src.is_single_phys_reg() &amp;&amp; dst.is_single_phys_reg())
1217       __ fmovs(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
1218     else
1219       ShouldNotReachHere();
1220   }
1221 }
1222 
1223 // A long move
1224 static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1225   if (src.first()-&gt;is_stack()) {
1226     if (dst.first()-&gt;is_stack()) {
1227       // stack to stack
1228       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
1229       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
1230     } else {
1231       // stack to reg
1232       __ ldr(dst.first()-&gt;as_Register(), Address(rfp, reg2offset_in(src.first())));
1233     }
1234   } else if (dst.first()-&gt;is_stack()) {
1235     // reg to stack
1236     // Do we really have to sign extend???
1237     // __ movslq(src.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1238     __ str(src.first()-&gt;as_Register(), Address(sp, reg2offset_out(dst.first())));
1239   } else {
1240     if (dst.first() != src.first()) {
1241       __ mov(dst.first()-&gt;as_Register(), src.first()-&gt;as_Register());
1242     }
1243   }
1244 }
1245 
1246 
1247 // A double move
1248 static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {
1249   assert(src.first()-&gt;is_stack() &amp;&amp; dst.first()-&gt;is_stack() ||
1250          src.first()-&gt;is_reg() &amp;&amp; dst.first()-&gt;is_reg(), &quot;Unexpected error&quot;);
1251   if (src.first()-&gt;is_stack()) {
1252     if (dst.first()-&gt;is_stack()) {
1253       __ ldr(rscratch1, Address(rfp, reg2offset_in(src.first())));
1254       __ str(rscratch1, Address(sp, reg2offset_out(dst.first())));
1255     } else {
1256       ShouldNotReachHere();
1257     }
1258   } else if (src.first() != dst.first()) {
1259     if (src.is_single_phys_reg() &amp;&amp; dst.is_single_phys_reg())
1260       __ fmovd(dst.first()-&gt;as_FloatRegister(), src.first()-&gt;as_FloatRegister());
1261     else
1262       ShouldNotReachHere();
1263   }
1264 }
1265 
1266 
1267 void SharedRuntime::save_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1268   // We always ignore the frame_slots arg and just use the space just below frame pointer
1269   // which by this time is free to use
1270   switch (ret_type) {
1271   case T_FLOAT:
1272     __ strs(v0, Address(rfp, -wordSize));
1273     break;
1274   case T_DOUBLE:
1275     __ strd(v0, Address(rfp, -wordSize));
1276     break;
1277   case T_VOID:  break;
1278   default: {
1279     __ str(r0, Address(rfp, -wordSize));
1280     }
1281   }
1282 }
1283 
1284 void SharedRuntime::restore_native_result(MacroAssembler *masm, BasicType ret_type, int frame_slots) {
1285   // We always ignore the frame_slots arg and just use the space just below frame pointer
1286   // which by this time is free to use
1287   switch (ret_type) {
1288   case T_FLOAT:
1289     __ ldrs(v0, Address(rfp, -wordSize));
1290     break;
1291   case T_DOUBLE:
1292     __ ldrd(v0, Address(rfp, -wordSize));
1293     break;
1294   case T_VOID:  break;
1295   default: {
1296     __ ldr(r0, Address(rfp, -wordSize));
1297     }
1298   }
1299 }
1300 static void save_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1301   RegSet x;
1302   for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1303     if (args[i].first()-&gt;is_Register()) {
1304       x = x + args[i].first()-&gt;as_Register();
1305     } else if (args[i].first()-&gt;is_FloatRegister()) {
1306       __ strd(args[i].first()-&gt;as_FloatRegister(), Address(__ pre(sp, -2 * wordSize)));
1307     }
1308   }
1309   __ push(x, sp);
1310 }
1311 
1312 static void restore_args(MacroAssembler *masm, int arg_count, int first_arg, VMRegPair *args) {
1313   RegSet x;
1314   for ( int i = first_arg ; i &lt; arg_count ; i++ ) {
1315     if (args[i].first()-&gt;is_Register()) {
1316       x = x + args[i].first()-&gt;as_Register();
1317     } else {
1318       ;
1319     }
1320   }
1321   __ pop(x, sp);
1322   for ( int i = arg_count - 1 ; i &gt;= first_arg ; i-- ) {
1323     if (args[i].first()-&gt;is_Register()) {
1324       ;
1325     } else if (args[i].first()-&gt;is_FloatRegister()) {
1326       __ ldrd(args[i].first()-&gt;as_FloatRegister(), Address(__ post(sp, 2 * wordSize)));
1327     }
1328   }
1329 }
1330 
1331 
1332 // Check GCLocker::needs_gc and enter the runtime if it&#39;s true.  This
1333 // keeps a new JNI critical region from starting until a GC has been
1334 // forced.  Save down any oops in registers and describe them in an
1335 // OopMap.
1336 static void check_needs_gc_for_critical_native(MacroAssembler* masm,
1337                                                int stack_slots,
1338                                                int total_c_args,
1339                                                int total_in_args,
1340                                                int arg_save_area,
1341                                                OopMapSet* oop_maps,
1342                                                VMRegPair* in_regs,
1343                                                BasicType* in_sig_bt) { Unimplemented(); }
1344 
1345 // Unpack an array argument into a pointer to the body and the length
1346 // if the array is non-null, otherwise pass 0 for both.
1347 static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) { Unimplemented(); }
1348 
1349 
1350 class ComputeMoveOrder: public StackObj {
1351   class MoveOperation: public ResourceObj {
1352     friend class ComputeMoveOrder;
1353    private:
1354     VMRegPair        _src;
1355     VMRegPair        _dst;
1356     int              _src_index;
1357     int              _dst_index;
1358     bool             _processed;
1359     MoveOperation*  _next;
1360     MoveOperation*  _prev;
1361 
1362     static int get_id(VMRegPair r) { Unimplemented(); return 0; }
1363 
1364    public:
1365     MoveOperation(int src_index, VMRegPair src, int dst_index, VMRegPair dst):
1366       _src(src)
1367     , _dst(dst)
1368     , _src_index(src_index)
1369     , _dst_index(dst_index)
1370     , _processed(false)
1371     , _next(NULL)
1372     , _prev(NULL) { Unimplemented(); }
1373 
1374     VMRegPair src() const              { Unimplemented(); return _src; }
1375     int src_id() const                 { Unimplemented(); return 0; }
1376     int src_index() const              { Unimplemented(); return 0; }
1377     VMRegPair dst() const              { Unimplemented(); return _src; }
1378     void set_dst(int i, VMRegPair dst) { Unimplemented(); }
1379     int dst_index() const              { Unimplemented(); return 0; }
1380     int dst_id() const                 { Unimplemented(); return 0; }
1381     MoveOperation* next() const        { Unimplemented(); return 0; }
1382     MoveOperation* prev() const        { Unimplemented(); return 0; }
1383     void set_processed()               { Unimplemented(); }
1384     bool is_processed() const          { Unimplemented(); return 0; }
1385 
1386     // insert
1387     void break_cycle(VMRegPair temp_register) { Unimplemented(); }
1388 
1389     void link(GrowableArray&lt;MoveOperation*&gt;&amp; killer) { Unimplemented(); }
1390   };
1391 
1392  private:
1393   GrowableArray&lt;MoveOperation*&gt; edges;
1394 
1395  public:
1396   ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,
1397                     BasicType* in_sig_bt, GrowableArray&lt;int&gt;&amp; arg_order, VMRegPair tmp_vmreg) { Unimplemented(); }
1398 
1399   // Collected all the move operations
1400   void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) { Unimplemented(); }
1401 
1402   // Walk the edges breaking cycles between moves.  The result list
1403   // can be walked in order to produce the proper set of loads
1404   GrowableArray&lt;MoveOperation*&gt;* get_store_order(VMRegPair temp_register) { Unimplemented(); return 0; }
1405 };
1406 
1407 
1408 static void rt_call(MacroAssembler* masm, address dest, int gpargs, int fpargs, int type) {
1409   CodeBlob *cb = CodeCache::find_blob(dest);
1410   if (cb) {
1411     __ far_call(RuntimeAddress(dest));
1412   } else {
1413     assert((unsigned)gpargs &lt; 256, &quot;eek!&quot;);
1414     assert((unsigned)fpargs &lt; 32, &quot;eek!&quot;);
1415     __ lea(rscratch1, RuntimeAddress(dest));
1416     __ blr(rscratch1);
1417     __ maybe_isb();
1418   }
1419 }
1420 
1421 static void verify_oop_args(MacroAssembler* masm,
1422                             const methodHandle&amp; method,
1423                             const BasicType* sig_bt,
1424                             const VMRegPair* regs) {
1425   Register temp_reg = r19;  // not part of any compiled calling seq
1426   if (VerifyOops) {
1427     for (int i = 0; i &lt; method-&gt;size_of_parameters(); i++) {
1428       if (sig_bt[i] == T_OBJECT ||
1429           sig_bt[i] == T_ARRAY) {
1430         VMReg r = regs[i].first();
1431         assert(r-&gt;is_valid(), &quot;bad oop arg&quot;);
1432         if (r-&gt;is_stack()) {
1433           __ ldr(temp_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1434           __ verify_oop(temp_reg);
1435         } else {
1436           __ verify_oop(r-&gt;as_Register());
1437         }
1438       }
1439     }
1440   }
1441 }
1442 
1443 static void gen_special_dispatch(MacroAssembler* masm,
1444                                  const methodHandle&amp; method,
1445                                  const BasicType* sig_bt,
1446                                  const VMRegPair* regs) {
1447   verify_oop_args(masm, method, sig_bt, regs);
1448   vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1449 
1450   // Now write the args into the outgoing interpreter space
1451   bool     has_receiver   = false;
1452   Register receiver_reg   = noreg;
1453   int      member_arg_pos = -1;
1454   Register member_reg     = noreg;
1455   int      ref_kind       = MethodHandles::signature_polymorphic_intrinsic_ref_kind(iid);
1456   if (ref_kind != 0) {
1457     member_arg_pos = method-&gt;size_of_parameters() - 1;  // trailing MemberName argument
1458     member_reg = r19;  // known to be free at this point
1459     has_receiver = MethodHandles::ref_kind_has_receiver(ref_kind);
1460   } else if (iid == vmIntrinsics::_invokeBasic) {
1461     has_receiver = true;
1462   } else {
1463     fatal(&quot;unexpected intrinsic id %d&quot;, iid);
1464   }
1465 
1466   if (member_reg != noreg) {
1467     // Load the member_arg into register, if necessary.
1468     SharedRuntime::check_member_name_argument_is_last_argument(method, sig_bt, regs);
1469     VMReg r = regs[member_arg_pos].first();
1470     if (r-&gt;is_stack()) {
1471       __ ldr(member_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1472     } else {
1473       // no data motion is needed
1474       member_reg = r-&gt;as_Register();
1475     }
1476   }
1477 
1478   if (has_receiver) {
1479     // Make sure the receiver is loaded into a register.
1480     assert(method-&gt;size_of_parameters() &gt; 0, &quot;oob&quot;);
1481     assert(sig_bt[0] == T_OBJECT, &quot;receiver argument must be an object&quot;);
1482     VMReg r = regs[0].first();
1483     assert(r-&gt;is_valid(), &quot;bad receiver arg&quot;);
1484     if (r-&gt;is_stack()) {
1485       // Porting note:  This assumes that compiled calling conventions always
1486       // pass the receiver oop in a register.  If this is not true on some
1487       // platform, pick a temp and load the receiver from stack.
1488       fatal(&quot;receiver always in a register&quot;);
1489       receiver_reg = r2;  // known to be free at this point
1490       __ ldr(receiver_reg, Address(sp, r-&gt;reg2stack() * VMRegImpl::stack_slot_size));
1491     } else {
1492       // no data motion is needed
1493       receiver_reg = r-&gt;as_Register();
1494     }
1495   }
1496 
1497   // Figure out which address we are really jumping to:
1498   MethodHandles::generate_method_handle_dispatch(masm, iid,
1499                                                  receiver_reg, member_reg, /*for_compiler_entry:*/ true);
1500 }
1501 
1502 // ---------------------------------------------------------------------------
1503 // Generate a native wrapper for a given method.  The method takes arguments
1504 // in the Java compiled code convention, marshals them to the native
1505 // convention (handlizes oops, etc), transitions to native, makes the call,
1506 // returns to java state (possibly blocking), unhandlizes any result and
1507 // returns.
1508 //
1509 // Critical native functions are a shorthand for the use of
1510 // GetPrimtiveArrayCritical and disallow the use of any other JNI
1511 // functions.  The wrapper is expected to unpack the arguments before
1512 // passing them to the callee and perform checks before and after the
1513 // native call to ensure that they GCLocker
1514 // lock_critical/unlock_critical semantics are followed.  Some other
1515 // parts of JNI setup are skipped like the tear down of the JNI handle
1516 // block and the check for pending exceptions it&#39;s impossible for them
1517 // to be thrown.
1518 //
1519 // They are roughly structured like this:
1520 //    if (GCLocker::needs_gc())
1521 //      SharedRuntime::block_for_jni_critical();
1522 //    tranistion to thread_in_native
1523 //    unpack arrray arguments and call native entry point
1524 //    check for safepoint in progress
1525 //    check if any thread suspend flags are set
1526 //      call into JVM and possible unlock the JNI critical
1527 //      if a GC was suppressed while in the critical native.
1528 //    transition back to thread_in_Java
1529 //    return to caller
1530 //
1531 nmethod* SharedRuntime::generate_native_wrapper(MacroAssembler* masm,
1532                                                 const methodHandle&amp; method,
1533                                                 int compile_id,
1534                                                 BasicType* in_sig_bt,
1535                                                 VMRegPair* in_regs,
1536                                                 BasicType ret_type,
1537                                                 address critical_entry) {
1538   if (method-&gt;is_method_handle_intrinsic()) {
1539     vmIntrinsics::ID iid = method-&gt;intrinsic_id();
1540     intptr_t start = (intptr_t)__ pc();
1541     int vep_offset = ((intptr_t)__ pc()) - start;
1542 
1543     // First instruction must be a nop as it may need to be patched on deoptimisation
1544     __ nop();
1545     gen_special_dispatch(masm,
1546                          method,
1547                          in_sig_bt,
1548                          in_regs);
1549     int frame_complete = ((intptr_t)__ pc()) - start;  // not complete, period
1550     __ flush();
1551     int stack_slots = SharedRuntime::out_preserve_stack_slots();  // no out slots at all, actually
1552     return nmethod::new_native_nmethod(method,
1553                                        compile_id,
1554                                        masm-&gt;code(),
1555                                        vep_offset,
1556                                        frame_complete,
1557                                        stack_slots / VMRegImpl::slots_per_word,
1558                                        in_ByteSize(-1),
1559                                        in_ByteSize(-1),
1560                                        (OopMapSet*)NULL);
1561   }
1562   bool is_critical_native = true;
1563   address native_func = critical_entry;
1564   if (native_func == NULL) {
1565     native_func = method-&gt;native_function();
1566     is_critical_native = false;
1567   }
1568   assert(native_func != NULL, &quot;must have function&quot;);
1569 
1570   // An OopMap for lock (and class if static)
1571   OopMapSet *oop_maps = new OopMapSet();
1572   intptr_t start = (intptr_t)__ pc();
1573 
1574   // We have received a description of where all the java arg are located
1575   // on entry to the wrapper. We need to convert these args to where
1576   // the jni function will expect them. To figure out where they go
1577   // we convert the java signature to a C signature by inserting
1578   // the hidden arguments as arg[0] and possibly arg[1] (static method)
1579 
1580   const int total_in_args = method-&gt;size_of_parameters();
1581   int total_c_args = total_in_args;
1582   if (!is_critical_native) {
1583     total_c_args += 1;
1584     if (method-&gt;is_static()) {
1585       total_c_args++;
1586     }
1587   } else {
1588     for (int i = 0; i &lt; total_in_args; i++) {
1589       if (in_sig_bt[i] == T_ARRAY) {
1590         total_c_args++;
1591       }
1592     }
1593   }
1594 
1595   BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);
1596   VMRegPair* out_regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);
1597   BasicType* in_elem_bt = NULL;
1598 
1599   int argc = 0;
1600   if (!is_critical_native) {
1601     out_sig_bt[argc++] = T_ADDRESS;
1602     if (method-&gt;is_static()) {
1603       out_sig_bt[argc++] = T_OBJECT;
1604     }
1605 
1606     for (int i = 0; i &lt; total_in_args ; i++ ) {
1607       out_sig_bt[argc++] = in_sig_bt[i];
1608     }
1609   } else {
1610     in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);
1611     SignatureStream ss(method-&gt;signature());
1612     for (int i = 0; i &lt; total_in_args ; i++ ) {
1613       if (in_sig_bt[i] == T_ARRAY) {
1614         // Arrays are passed as int, elem* pair
1615         out_sig_bt[argc++] = T_INT;
1616         out_sig_bt[argc++] = T_ADDRESS;
1617         ss.skip_array_prefix(1);  // skip one &#39;[&#39;
1618         assert(ss.is_primitive(), &quot;primitive type expected&quot;);
1619         in_elem_bt[i] = ss.type();
1620       } else {
1621         out_sig_bt[argc++] = in_sig_bt[i];
1622         in_elem_bt[i] = T_VOID;
1623       }
1624       if (in_sig_bt[i] != T_VOID) {
1625         assert(in_sig_bt[i] == ss.type() ||
1626                in_sig_bt[i] == T_ARRAY, &quot;must match&quot;);
1627         ss.next();
1628       }
1629     }
1630   }
1631 
1632   // Now figure out where the args must be stored and how much stack space
1633   // they require.
1634   int out_arg_slots;
1635   out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);
1636 
1637   // Compute framesize for the wrapper.  We need to handlize all oops in
1638   // incoming registers
1639 
1640   // Calculate the total number of stack slots we will need.
1641 
1642   // First count the abi requirement plus all of the outgoing args
1643   int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;
1644 
1645   // Now the space for the inbound oop handle area
1646   int total_save_slots = 8 * VMRegImpl::slots_per_word;  // 8 arguments passed in registers
1647   if (is_critical_native) {
1648     // Critical natives may have to call out so they need a save area
1649     // for register arguments.
1650     int double_slots = 0;
1651     int single_slots = 0;
1652     for ( int i = 0; i &lt; total_in_args; i++) {
1653       if (in_regs[i].first()-&gt;is_Register()) {
1654         const Register reg = in_regs[i].first()-&gt;as_Register();
1655         switch (in_sig_bt[i]) {
1656           case T_BOOLEAN:
1657           case T_BYTE:
1658           case T_SHORT:
1659           case T_CHAR:
1660           case T_INT:  single_slots++; break;
1661           case T_ARRAY:  // specific to LP64 (7145024)
1662           case T_LONG: double_slots++; break;
1663           default:  ShouldNotReachHere();
1664         }
1665       } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1666         ShouldNotReachHere();
1667       }
1668     }
1669     total_save_slots = double_slots * 2 + single_slots;
1670     // align the save area
1671     if (double_slots != 0) {
1672       stack_slots = align_up(stack_slots, 2);
1673     }
1674   }
1675 
1676   int oop_handle_offset = stack_slots;
1677   stack_slots += total_save_slots;
1678 
1679   // Now any space we need for handlizing a klass if static method
1680 
1681   int klass_slot_offset = 0;
1682   int klass_offset = -1;
1683   int lock_slot_offset = 0;
1684   bool is_static = false;
1685 
1686   if (method-&gt;is_static()) {
1687     klass_slot_offset = stack_slots;
1688     stack_slots += VMRegImpl::slots_per_word;
1689     klass_offset = klass_slot_offset * VMRegImpl::stack_slot_size;
1690     is_static = true;
1691   }
1692 
1693   // Plus a lock if needed
1694 
1695   if (method-&gt;is_synchronized()) {
1696     lock_slot_offset = stack_slots;
1697     stack_slots += VMRegImpl::slots_per_word;
1698   }
1699 
1700   // Now a place (+2) to save return values or temp during shuffling
1701   // + 4 for return address (which we own) and saved rfp
1702   stack_slots += 6;
1703 
1704   // Ok The space we have allocated will look like:
1705   //
1706   //
1707   // FP-&gt; |                     |
1708   //      |---------------------|
1709   //      | 2 slots for moves   |
1710   //      |---------------------|
1711   //      | lock box (if sync)  |
1712   //      |---------------------| &lt;- lock_slot_offset
1713   //      | klass (if static)   |
1714   //      |---------------------| &lt;- klass_slot_offset
1715   //      | oopHandle area      |
1716   //      |---------------------| &lt;- oop_handle_offset (8 java arg registers)
1717   //      | outbound memory     |
1718   //      | based arguments     |
1719   //      |                     |
1720   //      |---------------------|
1721   //      |                     |
1722   // SP-&gt; | out_preserved_slots |
1723   //
1724   //
1725 
1726 
1727   // Now compute actual number of stack words we need rounding to make
1728   // stack properly aligned.
1729   stack_slots = align_up(stack_slots, StackAlignmentInSlots);
1730 
1731   int stack_size = stack_slots * VMRegImpl::stack_slot_size;
1732 
1733   // First thing make an ic check to see if we should even be here
1734 
1735   // We are free to use all registers as temps without saving them and
1736   // restoring them except rfp. rfp is the only callee save register
1737   // as far as the interpreter and the compiler(s) are concerned.
1738 
1739 
1740   const Register ic_reg = rscratch2;
1741   const Register receiver = j_rarg0;
1742 
1743   Label hit;
1744   Label exception_pending;
1745 
1746   assert_different_registers(ic_reg, receiver, rscratch1);
1747   __ verify_oop(receiver);
1748   __ cmp_klass(receiver, ic_reg, rscratch1);
1749   __ br(Assembler::EQ, hit);
1750 
1751   __ far_jump(RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1752 
1753   // Verified entry point must be aligned
1754   __ align(8);
1755 
1756   __ bind(hit);
1757 
1758   int vep_offset = ((intptr_t)__ pc()) - start;
1759 
1760   // If we have to make this method not-entrant we&#39;ll overwrite its
1761   // first instruction with a jump.  For this action to be legal we
1762   // must ensure that this first instruction is a B, BL, NOP, BKPT,
1763   // SVC, HVC, or SMC.  Make it a NOP.
1764   __ nop();
1765 
1766   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; method-&gt;needs_clinit_barrier()) {
1767     Label L_skip_barrier;
1768     __ mov_metadata(rscratch2, method-&gt;method_holder()); // InstanceKlass*
1769     __ clinit_barrier(rscratch2, rscratch1, &amp;L_skip_barrier);
1770     __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
1771 
1772     __ bind(L_skip_barrier);
1773   }
1774 
1775   // Generate stack overflow check
1776   if (UseStackBanging) {
1777     __ bang_stack_with_offset(JavaThread::stack_shadow_zone_size());
1778   } else {
1779     Unimplemented();
1780   }
1781 
1782   // Generate a new frame for the wrapper.
1783   __ enter();
1784   // -2 because return address is already present and so is saved rfp
1785   __ sub(sp, sp, stack_size - 2*wordSize);
1786 
1787   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1788   bs-&gt;nmethod_entry_barrier(masm);
1789 
1790   // Frame is now completed as far as size and linkage.
1791   int frame_complete = ((intptr_t)__ pc()) - start;
1792 
1793   // We use r20 as the oop handle for the receiver/klass
1794   // It is callee save so it survives the call to native
1795 
1796   const Register oop_handle_reg = r20;
1797 
1798   if (is_critical_native) {
1799     check_needs_gc_for_critical_native(masm, stack_slots, total_c_args, total_in_args,
1800                                        oop_handle_offset, oop_maps, in_regs, in_sig_bt);
1801   }
1802 
1803   //
1804   // We immediately shuffle the arguments so that any vm call we have to
1805   // make from here on out (sync slow path, jvmti, etc.) we will have
1806   // captured the oops from our caller and have a valid oopMap for
1807   // them.
1808 
1809   // -----------------
1810   // The Grand Shuffle
1811 
1812   // The Java calling convention is either equal (linux) or denser (win64) than the
1813   // c calling convention. However the because of the jni_env argument the c calling
1814   // convention always has at least one more (and two for static) arguments than Java.
1815   // Therefore if we move the args from java -&gt; c backwards then we will never have
1816   // a register-&gt;register conflict and we don&#39;t have to build a dependency graph
1817   // and figure out how to break any cycles.
1818   //
1819 
1820   // Record esp-based slot for receiver on stack for non-static methods
1821   int receiver_offset = -1;
1822 
1823   // This is a trick. We double the stack slots so we can claim
1824   // the oops in the caller&#39;s frame. Since we are sure to have
1825   // more args than the caller doubling is enough to make
1826   // sure we can capture all the incoming oop args from the
1827   // caller.
1828   //
1829   OopMap* map = new OopMap(stack_slots * 2, 0 /* arg_slots*/);
1830 
1831   // Mark location of rfp (someday)
1832   // map-&gt;set_callee_saved(VMRegImpl::stack2reg( stack_slots - 2), stack_slots * 2, 0, vmreg(rfp));
1833 
1834 
1835   int float_args = 0;
1836   int int_args = 0;
1837 
1838 #ifdef ASSERT
1839   bool reg_destroyed[RegisterImpl::number_of_registers];
1840   bool freg_destroyed[FloatRegisterImpl::number_of_registers];
1841   for ( int r = 0 ; r &lt; RegisterImpl::number_of_registers ; r++ ) {
1842     reg_destroyed[r] = false;
1843   }
1844   for ( int f = 0 ; f &lt; FloatRegisterImpl::number_of_registers ; f++ ) {
1845     freg_destroyed[f] = false;
1846   }
1847 
1848 #endif /* ASSERT */
1849 
1850   // This may iterate in two different directions depending on the
1851   // kind of native it is.  The reason is that for regular JNI natives
1852   // the incoming and outgoing registers are offset upwards and for
1853   // critical natives they are offset down.
1854   GrowableArray&lt;int&gt; arg_order(2 * total_in_args);
1855   VMRegPair tmp_vmreg;
1856   tmp_vmreg.set2(r19-&gt;as_VMReg());
1857 
1858   if (!is_critical_native) {
1859     for (int i = total_in_args - 1, c_arg = total_c_args - 1; i &gt;= 0; i--, c_arg--) {
1860       arg_order.push(i);
1861       arg_order.push(c_arg);
1862     }
1863   } else {
1864     // Compute a valid move order, using tmp_vmreg to break any cycles
1865     ComputeMoveOrder cmo(total_in_args, in_regs, total_c_args, out_regs, in_sig_bt, arg_order, tmp_vmreg);
1866   }
1867 
1868   int temploc = -1;
1869   for (int ai = 0; ai &lt; arg_order.length(); ai += 2) {
1870     int i = arg_order.at(ai);
1871     int c_arg = arg_order.at(ai + 1);
1872     __ block_comment(err_msg(&quot;move %d -&gt; %d&quot;, i, c_arg));
1873     if (c_arg == -1) {
1874       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
1875       // This arg needs to be moved to a temporary
1876       __ mov(tmp_vmreg.first()-&gt;as_Register(), in_regs[i].first()-&gt;as_Register());
1877       in_regs[i] = tmp_vmreg;
1878       temploc = i;
1879       continue;
1880     } else if (i == -1) {
1881       assert(is_critical_native, &quot;should only be required for critical natives&quot;);
1882       // Read from the temporary location
1883       assert(temploc != -1, &quot;must be valid&quot;);
1884       i = temploc;
1885       temploc = -1;
1886     }
1887 #ifdef ASSERT
1888     if (in_regs[i].first()-&gt;is_Register()) {
1889       assert(!reg_destroyed[in_regs[i].first()-&gt;as_Register()-&gt;encoding()], &quot;destroyed reg!&quot;);
1890     } else if (in_regs[i].first()-&gt;is_FloatRegister()) {
1891       assert(!freg_destroyed[in_regs[i].first()-&gt;as_FloatRegister()-&gt;encoding()], &quot;destroyed reg!&quot;);
1892     }
1893     if (out_regs[c_arg].first()-&gt;is_Register()) {
1894       reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1895     } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1896       freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1897     }
1898 #endif /* ASSERT */
1899     switch (in_sig_bt[i]) {
1900       case T_ARRAY:
1901         if (is_critical_native) {
1902           unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);
1903           c_arg++;
1904 #ifdef ASSERT
1905           if (out_regs[c_arg].first()-&gt;is_Register()) {
1906             reg_destroyed[out_regs[c_arg].first()-&gt;as_Register()-&gt;encoding()] = true;
1907           } else if (out_regs[c_arg].first()-&gt;is_FloatRegister()) {
1908             freg_destroyed[out_regs[c_arg].first()-&gt;as_FloatRegister()-&gt;encoding()] = true;
1909           }
1910 #endif
1911           int_args++;
1912           break;
1913         }
1914       case T_VALUETYPE:
1915       case T_OBJECT:
1916         assert(!is_critical_native, &quot;no oop arguments&quot;);
1917         object_move(masm, map, oop_handle_offset, stack_slots, in_regs[i], out_regs[c_arg],
1918                     ((i == 0) &amp;&amp; (!is_static)),
1919                     &amp;receiver_offset);
1920         int_args++;
1921         break;
1922       case T_VOID:
1923         break;
1924 
1925       case T_FLOAT:
1926         float_move(masm, in_regs[i], out_regs[c_arg]);
1927         float_args++;
1928         break;
1929 
1930       case T_DOUBLE:
1931         assert( i + 1 &lt; total_in_args &amp;&amp;
1932                 in_sig_bt[i + 1] == T_VOID &amp;&amp;
1933                 out_sig_bt[c_arg+1] == T_VOID, &quot;bad arg list&quot;);
1934         double_move(masm, in_regs[i], out_regs[c_arg]);
1935         float_args++;
1936         break;
1937 
1938       case T_LONG :
1939         long_move(masm, in_regs[i], out_regs[c_arg]);
1940         int_args++;
1941         break;
1942 
1943       case T_ADDRESS: assert(false, &quot;found T_ADDRESS in java args&quot;);
1944 
1945       default:
1946         move32_64(masm, in_regs[i], out_regs[c_arg]);
1947         int_args++;
1948     }
1949   }
1950 
1951   // point c_arg at the first arg that is already loaded in case we
1952   // need to spill before we call out
1953   int c_arg = total_c_args - total_in_args;
1954 
1955   // Pre-load a static method&#39;s oop into c_rarg1.
1956   if (method-&gt;is_static() &amp;&amp; !is_critical_native) {
1957 
1958     //  load oop into a register
1959     __ movoop(c_rarg1,
1960               JNIHandles::make_local(method-&gt;method_holder()-&gt;java_mirror()),
1961               /*immediate*/true);
1962 
1963     // Now handlize the static class mirror it&#39;s known not-null.
1964     __ str(c_rarg1, Address(sp, klass_offset));
1965     map-&gt;set_oop(VMRegImpl::stack2reg(klass_slot_offset));
1966 
1967     // Now get the handle
1968     __ lea(c_rarg1, Address(sp, klass_offset));
1969     // and protect the arg if we must spill
1970     c_arg--;
1971   }
1972 
1973   // Change state to native (we save the return address in the thread, since it might not
1974   // be pushed on the stack when we do a stack traversal).
1975   // We use the same pc/oopMap repeatedly when we call out
1976 
1977   Label native_return;
1978   __ set_last_Java_frame(sp, noreg, native_return, rscratch1);
1979 
1980   Label dtrace_method_entry, dtrace_method_entry_done;
1981   {
1982     unsigned long offset;
1983     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
1984     __ ldrb(rscratch1, Address(rscratch1, offset));
1985     __ cbnzw(rscratch1, dtrace_method_entry);
1986     __ bind(dtrace_method_entry_done);
1987   }
1988 
1989   // RedefineClasses() tracing support for obsolete method entry
1990   if (log_is_enabled(Trace, redefine, class, obsolete)) {
1991     // protect the args we&#39;ve loaded
1992     save_args(masm, total_c_args, c_arg, out_regs);
1993     __ mov_metadata(c_rarg1, method());
1994     __ call_VM_leaf(
1995       CAST_FROM_FN_PTR(address, SharedRuntime::rc_trace_method_entry),
1996       rthread, c_rarg1);
1997     restore_args(masm, total_c_args, c_arg, out_regs);
1998   }
1999 
2000   // Lock a synchronized method
2001 
2002   // Register definitions used by locking and unlocking
2003 
2004   const Register swap_reg = r0;
2005   const Register obj_reg  = r19;  // Will contain the oop
2006   const Register lock_reg = r13;  // Address of compiler lock object (BasicLock)
2007   const Register old_hdr  = r13;  // value of old header at unlock time
2008   const Register tmp = lr;
2009 
2010   Label slow_path_lock;
2011   Label lock_done;
2012 
2013   if (method-&gt;is_synchronized()) {
2014     assert(!is_critical_native, &quot;unhandled&quot;);
2015 
2016     const int mark_word_offset = BasicLock::displaced_header_offset_in_bytes();
2017 
2018     // Get the handle (the 2nd argument)
2019     __ mov(oop_handle_reg, c_rarg1);
2020 
2021     // Get address of the box
2022 
2023     __ lea(lock_reg, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2024 
2025     // Load the oop from the handle
2026     __ ldr(obj_reg, Address(oop_handle_reg, 0));
2027 
2028     __ resolve(IS_NOT_NULL, obj_reg);
2029 
2030     if (UseBiasedLocking) {
2031       __ biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp, false, lock_done, &amp;slow_path_lock);
2032     }
2033 
2034     // Load (object-&gt;mark() | 1) into swap_reg %r0
2035     __ ldr(rscratch1, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
2036     __ orr(swap_reg, rscratch1, 1);
2037 
2038     // Save (object-&gt;mark() | 1) into BasicLock&#39;s displaced header
2039     __ str(swap_reg, Address(lock_reg, mark_word_offset));
2040 
2041     // src -&gt; dest iff dest == r0 else r0 &lt;- dest
2042     { Label here;
2043       __ cmpxchg_obj_header(r0, lock_reg, obj_reg, rscratch1, lock_done, /*fallthrough*/NULL);
2044     }
2045 
2046     // Hmm should this move to the slow path code area???
2047 
2048     // Test if the oopMark is an obvious stack pointer, i.e.,
2049     //  1) (mark &amp; 3) == 0, and
2050     //  2) sp &lt;= mark &lt; mark + os::pagesize()
2051     // These 3 tests can be done by evaluating the following
2052     // expression: ((mark - sp) &amp; (3 - os::vm_page_size())),
2053     // assuming both stack pointer and pagesize have their
2054     // least significant 2 bits clear.
2055     // NOTE: the oopMark is in swap_reg %r0 as the result of cmpxchg
2056 
2057     __ sub(swap_reg, sp, swap_reg);
2058     __ neg(swap_reg, swap_reg);
2059     __ ands(swap_reg, swap_reg, 3 - os::vm_page_size());
2060 
2061     // Save the test result, for recursive case, the result is zero
2062     __ str(swap_reg, Address(lock_reg, mark_word_offset));
2063     __ br(Assembler::NE, slow_path_lock);
2064 
2065     // Slow path will re-enter here
2066 
2067     __ bind(lock_done);
2068   }
2069 
2070 
2071   // Finally just about ready to make the JNI call
2072 
2073   // get JNIEnv* which is first argument to native
2074   if (!is_critical_native) {
2075     __ lea(c_rarg0, Address(rthread, in_bytes(JavaThread::jni_environment_offset())));
2076   }
2077 
2078   // Now set thread in native
2079   __ mov(rscratch1, _thread_in_native);
2080   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
2081   __ stlrw(rscratch1, rscratch2);
2082 
2083   {
2084     int return_type = 0;
2085     switch (ret_type) {
2086     case T_VOID: break;
2087       return_type = 0; break;
2088     case T_CHAR:
2089     case T_BYTE:
2090     case T_SHORT:
2091     case T_INT:
2092     case T_BOOLEAN:
2093     case T_LONG:
2094       return_type = 1; break;
2095     case T_ARRAY:
2096     case T_VALUETYPE:
2097     case T_OBJECT:
2098       return_type = 1; break;
2099     case T_FLOAT:
2100       return_type = 2; break;
2101     case T_DOUBLE:
2102       return_type = 3; break;
2103     default:
2104       ShouldNotReachHere();
2105     }
2106     rt_call(masm, native_func,
2107             int_args + 2, // AArch64 passes up to 8 args in int registers
2108             float_args,   // and up to 8 float args
2109             return_type);
2110   }
2111 
2112   __ bind(native_return);
2113 
2114   intptr_t return_pc = (intptr_t) __ pc();
2115   oop_maps-&gt;add_gc_map(return_pc - start, map);
2116 
2117   // Unpack native results.
2118   switch (ret_type) {
2119   case T_BOOLEAN: __ c2bool(r0);                     break;
2120   case T_CHAR   : __ ubfx(r0, r0, 0, 16);            break;
2121   case T_BYTE   : __ sbfx(r0, r0, 0, 8);             break;
2122   case T_SHORT  : __ sbfx(r0, r0, 0, 16);            break;
2123   case T_INT    : __ sbfx(r0, r0, 0, 32);            break;
2124   case T_DOUBLE :
2125   case T_FLOAT  :
2126     // Result is in v0 we&#39;ll save as needed
2127     break;
2128   case T_ARRAY:                 // Really a handle
2129   case T_VALUETYPE:
2130   case T_OBJECT:                // Really a handle
2131       break; // can&#39;t de-handlize until after safepoint check
2132   case T_VOID: break;
2133   case T_LONG: break;
2134   default       : ShouldNotReachHere();
2135   }
2136 
2137   // Switch thread to &quot;native transition&quot; state before reading the synchronization state.
2138   // This additional state is necessary because reading and testing the synchronization
2139   // state is not atomic w.r.t. GC, as this scenario demonstrates:
2140   //     Java thread A, in _thread_in_native state, loads _not_synchronized and is preempted.
2141   //     VM thread changes sync state to synchronizing and suspends threads for GC.
2142   //     Thread A is resumed to finish this native method, but doesn&#39;t block here since it
2143   //     didn&#39;t see any synchronization is progress, and escapes.
2144   __ mov(rscratch1, _thread_in_native_trans);
2145 
2146   __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));
2147 
2148   // Force this write out before the read below
2149   __ dmb(Assembler::ISH);
2150 
2151   // check for safepoint operation in progress and/or pending suspend requests
2152   Label safepoint_in_progress, safepoint_in_progress_done;
2153   {
2154     __ safepoint_poll_acquire(safepoint_in_progress);
2155     __ ldrw(rscratch1, Address(rthread, JavaThread::suspend_flags_offset()));
2156     __ cbnzw(rscratch1, safepoint_in_progress);
2157     __ bind(safepoint_in_progress_done);
2158   }
2159 
2160   // change thread state
2161   Label after_transition;
2162   __ mov(rscratch1, _thread_in_Java);
2163   __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));
2164   __ stlrw(rscratch1, rscratch2);
2165   __ bind(after_transition);
2166 
2167   Label reguard;
2168   Label reguard_done;
2169   __ ldrb(rscratch1, Address(rthread, JavaThread::stack_guard_state_offset()));
2170   __ cmpw(rscratch1, JavaThread::stack_guard_yellow_reserved_disabled);
2171   __ br(Assembler::EQ, reguard);
2172   __ bind(reguard_done);
2173 
2174   // native result if any is live
2175 
2176   // Unlock
2177   Label unlock_done;
2178   Label slow_path_unlock;
2179   if (method-&gt;is_synchronized()) {
2180 
2181     // Get locked oop from the handle we passed to jni
2182     __ ldr(obj_reg, Address(oop_handle_reg, 0));
2183 
2184     __ resolve(IS_NOT_NULL, obj_reg);
2185 
2186     Label done;
2187 
2188     if (UseBiasedLocking) {
2189       __ biased_locking_exit(obj_reg, old_hdr, done);
2190     }
2191 
2192     // Simple recursive lock?
2193 
2194     __ ldr(rscratch1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2195     __ cbz(rscratch1, done);
2196 
2197     // Must save r0 if if it is live now because cmpxchg must use it
2198     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2199       save_native_result(masm, ret_type, stack_slots);
2200     }
2201 
2202 
2203     // get address of the stack lock
2204     __ lea(r0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2205     //  get old displaced header
2206     __ ldr(old_hdr, Address(r0, 0));
2207 
2208     // Atomic swap old header if oop still contains the stack lock
2209     Label succeed;
2210     __ cmpxchg_obj_header(r0, old_hdr, obj_reg, rscratch1, succeed, &amp;slow_path_unlock);
2211     __ bind(succeed);
2212 
2213     // slow path re-enters here
2214     __ bind(unlock_done);
2215     if (ret_type != T_FLOAT &amp;&amp; ret_type != T_DOUBLE &amp;&amp; ret_type != T_VOID) {
2216       restore_native_result(masm, ret_type, stack_slots);
2217     }
2218 
2219     __ bind(done);
2220   }
2221 
2222   Label dtrace_method_exit, dtrace_method_exit_done;
2223   {
2224     unsigned long offset;
2225     __ adrp(rscratch1, ExternalAddress((address)&amp;DTraceMethodProbes), offset);
2226     __ ldrb(rscratch1, Address(rscratch1, offset));
2227     __ cbnzw(rscratch1, dtrace_method_exit);
2228     __ bind(dtrace_method_exit_done);
2229   }
2230 
2231   __ reset_last_Java_frame(false);
2232 
2233   // Unbox oop result, e.g. JNIHandles::resolve result.
2234   if (is_reference_type(ret_type)) {
2235     __ resolve_jobject(r0, rthread, rscratch2);
2236   }
2237 
2238   if (CheckJNICalls) {
2239     // clear_pending_jni_exception_check
2240     __ str(zr, Address(rthread, JavaThread::pending_jni_exception_check_fn_offset()));
2241   }
2242 
2243   if (!is_critical_native) {
2244     // reset handle block
2245     __ ldr(r2, Address(rthread, JavaThread::active_handles_offset()));
2246     __ str(zr, Address(r2, JNIHandleBlock::top_offset_in_bytes()));
2247   }
2248 
2249   __ leave();
2250 
2251   if (!is_critical_native) {
2252     // Any exception pending?
2253     __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2254     __ cbnz(rscratch1, exception_pending);
2255   }
2256 
2257   // We&#39;re done
2258   __ ret(lr);
2259 
2260   // Unexpected paths are out of line and go here
2261 
2262   if (!is_critical_native) {
2263     // forward the exception
2264     __ bind(exception_pending);
2265 
2266     // and forward the exception
2267     __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
2268   }
2269 
2270   // Slow path locking &amp; unlocking
2271   if (method-&gt;is_synchronized()) {
2272 
2273     __ block_comment(&quot;Slow path lock {&quot;);
2274     __ bind(slow_path_lock);
2275 
2276     // has last_Java_frame setup. No exceptions so do vanilla call not call_VM
2277     // args are (oop obj, BasicLock* lock, JavaThread* thread)
2278 
2279     // protect the args we&#39;ve loaded
2280     save_args(masm, total_c_args, c_arg, out_regs);
2281 
2282     __ mov(c_rarg0, obj_reg);
2283     __ mov(c_rarg1, lock_reg);
2284     __ mov(c_rarg2, rthread);
2285 
2286     // Not a leaf but we have last_Java_frame setup as we want
2287     __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_locking_C), 3);
2288     restore_args(masm, total_c_args, c_arg, out_regs);
2289 
2290 #ifdef ASSERT
2291     { Label L;
2292       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2293       __ cbz(rscratch1, L);
2294       __ stop(&quot;no pending exception allowed on exit from monitorenter&quot;);
2295       __ bind(L);
2296     }
2297 #endif
2298     __ b(lock_done);
2299 
2300     __ block_comment(&quot;} Slow path lock&quot;);
2301 
2302     __ block_comment(&quot;Slow path unlock {&quot;);
2303     __ bind(slow_path_unlock);
2304 
2305     // If we haven&#39;t already saved the native result we must save it now as xmm registers
2306     // are still exposed.
2307 
2308     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2309       save_native_result(masm, ret_type, stack_slots);
2310     }
2311 
2312     __ mov(c_rarg2, rthread);
2313     __ lea(c_rarg1, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));
2314     __ mov(c_rarg0, obj_reg);
2315 
2316     // Save pending exception around call to VM (which contains an EXCEPTION_MARK)
2317     // NOTE that obj_reg == r19 currently
2318     __ ldr(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2319     __ str(zr, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2320 
2321     rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C), 3, 0, 1);
2322 
2323 #ifdef ASSERT
2324     {
2325       Label L;
2326       __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2327       __ cbz(rscratch1, L);
2328       __ stop(&quot;no pending exception allowed on exit complete_monitor_unlocking_C&quot;);
2329       __ bind(L);
2330     }
2331 #endif /* ASSERT */
2332 
2333     __ str(r19, Address(rthread, in_bytes(Thread::pending_exception_offset())));
2334 
2335     if (ret_type == T_FLOAT || ret_type == T_DOUBLE ) {
2336       restore_native_result(masm, ret_type, stack_slots);
2337     }
2338     __ b(unlock_done);
2339 
2340     __ block_comment(&quot;} Slow path unlock&quot;);
2341 
2342   } // synchronized
2343 
2344   // SLOW PATH Reguard the stack if needed
2345 
2346   __ bind(reguard);
2347   save_native_result(masm, ret_type, stack_slots);
2348   rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), 0, 0, 0);
2349   restore_native_result(masm, ret_type, stack_slots);
2350   // and continue
2351   __ b(reguard_done);
2352 
2353   // SLOW PATH safepoint
2354   {
2355     __ block_comment(&quot;safepoint {&quot;);
2356     __ bind(safepoint_in_progress);
2357 
2358     // Don&#39;t use call_VM as it will see a possible pending exception and forward it
2359     // and never return here preventing us from clearing _last_native_pc down below.
2360     //
2361     save_native_result(masm, ret_type, stack_slots);
2362     __ mov(c_rarg0, rthread);
2363 #ifndef PRODUCT
2364   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2365 #endif
2366     if (!is_critical_native) {
2367       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));
2368     } else {
2369       __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans_and_transition)));
2370     }
2371     __ blr(rscratch1);
2372     __ maybe_isb();
2373     // Restore any method result value
2374     restore_native_result(masm, ret_type, stack_slots);
2375 
2376     if (is_critical_native) {
2377       // The call above performed the transition to thread_in_Java so
2378       // skip the transition logic above.
2379       __ b(after_transition);
2380     }
2381 
2382     __ b(safepoint_in_progress_done);
2383     __ block_comment(&quot;} safepoint&quot;);
2384   }
2385 
2386   // SLOW PATH dtrace support
2387   {
2388     __ block_comment(&quot;dtrace entry {&quot;);
2389     __ bind(dtrace_method_entry);
2390 
2391     // We have all of the arguments setup at this point. We must not touch any register
2392     // argument registers at this point (what if we save/restore them there are no oop?
2393 
2394     save_args(masm, total_c_args, c_arg, out_regs);
2395     __ mov_metadata(c_rarg1, method());
2396     __ call_VM_leaf(
2397       CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_entry),
2398       rthread, c_rarg1);
2399     restore_args(masm, total_c_args, c_arg, out_regs);
2400     __ b(dtrace_method_entry_done);
2401     __ block_comment(&quot;} dtrace entry&quot;);
2402   }
2403 
2404   {
2405     __ block_comment(&quot;dtrace exit {&quot;);
2406     __ bind(dtrace_method_exit);
2407     save_native_result(masm, ret_type, stack_slots);
2408     __ mov_metadata(c_rarg1, method());
2409     __ call_VM_leaf(
2410          CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit),
2411          rthread, c_rarg1);
2412     restore_native_result(masm, ret_type, stack_slots);
2413     __ b(dtrace_method_exit_done);
2414     __ block_comment(&quot;} dtrace exit&quot;);
2415   }
2416 
2417 
2418   __ flush();
2419 
2420   nmethod *nm = nmethod::new_native_nmethod(method,
2421                                             compile_id,
2422                                             masm-&gt;code(),
2423                                             vep_offset,
2424                                             frame_complete,
2425                                             stack_slots / VMRegImpl::slots_per_word,
2426                                             (is_static ? in_ByteSize(klass_offset) : in_ByteSize(receiver_offset)),
2427                                             in_ByteSize(lock_slot_offset*VMRegImpl::stack_slot_size),
2428                                             oop_maps);
2429 
2430   if (is_critical_native) {
2431     nm-&gt;set_lazy_critical_native(true);
2432   }
2433 
2434   return nm;
2435 
2436 }
2437 
2438 // this function returns the adjust size (in number of words) to a c2i adapter
2439 // activation for use during deoptimization
2440 int Deoptimization::last_frame_adjust(int callee_parameters, int callee_locals) {
2441   assert(callee_locals &gt;= callee_parameters,
2442           &quot;test and remove; got more parms than locals&quot;);
2443   if (callee_locals &lt; callee_parameters)
2444     return 0;                   // No adjustment for negative locals
2445   int diff = (callee_locals - callee_parameters) * Interpreter::stackElementWords;
2446   // diff is counted in stack words
2447   return align_up(diff, 2);
2448 }
2449 
2450 
2451 //------------------------------generate_deopt_blob----------------------------
2452 void SharedRuntime::generate_deopt_blob() {
2453   // Allocate space for the code
2454   ResourceMark rm;
2455   // Setup code generation tools
2456   int pad = 0;
2457 #if INCLUDE_JVMCI
2458   if (EnableJVMCI || UseAOT) {
2459     pad += 512; // Increase the buffer size when compiling for JVMCI
2460   }
2461 #endif
2462   CodeBuffer buffer(&quot;deopt_blob&quot;, 2048+pad, 1024);
2463   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2464   int frame_size_in_words;
2465   OopMap* map = NULL;
2466   OopMapSet *oop_maps = new OopMapSet();
2467 
2468   // -------------
2469   // This code enters when returning to a de-optimized nmethod.  A return
2470   // address has been pushed on the the stack, and return values are in
2471   // registers.
2472   // If we are doing a normal deopt then we were called from the patched
2473   // nmethod from the point we returned to the nmethod. So the return
2474   // address on the stack is wrong by NativeCall::instruction_size
2475   // We will adjust the value so it looks like we have the original return
2476   // address on the stack (like when we eagerly deoptimized).
2477   // In the case of an exception pending when deoptimizing, we enter
2478   // with a return address on the stack that points after the call we patched
2479   // into the exception handler. We have the following register state from,
2480   // e.g., the forward exception stub (see stubGenerator_x86_64.cpp).
2481   //    r0: exception oop
2482   //    r19: exception handler
2483   //    r3: throwing pc
2484   // So in this case we simply jam r3 into the useless return address and
2485   // the stack looks just like we want.
2486   //
2487   // At this point we need to de-opt.  We save the argument return
2488   // registers.  We call the first C routine, fetch_unroll_info().  This
2489   // routine captures the return values and returns a structure which
2490   // describes the current frame size and the sizes of all replacement frames.
2491   // The current frame is compiled code and may contain many inlined
2492   // functions, each with their own JVM state.  We pop the current frame, then
2493   // push all the new frames.  Then we call the C routine unpack_frames() to
2494   // populate these frames.  Finally unpack_frames() returns us the new target
2495   // address.  Notice that callee-save registers are BLOWN here; they have
2496   // already been captured in the vframeArray at the time the return PC was
2497   // patched.
2498   address start = __ pc();
2499   Label cont;
2500 
2501   // Prolog for non exception case!
2502 
2503   // Save everything in sight.
2504   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2505 
2506   // Normal deoptimization.  Save exec mode for unpack_frames.
2507   __ movw(rcpool, Deoptimization::Unpack_deopt); // callee-saved
2508   __ b(cont);
2509 
2510   int reexecute_offset = __ pc() - start;
2511 #if INCLUDE_JVMCI &amp;&amp; !defined(COMPILER1)
2512   if (EnableJVMCI &amp;&amp; UseJVMCICompiler) {
2513     // JVMCI does not use this kind of deoptimization
2514     __ should_not_reach_here();
2515   }
2516 #endif
2517 
2518   // Reexecute case
2519   // return address is the pc describes what bci to do re-execute at
2520 
2521   // No need to update map as each call to save_live_registers will produce identical oopmap
2522   (void) RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2523 
2524   __ movw(rcpool, Deoptimization::Unpack_reexecute); // callee-saved
2525   __ b(cont);
2526 
2527 #if INCLUDE_JVMCI
2528   Label after_fetch_unroll_info_call;
2529   int implicit_exception_uncommon_trap_offset = 0;
2530   int uncommon_trap_offset = 0;
2531 
2532   if (EnableJVMCI || UseAOT) {
2533     implicit_exception_uncommon_trap_offset = __ pc() - start;
2534 
2535     __ ldr(lr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2536     __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));
2537 
2538     uncommon_trap_offset = __ pc() - start;
2539 
2540     // Save everything in sight.
2541     RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2542     // fetch_unroll_info needs to call last_java_frame()
2543     Label retaddr;
2544     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2545 
2546     __ ldrw(c_rarg1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2547     __ movw(rscratch1, -1);
2548     __ strw(rscratch1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));
2549 
2550     __ movw(rcpool, (int32_t)Deoptimization::Unpack_reexecute);
2551     __ mov(c_rarg0, rthread);
2552     __ movw(c_rarg2, rcpool); // exec mode
2553     __ lea(rscratch1,
2554            RuntimeAddress(CAST_FROM_FN_PTR(address,
2555                                            Deoptimization::uncommon_trap)));
2556     __ blr(rscratch1);
2557     __ bind(retaddr);
2558     oop_maps-&gt;add_gc_map( __ pc()-start, map-&gt;deep_copy());
2559 
2560     __ reset_last_Java_frame(false);
2561 
2562     __ b(after_fetch_unroll_info_call);
2563   } // EnableJVMCI
2564 #endif // INCLUDE_JVMCI
2565 
2566   int exception_offset = __ pc() - start;
2567 
2568   // Prolog for exception case
2569 
2570   // all registers are dead at this entry point, except for r0, and
2571   // r3 which contain the exception oop and exception pc
2572   // respectively.  Set them in TLS and fall thru to the
2573   // unpack_with_exception_in_tls entry point.
2574 
2575   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
2576   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
2577 
2578   int exception_in_tls_offset = __ pc() - start;
2579 
2580   // new implementation because exception oop is now passed in JavaThread
2581 
2582   // Prolog for exception case
2583   // All registers must be preserved because they might be used by LinearScan
2584   // Exceptiop oop and throwing PC are passed in JavaThread
2585   // tos: stack at point of call to method that threw the exception (i.e. only
2586   // args are on the stack, no return address)
2587 
2588   // The return address pushed by save_live_registers will be patched
2589   // later with the throwing pc. The correct value is not available
2590   // now because loading it from memory would destroy registers.
2591 
2592   // NB: The SP at this point must be the SP of the method that is
2593   // being deoptimized.  Deoptimization assumes that the frame created
2594   // here by save_live_registers is immediately below the method&#39;s SP.
2595   // This is a somewhat fragile mechanism.
2596 
2597   // Save everything in sight.
2598   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
2599 
2600   // Now it is safe to overwrite any register
2601 
2602   // Deopt during an exception.  Save exec mode for unpack_frames.
2603   __ mov(rcpool, Deoptimization::Unpack_exception); // callee-saved
2604 
2605   // load throwing pc from JavaThread and patch it as the return address
2606   // of the current frame. Then clear the field in JavaThread
2607 
2608   __ ldr(r3, Address(rthread, JavaThread::exception_pc_offset()));
2609   __ str(r3, Address(rfp, wordSize));
2610   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
2611 
2612 #ifdef ASSERT
2613   // verify that there is really an exception oop in JavaThread
2614   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
2615   __ verify_oop(r0);
2616 
2617   // verify that there is no pending exception
2618   Label no_pending_exception;
2619   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
2620   __ cbz(rscratch1, no_pending_exception);
2621   __ stop(&quot;must not have pending exception here&quot;);
2622   __ bind(no_pending_exception);
2623 #endif
2624 
2625   __ bind(cont);
2626 
2627   // Call C code.  Need thread and this frame, but NOT official VM entry
2628   // crud.  We cannot block on this call, no GC can happen.
2629   //
2630   // UnrollBlock* fetch_unroll_info(JavaThread* thread)
2631 
2632   // fetch_unroll_info needs to call last_java_frame().
2633 
2634   Label retaddr;
2635   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2636 #ifdef ASSERT0
2637   { Label L;
2638     __ ldr(rscratch1, Address(rthread,
2639                               JavaThread::last_Java_fp_offset()));
2640     __ cbz(rscratch1, L);
2641     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2642     __ bind(L);
2643   }
2644 #endif // ASSERT
2645   __ mov(c_rarg0, rthread);
2646   __ mov(c_rarg1, rcpool);
2647   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::fetch_unroll_info)));
2648   __ blr(rscratch1);
2649   __ bind(retaddr);
2650 
2651   // Need to have an oopmap that tells fetch_unroll_info where to
2652   // find any register it might need.
2653   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2654 
2655   __ reset_last_Java_frame(false);
2656 
2657 #if INCLUDE_JVMCI
2658   if (EnableJVMCI || UseAOT) {
2659     __ bind(after_fetch_unroll_info_call);
2660   }
2661 #endif
2662 
2663   // Load UnrollBlock* into r5
2664   __ mov(r5, r0);
2665 
2666   __ ldrw(rcpool, Address(r5, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2667    Label noException;
2668   __ cmpw(rcpool, Deoptimization::Unpack_exception);   // Was exception pending?
2669   __ br(Assembler::NE, noException);
2670   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
2671   // QQQ this is useless it was NULL above
2672   __ ldr(r3, Address(rthread, JavaThread::exception_pc_offset()));
2673   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
2674   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
2675 
2676   __ verify_oop(r0);
2677 
2678   // Overwrite the result registers with the exception results.
2679   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2680   // I think this is useless
2681   // __ str(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2682 
2683   __ bind(noException);
2684 
2685   // Only register save data is on the stack.
2686   // Now restore the result registers.  Everything else is either dead
2687   // or captured in the vframeArray.
2688   RegisterSaver::restore_result_registers(masm);
2689 
2690   // All of the register save area has been popped of the stack. Only the
2691   // return address remains.
2692 
2693   // Pop all the frames we must move/replace.
2694   //
2695   // Frame picture (youngest to oldest)
2696   // 1: self-frame (no frame link)
2697   // 2: deopting frame  (no frame link)
2698   // 3: caller of deopting frame (could be compiled/interpreted).
2699   //
2700   // Note: by leaving the return address of self-frame on the stack
2701   // and using the size of frame 2 to adjust the stack
2702   // when we are done the return to frame 3 will still be on the stack.
2703 
2704   // Pop deoptimized frame
2705   __ ldrw(r2, Address(r5, Deoptimization::UnrollBlock::size_of_deoptimized_frame_offset_in_bytes()));
2706   __ sub(r2, r2, 2 * wordSize);
2707   __ add(sp, sp, r2);
2708   __ ldp(rfp, lr, __ post(sp, 2 * wordSize));
2709   // LR should now be the return address to the caller (3)
2710 
2711 #ifdef ASSERT
2712   // Compilers generate code that bang the stack by as much as the
2713   // interpreter would need. So this stack banging should never
2714   // trigger a fault. Verify that it does not on non product builds.
2715   if (UseStackBanging) {
2716     __ ldrw(r19, Address(r5, Deoptimization::UnrollBlock::total_frame_sizes_offset_in_bytes()));
2717     __ bang_stack_size(r19, r2);
2718   }
2719 #endif
2720   // Load address of array of frame pcs into r2
2721   __ ldr(r2, Address(r5, Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2722 
2723   // Trash the old pc
2724   // __ addptr(sp, wordSize);  FIXME ????
2725 
2726   // Load address of array of frame sizes into r4
2727   __ ldr(r4, Address(r5, Deoptimization::UnrollBlock::frame_sizes_offset_in_bytes()));
2728 
2729   // Load counter into r3
2730   __ ldrw(r3, Address(r5, Deoptimization::UnrollBlock::number_of_frames_offset_in_bytes()));
2731 
2732   // Now adjust the caller&#39;s stack to make up for the extra locals
2733   // but record the original sp so that we can save it in the skeletal interpreter
2734   // frame and the stack walking of interpreter_sender will get the unextended sp
2735   // value and not the &quot;real&quot; sp value.
2736 
2737   const Register sender_sp = r6;
2738 
2739   __ mov(sender_sp, sp);
2740   __ ldrw(r19, Address(r5,
2741                        Deoptimization::UnrollBlock::
2742                        caller_adjustment_offset_in_bytes()));
2743   __ sub(sp, sp, r19);
2744 
2745   // Push interpreter frames in a loop
2746   __ mov(rscratch1, (address)0xDEADDEAD);        // Make a recognizable pattern
2747   __ mov(rscratch2, rscratch1);
2748   Label loop;
2749   __ bind(loop);
2750   __ ldr(r19, Address(__ post(r4, wordSize)));          // Load frame size
2751   __ sub(r19, r19, 2*wordSize);           // We&#39;ll push pc and fp by hand
2752   __ ldr(lr, Address(__ post(r2, wordSize)));  // Load pc
2753   __ enter();                           // Save old &amp; set new fp
2754   __ sub(sp, sp, r19);                  // Prolog
2755   // This value is corrected by layout_activation_impl
2756   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
2757   __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); // Make it walkable
2758   __ mov(sender_sp, sp);               // Pass sender_sp to next frame
2759   __ sub(r3, r3, 1);                   // Decrement counter
2760   __ cbnz(r3, loop);
2761 
2762     // Re-push self-frame
2763   __ ldr(lr, Address(r2));
2764   __ enter();
2765 
2766   // Allocate a full sized register save area.  We subtract 2 because
2767   // enter() just pushed 2 words
2768   __ sub(sp, sp, (frame_size_in_words - 2) * wordSize);
2769 
2770   // Restore frame locals after moving the frame
2771   __ strd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2772   __ str(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2773 
2774   // Call C code.  Need thread but NOT official VM entry
2775   // crud.  We cannot block on this call, no GC can happen.  Call should
2776   // restore return values to their stack-slots with the new SP.
2777   //
2778   // void Deoptimization::unpack_frames(JavaThread* thread, int exec_mode)
2779 
2780   // Use rfp because the frames look interpreted now
2781   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2782   address the_pc = __ pc();
2783   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2784 
2785   __ mov(c_rarg0, rthread);
2786   __ movw(c_rarg1, rcpool); // second arg: exec_mode
2787   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
2788   __ blr(rscratch1);
2789 
2790   // Set an oopmap for the call site
2791   // Use the same PC we used for the last java frame
2792   oop_maps-&gt;add_gc_map(the_pc - start,
2793                        new OopMap( frame_size_in_words, 0 ));
2794 
2795   // Clear fp AND pc
2796   __ reset_last_Java_frame(true);
2797 
2798   // Collect return values
2799   __ ldrd(v0, Address(sp, RegisterSaver::v0_offset_in_bytes()));
2800   __ ldr(r0, Address(sp, RegisterSaver::r0_offset_in_bytes()));
2801   // I think this is useless (throwing pc?)
2802   // __ ldr(r3, Address(sp, RegisterSaver::r3_offset_in_bytes()));
2803 
2804   // Pop self-frame.
2805   __ leave();                           // Epilog
2806 
2807   // Jump to interpreter
2808   __ ret(lr);
2809 
2810   // Make sure all code is generated
2811   masm-&gt;flush();
2812 
2813   _deopt_blob = DeoptimizationBlob::create(&amp;buffer, oop_maps, 0, exception_offset, reexecute_offset, frame_size_in_words);
2814   _deopt_blob-&gt;set_unpack_with_exception_in_tls_offset(exception_in_tls_offset);
2815 #if INCLUDE_JVMCI
2816   if (EnableJVMCI || UseAOT) {
2817     _deopt_blob-&gt;set_uncommon_trap_offset(uncommon_trap_offset);
2818     _deopt_blob-&gt;set_implicit_exception_uncommon_trap_offset(implicit_exception_uncommon_trap_offset);
2819   }
2820 #endif
2821 }
2822 
2823 uint SharedRuntime::out_preserve_stack_slots() {
2824   return 0;
2825 }
2826 
2827 #ifdef COMPILER2
2828 //------------------------------generate_uncommon_trap_blob--------------------
2829 void SharedRuntime::generate_uncommon_trap_blob() {
2830   // Allocate space for the code
2831   ResourceMark rm;
2832   // Setup code generation tools
2833   CodeBuffer buffer(&quot;uncommon_trap_blob&quot;, 2048, 1024);
2834   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
2835 
2836   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
2837 
2838   address start = __ pc();
2839 
2840   // Push self-frame.  We get here with a return address in LR
2841   // and sp should be 16 byte aligned
2842   // push rfp and retaddr by hand
2843   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
2844   // we don&#39;t expect an arg reg save area
2845 #ifndef PRODUCT
2846   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
2847 #endif
2848   // compiler left unloaded_class_index in j_rarg0 move to where the
2849   // runtime expects it.
2850   if (c_rarg1 != j_rarg0) {
2851     __ movw(c_rarg1, j_rarg0);
2852   }
2853 
2854   // we need to set the past SP to the stack pointer of the stub frame
2855   // and the pc to the address where this runtime call will return
2856   // although actually any pc in this code blob will do).
2857   Label retaddr;
2858   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
2859 
2860   // Call C code.  Need thread but NOT official VM entry
2861   // crud.  We cannot block on this call, no GC can happen.  Call should
2862   // capture callee-saved registers as well as return values.
2863   // Thread is in rdi already.
2864   //
2865   // UnrollBlock* uncommon_trap(JavaThread* thread, jint unloaded_class_index);
2866   //
2867   // n.b. 2 gp args, 0 fp args, integral return type
2868 
2869   __ mov(c_rarg0, rthread);
2870   __ movw(c_rarg2, (unsigned)Deoptimization::Unpack_uncommon_trap);
2871   __ lea(rscratch1,
2872          RuntimeAddress(CAST_FROM_FN_PTR(address,
2873                                          Deoptimization::uncommon_trap)));
2874   __ blr(rscratch1);
2875   __ bind(retaddr);
2876 
2877   // Set an oopmap for the call site
2878   OopMapSet* oop_maps = new OopMapSet();
2879   OopMap* map = new OopMap(SimpleRuntimeFrame::framesize, 0);
2880 
2881   // location of rfp is known implicitly by the frame sender code
2882 
2883   oop_maps-&gt;add_gc_map(__ pc() - start, map);
2884 
2885   __ reset_last_Java_frame(false);
2886 
2887   // move UnrollBlock* into r4
2888   __ mov(r4, r0);
2889 
2890 #ifdef ASSERT
2891   { Label L;
2892     __ ldrw(rscratch1, Address(r4, Deoptimization::UnrollBlock::unpack_kind_offset_in_bytes()));
2893     __ cmpw(rscratch1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2894     __ br(Assembler::EQ, L);
2895     __ stop(&quot;SharedRuntime::generate_deopt_blob: last_Java_fp not cleared&quot;);
2896     __ bind(L);
2897   }
2898 #endif
2899 
2900   // Pop all the frames we must move/replace.
2901   //
2902   // Frame picture (youngest to oldest)
2903   // 1: self-frame (no frame link)
2904   // 2: deopting frame  (no frame link)
2905   // 3: caller of deopting frame (could be compiled/interpreted).
2906 
2907   // Pop self-frame.  We have no frame, and must rely only on r0 and sp.
2908   __ add(sp, sp, (SimpleRuntimeFrame::framesize) &lt;&lt; LogBytesPerInt); // Epilog!
2909 
2910   // Pop deoptimized frame (int)
2911   __ ldrw(r2, Address(r4,
2912                       Deoptimization::UnrollBlock::
2913                       size_of_deoptimized_frame_offset_in_bytes()));
2914   __ sub(r2, r2, 2 * wordSize);
2915   __ add(sp, sp, r2);
2916   __ ldp(rfp, lr, __ post(sp, 2 * wordSize));
2917   // LR should now be the return address to the caller (3) frame
2918 
2919 #ifdef ASSERT
2920   // Compilers generate code that bang the stack by as much as the
2921   // interpreter would need. So this stack banging should never
2922   // trigger a fault. Verify that it does not on non product builds.
2923   if (UseStackBanging) {
2924     __ ldrw(r1, Address(r4,
2925                         Deoptimization::UnrollBlock::
2926                         total_frame_sizes_offset_in_bytes()));
2927     __ bang_stack_size(r1, r2);
2928   }
2929 #endif
2930 
2931   // Load address of array of frame pcs into r2 (address*)
2932   __ ldr(r2, Address(r4,
2933                      Deoptimization::UnrollBlock::frame_pcs_offset_in_bytes()));
2934 
2935   // Load address of array of frame sizes into r5 (intptr_t*)
2936   __ ldr(r5, Address(r4,
2937                      Deoptimization::UnrollBlock::
2938                      frame_sizes_offset_in_bytes()));
2939 
2940   // Counter
2941   __ ldrw(r3, Address(r4,
2942                       Deoptimization::UnrollBlock::
2943                       number_of_frames_offset_in_bytes())); // (int)
2944 
2945   // Now adjust the caller&#39;s stack to make up for the extra locals but
2946   // record the original sp so that we can save it in the skeletal
2947   // interpreter frame and the stack walking of interpreter_sender
2948   // will get the unextended sp value and not the &quot;real&quot; sp value.
2949 
2950   const Register sender_sp = r8;
2951 
2952   __ mov(sender_sp, sp);
2953   __ ldrw(r1, Address(r4,
2954                       Deoptimization::UnrollBlock::
2955                       caller_adjustment_offset_in_bytes())); // (int)
2956   __ sub(sp, sp, r1);
2957 
2958   // Push interpreter frames in a loop
2959   Label loop;
2960   __ bind(loop);
2961   __ ldr(r1, Address(r5, 0));       // Load frame size
2962   __ sub(r1, r1, 2 * wordSize);     // We&#39;ll push pc and rfp by hand
2963   __ ldr(lr, Address(r2, 0));       // Save return address
2964   __ enter();                       // and old rfp &amp; set new rfp
2965   __ sub(sp, sp, r1);               // Prolog
2966   __ str(sender_sp, Address(rfp, frame::interpreter_frame_sender_sp_offset * wordSize)); // Make it walkable
2967   // This value is corrected by layout_activation_impl
2968   __ str(zr, Address(rfp, frame::interpreter_frame_last_sp_offset * wordSize));
2969   __ mov(sender_sp, sp);          // Pass sender_sp to next frame
2970   __ add(r5, r5, wordSize);       // Bump array pointer (sizes)
2971   __ add(r2, r2, wordSize);       // Bump array pointer (pcs)
2972   __ subsw(r3, r3, 1);            // Decrement counter
2973   __ br(Assembler::GT, loop);
2974   __ ldr(lr, Address(r2, 0));     // save final return address
2975   // Re-push self-frame
2976   __ enter();                     // &amp; old rfp &amp; set new rfp
2977 
2978   // Use rfp because the frames look interpreted now
2979   // Save &quot;the_pc&quot; since it cannot easily be retrieved using the last_java_SP after we aligned SP.
2980   // Don&#39;t need the precise return PC here, just precise enough to point into this code blob.
2981   address the_pc = __ pc();
2982   __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);
2983 
2984   // Call C code.  Need thread but NOT official VM entry
2985   // crud.  We cannot block on this call, no GC can happen.  Call should
2986   // restore return values to their stack-slots with the new SP.
2987   // Thread is in rdi already.
2988   //
2989   // BasicType unpack_frames(JavaThread* thread, int exec_mode);
2990   //
2991   // n.b. 2 gp args, 0 fp args, integral return type
2992 
2993   // sp should already be aligned
2994   __ mov(c_rarg0, rthread);
2995   __ movw(c_rarg1, (unsigned)Deoptimization::Unpack_uncommon_trap);
2996   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, Deoptimization::unpack_frames)));
2997   __ blr(rscratch1);
2998 
2999   // Set an oopmap for the call site
3000   // Use the same PC we used for the last java frame
3001   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
3002 
3003   // Clear fp AND pc
3004   __ reset_last_Java_frame(true);
3005 
3006   // Pop self-frame.
3007   __ leave();                 // Epilog
3008 
3009   // Jump to interpreter
3010   __ ret(lr);
3011 
3012   // Make sure all code is generated
3013   masm-&gt;flush();
3014 
3015   _uncommon_trap_blob =  UncommonTrapBlob::create(&amp;buffer, oop_maps,
3016                                                  SimpleRuntimeFrame::framesize &gt;&gt; 1);
3017 }
3018 #endif // COMPILER2
3019 
3020 
3021 //------------------------------generate_handler_blob------
3022 //
3023 // Generate a special Compile2Runtime blob that saves all registers,
3024 // and setup oopmap.
3025 //
3026 SafepointBlob* SharedRuntime::generate_handler_blob(address call_ptr, int poll_type) {
3027   ResourceMark rm;
3028   OopMapSet *oop_maps = new OopMapSet();
3029   OopMap* map;
3030 
3031   // Allocate space for the code.  Setup code generation tools.
3032   CodeBuffer buffer(&quot;handler_blob&quot;, 2048, 1024);
3033   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3034 
3035   address start   = __ pc();
3036   address call_pc = NULL;
3037   int frame_size_in_words;
3038   bool cause_return = (poll_type == POLL_AT_RETURN);
3039   bool save_vectors = (poll_type == POLL_AT_VECTOR_LOOP);
3040 
3041   // Save Integer and Float registers.
3042   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words, save_vectors);
3043 
3044   // The following is basically a call_VM.  However, we need the precise
3045   // address of the call in order to generate an oopmap. Hence, we do all the
3046   // work outselves.
3047 
3048   Label retaddr;
3049   __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
3050 
3051   // The return address must always be correct so that frame constructor never
3052   // sees an invalid pc.
3053 
3054   if (!cause_return) {
3055     // overwrite the return address pushed by save_live_registers
3056     // Additionally, r20 is a callee-saved register so we can look at
3057     // it later to determine if someone changed the return address for
3058     // us!
3059     __ ldr(r20, Address(rthread, JavaThread::saved_exception_pc_offset()));
3060     __ str(r20, Address(rfp, wordSize));
3061   }
3062 
3063   // Do the call
3064   __ mov(c_rarg0, rthread);
3065   __ lea(rscratch1, RuntimeAddress(call_ptr));
3066   __ blr(rscratch1);
3067   __ bind(retaddr);
3068 
3069   // Set an oopmap for the call site.  This oopmap will map all
3070   // oop-registers and debug-info registers as callee-saved.  This
3071   // will allow deoptimization at this safepoint to find all possible
3072   // debug-info recordings, as well as let GC find all oops.
3073 
3074   oop_maps-&gt;add_gc_map( __ pc() - start, map);
3075 
3076   Label noException;
3077 
3078   __ reset_last_Java_frame(false);
3079 
3080   __ maybe_isb();
3081   __ membar(Assembler::LoadLoad | Assembler::LoadStore);
3082 
3083   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
3084   __ cbz(rscratch1, noException);
3085 
3086   // Exception pending
3087 
3088   RegisterSaver::restore_live_registers(masm, save_vectors);
3089 
3090   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3091 
3092   // No exception case
3093   __ bind(noException);
3094 
3095   Label no_adjust, bail;
3096   if (!cause_return) {
3097     // If our stashed return pc was modified by the runtime we avoid touching it
3098     __ ldr(rscratch1, Address(rfp, wordSize));
3099     __ cmp(r20, rscratch1);
3100     __ br(Assembler::NE, no_adjust);
3101 
3102 #ifdef ASSERT
3103     // Verify the correct encoding of the poll we&#39;re about to skip.
3104     // See NativeInstruction::is_ldrw_to_zr()
3105     __ ldrw(rscratch1, Address(r20));
3106     __ ubfx(rscratch2, rscratch1, 22, 10);
3107     __ cmpw(rscratch2, 0b1011100101);
3108     __ br(Assembler::NE, bail);
3109     __ ubfx(rscratch2, rscratch1, 0, 5);
3110     __ cmpw(rscratch2, 0b11111);
3111     __ br(Assembler::NE, bail);
3112 #endif
3113     // Adjust return pc forward to step over the safepoint poll instruction
3114     __ add(r20, r20, NativeInstruction::instruction_size);
3115     __ str(r20, Address(rfp, wordSize));
3116   }
3117 
3118   __ bind(no_adjust);
3119   // Normal exit, restore registers and exit.
3120   RegisterSaver::restore_live_registers(masm, save_vectors);
3121 
3122   __ ret(lr);
3123 
3124 #ifdef ASSERT
3125   __ bind(bail);
3126   __ stop(&quot;Attempting to adjust pc to skip safepoint poll but the return point is not what we expected&quot;);
3127 #endif
3128 
3129   // Make sure all code is generated
3130   masm-&gt;flush();
3131 
3132   // Fill-out other meta info
3133   return SafepointBlob::create(&amp;buffer, oop_maps, frame_size_in_words);
3134 }
3135 
3136 //
3137 // generate_resolve_blob - call resolution (static/virtual/opt-virtual/ic-miss
3138 //
3139 // Generate a stub that calls into vm to find out the proper destination
3140 // of a java call. All the argument registers are live at this point
3141 // but since this is generic code we don&#39;t know what they are and the caller
3142 // must do any gc of the args.
3143 //
3144 RuntimeStub* SharedRuntime::generate_resolve_blob(address destination, const char* name) {
3145   assert (StubRoutines::forward_exception_entry() != NULL, &quot;must be generated before&quot;);
3146 
3147   // allocate space for the code
3148   ResourceMark rm;
3149 
3150   CodeBuffer buffer(name, 1000, 512);
3151   MacroAssembler* masm                = new MacroAssembler(&amp;buffer);
3152 
3153   int frame_size_in_words;
3154 
3155   OopMapSet *oop_maps = new OopMapSet();
3156   OopMap* map = NULL;
3157 
3158   int start = __ offset();
3159 
3160   map = RegisterSaver::save_live_registers(masm, 0, &amp;frame_size_in_words);
3161 
3162   int frame_complete = __ offset();
3163 
3164   {
3165     Label retaddr;
3166     __ set_last_Java_frame(sp, noreg, retaddr, rscratch1);
3167 
3168     __ mov(c_rarg0, rthread);
3169     __ lea(rscratch1, RuntimeAddress(destination));
3170 
3171     __ blr(rscratch1);
3172     __ bind(retaddr);
3173   }
3174 
3175   // Set an oopmap for the call site.
3176   // We need this not only for callee-saved registers, but also for volatile
3177   // registers that the compiler might be keeping live across a safepoint.
3178 
3179   oop_maps-&gt;add_gc_map( __ offset() - start, map);
3180 
3181   __ maybe_isb();
3182 
3183   // r0 contains the address we are going to jump to assuming no exception got installed
3184 
3185   // clear last_Java_sp
3186   __ reset_last_Java_frame(false);
3187   // check for pending exceptions
3188   Label pending;
3189   __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));
3190   __ cbnz(rscratch1, pending);
3191 
3192   // get the returned Method*
3193   __ get_vm_result_2(rmethod, rthread);
3194   __ str(rmethod, Address(sp, RegisterSaver::reg_offset_in_bytes(rmethod)));
3195 
3196   // r0 is where we want to jump, overwrite rscratch1 which is saved and scratch
3197   __ str(r0, Address(sp, RegisterSaver::rscratch1_offset_in_bytes()));
3198   RegisterSaver::restore_live_registers(masm);
3199 
3200   // We are back the the original state on entry and ready to go.
3201 
3202   __ br(rscratch1);
3203 
3204   // Pending exception after the safepoint
3205 
3206   __ bind(pending);
3207 
3208   RegisterSaver::restore_live_registers(masm);
3209 
3210   // exception pending =&gt; remove activation and forward to exception handler
3211 
3212   __ str(zr, Address(rthread, JavaThread::vm_result_offset()));
3213 
3214   __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));
3215   __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
3216 
3217   // -------------
3218   // make sure all code is generated
3219   masm-&gt;flush();
3220 
3221   // return the  blob
3222   // frame_size_words or bytes??
3223   return RuntimeStub::new_runtime_stub(name, &amp;buffer, frame_complete, frame_size_in_words, oop_maps, true);
3224 }
3225 
3226 #ifdef COMPILER2
3227 // This is here instead of runtime_x86_64.cpp because it uses SimpleRuntimeFrame
3228 //
3229 //------------------------------generate_exception_blob---------------------------
3230 // creates exception blob at the end
3231 // Using exception blob, this code is jumped from a compiled method.
3232 // (see emit_exception_handler in x86_64.ad file)
3233 //
3234 // Given an exception pc at a call we call into the runtime for the
3235 // handler in this method. This handler might merely restore state
3236 // (i.e. callee save registers) unwind the frame and jump to the
3237 // exception handler for the nmethod if there is no Java level handler
3238 // for the nmethod.
3239 //
3240 // This code is entered with a jmp.
3241 //
3242 // Arguments:
3243 //   r0: exception oop
3244 //   r3: exception pc
3245 //
3246 // Results:
3247 //   r0: exception oop
3248 //   r3: exception pc in caller or ???
3249 //   destination: exception handler of caller
3250 //
3251 // Note: the exception pc MUST be at a call (precise debug information)
3252 //       Registers r0, r3, r2, r4, r5, r8-r11 are not callee saved.
3253 //
3254 
3255 void OptoRuntime::generate_exception_blob() {
3256   assert(!OptoRuntime::is_callee_saved_register(R3_num), &quot;&quot;);
3257   assert(!OptoRuntime::is_callee_saved_register(R0_num), &quot;&quot;);
3258   assert(!OptoRuntime::is_callee_saved_register(R2_num), &quot;&quot;);
3259 
3260   assert(SimpleRuntimeFrame::framesize % 4 == 0, &quot;sp not 16-byte aligned&quot;);
3261 
3262   // Allocate space for the code
3263   ResourceMark rm;
3264   // Setup code generation tools
3265   CodeBuffer buffer(&quot;exception_blob&quot;, 2048, 1024);
3266   MacroAssembler* masm = new MacroAssembler(&amp;buffer);
3267 
3268   // TODO check various assumptions made here
3269   //
3270   // make sure we do so before running this
3271 
3272   address start = __ pc();
3273 
3274   // push rfp and retaddr by hand
3275   // Exception pc is &#39;return address&#39; for stack walker
3276   __ stp(rfp, lr, Address(__ pre(sp, -2 * wordSize)));
3277   // there are no callee save registers and we don&#39;t expect an
3278   // arg reg save area
3279 #ifndef PRODUCT
3280   assert(frame::arg_reg_save_area_bytes == 0, &quot;not expecting frame reg save area&quot;);
3281 #endif
3282   // Store exception in Thread object. We cannot pass any arguments to the
3283   // handle_exception call, since we do not want to make any assumption
3284   // about the size of the frame where the exception happened in.
3285   __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));
3286   __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));
3287 
3288   // This call does all the hard work.  It checks if an exception handler
3289   // exists in the method.
3290   // If so, it returns the handler address.
3291   // If not, it prepares for stack-unwinding, restoring the callee-save
3292   // registers of the frame being removed.
3293   //
3294   // address OptoRuntime::handle_exception_C(JavaThread* thread)
3295   //
3296   // n.b. 1 gp arg, 0 fp args, integral return type
3297 
3298   // the stack should always be aligned
3299   address the_pc = __ pc();
3300   __ set_last_Java_frame(sp, noreg, the_pc, rscratch1);
3301   __ mov(c_rarg0, rthread);
3302   __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, OptoRuntime::handle_exception_C)));
3303   __ blr(rscratch1);
3304   __ maybe_isb();
3305 
3306   // Set an oopmap for the call site.  This oopmap will only be used if we
3307   // are unwinding the stack.  Hence, all locations will be dead.
3308   // Callee-saved registers will be the same as the frame above (i.e.,
3309   // handle_exception_stub), since they were restored when we got the
3310   // exception.
3311 
3312   OopMapSet* oop_maps = new OopMapSet();
3313 
3314   oop_maps-&gt;add_gc_map(the_pc - start, new OopMap(SimpleRuntimeFrame::framesize, 0));
3315 
3316   __ reset_last_Java_frame(false);
3317 
3318   // Restore callee-saved registers
3319 
3320   // rfp is an implicitly saved callee saved register (i.e. the calling
3321   // convention will save restore it in prolog/epilog) Other than that
3322   // there are no callee save registers now that adapter frames are gone.
3323   // and we dont&#39; expect an arg reg save area
3324   __ ldp(rfp, r3, Address(__ post(sp, 2 * wordSize)));
3325 
3326   // r0: exception handler
3327 
3328   // We have a handler in r0 (could be deopt blob).
3329   __ mov(r8, r0);
3330 
3331   // Get the exception oop
3332   __ ldr(r0, Address(rthread, JavaThread::exception_oop_offset()));
3333   // Get the exception pc in case we are deoptimized
3334   __ ldr(r4, Address(rthread, JavaThread::exception_pc_offset()));
3335 #ifdef ASSERT
3336   __ str(zr, Address(rthread, JavaThread::exception_handler_pc_offset()));
3337   __ str(zr, Address(rthread, JavaThread::exception_pc_offset()));
3338 #endif
3339   // Clear the exception oop so GC no longer processes it as a root.
3340   __ str(zr, Address(rthread, JavaThread::exception_oop_offset()));
3341 
3342   // r0: exception oop
3343   // r8:  exception handler
3344   // r4: exception pc
3345   // Jump to handler
3346 
3347   __ br(r8);
3348 
3349   // Make sure all code is generated
3350   masm-&gt;flush();
3351 
3352   // Set exception blob
3353   _exception_blob =  ExceptionBlob::create(&amp;buffer, oop_maps, SimpleRuntimeFrame::framesize &gt;&gt; 1);
3354 }
3355 
3356 BufferedValueTypeBlob* SharedRuntime::generate_buffered_value_type_adapter(const ValueKlass* vk) {
3357   BufferBlob* buf = BufferBlob::create(&quot;value types pack/unpack&quot;, 16 * K);
3358   CodeBuffer buffer(buf);
3359   short buffer_locs[20];
3360   buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3361                                          sizeof(buffer_locs)/sizeof(relocInfo));
3362 
3363   MacroAssembler _masm(&amp;buffer);
3364   MacroAssembler* masm = &amp;_masm;
3365 
3366   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3367   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3368 
3369   int pack_fields_off = __ offset();
3370 
3371   int j = 1;
3372   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3373     BasicType bt = sig_vk-&gt;at(i)._bt;
3374     if (bt == T_VALUETYPE) {
3375       continue;
3376     }
3377     if (bt == T_VOID) {
3378       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
3379           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
3380         j++;
3381       }
3382       continue;
3383     }
3384     int off = sig_vk-&gt;at(i)._offset;
3385     VMRegPair pair = regs-&gt;at(j);
3386     VMReg r_1 = pair.first();
3387     VMReg r_2 = pair.second();
3388     Address to(r0, off);
3389     if (bt == T_FLOAT) {
3390       __ strs(r_1-&gt;as_FloatRegister(), to);
3391     } else if (bt == T_DOUBLE) {
3392       __ strd(r_1-&gt;as_FloatRegister(), to);
3393     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3394       Register val = r_1-&gt;as_Register();
3395       assert_different_registers(r0, val);
3396       // We don&#39;t need barriers because the destination is a newly allocated object.
3397       // Also, we cannot use store_heap_oop(to, val) because it uses r8 as tmp.
3398       if (UseCompressedOops) {
3399         __ encode_heap_oop(val);
3400         __ str(val, to);
3401       } else {
3402         __ str(val, to);
3403       }
3404     } else {
3405       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
3406       assert_different_registers(r0, r_1-&gt;as_Register());
3407       size_t size_in_bytes = type2aelembytes(bt);
3408       __ store_sized_value(to, r_1-&gt;as_Register(), size_in_bytes);
3409     }
3410     j++;
3411   }
3412   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3413 
3414   __ ret(lr);
3415 
3416   int unpack_fields_off = __ offset();
3417 
3418   j = 1;
3419   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3420     BasicType bt = sig_vk-&gt;at(i)._bt;
3421     if (bt == T_VALUETYPE) {
3422       continue;
3423     }
3424     if (bt == T_VOID) {
3425       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
3426           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
3427         j++;
3428       }
3429       continue;
3430     }
3431     int off = sig_vk-&gt;at(i)._offset;
3432     VMRegPair pair = regs-&gt;at(j);
3433     VMReg r_1 = pair.first();
3434     VMReg r_2 = pair.second();
3435     Address from(r0, off);
3436     if (bt == T_FLOAT) {
3437       __ ldrs(r_1-&gt;as_FloatRegister(), from);
3438     } else if (bt == T_DOUBLE) {
3439       __ ldrd(r_1-&gt;as_FloatRegister(), from);
3440     } else if (bt == T_OBJECT || bt == T_ARRAY) {
3441        assert_different_registers(r0, r_1-&gt;as_Register());
3442        __ load_heap_oop(r_1-&gt;as_Register(), from);
3443     } else {
3444       assert(is_java_primitive(bt), &quot;unexpected basic type&quot;);
3445       assert_different_registers(r0, r_1-&gt;as_Register());
3446 
3447       size_t size_in_bytes = type2aelembytes(bt);
3448       __ load_sized_value(r_1-&gt;as_Register(), from, size_in_bytes, bt != T_CHAR &amp;&amp; bt != T_BOOLEAN);
3449     }
3450     j++;
3451   }
3452   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3453 
3454   __ ret(lr);
3455 
3456   __ flush();
3457 
3458   return BufferedValueTypeBlob::create(&amp;buffer, pack_fields_off, unpack_fields_off);
3459 }
3460 #endif // COMPILER2
    </pre>
  </body>
</html>
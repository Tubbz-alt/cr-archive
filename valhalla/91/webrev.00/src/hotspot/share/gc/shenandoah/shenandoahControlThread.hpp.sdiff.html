<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahControlThread.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahControlThread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahControlThread.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 
 36 // Periodic task is useful for doing asynchronous things that do not require (heap) locks,
 37 // or synchronization with other parts of collector. These could run even when ShenandoahConcurrentThread
 38 // is busy driving the GC cycle.
 39 class ShenandoahPeriodicTask : public PeriodicTask {
 40 private:
 41   ShenandoahControlThread* _thread;
 42 public:
 43   ShenandoahPeriodicTask(ShenandoahControlThread* thread) :
 44           PeriodicTask(100), _thread(thread) {}
 45   virtual void task();
 46 };
 47 
 48 // Periodic task to flush SATB buffers periodically.
 49 class ShenandoahPeriodicSATBFlushTask : public PeriodicTask {
 50 public:
 51   ShenandoahPeriodicSATBFlushTask() : PeriodicTask(ShenandoahSATBBufferFlushInterval) {}
 52   virtual void task();
 53 };
 54 







 55 class ShenandoahControlThread: public ConcurrentGCThread {
 56   friend class VMStructs;
 57 
 58 private:
 59   typedef enum {
 60     none,
 61     concurrent_normal,
 62     stw_degenerated,
 63     stw_full
 64   } GCMode;
 65 
 66   // While we could have a single lock for these, it may risk unblocking
 67   // GC waiters when alloc failure GC cycle finishes. We want instead
 68   // to make complete explicit cycle for for demanding customers.
 69   Monitor _alloc_failure_waiters_lock;
 70   Monitor _gc_waiters_lock;
 71   ShenandoahPeriodicTask _periodic_task;
 72   ShenandoahPeriodicSATBFlushTask _periodic_satb_flush_task;

 73 
 74 public:
 75   void run_service();
 76   void stop_service();
 77 
 78 private:
 79   ShenandoahSharedFlag _gc_requested;
 80   ShenandoahSharedFlag _alloc_failure_gc;
 81   ShenandoahSharedFlag _graceful_shutdown;
 82   ShenandoahSharedFlag _heap_changed;
 83   ShenandoahSharedFlag _do_counters_update;
 84   ShenandoahSharedFlag _force_counters_update;
 85   GCCause::Cause       _requested_gc_cause;
 86   ShenandoahHeap::ShenandoahDegenPoint _degen_point;
 87 
 88   shenandoah_padding(0);
 89   volatile size_t _allocs_seen;
 90   shenandoah_padding(1);
 91   volatile size_t _gc_id;
 92   shenandoah_padding(2);
</pre>
</td>
<td>
<hr />
<pre>
 35 
 36 // Periodic task is useful for doing asynchronous things that do not require (heap) locks,
 37 // or synchronization with other parts of collector. These could run even when ShenandoahConcurrentThread
 38 // is busy driving the GC cycle.
 39 class ShenandoahPeriodicTask : public PeriodicTask {
 40 private:
 41   ShenandoahControlThread* _thread;
 42 public:
 43   ShenandoahPeriodicTask(ShenandoahControlThread* thread) :
 44           PeriodicTask(100), _thread(thread) {}
 45   virtual void task();
 46 };
 47 
 48 // Periodic task to flush SATB buffers periodically.
 49 class ShenandoahPeriodicSATBFlushTask : public PeriodicTask {
 50 public:
 51   ShenandoahPeriodicSATBFlushTask() : PeriodicTask(ShenandoahSATBBufferFlushInterval) {}
 52   virtual void task();
 53 };
 54 
<span class="line-added"> 55 // Periodic task to notify blocked paced waiters.</span>
<span class="line-added"> 56 class ShenandoahPeriodicPacerNotify : public PeriodicTask {</span>
<span class="line-added"> 57 public:</span>
<span class="line-added"> 58   ShenandoahPeriodicPacerNotify() : PeriodicTask(PeriodicTask::min_interval) {}</span>
<span class="line-added"> 59   virtual void task();</span>
<span class="line-added"> 60 };</span>
<span class="line-added"> 61 </span>
 62 class ShenandoahControlThread: public ConcurrentGCThread {
 63   friend class VMStructs;
 64 
 65 private:
 66   typedef enum {
 67     none,
 68     concurrent_normal,
 69     stw_degenerated,
 70     stw_full
 71   } GCMode;
 72 
 73   // While we could have a single lock for these, it may risk unblocking
 74   // GC waiters when alloc failure GC cycle finishes. We want instead
 75   // to make complete explicit cycle for for demanding customers.
 76   Monitor _alloc_failure_waiters_lock;
 77   Monitor _gc_waiters_lock;
 78   ShenandoahPeriodicTask _periodic_task;
 79   ShenandoahPeriodicSATBFlushTask _periodic_satb_flush_task;
<span class="line-added"> 80   ShenandoahPeriodicPacerNotify _periodic_pacer_notify_task;</span>
 81 
 82 public:
 83   void run_service();
 84   void stop_service();
 85 
 86 private:
 87   ShenandoahSharedFlag _gc_requested;
 88   ShenandoahSharedFlag _alloc_failure_gc;
 89   ShenandoahSharedFlag _graceful_shutdown;
 90   ShenandoahSharedFlag _heap_changed;
 91   ShenandoahSharedFlag _do_counters_update;
 92   ShenandoahSharedFlag _force_counters_update;
 93   GCCause::Cause       _requested_gc_cause;
 94   ShenandoahHeap::ShenandoahDegenPoint _degen_point;
 95 
 96   shenandoah_padding(0);
 97   volatile size_t _allocs_seen;
 98   shenandoah_padding(1);
 99   volatile size_t _gc_id;
100   shenandoah_padding(2);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahControlThread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahHeap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
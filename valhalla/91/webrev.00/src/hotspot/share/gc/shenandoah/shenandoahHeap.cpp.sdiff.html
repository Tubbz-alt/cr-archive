<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahControlThread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1280  * have a valid marking bitmap after successful marking. In particular, we *don&#39;t* have a valid
1281  * marking bitmap during marking, after aborted marking or during/after cleanup (when we just
1282  * wiped the bitmap in preparation for next marking).
1283  *
1284  * For all those reasons, we implement object iteration as a single marking traversal, reporting
1285  * objects as we mark+traverse through the heap, starting from GC roots. JVMTI IterateThroughHeap
1286  * is allowed to report dead objects, but is not required to do so.
1287  */
1288 void ShenandoahHeap::object_iterate(ObjectClosure* cl) {
1289   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);
1290   if (!_aux_bitmap_region_special &amp;&amp; !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {
1291     log_warning(gc)(&quot;Could not commit native memory for auxiliary marking bitmap for heap iteration&quot;);
1292     return;
1293   }
1294 
1295   // Reset bitmap
1296   _aux_bit_map.clear();
1297 
1298   Stack&lt;oop,mtGC&gt; oop_stack;
1299 
<span class="line-removed">1300   // First, we process GC roots according to current GC cycle. This populates the work stack with initial objects.</span>
<span class="line-removed">1301   ShenandoahHeapIterationRootScanner rp;</span>
1302   ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
1303 
<span class="line-modified">1304   rp.roots_do(&amp;oops);</span>







1305 
1306   // Work through the oop stack to traverse heap.
1307   while (! oop_stack.is_empty()) {
1308     oop obj = oop_stack.pop();
1309     assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1310     cl-&gt;do_object(obj);
1311     obj-&gt;oop_iterate(&amp;oops);
1312   }
1313 
1314   assert(oop_stack.is_empty(), &quot;should be empty&quot;);
1315 
1316   if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
1317     log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
1318   }
1319 }
1320 
1321 // Keep alive an object that was loaded with AS_NO_KEEPALIVE.
1322 void ShenandoahHeap::keep_alive(oop obj) {
1323   if (is_concurrent_mark_in_progress()) {
1324     ShenandoahBarrierSet::barrier_set()-&gt;enqueue(obj);
</pre>
</td>
<td>
<hr />
<pre>
1280  * have a valid marking bitmap after successful marking. In particular, we *don&#39;t* have a valid
1281  * marking bitmap during marking, after aborted marking or during/after cleanup (when we just
1282  * wiped the bitmap in preparation for next marking).
1283  *
1284  * For all those reasons, we implement object iteration as a single marking traversal, reporting
1285  * objects as we mark+traverse through the heap, starting from GC roots. JVMTI IterateThroughHeap
1286  * is allowed to report dead objects, but is not required to do so.
1287  */
1288 void ShenandoahHeap::object_iterate(ObjectClosure* cl) {
1289   assert(SafepointSynchronize::is_at_safepoint(), &quot;safe iteration is only available during safepoints&quot;);
1290   if (!_aux_bitmap_region_special &amp;&amp; !os::commit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size(), false)) {
1291     log_warning(gc)(&quot;Could not commit native memory for auxiliary marking bitmap for heap iteration&quot;);
1292     return;
1293   }
1294 
1295   // Reset bitmap
1296   _aux_bit_map.clear();
1297 
1298   Stack&lt;oop,mtGC&gt; oop_stack;
1299 


1300   ObjectIterateScanRootClosure oops(&amp;_aux_bit_map, &amp;oop_stack);
1301 
<span class="line-modified">1302   {</span>
<span class="line-added">1303     // First, we process GC roots according to current GC cycle.</span>
<span class="line-added">1304     // This populates the work stack with initial objects.</span>
<span class="line-added">1305     // It is important to relinquish the associated locks before diving</span>
<span class="line-added">1306     // into heap dumper.</span>
<span class="line-added">1307     ShenandoahHeapIterationRootScanner rp;</span>
<span class="line-added">1308     rp.roots_do(&amp;oops);</span>
<span class="line-added">1309   }</span>
1310 
1311   // Work through the oop stack to traverse heap.
1312   while (! oop_stack.is_empty()) {
1313     oop obj = oop_stack.pop();
1314     assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1315     cl-&gt;do_object(obj);
1316     obj-&gt;oop_iterate(&amp;oops);
1317   }
1318 
1319   assert(oop_stack.is_empty(), &quot;should be empty&quot;);
1320 
1321   if (!_aux_bitmap_region_special &amp;&amp; !os::uncommit_memory((char*)_aux_bitmap_region.start(), _aux_bitmap_region.byte_size())) {
1322     log_warning(gc)(&quot;Could not uncommit native memory for auxiliary marking bitmap for heap iteration&quot;);
1323   }
1324 }
1325 
1326 // Keep alive an object that was loaded with AS_NO_KEEPALIVE.
1327 void ShenandoahHeap::keep_alive(oop obj) {
1328   if (is_concurrent_mark_in_progress()) {
1329     ShenandoahBarrierSet::barrier_set()-&gt;enqueue(obj);
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahControlThread.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahPacer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
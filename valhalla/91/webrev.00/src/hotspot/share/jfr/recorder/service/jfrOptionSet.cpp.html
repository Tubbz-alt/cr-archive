<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/jfr/recorder/service/jfrOptionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;jfr/dcmd/jfrDcmds.hpp&quot;
 27 #include &quot;jfr/recorder/service/jfrMemorySizer.hpp&quot;
 28 #include &quot;jfr/recorder/service/jfrOptionSet.hpp&quot;
 29 #include &quot;jfr/utilities/jfrAllocation.hpp&quot;
 30 #include &quot;jfr/utilities/jfrTypes.hpp&quot;
 31 #include &quot;logging/log.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;runtime/java.hpp&quot;
 35 #include &quot;runtime/thread.inline.hpp&quot;
 36 #include &quot;services/diagnosticArgument.hpp&quot;
 37 #include &quot;services/diagnosticFramework.hpp&quot;
 38 #include &quot;utilities/growableArray.hpp&quot;
 39 #include &quot;utilities/ostream.hpp&quot;
 40 
 41 struct ObsoleteOption {
 42   const char* name;
 43   const char* message;
 44 };
 45 
 46 static const ObsoleteOption OBSOLETE_OPTIONS[] = {
 47   {&quot;checkpointbuffersize&quot;, &quot;&quot;},
 48   {&quot;maxsize&quot;,              &quot;Use -XX:StartFlightRecording=maxsize=... instead.&quot;},
 49   {&quot;maxage&quot;,               &quot;Use -XX:StartFlightRecording=maxage=... instead.&quot;},
 50   {&quot;settings&quot;,             &quot;Use -XX:StartFlightRecording=settings=... instead.&quot;},
 51   {&quot;defaultrecording&quot;,     &quot;Use -XX:StartFlightRecording=disk=false to create an in-memory recording.&quot;},
 52   {&quot;disk&quot;,                 &quot;Use -XX:StartFlightRecording=disk=... instead.&quot;},
 53   {&quot;dumponexit&quot;,           &quot;Use -XX:StartFlightRecording=dumponexit=... instead.&quot;},
 54   {&quot;dumponexitpath&quot;,       &quot;Use -XX:StartFlightRecording=filename=... instead.&quot;},
 55   {&quot;loglevel&quot;,             &quot;Use -Xlog:jfr=... instead.&quot;}
 56 };
 57 
 58 jlong JfrOptionSet::max_chunk_size() {
 59   return _max_chunk_size;
 60 }
 61 
 62 void JfrOptionSet::set_max_chunk_size(jlong value) {
 63   _max_chunk_size = value;
 64 }
 65 
 66 jlong JfrOptionSet::global_buffer_size() {
 67   return _global_buffer_size;
 68 }
 69 
 70 void JfrOptionSet::set_global_buffer_size(jlong value) {
 71   _global_buffer_size = value;
 72 }
 73 
 74 jlong JfrOptionSet::thread_buffer_size() {
 75   return _thread_buffer_size;
 76 }
 77 
 78 void JfrOptionSet::set_thread_buffer_size(jlong value) {
 79   _thread_buffer_size = value;
 80 }
 81 
 82 jlong JfrOptionSet::memory_size() {
 83   return _memory_size;
 84 }
 85 
 86 void JfrOptionSet::set_memory_size(jlong value) {
 87   _memory_size = value;
 88 }
 89 
 90 jlong JfrOptionSet::num_global_buffers() {
 91   return _num_global_buffers;
 92 }
 93 
 94 void JfrOptionSet::set_num_global_buffers(jlong value) {
 95   _num_global_buffers = value;
 96 }
 97 
 98 jint JfrOptionSet::old_object_queue_size() {
 99   return (jint)_old_object_queue_size;
100 }
101 
102 void JfrOptionSet::set_old_object_queue_size(jlong value) {
103   _old_object_queue_size = value;
104 }
105 
106 u4 JfrOptionSet::stackdepth() {
107   return _stack_depth;
108 }
109 
110 void JfrOptionSet::set_stackdepth(u4 depth) {
111   if (depth &lt; MIN_STACK_DEPTH) {
112     _stack_depth = MIN_STACK_DEPTH;
113   } else if (depth &gt; MAX_STACK_DEPTH) {
114     _stack_depth = MAX_STACK_DEPTH;
115   } else {
116     _stack_depth = depth;
117   }
118 }
119 
120 bool JfrOptionSet::sample_threads() {
121   return _sample_threads == JNI_TRUE;
122 }
123 
124 void JfrOptionSet::set_sample_threads(jboolean sample) {
125   _sample_threads = sample;
126 }
127 
128 bool JfrOptionSet::can_retransform() {
129   return _retransform == JNI_TRUE;
130 }
131 
132 void JfrOptionSet::set_retransform(jboolean value) {
133   _retransform = value;
134 }
135 
136 bool JfrOptionSet::sample_protection() {
137   return _sample_protection == JNI_TRUE;
138 }
139 
140 #ifdef ASSERT
141 void JfrOptionSet::set_sample_protection(jboolean protection) {
142   _sample_protection = protection;
143 }
144 #endif
145 
146 bool JfrOptionSet::compressed_integers() {
147   // Set this to false for debugging purposes.
148   return true;
149 }
150 
151 bool JfrOptionSet::allow_retransforms() {
152 #if INCLUDE_JVMTI
153   return true;
154 #else
155   return false;
156 #endif
157 }
158 
159 bool JfrOptionSet::allow_event_retransforms() {
160   return allow_retransforms() &amp;&amp; (DumpSharedSpaces || can_retransform());
161 }
162 
163 // default options for the dcmd parser
164 const char* const default_repository = NULL;
165 const char* const default_global_buffer_size = &quot;512k&quot;;
166 const char* const default_num_global_buffers = &quot;20&quot;;
167 const char* const default_memory_size = &quot;10m&quot;;
168 const char* const default_thread_buffer_size = &quot;8k&quot;;
169 const char* const default_max_chunk_size = &quot;12m&quot;;
170 const char* const default_sample_threads = &quot;true&quot;;
171 const char* const default_stack_depth = &quot;64&quot;;
172 const char* const default_retransform = &quot;true&quot;;
173 const char* const default_old_object_queue_size = &quot;256&quot;;
174 DEBUG_ONLY(const char* const default_sample_protection = &quot;false&quot;;)
175 
176 // statics
177 static DCmdArgument&lt;char*&gt; _dcmd_repository(
178   &quot;repository&quot;,
179   &quot;Flight recorder disk repository location&quot;,
180   &quot;STRING&quot;,
181   false,
182   default_repository);
183 
184 static DCmdArgument&lt;MemorySizeArgument&gt; _dcmd_threadbuffersize(
185   &quot;threadbuffersize&quot;,
186   &quot;Thread buffer size&quot;,
187   &quot;MEMORY SIZE&quot;,
188   false,
189   default_thread_buffer_size);
190 
191 static DCmdArgument&lt;MemorySizeArgument&gt; _dcmd_memorysize(
192   &quot;memorysize&quot;,
193   &quot;Size of memory to be used by Flight Recorder&quot;,
194   &quot;MEMORY SIZE&quot;,
195   false,
196   default_memory_size);
197 
198 static DCmdArgument&lt;MemorySizeArgument&gt; _dcmd_globalbuffersize(
199   &quot;globalbuffersize&quot;,
200   &quot;Global buffer size&quot;,
201   &quot;MEMORY SIZE&quot;,
202   false,
203   default_global_buffer_size);
204 
205 static DCmdArgument&lt;jlong&gt; _dcmd_numglobalbuffers(
206   &quot;numglobalbuffers&quot;,
207   &quot;Number of global buffers&quot;,
208   &quot;JULONG&quot;,
209   false,
210   default_num_global_buffers);
211 
212 static DCmdArgument&lt;MemorySizeArgument&gt; _dcmd_maxchunksize(
213   &quot;maxchunksize&quot;,
214   &quot;Maximum size of a single repository disk chunk&quot;,
215   &quot;MEMORY SIZE&quot;,
216   false,
217   default_max_chunk_size);
218 
219 static DCmdArgument&lt;jlong&gt; _dcmd_old_object_queue_size (
220   &quot;old-object-queue-size&quot;,
221   &quot;Maximum number of old objects to track&quot;,
222   &quot;JINT&quot;,
223   false,
224   default_old_object_queue_size);
225 
226 static DCmdArgument&lt;bool&gt; _dcmd_sample_threads(
227   &quot;samplethreads&quot;,
228   &quot;Thread sampling enable / disable (only sampling when event enabled and sampling enabled)&quot;,
229   &quot;BOOLEAN&quot;,
230   false,
231   default_sample_threads);
232 
233 #ifdef ASSERT
234 static DCmdArgument&lt;bool&gt; _dcmd_sample_protection(
235   &quot;sampleprotection&quot;,
236   &quot;Safeguard for stackwalking while sampling threads (false by default)&quot;,
237   &quot;BOOLEAN&quot;,
238   false,
239   default_sample_protection);
240 #endif
241 
242 static DCmdArgument&lt;jlong&gt; _dcmd_stackdepth(
243   &quot;stackdepth&quot;,
244   &quot;Stack depth for stacktraces (minimum 1, maximum 2048)&quot;,
245   &quot;JULONG&quot;,
246   false,
247   default_stack_depth);
248 
249 static DCmdArgument&lt;bool&gt; _dcmd_retransform(
250   &quot;retransform&quot;,
251   &quot;If event classes should be instrumented using JVMTI (by default true)&quot;,
252   &quot;BOOLEAN&quot;,
253   true,
254   default_retransform);
255 
256 static DCmdParser _parser;
257 
258 static void register_parser_options() {
259   _parser.add_dcmd_option(&amp;_dcmd_repository);
260   _parser.add_dcmd_option(&amp;_dcmd_threadbuffersize);
261   _parser.add_dcmd_option(&amp;_dcmd_memorysize);
262   _parser.add_dcmd_option(&amp;_dcmd_globalbuffersize);
263   _parser.add_dcmd_option(&amp;_dcmd_numglobalbuffers);
264   _parser.add_dcmd_option(&amp;_dcmd_maxchunksize);
265   _parser.add_dcmd_option(&amp;_dcmd_stackdepth);
266   _parser.add_dcmd_option(&amp;_dcmd_sample_threads);
267   _parser.add_dcmd_option(&amp;_dcmd_retransform);
268   _parser.add_dcmd_option(&amp;_dcmd_old_object_queue_size);
269   DEBUG_ONLY(_parser.add_dcmd_option(&amp;_dcmd_sample_protection);)
270 }
271 
272 static bool parse_flight_recorder_options_internal(TRAPS) {
273   if (FlightRecorderOptions == NULL) {
274     return true;
275   }
276   const size_t length = strlen((const char*)FlightRecorderOptions);
277   CmdLine cmdline((const char*)FlightRecorderOptions, length, true);
278   _parser.parse(&amp;cmdline, &#39;,&#39;, THREAD);
279   if (HAS_PENDING_EXCEPTION) {
280     for (int index = 0; index &lt; 9; index++) {
281       ObsoleteOption option = OBSOLETE_OPTIONS[index];
282       const char* p = strstr((const char*)FlightRecorderOptions, option.name);
283       const size_t option_length = strlen(option.name);
284       if (p != NULL &amp;&amp; p[option_length] == &#39;=&#39;) {
285         log_error(arguments) (&quot;-XX:FlightRecorderOptions=%s=... has been removed. %s&quot;, option.name, option.message);
286         return false;
287       }
288     }
289     ResourceMark rm(THREAD);
290     oop message = java_lang_Throwable::message(PENDING_EXCEPTION);
291     if (message != NULL) {
292       const char* msg = java_lang_String::as_utf8_string(message);
293       log_error(arguments) (&quot;%s&quot;, msg);
294     }
295     CLEAR_PENDING_EXCEPTION;
296     return false;
297   }
298   return true;
299 }
300 
301 jlong JfrOptionSet::_max_chunk_size = 0;
302 jlong JfrOptionSet::_global_buffer_size = 0;
303 jlong JfrOptionSet::_thread_buffer_size = 0;
304 jlong JfrOptionSet::_memory_size = 0;
305 jlong JfrOptionSet::_num_global_buffers = 0;
306 jlong JfrOptionSet::_old_object_queue_size = 0;
307 u4 JfrOptionSet::_stack_depth = STACK_DEPTH_DEFAULT;
308 jboolean JfrOptionSet::_sample_threads = JNI_TRUE;
309 jboolean JfrOptionSet::_retransform = JNI_TRUE;
310 #ifdef ASSERT
311 jboolean JfrOptionSet::_sample_protection = JNI_FALSE;
312 #else
313 jboolean JfrOptionSet::_sample_protection = JNI_TRUE;
314 #endif
315 
316 bool JfrOptionSet::initialize(Thread* thread) {
317   register_parser_options();
318   if (!parse_flight_recorder_options_internal(thread)) {
319     return false;
320   }
321   if (_dcmd_retransform.is_set()) {
322     set_retransform(_dcmd_retransform.value());
323   }
324   set_old_object_queue_size(_dcmd_old_object_queue_size.value());
325   return adjust_memory_options();
326 }
327 
328 bool JfrOptionSet::configure(TRAPS) {
329   if (FlightRecorderOptions == NULL) {
330     return true;
331   }
332   ResourceMark rm(THREAD);
333   bufferedStream st;
334   // delegate to DCmd execution
335   JfrConfigureFlightRecorderDCmd configure(&amp;st, false);
336   configure._repository_path.set_is_set(_dcmd_repository.is_set());
337   char* repo = _dcmd_repository.value();
338   if (repo != NULL) {
339     const size_t len = strlen(repo);
340     char* repo_copy = JfrCHeapObj::new_array&lt;char&gt;(len + 1);
341     if (NULL == repo_copy) {
342       return false;
343     }
344     strncpy(repo_copy, repo, len + 1);
345     configure._repository_path.set_value(repo_copy);
346   }
347 
348   configure._stack_depth.set_is_set(_dcmd_stackdepth.is_set());
349   configure._stack_depth.set_value(_dcmd_stackdepth.value());
350 
351   configure._thread_buffer_size.set_is_set(_dcmd_threadbuffersize.is_set());
352   configure._thread_buffer_size.set_value(_dcmd_threadbuffersize.value());
353 
354   configure._global_buffer_count.set_is_set(_dcmd_numglobalbuffers.is_set());
355   configure._global_buffer_count.set_value(_dcmd_numglobalbuffers.value());
356 
357   configure._global_buffer_size.set_is_set(_dcmd_globalbuffersize.is_set());
358   configure._global_buffer_size.set_value(_dcmd_globalbuffersize.value());
359 
360   configure._max_chunk_size.set_is_set(_dcmd_maxchunksize.is_set());
361   configure._max_chunk_size.set_value(_dcmd_maxchunksize.value());
362 
363   configure._memory_size.set_is_set(_dcmd_memorysize.is_set());
364   configure._memory_size.set_value(_dcmd_memorysize.value());
365 
366   configure._sample_threads.set_is_set(_dcmd_sample_threads.is_set());
367   configure._sample_threads.set_value(_dcmd_sample_threads.value());
368 
369   configure.set_verbose(false);
370   configure.execute(DCmd_Source_Internal, THREAD);
371 
372   if (HAS_PENDING_EXCEPTION) {
373     java_lang_Throwable::print(PENDING_EXCEPTION, tty);
374     CLEAR_PENDING_EXCEPTION;
375     return false;
376   }
377   return true;
378 }
379 
380 template &lt;typename Argument&gt;
381 static julong divide_with_user_unit(Argument&amp; memory_argument, julong value) {
382   if (memory_argument.value()._size != memory_argument.value()._val) {
383     switch (memory_argument.value()._multiplier) {
384     case &#39;k&#39;: case &#39;K&#39;:
385       return value / K;
386     case &#39;m&#39;: case &#39;M&#39;:
387       return value / M;
388     case &#39;g&#39;: case &#39;G&#39;:
389       return value / G;
390     }
391   }
392   return value;
393 }
394 
395 template &lt;typename Argument&gt;
396 static void log_lower_than_min_value(Argument&amp; memory_argument, julong min_value) {
397   if (memory_argument.value()._size != memory_argument.value()._val) {
398     // has multiplier
399     log_error(arguments) (
400       &quot;This value is lower than the minimum size required &quot; JULONG_FORMAT &quot;%c&quot;,
401       divide_with_user_unit(memory_argument, min_value),
402       memory_argument.value()._multiplier);
403     return;
404   }
405   log_error(arguments) (
406     &quot;This value is lower than the minimum size required &quot; JULONG_FORMAT,
407     divide_with_user_unit(memory_argument, min_value));
408 }
409 
410 template &lt;typename Argument&gt;
411 static void log_set_value(Argument&amp; memory_argument) {
412   if (memory_argument.value()._size != memory_argument.value()._val) {
413     // has multiplier
414     log_error(arguments) (
415       &quot;Value specified for option \&quot;%s\&quot; is &quot; JULONG_FORMAT &quot;%c&quot;,
416       memory_argument.name(),
417       memory_argument.value()._val,
418       memory_argument.value()._multiplier);
419     return;
420   }
421   log_error(arguments) (
422     &quot;Value specified for option \&quot;%s\&quot; is &quot; JULONG_FORMAT,
423     memory_argument.name(), memory_argument.value()._val);
424 }
425 
426 template &lt;typename MemoryArg&gt;
427 static void log_adjustments(MemoryArg&amp; original_memory_size, julong new_memory_size, const char* msg) {
428   log_trace(arguments) (
429     &quot;%s size (original) &quot; JULONG_FORMAT &quot; B (user defined: %s)&quot;,
430     msg,
431     original_memory_size.value()._size,
432     original_memory_size.is_set() ? &quot;true&quot; : &quot;false&quot;);
433   log_trace(arguments) (
434     &quot;%s size (adjusted) &quot; JULONG_FORMAT &quot; B (modified: %s)&quot;,
435     msg,
436     new_memory_size,
437     original_memory_size.value()._size != new_memory_size ? &quot;true&quot; : &quot;false&quot;);
438   log_trace(arguments) (
439     &quot;%s size (adjustment) %s&quot; JULONG_FORMAT &quot; B&quot;,
440     msg,
441     new_memory_size &lt; original_memory_size.value()._size ? &quot;-&quot; : &quot;+&quot;,
442     new_memory_size &lt; original_memory_size.value()._size ?
443     original_memory_size.value()._size - new_memory_size :
444     new_memory_size - original_memory_size.value()._size);
445 }
446 
447 // All &quot;triangular&quot; options are explicitly set
448 // check that they are congruent and not causing
449 // an ambiguous situtation
450 template &lt;typename MemoryArg, typename NumberArg&gt;
451 static bool check_for_ambiguity(MemoryArg&amp; memory_size, MemoryArg&amp; global_buffer_size, NumberArg&amp; num_global_buffers) {
452   assert(memory_size.is_set(), &quot;invariant&quot;);
453   assert(global_buffer_size.is_set(), &quot;invariant&quot;);
454   assert(num_global_buffers.is_set(), &quot;invariant&quot;);
455   const julong calc_size = global_buffer_size.value()._size * (julong)num_global_buffers.value();
456   if (calc_size != memory_size.value()._size) {
457     // ambiguous
458     log_set_value(global_buffer_size);
459     log_error(arguments) (
460       &quot;Value specified for option \&quot;%s\&quot; is &quot; JLONG_FORMAT,
461       num_global_buffers.name(), num_global_buffers.value());
462     log_set_value(memory_size);
463     log_error(arguments) (
464       &quot;These values are causing an ambiguity when trying to determine how much memory to use&quot;);
465     log_error(arguments) (&quot;\&quot;%s\&quot; * \&quot;%s\&quot; do not equal \&quot;%s\&quot;&quot;,
466       global_buffer_size.name(),
467       num_global_buffers.name(),
468       memory_size.name());
469     log_error(arguments) (
470       &quot;Try to remove one of the involved options or make sure they are unambigous&quot;);
471     return false;
472   }
473   return true;
474 }
475 
476 template &lt;typename Argument&gt;
477 static bool ensure_minimum_count(Argument&amp; buffer_count_argument, jlong min_count) {
478   if (buffer_count_argument.value() &lt; min_count) {
479     log_error(arguments) (
480       &quot;Value specified for option \&quot;%s\&quot; is &quot; JLONG_FORMAT,
481       buffer_count_argument.name(), buffer_count_argument.value());
482     log_error(arguments) (
483       &quot;This value is lower than the minimum required number &quot; JLONG_FORMAT,
484       min_count);
485     return false;
486   }
487   return true;
488 }
489 
490 // global buffer size and num global buffers specified
491 // ensure that particular combination to be ihigher than minimum memory size
492 template &lt;typename MemoryArg, typename NumberArg&gt;
493 static bool ensure_calculated_gteq(MemoryArg&amp; global_buffer_size, NumberArg&amp; num_global_buffers, julong min_value) {
494   assert(global_buffer_size.is_set(), &quot;invariant&quot;);
495   assert(num_global_buffers.is_set(), &quot;invariant&quot;);
496   const julong calc_size = global_buffer_size.value()._size * (julong)num_global_buffers.value();
497   if (calc_size &lt; min_value) {
498     log_set_value(global_buffer_size);
499     log_error(arguments) (
500       &quot;Value specified for option \&quot;%s\&quot; is &quot; JLONG_FORMAT,
501       num_global_buffers.name(), num_global_buffers.value());
502     log_error(arguments) (&quot;\&quot;%s\&quot; * \&quot;%s\&quot; (&quot; JULONG_FORMAT
503       &quot;) is lower than minimum memory size required &quot; JULONG_FORMAT,
504       global_buffer_size.name(),
505       num_global_buffers.name(),
506       calc_size,
507       min_value);
508     return false;
509   }
510   return true;
511 }
512 
513 template &lt;typename Argument&gt;
514 static bool ensure_first_gteq_second(Argument&amp; first_argument, Argument&amp; second_argument) {
515   if (second_argument.value()._size &gt; first_argument.value()._size) {
516     log_set_value(first_argument);
517     log_set_value(second_argument);
518     log_error(arguments) (
519       &quot;The value for option \&quot;%s\&quot; should not be larger than the value specified for option \&quot;%s\&quot;&quot;,
520       second_argument.name(), first_argument.name());
521     return false;
522   }
523   return true;
524 }
525 
526 static bool valid_memory_relations(const JfrMemoryOptions&amp; options) {
527   if (options.global_buffer_size_configured) {
528     if (options.memory_size_configured) {
529       if (!ensure_first_gteq_second(_dcmd_memorysize, _dcmd_globalbuffersize)) {
530         return false;
531       }
532     }
533     if (options.thread_buffer_size_configured) {
534       if (!ensure_first_gteq_second(_dcmd_globalbuffersize, _dcmd_threadbuffersize)) {
535         return false;
536       }
537     }
538     if (options.buffer_count_configured) {
539       if (!ensure_calculated_gteq(_dcmd_globalbuffersize, _dcmd_numglobalbuffers, MIN_MEMORY_SIZE)) {
540         return false;
541       }
542     }
543   }
544   return true;
545 }
546 
547 static void post_process_adjusted_memory_options(const JfrMemoryOptions&amp; options) {
548   assert(options.memory_size &gt;= MIN_MEMORY_SIZE, &quot;invariant&quot;);
549   assert(options.global_buffer_size &gt;= MIN_GLOBAL_BUFFER_SIZE, &quot;invariant&quot;);
550   assert(options.buffer_count &gt;= MIN_BUFFER_COUNT, &quot;invariant&quot;);
551   assert(options.thread_buffer_size &gt;= MIN_THREAD_BUFFER_SIZE, &quot;invariant&quot;);
552   log_adjustments(_dcmd_memorysize, options.memory_size, &quot;Memory&quot;);
553   log_adjustments(_dcmd_globalbuffersize, options.global_buffer_size, &quot;Global buffer&quot;);
554   log_adjustments(_dcmd_threadbuffersize, options.thread_buffer_size, &quot;Thread local buffer&quot;);
555   log_trace(arguments) (&quot;Number of global buffers (original) &quot; JLONG_FORMAT &quot; (user defined: %s)&quot;,
556     _dcmd_numglobalbuffers.value(),
557     _dcmd_numglobalbuffers.is_set() ? &quot;true&quot; : &quot;false&quot;);
558   log_trace(arguments) ( &quot;Number of global buffers (adjusted) &quot; JULONG_FORMAT &quot; (modified: %s)&quot;,
559     options.buffer_count,
560     _dcmd_numglobalbuffers.value() != (jlong)options.buffer_count ? &quot;true&quot; : &quot;false&quot;);
561   log_trace(arguments) (&quot;Number of global buffers (adjustment) %s&quot; JLONG_FORMAT,
562     (jlong)options.buffer_count &lt; _dcmd_numglobalbuffers.value() ? &quot;&quot; : &quot;+&quot;,
563     (jlong)options.buffer_count - _dcmd_numglobalbuffers.value());
564 
565   MemorySizeArgument adjusted_memory_size;
566   adjusted_memory_size._val = divide_with_user_unit(_dcmd_memorysize, options.memory_size);
567   adjusted_memory_size._multiplier = _dcmd_memorysize.value()._multiplier;
568   adjusted_memory_size._size = options.memory_size;
569 
570   MemorySizeArgument adjusted_global_buffer_size;
571   adjusted_global_buffer_size._val = divide_with_user_unit(_dcmd_globalbuffersize, options.global_buffer_size);
572   adjusted_global_buffer_size._multiplier = _dcmd_globalbuffersize.value()._multiplier;
573   adjusted_global_buffer_size._size = options.global_buffer_size;
574 
575   MemorySizeArgument adjusted_thread_buffer_size;
576   adjusted_thread_buffer_size._val = divide_with_user_unit(_dcmd_threadbuffersize, options.thread_buffer_size);
577   adjusted_thread_buffer_size._multiplier = _dcmd_threadbuffersize.value()._multiplier;
578   adjusted_thread_buffer_size._size = options.thread_buffer_size;
579 
580   // store back to dcmd
581   _dcmd_memorysize.set_value(adjusted_memory_size);
582   _dcmd_memorysize.set_is_set(true);
583   _dcmd_globalbuffersize.set_value(adjusted_global_buffer_size);
584   _dcmd_globalbuffersize.set_is_set(true);
585   _dcmd_numglobalbuffers.set_value((jlong)options.buffer_count);
586   _dcmd_numglobalbuffers.set_is_set(true);
587   _dcmd_threadbuffersize.set_value(adjusted_thread_buffer_size);
588   _dcmd_threadbuffersize.set_is_set(true);
589 }
590 
591 static void initialize_memory_options_from_dcmd(JfrMemoryOptions&amp; options) {
592   options.memory_size = _dcmd_memorysize.value()._size;
593   options.global_buffer_size = MAX2&lt;julong&gt;(_dcmd_globalbuffersize.value()._size, (julong)os::vm_page_size());
594   options.buffer_count = (julong)_dcmd_numglobalbuffers.value();
595   options.thread_buffer_size = MAX2&lt;julong&gt;(_dcmd_threadbuffersize.value()._size, (julong)os::vm_page_size());
596   // determine which options have been explicitly set
597   options.memory_size_configured = _dcmd_memorysize.is_set();
598   options.global_buffer_size_configured = _dcmd_globalbuffersize.is_set();
599   options.buffer_count_configured = _dcmd_numglobalbuffers.is_set();
600   options.thread_buffer_size_configured = _dcmd_threadbuffersize.is_set();
601   assert(options.memory_size &gt;= MIN_MEMORY_SIZE, &quot;invariant&quot;);
602   assert(options.global_buffer_size &gt;= MIN_GLOBAL_BUFFER_SIZE, &quot;invariant&quot;);
603   assert(options.buffer_count &gt;= MIN_BUFFER_COUNT, &quot;invariant&quot;);
604   assert(options.thread_buffer_size &gt;= MIN_THREAD_BUFFER_SIZE, &quot;invariant&quot;);
605 }
606 
607 template &lt;typename Argument&gt;
608 static bool ensure_gteq(Argument&amp; memory_argument, const jlong value) {
609   if ((jlong)memory_argument.value()._size &lt; value) {
610     log_set_value(memory_argument);
611     log_lower_than_min_value(memory_argument, value);
612     return false;
613   }
614   return true;
615 }
616 
617 static bool ensure_valid_minimum_sizes() {
618   // ensure valid minimum memory sizes
619   if (_dcmd_memorysize.is_set()) {
620     if (!ensure_gteq(_dcmd_memorysize, MIN_MEMORY_SIZE)) {
621       return false;
622     }
623   }
624   if (_dcmd_globalbuffersize.is_set()) {
625     if (!ensure_gteq(_dcmd_globalbuffersize, MIN_GLOBAL_BUFFER_SIZE)) {
626       return false;
627     }
628   }
629   if (_dcmd_numglobalbuffers.is_set()) {
630     if (!ensure_minimum_count(_dcmd_numglobalbuffers, MIN_BUFFER_COUNT)) {
631       return false;
632     }
633   }
634   if (_dcmd_threadbuffersize.is_set()) {
635     if (!ensure_gteq(_dcmd_threadbuffersize, MIN_THREAD_BUFFER_SIZE)) {
636       return false;
637     }
638   }
639   return true;
640 }
641 
642 /**
643  * Starting with the initial set of memory values from the user,
644  * sanitize, enforce min/max rules and adjust to a set of consistent options.
645  *
646  * Adjusted memory sizes will be page aligned.
647  */
648 bool JfrOptionSet::adjust_memory_options() {
649   if (!ensure_valid_minimum_sizes()) {
650     return false;
651   }
652   JfrMemoryOptions options;
653   initialize_memory_options_from_dcmd(options);
654   if (!valid_memory_relations(options)) {
655     return false;
656   }
657   if (!JfrMemorySizer::adjust_options(&amp;options)) {
658     if (!check_for_ambiguity(_dcmd_memorysize, _dcmd_globalbuffersize, _dcmd_numglobalbuffers)) {
659       return false;
660     }
661   }
662   post_process_adjusted_memory_options(options);
663   return true;
664 }
665 
666 bool JfrOptionSet::parse_flight_recorder_option(const JavaVMOption** option, char* delimiter) {
667   assert(option != NULL, &quot;invariant&quot;);
668   assert(delimiter != NULL, &quot;invariant&quot;);
669   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
670   assert(strncmp((*option)-&gt;optionString, &quot;-XX:FlightRecorderOptions&quot;, 25) == 0, &quot;invariant&quot;);
671   if (*delimiter == &#39;\0&#39;) {
672     // -XX:FlightRecorderOptions without any delimiter and values
673   } else {
674     // -XX:FlightRecorderOptions[=|:]
675     // set delimiter to &#39;=&#39;
676     *delimiter = &#39;=&#39;;
677   }
678   return false;
679 }
680 
681 static GrowableArray&lt;const char*&gt;* start_flight_recording_options_array = NULL;
682 
683 bool JfrOptionSet::parse_start_flight_recording_option(const JavaVMOption** option, char* delimiter) {
684   assert(option != NULL, &quot;invariant&quot;);
685   assert(delimiter != NULL, &quot;invariant&quot;);
686   assert((*option)-&gt;optionString != NULL, &quot;invariant&quot;);
687   assert(strncmp((*option)-&gt;optionString, &quot;-XX:StartFlightRecording&quot;, 24) == 0, &quot;invariant&quot;);
688   const char* value = NULL;
689   if (*delimiter == &#39;\0&#39;) {
690     // -XX:StartFlightRecording without any delimiter and values
691     // Add dummy value &quot;dumponexit=false&quot; so -XX:StartFlightRecording can be used without explicit values.
692     // The existing option-&gt;optionString points to stack memory so no need to deallocate.
693     const_cast&lt;JavaVMOption*&gt;(*option)-&gt;optionString = (char*)&quot;-XX:StartFlightRecording=dumponexit=false&quot;;
694     value = (*option)-&gt;optionString + 25;
695   } else {
696     // -XX:StartFlightRecording[=|:]
697     // set delimiter to &#39;=&#39;
698     *delimiter = &#39;=&#39;;
699     value = delimiter + 1;
700   }
701   assert(value != NULL, &quot;invariant&quot;);
702   const size_t value_length = strlen(value);
703 
704   if (start_flight_recording_options_array == NULL) {
705     start_flight_recording_options_array = new (ResourceObj::C_HEAP, mtTracing) GrowableArray&lt;const char*&gt;(8, mtTracing);
706   }
707   assert(start_flight_recording_options_array != NULL, &quot;invariant&quot;);
708   char* const startup_value = NEW_C_HEAP_ARRAY(char, value_length + 1, mtTracing);
709   strncpy(startup_value, value, value_length + 1);
710   assert(strncmp(startup_value, value, value_length) == 0, &quot;invariant&quot;);
711   start_flight_recording_options_array-&gt;append(startup_value);
712   return false;
713 }
714 
715 const GrowableArray&lt;const char*&gt;* JfrOptionSet::start_flight_recording_options() {
716   return start_flight_recording_options_array;
717 }
718 
719 void JfrOptionSet::release_start_flight_recording_options() {
720   if (start_flight_recording_options_array != NULL) {
721     const int length = start_flight_recording_options_array-&gt;length();
722     for (int i = 0; i &lt; length; ++i) {
723       FREE_C_HEAP_ARRAY(char, start_flight_recording_options_array-&gt;at(i));
724     }
725     delete start_flight_recording_options_array;
726     start_flight_recording_options_array = NULL;
727   }
728 }
    </pre>
  </body>
</html>
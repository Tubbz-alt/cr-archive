<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/oop.inline.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="oop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oop.inline.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 79 markWord oopDesc::cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order) {
 80   return Atomic::cmpxchg(&amp;_mark, old_mark, new_mark, order);
 81 }
 82 
 83 void oopDesc::init_mark() {
 84   set_mark(markWord::prototype_for_klass(klass()));
 85 }
 86 
 87 void oopDesc::init_mark_raw() {
 88   set_mark_raw(markWord::prototype_for_klass(klass()));
 89 }
 90 
 91 Klass* oopDesc::klass() const {
 92   if (UseCompressedClassPointers) {
 93     return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);
 94   } else {
 95     return _metadata._klass;
 96   }
 97 }
 98 
<span class="line-modified"> 99 Klass* oopDesc::klass_or_null() const volatile {</span>
100   if (UseCompressedClassPointers) {
101     return CompressedKlassPointers::decode(_metadata._compressed_klass);
102   } else {
103     return _metadata._klass;
104   }
105 }
106 
<span class="line-modified">107 Klass* oopDesc::klass_or_null_acquire() const volatile {</span>
108   if (UseCompressedClassPointers) {
<span class="line-modified">109     // Workaround for non-const load_acquire parameter.</span>
<span class="line-modified">110     const volatile narrowKlass* addr = &amp;_metadata._compressed_klass;</span>
<span class="line-removed">111     volatile narrowKlass* xaddr = const_cast&lt;volatile narrowKlass*&gt;(addr);</span>
<span class="line-removed">112     return CompressedKlassPointers::decode(Atomic::load_acquire(xaddr));</span>
113   } else {
114     return Atomic::load_acquire(&amp;_metadata._klass);
115   }
116 }
117 
118 Klass** oopDesc::klass_addr(HeapWord* mem) {
119   // Only used internally and with CMS and will not work with
120   // UseCompressedOops
121   assert(!UseCompressedClassPointers, &quot;only supported with uncompressed klass pointers&quot;);
122   ByteSize offset = byte_offset_of(oopDesc, _metadata._klass);
123   return (Klass**) (((char*)mem) + in_bytes(offset));
124 }
125 
126 narrowKlass* oopDesc::compressed_klass_addr(HeapWord* mem) {
127   assert(UseCompressedClassPointers, &quot;only called by compressed klass pointers&quot;);
128   ByteSize offset = byte_offset_of(oopDesc, _metadata._compressed_klass);
129   return (narrowKlass*) (((char*)mem) + in_bytes(offset));
130 }
131 
132 Klass** oopDesc::klass_addr() {
</pre>
</td>
<td>
<hr />
<pre>
 79 markWord oopDesc::cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order) {
 80   return Atomic::cmpxchg(&amp;_mark, old_mark, new_mark, order);
 81 }
 82 
 83 void oopDesc::init_mark() {
 84   set_mark(markWord::prototype_for_klass(klass()));
 85 }
 86 
 87 void oopDesc::init_mark_raw() {
 88   set_mark_raw(markWord::prototype_for_klass(klass()));
 89 }
 90 
 91 Klass* oopDesc::klass() const {
 92   if (UseCompressedClassPointers) {
 93     return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);
 94   } else {
 95     return _metadata._klass;
 96   }
 97 }
 98 
<span class="line-modified"> 99 Klass* oopDesc::klass_or_null() const {</span>
100   if (UseCompressedClassPointers) {
101     return CompressedKlassPointers::decode(_metadata._compressed_klass);
102   } else {
103     return _metadata._klass;
104   }
105 }
106 
<span class="line-modified">107 Klass* oopDesc::klass_or_null_acquire() const {</span>
108   if (UseCompressedClassPointers) {
<span class="line-modified">109     narrowKlass nklass = Atomic::load_acquire(&amp;_metadata._compressed_klass);</span>
<span class="line-modified">110     return CompressedKlassPointers::decode(nklass);</span>


111   } else {
112     return Atomic::load_acquire(&amp;_metadata._klass);
113   }
114 }
115 
116 Klass** oopDesc::klass_addr(HeapWord* mem) {
117   // Only used internally and with CMS and will not work with
118   // UseCompressedOops
119   assert(!UseCompressedClassPointers, &quot;only supported with uncompressed klass pointers&quot;);
120   ByteSize offset = byte_offset_of(oopDesc, _metadata._klass);
121   return (Klass**) (((char*)mem) + in_bytes(offset));
122 }
123 
124 narrowKlass* oopDesc::compressed_klass_addr(HeapWord* mem) {
125   assert(UseCompressedClassPointers, &quot;only called by compressed klass pointers&quot;);
126   ByteSize offset = byte_offset_of(oopDesc, _metadata._compressed_klass);
127   return (narrowKlass*) (((char*)mem) + in_bytes(offset));
128 }
129 
130 Klass** oopDesc::klass_addr() {
</pre>
</td>
</tr>
</table>
<center><a href="oop.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/c2_globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/services/memoryService.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/systemDictionary.hpp&quot;
 27 #include &quot;classfile/vmSymbols.hpp&quot;
 28 #include &quot;gc/shared/collectedHeap.hpp&quot;
 29 #include &quot;logging/logConfiguration.hpp&quot;
 30 #include &quot;memory/heap.hpp&quot;
 31 #include &quot;memory/memRegion.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;
 33 #include &quot;oops/oop.inline.hpp&quot;
 34 #include &quot;runtime/globals.hpp&quot;
 35 #include &quot;runtime/handles.inline.hpp&quot;
 36 #include &quot;runtime/javaCalls.hpp&quot;
 37 #include &quot;services/classLoadingService.hpp&quot;
 38 #include &quot;services/lowMemoryDetector.hpp&quot;
 39 #include &quot;services/management.hpp&quot;
 40 #include &quot;services/memoryManager.hpp&quot;
 41 #include &quot;services/memoryPool.hpp&quot;
 42 #include &quot;services/memoryService.hpp&quot;
 43 #include &quot;utilities/growableArray.hpp&quot;
 44 #include &quot;utilities/macros.hpp&quot;
 45 
 46 GrowableArray&lt;MemoryPool*&gt;* MemoryService::_pools_list =
<a name="1" id="anc1"></a><span class="line-modified"> 47   new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;MemoryPool*&gt;(init_pools_list_size, mtServiceability);</span>
 48 GrowableArray&lt;MemoryManager*&gt;* MemoryService::_managers_list =
<a name="2" id="anc2"></a><span class="line-modified"> 49   new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;MemoryManager*&gt;(init_managers_list_size, mtServiceability);</span>
 50 
 51 MemoryManager*   MemoryService::_code_cache_manager    = NULL;
 52 GrowableArray&lt;MemoryPool*&gt;* MemoryService::_code_heap_pools =
<a name="3" id="anc3"></a><span class="line-modified"> 53     new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;MemoryPool*&gt;(init_code_heap_pools_size, mtServiceability);</span>
 54 MemoryPool*      MemoryService::_metaspace_pool        = NULL;
 55 MemoryPool*      MemoryService::_compressed_class_pool = NULL;
 56 
 57 class GcThreadCountClosure: public ThreadClosure {
 58  private:
 59   int _count;
 60  public:
 61   GcThreadCountClosure() : _count(0) {};
 62   void do_thread(Thread* thread);
 63   int count() { return _count; }
 64 };
 65 
 66 void GcThreadCountClosure::do_thread(Thread* thread) {
 67   _count++;
 68 }
 69 
 70 void MemoryService::set_universe_heap(CollectedHeap* heap) {
 71   ResourceMark rm; // For internal allocations in GrowableArray.
 72 
 73   GrowableArray&lt;MemoryPool*&gt; gc_mem_pools = heap-&gt;memory_pools();
 74   _pools_list-&gt;appendAll(&amp;gc_mem_pools);
 75 
 76   // set the GC thread count
 77   GcThreadCountClosure gctcc;
 78   heap-&gt;gc_threads_do(&amp;gctcc);
 79   int count = gctcc.count();
 80 
 81   GrowableArray&lt;GCMemoryManager*&gt; gc_memory_managers = heap-&gt;memory_managers();
 82   for (int i = 0; i &lt; gc_memory_managers.length(); i++) {
 83     GCMemoryManager* gc_manager = gc_memory_managers.at(i);
 84 
 85     if (count &gt; 0) {
 86       gc_manager-&gt;set_num_gc_threads(count);
 87     }
 88     gc_manager-&gt;initialize_gc_stat_info();
 89     _managers_list-&gt;append(gc_manager);
 90   }
 91 }
 92 
 93 void MemoryService::add_code_heap_memory_pool(CodeHeap* heap, const char* name) {
 94   // Create new memory pool for this heap
 95   MemoryPool* code_heap_pool = new CodeHeapPool(heap, name, true /* support_usage_threshold */);
 96 
 97   // Append to lists
 98   _code_heap_pools-&gt;append(code_heap_pool);
 99   _pools_list-&gt;append(code_heap_pool);
100 
101   if (_code_cache_manager == NULL) {
102     // Create CodeCache memory manager
103     _code_cache_manager = MemoryManager::get_code_cache_memory_manager();
104     _managers_list-&gt;append(_code_cache_manager);
105   }
106 
107   _code_cache_manager-&gt;add_pool(code_heap_pool);
108 }
109 
110 void MemoryService::add_metaspace_memory_pools() {
111   MemoryManager* mgr = MemoryManager::get_metaspace_memory_manager();
112 
113   _metaspace_pool = new MetaspacePool();
114   mgr-&gt;add_pool(_metaspace_pool);
115   _pools_list-&gt;append(_metaspace_pool);
116 
117   if (UseCompressedClassPointers) {
118     _compressed_class_pool = new CompressedKlassSpacePool();
119     mgr-&gt;add_pool(_compressed_class_pool);
120     _pools_list-&gt;append(_compressed_class_pool);
121   }
122 
123   _managers_list-&gt;append(mgr);
124 }
125 
126 MemoryManager* MemoryService::get_memory_manager(instanceHandle mh) {
127   for (int i = 0; i &lt; _managers_list-&gt;length(); i++) {
128     MemoryManager* mgr = _managers_list-&gt;at(i);
129     if (mgr-&gt;is_manager(mh)) {
130       return mgr;
131     }
132   }
133   return NULL;
134 }
135 
136 MemoryPool* MemoryService::get_memory_pool(instanceHandle ph) {
137   for (int i = 0; i &lt; _pools_list-&gt;length(); i++) {
138     MemoryPool* pool = _pools_list-&gt;at(i);
139     if (pool-&gt;is_pool(ph)) {
140       return pool;
141     }
142   }
143   return NULL;
144 }
145 
146 void MemoryService::track_memory_usage() {
147   // Track the peak memory usage
148   for (int i = 0; i &lt; _pools_list-&gt;length(); i++) {
149     MemoryPool* pool = _pools_list-&gt;at(i);
150     pool-&gt;record_peak_memory_usage();
151   }
152 
153   // Detect low memory
154   LowMemoryDetector::detect_low_memory();
155 }
156 
157 void MemoryService::track_memory_pool_usage(MemoryPool* pool) {
158   // Track the peak memory usage
159   pool-&gt;record_peak_memory_usage();
160 
161   // Detect low memory
162   if (LowMemoryDetector::is_enabled(pool)) {
163     LowMemoryDetector::detect_low_memory(pool);
164   }
165 }
166 
167 void MemoryService::gc_begin(GCMemoryManager* manager, bool recordGCBeginTime,
168                              bool recordAccumulatedGCTime,
169                              bool recordPreGCUsage, bool recordPeakUsage) {
170 
171   manager-&gt;gc_begin(recordGCBeginTime, recordPreGCUsage, recordAccumulatedGCTime);
172 
173   // Track the peak memory usage when GC begins
174   if (recordPeakUsage) {
175     for (int i = 0; i &lt; _pools_list-&gt;length(); i++) {
176       MemoryPool* pool = _pools_list-&gt;at(i);
177       pool-&gt;record_peak_memory_usage();
178     }
179   }
180 }
181 
182 void MemoryService::gc_end(GCMemoryManager* manager, bool recordPostGCUsage,
183                            bool recordAccumulatedGCTime,
184                            bool recordGCEndTime, bool countCollection,
185                            GCCause::Cause cause,
186                            bool allMemoryPoolsAffected) {
187   // register the GC end statistics and memory usage
188   manager-&gt;gc_end(recordPostGCUsage, recordAccumulatedGCTime, recordGCEndTime,
189                   countCollection, cause, allMemoryPoolsAffected);
190 }
191 
192 void MemoryService::oops_do(OopClosure* f) {
193   int i;
194 
195   for (i = 0; i &lt; _pools_list-&gt;length(); i++) {
196     MemoryPool* pool = _pools_list-&gt;at(i);
197     pool-&gt;oops_do(f);
198   }
199   for (i = 0; i &lt; _managers_list-&gt;length(); i++) {
200     MemoryManager* mgr = _managers_list-&gt;at(i);
201     mgr-&gt;oops_do(f);
202   }
203 }
204 
205 bool MemoryService::set_verbose(bool verbose) {
206   MutexLocker m(Management_lock);
207   // verbose will be set to the previous value
208   if (verbose) {
209     LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(gc));
210   } else {
211     LogConfiguration::configure_stdout(LogLevel::Off, true, LOG_TAGS(gc));
212   }
213   ClassLoadingService::reset_trace_class_unloading();
214 
215   return verbose;
216 }
217 
218 Handle MemoryService::create_MemoryUsage_obj(MemoryUsage usage, TRAPS) {
219   InstanceKlass* ik = Management::java_lang_management_MemoryUsage_klass(CHECK_NH);
220 
221   JavaCallArguments args(10);
222   args.push_long(usage.init_size_as_jlong());
223   args.push_long(usage.used_as_jlong());
224   args.push_long(usage.committed_as_jlong());
225   args.push_long(usage.max_size_as_jlong());
226 
227   return JavaCalls::construct_new_instance(
228                           ik,
229                           vmSymbols::long_long_long_long_void_signature(),
230                           &amp;args,
231                           CHECK_NH);
232 }
233 
234 TraceMemoryManagerStats::TraceMemoryManagerStats(GCMemoryManager* gc_memory_manager,
235                                                  GCCause::Cause cause,
236                                                  bool allMemoryPoolsAffected,
237                                                  bool recordGCBeginTime,
238                                                  bool recordPreGCUsage,
239                                                  bool recordPeakUsage,
240                                                  bool recordPostGCUsage,
241                                                  bool recordAccumulatedGCTime,
242                                                  bool recordGCEndTime,
243                                                  bool countCollection) {
244   initialize(gc_memory_manager, cause, allMemoryPoolsAffected,
245              recordGCBeginTime, recordPreGCUsage, recordPeakUsage,
246              recordPostGCUsage, recordAccumulatedGCTime, recordGCEndTime,
247              countCollection);
248 }
249 
250 // for a subclass to create then initialize an instance before invoking
251 // the MemoryService
252 void TraceMemoryManagerStats::initialize(GCMemoryManager* gc_memory_manager,
253                                          GCCause::Cause cause,
254                                          bool allMemoryPoolsAffected,
255                                          bool recordGCBeginTime,
256                                          bool recordPreGCUsage,
257                                          bool recordPeakUsage,
258                                          bool recordPostGCUsage,
259                                          bool recordAccumulatedGCTime,
260                                          bool recordGCEndTime,
261                                          bool countCollection) {
262   _gc_memory_manager = gc_memory_manager;
263   _allMemoryPoolsAffected = allMemoryPoolsAffected;
264   _recordGCBeginTime = recordGCBeginTime;
265   _recordPreGCUsage = recordPreGCUsage;
266   _recordPeakUsage = recordPeakUsage;
267   _recordPostGCUsage = recordPostGCUsage;
268   _recordAccumulatedGCTime = recordAccumulatedGCTime;
269   _recordGCEndTime = recordGCEndTime;
270   _countCollection = countCollection;
271   _cause = cause;
272 
273   MemoryService::gc_begin(_gc_memory_manager, _recordGCBeginTime, _recordAccumulatedGCTime,
274                           _recordPreGCUsage, _recordPeakUsage);
275 }
276 
277 TraceMemoryManagerStats::~TraceMemoryManagerStats() {
278   MemoryService::gc_end(_gc_memory_manager, _recordPostGCUsage, _recordAccumulatedGCTime,
279                         _recordGCEndTime, _countCollection, _cause, _allMemoryPoolsAffected);
280 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
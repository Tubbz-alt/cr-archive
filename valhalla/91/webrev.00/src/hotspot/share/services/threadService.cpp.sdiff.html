<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/threadService.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memoryService.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../utilities/growableArray.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/threadService.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 572 void ThreadDumpResult::metadata_do(void f(Metadata*)) {
 573   for (ThreadSnapshot* ts = _snapshots; ts != NULL; ts = ts-&gt;next()) {
 574     ts-&gt;metadata_do(f);
 575   }
 576 }
 577 
 578 ThreadsList* ThreadDumpResult::t_list() {
 579   return _setter.list();
 580 }
 581 
 582 StackFrameInfo::StackFrameInfo(javaVFrame* jvf, bool with_lock_info) {
 583   _method = jvf-&gt;method();
 584   _bci = jvf-&gt;bci();
 585   _class_holder = _method-&gt;method_holder()-&gt;klass_holder();
 586   _locked_monitors = NULL;
 587   if (with_lock_info) {
 588     ResourceMark rm;
 589     GrowableArray&lt;MonitorInfo*&gt;* list = jvf-&gt;locked_monitors();
 590     int length = list-&gt;length();
 591     if (length &gt; 0) {
<span class="line-modified"> 592       _locked_monitors = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(length, true);</span>
 593       for (int i = 0; i &lt; length; i++) {
 594         MonitorInfo* monitor = list-&gt;at(i);
 595         assert(monitor-&gt;owner() != NULL, &quot;This monitor must have an owning object&quot;);
 596         _locked_monitors-&gt;append(monitor-&gt;owner());
 597       }
 598     }
 599   }
 600 }
 601 
 602 void StackFrameInfo::oops_do(OopClosure* f) {
 603   if (_locked_monitors != NULL) {
 604     int length = _locked_monitors-&gt;length();
 605     for (int i = 0; i &lt; length; i++) {
 606       f-&gt;do_oop((oop*) _locked_monitors-&gt;adr_at(i));
 607     }
 608   }
 609   f-&gt;do_oop(&amp;_class_holder);
 610 }
 611 
 612 void StackFrameInfo::metadata_do(void f(Metadata*)) {
</pre>
<hr />
<pre>
 629 private:
 630   ThreadStackTrace* _stack_trace;
 631   Thread* _thread;
 632 public:
 633   InflatedMonitorsClosure(Thread* t, ThreadStackTrace* st) {
 634     _thread = t;
 635     _stack_trace = st;
 636   }
 637   void do_monitor(ObjectMonitor* mid) {
 638     if (mid-&gt;owner() == _thread) {
 639       oop object = (oop) mid-&gt;object();
 640       if (!_stack_trace-&gt;is_owned_monitor_on_stack(object)) {
 641         _stack_trace-&gt;add_jni_locked_monitor(object);
 642       }
 643     }
 644   }
 645 };
 646 
 647 ThreadStackTrace::ThreadStackTrace(JavaThread* t, bool with_locked_monitors) {
 648   _thread = t;
<span class="line-modified"> 649   _frames = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;StackFrameInfo*&gt;(INITIAL_ARRAY_SIZE, true);</span>
 650   _depth = 0;
 651   _with_locked_monitors = with_locked_monitors;
 652   if (_with_locked_monitors) {
<span class="line-modified"> 653     _jni_locked_monitors = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(INITIAL_ARRAY_SIZE, true);</span>
 654   } else {
 655     _jni_locked_monitors = NULL;
 656   }
 657 }
 658 
 659 ThreadStackTrace::~ThreadStackTrace() {
 660   for (int i = 0; i &lt; _frames-&gt;length(); i++) {
 661     delete _frames-&gt;at(i);
 662   }
 663   delete _frames;
 664   if (_jni_locked_monitors != NULL) {
 665     delete _jni_locked_monitors;
 666   }
 667 }
 668 
 669 void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth) {
 670   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 671 
 672   if (_thread-&gt;has_last_Java_frame()) {
 673     RegisterMap reg_map(_thread);
</pre>
<hr />
<pre>
 759   }
 760 }
 761 
 762 
 763 ConcurrentLocksDump::~ConcurrentLocksDump() {
 764   if (_retain_map_on_free) {
 765     return;
 766   }
 767 
 768   for (ThreadConcurrentLocks* t = _map; t != NULL;)  {
 769     ThreadConcurrentLocks* tcl = t;
 770     t = t-&gt;next();
 771     delete tcl;
 772   }
 773 }
 774 
 775 void ConcurrentLocksDump::dump_at_safepoint() {
 776   // dump all locked concurrent locks
 777   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 778 
<span class="line-modified"> 779   GrowableArray&lt;oop&gt;* aos_objects = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(INITIAL_ARRAY_SIZE, true /* C_heap */);</span>
 780 
 781   // Find all instances of AbstractOwnableSynchronizer
 782   HeapInspection::find_instances_at_safepoint(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass(),
 783                                               aos_objects);
 784   // Build a map of thread to its owned AQS locks
 785   build_map(aos_objects);
 786 
 787   delete aos_objects;
 788 }
 789 
 790 
 791 // build a map of JavaThread to all its owned AbstractOwnableSynchronizer
 792 void ConcurrentLocksDump::build_map(GrowableArray&lt;oop&gt;* aos_objects) {
 793   int length = aos_objects-&gt;length();
 794   for (int i = 0; i &lt; length; i++) {
 795     oop o = aos_objects-&gt;at(i);
 796     oop owner_thread_obj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(o);
 797     if (owner_thread_obj != NULL) {
 798       // See comments in ThreadConcurrentLocks to see how this
 799       // JavaThread* is protected.
</pre>
<hr />
<pre>
 833 
 834 void ConcurrentLocksDump::print_locks_on(JavaThread* t, outputStream* st) {
 835   st-&gt;print_cr(&quot;   Locked ownable synchronizers:&quot;);
 836   ThreadConcurrentLocks* tcl = thread_concurrent_locks(t);
 837   GrowableArray&lt;instanceOop&gt;* locks = (tcl != NULL ? tcl-&gt;owned_locks() : NULL);
 838   if (locks == NULL || locks-&gt;is_empty()) {
 839     st-&gt;print_cr(&quot;\t- None&quot;);
 840     st-&gt;cr();
 841     return;
 842   }
 843 
 844   for (int i = 0; i &lt; locks-&gt;length(); i++) {
 845     instanceOop obj = locks-&gt;at(i);
 846     st-&gt;print_cr(&quot;\t- &lt;&quot; INTPTR_FORMAT &quot;&gt; (a %s)&quot;, p2i(obj), obj-&gt;klass()-&gt;external_name());
 847   }
 848   st-&gt;cr();
 849 }
 850 
 851 ThreadConcurrentLocks::ThreadConcurrentLocks(JavaThread* thread) {
 852   _thread = thread;
<span class="line-modified"> 853   _owned_locks = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;instanceOop&gt;(INITIAL_ARRAY_SIZE, true);</span>
 854   _next = NULL;
 855 }
 856 
 857 ThreadConcurrentLocks::~ThreadConcurrentLocks() {
 858   delete _owned_locks;
 859 }
 860 
 861 void ThreadConcurrentLocks::add_lock(instanceOop o) {
 862   _owned_locks-&gt;append(o);
 863 }
 864 
 865 void ThreadConcurrentLocks::oops_do(OopClosure* f) {
 866   int length = _owned_locks-&gt;length();
 867   for (int i = 0; i &lt; length; i++) {
 868     f-&gt;do_oop((oop*) _owned_locks-&gt;adr_at(i));
 869   }
 870 }
 871 
 872 ThreadStatistics::ThreadStatistics() {
 873   _contended_enter_count = 0;
</pre>
<hr />
<pre>
 945   f-&gt;do_oop(&amp;_threadObj);
 946   f-&gt;do_oop(&amp;_blocker_object);
 947   f-&gt;do_oop(&amp;_blocker_object_owner);
 948   if (_stack_trace != NULL) {
 949     _stack_trace-&gt;oops_do(f);
 950   }
 951   if (_concurrent_locks != NULL) {
 952     _concurrent_locks-&gt;oops_do(f);
 953   }
 954 }
 955 
 956 void ThreadSnapshot::metadata_do(void f(Metadata*)) {
 957   if (_stack_trace != NULL) {
 958     _stack_trace-&gt;metadata_do(f);
 959   }
 960 }
 961 
 962 
 963 DeadlockCycle::DeadlockCycle() {
 964   _is_deadlock = false;
<span class="line-modified"> 965   _threads = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;JavaThread*&gt;(INITIAL_ARRAY_SIZE, true);</span>
 966   _next = NULL;
 967 }
 968 
 969 DeadlockCycle::~DeadlockCycle() {
 970   delete _threads;
 971 }
 972 
 973 void DeadlockCycle::print_on_with(ThreadsList * t_list, outputStream* st) const {
 974   st-&gt;cr();
 975   st-&gt;print_cr(&quot;Found one Java-level deadlock:&quot;);
 976   st-&gt;print(&quot;=============================&quot;);
 977 
 978   JavaThread* currentThread;
 979   JvmtiRawMonitor* waitingToLockRawMonitor;
 980   oop waitingToLockBlocker;
 981   int len = _threads-&gt;length();
 982   for (int i = 0; i &lt; len; i++) {
 983     currentThread = _threads-&gt;at(i);
 984     // The ObjectMonitor* can&#39;t be async deflated since we are at a safepoint.
 985     ObjectMonitor* waitingToLockMonitor = currentThread-&gt;current_pending_monitor();
</pre>
</td>
<td>
<hr />
<pre>
 572 void ThreadDumpResult::metadata_do(void f(Metadata*)) {
 573   for (ThreadSnapshot* ts = _snapshots; ts != NULL; ts = ts-&gt;next()) {
 574     ts-&gt;metadata_do(f);
 575   }
 576 }
 577 
 578 ThreadsList* ThreadDumpResult::t_list() {
 579   return _setter.list();
 580 }
 581 
 582 StackFrameInfo::StackFrameInfo(javaVFrame* jvf, bool with_lock_info) {
 583   _method = jvf-&gt;method();
 584   _bci = jvf-&gt;bci();
 585   _class_holder = _method-&gt;method_holder()-&gt;klass_holder();
 586   _locked_monitors = NULL;
 587   if (with_lock_info) {
 588     ResourceMark rm;
 589     GrowableArray&lt;MonitorInfo*&gt;* list = jvf-&gt;locked_monitors();
 590     int length = list-&gt;length();
 591     if (length &gt; 0) {
<span class="line-modified"> 592       _locked_monitors = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;oop&gt;(length, mtServiceability);</span>
 593       for (int i = 0; i &lt; length; i++) {
 594         MonitorInfo* monitor = list-&gt;at(i);
 595         assert(monitor-&gt;owner() != NULL, &quot;This monitor must have an owning object&quot;);
 596         _locked_monitors-&gt;append(monitor-&gt;owner());
 597       }
 598     }
 599   }
 600 }
 601 
 602 void StackFrameInfo::oops_do(OopClosure* f) {
 603   if (_locked_monitors != NULL) {
 604     int length = _locked_monitors-&gt;length();
 605     for (int i = 0; i &lt; length; i++) {
 606       f-&gt;do_oop((oop*) _locked_monitors-&gt;adr_at(i));
 607     }
 608   }
 609   f-&gt;do_oop(&amp;_class_holder);
 610 }
 611 
 612 void StackFrameInfo::metadata_do(void f(Metadata*)) {
</pre>
<hr />
<pre>
 629 private:
 630   ThreadStackTrace* _stack_trace;
 631   Thread* _thread;
 632 public:
 633   InflatedMonitorsClosure(Thread* t, ThreadStackTrace* st) {
 634     _thread = t;
 635     _stack_trace = st;
 636   }
 637   void do_monitor(ObjectMonitor* mid) {
 638     if (mid-&gt;owner() == _thread) {
 639       oop object = (oop) mid-&gt;object();
 640       if (!_stack_trace-&gt;is_owned_monitor_on_stack(object)) {
 641         _stack_trace-&gt;add_jni_locked_monitor(object);
 642       }
 643     }
 644   }
 645 };
 646 
 647 ThreadStackTrace::ThreadStackTrace(JavaThread* t, bool with_locked_monitors) {
 648   _thread = t;
<span class="line-modified"> 649   _frames = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;StackFrameInfo*&gt;(INITIAL_ARRAY_SIZE, mtServiceability);</span>
 650   _depth = 0;
 651   _with_locked_monitors = with_locked_monitors;
 652   if (_with_locked_monitors) {
<span class="line-modified"> 653     _jni_locked_monitors = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;oop&gt;(INITIAL_ARRAY_SIZE, mtServiceability);</span>
 654   } else {
 655     _jni_locked_monitors = NULL;
 656   }
 657 }
 658 
 659 ThreadStackTrace::~ThreadStackTrace() {
 660   for (int i = 0; i &lt; _frames-&gt;length(); i++) {
 661     delete _frames-&gt;at(i);
 662   }
 663   delete _frames;
 664   if (_jni_locked_monitors != NULL) {
 665     delete _jni_locked_monitors;
 666   }
 667 }
 668 
 669 void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth) {
 670   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 671 
 672   if (_thread-&gt;has_last_Java_frame()) {
 673     RegisterMap reg_map(_thread);
</pre>
<hr />
<pre>
 759   }
 760 }
 761 
 762 
 763 ConcurrentLocksDump::~ConcurrentLocksDump() {
 764   if (_retain_map_on_free) {
 765     return;
 766   }
 767 
 768   for (ThreadConcurrentLocks* t = _map; t != NULL;)  {
 769     ThreadConcurrentLocks* tcl = t;
 770     t = t-&gt;next();
 771     delete tcl;
 772   }
 773 }
 774 
 775 void ConcurrentLocksDump::dump_at_safepoint() {
 776   // dump all locked concurrent locks
 777   assert(SafepointSynchronize::is_at_safepoint(), &quot;all threads are stopped&quot;);
 778 
<span class="line-modified"> 779   GrowableArray&lt;oop&gt;* aos_objects = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;oop&gt;(INITIAL_ARRAY_SIZE, mtServiceability);</span>
 780 
 781   // Find all instances of AbstractOwnableSynchronizer
 782   HeapInspection::find_instances_at_safepoint(SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass(),
 783                                               aos_objects);
 784   // Build a map of thread to its owned AQS locks
 785   build_map(aos_objects);
 786 
 787   delete aos_objects;
 788 }
 789 
 790 
 791 // build a map of JavaThread to all its owned AbstractOwnableSynchronizer
 792 void ConcurrentLocksDump::build_map(GrowableArray&lt;oop&gt;* aos_objects) {
 793   int length = aos_objects-&gt;length();
 794   for (int i = 0; i &lt; length; i++) {
 795     oop o = aos_objects-&gt;at(i);
 796     oop owner_thread_obj = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(o);
 797     if (owner_thread_obj != NULL) {
 798       // See comments in ThreadConcurrentLocks to see how this
 799       // JavaThread* is protected.
</pre>
<hr />
<pre>
 833 
 834 void ConcurrentLocksDump::print_locks_on(JavaThread* t, outputStream* st) {
 835   st-&gt;print_cr(&quot;   Locked ownable synchronizers:&quot;);
 836   ThreadConcurrentLocks* tcl = thread_concurrent_locks(t);
 837   GrowableArray&lt;instanceOop&gt;* locks = (tcl != NULL ? tcl-&gt;owned_locks() : NULL);
 838   if (locks == NULL || locks-&gt;is_empty()) {
 839     st-&gt;print_cr(&quot;\t- None&quot;);
 840     st-&gt;cr();
 841     return;
 842   }
 843 
 844   for (int i = 0; i &lt; locks-&gt;length(); i++) {
 845     instanceOop obj = locks-&gt;at(i);
 846     st-&gt;print_cr(&quot;\t- &lt;&quot; INTPTR_FORMAT &quot;&gt; (a %s)&quot;, p2i(obj), obj-&gt;klass()-&gt;external_name());
 847   }
 848   st-&gt;cr();
 849 }
 850 
 851 ThreadConcurrentLocks::ThreadConcurrentLocks(JavaThread* thread) {
 852   _thread = thread;
<span class="line-modified"> 853   _owned_locks = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;instanceOop&gt;(INITIAL_ARRAY_SIZE, mtServiceability);</span>
 854   _next = NULL;
 855 }
 856 
 857 ThreadConcurrentLocks::~ThreadConcurrentLocks() {
 858   delete _owned_locks;
 859 }
 860 
 861 void ThreadConcurrentLocks::add_lock(instanceOop o) {
 862   _owned_locks-&gt;append(o);
 863 }
 864 
 865 void ThreadConcurrentLocks::oops_do(OopClosure* f) {
 866   int length = _owned_locks-&gt;length();
 867   for (int i = 0; i &lt; length; i++) {
 868     f-&gt;do_oop((oop*) _owned_locks-&gt;adr_at(i));
 869   }
 870 }
 871 
 872 ThreadStatistics::ThreadStatistics() {
 873   _contended_enter_count = 0;
</pre>
<hr />
<pre>
 945   f-&gt;do_oop(&amp;_threadObj);
 946   f-&gt;do_oop(&amp;_blocker_object);
 947   f-&gt;do_oop(&amp;_blocker_object_owner);
 948   if (_stack_trace != NULL) {
 949     _stack_trace-&gt;oops_do(f);
 950   }
 951   if (_concurrent_locks != NULL) {
 952     _concurrent_locks-&gt;oops_do(f);
 953   }
 954 }
 955 
 956 void ThreadSnapshot::metadata_do(void f(Metadata*)) {
 957   if (_stack_trace != NULL) {
 958     _stack_trace-&gt;metadata_do(f);
 959   }
 960 }
 961 
 962 
 963 DeadlockCycle::DeadlockCycle() {
 964   _is_deadlock = false;
<span class="line-modified"> 965   _threads = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;JavaThread*&gt;(INITIAL_ARRAY_SIZE, mtServiceability);</span>
 966   _next = NULL;
 967 }
 968 
 969 DeadlockCycle::~DeadlockCycle() {
 970   delete _threads;
 971 }
 972 
 973 void DeadlockCycle::print_on_with(ThreadsList * t_list, outputStream* st) const {
 974   st-&gt;cr();
 975   st-&gt;print_cr(&quot;Found one Java-level deadlock:&quot;);
 976   st-&gt;print(&quot;=============================&quot;);
 977 
 978   JavaThread* currentThread;
 979   JvmtiRawMonitor* waitingToLockRawMonitor;
 980   oop waitingToLockBlocker;
 981   int len = _threads-&gt;length();
 982   for (int i = 0; i &lt; len; i++) {
 983     currentThread = _threads-&gt;at(i);
 984     // The ObjectMonitor* can&#39;t be async deflated since we are at a safepoint.
 985     ObjectMonitor* waitingToLockMonitor = currentThread-&gt;current_pending_monitor();
</pre>
</td>
</tr>
</table>
<center><a href="memoryService.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../utilities/growableArray.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
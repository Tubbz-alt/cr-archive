<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/systemDictionaryShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/classFileStream.hpp&quot;
  27 #include &quot;classfile/classListParser.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/javaClasses.hpp&quot;
  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/systemDictionary.hpp&quot;
  36 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  37 #include &quot;classfile/verificationType.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;jfr/jfrEvents.hpp&quot;
  40 #include &quot;logging/log.hpp&quot;
  41 #include &quot;memory/allocation.hpp&quot;
  42 #include &quot;memory/archiveUtils.hpp&quot;
  43 #include &quot;memory/dynamicArchive.hpp&quot;
  44 #include &quot;memory/filemap.hpp&quot;
  45 #include &quot;memory/heapShared.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/metaspaceClosure.hpp&quot;
  48 #include &quot;memory/oopFactory.hpp&quot;
  49 #include &quot;memory/resourceArea.hpp&quot;
  50 #include &quot;memory/universe.hpp&quot;
  51 #include &quot;oops/instanceKlass.hpp&quot;
  52 #include &quot;oops/klass.inline.hpp&quot;
  53 #include &quot;oops/objArrayOop.inline.hpp&quot;
  54 #include &quot;oops/oop.inline.hpp&quot;
  55 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  56 #include &quot;runtime/handles.inline.hpp&quot;
  57 #include &quot;runtime/java.hpp&quot;
  58 #include &quot;runtime/javaCalls.hpp&quot;
  59 #include &quot;runtime/mutexLocker.hpp&quot;
  60 #include &quot;utilities/hashtable.inline.hpp&quot;
  61 #include &quot;utilities/resourceHash.hpp&quot;
  62 #include &quot;utilities/stringUtils.hpp&quot;
  63 
  64 
  65 OopHandle SystemDictionaryShared::_shared_protection_domains;
  66 OopHandle SystemDictionaryShared::_shared_jar_urls;
  67 OopHandle SystemDictionaryShared::_shared_jar_manifests;
  68 DEBUG_ONLY(bool SystemDictionaryShared::_no_class_loading_should_happen = false;)
  69 
  70 class DumpTimeSharedClassInfo: public CHeapObj&lt;mtClass&gt; {
  71   bool                         _excluded;
  72 public:
  73   struct DTLoaderConstraint {
  74     Symbol* _name;
  75     char _loader_type1;
  76     char _loader_type2;
  77     DTLoaderConstraint(Symbol* name, char l1, char l2) : _name(name), _loader_type1(l1), _loader_type2(l2) {
  78       _name-&gt;increment_refcount();
  79     }
  80     DTLoaderConstraint() : _name(NULL), _loader_type1(&#39;0&#39;), _loader_type2(&#39;0&#39;) {}
  81     bool equals(const DTLoaderConstraint&amp; t) {
  82       return t._name == _name &amp;&amp;
  83              ((t._loader_type1 == _loader_type1 &amp;&amp; t._loader_type2 == _loader_type2) ||
  84               (t._loader_type2 == _loader_type1 &amp;&amp; t._loader_type1 == _loader_type2));
  85     }
  86   };
  87 
  88   struct DTVerifierConstraint {
  89     Symbol* _name;
  90     Symbol* _from_name;
  91     DTVerifierConstraint() : _name(NULL), _from_name(NULL) {}
  92     DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {
  93       _name-&gt;increment_refcount();
  94       _from_name-&gt;increment_refcount();
  95     }
  96   };
  97 
  98   InstanceKlass*               _klass;
  99   bool                         _failed_verification;
 100   bool                         _is_archived_lambda_proxy;
 101   int                          _id;
 102   int                          _clsfile_size;
 103   int                          _clsfile_crc32;
 104   GrowableArray&lt;DTVerifierConstraint&gt;* _verifier_constraints;
 105   GrowableArray&lt;char&gt;*                 _verifier_constraint_flags;
 106   GrowableArray&lt;DTLoaderConstraint&gt;* _loader_constraints;
 107 
 108   DumpTimeSharedClassInfo() {
 109     _klass = NULL;
 110     _failed_verification = false;
 111     _is_archived_lambda_proxy = false;
 112     _id = -1;
 113     _clsfile_size = -1;
 114     _clsfile_crc32 = -1;
 115     _excluded = false;
 116     _verifier_constraints = NULL;
 117     _verifier_constraint_flags = NULL;
 118     _loader_constraints = NULL;
 119   }
 120 
 121   void add_verification_constraint(InstanceKlass* k, Symbol* name,
 122          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);
 123   void record_linking_constraint(Symbol* name, Handle loader1, Handle loader2);
 124 
 125   bool is_builtin() {
 126     return SystemDictionaryShared::is_builtin(_klass);
 127   }
 128 
 129   int num_verifier_constraints() {
 130     if (_verifier_constraint_flags != NULL) {
 131       return _verifier_constraint_flags-&gt;length();
 132     } else {
 133       return 0;
 134     }
 135   }
 136 
 137   int num_loader_constraints() {
 138     if (_loader_constraints != NULL) {
 139       return _loader_constraints-&gt;length();
 140     } else {
 141       return 0;
 142     }
 143   }
 144 
 145   void metaspace_pointers_do(MetaspaceClosure* it) {
 146     it-&gt;push(&amp;_klass);
 147     if (_verifier_constraints != NULL) {
 148       for (int i = 0; i &lt; _verifier_constraints-&gt;length(); i++) {
 149         DTVerifierConstraint* cons = _verifier_constraints-&gt;adr_at(i);
 150         it-&gt;push(&amp;cons-&gt;_name);
 151         it-&gt;push(&amp;cons-&gt;_from_name);
 152       }
 153     }
 154     if (_loader_constraints != NULL) {
 155       for (int i = 0; i &lt; _loader_constraints-&gt;length(); i++) {
 156         DTLoaderConstraint* lc = _loader_constraints-&gt;adr_at(i);
 157         it-&gt;push(&amp;lc-&gt;_name);
 158       }
 159     }
 160   }
 161 
 162   void set_excluded() {
 163     _excluded = true;
 164   }
 165 
 166   bool is_excluded() {
 167     // _klass may become NULL due to DynamicArchiveBuilder::set_to_null
 168     return _excluded || _failed_verification || _klass == NULL;
 169   }
 170 
 171   void set_failed_verification() {
 172     _failed_verification = true;
 173   }
 174 
 175   bool failed_verification() {
 176     return _failed_verification;
 177   }
 178 };
 179 
 180 inline unsigned DumpTimeSharedClassTable_hash(InstanceKlass* const&amp; k) {
 181   if (DumpSharedSpaces) {
 182     // Deterministic archive contents
 183     uintx delta = k-&gt;name() - MetaspaceShared::symbol_rs_base();
 184     return primitive_hash&lt;uintx&gt;(delta);
 185   } else {
 186     // Deterministic archive is not possible because classes can be loaded
 187     // in multiple threads.
 188     return primitive_hash&lt;InstanceKlass*&gt;(k);
 189   }
 190 }
 191 
 192 class DumpTimeSharedClassTable: public ResourceHashtable&lt;
 193   InstanceKlass*,
 194   DumpTimeSharedClassInfo,
 195   &amp;DumpTimeSharedClassTable_hash,
 196   primitive_equals&lt;InstanceKlass*&gt;,
 197   15889, // prime number
 198   ResourceObj::C_HEAP&gt;
 199 {
 200   int _builtin_count;
 201   int _unregistered_count;
 202 public:
 203   DumpTimeSharedClassInfo* find_or_allocate_info_for(InstanceKlass* k) {
 204     bool created = false;
 205     DumpTimeSharedClassInfo* p = put_if_absent(k, &amp;created);
 206     if (created) {
 207       assert(!SystemDictionaryShared::no_class_loading_should_happen(),
 208              &quot;no new classes can be loaded while dumping archive&quot;);
 209       p-&gt;_klass = k;
 210     } else {
 211       assert(p-&gt;_klass == k, &quot;Sanity&quot;);
 212     }
 213     return p;
 214   }
 215 
 216   class CountClassByCategory : StackObj {
 217     DumpTimeSharedClassTable* _table;
 218   public:
 219     CountClassByCategory(DumpTimeSharedClassTable* table) : _table(table) {}
 220     bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
 221       if (!info.is_excluded()) {
 222         if (info.is_builtin()) {
 223           ++ _table-&gt;_builtin_count;
 224         } else {
 225           ++ _table-&gt;_unregistered_count;
 226         }
 227       }
 228       return true; // keep on iterating
 229     }
 230   };
 231 
 232   void update_counts() {
 233     _builtin_count = 0;
 234     _unregistered_count = 0;
 235     CountClassByCategory counter(this);
 236     iterate(&amp;counter);
 237   }
 238 
 239   int count_of(bool is_builtin) const {
 240     if (is_builtin) {
 241       return _builtin_count;
 242     } else {
 243       return _unregistered_count;
 244     }
 245   }
 246 };
 247 
 248 class LambdaProxyClassKey {
 249   template &lt;typename T&gt; static void original_to_target(T&amp; field) {
 250     if (field != NULL) {
 251       field = DynamicArchive::original_to_target(field);
 252       ArchivePtrMarker::mark_pointer(&amp;field);
 253     }
 254   }
 255 
 256   InstanceKlass* _caller_ik;
 257   Symbol*        _invoked_name;
 258   Symbol*        _invoked_type;
 259   Symbol*        _method_type;
 260   Method*        _member_method;
 261   Symbol*        _instantiated_method_type;
 262 
 263 public:
 264   LambdaProxyClassKey(InstanceKlass* caller_ik,
 265                       Symbol*        invoked_name,
 266                       Symbol*        invoked_type,
 267                       Symbol*        method_type,
 268                       Method*        member_method,
 269                       Symbol*        instantiated_method_type) :
 270     _caller_ik(caller_ik),
 271     _invoked_name(invoked_name),
 272     _invoked_type(invoked_type),
 273     _method_type(method_type),
 274     _member_method(member_method),
 275     _instantiated_method_type(instantiated_method_type) {}
 276 
 277   void original_to_target() {
 278     original_to_target(_caller_ik);
 279     original_to_target(_instantiated_method_type);
 280     original_to_target(_invoked_name);
 281     original_to_target(_invoked_type);
 282     original_to_target(_member_method);
 283     original_to_target(_method_type);
 284   }
 285 
 286   bool equals(LambdaProxyClassKey const&amp; other) const {
 287     return _caller_ik == other._caller_ik &amp;&amp;
 288            _invoked_name == other._invoked_name &amp;&amp;
 289            _invoked_type == other._invoked_type &amp;&amp;
 290            _method_type == other._method_type &amp;&amp;
 291            _member_method == other._member_method &amp;&amp;
 292            _instantiated_method_type == other._instantiated_method_type;
 293   }
 294 
 295   unsigned int hash() const {
 296     return SystemDictionaryShared::hash_for_shared_dictionary(_caller_ik) +
 297            SystemDictionaryShared::hash_for_shared_dictionary(_invoked_name) +
 298            SystemDictionaryShared::hash_for_shared_dictionary(_invoked_type) +
 299            SystemDictionaryShared::hash_for_shared_dictionary(_method_type) +
 300            SystemDictionaryShared::hash_for_shared_dictionary(_instantiated_method_type);
 301   }
 302 
 303   unsigned int dumptime_hash() const {
 304     return primitive_hash&lt;InstanceKlass*&gt;(_caller_ik) +
 305            primitive_hash&lt;Symbol*&gt;(_invoked_name) +
 306            primitive_hash&lt;Symbol*&gt;(_invoked_type) +
 307            primitive_hash&lt;Symbol*&gt;(_method_type) +
 308            primitive_hash&lt;Symbol*&gt;(_instantiated_method_type);
 309   }
 310 
 311   static inline unsigned int DUMPTIME_HASH(LambdaProxyClassKey const&amp; key) {
 312     return (key.dumptime_hash());
 313   }
 314 
 315   static inline bool DUMPTIME_EQUALS(
 316       LambdaProxyClassKey const&amp; k1, LambdaProxyClassKey const&amp; k2) {
 317     return (k1.equals(k2));
 318   }
 319 };
 320 
 321 
 322 class DumpTimeLambdaProxyClassInfo {
 323 public:
 324   GrowableArray&lt;InstanceKlass*&gt;* _proxy_klasses;
 325   DumpTimeLambdaProxyClassInfo() : _proxy_klasses(NULL) {}
 326   void add_proxy_klass(InstanceKlass* proxy_klass) {
 327     if (_proxy_klasses == NULL) {
<a name="1" id="anc1"></a><span class="line-modified"> 328       _proxy_klasses = new (ResourceObj::C_HEAP, mtInternal)GrowableArray&lt;InstanceKlass*&gt;(5, true);</span>
 329     }
 330     assert(_proxy_klasses != NULL, &quot;sanity&quot;);
 331     _proxy_klasses-&gt;append(proxy_klass);
 332   }
 333 };
 334 
 335 class RunTimeLambdaProxyClassInfo {
 336   LambdaProxyClassKey _key;
 337   InstanceKlass* _proxy_klass_head;
 338 public:
 339   RunTimeLambdaProxyClassInfo(LambdaProxyClassKey key, InstanceKlass* proxy_klass) :
 340     _key(key), _proxy_klass_head(proxy_klass) {}
 341 
 342   InstanceKlass* proxy_klass_head() const { return _proxy_klass_head; }
 343 
 344   // Used by LambdaProxyClassDictionary to implement OffsetCompactHashtable::EQUALS
 345   static inline bool EQUALS(
 346        const RunTimeLambdaProxyClassInfo* value, LambdaProxyClassKey* key, int len_unused) {
 347     return (value-&gt;_key.equals(*key));
 348   }
 349   void init(LambdaProxyClassKey&amp; key, DumpTimeLambdaProxyClassInfo&amp; info) {
 350     _key = key;
 351     _key.original_to_target();
 352     _proxy_klass_head = DynamicArchive::original_to_target(info._proxy_klasses-&gt;at(0));
 353     ArchivePtrMarker::mark_pointer(&amp;_proxy_klass_head);
 354   }
 355 
 356   unsigned int hash() const {
 357     return _key.hash();
 358   }
 359 };
 360 
 361 class LambdaProxyClassDictionary : public OffsetCompactHashtable&lt;
 362   LambdaProxyClassKey*,
 363   const RunTimeLambdaProxyClassInfo*,
 364   RunTimeLambdaProxyClassInfo::EQUALS&gt; {};
 365 
 366 LambdaProxyClassDictionary _lambda_proxy_class_dictionary;
 367 
 368 class DumpTimeLambdaProxyClassDictionary
 369   : public ResourceHashtable&lt;LambdaProxyClassKey,
 370                              DumpTimeLambdaProxyClassInfo,
 371                              LambdaProxyClassKey::DUMPTIME_HASH,
 372                              LambdaProxyClassKey::DUMPTIME_EQUALS,
 373                              137, // prime number
 374                              ResourceObj::C_HEAP&gt; {
 375 public:
 376   int _count;
 377 };
 378 
 379 DumpTimeLambdaProxyClassDictionary* _dumptime_lambda_proxy_class_dictionary = NULL;
 380 
 381 static void add_to_dump_time_lambda_proxy_class_dictionary(LambdaProxyClassKey key,
 382                                                            InstanceKlass* proxy_klass) {
 383   assert(DumpTimeTable_lock-&gt;owned_by_self(), &quot;sanity&quot;);
 384   if (_dumptime_lambda_proxy_class_dictionary == NULL) {
 385     _dumptime_lambda_proxy_class_dictionary =
 386       new (ResourceObj::C_HEAP, mtClass)DumpTimeLambdaProxyClassDictionary();
 387   }
 388   DumpTimeLambdaProxyClassInfo* lambda_info = _dumptime_lambda_proxy_class_dictionary-&gt;get(key);
 389   if (lambda_info == NULL) {
 390     DumpTimeLambdaProxyClassInfo info;
 391     info.add_proxy_klass(proxy_klass);
 392     _dumptime_lambda_proxy_class_dictionary-&gt;put(key, info);
 393     //lambda_info = _dumptime_lambda_proxy_class_dictionary-&gt;get(key);
 394     //assert(lambda_info-&gt;_proxy_klass == proxy_klass, &quot;must be&quot;); // debug only -- remove
 395     ++_dumptime_lambda_proxy_class_dictionary-&gt;_count;
 396   } else {
 397     lambda_info-&gt;add_proxy_klass(proxy_klass);
 398   }
 399 }
 400 
 401 class RunTimeSharedClassInfo {
 402 public:
 403   struct CrcInfo {
 404     int _clsfile_size;
 405     int _clsfile_crc32;
 406   };
 407 
 408   // This is different than  DumpTimeSharedClassInfo::DTVerifierConstraint. We use
 409   // u4 instead of Symbol* to save space on 64-bit CPU.
 410   struct RTVerifierConstraint {
 411     u4 _name;
 412     u4 _from_name;
 413     Symbol* name() { return (Symbol*)(SharedBaseAddress + _name);}
 414     Symbol* from_name() { return (Symbol*)(SharedBaseAddress + _from_name); }
 415   };
 416 
 417   struct RTLoaderConstraint {
 418     u4   _name;
 419     char _loader_type1;
 420     char _loader_type2;
 421     Symbol* constraint_name() {
 422       return (Symbol*)(SharedBaseAddress + _name);
 423     }
 424   };
 425 
 426   InstanceKlass* _klass;
 427   int _num_verifier_constraints;
 428   int _num_loader_constraints;
 429 
 430   // optional CrcInfo              _crc;  (only for UNREGISTERED classes)
 431   // optional InstanceKlass*       _nest_host
 432   // optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]
 433   // optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]
 434   // optional char                 _verifier_constraint_flags[_num_verifier_constraints]
 435 
 436 private:
 437   static size_t header_size_size() {
 438     return sizeof(RunTimeSharedClassInfo);
 439   }
 440   static size_t crc_size(InstanceKlass* klass) {
 441     if (!SystemDictionaryShared::is_builtin(klass)) {
 442       return sizeof(CrcInfo);
 443     } else {
 444       return 0;
 445     }
 446   }
 447   static size_t verifier_constraints_size(int num_verifier_constraints) {
 448     return sizeof(RTVerifierConstraint) * num_verifier_constraints;
 449   }
 450   static size_t verifier_constraint_flags_size(int num_verifier_constraints) {
 451     return sizeof(char) * num_verifier_constraints;
 452   }
 453   static size_t loader_constraints_size(int num_loader_constraints) {
 454     return sizeof(RTLoaderConstraint) * num_loader_constraints;
 455   }
 456   static size_t nest_host_size(InstanceKlass* klass) {
 457     if (klass-&gt;is_hidden()) {
 458       return sizeof(InstanceKlass*);
 459     } else {
 460       return 0;
 461     }
 462   }
 463 
 464 public:
 465   static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {
 466     return header_size_size() +
 467            crc_size(klass) +
 468            nest_host_size(klass) +
 469            loader_constraints_size(num_loader_constraints) +
 470            verifier_constraints_size(num_verifier_constraints) +
 471            verifier_constraint_flags_size(num_verifier_constraints);
 472   }
 473 
 474 private:
 475   size_t crc_offset() const {
 476     return header_size_size();
 477   }
 478 
 479   size_t nest_host_offset() const {
 480       return crc_offset() + crc_size(_klass);
 481   }
 482 
 483   size_t loader_constraints_offset() const  {
 484     return nest_host_offset() + nest_host_size(_klass);
 485   }
 486   size_t verifier_constraints_offset() const {
 487     return loader_constraints_offset() + loader_constraints_size(_num_loader_constraints);
 488   }
 489   size_t verifier_constraint_flags_offset() const {
 490     return verifier_constraints_offset() + verifier_constraints_size(_num_verifier_constraints);
 491   }
 492 
 493   void check_verifier_constraint_offset(int i) const {
 494     assert(0 &lt;= i &amp;&amp; i &lt; _num_verifier_constraints, &quot;sanity&quot;);
 495   }
 496 
 497   void check_loader_constraint_offset(int i) const {
 498     assert(0 &lt;= i &amp;&amp; i &lt; _num_loader_constraints, &quot;sanity&quot;);
 499   }
 500 
 501 public:
 502   CrcInfo* crc() const {
 503     assert(crc_size(_klass) &gt; 0, &quot;must be&quot;);
 504     return (CrcInfo*)(address(this) + crc_offset());
 505   }
 506   RTVerifierConstraint* verifier_constraints() {
 507     assert(_num_verifier_constraints &gt; 0, &quot;sanity&quot;);
 508     return (RTVerifierConstraint*)(address(this) + verifier_constraints_offset());
 509   }
 510   RTVerifierConstraint* verifier_constraint_at(int i) {
 511     check_verifier_constraint_offset(i);
 512     return verifier_constraints() + i;
 513   }
 514 
 515   char* verifier_constraint_flags() {
 516     assert(_num_verifier_constraints &gt; 0, &quot;sanity&quot;);
 517     return (char*)(address(this) + verifier_constraint_flags_offset());
 518   }
 519 
 520   InstanceKlass** nest_host_addr() {
 521     assert(_klass-&gt;is_hidden(), &quot;sanity&quot;);
 522     return (InstanceKlass**)(address(this) + nest_host_offset());
 523   }
 524   InstanceKlass* nest_host() {
 525     return *nest_host_addr();
 526   }
 527   void set_nest_host(InstanceKlass* k) {
 528     *nest_host_addr() = k;
 529     ArchivePtrMarker::mark_pointer((address*)nest_host_addr());
 530   }
 531 
 532   RTLoaderConstraint* loader_constraints() {
 533     assert(_num_loader_constraints &gt; 0, &quot;sanity&quot;);
 534     return (RTLoaderConstraint*)(address(this) + loader_constraints_offset());
 535   }
 536 
 537   RTLoaderConstraint* loader_constraint_at(int i) {
 538     check_loader_constraint_offset(i);
 539     return loader_constraints() + i;
 540   }
 541 
 542   static u4 object_delta_u4(Symbol* sym) {
 543     if (DynamicDumpSharedSpaces) {
 544       sym = DynamicArchive::original_to_target(sym);
 545     }
 546     return MetaspaceShared::object_delta_u4(sym);
 547   }
 548 
 549   void init(DumpTimeSharedClassInfo&amp; info) {
 550     _klass = info._klass;
 551     if (!SystemDictionaryShared::is_builtin(_klass)) {
 552       CrcInfo* c = crc();
 553       c-&gt;_clsfile_size = info._clsfile_size;
 554       c-&gt;_clsfile_crc32 = info._clsfile_crc32;
 555     }
 556     _num_verifier_constraints = info.num_verifier_constraints();
 557     _num_loader_constraints   = info.num_loader_constraints();
 558     int i;
 559     if (_num_verifier_constraints &gt; 0) {
 560       RTVerifierConstraint* vf_constraints = verifier_constraints();
 561       char* flags = verifier_constraint_flags();
 562       for (i = 0; i &lt; _num_verifier_constraints; i++) {
 563         vf_constraints[i]._name      = object_delta_u4(info._verifier_constraints-&gt;at(i)._name);
 564         vf_constraints[i]._from_name = object_delta_u4(info._verifier_constraints-&gt;at(i)._from_name);
 565       }
 566       for (i = 0; i &lt; _num_verifier_constraints; i++) {
 567         flags[i] = info._verifier_constraint_flags-&gt;at(i);
 568       }
 569     }
 570 
 571     if (_num_loader_constraints &gt; 0) {
 572       RTLoaderConstraint* ld_constraints = loader_constraints();
 573       for (i = 0; i &lt; _num_loader_constraints; i++) {
 574         ld_constraints[i]._name = object_delta_u4(info._loader_constraints-&gt;at(i)._name);
 575         ld_constraints[i]._loader_type1 = info._loader_constraints-&gt;at(i)._loader_type1;
 576         ld_constraints[i]._loader_type2 = info._loader_constraints-&gt;at(i)._loader_type2;
 577       }
 578     }
 579     if (DynamicDumpSharedSpaces) {
 580       if (_klass-&gt;is_hidden()) {
 581         Thread* THREAD = Thread::current();
 582         InstanceKlass* n_h = _klass-&gt;nest_host(THREAD);
 583         n_h = DynamicArchive::original_to_target(n_h);
 584         set_nest_host(n_h);
 585       }
 586       _klass = DynamicArchive::original_to_target(info._klass);
 587     }
 588     ArchivePtrMarker::mark_pointer(&amp;_klass);
 589   }
 590 
 591   bool matches(int clsfile_size, int clsfile_crc32) const {
 592     return crc()-&gt;_clsfile_size  == clsfile_size &amp;&amp;
 593            crc()-&gt;_clsfile_crc32 == clsfile_crc32;
 594   }
 595 
 596   char verifier_constraint_flag(int i) {
 597     check_verifier_constraint_offset(i);
 598     return verifier_constraint_flags()[i];
 599   }
 600 
 601 private:
 602   // ArchiveCompactor::allocate() has reserved a pointer immediately before
 603   // archived InstanceKlasses. We can use this slot to do a quick
 604   // lookup of InstanceKlass* -&gt; RunTimeSharedClassInfo* without
 605   // building a new hashtable.
 606   //
 607   //  info_pointer_addr(klass) --&gt; 0x0100   RunTimeSharedClassInfo*
 608   //  InstanceKlass* klass     --&gt; 0x0108   &lt;C++ vtbl&gt;
 609   //                               0x0110   fields from Klass ...
 610   static RunTimeSharedClassInfo** info_pointer_addr(InstanceKlass* klass) {
 611     return &amp;((RunTimeSharedClassInfo**)klass)[-1];
 612   }
 613 
 614 public:
 615   static RunTimeSharedClassInfo* get_for(InstanceKlass* klass) {
 616     assert(klass-&gt;is_shared(), &quot;don&#39;t call for non-shared class&quot;);
 617     return *info_pointer_addr(klass);
 618   }
 619   static void set_for(InstanceKlass* klass, RunTimeSharedClassInfo* record) {
 620     if (DynamicDumpSharedSpaces) {
 621       klass = DynamicArchive::original_to_buffer(klass);
 622       *info_pointer_addr(klass) = DynamicArchive::buffer_to_target(record);
 623     } else {
 624       *info_pointer_addr(klass) = record;
 625     }
 626 
 627     ArchivePtrMarker::mark_pointer(info_pointer_addr(klass));
 628   }
 629 
 630   // Used by RunTimeSharedDictionary to implement OffsetCompactHashtable::EQUALS
 631   static inline bool EQUALS(
 632        const RunTimeSharedClassInfo* value, Symbol* key, int len_unused) {
 633     return (value-&gt;_klass-&gt;name() == key);
 634   }
 635 };
 636 
 637 class RunTimeSharedDictionary : public OffsetCompactHashtable&lt;
 638   Symbol*,
 639   const RunTimeSharedClassInfo*,
 640   RunTimeSharedClassInfo::EQUALS&gt; {};
 641 
 642 static DumpTimeSharedClassTable* _dumptime_table = NULL;
 643 // SystemDictionaries in the base layer static archive
 644 static RunTimeSharedDictionary _builtin_dictionary;
 645 static RunTimeSharedDictionary _unregistered_dictionary;
 646 // SystemDictionaries in the top layer dynamic archive
 647 static RunTimeSharedDictionary _dynamic_builtin_dictionary;
 648 static RunTimeSharedDictionary _dynamic_unregistered_dictionary;
 649 
 650 oop SystemDictionaryShared::shared_protection_domain(int index) {
 651   return ((objArrayOop)_shared_protection_domains.resolve())-&gt;obj_at(index);
 652 }
 653 
 654 oop SystemDictionaryShared::shared_jar_url(int index) {
 655   return ((objArrayOop)_shared_jar_urls.resolve())-&gt;obj_at(index);
 656 }
 657 
 658 oop SystemDictionaryShared::shared_jar_manifest(int index) {
 659   return ((objArrayOop)_shared_jar_manifests.resolve())-&gt;obj_at(index);
 660 }
 661 
 662 Handle SystemDictionaryShared::get_shared_jar_manifest(int shared_path_index, TRAPS) {
 663   Handle manifest ;
 664   if (shared_jar_manifest(shared_path_index) == NULL) {
 665     SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);
 666     long size = ent-&gt;manifest_size();
 667     if (size &lt;= 0) {
 668       return Handle();
 669     }
 670 
 671     // ByteArrayInputStream bais = new ByteArrayInputStream(buf);
 672     const char* src = ent-&gt;manifest();
 673     assert(src != NULL, &quot;No Manifest data&quot;);
 674     typeArrayOop buf = oopFactory::new_byteArray(size, CHECK_NH);
 675     typeArrayHandle bufhandle(THREAD, buf);
 676     ArrayAccess&lt;&gt;::arraycopy_from_native(reinterpret_cast&lt;const jbyte*&gt;(src),
 677                                          buf, typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), size);
 678 
 679     Handle bais = JavaCalls::construct_new_instance(SystemDictionary::ByteArrayInputStream_klass(),
 680                       vmSymbols::byte_array_void_signature(),
 681                       bufhandle, CHECK_NH);
 682 
 683     // manifest = new Manifest(bais)
 684     manifest = JavaCalls::construct_new_instance(SystemDictionary::Jar_Manifest_klass(),
 685                       vmSymbols::input_stream_void_signature(),
 686                       bais, CHECK_NH);
 687     atomic_set_shared_jar_manifest(shared_path_index, manifest());
 688   }
 689 
 690   manifest = Handle(THREAD, shared_jar_manifest(shared_path_index));
 691   assert(manifest.not_null(), &quot;sanity&quot;);
 692   return manifest;
 693 }
 694 
 695 Handle SystemDictionaryShared::get_shared_jar_url(int shared_path_index, TRAPS) {
 696   Handle url_h;
 697   if (shared_jar_url(shared_path_index) == NULL) {
 698     JavaValue result(T_OBJECT);
 699     const char* path = FileMapInfo::shared_path_name(shared_path_index);
 700     Handle path_string = java_lang_String::create_from_str(path, CHECK_(url_h));
 701     Klass* classLoaders_klass =
 702         SystemDictionary::jdk_internal_loader_ClassLoaders_klass();
 703     JavaCalls::call_static(&amp;result, classLoaders_klass,
 704                            vmSymbols::toFileURL_name(),
 705                            vmSymbols::toFileURL_signature(),
 706                            path_string, CHECK_(url_h));
 707 
 708     atomic_set_shared_jar_url(shared_path_index, (oop)result.get_jobject());
 709   }
 710 
 711   url_h = Handle(THREAD, shared_jar_url(shared_path_index));
 712   assert(url_h.not_null(), &quot;sanity&quot;);
 713   return url_h;
 714 }
 715 
 716 Handle SystemDictionaryShared::get_package_name(Symbol* class_name, TRAPS) {
 717   ResourceMark rm(THREAD);
 718   Handle pkgname_string;
 719   Symbol* pkg = ClassLoader::package_from_class_name(class_name);
 720   if (pkg != NULL) { // Package prefix found
 721     const char* pkgname = pkg-&gt;as_klass_external_name();
 722     pkgname_string = java_lang_String::create_from_str(pkgname,
 723                                                        CHECK_(pkgname_string));
 724   }
 725   return pkgname_string;
 726 }
 727 
 728 // Define Package for shared app classes from JAR file and also checks for
 729 // package sealing (all done in Java code)
 730 // See http://docs.oracle.com/javase/tutorial/deployment/jar/sealman.html
 731 void SystemDictionaryShared::define_shared_package(Symbol*  class_name,
 732                                                    Handle class_loader,
 733                                                    Handle manifest,
 734                                                    Handle url,
 735                                                    TRAPS) {
 736   assert(SystemDictionary::is_system_class_loader(class_loader()), &quot;unexpected class loader&quot;);
 737   // get_package_name() returns a NULL handle if the class is in unnamed package
 738   Handle pkgname_string = get_package_name(class_name, CHECK);
 739   if (pkgname_string.not_null()) {
 740     Klass* app_classLoader_klass = SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass();
 741     JavaValue result(T_OBJECT);
 742     JavaCallArguments args(3);
 743     args.set_receiver(class_loader);
 744     args.push_oop(pkgname_string);
 745     args.push_oop(manifest);
 746     args.push_oop(url);
 747     JavaCalls::call_virtual(&amp;result, app_classLoader_klass,
 748                             vmSymbols::defineOrCheckPackage_name(),
 749                             vmSymbols::defineOrCheckPackage_signature(),
 750                             &amp;args,
 751                             CHECK);
 752   }
 753 }
 754 
 755 // Get the ProtectionDomain associated with the CodeSource from the classloader.
 756 Handle SystemDictionaryShared::get_protection_domain_from_classloader(Handle class_loader,
 757                                                                       Handle url, TRAPS) {
 758   // CodeSource cs = new CodeSource(url, null);
 759   Handle cs = JavaCalls::construct_new_instance(SystemDictionary::CodeSource_klass(),
 760                   vmSymbols::url_code_signer_array_void_signature(),
 761                   url, Handle(), CHECK_NH);
 762 
 763   // protection_domain = SecureClassLoader.getProtectionDomain(cs);
 764   Klass* secureClassLoader_klass = SystemDictionary::SecureClassLoader_klass();
 765   JavaValue obj_result(T_OBJECT);
 766   JavaCalls::call_virtual(&amp;obj_result, class_loader, secureClassLoader_klass,
 767                           vmSymbols::getProtectionDomain_name(),
 768                           vmSymbols::getProtectionDomain_signature(),
 769                           cs, CHECK_NH);
 770   return Handle(THREAD, (oop)obj_result.get_jobject());
 771 }
 772 
 773 // Returns the ProtectionDomain associated with the JAR file identified by the url.
 774 Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,
 775                                                             int shared_path_index,
 776                                                             Handle url,
 777                                                             TRAPS) {
 778   Handle protection_domain;
 779   if (shared_protection_domain(shared_path_index) == NULL) {
 780     Handle pd = get_protection_domain_from_classloader(class_loader, url, THREAD);
 781     atomic_set_shared_protection_domain(shared_path_index, pd());
 782   }
 783 
 784   // Acquire from the cache because if another thread beats the current one to
 785   // set the shared protection_domain and the atomic_set fails, the current thread
 786   // needs to get the updated protection_domain from the cache.
 787   protection_domain = Handle(THREAD, shared_protection_domain(shared_path_index));
 788   assert(protection_domain.not_null(), &quot;sanity&quot;);
 789   return protection_domain;
 790 }
 791 
 792 // Returns the ProtectionDomain associated with the moduleEntry.
 793 Handle SystemDictionaryShared::get_shared_protection_domain(Handle class_loader,
 794                                                             ModuleEntry* mod, TRAPS) {
 795   ClassLoaderData *loader_data = mod-&gt;loader_data();
 796   if (mod-&gt;shared_protection_domain() == NULL) {
 797     Symbol* location = mod-&gt;location();
 798     if (location != NULL) {
 799       Handle location_string = java_lang_String::create_from_symbol(
 800                                      location, CHECK_NH);
 801       Handle url;
 802       JavaValue result(T_OBJECT);
 803       if (location-&gt;starts_with(&quot;jrt:/&quot;)) {
 804         url = JavaCalls::construct_new_instance(SystemDictionary::URL_klass(),
 805                                                 vmSymbols::string_void_signature(),
 806                                                 location_string, CHECK_NH);
 807       } else {
 808         Klass* classLoaders_klass =
 809           SystemDictionary::jdk_internal_loader_ClassLoaders_klass();
 810         JavaCalls::call_static(&amp;result, classLoaders_klass, vmSymbols::toFileURL_name(),
 811                                vmSymbols::toFileURL_signature(),
 812                                location_string, CHECK_NH);
 813         url = Handle(THREAD, (oop)result.get_jobject());
 814       }
 815 
 816       Handle pd = get_protection_domain_from_classloader(class_loader, url,
 817                                                          CHECK_NH);
 818       mod-&gt;set_shared_protection_domain(loader_data, pd);
 819     }
 820   }
 821 
 822   Handle protection_domain(THREAD, mod-&gt;shared_protection_domain());
 823   assert(protection_domain.not_null(), &quot;sanity&quot;);
 824   return protection_domain;
 825 }
 826 
 827 // Initializes the java.lang.Package and java.security.ProtectionDomain objects associated with
 828 // the given InstanceKlass.
 829 // Returns the ProtectionDomain for the InstanceKlass.
 830 Handle SystemDictionaryShared::init_security_info(Handle class_loader, InstanceKlass* ik, PackageEntry* pkg_entry, TRAPS) {
 831   Handle pd;
 832 
 833   if (ik != NULL) {
 834     int index = ik-&gt;shared_classpath_index();
 835     assert(index &gt;= 0, &quot;Sanity&quot;);
 836     SharedClassPathEntry* ent = FileMapInfo::shared_path(index);
 837     Symbol* class_name = ik-&gt;name();
 838 
 839     if (ent-&gt;is_modules_image()) {
 840       // For shared app/platform classes originated from the run-time image:
 841       //   The ProtectionDomains are cached in the corresponding ModuleEntries
 842       //   for fast access by the VM.
 843       // all packages from module image are already created during VM bootstrap in
 844       // Modules::define_module().
 845       assert(pkg_entry != NULL, &quot;archived class in module image cannot be from unnamed package&quot;);
 846       ModuleEntry* mod_entry = pkg_entry-&gt;module();
 847       pd = get_shared_protection_domain(class_loader, mod_entry, THREAD);
 848     } else {
 849       // For shared app/platform classes originated from JAR files on the class path:
 850       //   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length
 851       //   as the shared classpath table in the shared archive (see
 852       //   FileMap::_shared_path_table in filemap.hpp for details).
 853       //
 854       //   If a shared InstanceKlass k is loaded from the class path, let
 855       //
 856       //     index = k-&gt;shared_classpath_index():
 857       //
 858       //   FileMap::_shared_path_table[index] identifies the JAR file that contains k.
 859       //
 860       //   k&#39;s protection domain is:
 861       //
 862       //     ProtectionDomain pd = _shared_protection_domains[index];
 863       //
 864       //   and k&#39;s Package is initialized using
 865       //
 866       //     manifest = _shared_jar_manifests[index];
 867       //     url = _shared_jar_urls[index];
 868       //     define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 869       //
 870       //   Note that if an element of these 3 _shared_xxx arrays is NULL, it will be initialized by
 871       //   the corresponding SystemDictionaryShared::get_shared_xxx() function.
 872       Handle manifest = get_shared_jar_manifest(index, CHECK_(pd));
 873       Handle url = get_shared_jar_url(index, CHECK_(pd));
 874       define_shared_package(class_name, class_loader, manifest, url, CHECK_(pd));
 875       pd = get_shared_protection_domain(class_loader, index, url, CHECK_(pd));
 876     }
 877   }
 878   return pd;
 879 }
 880 
 881 bool SystemDictionaryShared::is_sharing_possible(ClassLoaderData* loader_data) {
 882   oop class_loader = loader_data-&gt;class_loader();
 883   return (class_loader == NULL ||
 884           SystemDictionary::is_system_class_loader(class_loader) ||
 885           SystemDictionary::is_platform_class_loader(class_loader));
 886 }
 887 
 888 // Currently AppCDS only archives classes from the run-time image, the
 889 // -Xbootclasspath/a path, the class path, and the module path.
 890 //
 891 // Check if a shared class can be loaded by the specific classloader. Following
 892 // are the &quot;visible&quot; archived classes for different classloaders.
 893 //
 894 // NULL classloader:
 895 //   - see SystemDictionary::is_shared_class_visible()
 896 // Platform classloader:
 897 //   - Module class from runtime image. ModuleEntry must be defined in the
 898 //     classloader.
 899 // App classloader:
 900 //   - Module Class from runtime image and module path. ModuleEntry must be defined in the
 901 //     classloader.
 902 //   - Class from -cp. The class must have no PackageEntry defined in any of the
 903 //     boot/platform/app classloader, or must be in the unnamed module defined in the
 904 //     AppClassLoader.
 905 bool SystemDictionaryShared::is_shared_class_visible_for_classloader(
 906                                                      InstanceKlass* ik,
 907                                                      Handle class_loader,
 908                                                      Symbol* pkg_name,
 909                                                      PackageEntry* pkg_entry,
 910                                                      ModuleEntry* mod_entry,
 911                                                      TRAPS) {
 912   assert(class_loader.not_null(), &quot;Class loader should not be NULL&quot;);
 913   assert(Universe::is_module_initialized(), &quot;Module system is not initialized&quot;);
 914   ResourceMark rm(THREAD);
 915 
 916   int path_index = ik-&gt;shared_classpath_index();
 917   SharedClassPathEntry* ent =
 918             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
 919 
 920   if (SystemDictionary::is_platform_class_loader(class_loader())) {
 921     assert(ent != NULL, &quot;shared class for PlatformClassLoader should have valid SharedClassPathEntry&quot;);
 922     // The PlatformClassLoader can only load archived class originated from the
 923     // run-time image. The class&#39; PackageEntry/ModuleEntry must be
 924     // defined by the PlatformClassLoader.
 925     if (mod_entry != NULL) {
 926       // PackageEntry/ModuleEntry is found in the classloader. Check if the
 927       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
 928       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
 929         return true; // Module class from the runtime image
 930       }
 931     }
 932   } else if (SystemDictionary::is_system_class_loader(class_loader())) {
 933     assert(ent != NULL, &quot;shared class for system loader should have valid SharedClassPathEntry&quot;);
 934     if (pkg_name == NULL) {
 935       // The archived class is in the unnamed package. Currently, the boot image
 936       // does not contain any class in the unnamed package.
 937       assert(!ent-&gt;is_modules_image(), &quot;Class in the unnamed package must be from the classpath&quot;);
 938       if (path_index &gt;= ClassLoaderExt::app_class_paths_start_index()) {
 939         assert(path_index &lt; ClassLoaderExt::app_module_paths_start_index(), &quot;invalid path_index&quot;);
 940         return true;
 941       }
 942     } else {
 943       // Check if this is from a PackageEntry/ModuleEntry defined in the AppClassloader.
 944       if (pkg_entry == NULL) {
 945         // It&#39;s not guaranteed that the class is from the classpath if the
 946         // PackageEntry cannot be found from the AppClassloader. Need to check
 947         // the boot and platform classloader as well.
 948         ClassLoaderData* platform_loader_data =
 949           ClassLoaderData::class_loader_data_or_null(SystemDictionary::java_platform_loader()); // can be NULL during bootstrap
 950         if ((platform_loader_data == NULL ||
 951              ClassLoader::get_package_entry(pkg_name, platform_loader_data) == NULL) &amp;&amp;
 952              ClassLoader::get_package_entry(pkg_name, ClassLoaderData::the_null_class_loader_data()) == NULL) {
 953           // The PackageEntry is not defined in any of the boot/platform/app classloaders.
 954           // The archived class must from -cp path and not from the runtime image.
 955           if (!ent-&gt;is_modules_image() &amp;&amp; path_index &gt;= ClassLoaderExt::app_class_paths_start_index() &amp;&amp;
 956                                           path_index &lt; ClassLoaderExt::app_module_paths_start_index()) {
 957             return true;
 958           }
 959         }
 960       } else if (mod_entry != NULL) {
 961         // The package/module is defined in the AppClassLoader. We support
 962         // archiving application module class from the runtime image or from
 963         // a named module from a module path.
 964         // Packages from the -cp path are in the unnamed_module.
 965         if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
 966           // shared module class from runtime image
 967           return true;
 968         } else if (pkg_entry-&gt;in_unnamed_module() &amp;&amp; path_index &gt;= ClassLoaderExt::app_class_paths_start_index() &amp;&amp;
 969             path_index &lt; ClassLoaderExt::app_module_paths_start_index()) {
 970           // shared class from -cp
 971           DEBUG_ONLY( \
 972             ClassLoaderData* loader_data = class_loader_data(class_loader); \
 973             assert(mod_entry == loader_data-&gt;unnamed_module(), &quot;the unnamed module is not defined in the classloader&quot;);)
 974           return true;
 975         } else {
 976           if(!pkg_entry-&gt;in_unnamed_module() &amp;&amp;
 977               (path_index &gt;= ClassLoaderExt::app_module_paths_start_index())&amp;&amp;
 978               (path_index &lt; FileMapInfo::get_number_of_shared_paths()) &amp;&amp;
 979               (strcmp(ent-&gt;name(), ClassLoader::skip_uri_protocol(mod_entry-&gt;location()-&gt;as_C_string())) == 0)) {
 980             // shared module class from module path
 981             return true;
 982           } else {
 983             assert(path_index &lt; FileMapInfo::get_number_of_shared_paths(), &quot;invalid path_index&quot;);
 984           }
 985         }
 986       }
 987     }
 988   } else {
 989     // TEMP: if a shared class can be found by a custom loader, consider it visible now.
 990     // FIXME: is this actually correct?
 991     return true;
 992   }
 993   return false;
 994 }
 995 
 996 bool SystemDictionaryShared::has_platform_or_app_classes() {
 997   if (FileMapInfo::current_info()-&gt;has_platform_or_app_classes()) {
 998     return true;
 999   }
1000   if (DynamicArchive::is_mapped() &amp;&amp;
1001       FileMapInfo::dynamic_info()-&gt;has_platform_or_app_classes()) {
1002     return true;
1003   }
1004   return false;
1005 }
1006 
1007 // The following stack shows how this code is reached:
1008 //
1009 //   [0] SystemDictionaryShared::find_or_load_shared_class()
1010 //   [1] JVM_FindLoadedClass
1011 //   [2] java.lang.ClassLoader.findLoadedClass0()
1012 //   [3] java.lang.ClassLoader.findLoadedClass()
1013 //   [4] jdk.internal.loader.BuiltinClassLoader.loadClassOrNull()
1014 //   [5] jdk.internal.loader.BuiltinClassLoader.loadClass()
1015 //   [6] jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(), or
1016 //       jdk.internal.loader.ClassLoaders$PlatformClassLoader.loadClass()
1017 //
1018 // AppCDS supports fast class loading for these 2 built-in class loaders:
1019 //    jdk.internal.loader.ClassLoaders$PlatformClassLoader
1020 //    jdk.internal.loader.ClassLoaders$AppClassLoader
1021 // with the following assumptions (based on the JDK core library source code):
1022 //
1023 // [a] these two loaders use the BuiltinClassLoader.loadClassOrNull() to
1024 //     load the named class.
1025 // [b] BuiltinClassLoader.loadClassOrNull() first calls findLoadedClass(name).
1026 // [c] At this point, if we can find the named class inside the
1027 //     shared_dictionary, we can perform further checks (see
1028 //     is_shared_class_visible_for_classloader() to ensure that this class
1029 //     was loaded by the same class loader during dump time.
1030 //
1031 // Given these assumptions, we intercept the findLoadedClass() call to invoke
1032 // SystemDictionaryShared::find_or_load_shared_class() to load the shared class from
1033 // the archive for the 2 built-in class loaders. This way,
1034 // we can improve start-up because we avoid decoding the classfile,
1035 // and avoid delegating to the parent loader.
1036 //
1037 // NOTE: there&#39;s a lot of assumption about the Java code. If any of that change, this
1038 // needs to be redesigned.
1039 
1040 InstanceKlass* SystemDictionaryShared::find_or_load_shared_class(
1041                  Symbol* name, Handle class_loader, TRAPS) {
1042   InstanceKlass* k = NULL;
1043   if (UseSharedSpaces) {
1044     if (!has_platform_or_app_classes()) {
1045       return NULL;
1046     }
1047 
1048     if (SystemDictionary::is_system_class_loader(class_loader()) ||
1049         SystemDictionary::is_platform_class_loader(class_loader())) {
1050       // Fix for 4474172; see evaluation for more details
1051       class_loader = Handle(
1052         THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
1053       ClassLoaderData *loader_data = register_loader(class_loader);
1054       Dictionary* dictionary = loader_data-&gt;dictionary();
1055 
1056       unsigned int d_hash = dictionary-&gt;compute_hash(name);
1057 
1058       bool DoObjectLock = true;
1059       if (is_parallelCapable(class_loader)) {
1060         DoObjectLock = false;
1061       }
1062 
1063       // Make sure we are synchronized on the class loader before we proceed
1064       //
1065       // Note: currently, find_or_load_shared_class is called only from
1066       // JVM_FindLoadedClass and used for PlatformClassLoader and AppClassLoader,
1067       // which are parallel-capable loaders, so this lock is NOT taken.
1068       Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1069       check_loader_lock_contention(lockObject, THREAD);
1070       ObjectLocker ol(lockObject, THREAD, DoObjectLock);
1071 
1072       {
1073         MutexLocker mu(THREAD, SystemDictionary_lock);
1074         InstanceKlass* check = find_class(d_hash, name, dictionary);
1075         if (check != NULL) {
1076           return check;
1077         }
1078       }
1079 
1080       k = load_shared_class_for_builtin_loader(name, class_loader, THREAD);
1081       if (k != NULL) {
1082         define_instance_class(k, CHECK_NULL);
1083       }
1084     }
1085   }
1086   return k;
1087 }
1088 
1089 PackageEntry* SystemDictionaryShared::get_package_entry_from_class_name(Handle class_loader, Symbol* class_name) {
1090   PackageEntry* pkg_entry = NULL;
1091   TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
1092   if (pkg_name != NULL) {
1093     pkg_entry = class_loader_data(class_loader)-&gt;packages()-&gt;lookup_only(pkg_name);
1094   }
1095   return pkg_entry;
1096 }
1097 
1098 InstanceKlass* SystemDictionaryShared::load_shared_class_for_builtin_loader(
1099                  Symbol* class_name, Handle class_loader, TRAPS) {
1100   assert(UseSharedSpaces, &quot;must be&quot;);
1101   InstanceKlass* ik = find_builtin_class(class_name);
1102 
1103   if (ik != NULL) {
1104     if ((ik-&gt;is_shared_app_class() &amp;&amp;
1105          SystemDictionary::is_system_class_loader(class_loader()))  ||
1106         (ik-&gt;is_shared_platform_class() &amp;&amp;
1107          SystemDictionary::is_platform_class_loader(class_loader()))) {
1108       PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, class_name);
1109       Handle protection_domain =
1110         SystemDictionaryShared::init_security_info(class_loader, ik, pkg_entry, CHECK_NULL);
1111       return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);
1112     }
1113   }
1114   return NULL;
1115 }
1116 
1117 void SystemDictionaryShared::allocate_shared_protection_domain_array(int size, TRAPS) {
1118   if (_shared_protection_domains.resolve() == NULL) {
1119     oop spd = oopFactory::new_objArray(
1120         SystemDictionary::ProtectionDomain_klass(), size, CHECK);
1121     _shared_protection_domains = OopHandle::create(spd);
1122   }
1123 }
1124 
1125 void SystemDictionaryShared::allocate_shared_jar_url_array(int size, TRAPS) {
1126   if (_shared_jar_urls.resolve() == NULL) {
1127     oop sju = oopFactory::new_objArray(
1128         SystemDictionary::URL_klass(), size, CHECK);
1129     _shared_jar_urls = OopHandle::create(sju);
1130   }
1131 }
1132 
1133 void SystemDictionaryShared::allocate_shared_jar_manifest_array(int size, TRAPS) {
1134   if (_shared_jar_manifests.resolve() == NULL) {
1135     oop sjm = oopFactory::new_objArray(
1136         SystemDictionary::Jar_Manifest_klass(), size, CHECK);
1137     _shared_jar_manifests = OopHandle::create(sjm);
1138   }
1139 }
1140 
1141 void SystemDictionaryShared::allocate_shared_data_arrays(int size, TRAPS) {
1142   allocate_shared_protection_domain_array(size, CHECK);
1143   allocate_shared_jar_url_array(size, CHECK);
1144   allocate_shared_jar_manifest_array(size, CHECK);
1145 }
1146 
1147 // This function is called for loading only UNREGISTERED classes
1148 InstanceKlass* SystemDictionaryShared::lookup_from_stream(Symbol* class_name,
1149                                                           Handle class_loader,
1150                                                           Handle protection_domain,
1151                                                           const ClassFileStream* cfs,
1152                                                           TRAPS) {
1153   if (!UseSharedSpaces) {
1154     return NULL;
1155   }
1156   if (class_name == NULL) {  // don&#39;t do this for hidden and unsafe anonymous classes
1157     return NULL;
1158   }
1159   if (class_loader.is_null() ||
1160       SystemDictionary::is_system_class_loader(class_loader()) ||
1161       SystemDictionary::is_platform_class_loader(class_loader())) {
1162     // Do nothing for the BUILTIN loaders.
1163     return NULL;
1164   }
1165 
1166   const RunTimeSharedClassInfo* record = find_record(&amp;_unregistered_dictionary, &amp;_dynamic_unregistered_dictionary, class_name);
1167   if (record == NULL) {
1168     return NULL;
1169   }
1170 
1171   int clsfile_size  = cfs-&gt;length();
1172   int clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
1173 
1174   if (!record-&gt;matches(clsfile_size, clsfile_crc32)) {
1175     return NULL;
1176   }
1177 
1178   return acquire_class_for_current_thread(record-&gt;_klass, class_loader,
1179                                           protection_domain, cfs,
1180                                           THREAD);
1181 }
1182 
1183 InstanceKlass* SystemDictionaryShared::acquire_class_for_current_thread(
1184                    InstanceKlass *ik,
1185                    Handle class_loader,
1186                    Handle protection_domain,
1187                    const ClassFileStream *cfs,
1188                    TRAPS) {
1189   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1190 
1191   {
1192     MutexLocker mu(THREAD, SharedDictionary_lock);
1193     if (ik-&gt;class_loader_data() != NULL) {
1194       //    ik is already loaded (by this loader or by a different loader)
1195       // or ik is being loaded by a different thread (by this loader or by a different loader)
1196       return NULL;
1197     }
1198 
1199     // No other thread has acquired this yet, so give it to *this thread*
1200     ik-&gt;set_class_loader_data(loader_data);
1201   }
1202 
1203   // No longer holding SharedDictionary_lock
1204   // No need to lock, as &lt;ik&gt; can be held only by a single thread.
1205   loader_data-&gt;add_class(ik);
1206 
1207   // Get the package entry.
1208   PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, ik-&gt;name());
1209 
1210   // Load and check super/interfaces, restore unsharable info
1211   InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,
1212                                                   cfs, pkg_entry, THREAD);
1213   if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {
1214     // TODO: clean up &lt;ik&gt; so it can be used again
1215     return NULL;
1216   }
1217 
1218   return shared_klass;
1219 }
1220 
1221 static ResourceHashtable&lt;
1222   Symbol*, bool,
1223   primitive_hash&lt;Symbol*&gt;,
1224   primitive_equals&lt;Symbol*&gt;,
1225   6661,                             // prime number
1226   ResourceObj::C_HEAP&gt; _loaded_unregistered_classes;
1227 
1228 bool SystemDictionaryShared::add_unregistered_class(InstanceKlass* k, TRAPS) {
1229   // We don&#39;t allow duplicated unregistered classes of the same name.
1230   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
1231   Symbol* name = k-&gt;name();
1232   bool created = false;
1233   _loaded_unregistered_classes.put_if_absent(name, true, &amp;created);
1234   if (created) {
1235     MutexLocker mu_r(THREAD, Compile_lock); // add_to_hierarchy asserts this.
1236     SystemDictionary::add_to_hierarchy(k, CHECK_false);
1237   }
1238   return created;
1239 }
1240 
1241 // This function is called to resolve the super/interfaces of shared classes for
1242 // non-built-in loaders. E.g., ChildClass in the below example
1243 // where &quot;super:&quot; (and optionally &quot;interface:&quot;) have been specified.
1244 //
1245 // java/lang/Object id: 0
1246 // Interface   id: 2 super: 0 source: cust.jar
1247 // ChildClass  id: 4 super: 0 interfaces: 2 source: cust.jar
1248 InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(
1249     Symbol* child_name, Symbol* class_name, Handle class_loader,
1250     Handle protection_domain, bool is_superclass, TRAPS) {
1251 
1252   assert(DumpSharedSpaces, &quot;only when dumping&quot;);
1253 
1254   ClassListParser* parser = ClassListParser::instance();
1255   if (parser == NULL) {
1256     // We&#39;re still loading the well-known classes, before the ClassListParser is created.
1257     return NULL;
1258   }
1259   if (child_name-&gt;equals(parser-&gt;current_class_name())) {
1260     // When this function is called, all the numbered super and interface types
1261     // must have already been loaded. Hence this function is never recursively called.
1262     if (is_superclass) {
1263       return parser-&gt;lookup_super_for_current_class(class_name);
1264     } else {
1265       return parser-&gt;lookup_interface_for_current_class(class_name);
1266     }
1267   } else {
1268     // The VM is not trying to resolve a super type of parser-&gt;current_class_name().
1269     // Instead, it&#39;s resolving an error class (because parser-&gt;current_class_name() has
1270     // failed parsing or verification). Don&#39;t do anything here.
1271     return NULL;
1272   }
1273 }
1274 
1275 DumpTimeSharedClassInfo* SystemDictionaryShared::find_or_allocate_info_for(InstanceKlass* k) {
1276   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);
1277   if (_dumptime_table == NULL) {
1278     _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();
1279   }
1280   return _dumptime_table-&gt;find_or_allocate_info_for(k);
1281 }
1282 
1283 void SystemDictionaryShared::set_shared_class_misc_info(InstanceKlass* k, ClassFileStream* cfs) {
1284   Arguments::assert_is_dumping_archive();
1285   assert(!is_builtin(k), &quot;must be unregistered class&quot;);
1286   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
1287   info-&gt;_clsfile_size  = cfs-&gt;length();
1288   info-&gt;_clsfile_crc32 = ClassLoader::crc32(0, (const char*)cfs-&gt;buffer(), cfs-&gt;length());
1289 }
1290 
1291 void SystemDictionaryShared::init_dumptime_info(InstanceKlass* k) {
1292   (void)find_or_allocate_info_for(k);
1293 }
1294 
1295 void SystemDictionaryShared::remove_dumptime_info(InstanceKlass* k) {
1296   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);
1297   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(k);
1298   if (p == NULL) {
1299     return;
1300   }
1301   if (p-&gt;_verifier_constraints != NULL) {
1302     for (int i = 0; i &lt; p-&gt;_verifier_constraints-&gt;length(); i++) {
1303       DumpTimeSharedClassInfo::DTVerifierConstraint constraint = p-&gt;_verifier_constraints-&gt;at(i);
1304       if (constraint._name != NULL ) {
1305         constraint._name-&gt;decrement_refcount();
1306       }
1307       if (constraint._from_name != NULL ) {
1308         constraint._from_name-&gt;decrement_refcount();
1309       }
1310     }
1311     FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTVerifierConstraint, p-&gt;_verifier_constraints);
1312     p-&gt;_verifier_constraints = NULL;
1313     FREE_C_HEAP_ARRAY(char, p-&gt;_verifier_constraint_flags);
1314     p-&gt;_verifier_constraint_flags = NULL;
1315   }
1316   if (p-&gt;_loader_constraints != NULL) {
1317     for (int i = 0; i &lt; p-&gt;_loader_constraints-&gt;length(); i++) {
1318       DumpTimeSharedClassInfo::DTLoaderConstraint ld =  p-&gt;_loader_constraints-&gt;at(i);
1319       if (ld._name != NULL) {
1320         ld._name-&gt;decrement_refcount();
1321       }
1322     }
1323     FREE_C_HEAP_ARRAY(DumpTimeSharedClassInfo::DTLoaderConstraint, p-&gt;_loader_constraints);
1324     p-&gt;_loader_constraints = NULL;
1325   }
1326   _dumptime_table-&gt;remove(k);
1327 }
1328 
1329 bool SystemDictionaryShared::is_jfr_event_class(InstanceKlass *k) {
1330   while (k) {
1331     if (k-&gt;name()-&gt;equals(&quot;jdk/internal/event/Event&quot;)) {
1332       return true;
1333     }
1334     k = k-&gt;java_super();
1335   }
1336   return false;
1337 }
1338 
1339 bool SystemDictionaryShared::is_registered_lambda_proxy_class(InstanceKlass* ik) {
1340   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(ik);
1341   return (info != NULL) ? info-&gt;_is_archived_lambda_proxy : false;
1342 }
1343 
1344 bool SystemDictionaryShared::is_hidden_lambda_proxy(InstanceKlass* ik) {
1345   assert(ik-&gt;is_shared(), &quot;applicable to only a shared class&quot;);
1346   if (ik-&gt;is_hidden()) {
1347     return true;
1348   } else {
1349     return false;
1350   }
1351 }
1352 
1353 void SystemDictionaryShared::warn_excluded(InstanceKlass* k, const char* reason) {
1354   ResourceMark rm;
1355   log_warning(cds)(&quot;Skipping %s: %s&quot;, k-&gt;name()-&gt;as_C_string(), reason);
1356 }
1357 
1358 bool SystemDictionaryShared::should_be_excluded(InstanceKlass* k) {
1359 
1360   if (k-&gt;is_unsafe_anonymous()) {
1361     warn_excluded(k, &quot;Unsafe anonymous class&quot;);
1362     return true; // unsafe anonymous classes are not archived, skip
1363   }
1364 
1365   if (k-&gt;is_in_error_state()) {
1366     warn_excluded(k, &quot;In error state&quot;);
1367     return true;
1368   }
1369   if (k-&gt;has_been_redefined()) {
1370     warn_excluded(k, &quot;Has been redefined&quot;);
1371     return true;
1372   }
1373   if (!k-&gt;is_hidden() &amp;&amp; k-&gt;shared_classpath_index() &lt; 0 &amp;&amp; is_builtin(k)) {
1374     // These are classes loaded from unsupported locations (such as those loaded by JVMTI native
1375     // agent during dump time).
1376     warn_excluded(k, &quot;Unsupported location&quot;);
1377     return true;
1378   }
1379   if (k-&gt;signers() != NULL) {
1380     // We cannot include signed classes in the archive because the certificates
1381     // used during dump time may be different than those used during
1382     // runtime (due to expiration, etc).
1383     warn_excluded(k, &quot;Signed JAR&quot;);
1384     return true;
1385   }
1386   if (is_jfr_event_class(k)) {
1387     // We cannot include JFR event classes because they need runtime-specific
1388     // instrumentation in order to work with -XX:FlightRecorderOptions=retransform=false.
1389     // There are only a small number of these classes, so it&#39;s not worthwhile to
1390     // support them and make CDS more complicated.
1391     warn_excluded(k, &quot;JFR event class&quot;);
1392     return true;
1393   }
1394   if (k-&gt;init_state() &lt; InstanceKlass::linked) {
1395     // In CDS dumping, we will attempt to link all classes. Those that fail to link will
1396     // be recorded in DumpTimeSharedClassInfo.
1397     Arguments::assert_is_dumping_archive();
1398 
1399     // TODO -- rethink how this can be handled.
1400     // We should try to link ik, however, we can&#39;t do it here because
1401     // 1. We are at VM exit
1402     // 2. linking a class may cause other classes to be loaded, which means
1403     //    a custom ClassLoader.loadClass() may be called, at a point where the
1404     //    class loader doesn&#39;t expect it.
1405     if (has_class_failed_verification(k)) {
1406       warn_excluded(k, &quot;Failed verification&quot;);
1407     } else {
1408       warn_excluded(k, &quot;Not linked&quot;);
1409     }
1410     return true;
1411   }
1412   if (k-&gt;major_version() &lt; 50 /*JAVA_6_VERSION*/) {
1413     ResourceMark rm;
1414     log_warning(cds)(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
1415                      k-&gt;major_version(),  k-&gt;minor_version(), k-&gt;name()-&gt;as_C_string());
1416     return true;
1417   }
1418 
1419   InstanceKlass* super = k-&gt;java_super();
1420   if (super != NULL &amp;&amp; should_be_excluded(super)) {
1421     ResourceMark rm;
1422     log_warning(cds)(&quot;Skipping %s: super class %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), super-&gt;name()-&gt;as_C_string());
1423     return true;
1424   }
1425 
1426   if (k-&gt;is_hidden() &amp;&amp; !is_registered_lambda_proxy_class(k)) {
1427     warn_excluded(k, &quot;Hidden class&quot;);
1428     return true;
1429   }
1430 
1431   Array&lt;InstanceKlass*&gt;* interfaces = k-&gt;local_interfaces();
1432   int len = interfaces-&gt;length();
1433   for (int i = 0; i &lt; len; i++) {
1434     InstanceKlass* intf = interfaces-&gt;at(i);
1435     if (should_be_excluded(intf)) {
1436       log_warning(cds)(&quot;Skipping %s: interface %s is excluded&quot;, k-&gt;name()-&gt;as_C_string(), intf-&gt;name()-&gt;as_C_string());
1437       return true;
1438     }
1439   }
1440 
1441   return false;
1442 }
1443 
1444 // k is a class before relocating by ArchiveCompactor
1445 void SystemDictionaryShared::validate_before_archiving(InstanceKlass* k) {
1446   ResourceMark rm;
1447   const char* name = k-&gt;name()-&gt;as_C_string();
1448   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(k);
1449   assert(_no_class_loading_should_happen, &quot;class loading must be disabled&quot;);
1450   guarantee(info != NULL, &quot;Class %s must be entered into _dumptime_table&quot;, name);
1451   guarantee(!info-&gt;is_excluded(), &quot;Should not attempt to archive excluded class %s&quot;, name);
1452   if (is_builtin(k)) {
1453     if (k-&gt;is_hidden()) {
1454       assert(is_registered_lambda_proxy_class(k), &quot;unexpected hidden class %s&quot;, name);
1455     }
1456     guarantee(!k-&gt;is_shared_unregistered_class(),
1457               &quot;Class loader type must be set for BUILTIN class %s&quot;, name);
1458 
1459   } else {
1460     guarantee(k-&gt;is_shared_unregistered_class(),
1461               &quot;Class loader type must not be set for UNREGISTERED class %s&quot;, name);
1462   }
1463 }
1464 
1465 class ExcludeDumpTimeSharedClasses : StackObj {
1466 public:
1467   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1468     if (SystemDictionaryShared::should_be_excluded(k)) {
1469       info.set_excluded();
1470     }
1471     return true; // keep on iterating
1472   }
1473 };
1474 
1475 void SystemDictionaryShared::check_excluded_classes() {
1476   ExcludeDumpTimeSharedClasses excl;
1477   _dumptime_table-&gt;iterate(&amp;excl);
1478   _dumptime_table-&gt;update_counts();
1479 }
1480 
1481 bool SystemDictionaryShared::is_excluded_class(InstanceKlass* k) {
1482   assert(_no_class_loading_should_happen, &quot;sanity&quot;);
1483   Arguments::assert_is_dumping_archive();
1484   return find_or_allocate_info_for(k)-&gt;is_excluded();
1485 }
1486 
1487 void SystemDictionaryShared::set_class_has_failed_verification(InstanceKlass* ik) {
1488   Arguments::assert_is_dumping_archive();
1489   find_or_allocate_info_for(ik)-&gt;set_failed_verification();
1490 }
1491 
1492 bool SystemDictionaryShared::has_class_failed_verification(InstanceKlass* ik) {
1493   Arguments::assert_is_dumping_archive();
1494   if (_dumptime_table == NULL) {
1495     assert(DynamicDumpSharedSpaces, &quot;sanity&quot;);
1496     assert(ik-&gt;is_shared(), &quot;must be a shared class in the static archive&quot;);
1497     return false;
1498   }
1499   DumpTimeSharedClassInfo* p = _dumptime_table-&gt;get(ik);
1500   return (p == NULL) ? false : p-&gt;failed_verification();
1501 }
1502 
1503 class IterateDumpTimeSharedClassTable : StackObj {
1504   MetaspaceClosure *_it;
1505 public:
1506   IterateDumpTimeSharedClassTable(MetaspaceClosure* it) : _it(it) {}
1507 
1508   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1509     if (!info.is_excluded()) {
1510       info.metaspace_pointers_do(_it);
1511     }
1512     return true; // keep on iterating
1513   }
1514 };
1515 
1516 void SystemDictionaryShared::dumptime_classes_do(class MetaspaceClosure* it) {
1517   IterateDumpTimeSharedClassTable iter(it);
1518   _dumptime_table-&gt;iterate(&amp;iter);
1519 }
1520 
1521 bool SystemDictionaryShared::add_verification_constraint(InstanceKlass* k, Symbol* name,
1522          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
1523   Arguments::assert_is_dumping_archive();
1524   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
1525   info-&gt;add_verification_constraint(k, name, from_name, from_field_is_protected,
1526                                     from_is_array, from_is_object);
1527 
1528   if (DynamicDumpSharedSpaces) {
1529     // For dynamic dumping, we can resolve all the constraint classes for all class loaders during
1530     // the initial run prior to creating the archive before vm exit. We will also perform verification
1531     // check when running with the archive.
1532     return false;
1533   } else {
1534     if (is_builtin(k)) {
1535       // For builtin class loaders, we can try to complete the verification check at dump time,
1536       // because we can resolve all the constraint classes. We will also perform verification check
1537       // when running with the archive.
1538       return false;
1539     } else {
1540       // For non-builtin class loaders, we cannot complete the verification check at dump time,
1541       // because at dump time we don&#39;t know how to resolve classes for such loaders.
1542       return true;
1543     }
1544   }
1545 }
1546 
1547 void DumpTimeSharedClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,
1548          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object) {
1549   if (_verifier_constraints == NULL) {
<a name="2" id="anc2"></a><span class="line-modified">1550     _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;DTVerifierConstraint&gt;(4, true, mtClass);</span>
1551   }
1552   if (_verifier_constraint_flags == NULL) {
<a name="3" id="anc3"></a><span class="line-modified">1553     _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;char&gt;(4, true, mtClass);</span>
1554   }
1555   GrowableArray&lt;DTVerifierConstraint&gt;* vc_array = _verifier_constraints;
1556   for (int i = 0; i &lt; vc_array-&gt;length(); i++) {
1557     DTVerifierConstraint* p = vc_array-&gt;adr_at(i);
1558     if (name == p-&gt;_name &amp;&amp; from_name == p-&gt;_from_name) {
1559       return;
1560     }
1561   }
1562   DTVerifierConstraint cons(name, from_name);
1563   vc_array-&gt;append(cons);
1564 
1565   GrowableArray&lt;char&gt;* vcflags_array = _verifier_constraint_flags;
1566   char c = 0;
1567   c |= from_field_is_protected ? SystemDictionaryShared::FROM_FIELD_IS_PROTECTED : 0;
1568   c |= from_is_array           ? SystemDictionaryShared::FROM_IS_ARRAY           : 0;
1569   c |= from_is_object          ? SystemDictionaryShared::FROM_IS_OBJECT          : 0;
1570   vcflags_array-&gt;append(c);
1571 
1572   if (log_is_enabled(Trace, cds, verification)) {
1573     ResourceMark rm;
1574     log_trace(cds, verification)(&quot;add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d&quot;,
1575                                  k-&gt;external_name(), from_name-&gt;as_klass_external_name(),
1576                                  name-&gt;as_klass_external_name(), c, vc_array-&gt;length(), vcflags_array-&gt;length());
1577   }
1578 }
1579 
1580 void SystemDictionaryShared::add_lambda_proxy_class(InstanceKlass* caller_ik,
1581                                                     InstanceKlass* lambda_ik,
1582                                                     Symbol* invoked_name,
1583                                                     Symbol* invoked_type,
1584                                                     Symbol* method_type,
1585                                                     Method* member_method,
1586                                                     Symbol* instantiated_method_type) {
1587 
1588   assert(caller_ik-&gt;class_loader() == lambda_ik-&gt;class_loader(), &quot;mismatched class loader&quot;);
1589   assert(caller_ik-&gt;class_loader_data() == lambda_ik-&gt;class_loader_data(), &quot;mismatched class loader data&quot;);
1590   assert(java_lang_Class::class_data(lambda_ik-&gt;java_mirror()) == NULL, &quot;must not have class data&quot;);
1591 
1592   MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);
1593 
1594   lambda_ik-&gt;assign_class_loader_type();
1595   lambda_ik-&gt;set_shared_classpath_index(caller_ik-&gt;shared_classpath_index());
1596 
1597   DumpTimeSharedClassInfo* info = _dumptime_table-&gt;get(lambda_ik);
1598   if (info != NULL &amp;&amp; !lambda_ik-&gt;is_non_strong_hidden() &amp;&amp; is_builtin(lambda_ik) &amp;&amp; is_builtin(caller_ik)) {
1599     // Set _is_archived_lambda_proxy in DumpTimeSharedClassInfo so that the lambda_ik
1600     // won&#39;t be excluded during dumping of shared archive. See ExcludeDumpTimeSharedClasses.
1601     info-&gt;_is_archived_lambda_proxy = true;
1602 
1603     LambdaProxyClassKey key(caller_ik,
1604                             invoked_name,
1605                             invoked_type,
1606                             method_type,
1607                             member_method,
1608                             instantiated_method_type);
1609     add_to_dump_time_lambda_proxy_class_dictionary(key, lambda_ik);
1610   }
1611 }
1612 
1613 InstanceKlass* SystemDictionaryShared::get_shared_lambda_proxy_class(InstanceKlass* caller_ik,
1614                                                                      Symbol* invoked_name,
1615                                                                      Symbol* invoked_type,
1616                                                                      Symbol* method_type,
1617                                                                      Method* member_method,
1618                                                                      Symbol* instantiated_method_type) {
1619   MutexLocker ml(CDSLambda_lock, Mutex::_no_safepoint_check_flag);
1620   LambdaProxyClassKey key(caller_ik, invoked_name, invoked_type,
1621                           method_type, member_method, instantiated_method_type);
1622   const RunTimeLambdaProxyClassInfo* info = _lambda_proxy_class_dictionary.lookup(&amp;key, key.hash(), 0);
1623   InstanceKlass* proxy_klass = NULL;
1624   if (info != NULL) {
1625     InstanceKlass* curr_klass = info-&gt;proxy_klass_head();
1626     InstanceKlass* prev_klass = curr_klass;
1627     if (curr_klass-&gt;lambda_proxy_is_available()) {
1628       while (curr_klass-&gt;next_link() != NULL) {
1629         prev_klass = curr_klass;
1630         curr_klass = InstanceKlass::cast(curr_klass-&gt;next_link());
1631       }
1632       assert(curr_klass-&gt;is_hidden(), &quot;must be&quot;);
1633       assert(curr_klass-&gt;lambda_proxy_is_available(), &quot;must be&quot;);
1634 
1635       prev_klass-&gt;set_next_link(NULL);
1636       proxy_klass = curr_klass;
1637       proxy_klass-&gt;clear_lambda_proxy_is_available();
1638       if (log_is_enabled(Debug, cds)) {
1639         ResourceMark rm;
1640         log_debug(cds)(&quot;Loaded lambda proxy: %s&quot;, proxy_klass-&gt;external_name());
1641       }
1642     } else {
1643       if (log_is_enabled(Debug, cds)) {
1644         ResourceMark rm;
1645         log_debug(cds)(&quot;Used all archived lambda proxy classes for: %s %s%s&quot;,
1646                        caller_ik-&gt;external_name(), invoked_name-&gt;as_C_string(), invoked_type-&gt;as_C_string());
1647       }
1648     }
1649   }
1650   return proxy_klass;
1651 }
1652 
1653 InstanceKlass* SystemDictionaryShared::get_shared_nest_host(InstanceKlass* lambda_ik) {
1654   assert(!DumpSharedSpaces &amp;&amp; UseSharedSpaces, &quot;called at run time with CDS enabled only&quot;);
1655   RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(lambda_ik);
1656   return record-&gt;nest_host();
1657 }
1658 
1659 InstanceKlass* SystemDictionaryShared::prepare_shared_lambda_proxy_class(InstanceKlass* lambda_ik,
1660                                                                          InstanceKlass* caller_ik,
1661                                                                          bool initialize, TRAPS) {
1662   Handle class_loader(THREAD, caller_ik-&gt;class_loader());
1663   Handle protection_domain;
1664   PackageEntry* pkg_entry = get_package_entry_from_class_name(class_loader, caller_ik-&gt;name());
1665   if (caller_ik-&gt;class_loader() != NULL) {
1666     protection_domain = SystemDictionaryShared::init_security_info(class_loader, caller_ik, pkg_entry, CHECK_NULL);
1667   }
1668 
1669   InstanceKlass* shared_nest_host = get_shared_nest_host(lambda_ik);
1670   assert(shared_nest_host != NULL, &quot;unexpected NULL _nest_host&quot;);
1671 
1672   InstanceKlass* loaded_lambda =
1673     SystemDictionary::load_shared_lambda_proxy_class(lambda_ik, class_loader, protection_domain, pkg_entry, CHECK_NULL);
1674 
1675   // Ensures the nest host is the same as the lambda proxy&#39;s
1676   // nest host recorded at dump time.
1677   InstanceKlass* nest_host = caller_ik-&gt;nest_host(THREAD);
1678   assert(nest_host == shared_nest_host, &quot;mismatched nest host&quot;);
1679 
1680   EventClassLoad class_load_start_event;
1681   {
1682     MutexLocker mu_r(THREAD, Compile_lock);
1683 
1684     // Add to class hierarchy, initialize vtables, and do possible
1685     // deoptimizations.
1686     SystemDictionary::add_to_hierarchy(loaded_lambda, CHECK_NULL); // No exception, but can block
1687     // But, do not add to dictionary.
1688   }
1689   loaded_lambda-&gt;link_class(CHECK_NULL);
1690   // notify jvmti
1691   if (JvmtiExport::should_post_class_load()) {
1692     assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1693     JvmtiExport::post_class_load((JavaThread *) THREAD, loaded_lambda);
1694   }
1695   if (class_load_start_event.should_commit()) {
1696     SystemDictionary::post_class_load_event(&amp;class_load_start_event, loaded_lambda, ClassLoaderData::class_loader_data(class_loader()));
1697   }
1698 
1699   if (initialize) {
1700     loaded_lambda-&gt;initialize(CHECK_NULL);
1701   }
1702 
1703   return loaded_lambda;
1704 }
1705 
1706 static char get_loader_type_by(oop  loader) {
1707   assert(SystemDictionary::is_builtin_class_loader(loader), &quot;Must be built-in loader&quot;);
1708   if (SystemDictionary::is_boot_class_loader(loader)) {
1709     return (char)ClassLoader::BOOT_LOADER;
1710   } else if (SystemDictionary::is_platform_class_loader(loader)) {
1711     return (char)ClassLoader::PLATFORM_LOADER;
1712   } else {
1713     assert(SystemDictionary::is_system_class_loader(loader), &quot;Class loader mismatch&quot;);
1714     return (char)ClassLoader::APP_LOADER;
1715   }
1716 }
1717 
1718 static oop get_class_loader_by(char type) {
1719   if (type == (char)ClassLoader::BOOT_LOADER) {
1720     return (oop)NULL;
1721   } else if (type == (char)ClassLoader::PLATFORM_LOADER) {
1722     return SystemDictionary::java_platform_loader();
1723   } else {
1724     assert (type == (char)ClassLoader::APP_LOADER, &quot;Sanity&quot;);
1725     return SystemDictionary::java_system_loader();
1726   }
1727 }
1728 
1729 void DumpTimeSharedClassInfo::record_linking_constraint(Symbol* name, Handle loader1, Handle loader2) {
1730   assert(loader1 != loader2, &quot;sanity&quot;);
1731   LogTarget(Info, class, loader, constraints) log;
1732   if (_loader_constraints == NULL) {
<a name="4" id="anc4"></a><span class="line-modified">1733     _loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;DTLoaderConstraint&gt;(4, true, mtClass);</span>
1734   }
1735   char lt1 = get_loader_type_by(loader1());
1736   char lt2 = get_loader_type_by(loader2());
1737   DTLoaderConstraint lc(name, lt1, lt2);
1738   for (int i = 0; i &lt; _loader_constraints-&gt;length(); i++) {
1739     DTLoaderConstraint dt = _loader_constraints-&gt;at(i);
1740     if (lc.equals(dt)) {
1741       if (log.is_enabled()) {
1742         ResourceMark rm;
1743         // Use loader[0]/loader[1] to be consistent with the logs in loaderConstraints.cpp
1744         log.print(&quot;[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s already added]&quot;,
1745                   _klass-&gt;external_name(), name-&gt;as_C_string(),
1746                   ClassLoaderData::class_loader_data(loader1())-&gt;loader_name_and_id(),
1747                   ClassLoaderData::class_loader_data(loader2())-&gt;loader_name_and_id());
1748       }
1749       return;
1750     }
1751   }
1752   _loader_constraints-&gt;append(lc);
1753   if (log.is_enabled()) {
1754     ResourceMark rm;
1755     // Use loader[0]/loader[1] to be consistent with the logs in loaderConstraints.cpp
1756     log.print(&quot;[CDS record loader constraint for class: %s constraint_name: %s loader[0]: %s loader[1]: %s total %d]&quot;,
1757               _klass-&gt;external_name(), name-&gt;as_C_string(),
1758               ClassLoaderData::class_loader_data(loader1())-&gt;loader_name_and_id(),
1759               ClassLoaderData::class_loader_data(loader2())-&gt;loader_name_and_id(),
1760               _loader_constraints-&gt;length());
1761   }
1762 }
1763 
1764 void SystemDictionaryShared::check_verification_constraints(InstanceKlass* klass,
1765                                                             TRAPS) {
1766   assert(!DumpSharedSpaces &amp;&amp; UseSharedSpaces, &quot;called at run time with CDS enabled only&quot;);
1767   RunTimeSharedClassInfo* record = RunTimeSharedClassInfo::get_for(klass);
1768 
1769   int length = record-&gt;_num_verifier_constraints;
1770   if (length &gt; 0) {
1771     for (int i = 0; i &lt; length; i++) {
1772       RunTimeSharedClassInfo::RTVerifierConstraint* vc = record-&gt;verifier_constraint_at(i);
1773       Symbol* name      = vc-&gt;name();
1774       Symbol* from_name = vc-&gt;from_name();
1775       char c            = record-&gt;verifier_constraint_flag(i);
1776 
1777       if (log_is_enabled(Trace, cds, verification)) {
1778         ResourceMark rm(THREAD);
1779         log_trace(cds, verification)(&quot;check_verification_constraint: %s: %s must be subclass of %s [0x%x]&quot;,
1780                                      klass-&gt;external_name(), from_name-&gt;as_klass_external_name(),
1781                                      name-&gt;as_klass_external_name(), c);
1782       }
1783 
1784       bool from_field_is_protected = (c &amp; SystemDictionaryShared::FROM_FIELD_IS_PROTECTED) ? true : false;
1785       bool from_is_array           = (c &amp; SystemDictionaryShared::FROM_IS_ARRAY)           ? true : false;
1786       bool from_is_object          = (c &amp; SystemDictionaryShared::FROM_IS_OBJECT)          ? true : false;
1787 
1788       bool ok = VerificationType::resolve_and_check_assignability(klass, name,
1789          from_name, from_field_is_protected, from_is_array, from_is_object, CHECK);
1790       if (!ok) {
1791         ResourceMark rm(THREAD);
1792         stringStream ss;
1793 
1794         ss.print_cr(&quot;Bad type on operand stack&quot;);
1795         ss.print_cr(&quot;Exception Details:&quot;);
1796         ss.print_cr(&quot;  Location:\n    %s&quot;, klass-&gt;name()-&gt;as_C_string());
1797         ss.print_cr(&quot;  Reason:\n    Type &#39;%s&#39; is not assignable to &#39;%s&#39;&quot;,
1798                     from_name-&gt;as_quoted_ascii(), name-&gt;as_quoted_ascii());
1799         THROW_MSG(vmSymbols::java_lang_VerifyError(), ss.as_string());
1800       }
1801     }
1802   }
1803 }
1804 
1805 // Record class loader constraints that are checked inside
1806 // InstanceKlass::link_class(), so that these can be checked quickly
1807 // at runtime without laying out the vtable/itables.
1808 void SystemDictionaryShared::record_linking_constraint(Symbol* name, InstanceKlass* klass,
1809                                                     Handle loader1, Handle loader2, TRAPS) {
1810   // A linking constraint check is executed when:
1811   //   - klass extends or implements type S
1812   //   - klass overrides method S.M(...) with X.M
1813   //     - If klass defines the method M, X is
1814   //       the same as klass.
1815   //     - If klass does not define the method M,
1816   //       X must be a supertype of klass and X.M is
1817   //       a default method defined by X.
1818   //   - loader1 = X-&gt;class_loader()
1819   //   - loader2 = S-&gt;class_loader()
1820   //   - loader1 != loader2
1821   //   - M&#39;s paramater(s) include an object type T
1822   // We require that
1823   //   - whenever loader1 and loader2 try to
1824   //     resolve the type T, they must always resolve to
1825   //     the same InstanceKlass.
1826   // NOTE: type T may or may not be currently resolved in
1827   // either of these two loaders. The check itself does not
1828   // try to resolve T.
1829   oop klass_loader = klass-&gt;class_loader();
1830   assert(klass_loader != NULL, &quot;should not be called for boot loader&quot;);
1831   assert(loader1 != loader2, &quot;must be&quot;);
1832 
1833   if (!is_system_class_loader(klass_loader) &amp;&amp;
1834       !is_platform_class_loader(klass_loader)) {
1835     // If klass is loaded by system/platform loaders, we can
1836     // guarantee that klass and S must be loaded by the same
1837     // respective loader between dump time and run time, and
1838     // the exact same check on (name, loader1, loader2) will
1839     // be executed. Hence, we can cache this check and execute
1840     // it at runtime without walking the vtable/itables.
1841     //
1842     // This cannot be guaranteed for classes loaded by other
1843     // loaders, so we bail.
1844     return;
1845   }
1846 
1847   if (THREAD-&gt;is_VM_thread()) {
1848     assert(DynamicDumpSharedSpaces, &quot;must be&quot;);
1849     // We are re-laying out the vtable/itables of the *copy* of
1850     // a class during the final stage of dynamic dumping. The
1851     // linking constraints for this class has already been recorded.
1852     return;
1853   }
1854   Arguments::assert_is_dumping_archive();
1855   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(klass);
1856   info-&gt;record_linking_constraint(name, loader1, loader2);
1857 }
1858 
1859 // returns true IFF there&#39;s no need to re-initialize the i/v-tables for klass for
1860 // the purpose of checking class loader constraints.
1861 bool SystemDictionaryShared::check_linking_constraints(InstanceKlass* klass, TRAPS) {
1862   assert(!DumpSharedSpaces &amp;&amp; UseSharedSpaces, &quot;called at run time with CDS enabled only&quot;);
1863   LogTarget(Info, class, loader, constraints) log;
1864   if (klass-&gt;is_shared_boot_class()) {
1865     // No class loader constraint check performed for boot classes.
1866     return true;
1867   }
1868   if (klass-&gt;is_shared_platform_class() || klass-&gt;is_shared_app_class()) {
1869     RunTimeSharedClassInfo* info = RunTimeSharedClassInfo::get_for(klass);
1870     assert(info != NULL, &quot;Sanity&quot;);
1871     if (info-&gt;_num_loader_constraints &gt; 0) {
1872       HandleMark hm;
1873       for (int i = 0; i &lt; info-&gt;_num_loader_constraints; i++) {
1874         RunTimeSharedClassInfo::RTLoaderConstraint* lc = info-&gt;loader_constraint_at(i);
1875         Symbol* name = lc-&gt;constraint_name();
1876         Handle loader1(THREAD, get_class_loader_by(lc-&gt;_loader_type1));
1877         Handle loader2(THREAD, get_class_loader_by(lc-&gt;_loader_type2));
1878         if (log.is_enabled()) {
1879           ResourceMark rm(THREAD);
1880           log.print(&quot;[CDS add loader constraint for class %s symbol %s loader[0] %s loader[1] %s&quot;,
1881                     klass-&gt;external_name(), name-&gt;as_C_string(),
1882                     ClassLoaderData::class_loader_data(loader1())-&gt;loader_name_and_id(),
1883                     ClassLoaderData::class_loader_data(loader2())-&gt;loader_name_and_id());
1884         }
1885         if (!SystemDictionary::add_loader_constraint(name, klass, loader1, loader2, THREAD)) {
1886           // Loader constraint violation has been found. The caller
1887           // will re-layout the vtable/itables to produce the correct
1888           // exception.
1889           if (log.is_enabled()) {
1890             log.print(&quot; failed]&quot;);
1891           }
1892           return false;
1893         }
1894         if (log.is_enabled()) {
1895             log.print(&quot; succeeded]&quot;);
1896         }
1897       }
1898       return true; // for all recorded constraints added successully.
1899     }
1900   }
1901   if (log.is_enabled()) {
1902     ResourceMark rm(THREAD);
1903     log.print(&quot;[CDS has not recorded loader constraint for class %s]&quot;, klass-&gt;external_name());
1904   }
1905   return false;
1906 }
1907 
1908 class EstimateSizeForArchive : StackObj {
1909   size_t _shared_class_info_size;
1910   int _num_builtin_klasses;
1911   int _num_unregistered_klasses;
1912 
1913 public:
1914   EstimateSizeForArchive() {
1915     _shared_class_info_size = 0;
1916     _num_builtin_klasses = 0;
1917     _num_unregistered_klasses = 0;
1918   }
1919 
1920   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
1921     if (!info.is_excluded()) {
1922       size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());
1923       _shared_class_info_size += align_up(byte_size, BytesPerWord);
1924     }
1925     return true; // keep on iterating
1926   }
1927 
1928   size_t total() {
1929     return _shared_class_info_size;
1930   }
1931 };
1932 
1933 size_t SystemDictionaryShared::estimate_size_for_archive() {
1934   EstimateSizeForArchive est;
1935   _dumptime_table-&gt;iterate(&amp;est);
1936   size_t total_size = est.total() +
1937     CompactHashtableWriter::estimate_size(_dumptime_table-&gt;count_of(true)) +
1938     CompactHashtableWriter::estimate_size(_dumptime_table-&gt;count_of(false));
1939   if (_dumptime_lambda_proxy_class_dictionary != NULL) {
1940     total_size +=
1941       (sizeof(RunTimeLambdaProxyClassInfo) * _dumptime_lambda_proxy_class_dictionary-&gt;_count) +
1942       CompactHashtableWriter::estimate_size(_dumptime_lambda_proxy_class_dictionary-&gt;_count);
1943   } else {
1944     total_size += CompactHashtableWriter::estimate_size(0);
1945   }
1946   return total_size;
1947 }
1948 
1949 class CopyLambdaProxyClassInfoToArchive : StackObj {
1950   CompactHashtableWriter* _writer;
1951 public:
1952   CopyLambdaProxyClassInfoToArchive(CompactHashtableWriter* writer)
1953     : _writer(writer) {}
1954   bool do_entry(LambdaProxyClassKey&amp; key, DumpTimeLambdaProxyClassInfo&amp; info) {
1955     if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses-&gt;at(0))) {
1956       return true;
1957     }
1958     ResourceMark rm;
1959     log_info(cds,dynamic)(&quot;Archiving hidden %s&quot;, info._proxy_klasses-&gt;at(0)-&gt;external_name());
1960     size_t byte_size = sizeof(RunTimeLambdaProxyClassInfo);
1961     RunTimeLambdaProxyClassInfo* runtime_info =
1962         (RunTimeLambdaProxyClassInfo*)MetaspaceShared::read_only_space_alloc(byte_size);
1963     runtime_info-&gt;init(key, info);
1964     unsigned int hash = runtime_info-&gt;hash(); // Fields in runtime_info-&gt;_key already point to target space.
1965     u4 delta = MetaspaceShared::object_delta_u4(DynamicArchive::buffer_to_target(runtime_info));
1966     _writer-&gt;add(hash, delta);
1967     return true;
1968   }
1969 };
1970 
1971 class AdjustLambdaProxyClassInfo : StackObj {
1972 public:
1973   AdjustLambdaProxyClassInfo() {}
1974   bool do_entry(LambdaProxyClassKey&amp; key, DumpTimeLambdaProxyClassInfo&amp; info) {
1975     if (SystemDictionaryShared::is_excluded_class(info._proxy_klasses-&gt;at(0))) {
1976       return true;
1977     }
1978     int len = info._proxy_klasses-&gt;length();
1979     if (len &gt; 1) {
1980       for (int i = 0; i &lt; len-1; i++) {
1981         InstanceKlass* ok0 = info._proxy_klasses-&gt;at(i+0); // this is original klass
1982         InstanceKlass* ok1 = info._proxy_klasses-&gt;at(i+1); // this is original klass
1983         InstanceKlass* bk0 = DynamicArchive::original_to_buffer(ok0);
1984         InstanceKlass* bk1 = DynamicArchive::original_to_buffer(ok1);
1985         assert(bk0-&gt;next_link() == 0, &quot;must be called after Klass::remove_unshareable_info()&quot;);
1986         assert(bk1-&gt;next_link() == 0, &quot;must be called after Klass::remove_unshareable_info()&quot;);
1987         bk0-&gt;set_next_link(bk1);
1988         bk1-&gt;set_lambda_proxy_is_available();
1989         ArchivePtrMarker::mark_pointer(bk0-&gt;next_link_addr());
1990       }
1991     }
1992     DynamicArchive::original_to_buffer(info._proxy_klasses-&gt;at(0))-&gt;set_lambda_proxy_is_available();
1993     return true;
1994   }
1995 };
1996 
1997 class CopySharedClassInfoToArchive : StackObj {
1998   CompactHashtableWriter* _writer;
1999   bool _is_builtin;
2000 public:
2001   CopySharedClassInfoToArchive(CompactHashtableWriter* writer,
2002                                bool is_builtin,
2003                                bool is_static_archive)
2004     : _writer(writer), _is_builtin(is_builtin) {}
2005 
2006   bool do_entry(InstanceKlass* k, DumpTimeSharedClassInfo&amp; info) {
2007     if (!info.is_excluded() &amp;&amp; info.is_builtin() == _is_builtin) {
2008       size_t byte_size = RunTimeSharedClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());
2009       RunTimeSharedClassInfo* record;
2010       record = (RunTimeSharedClassInfo*)MetaspaceShared::read_only_space_alloc(byte_size);
2011       record-&gt;init(info);
2012 
2013       unsigned int hash;
2014       Symbol* name = info._klass-&gt;name();
2015       if (DynamicDumpSharedSpaces) {
2016         name = DynamicArchive::original_to_target(name);
2017       }
2018       hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
2019       u4 delta;
2020       if (DynamicDumpSharedSpaces) {
2021         delta = MetaspaceShared::object_delta_u4(DynamicArchive::buffer_to_target(record));
2022       } else {
2023         delta = MetaspaceShared::object_delta_u4(record);
2024       }
2025       if (_is_builtin &amp;&amp; info._klass-&gt;is_hidden()) {
2026         // skip
2027       } else {
2028         _writer-&gt;add(hash, delta);
2029       }
2030       if (log_is_enabled(Trace, cds, hashtables)) {
2031         ResourceMark rm;
2032         log_trace(cds,hashtables)(&quot;%s dictionary: %s&quot;, (_is_builtin ? &quot;builtin&quot; : &quot;unregistered&quot;), info._klass-&gt;external_name());
2033       }
2034 
2035       // Save this for quick runtime lookup of InstanceKlass* -&gt; RunTimeSharedClassInfo*
2036       RunTimeSharedClassInfo::set_for(info._klass, record);
2037     }
2038     return true; // keep on iterating
2039   }
2040 };
2041 
2042 void SystemDictionaryShared::write_lambda_proxy_class_dictionary(LambdaProxyClassDictionary *dictionary) {
2043   CompactHashtableStats stats;
2044   dictionary-&gt;reset();
2045   CompactHashtableWriter writer(_dumptime_lambda_proxy_class_dictionary-&gt;_count, &amp;stats);
2046   CopyLambdaProxyClassInfoToArchive copy(&amp;writer);
2047   _dumptime_lambda_proxy_class_dictionary-&gt;iterate(&amp;copy);
2048   writer.dump(dictionary, &quot;lambda proxy class dictionary&quot;);
2049 }
2050 
2051 void SystemDictionaryShared::write_dictionary(RunTimeSharedDictionary* dictionary,
2052                                               bool is_builtin,
2053                                               bool is_static_archive) {
2054   CompactHashtableStats stats;
2055   dictionary-&gt;reset();
2056   CompactHashtableWriter writer(_dumptime_table-&gt;count_of(is_builtin), &amp;stats);
2057   CopySharedClassInfoToArchive copy(&amp;writer, is_builtin, is_static_archive);
2058   _dumptime_table-&gt;iterate(&amp;copy);
2059   writer.dump(dictionary, is_builtin ? &quot;builtin dictionary&quot; : &quot;unregistered dictionary&quot;);
2060 }
2061 
2062 void SystemDictionaryShared::write_to_archive(bool is_static_archive) {
2063   if (is_static_archive) {
2064     write_dictionary(&amp;_builtin_dictionary, true);
2065     write_dictionary(&amp;_unregistered_dictionary, false);
2066   } else {
2067     write_dictionary(&amp;_dynamic_builtin_dictionary, true);
2068     write_dictionary(&amp;_dynamic_unregistered_dictionary, false);
2069   }
2070   if (_dumptime_lambda_proxy_class_dictionary != NULL) {
2071     write_lambda_proxy_class_dictionary(&amp;_lambda_proxy_class_dictionary);
2072   }
2073 }
2074 
2075 void SystemDictionaryShared::adjust_lambda_proxy_class_dictionary() {
2076   if (_dumptime_lambda_proxy_class_dictionary != NULL) {
2077     AdjustLambdaProxyClassInfo adjuster;
2078     _dumptime_lambda_proxy_class_dictionary-&gt;iterate(&amp;adjuster);
2079   }
2080 }
2081 
2082 void SystemDictionaryShared::serialize_dictionary_headers(SerializeClosure* soc,
2083                                                           bool is_static_archive) {
2084   if (is_static_archive) {
2085     _builtin_dictionary.serialize_header(soc);
2086     _unregistered_dictionary.serialize_header(soc);
2087   } else {
2088     _dynamic_builtin_dictionary.serialize_header(soc);
2089     _dynamic_unregistered_dictionary.serialize_header(soc);
2090     _lambda_proxy_class_dictionary.serialize_header(soc);
2091   }
2092 }
2093 
2094 void SystemDictionaryShared::serialize_well_known_klasses(SerializeClosure* soc) {
2095   for (int i = FIRST_WKID; i &lt; WKID_LIMIT; i++) {
2096     soc-&gt;do_ptr((void**)&amp;_well_known_klasses[i]);
2097   }
2098 }
2099 
2100 const RunTimeSharedClassInfo*
2101 SystemDictionaryShared::find_record(RunTimeSharedDictionary* static_dict, RunTimeSharedDictionary* dynamic_dict, Symbol* name) {
2102   if (!UseSharedSpaces || !name-&gt;is_shared()) {
2103     // The names of all shared classes must also be a shared Symbol.
2104     return NULL;
2105   }
2106 
2107   unsigned int hash = SystemDictionaryShared::hash_for_shared_dictionary(name);
2108   const RunTimeSharedClassInfo* record = NULL;
2109   if (!MetaspaceShared::is_shared_dynamic(name)) {
2110     // The names of all shared classes in the static dict must also be in the
2111     // static archive
2112     record = static_dict-&gt;lookup(name, hash, 0);
2113   }
2114 
2115   if (record == NULL &amp;&amp; DynamicArchive::is_mapped()) {
2116     record = dynamic_dict-&gt;lookup(name, hash, 0);
2117   }
2118 
2119   return record;
2120 }
2121 
2122 InstanceKlass* SystemDictionaryShared::find_builtin_class(Symbol* name) {
2123   const RunTimeSharedClassInfo* record = find_record(&amp;_builtin_dictionary, &amp;_dynamic_builtin_dictionary, name);
2124   if (record != NULL) {
2125     assert(!record-&gt;_klass-&gt;is_hidden(), &quot;hidden class cannot be looked up by name&quot;);
2126     return record-&gt;_klass;
2127   } else {
2128     return NULL;
2129   }
2130 }
2131 
2132 void SystemDictionaryShared::update_shared_entry(InstanceKlass* k, int id) {
2133   assert(DumpSharedSpaces, &quot;supported only when dumping&quot;);
2134   DumpTimeSharedClassInfo* info = find_or_allocate_info_for(k);
2135   info-&gt;_id = id;
2136 }
2137 
2138 class SharedDictionaryPrinter : StackObj {
2139   outputStream* _st;
2140   int _index;
2141 public:
2142   SharedDictionaryPrinter(outputStream* st) : _st(st), _index(0) {}
2143 
2144   void do_value(const RunTimeSharedClassInfo* record) {
2145     ResourceMark rm;
2146     _st-&gt;print_cr(&quot;%4d:  %s&quot;, (_index++), record-&gt;_klass-&gt;external_name());
2147   }
2148 };
2149 
2150 class SharedLambdaDictionaryPrinter : StackObj {
2151   outputStream* _st;
2152   int _index;
2153 public:
2154   SharedLambdaDictionaryPrinter(outputStream* st) : _st(st), _index(0) {}
2155 
2156   void do_value(const RunTimeLambdaProxyClassInfo* record) {
2157     ResourceMark rm;
2158     _st-&gt;print_cr(&quot;%4d:  %s&quot;, (_index++), record-&gt;proxy_klass_head()-&gt;external_name());
2159     Klass* k = record-&gt;proxy_klass_head()-&gt;next_link();
2160     while (k != NULL) {
2161       _st-&gt;print_cr(&quot;%4d:  %s&quot;, (_index++), k-&gt;external_name());
2162       k = k-&gt;next_link();
2163     }
2164   }
2165 };
2166 
2167 void SystemDictionaryShared::print_on(outputStream* st) {
2168   if (UseSharedSpaces) {
2169     st-&gt;print_cr(&quot;Shared Dictionary&quot;);
2170     SharedDictionaryPrinter p(st);
2171     _builtin_dictionary.iterate(&amp;p);
2172     _unregistered_dictionary.iterate(&amp;p);
2173     if (DynamicArchive::is_mapped()) {
2174       _dynamic_builtin_dictionary.iterate(&amp;p);
2175       _unregistered_dictionary.iterate(&amp;p);
2176       if (!_lambda_proxy_class_dictionary.empty()) {
2177         st-&gt;print_cr(&quot;Shared Lambda Dictionary&quot;);
2178         SharedLambdaDictionaryPrinter ldp(st);
2179         _lambda_proxy_class_dictionary.iterate(&amp;ldp);
2180       }
2181     }
2182   }
2183 }
2184 
2185 void SystemDictionaryShared::print_table_statistics(outputStream* st) {
2186   if (UseSharedSpaces) {
2187     _builtin_dictionary.print_table_statistics(st, &quot;Builtin Shared Dictionary&quot;);
2188     _unregistered_dictionary.print_table_statistics(st, &quot;Unregistered Shared Dictionary&quot;);
2189     if (DynamicArchive::is_mapped()) {
2190       _dynamic_builtin_dictionary.print_table_statistics(st, &quot;Dynamic Builtin Shared Dictionary&quot;);
2191       _dynamic_unregistered_dictionary.print_table_statistics(st, &quot;Unregistered Shared Dictionary&quot;);
2192       _lambda_proxy_class_dictionary.print_table_statistics(st, &quot;Lambda Shared Dictionary&quot;);
2193     }
2194   }
2195 }
2196 
2197 bool SystemDictionaryShared::empty_dumptime_table() {
2198   if (_dumptime_table == NULL) {
2199     return true;
2200   }
2201   _dumptime_table-&gt;update_counts();
2202   if (_dumptime_table-&gt;count_of(true) == 0 &amp;&amp; _dumptime_table-&gt;count_of(false) == 0){
2203     return true;
2204   }
2205   return false;
2206 }
2207 
2208 #if INCLUDE_CDS_JAVA_HEAP
2209 
2210 class ArchivedMirrorPatcher {
2211   static void update(Klass* k) {
2212     if (k-&gt;has_raw_archived_mirror()) {
2213       oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
2214       if (m != NULL) {
2215         java_lang_Class::update_archived_mirror_native_pointers(m);
2216       }
2217     }
2218   }
2219 
2220 public:
2221   static void update_array_klasses(Klass* ak) {
2222     while (ak != NULL) {
2223       update(ak);
2224       ak = ArrayKlass::cast(ak)-&gt;higher_dimension();
2225     }
2226   }
2227 
2228   void do_value(const RunTimeSharedClassInfo* info) {
2229     InstanceKlass* ik = info-&gt;_klass;
2230     update(ik);
2231     update_array_klasses(ik-&gt;array_klasses());
2232   }
2233 };
2234 
2235 void SystemDictionaryShared::update_archived_mirror_native_pointers_for(RunTimeSharedDictionary* dict) {
2236   ArchivedMirrorPatcher patcher;
2237   dict-&gt;iterate(&amp;patcher);
2238 }
2239 
2240 void SystemDictionaryShared::update_archived_mirror_native_pointers() {
2241   if (!HeapShared::open_archive_heap_region_mapped()) {
2242     return;
2243   }
2244   if (MetaspaceShared::relocation_delta() == 0) {
2245     return;
2246   }
2247   update_archived_mirror_native_pointers_for(&amp;_builtin_dictionary);
2248   update_archived_mirror_native_pointers_for(&amp;_unregistered_dictionary);
2249 
2250   for (int t = T_BOOLEAN; t &lt;= T_LONG; t++) {
2251     Klass* k = Universe::typeArrayKlassObj((BasicType)t);
2252     ArchivedMirrorPatcher::update_array_klasses(k);
2253   }
2254 }
2255 #endif
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
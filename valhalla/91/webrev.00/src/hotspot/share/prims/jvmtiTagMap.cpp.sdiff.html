<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiTagMap.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiRedefineClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiTagMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 804 
 805   // add a field
 806   void add(int index, char type, int offset);
 807 
 808   // returns the field count for the given class
 809   static int compute_field_count(InstanceKlass* ik);
 810 
 811  public:
 812   ~ClassFieldMap();
 813 
 814   // access
 815   int field_count()                     { return _fields-&gt;length(); }
 816   ClassFieldDescriptor* field_at(int i) { return _fields-&gt;at(i); }
 817 
 818   // functions to create maps of static or instance fields
 819   static ClassFieldMap* create_map_of_static_fields(Klass* k);
 820   static ClassFieldMap* create_map_of_instance_fields(oop obj);
 821 };
 822 
 823 ClassFieldMap::ClassFieldMap() {
<span class="line-modified"> 824   _fields = new (ResourceObj::C_HEAP, mtInternal)</span>
<span class="line-modified"> 825     GrowableArray&lt;ClassFieldDescriptor*&gt;(initial_field_count, true);</span>
 826 }
 827 
 828 ClassFieldMap::~ClassFieldMap() {
 829   for (int i=0; i&lt;_fields-&gt;length(); i++) {
 830     delete _fields-&gt;at(i);
 831   }
 832   delete _fields;
 833 }
 834 
 835 void ClassFieldMap::add(int index, char type, int offset) {
 836   ClassFieldDescriptor* field = new ClassFieldDescriptor(index, type, offset);
 837   _fields-&gt;append(field);
 838 }
 839 
 840 // Returns a heap allocated ClassFieldMap to describe the static fields
 841 // of the given class.
 842 //
 843 ClassFieldMap* ClassFieldMap::create_map_of_static_fields(Klass* k) {
 844   HandleMark hm;
 845   InstanceKlass* ik = InstanceKlass::cast(k);
</pre>
<hr />
<pre>
 941  public:
 942    ClassFieldMapCacheMark() {
 943      assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 944      assert(JvmtiCachedClassFieldMap::cached_field_map_count() == 0, &quot;cache not empty&quot;);
 945      assert(!_is_active, &quot;ClassFieldMapCacheMark cannot be nested&quot;);
 946      _is_active = true;
 947    }
 948    ~ClassFieldMapCacheMark() {
 949      JvmtiCachedClassFieldMap::clear_cache();
 950      _is_active = false;
 951    }
 952    static bool is_active() { return _is_active; }
 953 };
 954 
 955 bool ClassFieldMapCacheMark::_is_active;
 956 
 957 
 958 // record that the given InstanceKlass is caching a field map
 959 void JvmtiCachedClassFieldMap::add_to_class_list(InstanceKlass* ik) {
 960   if (_class_list == NULL) {
<span class="line-modified"> 961     _class_list = new (ResourceObj::C_HEAP, mtInternal)</span>
<span class="line-modified"> 962       GrowableArray&lt;InstanceKlass*&gt;(initial_class_count, true);</span>
 963   }
 964   _class_list-&gt;push(ik);
 965 }
 966 
 967 // returns the instance field map for the given object
 968 // (returns field map cached by the InstanceKlass if possible)
 969 ClassFieldMap* JvmtiCachedClassFieldMap::get_map_of_instance_fields(oop obj) {
 970   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 971   assert(ClassFieldMapCacheMark::is_active(), &quot;ClassFieldMapCacheMark not active&quot;);
 972 
 973   Klass* k = obj-&gt;klass();
 974   InstanceKlass* ik = InstanceKlass::cast(k);
 975 
 976   // return cached map if possible
 977   JvmtiCachedClassFieldMap* cached_map = ik-&gt;jvmti_cached_class_field_map();
 978   if (cached_map != NULL) {
 979     assert(cached_map-&gt;field_map() != NULL, &quot;missing field list&quot;);
 980     return cached_map-&gt;field_map();
 981   } else {
 982     ClassFieldMap* field_map = ClassFieldMap::create_map_of_instance_fields(obj);
</pre>
<hr />
<pre>
1514   VM_HeapIterateOperation op(&amp;blk);
1515   VMThread::execute(&amp;op);
1516 }
1517 
1518 // support class for get_objects_with_tags
1519 
1520 class TagObjectCollector : public JvmtiTagHashmapEntryClosure {
1521  private:
1522   JvmtiEnv* _env;
1523   jlong* _tags;
1524   jint _tag_count;
1525 
1526   GrowableArray&lt;jobject&gt;* _object_results;  // collected objects (JNI weak refs)
1527   GrowableArray&lt;uint64_t&gt;* _tag_results;    // collected tags
1528 
1529  public:
1530   TagObjectCollector(JvmtiEnv* env, const jlong* tags, jint tag_count) {
1531     _env = env;
1532     _tags = (jlong*)tags;
1533     _tag_count = tag_count;
<span class="line-modified">1534     _object_results = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;jobject&gt;(1,true);</span>
<span class="line-modified">1535     _tag_results = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;uint64_t&gt;(1,true);</span>
1536   }
1537 
1538   ~TagObjectCollector() {
1539     delete _object_results;
1540     delete _tag_results;
1541   }
1542 
1543   // for each tagged object check if the tag value matches
1544   // - if it matches then we create a JNI local reference to the object
1545   // and record the reference and tag value.
1546   //
1547   void do_entry(JvmtiTagHashmapEntry* entry) {
1548     for (int i=0; i&lt;_tag_count; i++) {
1549       if (_tags[i] == entry-&gt;tag()) {
1550         // The reference in this tag map could be the only (implicitly weak)
1551         // reference to that object. If we hand it out, we need to keep it live wrt
1552         // SATB marking similar to other j.l.ref.Reference referents. This is
1553         // achieved by using a phantom load in the object() accessor.
1554         oop o = entry-&gt;object();
1555         assert(o != NULL &amp;&amp; Universe::heap()-&gt;is_in(o), &quot;sanity check&quot;);
</pre>
<hr />
<pre>
1657 
1658   static inline void mark(oop o);           // mark an object
1659   static inline bool visited(oop o);        // check if object has been visited
1660 
1661   static inline bool needs_reset()            { return _needs_reset; }
1662   static inline void set_needs_reset(bool v)  { _needs_reset = v; }
1663 };
1664 
1665 GrowableArray&lt;oop&gt;* ObjectMarker::_saved_oop_stack = NULL;
1666 GrowableArray&lt;markWord&gt;* ObjectMarker::_saved_mark_stack = NULL;
1667 bool ObjectMarker::_needs_reset = true;  // need to reset mark bits by default
1668 
1669 // initialize ObjectMarker - prepares for object marking
1670 void ObjectMarker::init() {
1671   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
1672 
1673   // prepare heap for iteration
1674   Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
1675 
1676   // create stacks for interesting headers
<span class="line-modified">1677   _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;markWord&gt;(4000, true);</span>
<span class="line-modified">1678   _saved_oop_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(4000, true);</span>
1679 
1680   if (UseBiasedLocking) {
1681     BiasedLocking::preserve_marks();
1682   }
1683 }
1684 
1685 // Object marking is done so restore object headers
1686 void ObjectMarker::done() {
1687   // iterate over all objects and restore the mark bits to
1688   // their initial value
1689   RestoreMarksClosure blk;
1690   if (needs_reset()) {
1691     Universe::heap()-&gt;object_iterate(&amp;blk);
1692   } else {
1693     // We don&#39;t need to reset mark bits on this call, but reset the
1694     // flag to the default for the next call.
1695     set_needs_reset(true);
1696   }
1697 
1698   // now restore the interesting headers
</pre>
<hr />
<pre>
2646 //
2647 class VM_HeapWalkOperation: public VM_Operation {
2648  private:
2649   enum {
2650     initial_visit_stack_size = 4000
2651   };
2652 
2653   bool _is_advanced_heap_walk;                      // indicates FollowReferences
2654   JvmtiTagMap* _tag_map;
2655   Handle _initial_object;
2656   GrowableArray&lt;oop&gt;* _visit_stack;                 // the visit stack
2657 
2658   bool _collecting_heap_roots;                      // are we collecting roots
2659   bool _following_object_refs;                      // are we following object references
2660 
2661   bool _reporting_primitive_fields;                 // optional reporting
2662   bool _reporting_primitive_array_values;
2663   bool _reporting_string_values;
2664 
2665   GrowableArray&lt;oop&gt;* create_visit_stack() {
<span class="line-modified">2666     return new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;oop&gt;(initial_visit_stack_size, true);</span>
2667   }
2668 
2669   // accessors
2670   bool is_advanced_heap_walk() const               { return _is_advanced_heap_walk; }
2671   JvmtiTagMap* tag_map() const                     { return _tag_map; }
2672   Handle initial_object() const                    { return _initial_object; }
2673 
2674   bool is_following_references() const             { return _following_object_refs; }
2675 
2676   bool is_reporting_primitive_fields()  const      { return _reporting_primitive_fields; }
2677   bool is_reporting_primitive_array_values() const { return _reporting_primitive_array_values; }
2678   bool is_reporting_string_values() const          { return _reporting_string_values; }
2679 
2680   GrowableArray&lt;oop&gt;* visit_stack() const          { return _visit_stack; }
2681 
2682   // iterate over the various object types
2683   inline bool iterate_over_array(oop o);
2684   inline bool iterate_over_type_array(oop o);
2685   inline bool iterate_over_class(oop o);
2686   inline bool iterate_over_object(oop o);
</pre>
</td>
<td>
<hr />
<pre>
 804 
 805   // add a field
 806   void add(int index, char type, int offset);
 807 
 808   // returns the field count for the given class
 809   static int compute_field_count(InstanceKlass* ik);
 810 
 811  public:
 812   ~ClassFieldMap();
 813 
 814   // access
 815   int field_count()                     { return _fields-&gt;length(); }
 816   ClassFieldDescriptor* field_at(int i) { return _fields-&gt;at(i); }
 817 
 818   // functions to create maps of static or instance fields
 819   static ClassFieldMap* create_map_of_static_fields(Klass* k);
 820   static ClassFieldMap* create_map_of_instance_fields(oop obj);
 821 };
 822 
 823 ClassFieldMap::ClassFieldMap() {
<span class="line-modified"> 824   _fields = new (ResourceObj::C_HEAP, mtServiceability)</span>
<span class="line-modified"> 825     GrowableArray&lt;ClassFieldDescriptor*&gt;(initial_field_count, mtServiceability);</span>
 826 }
 827 
 828 ClassFieldMap::~ClassFieldMap() {
 829   for (int i=0; i&lt;_fields-&gt;length(); i++) {
 830     delete _fields-&gt;at(i);
 831   }
 832   delete _fields;
 833 }
 834 
 835 void ClassFieldMap::add(int index, char type, int offset) {
 836   ClassFieldDescriptor* field = new ClassFieldDescriptor(index, type, offset);
 837   _fields-&gt;append(field);
 838 }
 839 
 840 // Returns a heap allocated ClassFieldMap to describe the static fields
 841 // of the given class.
 842 //
 843 ClassFieldMap* ClassFieldMap::create_map_of_static_fields(Klass* k) {
 844   HandleMark hm;
 845   InstanceKlass* ik = InstanceKlass::cast(k);
</pre>
<hr />
<pre>
 941  public:
 942    ClassFieldMapCacheMark() {
 943      assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 944      assert(JvmtiCachedClassFieldMap::cached_field_map_count() == 0, &quot;cache not empty&quot;);
 945      assert(!_is_active, &quot;ClassFieldMapCacheMark cannot be nested&quot;);
 946      _is_active = true;
 947    }
 948    ~ClassFieldMapCacheMark() {
 949      JvmtiCachedClassFieldMap::clear_cache();
 950      _is_active = false;
 951    }
 952    static bool is_active() { return _is_active; }
 953 };
 954 
 955 bool ClassFieldMapCacheMark::_is_active;
 956 
 957 
 958 // record that the given InstanceKlass is caching a field map
 959 void JvmtiCachedClassFieldMap::add_to_class_list(InstanceKlass* ik) {
 960   if (_class_list == NULL) {
<span class="line-modified"> 961     _class_list = new (ResourceObj::C_HEAP, mtServiceability)</span>
<span class="line-modified"> 962       GrowableArray&lt;InstanceKlass*&gt;(initial_class_count, mtServiceability);</span>
 963   }
 964   _class_list-&gt;push(ik);
 965 }
 966 
 967 // returns the instance field map for the given object
 968 // (returns field map cached by the InstanceKlass if possible)
 969 ClassFieldMap* JvmtiCachedClassFieldMap::get_map_of_instance_fields(oop obj) {
 970   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
 971   assert(ClassFieldMapCacheMark::is_active(), &quot;ClassFieldMapCacheMark not active&quot;);
 972 
 973   Klass* k = obj-&gt;klass();
 974   InstanceKlass* ik = InstanceKlass::cast(k);
 975 
 976   // return cached map if possible
 977   JvmtiCachedClassFieldMap* cached_map = ik-&gt;jvmti_cached_class_field_map();
 978   if (cached_map != NULL) {
 979     assert(cached_map-&gt;field_map() != NULL, &quot;missing field list&quot;);
 980     return cached_map-&gt;field_map();
 981   } else {
 982     ClassFieldMap* field_map = ClassFieldMap::create_map_of_instance_fields(obj);
</pre>
<hr />
<pre>
1514   VM_HeapIterateOperation op(&amp;blk);
1515   VMThread::execute(&amp;op);
1516 }
1517 
1518 // support class for get_objects_with_tags
1519 
1520 class TagObjectCollector : public JvmtiTagHashmapEntryClosure {
1521  private:
1522   JvmtiEnv* _env;
1523   jlong* _tags;
1524   jint _tag_count;
1525 
1526   GrowableArray&lt;jobject&gt;* _object_results;  // collected objects (JNI weak refs)
1527   GrowableArray&lt;uint64_t&gt;* _tag_results;    // collected tags
1528 
1529  public:
1530   TagObjectCollector(JvmtiEnv* env, const jlong* tags, jint tag_count) {
1531     _env = env;
1532     _tags = (jlong*)tags;
1533     _tag_count = tag_count;
<span class="line-modified">1534     _object_results = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;jobject&gt;(1, mtServiceability);</span>
<span class="line-modified">1535     _tag_results = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;uint64_t&gt;(1, mtServiceability);</span>
1536   }
1537 
1538   ~TagObjectCollector() {
1539     delete _object_results;
1540     delete _tag_results;
1541   }
1542 
1543   // for each tagged object check if the tag value matches
1544   // - if it matches then we create a JNI local reference to the object
1545   // and record the reference and tag value.
1546   //
1547   void do_entry(JvmtiTagHashmapEntry* entry) {
1548     for (int i=0; i&lt;_tag_count; i++) {
1549       if (_tags[i] == entry-&gt;tag()) {
1550         // The reference in this tag map could be the only (implicitly weak)
1551         // reference to that object. If we hand it out, we need to keep it live wrt
1552         // SATB marking similar to other j.l.ref.Reference referents. This is
1553         // achieved by using a phantom load in the object() accessor.
1554         oop o = entry-&gt;object();
1555         assert(o != NULL &amp;&amp; Universe::heap()-&gt;is_in(o), &quot;sanity check&quot;);
</pre>
<hr />
<pre>
1657 
1658   static inline void mark(oop o);           // mark an object
1659   static inline bool visited(oop o);        // check if object has been visited
1660 
1661   static inline bool needs_reset()            { return _needs_reset; }
1662   static inline void set_needs_reset(bool v)  { _needs_reset = v; }
1663 };
1664 
1665 GrowableArray&lt;oop&gt;* ObjectMarker::_saved_oop_stack = NULL;
1666 GrowableArray&lt;markWord&gt;* ObjectMarker::_saved_mark_stack = NULL;
1667 bool ObjectMarker::_needs_reset = true;  // need to reset mark bits by default
1668 
1669 // initialize ObjectMarker - prepares for object marking
1670 void ObjectMarker::init() {
1671   assert(Thread::current()-&gt;is_VM_thread(), &quot;must be VMThread&quot;);
1672 
1673   // prepare heap for iteration
1674   Universe::heap()-&gt;ensure_parsability(false);  // no need to retire TLABs
1675 
1676   // create stacks for interesting headers
<span class="line-modified">1677   _saved_mark_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;markWord&gt;(4000, mtServiceability);</span>
<span class="line-modified">1678   _saved_oop_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;oop&gt;(4000, mtServiceability);</span>
1679 
1680   if (UseBiasedLocking) {
1681     BiasedLocking::preserve_marks();
1682   }
1683 }
1684 
1685 // Object marking is done so restore object headers
1686 void ObjectMarker::done() {
1687   // iterate over all objects and restore the mark bits to
1688   // their initial value
1689   RestoreMarksClosure blk;
1690   if (needs_reset()) {
1691     Universe::heap()-&gt;object_iterate(&amp;blk);
1692   } else {
1693     // We don&#39;t need to reset mark bits on this call, but reset the
1694     // flag to the default for the next call.
1695     set_needs_reset(true);
1696   }
1697 
1698   // now restore the interesting headers
</pre>
<hr />
<pre>
2646 //
2647 class VM_HeapWalkOperation: public VM_Operation {
2648  private:
2649   enum {
2650     initial_visit_stack_size = 4000
2651   };
2652 
2653   bool _is_advanced_heap_walk;                      // indicates FollowReferences
2654   JvmtiTagMap* _tag_map;
2655   Handle _initial_object;
2656   GrowableArray&lt;oop&gt;* _visit_stack;                 // the visit stack
2657 
2658   bool _collecting_heap_roots;                      // are we collecting roots
2659   bool _following_object_refs;                      // are we following object references
2660 
2661   bool _reporting_primitive_fields;                 // optional reporting
2662   bool _reporting_primitive_array_values;
2663   bool _reporting_string_values;
2664 
2665   GrowableArray&lt;oop&gt;* create_visit_stack() {
<span class="line-modified">2666     return new (ResourceObj::C_HEAP, mtServiceability) GrowableArray&lt;oop&gt;(initial_visit_stack_size, mtServiceability);</span>
2667   }
2668 
2669   // accessors
2670   bool is_advanced_heap_walk() const               { return _is_advanced_heap_walk; }
2671   JvmtiTagMap* tag_map() const                     { return _tag_map; }
2672   Handle initial_object() const                    { return _initial_object; }
2673 
2674   bool is_following_references() const             { return _following_object_refs; }
2675 
2676   bool is_reporting_primitive_fields()  const      { return _reporting_primitive_fields; }
2677   bool is_reporting_primitive_array_values() const { return _reporting_primitive_array_values; }
2678   bool is_reporting_string_values() const          { return _reporting_string_values; }
2679 
2680   GrowableArray&lt;oop&gt;* visit_stack() const          { return _visit_stack; }
2681 
2682   // iterate over the various object types
2683   inline bool iterate_over_array(oop o);
2684   inline bool iterate_over_type_array(oop o);
2685   inline bool iterate_over_class(oop o);
2686   inline bool iterate_over_object(oop o);
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiRedefineClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
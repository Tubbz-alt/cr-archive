diff a/src/hotspot/share/memory/heapInspection.cpp b/src/hotspot/share/memory/heapInspection.cpp
--- a/src/hotspot/share/memory/heapInspection.cpp
+++ b/src/hotspot/share/memory/heapInspection.cpp
@@ -50,11 +50,11 @@
   }
 }
 
 inline void KlassInfoEntry::add_subclass(KlassInfoEntry* cie) {
   if (_subclasses == NULL) {
-    _subclasses = new  (ResourceObj::C_HEAP, mtInternal) GrowableArray<KlassInfoEntry*>(4, true);
+    _subclasses = new  (ResourceObj::C_HEAP, mtServiceability) GrowableArray<KlassInfoEntry*>(4, mtServiceability);
   }
   _subclasses->append(cie);
 }
 
 int KlassInfoEntry::compare(KlassInfoEntry* e1, KlassInfoEntry* e2) {
@@ -243,11 +243,11 @@
   return (*e1)->compare(*e1,*e2);
 }
 
 KlassInfoHisto::KlassInfoHisto(KlassInfoTable* cit) :
   _cit(cit) {
-  _elements = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<KlassInfoEntry*>(_histo_initial_size, true);
+  _elements = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<KlassInfoEntry*>(_histo_initial_size, mtServiceability);
 }
 
 KlassInfoHisto::~KlassInfoHisto() {
   delete _elements;
 }
@@ -549,11 +549,11 @@
 }
 
 static void print_inlined_field(outputStream* st, int level, int offset, InstanceKlass* klass) {
   assert(klass->is_inline_klass(), "Only inline types can be inlined");
   ValueKlass* vklass = ValueKlass::cast(klass);
-  GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<FieldDesc>(100, true);
+  GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);
   for (FieldStream fd(klass, false, false); !fd.eos(); fd.next()) {
     if (!fd.access_flags().is_static()) {
       fields->append(FieldDesc(fd.field_descriptor()));
     }
   }
@@ -579,11 +579,11 @@
 
   Thread* THREAD = Thread::current();
 
   Symbol* classname = SymbolTable::probe(class_name, (int)strlen(class_name));
 
-  GrowableArray<Klass*>* klasses = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<Klass*>(100, true);
+  GrowableArray<Klass*>* klasses = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<Klass*>(100, mtServiceability);
 
   FindClassByNameClosure fbnc(klasses, classname);
   cit.iterate(&fbnc);
 
   for(int i = 0; i < klasses->length(); i++) {
@@ -592,11 +592,11 @@
     InstanceKlass* ik = InstanceKlass::cast(klass);
     int tab = 1;
     st->print_cr("Class %s [@%s]:", klass->name()->as_C_string(),
         klass->class_loader_data()->name()->as_C_string());
     ResourceMark rm;
-    GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<FieldDesc>(100, true);
+    GrowableArray<FieldDesc>* fields = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<FieldDesc>(100, mtServiceability);
     for (FieldStream fd(ik, false, false); !fd.eos(); fd.next()) {
       if (!fd.access_flags().is_static()) {
         fields->append(FieldDesc(fd.field_descriptor()));
       }
     }

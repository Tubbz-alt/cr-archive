<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/memory/heapShared.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="heapInspection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapShared.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/memory/heapShared.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;

  31 #include &quot;logging/log.hpp&quot;
  32 #include &quot;logging/logMessage.hpp&quot;
  33 #include &quot;logging/logStream.hpp&quot;
  34 #include &quot;memory/archiveUtils.hpp&quot;
  35 #include &quot;memory/filemap.hpp&quot;
  36 #include &quot;memory/heapShared.inline.hpp&quot;
  37 #include &quot;memory/iterator.inline.hpp&quot;
  38 #include &quot;memory/metadataFactory.hpp&quot;
  39 #include &quot;memory/metaspaceClosure.hpp&quot;
  40 #include &quot;memory/metaspaceShared.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;memory/universe.hpp&quot;
  43 #include &quot;oops/compressedOops.inline.hpp&quot;
  44 #include &quot;oops/fieldStreams.inline.hpp&quot;
  45 #include &quot;oops/oop.inline.hpp&quot;
  46 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  47 #include &quot;runtime/safepointVerifiers.hpp&quot;
  48 #include &quot;utilities/bitMap.inline.hpp&quot;
  49 #if INCLUDE_G1GC
  50 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
</pre>
<hr />
<pre>
 169   return NULL;
 170 }
 171 
 172 void HeapShared::archive_klass_objects(Thread* THREAD) {
 173   GrowableArray&lt;Klass*&gt;* klasses = MetaspaceShared::collected_klasses();
 174   assert(klasses != NULL, &quot;sanity&quot;);
 175   for (int i = 0; i &lt; klasses-&gt;length(); i++) {
 176     Klass* k = klasses-&gt;at(i);
 177 
 178     // archive mirror object
 179     java_lang_Class::archive_mirror(k, CHECK);
 180 
 181     // archive the resolved_referenes array
 182     if (k-&gt;is_instance_klass()) {
 183       InstanceKlass* ik = InstanceKlass::cast(k);
 184       ik-&gt;constants()-&gt;archive_resolved_references(THREAD);
 185     }
 186   }
 187 }
 188 



















 189 void HeapShared::archive_java_heap_objects(GrowableArray&lt;MemRegion&gt; *closed,
 190                                            GrowableArray&lt;MemRegion&gt; *open) {
 191   if (!is_heap_object_archiving_allowed()) {
 192     log_info(cds)(
 193       &quot;Archived java heap is not supported as UseG1GC, &quot;
 194       &quot;UseCompressedOops and UseCompressedClassPointers are required.&quot;
 195       &quot;Current settings: UseG1GC=%s, UseCompressedOops=%s, UseCompressedClassPointers=%s.&quot;,
 196       BOOL_TO_STR(UseG1GC), BOOL_TO_STR(UseCompressedOops),
 197       BOOL_TO_STR(UseCompressedClassPointers));
 198     return;
 199   }
 200 
 201   G1HeapVerifier::verify_ready_for_archiving();
 202 
 203   {
 204     NoSafepointVerifier nsv;
 205 
 206     // Cache for recording where the archived objects are copied to
 207     create_archived_object_cache();
 208 
</pre>
<hr />
<pre>
 272 // there is no existing one for k. The subgraph_info records the relocated
 273 // Klass* of the original k.
 274 KlassSubGraphInfo* HeapShared::get_subgraph_info(Klass* k) {
 275   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 276   Klass* relocated_k = MetaspaceShared::get_relocated_klass(k);
 277   KlassSubGraphInfo* info = _dump_time_subgraph_info_table-&gt;get(relocated_k);
 278   if (info == NULL) {
 279     _dump_time_subgraph_info_table-&gt;put(relocated_k, KlassSubGraphInfo(relocated_k));
 280     info = _dump_time_subgraph_info_table-&gt;get(relocated_k);
 281     ++ _dump_time_subgraph_info_table-&gt;_count;
 282   }
 283   return info;
 284 }
 285 
 286 // Add an entry field to the current KlassSubGraphInfo.
 287 void KlassSubGraphInfo::add_subgraph_entry_field(
 288       int static_field_offset, oop v, bool is_closed_archive) {
 289   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 290   if (_subgraph_entry_fields == NULL) {
 291     _subgraph_entry_fields =
<span class="line-modified"> 292       new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;juint&gt;(10, true);</span>
 293   }
 294   _subgraph_entry_fields-&gt;append((juint)static_field_offset);
 295   _subgraph_entry_fields-&gt;append(CompressedOops::encode(v));
 296   _subgraph_entry_fields-&gt;append(is_closed_archive ? 1 : 0);
 297 }
 298 
 299 // Add the Klass* for an object in the current KlassSubGraphInfo&#39;s subgraphs.
 300 // Only objects of boot classes can be included in sub-graph.
 301 void KlassSubGraphInfo::add_subgraph_object_klass(Klass* orig_k, Klass *relocated_k) {
 302   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 303   assert(relocated_k == MetaspaceShared::get_relocated_klass(orig_k),
 304          &quot;must be the relocated Klass in the shared space&quot;);
 305 
 306   if (_subgraph_object_klasses == NULL) {
 307     _subgraph_object_klasses =
<span class="line-modified"> 308       new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(50, true);</span>
 309   }
 310 
 311   assert(relocated_k-&gt;is_shared(), &quot;must be a shared class&quot;);
 312 
 313   if (_k == relocated_k) {
 314     // Don&#39;t add the Klass containing the sub-graph to it&#39;s own klass
 315     // initialization list.
 316     return;
 317   }
 318 
 319   if (relocated_k-&gt;is_instance_klass()) {
 320     assert(InstanceKlass::cast(relocated_k)-&gt;is_shared_boot_class(),
 321           &quot;must be boot class&quot;);
 322     // SystemDictionary::xxx_klass() are not updated, need to check
 323     // the original Klass*
 324     if (orig_k == SystemDictionary::String_klass() ||
 325         orig_k == SystemDictionary::Object_klass()) {
 326       // Initialized early during VM initialization. No need to be added
 327       // to the sub-graph object class list.
 328       return;
</pre>
</td>
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
<span class="line-added">  31 #include &quot;gc/shared/gcLocker.hpp&quot;</span>
  32 #include &quot;logging/log.hpp&quot;
  33 #include &quot;logging/logMessage.hpp&quot;
  34 #include &quot;logging/logStream.hpp&quot;
  35 #include &quot;memory/archiveUtils.hpp&quot;
  36 #include &quot;memory/filemap.hpp&quot;
  37 #include &quot;memory/heapShared.inline.hpp&quot;
  38 #include &quot;memory/iterator.inline.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/compressedOops.inline.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/safepointVerifiers.hpp&quot;
  49 #include &quot;utilities/bitMap.inline.hpp&quot;
  50 #if INCLUDE_G1GC
  51 #include &quot;gc/g1/g1CollectedHeap.hpp&quot;
</pre>
<hr />
<pre>
 170   return NULL;
 171 }
 172 
 173 void HeapShared::archive_klass_objects(Thread* THREAD) {
 174   GrowableArray&lt;Klass*&gt;* klasses = MetaspaceShared::collected_klasses();
 175   assert(klasses != NULL, &quot;sanity&quot;);
 176   for (int i = 0; i &lt; klasses-&gt;length(); i++) {
 177     Klass* k = klasses-&gt;at(i);
 178 
 179     // archive mirror object
 180     java_lang_Class::archive_mirror(k, CHECK);
 181 
 182     // archive the resolved_referenes array
 183     if (k-&gt;is_instance_klass()) {
 184       InstanceKlass* ik = InstanceKlass::cast(k);
 185       ik-&gt;constants()-&gt;archive_resolved_references(THREAD);
 186     }
 187   }
 188 }
 189 
<span class="line-added"> 190 void HeapShared::run_full_gc_in_vm_thread() {</span>
<span class="line-added"> 191   if (is_heap_object_archiving_allowed()) {</span>
<span class="line-added"> 192     // Avoid fragmentation while archiving heap objects.</span>
<span class="line-added"> 193     // We do this inside a safepoint, so that no further allocation can happen after GC</span>
<span class="line-added"> 194     // has finished.</span>
<span class="line-added"> 195     if (GCLocker::is_active()) {</span>
<span class="line-added"> 196       // Just checking for safety ...</span>
<span class="line-added"> 197       // This should not happen during -Xshare:dump. If you see this, probably the Java core lib</span>
<span class="line-added"> 198       // has been modified such that JNI code is executed in some clean up threads after</span>
<span class="line-added"> 199       // we have finished class loading.</span>
<span class="line-added"> 200       log_warning(cds)(&quot;GC locker is held, unable to start extra compacting GC. This may produce suboptimal results.&quot;);</span>
<span class="line-added"> 201     } else {</span>
<span class="line-added"> 202       log_info(cds)(&quot;Run GC ...&quot;);</span>
<span class="line-added"> 203       Universe::heap()-&gt;collect_as_vm_thread(GCCause::_archive_time_gc);</span>
<span class="line-added"> 204       log_info(cds)(&quot;Run GC done&quot;);</span>
<span class="line-added"> 205     }</span>
<span class="line-added"> 206   }</span>
<span class="line-added"> 207 }</span>
<span class="line-added"> 208 </span>
 209 void HeapShared::archive_java_heap_objects(GrowableArray&lt;MemRegion&gt; *closed,
 210                                            GrowableArray&lt;MemRegion&gt; *open) {
 211   if (!is_heap_object_archiving_allowed()) {
 212     log_info(cds)(
 213       &quot;Archived java heap is not supported as UseG1GC, &quot;
 214       &quot;UseCompressedOops and UseCompressedClassPointers are required.&quot;
 215       &quot;Current settings: UseG1GC=%s, UseCompressedOops=%s, UseCompressedClassPointers=%s.&quot;,
 216       BOOL_TO_STR(UseG1GC), BOOL_TO_STR(UseCompressedOops),
 217       BOOL_TO_STR(UseCompressedClassPointers));
 218     return;
 219   }
 220 
 221   G1HeapVerifier::verify_ready_for_archiving();
 222 
 223   {
 224     NoSafepointVerifier nsv;
 225 
 226     // Cache for recording where the archived objects are copied to
 227     create_archived_object_cache();
 228 
</pre>
<hr />
<pre>
 292 // there is no existing one for k. The subgraph_info records the relocated
 293 // Klass* of the original k.
 294 KlassSubGraphInfo* HeapShared::get_subgraph_info(Klass* k) {
 295   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 296   Klass* relocated_k = MetaspaceShared::get_relocated_klass(k);
 297   KlassSubGraphInfo* info = _dump_time_subgraph_info_table-&gt;get(relocated_k);
 298   if (info == NULL) {
 299     _dump_time_subgraph_info_table-&gt;put(relocated_k, KlassSubGraphInfo(relocated_k));
 300     info = _dump_time_subgraph_info_table-&gt;get(relocated_k);
 301     ++ _dump_time_subgraph_info_table-&gt;_count;
 302   }
 303   return info;
 304 }
 305 
 306 // Add an entry field to the current KlassSubGraphInfo.
 307 void KlassSubGraphInfo::add_subgraph_entry_field(
 308       int static_field_offset, oop v, bool is_closed_archive) {
 309   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 310   if (_subgraph_entry_fields == NULL) {
 311     _subgraph_entry_fields =
<span class="line-modified"> 312       new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;juint&gt;(10, mtClass);</span>
 313   }
 314   _subgraph_entry_fields-&gt;append((juint)static_field_offset);
 315   _subgraph_entry_fields-&gt;append(CompressedOops::encode(v));
 316   _subgraph_entry_fields-&gt;append(is_closed_archive ? 1 : 0);
 317 }
 318 
 319 // Add the Klass* for an object in the current KlassSubGraphInfo&#39;s subgraphs.
 320 // Only objects of boot classes can be included in sub-graph.
 321 void KlassSubGraphInfo::add_subgraph_object_klass(Klass* orig_k, Klass *relocated_k) {
 322   assert(DumpSharedSpaces, &quot;dump time only&quot;);
 323   assert(relocated_k == MetaspaceShared::get_relocated_klass(orig_k),
 324          &quot;must be the relocated Klass in the shared space&quot;);
 325 
 326   if (_subgraph_object_klasses == NULL) {
 327     _subgraph_object_klasses =
<span class="line-modified"> 328       new(ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(50, mtClass);</span>
 329   }
 330 
 331   assert(relocated_k-&gt;is_shared(), &quot;must be a shared class&quot;);
 332 
 333   if (_k == relocated_k) {
 334     // Don&#39;t add the Klass containing the sub-graph to it&#39;s own klass
 335     // initialization list.
 336     return;
 337   }
 338 
 339   if (relocated_k-&gt;is_instance_klass()) {
 340     assert(InstanceKlass::cast(relocated_k)-&gt;is_shared_boot_class(),
 341           &quot;must be boot class&quot;);
 342     // SystemDictionary::xxx_klass() are not updated, need to check
 343     // the original Klass*
 344     if (orig_k == SystemDictionary::String_klass() ||
 345         orig_k == SystemDictionary::Object_klass()) {
 346       // Initialized early during VM initialization. No need to be added
 347       // to the sub-graph object class list.
 348       return;
</pre>
</td>
</tr>
</table>
<center><a href="heapInspection.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="heapShared.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
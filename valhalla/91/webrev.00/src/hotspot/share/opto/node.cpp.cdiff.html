<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/node.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/node.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 2161,67 ***</span>
      if( n != NULL )
        in(i)-&gt;verify_edges(visited);
    }
  }
  
<span class="line-modified">! void Node::verify_recur(const Node *n, int verify_depth,</span>
<span class="line-modified">!                         VectorSet &amp;old_space, VectorSet &amp;new_space) {</span>
<span class="line-modified">!   if ( verify_depth == 0 )  return;</span>
<span class="line-modified">!   if (verify_depth &gt; 0)  --verify_depth;</span>
<span class="line-modified">! </span>
    Compile* C = Compile::current();
  
<span class="line-removed">-   // Contained in new_space or old_space?</span>
<span class="line-removed">-   VectorSet *v = C-&gt;node_arena()-&gt;contains(n) ? &amp;new_space : &amp;old_space;</span>
<span class="line-removed">-   // Check for visited in the proper space.  Numberings are not unique</span>
<span class="line-removed">-   // across spaces so we need a separate VectorSet for each space.</span>
<span class="line-removed">-   if( v-&gt;test_set(n-&gt;_idx) ) return;</span>
  
<span class="line-modified">!   if (n-&gt;is_Con() &amp;&amp; n-&gt;bottom_type() == Type::TOP) {</span>
<span class="line-modified">!     if (C-&gt;cached_top_node() == NULL)</span>
<span class="line-modified">!       C-&gt;set_cached_top_node((Node*)n);</span>
<span class="line-modified">!     assert(C-&gt;cached_top_node() == n, &quot;TOP node must be unique&quot;);</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   for( uint i = 0; i &lt; n-&gt;len(); i++ ) {</span>
<span class="line-modified">!     Node *x = n-&gt;in(i);</span>
<span class="line-modified">!     if (!x || x-&gt;is_top()) continue;</span>
  
<span class="line-modified">!     // Verify my input has a def-use edge to me</span>
<span class="line-removed">-     if (true /*VerifyDefUse*/) {</span>
        // Count use-def edges from n to x
        int cnt = 0;
<span class="line-modified">!       for( uint j = 0; j &lt; n-&gt;len(); j++ )</span>
<span class="line-modified">!         if( n-&gt;in(j) == x )</span>
            cnt++;
        // Count def-use edges from x to n
        uint max = x-&gt;_outcnt;
<span class="line-modified">!       for( uint k = 0; k &lt; max; k++ )</span>
<span class="line-modified">!         if (x-&gt;_out[k] == n)</span>
            cnt--;
<span class="line-modified">!       assert( cnt == 0, &quot;mismatched def-use edge counts&quot; );</span>
      }
  
<span class="line-modified">!     verify_recur(x, verify_depth, old_space, new_space);</span>
    }
<span class="line-removed">- </span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- //------------------------------verify-----------------------------------------</span>
<span class="line-removed">- // Check Def-Use info for my subgraph</span>
<span class="line-removed">- void Node::verify() const {</span>
<span class="line-removed">-   Compile* C = Compile::current();</span>
<span class="line-removed">-   Node* old_top = C-&gt;cached_top_node();</span>
<span class="line-removed">-   ResourceMark rm;</span>
<span class="line-removed">-   ResourceArea *area = Thread::current()-&gt;resource_area();</span>
<span class="line-removed">-   VectorSet old_space(area), new_space(area);</span>
<span class="line-removed">-   verify_recur(this, -1, old_space, new_space);</span>
<span class="line-removed">-   C-&gt;set_cached_top_node(old_top);</span>
  }
  #endif
  
<span class="line-removed">- </span>
  //------------------------------walk-------------------------------------------
  // Graph walk, with both pre-order and post-order functions
  void Node::walk(NFunc pre, NFunc post, void *env) {
    VectorSet visited(Thread::current()-&gt;resource_area()); // Setup for local walk
    walk_(pre, post, env, visited);
<span class="line-new-header">--- 2161,83 ---</span>
      if( n != NULL )
        in(i)-&gt;verify_edges(visited);
    }
  }
  
<span class="line-modified">! // Verify all nodes if verify_depth is negative</span>
<span class="line-modified">! void Node::verify(Node* n, int verify_depth) {</span>
<span class="line-modified">!   assert(verify_depth != 0, &quot;depth should not be 0&quot;);</span>
<span class="line-modified">!   ResourceMark rm;</span>
<span class="line-modified">!   ResourceArea* area = Thread::current()-&gt;resource_area();</span>
<span class="line-added">+   VectorSet old_space(area);</span>
<span class="line-added">+   VectorSet new_space(area);</span>
<span class="line-added">+   Node_List worklist(area);</span>
<span class="line-added">+   worklist.push(n);</span>
    Compile* C = Compile::current();
<span class="line-added">+   uint last_index_on_current_depth = 0;</span>
<span class="line-added">+   verify_depth--; // Visiting the first node on depth 1</span>
<span class="line-added">+   // Only add nodes to worklist if verify_depth is negative (visit all nodes) or greater than 0</span>
<span class="line-added">+   bool add_to_worklist = verify_depth != 0;</span>
  
  
<span class="line-modified">!   for (uint list_index = 0; list_index &lt; worklist.size(); list_index++) {</span>
<span class="line-modified">!     n = worklist[list_index];</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (n-&gt;is_Con() &amp;&amp; n-&gt;bottom_type() == Type::TOP) {</span>
<span class="line-modified">!       if (C-&gt;cached_top_node() == NULL) {</span>
<span class="line-added">+         C-&gt;set_cached_top_node((Node*)n);</span>
<span class="line-added">+       }</span>
<span class="line-added">+       assert(C-&gt;cached_top_node() == n, &quot;TOP node must be unique&quot;);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     for (uint i = 0; i &lt; n-&gt;len(); i++) {</span>
<span class="line-modified">!       Node* x = n-&gt;in(i);</span>
<span class="line-modified">!       if (!x || x-&gt;is_top()) {</span>
<span class="line-added">+         continue;</span>
<span class="line-added">+       }</span>
  
<span class="line-modified">!       // Verify my input has a def-use edge to me</span>
        // Count use-def edges from n to x
        int cnt = 0;
<span class="line-modified">!       for (uint j = 0; j &lt; n-&gt;len(); j++) {</span>
<span class="line-modified">!         if (n-&gt;in(j) == x) {</span>
            cnt++;
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
        // Count def-use edges from x to n
        uint max = x-&gt;_outcnt;
<span class="line-modified">!       for (uint k = 0; k &lt; max; k++) {</span>
<span class="line-modified">!         if (x-&gt;_out[k] == n) {</span>
            cnt--;
<span class="line-modified">!         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+       assert(cnt == 0, &quot;mismatched def-use edge counts&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+       // Contained in new_space or old_space?</span>
<span class="line-added">+       VectorSet* v = C-&gt;node_arena()-&gt;contains(x) ? &amp;new_space : &amp;old_space;</span>
<span class="line-added">+       // Check for visited in the proper space. Numberings are not unique</span>
<span class="line-added">+       // across spaces so we need a separate VectorSet for each space.</span>
<span class="line-added">+       if (add_to_worklist &amp;&amp; !v-&gt;test_set(x-&gt;_idx)) {</span>
<span class="line-added">+         worklist.push(x);</span>
<span class="line-added">+       }</span>
      }
  
<span class="line-modified">!     if (verify_depth &gt; 0 &amp;&amp; list_index == last_index_on_current_depth) {</span>
<span class="line-added">+       // All nodes on this depth were processed and its inputs are on the worklist. Decrement verify_depth and</span>
<span class="line-added">+       // store the current last list index which is the last node in the list with the new depth. All nodes</span>
<span class="line-added">+       // added afterwards will have a new depth again. Stop adding new nodes if depth limit is reached (=0).</span>
<span class="line-added">+       verify_depth--;</span>
<span class="line-added">+       if (verify_depth == 0) {</span>
<span class="line-added">+         add_to_worklist = false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       last_index_on_current_depth = worklist.size() - 1;</span>
<span class="line-added">+     }</span>
    }
  }
  #endif
  
  //------------------------------walk-------------------------------------------
  // Graph walk, with both pre-order and post-order functions
  void Node::walk(NFunc pre, NFunc post, void *env) {
    VectorSet visited(Thread::current()-&gt;resource_area()); // Setup for local walk
    walk_(pre, post, env, visited);
</pre>
<center><a href="macro.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
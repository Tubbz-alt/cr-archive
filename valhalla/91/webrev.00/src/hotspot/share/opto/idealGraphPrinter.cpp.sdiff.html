<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/idealGraphPrinter.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="idealGraphPrinter.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/idealGraphPrinter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 58 const char *IdealGraphPrinter::TO_PROPERTY = &quot;to&quot;;
 59 const char *IdealGraphPrinter::PROPERTY_NAME_PROPERTY = &quot;name&quot;;
 60 const char *IdealGraphPrinter::GRAPH_NAME_PROPERTY = &quot;name&quot;;
 61 const char *IdealGraphPrinter::INDEX_PROPERTY = &quot;index&quot;;
 62 const char *IdealGraphPrinter::METHOD_ELEMENT = &quot;method&quot;;
 63 const char *IdealGraphPrinter::INLINE_ELEMENT = &quot;inlined&quot;;
 64 const char *IdealGraphPrinter::BYTECODES_ELEMENT = &quot;bytecodes&quot;;
 65 const char *IdealGraphPrinter::METHOD_BCI_PROPERTY = &quot;bci&quot;;
 66 const char *IdealGraphPrinter::METHOD_SHORT_NAME_PROPERTY = &quot;shortName&quot;;
 67 const char *IdealGraphPrinter::CONTROL_FLOW_ELEMENT = &quot;controlFlow&quot;;
 68 const char *IdealGraphPrinter::BLOCK_NAME_PROPERTY = &quot;name&quot;;
 69 const char *IdealGraphPrinter::BLOCK_DOMINATOR_PROPERTY = &quot;dom&quot;;
 70 const char *IdealGraphPrinter::BLOCK_ELEMENT = &quot;block&quot;;
 71 const char *IdealGraphPrinter::SUCCESSORS_ELEMENT = &quot;successors&quot;;
 72 const char *IdealGraphPrinter::SUCCESSOR_ELEMENT = &quot;successor&quot;;
 73 const char *IdealGraphPrinter::ASSEMBLY_ELEMENT = &quot;assembly&quot;;
 74 
 75 int IdealGraphPrinter::_file_count = 0;
 76 
 77 IdealGraphPrinter *IdealGraphPrinter::printer() {
<span class="line-removed"> 78   if (!PrintIdealGraph) {</span>
<span class="line-removed"> 79     return NULL;</span>
<span class="line-removed"> 80   }</span>
<span class="line-removed"> 81 </span>
 82   JavaThread *thread = JavaThread::current();
 83   if (!thread-&gt;is_Compiler_thread()) return NULL;
 84 
 85   CompilerThread *compiler_thread = (CompilerThread *)thread;
 86   if (compiler_thread-&gt;ideal_graph_printer() == NULL) {
 87     IdealGraphPrinter *printer = new IdealGraphPrinter();
 88     compiler_thread-&gt;set_ideal_graph_printer(printer);
 89   }
 90 
 91   return compiler_thread-&gt;ideal_graph_printer();
 92 }
 93 
 94 void IdealGraphPrinter::clean_up() {
 95   for (JavaThreadIteratorWithHandle jtiwh; JavaThread* p = jtiwh.next(); ) {
 96     if (p-&gt;is_Compiler_thread()) {
 97       CompilerThread* c = (CompilerThread*)p;
 98       IdealGraphPrinter* printer = c-&gt;ideal_graph_printer();
 99       if (printer) {
100         delete printer;
101       }
</pre>
<hr />
<pre>
616     if (_traverse_outs) {
617       for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {
618         Node* p = n-&gt;out(i);
619         if (!visited.test_set(p-&gt;_idx)) {
620           nodeStack.push(p);
621         }
622       }
623     }
624 
625     for ( uint i = 0; i &lt; n-&gt;len(); i++ ) {
626       if ( n-&gt;in(i) ) {
627         if (!visited.test_set(n-&gt;in(i)-&gt;_idx)) {
628           nodeStack.push(n-&gt;in(i));
629         }
630       }
631     }
632   }
633 }
634 
635 void IdealGraphPrinter::print_method(const char *name, int level) {
<span class="line-modified">636   if (should_print(level)) {</span>
637     print(name, (Node *) C-&gt;root());
638   }
639 }
640 
641 // Print current ideal graph
642 void IdealGraphPrinter::print(const char *name, Node *node) {
643 
644   if (!_current_method || !_should_send_method || node == NULL) return;
645 
646   // Warning, unsafe cast?
647   _chaitin = (PhaseChaitin *)C-&gt;regalloc();
648 
649   begin_head(GRAPH_ELEMENT);
650   print_attr(GRAPH_NAME_PROPERTY, (const char *)name);
651   end_head();
652 
653   VectorSet temp_set(Thread::current()-&gt;resource_area());
654 
655   head(NODES_ELEMENT);
656   walk_nodes(node, false, &amp;temp_set);
</pre>
<hr />
<pre>
674         end_elem();
675       }
676       tail(SUCCESSORS_ELEMENT);
677 
678       head(NODES_ELEMENT);
679       for (uint s = 0; s &lt; block-&gt;number_of_nodes(); s++) {
680         begin_elem(NODE_ELEMENT);
681         print_attr(NODE_ID_PROPERTY, block-&gt;get_node(s)-&gt;_idx);
682         end_elem();
683       }
684       tail(NODES_ELEMENT);
685 
686       tail(BLOCK_ELEMENT);
687     }
688     tail(CONTROL_FLOW_ELEMENT);
689   }
690   tail(GRAPH_ELEMENT);
691   _xml-&gt;flush();
692 }
693 
<span class="line-removed">694 // Should method be printed?</span>
<span class="line-removed">695 bool IdealGraphPrinter::should_print(int level) {</span>
<span class="line-removed">696   return C-&gt;directive()-&gt;IGVPrintLevelOption &gt;= level;</span>
<span class="line-removed">697 }</span>
<span class="line-removed">698 </span>
699 void IdealGraphPrinter::init_file_stream(const char* file_name, bool use_multiple_files, bool append) {
700   ThreadCritical tc;
701   if (use_multiple_files &amp;&amp; _file_count != 0) {
702     assert(!append, &quot;append should only be used for debugging with a single file&quot;);
703     ResourceMark rm;
704     stringStream st;
705     const char* dot = strrchr(file_name, &#39;.&#39;);
706     if (dot) {
707       st.write(file_name, dot - file_name);
708       st.print(&quot;%d%s&quot;, _file_count, dot);
709     } else {
710       st.print(&quot;%s%d&quot;, file_name, _file_count);
711     }
712     _output = new (ResourceObj::C_HEAP, mtCompiler) fileStream(st.as_string(), &quot;w&quot;);
713   } else {
714     _output = new (ResourceObj::C_HEAP, mtCompiler) fileStream(file_name, append ? &quot;a&quot; : &quot;w&quot;);
715   }
716   if (use_multiple_files) {
717     assert(!append, &quot;append should only be used for debugging with a single file&quot;);
718     _file_count++;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2007, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
</pre>
<hr />
<pre>
 58 const char *IdealGraphPrinter::TO_PROPERTY = &quot;to&quot;;
 59 const char *IdealGraphPrinter::PROPERTY_NAME_PROPERTY = &quot;name&quot;;
 60 const char *IdealGraphPrinter::GRAPH_NAME_PROPERTY = &quot;name&quot;;
 61 const char *IdealGraphPrinter::INDEX_PROPERTY = &quot;index&quot;;
 62 const char *IdealGraphPrinter::METHOD_ELEMENT = &quot;method&quot;;
 63 const char *IdealGraphPrinter::INLINE_ELEMENT = &quot;inlined&quot;;
 64 const char *IdealGraphPrinter::BYTECODES_ELEMENT = &quot;bytecodes&quot;;
 65 const char *IdealGraphPrinter::METHOD_BCI_PROPERTY = &quot;bci&quot;;
 66 const char *IdealGraphPrinter::METHOD_SHORT_NAME_PROPERTY = &quot;shortName&quot;;
 67 const char *IdealGraphPrinter::CONTROL_FLOW_ELEMENT = &quot;controlFlow&quot;;
 68 const char *IdealGraphPrinter::BLOCK_NAME_PROPERTY = &quot;name&quot;;
 69 const char *IdealGraphPrinter::BLOCK_DOMINATOR_PROPERTY = &quot;dom&quot;;
 70 const char *IdealGraphPrinter::BLOCK_ELEMENT = &quot;block&quot;;
 71 const char *IdealGraphPrinter::SUCCESSORS_ELEMENT = &quot;successors&quot;;
 72 const char *IdealGraphPrinter::SUCCESSOR_ELEMENT = &quot;successor&quot;;
 73 const char *IdealGraphPrinter::ASSEMBLY_ELEMENT = &quot;assembly&quot;;
 74 
 75 int IdealGraphPrinter::_file_count = 0;
 76 
 77 IdealGraphPrinter *IdealGraphPrinter::printer() {




 78   JavaThread *thread = JavaThread::current();
 79   if (!thread-&gt;is_Compiler_thread()) return NULL;
 80 
 81   CompilerThread *compiler_thread = (CompilerThread *)thread;
 82   if (compiler_thread-&gt;ideal_graph_printer() == NULL) {
 83     IdealGraphPrinter *printer = new IdealGraphPrinter();
 84     compiler_thread-&gt;set_ideal_graph_printer(printer);
 85   }
 86 
 87   return compiler_thread-&gt;ideal_graph_printer();
 88 }
 89 
 90 void IdealGraphPrinter::clean_up() {
 91   for (JavaThreadIteratorWithHandle jtiwh; JavaThread* p = jtiwh.next(); ) {
 92     if (p-&gt;is_Compiler_thread()) {
 93       CompilerThread* c = (CompilerThread*)p;
 94       IdealGraphPrinter* printer = c-&gt;ideal_graph_printer();
 95       if (printer) {
 96         delete printer;
 97       }
</pre>
<hr />
<pre>
612     if (_traverse_outs) {
613       for (DUIterator i = n-&gt;outs(); n-&gt;has_out(i); i++) {
614         Node* p = n-&gt;out(i);
615         if (!visited.test_set(p-&gt;_idx)) {
616           nodeStack.push(p);
617         }
618       }
619     }
620 
621     for ( uint i = 0; i &lt; n-&gt;len(); i++ ) {
622       if ( n-&gt;in(i) ) {
623         if (!visited.test_set(n-&gt;in(i)-&gt;_idx)) {
624           nodeStack.push(n-&gt;in(i));
625         }
626       }
627     }
628   }
629 }
630 
631 void IdealGraphPrinter::print_method(const char *name, int level) {
<span class="line-modified">632   if (C-&gt;should_print(level)) {</span>
633     print(name, (Node *) C-&gt;root());
634   }
635 }
636 
637 // Print current ideal graph
638 void IdealGraphPrinter::print(const char *name, Node *node) {
639 
640   if (!_current_method || !_should_send_method || node == NULL) return;
641 
642   // Warning, unsafe cast?
643   _chaitin = (PhaseChaitin *)C-&gt;regalloc();
644 
645   begin_head(GRAPH_ELEMENT);
646   print_attr(GRAPH_NAME_PROPERTY, (const char *)name);
647   end_head();
648 
649   VectorSet temp_set(Thread::current()-&gt;resource_area());
650 
651   head(NODES_ELEMENT);
652   walk_nodes(node, false, &amp;temp_set);
</pre>
<hr />
<pre>
670         end_elem();
671       }
672       tail(SUCCESSORS_ELEMENT);
673 
674       head(NODES_ELEMENT);
675       for (uint s = 0; s &lt; block-&gt;number_of_nodes(); s++) {
676         begin_elem(NODE_ELEMENT);
677         print_attr(NODE_ID_PROPERTY, block-&gt;get_node(s)-&gt;_idx);
678         end_elem();
679       }
680       tail(NODES_ELEMENT);
681 
682       tail(BLOCK_ELEMENT);
683     }
684     tail(CONTROL_FLOW_ELEMENT);
685   }
686   tail(GRAPH_ELEMENT);
687   _xml-&gt;flush();
688 }
689 





690 void IdealGraphPrinter::init_file_stream(const char* file_name, bool use_multiple_files, bool append) {
691   ThreadCritical tc;
692   if (use_multiple_files &amp;&amp; _file_count != 0) {
693     assert(!append, &quot;append should only be used for debugging with a single file&quot;);
694     ResourceMark rm;
695     stringStream st;
696     const char* dot = strrchr(file_name, &#39;.&#39;);
697     if (dot) {
698       st.write(file_name, dot - file_name);
699       st.print(&quot;%d%s&quot;, _file_count, dot);
700     } else {
701       st.print(&quot;%s%d&quot;, file_name, _file_count);
702     }
703     _output = new (ResourceObj::C_HEAP, mtCompiler) fileStream(st.as_string(), &quot;w&quot;);
704   } else {
705     _output = new (ResourceObj::C_HEAP, mtCompiler) fileStream(file_name, append ? &quot;a&quot; : &quot;w&quot;);
706   }
707   if (use_multiple_files) {
708     assert(!append, &quot;append should only be used for debugging with a single file&quot;);
709     _file_count++;
</pre>
</td>
</tr>
</table>
<center><a href="compile.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="idealGraphPrinter.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
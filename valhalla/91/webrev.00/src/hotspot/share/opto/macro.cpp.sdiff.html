<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macro.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="idealGraphPrinter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 391   Node* region = mem-&gt;in(0);
 392   for (DUIterator_Fast kmax, k = region-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 393     Node* phi = region-&gt;fast_out(k);
 394     if (phi-&gt;is_Phi() &amp;&amp; phi != mem &amp;&amp;
 395         phi-&gt;as_Phi()-&gt;is_same_inst_field(phi_type, (int)mem-&gt;_idx, instance_id, alias_idx, offset)) {
 396       return phi;
 397     }
 398   }
 399   // Check if an appropriate new value phi already exists.
 400   Node* new_phi = value_phis-&gt;find(mem-&gt;_idx);
 401   if (new_phi != NULL)
 402     return new_phi;
 403 
 404   if (level &lt;= 0) {
 405     return NULL; // Give up: phi tree too deep
 406   }
 407   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 408   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 409 
 410   uint length = mem-&gt;req();
<span class="line-modified"> 411   GrowableArray &lt;Node *&gt; values(length, length, NULL, false);</span>
 412 
 413   // create a new Phi for the value
 414   PhiNode *phi = new PhiNode(mem-&gt;in(0), phi_type, NULL, mem-&gt;_idx, instance_id, alias_idx, offset);
 415   transform_later(phi);
 416   value_phis-&gt;push(phi, mem-&gt;_idx);
 417 
 418   for (uint j = 1; j &lt; length; j++) {
 419     Node *in = mem-&gt;in(j);
 420     if (in == NULL || in-&gt;is_top()) {
 421       values.at_put(j, in);
 422     } else  {
 423       Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 424       if (val == start_mem || val == alloc_mem) {
 425         // hit a sentinel, return appropriate 0 value
 426         Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);
 427         if (default_value != NULL) {
 428           values.at_put(j, default_value);
 429         } else {
 430           assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);
 431           values.at_put(j, _igvn.zerocon(ft));
</pre>
</td>
<td>
<hr />
<pre>
 391   Node* region = mem-&gt;in(0);
 392   for (DUIterator_Fast kmax, k = region-&gt;fast_outs(kmax); k &lt; kmax; k++) {
 393     Node* phi = region-&gt;fast_out(k);
 394     if (phi-&gt;is_Phi() &amp;&amp; phi != mem &amp;&amp;
 395         phi-&gt;as_Phi()-&gt;is_same_inst_field(phi_type, (int)mem-&gt;_idx, instance_id, alias_idx, offset)) {
 396       return phi;
 397     }
 398   }
 399   // Check if an appropriate new value phi already exists.
 400   Node* new_phi = value_phis-&gt;find(mem-&gt;_idx);
 401   if (new_phi != NULL)
 402     return new_phi;
 403 
 404   if (level &lt;= 0) {
 405     return NULL; // Give up: phi tree too deep
 406   }
 407   Node *start_mem = C-&gt;start()-&gt;proj_out_or_null(TypeFunc::Memory);
 408   Node *alloc_mem = alloc-&gt;in(TypeFunc::Memory);
 409 
 410   uint length = mem-&gt;req();
<span class="line-modified"> 411   GrowableArray &lt;Node *&gt; values(length, length, NULL);</span>
 412 
 413   // create a new Phi for the value
 414   PhiNode *phi = new PhiNode(mem-&gt;in(0), phi_type, NULL, mem-&gt;_idx, instance_id, alias_idx, offset);
 415   transform_later(phi);
 416   value_phis-&gt;push(phi, mem-&gt;_idx);
 417 
 418   for (uint j = 1; j &lt; length; j++) {
 419     Node *in = mem-&gt;in(j);
 420     if (in == NULL || in-&gt;is_top()) {
 421       values.at_put(j, in);
 422     } else  {
 423       Node *val = scan_mem_chain(in, alias_idx, offset, start_mem, alloc, &amp;_igvn);
 424       if (val == start_mem || val == alloc_mem) {
 425         // hit a sentinel, return appropriate 0 value
 426         Node* default_value = alloc-&gt;in(AllocateNode::DefaultValue);
 427         if (default_value != NULL) {
 428           values.at_put(j, default_value);
 429         } else {
 430           assert(alloc-&gt;in(AllocateNode::RawDefaultValue) == NULL, &quot;default value may not be null&quot;);
 431           values.at_put(j, _igvn.zerocon(ft));
</pre>
</td>
</tr>
</table>
<center><a href="idealGraphPrinter.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
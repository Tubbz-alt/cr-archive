<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/codeCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/codeCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 133     } else {
 134       code_size        += cb-&gt;code_size();
 135     }
 136   }
 137 };
 138 
 139 // Iterate over all CodeHeaps
 140 #define FOR_ALL_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _heaps-&gt;begin(); heap != _heaps-&gt;end(); ++heap)
 141 #define FOR_ALL_NMETHOD_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _nmethod_heaps-&gt;begin(); heap != _nmethod_heaps-&gt;end(); ++heap)
 142 #define FOR_ALL_ALLOCABLE_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _allocable_heaps-&gt;begin(); heap != _allocable_heaps-&gt;end(); ++heap)
 143 
 144 // Iterate over all CodeBlobs (cb) on the given CodeHeap
 145 #define FOR_ALL_BLOBS(cb, heap) for (CodeBlob* cb = first_blob(heap); cb != NULL; cb = next_blob(heap, cb))
 146 
 147 address CodeCache::_low_bound = 0;
 148 address CodeCache::_high_bound = 0;
 149 int CodeCache::_number_of_nmethods_with_dependencies = 0;
 150 ExceptionCache* volatile CodeCache::_exception_cache_purge_list = NULL;
 151 
 152 // Initialize arrays of CodeHeap subsets
<span class="line-modified"> 153 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);</span>
<span class="line-modified"> 154 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_compiled_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);</span>
<span class="line-modified"> 155 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_nmethod_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);</span>
<span class="line-modified"> 156 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_allocable_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, true);</span>
 157 
 158 void CodeCache::check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set) {
 159   size_t total_size = non_nmethod_size + profiled_size + non_profiled_size;
 160   // Prepare error message
 161   const char* error = &quot;Invalid code heap sizes&quot;;
 162   err_msg message(&quot;NonNMethodCodeHeapSize (&quot; SIZE_FORMAT &quot;K) + ProfiledCodeHeapSize (&quot; SIZE_FORMAT &quot;K)&quot;
 163                   &quot; + NonProfiledCodeHeapSize (&quot; SIZE_FORMAT &quot;K) = &quot; SIZE_FORMAT &quot;K&quot;,
 164           non_nmethod_size/K, profiled_size/K, non_profiled_size/K, total_size/K);
 165 
 166   if (total_size &gt; cache_size) {
 167     // Some code heap sizes were explicitly set: total_size must be &lt;= cache_size
 168     message.append(&quot; is greater than ReservedCodeCacheSize (&quot; SIZE_FORMAT &quot;K).&quot;, cache_size/K);
 169     vm_exit_during_initialization(error, message);
 170   } else if (all_set &amp;&amp; total_size != cache_size) {
 171     // All code heap sizes were explicitly set: total_size must equal cache_size
 172     message.append(&quot; is not equal to ReservedCodeCacheSize (&quot; SIZE_FORMAT &quot;K).&quot;, cache_size/K);
 173     vm_exit_during_initialization(error, message);
 174   }
 175 }
 176 
</pre>
<hr />
<pre>
1026   assert(cb == NULL || cb-&gt;is_compiled(), &quot;did not find an compiled_method&quot;);
1027   return (CompiledMethod*)cb;
1028 }
1029 
1030 bool CodeCache::is_far_target(address target) {
1031 #if INCLUDE_AOT
1032   return NativeCall::is_far_call(_low_bound,  target) ||
1033          NativeCall::is_far_call(_high_bound, target);
1034 #else
1035   return false;
1036 #endif
1037 }
1038 
1039 #if INCLUDE_JVMTI
1040 // RedefineClasses support for unloading nmethods that are dependent on &quot;old&quot; methods.
1041 // We don&#39;t really expect this table to grow very large.  If it does, it can become a hashtable.
1042 static GrowableArray&lt;CompiledMethod*&gt;* old_compiled_method_table = NULL;
1043 
1044 static void add_to_old_table(CompiledMethod* c) {
1045   if (old_compiled_method_table == NULL) {
<span class="line-modified">1046     old_compiled_method_table = new (ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CompiledMethod*&gt;(100, true);</span>
1047   }
1048   old_compiled_method_table-&gt;push(c);
1049 }
1050 
1051 static void reset_old_method_table() {
1052   if (old_compiled_method_table != NULL) {
1053     delete old_compiled_method_table;
1054     old_compiled_method_table = NULL;
1055   }
1056 }
1057 
1058 // Remove this method when zombied or unloaded.
1059 void CodeCache::unregister_old_nmethod(CompiledMethod* c) {
1060   assert_lock_strong(CodeCache_lock);
1061   if (old_compiled_method_table != NULL) {
1062     int index = old_compiled_method_table-&gt;find(c);
1063     if (index != -1) {
1064       old_compiled_method_table-&gt;delete_at(index);
1065     }
1066   }
</pre>
</td>
<td>
<hr />
<pre>
 133     } else {
 134       code_size        += cb-&gt;code_size();
 135     }
 136   }
 137 };
 138 
 139 // Iterate over all CodeHeaps
 140 #define FOR_ALL_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _heaps-&gt;begin(); heap != _heaps-&gt;end(); ++heap)
 141 #define FOR_ALL_NMETHOD_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _nmethod_heaps-&gt;begin(); heap != _nmethod_heaps-&gt;end(); ++heap)
 142 #define FOR_ALL_ALLOCABLE_HEAPS(heap) for (GrowableArrayIterator&lt;CodeHeap*&gt; heap = _allocable_heaps-&gt;begin(); heap != _allocable_heaps-&gt;end(); ++heap)
 143 
 144 // Iterate over all CodeBlobs (cb) on the given CodeHeap
 145 #define FOR_ALL_BLOBS(cb, heap) for (CodeBlob* cb = first_blob(heap); cb != NULL; cb = next_blob(heap, cb))
 146 
 147 address CodeCache::_low_bound = 0;
 148 address CodeCache::_high_bound = 0;
 149 int CodeCache::_number_of_nmethods_with_dependencies = 0;
 150 ExceptionCache* volatile CodeCache::_exception_cache_purge_list = NULL;
 151 
 152 // Initialize arrays of CodeHeap subsets
<span class="line-modified"> 153 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, mtCode);</span>
<span class="line-modified"> 154 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_compiled_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, mtCode);</span>
<span class="line-modified"> 155 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_nmethod_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, mtCode);</span>
<span class="line-modified"> 156 GrowableArray&lt;CodeHeap*&gt;* CodeCache::_allocable_heaps = new(ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CodeHeap*&gt; (CodeBlobType::All, mtCode);</span>
 157 
 158 void CodeCache::check_heap_sizes(size_t non_nmethod_size, size_t profiled_size, size_t non_profiled_size, size_t cache_size, bool all_set) {
 159   size_t total_size = non_nmethod_size + profiled_size + non_profiled_size;
 160   // Prepare error message
 161   const char* error = &quot;Invalid code heap sizes&quot;;
 162   err_msg message(&quot;NonNMethodCodeHeapSize (&quot; SIZE_FORMAT &quot;K) + ProfiledCodeHeapSize (&quot; SIZE_FORMAT &quot;K)&quot;
 163                   &quot; + NonProfiledCodeHeapSize (&quot; SIZE_FORMAT &quot;K) = &quot; SIZE_FORMAT &quot;K&quot;,
 164           non_nmethod_size/K, profiled_size/K, non_profiled_size/K, total_size/K);
 165 
 166   if (total_size &gt; cache_size) {
 167     // Some code heap sizes were explicitly set: total_size must be &lt;= cache_size
 168     message.append(&quot; is greater than ReservedCodeCacheSize (&quot; SIZE_FORMAT &quot;K).&quot;, cache_size/K);
 169     vm_exit_during_initialization(error, message);
 170   } else if (all_set &amp;&amp; total_size != cache_size) {
 171     // All code heap sizes were explicitly set: total_size must equal cache_size
 172     message.append(&quot; is not equal to ReservedCodeCacheSize (&quot; SIZE_FORMAT &quot;K).&quot;, cache_size/K);
 173     vm_exit_during_initialization(error, message);
 174   }
 175 }
 176 
</pre>
<hr />
<pre>
1026   assert(cb == NULL || cb-&gt;is_compiled(), &quot;did not find an compiled_method&quot;);
1027   return (CompiledMethod*)cb;
1028 }
1029 
1030 bool CodeCache::is_far_target(address target) {
1031 #if INCLUDE_AOT
1032   return NativeCall::is_far_call(_low_bound,  target) ||
1033          NativeCall::is_far_call(_high_bound, target);
1034 #else
1035   return false;
1036 #endif
1037 }
1038 
1039 #if INCLUDE_JVMTI
1040 // RedefineClasses support for unloading nmethods that are dependent on &quot;old&quot; methods.
1041 // We don&#39;t really expect this table to grow very large.  If it does, it can become a hashtable.
1042 static GrowableArray&lt;CompiledMethod*&gt;* old_compiled_method_table = NULL;
1043 
1044 static void add_to_old_table(CompiledMethod* c) {
1045   if (old_compiled_method_table == NULL) {
<span class="line-modified">1046     old_compiled_method_table = new (ResourceObj::C_HEAP, mtCode) GrowableArray&lt;CompiledMethod*&gt;(100, mtCode);</span>
1047   }
1048   old_compiled_method_table-&gt;push(c);
1049 }
1050 
1051 static void reset_old_method_table() {
1052   if (old_compiled_method_table != NULL) {
1053     delete old_compiled_method_table;
1054     old_compiled_method_table = NULL;
1055   }
1056 }
1057 
1058 // Remove this method when zombied or unloaded.
1059 void CodeCache::unregister_old_nmethod(CompiledMethod* c) {
1060   assert_lock_strong(CodeCache_lock);
1061   if (old_compiled_method_table != NULL) {
1062     int index = old_compiled_method_table-&gt;find(c);
1063     if (index != -1) {
1064       old_compiled_method_table-&gt;delete_at(index);
1065     }
1066   }
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/src/java.base/share/classes/java/security/Provider.java b/src/java.base/share/classes/java/security/Provider.java
--- a/src/java.base/share/classes/java/security/Provider.java
+++ b/src/java.base/share/classes/java/security/Provider.java
@@ -856,14 +856,22 @@
     // legacy properties changed since last call to any services method?
     private transient boolean legacyChanged;
     // serviceMap changed since last call to getServices()
     private volatile transient boolean servicesChanged;
 
+    // Map<String,String> used to keep track of legacy registration
+    private transient Map<String,String> legacyStrings;
+
     // Map<ServiceKey,Service>
     // used for services added via putService(), initialized on demand
     private transient Map<ServiceKey,Service> serviceMap;
 
+    // For backward compatibility, the registration ordering of
+    // SecureRandom (RNG) algorithms needs to be preserved for
+    // "new SecureRandom()" calls when this provider is used
+    private transient Set<Service> prngServices;
+
     // Map<ServiceKey,Service>
     // used for services added via legacy methods, init on demand
     private transient Map<ServiceKey,Service> legacyMap;
 
     // Set<Service>
@@ -911,16 +919,22 @@
         implClear();
         initialized = true;
         putAll(copy);
     }
 
-    private static boolean isProviderInfo(Object key) {
+    // check whether to update 'legacyString' with the specified key
+    private boolean checkLegacy(Object key) {
         String keyString = (String)key;
         if (keyString.startsWith("Provider.")) {
-            return true;
+            return false;
+        }
+
+        legacyChanged = true;
+        if (legacyStrings == null) {
+            legacyStrings = new LinkedHashMap<>();
         }
-        return false;
+        return true;
     }
 
     /**
      * Copies all of the mappings from the specified Map to this provider.
      * Internal method to be called AFTER the security check has been
@@ -932,132 +946,152 @@
         }
     }
 
     private Object implRemove(Object key) {
         if (key instanceof String) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.remove((String)key);
         }
         return super.remove(key);
     }
 
     private boolean implRemove(Object key, Object value) {
         if (key instanceof String && value instanceof String) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return false;
             }
-            legacyChanged = true;
+            legacyStrings.remove((String)key, (String)value);
         }
         return super.remove(key, value);
     }
 
     private boolean implReplace(Object key, Object oldValue, Object newValue) {
         if ((key instanceof String) && (oldValue instanceof String) &&
                 (newValue instanceof String)) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return false;
             }
-            legacyChanged = true;
+            legacyStrings.replace((String)key, (String)oldValue,
+                    (String)newValue);
         }
         return super.replace(key, oldValue, newValue);
     }
 
     private Object implReplace(Object key, Object value) {
         if ((key instanceof String) && (value instanceof String)) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.replace((String)key, (String)value);
         }
         return super.replace(key, value);
     }
 
     @SuppressWarnings("unchecked") // Function must actually operate over strings
     private void implReplaceAll(BiFunction<? super Object, ? super Object,
             ? extends Object> function) {
         legacyChanged = true;
+        if (legacyStrings == null) {
+            legacyStrings = new LinkedHashMap<>();
+        } else {
+            legacyStrings.replaceAll((BiFunction<? super String, ? super String,
+                    ? extends String>) function);
+        }
         super.replaceAll(function);
     }
 
     @SuppressWarnings("unchecked") // Function must actually operate over strings
-    private Object implMerge(Object key, Object value, BiFunction<? super Object,
-            ? super Object, ? extends Object> remappingFunction) {
+    private Object implMerge(Object key, Object value,
+            BiFunction<? super Object, ? super Object, ? extends Object>
+            remappingFunction) {
         if ((key instanceof String) && (value instanceof String)) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.merge((String)key, (String)value,
+                    (BiFunction<? super String, ? super String,
+                    ? extends String>) remappingFunction);
         }
         return super.merge(key, value, remappingFunction);
     }
 
     @SuppressWarnings("unchecked") // Function must actually operate over strings
     private Object implCompute(Object key, BiFunction<? super Object,
             ? super Object, ? extends Object> remappingFunction) {
         if (key instanceof String) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.compute((String) key,
+                    (BiFunction<? super String,? super String,
+                    ? extends String>) remappingFunction);
         }
         return super.compute(key, remappingFunction);
     }
 
     @SuppressWarnings("unchecked") // Function must actually operate over strings
     private Object implComputeIfAbsent(Object key, Function<? super Object,
             ? extends Object> mappingFunction) {
         if (key instanceof String) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.computeIfAbsent((String) key,
+                    (Function<? super String, ? extends String>)
+                    mappingFunction);
         }
         return super.computeIfAbsent(key, mappingFunction);
     }
 
     @SuppressWarnings("unchecked") // Function must actually operate over strings
     private Object implComputeIfPresent(Object key, BiFunction<? super Object,
             ? super Object, ? extends Object> remappingFunction) {
         if (key instanceof String) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.computeIfPresent((String) key,
+                    (BiFunction<? super String, ? super String,
+                    ? extends String>) remappingFunction);
         }
         return super.computeIfPresent(key, remappingFunction);
     }
 
     private Object implPut(Object key, Object value) {
         if ((key instanceof String) && (value instanceof String)) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.put((String)key, (String)value);
         }
         return super.put(key, value);
     }
 
     private Object implPutIfAbsent(Object key, Object value) {
         if ((key instanceof String) && (value instanceof String)) {
-            if (isProviderInfo(key)) {
+            if (!checkLegacy(key)) {
                 return null;
             }
-            legacyChanged = true;
+            legacyStrings.putIfAbsent((String)key, (String)value);
         }
         return super.putIfAbsent(key, value);
     }
 
     private void implClear() {
+        if (legacyStrings != null) {
+            legacyStrings.clear();
+        }
         if (legacyMap != null) {
             legacyMap.clear();
         }
         serviceMap.clear();
         legacyChanged = false;
         servicesChanged = false;
         serviceSet = null;
+        prngServices = null;
         super.clear();
         putId();
     }
 
     // used as key in the serviceMap and legacyMap HashMaps
@@ -1093,20 +1127,20 @@
     /**
      * Ensure all the legacy String properties are fully parsed into
      * service objects.
      */
     private void ensureLegacyParsed() {
-        if (legacyChanged == false) {
+        if (legacyChanged == false || (legacyStrings == null)) {
             return;
         }
         serviceSet = null;
         if (legacyMap == null) {
             legacyMap = new ConcurrentHashMap<>();
         } else {
             legacyMap.clear();
         }
-        for (Map.Entry<?,?> entry : super.entrySet()) {
+        for (Map.Entry<String,String> entry : legacyStrings.entrySet()) {
             parseLegacyPut(entry.getKey(), entry.getValue());
         }
         removeInvalidServices(legacyMap);
         legacyChanged = false;
     }
@@ -1123,16 +1157,16 @@
                 t.remove();
             }
         }
     }
 
-    private String[] getTypeAndAlgorithm(String key) {
+    private static String[] getTypeAndAlgorithm(String key) {
         int i = key.indexOf('.');
         if (i < 1) {
             if (debug != null) {
-                debug.println("Ignoring invalid entry in provider "
-                        + name + ":" + key);
+                debug.println("Ignoring invalid entry in provider: "
+                        + key);
             }
             return null;
         }
         String type = key.substring(0, i);
         String alg = key.substring(i + 1);
@@ -1141,19 +1175,11 @@
 
     private static final String ALIAS_PREFIX = "Alg.Alias.";
     private static final String ALIAS_PREFIX_LOWER = "alg.alias.";
     private static final int ALIAS_LENGTH = ALIAS_PREFIX.length();
 
-    private void parseLegacyPut(Object k, Object v) {
-        if (!(k instanceof String) || !(v instanceof String)) {
-            return;
-        }
-        String name = (String) k;
-        String value = (String) v;
-        if (isProviderInfo(name)) {
-            return;
-        }
+    private void parseLegacyPut(String name, String value) {
         if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {
             // e.g. put("Alg.Alias.MessageDigest.SHA", "SHA-1");
             // aliasKey ~ MessageDigest.SHA
             String stdAlg = value;
             String aliasKey = name.substring(ALIAS_LENGTH);
@@ -1191,10 +1217,14 @@
                     s.type = type;
                     s.algorithm = stdAlg;
                     legacyMap.put(key, s);
                 }
                 s.className = className;
+
+                if (type.equals("SecureRandom")) {
+                    updateSecureRandomEntries(true, s);
+                }
             } else { // attribute
                 // e.g. put("MessageDigest.SHA-1 ImplementedIn", "Software");
                 String attributeValue = value;
                 String type = getEngineName(typeAndAlg[0]);
                 String attributeString = typeAndAlg[1];
@@ -1350,11 +1380,48 @@
             serviceMap.put(new ServiceKey(type, alias, true), s);
         }
         servicesChanged = true;
         synchronized (this) {
             putPropertyStrings(s);
+            if (type.equals("SecureRandom")) {
+                updateSecureRandomEntries(true, s);
+            }
+        }
+    }
+
+    private void updateSecureRandomEntries(boolean doAdd, Service s) {
+        Objects.requireNonNull(s);
+        if (doAdd) {
+            if (prngServices == null) {
+                prngServices = new LinkedHashSet<Service>();
+            }
+            prngServices.add(s);
+        } else {
+            prngServices.remove(s);
+        }
+
+        if (debug != null) {
+            debug.println((doAdd? "Add":"Remove") + " SecureRandom algo " +
+                s.getAlgorithm());
+        }
+    }
+
+    // used by new SecureRandom() to find out the default SecureRandom
+    // service for this provider
+    synchronized Service getDefaultSecureRandomService() {
+        checkInitialized();
+
+        if (legacyChanged) {
+            prngServices = null;
+            ensureLegacyParsed();
         }
+
+        if (prngServices != null && !prngServices.isEmpty()) {
+            return prngServices.iterator().next();
+        }
+
+        return null;
     }
 
     /**
      * Put the string properties for this Service in this Provider's
      * Hashtable.
@@ -1446,10 +1513,13 @@
         for (String alias : s.getAliases()) {
             serviceMap.remove(new ServiceKey(type, alias, false));
         }
         synchronized (this) {
             removePropertyStrings(s);
+            if (type.equals("SecureRandom")) {
+                updateSecureRandomEntries(false, s);
+            }
         }
     }
 
     // Wrapped String that behaves in a case insensitive way for equals/hashCode
     private static class UString {

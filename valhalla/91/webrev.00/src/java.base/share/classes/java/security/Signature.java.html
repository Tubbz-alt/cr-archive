<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/security/Signature.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.security;
  27 
  28 import java.security.spec.AlgorithmParameterSpec;
  29 import java.util.*;
  30 import java.util.concurrent.ConcurrentHashMap;
  31 import java.io.*;
  32 import java.security.cert.Certificate;
  33 import java.security.cert.X509Certificate;
  34 
  35 import java.nio.ByteBuffer;
  36 
  37 import java.security.Provider.Service;
  38 
  39 import javax.crypto.Cipher;
  40 import javax.crypto.IllegalBlockSizeException;
  41 import javax.crypto.BadPaddingException;
  42 import javax.crypto.NoSuchPaddingException;
  43 import jdk.internal.access.JavaSecuritySignatureAccess;
  44 import jdk.internal.access.SharedSecrets;
  45 
  46 import sun.security.util.Debug;
  47 import sun.security.jca.*;
  48 import sun.security.jca.GetInstance.Instance;
  49 import sun.security.util.KnownOIDs;
  50 
  51 /**
  52  * The Signature class is used to provide applications the functionality
  53  * of a digital signature algorithm. Digital signatures are used for
  54  * authentication and integrity assurance of digital data.
  55  *
  56  * &lt;p&gt; The signature algorithm can be, among others, the NIST standard
  57  * DSA, using DSA and SHA-256. The DSA algorithm using the
  58  * SHA-256 message digest algorithm can be specified as {@code SHA256withDSA}.
  59  * In the case of RSA the signing algorithm could be specified as, for example,
  60  * {@code SHA256withRSA}.
  61  * The algorithm name must be specified, as there is no default.
  62  *
  63  * &lt;p&gt; A Signature object can be used to generate and verify digital
  64  * signatures.
  65  *
  66  * &lt;p&gt; There are three phases to the use of a Signature object for
  67  * either signing data or verifying a signature:&lt;ol&gt;
  68  *
  69  * &lt;li&gt;Initialization, with either
  70  *
  71  *     &lt;ul&gt;
  72  *
  73  *     &lt;li&gt;a public key, which initializes the signature for
  74  *     verification (see {@link #initVerify(PublicKey) initVerify}), or
  75  *
  76  *     &lt;li&gt;a private key (and optionally a Secure Random Number Generator),
  77  *     which initializes the signature for signing
  78  *     (see {@link #initSign(PrivateKey)}
  79  *     and {@link #initSign(PrivateKey, SecureRandom)}).
  80  *
  81  *     &lt;/ul&gt;
  82  *
  83  * &lt;li&gt;Updating
  84  *
  85  * &lt;p&gt;Depending on the type of initialization, this will update the
  86  * bytes to be signed or verified. See the
  87  * {@link #update(byte) update} methods.
  88  *
  89  * &lt;li&gt;Signing or Verifying a signature on all updated bytes. See the
  90  * {@link #sign() sign} methods and the {@link #verify(byte[]) verify}
  91  * method.
  92  *
  93  * &lt;/ol&gt;
  94  *
  95  * &lt;p&gt;Note that this class is abstract and extends from
  96  * {@code SignatureSpi} for historical reasons.
  97  * Application developers should only take notice of the methods defined in
  98  * this {@code Signature} class; all the methods in
  99  * the superclass are intended for cryptographic service providers who wish to
 100  * supply their own implementations of digital signature algorithms.
 101  *
 102  * &lt;p&gt; Every implementation of the Java platform is required to support the
 103  * following standard {@code Signature} algorithms:
 104  * &lt;ul&gt;
 105  * &lt;li&gt;{@code SHA1withDSA}&lt;/li&gt;
 106  * &lt;li&gt;{@code SHA256withDSA}&lt;/li&gt;
 107  * &lt;li&gt;{@code SHA1withRSA}&lt;/li&gt;
 108  * &lt;li&gt;{@code SHA256withRSA}&lt;/li&gt;
 109  * &lt;/ul&gt;
 110  * These algorithms are described in the &lt;a href=
 111  * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 112  * Signature section&lt;/a&gt; of the
 113  * Java Security Standard Algorithm Names Specification.
 114  * Consult the release documentation for your implementation to see if any
 115  * other algorithms are supported.
 116  *
 117  * @author Benjamin Renaud
 118  * @since 1.1
 119  *
 120  */
 121 
 122 public abstract class Signature extends SignatureSpi {
 123 
 124     static {
 125         SharedSecrets.setJavaSecuritySignatureAccess(
 126             new JavaSecuritySignatureAccess() {
 127                 @Override
 128                 public void initVerify(Signature s, PublicKey publicKey,
 129                         AlgorithmParameterSpec params)
 130                         throws InvalidKeyException,
 131                         InvalidAlgorithmParameterException {
 132                     s.initVerify(publicKey, params);
 133                 }
 134                 @Override
 135                 public void initVerify(Signature s,
 136                         java.security.cert.Certificate certificate,
 137                         AlgorithmParameterSpec params)
 138                         throws InvalidKeyException,
 139                         InvalidAlgorithmParameterException {
 140                     s.initVerify(certificate, params);
 141                 }
 142                 @Override
 143                 public void initSign(Signature s, PrivateKey privateKey,
 144                         AlgorithmParameterSpec params, SecureRandom random)
 145                         throws InvalidKeyException,
 146                         InvalidAlgorithmParameterException {
 147                     s.initSign(privateKey, params, random);
 148                 }
 149         });
 150     }
 151 
 152     private static final Debug debug =
 153                         Debug.getInstance(&quot;jca&quot;, &quot;Signature&quot;);
 154 
 155     private static final Debug pdebug =
 156                         Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 157     private static final boolean skipDebug =
 158         Debug.isOn(&quot;engine=&quot;) &amp;&amp; !Debug.isOn(&quot;signature&quot;);
 159 
 160     /*
 161      * The algorithm for this signature object.
 162      * This value is used to map an OID to the particular algorithm.
 163      * The mapping is done in AlgorithmObject.algOID(String algorithm)
 164      */
 165     private String algorithm;
 166 
 167     // The provider
 168     Provider provider;
 169 
 170     /**
 171      * Possible {@link #state} value, signifying that
 172      * this signature object has not yet been initialized.
 173      */
 174     protected static final int UNINITIALIZED = 0;
 175 
 176     /**
 177      * Possible {@link #state} value, signifying that
 178      * this signature object has been initialized for signing.
 179      */
 180     protected static final int SIGN = 2;
 181 
 182     /**
 183      * Possible {@link #state} value, signifying that
 184      * this signature object has been initialized for verification.
 185      */
 186     protected static final int VERIFY = 3;
 187 
 188     /**
 189      * Current state of this signature object.
 190      */
 191     protected int state = UNINITIALIZED;
 192 
 193     /**
 194      * Creates a Signature object for the specified algorithm.
 195      *
 196      * @param algorithm the standard string name of the algorithm.
 197      * See the Signature section in the &lt;a href=
 198      * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 199      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 200      * for information about standard algorithm names.
 201      */
 202     protected Signature(String algorithm) {
 203         this.algorithm = algorithm;
 204     }
 205 
 206     // name of the special signature alg
 207     private static final String RSA_SIGNATURE = &quot;NONEwithRSA&quot;;
 208 
 209     // name of the equivalent cipher alg
 210     private static final String RSA_CIPHER = &quot;RSA/ECB/PKCS1Padding&quot;;
 211 
 212     // all the services we need to lookup for compatibility with Cipher
 213     private static final List&lt;ServiceId&gt; rsaIds = List.of(
 214         new ServiceId(&quot;Signature&quot;, &quot;NONEwithRSA&quot;),
 215         new ServiceId(&quot;Cipher&quot;, &quot;RSA/ECB/PKCS1Padding&quot;),
 216         new ServiceId(&quot;Cipher&quot;, &quot;RSA/ECB&quot;),
 217         new ServiceId(&quot;Cipher&quot;, &quot;RSA//PKCS1Padding&quot;),
 218         new ServiceId(&quot;Cipher&quot;, &quot;RSA&quot;));
 219 
 220     /**
 221      * Returns a Signature object that implements the specified signature
 222      * algorithm.
 223      *
 224      * &lt;p&gt; This method traverses the list of registered security Providers,
 225      * starting with the most preferred Provider.
 226      * A new Signature object encapsulating the
 227      * SignatureSpi implementation from the first
 228      * Provider that supports the specified algorithm is returned.
 229      *
 230      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 231      * the {@link Security#getProviders() Security.getProviders()} method.
 232      *
 233      * @implNote
 234      * The JDK Reference Implementation additionally uses the
 235      * {@code jdk.security.provider.preferred}
 236      * {@link Security#getProperty(String) Security} property to determine
 237      * the preferred provider order for the specified algorithm. This
 238      * may be different than the order of providers returned by
 239      * {@link Security#getProviders() Security.getProviders()}.
 240      *
 241      * @param algorithm the standard name of the algorithm requested.
 242      * See the Signature section in the &lt;a href=
 243      * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 244      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 245      * for information about standard algorithm names.
 246      *
 247      * @return the new {@code Signature} object
 248      *
 249      * @throws NoSuchAlgorithmException if no {@code Provider} supports a
 250      *         {@code Signature} implementation for the
 251      *         specified algorithm
 252      *
 253      * @throws NullPointerException if {@code algorithm} is {@code null}
 254      *
 255      * @see Provider
 256      */
 257     public static Signature getInstance(String algorithm)
 258             throws NoSuchAlgorithmException {
 259         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 260         List&lt;Service&gt; list;
 261         if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {
 262             list = GetInstance.getServices(rsaIds);
 263         } else {
 264             list = GetInstance.getServices(&quot;Signature&quot;, algorithm);
 265         }
 266         Iterator&lt;Service&gt; t = list.iterator();
 267         if (t.hasNext() == false) {
 268             throw new NoSuchAlgorithmException
 269                 (algorithm + &quot; Signature not available&quot;);
 270         }
 271         // try services until we find an Spi or a working Signature subclass
 272         NoSuchAlgorithmException failure;
 273         do {
 274             Service s = t.next();
 275             if (isSpi(s)) { // delayed provider selection
 276                 return new Delegate(s, t, algorithm);
 277             } else {
 278                 // must be a subclass of Signature, disable dynamic selection
 279                 try {
 280                     Instance instance =
 281                         GetInstance.getInstance(s, SignatureSpi.class);
 282                     return getInstance(instance, algorithm);
 283                 } catch (NoSuchAlgorithmException e) {
 284                     failure = e;
 285                 }
 286             }
 287         } while (t.hasNext());
 288         throw failure;
 289     }
 290 
 291     private static Signature getInstance(Instance instance, String algorithm) {
 292         Signature sig;
 293         if (instance.impl instanceof Signature) {
 294             sig = (Signature)instance.impl;
 295             sig.algorithm = algorithm;
 296         } else {
 297             SignatureSpi spi = (SignatureSpi)instance.impl;
 298             sig = Delegate.of(spi, algorithm);
 299         }
 300         sig.provider = instance.provider;
 301         return sig;
 302     }
 303 
 304     private static final Map&lt;String,Boolean&gt; signatureInfo;
 305 
 306     static {
 307         signatureInfo = new ConcurrentHashMap&lt;&gt;();
 308         Boolean TRUE = Boolean.TRUE;
 309         // pre-initialize with values for our SignatureSpi implementations
 310         signatureInfo.put(&quot;sun.security.provider.DSA$RawDSA&quot;, TRUE);
 311         signatureInfo.put(&quot;sun.security.provider.DSA$SHA1withDSA&quot;, TRUE);
 312         signatureInfo.put(&quot;sun.security.rsa.RSASignature$MD2withRSA&quot;, TRUE);
 313         signatureInfo.put(&quot;sun.security.rsa.RSASignature$MD5withRSA&quot;, TRUE);
 314         signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA1withRSA&quot;, TRUE);
 315         signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA256withRSA&quot;, TRUE);
 316         signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA384withRSA&quot;, TRUE);
 317         signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA512withRSA&quot;, TRUE);
 318         signatureInfo.put(&quot;sun.security.rsa.RSAPSSSignature&quot;, TRUE);
 319         signatureInfo.put(&quot;sun.security.pkcs11.P11Signature&quot;, TRUE);
 320     }
 321 
 322     private static boolean isSpi(Service s) {
 323         if (s.getType().equals(&quot;Cipher&quot;)) {
 324             // must be a CipherSpi, which we can wrap with the CipherAdapter
 325             return true;
 326         }
 327         String className = s.getClassName();
 328         Boolean result = signatureInfo.get(className);
 329         if (result == null) {
 330             try {
 331                 Object instance = s.newInstance(null);
 332                 // Signature extends SignatureSpi
 333                 // so it is a &quot;real&quot; Spi if it is an
 334                 // instance of SignatureSpi but not Signature
 335                 boolean r = (instance instanceof SignatureSpi)
 336                                 &amp;&amp; (instance instanceof Signature == false);
 337                 if ((debug != null) &amp;&amp; (r == false)) {
 338                     debug.println(&quot;Not a SignatureSpi &quot; + className);
 339                     debug.println(&quot;Delayed provider selection may not be &quot;
 340                         + &quot;available for algorithm &quot; + s.getAlgorithm());
 341                 }
 342                 result = Boolean.valueOf(r);
 343                 signatureInfo.put(className, result);
 344             } catch (Exception e) {
 345                 // something is wrong, assume not an SPI
 346                 return false;
 347             }
 348         }
 349         return result.booleanValue();
 350     }
 351 
 352     /**
 353      * Returns a Signature object that implements the specified signature
 354      * algorithm.
 355      *
 356      * &lt;p&gt; A new Signature object encapsulating the
 357      * SignatureSpi implementation from the specified provider
 358      * is returned.  The specified provider must be registered
 359      * in the security provider list.
 360      *
 361      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 362      * the {@link Security#getProviders() Security.getProviders()} method.
 363      *
 364      * @param algorithm the name of the algorithm requested.
 365      * See the Signature section in the &lt;a href=
 366      * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 367      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 368      * for information about standard algorithm names.
 369      *
 370      * @param provider the name of the provider.
 371      *
 372      * @return the new {@code Signature} object
 373      *
 374      * @throws IllegalArgumentException if the provider name is {@code null}
 375      *         or empty
 376      *
 377      * @throws NoSuchAlgorithmException if a {@code SignatureSpi}
 378      *         implementation for the specified algorithm is not
 379      *         available from the specified provider
 380      *
 381      * @throws NoSuchProviderException if the specified provider is not
 382      *         registered in the security provider list
 383      *
 384      * @throws NullPointerException if {@code algorithm} is {@code null}
 385      *
 386      * @see Provider
 387      */
 388     public static Signature getInstance(String algorithm, String provider)
 389             throws NoSuchAlgorithmException, NoSuchProviderException {
 390         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 391         if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {
 392             // exception compatibility with existing code
 393             if (provider == null || provider.isEmpty()) {
 394                 throw new IllegalArgumentException(&quot;missing provider&quot;);
 395             }
 396             Provider p = Security.getProvider(provider);
 397             if (p == null) {
 398                 throw new NoSuchProviderException
 399                     (&quot;no such provider: &quot; + provider);
 400             }
 401             return getInstanceRSA(p);
 402         }
 403         Instance instance = GetInstance.getInstance
 404                 (&quot;Signature&quot;, SignatureSpi.class, algorithm, provider);
 405         return getInstance(instance, algorithm);
 406     }
 407 
 408     /**
 409      * Returns a Signature object that implements the specified
 410      * signature algorithm.
 411      *
 412      * &lt;p&gt; A new Signature object encapsulating the
 413      * SignatureSpi implementation from the specified Provider
 414      * object is returned.  Note that the specified Provider object
 415      * does not have to be registered in the provider list.
 416      *
 417      * @param algorithm the name of the algorithm requested.
 418      * See the Signature section in the &lt;a href=
 419      * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 420      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 421      * for information about standard algorithm names.
 422      *
 423      * @param provider the provider.
 424      *
 425      * @return the new {@code Signature} object
 426      *
 427      * @throws IllegalArgumentException if the provider is {@code null}
 428      *
 429      * @throws NoSuchAlgorithmException if a {@code SignatureSpi}
 430      *         implementation for the specified algorithm is not available
 431      *         from the specified {@code Provider} object
 432      *
 433      * @throws NullPointerException if {@code algorithm} is {@code null}
 434      *
 435      * @see Provider
 436      *
 437      * @since 1.4
 438      */
 439     public static Signature getInstance(String algorithm, Provider provider)
 440             throws NoSuchAlgorithmException {
 441         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 442         if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {
 443             // exception compatibility with existing code
 444             if (provider == null) {
 445                 throw new IllegalArgumentException(&quot;missing provider&quot;);
 446             }
 447             return getInstanceRSA(provider);
 448         }
 449         Instance instance = GetInstance.getInstance
 450                 (&quot;Signature&quot;, SignatureSpi.class, algorithm, provider);
 451         return getInstance(instance, algorithm);
 452     }
 453 
 454     // return an implementation for NONEwithRSA, which is a special case
 455     // because of the Cipher.RSA/ECB/PKCS1Padding compatibility wrapper
 456     private static Signature getInstanceRSA(Provider p)
 457             throws NoSuchAlgorithmException {
 458         // try Signature first
 459         Service s = p.getService(&quot;Signature&quot;, RSA_SIGNATURE);
 460         if (s != null) {
 461             Instance instance = GetInstance.getInstance(s, SignatureSpi.class);
 462             return getInstance(instance, RSA_SIGNATURE);
 463         }
 464         // check Cipher
 465         try {
 466             Cipher c = Cipher.getInstance(RSA_CIPHER, p);
 467             return Delegate.of(new CipherAdapter(c), RSA_SIGNATURE);
 468         } catch (GeneralSecurityException e) {
 469             // throw Signature style exception message to avoid confusion,
 470             // but append Cipher exception as cause
 471             throw new NoSuchAlgorithmException(&quot;no such algorithm: &quot;
 472                 + RSA_SIGNATURE + &quot; for provider &quot; + p.getName(), e);
 473         }
 474     }
 475 
 476     /**
 477      * Returns the provider of this signature object.
 478      *
 479      * @return the provider of this signature object
 480      */
 481     public final Provider getProvider() {
 482         chooseFirstProvider();
 483         return this.provider;
 484     }
 485 
 486     private String getProviderName() {
 487         return (provider == null)  ? &quot;(no provider)&quot; : provider.getName();
 488     }
 489 
 490     void chooseFirstProvider() {
 491         // empty, overridden in Delegate
 492     }
 493 
 494     /**
 495      * Initializes this object for verification. If this method is called
 496      * again with a different argument, it negates the effect
 497      * of this call.
 498      *
 499      * @param publicKey the public key of the identity whose signature is
 500      * going to be verified.
 501      *
 502      * @throws    InvalidKeyException if the key is invalid.
 503      */
 504     public final void initVerify(PublicKey publicKey)
 505             throws InvalidKeyException {
 506         engineInitVerify(publicKey);
 507         state = VERIFY;
 508 
 509         if (!skipDebug &amp;&amp; pdebug != null) {
 510             pdebug.println(&quot;Signature.&quot; + algorithm +
 511                 &quot; verification algorithm from: &quot; + getProviderName());
 512         }
 513     }
 514 
 515     /**
 516      * Initialize this object for verification. If this method is called
 517      * again with different arguments, it negates the effect
 518      * of this call.
 519      *
 520      * @param publicKey the public key of the identity whose signature is
 521      * going to be verified.
 522      * @param params the parameters used for verifying this signature.
 523      *
 524      * @throws    InvalidKeyException if the key is invalid.
 525      * @throws    InvalidAlgorithmParameterException if the params is invalid.
 526      */
 527     final void initVerify(PublicKey publicKey, AlgorithmParameterSpec params)
 528             throws InvalidKeyException, InvalidAlgorithmParameterException {
 529         engineInitVerify(publicKey, params);
 530         state = VERIFY;
 531 
 532         if (!skipDebug &amp;&amp; pdebug != null) {
 533             pdebug.println(&quot;Signature.&quot; + algorithm +
 534                 &quot; verification algorithm from: &quot; + getProviderName());
 535         }
 536     }
 537 
 538     private static PublicKey getPublicKeyFromCert(Certificate cert)
 539             throws InvalidKeyException {
 540         // If the certificate is of type X509Certificate,
 541         // we should check whether it has a Key Usage
 542         // extension marked as critical.
 543         //if (cert instanceof java.security.cert.X509Certificate) {
 544         if (cert instanceof X509Certificate) {
 545             // Check whether the cert has a key usage extension
 546             // marked as a critical extension.
 547             // The OID for KeyUsage extension is 2.5.29.15.
 548             X509Certificate c = (X509Certificate)cert;
 549             Set&lt;String&gt; critSet = c.getCriticalExtensionOIDs();
 550 
 551             if (critSet != null &amp;&amp; !critSet.isEmpty()
 552                 &amp;&amp; critSet.contains(KnownOIDs.KeyUsage.value())) {
 553                 boolean[] keyUsageInfo = c.getKeyUsage();
 554                 // keyUsageInfo[0] is for digitalSignature.
 555                 if ((keyUsageInfo != null) &amp;&amp; (keyUsageInfo[0] == false))
 556                     throw new InvalidKeyException(&quot;Wrong key usage&quot;);
 557             }
 558         }
 559         return cert.getPublicKey();
 560     }
 561 
 562     /**
 563      * Initializes this object for verification, using the public key from
 564      * the given certificate.
 565      * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
 566      * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
 567      * extension field implies that the public key in
 568      * the certificate and its corresponding private key are not
 569      * supposed to be used for digital signatures, an
 570      * {@code InvalidKeyException} is thrown.
 571      *
 572      * @param certificate the certificate of the identity whose signature is
 573      * going to be verified.
 574      *
 575      * @throws    InvalidKeyException  if the public key in the certificate
 576      * is not encoded properly or does not include required  parameter
 577      * information or cannot be used for digital signature purposes.
 578      * @since 1.3
 579      */
 580     public final void initVerify(Certificate certificate)
 581             throws InvalidKeyException {
 582         engineInitVerify(getPublicKeyFromCert(certificate));
 583         state = VERIFY;
 584 
 585         if (!skipDebug &amp;&amp; pdebug != null) {
 586             pdebug.println(&quot;Signature.&quot; + algorithm +
 587                 &quot; verification algorithm from: &quot; + getProviderName());
 588         }
 589     }
 590 
 591     /**
 592      * Initializes this object for verification, using the public key from
 593      * the given certificate.
 594      * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
 595      * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
 596      * extension field implies that the public key in
 597      * the certificate and its corresponding private key are not
 598      * supposed to be used for digital signatures, an
 599      * {@code InvalidKeyException} is thrown.
 600      *
 601      * @param certificate the certificate of the identity whose signature is
 602      * going to be verified.
 603      * @param params the parameters used for verifying this signature.
 604      *
 605      * @throws    InvalidKeyException  if the public key in the certificate
 606      * is not encoded properly or does not include required  parameter
 607      * information or cannot be used for digital signature purposes.
 608      * @throws    InvalidAlgorithmParameterException if the params is invalid.
 609      *
 610      * @since 13
 611      */
 612     final void initVerify(Certificate certificate,
 613             AlgorithmParameterSpec params)
 614             throws InvalidKeyException, InvalidAlgorithmParameterException {
 615         engineInitVerify(getPublicKeyFromCert(certificate), params);
 616         state = VERIFY;
 617 
 618         if (!skipDebug &amp;&amp; pdebug != null) {
 619             pdebug.println(&quot;Signature.&quot; + algorithm +
 620                 &quot; verification algorithm from: &quot; + getProviderName());
 621         }
 622     }
 623 
 624     /**
 625      * Initialize this object for signing. If this method is called
 626      * again with a different argument, it negates the effect
 627      * of this call.
 628      *
 629      * @param privateKey the private key of the identity whose signature
 630      * is going to be generated.
 631      *
 632      * @throws    InvalidKeyException if the key is invalid.
 633      */
 634     public final void initSign(PrivateKey privateKey)
 635             throws InvalidKeyException {
 636         engineInitSign(privateKey);
 637         state = SIGN;
 638 
 639         if (!skipDebug &amp;&amp; pdebug != null) {
 640             pdebug.println(&quot;Signature.&quot; + algorithm +
 641                 &quot; signing algorithm from: &quot; + getProviderName());
 642         }
 643     }
 644 
 645     /**
 646      * Initialize this object for signing. If this method is called
 647      * again with a different argument, it negates the effect
 648      * of this call.
 649      *
 650      * @param privateKey the private key of the identity whose signature
 651      * is going to be generated.
 652      *
 653      * @param random the source of randomness for this signature.
 654      *
 655      * @throws    InvalidKeyException if the key is invalid.
 656      */
 657     public final void initSign(PrivateKey privateKey, SecureRandom random)
 658             throws InvalidKeyException {
 659         engineInitSign(privateKey, random);
 660         state = SIGN;
 661 
 662         if (!skipDebug &amp;&amp; pdebug != null) {
 663             pdebug.println(&quot;Signature.&quot; + algorithm +
 664                 &quot; signing algorithm from: &quot; + getProviderName());
 665         }
 666     }
 667 
 668     /**
 669      * Initialize this object for signing. If this method is called
 670      * again with different arguments, it negates the effect
 671      * of this call.
 672      *
 673      * @param privateKey the private key of the identity whose signature
 674      * is going to be generated.
 675      * @param params the parameters used for generating signature.
 676      * @param random the source of randomness for this signature.
 677      *
 678      * @throws    InvalidKeyException if the key is invalid.
 679      * @throws    InvalidAlgorithmParameterException if the params is invalid
 680      */
 681     final void initSign(PrivateKey privateKey,
 682             AlgorithmParameterSpec params, SecureRandom random)
 683             throws InvalidKeyException, InvalidAlgorithmParameterException {
 684         engineInitSign(privateKey, params, random);
 685         state = SIGN;
 686 
 687         if (!skipDebug &amp;&amp; pdebug != null) {
 688             pdebug.println(&quot;Signature.&quot; + algorithm +
 689                 &quot; signing algorithm from: &quot; + getProviderName());
 690         }
 691     }
 692 
 693     /**
 694      * Returns the signature bytes of all the data updated.
 695      * The format of the signature depends on the underlying
 696      * signature scheme.
 697      *
 698      * &lt;p&gt;A call to this method resets this signature object to the state
 699      * it was in when previously initialized for signing via a
 700      * call to {@code initSign(PrivateKey)}. That is, the object is
 701      * reset and available to generate another signature from the same
 702      * signer, if desired, via new calls to {@code update} and
 703      * {@code sign}.
 704      *
 705      * @return the signature bytes of the signing operation&#39;s result.
 706      *
 707      * @throws    SignatureException if this signature object is not
 708      * initialized properly or if this signature algorithm is unable to
 709      * process the input data provided.
 710      */
 711     public final byte[] sign() throws SignatureException {
 712         if (state == SIGN) {
 713             return engineSign();
 714         }
 715         throw new SignatureException(&quot;object not initialized for &quot; +
 716                                      &quot;signing&quot;);
 717     }
 718 
 719     /**
 720      * Finishes the signature operation and stores the resulting signature
 721      * bytes in the provided buffer {@code outbuf}, starting at
 722      * {@code offset}.
 723      * The format of the signature depends on the underlying
 724      * signature scheme.
 725      *
 726      * &lt;p&gt;This signature object is reset to its initial state (the state it
 727      * was in after a call to one of the {@code initSign} methods) and
 728      * can be reused to generate further signatures with the same private key.
 729      *
 730      * @param outbuf buffer for the signature result.
 731      *
 732      * @param offset offset into {@code outbuf} where the signature is
 733      * stored.
 734      *
 735      * @param len number of bytes within {@code outbuf} allotted for the
 736      * signature.
 737      *
 738      * @return the number of bytes placed into {@code outbuf}.
 739      *
 740      * @throws    SignatureException if this signature object is not
 741      *     initialized properly, if this signature algorithm is unable to
 742      *     process the input data provided, or if {@code len} is less
 743      *     than the actual signature length.
 744      * @throws    IllegalArgumentException if {@code outbuf} is {@code null},
 745      *     or {@code offset} or {@code len} is less than 0, or the sum of
 746      *     {@code offset} and {@code len} is greater than the length of
 747      *     {@code outbuf}.
 748      *
 749      * @since 1.2
 750      */
 751     public final int sign(byte[] outbuf, int offset, int len)
 752         throws SignatureException {
 753         if (outbuf == null) {
 754             throw new IllegalArgumentException(&quot;No output buffer given&quot;);
 755         }
 756         if (offset &lt; 0 || len &lt; 0) {
 757             throw new IllegalArgumentException(&quot;offset or len is less than 0&quot;);
 758         }
 759         if (outbuf.length - offset &lt; len) {
 760             throw new IllegalArgumentException
 761                 (&quot;Output buffer too small for specified offset and length&quot;);
 762         }
 763         if (state != SIGN) {
 764             throw new SignatureException(&quot;object not initialized for &quot; +
 765                                          &quot;signing&quot;);
 766         }
 767         return engineSign(outbuf, offset, len);
 768     }
 769 
 770     /**
 771      * Verifies the passed-in signature.
 772      *
 773      * &lt;p&gt;A call to this method resets this signature object to the state
 774      * it was in when previously initialized for verification via a
 775      * call to {@code initVerify(PublicKey)}. That is, the object is
 776      * reset and available to verify another signature from the identity
 777      * whose public key was specified in the call to {@code initVerify}.
 778      *
 779      * @param signature the signature bytes to be verified.
 780      *
 781      * @return true if the signature was verified, false if not.
 782      *
 783      * @throws    SignatureException if this signature object is not
 784      * initialized properly, the passed-in signature is improperly
 785      * encoded or of the wrong type, if this signature algorithm is unable to
 786      * process the input data provided, etc.
 787      */
 788     public final boolean verify(byte[] signature) throws SignatureException {
 789         if (state == VERIFY) {
 790             return engineVerify(signature);
 791         }
 792         throw new SignatureException(&quot;object not initialized for &quot; +
 793                                      &quot;verification&quot;);
 794     }
 795 
 796     /**
 797      * Verifies the passed-in signature in the specified array
 798      * of bytes, starting at the specified offset.
 799      *
 800      * &lt;p&gt;A call to this method resets this signature object to the state
 801      * it was in when previously initialized for verification via a
 802      * call to {@code initVerify(PublicKey)}. That is, the object is
 803      * reset and available to verify another signature from the identity
 804      * whose public key was specified in the call to {@code initVerify}.
 805      *
 806      *
 807      * @param signature the signature bytes to be verified.
 808      * @param offset the offset to start from in the array of bytes.
 809      * @param length the number of bytes to use, starting at offset.
 810      *
 811      * @return true if the signature was verified, false if not.
 812      *
 813      * @throws    SignatureException if this signature object is not
 814      * initialized properly, the passed-in signature is improperly
 815      * encoded or of the wrong type, if this signature algorithm is unable to
 816      * process the input data provided, etc.
 817      * @throws    IllegalArgumentException if the {@code signature}
 818      * byte array is {@code null}, or the {@code offset} or {@code length}
 819      * is less than 0, or the sum of the {@code offset} and
 820      * {@code length} is greater than the length of the
 821      * {@code signature} byte array.
 822      * @since 1.4
 823      */
 824     public final boolean verify(byte[] signature, int offset, int length)
 825         throws SignatureException {
 826         if (state == VERIFY) {
 827             if (signature == null) {
 828                 throw new IllegalArgumentException(&quot;signature is null&quot;);
 829             }
 830             if (offset &lt; 0 || length &lt; 0) {
 831                 throw new IllegalArgumentException
 832                     (&quot;offset or length is less than 0&quot;);
 833             }
 834             if (signature.length - offset &lt; length) {
 835                 throw new IllegalArgumentException
 836                     (&quot;signature too small for specified offset and length&quot;);
 837             }
 838 
 839             return engineVerify(signature, offset, length);
 840         }
 841         throw new SignatureException(&quot;object not initialized for &quot; +
 842                                      &quot;verification&quot;);
 843     }
 844 
 845     /**
 846      * Updates the data to be signed or verified by a byte.
 847      *
 848      * @param b the byte to use for the update.
 849      *
 850      * @throws    SignatureException if this signature object is not
 851      * initialized properly.
 852      */
 853     public final void update(byte b) throws SignatureException {
 854         if (state == VERIFY || state == SIGN) {
 855             engineUpdate(b);
 856         } else {
 857             throw new SignatureException(&quot;object not initialized for &quot;
 858                                          + &quot;signature or verification&quot;);
 859         }
 860     }
 861 
 862     /**
 863      * Updates the data to be signed or verified, using the specified
 864      * array of bytes.
 865      *
 866      * @param data the byte array to use for the update.
 867      *
 868      * @throws    SignatureException if this signature object is not
 869      * initialized properly.
 870      */
 871     public final void update(byte[] data) throws SignatureException {
 872         update(data, 0, data.length);
 873     }
 874 
 875     /**
 876      * Updates the data to be signed or verified, using the specified
 877      * array of bytes, starting at the specified offset.
 878      *
 879      * @param data the array of bytes.
 880      * @param off the offset to start from in the array of bytes.
 881      * @param len the number of bytes to use, starting at offset.
 882      *
 883      * @throws    SignatureException if this signature object is not
 884      *     initialized properly.
 885      * @throws    IllegalArgumentException if {@code data} is {@code null},
 886      *     or {@code off} or {@code len} is less than 0, or the sum of
 887      *     {@code off} and {@code len} is greater than the length of
 888      *     {@code data}.
 889      */
 890     public final void update(byte[] data, int off, int len)
 891             throws SignatureException {
 892         if (state == SIGN || state == VERIFY) {
 893             if (data == null) {
 894                 throw new IllegalArgumentException(&quot;data is null&quot;);
 895             }
 896             if (off &lt; 0 || len &lt; 0) {
 897                 throw new IllegalArgumentException(&quot;off or len is less than 0&quot;);
 898             }
 899             if (data.length - off &lt; len) {
 900                 throw new IllegalArgumentException
 901                     (&quot;data too small for specified offset and length&quot;);
 902             }
 903             engineUpdate(data, off, len);
 904         } else {
 905             throw new SignatureException(&quot;object not initialized for &quot;
 906                                          + &quot;signature or verification&quot;);
 907         }
 908     }
 909 
 910     /**
 911      * Updates the data to be signed or verified using the specified
 912      * ByteBuffer. Processes the {@code data.remaining()} bytes
 913      * starting at {@code data.position()}.
 914      * Upon return, the buffer&#39;s position will be equal to its limit;
 915      * its limit will not have changed.
 916      *
 917      * @param data the ByteBuffer
 918      *
 919      * @throws    SignatureException if this signature object is not
 920      * initialized properly.
 921      * @since 1.5
 922      */
 923     public final void update(ByteBuffer data) throws SignatureException {
 924         if ((state != SIGN) &amp;&amp; (state != VERIFY)) {
 925             throw new SignatureException(&quot;object not initialized for &quot;
 926                                          + &quot;signature or verification&quot;);
 927         }
 928         if (data == null) {
 929             throw new NullPointerException();
 930         }
 931         engineUpdate(data);
 932     }
 933 
 934     /**
 935      * Returns the name of the algorithm for this signature object.
 936      *
 937      * @return the name of the algorithm for this signature object.
 938      */
 939     public final String getAlgorithm() {
 940         return this.algorithm;
 941     }
 942 
 943     /**
 944      * Returns a string representation of this signature object,
 945      * providing information that includes the state of the object
 946      * and the name of the algorithm used.
 947      *
 948      * @return a string representation of this signature object.
 949      */
 950     public String toString() {
 951         String initState = &quot;&quot;;
 952         switch (state) {
 953         case UNINITIALIZED:
 954             initState = &quot;&lt;not initialized&gt;&quot;;
 955             break;
 956         case VERIFY:
 957             initState = &quot;&lt;initialized for verifying&gt;&quot;;
 958             break;
 959         case SIGN:
 960             initState = &quot;&lt;initialized for signing&gt;&quot;;
 961             break;
 962         }
 963         return &quot;Signature object: &quot; + getAlgorithm() + initState;
 964     }
 965 
 966     /**
 967      * Sets the specified algorithm parameter to the specified value.
 968      * This method supplies a general-purpose mechanism through
 969      * which it is possible to set the various parameters of this object.
 970      * A parameter may be any settable parameter for the algorithm, such as
 971      * a parameter size, or a source of random bits for signature generation
 972      * (if appropriate), or an indication of whether or not to perform
 973      * a specific but optional computation. A uniform algorithm-specific
 974      * naming scheme for each parameter is desirable but left unspecified
 975      * at this time.
 976      *
 977      * @param param the string identifier of the parameter.
 978      * @param value the parameter value.
 979      *
 980      * @throws    InvalidParameterException if {@code param} is an
 981      * invalid parameter for this signature algorithm engine,
 982      * the parameter is already set
 983      * and cannot be set again, a security exception occurs, and so on.
 984      *
 985      * @see #getParameter
 986      *
 987      * @deprecated Use
 988      * {@link #setParameter(java.security.spec.AlgorithmParameterSpec)
 989      * setParameter}.
 990      */
 991     @Deprecated
 992     public final void setParameter(String param, Object value)
 993             throws InvalidParameterException {
 994         engineSetParameter(param, value);
 995     }
 996 
 997     /**
 998      * Initializes this signature engine with the specified parameter set.
 999      *
1000      * @param params the parameters
1001      *
1002      * @throws    InvalidAlgorithmParameterException if the given parameters
1003      * are inappropriate for this signature engine
1004      *
1005      * @see #getParameters
1006      */
1007     public final void setParameter(AlgorithmParameterSpec params)
1008             throws InvalidAlgorithmParameterException {
1009         engineSetParameter(params);
1010     }
1011 
1012     /**
1013      * Returns the parameters used with this signature object.
1014      *
1015      * &lt;p&gt; If this signature has been initialized with parameters
1016      * (by calling {@link #setParameter(AlgorithmParameterSpec)} or
1017      * {@link #setParameter(String, Object)}) and the underlying signature
1018      * implementation supports returning the parameters as
1019      * {@code AlgorithmParameters}, this method returns the same parameters.
1020      * If the parameters were not set, this method may return a combination
1021      * of default and randomly generated parameter values if the
1022      * underlying signature implementation supports it and can successfully
1023      * generate them. Otherwise, {@code null} is returned.
1024      *
1025      * @return the parameters used with this signature, or {@code null}
1026      *
1027      * @see #setParameter(AlgorithmParameterSpec)
1028      * @since 1.4
1029      */
1030     public final AlgorithmParameters getParameters() {
1031         return engineGetParameters();
1032     }
1033 
1034     /**
1035      * Gets the value of the specified algorithm parameter. This method
1036      * supplies a general-purpose mechanism through which it is possible to
1037      * get the various parameters of this object. A parameter may be any
1038      * settable parameter for the algorithm, such as a parameter size, or
1039      * a source of random bits for signature generation (if appropriate),
1040      * or an indication of whether or not to perform a specific but optional
1041      * computation. A uniform algorithm-specific naming scheme for each
1042      * parameter is desirable but left unspecified at this time.
1043      *
1044      * @param param the string name of the parameter.
1045      *
1046      * @return the object that represents the parameter value, or {@code null} if
1047      * there is none.
1048      *
1049      * @throws    InvalidParameterException if {@code param} is an invalid
1050      * parameter for this engine, or another exception occurs while
1051      * trying to get this parameter.
1052      *
1053      * @see #setParameter(String, Object)
1054      *
1055      * @deprecated
1056      */
1057     @Deprecated
1058     public final Object getParameter(String param)
1059             throws InvalidParameterException {
1060         return engineGetParameter(param);
1061     }
1062 
1063     /**
1064      * Returns a clone if the implementation is cloneable.
1065      *
1066      * @return a clone if the implementation is cloneable.
1067      *
1068      * @throws    CloneNotSupportedException if this is called
1069      * on an implementation that does not support {@code Cloneable}.
1070      */
1071     public Object clone() throws CloneNotSupportedException {
1072         if (this instanceof Cloneable) {
1073             return super.clone();
1074         } else {
1075             throw new CloneNotSupportedException();
1076         }
1077     }
1078 
1079     /*
1080      * The following class allows providers to extend from SignatureSpi
1081      * rather than from Signature. It represents a Signature with an
1082      * encapsulated, provider-supplied SPI object (of type SignatureSpi).
1083      * If the provider implementation is an instance of SignatureSpi, the
1084      * getInstance() methods above return an instance of this class, with
1085      * the SPI object encapsulated.
1086      *
1087      * Note: All SPI methods from the original Signature class have been
1088      * moved up the hierarchy into a new class (SignatureSpi), which has
1089      * been interposed in the hierarchy between the API (Signature)
1090      * and its original parent (Object).
1091      */
1092 
1093     @SuppressWarnings(&quot;deprecation&quot;)
1094     private static class Delegate extends Signature {
1095         // use this class for spi objects which implements Cloneable
1096         private static final class CloneableDelegate extends Delegate
1097                 implements Cloneable {
1098             private CloneableDelegate(SignatureSpi digestSpi,
1099                     String algorithm) {
1100                 super(digestSpi, algorithm);
1101             }
1102         }
1103 
1104         // The provider implementation (delegate)
1105         // filled in once the provider is selected
1106         private SignatureSpi sigSpi;
1107 
1108         // lock for mutex during provider selection
1109         private final Object lock;
1110 
1111         // next service to try in provider selection
1112         // null once provider is selected
1113         private Service firstService;
1114 
1115         // remaining services to try in provider selection
1116         // null once provider is selected
1117         private Iterator&lt;Service&gt; serviceIterator;
1118 
1119         // factory method used by Signature class to create Delegate objs
1120         static Delegate of(SignatureSpi sigSpi, String algorithm) {
1121             if (sigSpi instanceof Cloneable) {
1122                 return new CloneableDelegate(sigSpi, algorithm);
1123             } else {
1124                 return new Delegate(sigSpi, algorithm);
1125             }
1126         }
1127 
1128         // private constructor
1129         private Delegate(SignatureSpi sigSpi, String algorithm) {
1130             super(algorithm);
1131             this.sigSpi = sigSpi;
1132             this.lock = null; // no lock needed
1133         }
1134 
1135         // constructor used with delayed provider selection
1136         private Delegate(Service service,
1137                         Iterator&lt;Service&gt; iterator, String algorithm) {
1138             super(algorithm);
1139             this.firstService = service;
1140             this.serviceIterator = iterator;
1141             this.lock = new Object();
1142         }
1143 
1144         /**
1145          * Returns a clone if the delegate is cloneable.
1146          *
1147          * @return a clone if the delegate is cloneable.
1148          *
1149          * @throws    CloneNotSupportedException if this is called on a
1150          * delegate that does not support {@code Cloneable}.
1151          */
1152         @Override
1153         public Object clone() throws CloneNotSupportedException {
1154             chooseFirstProvider();
1155             if (sigSpi instanceof Cloneable) {
1156                 // Because &#39;algorithm&#39; and &#39;provider&#39; are private
1157                 // members of our supertype, we must perform a cast to
1158                 // access them.
1159                 Signature that = new CloneableDelegate(
1160                    (SignatureSpi)sigSpi.clone(),
1161                    ((Signature)this).algorithm);
1162                 that.provider = ((Signature)this).provider;
1163                 return that;
1164             } else {
1165                 throw new CloneNotSupportedException();
1166             }
1167         }
1168 
1169         private static SignatureSpi newInstance(Service s)
1170                 throws NoSuchAlgorithmException {
1171             if (s.getType().equals(&quot;Cipher&quot;)) {
1172                 // must be NONEwithRSA
1173                 try {
1174                     Cipher c = Cipher.getInstance(RSA_CIPHER, s.getProvider());
1175                     return new CipherAdapter(c);
1176                 } catch (NoSuchPaddingException e) {
1177                     throw new NoSuchAlgorithmException(e);
1178                 }
1179             } else {
1180                 Object o = s.newInstance(null);
1181                 if (o instanceof SignatureSpi == false) {
1182                     throw new NoSuchAlgorithmException
1183                         (&quot;Not a SignatureSpi: &quot; + o.getClass().getName());
1184                 }
1185                 return (SignatureSpi)o;
1186             }
1187         }
1188 
1189         // max number of debug warnings to print from chooseFirstProvider()
1190         private static int warnCount = 10;
1191 
1192         /**
1193          * Choose the Spi from the first provider available. Used if
1194          * delayed provider selection is not possible because initSign()/
1195          * initVerify() is not the first method called.
1196          */
1197         void chooseFirstProvider() {
1198             if (sigSpi != null) {
1199                 return;
1200             }
1201             synchronized (lock) {
1202                 if (sigSpi != null) {
1203                     return;
1204                 }
1205                 if (debug != null) {
1206                     int w = --warnCount;
1207                     if (w &gt;= 0) {
1208                         debug.println(&quot;Signature.init() not first method &quot;
1209                             + &quot;called, disabling delayed provider selection&quot;);
1210                         if (w == 0) {
1211                             debug.println(&quot;Further warnings of this type will &quot;
1212                                 + &quot;be suppressed&quot;);
1213                         }
1214                         new Exception(&quot;Debug call trace&quot;).printStackTrace();
1215                     }
1216                 }
1217                 Exception lastException = null;
1218                 while ((firstService != null) || serviceIterator.hasNext()) {
1219                     Service s;
1220                     if (firstService != null) {
1221                         s = firstService;
1222                         firstService = null;
1223                     } else {
1224                         s = serviceIterator.next();
1225                     }
1226                     if (isSpi(s) == false) {
1227                         continue;
1228                     }
1229                     try {
1230                         sigSpi = newInstance(s);
1231                         provider = s.getProvider();
1232                         // not needed any more
1233                         firstService = null;
1234                         serviceIterator = null;
1235                         return;
1236                     } catch (NoSuchAlgorithmException e) {
1237                         lastException = e;
1238                     }
1239                 }
1240                 ProviderException e = new ProviderException
1241                         (&quot;Could not construct SignatureSpi instance&quot;);
1242                 if (lastException != null) {
1243                     e.initCause(lastException);
1244                 }
1245                 throw e;
1246             }
1247         }
1248 
1249         // Used by engineSetParameter/engineInitSign/engineInitVerify() to
1250         // find the right provider with the supplied key, parameters, random source
1251         private void chooseProvider(int type, Key key,
1252                 AlgorithmParameterSpec params, SecureRandom random)
1253                 throws InvalidKeyException, InvalidAlgorithmParameterException {
1254             synchronized (lock) {
1255                 if (sigSpi != null) {
1256                     return;
1257                 }
1258                 Exception lastException = null;
1259                 while ((firstService != null) || serviceIterator.hasNext()) {
1260                     Service s;
1261                     if (firstService != null) {
1262                         s = firstService;
1263                         firstService = null;
1264                     } else {
1265                         s = serviceIterator.next();
1266                     }
1267                     // if provider says it does not support this key, ignore it
1268                     if (key != null &amp;&amp; s.supportsParameter(key) == false) {
1269                         continue;
1270                     }
1271                     // if instance is not a SignatureSpi, ignore it
1272                     if (isSpi(s) == false) {
1273                         continue;
1274                     }
1275                     try {
1276                         SignatureSpi spi = newInstance(s);
1277                         tryOperation(spi, type, key, params, random);
1278                         provider = s.getProvider();
1279                         sigSpi = spi;
1280                         firstService = null;
1281                         serviceIterator = null;
1282                         return;
1283                     } catch (Exception e) {
1284                         // NoSuchAlgorithmException from newInstance()
1285                         // InvalidKeyException from init()
1286                         // RuntimeException (ProviderException) from init()
1287                         if (lastException == null) {
1288                             lastException = e;
1289                         }
1290                     }
1291                 }
1292                 // no working provider found, fail
1293                 if (lastException instanceof InvalidKeyException) {
1294                     throw (InvalidKeyException)lastException;
1295                 }
1296                 if (lastException instanceof RuntimeException) {
1297                     throw (RuntimeException)lastException;
1298                 }
1299                 if (lastException instanceof InvalidAlgorithmParameterException) {
1300                     throw (InvalidAlgorithmParameterException)lastException;
1301                 }
1302 
1303                 String k = (key != null) ? key.getClass().getName() : &quot;(null)&quot;;
1304                 throw new InvalidKeyException
1305                     (&quot;No installed provider supports this key: &quot;
1306                     + k, lastException);
1307             }
1308         }
1309 
1310         private static final int I_PUB           = 1;
1311         private static final int I_PRIV          = 2;
1312         private static final int I_PRIV_SR       = 3;
1313         private static final int I_PUB_PARAM     = 4;
1314         private static final int I_PRIV_PARAM_SR = 5;
1315         private static final int S_PARAM         = 6;
1316 
1317         private void tryOperation(SignatureSpi spi, int type, Key  key,
1318                 AlgorithmParameterSpec params, SecureRandom random)
1319                 throws InvalidKeyException, InvalidAlgorithmParameterException {
1320             switch (type) {
1321             case I_PUB:
1322                 spi.engineInitVerify((PublicKey)key);
1323                 break;
1324             case I_PUB_PARAM:
1325                 spi.engineInitVerify((PublicKey)key, params);
1326                 break;
1327             case I_PRIV:
1328                 spi.engineInitSign((PrivateKey)key);
1329                 break;
1330             case I_PRIV_SR:
1331                 spi.engineInitSign((PrivateKey)key, random);
1332                 break;
1333             case I_PRIV_PARAM_SR:
1334                 spi.engineInitSign((PrivateKey)key, params, random);
1335                 break;
1336             case S_PARAM:
1337                 spi.engineSetParameter(params);
1338                 break;
1339             default:
1340                 throw new AssertionError(&quot;Internal error: &quot; + type);
1341             }
1342         }
1343 
1344         protected void engineInitVerify(PublicKey publicKey)
1345                 throws InvalidKeyException {
1346             if (sigSpi != null) {
1347                 sigSpi.engineInitVerify(publicKey);
1348             } else {
1349                 try {
1350                     chooseProvider(I_PUB, publicKey, null, null);
1351                 } catch (InvalidAlgorithmParameterException iape) {
1352                     // should not happen, re-throw as IKE just in case
1353                     throw new InvalidKeyException(iape);
1354                 }
1355             }
1356         }
1357 
1358         void engineInitVerify(PublicKey publicKey,
1359                 AlgorithmParameterSpec params)
1360                 throws InvalidKeyException, InvalidAlgorithmParameterException {
1361             if (sigSpi != null) {
1362                 sigSpi.engineInitVerify(publicKey, params);
1363             } else {
1364                 chooseProvider(I_PUB_PARAM, publicKey, params, null);
1365             }
1366         }
1367 
1368         protected void engineInitSign(PrivateKey privateKey)
1369                 throws InvalidKeyException {
1370             if (sigSpi != null) {
1371                 sigSpi.engineInitSign(privateKey);
1372             } else {
1373                 try {
1374                     chooseProvider(I_PRIV, privateKey, null, null);
1375                 } catch (InvalidAlgorithmParameterException iape) {
1376                     // should not happen, re-throw as IKE just in case
1377                     throw new InvalidKeyException(iape);
1378                 }
1379             }
1380         }
1381 
1382         protected void engineInitSign(PrivateKey privateKey, SecureRandom sr)
1383                 throws InvalidKeyException {
1384             if (sigSpi != null) {
1385                 sigSpi.engineInitSign(privateKey, sr);
1386             } else {
1387                 try {
1388                     chooseProvider(I_PRIV_SR, privateKey, null, sr);
1389                 } catch (InvalidAlgorithmParameterException iape) {
1390                     // should not happen, re-throw as IKE just in case
1391                     throw new InvalidKeyException(iape);
1392                 }
1393             }
1394         }
1395 
1396         void engineInitSign(PrivateKey privateKey,
1397                 AlgorithmParameterSpec params, SecureRandom sr)
1398                 throws InvalidKeyException, InvalidAlgorithmParameterException {
1399             if (sigSpi != null) {
1400                 sigSpi.engineInitSign(privateKey, params, sr);
1401             } else {
1402                 chooseProvider(I_PRIV_PARAM_SR, privateKey, params, sr);
1403             }
1404         }
1405 
1406         protected void engineUpdate(byte b) throws SignatureException {
1407             chooseFirstProvider();
1408             sigSpi.engineUpdate(b);
1409         }
1410 
1411         protected void engineUpdate(byte[] b, int off, int len)
1412                 throws SignatureException {
1413             chooseFirstProvider();
1414             sigSpi.engineUpdate(b, off, len);
1415         }
1416 
1417         protected void engineUpdate(ByteBuffer data) {
1418             chooseFirstProvider();
1419             sigSpi.engineUpdate(data);
1420         }
1421 
1422         protected byte[] engineSign() throws SignatureException {
1423             chooseFirstProvider();
1424             return sigSpi.engineSign();
1425         }
1426 
1427         protected int engineSign(byte[] outbuf, int offset, int len)
1428                 throws SignatureException {
1429             chooseFirstProvider();
1430             return sigSpi.engineSign(outbuf, offset, len);
1431         }
1432 
1433         protected boolean engineVerify(byte[] sigBytes)
1434                 throws SignatureException {
1435             chooseFirstProvider();
1436             return sigSpi.engineVerify(sigBytes);
1437         }
1438 
1439         protected boolean engineVerify(byte[] sigBytes, int offset, int length)
1440                 throws SignatureException {
1441             chooseFirstProvider();
1442             return sigSpi.engineVerify(sigBytes, offset, length);
1443         }
1444 
1445         protected void engineSetParameter(String param, Object value)
1446                 throws InvalidParameterException {
1447             chooseFirstProvider();
1448             sigSpi.engineSetParameter(param, value);
1449         }
1450 
1451         protected void engineSetParameter(AlgorithmParameterSpec params)
1452                 throws InvalidAlgorithmParameterException {
1453             if (sigSpi != null) {
1454                 sigSpi.engineSetParameter(params);
1455             } else {
1456                 try {
1457                     chooseProvider(S_PARAM, null, params, null);
1458                 } catch (InvalidKeyException ike) {
1459                     // should never happen, rethrow just in case
1460                     throw new InvalidAlgorithmParameterException(ike);
1461                 }
1462             }
1463         }
1464 
1465         protected Object engineGetParameter(String param)
1466                 throws InvalidParameterException {
1467             chooseFirstProvider();
1468             return sigSpi.engineGetParameter(param);
1469         }
1470 
1471         protected AlgorithmParameters engineGetParameters() {
1472             chooseFirstProvider();
1473             return sigSpi.engineGetParameters();
1474         }
1475     }
1476 
1477     // adapter for RSA/ECB/PKCS1Padding ciphers
1478     @SuppressWarnings(&quot;deprecation&quot;)
1479     private static class CipherAdapter extends SignatureSpi {
1480 
1481         private final Cipher cipher;
1482 
1483         private ByteArrayOutputStream data;
1484 
1485         CipherAdapter(Cipher cipher) {
1486             this.cipher = cipher;
1487         }
1488 
1489         protected void engineInitVerify(PublicKey publicKey)
1490                 throws InvalidKeyException {
1491             cipher.init(Cipher.DECRYPT_MODE, publicKey);
1492             if (data == null) {
1493                 data = new ByteArrayOutputStream(128);
1494             } else {
1495                 data.reset();
1496             }
1497         }
1498 
1499         protected void engineInitSign(PrivateKey privateKey)
1500                 throws InvalidKeyException {
1501             cipher.init(Cipher.ENCRYPT_MODE, privateKey);
1502             data = null;
1503         }
1504 
1505         protected void engineInitSign(PrivateKey privateKey,
1506                 SecureRandom random) throws InvalidKeyException {
1507             cipher.init(Cipher.ENCRYPT_MODE, privateKey, random);
1508             data = null;
1509         }
1510 
1511         protected void engineUpdate(byte b) throws SignatureException {
1512             engineUpdate(new byte[] {b}, 0, 1);
1513         }
1514 
1515         protected void engineUpdate(byte[] b, int off, int len)
1516                 throws SignatureException {
1517             if (data != null) {
1518                 data.write(b, off, len);
1519                 return;
1520             }
1521             byte[] out = cipher.update(b, off, len);
1522             if ((out != null) &amp;&amp; (out.length != 0)) {
1523                 throw new SignatureException
1524                     (&quot;Cipher unexpectedly returned data&quot;);
1525             }
1526         }
1527 
1528         protected byte[] engineSign() throws SignatureException {
1529             try {
1530                 return cipher.doFinal();
1531             } catch (IllegalBlockSizeException e) {
1532                 throw new SignatureException(&quot;doFinal() failed&quot;, e);
1533             } catch (BadPaddingException e) {
1534                 throw new SignatureException(&quot;doFinal() failed&quot;, e);
1535             }
1536         }
1537 
1538         protected boolean engineVerify(byte[] sigBytes)
1539                 throws SignatureException {
1540             try {
1541                 byte[] out = cipher.doFinal(sigBytes);
1542                 byte[] dataBytes = data.toByteArray();
1543                 data.reset();
1544                 return MessageDigest.isEqual(out, dataBytes);
1545             } catch (BadPaddingException e) {
1546                 // e.g. wrong public key used
1547                 // return false rather than throwing exception
1548                 return false;
1549             } catch (IllegalBlockSizeException e) {
1550                 throw new SignatureException(&quot;doFinal() failed&quot;, e);
1551             }
1552         }
1553 
1554         protected void engineSetParameter(String param, Object value)
1555                 throws InvalidParameterException {
1556             throw new InvalidParameterException(&quot;Parameters not supported&quot;);
1557         }
1558 
1559         protected Object engineGetParameter(String param)
1560                 throws InvalidParameterException {
1561             throw new InvalidParameterException(&quot;Parameters not supported&quot;);
1562         }
1563 
1564     }
1565 
1566 }
    </pre>
  </body>
</html>
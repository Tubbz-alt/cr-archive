<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/security/Signature.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.security;
  27 
  28 import java.security.spec.AlgorithmParameterSpec;
  29 import java.util.*;
  30 import java.util.concurrent.ConcurrentHashMap;
  31 import java.io.*;
  32 import java.security.cert.Certificate;
  33 import java.security.cert.X509Certificate;
  34 
  35 import java.nio.ByteBuffer;
  36 
  37 import java.security.Provider.Service;
  38 
  39 import javax.crypto.Cipher;
  40 import javax.crypto.IllegalBlockSizeException;
  41 import javax.crypto.BadPaddingException;
  42 import javax.crypto.NoSuchPaddingException;
  43 import jdk.internal.access.JavaSecuritySignatureAccess;
  44 import jdk.internal.access.SharedSecrets;
  45 
  46 import sun.security.util.Debug;
  47 import sun.security.jca.*;
  48 import sun.security.jca.GetInstance.Instance;
  49 import sun.security.util.KnownOIDs;
  50 
  51 /**
  52  * The Signature class is used to provide applications the functionality
  53  * of a digital signature algorithm. Digital signatures are used for
  54  * authentication and integrity assurance of digital data.
  55  *
  56  * &lt;p&gt; The signature algorithm can be, among others, the NIST standard
  57  * DSA, using DSA and SHA-256. The DSA algorithm using the
  58  * SHA-256 message digest algorithm can be specified as {@code SHA256withDSA}.
  59  * In the case of RSA the signing algorithm could be specified as, for example,
  60  * {@code SHA256withRSA}.
  61  * The algorithm name must be specified, as there is no default.
  62  *
  63  * &lt;p&gt; A Signature object can be used to generate and verify digital
  64  * signatures.
  65  *
  66  * &lt;p&gt; There are three phases to the use of a Signature object for
  67  * either signing data or verifying a signature:&lt;ol&gt;
  68  *
  69  * &lt;li&gt;Initialization, with either
  70  *
  71  *     &lt;ul&gt;
  72  *
  73  *     &lt;li&gt;a public key, which initializes the signature for
  74  *     verification (see {@link #initVerify(PublicKey) initVerify}), or
  75  *
  76  *     &lt;li&gt;a private key (and optionally a Secure Random Number Generator),
  77  *     which initializes the signature for signing
  78  *     (see {@link #initSign(PrivateKey)}
  79  *     and {@link #initSign(PrivateKey, SecureRandom)}).
  80  *
  81  *     &lt;/ul&gt;
  82  *
  83  * &lt;li&gt;Updating
  84  *
  85  * &lt;p&gt;Depending on the type of initialization, this will update the
  86  * bytes to be signed or verified. See the
  87  * {@link #update(byte) update} methods.
  88  *
  89  * &lt;li&gt;Signing or Verifying a signature on all updated bytes. See the
  90  * {@link #sign() sign} methods and the {@link #verify(byte[]) verify}
  91  * method.
  92  *
  93  * &lt;/ol&gt;
  94  *
  95  * &lt;p&gt;Note that this class is abstract and extends from
  96  * {@code SignatureSpi} for historical reasons.
  97  * Application developers should only take notice of the methods defined in
  98  * this {@code Signature} class; all the methods in
  99  * the superclass are intended for cryptographic service providers who wish to
 100  * supply their own implementations of digital signature algorithms.
 101  *
 102  * &lt;p&gt; Every implementation of the Java platform is required to support the
 103  * following standard {@code Signature} algorithms:
 104  * &lt;ul&gt;
 105  * &lt;li&gt;{@code SHA1withDSA}&lt;/li&gt;
 106  * &lt;li&gt;{@code SHA256withDSA}&lt;/li&gt;
 107  * &lt;li&gt;{@code SHA1withRSA}&lt;/li&gt;
 108  * &lt;li&gt;{@code SHA256withRSA}&lt;/li&gt;
 109  * &lt;/ul&gt;
 110  * These algorithms are described in the &lt;a href=
 111  * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 112  * Signature section&lt;/a&gt; of the
 113  * Java Security Standard Algorithm Names Specification.
 114  * Consult the release documentation for your implementation to see if any
 115  * other algorithms are supported.
 116  *
 117  * @author Benjamin Renaud
 118  * @since 1.1
 119  *
 120  */
 121 
 122 public abstract class Signature extends SignatureSpi {
 123 
 124     static {
 125         SharedSecrets.setJavaSecuritySignatureAccess(
 126             new JavaSecuritySignatureAccess() {
 127                 @Override
 128                 public void initVerify(Signature s, PublicKey publicKey,
 129                         AlgorithmParameterSpec params)
 130                         throws InvalidKeyException,
 131                         InvalidAlgorithmParameterException {
 132                     s.initVerify(publicKey, params);
 133                 }
 134                 @Override
 135                 public void initVerify(Signature s,
 136                         java.security.cert.Certificate certificate,
 137                         AlgorithmParameterSpec params)
 138                         throws InvalidKeyException,
 139                         InvalidAlgorithmParameterException {
 140                     s.initVerify(certificate, params);
 141                 }
 142                 @Override
 143                 public void initSign(Signature s, PrivateKey privateKey,
 144                         AlgorithmParameterSpec params, SecureRandom random)
 145                         throws InvalidKeyException,
 146                         InvalidAlgorithmParameterException {
 147                     s.initSign(privateKey, params, random);
 148                 }
 149         });
 150     }
 151 
 152     private static final Debug debug =
 153                         Debug.getInstance(&quot;jca&quot;, &quot;Signature&quot;);
 154 
 155     private static final Debug pdebug =
 156                         Debug.getInstance(&quot;provider&quot;, &quot;Provider&quot;);
 157     private static final boolean skipDebug =
 158         Debug.isOn(&quot;engine=&quot;) &amp;&amp; !Debug.isOn(&quot;signature&quot;);
 159 
 160     /*
 161      * The algorithm for this signature object.
 162      * This value is used to map an OID to the particular algorithm.
 163      * The mapping is done in AlgorithmObject.algOID(String algorithm)
 164      */
 165     private String algorithm;
 166 
 167     // The provider
 168     Provider provider;
 169 
 170     /**
 171      * Possible {@link #state} value, signifying that
 172      * this signature object has not yet been initialized.
 173      */
 174     protected static final int UNINITIALIZED = 0;
 175 
 176     /**
 177      * Possible {@link #state} value, signifying that
 178      * this signature object has been initialized for signing.
 179      */
 180     protected static final int SIGN = 2;
 181 
 182     /**
 183      * Possible {@link #state} value, signifying that
 184      * this signature object has been initialized for verification.
 185      */
 186     protected static final int VERIFY = 3;
 187 
 188     /**
 189      * Current state of this signature object.
 190      */
 191     protected int state = UNINITIALIZED;
 192 
 193     /**
 194      * Creates a Signature object for the specified algorithm.
 195      *
 196      * @param algorithm the standard string name of the algorithm.
 197      * See the Signature section in the &lt;a href=
 198      * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 199      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 200      * for information about standard algorithm names.
 201      */
 202     protected Signature(String algorithm) {
 203         this.algorithm = algorithm;
 204     }
 205 
 206     // name of the special signature alg
 207     private static final String RSA_SIGNATURE = &quot;NONEwithRSA&quot;;
 208 
 209     // name of the equivalent cipher alg
 210     private static final String RSA_CIPHER = &quot;RSA/ECB/PKCS1Padding&quot;;
 211 
 212     // all the services we need to lookup for compatibility with Cipher
 213     private static final List&lt;ServiceId&gt; rsaIds = List.of(
 214         new ServiceId(&quot;Signature&quot;, &quot;NONEwithRSA&quot;),
 215         new ServiceId(&quot;Cipher&quot;, &quot;RSA/ECB/PKCS1Padding&quot;),
 216         new ServiceId(&quot;Cipher&quot;, &quot;RSA/ECB&quot;),
 217         new ServiceId(&quot;Cipher&quot;, &quot;RSA//PKCS1Padding&quot;),
 218         new ServiceId(&quot;Cipher&quot;, &quot;RSA&quot;));
 219 
 220     /**
 221      * Returns a Signature object that implements the specified signature
 222      * algorithm.
 223      *
 224      * &lt;p&gt; This method traverses the list of registered security Providers,
 225      * starting with the most preferred Provider.
 226      * A new Signature object encapsulating the
 227      * SignatureSpi implementation from the first
 228      * Provider that supports the specified algorithm is returned.
 229      *
 230      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 231      * the {@link Security#getProviders() Security.getProviders()} method.
 232      *
 233      * @implNote
 234      * The JDK Reference Implementation additionally uses the
 235      * {@code jdk.security.provider.preferred}
 236      * {@link Security#getProperty(String) Security} property to determine
 237      * the preferred provider order for the specified algorithm. This
 238      * may be different than the order of providers returned by
 239      * {@link Security#getProviders() Security.getProviders()}.
 240      *
 241      * @param algorithm the standard name of the algorithm requested.
 242      * See the Signature section in the &lt;a href=
 243      * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 244      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 245      * for information about standard algorithm names.
 246      *
 247      * @return the new {@code Signature} object
 248      *
 249      * @throws NoSuchAlgorithmException if no {@code Provider} supports a
 250      *         {@code Signature} implementation for the
 251      *         specified algorithm
 252      *
 253      * @throws NullPointerException if {@code algorithm} is {@code null}
 254      *
 255      * @see Provider
 256      */
 257     public static Signature getInstance(String algorithm)
 258             throws NoSuchAlgorithmException {
 259         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 260         List&lt;Service&gt; list;
 261         if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {
 262             list = GetInstance.getServices(rsaIds);
 263         } else {
 264             list = GetInstance.getServices(&quot;Signature&quot;, algorithm);
 265         }
 266         Iterator&lt;Service&gt; t = list.iterator();
 267         if (t.hasNext() == false) {
 268             throw new NoSuchAlgorithmException
 269                 (algorithm + &quot; Signature not available&quot;);
 270         }
 271         // try services until we find an Spi or a working Signature subclass
 272         NoSuchAlgorithmException failure;
 273         do {
 274             Service s = t.next();
<a name="1" id="anc1"></a><span class="line-modified"> 275             if (isSpi(s)) {</span>
 276                 return new Delegate(s, t, algorithm);
 277             } else {
 278                 // must be a subclass of Signature, disable dynamic selection
 279                 try {
 280                     Instance instance =
 281                         GetInstance.getInstance(s, SignatureSpi.class);
 282                     return getInstance(instance, algorithm);
 283                 } catch (NoSuchAlgorithmException e) {
 284                     failure = e;
 285                 }
 286             }
 287         } while (t.hasNext());
 288         throw failure;
 289     }
 290 
 291     private static Signature getInstance(Instance instance, String algorithm) {
 292         Signature sig;
 293         if (instance.impl instanceof Signature) {
 294             sig = (Signature)instance.impl;
 295             sig.algorithm = algorithm;
 296         } else {
 297             SignatureSpi spi = (SignatureSpi)instance.impl;
<a name="2" id="anc2"></a><span class="line-modified"> 298             sig = new Delegate(spi, algorithm);</span>
 299         }
 300         sig.provider = instance.provider;
 301         return sig;
 302     }
 303 
 304     private static final Map&lt;String,Boolean&gt; signatureInfo;
 305 
 306     static {
 307         signatureInfo = new ConcurrentHashMap&lt;&gt;();
 308         Boolean TRUE = Boolean.TRUE;
 309         // pre-initialize with values for our SignatureSpi implementations
 310         signatureInfo.put(&quot;sun.security.provider.DSA$RawDSA&quot;, TRUE);
 311         signatureInfo.put(&quot;sun.security.provider.DSA$SHA1withDSA&quot;, TRUE);
 312         signatureInfo.put(&quot;sun.security.rsa.RSASignature$MD2withRSA&quot;, TRUE);
 313         signatureInfo.put(&quot;sun.security.rsa.RSASignature$MD5withRSA&quot;, TRUE);
 314         signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA1withRSA&quot;, TRUE);
 315         signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA256withRSA&quot;, TRUE);
 316         signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA384withRSA&quot;, TRUE);
 317         signatureInfo.put(&quot;sun.security.rsa.RSASignature$SHA512withRSA&quot;, TRUE);
 318         signatureInfo.put(&quot;sun.security.rsa.RSAPSSSignature&quot;, TRUE);
 319         signatureInfo.put(&quot;sun.security.pkcs11.P11Signature&quot;, TRUE);
 320     }
 321 
 322     private static boolean isSpi(Service s) {
 323         if (s.getType().equals(&quot;Cipher&quot;)) {
 324             // must be a CipherSpi, which we can wrap with the CipherAdapter
 325             return true;
 326         }
 327         String className = s.getClassName();
 328         Boolean result = signatureInfo.get(className);
 329         if (result == null) {
 330             try {
 331                 Object instance = s.newInstance(null);
 332                 // Signature extends SignatureSpi
 333                 // so it is a &quot;real&quot; Spi if it is an
 334                 // instance of SignatureSpi but not Signature
 335                 boolean r = (instance instanceof SignatureSpi)
 336                                 &amp;&amp; (instance instanceof Signature == false);
 337                 if ((debug != null) &amp;&amp; (r == false)) {
 338                     debug.println(&quot;Not a SignatureSpi &quot; + className);
 339                     debug.println(&quot;Delayed provider selection may not be &quot;
 340                         + &quot;available for algorithm &quot; + s.getAlgorithm());
 341                 }
 342                 result = Boolean.valueOf(r);
 343                 signatureInfo.put(className, result);
 344             } catch (Exception e) {
 345                 // something is wrong, assume not an SPI
 346                 return false;
 347             }
 348         }
 349         return result.booleanValue();
 350     }
 351 
 352     /**
 353      * Returns a Signature object that implements the specified signature
 354      * algorithm.
 355      *
 356      * &lt;p&gt; A new Signature object encapsulating the
 357      * SignatureSpi implementation from the specified provider
 358      * is returned.  The specified provider must be registered
 359      * in the security provider list.
 360      *
 361      * &lt;p&gt; Note that the list of registered providers may be retrieved via
 362      * the {@link Security#getProviders() Security.getProviders()} method.
 363      *
 364      * @param algorithm the name of the algorithm requested.
 365      * See the Signature section in the &lt;a href=
 366      * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 367      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 368      * for information about standard algorithm names.
 369      *
 370      * @param provider the name of the provider.
 371      *
 372      * @return the new {@code Signature} object
 373      *
 374      * @throws IllegalArgumentException if the provider name is {@code null}
 375      *         or empty
 376      *
 377      * @throws NoSuchAlgorithmException if a {@code SignatureSpi}
 378      *         implementation for the specified algorithm is not
 379      *         available from the specified provider
 380      *
 381      * @throws NoSuchProviderException if the specified provider is not
 382      *         registered in the security provider list
 383      *
 384      * @throws NullPointerException if {@code algorithm} is {@code null}
 385      *
 386      * @see Provider
 387      */
 388     public static Signature getInstance(String algorithm, String provider)
 389             throws NoSuchAlgorithmException, NoSuchProviderException {
 390         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 391         if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {
 392             // exception compatibility with existing code
 393             if (provider == null || provider.isEmpty()) {
 394                 throw new IllegalArgumentException(&quot;missing provider&quot;);
 395             }
 396             Provider p = Security.getProvider(provider);
 397             if (p == null) {
 398                 throw new NoSuchProviderException
 399                     (&quot;no such provider: &quot; + provider);
 400             }
 401             return getInstanceRSA(p);
 402         }
 403         Instance instance = GetInstance.getInstance
 404                 (&quot;Signature&quot;, SignatureSpi.class, algorithm, provider);
 405         return getInstance(instance, algorithm);
 406     }
 407 
 408     /**
 409      * Returns a Signature object that implements the specified
 410      * signature algorithm.
 411      *
 412      * &lt;p&gt; A new Signature object encapsulating the
 413      * SignatureSpi implementation from the specified Provider
 414      * object is returned.  Note that the specified Provider object
 415      * does not have to be registered in the provider list.
 416      *
 417      * @param algorithm the name of the algorithm requested.
 418      * See the Signature section in the &lt;a href=
 419      * &quot;{@docRoot}/../specs/security/standard-names.html#signature-algorithms&quot;&gt;
 420      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
 421      * for information about standard algorithm names.
 422      *
 423      * @param provider the provider.
 424      *
 425      * @return the new {@code Signature} object
 426      *
 427      * @throws IllegalArgumentException if the provider is {@code null}
 428      *
 429      * @throws NoSuchAlgorithmException if a {@code SignatureSpi}
 430      *         implementation for the specified algorithm is not available
 431      *         from the specified {@code Provider} object
 432      *
 433      * @throws NullPointerException if {@code algorithm} is {@code null}
 434      *
 435      * @see Provider
 436      *
 437      * @since 1.4
 438      */
 439     public static Signature getInstance(String algorithm, Provider provider)
 440             throws NoSuchAlgorithmException {
 441         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
 442         if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {
 443             // exception compatibility with existing code
 444             if (provider == null) {
 445                 throw new IllegalArgumentException(&quot;missing provider&quot;);
 446             }
 447             return getInstanceRSA(provider);
 448         }
 449         Instance instance = GetInstance.getInstance
 450                 (&quot;Signature&quot;, SignatureSpi.class, algorithm, provider);
 451         return getInstance(instance, algorithm);
 452     }
 453 
 454     // return an implementation for NONEwithRSA, which is a special case
 455     // because of the Cipher.RSA/ECB/PKCS1Padding compatibility wrapper
 456     private static Signature getInstanceRSA(Provider p)
 457             throws NoSuchAlgorithmException {
 458         // try Signature first
 459         Service s = p.getService(&quot;Signature&quot;, RSA_SIGNATURE);
 460         if (s != null) {
 461             Instance instance = GetInstance.getInstance(s, SignatureSpi.class);
 462             return getInstance(instance, RSA_SIGNATURE);
 463         }
 464         // check Cipher
 465         try {
 466             Cipher c = Cipher.getInstance(RSA_CIPHER, p);
<a name="3" id="anc3"></a><span class="line-modified"> 467             return new Delegate(new CipherAdapter(c), RSA_SIGNATURE);</span>
 468         } catch (GeneralSecurityException e) {
 469             // throw Signature style exception message to avoid confusion,
 470             // but append Cipher exception as cause
 471             throw new NoSuchAlgorithmException(&quot;no such algorithm: &quot;
 472                 + RSA_SIGNATURE + &quot; for provider &quot; + p.getName(), e);
 473         }
 474     }
 475 
 476     /**
 477      * Returns the provider of this signature object.
 478      *
 479      * @return the provider of this signature object
 480      */
 481     public final Provider getProvider() {
 482         chooseFirstProvider();
 483         return this.provider;
 484     }
 485 
 486     private String getProviderName() {
 487         return (provider == null)  ? &quot;(no provider)&quot; : provider.getName();
 488     }
 489 
 490     void chooseFirstProvider() {
 491         // empty, overridden in Delegate
 492     }
 493 
 494     /**
 495      * Initializes this object for verification. If this method is called
 496      * again with a different argument, it negates the effect
 497      * of this call.
 498      *
 499      * @param publicKey the public key of the identity whose signature is
 500      * going to be verified.
 501      *
 502      * @throws    InvalidKeyException if the key is invalid.
 503      */
 504     public final void initVerify(PublicKey publicKey)
 505             throws InvalidKeyException {
 506         engineInitVerify(publicKey);
 507         state = VERIFY;
 508 
 509         if (!skipDebug &amp;&amp; pdebug != null) {
 510             pdebug.println(&quot;Signature.&quot; + algorithm +
 511                 &quot; verification algorithm from: &quot; + getProviderName());
 512         }
 513     }
 514 
 515     /**
 516      * Initialize this object for verification. If this method is called
 517      * again with different arguments, it negates the effect
 518      * of this call.
 519      *
 520      * @param publicKey the public key of the identity whose signature is
 521      * going to be verified.
 522      * @param params the parameters used for verifying this signature.
 523      *
 524      * @throws    InvalidKeyException if the key is invalid.
 525      * @throws    InvalidAlgorithmParameterException if the params is invalid.
 526      */
 527     final void initVerify(PublicKey publicKey, AlgorithmParameterSpec params)
 528             throws InvalidKeyException, InvalidAlgorithmParameterException {
 529         engineInitVerify(publicKey, params);
 530         state = VERIFY;
 531 
 532         if (!skipDebug &amp;&amp; pdebug != null) {
 533             pdebug.println(&quot;Signature.&quot; + algorithm +
 534                 &quot; verification algorithm from: &quot; + getProviderName());
 535         }
 536     }
 537 
 538     private static PublicKey getPublicKeyFromCert(Certificate cert)
 539             throws InvalidKeyException {
 540         // If the certificate is of type X509Certificate,
 541         // we should check whether it has a Key Usage
 542         // extension marked as critical.
 543         //if (cert instanceof java.security.cert.X509Certificate) {
 544         if (cert instanceof X509Certificate) {
 545             // Check whether the cert has a key usage extension
 546             // marked as a critical extension.
 547             // The OID for KeyUsage extension is 2.5.29.15.
 548             X509Certificate c = (X509Certificate)cert;
 549             Set&lt;String&gt; critSet = c.getCriticalExtensionOIDs();
 550 
 551             if (critSet != null &amp;&amp; !critSet.isEmpty()
 552                 &amp;&amp; critSet.contains(KnownOIDs.KeyUsage.value())) {
 553                 boolean[] keyUsageInfo = c.getKeyUsage();
 554                 // keyUsageInfo[0] is for digitalSignature.
 555                 if ((keyUsageInfo != null) &amp;&amp; (keyUsageInfo[0] == false))
 556                     throw new InvalidKeyException(&quot;Wrong key usage&quot;);
 557             }
 558         }
 559         return cert.getPublicKey();
 560     }
 561 
 562     /**
 563      * Initializes this object for verification, using the public key from
 564      * the given certificate.
 565      * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
 566      * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
 567      * extension field implies that the public key in
 568      * the certificate and its corresponding private key are not
 569      * supposed to be used for digital signatures, an
 570      * {@code InvalidKeyException} is thrown.
 571      *
 572      * @param certificate the certificate of the identity whose signature is
 573      * going to be verified.
 574      *
 575      * @throws    InvalidKeyException  if the public key in the certificate
 576      * is not encoded properly or does not include required  parameter
 577      * information or cannot be used for digital signature purposes.
 578      * @since 1.3
 579      */
 580     public final void initVerify(Certificate certificate)
 581             throws InvalidKeyException {
 582         engineInitVerify(getPublicKeyFromCert(certificate));
 583         state = VERIFY;
 584 
 585         if (!skipDebug &amp;&amp; pdebug != null) {
 586             pdebug.println(&quot;Signature.&quot; + algorithm +
 587                 &quot; verification algorithm from: &quot; + getProviderName());
 588         }
 589     }
 590 
 591     /**
 592      * Initializes this object for verification, using the public key from
 593      * the given certificate.
 594      * &lt;p&gt;If the certificate is of type X.509 and has a &lt;i&gt;key usage&lt;/i&gt;
 595      * extension field marked as critical, and the value of the &lt;i&gt;key usage&lt;/i&gt;
 596      * extension field implies that the public key in
 597      * the certificate and its corresponding private key are not
 598      * supposed to be used for digital signatures, an
 599      * {@code InvalidKeyException} is thrown.
 600      *
 601      * @param certificate the certificate of the identity whose signature is
 602      * going to be verified.
 603      * @param params the parameters used for verifying this signature.
 604      *
 605      * @throws    InvalidKeyException  if the public key in the certificate
 606      * is not encoded properly or does not include required  parameter
 607      * information or cannot be used for digital signature purposes.
 608      * @throws    InvalidAlgorithmParameterException if the params is invalid.
 609      *
 610      * @since 13
 611      */
 612     final void initVerify(Certificate certificate,
 613             AlgorithmParameterSpec params)
 614             throws InvalidKeyException, InvalidAlgorithmParameterException {
 615         engineInitVerify(getPublicKeyFromCert(certificate), params);
 616         state = VERIFY;
 617 
 618         if (!skipDebug &amp;&amp; pdebug != null) {
 619             pdebug.println(&quot;Signature.&quot; + algorithm +
 620                 &quot; verification algorithm from: &quot; + getProviderName());
 621         }
 622     }
 623 
 624     /**
 625      * Initialize this object for signing. If this method is called
 626      * again with a different argument, it negates the effect
 627      * of this call.
 628      *
 629      * @param privateKey the private key of the identity whose signature
 630      * is going to be generated.
 631      *
 632      * @throws    InvalidKeyException if the key is invalid.
 633      */
 634     public final void initSign(PrivateKey privateKey)
 635             throws InvalidKeyException {
 636         engineInitSign(privateKey);
 637         state = SIGN;
 638 
 639         if (!skipDebug &amp;&amp; pdebug != null) {
 640             pdebug.println(&quot;Signature.&quot; + algorithm +
 641                 &quot; signing algorithm from: &quot; + getProviderName());
 642         }
 643     }
 644 
 645     /**
 646      * Initialize this object for signing. If this method is called
 647      * again with a different argument, it negates the effect
 648      * of this call.
 649      *
 650      * @param privateKey the private key of the identity whose signature
 651      * is going to be generated.
 652      *
 653      * @param random the source of randomness for this signature.
 654      *
 655      * @throws    InvalidKeyException if the key is invalid.
 656      */
 657     public final void initSign(PrivateKey privateKey, SecureRandom random)
 658             throws InvalidKeyException {
 659         engineInitSign(privateKey, random);
 660         state = SIGN;
 661 
 662         if (!skipDebug &amp;&amp; pdebug != null) {
 663             pdebug.println(&quot;Signature.&quot; + algorithm +
 664                 &quot; signing algorithm from: &quot; + getProviderName());
 665         }
 666     }
 667 
 668     /**
 669      * Initialize this object for signing. If this method is called
 670      * again with different arguments, it negates the effect
 671      * of this call.
 672      *
 673      * @param privateKey the private key of the identity whose signature
 674      * is going to be generated.
 675      * @param params the parameters used for generating signature.
 676      * @param random the source of randomness for this signature.
 677      *
 678      * @throws    InvalidKeyException if the key is invalid.
 679      * @throws    InvalidAlgorithmParameterException if the params is invalid
 680      */
 681     final void initSign(PrivateKey privateKey,
 682             AlgorithmParameterSpec params, SecureRandom random)
 683             throws InvalidKeyException, InvalidAlgorithmParameterException {
 684         engineInitSign(privateKey, params, random);
 685         state = SIGN;
 686 
 687         if (!skipDebug &amp;&amp; pdebug != null) {
 688             pdebug.println(&quot;Signature.&quot; + algorithm +
 689                 &quot; signing algorithm from: &quot; + getProviderName());
 690         }
 691     }
 692 
 693     /**
 694      * Returns the signature bytes of all the data updated.
 695      * The format of the signature depends on the underlying
 696      * signature scheme.
 697      *
 698      * &lt;p&gt;A call to this method resets this signature object to the state
 699      * it was in when previously initialized for signing via a
 700      * call to {@code initSign(PrivateKey)}. That is, the object is
 701      * reset and available to generate another signature from the same
 702      * signer, if desired, via new calls to {@code update} and
 703      * {@code sign}.
 704      *
 705      * @return the signature bytes of the signing operation&#39;s result.
 706      *
 707      * @throws    SignatureException if this signature object is not
 708      * initialized properly or if this signature algorithm is unable to
 709      * process the input data provided.
 710      */
 711     public final byte[] sign() throws SignatureException {
 712         if (state == SIGN) {
 713             return engineSign();
 714         }
 715         throw new SignatureException(&quot;object not initialized for &quot; +
 716                                      &quot;signing&quot;);
 717     }
 718 
 719     /**
 720      * Finishes the signature operation and stores the resulting signature
 721      * bytes in the provided buffer {@code outbuf}, starting at
 722      * {@code offset}.
 723      * The format of the signature depends on the underlying
 724      * signature scheme.
 725      *
 726      * &lt;p&gt;This signature object is reset to its initial state (the state it
 727      * was in after a call to one of the {@code initSign} methods) and
 728      * can be reused to generate further signatures with the same private key.
 729      *
 730      * @param outbuf buffer for the signature result.
 731      *
 732      * @param offset offset into {@code outbuf} where the signature is
 733      * stored.
 734      *
 735      * @param len number of bytes within {@code outbuf} allotted for the
 736      * signature.
 737      *
 738      * @return the number of bytes placed into {@code outbuf}.
 739      *
 740      * @throws    SignatureException if this signature object is not
 741      *     initialized properly, if this signature algorithm is unable to
 742      *     process the input data provided, or if {@code len} is less
 743      *     than the actual signature length.
 744      * @throws    IllegalArgumentException if {@code outbuf} is {@code null},
 745      *     or {@code offset} or {@code len} is less than 0, or the sum of
 746      *     {@code offset} and {@code len} is greater than the length of
 747      *     {@code outbuf}.
 748      *
 749      * @since 1.2
 750      */
 751     public final int sign(byte[] outbuf, int offset, int len)
 752         throws SignatureException {
 753         if (outbuf == null) {
 754             throw new IllegalArgumentException(&quot;No output buffer given&quot;);
 755         }
 756         if (offset &lt; 0 || len &lt; 0) {
 757             throw new IllegalArgumentException(&quot;offset or len is less than 0&quot;);
 758         }
 759         if (outbuf.length - offset &lt; len) {
 760             throw new IllegalArgumentException
 761                 (&quot;Output buffer too small for specified offset and length&quot;);
 762         }
 763         if (state != SIGN) {
 764             throw new SignatureException(&quot;object not initialized for &quot; +
 765                                          &quot;signing&quot;);
 766         }
 767         return engineSign(outbuf, offset, len);
 768     }
 769 
 770     /**
 771      * Verifies the passed-in signature.
 772      *
 773      * &lt;p&gt;A call to this method resets this signature object to the state
 774      * it was in when previously initialized for verification via a
 775      * call to {@code initVerify(PublicKey)}. That is, the object is
 776      * reset and available to verify another signature from the identity
 777      * whose public key was specified in the call to {@code initVerify}.
 778      *
 779      * @param signature the signature bytes to be verified.
 780      *
 781      * @return true if the signature was verified, false if not.
 782      *
 783      * @throws    SignatureException if this signature object is not
 784      * initialized properly, the passed-in signature is improperly
 785      * encoded or of the wrong type, if this signature algorithm is unable to
 786      * process the input data provided, etc.
 787      */
 788     public final boolean verify(byte[] signature) throws SignatureException {
 789         if (state == VERIFY) {
 790             return engineVerify(signature);
 791         }
 792         throw new SignatureException(&quot;object not initialized for &quot; +
 793                                      &quot;verification&quot;);
 794     }
 795 
 796     /**
 797      * Verifies the passed-in signature in the specified array
 798      * of bytes, starting at the specified offset.
 799      *
 800      * &lt;p&gt;A call to this method resets this signature object to the state
 801      * it was in when previously initialized for verification via a
 802      * call to {@code initVerify(PublicKey)}. That is, the object is
 803      * reset and available to verify another signature from the identity
 804      * whose public key was specified in the call to {@code initVerify}.
 805      *
 806      *
 807      * @param signature the signature bytes to be verified.
 808      * @param offset the offset to start from in the array of bytes.
 809      * @param length the number of bytes to use, starting at offset.
 810      *
 811      * @return true if the signature was verified, false if not.
 812      *
 813      * @throws    SignatureException if this signature object is not
 814      * initialized properly, the passed-in signature is improperly
 815      * encoded or of the wrong type, if this signature algorithm is unable to
 816      * process the input data provided, etc.
 817      * @throws    IllegalArgumentException if the {@code signature}
 818      * byte array is {@code null}, or the {@code offset} or {@code length}
 819      * is less than 0, or the sum of the {@code offset} and
 820      * {@code length} is greater than the length of the
 821      * {@code signature} byte array.
 822      * @since 1.4
 823      */
 824     public final boolean verify(byte[] signature, int offset, int length)
 825         throws SignatureException {
 826         if (state == VERIFY) {
 827             if (signature == null) {
 828                 throw new IllegalArgumentException(&quot;signature is null&quot;);
 829             }
 830             if (offset &lt; 0 || length &lt; 0) {
 831                 throw new IllegalArgumentException
 832                     (&quot;offset or length is less than 0&quot;);
 833             }
 834             if (signature.length - offset &lt; length) {
 835                 throw new IllegalArgumentException
 836                     (&quot;signature too small for specified offset and length&quot;);
 837             }
 838 
 839             return engineVerify(signature, offset, length);
 840         }
 841         throw new SignatureException(&quot;object not initialized for &quot; +
 842                                      &quot;verification&quot;);
 843     }
 844 
 845     /**
 846      * Updates the data to be signed or verified by a byte.
 847      *
 848      * @param b the byte to use for the update.
 849      *
 850      * @throws    SignatureException if this signature object is not
 851      * initialized properly.
 852      */
 853     public final void update(byte b) throws SignatureException {
 854         if (state == VERIFY || state == SIGN) {
 855             engineUpdate(b);
 856         } else {
 857             throw new SignatureException(&quot;object not initialized for &quot;
 858                                          + &quot;signature or verification&quot;);
 859         }
 860     }
 861 
 862     /**
 863      * Updates the data to be signed or verified, using the specified
 864      * array of bytes.
 865      *
 866      * @param data the byte array to use for the update.
 867      *
 868      * @throws    SignatureException if this signature object is not
 869      * initialized properly.
 870      */
 871     public final void update(byte[] data) throws SignatureException {
 872         update(data, 0, data.length);
 873     }
 874 
 875     /**
 876      * Updates the data to be signed or verified, using the specified
 877      * array of bytes, starting at the specified offset.
 878      *
 879      * @param data the array of bytes.
 880      * @param off the offset to start from in the array of bytes.
 881      * @param len the number of bytes to use, starting at offset.
 882      *
 883      * @throws    SignatureException if this signature object is not
 884      *     initialized properly.
 885      * @throws    IllegalArgumentException if {@code data} is {@code null},
 886      *     or {@code off} or {@code len} is less than 0, or the sum of
 887      *     {@code off} and {@code len} is greater than the length of
 888      *     {@code data}.
 889      */
 890     public final void update(byte[] data, int off, int len)
 891             throws SignatureException {
 892         if (state == SIGN || state == VERIFY) {
 893             if (data == null) {
 894                 throw new IllegalArgumentException(&quot;data is null&quot;);
 895             }
 896             if (off &lt; 0 || len &lt; 0) {
 897                 throw new IllegalArgumentException(&quot;off or len is less than 0&quot;);
 898             }
 899             if (data.length - off &lt; len) {
 900                 throw new IllegalArgumentException
 901                     (&quot;data too small for specified offset and length&quot;);
 902             }
 903             engineUpdate(data, off, len);
 904         } else {
 905             throw new SignatureException(&quot;object not initialized for &quot;
 906                                          + &quot;signature or verification&quot;);
 907         }
 908     }
 909 
 910     /**
 911      * Updates the data to be signed or verified using the specified
 912      * ByteBuffer. Processes the {@code data.remaining()} bytes
 913      * starting at {@code data.position()}.
 914      * Upon return, the buffer&#39;s position will be equal to its limit;
 915      * its limit will not have changed.
 916      *
 917      * @param data the ByteBuffer
 918      *
 919      * @throws    SignatureException if this signature object is not
 920      * initialized properly.
 921      * @since 1.5
 922      */
 923     public final void update(ByteBuffer data) throws SignatureException {
 924         if ((state != SIGN) &amp;&amp; (state != VERIFY)) {
 925             throw new SignatureException(&quot;object not initialized for &quot;
 926                                          + &quot;signature or verification&quot;);
 927         }
 928         if (data == null) {
 929             throw new NullPointerException();
 930         }
 931         engineUpdate(data);
 932     }
 933 
 934     /**
 935      * Returns the name of the algorithm for this signature object.
 936      *
 937      * @return the name of the algorithm for this signature object.
 938      */
 939     public final String getAlgorithm() {
 940         return this.algorithm;
 941     }
 942 
 943     /**
 944      * Returns a string representation of this signature object,
 945      * providing information that includes the state of the object
 946      * and the name of the algorithm used.
 947      *
 948      * @return a string representation of this signature object.
 949      */
 950     public String toString() {
 951         String initState = &quot;&quot;;
 952         switch (state) {
 953         case UNINITIALIZED:
 954             initState = &quot;&lt;not initialized&gt;&quot;;
 955             break;
 956         case VERIFY:
 957             initState = &quot;&lt;initialized for verifying&gt;&quot;;
 958             break;
 959         case SIGN:
 960             initState = &quot;&lt;initialized for signing&gt;&quot;;
 961             break;
 962         }
 963         return &quot;Signature object: &quot; + getAlgorithm() + initState;
 964     }
 965 
 966     /**
 967      * Sets the specified algorithm parameter to the specified value.
 968      * This method supplies a general-purpose mechanism through
 969      * which it is possible to set the various parameters of this object.
 970      * A parameter may be any settable parameter for the algorithm, such as
 971      * a parameter size, or a source of random bits for signature generation
 972      * (if appropriate), or an indication of whether or not to perform
 973      * a specific but optional computation. A uniform algorithm-specific
 974      * naming scheme for each parameter is desirable but left unspecified
 975      * at this time.
 976      *
 977      * @param param the string identifier of the parameter.
 978      * @param value the parameter value.
 979      *
 980      * @throws    InvalidParameterException if {@code param} is an
 981      * invalid parameter for this signature algorithm engine,
 982      * the parameter is already set
 983      * and cannot be set again, a security exception occurs, and so on.
 984      *
 985      * @see #getParameter
 986      *
 987      * @deprecated Use
 988      * {@link #setParameter(java.security.spec.AlgorithmParameterSpec)
 989      * setParameter}.
 990      */
 991     @Deprecated
 992     public final void setParameter(String param, Object value)
 993             throws InvalidParameterException {
 994         engineSetParameter(param, value);
 995     }
 996 
 997     /**
 998      * Initializes this signature engine with the specified parameter set.
 999      *
1000      * @param params the parameters
1001      *
1002      * @throws    InvalidAlgorithmParameterException if the given parameters
1003      * are inappropriate for this signature engine
1004      *
1005      * @see #getParameters
1006      */
1007     public final void setParameter(AlgorithmParameterSpec params)
1008             throws InvalidAlgorithmParameterException {
1009         engineSetParameter(params);
1010     }
1011 
1012     /**
1013      * Returns the parameters used with this signature object.
1014      *
1015      * &lt;p&gt; If this signature has been initialized with parameters
1016      * (by calling {@link #setParameter(AlgorithmParameterSpec)} or
1017      * {@link #setParameter(String, Object)}) and the underlying signature
1018      * implementation supports returning the parameters as
1019      * {@code AlgorithmParameters}, this method returns the same parameters.
1020      * If the parameters were not set, this method may return a combination
1021      * of default and randomly generated parameter values if the
1022      * underlying signature implementation supports it and can successfully
1023      * generate them. Otherwise, {@code null} is returned.
1024      *
1025      * @return the parameters used with this signature, or {@code null}
1026      *
1027      * @see #setParameter(AlgorithmParameterSpec)
1028      * @since 1.4
1029      */
1030     public final AlgorithmParameters getParameters() {
1031         return engineGetParameters();
1032     }
1033 
1034     /**
1035      * Gets the value of the specified algorithm parameter. This method
1036      * supplies a general-purpose mechanism through which it is possible to
1037      * get the various parameters of this object. A parameter may be any
1038      * settable parameter for the algorithm, such as a parameter size, or
1039      * a source of random bits for signature generation (if appropriate),
1040      * or an indication of whether or not to perform a specific but optional
1041      * computation. A uniform algorithm-specific naming scheme for each
1042      * parameter is desirable but left unspecified at this time.
1043      *
1044      * @param param the string name of the parameter.
1045      *
1046      * @return the object that represents the parameter value, or {@code null} if
1047      * there is none.
1048      *
1049      * @throws    InvalidParameterException if {@code param} is an invalid
1050      * parameter for this engine, or another exception occurs while
1051      * trying to get this parameter.
1052      *
1053      * @see #setParameter(String, Object)
1054      *
1055      * @deprecated
1056      */
1057     @Deprecated
1058     public final Object getParameter(String param)
1059             throws InvalidParameterException {
1060         return engineGetParameter(param);
1061     }
1062 
1063     /**
1064      * Returns a clone if the implementation is cloneable.
1065      *
1066      * @return a clone if the implementation is cloneable.
1067      *
1068      * @throws    CloneNotSupportedException if this is called
1069      * on an implementation that does not support {@code Cloneable}.
1070      */
1071     public Object clone() throws CloneNotSupportedException {
1072         if (this instanceof Cloneable) {
1073             return super.clone();
1074         } else {
1075             throw new CloneNotSupportedException();
1076         }
1077     }
1078 
1079     /*
1080      * The following class allows providers to extend from SignatureSpi
1081      * rather than from Signature. It represents a Signature with an
1082      * encapsulated, provider-supplied SPI object (of type SignatureSpi).
1083      * If the provider implementation is an instance of SignatureSpi, the
1084      * getInstance() methods above return an instance of this class, with
1085      * the SPI object encapsulated.
1086      *
1087      * Note: All SPI methods from the original Signature class have been
1088      * moved up the hierarchy into a new class (SignatureSpi), which has
1089      * been interposed in the hierarchy between the API (Signature)
1090      * and its original parent (Object).
1091      */
1092 
1093     @SuppressWarnings(&quot;deprecation&quot;)
1094     private static class Delegate extends Signature {
<a name="4" id="anc4"></a>







1095 
1096         // The provider implementation (delegate)
1097         // filled in once the provider is selected
1098         private SignatureSpi sigSpi;
1099 
1100         // lock for mutex during provider selection
1101         private final Object lock;
1102 
1103         // next service to try in provider selection
1104         // null once provider is selected
1105         private Service firstService;
1106 
1107         // remaining services to try in provider selection
1108         // null once provider is selected
1109         private Iterator&lt;Service&gt; serviceIterator;
1110 
<a name="5" id="anc5"></a><span class="line-modified">1111         // constructor</span>
<span class="line-modified">1112         Delegate(SignatureSpi sigSpi, String algorithm) {</span>









1113             super(algorithm);
1114             this.sigSpi = sigSpi;
1115             this.lock = null; // no lock needed
1116         }
1117 
<a name="6" id="anc6"></a><span class="line-modified">1118         // used with delayed provider selection</span>
<span class="line-modified">1119         Delegate(Service service,</span>
1120                         Iterator&lt;Service&gt; iterator, String algorithm) {
1121             super(algorithm);
1122             this.firstService = service;
1123             this.serviceIterator = iterator;
1124             this.lock = new Object();
1125         }
1126 
1127         /**
1128          * Returns a clone if the delegate is cloneable.
1129          *
1130          * @return a clone if the delegate is cloneable.
1131          *
1132          * @throws    CloneNotSupportedException if this is called on a
1133          * delegate that does not support {@code Cloneable}.
1134          */
<a name="7" id="anc7"></a>
1135         public Object clone() throws CloneNotSupportedException {
1136             chooseFirstProvider();
1137             if (sigSpi instanceof Cloneable) {
<a name="8" id="anc8"></a><span class="line-removed">1138                 SignatureSpi sigSpiClone = (SignatureSpi)sigSpi.clone();</span>
1139                 // Because &#39;algorithm&#39; and &#39;provider&#39; are private
1140                 // members of our supertype, we must perform a cast to
1141                 // access them.
<a name="9" id="anc9"></a><span class="line-modified">1142                 Signature that =</span>
<span class="line-modified">1143                     new Delegate(sigSpiClone, ((Signature)this).algorithm);</span>

1144                 that.provider = ((Signature)this).provider;
1145                 return that;
1146             } else {
1147                 throw new CloneNotSupportedException();
1148             }
1149         }
1150 
1151         private static SignatureSpi newInstance(Service s)
1152                 throws NoSuchAlgorithmException {
1153             if (s.getType().equals(&quot;Cipher&quot;)) {
1154                 // must be NONEwithRSA
1155                 try {
1156                     Cipher c = Cipher.getInstance(RSA_CIPHER, s.getProvider());
1157                     return new CipherAdapter(c);
1158                 } catch (NoSuchPaddingException e) {
1159                     throw new NoSuchAlgorithmException(e);
1160                 }
1161             } else {
1162                 Object o = s.newInstance(null);
1163                 if (o instanceof SignatureSpi == false) {
1164                     throw new NoSuchAlgorithmException
1165                         (&quot;Not a SignatureSpi: &quot; + o.getClass().getName());
1166                 }
1167                 return (SignatureSpi)o;
1168             }
1169         }
1170 
1171         // max number of debug warnings to print from chooseFirstProvider()
1172         private static int warnCount = 10;
1173 
1174         /**
1175          * Choose the Spi from the first provider available. Used if
1176          * delayed provider selection is not possible because initSign()/
1177          * initVerify() is not the first method called.
1178          */
1179         void chooseFirstProvider() {
1180             if (sigSpi != null) {
1181                 return;
1182             }
1183             synchronized (lock) {
1184                 if (sigSpi != null) {
1185                     return;
1186                 }
1187                 if (debug != null) {
1188                     int w = --warnCount;
1189                     if (w &gt;= 0) {
1190                         debug.println(&quot;Signature.init() not first method &quot;
1191                             + &quot;called, disabling delayed provider selection&quot;);
1192                         if (w == 0) {
1193                             debug.println(&quot;Further warnings of this type will &quot;
1194                                 + &quot;be suppressed&quot;);
1195                         }
1196                         new Exception(&quot;Debug call trace&quot;).printStackTrace();
1197                     }
1198                 }
1199                 Exception lastException = null;
1200                 while ((firstService != null) || serviceIterator.hasNext()) {
1201                     Service s;
1202                     if (firstService != null) {
1203                         s = firstService;
1204                         firstService = null;
1205                     } else {
1206                         s = serviceIterator.next();
1207                     }
1208                     if (isSpi(s) == false) {
1209                         continue;
1210                     }
1211                     try {
1212                         sigSpi = newInstance(s);
1213                         provider = s.getProvider();
1214                         // not needed any more
1215                         firstService = null;
1216                         serviceIterator = null;
1217                         return;
1218                     } catch (NoSuchAlgorithmException e) {
1219                         lastException = e;
1220                     }
1221                 }
1222                 ProviderException e = new ProviderException
1223                         (&quot;Could not construct SignatureSpi instance&quot;);
1224                 if (lastException != null) {
1225                     e.initCause(lastException);
1226                 }
1227                 throw e;
1228             }
1229         }
1230 
1231         // Used by engineSetParameter/engineInitSign/engineInitVerify() to
1232         // find the right provider with the supplied key, parameters, random source
1233         private void chooseProvider(int type, Key key,
1234                 AlgorithmParameterSpec params, SecureRandom random)
1235                 throws InvalidKeyException, InvalidAlgorithmParameterException {
1236             synchronized (lock) {
1237                 if (sigSpi != null) {
1238                     return;
1239                 }
1240                 Exception lastException = null;
1241                 while ((firstService != null) || serviceIterator.hasNext()) {
1242                     Service s;
1243                     if (firstService != null) {
1244                         s = firstService;
1245                         firstService = null;
1246                     } else {
1247                         s = serviceIterator.next();
1248                     }
1249                     // if provider says it does not support this key, ignore it
1250                     if (key != null &amp;&amp; s.supportsParameter(key) == false) {
1251                         continue;
1252                     }
1253                     // if instance is not a SignatureSpi, ignore it
1254                     if (isSpi(s) == false) {
1255                         continue;
1256                     }
1257                     try {
1258                         SignatureSpi spi = newInstance(s);
1259                         tryOperation(spi, type, key, params, random);
1260                         provider = s.getProvider();
1261                         sigSpi = spi;
1262                         firstService = null;
1263                         serviceIterator = null;
1264                         return;
1265                     } catch (Exception e) {
1266                         // NoSuchAlgorithmException from newInstance()
1267                         // InvalidKeyException from init()
1268                         // RuntimeException (ProviderException) from init()
1269                         if (lastException == null) {
1270                             lastException = e;
1271                         }
1272                     }
1273                 }
1274                 // no working provider found, fail
1275                 if (lastException instanceof InvalidKeyException) {
1276                     throw (InvalidKeyException)lastException;
1277                 }
1278                 if (lastException instanceof RuntimeException) {
1279                     throw (RuntimeException)lastException;
1280                 }
1281                 if (lastException instanceof InvalidAlgorithmParameterException) {
1282                     throw (InvalidAlgorithmParameterException)lastException;
1283                 }
1284 
1285                 String k = (key != null) ? key.getClass().getName() : &quot;(null)&quot;;
1286                 throw new InvalidKeyException
1287                     (&quot;No installed provider supports this key: &quot;
1288                     + k, lastException);
1289             }
1290         }
1291 
1292         private static final int I_PUB           = 1;
1293         private static final int I_PRIV          = 2;
1294         private static final int I_PRIV_SR       = 3;
1295         private static final int I_PUB_PARAM     = 4;
1296         private static final int I_PRIV_PARAM_SR = 5;
1297         private static final int S_PARAM         = 6;
1298 
1299         private void tryOperation(SignatureSpi spi, int type, Key  key,
1300                 AlgorithmParameterSpec params, SecureRandom random)
1301                 throws InvalidKeyException, InvalidAlgorithmParameterException {
1302             switch (type) {
1303             case I_PUB:
1304                 spi.engineInitVerify((PublicKey)key);
1305                 break;
1306             case I_PUB_PARAM:
1307                 spi.engineInitVerify((PublicKey)key, params);
1308                 break;
1309             case I_PRIV:
1310                 spi.engineInitSign((PrivateKey)key);
1311                 break;
1312             case I_PRIV_SR:
1313                 spi.engineInitSign((PrivateKey)key, random);
1314                 break;
1315             case I_PRIV_PARAM_SR:
1316                 spi.engineInitSign((PrivateKey)key, params, random);
1317                 break;
1318             case S_PARAM:
1319                 spi.engineSetParameter(params);
1320                 break;
1321             default:
1322                 throw new AssertionError(&quot;Internal error: &quot; + type);
1323             }
1324         }
1325 
1326         protected void engineInitVerify(PublicKey publicKey)
1327                 throws InvalidKeyException {
1328             if (sigSpi != null) {
1329                 sigSpi.engineInitVerify(publicKey);
1330             } else {
1331                 try {
1332                     chooseProvider(I_PUB, publicKey, null, null);
1333                 } catch (InvalidAlgorithmParameterException iape) {
1334                     // should not happen, re-throw as IKE just in case
1335                     throw new InvalidKeyException(iape);
1336                 }
1337             }
1338         }
1339 
1340         void engineInitVerify(PublicKey publicKey,
1341                 AlgorithmParameterSpec params)
1342                 throws InvalidKeyException, InvalidAlgorithmParameterException {
1343             if (sigSpi != null) {
1344                 sigSpi.engineInitVerify(publicKey, params);
1345             } else {
1346                 chooseProvider(I_PUB_PARAM, publicKey, params, null);
1347             }
1348         }
1349 
1350         protected void engineInitSign(PrivateKey privateKey)
1351                 throws InvalidKeyException {
1352             if (sigSpi != null) {
1353                 sigSpi.engineInitSign(privateKey);
1354             } else {
1355                 try {
1356                     chooseProvider(I_PRIV, privateKey, null, null);
1357                 } catch (InvalidAlgorithmParameterException iape) {
1358                     // should not happen, re-throw as IKE just in case
1359                     throw new InvalidKeyException(iape);
1360                 }
1361             }
1362         }
1363 
1364         protected void engineInitSign(PrivateKey privateKey, SecureRandom sr)
1365                 throws InvalidKeyException {
1366             if (sigSpi != null) {
1367                 sigSpi.engineInitSign(privateKey, sr);
1368             } else {
1369                 try {
1370                     chooseProvider(I_PRIV_SR, privateKey, null, sr);
1371                 } catch (InvalidAlgorithmParameterException iape) {
1372                     // should not happen, re-throw as IKE just in case
1373                     throw new InvalidKeyException(iape);
1374                 }
1375             }
1376         }
1377 
1378         void engineInitSign(PrivateKey privateKey,
1379                 AlgorithmParameterSpec params, SecureRandom sr)
1380                 throws InvalidKeyException, InvalidAlgorithmParameterException {
1381             if (sigSpi != null) {
1382                 sigSpi.engineInitSign(privateKey, params, sr);
1383             } else {
1384                 chooseProvider(I_PRIV_PARAM_SR, privateKey, params, sr);
1385             }
1386         }
1387 
1388         protected void engineUpdate(byte b) throws SignatureException {
1389             chooseFirstProvider();
1390             sigSpi.engineUpdate(b);
1391         }
1392 
1393         protected void engineUpdate(byte[] b, int off, int len)
1394                 throws SignatureException {
1395             chooseFirstProvider();
1396             sigSpi.engineUpdate(b, off, len);
1397         }
1398 
1399         protected void engineUpdate(ByteBuffer data) {
1400             chooseFirstProvider();
1401             sigSpi.engineUpdate(data);
1402         }
1403 
1404         protected byte[] engineSign() throws SignatureException {
1405             chooseFirstProvider();
1406             return sigSpi.engineSign();
1407         }
1408 
1409         protected int engineSign(byte[] outbuf, int offset, int len)
1410                 throws SignatureException {
1411             chooseFirstProvider();
1412             return sigSpi.engineSign(outbuf, offset, len);
1413         }
1414 
1415         protected boolean engineVerify(byte[] sigBytes)
1416                 throws SignatureException {
1417             chooseFirstProvider();
1418             return sigSpi.engineVerify(sigBytes);
1419         }
1420 
1421         protected boolean engineVerify(byte[] sigBytes, int offset, int length)
1422                 throws SignatureException {
1423             chooseFirstProvider();
1424             return sigSpi.engineVerify(sigBytes, offset, length);
1425         }
1426 
1427         protected void engineSetParameter(String param, Object value)
1428                 throws InvalidParameterException {
1429             chooseFirstProvider();
1430             sigSpi.engineSetParameter(param, value);
1431         }
1432 
1433         protected void engineSetParameter(AlgorithmParameterSpec params)
1434                 throws InvalidAlgorithmParameterException {
1435             if (sigSpi != null) {
1436                 sigSpi.engineSetParameter(params);
1437             } else {
1438                 try {
1439                     chooseProvider(S_PARAM, null, params, null);
1440                 } catch (InvalidKeyException ike) {
1441                     // should never happen, rethrow just in case
1442                     throw new InvalidAlgorithmParameterException(ike);
1443                 }
1444             }
1445         }
1446 
1447         protected Object engineGetParameter(String param)
1448                 throws InvalidParameterException {
1449             chooseFirstProvider();
1450             return sigSpi.engineGetParameter(param);
1451         }
1452 
1453         protected AlgorithmParameters engineGetParameters() {
1454             chooseFirstProvider();
1455             return sigSpi.engineGetParameters();
1456         }
1457     }
1458 
1459     // adapter for RSA/ECB/PKCS1Padding ciphers
1460     @SuppressWarnings(&quot;deprecation&quot;)
1461     private static class CipherAdapter extends SignatureSpi {
1462 
1463         private final Cipher cipher;
1464 
1465         private ByteArrayOutputStream data;
1466 
1467         CipherAdapter(Cipher cipher) {
1468             this.cipher = cipher;
1469         }
1470 
1471         protected void engineInitVerify(PublicKey publicKey)
1472                 throws InvalidKeyException {
1473             cipher.init(Cipher.DECRYPT_MODE, publicKey);
1474             if (data == null) {
1475                 data = new ByteArrayOutputStream(128);
1476             } else {
1477                 data.reset();
1478             }
1479         }
1480 
1481         protected void engineInitSign(PrivateKey privateKey)
1482                 throws InvalidKeyException {
1483             cipher.init(Cipher.ENCRYPT_MODE, privateKey);
1484             data = null;
1485         }
1486 
1487         protected void engineInitSign(PrivateKey privateKey,
1488                 SecureRandom random) throws InvalidKeyException {
1489             cipher.init(Cipher.ENCRYPT_MODE, privateKey, random);
1490             data = null;
1491         }
1492 
1493         protected void engineUpdate(byte b) throws SignatureException {
1494             engineUpdate(new byte[] {b}, 0, 1);
1495         }
1496 
1497         protected void engineUpdate(byte[] b, int off, int len)
1498                 throws SignatureException {
1499             if (data != null) {
1500                 data.write(b, off, len);
1501                 return;
1502             }
1503             byte[] out = cipher.update(b, off, len);
1504             if ((out != null) &amp;&amp; (out.length != 0)) {
1505                 throw new SignatureException
1506                     (&quot;Cipher unexpectedly returned data&quot;);
1507             }
1508         }
1509 
1510         protected byte[] engineSign() throws SignatureException {
1511             try {
1512                 return cipher.doFinal();
1513             } catch (IllegalBlockSizeException e) {
1514                 throw new SignatureException(&quot;doFinal() failed&quot;, e);
1515             } catch (BadPaddingException e) {
1516                 throw new SignatureException(&quot;doFinal() failed&quot;, e);
1517             }
1518         }
1519 
1520         protected boolean engineVerify(byte[] sigBytes)
1521                 throws SignatureException {
1522             try {
1523                 byte[] out = cipher.doFinal(sigBytes);
1524                 byte[] dataBytes = data.toByteArray();
1525                 data.reset();
1526                 return MessageDigest.isEqual(out, dataBytes);
1527             } catch (BadPaddingException e) {
1528                 // e.g. wrong public key used
1529                 // return false rather than throwing exception
1530                 return false;
1531             } catch (IllegalBlockSizeException e) {
1532                 throw new SignatureException(&quot;doFinal() failed&quot;, e);
1533             }
1534         }
1535 
1536         protected void engineSetParameter(String param, Object value)
1537                 throws InvalidParameterException {
1538             throw new InvalidParameterException(&quot;Parameters not supported&quot;);
1539         }
1540 
1541         protected Object engineGetParameter(String param)
1542                 throws InvalidParameterException {
1543             throw new InvalidParameterException(&quot;Parameters not supported&quot;);
1544         }
1545 
1546     }
1547 
1548 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
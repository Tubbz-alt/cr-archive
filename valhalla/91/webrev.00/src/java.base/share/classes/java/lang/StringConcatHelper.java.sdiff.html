<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/StringConcatHelper.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Class.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../security/KeyStore.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/StringConcatHelper.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
389             return new String(buf, String.UTF16);
390         } else {
391             throw new InternalError(&quot;Storage is not completely initialized, &quot; + (int)indexCoder + &quot; bytes left&quot;);
392         }
393     }
394 
395     /**
396      * Perform a simple concatenation between two objects. Added for startup
397      * performance, but also demonstrates the code that would be emitted by
398      * {@code java.lang.invoke.StringConcatFactory$MethodHandleInlineCopyStrategy}
399      * for two Object arguments.
400      *
401      * @param first         first argument
402      * @param second        second argument
403      * @return String       resulting string
404      */
405     @ForceInline
406     static String simpleConcat(Object first, Object second) {
407         String s1 = stringOf(first);
408         String s2 = stringOf(second);








409         // start &quot;mixing&quot; in length and coder or arguments, order is not
410         // important
411         long indexCoder = mix(initialCoder(), s1);
412         indexCoder = mix(indexCoder, s2);
413         byte[] buf = newArray(indexCoder);
414         // prepend each argument in reverse order, since we prepending
415         // from the end of the byte array
416         indexCoder = prepend(indexCoder, buf, s2);
417         indexCoder = prepend(indexCoder, buf, s1);
418         return newString(buf, indexCoder);
419     }
420 
421     /**
422      * We need some additional conversion for Objects in general, because
423      * {@code String.valueOf(Object)} may return null. String conversion rules
424      * in Java state we need to produce &quot;null&quot; String in this case, so we
425      * provide a customized version that deals with this problematic corner case.
426      */
427     static String stringOf(Object value) {
428         String s;
</pre>
</td>
<td>
<hr />
<pre>
389             return new String(buf, String.UTF16);
390         } else {
391             throw new InternalError(&quot;Storage is not completely initialized, &quot; + (int)indexCoder + &quot; bytes left&quot;);
392         }
393     }
394 
395     /**
396      * Perform a simple concatenation between two objects. Added for startup
397      * performance, but also demonstrates the code that would be emitted by
398      * {@code java.lang.invoke.StringConcatFactory$MethodHandleInlineCopyStrategy}
399      * for two Object arguments.
400      *
401      * @param first         first argument
402      * @param second        second argument
403      * @return String       resulting string
404      */
405     @ForceInline
406     static String simpleConcat(Object first, Object second) {
407         String s1 = stringOf(first);
408         String s2 = stringOf(second);
<span class="line-added">409         if (s1.isEmpty()) {</span>
<span class="line-added">410             // newly created string required, see JLS 15.18.1</span>
<span class="line-added">411             return new String(s2);</span>
<span class="line-added">412         }</span>
<span class="line-added">413         if (s2.isEmpty()) {</span>
<span class="line-added">414             // newly created string required, see JLS 15.18.1</span>
<span class="line-added">415             return new String(s1);</span>
<span class="line-added">416         }</span>
417         // start &quot;mixing&quot; in length and coder or arguments, order is not
418         // important
419         long indexCoder = mix(initialCoder(), s1);
420         indexCoder = mix(indexCoder, s2);
421         byte[] buf = newArray(indexCoder);
422         // prepend each argument in reverse order, since we prepending
423         // from the end of the byte array
424         indexCoder = prepend(indexCoder, buf, s2);
425         indexCoder = prepend(indexCoder, buf, s1);
426         return newString(buf, indexCoder);
427     }
428 
429     /**
430      * We need some additional conversion for Objects in general, because
431      * {@code String.valueOf(Object)} may return null. String conversion rules
432      * in Java state we need to produce &quot;null&quot; String in this case, so we
433      * provide a customized version that deals with this problematic corner case.
434      */
435     static String stringOf(Object value) {
436         String s;
</pre>
</td>
</tr>
</table>
<center><a href="Class.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../security/KeyStore.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
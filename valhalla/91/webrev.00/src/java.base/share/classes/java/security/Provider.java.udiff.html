<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/security/Provider.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="MessageDigest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SecureRandom.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/Provider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -856,14 +856,22 @@</span>
      // legacy properties changed since last call to any services method?
      private transient boolean legacyChanged;
      // serviceMap changed since last call to getServices()
      private volatile transient boolean servicesChanged;
  
<span class="udiff-line-added">+     // Map&lt;String,String&gt; used to keep track of legacy registration</span>
<span class="udiff-line-added">+     private transient Map&lt;String,String&gt; legacyStrings;</span>
<span class="udiff-line-added">+ </span>
      // Map&lt;ServiceKey,Service&gt;
      // used for services added via putService(), initialized on demand
      private transient Map&lt;ServiceKey,Service&gt; serviceMap;
  
<span class="udiff-line-added">+     // For backward compatibility, the registration ordering of</span>
<span class="udiff-line-added">+     // SecureRandom (RNG) algorithms needs to be preserved for</span>
<span class="udiff-line-added">+     // &quot;new SecureRandom()&quot; calls when this provider is used</span>
<span class="udiff-line-added">+     private transient Set&lt;Service&gt; prngServices;</span>
<span class="udiff-line-added">+ </span>
      // Map&lt;ServiceKey,Service&gt;
      // used for services added via legacy methods, init on demand
      private transient Map&lt;ServiceKey,Service&gt; legacyMap;
  
      // Set&lt;Service&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -911,16 +919,22 @@</span>
          implClear();
          initialized = true;
          putAll(copy);
      }
  
<span class="udiff-line-modified-removed">-     private static boolean isProviderInfo(Object key) {</span>
<span class="udiff-line-modified-added">+     // check whether to update &#39;legacyString&#39; with the specified key</span>
<span class="udiff-line-added">+     private boolean checkLegacy(Object key) {</span>
          String keyString = (String)key;
          if (keyString.startsWith(&quot;Provider.&quot;)) {
<span class="udiff-line-modified-removed">-             return true;</span>
<span class="udiff-line-modified-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         legacyChanged = true;</span>
<span class="udiff-line-added">+         if (legacyStrings == null) {</span>
<span class="udiff-line-added">+             legacyStrings = new LinkedHashMap&lt;&gt;();</span>
          }
<span class="udiff-line-modified-removed">-         return false;</span>
<span class="udiff-line-modified-added">+         return true;</span>
      }
  
      /**
       * Copies all of the mappings from the specified Map to this provider.
       * Internal method to be called AFTER the security check has been
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -932,132 +946,152 @@</span>
          }
      }
  
      private Object implRemove(Object key) {
          if (key instanceof String) {
<span class="udiff-line-modified-removed">-             if (isProviderInfo(key)) {</span>
<span class="udiff-line-modified-added">+             if (!checkLegacy(key)) {</span>
                  return null;
              }
<span class="udiff-line-modified-removed">-             legacyChanged = true;</span>
<span class="udiff-line-modified-added">+             legacyStrings.remove((String)key);</span>
          }
          return super.remove(key);
      }
  
      private boolean implRemove(Object key, Object value) {
          if (key instanceof String &amp;&amp; value instanceof String) {
<span class="udiff-line-modified-removed">-             if (isProviderInfo(key)) {</span>
<span class="udiff-line-modified-added">+             if (!checkLegacy(key)) {</span>
                  return false;
              }
<span class="udiff-line-modified-removed">-             legacyChanged = true;</span>
<span class="udiff-line-modified-added">+             legacyStrings.remove((String)key, (String)value);</span>
          }
          return super.remove(key, value);
      }
  
      private boolean implReplace(Object key, Object oldValue, Object newValue) {
          if ((key instanceof String) &amp;&amp; (oldValue instanceof String) &amp;&amp;
                  (newValue instanceof String)) {
<span class="udiff-line-modified-removed">-             if (isProviderInfo(key)) {</span>
<span class="udiff-line-modified-added">+             if (!checkLegacy(key)) {</span>
                  return false;
              }
<span class="udiff-line-modified-removed">-             legacyChanged = true;</span>
<span class="udiff-line-modified-added">+             legacyStrings.replace((String)key, (String)oldValue,</span>
<span class="udiff-line-added">+                     (String)newValue);</span>
          }
          return super.replace(key, oldValue, newValue);
      }
  
      private Object implReplace(Object key, Object value) {
          if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="udiff-line-modified-removed">-             if (isProviderInfo(key)) {</span>
<span class="udiff-line-modified-added">+             if (!checkLegacy(key)) {</span>
                  return null;
              }
<span class="udiff-line-modified-removed">-             legacyChanged = true;</span>
<span class="udiff-line-modified-added">+             legacyStrings.replace((String)key, (String)value);</span>
          }
          return super.replace(key, value);
      }
  
      @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
      private void implReplaceAll(BiFunction&lt;? super Object, ? super Object,
              ? extends Object&gt; function) {
          legacyChanged = true;
<span class="udiff-line-added">+         if (legacyStrings == null) {</span>
<span class="udiff-line-added">+             legacyStrings = new LinkedHashMap&lt;&gt;();</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             legacyStrings.replaceAll((BiFunction&lt;? super String, ? super String,</span>
<span class="udiff-line-added">+                     ? extends String&gt;) function);</span>
<span class="udiff-line-added">+         }</span>
          super.replaceAll(function);
      }
  
      @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
<span class="udiff-line-modified-removed">-     private Object implMerge(Object key, Object value, BiFunction&lt;? super Object,</span>
<span class="udiff-line-modified-removed">-             ? super Object, ? extends Object&gt; remappingFunction) {</span>
<span class="udiff-line-modified-added">+     private Object implMerge(Object key, Object value,</span>
<span class="udiff-line-modified-added">+             BiFunction&lt;? super Object, ? super Object, ? extends Object&gt;</span>
<span class="udiff-line-added">+             remappingFunction) {</span>
          if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="udiff-line-modified-removed">-             if (isProviderInfo(key)) {</span>
<span class="udiff-line-modified-added">+             if (!checkLegacy(key)) {</span>
                  return null;
              }
<span class="udiff-line-modified-removed">-             legacyChanged = true;</span>
<span class="udiff-line-modified-added">+             legacyStrings.merge((String)key, (String)value,</span>
<span class="udiff-line-added">+                     (BiFunction&lt;? super String, ? super String,</span>
<span class="udiff-line-added">+                     ? extends String&gt;) remappingFunction);</span>
          }
          return super.merge(key, value, remappingFunction);
      }
  
      @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
      private Object implCompute(Object key, BiFunction&lt;? super Object,
              ? super Object, ? extends Object&gt; remappingFunction) {
          if (key instanceof String) {
<span class="udiff-line-modified-removed">-             if (isProviderInfo(key)) {</span>
<span class="udiff-line-modified-added">+             if (!checkLegacy(key)) {</span>
                  return null;
              }
<span class="udiff-line-modified-removed">-             legacyChanged = true;</span>
<span class="udiff-line-modified-added">+             legacyStrings.compute((String) key,</span>
<span class="udiff-line-added">+                     (BiFunction&lt;? super String,? super String,</span>
<span class="udiff-line-added">+                     ? extends String&gt;) remappingFunction);</span>
          }
          return super.compute(key, remappingFunction);
      }
  
      @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
      private Object implComputeIfAbsent(Object key, Function&lt;? super Object,
              ? extends Object&gt; mappingFunction) {
          if (key instanceof String) {
<span class="udiff-line-modified-removed">-             if (isProviderInfo(key)) {</span>
<span class="udiff-line-modified-added">+             if (!checkLegacy(key)) {</span>
                  return null;
              }
<span class="udiff-line-modified-removed">-             legacyChanged = true;</span>
<span class="udiff-line-modified-added">+             legacyStrings.computeIfAbsent((String) key,</span>
<span class="udiff-line-added">+                     (Function&lt;? super String, ? extends String&gt;)</span>
<span class="udiff-line-added">+                     mappingFunction);</span>
          }
          return super.computeIfAbsent(key, mappingFunction);
      }
  
      @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
      private Object implComputeIfPresent(Object key, BiFunction&lt;? super Object,
              ? super Object, ? extends Object&gt; remappingFunction) {
          if (key instanceof String) {
<span class="udiff-line-modified-removed">-             if (isProviderInfo(key)) {</span>
<span class="udiff-line-modified-added">+             if (!checkLegacy(key)) {</span>
                  return null;
              }
<span class="udiff-line-modified-removed">-             legacyChanged = true;</span>
<span class="udiff-line-modified-added">+             legacyStrings.computeIfPresent((String) key,</span>
<span class="udiff-line-added">+                     (BiFunction&lt;? super String, ? super String,</span>
<span class="udiff-line-added">+                     ? extends String&gt;) remappingFunction);</span>
          }
          return super.computeIfPresent(key, remappingFunction);
      }
  
      private Object implPut(Object key, Object value) {
          if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="udiff-line-modified-removed">-             if (isProviderInfo(key)) {</span>
<span class="udiff-line-modified-added">+             if (!checkLegacy(key)) {</span>
                  return null;
              }
<span class="udiff-line-modified-removed">-             legacyChanged = true;</span>
<span class="udiff-line-modified-added">+             legacyStrings.put((String)key, (String)value);</span>
          }
          return super.put(key, value);
      }
  
      private Object implPutIfAbsent(Object key, Object value) {
          if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="udiff-line-modified-removed">-             if (isProviderInfo(key)) {</span>
<span class="udiff-line-modified-added">+             if (!checkLegacy(key)) {</span>
                  return null;
              }
<span class="udiff-line-modified-removed">-             legacyChanged = true;</span>
<span class="udiff-line-modified-added">+             legacyStrings.putIfAbsent((String)key, (String)value);</span>
          }
          return super.putIfAbsent(key, value);
      }
  
      private void implClear() {
<span class="udiff-line-added">+         if (legacyStrings != null) {</span>
<span class="udiff-line-added">+             legacyStrings.clear();</span>
<span class="udiff-line-added">+         }</span>
          if (legacyMap != null) {
              legacyMap.clear();
          }
          serviceMap.clear();
          legacyChanged = false;
          servicesChanged = false;
          serviceSet = null;
<span class="udiff-line-added">+         prngServices = null;</span>
          super.clear();
          putId();
      }
  
      // used as key in the serviceMap and legacyMap HashMaps
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1093,20 +1127,20 @@</span>
      /**
       * Ensure all the legacy String properties are fully parsed into
       * service objects.
       */
      private void ensureLegacyParsed() {
<span class="udiff-line-modified-removed">-         if (legacyChanged == false) {</span>
<span class="udiff-line-modified-added">+         if (legacyChanged == false || (legacyStrings == null)) {</span>
              return;
          }
          serviceSet = null;
          if (legacyMap == null) {
              legacyMap = new ConcurrentHashMap&lt;&gt;();
          } else {
              legacyMap.clear();
          }
<span class="udiff-line-modified-removed">-         for (Map.Entry&lt;?,?&gt; entry : super.entrySet()) {</span>
<span class="udiff-line-modified-added">+         for (Map.Entry&lt;String,String&gt; entry : legacyStrings.entrySet()) {</span>
              parseLegacyPut(entry.getKey(), entry.getValue());
          }
          removeInvalidServices(legacyMap);
          legacyChanged = false;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1123,16 +1157,16 @@</span>
                  t.remove();
              }
          }
      }
  
<span class="udiff-line-modified-removed">-     private String[] getTypeAndAlgorithm(String key) {</span>
<span class="udiff-line-modified-added">+     private static String[] getTypeAndAlgorithm(String key) {</span>
          int i = key.indexOf(&#39;.&#39;);
          if (i &lt; 1) {
              if (debug != null) {
<span class="udiff-line-modified-removed">-                 debug.println(&quot;Ignoring invalid entry in provider &quot;</span>
<span class="udiff-line-modified-removed">-                         + name + &quot;:&quot; + key);</span>
<span class="udiff-line-modified-added">+                 debug.println(&quot;Ignoring invalid entry in provider: &quot;</span>
<span class="udiff-line-modified-added">+                         + key);</span>
              }
              return null;
          }
          String type = key.substring(0, i);
          String alg = key.substring(i + 1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1141,19 +1175,11 @@</span>
  
      private static final String ALIAS_PREFIX = &quot;Alg.Alias.&quot;;
      private static final String ALIAS_PREFIX_LOWER = &quot;alg.alias.&quot;;
      private static final int ALIAS_LENGTH = ALIAS_PREFIX.length();
  
<span class="udiff-line-modified-removed">-     private void parseLegacyPut(Object k, Object v) {</span>
<span class="udiff-line-removed">-         if (!(k instanceof String) || !(v instanceof String)) {</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         String name = (String) k;</span>
<span class="udiff-line-removed">-         String value = (String) v;</span>
<span class="udiff-line-removed">-         if (isProviderInfo(name)) {</span>
<span class="udiff-line-removed">-             return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+     private void parseLegacyPut(String name, String value) {</span>
          if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {
              // e.g. put(&quot;Alg.Alias.MessageDigest.SHA&quot;, &quot;SHA-1&quot;);
              // aliasKey ~ MessageDigest.SHA
              String stdAlg = value;
              String aliasKey = name.substring(ALIAS_LENGTH);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1191,10 +1217,14 @@</span>
                      s.type = type;
                      s.algorithm = stdAlg;
                      legacyMap.put(key, s);
                  }
                  s.className = className;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 if (type.equals(&quot;SecureRandom&quot;)) {</span>
<span class="udiff-line-added">+                     updateSecureRandomEntries(true, s);</span>
<span class="udiff-line-added">+                 }</span>
              } else { // attribute
                  // e.g. put(&quot;MessageDigest.SHA-1 ImplementedIn&quot;, &quot;Software&quot;);
                  String attributeValue = value;
                  String type = getEngineName(typeAndAlg[0]);
                  String attributeString = typeAndAlg[1];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1350,11 +1380,48 @@</span>
              serviceMap.put(new ServiceKey(type, alias, true), s);
          }
          servicesChanged = true;
          synchronized (this) {
              putPropertyStrings(s);
<span class="udiff-line-added">+             if (type.equals(&quot;SecureRandom&quot;)) {</span>
<span class="udiff-line-added">+                 updateSecureRandomEntries(true, s);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private void updateSecureRandomEntries(boolean doAdd, Service s) {</span>
<span class="udiff-line-added">+         Objects.requireNonNull(s);</span>
<span class="udiff-line-added">+         if (doAdd) {</span>
<span class="udiff-line-added">+             if (prngServices == null) {</span>
<span class="udiff-line-added">+                 prngServices = new LinkedHashSet&lt;Service&gt;();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             prngServices.add(s);</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             prngServices.remove(s);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (debug != null) {</span>
<span class="udiff-line-added">+             debug.println((doAdd? &quot;Add&quot;:&quot;Remove&quot;) + &quot; SecureRandom algo &quot; +</span>
<span class="udiff-line-added">+                 s.getAlgorithm());</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // used by new SecureRandom() to find out the default SecureRandom</span>
<span class="udiff-line-added">+     // service for this provider</span>
<span class="udiff-line-added">+     synchronized Service getDefaultSecureRandomService() {</span>
<span class="udiff-line-added">+         checkInitialized();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (legacyChanged) {</span>
<span class="udiff-line-added">+             prngServices = null;</span>
<span class="udiff-line-added">+             ensureLegacyParsed();</span>
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (prngServices != null &amp;&amp; !prngServices.isEmpty()) {</span>
<span class="udiff-line-added">+             return prngServices.iterator().next();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         return null;</span>
      }
  
      /**
       * Put the string properties for this Service in this Provider&#39;s
       * Hashtable.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1446,10 +1513,13 @@</span>
          for (String alias : s.getAliases()) {
              serviceMap.remove(new ServiceKey(type, alias, false));
          }
          synchronized (this) {
              removePropertyStrings(s);
<span class="udiff-line-added">+             if (type.equals(&quot;SecureRandom&quot;)) {</span>
<span class="udiff-line-added">+                 updateSecureRandomEntries(false, s);</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  
      // Wrapped String that behaves in a case insensitive way for equals/hashCode
      private static class UString {
</pre>
<center><a href="MessageDigest.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SecureRandom.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
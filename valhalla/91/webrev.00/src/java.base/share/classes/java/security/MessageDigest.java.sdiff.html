<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/MessageDigest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="KeyStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Provider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/MessageDigest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
114     private static final int INITIAL = 0;
115     private static final int IN_PROGRESS = 1;
116     private int state = INITIAL;
117 
118     // The provider
119     private Provider provider;
120 
121     /**
122      * Creates a message digest with the specified algorithm name.
123      *
124      * @param algorithm the standard name of the digest algorithm.
125      * See the MessageDigest section in the &lt;a href=
126      * &quot;{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;
127      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
128      * for information about standard algorithm names.
129      */
130     protected MessageDigest(String algorithm) {
131         this.algorithm = algorithm;
132     }
133 






134     /**
135      * Returns a MessageDigest object that implements the specified digest
136      * algorithm.
137      *
138      * &lt;p&gt; This method traverses the list of registered security Providers,
139      * starting with the most preferred Provider.
140      * A new MessageDigest object encapsulating the
141      * MessageDigestSpi implementation from the first
142      * Provider that supports the specified algorithm is returned.
143      *
144      * &lt;p&gt; Note that the list of registered providers may be retrieved via
145      * the {@link Security#getProviders() Security.getProviders()} method.
146      *
147      * @implNote
148      * The JDK Reference Implementation additionally uses the
149      * {@code jdk.security.provider.preferred}
150      * {@link Security#getProperty(String) Security} property to determine
151      * the preferred provider order for the specified algorithm. This
152      * may be different than the order of providers returned by
153      * {@link Security#getProviders() Security.getProviders()}.
</pre>
<hr />
<pre>
161      * @return a {@code MessageDigest} object that implements the
162      *         specified algorithm
163      *
164      * @throws NoSuchAlgorithmException if no {@code Provider} supports a
165      *         {@code MessageDigestSpi} implementation for the
166      *         specified algorithm
167      *
168      * @throws NullPointerException if {@code algorithm} is {@code null}
169      *
170      * @see Provider
171      */
172     public static MessageDigest getInstance(String algorithm)
173     throws NoSuchAlgorithmException {
174         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
175         try {
176             MessageDigest md;
177             Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;,
178                                              (String)null);
179             if (objs[0] instanceof MessageDigest) {
180                 md = (MessageDigest)objs[0];

181             } else {
<span class="line-modified">182                 md = new Delegate((MessageDigestSpi)objs[0], algorithm);</span>

183             }
<span class="line-removed">184             md.provider = (Provider)objs[1];</span>
185 
186             if (!skipDebug &amp;&amp; pdebug != null) {
187                 pdebug.println(&quot;MessageDigest.&quot; + algorithm +
188                     &quot; algorithm from: &quot; + md.provider.getName());
189             }
190 
191             return md;
192 
193         } catch(NoSuchProviderException e) {
194             throw new NoSuchAlgorithmException(algorithm + &quot; not found&quot;);
195         }
196     }
197 
198     /**
199      * Returns a MessageDigest object that implements the specified digest
200      * algorithm.
201      *
202      * &lt;p&gt; A new MessageDigest object encapsulating the
203      * MessageDigestSpi implementation from the specified provider
204      * is returned.  The specified provider must be registered
</pre>
<hr />
<pre>
228      * @throws NoSuchProviderException if the specified provider is not
229      *         registered in the security provider list
230      *
231      * @throws NullPointerException if {@code algorithm} is {@code null}
232      *
233      * @see Provider
234      */
235     public static MessageDigest getInstance(String algorithm, String provider)
236         throws NoSuchAlgorithmException, NoSuchProviderException
237     {
238         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
239         if (provider == null || provider.isEmpty())
240             throw new IllegalArgumentException(&quot;missing provider&quot;);
241         Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;, provider);
242         if (objs[0] instanceof MessageDigest) {
243             MessageDigest md = (MessageDigest)objs[0];
244             md.provider = (Provider)objs[1];
245             return md;
246         } else {
247             MessageDigest delegate =
<span class="line-modified">248                 new Delegate((MessageDigestSpi)objs[0], algorithm);</span>
<span class="line-modified">249             delegate.provider = (Provider)objs[1];</span>
250             return delegate;
251         }
252     }
253 
254     /**
255      * Returns a MessageDigest object that implements the specified digest
256      * algorithm.
257      *
258      * &lt;p&gt; A new MessageDigest object encapsulating the
259      * MessageDigestSpi implementation from the specified Provider
260      * object is returned.  Note that the specified Provider object
261      * does not have to be registered in the provider list.
262      *
263      * @param algorithm the name of the algorithm requested.
264      * See the MessageDigest section in the &lt;a href=
265      * &quot;{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;
266      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
267      * for information about standard algorithm names.
268      *
269      * @param provider the provider.
</pre>
<hr />
<pre>
281      * @throws NullPointerException if {@code algorithm} is {@code null}
282      *
283      * @see Provider
284      *
285      * @since 1.4
286      */
287     public static MessageDigest getInstance(String algorithm,
288                                             Provider provider)
289         throws NoSuchAlgorithmException
290     {
291         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
292         if (provider == null)
293             throw new IllegalArgumentException(&quot;missing provider&quot;);
294         Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;, provider);
295         if (objs[0] instanceof MessageDigest) {
296             MessageDigest md = (MessageDigest)objs[0];
297             md.provider = (Provider)objs[1];
298             return md;
299         } else {
300             MessageDigest delegate =
<span class="line-modified">301                 new Delegate((MessageDigestSpi)objs[0], algorithm);</span>
<span class="line-modified">302             delegate.provider = (Provider)objs[1];</span>
303             return delegate;
304         }
305     }
306 
307     /**
308      * Returns the provider of this message digest object.
309      *
310      * @return the provider of this message digest object
311      */
312     public final Provider getProvider() {
313         return this.provider;
314     }
315 
316     /**
317      * Updates the digest using the specified byte.
318      *
319      * @param input the byte with which to update the digest.
320      */
321     public void update(byte input) {
322         engineUpdate(input);
</pre>
<hr />
<pre>
530         return digestLen;
531     }
532 
533     /**
534      * Returns a clone if the implementation is cloneable.
535      *
536      * @return a clone if the implementation is cloneable.
537      *
538      * @throws    CloneNotSupportedException if this is called on an
539      * implementation that does not support {@code Cloneable}.
540      */
541     public Object clone() throws CloneNotSupportedException {
542         if (this instanceof Cloneable) {
543             return super.clone();
544         } else {
545             throw new CloneNotSupportedException();
546         }
547     }
548 
549 
<span class="line-removed">550 </span>
<span class="line-removed">551 </span>
552     /*
553      * The following class allows providers to extend from MessageDigestSpi
554      * rather than from MessageDigest. It represents a MessageDigest with an
555      * encapsulated, provider-supplied SPI object (of type MessageDigestSpi).
556      * If the provider implementation is an instance of MessageDigestSpi,
557      * the getInstance() methods above return an instance of this class, with
558      * the SPI object encapsulated.
559      *
560      * Note: All SPI methods from the original MessageDigest class have been
561      * moved up the hierarchy into a new class (MessageDigestSpi), which has
562      * been interposed in the hierarchy between the API (MessageDigest)
563      * and its original parent (Object).
564      */
565 
<span class="line-modified">566     static class Delegate extends MessageDigest implements MessageDigestSpi2 {</span>










567 
568         // The provider implementation (delegate)
<span class="line-modified">569         private MessageDigestSpi digestSpi;</span>




















570 
<span class="line-modified">571         // constructor</span>
<span class="line-modified">572         public Delegate(MessageDigestSpi digestSpi, String algorithm) {</span>
<span class="line-modified">573             super(algorithm);</span>

574             this.digestSpi = digestSpi;
575         }
576 
577         /**
578          * Returns a clone if the delegate is cloneable.
579          *
580          * @return a clone if the delegate is cloneable.
581          *
582          * @throws    CloneNotSupportedException if this is called on a
583          * delegate that does not support {@code Cloneable}.
584          */

585         public Object clone() throws CloneNotSupportedException {
<span class="line-modified">586             if (digestSpi instanceof Cloneable) {</span>
<span class="line-removed">587                 MessageDigestSpi digestSpiClone =</span>
<span class="line-removed">588                     (MessageDigestSpi)digestSpi.clone();</span>
589                 // Because &#39;algorithm&#39;, &#39;provider&#39;, and &#39;state&#39; are private
590                 // members of our supertype, we must perform a cast to
591                 // access them.
<span class="line-modified">592                 MessageDigest that =</span>
<span class="line-modified">593                     new Delegate(digestSpiClone,</span>
<span class="line-modified">594                                  ((MessageDigest)this).algorithm);</span>
<span class="line-modified">595                 that.provider = ((MessageDigest)this).provider;</span>
596                 that.state = ((MessageDigest)this).state;
597                 return that;
598             } else {
599                 throw new CloneNotSupportedException();
600             }
601         }
602 

603         protected int engineGetDigestLength() {
604             return digestSpi.engineGetDigestLength();
605         }
606 

607         protected void engineUpdate(byte input) {
608             digestSpi.engineUpdate(input);
609         }
610 

611         protected void engineUpdate(byte[] input, int offset, int len) {
612             digestSpi.engineUpdate(input, offset, len);
613         }
614 

615         protected void engineUpdate(ByteBuffer input) {
616             digestSpi.engineUpdate(input);
617         }
618 

619         public void engineUpdate(SecretKey key) throws InvalidKeyException {
620             if (digestSpi instanceof MessageDigestSpi2) {
621                 ((MessageDigestSpi2)digestSpi).engineUpdate(key);
622             } else {
623                 throw new UnsupportedOperationException
624                 (&quot;Digest does not support update of SecretKey object&quot;);
625             }
626         }


627         protected byte[] engineDigest() {
628             return digestSpi.engineDigest();
629         }
630 

631         protected int engineDigest(byte[] buf, int offset, int len)
632             throws DigestException {
633                 return digestSpi.engineDigest(buf, offset, len);
634         }
635 

636         protected void engineReset() {
637             digestSpi.engineReset();
638         }
639     }
640 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
114     private static final int INITIAL = 0;
115     private static final int IN_PROGRESS = 1;
116     private int state = INITIAL;
117 
118     // The provider
119     private Provider provider;
120 
121     /**
122      * Creates a message digest with the specified algorithm name.
123      *
124      * @param algorithm the standard name of the digest algorithm.
125      * See the MessageDigest section in the &lt;a href=
126      * &quot;{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;
127      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
128      * for information about standard algorithm names.
129      */
130     protected MessageDigest(String algorithm) {
131         this.algorithm = algorithm;
132     }
133 
<span class="line-added">134     // private constructor used only by Delegate class</span>
<span class="line-added">135     private MessageDigest(String algorithm, Provider p) {</span>
<span class="line-added">136         this.algorithm = algorithm;</span>
<span class="line-added">137         this.provider = p;</span>
<span class="line-added">138     }</span>
<span class="line-added">139 </span>
140     /**
141      * Returns a MessageDigest object that implements the specified digest
142      * algorithm.
143      *
144      * &lt;p&gt; This method traverses the list of registered security Providers,
145      * starting with the most preferred Provider.
146      * A new MessageDigest object encapsulating the
147      * MessageDigestSpi implementation from the first
148      * Provider that supports the specified algorithm is returned.
149      *
150      * &lt;p&gt; Note that the list of registered providers may be retrieved via
151      * the {@link Security#getProviders() Security.getProviders()} method.
152      *
153      * @implNote
154      * The JDK Reference Implementation additionally uses the
155      * {@code jdk.security.provider.preferred}
156      * {@link Security#getProperty(String) Security} property to determine
157      * the preferred provider order for the specified algorithm. This
158      * may be different than the order of providers returned by
159      * {@link Security#getProviders() Security.getProviders()}.
</pre>
<hr />
<pre>
167      * @return a {@code MessageDigest} object that implements the
168      *         specified algorithm
169      *
170      * @throws NoSuchAlgorithmException if no {@code Provider} supports a
171      *         {@code MessageDigestSpi} implementation for the
172      *         specified algorithm
173      *
174      * @throws NullPointerException if {@code algorithm} is {@code null}
175      *
176      * @see Provider
177      */
178     public static MessageDigest getInstance(String algorithm)
179     throws NoSuchAlgorithmException {
180         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
181         try {
182             MessageDigest md;
183             Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;,
184                                              (String)null);
185             if (objs[0] instanceof MessageDigest) {
186                 md = (MessageDigest)objs[0];
<span class="line-added">187                 md.provider = (Provider)objs[1];</span>
188             } else {
<span class="line-modified">189                 md = Delegate.of((MessageDigestSpi)objs[0], algorithm,</span>
<span class="line-added">190                     (Provider) objs[1]);</span>
191             }

192 
193             if (!skipDebug &amp;&amp; pdebug != null) {
194                 pdebug.println(&quot;MessageDigest.&quot; + algorithm +
195                     &quot; algorithm from: &quot; + md.provider.getName());
196             }
197 
198             return md;
199 
200         } catch(NoSuchProviderException e) {
201             throw new NoSuchAlgorithmException(algorithm + &quot; not found&quot;);
202         }
203     }
204 
205     /**
206      * Returns a MessageDigest object that implements the specified digest
207      * algorithm.
208      *
209      * &lt;p&gt; A new MessageDigest object encapsulating the
210      * MessageDigestSpi implementation from the specified provider
211      * is returned.  The specified provider must be registered
</pre>
<hr />
<pre>
235      * @throws NoSuchProviderException if the specified provider is not
236      *         registered in the security provider list
237      *
238      * @throws NullPointerException if {@code algorithm} is {@code null}
239      *
240      * @see Provider
241      */
242     public static MessageDigest getInstance(String algorithm, String provider)
243         throws NoSuchAlgorithmException, NoSuchProviderException
244     {
245         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
246         if (provider == null || provider.isEmpty())
247             throw new IllegalArgumentException(&quot;missing provider&quot;);
248         Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;, provider);
249         if (objs[0] instanceof MessageDigest) {
250             MessageDigest md = (MessageDigest)objs[0];
251             md.provider = (Provider)objs[1];
252             return md;
253         } else {
254             MessageDigest delegate =
<span class="line-modified">255                     Delegate.of((MessageDigestSpi)objs[0], algorithm,</span>
<span class="line-modified">256                     (Provider)objs[1]);</span>
257             return delegate;
258         }
259     }
260 
261     /**
262      * Returns a MessageDigest object that implements the specified digest
263      * algorithm.
264      *
265      * &lt;p&gt; A new MessageDigest object encapsulating the
266      * MessageDigestSpi implementation from the specified Provider
267      * object is returned.  Note that the specified Provider object
268      * does not have to be registered in the provider list.
269      *
270      * @param algorithm the name of the algorithm requested.
271      * See the MessageDigest section in the &lt;a href=
272      * &quot;{@docRoot}/../specs/security/standard-names.html#messagedigest-algorithms&quot;&gt;
273      * Java Security Standard Algorithm Names Specification&lt;/a&gt;
274      * for information about standard algorithm names.
275      *
276      * @param provider the provider.
</pre>
<hr />
<pre>
288      * @throws NullPointerException if {@code algorithm} is {@code null}
289      *
290      * @see Provider
291      *
292      * @since 1.4
293      */
294     public static MessageDigest getInstance(String algorithm,
295                                             Provider provider)
296         throws NoSuchAlgorithmException
297     {
298         Objects.requireNonNull(algorithm, &quot;null algorithm name&quot;);
299         if (provider == null)
300             throw new IllegalArgumentException(&quot;missing provider&quot;);
301         Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;, provider);
302         if (objs[0] instanceof MessageDigest) {
303             MessageDigest md = (MessageDigest)objs[0];
304             md.provider = (Provider)objs[1];
305             return md;
306         } else {
307             MessageDigest delegate =
<span class="line-modified">308                     Delegate.of((MessageDigestSpi)objs[0], algorithm,</span>
<span class="line-modified">309                     (Provider)objs[1]);</span>
310             return delegate;
311         }
312     }
313 
314     /**
315      * Returns the provider of this message digest object.
316      *
317      * @return the provider of this message digest object
318      */
319     public final Provider getProvider() {
320         return this.provider;
321     }
322 
323     /**
324      * Updates the digest using the specified byte.
325      *
326      * @param input the byte with which to update the digest.
327      */
328     public void update(byte input) {
329         engineUpdate(input);
</pre>
<hr />
<pre>
537         return digestLen;
538     }
539 
540     /**
541      * Returns a clone if the implementation is cloneable.
542      *
543      * @return a clone if the implementation is cloneable.
544      *
545      * @throws    CloneNotSupportedException if this is called on an
546      * implementation that does not support {@code Cloneable}.
547      */
548     public Object clone() throws CloneNotSupportedException {
549         if (this instanceof Cloneable) {
550             return super.clone();
551         } else {
552             throw new CloneNotSupportedException();
553         }
554     }
555 
556 


557     /*
558      * The following class allows providers to extend from MessageDigestSpi
559      * rather than from MessageDigest. It represents a MessageDigest with an
560      * encapsulated, provider-supplied SPI object (of type MessageDigestSpi).
561      * If the provider implementation is an instance of MessageDigestSpi,
562      * the getInstance() methods above return an instance of this class, with
563      * the SPI object encapsulated.
564      *
565      * Note: All SPI methods from the original MessageDigest class have been
566      * moved up the hierarchy into a new class (MessageDigestSpi), which has
567      * been interposed in the hierarchy between the API (MessageDigest)
568      * and its original parent (Object).
569      */
570 
<span class="line-modified">571     private static class Delegate extends MessageDigest</span>
<span class="line-added">572             implements MessageDigestSpi2 {</span>
<span class="line-added">573         // use this class for spi objects which implements Cloneable</span>
<span class="line-added">574         private static final class CloneableDelegate extends Delegate</span>
<span class="line-added">575                 implements Cloneable {</span>
<span class="line-added">576 </span>
<span class="line-added">577             private CloneableDelegate(MessageDigestSpi digestSpi,</span>
<span class="line-added">578                     String algorithm, Provider p) {</span>
<span class="line-added">579                 super(digestSpi, algorithm, p);</span>
<span class="line-added">580             }</span>
<span class="line-added">581         }</span>
582 
583         // The provider implementation (delegate)
<span class="line-modified">584         private final MessageDigestSpi digestSpi;</span>
<span class="line-added">585 </span>
<span class="line-added">586         // factory method used by MessageDigest class to create Delegate objs</span>
<span class="line-added">587         static Delegate of(MessageDigestSpi digestSpi, String algo,</span>
<span class="line-added">588                 Provider p) {</span>
<span class="line-added">589             Objects.requireNonNull(digestSpi);</span>
<span class="line-added">590             boolean isCloneable = (digestSpi instanceof Cloneable);</span>
<span class="line-added">591             // Spi impls from SunPKCS11 provider implement Cloneable but their</span>
<span class="line-added">592             // clone() may throw CloneNotSupportException</span>
<span class="line-added">593             if (isCloneable &amp;&amp; p.getName().startsWith(&quot;SunPKCS11&quot;) &amp;&amp;</span>
<span class="line-added">594                     p.getClass().getModule().getName().equals</span>
<span class="line-added">595                     (&quot;jdk.crypto.cryptoki&quot;)) {</span>
<span class="line-added">596                 try {</span>
<span class="line-added">597                     digestSpi.clone();</span>
<span class="line-added">598                 } catch (CloneNotSupportedException cnse) {</span>
<span class="line-added">599                     isCloneable = false;</span>
<span class="line-added">600                 }</span>
<span class="line-added">601             }</span>
<span class="line-added">602             return (isCloneable? new CloneableDelegate(digestSpi, algo, p) :</span>
<span class="line-added">603                     new Delegate(digestSpi, algo, p));</span>
<span class="line-added">604         }</span>
605 
<span class="line-modified">606         // private constructor</span>
<span class="line-modified">607         private Delegate(MessageDigestSpi digestSpi, String algorithm,</span>
<span class="line-modified">608                 Provider p) {</span>
<span class="line-added">609             super(algorithm, p);</span>
610             this.digestSpi = digestSpi;
611         }
612 
613         /**
614          * Returns a clone if the delegate is cloneable.
615          *
616          * @return a clone if the delegate is cloneable.
617          *
618          * @throws    CloneNotSupportedException if this is called on a
619          * delegate that does not support {@code Cloneable}.
620          */
<span class="line-added">621         @Override</span>
622         public Object clone() throws CloneNotSupportedException {
<span class="line-modified">623             if (this instanceof Cloneable) {</span>


624                 // Because &#39;algorithm&#39;, &#39;provider&#39;, and &#39;state&#39; are private
625                 // members of our supertype, we must perform a cast to
626                 // access them.
<span class="line-modified">627                 MessageDigest that = new CloneableDelegate(</span>
<span class="line-modified">628                         (MessageDigestSpi)digestSpi.clone(),</span>
<span class="line-modified">629                         ((MessageDigest)this).algorithm,</span>
<span class="line-modified">630                         ((MessageDigest)this).provider);</span>
631                 that.state = ((MessageDigest)this).state;
632                 return that;
633             } else {
634                 throw new CloneNotSupportedException();
635             }
636         }
637 
<span class="line-added">638         @Override</span>
639         protected int engineGetDigestLength() {
640             return digestSpi.engineGetDigestLength();
641         }
642 
<span class="line-added">643         @Override</span>
644         protected void engineUpdate(byte input) {
645             digestSpi.engineUpdate(input);
646         }
647 
<span class="line-added">648         @Override</span>
649         protected void engineUpdate(byte[] input, int offset, int len) {
650             digestSpi.engineUpdate(input, offset, len);
651         }
652 
<span class="line-added">653         @Override</span>
654         protected void engineUpdate(ByteBuffer input) {
655             digestSpi.engineUpdate(input);
656         }
657 
<span class="line-added">658         @Override</span>
659         public void engineUpdate(SecretKey key) throws InvalidKeyException {
660             if (digestSpi instanceof MessageDigestSpi2) {
661                 ((MessageDigestSpi2)digestSpi).engineUpdate(key);
662             } else {
663                 throw new UnsupportedOperationException
664                 (&quot;Digest does not support update of SecretKey object&quot;);
665             }
666         }
<span class="line-added">667 </span>
<span class="line-added">668         @Override</span>
669         protected byte[] engineDigest() {
670             return digestSpi.engineDigest();
671         }
672 
<span class="line-added">673         @Override</span>
674         protected int engineDigest(byte[] buf, int offset, int len)
675             throws DigestException {
676                 return digestSpi.engineDigest(buf, offset, len);
677         }
678 
<span class="line-added">679         @Override</span>
680         protected void engineReset() {
681             digestSpi.engineReset();
682         }
683     }
684 }
</pre>
</td>
</tr>
</table>
<center><a href="KeyStore.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Provider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
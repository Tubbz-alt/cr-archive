<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/security/MessageDigest.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="KeyStore.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Provider.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/MessageDigest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,10 ***</span>
<span class="line-new-header">--- 129,16 ---</span>
       */
      protected MessageDigest(String algorithm) {
          this.algorithm = algorithm;
      }
  
<span class="line-added">+     // private constructor used only by Delegate class</span>
<span class="line-added">+     private MessageDigest(String algorithm, Provider p) {</span>
<span class="line-added">+         this.algorithm = algorithm;</span>
<span class="line-added">+         this.provider = p;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns a MessageDigest object that implements the specified digest
       * algorithm.
       *
       * &lt;p&gt; This method traverses the list of registered security Providers,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,14 ***</span>
              MessageDigest md;
              Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;,
                                               (String)null);
              if (objs[0] instanceof MessageDigest) {
                  md = (MessageDigest)objs[0];
              } else {
<span class="line-modified">!                 md = new Delegate((MessageDigestSpi)objs[0], algorithm);</span>
              }
<span class="line-removed">-             md.provider = (Provider)objs[1];</span>
  
              if (!skipDebug &amp;&amp; pdebug != null) {
                  pdebug.println(&quot;MessageDigest.&quot; + algorithm +
                      &quot; algorithm from: &quot; + md.provider.getName());
              }
<span class="line-new-header">--- 182,15 ---</span>
              MessageDigest md;
              Object[] objs = Security.getImpl(algorithm, &quot;MessageDigest&quot;,
                                               (String)null);
              if (objs[0] instanceof MessageDigest) {
                  md = (MessageDigest)objs[0];
<span class="line-added">+                 md.provider = (Provider)objs[1];</span>
              } else {
<span class="line-modified">!                 md = Delegate.of((MessageDigestSpi)objs[0], algorithm,</span>
<span class="line-added">+                     (Provider) objs[1]);</span>
              }
  
              if (!skipDebug &amp;&amp; pdebug != null) {
                  pdebug.println(&quot;MessageDigest.&quot; + algorithm +
                      &quot; algorithm from: &quot; + md.provider.getName());
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 243,12 ***</span>
              MessageDigest md = (MessageDigest)objs[0];
              md.provider = (Provider)objs[1];
              return md;
          } else {
              MessageDigest delegate =
<span class="line-modified">!                 new Delegate((MessageDigestSpi)objs[0], algorithm);</span>
<span class="line-modified">!             delegate.provider = (Provider)objs[1];</span>
              return delegate;
          }
      }
  
      /**
<span class="line-new-header">--- 250,12 ---</span>
              MessageDigest md = (MessageDigest)objs[0];
              md.provider = (Provider)objs[1];
              return md;
          } else {
              MessageDigest delegate =
<span class="line-modified">!                     Delegate.of((MessageDigestSpi)objs[0], algorithm,</span>
<span class="line-modified">!                     (Provider)objs[1]);</span>
              return delegate;
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,12 ***</span>
              MessageDigest md = (MessageDigest)objs[0];
              md.provider = (Provider)objs[1];
              return md;
          } else {
              MessageDigest delegate =
<span class="line-modified">!                 new Delegate((MessageDigestSpi)objs[0], algorithm);</span>
<span class="line-modified">!             delegate.provider = (Provider)objs[1];</span>
              return delegate;
          }
      }
  
      /**
<span class="line-new-header">--- 303,12 ---</span>
              MessageDigest md = (MessageDigest)objs[0];
              md.provider = (Provider)objs[1];
              return md;
          } else {
              MessageDigest delegate =
<span class="line-modified">!                     Delegate.of((MessageDigestSpi)objs[0], algorithm,</span>
<span class="line-modified">!                     (Provider)objs[1]);</span>
              return delegate;
          }
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 545,12 ***</span>
              throw new CloneNotSupportedException();
          }
      }
  
  
<span class="line-removed">- </span>
<span class="line-removed">- </span>
      /*
       * The following class allows providers to extend from MessageDigestSpi
       * rather than from MessageDigest. It represents a MessageDigest with an
       * encapsulated, provider-supplied SPI object (of type MessageDigestSpi).
       * If the provider implementation is an instance of MessageDigestSpi,
<span class="line-new-header">--- 552,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 561,18 ***</span>
       * moved up the hierarchy into a new class (MessageDigestSpi), which has
       * been interposed in the hierarchy between the API (MessageDigest)
       * and its original parent (Object).
       */
  
<span class="line-modified">!     static class Delegate extends MessageDigest implements MessageDigestSpi2 {</span>
  
          // The provider implementation (delegate)
<span class="line-modified">!         private MessageDigestSpi digestSpi;</span>
  
<span class="line-modified">!         // constructor</span>
<span class="line-modified">!         public Delegate(MessageDigestSpi digestSpi, String algorithm) {</span>
<span class="line-modified">!             super(algorithm);</span>
              this.digestSpi = digestSpi;
          }
  
          /**
           * Returns a clone if the delegate is cloneable.
<span class="line-new-header">--- 566,49 ---</span>
       * moved up the hierarchy into a new class (MessageDigestSpi), which has
       * been interposed in the hierarchy between the API (MessageDigest)
       * and its original parent (Object).
       */
  
<span class="line-modified">!     private static class Delegate extends MessageDigest</span>
<span class="line-added">+             implements MessageDigestSpi2 {</span>
<span class="line-added">+         // use this class for spi objects which implements Cloneable</span>
<span class="line-added">+         private static final class CloneableDelegate extends Delegate</span>
<span class="line-added">+                 implements Cloneable {</span>
<span class="line-added">+ </span>
<span class="line-added">+             private CloneableDelegate(MessageDigestSpi digestSpi,</span>
<span class="line-added">+                     String algorithm, Provider p) {</span>
<span class="line-added">+                 super(digestSpi, algorithm, p);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
          // The provider implementation (delegate)
<span class="line-modified">!         private final MessageDigestSpi digestSpi;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // factory method used by MessageDigest class to create Delegate objs</span>
<span class="line-added">+         static Delegate of(MessageDigestSpi digestSpi, String algo,</span>
<span class="line-added">+                 Provider p) {</span>
<span class="line-added">+             Objects.requireNonNull(digestSpi);</span>
<span class="line-added">+             boolean isCloneable = (digestSpi instanceof Cloneable);</span>
<span class="line-added">+             // Spi impls from SunPKCS11 provider implement Cloneable but their</span>
<span class="line-added">+             // clone() may throw CloneNotSupportException</span>
<span class="line-added">+             if (isCloneable &amp;&amp; p.getName().startsWith(&quot;SunPKCS11&quot;) &amp;&amp;</span>
<span class="line-added">+                     p.getClass().getModule().getName().equals</span>
<span class="line-added">+                     (&quot;jdk.crypto.cryptoki&quot;)) {</span>
<span class="line-added">+                 try {</span>
<span class="line-added">+                     digestSpi.clone();</span>
<span class="line-added">+                 } catch (CloneNotSupportedException cnse) {</span>
<span class="line-added">+                     isCloneable = false;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             return (isCloneable? new CloneableDelegate(digestSpi, algo, p) :</span>
<span class="line-added">+                     new Delegate(digestSpi, algo, p));</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         // private constructor</span>
<span class="line-modified">!         private Delegate(MessageDigestSpi digestSpi, String algorithm,</span>
<span class="line-modified">!                 Provider p) {</span>
<span class="line-added">+             super(algorithm, p);</span>
              this.digestSpi = digestSpi;
          }
  
          /**
           * Returns a clone if the delegate is cloneable.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 580,61 ***</span>
           * @return a clone if the delegate is cloneable.
           *
           * @throws    CloneNotSupportedException if this is called on a
           * delegate that does not support {@code Cloneable}.
           */
          public Object clone() throws CloneNotSupportedException {
<span class="line-modified">!             if (digestSpi instanceof Cloneable) {</span>
<span class="line-removed">-                 MessageDigestSpi digestSpiClone =</span>
<span class="line-removed">-                     (MessageDigestSpi)digestSpi.clone();</span>
                  // Because &#39;algorithm&#39;, &#39;provider&#39;, and &#39;state&#39; are private
                  // members of our supertype, we must perform a cast to
                  // access them.
<span class="line-modified">!                 MessageDigest that =</span>
<span class="line-modified">!                     new Delegate(digestSpiClone,</span>
<span class="line-modified">!                                  ((MessageDigest)this).algorithm);</span>
<span class="line-modified">!                 that.provider = ((MessageDigest)this).provider;</span>
                  that.state = ((MessageDigest)this).state;
                  return that;
              } else {
                  throw new CloneNotSupportedException();
              }
          }
  
          protected int engineGetDigestLength() {
              return digestSpi.engineGetDigestLength();
          }
  
          protected void engineUpdate(byte input) {
              digestSpi.engineUpdate(input);
          }
  
          protected void engineUpdate(byte[] input, int offset, int len) {
              digestSpi.engineUpdate(input, offset, len);
          }
  
          protected void engineUpdate(ByteBuffer input) {
              digestSpi.engineUpdate(input);
          }
  
          public void engineUpdate(SecretKey key) throws InvalidKeyException {
              if (digestSpi instanceof MessageDigestSpi2) {
                  ((MessageDigestSpi2)digestSpi).engineUpdate(key);
              } else {
                  throw new UnsupportedOperationException
                  (&quot;Digest does not support update of SecretKey object&quot;);
              }
          }
          protected byte[] engineDigest() {
              return digestSpi.engineDigest();
          }
  
          protected int engineDigest(byte[] buf, int offset, int len)
              throws DigestException {
                  return digestSpi.engineDigest(buf, offset, len);
          }
  
          protected void engineReset() {
              digestSpi.engineReset();
          }
      }
  }
<span class="line-new-header">--- 616,69 ---</span>
           * @return a clone if the delegate is cloneable.
           *
           * @throws    CloneNotSupportedException if this is called on a
           * delegate that does not support {@code Cloneable}.
           */
<span class="line-added">+         @Override</span>
          public Object clone() throws CloneNotSupportedException {
<span class="line-modified">!             if (this instanceof Cloneable) {</span>
                  // Because &#39;algorithm&#39;, &#39;provider&#39;, and &#39;state&#39; are private
                  // members of our supertype, we must perform a cast to
                  // access them.
<span class="line-modified">!                 MessageDigest that = new CloneableDelegate(</span>
<span class="line-modified">!                         (MessageDigestSpi)digestSpi.clone(),</span>
<span class="line-modified">!                         ((MessageDigest)this).algorithm,</span>
<span class="line-modified">!                         ((MessageDigest)this).provider);</span>
                  that.state = ((MessageDigest)this).state;
                  return that;
              } else {
                  throw new CloneNotSupportedException();
              }
          }
  
<span class="line-added">+         @Override</span>
          protected int engineGetDigestLength() {
              return digestSpi.engineGetDigestLength();
          }
  
<span class="line-added">+         @Override</span>
          protected void engineUpdate(byte input) {
              digestSpi.engineUpdate(input);
          }
  
<span class="line-added">+         @Override</span>
          protected void engineUpdate(byte[] input, int offset, int len) {
              digestSpi.engineUpdate(input, offset, len);
          }
  
<span class="line-added">+         @Override</span>
          protected void engineUpdate(ByteBuffer input) {
              digestSpi.engineUpdate(input);
          }
  
<span class="line-added">+         @Override</span>
          public void engineUpdate(SecretKey key) throws InvalidKeyException {
              if (digestSpi instanceof MessageDigestSpi2) {
                  ((MessageDigestSpi2)digestSpi).engineUpdate(key);
              } else {
                  throw new UnsupportedOperationException
                  (&quot;Digest does not support update of SecretKey object&quot;);
              }
          }
<span class="line-added">+ </span>
<span class="line-added">+         @Override</span>
          protected byte[] engineDigest() {
              return digestSpi.engineDigest();
          }
  
<span class="line-added">+         @Override</span>
          protected int engineDigest(byte[] buf, int offset, int len)
              throws DigestException {
                  return digestSpi.engineDigest(buf, offset, len);
          }
  
<span class="line-added">+         @Override</span>
          protected void engineReset() {
              digestSpi.engineReset();
          }
      }
  }
</pre>
<center><a href="KeyStore.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Provider.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/security/Provider.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="MessageDigest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SecureRandom.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/security/Provider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 841 
 842     private void checkInitialized() {
 843         if (!initialized) {
 844             throw new IllegalStateException();
 845         }
 846     }
 847 
 848     private void check(String directive) {
 849         checkInitialized();
 850         SecurityManager security = System.getSecurityManager();
 851         if (security != null) {
 852             security.checkSecurityAccess(directive);
 853         }
 854     }
 855 
 856     // legacy properties changed since last call to any services method?
 857     private transient boolean legacyChanged;
 858     // serviceMap changed since last call to getServices()
 859     private volatile transient boolean servicesChanged;
 860 



 861     // Map&lt;ServiceKey,Service&gt;
 862     // used for services added via putService(), initialized on demand
 863     private transient Map&lt;ServiceKey,Service&gt; serviceMap;
 864 





 865     // Map&lt;ServiceKey,Service&gt;
 866     // used for services added via legacy methods, init on demand
 867     private transient Map&lt;ServiceKey,Service&gt; legacyMap;
 868 
 869     // Set&lt;Service&gt;
 870     // Unmodifiable set of all services. Initialized on demand.
 871     private transient Set&lt;Service&gt; serviceSet;
 872 
 873     // register the id attributes for this provider
 874     // this is to ensure that equals() and hashCode() do not incorrectly
 875     // report to different provider objects as the same
 876     private void putId() {
 877         // note: name and info may be null
 878         super.put(&quot;Provider.id name&quot;, String.valueOf(name));
 879         super.put(&quot;Provider.id version&quot;, String.valueOf(versionStr));
 880         super.put(&quot;Provider.id info&quot;, String.valueOf(info));
 881         super.put(&quot;Provider.id className&quot;, this.getClass().getName());
 882     }
 883 
 884    /**
</pre>
<hr />
<pre>
 896                 throws IOException, ClassNotFoundException {
 897         Map&lt;Object,Object&gt; copy = new HashMap&lt;&gt;();
 898         for (Map.Entry&lt;Object,Object&gt; entry : super.entrySet()) {
 899             copy.put(entry.getKey(), entry.getValue());
 900         }
 901         defaults = null;
 902         in.defaultReadObject();
 903         if (this.versionStr == null) {
 904             // set versionStr based on version when not found in serialized bytes
 905             this.versionStr = Double.toString(this.version);
 906         } else {
 907             // otherwise, set version based on versionStr
 908             this.version = parseVersionStr(this.versionStr);
 909         }
 910         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 911         implClear();
 912         initialized = true;
 913         putAll(copy);
 914     }
 915 
<span class="line-modified"> 916     private static boolean isProviderInfo(Object key) {</span>

 917         String keyString = (String)key;
 918         if (keyString.startsWith(&quot;Provider.&quot;)) {
<span class="line-modified"> 919             return true;</span>





 920         }
<span class="line-modified"> 921         return false;</span>
 922     }
 923 
 924     /**
 925      * Copies all of the mappings from the specified Map to this provider.
 926      * Internal method to be called AFTER the security check has been
 927      * performed.
 928      */
 929     private void implPutAll(Map&lt;?,?&gt; t) {
 930         for (Map.Entry&lt;?,?&gt; e : t.entrySet()) {
 931             implPut(e.getKey(), e.getValue());
 932         }
 933     }
 934 
 935     private Object implRemove(Object key) {
 936         if (key instanceof String) {
<span class="line-modified"> 937             if (isProviderInfo(key)) {</span>
 938                 return null;
 939             }
<span class="line-modified"> 940             legacyChanged = true;</span>
 941         }
 942         return super.remove(key);
 943     }
 944 
 945     private boolean implRemove(Object key, Object value) {
 946         if (key instanceof String &amp;&amp; value instanceof String) {
<span class="line-modified"> 947             if (isProviderInfo(key)) {</span>
 948                 return false;
 949             }
<span class="line-modified"> 950             legacyChanged = true;</span>
 951         }
 952         return super.remove(key, value);
 953     }
 954 
 955     private boolean implReplace(Object key, Object oldValue, Object newValue) {
 956         if ((key instanceof String) &amp;&amp; (oldValue instanceof String) &amp;&amp;
 957                 (newValue instanceof String)) {
<span class="line-modified"> 958             if (isProviderInfo(key)) {</span>
 959                 return false;
 960             }
<span class="line-modified"> 961             legacyChanged = true;</span>

 962         }
 963         return super.replace(key, oldValue, newValue);
 964     }
 965 
 966     private Object implReplace(Object key, Object value) {
 967         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="line-modified"> 968             if (isProviderInfo(key)) {</span>
 969                 return null;
 970             }
<span class="line-modified"> 971             legacyChanged = true;</span>
 972         }
 973         return super.replace(key, value);
 974     }
 975 
 976     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
 977     private void implReplaceAll(BiFunction&lt;? super Object, ? super Object,
 978             ? extends Object&gt; function) {
 979         legacyChanged = true;






 980         super.replaceAll(function);
 981     }
 982 
 983     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
<span class="line-modified"> 984     private Object implMerge(Object key, Object value, BiFunction&lt;? super Object,</span>
<span class="line-modified"> 985             ? super Object, ? extends Object&gt; remappingFunction) {</span>

 986         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="line-modified"> 987             if (isProviderInfo(key)) {</span>
 988                 return null;
 989             }
<span class="line-modified"> 990             legacyChanged = true;</span>


 991         }
 992         return super.merge(key, value, remappingFunction);
 993     }
 994 
 995     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
 996     private Object implCompute(Object key, BiFunction&lt;? super Object,
 997             ? super Object, ? extends Object&gt; remappingFunction) {
 998         if (key instanceof String) {
<span class="line-modified"> 999             if (isProviderInfo(key)) {</span>
1000                 return null;
1001             }
<span class="line-modified">1002             legacyChanged = true;</span>


1003         }
1004         return super.compute(key, remappingFunction);
1005     }
1006 
1007     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1008     private Object implComputeIfAbsent(Object key, Function&lt;? super Object,
1009             ? extends Object&gt; mappingFunction) {
1010         if (key instanceof String) {
<span class="line-modified">1011             if (isProviderInfo(key)) {</span>
1012                 return null;
1013             }
<span class="line-modified">1014             legacyChanged = true;</span>


1015         }
1016         return super.computeIfAbsent(key, mappingFunction);
1017     }
1018 
1019     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1020     private Object implComputeIfPresent(Object key, BiFunction&lt;? super Object,
1021             ? super Object, ? extends Object&gt; remappingFunction) {
1022         if (key instanceof String) {
<span class="line-modified">1023             if (isProviderInfo(key)) {</span>
1024                 return null;
1025             }
<span class="line-modified">1026             legacyChanged = true;</span>


1027         }
1028         return super.computeIfPresent(key, remappingFunction);
1029     }
1030 
1031     private Object implPut(Object key, Object value) {
1032         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="line-modified">1033             if (isProviderInfo(key)) {</span>
1034                 return null;
1035             }
<span class="line-modified">1036             legacyChanged = true;</span>
1037         }
1038         return super.put(key, value);
1039     }
1040 
1041     private Object implPutIfAbsent(Object key, Object value) {
1042         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="line-modified">1043             if (isProviderInfo(key)) {</span>
1044                 return null;
1045             }
<span class="line-modified">1046             legacyChanged = true;</span>
1047         }
1048         return super.putIfAbsent(key, value);
1049     }
1050 
1051     private void implClear() {



1052         if (legacyMap != null) {
1053             legacyMap.clear();
1054         }
1055         serviceMap.clear();
1056         legacyChanged = false;
1057         servicesChanged = false;
1058         serviceSet = null;

1059         super.clear();
1060         putId();
1061     }
1062 
1063     // used as key in the serviceMap and legacyMap HashMaps
1064     private static class ServiceKey {
1065         private final String type;
1066         private final String algorithm;
1067         private final String originalAlgorithm;
1068         private ServiceKey(String type, String algorithm, boolean intern) {
1069             this.type = type;
1070             this.originalAlgorithm = algorithm;
1071             algorithm = algorithm.toUpperCase(ENGLISH);
1072             this.algorithm = intern ? algorithm.intern() : algorithm;
1073         }
1074         public int hashCode() {
1075             return Objects.hash(type, algorithm);
1076         }
1077         public boolean equals(Object obj) {
1078             if (this == obj) {
1079                 return true;
1080             }
1081             if (!(obj instanceof ServiceKey)) {
1082                 return false;
1083             }
1084             ServiceKey other = (ServiceKey)obj;
1085             return this.type.equals(other.type)
1086                 &amp;&amp; this.algorithm.equals(other.algorithm);
1087         }
1088         boolean matches(String type, String algorithm) {
1089             return (this.type == type) &amp;&amp; (this.originalAlgorithm == algorithm);
1090         }
1091     }
1092 
1093     /**
1094      * Ensure all the legacy String properties are fully parsed into
1095      * service objects.
1096      */
1097     private void ensureLegacyParsed() {
<span class="line-modified">1098         if (legacyChanged == false) {</span>
1099             return;
1100         }
1101         serviceSet = null;
1102         if (legacyMap == null) {
1103             legacyMap = new ConcurrentHashMap&lt;&gt;();
1104         } else {
1105             legacyMap.clear();
1106         }
<span class="line-modified">1107         for (Map.Entry&lt;?,?&gt; entry : super.entrySet()) {</span>
1108             parseLegacyPut(entry.getKey(), entry.getValue());
1109         }
1110         removeInvalidServices(legacyMap);
1111         legacyChanged = false;
1112     }
1113 
1114     /**
1115      * Remove all invalid services from the Map. Invalid services can only
1116      * occur if the legacy properties are inconsistent or incomplete.
1117      */
1118     private void removeInvalidServices(Map&lt;ServiceKey,Service&gt; map) {
1119         for (Iterator&lt;Map.Entry&lt;ServiceKey, Service&gt;&gt; t =
1120                 map.entrySet().iterator(); t.hasNext(); ) {
1121             Service s = t.next().getValue();
1122             if (s.isValid() == false) {
1123                 t.remove();
1124             }
1125         }
1126     }
1127 
<span class="line-modified">1128     private String[] getTypeAndAlgorithm(String key) {</span>
1129         int i = key.indexOf(&#39;.&#39;);
1130         if (i &lt; 1) {
1131             if (debug != null) {
<span class="line-modified">1132                 debug.println(&quot;Ignoring invalid entry in provider &quot;</span>
<span class="line-modified">1133                         + name + &quot;:&quot; + key);</span>
1134             }
1135             return null;
1136         }
1137         String type = key.substring(0, i);
1138         String alg = key.substring(i + 1);
1139         return new String[] {type, alg};
1140     }
1141 
1142     private static final String ALIAS_PREFIX = &quot;Alg.Alias.&quot;;
1143     private static final String ALIAS_PREFIX_LOWER = &quot;alg.alias.&quot;;
1144     private static final int ALIAS_LENGTH = ALIAS_PREFIX.length();
1145 
<span class="line-modified">1146     private void parseLegacyPut(Object k, Object v) {</span>
<span class="line-removed">1147         if (!(k instanceof String) || !(v instanceof String)) {</span>
<span class="line-removed">1148             return;</span>
<span class="line-removed">1149         }</span>
<span class="line-removed">1150         String name = (String) k;</span>
<span class="line-removed">1151         String value = (String) v;</span>
<span class="line-removed">1152         if (isProviderInfo(name)) {</span>
<span class="line-removed">1153             return;</span>
<span class="line-removed">1154         }</span>
1155         if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {
1156             // e.g. put(&quot;Alg.Alias.MessageDigest.SHA&quot;, &quot;SHA-1&quot;);
1157             // aliasKey ~ MessageDigest.SHA
1158             String stdAlg = value;
1159             String aliasKey = name.substring(ALIAS_LENGTH);
1160             String[] typeAndAlg = getTypeAndAlgorithm(aliasKey);
1161             if (typeAndAlg == null) {
1162                 return;
1163             }
1164             String type = getEngineName(typeAndAlg[0]);
1165             String aliasAlg = typeAndAlg[1].intern();
1166             ServiceKey key = new ServiceKey(type, stdAlg, true);
1167             Service s = legacyMap.get(key);
1168             if (s == null) {
1169                 s = new Service(this);
1170                 s.type = type;
1171                 s.algorithm = stdAlg;
1172                 legacyMap.put(key, s);
1173             }
1174             legacyMap.put(new ServiceKey(type, aliasAlg, true), s);
</pre>
<hr />
<pre>
1176         } else {
1177             String[] typeAndAlg = getTypeAndAlgorithm(name);
1178             if (typeAndAlg == null) {
1179                 return;
1180             }
1181             int i = typeAndAlg[1].indexOf(&#39; &#39;);
1182             if (i == -1) {
1183                 // e.g. put(&quot;MessageDigest.SHA-1&quot;, &quot;sun.security.provider.SHA&quot;);
1184                 String type = getEngineName(typeAndAlg[0]);
1185                 String stdAlg = typeAndAlg[1].intern();
1186                 String className = value;
1187                 ServiceKey key = new ServiceKey(type, stdAlg, true);
1188                 Service s = legacyMap.get(key);
1189                 if (s == null) {
1190                     s = new Service(this);
1191                     s.type = type;
1192                     s.algorithm = stdAlg;
1193                     legacyMap.put(key, s);
1194                 }
1195                 s.className = className;




1196             } else { // attribute
1197                 // e.g. put(&quot;MessageDigest.SHA-1 ImplementedIn&quot;, &quot;Software&quot;);
1198                 String attributeValue = value;
1199                 String type = getEngineName(typeAndAlg[0]);
1200                 String attributeString = typeAndAlg[1];
1201                 String stdAlg = attributeString.substring(0, i).intern();
1202                 String attributeName = attributeString.substring(i + 1);
1203                 // kill additional spaces
1204                 while (attributeName.startsWith(&quot; &quot;)) {
1205                     attributeName = attributeName.substring(1);
1206                 }
1207                 attributeName = attributeName.intern();
1208                 ServiceKey key = new ServiceKey(type, stdAlg, true);
1209                 Service s = legacyMap.get(key);
1210                 if (s == null) {
1211                     s = new Service(this);
1212                     s.type = type;
1213                     s.algorithm = stdAlg;
1214                     legacyMap.put(key, s);
1215                 }
</pre>
<hr />
<pre>
1335             debug.println(name + &quot;.putService(): &quot; + s);
1336         }
1337         if (s == null) {
1338             throw new NullPointerException();
1339         }
1340         if (s.getProvider() != this) {
1341             throw new IllegalArgumentException
1342                     (&quot;service.getProvider() must match this Provider object&quot;);
1343         }
1344         String type = s.getType();
1345         String algorithm = s.getAlgorithm();
1346         ServiceKey key = new ServiceKey(type, algorithm, true);
1347         implRemoveService(serviceMap.get(key));
1348         serviceMap.put(key, s);
1349         for (String alias : s.getAliases()) {
1350             serviceMap.put(new ServiceKey(type, alias, true), s);
1351         }
1352         servicesChanged = true;
1353         synchronized (this) {
1354             putPropertyStrings(s);































1355         }






1356     }
1357 
1358     /**
1359      * Put the string properties for this Service in this Provider&#39;s
1360      * Hashtable.
1361      */
1362     private void putPropertyStrings(Service s) {
1363         String type = s.getType();
1364         String algorithm = s.getAlgorithm();
1365         // use super() to avoid permission check and other processing
1366         super.put(type + &quot;.&quot; + algorithm, s.getClassName());
1367         for (String alias : s.getAliases()) {
1368             super.put(ALIAS_PREFIX + type + &quot;.&quot; + alias, algorithm);
1369         }
1370         for (Map.Entry&lt;UString,String&gt; entry : s.attributes.entrySet()) {
1371             String key = type + &quot;.&quot; + algorithm + &quot; &quot; + entry.getKey();
1372             super.put(key, entry.getValue());
1373         }
1374     }
1375 
</pre>
<hr />
<pre>
1431     }
1432 
1433     private void implRemoveService(Service s) {
1434         if ((s == null) || serviceMap.isEmpty()) {
1435             return;
1436         }
1437         String type = s.getType();
1438         String algorithm = s.getAlgorithm();
1439         ServiceKey key = new ServiceKey(type, algorithm, false);
1440         Service oldService = serviceMap.get(key);
1441         if (s != oldService) {
1442             return;
1443         }
1444         servicesChanged = true;
1445         serviceMap.remove(key);
1446         for (String alias : s.getAliases()) {
1447             serviceMap.remove(new ServiceKey(type, alias, false));
1448         }
1449         synchronized (this) {
1450             removePropertyStrings(s);



1451         }
1452     }
1453 
1454     // Wrapped String that behaves in a case insensitive way for equals/hashCode
1455     private static class UString {
1456         final String string;
1457         final String lowerString;
1458 
1459         UString(String s) {
1460             this.string = s;
1461             this.lowerString = s.toLowerCase(ENGLISH);
1462         }
1463 
1464         public int hashCode() {
1465             return lowerString.hashCode();
1466         }
1467 
1468         public boolean equals(Object obj) {
1469             if (this == obj) {
1470                 return true;
</pre>
</td>
<td>
<hr />
<pre>
 841 
 842     private void checkInitialized() {
 843         if (!initialized) {
 844             throw new IllegalStateException();
 845         }
 846     }
 847 
 848     private void check(String directive) {
 849         checkInitialized();
 850         SecurityManager security = System.getSecurityManager();
 851         if (security != null) {
 852             security.checkSecurityAccess(directive);
 853         }
 854     }
 855 
 856     // legacy properties changed since last call to any services method?
 857     private transient boolean legacyChanged;
 858     // serviceMap changed since last call to getServices()
 859     private volatile transient boolean servicesChanged;
 860 
<span class="line-added"> 861     // Map&lt;String,String&gt; used to keep track of legacy registration</span>
<span class="line-added"> 862     private transient Map&lt;String,String&gt; legacyStrings;</span>
<span class="line-added"> 863 </span>
 864     // Map&lt;ServiceKey,Service&gt;
 865     // used for services added via putService(), initialized on demand
 866     private transient Map&lt;ServiceKey,Service&gt; serviceMap;
 867 
<span class="line-added"> 868     // For backward compatibility, the registration ordering of</span>
<span class="line-added"> 869     // SecureRandom (RNG) algorithms needs to be preserved for</span>
<span class="line-added"> 870     // &quot;new SecureRandom()&quot; calls when this provider is used</span>
<span class="line-added"> 871     private transient Set&lt;Service&gt; prngServices;</span>
<span class="line-added"> 872 </span>
 873     // Map&lt;ServiceKey,Service&gt;
 874     // used for services added via legacy methods, init on demand
 875     private transient Map&lt;ServiceKey,Service&gt; legacyMap;
 876 
 877     // Set&lt;Service&gt;
 878     // Unmodifiable set of all services. Initialized on demand.
 879     private transient Set&lt;Service&gt; serviceSet;
 880 
 881     // register the id attributes for this provider
 882     // this is to ensure that equals() and hashCode() do not incorrectly
 883     // report to different provider objects as the same
 884     private void putId() {
 885         // note: name and info may be null
 886         super.put(&quot;Provider.id name&quot;, String.valueOf(name));
 887         super.put(&quot;Provider.id version&quot;, String.valueOf(versionStr));
 888         super.put(&quot;Provider.id info&quot;, String.valueOf(info));
 889         super.put(&quot;Provider.id className&quot;, this.getClass().getName());
 890     }
 891 
 892    /**
</pre>
<hr />
<pre>
 904                 throws IOException, ClassNotFoundException {
 905         Map&lt;Object,Object&gt; copy = new HashMap&lt;&gt;();
 906         for (Map.Entry&lt;Object,Object&gt; entry : super.entrySet()) {
 907             copy.put(entry.getKey(), entry.getValue());
 908         }
 909         defaults = null;
 910         in.defaultReadObject();
 911         if (this.versionStr == null) {
 912             // set versionStr based on version when not found in serialized bytes
 913             this.versionStr = Double.toString(this.version);
 914         } else {
 915             // otherwise, set version based on versionStr
 916             this.version = parseVersionStr(this.versionStr);
 917         }
 918         this.serviceMap = new ConcurrentHashMap&lt;&gt;();
 919         implClear();
 920         initialized = true;
 921         putAll(copy);
 922     }
 923 
<span class="line-modified"> 924     // check whether to update &#39;legacyString&#39; with the specified key</span>
<span class="line-added"> 925     private boolean checkLegacy(Object key) {</span>
 926         String keyString = (String)key;
 927         if (keyString.startsWith(&quot;Provider.&quot;)) {
<span class="line-modified"> 928             return false;</span>
<span class="line-added"> 929         }</span>
<span class="line-added"> 930 </span>
<span class="line-added"> 931         legacyChanged = true;</span>
<span class="line-added"> 932         if (legacyStrings == null) {</span>
<span class="line-added"> 933             legacyStrings = new LinkedHashMap&lt;&gt;();</span>
 934         }
<span class="line-modified"> 935         return true;</span>
 936     }
 937 
 938     /**
 939      * Copies all of the mappings from the specified Map to this provider.
 940      * Internal method to be called AFTER the security check has been
 941      * performed.
 942      */
 943     private void implPutAll(Map&lt;?,?&gt; t) {
 944         for (Map.Entry&lt;?,?&gt; e : t.entrySet()) {
 945             implPut(e.getKey(), e.getValue());
 946         }
 947     }
 948 
 949     private Object implRemove(Object key) {
 950         if (key instanceof String) {
<span class="line-modified"> 951             if (!checkLegacy(key)) {</span>
 952                 return null;
 953             }
<span class="line-modified"> 954             legacyStrings.remove((String)key);</span>
 955         }
 956         return super.remove(key);
 957     }
 958 
 959     private boolean implRemove(Object key, Object value) {
 960         if (key instanceof String &amp;&amp; value instanceof String) {
<span class="line-modified"> 961             if (!checkLegacy(key)) {</span>
 962                 return false;
 963             }
<span class="line-modified"> 964             legacyStrings.remove((String)key, (String)value);</span>
 965         }
 966         return super.remove(key, value);
 967     }
 968 
 969     private boolean implReplace(Object key, Object oldValue, Object newValue) {
 970         if ((key instanceof String) &amp;&amp; (oldValue instanceof String) &amp;&amp;
 971                 (newValue instanceof String)) {
<span class="line-modified"> 972             if (!checkLegacy(key)) {</span>
 973                 return false;
 974             }
<span class="line-modified"> 975             legacyStrings.replace((String)key, (String)oldValue,</span>
<span class="line-added"> 976                     (String)newValue);</span>
 977         }
 978         return super.replace(key, oldValue, newValue);
 979     }
 980 
 981     private Object implReplace(Object key, Object value) {
 982         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="line-modified"> 983             if (!checkLegacy(key)) {</span>
 984                 return null;
 985             }
<span class="line-modified"> 986             legacyStrings.replace((String)key, (String)value);</span>
 987         }
 988         return super.replace(key, value);
 989     }
 990 
 991     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
 992     private void implReplaceAll(BiFunction&lt;? super Object, ? super Object,
 993             ? extends Object&gt; function) {
 994         legacyChanged = true;
<span class="line-added"> 995         if (legacyStrings == null) {</span>
<span class="line-added"> 996             legacyStrings = new LinkedHashMap&lt;&gt;();</span>
<span class="line-added"> 997         } else {</span>
<span class="line-added"> 998             legacyStrings.replaceAll((BiFunction&lt;? super String, ? super String,</span>
<span class="line-added"> 999                     ? extends String&gt;) function);</span>
<span class="line-added">1000         }</span>
1001         super.replaceAll(function);
1002     }
1003 
1004     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
<span class="line-modified">1005     private Object implMerge(Object key, Object value,</span>
<span class="line-modified">1006             BiFunction&lt;? super Object, ? super Object, ? extends Object&gt;</span>
<span class="line-added">1007             remappingFunction) {</span>
1008         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="line-modified">1009             if (!checkLegacy(key)) {</span>
1010                 return null;
1011             }
<span class="line-modified">1012             legacyStrings.merge((String)key, (String)value,</span>
<span class="line-added">1013                     (BiFunction&lt;? super String, ? super String,</span>
<span class="line-added">1014                     ? extends String&gt;) remappingFunction);</span>
1015         }
1016         return super.merge(key, value, remappingFunction);
1017     }
1018 
1019     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1020     private Object implCompute(Object key, BiFunction&lt;? super Object,
1021             ? super Object, ? extends Object&gt; remappingFunction) {
1022         if (key instanceof String) {
<span class="line-modified">1023             if (!checkLegacy(key)) {</span>
1024                 return null;
1025             }
<span class="line-modified">1026             legacyStrings.compute((String) key,</span>
<span class="line-added">1027                     (BiFunction&lt;? super String,? super String,</span>
<span class="line-added">1028                     ? extends String&gt;) remappingFunction);</span>
1029         }
1030         return super.compute(key, remappingFunction);
1031     }
1032 
1033     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1034     private Object implComputeIfAbsent(Object key, Function&lt;? super Object,
1035             ? extends Object&gt; mappingFunction) {
1036         if (key instanceof String) {
<span class="line-modified">1037             if (!checkLegacy(key)) {</span>
1038                 return null;
1039             }
<span class="line-modified">1040             legacyStrings.computeIfAbsent((String) key,</span>
<span class="line-added">1041                     (Function&lt;? super String, ? extends String&gt;)</span>
<span class="line-added">1042                     mappingFunction);</span>
1043         }
1044         return super.computeIfAbsent(key, mappingFunction);
1045     }
1046 
1047     @SuppressWarnings(&quot;unchecked&quot;) // Function must actually operate over strings
1048     private Object implComputeIfPresent(Object key, BiFunction&lt;? super Object,
1049             ? super Object, ? extends Object&gt; remappingFunction) {
1050         if (key instanceof String) {
<span class="line-modified">1051             if (!checkLegacy(key)) {</span>
1052                 return null;
1053             }
<span class="line-modified">1054             legacyStrings.computeIfPresent((String) key,</span>
<span class="line-added">1055                     (BiFunction&lt;? super String, ? super String,</span>
<span class="line-added">1056                     ? extends String&gt;) remappingFunction);</span>
1057         }
1058         return super.computeIfPresent(key, remappingFunction);
1059     }
1060 
1061     private Object implPut(Object key, Object value) {
1062         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="line-modified">1063             if (!checkLegacy(key)) {</span>
1064                 return null;
1065             }
<span class="line-modified">1066             legacyStrings.put((String)key, (String)value);</span>
1067         }
1068         return super.put(key, value);
1069     }
1070 
1071     private Object implPutIfAbsent(Object key, Object value) {
1072         if ((key instanceof String) &amp;&amp; (value instanceof String)) {
<span class="line-modified">1073             if (!checkLegacy(key)) {</span>
1074                 return null;
1075             }
<span class="line-modified">1076             legacyStrings.putIfAbsent((String)key, (String)value);</span>
1077         }
1078         return super.putIfAbsent(key, value);
1079     }
1080 
1081     private void implClear() {
<span class="line-added">1082         if (legacyStrings != null) {</span>
<span class="line-added">1083             legacyStrings.clear();</span>
<span class="line-added">1084         }</span>
1085         if (legacyMap != null) {
1086             legacyMap.clear();
1087         }
1088         serviceMap.clear();
1089         legacyChanged = false;
1090         servicesChanged = false;
1091         serviceSet = null;
<span class="line-added">1092         prngServices = null;</span>
1093         super.clear();
1094         putId();
1095     }
1096 
1097     // used as key in the serviceMap and legacyMap HashMaps
1098     private static class ServiceKey {
1099         private final String type;
1100         private final String algorithm;
1101         private final String originalAlgorithm;
1102         private ServiceKey(String type, String algorithm, boolean intern) {
1103             this.type = type;
1104             this.originalAlgorithm = algorithm;
1105             algorithm = algorithm.toUpperCase(ENGLISH);
1106             this.algorithm = intern ? algorithm.intern() : algorithm;
1107         }
1108         public int hashCode() {
1109             return Objects.hash(type, algorithm);
1110         }
1111         public boolean equals(Object obj) {
1112             if (this == obj) {
1113                 return true;
1114             }
1115             if (!(obj instanceof ServiceKey)) {
1116                 return false;
1117             }
1118             ServiceKey other = (ServiceKey)obj;
1119             return this.type.equals(other.type)
1120                 &amp;&amp; this.algorithm.equals(other.algorithm);
1121         }
1122         boolean matches(String type, String algorithm) {
1123             return (this.type == type) &amp;&amp; (this.originalAlgorithm == algorithm);
1124         }
1125     }
1126 
1127     /**
1128      * Ensure all the legacy String properties are fully parsed into
1129      * service objects.
1130      */
1131     private void ensureLegacyParsed() {
<span class="line-modified">1132         if (legacyChanged == false || (legacyStrings == null)) {</span>
1133             return;
1134         }
1135         serviceSet = null;
1136         if (legacyMap == null) {
1137             legacyMap = new ConcurrentHashMap&lt;&gt;();
1138         } else {
1139             legacyMap.clear();
1140         }
<span class="line-modified">1141         for (Map.Entry&lt;String,String&gt; entry : legacyStrings.entrySet()) {</span>
1142             parseLegacyPut(entry.getKey(), entry.getValue());
1143         }
1144         removeInvalidServices(legacyMap);
1145         legacyChanged = false;
1146     }
1147 
1148     /**
1149      * Remove all invalid services from the Map. Invalid services can only
1150      * occur if the legacy properties are inconsistent or incomplete.
1151      */
1152     private void removeInvalidServices(Map&lt;ServiceKey,Service&gt; map) {
1153         for (Iterator&lt;Map.Entry&lt;ServiceKey, Service&gt;&gt; t =
1154                 map.entrySet().iterator(); t.hasNext(); ) {
1155             Service s = t.next().getValue();
1156             if (s.isValid() == false) {
1157                 t.remove();
1158             }
1159         }
1160     }
1161 
<span class="line-modified">1162     private static String[] getTypeAndAlgorithm(String key) {</span>
1163         int i = key.indexOf(&#39;.&#39;);
1164         if (i &lt; 1) {
1165             if (debug != null) {
<span class="line-modified">1166                 debug.println(&quot;Ignoring invalid entry in provider: &quot;</span>
<span class="line-modified">1167                         + key);</span>
1168             }
1169             return null;
1170         }
1171         String type = key.substring(0, i);
1172         String alg = key.substring(i + 1);
1173         return new String[] {type, alg};
1174     }
1175 
1176     private static final String ALIAS_PREFIX = &quot;Alg.Alias.&quot;;
1177     private static final String ALIAS_PREFIX_LOWER = &quot;alg.alias.&quot;;
1178     private static final int ALIAS_LENGTH = ALIAS_PREFIX.length();
1179 
<span class="line-modified">1180     private void parseLegacyPut(String name, String value) {</span>








1181         if (name.toLowerCase(ENGLISH).startsWith(ALIAS_PREFIX_LOWER)) {
1182             // e.g. put(&quot;Alg.Alias.MessageDigest.SHA&quot;, &quot;SHA-1&quot;);
1183             // aliasKey ~ MessageDigest.SHA
1184             String stdAlg = value;
1185             String aliasKey = name.substring(ALIAS_LENGTH);
1186             String[] typeAndAlg = getTypeAndAlgorithm(aliasKey);
1187             if (typeAndAlg == null) {
1188                 return;
1189             }
1190             String type = getEngineName(typeAndAlg[0]);
1191             String aliasAlg = typeAndAlg[1].intern();
1192             ServiceKey key = new ServiceKey(type, stdAlg, true);
1193             Service s = legacyMap.get(key);
1194             if (s == null) {
1195                 s = new Service(this);
1196                 s.type = type;
1197                 s.algorithm = stdAlg;
1198                 legacyMap.put(key, s);
1199             }
1200             legacyMap.put(new ServiceKey(type, aliasAlg, true), s);
</pre>
<hr />
<pre>
1202         } else {
1203             String[] typeAndAlg = getTypeAndAlgorithm(name);
1204             if (typeAndAlg == null) {
1205                 return;
1206             }
1207             int i = typeAndAlg[1].indexOf(&#39; &#39;);
1208             if (i == -1) {
1209                 // e.g. put(&quot;MessageDigest.SHA-1&quot;, &quot;sun.security.provider.SHA&quot;);
1210                 String type = getEngineName(typeAndAlg[0]);
1211                 String stdAlg = typeAndAlg[1].intern();
1212                 String className = value;
1213                 ServiceKey key = new ServiceKey(type, stdAlg, true);
1214                 Service s = legacyMap.get(key);
1215                 if (s == null) {
1216                     s = new Service(this);
1217                     s.type = type;
1218                     s.algorithm = stdAlg;
1219                     legacyMap.put(key, s);
1220                 }
1221                 s.className = className;
<span class="line-added">1222 </span>
<span class="line-added">1223                 if (type.equals(&quot;SecureRandom&quot;)) {</span>
<span class="line-added">1224                     updateSecureRandomEntries(true, s);</span>
<span class="line-added">1225                 }</span>
1226             } else { // attribute
1227                 // e.g. put(&quot;MessageDigest.SHA-1 ImplementedIn&quot;, &quot;Software&quot;);
1228                 String attributeValue = value;
1229                 String type = getEngineName(typeAndAlg[0]);
1230                 String attributeString = typeAndAlg[1];
1231                 String stdAlg = attributeString.substring(0, i).intern();
1232                 String attributeName = attributeString.substring(i + 1);
1233                 // kill additional spaces
1234                 while (attributeName.startsWith(&quot; &quot;)) {
1235                     attributeName = attributeName.substring(1);
1236                 }
1237                 attributeName = attributeName.intern();
1238                 ServiceKey key = new ServiceKey(type, stdAlg, true);
1239                 Service s = legacyMap.get(key);
1240                 if (s == null) {
1241                     s = new Service(this);
1242                     s.type = type;
1243                     s.algorithm = stdAlg;
1244                     legacyMap.put(key, s);
1245                 }
</pre>
<hr />
<pre>
1365             debug.println(name + &quot;.putService(): &quot; + s);
1366         }
1367         if (s == null) {
1368             throw new NullPointerException();
1369         }
1370         if (s.getProvider() != this) {
1371             throw new IllegalArgumentException
1372                     (&quot;service.getProvider() must match this Provider object&quot;);
1373         }
1374         String type = s.getType();
1375         String algorithm = s.getAlgorithm();
1376         ServiceKey key = new ServiceKey(type, algorithm, true);
1377         implRemoveService(serviceMap.get(key));
1378         serviceMap.put(key, s);
1379         for (String alias : s.getAliases()) {
1380             serviceMap.put(new ServiceKey(type, alias, true), s);
1381         }
1382         servicesChanged = true;
1383         synchronized (this) {
1384             putPropertyStrings(s);
<span class="line-added">1385             if (type.equals(&quot;SecureRandom&quot;)) {</span>
<span class="line-added">1386                 updateSecureRandomEntries(true, s);</span>
<span class="line-added">1387             }</span>
<span class="line-added">1388         }</span>
<span class="line-added">1389     }</span>
<span class="line-added">1390 </span>
<span class="line-added">1391     private void updateSecureRandomEntries(boolean doAdd, Service s) {</span>
<span class="line-added">1392         Objects.requireNonNull(s);</span>
<span class="line-added">1393         if (doAdd) {</span>
<span class="line-added">1394             if (prngServices == null) {</span>
<span class="line-added">1395                 prngServices = new LinkedHashSet&lt;Service&gt;();</span>
<span class="line-added">1396             }</span>
<span class="line-added">1397             prngServices.add(s);</span>
<span class="line-added">1398         } else {</span>
<span class="line-added">1399             prngServices.remove(s);</span>
<span class="line-added">1400         }</span>
<span class="line-added">1401 </span>
<span class="line-added">1402         if (debug != null) {</span>
<span class="line-added">1403             debug.println((doAdd? &quot;Add&quot;:&quot;Remove&quot;) + &quot; SecureRandom algo &quot; +</span>
<span class="line-added">1404                 s.getAlgorithm());</span>
<span class="line-added">1405         }</span>
<span class="line-added">1406     }</span>
<span class="line-added">1407 </span>
<span class="line-added">1408     // used by new SecureRandom() to find out the default SecureRandom</span>
<span class="line-added">1409     // service for this provider</span>
<span class="line-added">1410     synchronized Service getDefaultSecureRandomService() {</span>
<span class="line-added">1411         checkInitialized();</span>
<span class="line-added">1412 </span>
<span class="line-added">1413         if (legacyChanged) {</span>
<span class="line-added">1414             prngServices = null;</span>
<span class="line-added">1415             ensureLegacyParsed();</span>
1416         }
<span class="line-added">1417 </span>
<span class="line-added">1418         if (prngServices != null &amp;&amp; !prngServices.isEmpty()) {</span>
<span class="line-added">1419             return prngServices.iterator().next();</span>
<span class="line-added">1420         }</span>
<span class="line-added">1421 </span>
<span class="line-added">1422         return null;</span>
1423     }
1424 
1425     /**
1426      * Put the string properties for this Service in this Provider&#39;s
1427      * Hashtable.
1428      */
1429     private void putPropertyStrings(Service s) {
1430         String type = s.getType();
1431         String algorithm = s.getAlgorithm();
1432         // use super() to avoid permission check and other processing
1433         super.put(type + &quot;.&quot; + algorithm, s.getClassName());
1434         for (String alias : s.getAliases()) {
1435             super.put(ALIAS_PREFIX + type + &quot;.&quot; + alias, algorithm);
1436         }
1437         for (Map.Entry&lt;UString,String&gt; entry : s.attributes.entrySet()) {
1438             String key = type + &quot;.&quot; + algorithm + &quot; &quot; + entry.getKey();
1439             super.put(key, entry.getValue());
1440         }
1441     }
1442 
</pre>
<hr />
<pre>
1498     }
1499 
1500     private void implRemoveService(Service s) {
1501         if ((s == null) || serviceMap.isEmpty()) {
1502             return;
1503         }
1504         String type = s.getType();
1505         String algorithm = s.getAlgorithm();
1506         ServiceKey key = new ServiceKey(type, algorithm, false);
1507         Service oldService = serviceMap.get(key);
1508         if (s != oldService) {
1509             return;
1510         }
1511         servicesChanged = true;
1512         serviceMap.remove(key);
1513         for (String alias : s.getAliases()) {
1514             serviceMap.remove(new ServiceKey(type, alias, false));
1515         }
1516         synchronized (this) {
1517             removePropertyStrings(s);
<span class="line-added">1518             if (type.equals(&quot;SecureRandom&quot;)) {</span>
<span class="line-added">1519                 updateSecureRandomEntries(false, s);</span>
<span class="line-added">1520             }</span>
1521         }
1522     }
1523 
1524     // Wrapped String that behaves in a case insensitive way for equals/hashCode
1525     private static class UString {
1526         final String string;
1527         final String lowerString;
1528 
1529         UString(String s) {
1530             this.string = s;
1531             this.lowerString = s.toLowerCase(ENGLISH);
1532         }
1533 
1534         public int hashCode() {
1535             return lowerString.hashCode();
1536         }
1537 
1538         public boolean equals(Object obj) {
1539             if (this == obj) {
1540                 return true;
</pre>
</td>
</tr>
</table>
<center><a href="MessageDigest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="SecureRandom.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/time/tck/java/time/TCKYear.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * This file is available under and governed by the GNU General Public
  26  * License version 2 only, as published by the Free Software Foundation.
  27  * However, the following notice accompanied the original version of this
  28  * file:
  29  *
  30  * Copyright (c) 2008-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  31  *
  32  * All rights reserved.
  33  *
  34  * Redistribution and use in source and binary forms, with or without
  35  * modification, are permitted provided that the following conditions are met:
  36  *
  37  *  * Redistributions of source code must retain the above copyright notice,
  38  *    this list of conditions and the following disclaimer.
  39  *
  40  *  * Redistributions in binary form must reproduce the above copyright notice,
  41  *    this list of conditions and the following disclaimer in the documentation
  42  *    and/or other materials provided with the distribution.
  43  *
  44  *  * Neither the name of JSR-310 nor the names of its contributors
  45  *    may be used to endorse or promote products derived from this software
  46  *    without specific prior written permission.
  47  *
  48  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  49  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  50  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  51  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  52  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  53  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  54  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  55  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  56  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  57  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  58  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  59  */
  60 package tck.java.time;
  61 
  62 import static java.time.temporal.ChronoField.ERA;
  63 import static java.time.temporal.ChronoField.YEAR;
  64 import static java.time.temporal.ChronoField.YEAR_OF_ERA;
  65 import static java.time.temporal.ChronoUnit.CENTURIES;
  66 import static java.time.temporal.ChronoUnit.DAYS;
  67 import static java.time.temporal.ChronoUnit.DECADES;
  68 import static java.time.temporal.ChronoUnit.MILLENNIA;
  69 import static java.time.temporal.ChronoUnit.MONTHS;
  70 import static java.time.temporal.ChronoUnit.YEARS;
  71 import static org.testng.Assert.assertEquals;
  72 import static org.testng.Assert.assertTrue;
  73 import static org.testng.Assert.fail;
  74 
  75 import java.io.ByteArrayOutputStream;
  76 import java.io.DataOutputStream;
  77 import java.time.Clock;
  78 import java.time.DateTimeException;
  79 import java.time.Duration;
  80 import java.time.Instant;
  81 import java.time.LocalDate;
  82 import java.time.LocalTime;
  83 import java.time.Month;
  84 import java.time.MonthDay;
  85 import java.time.OffsetDateTime;
  86 import java.time.Period;
  87 import java.time.Year;
  88 import java.time.YearMonth;
  89 import java.time.ZoneId;
  90 import java.time.ZoneOffset;
  91 import java.time.chrono.IsoChronology;
  92 import java.time.chrono.IsoEra;
  93 import java.time.format.DateTimeFormatter;
  94 import java.time.format.DateTimeParseException;
  95 import java.time.temporal.ChronoField;
  96 import java.time.temporal.ChronoUnit;
  97 import java.time.temporal.JulianFields;
  98 import java.time.temporal.Temporal;
  99 import java.time.temporal.TemporalAccessor;
 100 import java.time.temporal.TemporalAmount;
 101 import java.time.temporal.TemporalField;
 102 import java.time.temporal.TemporalQueries;
 103 import java.time.temporal.TemporalQuery;
 104 import java.time.temporal.TemporalUnit;
 105 import java.time.temporal.UnsupportedTemporalTypeException;
 106 import java.util.ArrayList;
 107 import java.util.Arrays;
 108 import java.util.List;
 109 
 110 import org.testng.annotations.BeforeMethod;
 111 import org.testng.annotations.DataProvider;
 112 import org.testng.annotations.Test;
 113 
 114 /**
 115  * Test Year.
 116  */
 117 @Test
 118 public class TCKYear extends AbstractDateTimeTest {
 119 
 120     private static final Year TEST_2008 = Year.of(2008);
 121 
 122     @BeforeMethod
 123     public void setUp() {
 124     }
 125 
 126     //-----------------------------------------------------------------------
 127     @Override
 128     protected List&lt;TemporalAccessor&gt; samples() {
 129         TemporalAccessor[] array = {TEST_2008, };
 130         return Arrays.asList(array);
 131     }
 132 
 133     @Override
 134     protected List&lt;TemporalField&gt; validFields() {
 135         TemporalField[] array = {
 136             YEAR_OF_ERA,
 137             YEAR,
 138             ERA,
 139         };
 140         return Arrays.asList(array);
 141     }
 142 
 143     @Override
 144     protected List&lt;TemporalField&gt; invalidFields() {
 145         List&lt;TemporalField&gt; list = new ArrayList&lt;&gt;(Arrays.&lt;TemporalField&gt;asList(ChronoField.values()));
 146         list.removeAll(validFields());
 147         list.add(JulianFields.JULIAN_DAY);
 148         list.add(JulianFields.MODIFIED_JULIAN_DAY);
 149         list.add(JulianFields.RATA_DIE);
 150         return list;
 151     }
 152 
 153     //-----------------------------------------------------------------------
 154     // now()
 155     //-----------------------------------------------------------------------
 156     @Test
 157     public void now() {
 158         Year expected = Year.now(Clock.systemDefaultZone());
 159         Year test = Year.now();
 160         for (int i = 0; i &lt; 100; i++) {
 161             if (expected.equals(test)) {
 162                 return;
 163             }
 164             expected = Year.now(Clock.systemDefaultZone());
 165             test = Year.now();
 166         }
 167         assertEquals(test, expected);
 168     }
 169 
 170     //-----------------------------------------------------------------------
 171     // now(ZoneId)
 172     //-----------------------------------------------------------------------
 173     @Test(expectedExceptions=NullPointerException.class)
 174     public void now_ZoneId_nullZoneId() {
 175         Year.now((ZoneId) null);
 176     }
 177 
 178     @Test
 179     public void now_ZoneId() {
 180         ZoneId zone = ZoneId.of(&quot;UTC+01:02:03&quot;);
 181         Year expected = Year.now(Clock.system(zone));
 182         Year test = Year.now(zone);
 183         for (int i = 0; i &lt; 100; i++) {
 184             if (expected.equals(test)) {
 185                 return;
 186             }
 187             expected = Year.now(Clock.system(zone));
 188             test = Year.now(zone);
 189         }
 190         assertEquals(test, expected);
 191     }
 192 
 193     //-----------------------------------------------------------------------
 194     // now(Clock)
 195     //-----------------------------------------------------------------------
 196     @Test
 197     public void now_Clock() {
 198         Instant instant = OffsetDateTime.of(LocalDate.of(2010, 12, 31), LocalTime.of(0, 0), ZoneOffset.UTC).toInstant();
 199         Clock clock = Clock.fixed(instant, ZoneOffset.UTC);
 200         Year test = Year.now(clock);
 201         assertEquals(test.getValue(), 2010);
 202     }
 203 
 204     @Test(expectedExceptions=NullPointerException.class)
 205     public void now_Clock_nullClock() {
 206         Year.now((Clock) null);
 207     }
 208 
 209     //-----------------------------------------------------------------------
 210     @Test
 211     public void test_factory_int_singleton() {
 212         for (int i = -4; i &lt;= 2104; i++) {
 213             Year test = Year.of(i);
 214             assertEquals(test.getValue(), i);
 215             assertEquals(Year.of(i), test);
 216         }
 217     }
 218 
 219     @Test(expectedExceptions=DateTimeException.class)
 220     public void test_factory_int_tooLow() {
 221         Year.of(Year.MIN_VALUE - 1);
 222     }
 223 
 224     @Test(expectedExceptions=DateTimeException.class)
 225     public void test_factory_int_tooHigh() {
 226         Year.of(Year.MAX_VALUE + 1);
 227     }
 228 
 229     //-----------------------------------------------------------------------
 230     @Test
 231     public void test_from_TemporalAccessor() {
 232         assertEquals(Year.from(LocalDate.of(2007, 7, 15)), Year.of(2007));
 233     }
 234 
 235     @Test(expectedExceptions=DateTimeException.class)
 236     public void test_from_TemporalAccessor_invalid_noDerive() {
 237         Year.from(LocalTime.of(12, 30));
 238     }
 239 
 240     @Test(expectedExceptions=NullPointerException.class)
 241     public void test_from_TemporalAccessor_null() {
 242         Year.from((TemporalAccessor) null);
 243     }
 244 
 245     //-----------------------------------------------------------------------
 246     // parse()
 247     //-----------------------------------------------------------------------
 248     @DataProvider(name=&quot;goodParseData&quot;)
 249     Object[][] provider_goodParseData() {
 250         return new Object[][] {
<a name="2" id="anc2"></a><span class="line-removed"> 251                 {&quot;0000&quot;, Year.of(0)},</span>
 252                 {&quot;9999&quot;, Year.of(9999)},
 253                 {&quot;2000&quot;, Year.of(2000)},
 254 
<a name="3" id="anc3"></a>






















 255                 {&quot;+12345678&quot;, Year.of(12345678)},
 256                 {&quot;+123456&quot;, Year.of(123456)},
 257                 {&quot;-1234&quot;, Year.of(-1234)},
 258                 {&quot;-12345678&quot;, Year.of(-12345678)},
 259 
 260                 {&quot;+&quot; + Year.MAX_VALUE, Year.of(Year.MAX_VALUE)},
 261                 {&quot;&quot; + Year.MIN_VALUE, Year.of(Year.MIN_VALUE)},
 262         };
 263     }
 264 
 265     @Test(dataProvider=&quot;goodParseData&quot;)
 266     public void factory_parse_success(String text, Year expected) {
 267         Year year = Year.parse(text);
 268         assertEquals(year, expected);
 269     }
 270 
 271     @DataProvider(name=&quot;badParseData&quot;)
 272     Object[][] provider_badParseData() {
 273         return new Object[][] {
 274                 {&quot;&quot;, 0},
<a name="4" id="anc4"></a><span class="line-removed"> 275                 {&quot;-00&quot;, 1},</span>
 276                 {&quot;--01-0&quot;, 1},
 277                 {&quot;A01&quot;, 0},
<a name="5" id="anc5"></a><span class="line-removed"> 278                 {&quot;200&quot;, 0},</span>
 279                 {&quot;2009/12&quot;, 4},
 280 
<a name="6" id="anc6"></a><span class="line-modified"> 281                 {&quot;-0000-10&quot;, 0},</span>
<span class="line-modified"> 282                 {&quot;-12345678901-10&quot;, 11},</span>
<span class="line-modified"> 283                 {&quot;+1-10&quot;, 1},</span>
<span class="line-modified"> 284                 {&quot;+12-10&quot;, 1},</span>
<span class="line-modified"> 285                 {&quot;+123-10&quot;, 1},</span>
<span class="line-modified"> 286                 {&quot;+1234-10&quot;, 0},</span>
<span class="line-modified"> 287                 {&quot;12345-10&quot;, 0},</span>
<span class="line-modified"> 288                 {&quot;+12345678901-10&quot;, 11},</span>
 289         };
 290     }
 291 
 292     @Test(dataProvider=&quot;badParseData&quot;, expectedExceptions=DateTimeParseException.class)
 293     public void factory_parse_fail(String text, int pos) {
 294         try {
 295             Year.parse(text);
 296             fail(String.format(&quot;Parse should have failed for %s at position %d&quot;, text, pos));
 297         } catch (DateTimeParseException ex) {
 298             assertEquals(ex.getParsedString(), text);
 299             assertEquals(ex.getErrorIndex(), pos);
 300             throw ex;
 301         }
 302     }
 303 
 304     @Test(expectedExceptions=NullPointerException.class)
 305     public void factory_parse_nullText() {
 306         Year.parse(null);
 307     }
 308 
 309     //-----------------------------------------------------------------------
 310     // parse(DateTimeFormatter)
 311     //-----------------------------------------------------------------------
 312     @Test
 313     public void factory_parse_formatter() {
 314         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;y&quot;);
 315         Year test = Year.parse(&quot;2010&quot;, f);
 316         assertEquals(test, Year.of(2010));
 317     }
 318 
 319     @Test(expectedExceptions=NullPointerException.class)
 320     public void factory_parse_formatter_nullText() {
 321         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;y&quot;);
 322         Year.parse((String) null, f);
 323     }
 324 
 325     @Test(expectedExceptions=NullPointerException.class)
 326     public void factory_parse_formatter_nullFormatter() {
 327         Year.parse(&quot;ANY&quot;, null);
 328     }
 329 
 330     //-----------------------------------------------------------------------
 331     // isSupported(TemporalField)
 332     //-----------------------------------------------------------------------
 333     @Test
 334     public void test_isSupported_TemporalField() {
 335         assertEquals(TEST_2008.isSupported((TemporalField) null), false);
 336         assertEquals(TEST_2008.isSupported(ChronoField.NANO_OF_SECOND), false);
 337         assertEquals(TEST_2008.isSupported(ChronoField.NANO_OF_DAY), false);
 338         assertEquals(TEST_2008.isSupported(ChronoField.MICRO_OF_SECOND), false);
 339         assertEquals(TEST_2008.isSupported(ChronoField.MICRO_OF_DAY), false);
 340         assertEquals(TEST_2008.isSupported(ChronoField.MILLI_OF_SECOND), false);
 341         assertEquals(TEST_2008.isSupported(ChronoField.MILLI_OF_DAY), false);
 342         assertEquals(TEST_2008.isSupported(ChronoField.SECOND_OF_MINUTE), false);
 343         assertEquals(TEST_2008.isSupported(ChronoField.SECOND_OF_DAY), false);
 344         assertEquals(TEST_2008.isSupported(ChronoField.MINUTE_OF_HOUR), false);
 345         assertEquals(TEST_2008.isSupported(ChronoField.MINUTE_OF_DAY), false);
 346         assertEquals(TEST_2008.isSupported(ChronoField.HOUR_OF_AMPM), false);
 347         assertEquals(TEST_2008.isSupported(ChronoField.CLOCK_HOUR_OF_AMPM), false);
 348         assertEquals(TEST_2008.isSupported(ChronoField.HOUR_OF_DAY), false);
 349         assertEquals(TEST_2008.isSupported(ChronoField.CLOCK_HOUR_OF_DAY), false);
 350         assertEquals(TEST_2008.isSupported(ChronoField.AMPM_OF_DAY), false);
 351         assertEquals(TEST_2008.isSupported(ChronoField.DAY_OF_WEEK), false);
 352         assertEquals(TEST_2008.isSupported(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH), false);
 353         assertEquals(TEST_2008.isSupported(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), false);
 354         assertEquals(TEST_2008.isSupported(ChronoField.DAY_OF_MONTH), false);
 355         assertEquals(TEST_2008.isSupported(ChronoField.DAY_OF_YEAR), false);
 356         assertEquals(TEST_2008.isSupported(ChronoField.EPOCH_DAY), false);
 357         assertEquals(TEST_2008.isSupported(ChronoField.ALIGNED_WEEK_OF_MONTH), false);
 358         assertEquals(TEST_2008.isSupported(ChronoField.ALIGNED_WEEK_OF_YEAR), false);
 359         assertEquals(TEST_2008.isSupported(ChronoField.MONTH_OF_YEAR), false);
 360         assertEquals(TEST_2008.isSupported(ChronoField.PROLEPTIC_MONTH), false);
 361         assertEquals(TEST_2008.isSupported(ChronoField.YEAR), true);
 362         assertEquals(TEST_2008.isSupported(ChronoField.YEAR_OF_ERA), true);
 363         assertEquals(TEST_2008.isSupported(ChronoField.ERA), true);
 364         assertEquals(TEST_2008.isSupported(ChronoField.INSTANT_SECONDS), false);
 365         assertEquals(TEST_2008.isSupported(ChronoField.OFFSET_SECONDS), false);
 366     }
 367 
 368     //-----------------------------------------------------------------------
 369     // isSupported(TemporalUnit)
 370     //-----------------------------------------------------------------------
 371     @Test
 372     public void test_isSupported_TemporalUnit() {
 373         assertEquals(TEST_2008.isSupported((TemporalUnit) null), false);
 374         assertEquals(TEST_2008.isSupported(ChronoUnit.NANOS), false);
 375         assertEquals(TEST_2008.isSupported(ChronoUnit.MICROS), false);
 376         assertEquals(TEST_2008.isSupported(ChronoUnit.MILLIS), false);
 377         assertEquals(TEST_2008.isSupported(ChronoUnit.SECONDS), false);
 378         assertEquals(TEST_2008.isSupported(ChronoUnit.MINUTES), false);
 379         assertEquals(TEST_2008.isSupported(ChronoUnit.HOURS), false);
 380         assertEquals(TEST_2008.isSupported(ChronoUnit.HALF_DAYS), false);
 381         assertEquals(TEST_2008.isSupported(ChronoUnit.DAYS), false);
 382         assertEquals(TEST_2008.isSupported(ChronoUnit.WEEKS), false);
 383         assertEquals(TEST_2008.isSupported(ChronoUnit.MONTHS), false);
 384         assertEquals(TEST_2008.isSupported(ChronoUnit.YEARS), true);
 385         assertEquals(TEST_2008.isSupported(ChronoUnit.DECADES), true);
 386         assertEquals(TEST_2008.isSupported(ChronoUnit.CENTURIES), true);
 387         assertEquals(TEST_2008.isSupported(ChronoUnit.MILLENNIA), true);
 388         assertEquals(TEST_2008.isSupported(ChronoUnit.ERAS), true);
 389         assertEquals(TEST_2008.isSupported(ChronoUnit.FOREVER), false);
 390     }
 391 
 392     //-----------------------------------------------------------------------
 393     // get(TemporalField)
 394     //-----------------------------------------------------------------------
 395     @Test
 396     public void test_get_TemporalField() {
 397         assertEquals(TEST_2008.get(ChronoField.YEAR), 2008);
 398         assertEquals(TEST_2008.get(ChronoField.YEAR_OF_ERA), 2008);
 399         assertEquals(TEST_2008.get(ChronoField.ERA), 1);
 400     }
 401 
 402     @Test
 403     public void test_getLong_TemporalField() {
 404         assertEquals(TEST_2008.getLong(ChronoField.YEAR), 2008);
 405         assertEquals(TEST_2008.getLong(ChronoField.YEAR_OF_ERA), 2008);
 406         assertEquals(TEST_2008.getLong(ChronoField.ERA), 1);
 407     }
 408 
 409     //-----------------------------------------------------------------------
 410     // query(TemporalQuery)
 411     //-----------------------------------------------------------------------
 412     @DataProvider(name=&quot;query&quot;)
 413     Object[][] data_query() {
 414         return new Object[][] {
 415                 {TEST_2008, TemporalQueries.chronology(), IsoChronology.INSTANCE},
 416                 {TEST_2008, TemporalQueries.zoneId(), null},
 417                 {TEST_2008, TemporalQueries.precision(), ChronoUnit.YEARS},
 418                 {TEST_2008, TemporalQueries.zone(), null},
 419                 {TEST_2008, TemporalQueries.offset(), null},
 420                 {TEST_2008, TemporalQueries.localDate(), null},
 421                 {TEST_2008, TemporalQueries.localTime(), null},
 422         };
 423     }
 424 
 425     @Test(dataProvider=&quot;query&quot;)
 426     public &lt;T&gt; void test_query(TemporalAccessor temporal, TemporalQuery&lt;T&gt; query, T expected) {
 427         assertEquals(temporal.query(query), expected);
 428     }
 429 
 430     @Test(dataProvider=&quot;query&quot;)
 431     public &lt;T&gt; void test_queryFrom(TemporalAccessor temporal, TemporalQuery&lt;T&gt; query, T expected) {
 432         assertEquals(query.queryFrom(temporal), expected);
 433     }
 434 
 435     @Test(expectedExceptions=NullPointerException.class)
 436     public void test_query_null() {
 437         TEST_2008.query(null);
 438     }
 439 
 440     //-----------------------------------------------------------------------
 441     // isLeap()
 442     //-----------------------------------------------------------------------
 443     @Test
 444     public void test_isLeap() {
 445         assertEquals(Year.of(1999).isLeap(), false);
 446         assertEquals(Year.of(2000).isLeap(), true);
 447         assertEquals(Year.of(2001).isLeap(), false);
 448 
 449         assertEquals(Year.of(2007).isLeap(), false);
 450         assertEquals(Year.of(2008).isLeap(), true);
 451         assertEquals(Year.of(2009).isLeap(), false);
 452         assertEquals(Year.of(2010).isLeap(), false);
 453         assertEquals(Year.of(2011).isLeap(), false);
 454         assertEquals(Year.of(2012).isLeap(), true);
 455 
 456         assertEquals(Year.of(2095).isLeap(), false);
 457         assertEquals(Year.of(2096).isLeap(), true);
 458         assertEquals(Year.of(2097).isLeap(), false);
 459         assertEquals(Year.of(2098).isLeap(), false);
 460         assertEquals(Year.of(2099).isLeap(), false);
 461         assertEquals(Year.of(2100).isLeap(), false);
 462         assertEquals(Year.of(2101).isLeap(), false);
 463         assertEquals(Year.of(2102).isLeap(), false);
 464         assertEquals(Year.of(2103).isLeap(), false);
 465         assertEquals(Year.of(2104).isLeap(), true);
 466         assertEquals(Year.of(2105).isLeap(), false);
 467 
 468         assertEquals(Year.of(-500).isLeap(), false);
 469         assertEquals(Year.of(-400).isLeap(), true);
 470         assertEquals(Year.of(-300).isLeap(), false);
 471         assertEquals(Year.of(-200).isLeap(), false);
 472         assertEquals(Year.of(-100).isLeap(), false);
 473         assertEquals(Year.of(0).isLeap(), true);
 474         assertEquals(Year.of(100).isLeap(), false);
 475         assertEquals(Year.of(200).isLeap(), false);
 476         assertEquals(Year.of(300).isLeap(), false);
 477         assertEquals(Year.of(400).isLeap(), true);
 478         assertEquals(Year.of(500).isLeap(), false);
 479     }
 480 
 481     //-----------------------------------------------------------------------
 482     // plus(Period)
 483     //-----------------------------------------------------------------------
 484     @DataProvider(name=&quot;plusValid&quot;)
 485     Object[][] data_plusValid() {
 486         return new Object[][] {
 487                 {2012, Period.ofYears(0), 2012},
 488                 {2012, Period.ofYears(1), 2013},
 489                 {2012, Period.ofYears(2), 2014},
 490                 {2012, Period.ofYears(-2), 2010},
 491         };
 492     }
 493 
 494     @Test(dataProvider=&quot;plusValid&quot;)
 495     public void test_plusValid(int year, TemporalAmount amount, int expected) {
 496         assertEquals(Year.of(year).plus(amount), Year.of(expected));
 497     }
 498 
 499     @DataProvider(name=&quot;plusInvalidUnit&quot;)
 500     Object[][] data_plusInvalidUnit() {
 501         return new Object[][] {
 502                 {Period.of(0, 1, 0)},
 503                 {Period.of(0, 0, 1)},
 504                 {Period.of(0, 1, 1)},
 505                 {Period.of(1, 1, 1)},
 506                 {Duration.ofDays(1)},
 507                 {Duration.ofHours(1)},
 508                 {Duration.ofMinutes(1)},
 509                 {Duration.ofSeconds(1)},
 510         };
 511     }
 512 
 513     @Test(dataProvider=&quot;plusInvalidUnit&quot;, expectedExceptions=UnsupportedTemporalTypeException.class)
 514     public void test_plusInvalidUnit(TemporalAmount amount) {
 515         TEST_2008.plus(amount);
 516     }
 517 
 518     @Test(expectedExceptions=NullPointerException.class)
 519     public void test_plus_null() {
 520         TEST_2008.plus(null);
 521     }
 522 
 523     //-----------------------------------------------------------------------
 524     // plusYears()
 525     //-----------------------------------------------------------------------
 526     @Test
 527     public void test_plusYears() {
 528         assertEquals(Year.of(2007).plusYears(-1), Year.of(2006));
 529         assertEquals(Year.of(2007).plusYears(0), Year.of(2007));
 530         assertEquals(Year.of(2007).plusYears(1), Year.of(2008));
 531         assertEquals(Year.of(2007).plusYears(2), Year.of(2009));
 532 
 533         assertEquals(Year.of(Year.MAX_VALUE - 1).plusYears(1), Year.of(Year.MAX_VALUE));
 534         assertEquals(Year.of(Year.MAX_VALUE).plusYears(0), Year.of(Year.MAX_VALUE));
 535 
 536         assertEquals(Year.of(Year.MIN_VALUE + 1).plusYears(-1), Year.of(Year.MIN_VALUE));
 537         assertEquals(Year.of(Year.MIN_VALUE).plusYears(0), Year.of(Year.MIN_VALUE));
 538     }
 539 
 540     @Test
 541     public void test_plusYear_zero_equals() {
 542         Year base = Year.of(2007);
 543         assertEquals(base.plusYears(0), base);
 544     }
 545 
 546     @Test
 547     public void test_plusYears_big() {
 548         long years = 20L + Year.MAX_VALUE;
 549         assertEquals(Year.of(-40).plusYears(years), Year.of((int) (-40L + years)));
 550     }
 551 
 552     @Test(expectedExceptions=DateTimeException.class)
 553     public void test_plusYears_max() {
 554         Year.of(Year.MAX_VALUE).plusYears(1);
 555     }
 556 
 557     @Test(expectedExceptions=DateTimeException.class)
 558     public void test_plusYears_maxLots() {
 559         Year.of(Year.MAX_VALUE).plusYears(1000);
 560     }
 561 
 562     @Test(expectedExceptions=DateTimeException.class)
 563     public void test_plusYears_min() {
 564         Year.of(Year.MIN_VALUE).plusYears(-1);
 565     }
 566 
 567     @Test(expectedExceptions=DateTimeException.class)
 568     public void test_plusYears_minLots() {
 569         Year.of(Year.MIN_VALUE).plusYears(-1000);
 570     }
 571 
 572     //-----------------------------------------------------------------------
 573     // plus(long, TemporalUnit)
 574     //-----------------------------------------------------------------------
 575     @DataProvider(name=&quot;plus_long_TemporalUnit&quot;)
 576     Object[][] data_plus_long_TemporalUnit() {
 577         return new Object[][] {
 578             {Year.of(1), 1, ChronoUnit.YEARS, Year.of(2), null},
 579             {Year.of(1), -12, ChronoUnit.YEARS, Year.of(-11), null},
 580             {Year.of(1), 0, ChronoUnit.YEARS, Year.of(1), null},
 581             {Year.of(999999999), 0, ChronoUnit.YEARS, Year.of(999999999), null},
 582             {Year.of(-999999999), 0, ChronoUnit.YEARS, Year.of(-999999999), null},
 583             {Year.of(0), -999999999, ChronoUnit.YEARS, Year.of(-999999999), null},
 584             {Year.of(0), 999999999, ChronoUnit.YEARS, Year.of(999999999), null},
 585 
 586             {Year.of(-1), 1, ChronoUnit.ERAS, Year.of(2), null},
 587             {Year.of(5), 1, ChronoUnit.CENTURIES, Year.of(105), null},
 588             {Year.of(5), 1, ChronoUnit.DECADES, Year.of(15), null},
 589 
 590             {Year.of(999999999), 1, ChronoUnit.YEARS, null, DateTimeException.class},
 591             {Year.of(-999999999), -1, ChronoUnit.YEARS, null, DateTimeException.class},
 592 
 593             {Year.of(1), 0, ChronoUnit.DAYS, null, DateTimeException.class},
 594             {Year.of(1), 0, ChronoUnit.WEEKS, null, DateTimeException.class},
 595             {Year.of(1), 0, ChronoUnit.MONTHS, null, DateTimeException.class},
 596         };
 597     }
 598 
 599     @Test(dataProvider=&quot;plus_long_TemporalUnit&quot;)
 600     public void test_plus_long_TemporalUnit(Year base, long amount, TemporalUnit unit, Year expectedYear, Class&lt;?&gt; expectedEx) {
 601         if (expectedEx == null) {
 602             assertEquals(base.plus(amount, unit), expectedYear);
 603         } else {
 604             try {
 605                 base.plus(amount, unit);
 606                 fail();
 607             } catch (Exception ex) {
 608                 assertTrue(expectedEx.isInstance(ex));
 609             }
 610         }
 611     }
 612 
 613     //-----------------------------------------------------------------------
 614     // minus(Period)
 615     //-----------------------------------------------------------------------
 616     @DataProvider(name=&quot;minusValid&quot;)
 617     Object[][] data_minusValid() {
 618         return new Object[][] {
 619                 {2012, Period.ofYears(0), 2012},
 620                 {2012, Period.ofYears(1), 2011},
 621                 {2012, Period.ofYears(2), 2010},
 622                 {2012, Period.ofYears(-2), 2014},
 623         };
 624     }
 625 
 626     @Test(dataProvider=&quot;minusValid&quot;)
 627     public void test_minusValid(int year, TemporalAmount amount, int expected) {
 628         assertEquals(Year.of(year).minus(amount), Year.of(expected));
 629     }
 630 
 631     @DataProvider(name=&quot;minusInvalidUnit&quot;)
 632     Object[][] data_minusInvalidUnit() {
 633         return new Object[][] {
 634                 {Period.of(0, 1, 0)},
 635                 {Period.of(0, 0, 1)},
 636                 {Period.of(0, 1, 1)},
 637                 {Period.of(1, 1, 1)},
 638                 {Duration.ofDays(1)},
 639                 {Duration.ofHours(1)},
 640                 {Duration.ofMinutes(1)},
 641                 {Duration.ofSeconds(1)},
 642         };
 643     }
 644 
 645     @Test(dataProvider=&quot;minusInvalidUnit&quot;, expectedExceptions=UnsupportedTemporalTypeException.class)
 646     public void test_minusInvalidUnit(TemporalAmount amount) {
 647         TEST_2008.minus(amount);
 648     }
 649 
 650     @Test(expectedExceptions=NullPointerException.class)
 651     public void test_minus_null() {
 652         TEST_2008.minus(null);
 653     }
 654 
 655     //-----------------------------------------------------------------------
 656     // minusYears()
 657     //-----------------------------------------------------------------------
 658     @Test
 659     public void test_minusYears() {
 660         assertEquals(Year.of(2007).minusYears(-1), Year.of(2008));
 661         assertEquals(Year.of(2007).minusYears(0), Year.of(2007));
 662         assertEquals(Year.of(2007).minusYears(1), Year.of(2006));
 663         assertEquals(Year.of(2007).minusYears(2), Year.of(2005));
 664 
 665         assertEquals(Year.of(Year.MAX_VALUE - 1).minusYears(-1), Year.of(Year.MAX_VALUE));
 666         assertEquals(Year.of(Year.MAX_VALUE).minusYears(0), Year.of(Year.MAX_VALUE));
 667 
 668         assertEquals(Year.of(Year.MIN_VALUE + 1).minusYears(1), Year.of(Year.MIN_VALUE));
 669         assertEquals(Year.of(Year.MIN_VALUE).minusYears(0), Year.of(Year.MIN_VALUE));
 670     }
 671 
 672     @Test
 673     public void test_minusYear_zero_equals() {
 674         Year base = Year.of(2007);
 675         assertEquals(base.minusYears(0), base);
 676     }
 677 
 678     @Test
 679     public void test_minusYears_big() {
 680         long years = 20L + Year.MAX_VALUE;
 681         assertEquals(Year.of(40).minusYears(years), Year.of((int) (40L - years)));
 682     }
 683 
 684     @Test(expectedExceptions=DateTimeException.class)
 685     public void test_minusYears_max() {
 686         Year.of(Year.MAX_VALUE).minusYears(-1);
 687     }
 688 
 689     @Test(expectedExceptions=DateTimeException.class)
 690     public void test_minusYears_maxLots() {
 691         Year.of(Year.MAX_VALUE).minusYears(-1000);
 692     }
 693 
 694     @Test(expectedExceptions=DateTimeException.class)
 695     public void test_minusYears_min() {
 696         Year.of(Year.MIN_VALUE).minusYears(1);
 697     }
 698 
 699     @Test(expectedExceptions=DateTimeException.class)
 700     public void test_minusYears_minLots() {
 701         Year.of(Year.MIN_VALUE).minusYears(1000);
 702     }
 703 
 704     //-----------------------------------------------------------------------
 705     // minus(long, TemporalUnit)
 706     //-----------------------------------------------------------------------
 707     @DataProvider(name=&quot;minus_long_TemporalUnit&quot;)
 708     Object[][] data_minus_long_TemporalUnit() {
 709         return new Object[][] {
 710             {Year.of(1), 1, ChronoUnit.YEARS, Year.of(0), null},
 711             {Year.of(1), -12, ChronoUnit.YEARS, Year.of(13), null},
 712             {Year.of(1), 0, ChronoUnit.YEARS, Year.of(1), null},
 713             {Year.of(999999999), 0, ChronoUnit.YEARS, Year.of(999999999), null},
 714             {Year.of(-999999999), 0, ChronoUnit.YEARS, Year.of(-999999999), null},
 715             {Year.of(0), -999999999, ChronoUnit.YEARS, Year.of(999999999), null},
 716             {Year.of(0), 999999999, ChronoUnit.YEARS, Year.of(-999999999), null},
 717 
 718             {Year.of(999999999), 1, ChronoUnit.ERAS, Year.of(-999999999 + 1), null},
 719             {Year.of(105), 1, ChronoUnit.CENTURIES, Year.of(5), null},
 720             {Year.of(15), 1, ChronoUnit.DECADES, Year.of(5), null},
 721 
 722             {Year.of(-999999999), 1, ChronoUnit.YEARS, null, DateTimeException.class},
 723             {Year.of(1), -999999999, ChronoUnit.YEARS, null, DateTimeException.class},
 724 
 725             {Year.of(1), 0, ChronoUnit.DAYS, null, DateTimeException.class},
 726             {Year.of(1), 0, ChronoUnit.WEEKS, null, DateTimeException.class},
 727             {Year.of(1), 0, ChronoUnit.MONTHS, null, DateTimeException.class},
 728         };
 729     }
 730 
 731     @Test(dataProvider=&quot;minus_long_TemporalUnit&quot;)
 732     public void test_minus_long_TemporalUnit(Year base, long amount, TemporalUnit unit, Year expectedYear, Class&lt;?&gt; expectedEx) {
 733         if (expectedEx == null) {
 734             assertEquals(base.minus(amount, unit), expectedYear);
 735         } else {
 736             try {
 737                 Year result = base.minus(amount, unit);
 738                 fail();
 739             } catch (Exception ex) {
 740                 assertTrue(expectedEx.isInstance(ex));
 741             }
 742         }
 743     }
 744 
 745     //-----------------------------------------------------------------------
 746     // adjustInto()
 747     //-----------------------------------------------------------------------
 748     @Test
 749     public void test_adjustDate() {
 750         LocalDate base = LocalDate.of(2007, 2, 12);
 751         for (int i = -4; i &lt;= 2104; i++) {
 752             Temporal result = Year.of(i).adjustInto(base);
 753             assertEquals(result, LocalDate.of(i, 2, 12));
 754         }
 755     }
 756 
 757     @Test
 758     public void test_adjustDate_resolve() {
 759         Year test = Year.of(2011);
 760         assertEquals(test.adjustInto(LocalDate.of(2012, 2, 29)), LocalDate.of(2011, 2, 28));
 761     }
 762 
 763     @Test(expectedExceptions=NullPointerException.class)
 764     public void test_adjustDate_nullLocalDate() {
 765         Year test = Year.of(1);
 766         test.adjustInto((LocalDate) null);
 767     }
 768 
 769     //-----------------------------------------------------------------------
 770     // with(TemporalAdjuster)
 771     //-----------------------------------------------------------------------
 772     @Test
 773     public void test_with_TemporalAdjuster() {
 774         Year base = Year.of(-10);
 775         for (int i = -4; i &lt;= 2104; i++) {
 776             Temporal result = base.with(Year.of(i));
 777             assertEquals(result, Year.of(i));
 778         }
 779     }
 780 
 781     @Test(expectedExceptions=DateTimeException.class)
 782     public void test_with_BadTemporalAdjuster() {
 783         Year test = Year.of(1);
 784         test.with(LocalTime.of(18, 1, 2));
 785     }
 786 
 787     //-----------------------------------------------------------------------
 788     // with(TemporalField, long)
 789     //-----------------------------------------------------------------------
 790     @Test
 791     public void test_with() {
 792         Year base = Year.of(5);
 793         Year result = base.with(ChronoField.ERA, 0);
 794         assertEquals(result, base.with(IsoEra.of(0)));
 795 
 796         int prolepticYear = IsoChronology.INSTANCE.prolepticYear(IsoEra.of(0), 5);
 797         assertEquals(result.get(ChronoField.ERA), 0);
 798         assertEquals(result.get(ChronoField.YEAR), prolepticYear);
 799         assertEquals(result.get(ChronoField.YEAR_OF_ERA), 5);
 800 
 801         result = base.with(ChronoField.YEAR, 10);
 802         assertEquals(result.get(ChronoField.ERA), base.get(ChronoField.ERA));
 803         assertEquals(result.get(ChronoField.YEAR), 10);
 804         assertEquals(result.get(ChronoField.YEAR_OF_ERA), 10);
 805 
 806         result = base.with(ChronoField.YEAR_OF_ERA, 20);
 807         assertEquals(result.get(ChronoField.ERA), base.get(ChronoField.ERA));
 808         assertEquals(result.get(ChronoField.YEAR), 20);
 809         assertEquals(result.get(ChronoField.YEAR_OF_ERA), 20);
 810     }
 811 
 812     //-----------------------------------------------------------------------
 813     // length()
 814     //-----------------------------------------------------------------------
 815     @Test
 816     public void test_length() {
 817         assertEquals(Year.of(1999).length(), 365);
 818         assertEquals(Year.of(2000).length(), 366);
 819         assertEquals(Year.of(2001).length(), 365);
 820 
 821         assertEquals(Year.of(2007).length(), 365);
 822         assertEquals(Year.of(2008).length(), 366);
 823         assertEquals(Year.of(2009).length(), 365);
 824         assertEquals(Year.of(2010).length(), 365);
 825         assertEquals(Year.of(2011).length(), 365);
 826         assertEquals(Year.of(2012).length(), 366);
 827 
 828         assertEquals(Year.of(2095).length(), 365);
 829         assertEquals(Year.of(2096).length(), 366);
 830         assertEquals(Year.of(2097).length(), 365);
 831         assertEquals(Year.of(2098).length(), 365);
 832         assertEquals(Year.of(2099).length(), 365);
 833         assertEquals(Year.of(2100).length(), 365);
 834         assertEquals(Year.of(2101).length(), 365);
 835         assertEquals(Year.of(2102).length(), 365);
 836         assertEquals(Year.of(2103).length(), 365);
 837         assertEquals(Year.of(2104).length(), 366);
 838         assertEquals(Year.of(2105).length(), 365);
 839 
 840         assertEquals(Year.of(-500).length(), 365);
 841         assertEquals(Year.of(-400).length(), 366);
 842         assertEquals(Year.of(-300).length(), 365);
 843         assertEquals(Year.of(-200).length(), 365);
 844         assertEquals(Year.of(-100).length(), 365);
 845         assertEquals(Year.of(0).length(), 366);
 846         assertEquals(Year.of(100).length(), 365);
 847         assertEquals(Year.of(200).length(), 365);
 848         assertEquals(Year.of(300).length(), 365);
 849         assertEquals(Year.of(400).length(), 366);
 850         assertEquals(Year.of(500).length(), 365);
 851     }
 852 
 853     //-----------------------------------------------------------------------
 854     // isValidMonthDay(MonthDay)
 855     //-----------------------------------------------------------------------
 856     @DataProvider(name=&quot;isValidMonthDay&quot;)
 857     Object[][] data_isValidMonthDay() {
 858         return new Object[][] {
 859                 {Year.of(2007), MonthDay.of(6, 30), true},
 860                 {Year.of(2008), MonthDay.of(2, 28), true},
 861                 {Year.of(2008), MonthDay.of(2, 29), true},
 862                 {Year.of(2009), MonthDay.of(2, 28), true},
 863                 {Year.of(2009), MonthDay.of(2, 29), false},
 864                 {Year.of(2009), null, false},
 865         };
 866     }
 867 
 868     @Test(dataProvider=&quot;isValidMonthDay&quot;)
 869     public void test_isValidMonthDay(Year year, MonthDay monthDay, boolean expected) {
 870         assertEquals(year.isValidMonthDay(monthDay), expected);
 871     }
 872 
 873     //-----------------------------------------------------------------------
 874     // until(Temporal, TemporalUnit)
 875     //-----------------------------------------------------------------------
 876     @DataProvider(name=&quot;periodUntilUnit&quot;)
 877     Object[][] data_periodUntilUnit() {
 878         return new Object[][] {
 879                 {Year.of(2000), Year.of(-1), YEARS, -2001},
 880                 {Year.of(2000), Year.of(0), YEARS, -2000},
 881                 {Year.of(2000), Year.of(1), YEARS, -1999},
 882                 {Year.of(2000), Year.of(1998), YEARS, -2},
 883                 {Year.of(2000), Year.of(1999), YEARS, -1},
 884                 {Year.of(2000), Year.of(2000), YEARS, 0},
 885                 {Year.of(2000), Year.of(2001), YEARS, 1},
 886                 {Year.of(2000), Year.of(2002), YEARS, 2},
 887                 {Year.of(2000), Year.of(2246), YEARS, 246},
 888 
 889                 {Year.of(2000), Year.of(-1), DECADES, -200},
 890                 {Year.of(2000), Year.of(0), DECADES, -200},
 891                 {Year.of(2000), Year.of(1), DECADES, -199},
 892                 {Year.of(2000), Year.of(1989), DECADES, -1},
 893                 {Year.of(2000), Year.of(1990), DECADES, -1},
 894                 {Year.of(2000), Year.of(1991), DECADES, 0},
 895                 {Year.of(2000), Year.of(2000), DECADES, 0},
 896                 {Year.of(2000), Year.of(2009), DECADES, 0},
 897                 {Year.of(2000), Year.of(2010), DECADES, 1},
 898                 {Year.of(2000), Year.of(2011), DECADES, 1},
 899 
 900                 {Year.of(2000), Year.of(-1), CENTURIES, -20},
 901                 {Year.of(2000), Year.of(0), CENTURIES, -20},
 902                 {Year.of(2000), Year.of(1), CENTURIES, -19},
 903                 {Year.of(2000), Year.of(1899), CENTURIES, -1},
 904                 {Year.of(2000), Year.of(1900), CENTURIES, -1},
 905                 {Year.of(2000), Year.of(1901), CENTURIES, 0},
 906                 {Year.of(2000), Year.of(2000), CENTURIES, 0},
 907                 {Year.of(2000), Year.of(2099), CENTURIES, 0},
 908                 {Year.of(2000), Year.of(2100), CENTURIES, 1},
 909                 {Year.of(2000), Year.of(2101), CENTURIES, 1},
 910 
 911                 {Year.of(2000), Year.of(-1), MILLENNIA, -2},
 912                 {Year.of(2000), Year.of(0), MILLENNIA, -2},
 913                 {Year.of(2000), Year.of(1), MILLENNIA, -1},
 914                 {Year.of(2000), Year.of(999), MILLENNIA, -1},
 915                 {Year.of(2000), Year.of(1000), MILLENNIA, -1},
 916                 {Year.of(2000), Year.of(1001), MILLENNIA, 0},
 917                 {Year.of(2000), Year.of(2000), MILLENNIA, 0},
 918                 {Year.of(2000), Year.of(2999), MILLENNIA, 0},
 919                 {Year.of(2000), Year.of(3000), MILLENNIA, 1},
 920                 {Year.of(2000), Year.of(3001), MILLENNIA, 1},
 921         };
 922     }
 923 
 924     @Test(dataProvider=&quot;periodUntilUnit&quot;)
 925     public void test_until_TemporalUnit(Year year1, Year year2, TemporalUnit unit, long expected) {
 926         long amount = year1.until(year2, unit);
 927         assertEquals(amount, expected);
 928     }
 929 
 930     @Test(dataProvider=&quot;periodUntilUnit&quot;)
 931     public void test_until_TemporalUnit_negated(Year year1, Year year2, TemporalUnit unit, long expected) {
 932         long amount = year2.until(year1, unit);
 933         assertEquals(amount, -expected);
 934     }
 935 
 936     @Test(dataProvider=&quot;periodUntilUnit&quot;)
 937     public void test_until_TemporalUnit_between(Year year1, Year year2, TemporalUnit unit, long expected) {
 938         long amount = unit.between(year1, year2);
 939         assertEquals(amount, expected);
 940     }
 941 
 942     @Test
 943     public void test_until_convertedType() {
 944         Year start = Year.of(2010);
 945         YearMonth end = start.plusYears(2).atMonth(Month.APRIL);
 946         assertEquals(start.until(end, YEARS), 2);
 947     }
 948 
 949     @Test(expectedExceptions=DateTimeException.class)
 950     public void test_until_invalidType() {
 951         Year start = Year.of(2010);
 952         start.until(LocalTime.of(11, 30), YEARS);
 953     }
 954 
 955     @Test(expectedExceptions = UnsupportedTemporalTypeException.class)
 956     public void test_until_TemporalUnit_unsupportedUnit() {
 957         TEST_2008.until(TEST_2008, MONTHS);
 958     }
 959 
 960     @Test(expectedExceptions = NullPointerException.class)
 961     public void test_until_TemporalUnit_nullEnd() {
 962         TEST_2008.until(null, DAYS);
 963     }
 964 
 965     @Test(expectedExceptions = NullPointerException.class)
 966     public void test_until_TemporalUnit_nullUnit() {
 967         TEST_2008.until(TEST_2008, null);
 968     }
 969 
 970     //-----------------------------------------------------------------------
 971     // format(DateTimeFormatter)
 972     //-----------------------------------------------------------------------
 973     @Test
 974     public void test_format_formatter() {
 975         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;y&quot;);
 976         String t = Year.of(2010).format(f);
 977         assertEquals(t, &quot;2010&quot;);
 978     }
 979 
 980     @Test(expectedExceptions=NullPointerException.class)
 981     public void test_format_formatter_null() {
 982         Year.of(2010).format(null);
 983     }
 984 
 985     //-----------------------------------------------------------------------
 986     // atMonth(Month)
 987     //-----------------------------------------------------------------------
 988     @Test
 989     public void test_atMonth() {
 990         Year test = Year.of(2008);
 991         assertEquals(test.atMonth(Month.JUNE), YearMonth.of(2008, 6));
 992     }
 993 
 994     @Test(expectedExceptions=NullPointerException.class)
 995     public void test_atMonth_nullMonth() {
 996         Year test = Year.of(2008);
 997         test.atMonth((Month) null);
 998     }
 999 
1000     //-----------------------------------------------------------------------
1001     // atMonth(int)
1002     //-----------------------------------------------------------------------
1003     @Test
1004     public void test_atMonth_int() {
1005         Year test = Year.of(2008);
1006         assertEquals(test.atMonth(6), YearMonth.of(2008, 6));
1007     }
1008 
1009     @Test(expectedExceptions=DateTimeException.class)
1010     public void test_atMonth_int_invalidMonth() {
1011         Year test = Year.of(2008);
1012         test.atMonth(13);
1013     }
1014 
1015     //-----------------------------------------------------------------------
1016     // atMonthDay(MonthDay)
1017     //-----------------------------------------------------------------------
1018     @DataProvider(name=&quot;atMonthDay&quot;)
1019     Object[][] data_atMonthDay() {
1020         return new Object[][] {
1021                 {Year.of(2008), MonthDay.of(6, 30), LocalDate.of(2008, 6, 30)},
1022                 {Year.of(2008), MonthDay.of(2, 29), LocalDate.of(2008, 2, 29)},
1023                 {Year.of(2009), MonthDay.of(2, 29), LocalDate.of(2009, 2, 28)},
1024         };
1025     }
1026 
1027     @Test(dataProvider=&quot;atMonthDay&quot;)
1028     public void test_atMonthDay(Year year, MonthDay monthDay, LocalDate expected) {
1029         assertEquals(year.atMonthDay(monthDay), expected);
1030     }
1031 
1032     @Test(expectedExceptions=NullPointerException.class)
1033     public void test_atMonthDay_nullMonthDay() {
1034         Year test = Year.of(2008);
1035         test.atMonthDay((MonthDay) null);
1036     }
1037 
1038     //-----------------------------------------------------------------------
1039     // atDay(int)
1040     //-----------------------------------------------------------------------
1041     @Test
1042     public void test_atDay_notLeapYear() {
1043         Year test = Year.of(2007);
1044         LocalDate expected = LocalDate.of(2007, 1, 1);
1045         for (int i = 1; i &lt;= 365; i++) {
1046             assertEquals(test.atDay(i), expected);
1047             expected = expected.plusDays(1);
1048         }
1049     }
1050 
1051     @Test(expectedExceptions=DateTimeException.class)
1052     public void test_atDay_notLeapYear_day366() {
1053         Year test = Year.of(2007);
1054         test.atDay(366);
1055     }
1056 
1057     @Test
1058     public void test_atDay_leapYear() {
1059         Year test = Year.of(2008);
1060         LocalDate expected = LocalDate.of(2008, 1, 1);
1061         for (int i = 1; i &lt;= 366; i++) {
1062             assertEquals(test.atDay(i), expected);
1063             expected = expected.plusDays(1);
1064         }
1065     }
1066 
1067     @Test(expectedExceptions=DateTimeException.class)
1068     public void test_atDay_day0() {
1069         Year test = Year.of(2007);
1070         test.atDay(0);
1071     }
1072 
1073     @Test(expectedExceptions=DateTimeException.class)
1074     public void test_atDay_day367() {
1075         Year test = Year.of(2007);
1076         test.atDay(367);
1077     }
1078 
1079     //-----------------------------------------------------------------------
1080     // compareTo()
1081     //-----------------------------------------------------------------------
1082     @Test
1083     public void test_compareTo() {
1084         for (int i = -4; i &lt;= 2104; i++) {
1085             Year a = Year.of(i);
1086             for (int j = -4; j &lt;= 2104; j++) {
1087                 Year b = Year.of(j);
1088                 if (i &lt; j) {
1089                     assertEquals(a.compareTo(b) &lt; 0, true);
1090                     assertEquals(b.compareTo(a) &gt; 0, true);
1091                     assertEquals(a.isAfter(b), false);
1092                     assertEquals(a.isBefore(b), true);
1093                     assertEquals(b.isAfter(a), true);
1094                     assertEquals(b.isBefore(a), false);
1095                 } else if (i &gt; j) {
1096                     assertEquals(a.compareTo(b) &gt; 0, true);
1097                     assertEquals(b.compareTo(a) &lt; 0, true);
1098                     assertEquals(a.isAfter(b), true);
1099                     assertEquals(a.isBefore(b), false);
1100                     assertEquals(b.isAfter(a), false);
1101                     assertEquals(b.isBefore(a), true);
1102                 } else {
1103                     assertEquals(a.compareTo(b), 0);
1104                     assertEquals(b.compareTo(a), 0);
1105                     assertEquals(a.isAfter(b), false);
1106                     assertEquals(a.isBefore(b), false);
1107                     assertEquals(b.isAfter(a), false);
1108                     assertEquals(b.isBefore(a), false);
1109                 }
1110             }
1111         }
1112     }
1113 
1114     @Test(expectedExceptions=NullPointerException.class)
1115     public void test_compareTo_nullYear() {
1116         Year doy = null;
1117         Year test = Year.of(1);
1118         test.compareTo(doy);
1119     }
1120 
1121     //-----------------------------------------------------------------------
1122     // equals() / hashCode()
1123     //-----------------------------------------------------------------------
1124     @Test
1125     public void test_equals() {
1126         for (int i = -4; i &lt;= 2104; i++) {
1127             Year a = Year.of(i);
1128             for (int j = -4; j &lt;= 2104; j++) {
1129                 Year b = Year.of(j);
1130                 assertEquals(a.equals(b), i == j);
1131                 assertEquals(a.hashCode() == b.hashCode(), i == j);
1132             }
1133         }
1134     }
1135 
1136     @Test
1137     public void test_equals_same() {
1138         Year test = Year.of(2011);
1139         assertEquals(test.equals(test), true);
1140     }
1141 
1142     @Test
1143     public void test_equals_nullYear() {
1144         Year doy = null;
1145         Year test = Year.of(1);
1146         assertEquals(test.equals(doy), false);
1147     }
1148 
1149     @Test
1150     public void test_equals_incorrectType() {
1151         Year test = Year.of(1);
1152         assertEquals(test.equals(&quot;Incorrect type&quot;), false);
1153     }
1154 
1155     //-----------------------------------------------------------------------
1156     // toString()
1157     //-----------------------------------------------------------------------
1158     @Test
1159     public void test_toString() {
1160         for (int i = -4; i &lt;= 2104; i++) {
1161             Year a = Year.of(i);
1162             assertEquals(a.toString(), &quot;&quot; + i);
1163         }
1164     }
1165 
1166 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/jdk/java/time/tck/java/time/TCKYear.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 /*
  25  * This file is available under and governed by the GNU General Public
  26  * License version 2 only, as published by the Free Software Foundation.
  27  * However, the following notice accompanied the original version of this
  28  * file:
  29  *
  30  * Copyright (c) 2008-2012, Stephen Colebourne &amp; Michael Nascimento Santos
  31  *
  32  * All rights reserved.
  33  *
  34  * Redistribution and use in source and binary forms, with or without
  35  * modification, are permitted provided that the following conditions are met:
  36  *
  37  *  * Redistributions of source code must retain the above copyright notice,
  38  *    this list of conditions and the following disclaimer.
  39  *
  40  *  * Redistributions in binary form must reproduce the above copyright notice,
  41  *    this list of conditions and the following disclaimer in the documentation
  42  *    and/or other materials provided with the distribution.
  43  *
  44  *  * Neither the name of JSR-310 nor the names of its contributors
  45  *    may be used to endorse or promote products derived from this software
  46  *    without specific prior written permission.
  47  *
  48  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  49  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  50  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  51  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  52  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  53  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  54  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  55  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  56  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  57  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  58  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  59  */
  60 package tck.java.time;
  61 
  62 import static java.time.temporal.ChronoField.ERA;
  63 import static java.time.temporal.ChronoField.YEAR;
  64 import static java.time.temporal.ChronoField.YEAR_OF_ERA;
  65 import static java.time.temporal.ChronoUnit.CENTURIES;
  66 import static java.time.temporal.ChronoUnit.DAYS;
  67 import static java.time.temporal.ChronoUnit.DECADES;
  68 import static java.time.temporal.ChronoUnit.MILLENNIA;
  69 import static java.time.temporal.ChronoUnit.MONTHS;
  70 import static java.time.temporal.ChronoUnit.YEARS;
  71 import static org.testng.Assert.assertEquals;
  72 import static org.testng.Assert.assertTrue;
  73 import static org.testng.Assert.fail;
  74 
  75 import java.io.ByteArrayOutputStream;
  76 import java.io.DataOutputStream;
  77 import java.time.Clock;
  78 import java.time.DateTimeException;
  79 import java.time.Duration;
  80 import java.time.Instant;
  81 import java.time.LocalDate;
  82 import java.time.LocalTime;
  83 import java.time.Month;
  84 import java.time.MonthDay;
  85 import java.time.OffsetDateTime;
  86 import java.time.Period;
  87 import java.time.Year;
  88 import java.time.YearMonth;
  89 import java.time.ZoneId;
  90 import java.time.ZoneOffset;
  91 import java.time.chrono.IsoChronology;
  92 import java.time.chrono.IsoEra;
  93 import java.time.format.DateTimeFormatter;
  94 import java.time.format.DateTimeParseException;
  95 import java.time.temporal.ChronoField;
  96 import java.time.temporal.ChronoUnit;
  97 import java.time.temporal.JulianFields;
  98 import java.time.temporal.Temporal;
  99 import java.time.temporal.TemporalAccessor;
 100 import java.time.temporal.TemporalAmount;
 101 import java.time.temporal.TemporalField;
 102 import java.time.temporal.TemporalQueries;
 103 import java.time.temporal.TemporalQuery;
 104 import java.time.temporal.TemporalUnit;
 105 import java.time.temporal.UnsupportedTemporalTypeException;
 106 import java.util.ArrayList;
 107 import java.util.Arrays;
 108 import java.util.List;
 109 
 110 import org.testng.annotations.BeforeMethod;
 111 import org.testng.annotations.DataProvider;
 112 import org.testng.annotations.Test;
 113 
 114 /**
 115  * Test Year.
 116  */
 117 @Test
 118 public class TCKYear extends AbstractDateTimeTest {
 119 
 120     private static final Year TEST_2008 = Year.of(2008);
 121 
 122     @BeforeMethod
 123     public void setUp() {
 124     }
 125 
 126     //-----------------------------------------------------------------------
 127     @Override
 128     protected List&lt;TemporalAccessor&gt; samples() {
 129         TemporalAccessor[] array = {TEST_2008, };
 130         return Arrays.asList(array);
 131     }
 132 
 133     @Override
 134     protected List&lt;TemporalField&gt; validFields() {
 135         TemporalField[] array = {
 136             YEAR_OF_ERA,
 137             YEAR,
 138             ERA,
 139         };
 140         return Arrays.asList(array);
 141     }
 142 
 143     @Override
 144     protected List&lt;TemporalField&gt; invalidFields() {
 145         List&lt;TemporalField&gt; list = new ArrayList&lt;&gt;(Arrays.&lt;TemporalField&gt;asList(ChronoField.values()));
 146         list.removeAll(validFields());
 147         list.add(JulianFields.JULIAN_DAY);
 148         list.add(JulianFields.MODIFIED_JULIAN_DAY);
 149         list.add(JulianFields.RATA_DIE);
 150         return list;
 151     }
 152 
 153     //-----------------------------------------------------------------------
 154     // now()
 155     //-----------------------------------------------------------------------
 156     @Test
 157     public void now() {
 158         Year expected = Year.now(Clock.systemDefaultZone());
 159         Year test = Year.now();
 160         for (int i = 0; i &lt; 100; i++) {
 161             if (expected.equals(test)) {
 162                 return;
 163             }
 164             expected = Year.now(Clock.systemDefaultZone());
 165             test = Year.now();
 166         }
 167         assertEquals(test, expected);
 168     }
 169 
 170     //-----------------------------------------------------------------------
 171     // now(ZoneId)
 172     //-----------------------------------------------------------------------
 173     @Test(expectedExceptions=NullPointerException.class)
 174     public void now_ZoneId_nullZoneId() {
 175         Year.now((ZoneId) null);
 176     }
 177 
 178     @Test
 179     public void now_ZoneId() {
 180         ZoneId zone = ZoneId.of(&quot;UTC+01:02:03&quot;);
 181         Year expected = Year.now(Clock.system(zone));
 182         Year test = Year.now(zone);
 183         for (int i = 0; i &lt; 100; i++) {
 184             if (expected.equals(test)) {
 185                 return;
 186             }
 187             expected = Year.now(Clock.system(zone));
 188             test = Year.now(zone);
 189         }
 190         assertEquals(test, expected);
 191     }
 192 
 193     //-----------------------------------------------------------------------
 194     // now(Clock)
 195     //-----------------------------------------------------------------------
 196     @Test
 197     public void now_Clock() {
 198         Instant instant = OffsetDateTime.of(LocalDate.of(2010, 12, 31), LocalTime.of(0, 0), ZoneOffset.UTC).toInstant();
 199         Clock clock = Clock.fixed(instant, ZoneOffset.UTC);
 200         Year test = Year.now(clock);
 201         assertEquals(test.getValue(), 2010);
 202     }
 203 
 204     @Test(expectedExceptions=NullPointerException.class)
 205     public void now_Clock_nullClock() {
 206         Year.now((Clock) null);
 207     }
 208 
 209     //-----------------------------------------------------------------------
 210     @Test
 211     public void test_factory_int_singleton() {
 212         for (int i = -4; i &lt;= 2104; i++) {
 213             Year test = Year.of(i);
 214             assertEquals(test.getValue(), i);
 215             assertEquals(Year.of(i), test);
 216         }
 217     }
 218 
 219     @Test(expectedExceptions=DateTimeException.class)
 220     public void test_factory_int_tooLow() {
 221         Year.of(Year.MIN_VALUE - 1);
 222     }
 223 
 224     @Test(expectedExceptions=DateTimeException.class)
 225     public void test_factory_int_tooHigh() {
 226         Year.of(Year.MAX_VALUE + 1);
 227     }
 228 
 229     //-----------------------------------------------------------------------
 230     @Test
 231     public void test_from_TemporalAccessor() {
 232         assertEquals(Year.from(LocalDate.of(2007, 7, 15)), Year.of(2007));
 233     }
 234 
 235     @Test(expectedExceptions=DateTimeException.class)
 236     public void test_from_TemporalAccessor_invalid_noDerive() {
 237         Year.from(LocalTime.of(12, 30));
 238     }
 239 
 240     @Test(expectedExceptions=NullPointerException.class)
 241     public void test_from_TemporalAccessor_null() {
 242         Year.from((TemporalAccessor) null);
 243     }
 244 
 245     //-----------------------------------------------------------------------
 246     // parse()
 247     //-----------------------------------------------------------------------
 248     @DataProvider(name=&quot;goodParseData&quot;)
 249     Object[][] provider_goodParseData() {
 250         return new Object[][] {
<a name="2" id="anc2"></a>
 251                 {&quot;9999&quot;, Year.of(9999)},
 252                 {&quot;2000&quot;, Year.of(2000)},
 253 
<a name="3" id="anc3"></a><span class="line-added"> 254                 {&quot;0&quot;, Year.of(0)},</span>
<span class="line-added"> 255                 {&quot;00&quot;, Year.of(0)},</span>
<span class="line-added"> 256                 {&quot;000&quot;, Year.of(0)},</span>
<span class="line-added"> 257                 {&quot;0000&quot;, Year.of(0)},</span>
<span class="line-added"> 258                 {&quot;00000&quot;, Year.of(0)},</span>
<span class="line-added"> 259                 {&quot;+00000&quot;, Year.of(0)},</span>
<span class="line-added"> 260                 {&quot;-0&quot;, Year.of(0)},</span>
<span class="line-added"> 261                 {&quot;-00&quot;, Year.of(0)},</span>
<span class="line-added"> 262                 {&quot;-000&quot;, Year.of(0)},</span>
<span class="line-added"> 263                 {&quot;-0000&quot;, Year.of(0)},</span>
<span class="line-added"> 264                 {&quot;-00000&quot;, Year.of(0)},</span>
<span class="line-added"> 265                 {&quot;1&quot;, Year.of(1)},</span>
<span class="line-added"> 266                 {&quot;01&quot;, Year.of(1)},</span>
<span class="line-added"> 267                 {&quot;001&quot;, Year.of(1)},</span>
<span class="line-added"> 268                 {&quot;0001&quot;, Year.of(1)},</span>
<span class="line-added"> 269                 {&quot;00001&quot;, Year.of(1)},</span>
<span class="line-added"> 270                 {&quot;+00001&quot;, Year.of(1)},</span>
<span class="line-added"> 271                 {&quot;-1&quot;, Year.of(-1)},</span>
<span class="line-added"> 272                 {&quot;-01&quot;, Year.of(-1)},</span>
<span class="line-added"> 273                 {&quot;-001&quot;, Year.of(-1)},</span>
<span class="line-added"> 274                 {&quot;-0001&quot;, Year.of(-1)},</span>
<span class="line-added"> 275                 {&quot;-00001&quot;, Year.of(-1)},</span>
<span class="line-added"> 276 </span>
 277                 {&quot;+12345678&quot;, Year.of(12345678)},
 278                 {&quot;+123456&quot;, Year.of(123456)},
 279                 {&quot;-1234&quot;, Year.of(-1234)},
 280                 {&quot;-12345678&quot;, Year.of(-12345678)},
 281 
 282                 {&quot;+&quot; + Year.MAX_VALUE, Year.of(Year.MAX_VALUE)},
 283                 {&quot;&quot; + Year.MIN_VALUE, Year.of(Year.MIN_VALUE)},
 284         };
 285     }
 286 
 287     @Test(dataProvider=&quot;goodParseData&quot;)
 288     public void factory_parse_success(String text, Year expected) {
 289         Year year = Year.parse(text);
 290         assertEquals(year, expected);
 291     }
 292 
 293     @DataProvider(name=&quot;badParseData&quot;)
 294     Object[][] provider_badParseData() {
 295         return new Object[][] {
 296                 {&quot;&quot;, 0},
<a name="4" id="anc4"></a>
 297                 {&quot;--01-0&quot;, 1},
 298                 {&quot;A01&quot;, 0},
<a name="5" id="anc5"></a>
 299                 {&quot;2009/12&quot;, 4},
 300 
<a name="6" id="anc6"></a><span class="line-modified"> 301                 {&quot;-0000-10&quot;, 5},</span>
<span class="line-modified"> 302                 {&quot;-12345678901-10&quot;, 10},</span>
<span class="line-modified"> 303                 {&quot;+1-10&quot;, 2},</span>
<span class="line-modified"> 304                 {&quot;+12-10&quot;, 3},</span>
<span class="line-modified"> 305                 {&quot;+123-10&quot;, 4},</span>
<span class="line-modified"> 306                 {&quot;+1234-10&quot;, 5},</span>
<span class="line-modified"> 307                 {&quot;12345-10&quot;, 5},</span>
<span class="line-modified"> 308                 {&quot;+12345678901-10&quot;, 10},</span>
 309         };
 310     }
 311 
 312     @Test(dataProvider=&quot;badParseData&quot;, expectedExceptions=DateTimeParseException.class)
 313     public void factory_parse_fail(String text, int pos) {
 314         try {
 315             Year.parse(text);
 316             fail(String.format(&quot;Parse should have failed for %s at position %d&quot;, text, pos));
 317         } catch (DateTimeParseException ex) {
 318             assertEquals(ex.getParsedString(), text);
 319             assertEquals(ex.getErrorIndex(), pos);
 320             throw ex;
 321         }
 322     }
 323 
 324     @Test(expectedExceptions=NullPointerException.class)
 325     public void factory_parse_nullText() {
 326         Year.parse(null);
 327     }
 328 
 329     //-----------------------------------------------------------------------
 330     // parse(DateTimeFormatter)
 331     //-----------------------------------------------------------------------
 332     @Test
 333     public void factory_parse_formatter() {
 334         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;y&quot;);
 335         Year test = Year.parse(&quot;2010&quot;, f);
 336         assertEquals(test, Year.of(2010));
 337     }
 338 
 339     @Test(expectedExceptions=NullPointerException.class)
 340     public void factory_parse_formatter_nullText() {
 341         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;y&quot;);
 342         Year.parse((String) null, f);
 343     }
 344 
 345     @Test(expectedExceptions=NullPointerException.class)
 346     public void factory_parse_formatter_nullFormatter() {
 347         Year.parse(&quot;ANY&quot;, null);
 348     }
 349 
 350     //-----------------------------------------------------------------------
 351     // isSupported(TemporalField)
 352     //-----------------------------------------------------------------------
 353     @Test
 354     public void test_isSupported_TemporalField() {
 355         assertEquals(TEST_2008.isSupported((TemporalField) null), false);
 356         assertEquals(TEST_2008.isSupported(ChronoField.NANO_OF_SECOND), false);
 357         assertEquals(TEST_2008.isSupported(ChronoField.NANO_OF_DAY), false);
 358         assertEquals(TEST_2008.isSupported(ChronoField.MICRO_OF_SECOND), false);
 359         assertEquals(TEST_2008.isSupported(ChronoField.MICRO_OF_DAY), false);
 360         assertEquals(TEST_2008.isSupported(ChronoField.MILLI_OF_SECOND), false);
 361         assertEquals(TEST_2008.isSupported(ChronoField.MILLI_OF_DAY), false);
 362         assertEquals(TEST_2008.isSupported(ChronoField.SECOND_OF_MINUTE), false);
 363         assertEquals(TEST_2008.isSupported(ChronoField.SECOND_OF_DAY), false);
 364         assertEquals(TEST_2008.isSupported(ChronoField.MINUTE_OF_HOUR), false);
 365         assertEquals(TEST_2008.isSupported(ChronoField.MINUTE_OF_DAY), false);
 366         assertEquals(TEST_2008.isSupported(ChronoField.HOUR_OF_AMPM), false);
 367         assertEquals(TEST_2008.isSupported(ChronoField.CLOCK_HOUR_OF_AMPM), false);
 368         assertEquals(TEST_2008.isSupported(ChronoField.HOUR_OF_DAY), false);
 369         assertEquals(TEST_2008.isSupported(ChronoField.CLOCK_HOUR_OF_DAY), false);
 370         assertEquals(TEST_2008.isSupported(ChronoField.AMPM_OF_DAY), false);
 371         assertEquals(TEST_2008.isSupported(ChronoField.DAY_OF_WEEK), false);
 372         assertEquals(TEST_2008.isSupported(ChronoField.ALIGNED_DAY_OF_WEEK_IN_MONTH), false);
 373         assertEquals(TEST_2008.isSupported(ChronoField.ALIGNED_DAY_OF_WEEK_IN_YEAR), false);
 374         assertEquals(TEST_2008.isSupported(ChronoField.DAY_OF_MONTH), false);
 375         assertEquals(TEST_2008.isSupported(ChronoField.DAY_OF_YEAR), false);
 376         assertEquals(TEST_2008.isSupported(ChronoField.EPOCH_DAY), false);
 377         assertEquals(TEST_2008.isSupported(ChronoField.ALIGNED_WEEK_OF_MONTH), false);
 378         assertEquals(TEST_2008.isSupported(ChronoField.ALIGNED_WEEK_OF_YEAR), false);
 379         assertEquals(TEST_2008.isSupported(ChronoField.MONTH_OF_YEAR), false);
 380         assertEquals(TEST_2008.isSupported(ChronoField.PROLEPTIC_MONTH), false);
 381         assertEquals(TEST_2008.isSupported(ChronoField.YEAR), true);
 382         assertEquals(TEST_2008.isSupported(ChronoField.YEAR_OF_ERA), true);
 383         assertEquals(TEST_2008.isSupported(ChronoField.ERA), true);
 384         assertEquals(TEST_2008.isSupported(ChronoField.INSTANT_SECONDS), false);
 385         assertEquals(TEST_2008.isSupported(ChronoField.OFFSET_SECONDS), false);
 386     }
 387 
 388     //-----------------------------------------------------------------------
 389     // isSupported(TemporalUnit)
 390     //-----------------------------------------------------------------------
 391     @Test
 392     public void test_isSupported_TemporalUnit() {
 393         assertEquals(TEST_2008.isSupported((TemporalUnit) null), false);
 394         assertEquals(TEST_2008.isSupported(ChronoUnit.NANOS), false);
 395         assertEquals(TEST_2008.isSupported(ChronoUnit.MICROS), false);
 396         assertEquals(TEST_2008.isSupported(ChronoUnit.MILLIS), false);
 397         assertEquals(TEST_2008.isSupported(ChronoUnit.SECONDS), false);
 398         assertEquals(TEST_2008.isSupported(ChronoUnit.MINUTES), false);
 399         assertEquals(TEST_2008.isSupported(ChronoUnit.HOURS), false);
 400         assertEquals(TEST_2008.isSupported(ChronoUnit.HALF_DAYS), false);
 401         assertEquals(TEST_2008.isSupported(ChronoUnit.DAYS), false);
 402         assertEquals(TEST_2008.isSupported(ChronoUnit.WEEKS), false);
 403         assertEquals(TEST_2008.isSupported(ChronoUnit.MONTHS), false);
 404         assertEquals(TEST_2008.isSupported(ChronoUnit.YEARS), true);
 405         assertEquals(TEST_2008.isSupported(ChronoUnit.DECADES), true);
 406         assertEquals(TEST_2008.isSupported(ChronoUnit.CENTURIES), true);
 407         assertEquals(TEST_2008.isSupported(ChronoUnit.MILLENNIA), true);
 408         assertEquals(TEST_2008.isSupported(ChronoUnit.ERAS), true);
 409         assertEquals(TEST_2008.isSupported(ChronoUnit.FOREVER), false);
 410     }
 411 
 412     //-----------------------------------------------------------------------
 413     // get(TemporalField)
 414     //-----------------------------------------------------------------------
 415     @Test
 416     public void test_get_TemporalField() {
 417         assertEquals(TEST_2008.get(ChronoField.YEAR), 2008);
 418         assertEquals(TEST_2008.get(ChronoField.YEAR_OF_ERA), 2008);
 419         assertEquals(TEST_2008.get(ChronoField.ERA), 1);
 420     }
 421 
 422     @Test
 423     public void test_getLong_TemporalField() {
 424         assertEquals(TEST_2008.getLong(ChronoField.YEAR), 2008);
 425         assertEquals(TEST_2008.getLong(ChronoField.YEAR_OF_ERA), 2008);
 426         assertEquals(TEST_2008.getLong(ChronoField.ERA), 1);
 427     }
 428 
 429     //-----------------------------------------------------------------------
 430     // query(TemporalQuery)
 431     //-----------------------------------------------------------------------
 432     @DataProvider(name=&quot;query&quot;)
 433     Object[][] data_query() {
 434         return new Object[][] {
 435                 {TEST_2008, TemporalQueries.chronology(), IsoChronology.INSTANCE},
 436                 {TEST_2008, TemporalQueries.zoneId(), null},
 437                 {TEST_2008, TemporalQueries.precision(), ChronoUnit.YEARS},
 438                 {TEST_2008, TemporalQueries.zone(), null},
 439                 {TEST_2008, TemporalQueries.offset(), null},
 440                 {TEST_2008, TemporalQueries.localDate(), null},
 441                 {TEST_2008, TemporalQueries.localTime(), null},
 442         };
 443     }
 444 
 445     @Test(dataProvider=&quot;query&quot;)
 446     public &lt;T&gt; void test_query(TemporalAccessor temporal, TemporalQuery&lt;T&gt; query, T expected) {
 447         assertEquals(temporal.query(query), expected);
 448     }
 449 
 450     @Test(dataProvider=&quot;query&quot;)
 451     public &lt;T&gt; void test_queryFrom(TemporalAccessor temporal, TemporalQuery&lt;T&gt; query, T expected) {
 452         assertEquals(query.queryFrom(temporal), expected);
 453     }
 454 
 455     @Test(expectedExceptions=NullPointerException.class)
 456     public void test_query_null() {
 457         TEST_2008.query(null);
 458     }
 459 
 460     //-----------------------------------------------------------------------
 461     // isLeap()
 462     //-----------------------------------------------------------------------
 463     @Test
 464     public void test_isLeap() {
 465         assertEquals(Year.of(1999).isLeap(), false);
 466         assertEquals(Year.of(2000).isLeap(), true);
 467         assertEquals(Year.of(2001).isLeap(), false);
 468 
 469         assertEquals(Year.of(2007).isLeap(), false);
 470         assertEquals(Year.of(2008).isLeap(), true);
 471         assertEquals(Year.of(2009).isLeap(), false);
 472         assertEquals(Year.of(2010).isLeap(), false);
 473         assertEquals(Year.of(2011).isLeap(), false);
 474         assertEquals(Year.of(2012).isLeap(), true);
 475 
 476         assertEquals(Year.of(2095).isLeap(), false);
 477         assertEquals(Year.of(2096).isLeap(), true);
 478         assertEquals(Year.of(2097).isLeap(), false);
 479         assertEquals(Year.of(2098).isLeap(), false);
 480         assertEquals(Year.of(2099).isLeap(), false);
 481         assertEquals(Year.of(2100).isLeap(), false);
 482         assertEquals(Year.of(2101).isLeap(), false);
 483         assertEquals(Year.of(2102).isLeap(), false);
 484         assertEquals(Year.of(2103).isLeap(), false);
 485         assertEquals(Year.of(2104).isLeap(), true);
 486         assertEquals(Year.of(2105).isLeap(), false);
 487 
 488         assertEquals(Year.of(-500).isLeap(), false);
 489         assertEquals(Year.of(-400).isLeap(), true);
 490         assertEquals(Year.of(-300).isLeap(), false);
 491         assertEquals(Year.of(-200).isLeap(), false);
 492         assertEquals(Year.of(-100).isLeap(), false);
 493         assertEquals(Year.of(0).isLeap(), true);
 494         assertEquals(Year.of(100).isLeap(), false);
 495         assertEquals(Year.of(200).isLeap(), false);
 496         assertEquals(Year.of(300).isLeap(), false);
 497         assertEquals(Year.of(400).isLeap(), true);
 498         assertEquals(Year.of(500).isLeap(), false);
 499     }
 500 
 501     //-----------------------------------------------------------------------
 502     // plus(Period)
 503     //-----------------------------------------------------------------------
 504     @DataProvider(name=&quot;plusValid&quot;)
 505     Object[][] data_plusValid() {
 506         return new Object[][] {
 507                 {2012, Period.ofYears(0), 2012},
 508                 {2012, Period.ofYears(1), 2013},
 509                 {2012, Period.ofYears(2), 2014},
 510                 {2012, Period.ofYears(-2), 2010},
 511         };
 512     }
 513 
 514     @Test(dataProvider=&quot;plusValid&quot;)
 515     public void test_plusValid(int year, TemporalAmount amount, int expected) {
 516         assertEquals(Year.of(year).plus(amount), Year.of(expected));
 517     }
 518 
 519     @DataProvider(name=&quot;plusInvalidUnit&quot;)
 520     Object[][] data_plusInvalidUnit() {
 521         return new Object[][] {
 522                 {Period.of(0, 1, 0)},
 523                 {Period.of(0, 0, 1)},
 524                 {Period.of(0, 1, 1)},
 525                 {Period.of(1, 1, 1)},
 526                 {Duration.ofDays(1)},
 527                 {Duration.ofHours(1)},
 528                 {Duration.ofMinutes(1)},
 529                 {Duration.ofSeconds(1)},
 530         };
 531     }
 532 
 533     @Test(dataProvider=&quot;plusInvalidUnit&quot;, expectedExceptions=UnsupportedTemporalTypeException.class)
 534     public void test_plusInvalidUnit(TemporalAmount amount) {
 535         TEST_2008.plus(amount);
 536     }
 537 
 538     @Test(expectedExceptions=NullPointerException.class)
 539     public void test_plus_null() {
 540         TEST_2008.plus(null);
 541     }
 542 
 543     //-----------------------------------------------------------------------
 544     // plusYears()
 545     //-----------------------------------------------------------------------
 546     @Test
 547     public void test_plusYears() {
 548         assertEquals(Year.of(2007).plusYears(-1), Year.of(2006));
 549         assertEquals(Year.of(2007).plusYears(0), Year.of(2007));
 550         assertEquals(Year.of(2007).plusYears(1), Year.of(2008));
 551         assertEquals(Year.of(2007).plusYears(2), Year.of(2009));
 552 
 553         assertEquals(Year.of(Year.MAX_VALUE - 1).plusYears(1), Year.of(Year.MAX_VALUE));
 554         assertEquals(Year.of(Year.MAX_VALUE).plusYears(0), Year.of(Year.MAX_VALUE));
 555 
 556         assertEquals(Year.of(Year.MIN_VALUE + 1).plusYears(-1), Year.of(Year.MIN_VALUE));
 557         assertEquals(Year.of(Year.MIN_VALUE).plusYears(0), Year.of(Year.MIN_VALUE));
 558     }
 559 
 560     @Test
 561     public void test_plusYear_zero_equals() {
 562         Year base = Year.of(2007);
 563         assertEquals(base.plusYears(0), base);
 564     }
 565 
 566     @Test
 567     public void test_plusYears_big() {
 568         long years = 20L + Year.MAX_VALUE;
 569         assertEquals(Year.of(-40).plusYears(years), Year.of((int) (-40L + years)));
 570     }
 571 
 572     @Test(expectedExceptions=DateTimeException.class)
 573     public void test_plusYears_max() {
 574         Year.of(Year.MAX_VALUE).plusYears(1);
 575     }
 576 
 577     @Test(expectedExceptions=DateTimeException.class)
 578     public void test_plusYears_maxLots() {
 579         Year.of(Year.MAX_VALUE).plusYears(1000);
 580     }
 581 
 582     @Test(expectedExceptions=DateTimeException.class)
 583     public void test_plusYears_min() {
 584         Year.of(Year.MIN_VALUE).plusYears(-1);
 585     }
 586 
 587     @Test(expectedExceptions=DateTimeException.class)
 588     public void test_plusYears_minLots() {
 589         Year.of(Year.MIN_VALUE).plusYears(-1000);
 590     }
 591 
 592     //-----------------------------------------------------------------------
 593     // plus(long, TemporalUnit)
 594     //-----------------------------------------------------------------------
 595     @DataProvider(name=&quot;plus_long_TemporalUnit&quot;)
 596     Object[][] data_plus_long_TemporalUnit() {
 597         return new Object[][] {
 598             {Year.of(1), 1, ChronoUnit.YEARS, Year.of(2), null},
 599             {Year.of(1), -12, ChronoUnit.YEARS, Year.of(-11), null},
 600             {Year.of(1), 0, ChronoUnit.YEARS, Year.of(1), null},
 601             {Year.of(999999999), 0, ChronoUnit.YEARS, Year.of(999999999), null},
 602             {Year.of(-999999999), 0, ChronoUnit.YEARS, Year.of(-999999999), null},
 603             {Year.of(0), -999999999, ChronoUnit.YEARS, Year.of(-999999999), null},
 604             {Year.of(0), 999999999, ChronoUnit.YEARS, Year.of(999999999), null},
 605 
 606             {Year.of(-1), 1, ChronoUnit.ERAS, Year.of(2), null},
 607             {Year.of(5), 1, ChronoUnit.CENTURIES, Year.of(105), null},
 608             {Year.of(5), 1, ChronoUnit.DECADES, Year.of(15), null},
 609 
 610             {Year.of(999999999), 1, ChronoUnit.YEARS, null, DateTimeException.class},
 611             {Year.of(-999999999), -1, ChronoUnit.YEARS, null, DateTimeException.class},
 612 
 613             {Year.of(1), 0, ChronoUnit.DAYS, null, DateTimeException.class},
 614             {Year.of(1), 0, ChronoUnit.WEEKS, null, DateTimeException.class},
 615             {Year.of(1), 0, ChronoUnit.MONTHS, null, DateTimeException.class},
 616         };
 617     }
 618 
 619     @Test(dataProvider=&quot;plus_long_TemporalUnit&quot;)
 620     public void test_plus_long_TemporalUnit(Year base, long amount, TemporalUnit unit, Year expectedYear, Class&lt;?&gt; expectedEx) {
 621         if (expectedEx == null) {
 622             assertEquals(base.plus(amount, unit), expectedYear);
 623         } else {
 624             try {
 625                 base.plus(amount, unit);
 626                 fail();
 627             } catch (Exception ex) {
 628                 assertTrue(expectedEx.isInstance(ex));
 629             }
 630         }
 631     }
 632 
 633     //-----------------------------------------------------------------------
 634     // minus(Period)
 635     //-----------------------------------------------------------------------
 636     @DataProvider(name=&quot;minusValid&quot;)
 637     Object[][] data_minusValid() {
 638         return new Object[][] {
 639                 {2012, Period.ofYears(0), 2012},
 640                 {2012, Period.ofYears(1), 2011},
 641                 {2012, Period.ofYears(2), 2010},
 642                 {2012, Period.ofYears(-2), 2014},
 643         };
 644     }
 645 
 646     @Test(dataProvider=&quot;minusValid&quot;)
 647     public void test_minusValid(int year, TemporalAmount amount, int expected) {
 648         assertEquals(Year.of(year).minus(amount), Year.of(expected));
 649     }
 650 
 651     @DataProvider(name=&quot;minusInvalidUnit&quot;)
 652     Object[][] data_minusInvalidUnit() {
 653         return new Object[][] {
 654                 {Period.of(0, 1, 0)},
 655                 {Period.of(0, 0, 1)},
 656                 {Period.of(0, 1, 1)},
 657                 {Period.of(1, 1, 1)},
 658                 {Duration.ofDays(1)},
 659                 {Duration.ofHours(1)},
 660                 {Duration.ofMinutes(1)},
 661                 {Duration.ofSeconds(1)},
 662         };
 663     }
 664 
 665     @Test(dataProvider=&quot;minusInvalidUnit&quot;, expectedExceptions=UnsupportedTemporalTypeException.class)
 666     public void test_minusInvalidUnit(TemporalAmount amount) {
 667         TEST_2008.minus(amount);
 668     }
 669 
 670     @Test(expectedExceptions=NullPointerException.class)
 671     public void test_minus_null() {
 672         TEST_2008.minus(null);
 673     }
 674 
 675     //-----------------------------------------------------------------------
 676     // minusYears()
 677     //-----------------------------------------------------------------------
 678     @Test
 679     public void test_minusYears() {
 680         assertEquals(Year.of(2007).minusYears(-1), Year.of(2008));
 681         assertEquals(Year.of(2007).minusYears(0), Year.of(2007));
 682         assertEquals(Year.of(2007).minusYears(1), Year.of(2006));
 683         assertEquals(Year.of(2007).minusYears(2), Year.of(2005));
 684 
 685         assertEquals(Year.of(Year.MAX_VALUE - 1).minusYears(-1), Year.of(Year.MAX_VALUE));
 686         assertEquals(Year.of(Year.MAX_VALUE).minusYears(0), Year.of(Year.MAX_VALUE));
 687 
 688         assertEquals(Year.of(Year.MIN_VALUE + 1).minusYears(1), Year.of(Year.MIN_VALUE));
 689         assertEquals(Year.of(Year.MIN_VALUE).minusYears(0), Year.of(Year.MIN_VALUE));
 690     }
 691 
 692     @Test
 693     public void test_minusYear_zero_equals() {
 694         Year base = Year.of(2007);
 695         assertEquals(base.minusYears(0), base);
 696     }
 697 
 698     @Test
 699     public void test_minusYears_big() {
 700         long years = 20L + Year.MAX_VALUE;
 701         assertEquals(Year.of(40).minusYears(years), Year.of((int) (40L - years)));
 702     }
 703 
 704     @Test(expectedExceptions=DateTimeException.class)
 705     public void test_minusYears_max() {
 706         Year.of(Year.MAX_VALUE).minusYears(-1);
 707     }
 708 
 709     @Test(expectedExceptions=DateTimeException.class)
 710     public void test_minusYears_maxLots() {
 711         Year.of(Year.MAX_VALUE).minusYears(-1000);
 712     }
 713 
 714     @Test(expectedExceptions=DateTimeException.class)
 715     public void test_minusYears_min() {
 716         Year.of(Year.MIN_VALUE).minusYears(1);
 717     }
 718 
 719     @Test(expectedExceptions=DateTimeException.class)
 720     public void test_minusYears_minLots() {
 721         Year.of(Year.MIN_VALUE).minusYears(1000);
 722     }
 723 
 724     //-----------------------------------------------------------------------
 725     // minus(long, TemporalUnit)
 726     //-----------------------------------------------------------------------
 727     @DataProvider(name=&quot;minus_long_TemporalUnit&quot;)
 728     Object[][] data_minus_long_TemporalUnit() {
 729         return new Object[][] {
 730             {Year.of(1), 1, ChronoUnit.YEARS, Year.of(0), null},
 731             {Year.of(1), -12, ChronoUnit.YEARS, Year.of(13), null},
 732             {Year.of(1), 0, ChronoUnit.YEARS, Year.of(1), null},
 733             {Year.of(999999999), 0, ChronoUnit.YEARS, Year.of(999999999), null},
 734             {Year.of(-999999999), 0, ChronoUnit.YEARS, Year.of(-999999999), null},
 735             {Year.of(0), -999999999, ChronoUnit.YEARS, Year.of(999999999), null},
 736             {Year.of(0), 999999999, ChronoUnit.YEARS, Year.of(-999999999), null},
 737 
 738             {Year.of(999999999), 1, ChronoUnit.ERAS, Year.of(-999999999 + 1), null},
 739             {Year.of(105), 1, ChronoUnit.CENTURIES, Year.of(5), null},
 740             {Year.of(15), 1, ChronoUnit.DECADES, Year.of(5), null},
 741 
 742             {Year.of(-999999999), 1, ChronoUnit.YEARS, null, DateTimeException.class},
 743             {Year.of(1), -999999999, ChronoUnit.YEARS, null, DateTimeException.class},
 744 
 745             {Year.of(1), 0, ChronoUnit.DAYS, null, DateTimeException.class},
 746             {Year.of(1), 0, ChronoUnit.WEEKS, null, DateTimeException.class},
 747             {Year.of(1), 0, ChronoUnit.MONTHS, null, DateTimeException.class},
 748         };
 749     }
 750 
 751     @Test(dataProvider=&quot;minus_long_TemporalUnit&quot;)
 752     public void test_minus_long_TemporalUnit(Year base, long amount, TemporalUnit unit, Year expectedYear, Class&lt;?&gt; expectedEx) {
 753         if (expectedEx == null) {
 754             assertEquals(base.minus(amount, unit), expectedYear);
 755         } else {
 756             try {
 757                 Year result = base.minus(amount, unit);
 758                 fail();
 759             } catch (Exception ex) {
 760                 assertTrue(expectedEx.isInstance(ex));
 761             }
 762         }
 763     }
 764 
 765     //-----------------------------------------------------------------------
 766     // adjustInto()
 767     //-----------------------------------------------------------------------
 768     @Test
 769     public void test_adjustDate() {
 770         LocalDate base = LocalDate.of(2007, 2, 12);
 771         for (int i = -4; i &lt;= 2104; i++) {
 772             Temporal result = Year.of(i).adjustInto(base);
 773             assertEquals(result, LocalDate.of(i, 2, 12));
 774         }
 775     }
 776 
 777     @Test
 778     public void test_adjustDate_resolve() {
 779         Year test = Year.of(2011);
 780         assertEquals(test.adjustInto(LocalDate.of(2012, 2, 29)), LocalDate.of(2011, 2, 28));
 781     }
 782 
 783     @Test(expectedExceptions=NullPointerException.class)
 784     public void test_adjustDate_nullLocalDate() {
 785         Year test = Year.of(1);
 786         test.adjustInto((LocalDate) null);
 787     }
 788 
 789     //-----------------------------------------------------------------------
 790     // with(TemporalAdjuster)
 791     //-----------------------------------------------------------------------
 792     @Test
 793     public void test_with_TemporalAdjuster() {
 794         Year base = Year.of(-10);
 795         for (int i = -4; i &lt;= 2104; i++) {
 796             Temporal result = base.with(Year.of(i));
 797             assertEquals(result, Year.of(i));
 798         }
 799     }
 800 
 801     @Test(expectedExceptions=DateTimeException.class)
 802     public void test_with_BadTemporalAdjuster() {
 803         Year test = Year.of(1);
 804         test.with(LocalTime.of(18, 1, 2));
 805     }
 806 
 807     //-----------------------------------------------------------------------
 808     // with(TemporalField, long)
 809     //-----------------------------------------------------------------------
 810     @Test
 811     public void test_with() {
 812         Year base = Year.of(5);
 813         Year result = base.with(ChronoField.ERA, 0);
 814         assertEquals(result, base.with(IsoEra.of(0)));
 815 
 816         int prolepticYear = IsoChronology.INSTANCE.prolepticYear(IsoEra.of(0), 5);
 817         assertEquals(result.get(ChronoField.ERA), 0);
 818         assertEquals(result.get(ChronoField.YEAR), prolepticYear);
 819         assertEquals(result.get(ChronoField.YEAR_OF_ERA), 5);
 820 
 821         result = base.with(ChronoField.YEAR, 10);
 822         assertEquals(result.get(ChronoField.ERA), base.get(ChronoField.ERA));
 823         assertEquals(result.get(ChronoField.YEAR), 10);
 824         assertEquals(result.get(ChronoField.YEAR_OF_ERA), 10);
 825 
 826         result = base.with(ChronoField.YEAR_OF_ERA, 20);
 827         assertEquals(result.get(ChronoField.ERA), base.get(ChronoField.ERA));
 828         assertEquals(result.get(ChronoField.YEAR), 20);
 829         assertEquals(result.get(ChronoField.YEAR_OF_ERA), 20);
 830     }
 831 
 832     //-----------------------------------------------------------------------
 833     // length()
 834     //-----------------------------------------------------------------------
 835     @Test
 836     public void test_length() {
 837         assertEquals(Year.of(1999).length(), 365);
 838         assertEquals(Year.of(2000).length(), 366);
 839         assertEquals(Year.of(2001).length(), 365);
 840 
 841         assertEquals(Year.of(2007).length(), 365);
 842         assertEquals(Year.of(2008).length(), 366);
 843         assertEquals(Year.of(2009).length(), 365);
 844         assertEquals(Year.of(2010).length(), 365);
 845         assertEquals(Year.of(2011).length(), 365);
 846         assertEquals(Year.of(2012).length(), 366);
 847 
 848         assertEquals(Year.of(2095).length(), 365);
 849         assertEquals(Year.of(2096).length(), 366);
 850         assertEquals(Year.of(2097).length(), 365);
 851         assertEquals(Year.of(2098).length(), 365);
 852         assertEquals(Year.of(2099).length(), 365);
 853         assertEquals(Year.of(2100).length(), 365);
 854         assertEquals(Year.of(2101).length(), 365);
 855         assertEquals(Year.of(2102).length(), 365);
 856         assertEquals(Year.of(2103).length(), 365);
 857         assertEquals(Year.of(2104).length(), 366);
 858         assertEquals(Year.of(2105).length(), 365);
 859 
 860         assertEquals(Year.of(-500).length(), 365);
 861         assertEquals(Year.of(-400).length(), 366);
 862         assertEquals(Year.of(-300).length(), 365);
 863         assertEquals(Year.of(-200).length(), 365);
 864         assertEquals(Year.of(-100).length(), 365);
 865         assertEquals(Year.of(0).length(), 366);
 866         assertEquals(Year.of(100).length(), 365);
 867         assertEquals(Year.of(200).length(), 365);
 868         assertEquals(Year.of(300).length(), 365);
 869         assertEquals(Year.of(400).length(), 366);
 870         assertEquals(Year.of(500).length(), 365);
 871     }
 872 
 873     //-----------------------------------------------------------------------
 874     // isValidMonthDay(MonthDay)
 875     //-----------------------------------------------------------------------
 876     @DataProvider(name=&quot;isValidMonthDay&quot;)
 877     Object[][] data_isValidMonthDay() {
 878         return new Object[][] {
 879                 {Year.of(2007), MonthDay.of(6, 30), true},
 880                 {Year.of(2008), MonthDay.of(2, 28), true},
 881                 {Year.of(2008), MonthDay.of(2, 29), true},
 882                 {Year.of(2009), MonthDay.of(2, 28), true},
 883                 {Year.of(2009), MonthDay.of(2, 29), false},
 884                 {Year.of(2009), null, false},
 885         };
 886     }
 887 
 888     @Test(dataProvider=&quot;isValidMonthDay&quot;)
 889     public void test_isValidMonthDay(Year year, MonthDay monthDay, boolean expected) {
 890         assertEquals(year.isValidMonthDay(monthDay), expected);
 891     }
 892 
 893     //-----------------------------------------------------------------------
 894     // until(Temporal, TemporalUnit)
 895     //-----------------------------------------------------------------------
 896     @DataProvider(name=&quot;periodUntilUnit&quot;)
 897     Object[][] data_periodUntilUnit() {
 898         return new Object[][] {
 899                 {Year.of(2000), Year.of(-1), YEARS, -2001},
 900                 {Year.of(2000), Year.of(0), YEARS, -2000},
 901                 {Year.of(2000), Year.of(1), YEARS, -1999},
 902                 {Year.of(2000), Year.of(1998), YEARS, -2},
 903                 {Year.of(2000), Year.of(1999), YEARS, -1},
 904                 {Year.of(2000), Year.of(2000), YEARS, 0},
 905                 {Year.of(2000), Year.of(2001), YEARS, 1},
 906                 {Year.of(2000), Year.of(2002), YEARS, 2},
 907                 {Year.of(2000), Year.of(2246), YEARS, 246},
 908 
 909                 {Year.of(2000), Year.of(-1), DECADES, -200},
 910                 {Year.of(2000), Year.of(0), DECADES, -200},
 911                 {Year.of(2000), Year.of(1), DECADES, -199},
 912                 {Year.of(2000), Year.of(1989), DECADES, -1},
 913                 {Year.of(2000), Year.of(1990), DECADES, -1},
 914                 {Year.of(2000), Year.of(1991), DECADES, 0},
 915                 {Year.of(2000), Year.of(2000), DECADES, 0},
 916                 {Year.of(2000), Year.of(2009), DECADES, 0},
 917                 {Year.of(2000), Year.of(2010), DECADES, 1},
 918                 {Year.of(2000), Year.of(2011), DECADES, 1},
 919 
 920                 {Year.of(2000), Year.of(-1), CENTURIES, -20},
 921                 {Year.of(2000), Year.of(0), CENTURIES, -20},
 922                 {Year.of(2000), Year.of(1), CENTURIES, -19},
 923                 {Year.of(2000), Year.of(1899), CENTURIES, -1},
 924                 {Year.of(2000), Year.of(1900), CENTURIES, -1},
 925                 {Year.of(2000), Year.of(1901), CENTURIES, 0},
 926                 {Year.of(2000), Year.of(2000), CENTURIES, 0},
 927                 {Year.of(2000), Year.of(2099), CENTURIES, 0},
 928                 {Year.of(2000), Year.of(2100), CENTURIES, 1},
 929                 {Year.of(2000), Year.of(2101), CENTURIES, 1},
 930 
 931                 {Year.of(2000), Year.of(-1), MILLENNIA, -2},
 932                 {Year.of(2000), Year.of(0), MILLENNIA, -2},
 933                 {Year.of(2000), Year.of(1), MILLENNIA, -1},
 934                 {Year.of(2000), Year.of(999), MILLENNIA, -1},
 935                 {Year.of(2000), Year.of(1000), MILLENNIA, -1},
 936                 {Year.of(2000), Year.of(1001), MILLENNIA, 0},
 937                 {Year.of(2000), Year.of(2000), MILLENNIA, 0},
 938                 {Year.of(2000), Year.of(2999), MILLENNIA, 0},
 939                 {Year.of(2000), Year.of(3000), MILLENNIA, 1},
 940                 {Year.of(2000), Year.of(3001), MILLENNIA, 1},
 941         };
 942     }
 943 
 944     @Test(dataProvider=&quot;periodUntilUnit&quot;)
 945     public void test_until_TemporalUnit(Year year1, Year year2, TemporalUnit unit, long expected) {
 946         long amount = year1.until(year2, unit);
 947         assertEquals(amount, expected);
 948     }
 949 
 950     @Test(dataProvider=&quot;periodUntilUnit&quot;)
 951     public void test_until_TemporalUnit_negated(Year year1, Year year2, TemporalUnit unit, long expected) {
 952         long amount = year2.until(year1, unit);
 953         assertEquals(amount, -expected);
 954     }
 955 
 956     @Test(dataProvider=&quot;periodUntilUnit&quot;)
 957     public void test_until_TemporalUnit_between(Year year1, Year year2, TemporalUnit unit, long expected) {
 958         long amount = unit.between(year1, year2);
 959         assertEquals(amount, expected);
 960     }
 961 
 962     @Test
 963     public void test_until_convertedType() {
 964         Year start = Year.of(2010);
 965         YearMonth end = start.plusYears(2).atMonth(Month.APRIL);
 966         assertEquals(start.until(end, YEARS), 2);
 967     }
 968 
 969     @Test(expectedExceptions=DateTimeException.class)
 970     public void test_until_invalidType() {
 971         Year start = Year.of(2010);
 972         start.until(LocalTime.of(11, 30), YEARS);
 973     }
 974 
 975     @Test(expectedExceptions = UnsupportedTemporalTypeException.class)
 976     public void test_until_TemporalUnit_unsupportedUnit() {
 977         TEST_2008.until(TEST_2008, MONTHS);
 978     }
 979 
 980     @Test(expectedExceptions = NullPointerException.class)
 981     public void test_until_TemporalUnit_nullEnd() {
 982         TEST_2008.until(null, DAYS);
 983     }
 984 
 985     @Test(expectedExceptions = NullPointerException.class)
 986     public void test_until_TemporalUnit_nullUnit() {
 987         TEST_2008.until(TEST_2008, null);
 988     }
 989 
 990     //-----------------------------------------------------------------------
 991     // format(DateTimeFormatter)
 992     //-----------------------------------------------------------------------
 993     @Test
 994     public void test_format_formatter() {
 995         DateTimeFormatter f = DateTimeFormatter.ofPattern(&quot;y&quot;);
 996         String t = Year.of(2010).format(f);
 997         assertEquals(t, &quot;2010&quot;);
 998     }
 999 
1000     @Test(expectedExceptions=NullPointerException.class)
1001     public void test_format_formatter_null() {
1002         Year.of(2010).format(null);
1003     }
1004 
1005     //-----------------------------------------------------------------------
1006     // atMonth(Month)
1007     //-----------------------------------------------------------------------
1008     @Test
1009     public void test_atMonth() {
1010         Year test = Year.of(2008);
1011         assertEquals(test.atMonth(Month.JUNE), YearMonth.of(2008, 6));
1012     }
1013 
1014     @Test(expectedExceptions=NullPointerException.class)
1015     public void test_atMonth_nullMonth() {
1016         Year test = Year.of(2008);
1017         test.atMonth((Month) null);
1018     }
1019 
1020     //-----------------------------------------------------------------------
1021     // atMonth(int)
1022     //-----------------------------------------------------------------------
1023     @Test
1024     public void test_atMonth_int() {
1025         Year test = Year.of(2008);
1026         assertEquals(test.atMonth(6), YearMonth.of(2008, 6));
1027     }
1028 
1029     @Test(expectedExceptions=DateTimeException.class)
1030     public void test_atMonth_int_invalidMonth() {
1031         Year test = Year.of(2008);
1032         test.atMonth(13);
1033     }
1034 
1035     //-----------------------------------------------------------------------
1036     // atMonthDay(MonthDay)
1037     //-----------------------------------------------------------------------
1038     @DataProvider(name=&quot;atMonthDay&quot;)
1039     Object[][] data_atMonthDay() {
1040         return new Object[][] {
1041                 {Year.of(2008), MonthDay.of(6, 30), LocalDate.of(2008, 6, 30)},
1042                 {Year.of(2008), MonthDay.of(2, 29), LocalDate.of(2008, 2, 29)},
1043                 {Year.of(2009), MonthDay.of(2, 29), LocalDate.of(2009, 2, 28)},
1044         };
1045     }
1046 
1047     @Test(dataProvider=&quot;atMonthDay&quot;)
1048     public void test_atMonthDay(Year year, MonthDay monthDay, LocalDate expected) {
1049         assertEquals(year.atMonthDay(monthDay), expected);
1050     }
1051 
1052     @Test(expectedExceptions=NullPointerException.class)
1053     public void test_atMonthDay_nullMonthDay() {
1054         Year test = Year.of(2008);
1055         test.atMonthDay((MonthDay) null);
1056     }
1057 
1058     //-----------------------------------------------------------------------
1059     // atDay(int)
1060     //-----------------------------------------------------------------------
1061     @Test
1062     public void test_atDay_notLeapYear() {
1063         Year test = Year.of(2007);
1064         LocalDate expected = LocalDate.of(2007, 1, 1);
1065         for (int i = 1; i &lt;= 365; i++) {
1066             assertEquals(test.atDay(i), expected);
1067             expected = expected.plusDays(1);
1068         }
1069     }
1070 
1071     @Test(expectedExceptions=DateTimeException.class)
1072     public void test_atDay_notLeapYear_day366() {
1073         Year test = Year.of(2007);
1074         test.atDay(366);
1075     }
1076 
1077     @Test
1078     public void test_atDay_leapYear() {
1079         Year test = Year.of(2008);
1080         LocalDate expected = LocalDate.of(2008, 1, 1);
1081         for (int i = 1; i &lt;= 366; i++) {
1082             assertEquals(test.atDay(i), expected);
1083             expected = expected.plusDays(1);
1084         }
1085     }
1086 
1087     @Test(expectedExceptions=DateTimeException.class)
1088     public void test_atDay_day0() {
1089         Year test = Year.of(2007);
1090         test.atDay(0);
1091     }
1092 
1093     @Test(expectedExceptions=DateTimeException.class)
1094     public void test_atDay_day367() {
1095         Year test = Year.of(2007);
1096         test.atDay(367);
1097     }
1098 
1099     //-----------------------------------------------------------------------
1100     // compareTo()
1101     //-----------------------------------------------------------------------
1102     @Test
1103     public void test_compareTo() {
1104         for (int i = -4; i &lt;= 2104; i++) {
1105             Year a = Year.of(i);
1106             for (int j = -4; j &lt;= 2104; j++) {
1107                 Year b = Year.of(j);
1108                 if (i &lt; j) {
1109                     assertEquals(a.compareTo(b) &lt; 0, true);
1110                     assertEquals(b.compareTo(a) &gt; 0, true);
1111                     assertEquals(a.isAfter(b), false);
1112                     assertEquals(a.isBefore(b), true);
1113                     assertEquals(b.isAfter(a), true);
1114                     assertEquals(b.isBefore(a), false);
1115                 } else if (i &gt; j) {
1116                     assertEquals(a.compareTo(b) &gt; 0, true);
1117                     assertEquals(b.compareTo(a) &lt; 0, true);
1118                     assertEquals(a.isAfter(b), true);
1119                     assertEquals(a.isBefore(b), false);
1120                     assertEquals(b.isAfter(a), false);
1121                     assertEquals(b.isBefore(a), true);
1122                 } else {
1123                     assertEquals(a.compareTo(b), 0);
1124                     assertEquals(b.compareTo(a), 0);
1125                     assertEquals(a.isAfter(b), false);
1126                     assertEquals(a.isBefore(b), false);
1127                     assertEquals(b.isAfter(a), false);
1128                     assertEquals(b.isBefore(a), false);
1129                 }
1130             }
1131         }
1132     }
1133 
1134     @Test(expectedExceptions=NullPointerException.class)
1135     public void test_compareTo_nullYear() {
1136         Year doy = null;
1137         Year test = Year.of(1);
1138         test.compareTo(doy);
1139     }
1140 
1141     //-----------------------------------------------------------------------
1142     // equals() / hashCode()
1143     //-----------------------------------------------------------------------
1144     @Test
1145     public void test_equals() {
1146         for (int i = -4; i &lt;= 2104; i++) {
1147             Year a = Year.of(i);
1148             for (int j = -4; j &lt;= 2104; j++) {
1149                 Year b = Year.of(j);
1150                 assertEquals(a.equals(b), i == j);
1151                 assertEquals(a.hashCode() == b.hashCode(), i == j);
1152             }
1153         }
1154     }
1155 
1156     @Test
1157     public void test_equals_same() {
1158         Year test = Year.of(2011);
1159         assertEquals(test.equals(test), true);
1160     }
1161 
1162     @Test
1163     public void test_equals_nullYear() {
1164         Year doy = null;
1165         Year test = Year.of(1);
1166         assertEquals(test.equals(doy), false);
1167     }
1168 
1169     @Test
1170     public void test_equals_incorrectType() {
1171         Year test = Year.of(1);
1172         assertEquals(test.equals(&quot;Incorrect type&quot;), false);
1173     }
1174 
1175     //-----------------------------------------------------------------------
1176     // toString()
1177     //-----------------------------------------------------------------------
1178     @Test
1179     public void test_toString() {
1180         for (int i = -4; i &lt;= 2104; i++) {
1181             Year a = Year.of(i);
1182             assertEquals(a.toString(), &quot;&quot; + i);
1183         }
1184     }
1185 
1186 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
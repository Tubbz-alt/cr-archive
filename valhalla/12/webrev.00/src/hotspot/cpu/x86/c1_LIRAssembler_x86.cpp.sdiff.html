<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 463     __ bind(*stub-&gt;continuation());
 464   }
 465 
 466   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 467 #ifdef _LP64
 468     __ mov(rdi, r15_thread);
 469     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 470 #else
 471     __ get_thread(rax);
 472     __ movptr(Address(rsp, 0), rax);
 473     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 474 #endif
 475     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 476   }
 477 
 478   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 479     __ mov(rax, rbx);  // Restore the exception
 480   }
 481 
 482   // remove the activation and dispatch to the unwind handler
<span class="line-modified"> 483   __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());</span>

 484   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 485 
 486   // Emit the slow path assembly
 487   if (stub != NULL) {
 488     stub-&gt;emit_code(this);
 489   }
 490 
 491   return offset;
 492 }
 493 
 494 
 495 int LIR_Assembler::emit_deopt_handler() {
 496   // if the last instruction is a call (typically to do a throw which
 497   // is coming at the end after block reordering) the return address
 498   // must still point into the code area in order to avoid assertion
 499   // failures when searching for the corresponding bci =&gt; add a nop
 500   // (was bug 5/14/1999 - gri)
 501   __ nop();
 502 
 503   // generate code for exception handler
</pre>
<hr />
<pre>
 529   ciMethod* method = compilation()-&gt;method();
 530   if (ValueTypeReturnedAsFields &amp;&amp; method-&gt;signature()-&gt;returns_never_null()) {
 531     ciType* return_type = method-&gt;return_type();
 532     if (return_type-&gt;is_valuetype()) {
 533       ciValueKlass* vk = return_type-&gt;as_value_klass();
 534       if (vk-&gt;can_be_returned_as_fields()) {
 535 #ifndef _LP64
 536         Unimplemented();
 537 #else
 538         address unpack_handler = vk-&gt;unpack_handler();
 539         assert(unpack_handler != NULL, &quot;must be&quot;);
 540         __ call(RuntimeAddress(unpack_handler));
 541         // At this point, rax points to the value object (for interpreter or C1 caller).
 542         // The fields of the object are copied into registers (for C2 caller).
 543 #endif
 544       }
 545     }
 546   }
 547 
 548   // Pop the stack before the safepoint code
<span class="line-modified"> 549   __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());</span>

 550 
 551   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 552     __ reserved_stack_check();
 553   }
 554 
 555   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 556 
 557   // Note: we do not need to round double result; float result has the right precision
 558   // the poll sets the condition code, but no data registers
 559 
 560   if (SafepointMechanism::uses_thread_local_poll()) {
 561 #ifdef _LP64
 562     const Register poll_addr = rscratch1;
 563     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 564 #else
 565     const Register poll_addr = rbx;
 566     assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 567     __ get_thread(poll_addr);
 568     __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 569 #endif
</pre>
</td>
<td>
<hr />
<pre>
 463     __ bind(*stub-&gt;continuation());
 464   }
 465 
 466   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 467 #ifdef _LP64
 468     __ mov(rdi, r15_thread);
 469     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 470 #else
 471     __ get_thread(rax);
 472     __ movptr(Address(rsp, 0), rax);
 473     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 474 #endif
 475     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 476   }
 477 
 478   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 479     __ mov(rax, rbx);  // Restore the exception
 480   }
 481 
 482   // remove the activation and dispatch to the unwind handler
<span class="line-modified"> 483   int initial_framesize = initial_frame_size_in_bytes();</span>
<span class="line-added"> 484   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);</span>
 485   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 486 
 487   // Emit the slow path assembly
 488   if (stub != NULL) {
 489     stub-&gt;emit_code(this);
 490   }
 491 
 492   return offset;
 493 }
 494 
 495 
 496 int LIR_Assembler::emit_deopt_handler() {
 497   // if the last instruction is a call (typically to do a throw which
 498   // is coming at the end after block reordering) the return address
 499   // must still point into the code area in order to avoid assertion
 500   // failures when searching for the corresponding bci =&gt; add a nop
 501   // (was bug 5/14/1999 - gri)
 502   __ nop();
 503 
 504   // generate code for exception handler
</pre>
<hr />
<pre>
 530   ciMethod* method = compilation()-&gt;method();
 531   if (ValueTypeReturnedAsFields &amp;&amp; method-&gt;signature()-&gt;returns_never_null()) {
 532     ciType* return_type = method-&gt;return_type();
 533     if (return_type-&gt;is_valuetype()) {
 534       ciValueKlass* vk = return_type-&gt;as_value_klass();
 535       if (vk-&gt;can_be_returned_as_fields()) {
 536 #ifndef _LP64
 537         Unimplemented();
 538 #else
 539         address unpack_handler = vk-&gt;unpack_handler();
 540         assert(unpack_handler != NULL, &quot;must be&quot;);
 541         __ call(RuntimeAddress(unpack_handler));
 542         // At this point, rax points to the value object (for interpreter or C1 caller).
 543         // The fields of the object are copied into registers (for C2 caller).
 544 #endif
 545       }
 546     }
 547   }
 548 
 549   // Pop the stack before the safepoint code
<span class="line-modified"> 550   int initial_framesize = initial_frame_size_in_bytes();</span>
<span class="line-added"> 551   __ remove_frame(initial_framesize, needs_stack_repair(), initial_framesize - wordSize);</span>
 552 
 553   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 554     __ reserved_stack_check();
 555   }
 556 
 557   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 558 
 559   // Note: we do not need to round double result; float result has the right precision
 560   // the poll sets the condition code, but no data registers
 561 
 562   if (SafepointMechanism::uses_thread_local_poll()) {
 563 #ifdef _LP64
 564     const Register poll_addr = rscratch1;
 565     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 566 #else
 567     const Register poll_addr = rbx;
 568     assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 569     __ get_thread(poll_addr);
 570     __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 571 #endif
</pre>
</td>
</tr>
</table>
<center>&lt; prev <a href="../../../../index.html" target="_top">index</a> <a href="c1_MacroAssembler_x86.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
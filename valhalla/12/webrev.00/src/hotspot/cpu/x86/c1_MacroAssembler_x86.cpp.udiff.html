<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/x86/c1_MacroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame_x86.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/c1_MacroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -343,37 +343,22 @@</span>
      empty_FPU_stack();
    }
  #endif // !_LP64 &amp;&amp; TIERED
    decrement(rsp, frame_size_in_bytes); // does not emit code for frame_size == 0
    if (needs_stack_repair) {
<span class="udiff-line-modified-removed">-     int real_frame_size =  frame_size_in_bytes</span>
<span class="udiff-line-modified-removed">-            + wordSize     // skip over pushed rbp</span>
<span class="udiff-line-removed">-            + wordSize;    // skip over RA pushed by caller</span>
<span class="udiff-line-modified-added">+     // Save stack increment (also account for rbp)</span>
<span class="udiff-line-modified-added">+     int real_frame_size = frame_size_in_bytes + wordSize;</span>
      movptr(Address(rsp, frame_size_in_bytes - wordSize), real_frame_size);
      if (verified_value_entry_label != NULL) {
        bind(*verified_value_entry_label);
      }
    }
  
    BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
    bs-&gt;nmethod_entry_barrier(this);
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void C1_MacroAssembler::remove_frame(int frame_size_in_bytes, bool needs_stack_repair) {</span>
<span class="udiff-line-removed">-   if (!needs_stack_repair) {</span>
<span class="udiff-line-removed">-     increment(rsp, frame_size_in_bytes);  // Does not emit code for frame_size == 0</span>
<span class="udiff-line-removed">-     pop(rbp);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     movq(r13, Address(rsp, frame_size_in_bytes + wordSize)); // return address</span>
<span class="udiff-line-removed">-     movq(rbp, Address(rsp, frame_size_in_bytes));</span>
<span class="udiff-line-removed">-     addq(rsp, Address(rsp, frame_size_in_bytes - wordSize)); // now we are back to caller frame, without the outgoing return address</span>
<span class="udiff-line-removed">-     push(r13); // restore the return address, as pushed by caller</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
  void C1_MacroAssembler::verified_entry() {
    if (C1Breakpoint || VerifyFPU || !UseStackBanging) {
      // Verified Entry first instruction should be 5 bytes long for correct
      // patching by patch_verified_entry().
      //
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -405,31 +390,32 @@</span>
    BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sig_cc-&gt;length());
    int args_passed = sig-&gt;length();
    int args_passed_cc = SigEntry::fill_sig_bt(sig_cc, sig_bt);
    int extra_stack_offset = wordSize; // tos is return address.
  
<span class="udiff-line-modified-removed">-   int sp_inc = (args_on_stack - args_on_stack_cc) * VMRegImpl::stack_slot_size;</span>
<span class="udiff-line-modified-removed">-   if (sp_inc &gt; 0) {</span>
<span class="udiff-line-modified-removed">-     pop(r13);</span>
<span class="udiff-line-modified-added">+   // Check if we need to extend the stack for packing</span>
<span class="udiff-line-modified-added">+   int sp_inc = 0;</span>
<span class="udiff-line-modified-added">+   if (args_on_stack &gt; args_on_stack_cc) {</span>
<span class="udiff-line-added">+     // Two additional slots to account for return address</span>
<span class="udiff-line-added">+     sp_inc = (args_on_stack + 2) * VMRegImpl::stack_slot_size;</span>
      sp_inc = align_up(sp_inc, StackAlignmentInBytes);
<span class="udiff-line-added">+     pop(r13); // Copy return address</span>
      subptr(rsp, sp_inc);
      push(r13);
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     sp_inc = 0;</span>
    }
  
<span class="udiff-line-modified-removed">-   // Create a temp frame so we can call into runtime. It must be properly set up to accommodate GC.</span>
<span class="udiff-line-modified-added">+   // Create a temp frame so we can call into the runtime. It must be properly set up to accommodate GC.</span>
    push(rbp);
    if (PreserveFramePointer) {
      mov(rbp, rsp);
    }
    subptr(rsp, frame_size_in_bytes);
<span class="udiff-line-modified-removed">-   if (sp_inc &gt; 0) {</span>
<span class="udiff-line-modified-removed">-     int real_frame_size = frame_size_in_bytes +</span>
<span class="udiff-line-modified-removed">-            + wordSize  // pushed rbp</span>
<span class="udiff-line-modified-removed">-            + wordSize  // return address pushed by the stack extension code</span>
<span class="udiff-line-modified-removed">-            + sp_inc;   // stack extension</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   if (ces-&gt;c1_needs_stack_repair()) {</span>
<span class="udiff-line-modified-added">+     // Save stack increment (also account for fixed framesize and rbp)</span>
<span class="udiff-line-modified-added">+     assert((sp_inc &amp; (StackAlignmentInBytes-1)) == 0, &quot;stack increment not aligned&quot;);</span>
<span class="udiff-line-modified-added">+     int real_frame_size = sp_inc + frame_size_in_bytes + wordSize;</span>
      movptr(Address(rsp, frame_size_in_bytes - wordSize), real_frame_size);
    }
  
    // Initialize orig_pc to detect deoptimization during buffering in below runtime call
    movptr(Address(rsp, sp_offset_for_orig_pc), 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -445,19 +431,17 @@</span>
  
    // Remove the temp frame
    addptr(rsp, frame_size_in_bytes);
    pop(rbp);
  
<span class="udiff-line-modified-removed">-   int n = shuffle_value_args(true, is_value_ro_entry, extra_stack_offset, sig_bt, sig_cc,</span>
<span class="udiff-line-modified-removed">-                              args_passed_cc, args_on_stack_cc, regs_cc, // from</span>
<span class="udiff-line-modified-removed">-                              args_passed, args_on_stack, regs);         // to</span>
<span class="udiff-line-removed">-   assert(sp_inc == n, &quot;must be&quot;);</span>
<span class="udiff-line-modified-added">+   shuffle_value_args(true, is_value_ro_entry, extra_stack_offset, sig_bt, sig_cc,</span>
<span class="udiff-line-modified-added">+                      args_passed_cc, args_on_stack_cc, regs_cc, // from</span>
<span class="udiff-line-modified-added">+                      args_passed, args_on_stack, regs, sp_inc); // to</span>
  
<span class="udiff-line-modified-removed">-   if (sp_inc != 0) {</span>
<span class="udiff-line-modified-added">+   if (ces-&gt;c1_needs_stack_repair()) {</span>
      // Skip over the stack banging and frame setup code in the
      // verified_value_entry (which has a different real_frame_size).
<span class="udiff-line-removed">-     assert(sp_inc &gt; 0, &quot;stack should not shrink&quot;);</span>
      push(rbp);
      if (PreserveFramePointer) {
        mov(rbp, rsp);
      }
  #if !defined(_LP64) &amp;&amp; defined(TIERED)
</pre>
<center><a href="c1_LIRAssembler_x86.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="frame_x86.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
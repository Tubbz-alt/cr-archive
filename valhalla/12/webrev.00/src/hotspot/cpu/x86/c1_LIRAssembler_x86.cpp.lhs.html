<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/c1_LIRAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;ci/ciValueKlass.hpp&quot;
  36 #include &quot;gc/shared/collectedHeap.hpp&quot;
  37 #include &quot;nativeInst_x86.hpp&quot;
  38 #include &quot;oops/oop.inline.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 #include &quot;vmreg_x86.inline.hpp&quot;
  45 
  46 
  47 // These masks are used to provide 128-bit aligned bitmasks to the XMM
  48 // instructions, to allow sign-masking or sign-bit flipping.  They allow
  49 // fast versions of NegF/NegD and AbsF/AbsD.
  50 
  51 // Note: &#39;double&#39; and &#39;long long&#39; have 32-bits alignment on x86.
  52 static jlong* double_quadword(jlong *adr, jlong lo, jlong hi) {
  53   // Use the expression (adr)&amp;(~0xF) to provide 128-bits aligned address
  54   // of 128-bits operands for SSE instructions.
  55   jlong *operand = (jlong*)(((intptr_t)adr) &amp; ((intptr_t)(~0xF)));
  56   // Store the value to a 128-bits operand.
  57   operand[0] = lo;
  58   operand[1] = hi;
  59   return operand;
  60 }
  61 
  62 // Buffer for 128-bits masks used by SSE instructions.
  63 static jlong fp_signmask_pool[(4+1)*2]; // 4*128bits(data) + 128bits(alignment)
  64 
  65 // Static initialization during VM startup.
  66 static jlong *float_signmask_pool  = double_quadword(&amp;fp_signmask_pool[1*2],         CONST64(0x7FFFFFFF7FFFFFFF),         CONST64(0x7FFFFFFF7FFFFFFF));
  67 static jlong *double_signmask_pool = double_quadword(&amp;fp_signmask_pool[2*2],         CONST64(0x7FFFFFFFFFFFFFFF),         CONST64(0x7FFFFFFFFFFFFFFF));
  68 static jlong *float_signflip_pool  = double_quadword(&amp;fp_signmask_pool[3*2], (jlong)UCONST64(0x8000000080000000), (jlong)UCONST64(0x8000000080000000));
  69 static jlong *double_signflip_pool = double_quadword(&amp;fp_signmask_pool[4*2], (jlong)UCONST64(0x8000000000000000), (jlong)UCONST64(0x8000000000000000));
  70 
  71 
  72 NEEDS_CLEANUP // remove this definitions ?
  73 const Register IC_Klass    = rax;   // where the IC klass is cached
  74 const Register SYNC_header = rax;   // synchronization header
  75 const Register SHIFT_count = rcx;   // where count for shift operations must be
  76 
  77 #define __ _masm-&gt;
  78 
  79 
  80 static void select_different_registers(Register preserve,
  81                                        Register extra,
  82                                        Register &amp;tmp1,
  83                                        Register &amp;tmp2) {
  84   if (tmp1 == preserve) {
  85     assert_different_registers(tmp1, tmp2, extra);
  86     tmp1 = extra;
  87   } else if (tmp2 == preserve) {
  88     assert_different_registers(tmp1, tmp2, extra);
  89     tmp2 = extra;
  90   }
  91   assert_different_registers(preserve, tmp1, tmp2);
  92 }
  93 
  94 
  95 
  96 static void select_different_registers(Register preserve,
  97                                        Register extra,
  98                                        Register &amp;tmp1,
  99                                        Register &amp;tmp2,
 100                                        Register &amp;tmp3) {
 101   if (tmp1 == preserve) {
 102     assert_different_registers(tmp1, tmp2, tmp3, extra);
 103     tmp1 = extra;
 104   } else if (tmp2 == preserve) {
 105     assert_different_registers(tmp1, tmp2, tmp3, extra);
 106     tmp2 = extra;
 107   } else if (tmp3 == preserve) {
 108     assert_different_registers(tmp1, tmp2, tmp3, extra);
 109     tmp3 = extra;
 110   }
 111   assert_different_registers(preserve, tmp1, tmp2, tmp3);
 112 }
 113 
 114 
 115 
 116 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
 117   if (opr-&gt;is_constant()) {
 118     LIR_Const* constant = opr-&gt;as_constant_ptr();
 119     switch (constant-&gt;type()) {
 120       case T_INT: {
 121         return true;
 122       }
 123 
 124       default:
 125         return false;
 126     }
 127   }
 128   return false;
 129 }
 130 
 131 
 132 LIR_Opr LIR_Assembler::receiverOpr() {
 133   return FrameMap::receiver_opr;
 134 }
 135 
 136 LIR_Opr LIR_Assembler::osrBufferPointer() {
 137   return FrameMap::as_pointer_opr(receiverOpr()-&gt;as_register());
 138 }
 139 
 140 //--------------fpu register translations-----------------------
 141 
 142 
 143 address LIR_Assembler::float_constant(float f) {
 144   address const_addr = __ float_constant(f);
 145   if (const_addr == NULL) {
 146     bailout(&quot;const section overflow&quot;);
 147     return __ code()-&gt;consts()-&gt;start();
 148   } else {
 149     return const_addr;
 150   }
 151 }
 152 
 153 
 154 address LIR_Assembler::double_constant(double d) {
 155   address const_addr = __ double_constant(d);
 156   if (const_addr == NULL) {
 157     bailout(&quot;const section overflow&quot;);
 158     return __ code()-&gt;consts()-&gt;start();
 159   } else {
 160     return const_addr;
 161   }
 162 }
 163 
 164 #ifndef _LP64
 165 void LIR_Assembler::fpop() {
 166   __ fpop();
 167 }
 168 
 169 void LIR_Assembler::fxch(int i) {
 170   __ fxch(i);
 171 }
 172 
 173 void LIR_Assembler::fld(int i) {
 174   __ fld_s(i);
 175 }
 176 
 177 void LIR_Assembler::ffree(int i) {
 178   __ ffree(i);
 179 }
 180 #endif // !_LP64
 181 
 182 void LIR_Assembler::breakpoint() {
 183   __ int3();
 184 }
 185 
 186 void LIR_Assembler::push(LIR_Opr opr) {
 187   if (opr-&gt;is_single_cpu()) {
 188     __ push_reg(opr-&gt;as_register());
 189   } else if (opr-&gt;is_double_cpu()) {
 190     NOT_LP64(__ push_reg(opr-&gt;as_register_hi()));
 191     __ push_reg(opr-&gt;as_register_lo());
 192   } else if (opr-&gt;is_stack()) {
 193     __ push_addr(frame_map()-&gt;address_for_slot(opr-&gt;single_stack_ix()));
 194   } else if (opr-&gt;is_constant()) {
 195     LIR_Const* const_opr = opr-&gt;as_constant_ptr();
 196     if (const_opr-&gt;type() == T_OBJECT || const_opr-&gt;type() == T_VALUETYPE) {
 197       __ push_oop(const_opr-&gt;as_jobject());
 198     } else if (const_opr-&gt;type() == T_INT) {
 199       __ push_jint(const_opr-&gt;as_jint());
 200     } else {
 201       ShouldNotReachHere();
 202     }
 203 
 204   } else {
 205     ShouldNotReachHere();
 206   }
 207 }
 208 
 209 void LIR_Assembler::pop(LIR_Opr opr) {
 210   if (opr-&gt;is_single_cpu()) {
 211     __ pop_reg(opr-&gt;as_register());
 212   } else {
 213     ShouldNotReachHere();
 214   }
 215 }
 216 
 217 bool LIR_Assembler::is_literal_address(LIR_Address* addr) {
 218   return addr-&gt;base()-&gt;is_illegal() &amp;&amp; addr-&gt;index()-&gt;is_illegal();
 219 }
 220 
 221 //-------------------------------------------
 222 
 223 Address LIR_Assembler::as_Address(LIR_Address* addr) {
 224   return as_Address(addr, rscratch1);
 225 }
 226 
 227 Address LIR_Assembler::as_Address(LIR_Address* addr, Register tmp) {
 228   if (addr-&gt;base()-&gt;is_illegal()) {
 229     assert(addr-&gt;index()-&gt;is_illegal(), &quot;must be illegal too&quot;);
 230     AddressLiteral laddr((address)addr-&gt;disp(), relocInfo::none);
 231     if (! __ reachable(laddr)) {
 232       __ movptr(tmp, laddr.addr());
 233       Address res(tmp, 0);
 234       return res;
 235     } else {
 236       return __ as_Address(laddr);
 237     }
 238   }
 239 
 240   Register base = addr-&gt;base()-&gt;as_pointer_register();
 241 
 242   if (addr-&gt;index()-&gt;is_illegal()) {
 243     return Address( base, addr-&gt;disp());
 244   } else if (addr-&gt;index()-&gt;is_cpu_register()) {
 245     Register index = addr-&gt;index()-&gt;as_pointer_register();
 246     return Address(base, index, (Address::ScaleFactor) addr-&gt;scale(), addr-&gt;disp());
 247   } else if (addr-&gt;index()-&gt;is_constant()) {
 248     intptr_t addr_offset = (addr-&gt;index()-&gt;as_constant_ptr()-&gt;as_jint() &lt;&lt; addr-&gt;scale()) + addr-&gt;disp();
 249     assert(Assembler::is_simm32(addr_offset), &quot;must be&quot;);
 250 
 251     return Address(base, addr_offset);
 252   } else {
 253     Unimplemented();
 254     return Address();
 255   }
 256 }
 257 
 258 
 259 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
 260   Address base = as_Address(addr);
 261   return Address(base._base, base._index, base._scale, base._disp + BytesPerWord);
 262 }
 263 
 264 
 265 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
 266   return as_Address(addr);
 267 }
 268 
 269 
 270 void LIR_Assembler::osr_entry() {
 271   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 272   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 273   ValueStack* entry_state = osr_entry-&gt;state();
 274   int number_of_locks = entry_state-&gt;locks_size();
 275 
 276   // we jump here if osr happens with the interpreter
 277   // state set up to continue at the beginning of the
 278   // loop that triggered osr - in particular, we have
 279   // the following registers setup:
 280   //
 281   // rcx: osr buffer
 282   //
 283 
 284   // build frame
 285   ciMethod* m = compilation()-&gt;method();
 286   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 287 
 288   // OSR buffer is
 289   //
 290   // locals[nlocals-1..0]
 291   // monitors[0..number_of_locks]
 292   //
 293   // locals is a direct copy of the interpreter frame so in the osr buffer
 294   // so first slot in the local array is the last local from the interpreter
 295   // and last slot is local[0] (receiver) from the interpreter
 296   //
 297   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 298   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 299   // in the interpreter frame (the method lock if a sync method)
 300 
 301   // Initialize monitors in the compiled activation.
 302   //   rcx: pointer to osr buffer
 303   //
 304   // All other registers are dead at this point and the locals will be
 305   // copied into place by code emitted in the IR.
 306 
 307   Register OSR_buf = osrBufferPointer()-&gt;as_pointer_register();
 308   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 309     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 310       (BasicObjectLock::size() * BytesPerWord) * (number_of_locks - 1);
 311     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 312     // the OSR buffer using 2 word entries: first the lock and then
 313     // the oop.
 314     for (int i = 0; i &lt; number_of_locks; i++) {
 315       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 316 #ifdef ASSERT
 317       // verify the interpreter&#39;s monitor has a non-null object
 318       {
 319         Label L;
 320         __ cmpptr(Address(OSR_buf, slot_offset + 1*BytesPerWord), (int32_t)NULL_WORD);
 321         __ jcc(Assembler::notZero, L);
 322         __ stop(&quot;locked object is NULL&quot;);
 323         __ bind(L);
 324       }
 325 #endif
 326       __ movptr(rbx, Address(OSR_buf, slot_offset + 0));
 327       __ movptr(frame_map()-&gt;address_for_monitor_lock(i), rbx);
 328       __ movptr(rbx, Address(OSR_buf, slot_offset + 1*BytesPerWord));
 329       __ movptr(frame_map()-&gt;address_for_monitor_object(i), rbx);
 330     }
 331   }
 332 }
 333 
 334 
 335 // inline cache check; done before the frame is built.
 336 int LIR_Assembler::check_icache() {
 337   Register receiver = FrameMap::receiver_opr-&gt;as_register();
 338   Register ic_klass = IC_Klass;
 339   const int ic_cmp_size = LP64_ONLY(10) NOT_LP64(9);
 340   const bool do_post_padding = VerifyOops || UseCompressedClassPointers;
 341   if (!do_post_padding) {
 342     // insert some nops so that the verified entry point is aligned on CodeEntryAlignment
 343     __ align(CodeEntryAlignment, __ offset() + ic_cmp_size);
 344   }
 345   int offset = __ offset();
 346   __ inline_cache_check(receiver, IC_Klass);
 347   assert(__ offset() % CodeEntryAlignment == 0 || do_post_padding, &quot;alignment must be correct&quot;);
 348   if (do_post_padding) {
 349     // force alignment after the cache check.
 350     // It&#39;s been verified to be aligned if !VerifyOops
 351     __ align(CodeEntryAlignment);
 352   }
 353   return offset;
 354 }
 355 
 356 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 357   assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
 358   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 359 
 360   Label L_skip_barrier;
 361   Register klass = rscratch1;
 362   Register thread = LP64_ONLY( r15_thread ) NOT_LP64( noreg );
 363   assert(thread != noreg, &quot;x86_32 not implemented&quot;);
 364 
 365   __ mov_metadata(klass, method-&gt;holder()-&gt;constant_encoding());
 366   __ clinit_barrier(klass, thread, &amp;L_skip_barrier /*L_fast_path*/);
 367 
 368   __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));
 369 
 370   __ bind(L_skip_barrier);
 371 }
 372 
 373 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo* info) {
 374   jobject o = NULL;
 375   PatchingStub* patch = new PatchingStub(_masm, patching_id(info));
 376   __ movoop(reg, o);
 377   patching_epilog(patch, lir_patch_normal, reg, info);
 378 }
 379 
 380 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo* info) {
 381   Metadata* o = NULL;
 382   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id);
 383   __ mov_metadata(reg, o);
 384   patching_epilog(patch, lir_patch_normal, reg, info);
 385 }
 386 
 387 // This specifies the rsp decrement needed to build the frame
 388 int LIR_Assembler::initial_frame_size_in_bytes() const {
 389   // if rounding, must let FrameMap know!
 390 
 391   // The frame_map records size in slots (32bit word)
 392 
 393   // subtract two words to account for return address and link
 394   return (frame_map()-&gt;framesize() - (2*VMRegImpl::slots_per_word))  * VMRegImpl::stack_slot_size;
 395 }
 396 
 397 
 398 int LIR_Assembler::emit_exception_handler() {
 399   // if the last instruction is a call (typically to do a throw which
 400   // is coming at the end after block reordering) the return address
 401   // must still point into the code area in order to avoid assertion
 402   // failures when searching for the corresponding bci =&gt; add a nop
 403   // (was bug 5/14/1999 - gri)
 404   __ nop();
 405 
 406   // generate code for exception handler
 407   address handler_base = __ start_a_stub(exception_handler_size());
 408   if (handler_base == NULL) {
 409     // not enough space left for the handler
 410     bailout(&quot;exception handler overflow&quot;);
 411     return -1;
 412   }
 413 
 414   int offset = code_offset();
 415 
 416   // the exception oop and pc are in rax, and rdx
 417   // no other registers need to be preserved, so invalidate them
 418   __ invalidate_registers(false, true, true, false, true, true);
 419 
 420   // check that there is really an exception
 421   __ verify_not_null_oop(rax);
 422 
 423   // search an exception handler (rax: exception oop, rdx: throwing pc)
 424   __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id)));
 425   __ should_not_reach_here();
 426   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 427   __ end_a_stub();
 428 
 429   return offset;
 430 }
 431 
 432 
 433 // Emit the code to remove the frame from the stack in the exception
 434 // unwind path.
 435 int LIR_Assembler::emit_unwind_handler() {
 436 #ifndef PRODUCT
 437   if (CommentedAssembly) {
 438     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 439   }
 440 #endif
 441 
 442   int offset = code_offset();
 443 
 444   // Fetch the exception from TLS and clear out exception related thread state
 445   Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
 446   NOT_LP64(__ get_thread(rsi));
 447   __ movptr(rax, Address(thread, JavaThread::exception_oop_offset()));
 448   __ movptr(Address(thread, JavaThread::exception_oop_offset()), (intptr_t)NULL_WORD);
 449   __ movptr(Address(thread, JavaThread::exception_pc_offset()), (intptr_t)NULL_WORD);
 450 
 451   __ bind(_unwind_handler_entry);
 452   __ verify_not_null_oop(rax);
 453   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 454     __ mov(rbx, rax);  // Preserve the exception (rbx is always callee-saved)
 455   }
 456 
 457   // Preform needed unlocking
 458   MonitorExitStub* stub = NULL;
 459   if (method()-&gt;is_synchronized()) {
 460     monitor_address(0, FrameMap::rax_opr);
 461     stub = new MonitorExitStub(FrameMap::rax_opr, true, 0);
 462     __ unlock_object(rdi, rsi, rax, *stub-&gt;entry());
 463     __ bind(*stub-&gt;continuation());
 464   }
 465 
 466   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 467 #ifdef _LP64
 468     __ mov(rdi, r15_thread);
 469     __ mov_metadata(rsi, method()-&gt;constant_encoding());
 470 #else
 471     __ get_thread(rax);
 472     __ movptr(Address(rsp, 0), rax);
 473     __ mov_metadata(Address(rsp, sizeof(void*)), method()-&gt;constant_encoding());
 474 #endif
 475     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit)));
 476   }
 477 
 478   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 479     __ mov(rax, rbx);  // Restore the exception
 480   }
 481 
 482   // remove the activation and dispatch to the unwind handler
<a name="1" id="anc1"></a><span class="line-modified"> 483   __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());</span>

 484   __ jump(RuntimeAddress(Runtime1::entry_for(Runtime1::unwind_exception_id)));
 485 
 486   // Emit the slow path assembly
 487   if (stub != NULL) {
 488     stub-&gt;emit_code(this);
 489   }
 490 
 491   return offset;
 492 }
 493 
 494 
 495 int LIR_Assembler::emit_deopt_handler() {
 496   // if the last instruction is a call (typically to do a throw which
 497   // is coming at the end after block reordering) the return address
 498   // must still point into the code area in order to avoid assertion
 499   // failures when searching for the corresponding bci =&gt; add a nop
 500   // (was bug 5/14/1999 - gri)
 501   __ nop();
 502 
 503   // generate code for exception handler
 504   address handler_base = __ start_a_stub(deopt_handler_size());
 505   if (handler_base == NULL) {
 506     // not enough space left for the handler
 507     bailout(&quot;deopt handler overflow&quot;);
 508     return -1;
 509   }
 510 
 511   int offset = code_offset();
 512   InternalAddress here(__ pc());
 513 
 514   __ pushptr(here.addr());
 515   __ jump(RuntimeAddress(SharedRuntime::deopt_blob()-&gt;unpack()));
 516   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 517   __ end_a_stub();
 518 
 519   return offset;
 520 }
 521 
 522 
 523 void LIR_Assembler::return_op(LIR_Opr result) {
 524   assert(result-&gt;is_illegal() || !result-&gt;is_single_cpu() || result-&gt;as_register() == rax, &quot;word returns are in rax,&quot;);
 525   if (!result-&gt;is_illegal() &amp;&amp; result-&gt;is_float_kind() &amp;&amp; !result-&gt;is_xmm_register()) {
 526     assert(result-&gt;fpu() == 0, &quot;result must already be on TOS&quot;);
 527   }
 528 
 529   ciMethod* method = compilation()-&gt;method();
 530   if (ValueTypeReturnedAsFields &amp;&amp; method-&gt;signature()-&gt;returns_never_null()) {
 531     ciType* return_type = method-&gt;return_type();
 532     if (return_type-&gt;is_valuetype()) {
 533       ciValueKlass* vk = return_type-&gt;as_value_klass();
 534       if (vk-&gt;can_be_returned_as_fields()) {
 535 #ifndef _LP64
 536         Unimplemented();
 537 #else
 538         address unpack_handler = vk-&gt;unpack_handler();
 539         assert(unpack_handler != NULL, &quot;must be&quot;);
 540         __ call(RuntimeAddress(unpack_handler));
 541         // At this point, rax points to the value object (for interpreter or C1 caller).
 542         // The fields of the object are copied into registers (for C2 caller).
 543 #endif
 544       }
 545     }
 546   }
 547 
 548   // Pop the stack before the safepoint code
<a name="2" id="anc2"></a><span class="line-modified"> 549   __ remove_frame(initial_frame_size_in_bytes(), needs_stack_repair());</span>

 550 
 551   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
 552     __ reserved_stack_check();
 553   }
 554 
 555   bool result_is_oop = result-&gt;is_valid() ? result-&gt;is_oop() : false;
 556 
 557   // Note: we do not need to round double result; float result has the right precision
 558   // the poll sets the condition code, but no data registers
 559 
 560   if (SafepointMechanism::uses_thread_local_poll()) {
 561 #ifdef _LP64
 562     const Register poll_addr = rscratch1;
 563     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 564 #else
 565     const Register poll_addr = rbx;
 566     assert(FrameMap::is_caller_save_register(poll_addr), &quot;will overwrite&quot;);
 567     __ get_thread(poll_addr);
 568     __ movptr(poll_addr, Address(poll_addr, Thread::polling_page_offset()));
 569 #endif
 570     __ relocate(relocInfo::poll_return_type);
 571     __ testl(rax, Address(poll_addr, 0));
 572   } else {
 573     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 574 
 575     if (Assembler::is_polling_page_far()) {
 576       __ lea(rscratch1, polling_page);
 577       __ relocate(relocInfo::poll_return_type);
 578       __ testl(rax, Address(rscratch1, 0));
 579     } else {
 580       __ testl(rax, polling_page);
 581     }
 582   }
 583   __ ret(0);
 584 }
 585 
 586 
 587 int LIR_Assembler::store_value_type_fields_to_buf(ciValueKlass* vk) {
 588   return (__ store_value_type_fields_to_buf(vk, false));
 589 }
 590 
 591 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
 592   guarantee(info != NULL, &quot;Shouldn&#39;t be NULL&quot;);
 593   int offset = __ offset();
 594   if (SafepointMechanism::uses_thread_local_poll()) {
 595 #ifdef _LP64
 596     const Register poll_addr = rscratch1;
 597     __ movptr(poll_addr, Address(r15_thread, Thread::polling_page_offset()));
 598 #else
 599     assert(tmp-&gt;is_cpu_register(), &quot;needed&quot;);
 600     const Register poll_addr = tmp-&gt;as_register();
 601     __ get_thread(poll_addr);
 602     __ movptr(poll_addr, Address(poll_addr, in_bytes(Thread::polling_page_offset())));
 603 #endif
 604     add_debug_info_for_branch(info);
 605     __ relocate(relocInfo::poll_type);
 606     address pre_pc = __ pc();
 607     __ testl(rax, Address(poll_addr, 0));
 608     address post_pc = __ pc();
 609     guarantee(pointer_delta(post_pc, pre_pc, 1) == 2 LP64_ONLY(+1), &quot;must be exact length&quot;);
 610   } else {
 611     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_type);
 612     if (Assembler::is_polling_page_far()) {
 613       __ lea(rscratch1, polling_page);
 614       offset = __ offset();
 615       add_debug_info_for_branch(info);
 616       __ relocate(relocInfo::poll_type);
 617       __ testl(rax, Address(rscratch1, 0));
 618     } else {
 619       add_debug_info_for_branch(info);
 620       __ testl(rax, polling_page);
 621     }
 622   }
 623   return offset;
 624 }
 625 
 626 
 627 void LIR_Assembler::move_regs(Register from_reg, Register to_reg) {
 628   if (from_reg != to_reg) __ mov(to_reg, from_reg);
 629 }
 630 
 631 void LIR_Assembler::swap_reg(Register a, Register b) {
 632   __ xchgptr(a, b);
 633 }
 634 
 635 
 636 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 637   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 638   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 639   LIR_Const* c = src-&gt;as_constant_ptr();
 640 
 641   switch (c-&gt;type()) {
 642     case T_INT: {
 643       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 644       __ movl(dest-&gt;as_register(), c-&gt;as_jint());
 645       break;
 646     }
 647 
 648     case T_ADDRESS: {
 649       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 650       __ movptr(dest-&gt;as_register(), c-&gt;as_jint());
 651       break;
 652     }
 653 
 654     case T_LONG: {
 655       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 656 #ifdef _LP64
 657       __ movptr(dest-&gt;as_register_lo(), (intptr_t)c-&gt;as_jlong());
 658 #else
 659       __ movptr(dest-&gt;as_register_lo(), c-&gt;as_jint_lo());
 660       __ movptr(dest-&gt;as_register_hi(), c-&gt;as_jint_hi());
 661 #endif // _LP64
 662       break;
 663     }
 664 
 665     case T_VALUETYPE: // Fall through
 666     case T_OBJECT: {
 667       if (patch_code != lir_patch_none) {
 668         jobject2reg_with_patching(dest-&gt;as_register(), info);
 669       } else {
 670         __ movoop(dest-&gt;as_register(), c-&gt;as_jobject());
 671       }
 672       break;
 673     }
 674 
 675     case T_METADATA: {
 676       if (patch_code != lir_patch_none) {
 677         klass2reg_with_patching(dest-&gt;as_register(), info);
 678       } else {
 679         __ mov_metadata(dest-&gt;as_register(), c-&gt;as_metadata());
 680       }
 681       break;
 682     }
 683 
 684     case T_FLOAT: {
 685       if (dest-&gt;is_single_xmm()) {
 686         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_float()) {
 687           __ xorps(dest-&gt;as_xmm_float_reg(), dest-&gt;as_xmm_float_reg());
 688         } else {
 689           __ movflt(dest-&gt;as_xmm_float_reg(),
 690                    InternalAddress(float_constant(c-&gt;as_jfloat())));
 691         }
 692       } else {
 693 #ifndef _LP64
 694         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
 695         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
 696         if (c-&gt;is_zero_float()) {
 697           __ fldz();
 698         } else if (c-&gt;is_one_float()) {
 699           __ fld1();
 700         } else {
 701           __ fld_s (InternalAddress(float_constant(c-&gt;as_jfloat())));
 702         }
 703 #else
 704         ShouldNotReachHere();
 705 #endif // !_LP64
 706       }
 707       break;
 708     }
 709 
 710     case T_DOUBLE: {
 711       if (dest-&gt;is_double_xmm()) {
 712         if (LP64_ONLY(UseAVX &lt;= 2 &amp;&amp;) c-&gt;is_zero_double()) {
 713           __ xorpd(dest-&gt;as_xmm_double_reg(), dest-&gt;as_xmm_double_reg());
 714         } else {
 715           __ movdbl(dest-&gt;as_xmm_double_reg(),
 716                     InternalAddress(double_constant(c-&gt;as_jdouble())));
 717         }
 718       } else {
 719 #ifndef _LP64
 720         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
 721         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
 722         if (c-&gt;is_zero_double()) {
 723           __ fldz();
 724         } else if (c-&gt;is_one_double()) {
 725           __ fld1();
 726         } else {
 727           __ fld_d (InternalAddress(double_constant(c-&gt;as_jdouble())));
 728         }
 729 #else
 730         ShouldNotReachHere();
 731 #endif // !_LP64
 732       }
 733       break;
 734     }
 735 
 736     default:
 737       ShouldNotReachHere();
 738   }
 739 }
 740 
 741 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 742   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 743   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 744   LIR_Const* c = src-&gt;as_constant_ptr();
 745 
 746   switch (c-&gt;type()) {
 747     case T_INT:  // fall through
 748     case T_FLOAT:
 749       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 750       break;
 751 
 752     case T_ADDRESS:
 753       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jint_bits());
 754       break;
 755 
 756     case T_VALUETYPE: // Fall through
 757     case T_OBJECT:
 758       __ movoop(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), c-&gt;as_jobject());
 759       break;
 760 
 761     case T_LONG:  // fall through
 762     case T_DOUBLE:
 763 #ifdef _LP64
 764       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 765                                             lo_word_offset_in_bytes), (intptr_t)c-&gt;as_jlong_bits());
 766 #else
 767       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 768                                               lo_word_offset_in_bytes), c-&gt;as_jint_lo_bits());
 769       __ movptr(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(),
 770                                               hi_word_offset_in_bytes), c-&gt;as_jint_hi_bits());
 771 #endif // _LP64
 772       break;
 773 
 774     default:
 775       ShouldNotReachHere();
 776   }
 777 }
 778 
 779 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 780   assert(src-&gt;is_constant(), &quot;should not call otherwise&quot;);
 781   assert(dest-&gt;is_address(), &quot;should not call otherwise&quot;);
 782   LIR_Const* c = src-&gt;as_constant_ptr();
 783   LIR_Address* addr = dest-&gt;as_address_ptr();
 784 
 785   int null_check_here = code_offset();
 786   switch (type) {
 787     case T_INT:    // fall through
 788     case T_FLOAT:
 789       __ movl(as_Address(addr), c-&gt;as_jint_bits());
 790       break;
 791 
 792     case T_ADDRESS:
 793       __ movptr(as_Address(addr), c-&gt;as_jint_bits());
 794       break;
 795 
 796     case T_VALUETYPE: // fall through
 797     case T_OBJECT:  // fall through
 798     case T_ARRAY:
 799       if (c-&gt;as_jobject() == NULL) {
 800         if (UseCompressedOops &amp;&amp; !wide) {
 801           __ movl(as_Address(addr), (int32_t)NULL_WORD);
 802         } else {
 803 #ifdef _LP64
 804           __ xorptr(rscratch1, rscratch1);
 805           null_check_here = code_offset();
 806           __ movptr(as_Address(addr), rscratch1);
 807 #else
 808           __ movptr(as_Address(addr), NULL_WORD);
 809 #endif
 810         }
 811       } else {
 812         if (is_literal_address(addr)) {
 813           ShouldNotReachHere();
 814           __ movoop(as_Address(addr, noreg), c-&gt;as_jobject());
 815         } else {
 816 #ifdef _LP64
 817           __ movoop(rscratch1, c-&gt;as_jobject());
 818           if (UseCompressedOops &amp;&amp; !wide) {
 819             __ encode_heap_oop(rscratch1);
 820             null_check_here = code_offset();
 821             __ movl(as_Address_lo(addr), rscratch1);
 822           } else {
 823             null_check_here = code_offset();
 824             __ movptr(as_Address_lo(addr), rscratch1);
 825           }
 826 #else
 827           __ movoop(as_Address(addr), c-&gt;as_jobject());
 828 #endif
 829         }
 830       }
 831       break;
 832 
 833     case T_LONG:    // fall through
 834     case T_DOUBLE:
 835 #ifdef _LP64
 836       if (is_literal_address(addr)) {
 837         ShouldNotReachHere();
 838         __ movptr(as_Address(addr, r15_thread), (intptr_t)c-&gt;as_jlong_bits());
 839       } else {
 840         __ movptr(r10, (intptr_t)c-&gt;as_jlong_bits());
 841         null_check_here = code_offset();
 842         __ movptr(as_Address_lo(addr), r10);
 843       }
 844 #else
 845       // Always reachable in 32bit so this doesn&#39;t produce useless move literal
 846       __ movptr(as_Address_hi(addr), c-&gt;as_jint_hi_bits());
 847       __ movptr(as_Address_lo(addr), c-&gt;as_jint_lo_bits());
 848 #endif // _LP64
 849       break;
 850 
 851     case T_BOOLEAN: // fall through
 852     case T_BYTE:
 853       __ movb(as_Address(addr), c-&gt;as_jint() &amp; 0xFF);
 854       break;
 855 
 856     case T_CHAR:    // fall through
 857     case T_SHORT:
 858       __ movw(as_Address(addr), c-&gt;as_jint() &amp; 0xFFFF);
 859       break;
 860 
 861     default:
 862       ShouldNotReachHere();
 863   };
 864 
 865   if (info != NULL) {
 866     add_debug_info_for_null_check(null_check_here, info);
 867   }
 868 }
 869 
 870 
 871 void LIR_Assembler::reg2reg(LIR_Opr src, LIR_Opr dest) {
 872   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 873   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
 874 
 875   // move between cpu-registers
 876   if (dest-&gt;is_single_cpu()) {
 877 #ifdef _LP64
 878     if (src-&gt;type() == T_LONG) {
 879       // Can do LONG -&gt; OBJECT
 880       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
 881       return;
 882     }
 883 #endif
 884     assert(src-&gt;is_single_cpu(), &quot;must match&quot;);
 885     if (src-&gt;type() == T_OBJECT || src-&gt;type() == T_VALUETYPE) {
 886       __ verify_oop(src-&gt;as_register());
 887     }
 888     move_regs(src-&gt;as_register(), dest-&gt;as_register());
 889 
 890   } else if (dest-&gt;is_double_cpu()) {
 891 #ifdef _LP64
 892     if (is_reference_type(src-&gt;type())) {
 893       // Surprising to me but we can see move of a long to t_object
 894       __ verify_oop(src-&gt;as_register());
 895       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
 896       return;
 897     }
 898 #endif
 899     assert(src-&gt;is_double_cpu(), &quot;must match&quot;);
 900     Register f_lo = src-&gt;as_register_lo();
 901     Register f_hi = src-&gt;as_register_hi();
 902     Register t_lo = dest-&gt;as_register_lo();
 903     Register t_hi = dest-&gt;as_register_hi();
 904 #ifdef _LP64
 905     assert(f_hi == f_lo, &quot;must be same&quot;);
 906     assert(t_hi == t_lo, &quot;must be same&quot;);
 907     move_regs(f_lo, t_lo);
 908 #else
 909     assert(f_lo != f_hi &amp;&amp; t_lo != t_hi, &quot;invalid register allocation&quot;);
 910 
 911 
 912     if (f_lo == t_hi &amp;&amp; f_hi == t_lo) {
 913       swap_reg(f_lo, f_hi);
 914     } else if (f_hi == t_lo) {
 915       assert(f_lo != t_hi, &quot;overwriting register&quot;);
 916       move_regs(f_hi, t_hi);
 917       move_regs(f_lo, t_lo);
 918     } else {
 919       assert(f_hi != t_lo, &quot;overwriting register&quot;);
 920       move_regs(f_lo, t_lo);
 921       move_regs(f_hi, t_hi);
 922     }
 923 #endif // LP64
 924 
 925 #ifndef _LP64
 926     // special moves from fpu-register to xmm-register
 927     // necessary for method results
 928   } else if (src-&gt;is_single_xmm() &amp;&amp; !dest-&gt;is_single_xmm()) {
 929     __ movflt(Address(rsp, 0), src-&gt;as_xmm_float_reg());
 930     __ fld_s(Address(rsp, 0));
 931   } else if (src-&gt;is_double_xmm() &amp;&amp; !dest-&gt;is_double_xmm()) {
 932     __ movdbl(Address(rsp, 0), src-&gt;as_xmm_double_reg());
 933     __ fld_d(Address(rsp, 0));
 934   } else if (dest-&gt;is_single_xmm() &amp;&amp; !src-&gt;is_single_xmm()) {
 935     __ fstp_s(Address(rsp, 0));
 936     __ movflt(dest-&gt;as_xmm_float_reg(), Address(rsp, 0));
 937   } else if (dest-&gt;is_double_xmm() &amp;&amp; !src-&gt;is_double_xmm()) {
 938     __ fstp_d(Address(rsp, 0));
 939     __ movdbl(dest-&gt;as_xmm_double_reg(), Address(rsp, 0));
 940 #endif // !_LP64
 941 
 942     // move between xmm-registers
 943   } else if (dest-&gt;is_single_xmm()) {
 944     assert(src-&gt;is_single_xmm(), &quot;must match&quot;);
 945     __ movflt(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_float_reg());
 946   } else if (dest-&gt;is_double_xmm()) {
 947     assert(src-&gt;is_double_xmm(), &quot;must match&quot;);
 948     __ movdbl(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_double_reg());
 949 
 950 #ifndef _LP64
 951     // move between fpu-registers (no instruction necessary because of fpu-stack)
 952   } else if (dest-&gt;is_single_fpu() || dest-&gt;is_double_fpu()) {
 953     assert(src-&gt;is_single_fpu() || src-&gt;is_double_fpu(), &quot;must match&quot;);
 954     assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;currently should be nothing to do&quot;);
 955 #endif // !_LP64
 956 
 957   } else {
 958     ShouldNotReachHere();
 959   }
 960 }
 961 
 962 void LIR_Assembler::reg2stack(LIR_Opr src, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
 963   assert(src-&gt;is_register(), &quot;should not call otherwise&quot;);
 964   assert(dest-&gt;is_stack(), &quot;should not call otherwise&quot;);
 965 
 966   if (src-&gt;is_single_cpu()) {
 967     Address dst = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 968     if (is_reference_type(type)) {
 969       __ verify_oop(src-&gt;as_register());
 970       __ movptr (dst, src-&gt;as_register());
 971     } else if (type == T_METADATA || type == T_ADDRESS) {
 972       __ movptr (dst, src-&gt;as_register());
 973     } else {
 974       __ movl (dst, src-&gt;as_register());
 975     }
 976 
 977   } else if (src-&gt;is_double_cpu()) {
 978     Address dstLO = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), lo_word_offset_in_bytes);
 979     Address dstHI = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), hi_word_offset_in_bytes);
 980     __ movptr (dstLO, src-&gt;as_register_lo());
 981     NOT_LP64(__ movptr (dstHI, src-&gt;as_register_hi()));
 982 
 983   } else if (src-&gt;is_single_xmm()) {
 984     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 985     __ movflt(dst_addr, src-&gt;as_xmm_float_reg());
 986 
 987   } else if (src-&gt;is_double_xmm()) {
 988     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
 989     __ movdbl(dst_addr, src-&gt;as_xmm_double_reg());
 990 
 991 #ifndef _LP64
 992   } else if (src-&gt;is_single_fpu()) {
 993     assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
 994     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 995     if (pop_fpu_stack)     __ fstp_s (dst_addr);
 996     else                   __ fst_s  (dst_addr);
 997 
 998   } else if (src-&gt;is_double_fpu()) {
 999     assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1000     Address dst_addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1001     if (pop_fpu_stack)     __ fstp_d (dst_addr);
1002     else                   __ fst_d  (dst_addr);
1003 #endif // !_LP64
1004 
1005   } else {
1006     ShouldNotReachHere();
1007   }
1008 }
1009 
1010 
1011 void LIR_Assembler::reg2mem(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack, bool wide, bool /* unaligned */) {
1012   LIR_Address* to_addr = dest-&gt;as_address_ptr();
1013   PatchingStub* patch = NULL;
1014   Register compressed_src = rscratch1;
1015 
1016   if (is_reference_type(type)) {
1017     __ verify_oop(src-&gt;as_register());
1018 #ifdef _LP64
1019     if (UseCompressedOops &amp;&amp; !wide) {
1020       __ movptr(compressed_src, src-&gt;as_register());
1021       __ encode_heap_oop(compressed_src);
1022       if (patch_code != lir_patch_none) {
1023         info-&gt;oop_map()-&gt;set_narrowoop(compressed_src-&gt;as_VMReg());
1024       }
1025     }
1026 #endif
1027   }
1028 
1029   if (patch_code != lir_patch_none) {
1030     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1031     Address toa = as_Address(to_addr);
1032     assert(toa.disp() != 0, &quot;must have&quot;);
1033   }
1034 
1035   int null_check_here = code_offset();
1036   switch (type) {
1037     case T_FLOAT: {
1038 #ifdef _LP64
1039       assert(src-&gt;is_single_xmm(), &quot;not a float&quot;);
1040       __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1041 #else
1042       if (src-&gt;is_single_xmm()) {
1043         __ movflt(as_Address(to_addr), src-&gt;as_xmm_float_reg());
1044       } else {
1045         assert(src-&gt;is_single_fpu(), &quot;must be&quot;);
1046         assert(src-&gt;fpu_regnr() == 0, &quot;argument must be on TOS&quot;);
1047         if (pop_fpu_stack)      __ fstp_s(as_Address(to_addr));
1048         else                    __ fst_s (as_Address(to_addr));
1049       }
1050 #endif // _LP64
1051       break;
1052     }
1053 
1054     case T_DOUBLE: {
1055 #ifdef _LP64
1056       assert(src-&gt;is_double_xmm(), &quot;not a double&quot;);
1057       __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1058 #else
1059       if (src-&gt;is_double_xmm()) {
1060         __ movdbl(as_Address(to_addr), src-&gt;as_xmm_double_reg());
1061       } else {
1062         assert(src-&gt;is_double_fpu(), &quot;must be&quot;);
1063         assert(src-&gt;fpu_regnrLo() == 0, &quot;argument must be on TOS&quot;);
1064         if (pop_fpu_stack)      __ fstp_d(as_Address(to_addr));
1065         else                    __ fst_d (as_Address(to_addr));
1066       }
1067 #endif // _LP64
1068       break;
1069     }
1070 
1071     case T_VALUETYPE: // fall through
1072     case T_ARRAY:   // fall through
1073     case T_OBJECT:  // fall through
1074       if (UseCompressedOops &amp;&amp; !wide) {
1075         __ movl(as_Address(to_addr), compressed_src);
1076       } else {
1077         __ movptr(as_Address(to_addr), src-&gt;as_register());
1078       }
1079       break;
1080     case T_METADATA:
1081       // We get here to store a method pointer to the stack to pass to
1082       // a dtrace runtime call. This can&#39;t work on 64 bit with
1083       // compressed klass ptrs: T_METADATA can be a compressed klass
1084       // ptr or a 64 bit method pointer.
1085       LP64_ONLY(ShouldNotReachHere());
1086       __ movptr(as_Address(to_addr), src-&gt;as_register());
1087       break;
1088     case T_ADDRESS:
1089       __ movptr(as_Address(to_addr), src-&gt;as_register());
1090       break;
1091     case T_INT:
1092       __ movl(as_Address(to_addr), src-&gt;as_register());
1093       break;
1094 
1095     case T_LONG: {
1096       Register from_lo = src-&gt;as_register_lo();
1097       Register from_hi = src-&gt;as_register_hi();
1098 #ifdef _LP64
1099       __ movptr(as_Address_lo(to_addr), from_lo);
1100 #else
1101       Register base = to_addr-&gt;base()-&gt;as_register();
1102       Register index = noreg;
1103       if (to_addr-&gt;index()-&gt;is_register()) {
1104         index = to_addr-&gt;index()-&gt;as_register();
1105       }
1106       if (base == from_lo || index == from_lo) {
1107         assert(base != from_hi, &quot;can&#39;t be&quot;);
1108         assert(index == noreg || (index != base &amp;&amp; index != from_hi), &quot;can&#39;t handle this&quot;);
1109         __ movl(as_Address_hi(to_addr), from_hi);
1110         if (patch != NULL) {
1111           patching_epilog(patch, lir_patch_high, base, info);
1112           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1113           patch_code = lir_patch_low;
1114         }
1115         __ movl(as_Address_lo(to_addr), from_lo);
1116       } else {
1117         assert(index == noreg || (index != base &amp;&amp; index != from_lo), &quot;can&#39;t handle this&quot;);
1118         __ movl(as_Address_lo(to_addr), from_lo);
1119         if (patch != NULL) {
1120           patching_epilog(patch, lir_patch_low, base, info);
1121           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1122           patch_code = lir_patch_high;
1123         }
1124         __ movl(as_Address_hi(to_addr), from_hi);
1125       }
1126 #endif // _LP64
1127       break;
1128     }
1129 
1130     case T_BYTE:    // fall through
1131     case T_BOOLEAN: {
1132       Register src_reg = src-&gt;as_register();
1133       Address dst_addr = as_Address(to_addr);
1134       assert(VM_Version::is_P6() || src_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1135       __ movb(dst_addr, src_reg);
1136       break;
1137     }
1138 
1139     case T_CHAR:    // fall through
1140     case T_SHORT:
1141       __ movw(as_Address(to_addr), src-&gt;as_register());
1142       break;
1143 
1144     default:
1145       ShouldNotReachHere();
1146   }
1147   if (info != NULL) {
1148     add_debug_info_for_null_check(null_check_here, info);
1149   }
1150 
1151   if (patch_code != lir_patch_none) {
1152     patching_epilog(patch, patch_code, to_addr-&gt;base()-&gt;as_register(), info);
1153   }
1154 }
1155 
1156 
1157 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1158   assert(src-&gt;is_stack(), &quot;should not call otherwise&quot;);
1159   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1160 
1161   if (dest-&gt;is_single_cpu()) {
1162     if (is_reference_type(type)) {
1163       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1164       __ verify_oop(dest-&gt;as_register());
1165     } else if (type == T_METADATA || type == T_ADDRESS) {
1166       __ movptr(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1167     } else {
1168       __ movl(dest-&gt;as_register(), frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix()));
1169     }
1170 
1171   } else if (dest-&gt;is_double_cpu()) {
1172     Address src_addr_LO = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), lo_word_offset_in_bytes);
1173     Address src_addr_HI = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix(), hi_word_offset_in_bytes);
1174     __ movptr(dest-&gt;as_register_lo(), src_addr_LO);
1175     NOT_LP64(__ movptr(dest-&gt;as_register_hi(), src_addr_HI));
1176 
1177   } else if (dest-&gt;is_single_xmm()) {
1178     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1179     __ movflt(dest-&gt;as_xmm_float_reg(), src_addr);
1180 
1181   } else if (dest-&gt;is_double_xmm()) {
1182     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1183     __ movdbl(dest-&gt;as_xmm_double_reg(), src_addr);
1184 
1185 #ifndef _LP64
1186   } else if (dest-&gt;is_single_fpu()) {
1187     assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1188     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1189     __ fld_s(src_addr);
1190 
1191   } else if (dest-&gt;is_double_fpu()) {
1192     assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1193     Address src_addr = frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix());
1194     __ fld_d(src_addr);
1195 #endif // _LP64
1196 
1197   } else {
1198     ShouldNotReachHere();
1199   }
1200 }
1201 
1202 
1203 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1204   if (src-&gt;is_single_stack()) {
1205     if (is_reference_type(type)) {
1206       __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1207       __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1208     } else {
1209 #ifndef _LP64
1210       __ pushl(frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1211       __ popl (frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()));
1212 #else
1213       //no pushl on 64bits
1214       __ movl(rscratch1, frame_map()-&gt;address_for_slot(src -&gt;single_stack_ix()));
1215       __ movl(frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix()), rscratch1);
1216 #endif
1217     }
1218 
1219   } else if (src-&gt;is_double_stack()) {
1220 #ifdef _LP64
1221     __ pushptr(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix()));
1222     __ popptr (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
1223 #else
1224     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 0));
1225     // push and pop the part at src + wordSize, adding wordSize for the previous push
1226     __ pushl(frame_map()-&gt;address_for_slot(src -&gt;double_stack_ix(), 2 * wordSize));
1227     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 2 * wordSize));
1228     __ popl (frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix(), 0));
1229 #endif // _LP64
1230 
1231   } else {
1232     ShouldNotReachHere();
1233   }
1234 }
1235 
1236 
1237 void LIR_Assembler::mem2reg(LIR_Opr src, LIR_Opr dest, BasicType type, LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool /* unaligned */) {
1238   assert(src-&gt;is_address(), &quot;should not call otherwise&quot;);
1239   assert(dest-&gt;is_register(), &quot;should not call otherwise&quot;);
1240 
1241   LIR_Address* addr = src-&gt;as_address_ptr();
1242   Address from_addr = as_Address(addr);
1243 
1244   if (addr-&gt;base()-&gt;type() == T_OBJECT || addr-&gt;base()-&gt;type() == T_VALUETYPE) {
1245     __ verify_oop(addr-&gt;base()-&gt;as_pointer_register());
1246   }
1247 
1248   switch (type) {
1249     case T_BOOLEAN: // fall through
1250     case T_BYTE:    // fall through
1251     case T_CHAR:    // fall through
1252     case T_SHORT:
1253       if (!VM_Version::is_P6() &amp;&amp; !from_addr.uses(dest-&gt;as_register())) {
1254         // on pre P6 processors we may get partial register stalls
1255         // so blow away the value of to_rinfo before loading a
1256         // partial word into it.  Do it here so that it precedes
1257         // the potential patch point below.
1258         __ xorptr(dest-&gt;as_register(), dest-&gt;as_register());
1259       }
1260       break;
1261    default:
1262      break;
1263   }
1264 
1265   PatchingStub* patch = NULL;
1266   if (patch_code != lir_patch_none) {
1267     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1268     assert(from_addr.disp() != 0, &quot;must have&quot;);
1269   }
1270   if (info != NULL) {
1271     add_debug_info_for_null_check_here(info);
1272   }
1273 
1274   switch (type) {
1275     case T_FLOAT: {
1276       if (dest-&gt;is_single_xmm()) {
1277         __ movflt(dest-&gt;as_xmm_float_reg(), from_addr);
1278       } else {
1279 #ifndef _LP64
1280         assert(dest-&gt;is_single_fpu(), &quot;must be&quot;);
1281         assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be TOS&quot;);
1282         __ fld_s(from_addr);
1283 #else
1284         ShouldNotReachHere();
1285 #endif // !LP64
1286       }
1287       break;
1288     }
1289 
1290     case T_DOUBLE: {
1291       if (dest-&gt;is_double_xmm()) {
1292         __ movdbl(dest-&gt;as_xmm_double_reg(), from_addr);
1293       } else {
1294 #ifndef _LP64
1295         assert(dest-&gt;is_double_fpu(), &quot;must be&quot;);
1296         assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be TOS&quot;);
1297         __ fld_d(from_addr);
1298 #else
1299         ShouldNotReachHere();
1300 #endif // !LP64
1301       }
1302       break;
1303     }
1304 
1305     case T_VALUETYPE: // fall through
1306     case T_OBJECT:  // fall through
1307     case T_ARRAY:   // fall through
1308       if (UseCompressedOops &amp;&amp; !wide) {
1309         __ movl(dest-&gt;as_register(), from_addr);
1310       } else {
1311         __ movptr(dest-&gt;as_register(), from_addr);
1312       }
1313       break;
1314 
1315     case T_ADDRESS:
1316       if (UseCompressedClassPointers &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1317         __ movl(dest-&gt;as_register(), from_addr);
1318       } else {
1319         __ movptr(dest-&gt;as_register(), from_addr);
1320       }
1321       break;
1322     case T_INT:
1323       __ movl(dest-&gt;as_register(), from_addr);
1324       break;
1325 
1326     case T_LONG: {
1327       Register to_lo = dest-&gt;as_register_lo();
1328       Register to_hi = dest-&gt;as_register_hi();
1329 #ifdef _LP64
1330       __ movptr(to_lo, as_Address_lo(addr));
1331 #else
1332       Register base = addr-&gt;base()-&gt;as_register();
1333       Register index = noreg;
1334       if (addr-&gt;index()-&gt;is_register()) {
1335         index = addr-&gt;index()-&gt;as_register();
1336       }
1337       if ((base == to_lo &amp;&amp; index == to_hi) ||
1338           (base == to_hi &amp;&amp; index == to_lo)) {
1339         // addresses with 2 registers are only formed as a result of
1340         // array access so this code will never have to deal with
1341         // patches or null checks.
1342         assert(info == NULL &amp;&amp; patch == NULL, &quot;must be&quot;);
1343         __ lea(to_hi, as_Address(addr));
1344         __ movl(to_lo, Address(to_hi, 0));
1345         __ movl(to_hi, Address(to_hi, BytesPerWord));
1346       } else if (base == to_lo || index == to_lo) {
1347         assert(base != to_hi, &quot;can&#39;t be&quot;);
1348         assert(index == noreg || (index != base &amp;&amp; index != to_hi), &quot;can&#39;t handle this&quot;);
1349         __ movl(to_hi, as_Address_hi(addr));
1350         if (patch != NULL) {
1351           patching_epilog(patch, lir_patch_high, base, info);
1352           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1353           patch_code = lir_patch_low;
1354         }
1355         __ movl(to_lo, as_Address_lo(addr));
1356       } else {
1357         assert(index == noreg || (index != base &amp;&amp; index != to_lo), &quot;can&#39;t handle this&quot;);
1358         __ movl(to_lo, as_Address_lo(addr));
1359         if (patch != NULL) {
1360           patching_epilog(patch, lir_patch_low, base, info);
1361           patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1362           patch_code = lir_patch_high;
1363         }
1364         __ movl(to_hi, as_Address_hi(addr));
1365       }
1366 #endif // _LP64
1367       break;
1368     }
1369 
1370     case T_BOOLEAN: // fall through
1371     case T_BYTE: {
1372       Register dest_reg = dest-&gt;as_register();
1373       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1374       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1375         __ movsbl(dest_reg, from_addr);
1376       } else {
1377         __ movb(dest_reg, from_addr);
1378         __ shll(dest_reg, 24);
1379         __ sarl(dest_reg, 24);
1380       }
1381       break;
1382     }
1383 
1384     case T_CHAR: {
1385       Register dest_reg = dest-&gt;as_register();
1386       assert(VM_Version::is_P6() || dest_reg-&gt;has_byte_register(), &quot;must use byte registers if not P6&quot;);
1387       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1388         __ movzwl(dest_reg, from_addr);
1389       } else {
1390         __ movw(dest_reg, from_addr);
1391       }
1392       break;
1393     }
1394 
1395     case T_SHORT: {
1396       Register dest_reg = dest-&gt;as_register();
1397       if (VM_Version::is_P6() || from_addr.uses(dest_reg)) {
1398         __ movswl(dest_reg, from_addr);
1399       } else {
1400         __ movw(dest_reg, from_addr);
1401         __ shll(dest_reg, 16);
1402         __ sarl(dest_reg, 16);
1403       }
1404       break;
1405     }
1406 
1407     default:
1408       ShouldNotReachHere();
1409   }
1410 
1411   if (patch != NULL) {
1412     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
1413   }
1414 
1415   if (is_reference_type(type)) {
1416 #ifdef _LP64
1417     if (UseCompressedOops &amp;&amp; !wide) {
1418       __ decode_heap_oop(dest-&gt;as_register());
1419     }
1420 #endif
1421 
1422     // Load barrier has not yet been applied, so ZGC can&#39;t verify the oop here
1423     if (!UseZGC) {
1424       __ verify_oop(dest-&gt;as_register());
1425     }
1426   } else if (type == T_ADDRESS &amp;&amp; addr-&gt;disp() == oopDesc::klass_offset_in_bytes()) {
1427 #ifdef _LP64
1428     if (UseCompressedClassPointers) {
1429       __ andl(dest-&gt;as_register(), oopDesc::compressed_klass_mask());
1430       __ decode_klass_not_null(dest-&gt;as_register());
1431     } else {
1432       __ shlq(dest-&gt;as_register(), oopDesc::storage_props_nof_bits);
1433       __ shrq(dest-&gt;as_register(), oopDesc::storage_props_nof_bits);
1434     }
1435 #else
1436     __ andl(dest-&gt;as_register(), oopDesc::wide_klass_mask());
1437 #endif
1438   }
1439 }
1440 
1441 
1442 NEEDS_CLEANUP; // This could be static?
1443 Address::ScaleFactor LIR_Assembler::array_element_size(BasicType type) const {
1444   int elem_size = type2aelembytes(type);
1445   switch (elem_size) {
1446     case 1: return Address::times_1;
1447     case 2: return Address::times_2;
1448     case 4: return Address::times_4;
1449     case 8: return Address::times_8;
1450   }
1451   ShouldNotReachHere();
1452   return Address::no_scale;
1453 }
1454 
1455 
1456 void LIR_Assembler::emit_op3(LIR_Op3* op) {
1457   switch (op-&gt;code()) {
1458     case lir_idiv:
1459     case lir_irem:
1460       arithmetic_idiv(op-&gt;code(),
1461                       op-&gt;in_opr1(),
1462                       op-&gt;in_opr2(),
1463                       op-&gt;in_opr3(),
1464                       op-&gt;result_opr(),
1465                       op-&gt;info());
1466       break;
1467     case lir_fmad:
1468       __ fmad(op-&gt;result_opr()-&gt;as_xmm_double_reg(),
1469               op-&gt;in_opr1()-&gt;as_xmm_double_reg(),
1470               op-&gt;in_opr2()-&gt;as_xmm_double_reg(),
1471               op-&gt;in_opr3()-&gt;as_xmm_double_reg());
1472       break;
1473     case lir_fmaf:
1474       __ fmaf(op-&gt;result_opr()-&gt;as_xmm_float_reg(),
1475               op-&gt;in_opr1()-&gt;as_xmm_float_reg(),
1476               op-&gt;in_opr2()-&gt;as_xmm_float_reg(),
1477               op-&gt;in_opr3()-&gt;as_xmm_float_reg());
1478       break;
1479     default:      ShouldNotReachHere(); break;
1480   }
1481 }
1482 
1483 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
1484 #ifdef ASSERT
1485   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
1486   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
1487   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
1488 #endif
1489 
1490   if (op-&gt;cond() == lir_cond_always) {
1491     if (op-&gt;info() != NULL) add_debug_info_for_branch(op-&gt;info());
1492     __ jmp (*(op-&gt;label()));
1493   } else {
1494     Assembler::Condition acond = Assembler::zero;
1495     if (op-&gt;code() == lir_cond_float_branch) {
1496       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
1497       __ jcc(Assembler::parity, *(op-&gt;ublock()-&gt;label()));
1498       switch(op-&gt;cond()) {
1499         case lir_cond_equal:        acond = Assembler::equal;      break;
1500         case lir_cond_notEqual:     acond = Assembler::notEqual;   break;
1501         case lir_cond_less:         acond = Assembler::below;      break;
1502         case lir_cond_lessEqual:    acond = Assembler::belowEqual; break;
1503         case lir_cond_greaterEqual: acond = Assembler::aboveEqual; break;
1504         case lir_cond_greater:      acond = Assembler::above;      break;
1505         default:                         ShouldNotReachHere();
1506       }
1507     } else {
1508       switch (op-&gt;cond()) {
1509         case lir_cond_equal:        acond = Assembler::equal;       break;
1510         case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
1511         case lir_cond_less:         acond = Assembler::less;        break;
1512         case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
1513         case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
1514         case lir_cond_greater:      acond = Assembler::greater;     break;
1515         case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
1516         case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
1517         default:                         ShouldNotReachHere();
1518       }
1519     }
1520     __ jcc(acond,*(op-&gt;label()));
1521   }
1522 }
1523 
1524 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
1525   LIR_Opr src  = op-&gt;in_opr();
1526   LIR_Opr dest = op-&gt;result_opr();
1527 
1528   switch (op-&gt;bytecode()) {
1529     case Bytecodes::_i2l:
1530 #ifdef _LP64
1531       __ movl2ptr(dest-&gt;as_register_lo(), src-&gt;as_register());
1532 #else
1533       move_regs(src-&gt;as_register(), dest-&gt;as_register_lo());
1534       move_regs(src-&gt;as_register(), dest-&gt;as_register_hi());
1535       __ sarl(dest-&gt;as_register_hi(), 31);
1536 #endif // LP64
1537       break;
1538 
1539     case Bytecodes::_l2i:
1540 #ifdef _LP64
1541       __ movl(dest-&gt;as_register(), src-&gt;as_register_lo());
1542 #else
1543       move_regs(src-&gt;as_register_lo(), dest-&gt;as_register());
1544 #endif
1545       break;
1546 
1547     case Bytecodes::_i2b:
1548       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1549       __ sign_extend_byte(dest-&gt;as_register());
1550       break;
1551 
1552     case Bytecodes::_i2c:
1553       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1554       __ andl(dest-&gt;as_register(), 0xFFFF);
1555       break;
1556 
1557     case Bytecodes::_i2s:
1558       move_regs(src-&gt;as_register(), dest-&gt;as_register());
1559       __ sign_extend_short(dest-&gt;as_register());
1560       break;
1561 
1562 
1563 #ifdef _LP64
1564     case Bytecodes::_f2d:
1565       __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1566       break;
1567 
1568     case Bytecodes::_d2f:
1569       __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1570       break;
1571 
1572     case Bytecodes::_i2f:
1573       __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1574       break;
1575 
1576     case Bytecodes::_i2d:
1577       __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1578       break;
1579 
1580     case Bytecodes::_l2f:
1581       __ cvtsi2ssq(dest-&gt;as_xmm_float_reg(), src-&gt;as_register_lo());
1582       break;
1583 
1584     case Bytecodes::_l2d:
1585       __ cvtsi2sdq(dest-&gt;as_xmm_double_reg(), src-&gt;as_register_lo());
1586       break;
1587 
1588     case Bytecodes::_f2i:
1589       __ convert_f2i(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1590       break;
1591 
1592     case Bytecodes::_d2i:
1593       __ convert_d2i(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1594       break;
1595 
1596     case Bytecodes::_f2l:
1597       __ convert_f2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_float_reg());
1598       break;
1599 
1600     case Bytecodes::_d2l:
1601       __ convert_d2l(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
1602       break;
1603 #else
1604     case Bytecodes::_f2d:
1605     case Bytecodes::_d2f:
1606       if (dest-&gt;is_single_xmm()) {
1607         __ cvtsd2ss(dest-&gt;as_xmm_float_reg(), src-&gt;as_xmm_double_reg());
1608       } else if (dest-&gt;is_double_xmm()) {
1609         __ cvtss2sd(dest-&gt;as_xmm_double_reg(), src-&gt;as_xmm_float_reg());
1610       } else {
1611         assert(src-&gt;fpu() == dest-&gt;fpu(), &quot;register must be equal&quot;);
1612         // do nothing (float result is rounded later through spilling)
1613       }
1614       break;
1615 
1616     case Bytecodes::_i2f:
1617     case Bytecodes::_i2d:
1618       if (dest-&gt;is_single_xmm()) {
1619         __ cvtsi2ssl(dest-&gt;as_xmm_float_reg(), src-&gt;as_register());
1620       } else if (dest-&gt;is_double_xmm()) {
1621         __ cvtsi2sdl(dest-&gt;as_xmm_double_reg(), src-&gt;as_register());
1622       } else {
1623         assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1624         __ movl(Address(rsp, 0), src-&gt;as_register());
1625         __ fild_s(Address(rsp, 0));
1626       }
1627       break;
1628 
1629     case Bytecodes::_l2f:
1630     case Bytecodes::_l2d:
1631       assert(!dest-&gt;is_xmm_register(), &quot;result in xmm register not supported (no SSE instruction present)&quot;);
1632       assert(dest-&gt;fpu() == 0, &quot;result must be on TOS&quot;);
1633       __ movptr(Address(rsp, 0),          src-&gt;as_register_lo());
1634       __ movl(Address(rsp, BytesPerWord), src-&gt;as_register_hi());
1635       __ fild_d(Address(rsp, 0));
1636       // float result is rounded later through spilling
1637       break;
1638 
1639     case Bytecodes::_f2i:
1640     case Bytecodes::_d2i:
1641       if (src-&gt;is_single_xmm()) {
1642         __ cvttss2sil(dest-&gt;as_register(), src-&gt;as_xmm_float_reg());
1643       } else if (src-&gt;is_double_xmm()) {
1644         __ cvttsd2sil(dest-&gt;as_register(), src-&gt;as_xmm_double_reg());
1645       } else {
1646         assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1647         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_trunc()));
1648         __ fist_s(Address(rsp, 0));
1649         __ movl(dest-&gt;as_register(), Address(rsp, 0));
1650         __ fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
1651       }
1652       // IA32 conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
1653       assert(op-&gt;stub() != NULL, &quot;stub required&quot;);
1654       __ cmpl(dest-&gt;as_register(), 0x80000000);
1655       __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry());
1656       __ bind(*op-&gt;stub()-&gt;continuation());
1657       break;
1658 
1659     case Bytecodes::_f2l:
1660     case Bytecodes::_d2l:
1661       assert(!src-&gt;is_xmm_register(), &quot;input in xmm register not supported (no SSE instruction present)&quot;);
1662       assert(src-&gt;fpu() == 0, &quot;input must be on TOS&quot;);
1663       assert(dest == FrameMap::long0_opr, &quot;runtime stub places result in these registers&quot;);
1664 
1665       // instruction sequence too long to inline it here
1666       {
1667         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::fpu2long_stub_id)));
1668       }
1669       break;
1670 #endif // _LP64
1671 
1672     default: ShouldNotReachHere();
1673   }
1674 }
1675 
1676 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
1677   if (op-&gt;init_check()) {
1678     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
1679     __ cmpb(Address(op-&gt;klass()-&gt;as_register(),
1680                     InstanceKlass::init_state_offset()),
1681                     InstanceKlass::fully_initialized);
1682     __ jcc(Assembler::notEqual, *op-&gt;stub()-&gt;entry());
1683   }
1684   __ allocate_object(op-&gt;obj()-&gt;as_register(),
1685                      op-&gt;tmp1()-&gt;as_register(),
1686                      op-&gt;tmp2()-&gt;as_register(),
1687                      op-&gt;header_size(),
1688                      op-&gt;object_size(),
1689                      op-&gt;klass()-&gt;as_register(),
1690                      *op-&gt;stub()-&gt;entry());
1691   __ bind(*op-&gt;stub()-&gt;continuation());
1692 }
1693 
1694 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
1695   Register len =  op-&gt;len()-&gt;as_register();
1696   LP64_ONLY( __ movslq(len, len); )
1697 
1698   if (UseSlowPath || op-&gt;type() == T_VALUETYPE ||
1699       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
1700       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
1701     __ jmp(*op-&gt;stub()-&gt;entry());
1702   } else {
1703     Register tmp1 = op-&gt;tmp1()-&gt;as_register();
1704     Register tmp2 = op-&gt;tmp2()-&gt;as_register();
1705     Register tmp3 = op-&gt;tmp3()-&gt;as_register();
1706     if (len == tmp1) {
1707       tmp1 = tmp3;
1708     } else if (len == tmp2) {
1709       tmp2 = tmp3;
1710     } else if (len == tmp3) {
1711       // everything is ok
1712     } else {
1713       __ mov(tmp3, len);
1714     }
1715     __ allocate_array(op-&gt;obj()-&gt;as_register(),
1716                       len,
1717                       tmp1,
1718                       tmp2,
1719                       arrayOopDesc::header_size(op-&gt;type()),
1720                       array_element_size(op-&gt;type()),
1721                       op-&gt;klass()-&gt;as_register(),
1722                       *op-&gt;stub()-&gt;entry());
1723   }
1724   __ bind(*op-&gt;stub()-&gt;continuation());
1725 }
1726 
1727 void LIR_Assembler::type_profile_helper(Register mdo,
1728                                         ciMethodData *md, ciProfileData *data,
1729                                         Register recv, Label* update_done) {
1730   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1731     Label next_test;
1732     // See if the receiver is receiver[n].
1733     __ cmpptr(recv, Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i))));
1734     __ jccb(Assembler::notEqual, next_test);
1735     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)));
1736     __ addptr(data_addr, DataLayout::counter_increment);
1737     __ jmp(*update_done);
1738     __ bind(next_test);
1739   }
1740 
1741   // Didn&#39;t find receiver; find next empty slot and fill it in
1742   for (uint i = 0; i &lt; ReceiverTypeData::row_limit(); i++) {
1743     Label next_test;
1744     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)));
1745     __ cmpptr(recv_addr, (intptr_t)NULL_WORD);
1746     __ jccb(Assembler::notEqual, next_test);
1747     __ movptr(recv_addr, recv);
1748     __ movptr(Address(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i))), DataLayout::counter_increment);
1749     __ jmp(*update_done);
1750     __ bind(next_test);
1751   }
1752 }
1753 
1754 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
1755   // we always need a stub for the failure case.
1756   CodeStub* stub = op-&gt;stub();
1757   Register obj = op-&gt;object()-&gt;as_register();
1758   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1759   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1760   Register dst = op-&gt;result_opr()-&gt;as_register();
1761   ciKlass* k = op-&gt;klass();
1762   Register Rtmp1 = noreg;
1763 
1764   // check if it needs to be profiled
1765   ciMethodData* md = NULL;
1766   ciProfileData* data = NULL;
1767 
1768   if (op-&gt;should_profile()) {
1769     ciMethod* method = op-&gt;profiled_method();
1770     assert(method != NULL, &quot;Should have method&quot;);
1771     int bci = op-&gt;profiled_bci();
1772     md = method-&gt;method_data_or_null();
1773     assert(md != NULL, &quot;Sanity&quot;);
1774     data = md-&gt;bci_to_data(bci);
1775     assert(data != NULL,                &quot;need data for type check&quot;);
1776     assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1777   }
1778   Label profile_cast_success, profile_cast_failure;
1779   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
1780   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
1781 
1782   if (obj == k_RInfo) {
1783     k_RInfo = dst;
1784   } else if (obj == klass_RInfo) {
1785     klass_RInfo = dst;
1786   }
1787   if (k-&gt;is_loaded() &amp;&amp; !UseCompressedClassPointers) {
1788     select_different_registers(obj, dst, k_RInfo, klass_RInfo);
1789   } else {
1790     Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1791     select_different_registers(obj, dst, k_RInfo, klass_RInfo, Rtmp1);
1792   }
1793 
1794   assert_different_registers(obj, k_RInfo, klass_RInfo);
1795 
1796   if (op-&gt;need_null_check()) {
1797     __ cmpptr(obj, (int32_t)NULL_WORD);
1798     if (op-&gt;should_profile()) {
1799       Label not_null;
1800       __ jccb(Assembler::notEqual, not_null);
1801       // Object is null; update MDO and exit
1802       Register mdo  = klass_RInfo;
1803       __ mov_metadata(mdo, md-&gt;constant_encoding());
1804       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1805       int header_bits = BitData::null_seen_byte_constant();
1806       __ orb(data_addr, header_bits);
1807       __ jmp(*obj_is_null);
1808       __ bind(not_null);
1809     } else {
1810       __ jcc(Assembler::equal, *obj_is_null);
1811     }
1812   }
1813 
1814   if (!k-&gt;is_loaded()) {
1815     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
1816   } else {
1817 #ifdef _LP64
1818     __ mov_metadata(k_RInfo, k-&gt;constant_encoding());
1819 #endif // _LP64
1820   }
1821   __ verify_oop(obj);
1822 
1823   if (op-&gt;fast_check()) {
1824     // get object class
1825     // not a safepoint as obj null check happens earlier
1826 #ifdef _LP64
1827     if (UseCompressedClassPointers) {
1828       __ load_klass(Rtmp1, obj);
1829       __ cmpptr(k_RInfo, Rtmp1);
1830     } else {
1831       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1832     }
1833 #else
1834     if (k-&gt;is_loaded()) {
1835       __ cmpklass(Address(obj, oopDesc::klass_offset_in_bytes()), k-&gt;constant_encoding());
1836     } else {
1837       __ cmpptr(k_RInfo, Address(obj, oopDesc::klass_offset_in_bytes()));
1838     }
1839 #endif
1840     __ jcc(Assembler::notEqual, *failure_target);
1841     // successful cast, fall through to profile or jump
1842   } else {
1843     // get object class
1844     // not a safepoint as obj null check happens earlier
1845     __ load_klass(klass_RInfo, obj);
1846     if (k-&gt;is_loaded()) {
1847       // See if we get an immediate positive hit
1848 #ifdef _LP64
1849       __ cmpptr(k_RInfo, Address(klass_RInfo, k-&gt;super_check_offset()));
1850 #else
1851       __ cmpklass(Address(klass_RInfo, k-&gt;super_check_offset()), k-&gt;constant_encoding());
1852 #endif // _LP64
1853       if ((juint)in_bytes(Klass::secondary_super_cache_offset()) != k-&gt;super_check_offset()) {
1854         __ jcc(Assembler::notEqual, *failure_target);
1855         // successful cast, fall through to profile or jump
1856       } else {
1857         // See if we get an immediate positive hit
1858         __ jcc(Assembler::equal, *success_target);
1859         // check for self
1860 #ifdef _LP64
1861         __ cmpptr(klass_RInfo, k_RInfo);
1862 #else
1863         __ cmpklass(klass_RInfo, k-&gt;constant_encoding());
1864 #endif // _LP64
1865         __ jcc(Assembler::equal, *success_target);
1866 
1867         __ push(klass_RInfo);
1868 #ifdef _LP64
1869         __ push(k_RInfo);
1870 #else
1871         __ pushklass(k-&gt;constant_encoding());
1872 #endif // _LP64
1873         __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1874         __ pop(klass_RInfo);
1875         __ pop(klass_RInfo);
1876         // result is a boolean
1877         __ cmpl(klass_RInfo, 0);
1878         __ jcc(Assembler::equal, *failure_target);
1879         // successful cast, fall through to profile or jump
1880       }
1881     } else {
1882       // perform the fast part of the checking logic
1883       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1884       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1885       __ push(klass_RInfo);
1886       __ push(k_RInfo);
1887       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1888       __ pop(klass_RInfo);
1889       __ pop(k_RInfo);
1890       // result is a boolean
1891       __ cmpl(k_RInfo, 0);
1892       __ jcc(Assembler::equal, *failure_target);
1893       // successful cast, fall through to profile or jump
1894     }
1895   }
1896   if (op-&gt;should_profile()) {
1897     Register mdo  = klass_RInfo, recv = k_RInfo;
1898     __ bind(profile_cast_success);
1899     __ mov_metadata(mdo, md-&gt;constant_encoding());
1900     __ load_klass(recv, obj);
1901     type_profile_helper(mdo, md, data, recv, success);
1902     __ jmp(*success);
1903 
1904     __ bind(profile_cast_failure);
1905     __ mov_metadata(mdo, md-&gt;constant_encoding());
1906     Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1907     __ subptr(counter_addr, DataLayout::counter_increment);
1908     __ jmp(*failure);
1909   }
1910   __ jmp(*success);
1911 }
1912 
1913 
1914 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
1915   LIR_Code code = op-&gt;code();
1916   if (code == lir_store_check) {
1917     Register value = op-&gt;object()-&gt;as_register();
1918     Register array = op-&gt;array()-&gt;as_register();
1919     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
1920     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
1921     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
1922 
1923     CodeStub* stub = op-&gt;stub();
1924 
1925     // check if it needs to be profiled
1926     ciMethodData* md = NULL;
1927     ciProfileData* data = NULL;
1928 
1929     if (op-&gt;should_profile()) {
1930       ciMethod* method = op-&gt;profiled_method();
1931       assert(method != NULL, &quot;Should have method&quot;);
1932       int bci = op-&gt;profiled_bci();
1933       md = method-&gt;method_data_or_null();
1934       assert(md != NULL, &quot;Sanity&quot;);
1935       data = md-&gt;bci_to_data(bci);
1936       assert(data != NULL,                &quot;need data for type check&quot;);
1937       assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
1938     }
1939     Label profile_cast_success, profile_cast_failure, done;
1940     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
1941     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
1942 
1943     __ cmpptr(value, (int32_t)NULL_WORD);
1944     if (op-&gt;should_profile()) {
1945       Label not_null;
1946       __ jccb(Assembler::notEqual, not_null);
1947       // Object is null; update MDO and exit
1948       Register mdo  = klass_RInfo;
1949       __ mov_metadata(mdo, md-&gt;constant_encoding());
1950       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()));
1951       int header_bits = BitData::null_seen_byte_constant();
1952       __ orb(data_addr, header_bits);
1953       __ jmp(done);
1954       __ bind(not_null);
1955     } else {
1956       __ jcc(Assembler::equal, done);
1957     }
1958 
1959     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
1960     __ load_klass(k_RInfo, array);
1961     __ load_klass(klass_RInfo, value);
1962 
1963     // get instance klass (it&#39;s already uncompressed)
1964     __ movptr(k_RInfo, Address(k_RInfo, ObjArrayKlass::element_klass_offset()));
1965     // perform the fast part of the checking logic
1966     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, success_target, failure_target, NULL);
1967     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
1968     __ push(klass_RInfo);
1969     __ push(k_RInfo);
1970     __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
1971     __ pop(klass_RInfo);
1972     __ pop(k_RInfo);
1973     // result is a boolean
1974     __ cmpl(k_RInfo, 0);
1975     __ jcc(Assembler::equal, *failure_target);
1976     // fall through to the success case
1977 
1978     if (op-&gt;should_profile()) {
1979       Register mdo  = klass_RInfo, recv = k_RInfo;
1980       __ bind(profile_cast_success);
1981       __ mov_metadata(mdo, md-&gt;constant_encoding());
1982       __ load_klass(recv, value);
1983       type_profile_helper(mdo, md, data, recv, &amp;done);
1984       __ jmpb(done);
1985 
1986       __ bind(profile_cast_failure);
1987       __ mov_metadata(mdo, md-&gt;constant_encoding());
1988       Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
1989       __ subptr(counter_addr, DataLayout::counter_increment);
1990       __ jmp(*stub-&gt;entry());
1991     }
1992 
1993     __ bind(done);
1994   } else
1995     if (code == lir_checkcast) {
1996       Register obj = op-&gt;object()-&gt;as_register();
1997       Register dst = op-&gt;result_opr()-&gt;as_register();
1998       Label success;
1999       emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
2000       __ bind(success);
2001       if (dst != obj) {
2002         __ mov(dst, obj);
2003       }
2004     } else
2005       if (code == lir_instanceof) {
2006         Register obj = op-&gt;object()-&gt;as_register();
2007         Register dst = op-&gt;result_opr()-&gt;as_register();
2008         Label success, failure, done;
2009         emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
2010         __ bind(failure);
2011         __ xorptr(dst, dst);
2012         __ jmpb(done);
2013         __ bind(success);
2014         __ movptr(dst, 1);
2015         __ bind(done);
2016       } else {
2017         ShouldNotReachHere();
2018       }
2019 
2020 }
2021 
2022 void LIR_Assembler::emit_opFlattenedArrayCheck(LIR_OpFlattenedArrayCheck* op) {
2023   // We are loading/storing an array that *may* be a flattened array (the declared type
2024   // Object[], interface[], or VT?[]). If this array is flattened, take slow path.
2025 
2026   __ load_storage_props(op-&gt;tmp()-&gt;as_register(), op-&gt;array()-&gt;as_register());
2027   __ testb(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::flattened_value);
2028   __ jcc(Assembler::notZero, *op-&gt;stub()-&gt;entry());
2029   if (!op-&gt;value()-&gt;is_illegal()) {
2030     // We are storing into the array.
2031     Label skip;
2032     __ testb(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::null_free_value);
2033     __ jcc(Assembler::zero, skip);
2034     // The array is not flattened, but it is null_free. If we are storing
2035     // a null, take the slow path (which will throw NPE).
2036     __ cmpptr(op-&gt;value()-&gt;as_register(), (int32_t)NULL_WORD);
2037     __ jcc(Assembler::zero, *op-&gt;stub()-&gt;entry());
2038     __ bind(skip);
2039   }
2040 }
2041 
2042 void LIR_Assembler::emit_opNullFreeArrayCheck(LIR_OpNullFreeArrayCheck* op) {
2043   // This is called when we use aastore into a an array declared as &quot;[LVT;&quot;,
2044   // where we know VT is not flattenable (due to ValueArrayElemMaxFlatOops, etc).
2045   // However, we need to do a NULL check if the actual array is a &quot;[QVT;&quot;.
2046 
2047   __ load_storage_props(op-&gt;tmp()-&gt;as_register(), op-&gt;array()-&gt;as_register());
2048   __ testb(op-&gt;tmp()-&gt;as_register(), ArrayStorageProperties::null_free_value);
2049 }
2050 
2051 void LIR_Assembler::emit_opSubstitutabilityCheck(LIR_OpSubstitutabilityCheck* op) {
2052   Label L_oops_equal;
2053   Label L_oops_not_equal;
2054   Label L_end;
2055 
2056   Register left  = op-&gt;left()-&gt;as_register();
2057   Register right = op-&gt;right()-&gt;as_register();
2058 
2059   __ cmpptr(left, right);
2060   __ jcc(Assembler::equal, L_oops_equal);
2061 
2062   // (1) Null check -- if one of the operands is null, the other must not be null (because
2063   //     the two references are not equal), so they are not substitutable,
2064   //     FIXME: do null check only if the operand is nullable
2065   {
2066     __ cmpptr(left, (int32_t)NULL_WORD);
2067     __ jcc(Assembler::equal, L_oops_not_equal);
2068 
2069     __ cmpptr(right, (int32_t)NULL_WORD);
2070     __ jcc(Assembler::equal, L_oops_not_equal);
2071   }
2072 
2073   ciKlass* left_klass = op-&gt;left_klass();
2074   ciKlass* right_klass = op-&gt;right_klass();
2075 
2076   // (2) Value object check -- if either of the operands is not a value object,
2077   //     they are not substitutable. We do this only if we are not sure that the
2078   //     operands are value objects
2079   if ((left_klass == NULL || right_klass == NULL) ||// The klass is still unloaded, or came from a Phi node.
2080       !left_klass-&gt;is_valuetype() || !right_klass-&gt;is_valuetype()) {
2081     Register tmp1  = op-&gt;tmp1()-&gt;as_register();
2082     __ movptr(tmp1, (intptr_t)markWord::always_locked_pattern);
2083     __ andl(tmp1, Address(left, oopDesc::mark_offset_in_bytes()));
2084     __ andl(tmp1, Address(right, oopDesc::mark_offset_in_bytes()));
2085     __ cmpptr(tmp1, (intptr_t)markWord::always_locked_pattern);
2086     __ jcc(Assembler::notEqual, L_oops_not_equal);
2087   }
2088 
2089   // (3) Same klass check: if the operands are of different klasses, they are not substitutable.
2090   if (left_klass != NULL &amp;&amp; left_klass-&gt;is_valuetype() &amp;&amp; left_klass == right_klass) {
2091     // No need to load klass -- the operands are statically known to be the same value klass.
2092     __ jmp(*op-&gt;stub()-&gt;entry());
2093   } else {
2094     Register left_klass_op = op-&gt;left_klass_op()-&gt;as_register();
2095     Register right_klass_op = op-&gt;right_klass_op()-&gt;as_register();
2096 
2097     if (UseCompressedOops) {
2098       __ movl(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
2099       __ movl(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
2100       __ cmpl(left_klass_op, right_klass_op);
2101     } else {
2102       __ movptr(left_klass_op,  Address(left,  oopDesc::klass_offset_in_bytes()));
2103       __ movptr(right_klass_op, Address(right, oopDesc::klass_offset_in_bytes()));
2104       __ cmpptr(left_klass_op, right_klass_op);
2105     }
2106 
2107     __ jcc(Assembler::equal, *op-&gt;stub()-&gt;entry()); // same klass -&gt; do slow check
2108     // fall through to L_oops_not_equal
2109   }
2110 
2111   __ bind(L_oops_not_equal);
2112   move(op-&gt;not_equal_result(), op-&gt;result_opr());
2113   __ jmp(L_end);
2114 
2115   __ bind(L_oops_equal);
2116   move(op-&gt;equal_result(), op-&gt;result_opr());
2117   __ jmp(L_end);
2118 
2119   // We&#39;ve returned from the stub. RAX contains 0x0 IFF the two
2120   // operands are not substitutable. (Don&#39;t compare against 0x1 in case the
2121   // C compiler is naughty)
2122   __ bind(*op-&gt;stub()-&gt;continuation());
2123   __ cmpl(rax, 0);
2124   __ jcc(Assembler::equal, L_oops_not_equal); // (call_stub() == 0x0) -&gt; not_equal
2125   move(op-&gt;equal_result(), op-&gt;result_opr()); // (call_stub() != 0x0) -&gt; equal
2126   // fall-through
2127   __ bind(L_end);
2128 }
2129 
2130 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2131   if (LP64_ONLY(false &amp;&amp;) op-&gt;code() == lir_cas_long &amp;&amp; VM_Version::supports_cx8()) {
2132     assert(op-&gt;cmp_value()-&gt;as_register_lo() == rax, &quot;wrong register&quot;);
2133     assert(op-&gt;cmp_value()-&gt;as_register_hi() == rdx, &quot;wrong register&quot;);
2134     assert(op-&gt;new_value()-&gt;as_register_lo() == rbx, &quot;wrong register&quot;);
2135     assert(op-&gt;new_value()-&gt;as_register_hi() == rcx, &quot;wrong register&quot;);
2136     Register addr = op-&gt;addr()-&gt;as_register();
2137     __ lock();
2138     NOT_LP64(__ cmpxchg8(Address(addr, 0)));
2139 
2140   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj ) {
2141     NOT_LP64(assert(op-&gt;addr()-&gt;is_single_cpu(), &quot;must be single&quot;);)
2142     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2143     Register newval = op-&gt;new_value()-&gt;as_register();
2144     Register cmpval = op-&gt;cmp_value()-&gt;as_register();
2145     assert(cmpval == rax, &quot;wrong register&quot;);
2146     assert(newval != NULL, &quot;new val must be register&quot;);
2147     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2148     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2149     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2150 
2151     if ( op-&gt;code() == lir_cas_obj) {
2152 #ifdef _LP64
2153       if (UseCompressedOops) {
2154         __ encode_heap_oop(cmpval);
2155         __ mov(rscratch1, newval);
2156         __ encode_heap_oop(rscratch1);
2157         __ lock();
2158         // cmpval (rax) is implicitly used by this instruction
2159         __ cmpxchgl(rscratch1, Address(addr, 0));
2160       } else
2161 #endif
2162       {
2163         __ lock();
2164         __ cmpxchgptr(newval, Address(addr, 0));
2165       }
2166     } else {
2167       assert(op-&gt;code() == lir_cas_int, &quot;lir_cas_int expected&quot;);
2168       __ lock();
2169       __ cmpxchgl(newval, Address(addr, 0));
2170     }
2171 #ifdef _LP64
2172   } else if (op-&gt;code() == lir_cas_long) {
2173     Register addr = (op-&gt;addr()-&gt;is_single_cpu() ? op-&gt;addr()-&gt;as_register() : op-&gt;addr()-&gt;as_register_lo());
2174     Register newval = op-&gt;new_value()-&gt;as_register_lo();
2175     Register cmpval = op-&gt;cmp_value()-&gt;as_register_lo();
2176     assert(cmpval == rax, &quot;wrong register&quot;);
2177     assert(newval != NULL, &quot;new val must be register&quot;);
2178     assert(cmpval != newval, &quot;cmp and new values must be in different registers&quot;);
2179     assert(cmpval != addr, &quot;cmp and addr must be in different registers&quot;);
2180     assert(newval != addr, &quot;new value and addr must be in different registers&quot;);
2181     __ lock();
2182     __ cmpxchgq(newval, Address(addr, 0));
2183 #endif // _LP64
2184   } else {
2185     Unimplemented();
2186   }
2187 }
2188 
2189 void LIR_Assembler::move(LIR_Opr src, LIR_Opr dst) {
2190   assert(dst-&gt;is_cpu_register(), &quot;must be&quot;);
2191   assert(dst-&gt;type() == src-&gt;type(), &quot;must be&quot;);
2192 
2193   if (src-&gt;is_cpu_register()) {
2194     reg2reg(src, dst);
2195   } else if (src-&gt;is_stack()) {
2196     stack2reg(src, dst, dst-&gt;type());
2197   } else if (src-&gt;is_constant()) {
2198     const2reg(src, dst, lir_patch_none, NULL);
2199   } else {
2200     ShouldNotReachHere();
2201   }
2202 }
2203 
2204 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
2205   Assembler::Condition acond, ncond;
2206   switch (condition) {
2207     case lir_cond_equal:        acond = Assembler::equal;        ncond = Assembler::notEqual;     break;
2208     case lir_cond_notEqual:     acond = Assembler::notEqual;     ncond = Assembler::equal;        break;
2209     case lir_cond_less:         acond = Assembler::less;         ncond = Assembler::greaterEqual; break;
2210     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    ncond = Assembler::greater;      break;
2211     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; ncond = Assembler::less;         break;
2212     case lir_cond_greater:      acond = Assembler::greater;      ncond = Assembler::lessEqual;    break;
2213     case lir_cond_belowEqual:   acond = Assembler::belowEqual;   ncond = Assembler::above;        break;
2214     case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;   ncond = Assembler::below;        break;
2215     default:                    acond = Assembler::equal;        ncond = Assembler::notEqual;
2216                                 ShouldNotReachHere();
2217   }
2218 
2219   if (opr1-&gt;is_cpu_register()) {
2220     reg2reg(opr1, result);
2221   } else if (opr1-&gt;is_stack()) {
2222     stack2reg(opr1, result, result-&gt;type());
2223   } else if (opr1-&gt;is_constant()) {
2224     const2reg(opr1, result, lir_patch_none, NULL);
2225   } else {
2226     ShouldNotReachHere();
2227   }
2228 
2229   if (VM_Version::supports_cmov() &amp;&amp; !opr2-&gt;is_constant()) {
2230     // optimized version that does not require a branch
2231     if (opr2-&gt;is_single_cpu()) {
2232       assert(opr2-&gt;cpu_regnr() != result-&gt;cpu_regnr(), &quot;opr2 already overwritten by previous move&quot;);
2233       __ cmov(ncond, result-&gt;as_register(), opr2-&gt;as_register());
2234     } else if (opr2-&gt;is_double_cpu()) {
2235       assert(opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrLo() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2236       assert(opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrLo() &amp;&amp; opr2-&gt;cpu_regnrHi() != result-&gt;cpu_regnrHi(), &quot;opr2 already overwritten by previous move&quot;);
2237       __ cmovptr(ncond, result-&gt;as_register_lo(), opr2-&gt;as_register_lo());
2238       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), opr2-&gt;as_register_hi());)
2239     } else if (opr2-&gt;is_single_stack()) {
2240       __ cmovl(ncond, result-&gt;as_register(), frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2241     } else if (opr2-&gt;is_double_stack()) {
2242       __ cmovptr(ncond, result-&gt;as_register_lo(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), lo_word_offset_in_bytes));
2243       NOT_LP64(__ cmovptr(ncond, result-&gt;as_register_hi(), frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix(), hi_word_offset_in_bytes));)
2244     } else {
2245       ShouldNotReachHere();
2246     }
2247 
2248   } else {
2249     Label skip;
2250     __ jcc (acond, skip);
2251     if (opr2-&gt;is_cpu_register()) {
2252       reg2reg(opr2, result);
2253     } else if (opr2-&gt;is_stack()) {
2254       stack2reg(opr2, result, result-&gt;type());
2255     } else if (opr2-&gt;is_constant()) {
2256       const2reg(opr2, result, lir_patch_none, NULL);
2257     } else {
2258       ShouldNotReachHere();
2259     }
2260     __ bind(skip);
2261   }
2262 }
2263 
2264 
2265 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
2266   assert(info == NULL, &quot;should never be used, idiv/irem and ldiv/lrem not handled by this method&quot;);
2267 
2268   if (left-&gt;is_single_cpu()) {
2269     assert(left == dest, &quot;left and dest must be equal&quot;);
2270     Register lreg = left-&gt;as_register();
2271 
2272     if (right-&gt;is_single_cpu()) {
2273       // cpu register - cpu register
2274       Register rreg = right-&gt;as_register();
2275       switch (code) {
2276         case lir_add: __ addl (lreg, rreg); break;
2277         case lir_sub: __ subl (lreg, rreg); break;
2278         case lir_mul: __ imull(lreg, rreg); break;
2279         default:      ShouldNotReachHere();
2280       }
2281 
2282     } else if (right-&gt;is_stack()) {
2283       // cpu register - stack
2284       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2285       switch (code) {
2286         case lir_add: __ addl(lreg, raddr); break;
2287         case lir_sub: __ subl(lreg, raddr); break;
2288         default:      ShouldNotReachHere();
2289       }
2290 
2291     } else if (right-&gt;is_constant()) {
2292       // cpu register - constant
2293       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2294       switch (code) {
2295         case lir_add: {
2296           __ incrementl(lreg, c);
2297           break;
2298         }
2299         case lir_sub: {
2300           __ decrementl(lreg, c);
2301           break;
2302         }
2303         default: ShouldNotReachHere();
2304       }
2305 
2306     } else {
2307       ShouldNotReachHere();
2308     }
2309 
2310   } else if (left-&gt;is_double_cpu()) {
2311     assert(left == dest, &quot;left and dest must be equal&quot;);
2312     Register lreg_lo = left-&gt;as_register_lo();
2313     Register lreg_hi = left-&gt;as_register_hi();
2314 
2315     if (right-&gt;is_double_cpu()) {
2316       // cpu register - cpu register
2317       Register rreg_lo = right-&gt;as_register_lo();
2318       Register rreg_hi = right-&gt;as_register_hi();
2319       NOT_LP64(assert_different_registers(lreg_lo, lreg_hi, rreg_lo, rreg_hi));
2320       LP64_ONLY(assert_different_registers(lreg_lo, rreg_lo));
2321       switch (code) {
2322         case lir_add:
2323           __ addptr(lreg_lo, rreg_lo);
2324           NOT_LP64(__ adcl(lreg_hi, rreg_hi));
2325           break;
2326         case lir_sub:
2327           __ subptr(lreg_lo, rreg_lo);
2328           NOT_LP64(__ sbbl(lreg_hi, rreg_hi));
2329           break;
2330         case lir_mul:
2331 #ifdef _LP64
2332           __ imulq(lreg_lo, rreg_lo);
2333 #else
2334           assert(lreg_lo == rax &amp;&amp; lreg_hi == rdx, &quot;must be&quot;);
2335           __ imull(lreg_hi, rreg_lo);
2336           __ imull(rreg_hi, lreg_lo);
2337           __ addl (rreg_hi, lreg_hi);
2338           __ mull (rreg_lo);
2339           __ addl (lreg_hi, rreg_hi);
2340 #endif // _LP64
2341           break;
2342         default:
2343           ShouldNotReachHere();
2344       }
2345 
2346     } else if (right-&gt;is_constant()) {
2347       // cpu register - constant
2348 #ifdef _LP64
2349       jlong c = right-&gt;as_constant_ptr()-&gt;as_jlong_bits();
2350       __ movptr(r10, (intptr_t) c);
2351       switch (code) {
2352         case lir_add:
2353           __ addptr(lreg_lo, r10);
2354           break;
2355         case lir_sub:
2356           __ subptr(lreg_lo, r10);
2357           break;
2358         default:
2359           ShouldNotReachHere();
2360       }
2361 #else
2362       jint c_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2363       jint c_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2364       switch (code) {
2365         case lir_add:
2366           __ addptr(lreg_lo, c_lo);
2367           __ adcl(lreg_hi, c_hi);
2368           break;
2369         case lir_sub:
2370           __ subptr(lreg_lo, c_lo);
2371           __ sbbl(lreg_hi, c_hi);
2372           break;
2373         default:
2374           ShouldNotReachHere();
2375       }
2376 #endif // _LP64
2377 
2378     } else {
2379       ShouldNotReachHere();
2380     }
2381 
2382   } else if (left-&gt;is_single_xmm()) {
2383     assert(left == dest, &quot;left and dest must be equal&quot;);
2384     XMMRegister lreg = left-&gt;as_xmm_float_reg();
2385 
2386     if (right-&gt;is_single_xmm()) {
2387       XMMRegister rreg = right-&gt;as_xmm_float_reg();
2388       switch (code) {
2389         case lir_add: __ addss(lreg, rreg);  break;
2390         case lir_sub: __ subss(lreg, rreg);  break;
2391         case lir_mul_strictfp: // fall through
2392         case lir_mul: __ mulss(lreg, rreg);  break;
2393         case lir_div_strictfp: // fall through
2394         case lir_div: __ divss(lreg, rreg);  break;
2395         default: ShouldNotReachHere();
2396       }
2397     } else {
2398       Address raddr;
2399       if (right-&gt;is_single_stack()) {
2400         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2401       } else if (right-&gt;is_constant()) {
2402         // hack for now
2403         raddr = __ as_Address(InternalAddress(float_constant(right-&gt;as_jfloat())));
2404       } else {
2405         ShouldNotReachHere();
2406       }
2407       switch (code) {
2408         case lir_add: __ addss(lreg, raddr);  break;
2409         case lir_sub: __ subss(lreg, raddr);  break;
2410         case lir_mul_strictfp: // fall through
2411         case lir_mul: __ mulss(lreg, raddr);  break;
2412         case lir_div_strictfp: // fall through
2413         case lir_div: __ divss(lreg, raddr);  break;
2414         default: ShouldNotReachHere();
2415       }
2416     }
2417 
2418   } else if (left-&gt;is_double_xmm()) {
2419     assert(left == dest, &quot;left and dest must be equal&quot;);
2420 
2421     XMMRegister lreg = left-&gt;as_xmm_double_reg();
2422     if (right-&gt;is_double_xmm()) {
2423       XMMRegister rreg = right-&gt;as_xmm_double_reg();
2424       switch (code) {
2425         case lir_add: __ addsd(lreg, rreg);  break;
2426         case lir_sub: __ subsd(lreg, rreg);  break;
2427         case lir_mul_strictfp: // fall through
2428         case lir_mul: __ mulsd(lreg, rreg);  break;
2429         case lir_div_strictfp: // fall through
2430         case lir_div: __ divsd(lreg, rreg);  break;
2431         default: ShouldNotReachHere();
2432       }
2433     } else {
2434       Address raddr;
2435       if (right-&gt;is_double_stack()) {
2436         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2437       } else if (right-&gt;is_constant()) {
2438         // hack for now
2439         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2440       } else {
2441         ShouldNotReachHere();
2442       }
2443       switch (code) {
2444         case lir_add: __ addsd(lreg, raddr);  break;
2445         case lir_sub: __ subsd(lreg, raddr);  break;
2446         case lir_mul_strictfp: // fall through
2447         case lir_mul: __ mulsd(lreg, raddr);  break;
2448         case lir_div_strictfp: // fall through
2449         case lir_div: __ divsd(lreg, raddr);  break;
2450         default: ShouldNotReachHere();
2451       }
2452     }
2453 
2454 #ifndef _LP64
2455   } else if (left-&gt;is_single_fpu()) {
2456     assert(dest-&gt;is_single_fpu(),  &quot;fpu stack allocation required&quot;);
2457 
2458     if (right-&gt;is_single_fpu()) {
2459       arith_fpu_implementation(code, left-&gt;fpu_regnr(), right-&gt;fpu_regnr(), dest-&gt;fpu_regnr(), pop_fpu_stack);
2460 
2461     } else {
2462       assert(left-&gt;fpu_regnr() == 0, &quot;left must be on TOS&quot;);
2463       assert(dest-&gt;fpu_regnr() == 0, &quot;dest must be on TOS&quot;);
2464 
2465       Address raddr;
2466       if (right-&gt;is_single_stack()) {
2467         raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2468       } else if (right-&gt;is_constant()) {
2469         address const_addr = float_constant(right-&gt;as_jfloat());
2470         assert(const_addr != NULL, &quot;incorrect float/double constant maintainance&quot;);
2471         // hack for now
2472         raddr = __ as_Address(InternalAddress(const_addr));
2473       } else {
2474         ShouldNotReachHere();
2475       }
2476 
2477       switch (code) {
2478         case lir_add: __ fadd_s(raddr); break;
2479         case lir_sub: __ fsub_s(raddr); break;
2480         case lir_mul_strictfp: // fall through
2481         case lir_mul: __ fmul_s(raddr); break;
2482         case lir_div_strictfp: // fall through
2483         case lir_div: __ fdiv_s(raddr); break;
2484         default:      ShouldNotReachHere();
2485       }
2486     }
2487 
2488   } else if (left-&gt;is_double_fpu()) {
2489     assert(dest-&gt;is_double_fpu(),  &quot;fpu stack allocation required&quot;);
2490 
2491     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2492       // Double values require special handling for strictfp mul/div on x86
2493       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias1()));
2494       __ fmulp(left-&gt;fpu_regnrLo() + 1);
2495     }
2496 
2497     if (right-&gt;is_double_fpu()) {
2498       arith_fpu_implementation(code, left-&gt;fpu_regnrLo(), right-&gt;fpu_regnrLo(), dest-&gt;fpu_regnrLo(), pop_fpu_stack);
2499 
2500     } else {
2501       assert(left-&gt;fpu_regnrLo() == 0, &quot;left must be on TOS&quot;);
2502       assert(dest-&gt;fpu_regnrLo() == 0, &quot;dest must be on TOS&quot;);
2503 
2504       Address raddr;
2505       if (right-&gt;is_double_stack()) {
2506         raddr = frame_map()-&gt;address_for_slot(right-&gt;double_stack_ix());
2507       } else if (right-&gt;is_constant()) {
2508         // hack for now
2509         raddr = __ as_Address(InternalAddress(double_constant(right-&gt;as_jdouble())));
2510       } else {
2511         ShouldNotReachHere();
2512       }
2513 
2514       switch (code) {
2515         case lir_add: __ fadd_d(raddr); break;
2516         case lir_sub: __ fsub_d(raddr); break;
2517         case lir_mul_strictfp: // fall through
2518         case lir_mul: __ fmul_d(raddr); break;
2519         case lir_div_strictfp: // fall through
2520         case lir_div: __ fdiv_d(raddr); break;
2521         default: ShouldNotReachHere();
2522       }
2523     }
2524 
2525     if (code == lir_mul_strictfp || code == lir_div_strictfp) {
2526       // Double values require special handling for strictfp mul/div on x86
2527       __ fld_x(ExternalAddress(StubRoutines::addr_fpu_subnormal_bias2()));
2528       __ fmulp(dest-&gt;fpu_regnrLo() + 1);
2529     }
2530 #endif // !_LP64
2531 
2532   } else if (left-&gt;is_single_stack() || left-&gt;is_address()) {
2533     assert(left == dest, &quot;left and dest must be equal&quot;);
2534 
2535     Address laddr;
2536     if (left-&gt;is_single_stack()) {
2537       laddr = frame_map()-&gt;address_for_slot(left-&gt;single_stack_ix());
2538     } else if (left-&gt;is_address()) {
2539       laddr = as_Address(left-&gt;as_address_ptr());
2540     } else {
2541       ShouldNotReachHere();
2542     }
2543 
2544     if (right-&gt;is_single_cpu()) {
2545       Register rreg = right-&gt;as_register();
2546       switch (code) {
2547         case lir_add: __ addl(laddr, rreg); break;
2548         case lir_sub: __ subl(laddr, rreg); break;
2549         default:      ShouldNotReachHere();
2550       }
2551     } else if (right-&gt;is_constant()) {
2552       jint c = right-&gt;as_constant_ptr()-&gt;as_jint();
2553       switch (code) {
2554         case lir_add: {
2555           __ incrementl(laddr, c);
2556           break;
2557         }
2558         case lir_sub: {
2559           __ decrementl(laddr, c);
2560           break;
2561         }
2562         default: ShouldNotReachHere();
2563       }
2564     } else {
2565       ShouldNotReachHere();
2566     }
2567 
2568   } else {
2569     ShouldNotReachHere();
2570   }
2571 }
2572 
2573 #ifndef _LP64
2574 void LIR_Assembler::arith_fpu_implementation(LIR_Code code, int left_index, int right_index, int dest_index, bool pop_fpu_stack) {
2575   assert(pop_fpu_stack  || (left_index     == dest_index || right_index     == dest_index), &quot;invalid LIR&quot;);
2576   assert(!pop_fpu_stack || (left_index - 1 == dest_index || right_index - 1 == dest_index), &quot;invalid LIR&quot;);
2577   assert(left_index == 0 || right_index == 0, &quot;either must be on top of stack&quot;);
2578 
2579   bool left_is_tos = (left_index == 0);
2580   bool dest_is_tos = (dest_index == 0);
2581   int non_tos_index = (left_is_tos ? right_index : left_index);
2582 
2583   switch (code) {
2584     case lir_add:
2585       if (pop_fpu_stack)       __ faddp(non_tos_index);
2586       else if (dest_is_tos)    __ fadd (non_tos_index);
2587       else                     __ fadda(non_tos_index);
2588       break;
2589 
2590     case lir_sub:
2591       if (left_is_tos) {
2592         if (pop_fpu_stack)     __ fsubrp(non_tos_index);
2593         else if (dest_is_tos)  __ fsub  (non_tos_index);
2594         else                   __ fsubra(non_tos_index);
2595       } else {
2596         if (pop_fpu_stack)     __ fsubp (non_tos_index);
2597         else if (dest_is_tos)  __ fsubr (non_tos_index);
2598         else                   __ fsuba (non_tos_index);
2599       }
2600       break;
2601 
2602     case lir_mul_strictfp: // fall through
2603     case lir_mul:
2604       if (pop_fpu_stack)       __ fmulp(non_tos_index);
2605       else if (dest_is_tos)    __ fmul (non_tos_index);
2606       else                     __ fmula(non_tos_index);
2607       break;
2608 
2609     case lir_div_strictfp: // fall through
2610     case lir_div:
2611       if (left_is_tos) {
2612         if (pop_fpu_stack)     __ fdivrp(non_tos_index);
2613         else if (dest_is_tos)  __ fdiv  (non_tos_index);
2614         else                   __ fdivra(non_tos_index);
2615       } else {
2616         if (pop_fpu_stack)     __ fdivp (non_tos_index);
2617         else if (dest_is_tos)  __ fdivr (non_tos_index);
2618         else                   __ fdiva (non_tos_index);
2619       }
2620       break;
2621 
2622     case lir_rem:
2623       assert(left_is_tos &amp;&amp; dest_is_tos &amp;&amp; right_index == 1, &quot;must be guaranteed by FPU stack allocation&quot;);
2624       __ fremr(noreg);
2625       break;
2626 
2627     default:
2628       ShouldNotReachHere();
2629   }
2630 }
2631 #endif // _LP64
2632 
2633 
2634 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {
2635   if (value-&gt;is_double_xmm()) {
2636     switch(code) {
2637       case lir_abs :
2638         {
2639 #ifdef _LP64
2640           if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
2641             assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
2642             __ vpandn(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg(), 2);
2643           } else
2644 #endif
2645           {
2646             if (dest-&gt;as_xmm_double_reg() != value-&gt;as_xmm_double_reg()) {
2647               __ movdbl(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg());
2648             }
2649             assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
2650             __ andpd(dest-&gt;as_xmm_double_reg(),
2651                      ExternalAddress((address)double_signmask_pool));
2652           }
2653         }
2654         break;
2655 
2656       case lir_sqrt: __ sqrtsd(dest-&gt;as_xmm_double_reg(), value-&gt;as_xmm_double_reg()); break;
2657       // all other intrinsics are not available in the SSE instruction set, so FPU is used
2658       default      : ShouldNotReachHere();
2659     }
2660 
2661 #ifndef _LP64
2662   } else if (value-&gt;is_double_fpu()) {
2663     assert(value-&gt;fpu_regnrLo() == 0 &amp;&amp; dest-&gt;fpu_regnrLo() == 0, &quot;both must be on TOS&quot;);
2664     switch(code) {
2665       case lir_abs   : __ fabs() ; break;
2666       case lir_sqrt  : __ fsqrt(); break;
2667       default      : ShouldNotReachHere();
2668     }
2669 #endif // !_LP64
2670   } else {
2671     Unimplemented();
2672   }
2673 }
2674 
2675 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst) {
2676   // assert(left-&gt;destroys_register(), &quot;check&quot;);
2677   if (left-&gt;is_single_cpu()) {
2678     Register reg = left-&gt;as_register();
2679     if (right-&gt;is_constant()) {
2680       int val = right-&gt;as_constant_ptr()-&gt;as_jint();
2681       switch (code) {
2682         case lir_logic_and: __ andl (reg, val); break;
2683         case lir_logic_or:  __ orl  (reg, val); break;
2684         case lir_logic_xor: __ xorl (reg, val); break;
2685         default: ShouldNotReachHere();
2686       }
2687     } else if (right-&gt;is_stack()) {
2688       // added support for stack operands
2689       Address raddr = frame_map()-&gt;address_for_slot(right-&gt;single_stack_ix());
2690       switch (code) {
2691         case lir_logic_and: __ andl (reg, raddr); break;
2692         case lir_logic_or:  __ orl  (reg, raddr); break;
2693         case lir_logic_xor: __ xorl (reg, raddr); break;
2694         default: ShouldNotReachHere();
2695       }
2696     } else {
2697       Register rright = right-&gt;as_register();
2698       switch (code) {
2699         case lir_logic_and: __ andptr (reg, rright); break;
2700         case lir_logic_or : __ orptr  (reg, rright); break;
2701         case lir_logic_xor: __ xorptr (reg, rright); break;
2702         default: ShouldNotReachHere();
2703       }
2704     }
2705     move_regs(reg, dst-&gt;as_register());
2706   } else {
2707     Register l_lo = left-&gt;as_register_lo();
2708     Register l_hi = left-&gt;as_register_hi();
2709     if (right-&gt;is_constant()) {
2710 #ifdef _LP64
2711       __ mov64(rscratch1, right-&gt;as_constant_ptr()-&gt;as_jlong());
2712       switch (code) {
2713         case lir_logic_and:
2714           __ andq(l_lo, rscratch1);
2715           break;
2716         case lir_logic_or:
2717           __ orq(l_lo, rscratch1);
2718           break;
2719         case lir_logic_xor:
2720           __ xorq(l_lo, rscratch1);
2721           break;
2722         default: ShouldNotReachHere();
2723       }
2724 #else
2725       int r_lo = right-&gt;as_constant_ptr()-&gt;as_jint_lo();
2726       int r_hi = right-&gt;as_constant_ptr()-&gt;as_jint_hi();
2727       switch (code) {
2728         case lir_logic_and:
2729           __ andl(l_lo, r_lo);
2730           __ andl(l_hi, r_hi);
2731           break;
2732         case lir_logic_or:
2733           __ orl(l_lo, r_lo);
2734           __ orl(l_hi, r_hi);
2735           break;
2736         case lir_logic_xor:
2737           __ xorl(l_lo, r_lo);
2738           __ xorl(l_hi, r_hi);
2739           break;
2740         default: ShouldNotReachHere();
2741       }
2742 #endif // _LP64
2743     } else {
2744 #ifdef _LP64
2745       Register r_lo;
2746       if (is_reference_type(right-&gt;type())) {
2747         r_lo = right-&gt;as_register();
2748       } else {
2749         r_lo = right-&gt;as_register_lo();
2750       }
2751 #else
2752       Register r_lo = right-&gt;as_register_lo();
2753       Register r_hi = right-&gt;as_register_hi();
2754       assert(l_lo != r_hi, &quot;overwriting registers&quot;);
2755 #endif
2756       switch (code) {
2757         case lir_logic_and:
2758           __ andptr(l_lo, r_lo);
2759           NOT_LP64(__ andptr(l_hi, r_hi);)
2760           break;
2761         case lir_logic_or:
2762           __ orptr(l_lo, r_lo);
2763           NOT_LP64(__ orptr(l_hi, r_hi);)
2764           break;
2765         case lir_logic_xor:
2766           __ xorptr(l_lo, r_lo);
2767           NOT_LP64(__ xorptr(l_hi, r_hi);)
2768           break;
2769         default: ShouldNotReachHere();
2770       }
2771     }
2772 
2773     Register dst_lo = dst-&gt;as_register_lo();
2774     Register dst_hi = dst-&gt;as_register_hi();
2775 
2776 #ifdef _LP64
2777     move_regs(l_lo, dst_lo);
2778 #else
2779     if (dst_lo == l_hi) {
2780       assert(dst_hi != l_lo, &quot;overwriting registers&quot;);
2781       move_regs(l_hi, dst_hi);
2782       move_regs(l_lo, dst_lo);
2783     } else {
2784       assert(dst_lo != l_hi, &quot;overwriting registers&quot;);
2785       move_regs(l_lo, dst_lo);
2786       move_regs(l_hi, dst_hi);
2787     }
2788 #endif // _LP64
2789   }
2790 }
2791 
2792 
2793 // we assume that rax, and rdx can be overwritten
2794 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
2795 
2796   assert(left-&gt;is_single_cpu(),   &quot;left must be register&quot;);
2797   assert(right-&gt;is_single_cpu() || right-&gt;is_constant(),  &quot;right must be register or constant&quot;);
2798   assert(result-&gt;is_single_cpu(), &quot;result must be register&quot;);
2799 
2800   //  assert(left-&gt;destroys_register(), &quot;check&quot;);
2801   //  assert(right-&gt;destroys_register(), &quot;check&quot;);
2802 
2803   Register lreg = left-&gt;as_register();
2804   Register dreg = result-&gt;as_register();
2805 
2806   if (right-&gt;is_constant()) {
2807     jint divisor = right-&gt;as_constant_ptr()-&gt;as_jint();
2808     assert(divisor &gt; 0 &amp;&amp; is_power_of_2(divisor), &quot;must be&quot;);
2809     if (code == lir_idiv) {
2810       assert(lreg == rax, &quot;must be rax,&quot;);
2811       assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2812       __ cdql(); // sign extend into rdx:rax
2813       if (divisor == 2) {
2814         __ subl(lreg, rdx);
2815       } else {
2816         __ andl(rdx, divisor - 1);
2817         __ addl(lreg, rdx);
2818       }
2819       __ sarl(lreg, log2_jint(divisor));
2820       move_regs(lreg, dreg);
2821     } else if (code == lir_irem) {
2822       Label done;
2823       __ mov(dreg, lreg);
2824       __ andl(dreg, 0x80000000 | (divisor - 1));
2825       __ jcc(Assembler::positive, done);
2826       __ decrement(dreg);
2827       __ orl(dreg, ~(divisor - 1));
2828       __ increment(dreg);
2829       __ bind(done);
2830     } else {
2831       ShouldNotReachHere();
2832     }
2833   } else {
2834     Register rreg = right-&gt;as_register();
2835     assert(lreg == rax, &quot;left register must be rax,&quot;);
2836     assert(rreg != rdx, &quot;right register must not be rdx&quot;);
2837     assert(temp-&gt;as_register() == rdx, &quot;tmp register must be rdx&quot;);
2838 
2839     move_regs(lreg, rax);
2840 
2841     int idivl_offset = __ corrected_idivl(rreg);
2842     if (ImplicitDiv0Checks) {
2843       add_debug_info_for_div0(idivl_offset, info);
2844     }
2845     if (code == lir_irem) {
2846       move_regs(rdx, dreg); // result is in rdx
2847     } else {
2848       move_regs(rax, dreg);
2849     }
2850   }
2851 }
2852 
2853 
2854 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
2855   if (opr1-&gt;is_single_cpu()) {
2856     Register reg1 = opr1-&gt;as_register();
2857     if (opr2-&gt;is_single_cpu()) {
2858       // cpu register - cpu register
2859       if (is_reference_type(opr1-&gt;type())) {
2860         __ cmpoop(reg1, opr2-&gt;as_register());
2861       } else {
2862         assert(!is_reference_type(opr2-&gt;type()), &quot;cmp int, oop?&quot;);
2863         __ cmpl(reg1, opr2-&gt;as_register());
2864       }
2865     } else if (opr2-&gt;is_stack()) {
2866       // cpu register - stack
2867       if (is_reference_type(opr1-&gt;type())) {
2868         __ cmpoop(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2869       } else {
2870         __ cmpl(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2871       }
2872     } else if (opr2-&gt;is_constant()) {
2873       // cpu register - constant
2874       LIR_Const* c = opr2-&gt;as_constant_ptr();
2875       if (c-&gt;type() == T_INT) {
2876         __ cmpl(reg1, c-&gt;as_jint());
2877       } else if (c-&gt;type() == T_METADATA) {
2878         // All we need for now is a comparison with NULL for equality.
2879         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
2880         Metadata* m = c-&gt;as_metadata();
2881         if (m == NULL) {
2882           __ cmpptr(reg1, (int32_t)0);
2883         } else {
2884           ShouldNotReachHere();
2885         }
2886       } else if (is_reference_type(c-&gt;type())) {
2887         // In 64bit oops are single register
2888         jobject o = c-&gt;as_jobject();
2889         if (o == NULL) {
2890           __ cmpptr(reg1, (int32_t)NULL_WORD);
2891         } else {
2892           __ cmpoop(reg1, o);
2893         }
2894       } else {
2895         fatal(&quot;unexpected type: %s&quot;, basictype_to_str(c-&gt;type()));
2896       }
2897       // cpu register - address
2898     } else if (opr2-&gt;is_address()) {
2899       if (op-&gt;info() != NULL) {
2900         add_debug_info_for_null_check_here(op-&gt;info());
2901       }
2902       __ cmpl(reg1, as_Address(opr2-&gt;as_address_ptr()));
2903     } else {
2904       ShouldNotReachHere();
2905     }
2906 
2907   } else if(opr1-&gt;is_double_cpu()) {
2908     Register xlo = opr1-&gt;as_register_lo();
2909     Register xhi = opr1-&gt;as_register_hi();
2910     if (opr2-&gt;is_double_cpu()) {
2911 #ifdef _LP64
2912       __ cmpptr(xlo, opr2-&gt;as_register_lo());
2913 #else
2914       // cpu register - cpu register
2915       Register ylo = opr2-&gt;as_register_lo();
2916       Register yhi = opr2-&gt;as_register_hi();
2917       __ subl(xlo, ylo);
2918       __ sbbl(xhi, yhi);
2919       if (condition == lir_cond_equal || condition == lir_cond_notEqual) {
2920         __ orl(xhi, xlo);
2921       }
2922 #endif // _LP64
2923     } else if (opr2-&gt;is_constant()) {
2924       // cpu register - constant 0
2925       assert(opr2-&gt;as_jlong() == (jlong)0, &quot;only handles zero&quot;);
2926 #ifdef _LP64
2927       __ cmpptr(xlo, (int32_t)opr2-&gt;as_jlong());
2928 #else
2929       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles equals case&quot;);
2930       __ orl(xhi, xlo);
2931 #endif // _LP64
2932     } else {
2933       ShouldNotReachHere();
2934     }
2935 
2936   } else if (opr1-&gt;is_single_xmm()) {
2937     XMMRegister reg1 = opr1-&gt;as_xmm_float_reg();
2938     if (opr2-&gt;is_single_xmm()) {
2939       // xmm register - xmm register
2940       __ ucomiss(reg1, opr2-&gt;as_xmm_float_reg());
2941     } else if (opr2-&gt;is_stack()) {
2942       // xmm register - stack
2943       __ ucomiss(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;single_stack_ix()));
2944     } else if (opr2-&gt;is_constant()) {
2945       // xmm register - constant
2946       __ ucomiss(reg1, InternalAddress(float_constant(opr2-&gt;as_jfloat())));
2947     } else if (opr2-&gt;is_address()) {
2948       // xmm register - address
2949       if (op-&gt;info() != NULL) {
2950         add_debug_info_for_null_check_here(op-&gt;info());
2951       }
2952       __ ucomiss(reg1, as_Address(opr2-&gt;as_address_ptr()));
2953     } else {
2954       ShouldNotReachHere();
2955     }
2956 
2957   } else if (opr1-&gt;is_double_xmm()) {
2958     XMMRegister reg1 = opr1-&gt;as_xmm_double_reg();
2959     if (opr2-&gt;is_double_xmm()) {
2960       // xmm register - xmm register
2961       __ ucomisd(reg1, opr2-&gt;as_xmm_double_reg());
2962     } else if (opr2-&gt;is_stack()) {
2963       // xmm register - stack
2964       __ ucomisd(reg1, frame_map()-&gt;address_for_slot(opr2-&gt;double_stack_ix()));
2965     } else if (opr2-&gt;is_constant()) {
2966       // xmm register - constant
2967       __ ucomisd(reg1, InternalAddress(double_constant(opr2-&gt;as_jdouble())));
2968     } else if (opr2-&gt;is_address()) {
2969       // xmm register - address
2970       if (op-&gt;info() != NULL) {
2971         add_debug_info_for_null_check_here(op-&gt;info());
2972       }
2973       __ ucomisd(reg1, as_Address(opr2-&gt;pointer()-&gt;as_address()));
2974     } else {
2975       ShouldNotReachHere();
2976     }
2977 
2978 #ifndef _LP64
2979   } else if(opr1-&gt;is_single_fpu() || opr1-&gt;is_double_fpu()) {
2980     assert(opr1-&gt;is_fpu_register() &amp;&amp; opr1-&gt;fpu() == 0, &quot;currently left-hand side must be on TOS (relax this restriction)&quot;);
2981     assert(opr2-&gt;is_fpu_register(), &quot;both must be registers&quot;);
2982     __ fcmp(noreg, opr2-&gt;fpu(), op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
2983 #endif // LP64
2984 
2985   } else if (opr1-&gt;is_address() &amp;&amp; opr2-&gt;is_constant()) {
2986     LIR_Const* c = opr2-&gt;as_constant_ptr();
2987 #ifdef _LP64
2988     if (is_reference_type(c-&gt;type())) {
2989       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;need to reverse&quot;);
2990       __ movoop(rscratch1, c-&gt;as_jobject());
2991     }
2992 #endif // LP64
2993     if (op-&gt;info() != NULL) {
2994       add_debug_info_for_null_check_here(op-&gt;info());
2995     }
2996     // special case: address - constant
2997     LIR_Address* addr = opr1-&gt;as_address_ptr();
2998     if (c-&gt;type() == T_INT) {
2999       __ cmpl(as_Address(addr), c-&gt;as_jint());
3000     } else if (is_reference_type(c-&gt;type())) {
3001 #ifdef _LP64
3002       // %%% Make this explode if addr isn&#39;t reachable until we figure out a
3003       // better strategy by giving noreg as the temp for as_Address
3004       __ cmpoop(rscratch1, as_Address(addr, noreg));
3005 #else
3006       __ cmpoop(as_Address(addr), c-&gt;as_jobject());
3007 #endif // _LP64
3008     } else {
3009       ShouldNotReachHere();
3010     }
3011 
3012   } else {
3013     ShouldNotReachHere();
3014   }
3015 }
3016 
3017 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op) {
3018   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
3019     if (left-&gt;is_single_xmm()) {
3020       assert(right-&gt;is_single_xmm(), &quot;must match&quot;);
3021       __ cmpss2int(left-&gt;as_xmm_float_reg(), right-&gt;as_xmm_float_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
3022     } else if (left-&gt;is_double_xmm()) {
3023       assert(right-&gt;is_double_xmm(), &quot;must match&quot;);
3024       __ cmpsd2int(left-&gt;as_xmm_double_reg(), right-&gt;as_xmm_double_reg(), dst-&gt;as_register(), code == lir_ucmp_fd2i);
3025 
3026     } else {
3027 #ifdef _LP64
3028       ShouldNotReachHere();
3029 #else
3030       assert(left-&gt;is_single_fpu() || left-&gt;is_double_fpu(), &quot;must be&quot;);
3031       assert(right-&gt;is_single_fpu() || right-&gt;is_double_fpu(), &quot;must match&quot;);
3032 
3033       assert(left-&gt;fpu() == 0, &quot;left must be on TOS&quot;);
3034       __ fcmp2int(dst-&gt;as_register(), code == lir_ucmp_fd2i, right-&gt;fpu(),
3035                   op-&gt;fpu_pop_count() &gt; 0, op-&gt;fpu_pop_count() &gt; 1);
3036 #endif // LP64
3037     }
3038   } else {
3039     assert(code == lir_cmp_l2i, &quot;check&quot;);
3040 #ifdef _LP64
3041     Label done;
3042     Register dest = dst-&gt;as_register();
3043     __ cmpptr(left-&gt;as_register_lo(), right-&gt;as_register_lo());
3044     __ movl(dest, -1);
3045     __ jccb(Assembler::less, done);
3046     __ set_byte_if_not_zero(dest);
3047     __ movzbl(dest, dest);
3048     __ bind(done);
3049 #else
3050     __ lcmp2int(left-&gt;as_register_hi(),
3051                 left-&gt;as_register_lo(),
3052                 right-&gt;as_register_hi(),
3053                 right-&gt;as_register_lo());
3054     move_regs(left-&gt;as_register_hi(), dst-&gt;as_register());
3055 #endif // _LP64
3056   }
3057 }
3058 
3059 
3060 void LIR_Assembler::align_call(LIR_Code code) {
3061   // make sure that the displacement word of the call ends up word aligned
3062   int offset = __ offset();
3063   switch (code) {
3064   case lir_static_call:
3065   case lir_optvirtual_call:
3066   case lir_dynamic_call:
3067     offset += NativeCall::displacement_offset;
3068     break;
3069   case lir_icvirtual_call:
3070     offset += NativeCall::displacement_offset + NativeMovConstReg::instruction_size;
3071     break;
3072   case lir_virtual_call:  // currently, sparc-specific for niagara
3073   default: ShouldNotReachHere();
3074   }
3075   __ align(BytesPerWord, offset);
3076 }
3077 
3078 
3079 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
3080   assert((__ offset() + NativeCall::displacement_offset) % BytesPerWord == 0,
3081          &quot;must be aligned&quot;);
3082   __ call(AddressLiteral(op-&gt;addr(), rtype));
3083   add_call_info(code_offset(), op-&gt;info(), op-&gt;maybe_return_as_fields());
3084 }
3085 
3086 
3087 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
3088   __ ic_call(op-&gt;addr());
3089   add_call_info(code_offset(), op-&gt;info(), op-&gt;maybe_return_as_fields());
3090   assert((__ offset() - NativeCall::instruction_size + NativeCall::displacement_offset) % BytesPerWord == 0,
3091          &quot;must be aligned&quot;);
3092 }
3093 
3094 
3095 /* Currently, vtable-dispatch is only enabled for sparc platforms */
3096 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
3097   ShouldNotReachHere();
3098 }
3099 
3100 
3101 void LIR_Assembler::emit_static_call_stub() {
3102   address call_pc = __ pc();
3103   address stub = __ start_a_stub(call_stub_size());
3104   if (stub == NULL) {
3105     bailout(&quot;static call stub overflow&quot;);
3106     return;
3107   }
3108 
3109   int start = __ offset();
3110 
3111   // make sure that the displacement word of the call ends up word aligned
3112   __ align(BytesPerWord, __ offset() + NativeMovConstReg::instruction_size + NativeCall::displacement_offset);
3113   __ relocate(static_stub_Relocation::spec(call_pc, false /* is_aot */));
3114   __ mov_metadata(rbx, (Metadata*)NULL);
3115   // must be set to -1 at code generation time
3116   assert(((__ offset() + 1) % BytesPerWord) == 0, &quot;must be aligned&quot;);
3117   // On 64bit this will die since it will take a movq &amp; jmp, must be only a jmp
3118   __ jump(RuntimeAddress(__ pc()));
3119 
3120   if (UseAOT) {
3121     // Trampoline to aot code
3122     __ relocate(static_stub_Relocation::spec(call_pc, true /* is_aot */));
3123 #ifdef _LP64
3124     __ mov64(rax, CONST64(0));  // address is zapped till fixup time.
3125 #else
3126     __ movl(rax, 0xdeadffff);  // address is zapped till fixup time.
3127 #endif
3128     __ jmp(rax);
3129   }
3130   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
3131   __ end_a_stub();
3132 }
3133 
3134 
3135 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
3136   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3137   assert(exceptionPC-&gt;as_register() == rdx, &quot;must match&quot;);
3138 
3139   // exception object is not added to oop map by LinearScan
3140   // (LinearScan assumes that no oops are in fixed registers)
3141   info-&gt;add_register_oop(exceptionOop);
3142   Runtime1::StubID unwind_id;
3143 
3144   // get current pc information
3145   // pc is only needed if the method has an exception handler, the unwind code does not need it.
3146   int pc_for_athrow_offset = __ offset();
3147   InternalAddress pc_for_athrow(__ pc());
3148   __ lea(exceptionPC-&gt;as_register(), pc_for_athrow);
3149   add_call_info(pc_for_athrow_offset, info); // for exception handler
3150 
3151   __ verify_not_null_oop(rax);
3152   // search an exception handler (rax: exception oop, rdx: throwing pc)
3153   if (compilation()-&gt;has_fpu_code()) {
3154     unwind_id = Runtime1::handle_exception_id;
3155   } else {
3156     unwind_id = Runtime1::handle_exception_nofpu_id;
3157   }
3158   __ call(RuntimeAddress(Runtime1::entry_for(unwind_id)));
3159 
3160   // enough room for two byte trap
3161   __ nop();
3162 }
3163 
3164 
3165 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
3166   assert(exceptionOop-&gt;as_register() == rax, &quot;must match&quot;);
3167 
3168   __ jmp(_unwind_handler_entry);
3169 }
3170 
3171 
3172 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
3173 
3174   // optimized version for linear scan:
3175   // * count must be already in ECX (guaranteed by LinearScan)
3176   // * left and dest must be equal
3177   // * tmp must be unused
3178   assert(count-&gt;as_register() == SHIFT_count, &quot;count must be in ECX&quot;);
3179   assert(left == dest, &quot;left and dest must be equal&quot;);
3180   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3181 
3182   if (left-&gt;is_single_cpu()) {
3183     Register value = left-&gt;as_register();
3184     assert(value != SHIFT_count, &quot;left cannot be ECX&quot;);
3185 
3186     switch (code) {
3187       case lir_shl:  __ shll(value); break;
3188       case lir_shr:  __ sarl(value); break;
3189       case lir_ushr: __ shrl(value); break;
3190       default: ShouldNotReachHere();
3191     }
3192   } else if (left-&gt;is_double_cpu()) {
3193     Register lo = left-&gt;as_register_lo();
3194     Register hi = left-&gt;as_register_hi();
3195     assert(lo != SHIFT_count &amp;&amp; hi != SHIFT_count, &quot;left cannot be ECX&quot;);
3196 #ifdef _LP64
3197     switch (code) {
3198       case lir_shl:  __ shlptr(lo);        break;
3199       case lir_shr:  __ sarptr(lo);        break;
3200       case lir_ushr: __ shrptr(lo);        break;
3201       default: ShouldNotReachHere();
3202     }
3203 #else
3204 
3205     switch (code) {
3206       case lir_shl:  __ lshl(hi, lo);        break;
3207       case lir_shr:  __ lshr(hi, lo, true);  break;
3208       case lir_ushr: __ lshr(hi, lo, false); break;
3209       default: ShouldNotReachHere();
3210     }
3211 #endif // LP64
3212   } else {
3213     ShouldNotReachHere();
3214   }
3215 }
3216 
3217 
3218 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
3219   if (dest-&gt;is_single_cpu()) {
3220     // first move left into dest so that left is not destroyed by the shift
3221     Register value = dest-&gt;as_register();
3222     count = count &amp; 0x1F; // Java spec
3223 
3224     move_regs(left-&gt;as_register(), value);
3225     switch (code) {
3226       case lir_shl:  __ shll(value, count); break;
3227       case lir_shr:  __ sarl(value, count); break;
3228       case lir_ushr: __ shrl(value, count); break;
3229       default: ShouldNotReachHere();
3230     }
3231   } else if (dest-&gt;is_double_cpu()) {
3232 #ifndef _LP64
3233     Unimplemented();
3234 #else
3235     // first move left into dest so that left is not destroyed by the shift
3236     Register value = dest-&gt;as_register_lo();
3237     count = count &amp; 0x1F; // Java spec
3238 
3239     move_regs(left-&gt;as_register_lo(), value);
3240     switch (code) {
3241       case lir_shl:  __ shlptr(value, count); break;
3242       case lir_shr:  __ sarptr(value, count); break;
3243       case lir_ushr: __ shrptr(value, count); break;
3244       default: ShouldNotReachHere();
3245     }
3246 #endif // _LP64
3247   } else {
3248     ShouldNotReachHere();
3249   }
3250 }
3251 
3252 
3253 void LIR_Assembler::store_parameter(Register r, int offset_from_rsp_in_words) {
3254   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3255   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3256   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3257   __ movptr (Address(rsp, offset_from_rsp_in_bytes), r);
3258 }
3259 
3260 
3261 void LIR_Assembler::store_parameter(jint c,     int offset_from_rsp_in_words) {
3262   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3263   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3264   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3265   __ movptr (Address(rsp, offset_from_rsp_in_bytes), c);
3266 }
3267 
3268 
3269 void LIR_Assembler::store_parameter(jobject o,  int offset_from_rsp_in_words) {
3270   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3271   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3272   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3273   __ movoop (Address(rsp, offset_from_rsp_in_bytes), o);
3274 }
3275 
3276 
3277 void LIR_Assembler::store_parameter(Metadata* m,  int offset_from_rsp_in_words) {
3278   assert(offset_from_rsp_in_words &gt;= 0, &quot;invalid offset from rsp&quot;);
3279   int offset_from_rsp_in_bytes = offset_from_rsp_in_words * BytesPerWord;
3280   assert(offset_from_rsp_in_bytes &lt; frame_map()-&gt;reserved_argument_area_size(), &quot;invalid offset&quot;);
3281   __ mov_metadata(Address(rsp, offset_from_rsp_in_bytes), m);
3282 }
3283 
3284 
3285 void LIR_Assembler::arraycopy_valuetype_check(Register obj, Register tmp, CodeStub* slow_path, bool is_dest, bool null_check) {
3286   if (null_check) {
3287     __ testptr(obj, obj);
3288     __ jcc(Assembler::zero, *slow_path-&gt;entry());
3289   }
3290   __ load_storage_props(tmp, obj);
3291   if (is_dest) {
3292     // We also take slow path if it&#39;s a null_free destination array, just in case the source array
3293     // contains NULLs.
3294     __ testb(tmp, ArrayStorageProperties::flattened_value | ArrayStorageProperties::null_free_value);
3295   } else {
3296     __ testb(tmp, ArrayStorageProperties::flattened_value);
3297   }
3298   __ jcc(Assembler::notEqual, *slow_path-&gt;entry());
3299 }
3300 
3301 
3302 // This code replaces a call to arraycopy; no exception may
3303 // be thrown in this code, they must be thrown in the System.arraycopy
3304 // activation frame; we could save some checks if this would not be the case
3305 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
3306   ciArrayKlass* default_type = op-&gt;expected_type();
3307   Register src = op-&gt;src()-&gt;as_register();
3308   Register dst = op-&gt;dst()-&gt;as_register();
3309   Register src_pos = op-&gt;src_pos()-&gt;as_register();
3310   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
3311   Register length  = op-&gt;length()-&gt;as_register();
3312   Register tmp = op-&gt;tmp()-&gt;as_register();
3313 
3314   __ resolve(ACCESS_READ, src);
3315   __ resolve(ACCESS_WRITE, dst);
3316 
3317   CodeStub* stub = op-&gt;stub();
3318   int flags = op-&gt;flags();
3319   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
3320   if (is_reference_type(basic_type)) basic_type = T_OBJECT;
3321 
3322   if (flags &amp; LIR_OpArrayCopy::always_slow_path) {
3323     __ jmp(*stub-&gt;entry());
3324     __ bind(*stub-&gt;continuation());
3325     return;
3326   }
3327 
3328   if (flags &amp; LIR_OpArrayCopy::src_valuetype_check) {
3329     arraycopy_valuetype_check(src, tmp, stub, false, (flags &amp; LIR_OpArrayCopy::src_null_check));
3330   }
3331 
3332   if (flags &amp; LIR_OpArrayCopy::dst_valuetype_check) {
3333     arraycopy_valuetype_check(dst, tmp, stub, true, (flags &amp; LIR_OpArrayCopy::dst_null_check));
3334   }
3335 
3336   // if we don&#39;t know anything, just go through the generic arraycopy
3337   if (default_type == NULL) {
3338     // save outgoing arguments on stack in case call to System.arraycopy is needed
3339     // HACK ALERT. This code used to push the parameters in a hardwired fashion
3340     // for interpreter calling conventions. Now we have to do it in new style conventions.
3341     // For the moment until C1 gets the new register allocator I just force all the
3342     // args to the right place (except the register args) and then on the back side
3343     // reload the register args properly if we go slow path. Yuck
3344 
3345     // These are proper for the calling convention
3346     store_parameter(length, 2);
3347     store_parameter(dst_pos, 1);
3348     store_parameter(dst, 0);
3349 
3350     // these are just temporary placements until we need to reload
3351     store_parameter(src_pos, 3);
3352     store_parameter(src, 4);
3353     NOT_LP64(assert(src == rcx &amp;&amp; src_pos == rdx, &quot;mismatch in calling convention&quot;);)
3354 
3355     address copyfunc_addr = StubRoutines::generic_arraycopy();
3356     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
3357 
3358     // pass arguments: may push as this is not a safepoint; SP must be fix at each safepoint
3359 #ifdef _LP64
3360     // The arguments are in java calling convention so we can trivially shift them to C
3361     // convention
3362     assert_different_registers(c_rarg0, j_rarg1, j_rarg2, j_rarg3, j_rarg4);
3363     __ mov(c_rarg0, j_rarg0);
3364     assert_different_registers(c_rarg1, j_rarg2, j_rarg3, j_rarg4);
3365     __ mov(c_rarg1, j_rarg1);
3366     assert_different_registers(c_rarg2, j_rarg3, j_rarg4);
3367     __ mov(c_rarg2, j_rarg2);
3368     assert_different_registers(c_rarg3, j_rarg4);
3369     __ mov(c_rarg3, j_rarg3);
3370 #ifdef _WIN64
3371     // Allocate abi space for args but be sure to keep stack aligned
3372     __ subptr(rsp, 6*wordSize);
3373     store_parameter(j_rarg4, 4);
3374 #ifndef PRODUCT
3375     if (PrintC1Statistics) {
3376       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3377     }
3378 #endif
3379     __ call(RuntimeAddress(copyfunc_addr));
3380     __ addptr(rsp, 6*wordSize);
3381 #else
3382     __ mov(c_rarg4, j_rarg4);
3383 #ifndef PRODUCT
3384     if (PrintC1Statistics) {
3385       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3386     }
3387 #endif
3388     __ call(RuntimeAddress(copyfunc_addr));
3389 #endif // _WIN64
3390 #else
3391     __ push(length);
3392     __ push(dst_pos);
3393     __ push(dst);
3394     __ push(src_pos);
3395     __ push(src);
3396 
3397 #ifndef PRODUCT
3398     if (PrintC1Statistics) {
3399       __ incrementl(ExternalAddress((address)&amp;Runtime1::_generic_arraycopystub_cnt));
3400     }
3401 #endif
3402     __ call_VM_leaf(copyfunc_addr, 5); // removes pushed parameter from the stack
3403 
3404 #endif // _LP64
3405 
3406     __ cmpl(rax, 0);
3407     __ jcc(Assembler::equal, *stub-&gt;continuation());
3408 
3409     __ mov(tmp, rax);
3410     __ xorl(tmp, -1);
3411 
3412     // Reload values from the stack so they are where the stub
3413     // expects them.
3414     __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3415     __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3416     __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3417     __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3418     __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3419 
3420     __ subl(length, tmp);
3421     __ addl(src_pos, tmp);
3422     __ addl(dst_pos, tmp);
3423     __ jmp(*stub-&gt;entry());
3424 
3425     __ bind(*stub-&gt;continuation());
3426     return;
3427   }
3428 
3429   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass() &amp;&amp; default_type-&gt;is_loaded(), &quot;must be true at this point&quot;);
3430 
3431   int elem_size = type2aelembytes(basic_type);
3432   Address::ScaleFactor scale;
3433 
3434   switch (elem_size) {
3435     case 1 :
3436       scale = Address::times_1;
3437       break;
3438     case 2 :
3439       scale = Address::times_2;
3440       break;
3441     case 4 :
3442       scale = Address::times_4;
3443       break;
3444     case 8 :
3445       scale = Address::times_8;
3446       break;
3447     default:
3448       scale = Address::no_scale;
3449       ShouldNotReachHere();
3450   }
3451 
3452   Address src_length_addr = Address(src, arrayOopDesc::length_offset_in_bytes());
3453   Address dst_length_addr = Address(dst, arrayOopDesc::length_offset_in_bytes());
3454   Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());
3455   Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());
3456 
3457   // length and pos&#39;s are all sign extended at this point on 64bit
3458 
3459   // test for NULL
3460   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
3461     __ testptr(src, src);
3462     __ jcc(Assembler::zero, *stub-&gt;entry());
3463   }
3464   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
3465     __ testptr(dst, dst);
3466     __ jcc(Assembler::zero, *stub-&gt;entry());
3467   }
3468 
3469   // If the compiler was not able to prove that exact type of the source or the destination
3470   // of the arraycopy is an array type, check at runtime if the source or the destination is
3471   // an instance type.
3472   if (flags &amp; LIR_OpArrayCopy::type_check) {
3473     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3474       __ load_klass(tmp, dst);
3475       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3476       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3477     }
3478 
3479     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3480       __ load_klass(tmp, src);
3481       __ cmpl(Address(tmp, in_bytes(Klass::layout_helper_offset())), Klass::_lh_neutral_value);
3482       __ jcc(Assembler::greaterEqual, *stub-&gt;entry());
3483     }
3484   }
3485 
3486   // check if negative
3487   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
3488     __ testl(src_pos, src_pos);
3489     __ jcc(Assembler::less, *stub-&gt;entry());
3490   }
3491   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
3492     __ testl(dst_pos, dst_pos);
3493     __ jcc(Assembler::less, *stub-&gt;entry());
3494   }
3495 
3496   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
3497     __ lea(tmp, Address(src_pos, length, Address::times_1, 0));
3498     __ cmpl(tmp, src_length_addr);
3499     __ jcc(Assembler::above, *stub-&gt;entry());
3500   }
3501   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
3502     __ lea(tmp, Address(dst_pos, length, Address::times_1, 0));
3503     __ cmpl(tmp, dst_length_addr);
3504     __ jcc(Assembler::above, *stub-&gt;entry());
3505   }
3506 
3507   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
3508     __ testl(length, length);
3509     __ jcc(Assembler::less, *stub-&gt;entry());
3510   }
3511 
3512 #ifdef _LP64
3513   __ movl2ptr(src_pos, src_pos); //higher 32bits must be null
3514   __ movl2ptr(dst_pos, dst_pos); //higher 32bits must be null
3515 #endif
3516 
3517   if (flags &amp; LIR_OpArrayCopy::type_check) {
3518     // We don&#39;t know the array types are compatible
3519     if (basic_type != T_OBJECT) {
3520       // Simple test for basic type arrays
3521       if (UseCompressedClassPointers) {
3522         __ movl(tmp, src_klass_addr);
3523         __ cmpl(tmp, dst_klass_addr);
3524       } else {
3525         __ movptr(tmp, src_klass_addr);
3526         __ cmpptr(tmp, dst_klass_addr);
3527       }
3528       __ jcc(Assembler::notEqual, *stub-&gt;entry());
3529     } else {
3530       // For object arrays, if src is a sub class of dst then we can
3531       // safely do the copy.
3532       Label cont, slow;
3533 
3534       __ push(src);
3535       __ push(dst);
3536 
3537       __ load_klass(src, src);
3538       __ load_klass(dst, dst);
3539 
3540       __ check_klass_subtype_fast_path(src, dst, tmp, &amp;cont, &amp;slow, NULL);
3541 
3542       __ push(src);
3543       __ push(dst);
3544       __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::slow_subtype_check_id)));
3545       __ pop(dst);
3546       __ pop(src);
3547 
3548       __ cmpl(src, 0);
3549       __ jcc(Assembler::notEqual, cont);
3550 
3551       __ bind(slow);
3552       __ pop(dst);
3553       __ pop(src);
3554 
3555       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
3556       if (copyfunc_addr != NULL) { // use stub if available
3557         // src is not a sub class of dst so we have to do a
3558         // per-element check.
3559 
3560         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
3561         if ((flags &amp; mask) != mask) {
3562           // Check that at least both of them object arrays.
3563           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
3564 
3565           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
3566             __ load_klass(tmp, src);
3567           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
3568             __ load_klass(tmp, dst);
3569           }
3570           int lh_offset = in_bytes(Klass::layout_helper_offset());
3571           Address klass_lh_addr(tmp, lh_offset);
3572           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
3573           __ cmpl(klass_lh_addr, objArray_lh);
3574           __ jcc(Assembler::notEqual, *stub-&gt;entry());
3575         }
3576 
3577        // Spill because stubs can use any register they like and it&#39;s
3578        // easier to restore just those that we care about.
3579        store_parameter(dst, 0);
3580        store_parameter(dst_pos, 1);
3581        store_parameter(length, 2);
3582        store_parameter(src_pos, 3);
3583        store_parameter(src, 4);
3584 
3585 #ifndef _LP64
3586         __ movptr(tmp, dst_klass_addr);
3587         __ movptr(tmp, Address(tmp, ObjArrayKlass::element_klass_offset()));
3588         __ push(tmp);
3589         __ movl(tmp, Address(tmp, Klass::super_check_offset_offset()));
3590         __ push(tmp);
3591         __ push(length);
3592         __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3593         __ push(tmp);
3594         __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3595         __ push(tmp);
3596 
3597         __ call_VM_leaf(copyfunc_addr, 5);
3598 #else
3599         __ movl2ptr(length, length); //higher 32bits must be null
3600 
3601         __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3602         assert_different_registers(c_rarg0, dst, dst_pos, length);
3603         __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3604         assert_different_registers(c_rarg1, dst, length);
3605 
3606         __ mov(c_rarg2, length);
3607         assert_different_registers(c_rarg2, dst);
3608 
3609 #ifdef _WIN64
3610         // Allocate abi space for args but be sure to keep stack aligned
3611         __ subptr(rsp, 6*wordSize);
3612         __ load_klass(c_rarg3, dst);
3613         __ movptr(c_rarg3, Address(c_rarg3, ObjArrayKlass::element_klass_offset()));
3614         store_parameter(c_rarg3, 4);
3615         __ movl(c_rarg3, Address(c_rarg3, Klass::super_check_offset_offset()));
3616         __ call(RuntimeAddress(copyfunc_addr));
3617         __ addptr(rsp, 6*wordSize);
3618 #else
3619         __ load_klass(c_rarg4, dst);
3620         __ movptr(c_rarg4, Address(c_rarg4, ObjArrayKlass::element_klass_offset()));
3621         __ movl(c_rarg3, Address(c_rarg4, Klass::super_check_offset_offset()));
3622         __ call(RuntimeAddress(copyfunc_addr));
3623 #endif
3624 
3625 #endif
3626 
3627 #ifndef PRODUCT
3628         if (PrintC1Statistics) {
3629           Label failed;
3630           __ testl(rax, rax);
3631           __ jcc(Assembler::notZero, failed);
3632           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_cnt));
3633           __ bind(failed);
3634         }
3635 #endif
3636 
3637         __ testl(rax, rax);
3638         __ jcc(Assembler::zero, *stub-&gt;continuation());
3639 
3640 #ifndef PRODUCT
3641         if (PrintC1Statistics) {
3642           __ incrementl(ExternalAddress((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt));
3643         }
3644 #endif
3645 
3646         __ mov(tmp, rax);
3647 
3648         __ xorl(tmp, -1);
3649 
3650         // Restore previously spilled arguments
3651         __ movptr   (dst,     Address(rsp, 0*BytesPerWord));
3652         __ movptr   (dst_pos, Address(rsp, 1*BytesPerWord));
3653         __ movptr   (length,  Address(rsp, 2*BytesPerWord));
3654         __ movptr   (src_pos, Address(rsp, 3*BytesPerWord));
3655         __ movptr   (src,     Address(rsp, 4*BytesPerWord));
3656 
3657 
3658         __ subl(length, tmp);
3659         __ addl(src_pos, tmp);
3660         __ addl(dst_pos, tmp);
3661       }
3662 
3663       __ jmp(*stub-&gt;entry());
3664 
3665       __ bind(cont);
3666       __ pop(dst);
3667       __ pop(src);
3668     }
3669   }
3670 
3671 #ifdef ASSERT
3672   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
3673     // Sanity check the known type with the incoming class.  For the
3674     // primitive case the types must match exactly with src.klass and
3675     // dst.klass each exactly matching the default type.  For the
3676     // object array case, if no type check is needed then either the
3677     // dst type is exactly the expected type and the src type is a
3678     // subtype which we can&#39;t check or src is the same array as dst
3679     // but not necessarily exactly of type default_type.
3680     Label known_ok, halt;
3681     __ mov_metadata(tmp, default_type-&gt;constant_encoding());
3682 #ifdef _LP64
3683     if (UseCompressedClassPointers) {
3684       __ encode_klass_not_null(tmp);
3685     }
3686 #endif
3687 
3688     if (basic_type != T_OBJECT) {
3689 
3690       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3691       else                   __ cmpptr(tmp, dst_klass_addr);
3692       __ jcc(Assembler::notEqual, halt);
3693       if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);
3694       else                   __ cmpptr(tmp, src_klass_addr);
3695       __ jcc(Assembler::equal, known_ok);
3696     } else {
3697       if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);
3698       else                   __ cmpptr(tmp, dst_klass_addr);
3699       __ jcc(Assembler::equal, known_ok);
3700       __ cmpptr(src, dst);
3701       __ jcc(Assembler::equal, known_ok);
3702     }
3703     __ bind(halt);
3704     __ stop(&quot;incorrect type information in arraycopy&quot;);
3705     __ bind(known_ok);
3706   }
3707 #endif
3708 
3709 #ifndef PRODUCT
3710   if (PrintC1Statistics) {
3711     __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));
3712   }
3713 #endif
3714 
3715 #ifdef _LP64
3716   assert_different_registers(c_rarg0, dst, dst_pos, length);
3717   __ lea(c_rarg0, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3718   assert_different_registers(c_rarg1, length);
3719   __ lea(c_rarg1, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3720   __ mov(c_rarg2, length);
3721 
3722 #else
3723   __ lea(tmp, Address(src, src_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3724   store_parameter(tmp, 0);
3725   __ lea(tmp, Address(dst, dst_pos, scale, arrayOopDesc::base_offset_in_bytes(basic_type)));
3726   store_parameter(tmp, 1);
3727   store_parameter(length, 2);
3728 #endif // _LP64
3729 
3730   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
3731   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
3732   const char *name;
3733   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
3734   __ call_VM_leaf(entry, 0);
3735 
3736   __ bind(*stub-&gt;continuation());
3737 }
3738 
3739 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3740   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
3741   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
3742   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3743   Register crc = op-&gt;crc()-&gt;as_register();
3744   Register val = op-&gt;val()-&gt;as_register();
3745   Register res = op-&gt;result_opr()-&gt;as_register();
3746 
3747   assert_different_registers(val, crc, res);
3748 
3749   __ lea(res, ExternalAddress(StubRoutines::crc_table_addr()));
3750   __ notl(crc); // ~crc
3751   __ update_byte_crc32(crc, val, res);
3752   __ notl(crc); // ~crc
3753   __ mov(res, crc);
3754 }
3755 
3756 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
3757   Register obj = op-&gt;obj_opr()-&gt;as_register();  // may not be an oop
3758   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
3759   Register lock = op-&gt;lock_opr()-&gt;as_register();
3760   if (!UseFastLocking) {
3761     __ jmp(*op-&gt;stub()-&gt;entry());
3762   } else if (op-&gt;code() == lir_lock) {
3763     Register scratch = noreg;
3764     if (UseBiasedLocking) {
3765       scratch = op-&gt;scratch_opr()-&gt;as_register();
3766     }
3767     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3768     __ resolve(ACCESS_READ | ACCESS_WRITE, obj);
3769     // add debug info for NullPointerException only if one is possible
3770     int null_check_offset = __ lock_object(hdr, obj, lock, scratch, *op-&gt;stub()-&gt;entry());
3771     if (op-&gt;info() != NULL) {
3772       add_debug_info_for_null_check(null_check_offset, op-&gt;info());
3773     }
3774     // done
3775   } else if (op-&gt;code() == lir_unlock) {
3776     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
3777     __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
3778   } else {
3779     Unimplemented();
3780   }
3781   __ bind(*op-&gt;stub()-&gt;continuation());
3782 }
3783 
3784 
3785 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
3786   ciMethod* method = op-&gt;profiled_method();
3787   int bci          = op-&gt;profiled_bci();
3788   ciMethod* callee = op-&gt;profiled_callee();
3789 
3790   // Update counter for all call types
3791   ciMethodData* md = method-&gt;method_data_or_null();
3792   assert(md != NULL, &quot;Sanity&quot;);
3793   ciProfileData* data = md-&gt;bci_to_data(bci);
3794   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
3795   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
3796   Register mdo  = op-&gt;mdo()-&gt;as_register();
3797   __ mov_metadata(mdo, md-&gt;constant_encoding());
3798   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()));
3799   // Perform additional virtual call profiling for invokevirtual and
3800   // invokeinterface bytecodes
3801   if (op-&gt;should_profile_receiver_type()) {
3802     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
3803     Register recv = op-&gt;recv()-&gt;as_register();
3804     assert_different_registers(mdo, recv);
3805     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
3806     ciKlass* known_klass = op-&gt;known_holder();
3807     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
3808       // We know the type that will be seen at this call site; we can
3809       // statically update the MethodData* rather than needing to do
3810       // dynamic tests on the receiver type
3811 
3812       // NOTE: we should probably put a lock around this search to
3813       // avoid collisions by concurrent compilations
3814       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
3815       uint i;
3816       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3817         ciKlass* receiver = vc_data-&gt;receiver(i);
3818         if (known_klass-&gt;equals(receiver)) {
3819           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3820           __ addptr(data_addr, DataLayout::counter_increment);
3821           return;
3822         }
3823       }
3824 
3825       // Receiver type not found in profile data; select an empty slot
3826 
3827       // Note that this is less efficient than it should be because it
3828       // always does a write to the receiver part of the
3829       // VirtualCallData rather than just the first time
3830       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
3831         ciKlass* receiver = vc_data-&gt;receiver(i);
3832         if (receiver == NULL) {
3833           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)));
3834           __ mov_metadata(recv_addr, known_klass-&gt;constant_encoding());
3835           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));
3836           __ addptr(data_addr, DataLayout::counter_increment);
3837           return;
3838         }
3839       }
3840     } else {
3841       __ load_klass(recv, recv);
3842       Label update_done;
3843       type_profile_helper(mdo, md, data, recv, &amp;update_done);
3844       // Receiver did not match any saved receiver and there is no empty row for it.
3845       // Increment total counter to indicate polymorphic case.
3846       __ addptr(counter_addr, DataLayout::counter_increment);
3847 
3848       __ bind(update_done);
3849     }
3850   } else {
3851     // Static call
3852     __ addptr(counter_addr, DataLayout::counter_increment);
3853   }
3854 }
3855 
3856 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3857   Register obj = op-&gt;obj()-&gt;as_register();
3858   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3859   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
3860   ciKlass* exact_klass = op-&gt;exact_klass();
3861   intptr_t current_klass = op-&gt;current_klass();
3862   bool not_null = op-&gt;not_null();
3863   bool no_conflict = op-&gt;no_conflict();
3864 
3865   Label update, next, none;
3866 
3867   bool do_null = !not_null;
3868   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3869   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3870 
3871   assert(do_null || do_update, &quot;why are we here?&quot;);
3872   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3873 
3874   __ verify_oop(obj);
3875 
3876   if (tmp != obj) {
3877     __ mov(tmp, obj);
3878   }
3879   if (do_null) {
3880     __ testptr(tmp, tmp);
3881     __ jccb(Assembler::notZero, update);
3882     if (!TypeEntries::was_null_seen(current_klass)) {
3883       __ orptr(mdo_addr, TypeEntries::null_seen);
3884     }
3885     if (do_update) {
3886 #ifndef ASSERT
3887       __ jmpb(next);
3888     }
3889 #else
3890       __ jmp(next);
3891     }
3892   } else {
3893     __ testptr(tmp, tmp);
3894     __ jcc(Assembler::notZero, update);
3895     __ stop(&quot;unexpect null obj&quot;);
3896 #endif
3897   }
3898 
3899   __ bind(update);
3900 
3901   if (do_update) {
3902 #ifdef ASSERT
3903     if (exact_klass != NULL) {
3904       Label ok;
3905       __ load_klass(tmp, tmp);
3906       __ push(tmp);
3907       __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3908       __ cmpptr(tmp, Address(rsp, 0));
3909       __ jcc(Assembler::equal, ok);
3910       __ stop(&quot;exact klass and actual klass differ&quot;);
3911       __ bind(ok);
3912       __ pop(tmp);
3913     }
3914 #endif
3915     if (!no_conflict) {
3916       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3917         if (exact_klass != NULL) {
3918           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3919         } else {
3920           __ load_klass(tmp, tmp);
3921         }
3922 
3923         __ xorptr(tmp, mdo_addr);
3924         __ testptr(tmp, TypeEntries::type_klass_mask);
3925         // klass seen before, nothing to do. The unknown bit may have been
3926         // set already but no need to check.
3927         __ jccb(Assembler::zero, next);
3928 
3929         __ testptr(tmp, TypeEntries::type_unknown);
3930         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3931 
3932         if (TypeEntries::is_type_none(current_klass)) {
3933           __ cmpptr(mdo_addr, 0);
3934           __ jccb(Assembler::equal, none);
3935           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3936           __ jccb(Assembler::equal, none);
3937           // There is a chance that the checks above (re-reading profiling
3938           // data from memory) fail if another thread has just set the
3939           // profiling to this obj&#39;s klass
3940           __ xorptr(tmp, mdo_addr);
3941           __ testptr(tmp, TypeEntries::type_klass_mask);
3942           __ jccb(Assembler::zero, next);
3943         }
3944       } else {
3945         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3946                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3947 
3948         __ movptr(tmp, mdo_addr);
3949         __ testptr(tmp, TypeEntries::type_unknown);
3950         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
3951       }
3952 
3953       // different than before. Cannot keep accurate profile.
3954       __ orptr(mdo_addr, TypeEntries::type_unknown);
3955 
3956       if (TypeEntries::is_type_none(current_klass)) {
3957         __ jmpb(next);
3958 
3959         __ bind(none);
3960         // first time here. Set profile type.
3961         __ movptr(mdo_addr, tmp);
3962       }
3963     } else {
3964       // There&#39;s a single possible klass at this profile point
3965       assert(exact_klass != NULL, &quot;should be&quot;);
3966       if (TypeEntries::is_type_none(current_klass)) {
3967         __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3968         __ xorptr(tmp, mdo_addr);
3969         __ testptr(tmp, TypeEntries::type_klass_mask);
3970 #ifdef ASSERT
3971         __ jcc(Assembler::zero, next);
3972 
3973         {
3974           Label ok;
3975           __ push(tmp);
3976           __ cmpptr(mdo_addr, 0);
3977           __ jcc(Assembler::equal, ok);
3978           __ cmpptr(mdo_addr, TypeEntries::null_seen);
3979           __ jcc(Assembler::equal, ok);
3980           // may have been set by another thread
3981           __ mov_metadata(tmp, exact_klass-&gt;constant_encoding());
3982           __ xorptr(tmp, mdo_addr);
3983           __ testptr(tmp, TypeEntries::type_mask);
3984           __ jcc(Assembler::zero, ok);
3985 
3986           __ stop(&quot;unexpected profiling mismatch&quot;);
3987           __ bind(ok);
3988           __ pop(tmp);
3989         }
3990 #else
3991         __ jccb(Assembler::zero, next);
3992 #endif
3993         // first time here. Set profile type.
3994         __ movptr(mdo_addr, tmp);
3995       } else {
3996         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3997                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3998 
3999         __ movptr(tmp, mdo_addr);
4000         __ testptr(tmp, TypeEntries::type_unknown);
4001         __ jccb(Assembler::notZero, next); // already unknown. Nothing to do anymore.
4002 
4003         __ orptr(mdo_addr, TypeEntries::type_unknown);
4004       }
4005     }
4006 
4007     __ bind(next);
4008   }
4009 }
4010 
4011 void LIR_Assembler::emit_delay(LIR_OpDelay*) {
4012   Unimplemented();
4013 }
4014 
4015 
4016 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst) {
4017   __ lea(dst-&gt;as_register(), frame_map()-&gt;address_for_monitor_lock(monitor_no));
4018 }
4019 
4020 
4021 void LIR_Assembler::align_backward_branch_target() {
4022   __ align(BytesPerWord);
4023 }
4024 
4025 
4026 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
4027   if (left-&gt;is_single_cpu()) {
4028     __ negl(left-&gt;as_register());
4029     move_regs(left-&gt;as_register(), dest-&gt;as_register());
4030 
4031   } else if (left-&gt;is_double_cpu()) {
4032     Register lo = left-&gt;as_register_lo();
4033 #ifdef _LP64
4034     Register dst = dest-&gt;as_register_lo();
4035     __ movptr(dst, lo);
4036     __ negptr(dst);
4037 #else
4038     Register hi = left-&gt;as_register_hi();
4039     __ lneg(hi, lo);
4040     if (dest-&gt;as_register_lo() == hi) {
4041       assert(dest-&gt;as_register_hi() != lo, &quot;destroying register&quot;);
4042       move_regs(hi, dest-&gt;as_register_hi());
4043       move_regs(lo, dest-&gt;as_register_lo());
4044     } else {
4045       move_regs(lo, dest-&gt;as_register_lo());
4046       move_regs(hi, dest-&gt;as_register_hi());
4047     }
4048 #endif // _LP64
4049 
4050   } else if (dest-&gt;is_single_xmm()) {
4051 #ifdef _LP64
4052     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
4053       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
4054       assert_different_registers(left-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg());
4055       __ vpxor(dest-&gt;as_xmm_float_reg(), tmp-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg(), 2);
4056     }
4057     else
4058 #endif
4059     {
4060       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
4061       if (left-&gt;as_xmm_float_reg() != dest-&gt;as_xmm_float_reg()) {
4062         __ movflt(dest-&gt;as_xmm_float_reg(), left-&gt;as_xmm_float_reg());
4063       }
4064       __ xorps(dest-&gt;as_xmm_float_reg(),
4065                ExternalAddress((address)float_signflip_pool));
4066     }
4067   } else if (dest-&gt;is_double_xmm()) {
4068 #ifdef _LP64
4069     if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512vl()) {
4070       assert(tmp-&gt;is_valid(), &quot;need temporary&quot;);
4071       assert_different_registers(left-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg());
4072       __ vpxor(dest-&gt;as_xmm_double_reg(), tmp-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg(), 2);
4073     }
4074     else
4075 #endif
4076     {
4077       assert(!tmp-&gt;is_valid(), &quot;do not need temporary&quot;);
4078       if (left-&gt;as_xmm_double_reg() != dest-&gt;as_xmm_double_reg()) {
4079         __ movdbl(dest-&gt;as_xmm_double_reg(), left-&gt;as_xmm_double_reg());
4080       }
4081       __ xorpd(dest-&gt;as_xmm_double_reg(),
4082                ExternalAddress((address)double_signflip_pool));
4083     }
4084 #ifndef _LP64
4085   } else if (left-&gt;is_single_fpu() || left-&gt;is_double_fpu()) {
4086     assert(left-&gt;fpu() == 0, &quot;arg must be on TOS&quot;);
4087     assert(dest-&gt;fpu() == 0, &quot;dest must be TOS&quot;);
4088     __ fchs();
4089 #endif // !_LP64
4090 
4091   } else {
4092     ShouldNotReachHere();
4093   }
4094 }
4095 
4096 
4097 void LIR_Assembler::leal(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
4098   assert(src-&gt;is_address(), &quot;must be an address&quot;);
4099   assert(dest-&gt;is_register(), &quot;must be a register&quot;);
4100 
4101   PatchingStub* patch = NULL;
4102   if (patch_code != lir_patch_none) {
4103     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
4104   }
4105 
4106   Register reg = dest-&gt;as_pointer_register();
4107   LIR_Address* addr = src-&gt;as_address_ptr();
4108   __ lea(reg, as_Address(addr));
4109 
4110   if (patch != NULL) {
4111     patching_epilog(patch, patch_code, addr-&gt;base()-&gt;as_register(), info);
4112   }
4113 }
4114 
4115 
4116 
4117 void LIR_Assembler::rt_call(LIR_Opr result, address dest, const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
4118   assert(!tmp-&gt;is_valid(), &quot;don&#39;t need temporary&quot;);
4119   __ call(RuntimeAddress(dest));
4120   if (info != NULL) {
4121     add_call_info_here(info);
4122   }
4123 }
4124 
4125 
4126 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
4127   assert(type == T_LONG, &quot;only for volatile long fields&quot;);
4128 
4129   if (info != NULL) {
4130     add_debug_info_for_null_check_here(info);
4131   }
4132 
4133   if (src-&gt;is_double_xmm()) {
4134     if (dest-&gt;is_double_cpu()) {
4135 #ifdef _LP64
4136       __ movdq(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
4137 #else
4138       __ movdl(dest-&gt;as_register_lo(), src-&gt;as_xmm_double_reg());
4139       __ psrlq(src-&gt;as_xmm_double_reg(), 32);
4140       __ movdl(dest-&gt;as_register_hi(), src-&gt;as_xmm_double_reg());
4141 #endif // _LP64
4142     } else if (dest-&gt;is_double_stack()) {
4143       __ movdbl(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()), src-&gt;as_xmm_double_reg());
4144     } else if (dest-&gt;is_address()) {
4145       __ movdbl(as_Address(dest-&gt;as_address_ptr()), src-&gt;as_xmm_double_reg());
4146     } else {
4147       ShouldNotReachHere();
4148     }
4149 
4150   } else if (dest-&gt;is_double_xmm()) {
4151     if (src-&gt;is_double_stack()) {
4152       __ movdbl(dest-&gt;as_xmm_double_reg(), frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
4153     } else if (src-&gt;is_address()) {
4154       __ movdbl(dest-&gt;as_xmm_double_reg(), as_Address(src-&gt;as_address_ptr()));
4155     } else {
4156       ShouldNotReachHere();
4157     }
4158 
4159 #ifndef _LP64
4160   } else if (src-&gt;is_double_fpu()) {
4161     assert(src-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
4162     if (dest-&gt;is_double_stack()) {
4163       __ fistp_d(frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix()));
4164     } else if (dest-&gt;is_address()) {
4165       __ fistp_d(as_Address(dest-&gt;as_address_ptr()));
4166     } else {
4167       ShouldNotReachHere();
4168     }
4169 
4170   } else if (dest-&gt;is_double_fpu()) {
4171     assert(dest-&gt;fpu_regnrLo() == 0, &quot;must be TOS&quot;);
4172     if (src-&gt;is_double_stack()) {
4173       __ fild_d(frame_map()-&gt;address_for_slot(src-&gt;double_stack_ix()));
4174     } else if (src-&gt;is_address()) {
4175       __ fild_d(as_Address(src-&gt;as_address_ptr()));
4176     } else {
4177       ShouldNotReachHere();
4178     }
4179 #endif // !_LP64
4180 
4181   } else {
4182     ShouldNotReachHere();
4183   }
4184 }
4185 
4186 #ifdef ASSERT
4187 // emit run-time assertion
4188 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
4189   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
4190 
4191   if (op-&gt;in_opr1()-&gt;is_valid()) {
4192     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
4193     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
4194   } else {
4195     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
4196     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
4197   }
4198 
4199   Label ok;
4200   if (op-&gt;condition() != lir_cond_always) {
4201     Assembler::Condition acond = Assembler::zero;
4202     switch (op-&gt;condition()) {
4203       case lir_cond_equal:        acond = Assembler::equal;       break;
4204       case lir_cond_notEqual:     acond = Assembler::notEqual;    break;
4205       case lir_cond_less:         acond = Assembler::less;        break;
4206       case lir_cond_lessEqual:    acond = Assembler::lessEqual;   break;
4207       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;break;
4208       case lir_cond_greater:      acond = Assembler::greater;     break;
4209       case lir_cond_belowEqual:   acond = Assembler::belowEqual;  break;
4210       case lir_cond_aboveEqual:   acond = Assembler::aboveEqual;  break;
4211       default:                    ShouldNotReachHere();
4212     }
4213     __ jcc(acond, ok);
4214   }
4215   if (op-&gt;halt()) {
4216     const char* str = __ code_string(op-&gt;msg());
4217     __ stop(str);
4218   } else {
4219     breakpoint();
4220   }
4221   __ bind(ok);
4222 }
4223 #endif
4224 
4225 void LIR_Assembler::membar() {
4226   // QQQ sparc TSO uses this,
4227   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad));
4228 }
4229 
4230 void LIR_Assembler::membar_acquire() {
4231   // No x86 machines currently require load fences
4232 }
4233 
4234 void LIR_Assembler::membar_release() {
4235   // No x86 machines currently require store fences
4236 }
4237 
4238 void LIR_Assembler::membar_loadload() {
4239   // no-op
4240   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
4241 }
4242 
4243 void LIR_Assembler::membar_storestore() {
4244   // no-op
4245   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
4246 }
4247 
4248 void LIR_Assembler::membar_loadstore() {
4249   // no-op
4250   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
4251 }
4252 
4253 void LIR_Assembler::membar_storeload() {
4254   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
4255 }
4256 
4257 void LIR_Assembler::on_spin_wait() {
4258   __ pause ();
4259 }
4260 
4261 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
4262   assert(result_reg-&gt;is_register(), &quot;check&quot;);
4263 #ifdef _LP64
4264   // __ get_thread(result_reg-&gt;as_register_lo());
4265   __ mov(result_reg-&gt;as_register(), r15_thread);
4266 #else
4267   __ get_thread(result_reg-&gt;as_register());
4268 #endif // _LP64
4269 }
4270 
4271 void LIR_Assembler::check_orig_pc() {
4272   __ cmpptr(frame_map()-&gt;address_for_orig_pc_addr(), (int32_t)NULL_WORD);
4273 }
4274 
4275 void LIR_Assembler::peephole(LIR_List*) {
4276   // do nothing for now
4277 }
4278 
4279 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
4280   assert(data == dest, &quot;xchg/xadd uses only 2 operands&quot;);
4281 
4282   if (data-&gt;type() == T_INT) {
4283     if (code == lir_xadd) {
4284       __ lock();
4285       __ xaddl(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register());
4286     } else {
4287       __ xchgl(data-&gt;as_register(), as_Address(src-&gt;as_address_ptr()));
4288     }
4289   } else if (data-&gt;is_oop()) {
4290     assert (code == lir_xchg, &quot;xadd for oops&quot;);
4291     Register obj = data-&gt;as_register();
4292 #ifdef _LP64
4293     if (UseCompressedOops) {
4294       __ encode_heap_oop(obj);
4295       __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4296       __ decode_heap_oop(obj);
4297     } else {
4298       __ xchgptr(obj, as_Address(src-&gt;as_address_ptr()));
4299     }
4300 #else
4301     __ xchgl(obj, as_Address(src-&gt;as_address_ptr()));
4302 #endif
4303   } else if (data-&gt;type() == T_LONG) {
4304 #ifdef _LP64
4305     assert(data-&gt;as_register_lo() == data-&gt;as_register_hi(), &quot;should be a single register&quot;);
4306     if (code == lir_xadd) {
4307       __ lock();
4308       __ xaddq(as_Address(src-&gt;as_address_ptr()), data-&gt;as_register_lo());
4309     } else {
4310       __ xchgq(data-&gt;as_register_lo(), as_Address(src-&gt;as_address_ptr()));
4311     }
4312 #else
4313     ShouldNotReachHere();
4314 #endif
4315   } else {
4316     ShouldNotReachHere();
4317   }
4318 }
4319 
4320 #undef __
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
  360   return UseCompressedOops || UseCompressedClassPointers;
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 // Indicate if the safepoint node needs the polling page as an input,
  463 // it does if the polling page is more than disp32 away.
  464 bool SafePointNode::needs_polling_address_input()
  465 {
  466   return SafepointMechanism::uses_thread_local_poll() || Assembler::is_polling_page_far();
  467 }
  468 
  469 //
  470 // Compute padding required for nodes which need alignment
  471 //
  472 
  473 // The address of the call instruction needs to be 4-byte aligned to
  474 // ensure that it does not span a cache line so that it can be patched.
  475 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  476 {
  477   current_offset += clear_avx_size(); // skip vzeroupper
  478   current_offset += 1; // skip call opcode byte
  479   return align_up(current_offset, alignment_required()) - current_offset;
  480 }
  481 
  482 // The address of the call instruction needs to be 4-byte aligned to
  483 // ensure that it does not span a cache line so that it can be patched.
  484 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  485 {
  486   current_offset += clear_avx_size(); // skip vzeroupper
  487   current_offset += 11; // skip movq instruction + call opcode byte
  488   return align_up(current_offset, alignment_required()) - current_offset;
  489 }
  490 
  491 // EMIT_RM()
  492 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  493   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  494   cbuf.insts()-&gt;emit_int8(c);
  495 }
  496 
  497 // EMIT_CC()
  498 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  499   unsigned char c = (unsigned char) (f1 | f2);
  500   cbuf.insts()-&gt;emit_int8(c);
  501 }
  502 
  503 // EMIT_OPCODE()
  504 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  505   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  506 }
  507 
  508 // EMIT_OPCODE() w/ relocation information
  509 void emit_opcode(CodeBuffer &amp;cbuf,
  510                  int code, relocInfo::relocType reloc, int offset, int format)
  511 {
  512   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  513   emit_opcode(cbuf, code);
  514 }
  515 
  516 // EMIT_D8()
  517 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  518   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  519 }
  520 
  521 // EMIT_D16()
  522 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  523   cbuf.insts()-&gt;emit_int16(d16);
  524 }
  525 
  526 // EMIT_D32()
  527 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  528   cbuf.insts()-&gt;emit_int32(d32);
  529 }
  530 
  531 // EMIT_D64()
  532 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  533   cbuf.insts()-&gt;emit_int64(d64);
  534 }
  535 
  536 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  537 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  538                     int d32,
  539                     relocInfo::relocType reloc,
  540                     int format)
  541 {
  542   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  543   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  544   cbuf.insts()-&gt;emit_int32(d32);
  545 }
  546 
  547 // emit 32 bit value and construct relocation entry from RelocationHolder
  548 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  549 #ifdef ASSERT
  550   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  551       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  552     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  553     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  554   }
  555 #endif
  556   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  557   cbuf.insts()-&gt;emit_int32(d32);
  558 }
  559 
  560 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  561   address next_ip = cbuf.insts_end() + 4;
  562   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  563                  external_word_Relocation::spec(addr),
  564                  RELOC_DISP32);
  565 }
  566 
  567 
  568 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  569 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  570   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  571   cbuf.insts()-&gt;emit_int64(d64);
  572 }
  573 
  574 // emit 64 bit value and construct relocation entry from RelocationHolder
  575 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  576 #ifdef ASSERT
  577   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  578       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  579     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  580     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  581   }
  582 #endif
  583   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  584   cbuf.insts()-&gt;emit_int64(d64);
  585 }
  586 
  587 // Access stack slot for load or store
  588 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  589 {
  590   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  591   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  592     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  593     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  594     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  595   } else {
  596     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  597     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  598     emit_d32(cbuf, disp);     // Displacement // R/M byte
  599   }
  600 }
  601 
  602    // rRegI ereg, memory mem) %{    // emit_reg_mem
  603 void encode_RegMem(CodeBuffer &amp;cbuf,
  604                    int reg,
  605                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  606 {
  607   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  608   int regenc = reg &amp; 7;
  609   int baseenc = base &amp; 7;
  610   int indexenc = index &amp; 7;
  611 
  612   // There is no index &amp; no scale, use form without SIB byte
  613   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  614     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  615     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  616       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  617     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  618       // If 8-bit displacement, mode 0x1
  619       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  620       emit_d8(cbuf, disp);
  621     } else {
  622       // If 32-bit displacement
  623       if (base == -1) { // Special flag for absolute address
  624         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  625         if (disp_reloc != relocInfo::none) {
  626           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  627         } else {
  628           emit_d32(cbuf, disp);
  629         }
  630       } else {
  631         // Normal base + offset
  632         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  633         if (disp_reloc != relocInfo::none) {
  634           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  635         } else {
  636           emit_d32(cbuf, disp);
  637         }
  638       }
  639     }
  640   } else {
  641     // Else, encode with the SIB byte
  642     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  643     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  644       // If no displacement
  645       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  646       emit_rm(cbuf, scale, indexenc, baseenc);
  647     } else {
  648       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  649         // If 8-bit displacement, mode 0x1
  650         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  651         emit_rm(cbuf, scale, indexenc, baseenc);
  652         emit_d8(cbuf, disp);
  653       } else {
  654         // If 32-bit displacement
  655         if (base == 0x04 ) {
  656           emit_rm(cbuf, 0x2, regenc, 0x4);
  657           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  658         } else {
  659           emit_rm(cbuf, 0x2, regenc, 0x4);
  660           emit_rm(cbuf, scale, indexenc, baseenc); // *
  661         }
  662         if (disp_reloc != relocInfo::none) {
  663           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  664         } else {
  665           emit_d32(cbuf, disp);
  666         }
  667       }
  668     }
  669   }
  670 }
  671 
  672 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  673 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  674   Label exit;
  675   __ jccb(Assembler::noParity, exit);
  676   __ pushf();
  677   //
  678   // comiss/ucomiss instructions set ZF,PF,CF flags and
  679   // zero OF,AF,SF for NaN values.
  680   // Fixup flags by zeroing ZF,PF so that compare of NaN
  681   // values returns &#39;less than&#39; result (CF is set).
  682   // Leave the rest of flags unchanged.
  683   //
  684   //    7 6 5 4 3 2 1 0
  685   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  686   //    0 0 1 0 1 0 1 1   (0x2B)
  687   //
  688   __ andq(Address(rsp, 0), 0xffffff2b);
  689   __ popf();
  690   __ bind(exit);
  691 }
  692 
  693 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  694   Label done;
  695   __ movl(dst, -1);
  696   __ jcc(Assembler::parity, done);
  697   __ jcc(Assembler::below, done);
  698   __ setb(Assembler::notEqual, dst);
  699   __ movzbl(dst, dst);
  700   __ bind(done);
  701 }
  702 
  703 // Math.min()    # Math.max()
  704 // --------------------------
  705 // ucomis[s/d]   #
  706 // ja   -&gt; b     # a
  707 // jp   -&gt; NaN   # NaN
  708 // jb   -&gt; a     # b
  709 // je            #
  710 // |-jz -&gt; a | b # a &amp; b
  711 // |    -&gt; a     #
  712 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  713                      XMMRegister a, XMMRegister b,
  714                      XMMRegister xmmt, Register rt,
  715                      bool min, bool single) {
  716 
  717   Label nan, zero, below, above, done;
  718 
  719   if (single)
  720     __ ucomiss(a, b);
  721   else
  722     __ ucomisd(a, b);
  723 
  724   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  725     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  726   else
  727     __ jccb(Assembler::above, done);
  728 
  729   __ jccb(Assembler::parity, nan);  // PF=1
  730   __ jccb(Assembler::below, below); // CF=1
  731 
  732   // equal
  733   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  734   if (single) {
  735     __ ucomiss(a, xmmt);
  736     __ jccb(Assembler::equal, zero);
  737 
  738     __ movflt(dst, a);
  739     __ jmp(done);
  740   }
  741   else {
  742     __ ucomisd(a, xmmt);
  743     __ jccb(Assembler::equal, zero);
  744 
  745     __ movdbl(dst, a);
  746     __ jmp(done);
  747   }
  748 
  749   __ bind(zero);
  750   if (min)
  751     __ vpor(dst, a, b, Assembler::AVX_128bit);
  752   else
  753     __ vpand(dst, a, b, Assembler::AVX_128bit);
  754 
  755   __ jmp(done);
  756 
  757   __ bind(above);
  758   if (single)
  759     __ movflt(dst, min ? b : a);
  760   else
  761     __ movdbl(dst, min ? b : a);
  762 
  763   __ jmp(done);
  764 
  765   __ bind(nan);
  766   if (single) {
  767     __ movl(rt, 0x7fc00000); // Float.NaN
  768     __ movdl(dst, rt);
  769   }
  770   else {
  771     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  772     __ movdq(dst, rt);
  773   }
  774   __ jmp(done);
  775 
  776   __ bind(below);
  777   if (single)
  778     __ movflt(dst, min ? a : b);
  779   else
  780     __ movdbl(dst, min ? a : b);
  781 
  782   __ bind(done);
  783 }
  784 
  785 //=============================================================================
  786 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  787 
  788 int Compile::ConstantTable::calculate_table_base_offset() const {
  789   return 0;  // absolute addressing, no offset
  790 }
  791 
  792 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  793 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  794   ShouldNotReachHere();
  795 }
  796 
  797 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  798   // Empty encoding
  799 }
  800 
  801 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  802   return 0;
  803 }
  804 
  805 #ifndef PRODUCT
  806 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  807   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  808 }
  809 #endif
  810 
  811 
  812 //=============================================================================
  813 #ifndef PRODUCT
  814 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  815   Compile* C = ra_-&gt;C;
  816 
  817   int framesize = C-&gt;frame_size_in_bytes();
  818   int bangsize = C-&gt;bang_size_in_bytes();
  819   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  820   // Remove wordSize for return addr which is already pushed.
  821   framesize -= wordSize;
  822 
  823   if (C-&gt;need_stack_bang(bangsize)) {
  824     framesize -= wordSize;
  825     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  826     st-&gt;print(&quot;\n\t&quot;);
  827     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  828     if (PreserveFramePointer) {
  829         st-&gt;print(&quot;\n\t&quot;);
  830         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  831     }
  832     if (framesize) {
  833       st-&gt;print(&quot;\n\t&quot;);
  834       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  835     }
  836   } else {
  837     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  838     st-&gt;print(&quot;\n\t&quot;);
  839     framesize -= wordSize;
  840     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  841     if (PreserveFramePointer) {
  842       st-&gt;print(&quot;\n\t&quot;);
  843       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  844       if (framesize &gt; 0) {
  845         st-&gt;print(&quot;\n\t&quot;);
  846         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  847       }
  848     }
  849   }
  850 
  851   if (VerifyStackAtCalls) {
  852     st-&gt;print(&quot;\n\t&quot;);
  853     framesize -= wordSize;
  854     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  855 #ifdef ASSERT
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;# stack alignment check&quot;);
  858 #endif
  859   }
  860   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  861     st-&gt;print(&quot;\n\t&quot;);
  862     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  863     st-&gt;print(&quot;\n\t&quot;);
  864     st-&gt;print(&quot;je      fast_entry\t&quot;);
  865     st-&gt;print(&quot;\n\t&quot;);
  866     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  867     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  868   }
  869   st-&gt;cr();
  870 }
  871 #endif
  872 
  873 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  874   Compile* C = ra_-&gt;C;
  875   MacroAssembler _masm(&amp;cbuf);
  876 
  877   if (C-&gt;clinit_barrier_on_entry()) {
  878     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  879     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  880 
  881     Label L_skip_barrier;
  882     Register klass = rscratch1;
  883 
  884     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  885     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  886 
  887     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  888 
  889     __ bind(L_skip_barrier);
  890   }
  891 
  892   __ verified_entry(C);
  893   __ bind(*_verified_entry);
  894 
  895   if (C-&gt;stub_function() == NULL) {
  896     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  897     bs-&gt;nmethod_entry_barrier(&amp;_masm);
  898   }
  899 
  900   C-&gt;set_frame_complete(cbuf.insts_size());
  901 
  902   if (C-&gt;has_mach_constant_base_node()) {
  903     // NOTE: We set the table base offset here because users might be
  904     // emitted before MachConstantBaseNode.
  905     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
  906     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  907   }
  908 }
  909 
  910 int MachPrologNode::reloc() const
  911 {
  912   return 0; // a large enough number
  913 }
  914 
  915 //=============================================================================
  916 #ifndef PRODUCT
  917 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  918 {
  919   Compile* C = ra_-&gt;C;
  920   if (generate_vzeroupper(C)) {
  921     st-&gt;print(&quot;vzeroupper&quot;);
  922     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  923   }
  924 
  925   int framesize = C-&gt;frame_size_in_bytes();
  926   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  927   // Remove word for return adr already pushed
  928   // and RBP
  929   framesize -= 2*wordSize;
  930 
  931   if (framesize) {
  932     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  933     st-&gt;print(&quot;\t&quot;);
  934   }
  935 
  936   st-&gt;print_cr(&quot;popq    rbp&quot;);
  937   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  938     st-&gt;print(&quot;\t&quot;);
  939     if (SafepointMechanism::uses_thread_local_poll()) {
  940       st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  941                    &quot;testl   rax, [rscratch1]\t&quot;
  942                    &quot;# Safepoint: poll for GC&quot;);
  943     } else if (Assembler::is_polling_page_far()) {
  944       st-&gt;print_cr(&quot;movq    rscratch1, #polling_page_address\n\t&quot;
  945                    &quot;testl   rax, [rscratch1]\t&quot;
  946                    &quot;# Safepoint: poll for GC&quot;);
  947     } else {
  948       st-&gt;print_cr(&quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;
  949                    &quot;# Safepoint: poll for GC&quot;);
  950     }
  951   }
  952 }
  953 #endif
  954 
  955 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  956 {
  957   Compile* C = ra_-&gt;C;
  958   MacroAssembler _masm(&amp;cbuf);
  959 
  960   if (generate_vzeroupper(C)) {
  961     // Clear upper bits of YMM registers when current compiled code uses
  962     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  963     __ vzeroupper();
  964   }
  965 
<a name="1" id="anc1"></a><span class="line-modified">  966   __ restore_stack(C);</span>
<span class="line-modified">  967 </span>

  968 
  969   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  970     __ reserved_stack_check();
  971   }
  972 
  973   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  974     MacroAssembler _masm(&amp;cbuf);
  975     if (SafepointMechanism::uses_thread_local_poll()) {
  976       __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  977       __ relocate(relocInfo::poll_return_type);
  978       __ testl(rax, Address(rscratch1, 0));
  979     } else {
  980       AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
  981       if (Assembler::is_polling_page_far()) {
  982         __ lea(rscratch1, polling_page);
  983         __ relocate(relocInfo::poll_return_type);
  984         __ testl(rax, Address(rscratch1, 0));
  985       } else {
  986         __ testl(rax, polling_page);
  987       }
  988     }
  989   }
  990 }
  991 
  992 int MachEpilogNode::reloc() const
  993 {
  994   return 2; // a large enough number
  995 }
  996 
  997 const Pipeline* MachEpilogNode::pipeline() const
  998 {
  999   return MachNode::pipeline_class();
 1000 }
 1001 
 1002 int MachEpilogNode::safepoint_offset() const
 1003 {
 1004   return 0;
 1005 }
 1006 
 1007 //=============================================================================
 1008 
 1009 enum RC {
 1010   rc_bad,
 1011   rc_int,
 1012   rc_float,
 1013   rc_stack
 1014 };
 1015 
 1016 static enum RC rc_class(OptoReg::Name reg)
 1017 {
 1018   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1019 
 1020   if (OptoReg::is_stack(reg)) return rc_stack;
 1021 
 1022   VMReg r = OptoReg::as_VMReg(reg);
 1023 
 1024   if (r-&gt;is_Register()) return rc_int;
 1025 
 1026   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1027   return rc_float;
 1028 }
 1029 
 1030 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1031 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1032                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1033 
 1034 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1035                      int stack_offset, int reg, uint ireg, outputStream* st);
 1036 
 1037 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1038                                       int dst_offset, uint ireg, outputStream* st) {
 1039   if (cbuf) {
 1040     MacroAssembler _masm(cbuf);
 1041     switch (ireg) {
 1042     case Op_VecS:
 1043       __ movq(Address(rsp, -8), rax);
 1044       __ movl(rax, Address(rsp, src_offset));
 1045       __ movl(Address(rsp, dst_offset), rax);
 1046       __ movq(rax, Address(rsp, -8));
 1047       break;
 1048     case Op_VecD:
 1049       __ pushq(Address(rsp, src_offset));
 1050       __ popq (Address(rsp, dst_offset));
 1051       break;
 1052     case Op_VecX:
 1053       __ pushq(Address(rsp, src_offset));
 1054       __ popq (Address(rsp, dst_offset));
 1055       __ pushq(Address(rsp, src_offset+8));
 1056       __ popq (Address(rsp, dst_offset+8));
 1057       break;
 1058     case Op_VecY:
 1059       __ vmovdqu(Address(rsp, -32), xmm0);
 1060       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1061       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1062       __ vmovdqu(xmm0, Address(rsp, -32));
 1063       break;
 1064     case Op_VecZ:
 1065       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1066       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1067       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1068       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1069       break;
 1070     default:
 1071       ShouldNotReachHere();
 1072     }
 1073 #ifndef PRODUCT
 1074   } else {
 1075     switch (ireg) {
 1076     case Op_VecS:
 1077       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1078                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1079                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1080                 &quot;movq    rax, [rsp - #8]&quot;,
 1081                 src_offset, dst_offset);
 1082       break;
 1083     case Op_VecD:
 1084       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1085                 &quot;popq    [rsp + #%d]&quot;,
 1086                 src_offset, dst_offset);
 1087       break;
 1088      case Op_VecX:
 1089       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1090                 &quot;popq    [rsp + #%d]\n\t&quot;
 1091                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1092                 &quot;popq    [rsp + #%d]&quot;,
 1093                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1094       break;
 1095     case Op_VecY:
 1096       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1097                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1098                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1099                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1100                 src_offset, dst_offset);
 1101       break;
 1102     case Op_VecZ:
 1103       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1104                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1105                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1106                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1107                 src_offset, dst_offset);
 1108       break;
 1109     default:
 1110       ShouldNotReachHere();
 1111     }
 1112 #endif
 1113   }
 1114 }
 1115 
 1116 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1117                                        PhaseRegAlloc* ra_,
 1118                                        bool do_size,
 1119                                        outputStream* st) const {
 1120   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1121   // Get registers to move
 1122   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1123   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1124   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1125   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1126 
 1127   enum RC src_second_rc = rc_class(src_second);
 1128   enum RC src_first_rc = rc_class(src_first);
 1129   enum RC dst_second_rc = rc_class(dst_second);
 1130   enum RC dst_first_rc = rc_class(dst_first);
 1131 
 1132   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1133          &quot;must move at least 1 register&quot; );
 1134 
 1135   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1136     // Self copy, no move
 1137     return 0;
 1138   }
 1139   if (bottom_type()-&gt;isa_vect() != NULL) {
 1140     uint ireg = ideal_reg();
 1141     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1142     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1143     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1144       // mem -&gt; mem
 1145       int src_offset = ra_-&gt;reg2offset(src_first);
 1146       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1147       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1148     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1149       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1150     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1151       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1152       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1153     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1154       int stack_offset = ra_-&gt;reg2offset(src_first);
 1155       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1156     } else {
 1157       ShouldNotReachHere();
 1158     }
 1159     return 0;
 1160   }
 1161   if (src_first_rc == rc_stack) {
 1162     // mem -&gt;
 1163     if (dst_first_rc == rc_stack) {
 1164       // mem -&gt; mem
 1165       assert(src_second != dst_first, &quot;overlap&quot;);
 1166       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1167           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1168         // 64-bit
 1169         int src_offset = ra_-&gt;reg2offset(src_first);
 1170         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1171         if (cbuf) {
 1172           MacroAssembler _masm(cbuf);
 1173           __ pushq(Address(rsp, src_offset));
 1174           __ popq (Address(rsp, dst_offset));
 1175 #ifndef PRODUCT
 1176         } else {
 1177           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1178                     &quot;popq    [rsp + #%d]&quot;,
 1179                      src_offset, dst_offset);
 1180 #endif
 1181         }
 1182       } else {
 1183         // 32-bit
 1184         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1185         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1186         // No pushl/popl, so:
 1187         int src_offset = ra_-&gt;reg2offset(src_first);
 1188         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1189         if (cbuf) {
 1190           MacroAssembler _masm(cbuf);
 1191           __ movq(Address(rsp, -8), rax);
 1192           __ movl(rax, Address(rsp, src_offset));
 1193           __ movl(Address(rsp, dst_offset), rax);
 1194           __ movq(rax, Address(rsp, -8));
 1195 #ifndef PRODUCT
 1196         } else {
 1197           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1198                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1199                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1200                     &quot;movq    rax, [rsp - #8]&quot;,
 1201                      src_offset, dst_offset);
 1202 #endif
 1203         }
 1204       }
 1205       return 0;
 1206     } else if (dst_first_rc == rc_int) {
 1207       // mem -&gt; gpr
 1208       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1209           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1210         // 64-bit
 1211         int offset = ra_-&gt;reg2offset(src_first);
 1212         if (cbuf) {
 1213           MacroAssembler _masm(cbuf);
 1214           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1215 #ifndef PRODUCT
 1216         } else {
 1217           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1218                      Matcher::regName[dst_first],
 1219                      offset);
 1220 #endif
 1221         }
 1222       } else {
 1223         // 32-bit
 1224         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1225         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1226         int offset = ra_-&gt;reg2offset(src_first);
 1227         if (cbuf) {
 1228           MacroAssembler _masm(cbuf);
 1229           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1230 #ifndef PRODUCT
 1231         } else {
 1232           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1233                      Matcher::regName[dst_first],
 1234                      offset);
 1235 #endif
 1236         }
 1237       }
 1238       return 0;
 1239     } else if (dst_first_rc == rc_float) {
 1240       // mem-&gt; xmm
 1241       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1242           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1243         // 64-bit
 1244         int offset = ra_-&gt;reg2offset(src_first);
 1245         if (cbuf) {
 1246           MacroAssembler _masm(cbuf);
 1247           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1248 #ifndef PRODUCT
 1249         } else {
 1250           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1251                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1252                      Matcher::regName[dst_first],
 1253                      offset);
 1254 #endif
 1255         }
 1256       } else {
 1257         // 32-bit
 1258         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1259         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1260         int offset = ra_-&gt;reg2offset(src_first);
 1261         if (cbuf) {
 1262           MacroAssembler _masm(cbuf);
 1263           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1264 #ifndef PRODUCT
 1265         } else {
 1266           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1267                      Matcher::regName[dst_first],
 1268                      offset);
 1269 #endif
 1270         }
 1271       }
 1272       return 0;
 1273     }
 1274   } else if (src_first_rc == rc_int) {
 1275     // gpr -&gt;
 1276     if (dst_first_rc == rc_stack) {
 1277       // gpr -&gt; mem
 1278       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1279           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1280         // 64-bit
 1281         int offset = ra_-&gt;reg2offset(dst_first);
 1282         if (cbuf) {
 1283           MacroAssembler _masm(cbuf);
 1284           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1285 #ifndef PRODUCT
 1286         } else {
 1287           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1288                      offset,
 1289                      Matcher::regName[src_first]);
 1290 #endif
 1291         }
 1292       } else {
 1293         // 32-bit
 1294         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1295         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1296         int offset = ra_-&gt;reg2offset(dst_first);
 1297         if (cbuf) {
 1298           MacroAssembler _masm(cbuf);
 1299           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1300 #ifndef PRODUCT
 1301         } else {
 1302           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1303                      offset,
 1304                      Matcher::regName[src_first]);
 1305 #endif
 1306         }
 1307       }
 1308       return 0;
 1309     } else if (dst_first_rc == rc_int) {
 1310       // gpr -&gt; gpr
 1311       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1312           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1313         // 64-bit
 1314         if (cbuf) {
 1315           MacroAssembler _masm(cbuf);
 1316           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1317                   as_Register(Matcher::_regEncode[src_first]));
 1318 #ifndef PRODUCT
 1319         } else {
 1320           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1321                      Matcher::regName[dst_first],
 1322                      Matcher::regName[src_first]);
 1323 #endif
 1324         }
 1325         return 0;
 1326       } else {
 1327         // 32-bit
 1328         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1329         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1330         if (cbuf) {
 1331           MacroAssembler _masm(cbuf);
 1332           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1333                   as_Register(Matcher::_regEncode[src_first]));
 1334 #ifndef PRODUCT
 1335         } else {
 1336           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1337                      Matcher::regName[dst_first],
 1338                      Matcher::regName[src_first]);
 1339 #endif
 1340         }
 1341         return 0;
 1342       }
 1343     } else if (dst_first_rc == rc_float) {
 1344       // gpr -&gt; xmm
 1345       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1346           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1347         // 64-bit
 1348         if (cbuf) {
 1349           MacroAssembler _masm(cbuf);
 1350           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1351 #ifndef PRODUCT
 1352         } else {
 1353           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1354                      Matcher::regName[dst_first],
 1355                      Matcher::regName[src_first]);
 1356 #endif
 1357         }
 1358       } else {
 1359         // 32-bit
 1360         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1361         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1362         if (cbuf) {
 1363           MacroAssembler _masm(cbuf);
 1364           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1365 #ifndef PRODUCT
 1366         } else {
 1367           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1368                      Matcher::regName[dst_first],
 1369                      Matcher::regName[src_first]);
 1370 #endif
 1371         }
 1372       }
 1373       return 0;
 1374     }
 1375   } else if (src_first_rc == rc_float) {
 1376     // xmm -&gt;
 1377     if (dst_first_rc == rc_stack) {
 1378       // xmm -&gt; mem
 1379       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1380           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1381         // 64-bit
 1382         int offset = ra_-&gt;reg2offset(dst_first);
 1383         if (cbuf) {
 1384           MacroAssembler _masm(cbuf);
 1385           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1386 #ifndef PRODUCT
 1387         } else {
 1388           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1389                      offset,
 1390                      Matcher::regName[src_first]);
 1391 #endif
 1392         }
 1393       } else {
 1394         // 32-bit
 1395         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1396         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1397         int offset = ra_-&gt;reg2offset(dst_first);
 1398         if (cbuf) {
 1399           MacroAssembler _masm(cbuf);
 1400           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1401 #ifndef PRODUCT
 1402         } else {
 1403           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1404                      offset,
 1405                      Matcher::regName[src_first]);
 1406 #endif
 1407         }
 1408       }
 1409       return 0;
 1410     } else if (dst_first_rc == rc_int) {
 1411       // xmm -&gt; gpr
 1412       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1413           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1414         // 64-bit
 1415         if (cbuf) {
 1416           MacroAssembler _masm(cbuf);
 1417           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1418 #ifndef PRODUCT
 1419         } else {
 1420           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1421                      Matcher::regName[dst_first],
 1422                      Matcher::regName[src_first]);
 1423 #endif
 1424         }
 1425       } else {
 1426         // 32-bit
 1427         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1428         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1429         if (cbuf) {
 1430           MacroAssembler _masm(cbuf);
 1431           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1432 #ifndef PRODUCT
 1433         } else {
 1434           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1435                      Matcher::regName[dst_first],
 1436                      Matcher::regName[src_first]);
 1437 #endif
 1438         }
 1439       }
 1440       return 0;
 1441     } else if (dst_first_rc == rc_float) {
 1442       // xmm -&gt; xmm
 1443       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1444           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1445         // 64-bit
 1446         if (cbuf) {
 1447           MacroAssembler _masm(cbuf);
 1448           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1449 #ifndef PRODUCT
 1450         } else {
 1451           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1452                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1453                      Matcher::regName[dst_first],
 1454                      Matcher::regName[src_first]);
 1455 #endif
 1456         }
 1457       } else {
 1458         // 32-bit
 1459         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1460         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1461         if (cbuf) {
 1462           MacroAssembler _masm(cbuf);
 1463           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1464 #ifndef PRODUCT
 1465         } else {
 1466           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1467                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1468                      Matcher::regName[dst_first],
 1469                      Matcher::regName[src_first]);
 1470 #endif
 1471         }
 1472       }
 1473       return 0;
 1474     }
 1475   }
 1476 
 1477   assert(0,&quot; foo &quot;);
 1478   Unimplemented();
 1479   return 0;
 1480 }
 1481 
 1482 #ifndef PRODUCT
 1483 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1484   implementation(NULL, ra_, false, st);
 1485 }
 1486 #endif
 1487 
 1488 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1489   implementation(&amp;cbuf, ra_, false, NULL);
 1490 }
 1491 
 1492 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1493   return MachNode::size(ra_);
 1494 }
 1495 
 1496 //=============================================================================
 1497 #ifndef PRODUCT
 1498 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1499 {
 1500   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1501   int reg = ra_-&gt;get_reg_first(this);
 1502   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1503             Matcher::regName[reg], offset);
 1504 }
 1505 #endif
 1506 
 1507 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1508 {
 1509   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1510   int reg = ra_-&gt;get_encode(this);
 1511   if (offset &gt;= 0x80) {
 1512     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1513     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1514     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1515     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1516     emit_d32(cbuf, offset);
 1517   } else {
 1518     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1519     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1520     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1521     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1522     emit_d8(cbuf, offset);
 1523   }
 1524 }
 1525 
 1526 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1527 {
 1528   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1529   return (offset &lt; 0x80) ? 5 : 8; // REX
 1530 }
 1531 
 1532 //=============================================================================
 1533 #ifndef PRODUCT
 1534 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1535 {
 1536   st-&gt;print_cr(&quot;MachVEPNode&quot;);
 1537 }
 1538 #endif
 1539 
 1540 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1541 {
 1542   MacroAssembler masm(&amp;cbuf);
 1543   if (!_verified) {  
 1544     uint insts_size = cbuf.insts_size();
 1545     if (UseCompressedClassPointers) {
 1546       masm.load_klass(rscratch1, j_rarg0);
 1547       masm.cmpptr(rax, rscratch1);
 1548     } else {
 1549       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1550     }
 1551     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1552   } else {
 1553     // Unpack value type args passed as oop and then jump to
 1554     // the verified entry point (skipping the unverified entry).
 1555     masm.unpack_value_args(ra_-&gt;C, _receiver_only);
 1556     masm.jmp(*_verified_entry);
 1557   }
 1558 }
 1559 
 1560 //=============================================================================
 1561 #ifndef PRODUCT
 1562 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1563 {
 1564   if (UseCompressedClassPointers) {
 1565     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1566     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1567     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1568   } else {
 1569     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1570                  &quot;# Inline cache check&quot;);
 1571   }
 1572   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1573   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1574 }
 1575 #endif
 1576 
 1577 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1578 {
 1579   MacroAssembler masm(&amp;cbuf);
 1580   uint insts_size = cbuf.insts_size();
 1581   if (UseCompressedClassPointers) {
 1582     masm.load_klass(rscratch1, j_rarg0);
 1583     masm.cmpptr(rax, rscratch1);
 1584   } else {
 1585     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1586   }
 1587 
 1588   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1589 
 1590   /* WARNING these NOPs are critical so that verified entry point is properly
 1591      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1592   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1593   if (OptoBreakpoint) {
 1594     // Leave space for int3
 1595     nops_cnt -= 1;
 1596   }
 1597   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1598   if (nops_cnt &gt; 0)
 1599     masm.nop(nops_cnt);
 1600 }
 1601 
 1602 //=============================================================================
 1603 
 1604 int Matcher::regnum_to_fpu_offset(int regnum)
 1605 {
 1606   return regnum - 32; // The FP registers are in the second chunk
 1607 }
 1608 
 1609 // This is UltraSparc specific, true just means we have fast l2f conversion
 1610 const bool Matcher::convL2FSupported(void) {
 1611   return true;
 1612 }
 1613 
 1614 // Is this branch offset short enough that a short branch can be used?
 1615 //
 1616 // NOTE: If the platform does not provide any short branch variants, then
 1617 //       this method should return false for offset 0.
 1618 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1619   // The passed offset is relative to address of the branch.
 1620   // On 86 a branch displacement is calculated relative to address
 1621   // of a next instruction.
 1622   offset -= br_size;
 1623 
 1624   // the short version of jmpConUCF2 contains multiple branches,
 1625   // making the reach slightly less
 1626   if (rule == jmpConUCF2_rule)
 1627     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1628   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1629 }
 1630 
 1631 const bool Matcher::isSimpleConstant64(jlong value) {
 1632   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1633   //return value == (int) value;  // Cf. storeImmL and immL32.
 1634 
 1635   // Probably always true, even if a temp register is required.
 1636   return true;
 1637 }
 1638 
 1639 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1640 const bool Matcher::init_array_count_is_in_bytes = false;
 1641 
 1642 // No additional cost for CMOVL.
 1643 const int Matcher::long_cmove_cost() { return 0; }
 1644 
 1645 // No CMOVF/CMOVD with SSE2
 1646 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1647 
 1648 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1649 const bool Matcher::require_postalloc_expand = false;
 1650 
 1651 // Do we need to mask the count passed to shift instructions or does
 1652 // the cpu only look at the lower 5/6 bits anyway?
 1653 const bool Matcher::need_masked_shift_count = false;
 1654 
 1655 bool Matcher::narrow_oop_use_complex_address() {
 1656   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1657   return (LogMinObjAlignmentInBytes &lt;= 3);
 1658 }
 1659 
 1660 bool Matcher::narrow_klass_use_complex_address() {
 1661   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1662   return (LogKlassAlignmentInBytes &lt;= 3);
 1663 }
 1664 
 1665 bool Matcher::const_oop_prefer_decode() {
 1666   // Prefer ConN+DecodeN over ConP.
 1667   return true;
 1668 }
 1669 
 1670 bool Matcher::const_klass_prefer_decode() {
 1671   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1672   //       or condisider the following:
 1673   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1674   //return CompressedKlassPointers::base() == NULL;
 1675   return true;
 1676 }
 1677 
 1678 // Is it better to copy float constants, or load them directly from
 1679 // memory?  Intel can load a float constant from a direct address,
 1680 // requiring no extra registers.  Most RISCs will have to materialize
 1681 // an address into a register first, so they would do better to copy
 1682 // the constant from stack.
 1683 const bool Matcher::rematerialize_float_constants = true; // XXX
 1684 
 1685 // If CPU can load and store mis-aligned doubles directly then no
 1686 // fixup is needed.  Else we split the double into 2 integer pieces
 1687 // and move it piece-by-piece.  Only happens when passing doubles into
 1688 // C code as the Java calling convention forces doubles to be aligned.
 1689 const bool Matcher::misaligned_doubles_ok = true;
 1690 
 1691 // No-op on amd64
 1692 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1693 
 1694 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1695 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1696 
 1697 // Are floats conerted to double when stored to stack during deoptimization?
 1698 // On x64 it is stored without convertion so we can use normal access.
 1699 bool Matcher::float_in_double() { return false; }
 1700 
 1701 // Do ints take an entire long register or just half?
 1702 const bool Matcher::int_in_long = true;
 1703 
 1704 // Return whether or not this register is ever used as an argument.
 1705 // This function is used on startup to build the trampoline stubs in
 1706 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1707 // call in the trampoline, and arguments in those registers not be
 1708 // available to the callee.
 1709 bool Matcher::can_be_java_arg(int reg)
 1710 {
 1711   return
 1712     reg ==  RDI_num || reg == RDI_H_num ||
 1713     reg ==  RSI_num || reg == RSI_H_num ||
 1714     reg ==  RDX_num || reg == RDX_H_num ||
 1715     reg ==  RCX_num || reg == RCX_H_num ||
 1716     reg ==   R8_num || reg ==  R8_H_num ||
 1717     reg ==   R9_num || reg ==  R9_H_num ||
 1718     reg ==  R12_num || reg == R12_H_num ||
 1719     reg == XMM0_num || reg == XMM0b_num ||
 1720     reg == XMM1_num || reg == XMM1b_num ||
 1721     reg == XMM2_num || reg == XMM2b_num ||
 1722     reg == XMM3_num || reg == XMM3b_num ||
 1723     reg == XMM4_num || reg == XMM4b_num ||
 1724     reg == XMM5_num || reg == XMM5b_num ||
 1725     reg == XMM6_num || reg == XMM6b_num ||
 1726     reg == XMM7_num || reg == XMM7b_num;
 1727 }
 1728 
 1729 bool Matcher::is_spillable_arg(int reg)
 1730 {
 1731   return can_be_java_arg(reg);
 1732 }
 1733 
 1734 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1735   // In 64 bit mode a code which use multiply when
 1736   // devisor is constant is faster than hardware
 1737   // DIV instruction (it uses MulHiL).
 1738   return false;
 1739 }
 1740 
 1741 // Register for DIVI projection of divmodI
 1742 RegMask Matcher::divI_proj_mask() {
 1743   return INT_RAX_REG_mask();
 1744 }
 1745 
 1746 // Register for MODI projection of divmodI
 1747 RegMask Matcher::modI_proj_mask() {
 1748   return INT_RDX_REG_mask();
 1749 }
 1750 
 1751 // Register for DIVL projection of divmodL
 1752 RegMask Matcher::divL_proj_mask() {
 1753   return LONG_RAX_REG_mask();
 1754 }
 1755 
 1756 // Register for MODL projection of divmodL
 1757 RegMask Matcher::modL_proj_mask() {
 1758   return LONG_RDX_REG_mask();
 1759 }
 1760 
 1761 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1762 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1763     return NO_REG_mask();
 1764 }
 1765 
 1766 %}
 1767 
 1768 //----------ENCODING BLOCK-----------------------------------------------------
 1769 // This block specifies the encoding classes used by the compiler to
 1770 // output byte streams.  Encoding classes are parameterized macros
 1771 // used by Machine Instruction Nodes in order to generate the bit
 1772 // encoding of the instruction.  Operands specify their base encoding
 1773 // interface with the interface keyword.  There are currently
 1774 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1775 // COND_INTER.  REG_INTER causes an operand to generate a function
 1776 // which returns its register number when queried.  CONST_INTER causes
 1777 // an operand to generate a function which returns the value of the
 1778 // constant when queried.  MEMORY_INTER causes an operand to generate
 1779 // four functions which return the Base Register, the Index Register,
 1780 // the Scale Value, and the Offset Value of the operand when queried.
 1781 // COND_INTER causes an operand to generate six functions which return
 1782 // the encoding code (ie - encoding bits for the instruction)
 1783 // associated with each basic boolean condition for a conditional
 1784 // instruction.
 1785 //
 1786 // Instructions specify two basic values for encoding.  Again, a
 1787 // function is available to check if the constant displacement is an
 1788 // oop. They use the ins_encode keyword to specify their encoding
 1789 // classes (which must be a sequence of enc_class names, and their
 1790 // parameters, specified in the encoding block), and they use the
 1791 // opcode keyword to specify, in order, their primary, secondary, and
 1792 // tertiary opcode.  Only the opcode sections which a particular
 1793 // instruction needs for encoding need to be specified.
 1794 encode %{
 1795   // Build emit functions for each basic byte or larger field in the
 1796   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1797   // from C++ code in the enc_class source block.  Emit functions will
 1798   // live in the main source block for now.  In future, we can
 1799   // generalize this by adding a syntax that specifies the sizes of
 1800   // fields in an order, so that the adlc can build the emit functions
 1801   // automagically
 1802 
 1803   // Emit primary opcode
 1804   enc_class OpcP
 1805   %{
 1806     emit_opcode(cbuf, $primary);
 1807   %}
 1808 
 1809   // Emit secondary opcode
 1810   enc_class OpcS
 1811   %{
 1812     emit_opcode(cbuf, $secondary);
 1813   %}
 1814 
 1815   // Emit tertiary opcode
 1816   enc_class OpcT
 1817   %{
 1818     emit_opcode(cbuf, $tertiary);
 1819   %}
 1820 
 1821   // Emit opcode directly
 1822   enc_class Opcode(immI d8)
 1823   %{
 1824     emit_opcode(cbuf, $d8$$constant);
 1825   %}
 1826 
 1827   // Emit size prefix
 1828   enc_class SizePrefix
 1829   %{
 1830     emit_opcode(cbuf, 0x66);
 1831   %}
 1832 
 1833   enc_class reg(rRegI reg)
 1834   %{
 1835     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1836   %}
 1837 
 1838   enc_class reg_reg(rRegI dst, rRegI src)
 1839   %{
 1840     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1841   %}
 1842 
 1843   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1844   %{
 1845     emit_opcode(cbuf, $opcode$$constant);
 1846     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1847   %}
 1848 
 1849   enc_class cdql_enc(no_rax_rdx_RegI div)
 1850   %{
 1851     // Full implementation of Java idiv and irem; checks for
 1852     // special case as described in JVM spec., p.243 &amp; p.271.
 1853     //
 1854     //         normal case                           special case
 1855     //
 1856     // input : rax: dividend                         min_int
 1857     //         reg: divisor                          -1
 1858     //
 1859     // output: rax: quotient  (= rax idiv reg)       min_int
 1860     //         rdx: remainder (= rax irem reg)       0
 1861     //
 1862     //  Code sequnce:
 1863     //
 1864     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1865     //    5:   75 07/08                jne    e &lt;normal&gt;
 1866     //    7:   33 d2                   xor    %edx,%edx
 1867     //  [div &gt;= 8 -&gt; offset + 1]
 1868     //  [REX_B]
 1869     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1870     //    c:   74 03/04                je     11 &lt;done&gt;
 1871     // 000000000000000e &lt;normal&gt;:
 1872     //    e:   99                      cltd
 1873     //  [div &gt;= 8 -&gt; offset + 1]
 1874     //  [REX_B]
 1875     //    f:   f7 f9                   idiv   $div
 1876     // 0000000000000011 &lt;done&gt;:
 1877 
 1878     // cmp    $0x80000000,%eax
 1879     emit_opcode(cbuf, 0x3d);
 1880     emit_d8(cbuf, 0x00);
 1881     emit_d8(cbuf, 0x00);
 1882     emit_d8(cbuf, 0x00);
 1883     emit_d8(cbuf, 0x80);
 1884 
 1885     // jne    e &lt;normal&gt;
 1886     emit_opcode(cbuf, 0x75);
 1887     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1888 
 1889     // xor    %edx,%edx
 1890     emit_opcode(cbuf, 0x33);
 1891     emit_d8(cbuf, 0xD2);
 1892 
 1893     // cmp    $0xffffffffffffffff,%ecx
 1894     if ($div$$reg &gt;= 8) {
 1895       emit_opcode(cbuf, Assembler::REX_B);
 1896     }
 1897     emit_opcode(cbuf, 0x83);
 1898     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1899     emit_d8(cbuf, 0xFF);
 1900 
 1901     // je     11 &lt;done&gt;
 1902     emit_opcode(cbuf, 0x74);
 1903     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1904 
 1905     // &lt;normal&gt;
 1906     // cltd
 1907     emit_opcode(cbuf, 0x99);
 1908 
 1909     // idivl (note: must be emitted by the user of this rule)
 1910     // &lt;done&gt;
 1911   %}
 1912 
 1913   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1914   %{
 1915     // Full implementation of Java ldiv and lrem; checks for
 1916     // special case as described in JVM spec., p.243 &amp; p.271.
 1917     //
 1918     //         normal case                           special case
 1919     //
 1920     // input : rax: dividend                         min_long
 1921     //         reg: divisor                          -1
 1922     //
 1923     // output: rax: quotient  (= rax idiv reg)       min_long
 1924     //         rdx: remainder (= rax irem reg)       0
 1925     //
 1926     //  Code sequnce:
 1927     //
 1928     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1929     //    7:   00 00 80
 1930     //    a:   48 39 d0                cmp    %rdx,%rax
 1931     //    d:   75 08                   jne    17 &lt;normal&gt;
 1932     //    f:   33 d2                   xor    %edx,%edx
 1933     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1934     //   15:   74 05                   je     1c &lt;done&gt;
 1935     // 0000000000000017 &lt;normal&gt;:
 1936     //   17:   48 99                   cqto
 1937     //   19:   48 f7 f9                idiv   $div
 1938     // 000000000000001c &lt;done&gt;:
 1939 
 1940     // mov    $0x8000000000000000,%rdx
 1941     emit_opcode(cbuf, Assembler::REX_W);
 1942     emit_opcode(cbuf, 0xBA);
 1943     emit_d8(cbuf, 0x00);
 1944     emit_d8(cbuf, 0x00);
 1945     emit_d8(cbuf, 0x00);
 1946     emit_d8(cbuf, 0x00);
 1947     emit_d8(cbuf, 0x00);
 1948     emit_d8(cbuf, 0x00);
 1949     emit_d8(cbuf, 0x00);
 1950     emit_d8(cbuf, 0x80);
 1951 
 1952     // cmp    %rdx,%rax
 1953     emit_opcode(cbuf, Assembler::REX_W);
 1954     emit_opcode(cbuf, 0x39);
 1955     emit_d8(cbuf, 0xD0);
 1956 
 1957     // jne    17 &lt;normal&gt;
 1958     emit_opcode(cbuf, 0x75);
 1959     emit_d8(cbuf, 0x08);
 1960 
 1961     // xor    %edx,%edx
 1962     emit_opcode(cbuf, 0x33);
 1963     emit_d8(cbuf, 0xD2);
 1964 
 1965     // cmp    $0xffffffffffffffff,$div
 1966     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1967     emit_opcode(cbuf, 0x83);
 1968     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1969     emit_d8(cbuf, 0xFF);
 1970 
 1971     // je     1e &lt;done&gt;
 1972     emit_opcode(cbuf, 0x74);
 1973     emit_d8(cbuf, 0x05);
 1974 
 1975     // &lt;normal&gt;
 1976     // cqto
 1977     emit_opcode(cbuf, Assembler::REX_W);
 1978     emit_opcode(cbuf, 0x99);
 1979 
 1980     // idivq (note: must be emitted by the user of this rule)
 1981     // &lt;done&gt;
 1982   %}
 1983 
 1984   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1985   enc_class OpcSE(immI imm)
 1986   %{
 1987     // Emit primary opcode and set sign-extend bit
 1988     // Check for 8-bit immediate, and set sign extend bit in opcode
 1989     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1990       emit_opcode(cbuf, $primary | 0x02);
 1991     } else {
 1992       // 32-bit immediate
 1993       emit_opcode(cbuf, $primary);
 1994     }
 1995   %}
 1996 
 1997   enc_class OpcSErm(rRegI dst, immI imm)
 1998   %{
 1999     // OpcSEr/m
 2000     int dstenc = $dst$$reg;
 2001     if (dstenc &gt;= 8) {
 2002       emit_opcode(cbuf, Assembler::REX_B);
 2003       dstenc -= 8;
 2004     }
 2005     // Emit primary opcode and set sign-extend bit
 2006     // Check for 8-bit immediate, and set sign extend bit in opcode
 2007     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2008       emit_opcode(cbuf, $primary | 0x02);
 2009     } else {
 2010       // 32-bit immediate
 2011       emit_opcode(cbuf, $primary);
 2012     }
 2013     // Emit r/m byte with secondary opcode, after primary opcode.
 2014     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2015   %}
 2016 
 2017   enc_class OpcSErm_wide(rRegL dst, immI imm)
 2018   %{
 2019     // OpcSEr/m
 2020     int dstenc = $dst$$reg;
 2021     if (dstenc &lt; 8) {
 2022       emit_opcode(cbuf, Assembler::REX_W);
 2023     } else {
 2024       emit_opcode(cbuf, Assembler::REX_WB);
 2025       dstenc -= 8;
 2026     }
 2027     // Emit primary opcode and set sign-extend bit
 2028     // Check for 8-bit immediate, and set sign extend bit in opcode
 2029     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2030       emit_opcode(cbuf, $primary | 0x02);
 2031     } else {
 2032       // 32-bit immediate
 2033       emit_opcode(cbuf, $primary);
 2034     }
 2035     // Emit r/m byte with secondary opcode, after primary opcode.
 2036     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2037   %}
 2038 
 2039   enc_class Con8or32(immI imm)
 2040   %{
 2041     // Check for 8-bit immediate, and set sign extend bit in opcode
 2042     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2043       $$$emit8$imm$$constant;
 2044     } else {
 2045       // 32-bit immediate
 2046       $$$emit32$imm$$constant;
 2047     }
 2048   %}
 2049 
 2050   enc_class opc2_reg(rRegI dst)
 2051   %{
 2052     // BSWAP
 2053     emit_cc(cbuf, $secondary, $dst$$reg);
 2054   %}
 2055 
 2056   enc_class opc3_reg(rRegI dst)
 2057   %{
 2058     // BSWAP
 2059     emit_cc(cbuf, $tertiary, $dst$$reg);
 2060   %}
 2061 
 2062   enc_class reg_opc(rRegI div)
 2063   %{
 2064     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2065     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2066   %}
 2067 
 2068   enc_class enc_cmov(cmpOp cop)
 2069   %{
 2070     // CMOV
 2071     $$$emit8$primary;
 2072     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2073   %}
 2074 
 2075   enc_class enc_PartialSubtypeCheck()
 2076   %{
 2077     Register Rrdi = as_Register(RDI_enc); // result register
 2078     Register Rrax = as_Register(RAX_enc); // super class
 2079     Register Rrcx = as_Register(RCX_enc); // killed
 2080     Register Rrsi = as_Register(RSI_enc); // sub class
 2081     Label miss;
 2082     const bool set_cond_codes = true;
 2083 
 2084     MacroAssembler _masm(&amp;cbuf);
 2085     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2086                                      NULL, &amp;miss,
 2087                                      /*set_cond_codes:*/ true);
 2088     if ($primary) {
 2089       __ xorptr(Rrdi, Rrdi);
 2090     }
 2091     __ bind(miss);
 2092   %}
 2093 
 2094   enc_class clear_avx %{
 2095     debug_only(int off0 = cbuf.insts_size());
 2096     if (generate_vzeroupper(Compile::current())) {
 2097       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2098       // Clear upper bits of YMM registers when current compiled code uses
 2099       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2100       MacroAssembler _masm(&amp;cbuf);
 2101       __ vzeroupper();
 2102     }
 2103     debug_only(int off1 = cbuf.insts_size());
 2104     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2105   %}
 2106 
 2107   enc_class Java_To_Runtime(method meth) %{
 2108     // No relocation needed
 2109     MacroAssembler _masm(&amp;cbuf);
 2110     __ mov64(r10, (int64_t) $meth$$method);
 2111     __ call(r10);
 2112   %}
 2113 
 2114   enc_class Java_To_Interpreter(method meth)
 2115   %{
 2116     // CALL Java_To_Interpreter
 2117     // This is the instruction starting address for relocation info.
 2118     cbuf.set_insts_mark();
 2119     $$$emit8$primary;
 2120     // CALL directly to the runtime
 2121     emit_d32_reloc(cbuf,
 2122                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2123                    runtime_call_Relocation::spec(),
 2124                    RELOC_DISP32);
 2125   %}
 2126 
 2127   enc_class Java_Static_Call(method meth)
 2128   %{
 2129     // JAVA STATIC CALL
 2130     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2131     // determine who we intended to call.
 2132     cbuf.set_insts_mark();
 2133     $$$emit8$primary;
 2134 
 2135     if (!_method) {
 2136       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2137                      runtime_call_Relocation::spec(),
 2138                      RELOC_DISP32);
 2139     } else {
 2140       int method_index = resolved_method_index(cbuf);
 2141       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2142                                                   : static_call_Relocation::spec(method_index);
 2143       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2144                      rspec, RELOC_DISP32);
 2145       // Emit stubs for static call.
 2146       address mark = cbuf.insts_mark();
 2147       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2148       if (stub == NULL) {
 2149         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2150         return;
 2151       }
 2152 #if INCLUDE_AOT
 2153       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2154 #endif
 2155     }
 2156   %}
 2157 
 2158   enc_class Java_Dynamic_Call(method meth) %{
 2159     MacroAssembler _masm(&amp;cbuf);
 2160     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2161   %}
 2162 
 2163   enc_class Java_Compiled_Call(method meth)
 2164   %{
 2165     // JAVA COMPILED CALL
 2166     int disp = in_bytes(Method:: from_compiled_offset());
 2167 
 2168     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2169     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2170 
 2171     // callq *disp(%rax)
 2172     cbuf.set_insts_mark();
 2173     $$$emit8$primary;
 2174     if (disp &lt; 0x80) {
 2175       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2176       emit_d8(cbuf, disp); // Displacement
 2177     } else {
 2178       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2179       emit_d32(cbuf, disp); // Displacement
 2180     }
 2181   %}
 2182 
 2183   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2184   %{
 2185     // SAL, SAR, SHR
 2186     int dstenc = $dst$$reg;
 2187     if (dstenc &gt;= 8) {
 2188       emit_opcode(cbuf, Assembler::REX_B);
 2189       dstenc -= 8;
 2190     }
 2191     $$$emit8$primary;
 2192     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2193     $$$emit8$shift$$constant;
 2194   %}
 2195 
 2196   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2197   %{
 2198     // SAL, SAR, SHR
 2199     int dstenc = $dst$$reg;
 2200     if (dstenc &lt; 8) {
 2201       emit_opcode(cbuf, Assembler::REX_W);
 2202     } else {
 2203       emit_opcode(cbuf, Assembler::REX_WB);
 2204       dstenc -= 8;
 2205     }
 2206     $$$emit8$primary;
 2207     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2208     $$$emit8$shift$$constant;
 2209   %}
 2210 
 2211   enc_class load_immI(rRegI dst, immI src)
 2212   %{
 2213     int dstenc = $dst$$reg;
 2214     if (dstenc &gt;= 8) {
 2215       emit_opcode(cbuf, Assembler::REX_B);
 2216       dstenc -= 8;
 2217     }
 2218     emit_opcode(cbuf, 0xB8 | dstenc);
 2219     $$$emit32$src$$constant;
 2220   %}
 2221 
 2222   enc_class load_immL(rRegL dst, immL src)
 2223   %{
 2224     int dstenc = $dst$$reg;
 2225     if (dstenc &lt; 8) {
 2226       emit_opcode(cbuf, Assembler::REX_W);
 2227     } else {
 2228       emit_opcode(cbuf, Assembler::REX_WB);
 2229       dstenc -= 8;
 2230     }
 2231     emit_opcode(cbuf, 0xB8 | dstenc);
 2232     emit_d64(cbuf, $src$$constant);
 2233   %}
 2234 
 2235   enc_class load_immUL32(rRegL dst, immUL32 src)
 2236   %{
 2237     // same as load_immI, but this time we care about zeroes in the high word
 2238     int dstenc = $dst$$reg;
 2239     if (dstenc &gt;= 8) {
 2240       emit_opcode(cbuf, Assembler::REX_B);
 2241       dstenc -= 8;
 2242     }
 2243     emit_opcode(cbuf, 0xB8 | dstenc);
 2244     $$$emit32$src$$constant;
 2245   %}
 2246 
 2247   enc_class load_immL32(rRegL dst, immL32 src)
 2248   %{
 2249     int dstenc = $dst$$reg;
 2250     if (dstenc &lt; 8) {
 2251       emit_opcode(cbuf, Assembler::REX_W);
 2252     } else {
 2253       emit_opcode(cbuf, Assembler::REX_WB);
 2254       dstenc -= 8;
 2255     }
 2256     emit_opcode(cbuf, 0xC7);
 2257     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2258     $$$emit32$src$$constant;
 2259   %}
 2260 
 2261   enc_class load_immP31(rRegP dst, immP32 src)
 2262   %{
 2263     // same as load_immI, but this time we care about zeroes in the high word
 2264     int dstenc = $dst$$reg;
 2265     if (dstenc &gt;= 8) {
 2266       emit_opcode(cbuf, Assembler::REX_B);
 2267       dstenc -= 8;
 2268     }
 2269     emit_opcode(cbuf, 0xB8 | dstenc);
 2270     $$$emit32$src$$constant;
 2271   %}
 2272 
 2273   enc_class load_immP(rRegP dst, immP src)
 2274   %{
 2275     int dstenc = $dst$$reg;
 2276     if (dstenc &lt; 8) {
 2277       emit_opcode(cbuf, Assembler::REX_W);
 2278     } else {
 2279       emit_opcode(cbuf, Assembler::REX_WB);
 2280       dstenc -= 8;
 2281     }
 2282     emit_opcode(cbuf, 0xB8 | dstenc);
 2283     // This next line should be generated from ADLC
 2284     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2285       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2286     } else {
 2287       emit_d64(cbuf, $src$$constant);
 2288     }
 2289   %}
 2290 
 2291   enc_class Con32(immI src)
 2292   %{
 2293     // Output immediate
 2294     $$$emit32$src$$constant;
 2295   %}
 2296 
 2297   enc_class Con32F_as_bits(immF src)
 2298   %{
 2299     // Output Float immediate bits
 2300     jfloat jf = $src$$constant;
 2301     jint jf_as_bits = jint_cast(jf);
 2302     emit_d32(cbuf, jf_as_bits);
 2303   %}
 2304 
 2305   enc_class Con16(immI src)
 2306   %{
 2307     // Output immediate
 2308     $$$emit16$src$$constant;
 2309   %}
 2310 
 2311   // How is this different from Con32??? XXX
 2312   enc_class Con_d32(immI src)
 2313   %{
 2314     emit_d32(cbuf,$src$$constant);
 2315   %}
 2316 
 2317   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2318     // Output immediate memory reference
 2319     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2320     emit_d32(cbuf, 0x00);
 2321   %}
 2322 
 2323   enc_class lock_prefix()
 2324   %{
 2325     emit_opcode(cbuf, 0xF0); // lock
 2326   %}
 2327 
 2328   enc_class REX_mem(memory mem)
 2329   %{
 2330     if ($mem$$base &gt;= 8) {
 2331       if ($mem$$index &lt; 8) {
 2332         emit_opcode(cbuf, Assembler::REX_B);
 2333       } else {
 2334         emit_opcode(cbuf, Assembler::REX_XB);
 2335       }
 2336     } else {
 2337       if ($mem$$index &gt;= 8) {
 2338         emit_opcode(cbuf, Assembler::REX_X);
 2339       }
 2340     }
 2341   %}
 2342 
 2343   enc_class REX_mem_wide(memory mem)
 2344   %{
 2345     if ($mem$$base &gt;= 8) {
 2346       if ($mem$$index &lt; 8) {
 2347         emit_opcode(cbuf, Assembler::REX_WB);
 2348       } else {
 2349         emit_opcode(cbuf, Assembler::REX_WXB);
 2350       }
 2351     } else {
 2352       if ($mem$$index &lt; 8) {
 2353         emit_opcode(cbuf, Assembler::REX_W);
 2354       } else {
 2355         emit_opcode(cbuf, Assembler::REX_WX);
 2356       }
 2357     }
 2358   %}
 2359 
 2360   // for byte regs
 2361   enc_class REX_breg(rRegI reg)
 2362   %{
 2363     if ($reg$$reg &gt;= 4) {
 2364       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2365     }
 2366   %}
 2367 
 2368   // for byte regs
 2369   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2370   %{
 2371     if ($dst$$reg &lt; 8) {
 2372       if ($src$$reg &gt;= 4) {
 2373         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2374       }
 2375     } else {
 2376       if ($src$$reg &lt; 8) {
 2377         emit_opcode(cbuf, Assembler::REX_R);
 2378       } else {
 2379         emit_opcode(cbuf, Assembler::REX_RB);
 2380       }
 2381     }
 2382   %}
 2383 
 2384   // for byte regs
 2385   enc_class REX_breg_mem(rRegI reg, memory mem)
 2386   %{
 2387     if ($reg$$reg &lt; 8) {
 2388       if ($mem$$base &lt; 8) {
 2389         if ($mem$$index &gt;= 8) {
 2390           emit_opcode(cbuf, Assembler::REX_X);
 2391         } else if ($reg$$reg &gt;= 4) {
 2392           emit_opcode(cbuf, Assembler::REX);
 2393         }
 2394       } else {
 2395         if ($mem$$index &lt; 8) {
 2396           emit_opcode(cbuf, Assembler::REX_B);
 2397         } else {
 2398           emit_opcode(cbuf, Assembler::REX_XB);
 2399         }
 2400       }
 2401     } else {
 2402       if ($mem$$base &lt; 8) {
 2403         if ($mem$$index &lt; 8) {
 2404           emit_opcode(cbuf, Assembler::REX_R);
 2405         } else {
 2406           emit_opcode(cbuf, Assembler::REX_RX);
 2407         }
 2408       } else {
 2409         if ($mem$$index &lt; 8) {
 2410           emit_opcode(cbuf, Assembler::REX_RB);
 2411         } else {
 2412           emit_opcode(cbuf, Assembler::REX_RXB);
 2413         }
 2414       }
 2415     }
 2416   %}
 2417 
 2418   enc_class REX_reg(rRegI reg)
 2419   %{
 2420     if ($reg$$reg &gt;= 8) {
 2421       emit_opcode(cbuf, Assembler::REX_B);
 2422     }
 2423   %}
 2424 
 2425   enc_class REX_reg_wide(rRegI reg)
 2426   %{
 2427     if ($reg$$reg &lt; 8) {
 2428       emit_opcode(cbuf, Assembler::REX_W);
 2429     } else {
 2430       emit_opcode(cbuf, Assembler::REX_WB);
 2431     }
 2432   %}
 2433 
 2434   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2435   %{
 2436     if ($dst$$reg &lt; 8) {
 2437       if ($src$$reg &gt;= 8) {
 2438         emit_opcode(cbuf, Assembler::REX_B);
 2439       }
 2440     } else {
 2441       if ($src$$reg &lt; 8) {
 2442         emit_opcode(cbuf, Assembler::REX_R);
 2443       } else {
 2444         emit_opcode(cbuf, Assembler::REX_RB);
 2445       }
 2446     }
 2447   %}
 2448 
 2449   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2450   %{
 2451     if ($dst$$reg &lt; 8) {
 2452       if ($src$$reg &lt; 8) {
 2453         emit_opcode(cbuf, Assembler::REX_W);
 2454       } else {
 2455         emit_opcode(cbuf, Assembler::REX_WB);
 2456       }
 2457     } else {
 2458       if ($src$$reg &lt; 8) {
 2459         emit_opcode(cbuf, Assembler::REX_WR);
 2460       } else {
 2461         emit_opcode(cbuf, Assembler::REX_WRB);
 2462       }
 2463     }
 2464   %}
 2465 
 2466   enc_class REX_reg_mem(rRegI reg, memory mem)
 2467   %{
 2468     if ($reg$$reg &lt; 8) {
 2469       if ($mem$$base &lt; 8) {
 2470         if ($mem$$index &gt;= 8) {
 2471           emit_opcode(cbuf, Assembler::REX_X);
 2472         }
 2473       } else {
 2474         if ($mem$$index &lt; 8) {
 2475           emit_opcode(cbuf, Assembler::REX_B);
 2476         } else {
 2477           emit_opcode(cbuf, Assembler::REX_XB);
 2478         }
 2479       }
 2480     } else {
 2481       if ($mem$$base &lt; 8) {
 2482         if ($mem$$index &lt; 8) {
 2483           emit_opcode(cbuf, Assembler::REX_R);
 2484         } else {
 2485           emit_opcode(cbuf, Assembler::REX_RX);
 2486         }
 2487       } else {
 2488         if ($mem$$index &lt; 8) {
 2489           emit_opcode(cbuf, Assembler::REX_RB);
 2490         } else {
 2491           emit_opcode(cbuf, Assembler::REX_RXB);
 2492         }
 2493       }
 2494     }
 2495   %}
 2496 
 2497   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2498   %{
 2499     if ($reg$$reg &lt; 8) {
 2500       if ($mem$$base &lt; 8) {
 2501         if ($mem$$index &lt; 8) {
 2502           emit_opcode(cbuf, Assembler::REX_W);
 2503         } else {
 2504           emit_opcode(cbuf, Assembler::REX_WX);
 2505         }
 2506       } else {
 2507         if ($mem$$index &lt; 8) {
 2508           emit_opcode(cbuf, Assembler::REX_WB);
 2509         } else {
 2510           emit_opcode(cbuf, Assembler::REX_WXB);
 2511         }
 2512       }
 2513     } else {
 2514       if ($mem$$base &lt; 8) {
 2515         if ($mem$$index &lt; 8) {
 2516           emit_opcode(cbuf, Assembler::REX_WR);
 2517         } else {
 2518           emit_opcode(cbuf, Assembler::REX_WRX);
 2519         }
 2520       } else {
 2521         if ($mem$$index &lt; 8) {
 2522           emit_opcode(cbuf, Assembler::REX_WRB);
 2523         } else {
 2524           emit_opcode(cbuf, Assembler::REX_WRXB);
 2525         }
 2526       }
 2527     }
 2528   %}
 2529 
 2530   enc_class reg_mem(rRegI ereg, memory mem)
 2531   %{
 2532     // High registers handle in encode_RegMem
 2533     int reg = $ereg$$reg;
 2534     int base = $mem$$base;
 2535     int index = $mem$$index;
 2536     int scale = $mem$$scale;
 2537     int disp = $mem$$disp;
 2538     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2539 
 2540     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2541   %}
 2542 
 2543   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2544   %{
 2545     int rm_byte_opcode = $rm_opcode$$constant;
 2546 
 2547     // High registers handle in encode_RegMem
 2548     int base = $mem$$base;
 2549     int index = $mem$$index;
 2550     int scale = $mem$$scale;
 2551     int displace = $mem$$disp;
 2552 
 2553     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2554                                             // working with static
 2555                                             // globals
 2556     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2557                   disp_reloc);
 2558   %}
 2559 
 2560   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2561   %{
 2562     int reg_encoding = $dst$$reg;
 2563     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2564     int index        = 0x04;            // 0x04 indicates no index
 2565     int scale        = 0x00;            // 0x00 indicates no scale
 2566     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2567     relocInfo::relocType disp_reloc = relocInfo::none;
 2568     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2569                   disp_reloc);
 2570   %}
 2571 
 2572   enc_class neg_reg(rRegI dst)
 2573   %{
 2574     int dstenc = $dst$$reg;
 2575     if (dstenc &gt;= 8) {
 2576       emit_opcode(cbuf, Assembler::REX_B);
 2577       dstenc -= 8;
 2578     }
 2579     // NEG $dst
 2580     emit_opcode(cbuf, 0xF7);
 2581     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2582   %}
 2583 
 2584   enc_class neg_reg_wide(rRegI dst)
 2585   %{
 2586     int dstenc = $dst$$reg;
 2587     if (dstenc &lt; 8) {
 2588       emit_opcode(cbuf, Assembler::REX_W);
 2589     } else {
 2590       emit_opcode(cbuf, Assembler::REX_WB);
 2591       dstenc -= 8;
 2592     }
 2593     // NEG $dst
 2594     emit_opcode(cbuf, 0xF7);
 2595     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2596   %}
 2597 
 2598   enc_class setLT_reg(rRegI dst)
 2599   %{
 2600     int dstenc = $dst$$reg;
 2601     if (dstenc &gt;= 8) {
 2602       emit_opcode(cbuf, Assembler::REX_B);
 2603       dstenc -= 8;
 2604     } else if (dstenc &gt;= 4) {
 2605       emit_opcode(cbuf, Assembler::REX);
 2606     }
 2607     // SETLT $dst
 2608     emit_opcode(cbuf, 0x0F);
 2609     emit_opcode(cbuf, 0x9C);
 2610     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2611   %}
 2612 
 2613   enc_class setNZ_reg(rRegI dst)
 2614   %{
 2615     int dstenc = $dst$$reg;
 2616     if (dstenc &gt;= 8) {
 2617       emit_opcode(cbuf, Assembler::REX_B);
 2618       dstenc -= 8;
 2619     } else if (dstenc &gt;= 4) {
 2620       emit_opcode(cbuf, Assembler::REX);
 2621     }
 2622     // SETNZ $dst
 2623     emit_opcode(cbuf, 0x0F);
 2624     emit_opcode(cbuf, 0x95);
 2625     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2626   %}
 2627 
 2628 
 2629   // Compare the lonogs and set -1, 0, or 1 into dst
 2630   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2631   %{
 2632     int src1enc = $src1$$reg;
 2633     int src2enc = $src2$$reg;
 2634     int dstenc = $dst$$reg;
 2635 
 2636     // cmpq $src1, $src2
 2637     if (src1enc &lt; 8) {
 2638       if (src2enc &lt; 8) {
 2639         emit_opcode(cbuf, Assembler::REX_W);
 2640       } else {
 2641         emit_opcode(cbuf, Assembler::REX_WB);
 2642       }
 2643     } else {
 2644       if (src2enc &lt; 8) {
 2645         emit_opcode(cbuf, Assembler::REX_WR);
 2646       } else {
 2647         emit_opcode(cbuf, Assembler::REX_WRB);
 2648       }
 2649     }
 2650     emit_opcode(cbuf, 0x3B);
 2651     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2652 
 2653     // movl $dst, -1
 2654     if (dstenc &gt;= 8) {
 2655       emit_opcode(cbuf, Assembler::REX_B);
 2656     }
 2657     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2658     emit_d32(cbuf, -1);
 2659 
 2660     // jl,s done
 2661     emit_opcode(cbuf, 0x7C);
 2662     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2663 
 2664     // setne $dst
 2665     if (dstenc &gt;= 4) {
 2666       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2667     }
 2668     emit_opcode(cbuf, 0x0F);
 2669     emit_opcode(cbuf, 0x95);
 2670     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2671 
 2672     // movzbl $dst, $dst
 2673     if (dstenc &gt;= 4) {
 2674       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2675     }
 2676     emit_opcode(cbuf, 0x0F);
 2677     emit_opcode(cbuf, 0xB6);
 2678     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2679   %}
 2680 
 2681   enc_class Push_ResultXD(regD dst) %{
 2682     MacroAssembler _masm(&amp;cbuf);
 2683     __ fstp_d(Address(rsp, 0));
 2684     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2685     __ addptr(rsp, 8);
 2686   %}
 2687 
 2688   enc_class Push_SrcXD(regD src) %{
 2689     MacroAssembler _masm(&amp;cbuf);
 2690     __ subptr(rsp, 8);
 2691     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2692     __ fld_d(Address(rsp, 0));
 2693   %}
 2694 
 2695 
 2696   enc_class enc_rethrow()
 2697   %{
 2698     cbuf.set_insts_mark();
 2699     emit_opcode(cbuf, 0xE9); // jmp entry
 2700     emit_d32_reloc(cbuf,
 2701                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2702                    runtime_call_Relocation::spec(),
 2703                    RELOC_DISP32);
 2704   %}
 2705 
 2706 %}
 2707 
 2708 
 2709 
 2710 //----------FRAME--------------------------------------------------------------
 2711 // Definition of frame structure and management information.
 2712 //
 2713 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2714 //                             |   (to get allocators register number
 2715 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2716 //  r   CALLER     |        |
 2717 //  o     |        +--------+      pad to even-align allocators stack-slot
 2718 //  w     V        |  pad0  |        numbers; owned by CALLER
 2719 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2720 //  h     ^        |   in   |  5
 2721 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2722 //  |     |        |        |  3
 2723 //  |     |        +--------+
 2724 //  V     |        | old out|      Empty on Intel, window on Sparc
 2725 //        |    old |preserve|      Must be even aligned.
 2726 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2727 //        |        |   in   |  3   area for Intel ret address
 2728 //     Owned by    |preserve|      Empty on Sparc.
 2729 //       SELF      +--------+
 2730 //        |        |  pad2  |  2   pad to align old SP
 2731 //        |        +--------+  1
 2732 //        |        | locks  |  0
 2733 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2734 //        |        |  pad1  | 11   pad to align new SP
 2735 //        |        +--------+
 2736 //        |        |        | 10
 2737 //        |        | spills |  9   spills
 2738 //        V        |        |  8   (pad0 slot for callee)
 2739 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2740 //        ^        |  out   |  7
 2741 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2742 //     Owned by    +--------+
 2743 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2744 //        |    new |preserve|      Must be even-aligned.
 2745 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2746 //        |        |        |
 2747 //
 2748 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2749 //         known from SELF&#39;s arguments and the Java calling convention.
 2750 //         Region 6-7 is determined per call site.
 2751 // Note 2: If the calling convention leaves holes in the incoming argument
 2752 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2753 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2754 //         incoming area, as the Java calling convention is completely under
 2755 //         the control of the AD file.  Doubles can be sorted and packed to
 2756 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2757 //         varargs C calling conventions.
 2758 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2759 //         even aligned with pad0 as needed.
 2760 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2761 //         region 6-11 is even aligned; it may be padded out more so that
 2762 //         the region from SP to FP meets the minimum stack alignment.
 2763 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2764 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2765 //         SP meets the minimum alignment.
 2766 
 2767 frame
 2768 %{
 2769   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2770   stack_direction(TOWARDS_LOW);
 2771 
 2772   // These three registers define part of the calling convention
 2773   // between compiled code and the interpreter.
 2774   inline_cache_reg(RAX);                // Inline Cache Register
 2775   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2776                                         // calling interpreter
 2777 
 2778   // Optional: name the operand used by cisc-spilling to access
 2779   // [stack_pointer + offset]
 2780   cisc_spilling_operand_name(indOffset32);
 2781 
 2782   // Number of stack slots consumed by locking an object
 2783   sync_stack_slots(2);
 2784 
 2785   // Compiled code&#39;s Frame Pointer
 2786   frame_pointer(RSP);
 2787 
 2788   // Interpreter stores its frame pointer in a register which is
 2789   // stored to the stack by I2CAdaptors.
 2790   // I2CAdaptors convert from interpreted java to compiled java.
 2791   interpreter_frame_pointer(RBP);
 2792 
 2793   // Stack alignment requirement
 2794   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2795 
 2796   // Number of stack slots between incoming argument block and the start of
 2797   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2798   // EPILOG must remove this many slots.  amd64 needs two slots for
 2799   // return address.
 2800   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2801 
 2802   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2803   // for calls to C.  Supports the var-args backing area for register parms.
 2804   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2805 
 2806   // The after-PROLOG location of the return address.  Location of
 2807   // return address specifies a type (REG or STACK) and a number
 2808   // representing the register number (i.e. - use a register name) or
 2809   // stack slot.
 2810   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2811   // Otherwise, it is above the locks and verification slot and alignment word
 2812   return_addr(STACK - 2 +
 2813               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2814                         Compile::current()-&gt;fixed_slots()),
 2815                        stack_alignment_in_slots()));
 2816 
 2817   // Body of function which returns an integer array locating
 2818   // arguments either in registers or in stack slots.  Passed an array
 2819   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2820   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2821   // arguments for a CALLEE.  Incoming stack arguments are
 2822   // automatically biased by the preserve_stack_slots field above.
 2823 
 2824   calling_convention
 2825   %{
 2826     // No difference between ingoing/outgoing just pass false
 2827     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2828   %}
 2829 
 2830   c_calling_convention
 2831   %{
 2832     // This is obviously always outgoing
 2833     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2834   %}
 2835 
 2836   // Location of compiled Java return values.  Same as C for now.
 2837   return_value
 2838   %{
 2839     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2840            &quot;only return normal values&quot;);
 2841 
 2842     static const int lo[Op_RegL + 1] = {
 2843       0,
 2844       0,
 2845       RAX_num,  // Op_RegN
 2846       RAX_num,  // Op_RegI
 2847       RAX_num,  // Op_RegP
 2848       XMM0_num, // Op_RegF
 2849       XMM0_num, // Op_RegD
 2850       RAX_num   // Op_RegL
 2851     };
 2852     static const int hi[Op_RegL + 1] = {
 2853       0,
 2854       0,
 2855       OptoReg::Bad, // Op_RegN
 2856       OptoReg::Bad, // Op_RegI
 2857       RAX_H_num,    // Op_RegP
 2858       OptoReg::Bad, // Op_RegF
 2859       XMM0b_num,    // Op_RegD
 2860       RAX_H_num     // Op_RegL
 2861     };
 2862     // Excluded flags and vector registers.
 2863     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2864     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2865   %}
 2866 %}
 2867 
 2868 //----------ATTRIBUTES---------------------------------------------------------
 2869 //----------Operand Attributes-------------------------------------------------
 2870 op_attrib op_cost(0);        // Required cost attribute
 2871 
 2872 //----------Instruction Attributes---------------------------------------------
 2873 ins_attrib ins_cost(100);       // Required cost attribute
 2874 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2875 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2876                                 // a non-matching short branch variant
 2877                                 // of some long branch?
 2878 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2879                                 // be a power of 2) specifies the
 2880                                 // alignment that some part of the
 2881                                 // instruction (not necessarily the
 2882                                 // start) requires.  If &gt; 1, a
 2883                                 // compute_padding() function must be
 2884                                 // provided for the instruction
 2885 
 2886 //----------OPERANDS-----------------------------------------------------------
 2887 // Operand definitions must precede instruction definitions for correct parsing
 2888 // in the ADLC because operands constitute user defined types which are used in
 2889 // instruction definitions.
 2890 
 2891 //----------Simple Operands----------------------------------------------------
 2892 // Immediate Operands
 2893 // Integer Immediate
 2894 operand immI()
 2895 %{
 2896   match(ConI);
 2897 
 2898   op_cost(10);
 2899   format %{ %}
 2900   interface(CONST_INTER);
 2901 %}
 2902 
 2903 // Constant for test vs zero
 2904 operand immI0()
 2905 %{
 2906   predicate(n-&gt;get_int() == 0);
 2907   match(ConI);
 2908 
 2909   op_cost(0);
 2910   format %{ %}
 2911   interface(CONST_INTER);
 2912 %}
 2913 
 2914 // Constant for increment
 2915 operand immI1()
 2916 %{
 2917   predicate(n-&gt;get_int() == 1);
 2918   match(ConI);
 2919 
 2920   op_cost(0);
 2921   format %{ %}
 2922   interface(CONST_INTER);
 2923 %}
 2924 
 2925 // Constant for decrement
 2926 operand immI_M1()
 2927 %{
 2928   predicate(n-&gt;get_int() == -1);
 2929   match(ConI);
 2930 
 2931   op_cost(0);
 2932   format %{ %}
 2933   interface(CONST_INTER);
 2934 %}
 2935 
 2936 // Valid scale values for addressing modes
 2937 operand immI2()
 2938 %{
 2939   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2940   match(ConI);
 2941 
 2942   format %{ %}
 2943   interface(CONST_INTER);
 2944 %}
 2945 
 2946 operand immI8()
 2947 %{
 2948   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2949   match(ConI);
 2950 
 2951   op_cost(5);
 2952   format %{ %}
 2953   interface(CONST_INTER);
 2954 %}
 2955 
 2956 operand immU8()
 2957 %{
 2958   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2959   match(ConI);
 2960 
 2961   op_cost(5);
 2962   format %{ %}
 2963   interface(CONST_INTER);
 2964 %}
 2965 
 2966 operand immI16()
 2967 %{
 2968   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2969   match(ConI);
 2970 
 2971   op_cost(10);
 2972   format %{ %}
 2973   interface(CONST_INTER);
 2974 %}
 2975 
 2976 // Int Immediate non-negative
 2977 operand immU31()
 2978 %{
 2979   predicate(n-&gt;get_int() &gt;= 0);
 2980   match(ConI);
 2981 
 2982   op_cost(0);
 2983   format %{ %}
 2984   interface(CONST_INTER);
 2985 %}
 2986 
 2987 // Constant for long shifts
 2988 operand immI_32()
 2989 %{
 2990   predicate( n-&gt;get_int() == 32 );
 2991   match(ConI);
 2992 
 2993   op_cost(0);
 2994   format %{ %}
 2995   interface(CONST_INTER);
 2996 %}
 2997 
 2998 // Constant for long shifts
 2999 operand immI_64()
 3000 %{
 3001   predicate( n-&gt;get_int() == 64 );
 3002   match(ConI);
 3003 
 3004   op_cost(0);
 3005   format %{ %}
 3006   interface(CONST_INTER);
 3007 %}
 3008 
 3009 // Pointer Immediate
 3010 operand immP()
 3011 %{
 3012   match(ConP);
 3013 
 3014   op_cost(10);
 3015   format %{ %}
 3016   interface(CONST_INTER);
 3017 %}
 3018 
 3019 // NULL Pointer Immediate
 3020 operand immP0()
 3021 %{
 3022   predicate(n-&gt;get_ptr() == 0);
 3023   match(ConP);
 3024 
 3025   op_cost(5);
 3026   format %{ %}
 3027   interface(CONST_INTER);
 3028 %}
 3029 
 3030 // Pointer Immediate
 3031 operand immN() %{
 3032   match(ConN);
 3033 
 3034   op_cost(10);
 3035   format %{ %}
 3036   interface(CONST_INTER);
 3037 %}
 3038 
 3039 operand immNKlass() %{
 3040   match(ConNKlass);
 3041 
 3042   op_cost(10);
 3043   format %{ %}
 3044   interface(CONST_INTER);
 3045 %}
 3046 
 3047 // NULL Pointer Immediate
 3048 operand immN0() %{
 3049   predicate(n-&gt;get_narrowcon() == 0);
 3050   match(ConN);
 3051 
 3052   op_cost(5);
 3053   format %{ %}
 3054   interface(CONST_INTER);
 3055 %}
 3056 
 3057 operand immP31()
 3058 %{
 3059   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3060             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3061   match(ConP);
 3062 
 3063   op_cost(5);
 3064   format %{ %}
 3065   interface(CONST_INTER);
 3066 %}
 3067 
 3068 
 3069 // Long Immediate
 3070 operand immL()
 3071 %{
 3072   match(ConL);
 3073 
 3074   op_cost(20);
 3075   format %{ %}
 3076   interface(CONST_INTER);
 3077 %}
 3078 
 3079 // Long Immediate 8-bit
 3080 operand immL8()
 3081 %{
 3082   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3083   match(ConL);
 3084 
 3085   op_cost(5);
 3086   format %{ %}
 3087   interface(CONST_INTER);
 3088 %}
 3089 
 3090 // Long Immediate 32-bit unsigned
 3091 operand immUL32()
 3092 %{
 3093   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3094   match(ConL);
 3095 
 3096   op_cost(10);
 3097   format %{ %}
 3098   interface(CONST_INTER);
 3099 %}
 3100 
 3101 // Long Immediate 32-bit signed
 3102 operand immL32()
 3103 %{
 3104   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3105   match(ConL);
 3106 
 3107   op_cost(15);
 3108   format %{ %}
 3109   interface(CONST_INTER);
 3110 %}
 3111 
 3112 operand immL_Pow2()
 3113 %{
 3114   predicate(is_power_of_2(n-&gt;get_long()));
 3115   match(ConL);
 3116 
 3117   op_cost(15);
 3118   format %{ %}
 3119   interface(CONST_INTER);
 3120 %}
 3121 
 3122 operand immL_NotPow2()
 3123 %{
 3124   predicate(is_power_of_2(~n-&gt;get_long()));
 3125   match(ConL);
 3126 
 3127   op_cost(15);
 3128   format %{ %}
 3129   interface(CONST_INTER);
 3130 %}
 3131 
 3132 // Long Immediate zero
 3133 operand immL0()
 3134 %{
 3135   predicate(n-&gt;get_long() == 0L);
 3136   match(ConL);
 3137 
 3138   op_cost(10);
 3139   format %{ %}
 3140   interface(CONST_INTER);
 3141 %}
 3142 
 3143 // Constant for increment
 3144 operand immL1()
 3145 %{
 3146   predicate(n-&gt;get_long() == 1);
 3147   match(ConL);
 3148 
 3149   format %{ %}
 3150   interface(CONST_INTER);
 3151 %}
 3152 
 3153 // Constant for decrement
 3154 operand immL_M1()
 3155 %{
 3156   predicate(n-&gt;get_long() == -1);
 3157   match(ConL);
 3158 
 3159   format %{ %}
 3160   interface(CONST_INTER);
 3161 %}
 3162 
 3163 // Long Immediate: the value 10
 3164 operand immL10()
 3165 %{
 3166   predicate(n-&gt;get_long() == 10);
 3167   match(ConL);
 3168 
 3169   format %{ %}
 3170   interface(CONST_INTER);
 3171 %}
 3172 
 3173 // Long immediate from 0 to 127.
 3174 // Used for a shorter form of long mul by 10.
 3175 operand immL_127()
 3176 %{
 3177   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3178   match(ConL);
 3179 
 3180   op_cost(10);
 3181   format %{ %}
 3182   interface(CONST_INTER);
 3183 %}
 3184 
 3185 // Long Immediate: low 32-bit mask
 3186 operand immL_32bits()
 3187 %{
 3188   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3189   match(ConL);
 3190   op_cost(20);
 3191 
 3192   format %{ %}
 3193   interface(CONST_INTER);
 3194 %}
 3195 
 3196 // Float Immediate zero
 3197 operand immF0()
 3198 %{
 3199   predicate(jint_cast(n-&gt;getf()) == 0);
 3200   match(ConF);
 3201 
 3202   op_cost(5);
 3203   format %{ %}
 3204   interface(CONST_INTER);
 3205 %}
 3206 
 3207 // Float Immediate
 3208 operand immF()
 3209 %{
 3210   match(ConF);
 3211 
 3212   op_cost(15);
 3213   format %{ %}
 3214   interface(CONST_INTER);
 3215 %}
 3216 
 3217 // Double Immediate zero
 3218 operand immD0()
 3219 %{
 3220   predicate(jlong_cast(n-&gt;getd()) == 0);
 3221   match(ConD);
 3222 
 3223   op_cost(5);
 3224   format %{ %}
 3225   interface(CONST_INTER);
 3226 %}
 3227 
 3228 // Double Immediate
 3229 operand immD()
 3230 %{
 3231   match(ConD);
 3232 
 3233   op_cost(15);
 3234   format %{ %}
 3235   interface(CONST_INTER);
 3236 %}
 3237 
 3238 // Immediates for special shifts (sign extend)
 3239 
 3240 // Constants for increment
 3241 operand immI_16()
 3242 %{
 3243   predicate(n-&gt;get_int() == 16);
 3244   match(ConI);
 3245 
 3246   format %{ %}
 3247   interface(CONST_INTER);
 3248 %}
 3249 
 3250 operand immI_24()
 3251 %{
 3252   predicate(n-&gt;get_int() == 24);
 3253   match(ConI);
 3254 
 3255   format %{ %}
 3256   interface(CONST_INTER);
 3257 %}
 3258 
 3259 // Constant for byte-wide masking
 3260 operand immI_255()
 3261 %{
 3262   predicate(n-&gt;get_int() == 255);
 3263   match(ConI);
 3264 
 3265   format %{ %}
 3266   interface(CONST_INTER);
 3267 %}
 3268 
 3269 // Constant for short-wide masking
 3270 operand immI_65535()
 3271 %{
 3272   predicate(n-&gt;get_int() == 65535);
 3273   match(ConI);
 3274 
 3275   format %{ %}
 3276   interface(CONST_INTER);
 3277 %}
 3278 
 3279 // Constant for byte-wide masking
 3280 operand immL_255()
 3281 %{
 3282   predicate(n-&gt;get_long() == 255);
 3283   match(ConL);
 3284 
 3285   format %{ %}
 3286   interface(CONST_INTER);
 3287 %}
 3288 
 3289 // Constant for short-wide masking
 3290 operand immL_65535()
 3291 %{
 3292   predicate(n-&gt;get_long() == 65535);
 3293   match(ConL);
 3294 
 3295   format %{ %}
 3296   interface(CONST_INTER);
 3297 %}
 3298 
 3299 // Register Operands
 3300 // Integer Register
 3301 operand rRegI()
 3302 %{
 3303   constraint(ALLOC_IN_RC(int_reg));
 3304   match(RegI);
 3305 
 3306   match(rax_RegI);
 3307   match(rbx_RegI);
 3308   match(rcx_RegI);
 3309   match(rdx_RegI);
 3310   match(rdi_RegI);
 3311 
 3312   format %{ %}
 3313   interface(REG_INTER);
 3314 %}
 3315 
 3316 // Special Registers
 3317 operand rax_RegI()
 3318 %{
 3319   constraint(ALLOC_IN_RC(int_rax_reg));
 3320   match(RegI);
 3321   match(rRegI);
 3322 
 3323   format %{ &quot;RAX&quot; %}
 3324   interface(REG_INTER);
 3325 %}
 3326 
 3327 // Special Registers
 3328 operand rbx_RegI()
 3329 %{
 3330   constraint(ALLOC_IN_RC(int_rbx_reg));
 3331   match(RegI);
 3332   match(rRegI);
 3333 
 3334   format %{ &quot;RBX&quot; %}
 3335   interface(REG_INTER);
 3336 %}
 3337 
 3338 operand rcx_RegI()
 3339 %{
 3340   constraint(ALLOC_IN_RC(int_rcx_reg));
 3341   match(RegI);
 3342   match(rRegI);
 3343 
 3344   format %{ &quot;RCX&quot; %}
 3345   interface(REG_INTER);
 3346 %}
 3347 
 3348 operand rdx_RegI()
 3349 %{
 3350   constraint(ALLOC_IN_RC(int_rdx_reg));
 3351   match(RegI);
 3352   match(rRegI);
 3353 
 3354   format %{ &quot;RDX&quot; %}
 3355   interface(REG_INTER);
 3356 %}
 3357 
 3358 operand rdi_RegI()
 3359 %{
 3360   constraint(ALLOC_IN_RC(int_rdi_reg));
 3361   match(RegI);
 3362   match(rRegI);
 3363 
 3364   format %{ &quot;RDI&quot; %}
 3365   interface(REG_INTER);
 3366 %}
 3367 
 3368 operand no_rcx_RegI()
 3369 %{
 3370   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3371   match(RegI);
 3372   match(rax_RegI);
 3373   match(rbx_RegI);
 3374   match(rdx_RegI);
 3375   match(rdi_RegI);
 3376 
 3377   format %{ %}
 3378   interface(REG_INTER);
 3379 %}
 3380 
 3381 operand no_rax_rdx_RegI()
 3382 %{
 3383   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3384   match(RegI);
 3385   match(rbx_RegI);
 3386   match(rcx_RegI);
 3387   match(rdi_RegI);
 3388 
 3389   format %{ %}
 3390   interface(REG_INTER);
 3391 %}
 3392 
 3393 // Pointer Register
 3394 operand any_RegP()
 3395 %{
 3396   constraint(ALLOC_IN_RC(any_reg));
 3397   match(RegP);
 3398   match(rax_RegP);
 3399   match(rbx_RegP);
 3400   match(rdi_RegP);
 3401   match(rsi_RegP);
 3402   match(rbp_RegP);
 3403   match(r15_RegP);
 3404   match(rRegP);
 3405 
 3406   format %{ %}
 3407   interface(REG_INTER);
 3408 %}
 3409 
 3410 operand rRegP()
 3411 %{
 3412   constraint(ALLOC_IN_RC(ptr_reg));
 3413   match(RegP);
 3414   match(rax_RegP);
 3415   match(rbx_RegP);
 3416   match(rdi_RegP);
 3417   match(rsi_RegP);
 3418   match(rbp_RegP);  // See Q&amp;A below about
 3419   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3420 
 3421   format %{ %}
 3422   interface(REG_INTER);
 3423 %}
 3424 
 3425 operand rRegN() %{
 3426   constraint(ALLOC_IN_RC(int_reg));
 3427   match(RegN);
 3428 
 3429   format %{ %}
 3430   interface(REG_INTER);
 3431 %}
 3432 
 3433 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3434 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3435 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3436 // The output of an instruction is controlled by the allocator, which respects
 3437 // register class masks, not match rules.  Unless an instruction mentions
 3438 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3439 // by the allocator as an input.
 3440 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3441 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3442 // result, RBP is not included in the output of the instruction either.
 3443 
 3444 operand no_rax_RegP()
 3445 %{
 3446   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3447   match(RegP);
 3448   match(rbx_RegP);
 3449   match(rsi_RegP);
 3450   match(rdi_RegP);
 3451 
 3452   format %{ %}
 3453   interface(REG_INTER);
 3454 %}
 3455 
 3456 // This operand is not allowed to use RBP even if
 3457 // RBP is not used to hold the frame pointer.
 3458 operand no_rbp_RegP()
 3459 %{
 3460   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3461   match(RegP);
 3462   match(rbx_RegP);
 3463   match(rsi_RegP);
 3464   match(rdi_RegP);
 3465 
 3466   format %{ %}
 3467   interface(REG_INTER);
 3468 %}
 3469 
 3470 operand no_rax_rbx_RegP()
 3471 %{
 3472   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3473   match(RegP);
 3474   match(rsi_RegP);
 3475   match(rdi_RegP);
 3476 
 3477   format %{ %}
 3478   interface(REG_INTER);
 3479 %}
 3480 
 3481 // Special Registers
 3482 // Return a pointer value
 3483 operand rax_RegP()
 3484 %{
 3485   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3486   match(RegP);
 3487   match(rRegP);
 3488 
 3489   format %{ %}
 3490   interface(REG_INTER);
 3491 %}
 3492 
 3493 // Special Registers
 3494 // Return a compressed pointer value
 3495 operand rax_RegN()
 3496 %{
 3497   constraint(ALLOC_IN_RC(int_rax_reg));
 3498   match(RegN);
 3499   match(rRegN);
 3500 
 3501   format %{ %}
 3502   interface(REG_INTER);
 3503 %}
 3504 
 3505 // Used in AtomicAdd
 3506 operand rbx_RegP()
 3507 %{
 3508   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3509   match(RegP);
 3510   match(rRegP);
 3511 
 3512   format %{ %}
 3513   interface(REG_INTER);
 3514 %}
 3515 
 3516 operand rsi_RegP()
 3517 %{
 3518   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3519   match(RegP);
 3520   match(rRegP);
 3521 
 3522   format %{ %}
 3523   interface(REG_INTER);
 3524 %}
 3525 
 3526 operand rbp_RegP()
 3527 %{
 3528   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3529   match(RegP);
 3530   match(rRegP);
 3531 
 3532   format %{ %}
 3533   interface(REG_INTER);
 3534 %}
 3535 
 3536 // Used in rep stosq
 3537 operand rdi_RegP()
 3538 %{
 3539   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3540   match(RegP);
 3541   match(rRegP);
 3542 
 3543   format %{ %}
 3544   interface(REG_INTER);
 3545 %}
 3546 
 3547 operand r15_RegP()
 3548 %{
 3549   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3550   match(RegP);
 3551   match(rRegP);
 3552 
 3553   format %{ %}
 3554   interface(REG_INTER);
 3555 %}
 3556 
 3557 operand rRegL()
 3558 %{
 3559   constraint(ALLOC_IN_RC(long_reg));
 3560   match(RegL);
 3561   match(rax_RegL);
 3562   match(rdx_RegL);
 3563 
 3564   format %{ %}
 3565   interface(REG_INTER);
 3566 %}
 3567 
 3568 // Special Registers
 3569 operand no_rax_rdx_RegL()
 3570 %{
 3571   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3572   match(RegL);
 3573   match(rRegL);
 3574 
 3575   format %{ %}
 3576   interface(REG_INTER);
 3577 %}
 3578 
 3579 operand no_rax_RegL()
 3580 %{
 3581   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3582   match(RegL);
 3583   match(rRegL);
 3584   match(rdx_RegL);
 3585 
 3586   format %{ %}
 3587   interface(REG_INTER);
 3588 %}
 3589 
 3590 operand no_rcx_RegL()
 3591 %{
 3592   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3593   match(RegL);
 3594   match(rRegL);
 3595 
 3596   format %{ %}
 3597   interface(REG_INTER);
 3598 %}
 3599 
 3600 operand rax_RegL()
 3601 %{
 3602   constraint(ALLOC_IN_RC(long_rax_reg));
 3603   match(RegL);
 3604   match(rRegL);
 3605 
 3606   format %{ &quot;RAX&quot; %}
 3607   interface(REG_INTER);
 3608 %}
 3609 
 3610 operand rcx_RegL()
 3611 %{
 3612   constraint(ALLOC_IN_RC(long_rcx_reg));
 3613   match(RegL);
 3614   match(rRegL);
 3615 
 3616   format %{ %}
 3617   interface(REG_INTER);
 3618 %}
 3619 
 3620 operand rdx_RegL()
 3621 %{
 3622   constraint(ALLOC_IN_RC(long_rdx_reg));
 3623   match(RegL);
 3624   match(rRegL);
 3625 
 3626   format %{ %}
 3627   interface(REG_INTER);
 3628 %}
 3629 
 3630 // Flags register, used as output of compare instructions
 3631 operand rFlagsReg()
 3632 %{
 3633   constraint(ALLOC_IN_RC(int_flags));
 3634   match(RegFlags);
 3635 
 3636   format %{ &quot;RFLAGS&quot; %}
 3637   interface(REG_INTER);
 3638 %}
 3639 
 3640 // Flags register, used as output of FLOATING POINT compare instructions
 3641 operand rFlagsRegU()
 3642 %{
 3643   constraint(ALLOC_IN_RC(int_flags));
 3644   match(RegFlags);
 3645 
 3646   format %{ &quot;RFLAGS_U&quot; %}
 3647   interface(REG_INTER);
 3648 %}
 3649 
 3650 operand rFlagsRegUCF() %{
 3651   constraint(ALLOC_IN_RC(int_flags));
 3652   match(RegFlags);
 3653   predicate(false);
 3654 
 3655   format %{ &quot;RFLAGS_U_CF&quot; %}
 3656   interface(REG_INTER);
 3657 %}
 3658 
 3659 // Float register operands
 3660 operand regF() %{
 3661    constraint(ALLOC_IN_RC(float_reg));
 3662    match(RegF);
 3663 
 3664    format %{ %}
 3665    interface(REG_INTER);
 3666 %}
 3667 
 3668 // Float register operands
 3669 operand legRegF() %{
 3670    constraint(ALLOC_IN_RC(float_reg_legacy));
 3671    match(RegF);
 3672 
 3673    format %{ %}
 3674    interface(REG_INTER);
 3675 %}
 3676 
 3677 // Float register operands
 3678 operand vlRegF() %{
 3679    constraint(ALLOC_IN_RC(float_reg_vl));
 3680    match(RegF);
 3681 
 3682    format %{ %}
 3683    interface(REG_INTER);
 3684 %}
 3685 
 3686 // Double register operands
 3687 operand regD() %{
 3688    constraint(ALLOC_IN_RC(double_reg));
 3689    match(RegD);
 3690 
 3691    format %{ %}
 3692    interface(REG_INTER);
 3693 %}
 3694 
 3695 // Double register operands
 3696 operand legRegD() %{
 3697    constraint(ALLOC_IN_RC(double_reg_legacy));
 3698    match(RegD);
 3699 
 3700    format %{ %}
 3701    interface(REG_INTER);
 3702 %}
 3703 
 3704 // Double register operands
 3705 operand vlRegD() %{
 3706    constraint(ALLOC_IN_RC(double_reg_vl));
 3707    match(RegD);
 3708 
 3709    format %{ %}
 3710    interface(REG_INTER);
 3711 %}
 3712 
 3713 //----------Memory Operands----------------------------------------------------
 3714 // Direct Memory Operand
 3715 // operand direct(immP addr)
 3716 // %{
 3717 //   match(addr);
 3718 
 3719 //   format %{ &quot;[$addr]&quot; %}
 3720 //   interface(MEMORY_INTER) %{
 3721 //     base(0xFFFFFFFF);
 3722 //     index(0x4);
 3723 //     scale(0x0);
 3724 //     disp($addr);
 3725 //   %}
 3726 // %}
 3727 
 3728 // Indirect Memory Operand
 3729 operand indirect(any_RegP reg)
 3730 %{
 3731   constraint(ALLOC_IN_RC(ptr_reg));
 3732   match(reg);
 3733 
 3734   format %{ &quot;[$reg]&quot; %}
 3735   interface(MEMORY_INTER) %{
 3736     base($reg);
 3737     index(0x4);
 3738     scale(0x0);
 3739     disp(0x0);
 3740   %}
 3741 %}
 3742 
 3743 // Indirect Memory Plus Short Offset Operand
 3744 operand indOffset8(any_RegP reg, immL8 off)
 3745 %{
 3746   constraint(ALLOC_IN_RC(ptr_reg));
 3747   match(AddP reg off);
 3748 
 3749   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3750   interface(MEMORY_INTER) %{
 3751     base($reg);
 3752     index(0x4);
 3753     scale(0x0);
 3754     disp($off);
 3755   %}
 3756 %}
 3757 
 3758 // Indirect Memory Plus Long Offset Operand
 3759 operand indOffset32(any_RegP reg, immL32 off)
 3760 %{
 3761   constraint(ALLOC_IN_RC(ptr_reg));
 3762   match(AddP reg off);
 3763 
 3764   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3765   interface(MEMORY_INTER) %{
 3766     base($reg);
 3767     index(0x4);
 3768     scale(0x0);
 3769     disp($off);
 3770   %}
 3771 %}
 3772 
 3773 // Indirect Memory Plus Index Register Plus Offset Operand
 3774 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3775 %{
 3776   constraint(ALLOC_IN_RC(ptr_reg));
 3777   match(AddP (AddP reg lreg) off);
 3778 
 3779   op_cost(10);
 3780   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3781   interface(MEMORY_INTER) %{
 3782     base($reg);
 3783     index($lreg);
 3784     scale(0x0);
 3785     disp($off);
 3786   %}
 3787 %}
 3788 
 3789 // Indirect Memory Plus Index Register Plus Offset Operand
 3790 operand indIndex(any_RegP reg, rRegL lreg)
 3791 %{
 3792   constraint(ALLOC_IN_RC(ptr_reg));
 3793   match(AddP reg lreg);
 3794 
 3795   op_cost(10);
 3796   format %{&quot;[$reg + $lreg]&quot; %}
 3797   interface(MEMORY_INTER) %{
 3798     base($reg);
 3799     index($lreg);
 3800     scale(0x0);
 3801     disp(0x0);
 3802   %}
 3803 %}
 3804 
 3805 // Indirect Memory Times Scale Plus Index Register
 3806 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3807 %{
 3808   constraint(ALLOC_IN_RC(ptr_reg));
 3809   match(AddP reg (LShiftL lreg scale));
 3810 
 3811   op_cost(10);
 3812   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3813   interface(MEMORY_INTER) %{
 3814     base($reg);
 3815     index($lreg);
 3816     scale($scale);
 3817     disp(0x0);
 3818   %}
 3819 %}
 3820 
 3821 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3822 %{
 3823   constraint(ALLOC_IN_RC(ptr_reg));
 3824   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3825   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3826 
 3827   op_cost(10);
 3828   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3829   interface(MEMORY_INTER) %{
 3830     base($reg);
 3831     index($idx);
 3832     scale($scale);
 3833     disp(0x0);
 3834   %}
 3835 %}
 3836 
 3837 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3838 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3839 %{
 3840   constraint(ALLOC_IN_RC(ptr_reg));
 3841   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3842 
 3843   op_cost(10);
 3844   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3845   interface(MEMORY_INTER) %{
 3846     base($reg);
 3847     index($lreg);
 3848     scale($scale);
 3849     disp($off);
 3850   %}
 3851 %}
 3852 
 3853 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3854 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3855 %{
 3856   constraint(ALLOC_IN_RC(ptr_reg));
 3857   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3858   match(AddP (AddP reg (ConvI2L idx)) off);
 3859 
 3860   op_cost(10);
 3861   format %{&quot;[$reg + $off + $idx]&quot; %}
 3862   interface(MEMORY_INTER) %{
 3863     base($reg);
 3864     index($idx);
 3865     scale(0x0);
 3866     disp($off);
 3867   %}
 3868 %}
 3869 
 3870 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3871 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3872 %{
 3873   constraint(ALLOC_IN_RC(ptr_reg));
 3874   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3875   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3876 
 3877   op_cost(10);
 3878   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3879   interface(MEMORY_INTER) %{
 3880     base($reg);
 3881     index($idx);
 3882     scale($scale);
 3883     disp($off);
 3884   %}
 3885 %}
 3886 
 3887 // Indirect Narrow Oop Operand
 3888 operand indCompressedOop(rRegN reg) %{
 3889   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3890   constraint(ALLOC_IN_RC(ptr_reg));
 3891   match(DecodeN reg);
 3892 
 3893   op_cost(10);
 3894   format %{&quot;[R12 + $reg &lt;&lt; 3] (compressed oop addressing)&quot; %}
 3895   interface(MEMORY_INTER) %{
 3896     base(0xc); // R12
 3897     index($reg);
 3898     scale(0x3);
 3899     disp(0x0);
 3900   %}
 3901 %}
 3902 
 3903 // Indirect Narrow Oop Plus Offset Operand
 3904 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3905 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3906 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3907   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3908   constraint(ALLOC_IN_RC(ptr_reg));
 3909   match(AddP (DecodeN reg) off);
 3910 
 3911   op_cost(10);
 3912   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3913   interface(MEMORY_INTER) %{
 3914     base(0xc); // R12
 3915     index($reg);
 3916     scale(0x3);
 3917     disp($off);
 3918   %}
 3919 %}
 3920 
 3921 // Indirect Memory Operand
 3922 operand indirectNarrow(rRegN reg)
 3923 %{
 3924   predicate(CompressedOops::shift() == 0);
 3925   constraint(ALLOC_IN_RC(ptr_reg));
 3926   match(DecodeN reg);
 3927 
 3928   format %{ &quot;[$reg]&quot; %}
 3929   interface(MEMORY_INTER) %{
 3930     base($reg);
 3931     index(0x4);
 3932     scale(0x0);
 3933     disp(0x0);
 3934   %}
 3935 %}
 3936 
 3937 // Indirect Memory Plus Short Offset Operand
 3938 operand indOffset8Narrow(rRegN reg, immL8 off)
 3939 %{
 3940   predicate(CompressedOops::shift() == 0);
 3941   constraint(ALLOC_IN_RC(ptr_reg));
 3942   match(AddP (DecodeN reg) off);
 3943 
 3944   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3945   interface(MEMORY_INTER) %{
 3946     base($reg);
 3947     index(0x4);
 3948     scale(0x0);
 3949     disp($off);
 3950   %}
 3951 %}
 3952 
 3953 // Indirect Memory Plus Long Offset Operand
 3954 operand indOffset32Narrow(rRegN reg, immL32 off)
 3955 %{
 3956   predicate(CompressedOops::shift() == 0);
 3957   constraint(ALLOC_IN_RC(ptr_reg));
 3958   match(AddP (DecodeN reg) off);
 3959 
 3960   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3961   interface(MEMORY_INTER) %{
 3962     base($reg);
 3963     index(0x4);
 3964     scale(0x0);
 3965     disp($off);
 3966   %}
 3967 %}
 3968 
 3969 // Indirect Memory Plus Index Register Plus Offset Operand
 3970 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3971 %{
 3972   predicate(CompressedOops::shift() == 0);
 3973   constraint(ALLOC_IN_RC(ptr_reg));
 3974   match(AddP (AddP (DecodeN reg) lreg) off);
 3975 
 3976   op_cost(10);
 3977   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3978   interface(MEMORY_INTER) %{
 3979     base($reg);
 3980     index($lreg);
 3981     scale(0x0);
 3982     disp($off);
 3983   %}
 3984 %}
 3985 
 3986 // Indirect Memory Plus Index Register Plus Offset Operand
 3987 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3988 %{
 3989   predicate(CompressedOops::shift() == 0);
 3990   constraint(ALLOC_IN_RC(ptr_reg));
 3991   match(AddP (DecodeN reg) lreg);
 3992 
 3993   op_cost(10);
 3994   format %{&quot;[$reg + $lreg]&quot; %}
 3995   interface(MEMORY_INTER) %{
 3996     base($reg);
 3997     index($lreg);
 3998     scale(0x0);
 3999     disp(0x0);
 4000   %}
 4001 %}
 4002 
 4003 // Indirect Memory Times Scale Plus Index Register
 4004 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 4005 %{
 4006   predicate(CompressedOops::shift() == 0);
 4007   constraint(ALLOC_IN_RC(ptr_reg));
 4008   match(AddP (DecodeN reg) (LShiftL lreg scale));
 4009 
 4010   op_cost(10);
 4011   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 4012   interface(MEMORY_INTER) %{
 4013     base($reg);
 4014     index($lreg);
 4015     scale($scale);
 4016     disp(0x0);
 4017   %}
 4018 %}
 4019 
 4020 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4021 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 4022 %{
 4023   predicate(CompressedOops::shift() == 0);
 4024   constraint(ALLOC_IN_RC(ptr_reg));
 4025   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 4026 
 4027   op_cost(10);
 4028   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 4029   interface(MEMORY_INTER) %{
 4030     base($reg);
 4031     index($lreg);
 4032     scale($scale);
 4033     disp($off);
 4034   %}
 4035 %}
 4036 
 4037 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4038 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4039 %{
 4040   constraint(ALLOC_IN_RC(ptr_reg));
 4041   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4042   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4043 
 4044   op_cost(10);
 4045   format %{&quot;[$reg + $off + $idx]&quot; %}
 4046   interface(MEMORY_INTER) %{
 4047     base($reg);
 4048     index($idx);
 4049     scale(0x0);
 4050     disp($off);
 4051   %}
 4052 %}
 4053 
 4054 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4055 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4056 %{
 4057   constraint(ALLOC_IN_RC(ptr_reg));
 4058   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4059   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4060 
 4061   op_cost(10);
 4062   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4063   interface(MEMORY_INTER) %{
 4064     base($reg);
 4065     index($idx);
 4066     scale($scale);
 4067     disp($off);
 4068   %}
 4069 %}
 4070 
 4071 //----------Special Memory Operands--------------------------------------------
 4072 // Stack Slot Operand - This operand is used for loading and storing temporary
 4073 //                      values on the stack where a match requires a value to
 4074 //                      flow through memory.
 4075 operand stackSlotP(sRegP reg)
 4076 %{
 4077   constraint(ALLOC_IN_RC(stack_slots));
 4078   // No match rule because this operand is only generated in matching
 4079 
 4080   format %{ &quot;[$reg]&quot; %}
 4081   interface(MEMORY_INTER) %{
 4082     base(0x4);   // RSP
 4083     index(0x4);  // No Index
 4084     scale(0x0);  // No Scale
 4085     disp($reg);  // Stack Offset
 4086   %}
 4087 %}
 4088 
 4089 operand stackSlotI(sRegI reg)
 4090 %{
 4091   constraint(ALLOC_IN_RC(stack_slots));
 4092   // No match rule because this operand is only generated in matching
 4093 
 4094   format %{ &quot;[$reg]&quot; %}
 4095   interface(MEMORY_INTER) %{
 4096     base(0x4);   // RSP
 4097     index(0x4);  // No Index
 4098     scale(0x0);  // No Scale
 4099     disp($reg);  // Stack Offset
 4100   %}
 4101 %}
 4102 
 4103 operand stackSlotF(sRegF reg)
 4104 %{
 4105   constraint(ALLOC_IN_RC(stack_slots));
 4106   // No match rule because this operand is only generated in matching
 4107 
 4108   format %{ &quot;[$reg]&quot; %}
 4109   interface(MEMORY_INTER) %{
 4110     base(0x4);   // RSP
 4111     index(0x4);  // No Index
 4112     scale(0x0);  // No Scale
 4113     disp($reg);  // Stack Offset
 4114   %}
 4115 %}
 4116 
 4117 operand stackSlotD(sRegD reg)
 4118 %{
 4119   constraint(ALLOC_IN_RC(stack_slots));
 4120   // No match rule because this operand is only generated in matching
 4121 
 4122   format %{ &quot;[$reg]&quot; %}
 4123   interface(MEMORY_INTER) %{
 4124     base(0x4);   // RSP
 4125     index(0x4);  // No Index
 4126     scale(0x0);  // No Scale
 4127     disp($reg);  // Stack Offset
 4128   %}
 4129 %}
 4130 operand stackSlotL(sRegL reg)
 4131 %{
 4132   constraint(ALLOC_IN_RC(stack_slots));
 4133   // No match rule because this operand is only generated in matching
 4134 
 4135   format %{ &quot;[$reg]&quot; %}
 4136   interface(MEMORY_INTER) %{
 4137     base(0x4);   // RSP
 4138     index(0x4);  // No Index
 4139     scale(0x0);  // No Scale
 4140     disp($reg);  // Stack Offset
 4141   %}
 4142 %}
 4143 
 4144 //----------Conditional Branch Operands----------------------------------------
 4145 // Comparison Op  - This is the operation of the comparison, and is limited to
 4146 //                  the following set of codes:
 4147 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4148 //
 4149 // Other attributes of the comparison, such as unsignedness, are specified
 4150 // by the comparison instruction that sets a condition code flags register.
 4151 // That result is represented by a flags operand whose subtype is appropriate
 4152 // to the unsignedness (etc.) of the comparison.
 4153 //
 4154 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4155 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4156 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4157 
 4158 // Comparision Code
 4159 operand cmpOp()
 4160 %{
 4161   match(Bool);
 4162 
 4163   format %{ &quot;&quot; %}
 4164   interface(COND_INTER) %{
 4165     equal(0x4, &quot;e&quot;);
 4166     not_equal(0x5, &quot;ne&quot;);
 4167     less(0xC, &quot;l&quot;);
 4168     greater_equal(0xD, &quot;ge&quot;);
 4169     less_equal(0xE, &quot;le&quot;);
 4170     greater(0xF, &quot;g&quot;);
 4171     overflow(0x0, &quot;o&quot;);
 4172     no_overflow(0x1, &quot;no&quot;);
 4173   %}
 4174 %}
 4175 
 4176 // Comparison Code, unsigned compare.  Used by FP also, with
 4177 // C2 (unordered) turned into GT or LT already.  The other bits
 4178 // C0 and C3 are turned into Carry &amp; Zero flags.
 4179 operand cmpOpU()
 4180 %{
 4181   match(Bool);
 4182 
 4183   format %{ &quot;&quot; %}
 4184   interface(COND_INTER) %{
 4185     equal(0x4, &quot;e&quot;);
 4186     not_equal(0x5, &quot;ne&quot;);
 4187     less(0x2, &quot;b&quot;);
 4188     greater_equal(0x3, &quot;nb&quot;);
 4189     less_equal(0x6, &quot;be&quot;);
 4190     greater(0x7, &quot;nbe&quot;);
 4191     overflow(0x0, &quot;o&quot;);
 4192     no_overflow(0x1, &quot;no&quot;);
 4193   %}
 4194 %}
 4195 
 4196 
 4197 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4198 operand cmpOpUCF() %{
 4199   match(Bool);
 4200   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4201             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4202             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4203             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4204   format %{ &quot;&quot; %}
 4205   interface(COND_INTER) %{
 4206     equal(0x4, &quot;e&quot;);
 4207     not_equal(0x5, &quot;ne&quot;);
 4208     less(0x2, &quot;b&quot;);
 4209     greater_equal(0x3, &quot;nb&quot;);
 4210     less_equal(0x6, &quot;be&quot;);
 4211     greater(0x7, &quot;nbe&quot;);
 4212     overflow(0x0, &quot;o&quot;);
 4213     no_overflow(0x1, &quot;no&quot;);
 4214   %}
 4215 %}
 4216 
 4217 
 4218 // Floating comparisons that can be fixed up with extra conditional jumps
 4219 operand cmpOpUCF2() %{
 4220   match(Bool);
 4221   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4222             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4223   format %{ &quot;&quot; %}
 4224   interface(COND_INTER) %{
 4225     equal(0x4, &quot;e&quot;);
 4226     not_equal(0x5, &quot;ne&quot;);
 4227     less(0x2, &quot;b&quot;);
 4228     greater_equal(0x3, &quot;nb&quot;);
 4229     less_equal(0x6, &quot;be&quot;);
 4230     greater(0x7, &quot;nbe&quot;);
 4231     overflow(0x0, &quot;o&quot;);
 4232     no_overflow(0x1, &quot;no&quot;);
 4233   %}
 4234 %}
 4235 
 4236 //----------OPERAND CLASSES----------------------------------------------------
 4237 // Operand Classes are groups of operands that are used as to simplify
 4238 // instruction definitions by not requiring the AD writer to specify separate
 4239 // instructions for every form of operand when the instruction accepts
 4240 // multiple operand types with the same basic encoding and format.  The classic
 4241 // case of this is memory operands.
 4242 
 4243 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4244                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4245                indCompressedOop, indCompressedOopOffset,
 4246                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4247                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4248                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4249 
 4250 //----------PIPELINE-----------------------------------------------------------
 4251 // Rules which define the behavior of the target architectures pipeline.
 4252 pipeline %{
 4253 
 4254 //----------ATTRIBUTES---------------------------------------------------------
 4255 attributes %{
 4256   variable_size_instructions;        // Fixed size instructions
 4257   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4258   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4259   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4260   instruction_fetch_units = 1;       // of 16 bytes
 4261 
 4262   // List of nop instructions
 4263   nops( MachNop );
 4264 %}
 4265 
 4266 //----------RESOURCES----------------------------------------------------------
 4267 // Resources are the functional units available to the machine
 4268 
 4269 // Generic P2/P3 pipeline
 4270 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4271 // 3 instructions decoded per cycle.
 4272 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4273 // 3 ALU op, only ALU0 handles mul instructions.
 4274 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4275            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4276            BR, FPU,
 4277            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4278 
 4279 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4280 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4281 
 4282 // Generic P2/P3 pipeline
 4283 pipe_desc(S0, S1, S2, S3, S4, S5);
 4284 
 4285 //----------PIPELINE CLASSES---------------------------------------------------
 4286 // Pipeline Classes describe the stages in which input and output are
 4287 // referenced by the hardware pipeline.
 4288 
 4289 // Naming convention: ialu or fpu
 4290 // Then: _reg
 4291 // Then: _reg if there is a 2nd register
 4292 // Then: _long if it&#39;s a pair of instructions implementing a long
 4293 // Then: _fat if it requires the big decoder
 4294 //   Or: _mem if it requires the big decoder and a memory unit.
 4295 
 4296 // Integer ALU reg operation
 4297 pipe_class ialu_reg(rRegI dst)
 4298 %{
 4299     single_instruction;
 4300     dst    : S4(write);
 4301     dst    : S3(read);
 4302     DECODE : S0;        // any decoder
 4303     ALU    : S3;        // any alu
 4304 %}
 4305 
 4306 // Long ALU reg operation
 4307 pipe_class ialu_reg_long(rRegL dst)
 4308 %{
 4309     instruction_count(2);
 4310     dst    : S4(write);
 4311     dst    : S3(read);
 4312     DECODE : S0(2);     // any 2 decoders
 4313     ALU    : S3(2);     // both alus
 4314 %}
 4315 
 4316 // Integer ALU reg operation using big decoder
 4317 pipe_class ialu_reg_fat(rRegI dst)
 4318 %{
 4319     single_instruction;
 4320     dst    : S4(write);
 4321     dst    : S3(read);
 4322     D0     : S0;        // big decoder only
 4323     ALU    : S3;        // any alu
 4324 %}
 4325 
 4326 // Long ALU reg operation using big decoder
 4327 pipe_class ialu_reg_long_fat(rRegL dst)
 4328 %{
 4329     instruction_count(2);
 4330     dst    : S4(write);
 4331     dst    : S3(read);
 4332     D0     : S0(2);     // big decoder only; twice
 4333     ALU    : S3(2);     // any 2 alus
 4334 %}
 4335 
 4336 // Integer ALU reg-reg operation
 4337 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4338 %{
 4339     single_instruction;
 4340     dst    : S4(write);
 4341     src    : S3(read);
 4342     DECODE : S0;        // any decoder
 4343     ALU    : S3;        // any alu
 4344 %}
 4345 
 4346 // Long ALU reg-reg operation
 4347 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4348 %{
 4349     instruction_count(2);
 4350     dst    : S4(write);
 4351     src    : S3(read);
 4352     DECODE : S0(2);     // any 2 decoders
 4353     ALU    : S3(2);     // both alus
 4354 %}
 4355 
 4356 // Integer ALU reg-reg operation
 4357 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4358 %{
 4359     single_instruction;
 4360     dst    : S4(write);
 4361     src    : S3(read);
 4362     D0     : S0;        // big decoder only
 4363     ALU    : S3;        // any alu
 4364 %}
 4365 
 4366 // Long ALU reg-reg operation
 4367 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4368 %{
 4369     instruction_count(2);
 4370     dst    : S4(write);
 4371     src    : S3(read);
 4372     D0     : S0(2);     // big decoder only; twice
 4373     ALU    : S3(2);     // both alus
 4374 %}
 4375 
 4376 // Integer ALU reg-mem operation
 4377 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4378 %{
 4379     single_instruction;
 4380     dst    : S5(write);
 4381     mem    : S3(read);
 4382     D0     : S0;        // big decoder only
 4383     ALU    : S4;        // any alu
 4384     MEM    : S3;        // any mem
 4385 %}
 4386 
 4387 // Integer mem operation (prefetch)
 4388 pipe_class ialu_mem(memory mem)
 4389 %{
 4390     single_instruction;
 4391     mem    : S3(read);
 4392     D0     : S0;        // big decoder only
 4393     MEM    : S3;        // any mem
 4394 %}
 4395 
 4396 // Integer Store to Memory
 4397 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4398 %{
 4399     single_instruction;
 4400     mem    : S3(read);
 4401     src    : S5(read);
 4402     D0     : S0;        // big decoder only
 4403     ALU    : S4;        // any alu
 4404     MEM    : S3;
 4405 %}
 4406 
 4407 // // Long Store to Memory
 4408 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4409 // %{
 4410 //     instruction_count(2);
 4411 //     mem    : S3(read);
 4412 //     src    : S5(read);
 4413 //     D0     : S0(2);          // big decoder only; twice
 4414 //     ALU    : S4(2);     // any 2 alus
 4415 //     MEM    : S3(2);  // Both mems
 4416 // %}
 4417 
 4418 // Integer Store to Memory
 4419 pipe_class ialu_mem_imm(memory mem)
 4420 %{
 4421     single_instruction;
 4422     mem    : S3(read);
 4423     D0     : S0;        // big decoder only
 4424     ALU    : S4;        // any alu
 4425     MEM    : S3;
 4426 %}
 4427 
 4428 // Integer ALU0 reg-reg operation
 4429 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4430 %{
 4431     single_instruction;
 4432     dst    : S4(write);
 4433     src    : S3(read);
 4434     D0     : S0;        // Big decoder only
 4435     ALU0   : S3;        // only alu0
 4436 %}
 4437 
 4438 // Integer ALU0 reg-mem operation
 4439 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4440 %{
 4441     single_instruction;
 4442     dst    : S5(write);
 4443     mem    : S3(read);
 4444     D0     : S0;        // big decoder only
 4445     ALU0   : S4;        // ALU0 only
 4446     MEM    : S3;        // any mem
 4447 %}
 4448 
 4449 // Integer ALU reg-reg operation
 4450 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4451 %{
 4452     single_instruction;
 4453     cr     : S4(write);
 4454     src1   : S3(read);
 4455     src2   : S3(read);
 4456     DECODE : S0;        // any decoder
 4457     ALU    : S3;        // any alu
 4458 %}
 4459 
 4460 // Integer ALU reg-imm operation
 4461 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4462 %{
 4463     single_instruction;
 4464     cr     : S4(write);
 4465     src1   : S3(read);
 4466     DECODE : S0;        // any decoder
 4467     ALU    : S3;        // any alu
 4468 %}
 4469 
 4470 // Integer ALU reg-mem operation
 4471 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4472 %{
 4473     single_instruction;
 4474     cr     : S4(write);
 4475     src1   : S3(read);
 4476     src2   : S3(read);
 4477     D0     : S0;        // big decoder only
 4478     ALU    : S4;        // any alu
 4479     MEM    : S3;
 4480 %}
 4481 
 4482 // Conditional move reg-reg
 4483 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4484 %{
 4485     instruction_count(4);
 4486     y      : S4(read);
 4487     q      : S3(read);
 4488     p      : S3(read);
 4489     DECODE : S0(4);     // any decoder
 4490 %}
 4491 
 4492 // Conditional move reg-reg
 4493 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4494 %{
 4495     single_instruction;
 4496     dst    : S4(write);
 4497     src    : S3(read);
 4498     cr     : S3(read);
 4499     DECODE : S0;        // any decoder
 4500 %}
 4501 
 4502 // Conditional move reg-mem
 4503 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4504 %{
 4505     single_instruction;
 4506     dst    : S4(write);
 4507     src    : S3(read);
 4508     cr     : S3(read);
 4509     DECODE : S0;        // any decoder
 4510     MEM    : S3;
 4511 %}
 4512 
 4513 // Conditional move reg-reg long
 4514 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4515 %{
 4516     single_instruction;
 4517     dst    : S4(write);
 4518     src    : S3(read);
 4519     cr     : S3(read);
 4520     DECODE : S0(2);     // any 2 decoders
 4521 %}
 4522 
 4523 // XXX
 4524 // // Conditional move double reg-reg
 4525 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4526 // %{
 4527 //     single_instruction;
 4528 //     dst    : S4(write);
 4529 //     src    : S3(read);
 4530 //     cr     : S3(read);
 4531 //     DECODE : S0;     // any decoder
 4532 // %}
 4533 
 4534 // Float reg-reg operation
 4535 pipe_class fpu_reg(regD dst)
 4536 %{
 4537     instruction_count(2);
 4538     dst    : S3(read);
 4539     DECODE : S0(2);     // any 2 decoders
 4540     FPU    : S3;
 4541 %}
 4542 
 4543 // Float reg-reg operation
 4544 pipe_class fpu_reg_reg(regD dst, regD src)
 4545 %{
 4546     instruction_count(2);
 4547     dst    : S4(write);
 4548     src    : S3(read);
 4549     DECODE : S0(2);     // any 2 decoders
 4550     FPU    : S3;
 4551 %}
 4552 
 4553 // Float reg-reg operation
 4554 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4555 %{
 4556     instruction_count(3);
 4557     dst    : S4(write);
 4558     src1   : S3(read);
 4559     src2   : S3(read);
 4560     DECODE : S0(3);     // any 3 decoders
 4561     FPU    : S3(2);
 4562 %}
 4563 
 4564 // Float reg-reg operation
 4565 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4566 %{
 4567     instruction_count(4);
 4568     dst    : S4(write);
 4569     src1   : S3(read);
 4570     src2   : S3(read);
 4571     src3   : S3(read);
 4572     DECODE : S0(4);     // any 3 decoders
 4573     FPU    : S3(2);
 4574 %}
 4575 
 4576 // Float reg-reg operation
 4577 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4578 %{
 4579     instruction_count(4);
 4580     dst    : S4(write);
 4581     src1   : S3(read);
 4582     src2   : S3(read);
 4583     src3   : S3(read);
 4584     DECODE : S1(3);     // any 3 decoders
 4585     D0     : S0;        // Big decoder only
 4586     FPU    : S3(2);
 4587     MEM    : S3;
 4588 %}
 4589 
 4590 // Float reg-mem operation
 4591 pipe_class fpu_reg_mem(regD dst, memory mem)
 4592 %{
 4593     instruction_count(2);
 4594     dst    : S5(write);
 4595     mem    : S3(read);
 4596     D0     : S0;        // big decoder only
 4597     DECODE : S1;        // any decoder for FPU POP
 4598     FPU    : S4;
 4599     MEM    : S3;        // any mem
 4600 %}
 4601 
 4602 // Float reg-mem operation
 4603 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4604 %{
 4605     instruction_count(3);
 4606     dst    : S5(write);
 4607     src1   : S3(read);
 4608     mem    : S3(read);
 4609     D0     : S0;        // big decoder only
 4610     DECODE : S1(2);     // any decoder for FPU POP
 4611     FPU    : S4;
 4612     MEM    : S3;        // any mem
 4613 %}
 4614 
 4615 // Float mem-reg operation
 4616 pipe_class fpu_mem_reg(memory mem, regD src)
 4617 %{
 4618     instruction_count(2);
 4619     src    : S5(read);
 4620     mem    : S3(read);
 4621     DECODE : S0;        // any decoder for FPU PUSH
 4622     D0     : S1;        // big decoder only
 4623     FPU    : S4;
 4624     MEM    : S3;        // any mem
 4625 %}
 4626 
 4627 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4628 %{
 4629     instruction_count(3);
 4630     src1   : S3(read);
 4631     src2   : S3(read);
 4632     mem    : S3(read);
 4633     DECODE : S0(2);     // any decoder for FPU PUSH
 4634     D0     : S1;        // big decoder only
 4635     FPU    : S4;
 4636     MEM    : S3;        // any mem
 4637 %}
 4638 
 4639 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4640 %{
 4641     instruction_count(3);
 4642     src1   : S3(read);
 4643     src2   : S3(read);
 4644     mem    : S4(read);
 4645     DECODE : S0;        // any decoder for FPU PUSH
 4646     D0     : S0(2);     // big decoder only
 4647     FPU    : S4;
 4648     MEM    : S3(2);     // any mem
 4649 %}
 4650 
 4651 pipe_class fpu_mem_mem(memory dst, memory src1)
 4652 %{
 4653     instruction_count(2);
 4654     src1   : S3(read);
 4655     dst    : S4(read);
 4656     D0     : S0(2);     // big decoder only
 4657     MEM    : S3(2);     // any mem
 4658 %}
 4659 
 4660 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4661 %{
 4662     instruction_count(3);
 4663     src1   : S3(read);
 4664     src2   : S3(read);
 4665     dst    : S4(read);
 4666     D0     : S0(3);     // big decoder only
 4667     FPU    : S4;
 4668     MEM    : S3(3);     // any mem
 4669 %}
 4670 
 4671 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4672 %{
 4673     instruction_count(3);
 4674     src1   : S4(read);
 4675     mem    : S4(read);
 4676     DECODE : S0;        // any decoder for FPU PUSH
 4677     D0     : S0(2);     // big decoder only
 4678     FPU    : S4;
 4679     MEM    : S3(2);     // any mem
 4680 %}
 4681 
 4682 // Float load constant
 4683 pipe_class fpu_reg_con(regD dst)
 4684 %{
 4685     instruction_count(2);
 4686     dst    : S5(write);
 4687     D0     : S0;        // big decoder only for the load
 4688     DECODE : S1;        // any decoder for FPU POP
 4689     FPU    : S4;
 4690     MEM    : S3;        // any mem
 4691 %}
 4692 
 4693 // Float load constant
 4694 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4695 %{
 4696     instruction_count(3);
 4697     dst    : S5(write);
 4698     src    : S3(read);
 4699     D0     : S0;        // big decoder only for the load
 4700     DECODE : S1(2);     // any decoder for FPU POP
 4701     FPU    : S4;
 4702     MEM    : S3;        // any mem
 4703 %}
 4704 
 4705 // UnConditional branch
 4706 pipe_class pipe_jmp(label labl)
 4707 %{
 4708     single_instruction;
 4709     BR   : S3;
 4710 %}
 4711 
 4712 // Conditional branch
 4713 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4714 %{
 4715     single_instruction;
 4716     cr    : S1(read);
 4717     BR    : S3;
 4718 %}
 4719 
 4720 // Allocation idiom
 4721 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4722 %{
 4723     instruction_count(1); force_serialization;
 4724     fixed_latency(6);
 4725     heap_ptr : S3(read);
 4726     DECODE   : S0(3);
 4727     D0       : S2;
 4728     MEM      : S3;
 4729     ALU      : S3(2);
 4730     dst      : S5(write);
 4731     BR       : S5;
 4732 %}
 4733 
 4734 // Generic big/slow expanded idiom
 4735 pipe_class pipe_slow()
 4736 %{
 4737     instruction_count(10); multiple_bundles; force_serialization;
 4738     fixed_latency(100);
 4739     D0  : S0(2);
 4740     MEM : S3(2);
 4741 %}
 4742 
 4743 // The real do-nothing guy
 4744 pipe_class empty()
 4745 %{
 4746     instruction_count(0);
 4747 %}
 4748 
 4749 // Define the class for the Nop node
 4750 define
 4751 %{
 4752    MachNop = empty;
 4753 %}
 4754 
 4755 %}
 4756 
 4757 //----------INSTRUCTIONS-------------------------------------------------------
 4758 //
 4759 // match      -- States which machine-independent subtree may be replaced
 4760 //               by this instruction.
 4761 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4762 //               selection to identify a minimum cost tree of machine
 4763 //               instructions that matches a tree of machine-independent
 4764 //               instructions.
 4765 // format     -- A string providing the disassembly for this instruction.
 4766 //               The value of an instruction&#39;s operand may be inserted
 4767 //               by referring to it with a &#39;$&#39; prefix.
 4768 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4769 //               to within an encode class as $primary, $secondary, and $tertiary
 4770 //               rrspectively.  The primary opcode is commonly used to
 4771 //               indicate the type of machine instruction, while secondary
 4772 //               and tertiary are often used for prefix options or addressing
 4773 //               modes.
 4774 // ins_encode -- A list of encode classes with parameters. The encode class
 4775 //               name must have been defined in an &#39;enc_class&#39; specification
 4776 //               in the encode section of the architecture description.
 4777 
 4778 
 4779 //----------Load/Store/Move Instructions---------------------------------------
 4780 //----------Load Instructions--------------------------------------------------
 4781 
 4782 // Load Byte (8 bit signed)
 4783 instruct loadB(rRegI dst, memory mem)
 4784 %{
 4785   match(Set dst (LoadB mem));
 4786 
 4787   ins_cost(125);
 4788   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4789 
 4790   ins_encode %{
 4791     __ movsbl($dst$$Register, $mem$$Address);
 4792   %}
 4793 
 4794   ins_pipe(ialu_reg_mem);
 4795 %}
 4796 
 4797 // Load Byte (8 bit signed) into Long Register
 4798 instruct loadB2L(rRegL dst, memory mem)
 4799 %{
 4800   match(Set dst (ConvI2L (LoadB mem)));
 4801 
 4802   ins_cost(125);
 4803   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4804 
 4805   ins_encode %{
 4806     __ movsbq($dst$$Register, $mem$$Address);
 4807   %}
 4808 
 4809   ins_pipe(ialu_reg_mem);
 4810 %}
 4811 
 4812 // Load Unsigned Byte (8 bit UNsigned)
 4813 instruct loadUB(rRegI dst, memory mem)
 4814 %{
 4815   match(Set dst (LoadUB mem));
 4816 
 4817   ins_cost(125);
 4818   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4819 
 4820   ins_encode %{
 4821     __ movzbl($dst$$Register, $mem$$Address);
 4822   %}
 4823 
 4824   ins_pipe(ialu_reg_mem);
 4825 %}
 4826 
 4827 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4828 instruct loadUB2L(rRegL dst, memory mem)
 4829 %{
 4830   match(Set dst (ConvI2L (LoadUB mem)));
 4831 
 4832   ins_cost(125);
 4833   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4834 
 4835   ins_encode %{
 4836     __ movzbq($dst$$Register, $mem$$Address);
 4837   %}
 4838 
 4839   ins_pipe(ialu_reg_mem);
 4840 %}
 4841 
 4842 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4843 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4844   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4845   effect(KILL cr);
 4846 
 4847   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4848             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4849   ins_encode %{
 4850     Register Rdst = $dst$$Register;
 4851     __ movzbq(Rdst, $mem$$Address);
 4852     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4853   %}
 4854   ins_pipe(ialu_reg_mem);
 4855 %}
 4856 
 4857 // Load Short (16 bit signed)
 4858 instruct loadS(rRegI dst, memory mem)
 4859 %{
 4860   match(Set dst (LoadS mem));
 4861 
 4862   ins_cost(125);
 4863   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4864 
 4865   ins_encode %{
 4866     __ movswl($dst$$Register, $mem$$Address);
 4867   %}
 4868 
 4869   ins_pipe(ialu_reg_mem);
 4870 %}
 4871 
 4872 // Load Short (16 bit signed) to Byte (8 bit signed)
 4873 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4874   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4875 
 4876   ins_cost(125);
 4877   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4878   ins_encode %{
 4879     __ movsbl($dst$$Register, $mem$$Address);
 4880   %}
 4881   ins_pipe(ialu_reg_mem);
 4882 %}
 4883 
 4884 // Load Short (16 bit signed) into Long Register
 4885 instruct loadS2L(rRegL dst, memory mem)
 4886 %{
 4887   match(Set dst (ConvI2L (LoadS mem)));
 4888 
 4889   ins_cost(125);
 4890   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4891 
 4892   ins_encode %{
 4893     __ movswq($dst$$Register, $mem$$Address);
 4894   %}
 4895 
 4896   ins_pipe(ialu_reg_mem);
 4897 %}
 4898 
 4899 // Load Unsigned Short/Char (16 bit UNsigned)
 4900 instruct loadUS(rRegI dst, memory mem)
 4901 %{
 4902   match(Set dst (LoadUS mem));
 4903 
 4904   ins_cost(125);
 4905   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4906 
 4907   ins_encode %{
 4908     __ movzwl($dst$$Register, $mem$$Address);
 4909   %}
 4910 
 4911   ins_pipe(ialu_reg_mem);
 4912 %}
 4913 
 4914 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4915 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4916   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4917 
 4918   ins_cost(125);
 4919   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4920   ins_encode %{
 4921     __ movsbl($dst$$Register, $mem$$Address);
 4922   %}
 4923   ins_pipe(ialu_reg_mem);
 4924 %}
 4925 
 4926 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4927 instruct loadUS2L(rRegL dst, memory mem)
 4928 %{
 4929   match(Set dst (ConvI2L (LoadUS mem)));
 4930 
 4931   ins_cost(125);
 4932   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4933 
 4934   ins_encode %{
 4935     __ movzwq($dst$$Register, $mem$$Address);
 4936   %}
 4937 
 4938   ins_pipe(ialu_reg_mem);
 4939 %}
 4940 
 4941 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4942 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4943   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4944 
 4945   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4946   ins_encode %{
 4947     __ movzbq($dst$$Register, $mem$$Address);
 4948   %}
 4949   ins_pipe(ialu_reg_mem);
 4950 %}
 4951 
 4952 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4953 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4954   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4955   effect(KILL cr);
 4956 
 4957   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4958             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4959   ins_encode %{
 4960     Register Rdst = $dst$$Register;
 4961     __ movzwq(Rdst, $mem$$Address);
 4962     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4963   %}
 4964   ins_pipe(ialu_reg_mem);
 4965 %}
 4966 
 4967 // Load Integer
 4968 instruct loadI(rRegI dst, memory mem)
 4969 %{
 4970   match(Set dst (LoadI mem));
 4971 
 4972   ins_cost(125);
 4973   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4974 
 4975   ins_encode %{
 4976     __ movl($dst$$Register, $mem$$Address);
 4977   %}
 4978 
 4979   ins_pipe(ialu_reg_mem);
 4980 %}
 4981 
 4982 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4983 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4984   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4985 
 4986   ins_cost(125);
 4987   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4988   ins_encode %{
 4989     __ movsbl($dst$$Register, $mem$$Address);
 4990   %}
 4991   ins_pipe(ialu_reg_mem);
 4992 %}
 4993 
 4994 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4995 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4996   match(Set dst (AndI (LoadI mem) mask));
 4997 
 4998   ins_cost(125);
 4999   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 5000   ins_encode %{
 5001     __ movzbl($dst$$Register, $mem$$Address);
 5002   %}
 5003   ins_pipe(ialu_reg_mem);
 5004 %}
 5005 
 5006 // Load Integer (32 bit signed) to Short (16 bit signed)
 5007 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 5008   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5009 
 5010   ins_cost(125);
 5011   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 5012   ins_encode %{
 5013     __ movswl($dst$$Register, $mem$$Address);
 5014   %}
 5015   ins_pipe(ialu_reg_mem);
 5016 %}
 5017 
 5018 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 5019 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 5020   match(Set dst (AndI (LoadI mem) mask));
 5021 
 5022   ins_cost(125);
 5023   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 5024   ins_encode %{
 5025     __ movzwl($dst$$Register, $mem$$Address);
 5026   %}
 5027   ins_pipe(ialu_reg_mem);
 5028 %}
 5029 
 5030 // Load Integer into Long Register
 5031 instruct loadI2L(rRegL dst, memory mem)
 5032 %{
 5033   match(Set dst (ConvI2L (LoadI mem)));
 5034 
 5035   ins_cost(125);
 5036   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 5037 
 5038   ins_encode %{
 5039     __ movslq($dst$$Register, $mem$$Address);
 5040   %}
 5041 
 5042   ins_pipe(ialu_reg_mem);
 5043 %}
 5044 
 5045 // Load Integer with mask 0xFF into Long Register
 5046 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5047   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5048 
 5049   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5050   ins_encode %{
 5051     __ movzbq($dst$$Register, $mem$$Address);
 5052   %}
 5053   ins_pipe(ialu_reg_mem);
 5054 %}
 5055 
 5056 // Load Integer with mask 0xFFFF into Long Register
 5057 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5058   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5059 
 5060   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5061   ins_encode %{
 5062     __ movzwq($dst$$Register, $mem$$Address);
 5063   %}
 5064   ins_pipe(ialu_reg_mem);
 5065 %}
 5066 
 5067 // Load Integer with a 31-bit mask into Long Register
 5068 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5069   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5070   effect(KILL cr);
 5071 
 5072   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5073             &quot;andl    $dst, $mask&quot; %}
 5074   ins_encode %{
 5075     Register Rdst = $dst$$Register;
 5076     __ movl(Rdst, $mem$$Address);
 5077     __ andl(Rdst, $mask$$constant);
 5078   %}
 5079   ins_pipe(ialu_reg_mem);
 5080 %}
 5081 
 5082 // Load Unsigned Integer into Long Register
 5083 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5084 %{
 5085   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5086 
 5087   ins_cost(125);
 5088   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5089 
 5090   ins_encode %{
 5091     __ movl($dst$$Register, $mem$$Address);
 5092   %}
 5093 
 5094   ins_pipe(ialu_reg_mem);
 5095 %}
 5096 
 5097 // Load Long
 5098 instruct loadL(rRegL dst, memory mem)
 5099 %{
 5100   match(Set dst (LoadL mem));
 5101 
 5102   ins_cost(125);
 5103   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5104 
 5105   ins_encode %{
 5106     __ movq($dst$$Register, $mem$$Address);
 5107   %}
 5108 
 5109   ins_pipe(ialu_reg_mem); // XXX
 5110 %}
 5111 
 5112 // Load Range
 5113 instruct loadRange(rRegI dst, memory mem)
 5114 %{
 5115   match(Set dst (LoadRange mem));
 5116 
 5117   ins_cost(125); // XXX
 5118   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5119   opcode(0x8B);
 5120   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5121   ins_pipe(ialu_reg_mem);
 5122 %}
 5123 
 5124 // Load Pointer
 5125 instruct loadP(rRegP dst, memory mem)
 5126 %{
 5127   match(Set dst (LoadP mem));
 5128   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5129 
 5130   ins_cost(125); // XXX
 5131   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5132   opcode(0x8B);
 5133   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5134   ins_pipe(ialu_reg_mem); // XXX
 5135 %}
 5136 
 5137 // Load Compressed Pointer
 5138 instruct loadN(rRegN dst, memory mem)
 5139 %{
 5140    match(Set dst (LoadN mem));
 5141 
 5142    ins_cost(125); // XXX
 5143    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5144    ins_encode %{
 5145      __ movl($dst$$Register, $mem$$Address);
 5146    %}
 5147    ins_pipe(ialu_reg_mem); // XXX
 5148 %}
 5149 
 5150 
 5151 // Load Klass Pointer
 5152 instruct loadKlass(rRegP dst, memory mem)
 5153 %{
 5154   match(Set dst (LoadKlass mem));
 5155 
 5156   ins_cost(125); // XXX
 5157   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5158   opcode(0x8B);
 5159   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5160   ins_pipe(ialu_reg_mem); // XXX
 5161 %}
 5162 
 5163 // Load narrow Klass Pointer
 5164 instruct loadNKlass(rRegN dst, memory mem)
 5165 %{
 5166   match(Set dst (LoadNKlass mem));
 5167 
 5168   ins_cost(125); // XXX
 5169   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5170   ins_encode %{
 5171     __ movl($dst$$Register, $mem$$Address);
 5172   %}
 5173   ins_pipe(ialu_reg_mem); // XXX
 5174 %}
 5175 
 5176 // Load Float
 5177 instruct loadF(regF dst, memory mem)
 5178 %{
 5179   match(Set dst (LoadF mem));
 5180 
 5181   ins_cost(145); // XXX
 5182   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5183   ins_encode %{
 5184     __ movflt($dst$$XMMRegister, $mem$$Address);
 5185   %}
 5186   ins_pipe(pipe_slow); // XXX
 5187 %}
 5188 
 5189 // Load Float
 5190 instruct MoveF2VL(vlRegF dst, regF src) %{
 5191   match(Set dst src);
 5192   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5193   ins_encode %{
 5194     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5195   %}
 5196   ins_pipe( fpu_reg_reg );
 5197 %}
 5198 
 5199 // Load Float
 5200 instruct MoveF2LEG(legRegF dst, regF src) %{
 5201   match(Set dst src);
 5202   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5203   ins_encode %{
 5204     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5205   %}
 5206   ins_pipe( fpu_reg_reg );
 5207 %}
 5208 
 5209 // Load Float
 5210 instruct MoveVL2F(regF dst, vlRegF src) %{
 5211   match(Set dst src);
 5212   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5213   ins_encode %{
 5214     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5215   %}
 5216   ins_pipe( fpu_reg_reg );
 5217 %}
 5218 
 5219 // Load Float
 5220 instruct MoveLEG2F(regF dst, legRegF src) %{
 5221   match(Set dst src);
 5222   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5223   ins_encode %{
 5224     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5225   %}
 5226   ins_pipe( fpu_reg_reg );
 5227 %}
 5228 
 5229 // Load Double
 5230 instruct loadD_partial(regD dst, memory mem)
 5231 %{
 5232   predicate(!UseXmmLoadAndClearUpper);
 5233   match(Set dst (LoadD mem));
 5234 
 5235   ins_cost(145); // XXX
 5236   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5237   ins_encode %{
 5238     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5239   %}
 5240   ins_pipe(pipe_slow); // XXX
 5241 %}
 5242 
 5243 instruct loadD(regD dst, memory mem)
 5244 %{
 5245   predicate(UseXmmLoadAndClearUpper);
 5246   match(Set dst (LoadD mem));
 5247 
 5248   ins_cost(145); // XXX
 5249   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5250   ins_encode %{
 5251     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5252   %}
 5253   ins_pipe(pipe_slow); // XXX
 5254 %}
 5255 
 5256 // Load Double
 5257 instruct MoveD2VL(vlRegD dst, regD src) %{
 5258   match(Set dst src);
 5259   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5260   ins_encode %{
 5261     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5262   %}
 5263   ins_pipe( fpu_reg_reg );
 5264 %}
 5265 
 5266 // Load Double
 5267 instruct MoveD2LEG(legRegD dst, regD src) %{
 5268   match(Set dst src);
 5269   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5270   ins_encode %{
 5271     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5272   %}
 5273   ins_pipe( fpu_reg_reg );
 5274 %}
 5275 
 5276 // Load Double
 5277 instruct MoveVL2D(regD dst, vlRegD src) %{
 5278   match(Set dst src);
 5279   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5280   ins_encode %{
 5281     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5282   %}
 5283   ins_pipe( fpu_reg_reg );
 5284 %}
 5285 
 5286 // Load Double
 5287 instruct MoveLEG2D(regD dst, legRegD src) %{
 5288   match(Set dst src);
 5289   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5290   ins_encode %{
 5291     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5292   %}
 5293   ins_pipe( fpu_reg_reg );
 5294 %}
 5295 
 5296 // Following pseudo code describes the algorithm for max[FD]:
 5297 // Min algorithm is on similar lines
 5298 //  btmp = (b &lt; +0.0) ? a : b
 5299 //  atmp = (b &lt; +0.0) ? b : a
 5300 //  Tmp  = Max_Float(atmp , btmp)
 5301 //  Res  = (atmp == NaN) ? atmp : Tmp
 5302 
 5303 // max = java.lang.Math.max(float a, float b)
 5304 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5305   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5306   match(Set dst (MaxF a b));
 5307   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5308   format %{
 5309      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5310      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5311      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5312      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5313      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5314   %}
 5315   ins_encode %{
 5316     int vector_len = Assembler::AVX_128bit;
 5317     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5318     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5319     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5320     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5321     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5322  %}
 5323   ins_pipe( pipe_slow );
 5324 %}
 5325 
 5326 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5327   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5328   match(Set dst (MaxF a b));
 5329   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5330 
 5331   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5332   ins_encode %{
 5333     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5334                     false /*min*/, true /*single*/);
 5335   %}
 5336   ins_pipe( pipe_slow );
 5337 %}
 5338 
 5339 // max = java.lang.Math.max(double a, double b)
 5340 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5341   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5342   match(Set dst (MaxD a b));
 5343   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5344   format %{
 5345      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5346      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5347      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5348      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5349      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5350   %}
 5351   ins_encode %{
 5352     int vector_len = Assembler::AVX_128bit;
 5353     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5354     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5355     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5356     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5357     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5358   %}
 5359   ins_pipe( pipe_slow );
 5360 %}
 5361 
 5362 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5363   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5364   match(Set dst (MaxD a b));
 5365   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5366 
 5367   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5368   ins_encode %{
 5369     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5370                     false /*min*/, false /*single*/);
 5371   %}
 5372   ins_pipe( pipe_slow );
 5373 %}
 5374 
 5375 // min = java.lang.Math.min(float a, float b)
 5376 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5377   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5378   match(Set dst (MinF a b));
 5379   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5380   format %{
 5381      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5382      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5383      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5384      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5385      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5386   %}
 5387   ins_encode %{
 5388     int vector_len = Assembler::AVX_128bit;
 5389     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5390     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5391     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5392     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5393     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5394   %}
 5395   ins_pipe( pipe_slow );
 5396 %}
 5397 
 5398 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5399   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5400   match(Set dst (MinF a b));
 5401   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5402 
 5403   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5404   ins_encode %{
 5405     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5406                     true /*min*/, true /*single*/);
 5407   %}
 5408   ins_pipe( pipe_slow );
 5409 %}
 5410 
 5411 // min = java.lang.Math.min(double a, double b)
 5412 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5413   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5414   match(Set dst (MinD a b));
 5415   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5416   format %{
 5417      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5418      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5419      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5420      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5421      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5422   %}
 5423   ins_encode %{
 5424     int vector_len = Assembler::AVX_128bit;
 5425     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5426     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5427     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5428     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5429     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5430   %}
 5431   ins_pipe( pipe_slow );
 5432 %}
 5433 
 5434 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5435   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5436   match(Set dst (MinD a b));
 5437   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5438 
 5439   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5440   ins_encode %{
 5441     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5442                     true /*min*/, false /*single*/);
 5443   %}
 5444   ins_pipe( pipe_slow );
 5445 %}
 5446 
 5447 // Load Effective Address
 5448 instruct leaP8(rRegP dst, indOffset8 mem)
 5449 %{
 5450   match(Set dst mem);
 5451 
 5452   ins_cost(110); // XXX
 5453   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5454   opcode(0x8D);
 5455   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5456   ins_pipe(ialu_reg_reg_fat);
 5457 %}
 5458 
 5459 instruct leaP32(rRegP dst, indOffset32 mem)
 5460 %{
 5461   match(Set dst mem);
 5462 
 5463   ins_cost(110);
 5464   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5465   opcode(0x8D);
 5466   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5467   ins_pipe(ialu_reg_reg_fat);
 5468 %}
 5469 
 5470 // instruct leaPIdx(rRegP dst, indIndex mem)
 5471 // %{
 5472 //   match(Set dst mem);
 5473 
 5474 //   ins_cost(110);
 5475 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5476 //   opcode(0x8D);
 5477 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5478 //   ins_pipe(ialu_reg_reg_fat);
 5479 // %}
 5480 
 5481 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5482 %{
 5483   match(Set dst mem);
 5484 
 5485   ins_cost(110);
 5486   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5487   opcode(0x8D);
 5488   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5489   ins_pipe(ialu_reg_reg_fat);
 5490 %}
 5491 
 5492 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5493 %{
 5494   match(Set dst mem);
 5495 
 5496   ins_cost(110);
 5497   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5498   opcode(0x8D);
 5499   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5500   ins_pipe(ialu_reg_reg_fat);
 5501 %}
 5502 
 5503 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5504 %{
 5505   match(Set dst mem);
 5506 
 5507   ins_cost(110);
 5508   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5509   opcode(0x8D);
 5510   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5511   ins_pipe(ialu_reg_reg_fat);
 5512 %}
 5513 
 5514 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5515 %{
 5516   match(Set dst mem);
 5517 
 5518   ins_cost(110);
 5519   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5520   opcode(0x8D);
 5521   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5522   ins_pipe(ialu_reg_reg_fat);
 5523 %}
 5524 
 5525 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5526 %{
 5527   match(Set dst mem);
 5528 
 5529   ins_cost(110);
 5530   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5531   opcode(0x8D);
 5532   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5533   ins_pipe(ialu_reg_reg_fat);
 5534 %}
 5535 
 5536 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5537 %{
 5538   match(Set dst mem);
 5539 
 5540   ins_cost(110);
 5541   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5542   opcode(0x8D);
 5543   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5544   ins_pipe(ialu_reg_reg_fat);
 5545 %}
 5546 
 5547 // Load Effective Address which uses Narrow (32-bits) oop
 5548 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5549 %{
 5550   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5551   match(Set dst mem);
 5552 
 5553   ins_cost(110);
 5554   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5555   opcode(0x8D);
 5556   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5557   ins_pipe(ialu_reg_reg_fat);
 5558 %}
 5559 
 5560 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5561 %{
 5562   predicate(CompressedOops::shift() == 0);
 5563   match(Set dst mem);
 5564 
 5565   ins_cost(110); // XXX
 5566   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5567   opcode(0x8D);
 5568   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5569   ins_pipe(ialu_reg_reg_fat);
 5570 %}
 5571 
 5572 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5573 %{
 5574   predicate(CompressedOops::shift() == 0);
 5575   match(Set dst mem);
 5576 
 5577   ins_cost(110);
 5578   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5579   opcode(0x8D);
 5580   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5581   ins_pipe(ialu_reg_reg_fat);
 5582 %}
 5583 
 5584 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5585 %{
 5586   predicate(CompressedOops::shift() == 0);
 5587   match(Set dst mem);
 5588 
 5589   ins_cost(110);
 5590   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5591   opcode(0x8D);
 5592   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5593   ins_pipe(ialu_reg_reg_fat);
 5594 %}
 5595 
 5596 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5597 %{
 5598   predicate(CompressedOops::shift() == 0);
 5599   match(Set dst mem);
 5600 
 5601   ins_cost(110);
 5602   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5603   opcode(0x8D);
 5604   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5605   ins_pipe(ialu_reg_reg_fat);
 5606 %}
 5607 
 5608 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5609 %{
 5610   predicate(CompressedOops::shift() == 0);
 5611   match(Set dst mem);
 5612 
 5613   ins_cost(110);
 5614   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5615   opcode(0x8D);
 5616   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5617   ins_pipe(ialu_reg_reg_fat);
 5618 %}
 5619 
 5620 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5621 %{
 5622   predicate(CompressedOops::shift() == 0);
 5623   match(Set dst mem);
 5624 
 5625   ins_cost(110);
 5626   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5627   opcode(0x8D);
 5628   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5629   ins_pipe(ialu_reg_reg_fat);
 5630 %}
 5631 
 5632 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5633 %{
 5634   predicate(CompressedOops::shift() == 0);
 5635   match(Set dst mem);
 5636 
 5637   ins_cost(110);
 5638   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5639   opcode(0x8D);
 5640   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5641   ins_pipe(ialu_reg_reg_fat);
 5642 %}
 5643 
 5644 instruct loadConI(rRegI dst, immI src)
 5645 %{
 5646   match(Set dst src);
 5647 
 5648   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5649   ins_encode(load_immI(dst, src));
 5650   ins_pipe(ialu_reg_fat); // XXX
 5651 %}
 5652 
 5653 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5654 %{
 5655   match(Set dst src);
 5656   effect(KILL cr);
 5657 
 5658   ins_cost(50);
 5659   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5660   opcode(0x33); /* + rd */
 5661   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5662   ins_pipe(ialu_reg);
 5663 %}
 5664 
 5665 instruct loadConL(rRegL dst, immL src)
 5666 %{
 5667   match(Set dst src);
 5668 
 5669   ins_cost(150);
 5670   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5671   ins_encode(load_immL(dst, src));
 5672   ins_pipe(ialu_reg);
 5673 %}
 5674 
 5675 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5676 %{
 5677   match(Set dst src);
 5678   effect(KILL cr);
 5679 
 5680   ins_cost(50);
 5681   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5682   opcode(0x33); /* + rd */
 5683   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5684   ins_pipe(ialu_reg); // XXX
 5685 %}
 5686 
 5687 instruct loadConUL32(rRegL dst, immUL32 src)
 5688 %{
 5689   match(Set dst src);
 5690 
 5691   ins_cost(60);
 5692   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5693   ins_encode(load_immUL32(dst, src));
 5694   ins_pipe(ialu_reg);
 5695 %}
 5696 
 5697 instruct loadConL32(rRegL dst, immL32 src)
 5698 %{
 5699   match(Set dst src);
 5700 
 5701   ins_cost(70);
 5702   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5703   ins_encode(load_immL32(dst, src));
 5704   ins_pipe(ialu_reg);
 5705 %}
 5706 
 5707 instruct loadConP(rRegP dst, immP con) %{
 5708   match(Set dst con);
 5709 
 5710   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5711   ins_encode(load_immP(dst, con));
 5712   ins_pipe(ialu_reg_fat); // XXX
 5713 %}
 5714 
 5715 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5716 %{
 5717   match(Set dst src);
 5718   effect(KILL cr);
 5719 
 5720   ins_cost(50);
 5721   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5722   opcode(0x33); /* + rd */
 5723   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5724   ins_pipe(ialu_reg);
 5725 %}
 5726 
 5727 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5728 %{
 5729   match(Set dst src);
 5730   effect(KILL cr);
 5731 
 5732   ins_cost(60);
 5733   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5734   ins_encode(load_immP31(dst, src));
 5735   ins_pipe(ialu_reg);
 5736 %}
 5737 
 5738 instruct loadConF(regF dst, immF con) %{
 5739   match(Set dst con);
 5740   ins_cost(125);
 5741   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5742   ins_encode %{
 5743     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5744   %}
 5745   ins_pipe(pipe_slow);
 5746 %}
 5747 
 5748 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5749   match(Set dst src);
 5750   effect(KILL cr);
 5751   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5752   ins_encode %{
 5753     __ xorq($dst$$Register, $dst$$Register);
 5754   %}
 5755   ins_pipe(ialu_reg);
 5756 %}
 5757 
 5758 instruct loadConN(rRegN dst, immN src) %{
 5759   match(Set dst src);
 5760 
 5761   ins_cost(125);
 5762   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5763   ins_encode %{
 5764     address con = (address)$src$$constant;
 5765     if (con == NULL) {
 5766       ShouldNotReachHere();
 5767     } else {
 5768       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5769     }
 5770   %}
 5771   ins_pipe(ialu_reg_fat); // XXX
 5772 %}
 5773 
 5774 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5775   match(Set dst src);
 5776 
 5777   ins_cost(125);
 5778   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5779   ins_encode %{
 5780     address con = (address)$src$$constant;
 5781     if (con == NULL) {
 5782       ShouldNotReachHere();
 5783     } else {
 5784       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5785     }
 5786   %}
 5787   ins_pipe(ialu_reg_fat); // XXX
 5788 %}
 5789 
 5790 instruct loadConF0(regF dst, immF0 src)
 5791 %{
 5792   match(Set dst src);
 5793   ins_cost(100);
 5794 
 5795   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5796   ins_encode %{
 5797     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5798   %}
 5799   ins_pipe(pipe_slow);
 5800 %}
 5801 
 5802 // Use the same format since predicate() can not be used here.
 5803 instruct loadConD(regD dst, immD con) %{
 5804   match(Set dst con);
 5805   ins_cost(125);
 5806   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5807   ins_encode %{
 5808     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5809   %}
 5810   ins_pipe(pipe_slow);
 5811 %}
 5812 
 5813 instruct loadConD0(regD dst, immD0 src)
 5814 %{
 5815   match(Set dst src);
 5816   ins_cost(100);
 5817 
 5818   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5819   ins_encode %{
 5820     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5821   %}
 5822   ins_pipe(pipe_slow);
 5823 %}
 5824 
 5825 instruct loadSSI(rRegI dst, stackSlotI src)
 5826 %{
 5827   match(Set dst src);
 5828 
 5829   ins_cost(125);
 5830   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5831   opcode(0x8B);
 5832   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5833   ins_pipe(ialu_reg_mem);
 5834 %}
 5835 
 5836 instruct loadSSL(rRegL dst, stackSlotL src)
 5837 %{
 5838   match(Set dst src);
 5839 
 5840   ins_cost(125);
 5841   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5842   opcode(0x8B);
 5843   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5844   ins_pipe(ialu_reg_mem);
 5845 %}
 5846 
 5847 instruct loadSSP(rRegP dst, stackSlotP src)
 5848 %{
 5849   match(Set dst src);
 5850 
 5851   ins_cost(125);
 5852   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5853   opcode(0x8B);
 5854   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5855   ins_pipe(ialu_reg_mem);
 5856 %}
 5857 
 5858 instruct loadSSF(regF dst, stackSlotF src)
 5859 %{
 5860   match(Set dst src);
 5861 
 5862   ins_cost(125);
 5863   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5864   ins_encode %{
 5865     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5866   %}
 5867   ins_pipe(pipe_slow); // XXX
 5868 %}
 5869 
 5870 // Use the same format since predicate() can not be used here.
 5871 instruct loadSSD(regD dst, stackSlotD src)
 5872 %{
 5873   match(Set dst src);
 5874 
 5875   ins_cost(125);
 5876   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5877   ins_encode  %{
 5878     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5879   %}
 5880   ins_pipe(pipe_slow); // XXX
 5881 %}
 5882 
 5883 // Prefetch instructions for allocation.
 5884 // Must be safe to execute with invalid address (cannot fault).
 5885 
 5886 instruct prefetchAlloc( memory mem ) %{
 5887   predicate(AllocatePrefetchInstr==3);
 5888   match(PrefetchAllocation mem);
 5889   ins_cost(125);
 5890 
 5891   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5892   ins_encode %{
 5893     __ prefetchw($mem$$Address);
 5894   %}
 5895   ins_pipe(ialu_mem);
 5896 %}
 5897 
 5898 instruct prefetchAllocNTA( memory mem ) %{
 5899   predicate(AllocatePrefetchInstr==0);
 5900   match(PrefetchAllocation mem);
 5901   ins_cost(125);
 5902 
 5903   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5904   ins_encode %{
 5905     __ prefetchnta($mem$$Address);
 5906   %}
 5907   ins_pipe(ialu_mem);
 5908 %}
 5909 
 5910 instruct prefetchAllocT0( memory mem ) %{
 5911   predicate(AllocatePrefetchInstr==1);
 5912   match(PrefetchAllocation mem);
 5913   ins_cost(125);
 5914 
 5915   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5916   ins_encode %{
 5917     __ prefetcht0($mem$$Address);
 5918   %}
 5919   ins_pipe(ialu_mem);
 5920 %}
 5921 
 5922 instruct prefetchAllocT2( memory mem ) %{
 5923   predicate(AllocatePrefetchInstr==2);
 5924   match(PrefetchAllocation mem);
 5925   ins_cost(125);
 5926 
 5927   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5928   ins_encode %{
 5929     __ prefetcht2($mem$$Address);
 5930   %}
 5931   ins_pipe(ialu_mem);
 5932 %}
 5933 
 5934 //----------Store Instructions-------------------------------------------------
 5935 
 5936 // Store Byte
 5937 instruct storeB(memory mem, rRegI src)
 5938 %{
 5939   match(Set mem (StoreB mem src));
 5940 
 5941   ins_cost(125); // XXX
 5942   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5943   opcode(0x88);
 5944   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5945   ins_pipe(ialu_mem_reg);
 5946 %}
 5947 
 5948 // Store Char/Short
 5949 instruct storeC(memory mem, rRegI src)
 5950 %{
 5951   match(Set mem (StoreC mem src));
 5952 
 5953   ins_cost(125); // XXX
 5954   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5955   opcode(0x89);
 5956   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5957   ins_pipe(ialu_mem_reg);
 5958 %}
 5959 
 5960 // Store Integer
 5961 instruct storeI(memory mem, rRegI src)
 5962 %{
 5963   match(Set mem (StoreI mem src));
 5964 
 5965   ins_cost(125); // XXX
 5966   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5967   opcode(0x89);
 5968   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5969   ins_pipe(ialu_mem_reg);
 5970 %}
 5971 
 5972 // Store Long
 5973 instruct storeL(memory mem, rRegL src)
 5974 %{
 5975   match(Set mem (StoreL mem src));
 5976 
 5977   ins_cost(125); // XXX
 5978   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5979   opcode(0x89);
 5980   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5981   ins_pipe(ialu_mem_reg); // XXX
 5982 %}
 5983 
 5984 // Store Pointer
 5985 instruct storeP(memory mem, any_RegP src)
 5986 %{
 5987   match(Set mem (StoreP mem src));
 5988 
 5989   ins_cost(125); // XXX
 5990   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5991   opcode(0x89);
 5992   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5993   ins_pipe(ialu_mem_reg);
 5994 %}
 5995 
 5996 instruct storeImmP0(memory mem, immP0 zero)
 5997 %{
 5998   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 5999   match(Set mem (StoreP mem zero));
 6000 
 6001   ins_cost(125); // XXX
 6002   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 6003   ins_encode %{
 6004     __ movq($mem$$Address, r12);
 6005   %}
 6006   ins_pipe(ialu_mem_reg);
 6007 %}
 6008 
 6009 // Store NULL Pointer, mark word, or other simple pointer constant.
 6010 instruct storeImmP(memory mem, immP31 src)
 6011 %{
 6012   match(Set mem (StoreP mem src));
 6013 
 6014   ins_cost(150); // XXX
 6015   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 6016   opcode(0xC7); /* C7 /0 */
 6017   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6018   ins_pipe(ialu_mem_imm);
 6019 %}
 6020 
 6021 // Store Compressed Pointer
 6022 instruct storeN(memory mem, rRegN src)
 6023 %{
 6024   match(Set mem (StoreN mem src));
 6025 
 6026   ins_cost(125); // XXX
 6027   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6028   ins_encode %{
 6029     __ movl($mem$$Address, $src$$Register);
 6030   %}
 6031   ins_pipe(ialu_mem_reg);
 6032 %}
 6033 
 6034 instruct storeNKlass(memory mem, rRegN src)
 6035 %{
 6036   match(Set mem (StoreNKlass mem src));
 6037 
 6038   ins_cost(125); // XXX
 6039   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6040   ins_encode %{
 6041     __ movl($mem$$Address, $src$$Register);
 6042   %}
 6043   ins_pipe(ialu_mem_reg);
 6044 %}
 6045 
 6046 instruct storeImmN0(memory mem, immN0 zero)
 6047 %{
 6048   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);
 6049   match(Set mem (StoreN mem zero));
 6050 
 6051   ins_cost(125); // XXX
 6052   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6053   ins_encode %{
 6054     __ movl($mem$$Address, r12);
 6055   %}
 6056   ins_pipe(ialu_mem_reg);
 6057 %}
 6058 
 6059 instruct storeImmN(memory mem, immN src)
 6060 %{
 6061   match(Set mem (StoreN mem src));
 6062 
 6063   ins_cost(150); // XXX
 6064   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6065   ins_encode %{
 6066     address con = (address)$src$$constant;
 6067     if (con == NULL) {
 6068       __ movl($mem$$Address, (int32_t)0);
 6069     } else {
 6070       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6071     }
 6072   %}
 6073   ins_pipe(ialu_mem_imm);
 6074 %}
 6075 
 6076 instruct storeImmNKlass(memory mem, immNKlass src)
 6077 %{
 6078   match(Set mem (StoreNKlass mem src));
 6079 
 6080   ins_cost(150); // XXX
 6081   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6082   ins_encode %{
 6083     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6084   %}
 6085   ins_pipe(ialu_mem_imm);
 6086 %}
 6087 
 6088 // Store Integer Immediate
 6089 instruct storeImmI0(memory mem, immI0 zero)
 6090 %{
 6091   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6092   match(Set mem (StoreI mem zero));
 6093 
 6094   ins_cost(125); // XXX
 6095   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6096   ins_encode %{
 6097     __ movl($mem$$Address, r12);
 6098   %}
 6099   ins_pipe(ialu_mem_reg);
 6100 %}
 6101 
 6102 instruct storeImmI(memory mem, immI src)
 6103 %{
 6104   match(Set mem (StoreI mem src));
 6105 
 6106   ins_cost(150);
 6107   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6108   opcode(0xC7); /* C7 /0 */
 6109   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6110   ins_pipe(ialu_mem_imm);
 6111 %}
 6112 
 6113 // Store Long Immediate
 6114 instruct storeImmL0(memory mem, immL0 zero)
 6115 %{
 6116   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6117   match(Set mem (StoreL mem zero));
 6118 
 6119   ins_cost(125); // XXX
 6120   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6121   ins_encode %{
 6122     __ movq($mem$$Address, r12);
 6123   %}
 6124   ins_pipe(ialu_mem_reg);
 6125 %}
 6126 
 6127 instruct storeImmL(memory mem, immL32 src)
 6128 %{
 6129   match(Set mem (StoreL mem src));
 6130 
 6131   ins_cost(150);
 6132   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6133   opcode(0xC7); /* C7 /0 */
 6134   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6135   ins_pipe(ialu_mem_imm);
 6136 %}
 6137 
 6138 // Store Short/Char Immediate
 6139 instruct storeImmC0(memory mem, immI0 zero)
 6140 %{
 6141   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6142   match(Set mem (StoreC mem zero));
 6143 
 6144   ins_cost(125); // XXX
 6145   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6146   ins_encode %{
 6147     __ movw($mem$$Address, r12);
 6148   %}
 6149   ins_pipe(ialu_mem_reg);
 6150 %}
 6151 
 6152 instruct storeImmI16(memory mem, immI16 src)
 6153 %{
 6154   predicate(UseStoreImmI16);
 6155   match(Set mem (StoreC mem src));
 6156 
 6157   ins_cost(150);
 6158   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6159   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6160   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6161   ins_pipe(ialu_mem_imm);
 6162 %}
 6163 
 6164 // Store Byte Immediate
 6165 instruct storeImmB0(memory mem, immI0 zero)
 6166 %{
 6167   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6168   match(Set mem (StoreB mem zero));
 6169 
 6170   ins_cost(125); // XXX
 6171   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6172   ins_encode %{
 6173     __ movb($mem$$Address, r12);
 6174   %}
 6175   ins_pipe(ialu_mem_reg);
 6176 %}
 6177 
 6178 instruct storeImmB(memory mem, immI8 src)
 6179 %{
 6180   match(Set mem (StoreB mem src));
 6181 
 6182   ins_cost(150); // XXX
 6183   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6184   opcode(0xC6); /* C6 /0 */
 6185   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6186   ins_pipe(ialu_mem_imm);
 6187 %}
 6188 
 6189 // Store CMS card-mark Immediate
 6190 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6191 %{
 6192   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6193   match(Set mem (StoreCM mem zero));
 6194 
 6195   ins_cost(125); // XXX
 6196   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6197   ins_encode %{
 6198     __ movb($mem$$Address, r12);
 6199   %}
 6200   ins_pipe(ialu_mem_reg);
 6201 %}
 6202 
 6203 instruct storeImmCM0(memory mem, immI0 src)
 6204 %{
 6205   match(Set mem (StoreCM mem src));
 6206 
 6207   ins_cost(150); // XXX
 6208   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6209   opcode(0xC6); /* C6 /0 */
 6210   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6211   ins_pipe(ialu_mem_imm);
 6212 %}
 6213 
 6214 // Store Float
 6215 instruct storeF(memory mem, regF src)
 6216 %{
 6217   match(Set mem (StoreF mem src));
 6218 
 6219   ins_cost(95); // XXX
 6220   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6221   ins_encode %{
 6222     __ movflt($mem$$Address, $src$$XMMRegister);
 6223   %}
 6224   ins_pipe(pipe_slow); // XXX
 6225 %}
 6226 
 6227 // Store immediate Float value (it is faster than store from XMM register)
 6228 instruct storeF0(memory mem, immF0 zero)
 6229 %{
 6230   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6231   match(Set mem (StoreF mem zero));
 6232 
 6233   ins_cost(25); // XXX
 6234   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6235   ins_encode %{
 6236     __ movl($mem$$Address, r12);
 6237   %}
 6238   ins_pipe(ialu_mem_reg);
 6239 %}
 6240 
 6241 instruct storeF_imm(memory mem, immF src)
 6242 %{
 6243   match(Set mem (StoreF mem src));
 6244 
 6245   ins_cost(50);
 6246   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6247   opcode(0xC7); /* C7 /0 */
 6248   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6249   ins_pipe(ialu_mem_imm);
 6250 %}
 6251 
 6252 // Store Double
 6253 instruct storeD(memory mem, regD src)
 6254 %{
 6255   match(Set mem (StoreD mem src));
 6256 
 6257   ins_cost(95); // XXX
 6258   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6259   ins_encode %{
 6260     __ movdbl($mem$$Address, $src$$XMMRegister);
 6261   %}
 6262   ins_pipe(pipe_slow); // XXX
 6263 %}
 6264 
 6265 // Store immediate double 0.0 (it is faster than store from XMM register)
 6266 instruct storeD0_imm(memory mem, immD0 src)
 6267 %{
 6268   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6269   match(Set mem (StoreD mem src));
 6270 
 6271   ins_cost(50);
 6272   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6273   opcode(0xC7); /* C7 /0 */
 6274   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6275   ins_pipe(ialu_mem_imm);
 6276 %}
 6277 
 6278 instruct storeD0(memory mem, immD0 zero)
 6279 %{
 6280   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6281   match(Set mem (StoreD mem zero));
 6282 
 6283   ins_cost(25); // XXX
 6284   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6285   ins_encode %{
 6286     __ movq($mem$$Address, r12);
 6287   %}
 6288   ins_pipe(ialu_mem_reg);
 6289 %}
 6290 
 6291 instruct storeSSI(stackSlotI dst, rRegI src)
 6292 %{
 6293   match(Set dst src);
 6294 
 6295   ins_cost(100);
 6296   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6297   opcode(0x89);
 6298   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6299   ins_pipe( ialu_mem_reg );
 6300 %}
 6301 
 6302 instruct storeSSL(stackSlotL dst, rRegL src)
 6303 %{
 6304   match(Set dst src);
 6305 
 6306   ins_cost(100);
 6307   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6308   opcode(0x89);
 6309   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6310   ins_pipe(ialu_mem_reg);
 6311 %}
 6312 
 6313 instruct storeSSP(stackSlotP dst, rRegP src)
 6314 %{
 6315   match(Set dst src);
 6316 
 6317   ins_cost(100);
 6318   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6319   opcode(0x89);
 6320   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6321   ins_pipe(ialu_mem_reg);
 6322 %}
 6323 
 6324 instruct storeSSF(stackSlotF dst, regF src)
 6325 %{
 6326   match(Set dst src);
 6327 
 6328   ins_cost(95); // XXX
 6329   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6330   ins_encode %{
 6331     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6332   %}
 6333   ins_pipe(pipe_slow); // XXX
 6334 %}
 6335 
 6336 instruct storeSSD(stackSlotD dst, regD src)
 6337 %{
 6338   match(Set dst src);
 6339 
 6340   ins_cost(95); // XXX
 6341   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6342   ins_encode %{
 6343     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6344   %}
 6345   ins_pipe(pipe_slow); // XXX
 6346 %}
 6347 
 6348 instruct cacheWB(indirect addr)
 6349 %{
 6350   predicate(VM_Version::supports_data_cache_line_flush());
 6351   match(CacheWB addr);
 6352 
 6353   ins_cost(100);
 6354   format %{&quot;cache wb $addr&quot; %}
 6355   ins_encode %{
 6356     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6357     assert($addr$$disp == 0, &quot;should be&quot;);
 6358     __ cache_wb(Address($addr$$base$$Register, 0));
 6359   %}
 6360   ins_pipe(pipe_slow); // XXX
 6361 %}
 6362 
 6363 instruct cacheWBPreSync()
 6364 %{
 6365   predicate(VM_Version::supports_data_cache_line_flush());
 6366   match(CacheWBPreSync);
 6367 
 6368   ins_cost(100);
 6369   format %{&quot;cache wb presync&quot; %}
 6370   ins_encode %{
 6371     __ cache_wbsync(true);
 6372   %}
 6373   ins_pipe(pipe_slow); // XXX
 6374 %}
 6375 
 6376 instruct cacheWBPostSync()
 6377 %{
 6378   predicate(VM_Version::supports_data_cache_line_flush());
 6379   match(CacheWBPostSync);
 6380 
 6381   ins_cost(100);
 6382   format %{&quot;cache wb postsync&quot; %}
 6383   ins_encode %{
 6384     __ cache_wbsync(false);
 6385   %}
 6386   ins_pipe(pipe_slow); // XXX
 6387 %}
 6388 
 6389 //----------BSWAP Instructions-------------------------------------------------
 6390 instruct bytes_reverse_int(rRegI dst) %{
 6391   match(Set dst (ReverseBytesI dst));
 6392 
 6393   format %{ &quot;bswapl  $dst&quot; %}
 6394   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6395   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6396   ins_pipe( ialu_reg );
 6397 %}
 6398 
 6399 instruct bytes_reverse_long(rRegL dst) %{
 6400   match(Set dst (ReverseBytesL dst));
 6401 
 6402   format %{ &quot;bswapq  $dst&quot; %}
 6403   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6404   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6405   ins_pipe( ialu_reg);
 6406 %}
 6407 
 6408 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6409   match(Set dst (ReverseBytesUS dst));
 6410   effect(KILL cr);
 6411 
 6412   format %{ &quot;bswapl  $dst\n\t&quot;
 6413             &quot;shrl    $dst,16\n\t&quot; %}
 6414   ins_encode %{
 6415     __ bswapl($dst$$Register);
 6416     __ shrl($dst$$Register, 16);
 6417   %}
 6418   ins_pipe( ialu_reg );
 6419 %}
 6420 
 6421 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6422   match(Set dst (ReverseBytesS dst));
 6423   effect(KILL cr);
 6424 
 6425   format %{ &quot;bswapl  $dst\n\t&quot;
 6426             &quot;sar     $dst,16\n\t&quot; %}
 6427   ins_encode %{
 6428     __ bswapl($dst$$Register);
 6429     __ sarl($dst$$Register, 16);
 6430   %}
 6431   ins_pipe( ialu_reg );
 6432 %}
 6433 
 6434 //---------- Zeros Count Instructions ------------------------------------------
 6435 
 6436 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6437   predicate(UseCountLeadingZerosInstruction);
 6438   match(Set dst (CountLeadingZerosI src));
 6439   effect(KILL cr);
 6440 
 6441   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6442   ins_encode %{
 6443     __ lzcntl($dst$$Register, $src$$Register);
 6444   %}
 6445   ins_pipe(ialu_reg);
 6446 %}
 6447 
 6448 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6449   predicate(!UseCountLeadingZerosInstruction);
 6450   match(Set dst (CountLeadingZerosI src));
 6451   effect(KILL cr);
 6452 
 6453   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6454             &quot;jnz     skip\n\t&quot;
 6455             &quot;movl    $dst, -1\n&quot;
 6456       &quot;skip:\n\t&quot;
 6457             &quot;negl    $dst\n\t&quot;
 6458             &quot;addl    $dst, 31&quot; %}
 6459   ins_encode %{
 6460     Register Rdst = $dst$$Register;
 6461     Register Rsrc = $src$$Register;
 6462     Label skip;
 6463     __ bsrl(Rdst, Rsrc);
 6464     __ jccb(Assembler::notZero, skip);
 6465     __ movl(Rdst, -1);
 6466     __ bind(skip);
 6467     __ negl(Rdst);
 6468     __ addl(Rdst, BitsPerInt - 1);
 6469   %}
 6470   ins_pipe(ialu_reg);
 6471 %}
 6472 
 6473 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6474   predicate(UseCountLeadingZerosInstruction);
 6475   match(Set dst (CountLeadingZerosL src));
 6476   effect(KILL cr);
 6477 
 6478   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6479   ins_encode %{
 6480     __ lzcntq($dst$$Register, $src$$Register);
 6481   %}
 6482   ins_pipe(ialu_reg);
 6483 %}
 6484 
 6485 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6486   predicate(!UseCountLeadingZerosInstruction);
 6487   match(Set dst (CountLeadingZerosL src));
 6488   effect(KILL cr);
 6489 
 6490   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6491             &quot;jnz     skip\n\t&quot;
 6492             &quot;movl    $dst, -1\n&quot;
 6493       &quot;skip:\n\t&quot;
 6494             &quot;negl    $dst\n\t&quot;
 6495             &quot;addl    $dst, 63&quot; %}
 6496   ins_encode %{
 6497     Register Rdst = $dst$$Register;
 6498     Register Rsrc = $src$$Register;
 6499     Label skip;
 6500     __ bsrq(Rdst, Rsrc);
 6501     __ jccb(Assembler::notZero, skip);
 6502     __ movl(Rdst, -1);
 6503     __ bind(skip);
 6504     __ negl(Rdst);
 6505     __ addl(Rdst, BitsPerLong - 1);
 6506   %}
 6507   ins_pipe(ialu_reg);
 6508 %}
 6509 
 6510 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6511   predicate(UseCountTrailingZerosInstruction);
 6512   match(Set dst (CountTrailingZerosI src));
 6513   effect(KILL cr);
 6514 
 6515   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6516   ins_encode %{
 6517     __ tzcntl($dst$$Register, $src$$Register);
 6518   %}
 6519   ins_pipe(ialu_reg);
 6520 %}
 6521 
 6522 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6523   predicate(!UseCountTrailingZerosInstruction);
 6524   match(Set dst (CountTrailingZerosI src));
 6525   effect(KILL cr);
 6526 
 6527   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6528             &quot;jnz     done\n\t&quot;
 6529             &quot;movl    $dst, 32\n&quot;
 6530       &quot;done:&quot; %}
 6531   ins_encode %{
 6532     Register Rdst = $dst$$Register;
 6533     Label done;
 6534     __ bsfl(Rdst, $src$$Register);
 6535     __ jccb(Assembler::notZero, done);
 6536     __ movl(Rdst, BitsPerInt);
 6537     __ bind(done);
 6538   %}
 6539   ins_pipe(ialu_reg);
 6540 %}
 6541 
 6542 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6543   predicate(UseCountTrailingZerosInstruction);
 6544   match(Set dst (CountTrailingZerosL src));
 6545   effect(KILL cr);
 6546 
 6547   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6548   ins_encode %{
 6549     __ tzcntq($dst$$Register, $src$$Register);
 6550   %}
 6551   ins_pipe(ialu_reg);
 6552 %}
 6553 
 6554 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6555   predicate(!UseCountTrailingZerosInstruction);
 6556   match(Set dst (CountTrailingZerosL src));
 6557   effect(KILL cr);
 6558 
 6559   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6560             &quot;jnz     done\n\t&quot;
 6561             &quot;movl    $dst, 64\n&quot;
 6562       &quot;done:&quot; %}
 6563   ins_encode %{
 6564     Register Rdst = $dst$$Register;
 6565     Label done;
 6566     __ bsfq(Rdst, $src$$Register);
 6567     __ jccb(Assembler::notZero, done);
 6568     __ movl(Rdst, BitsPerLong);
 6569     __ bind(done);
 6570   %}
 6571   ins_pipe(ialu_reg);
 6572 %}
 6573 
 6574 
 6575 //---------- Population Count Instructions -------------------------------------
 6576 
 6577 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6578   predicate(UsePopCountInstruction);
 6579   match(Set dst (PopCountI src));
 6580   effect(KILL cr);
 6581 
 6582   format %{ &quot;popcnt  $dst, $src&quot; %}
 6583   ins_encode %{
 6584     __ popcntl($dst$$Register, $src$$Register);
 6585   %}
 6586   ins_pipe(ialu_reg);
 6587 %}
 6588 
 6589 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6590   predicate(UsePopCountInstruction);
 6591   match(Set dst (PopCountI (LoadI mem)));
 6592   effect(KILL cr);
 6593 
 6594   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6595   ins_encode %{
 6596     __ popcntl($dst$$Register, $mem$$Address);
 6597   %}
 6598   ins_pipe(ialu_reg);
 6599 %}
 6600 
 6601 // Note: Long.bitCount(long) returns an int.
 6602 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6603   predicate(UsePopCountInstruction);
 6604   match(Set dst (PopCountL src));
 6605   effect(KILL cr);
 6606 
 6607   format %{ &quot;popcnt  $dst, $src&quot; %}
 6608   ins_encode %{
 6609     __ popcntq($dst$$Register, $src$$Register);
 6610   %}
 6611   ins_pipe(ialu_reg);
 6612 %}
 6613 
 6614 // Note: Long.bitCount(long) returns an int.
 6615 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6616   predicate(UsePopCountInstruction);
 6617   match(Set dst (PopCountL (LoadL mem)));
 6618   effect(KILL cr);
 6619 
 6620   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6621   ins_encode %{
 6622     __ popcntq($dst$$Register, $mem$$Address);
 6623   %}
 6624   ins_pipe(ialu_reg);
 6625 %}
 6626 
 6627 
 6628 //----------MemBar Instructions-----------------------------------------------
 6629 // Memory barrier flavors
 6630 
 6631 instruct membar_acquire()
 6632 %{
 6633   match(MemBarAcquire);
 6634   match(LoadFence);
 6635   ins_cost(0);
 6636 
 6637   size(0);
 6638   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6639   ins_encode();
 6640   ins_pipe(empty);
 6641 %}
 6642 
 6643 instruct membar_acquire_lock()
 6644 %{
 6645   match(MemBarAcquireLock);
 6646   ins_cost(0);
 6647 
 6648   size(0);
 6649   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6650   ins_encode();
 6651   ins_pipe(empty);
 6652 %}
 6653 
 6654 instruct membar_release()
 6655 %{
 6656   match(MemBarRelease);
 6657   match(StoreFence);
 6658   ins_cost(0);
 6659 
 6660   size(0);
 6661   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6662   ins_encode();
 6663   ins_pipe(empty);
 6664 %}
 6665 
 6666 instruct membar_release_lock()
 6667 %{
 6668   match(MemBarReleaseLock);
 6669   ins_cost(0);
 6670 
 6671   size(0);
 6672   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6673   ins_encode();
 6674   ins_pipe(empty);
 6675 %}
 6676 
 6677 instruct membar_volatile(rFlagsReg cr) %{
 6678   match(MemBarVolatile);
 6679   effect(KILL cr);
 6680   ins_cost(400);
 6681 
 6682   format %{
 6683     $$template
 6684     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6685   %}
 6686   ins_encode %{
 6687     __ membar(Assembler::StoreLoad);
 6688   %}
 6689   ins_pipe(pipe_slow);
 6690 %}
 6691 
 6692 instruct unnecessary_membar_volatile()
 6693 %{
 6694   match(MemBarVolatile);
 6695   predicate(Matcher::post_store_load_barrier(n));
 6696   ins_cost(0);
 6697 
 6698   size(0);
 6699   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6700   ins_encode();
 6701   ins_pipe(empty);
 6702 %}
 6703 
 6704 instruct membar_storestore() %{
 6705   match(MemBarStoreStore);
 6706   ins_cost(0);
 6707 
 6708   size(0);
 6709   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6710   ins_encode( );
 6711   ins_pipe(empty);
 6712 %}
 6713 
 6714 //----------Move Instructions--------------------------------------------------
 6715 
 6716 instruct castX2P(rRegP dst, rRegL src)
 6717 %{
 6718   match(Set dst (CastX2P src));
 6719 
 6720   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6721   ins_encode %{
 6722     if ($dst$$reg != $src$$reg) {
 6723       __ movptr($dst$$Register, $src$$Register);
 6724     }
 6725   %}
 6726   ins_pipe(ialu_reg_reg); // XXX
 6727 %}
 6728 
 6729 instruct castN2X(rRegL dst, rRegN src)
 6730 %{
 6731   match(Set dst (CastP2X src));
 6732 
 6733   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6734   ins_encode %{
 6735     if ($dst$$reg != $src$$reg) {
 6736       __ movptr($dst$$Register, $src$$Register);
 6737     }
 6738   %}
 6739   ins_pipe(ialu_reg_reg); // XXX
 6740 %}
 6741 
 6742 instruct castP2X(rRegL dst, rRegP src)
 6743 %{
 6744   match(Set dst (CastP2X src));
 6745 
 6746   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6747   ins_encode %{
 6748     if ($dst$$reg != $src$$reg) {
 6749       __ movptr($dst$$Register, $src$$Register);
 6750     }
 6751   %}
 6752   ins_pipe(ialu_reg_reg); // XXX
 6753 %}
 6754 
 6755 instruct castN2I(rRegI dst, rRegN src)
 6756 %{
 6757   match(Set dst (CastN2I src));
 6758 
 6759   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6760   ins_encode %{
 6761     if ($dst$$reg != $src$$reg) {
 6762       __ movl($dst$$Register, $src$$Register);
 6763     }
 6764   %}
 6765   ins_pipe(ialu_reg_reg); // XXX
 6766 %}
 6767 
 6768 instruct castI2N(rRegN dst, rRegI src)
 6769 %{
 6770   match(Set dst (CastI2N src));
 6771 
 6772   format %{ &quot;movl    $dst, $src\t# int -&gt; compressed ptr&quot; %}
 6773   ins_encode %{
 6774     if ($dst$$reg != $src$$reg) {
 6775       __ movl($dst$$Register, $src$$Register);
 6776     }
 6777   %}
 6778   ins_pipe(ialu_reg_reg); // XXX
 6779 %}
 6780 
 6781 
 6782 // Convert oop into int for vectors alignment masking
 6783 instruct convP2I(rRegI dst, rRegP src)
 6784 %{
 6785   match(Set dst (ConvL2I (CastP2X src)));
 6786 
 6787   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6788   ins_encode %{
 6789     __ movl($dst$$Register, $src$$Register);
 6790   %}
 6791   ins_pipe(ialu_reg_reg); // XXX
 6792 %}
 6793 
 6794 // Convert compressed oop into int for vectors alignment masking
 6795 // in case of 32bit oops (heap &lt; 4Gb).
 6796 instruct convN2I(rRegI dst, rRegN src)
 6797 %{
 6798   predicate(CompressedOops::shift() == 0);
 6799   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6800 
 6801   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6802   ins_encode %{
 6803     __ movl($dst$$Register, $src$$Register);
 6804   %}
 6805   ins_pipe(ialu_reg_reg); // XXX
 6806 %}
 6807 
 6808 // Convert oop pointer into compressed form
 6809 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6810   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6811   match(Set dst (EncodeP src));
 6812   effect(KILL cr);
 6813   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6814   ins_encode %{
 6815     Register s = $src$$Register;
 6816     Register d = $dst$$Register;
 6817     if (s != d) {
 6818       __ movq(d, s);
 6819     }
 6820     __ encode_heap_oop(d);
 6821   %}
 6822   ins_pipe(ialu_reg_long);
 6823 %}
 6824 
 6825 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6826   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6827   match(Set dst (EncodeP src));
 6828   effect(KILL cr);
 6829   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6830   ins_encode %{
 6831     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6832   %}
 6833   ins_pipe(ialu_reg_long);
 6834 %}
 6835 
 6836 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6837   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6838             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6839   match(Set dst (DecodeN src));
 6840   effect(KILL cr);
 6841   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6842   ins_encode %{
 6843     Register s = $src$$Register;
 6844     Register d = $dst$$Register;
 6845     if (s != d) {
 6846       __ movq(d, s);
 6847     }
 6848     __ decode_heap_oop(d);
 6849   %}
 6850   ins_pipe(ialu_reg_long);
 6851 %}
 6852 
 6853 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6854   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6855             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6856   match(Set dst (DecodeN src));
 6857   effect(KILL cr);
 6858   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6859   ins_encode %{
 6860     Register s = $src$$Register;
 6861     Register d = $dst$$Register;
 6862     if (s != d) {
 6863       __ decode_heap_oop_not_null(d, s);
 6864     } else {
 6865       __ decode_heap_oop_not_null(d);
 6866     }
 6867   %}
 6868   ins_pipe(ialu_reg_long);
 6869 %}
 6870 
 6871 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6872   match(Set dst (EncodePKlass src));
 6873   effect(KILL cr);
 6874   format %{ &quot;encode_klass_not_null $dst,$src&quot; %}
 6875   ins_encode %{
 6876     __ encode_klass_not_null($dst$$Register, $src$$Register);
 6877   %}
 6878   ins_pipe(ialu_reg_long);
 6879 %}
 6880 
 6881 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6882   match(Set dst (DecodeNKlass src));
 6883   effect(KILL cr);
 6884   format %{ &quot;decode_klass_not_null $dst,$src&quot; %}
 6885   ins_encode %{
 6886     Register s = $src$$Register;
 6887     Register d = $dst$$Register;
 6888     if (s != d) {
 6889       __ decode_klass_not_null(d, s);
 6890     } else {
 6891       __ decode_klass_not_null(d);
 6892     }
 6893   %}
 6894   ins_pipe(ialu_reg_long);
 6895 %}
 6896 
 6897 
 6898 //----------Conditional Move---------------------------------------------------
 6899 // Jump
 6900 // dummy instruction for generating temp registers
 6901 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6902   match(Jump (LShiftL switch_val shift));
 6903   ins_cost(350);
 6904   predicate(false);
 6905   effect(TEMP dest);
 6906 
 6907   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6908             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6909   ins_encode %{
 6910     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6911     // to do that and the compiler is using that register as one it can allocate.
 6912     // So we build it all by hand.
 6913     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6914     // ArrayAddress dispatch(table, index);
 6915     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6916     __ lea($dest$$Register, $constantaddress);
 6917     __ jmp(dispatch);
 6918   %}
 6919   ins_pipe(pipe_jmp);
 6920 %}
 6921 
 6922 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6923   match(Jump (AddL (LShiftL switch_val shift) offset));
 6924   ins_cost(350);
 6925   effect(TEMP dest);
 6926 
 6927   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6928             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6929   ins_encode %{
 6930     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6931     // to do that and the compiler is using that register as one it can allocate.
 6932     // So we build it all by hand.
 6933     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6934     // ArrayAddress dispatch(table, index);
 6935     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6936     __ lea($dest$$Register, $constantaddress);
 6937     __ jmp(dispatch);
 6938   %}
 6939   ins_pipe(pipe_jmp);
 6940 %}
 6941 
 6942 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6943   match(Jump switch_val);
 6944   ins_cost(350);
 6945   effect(TEMP dest);
 6946 
 6947   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6948             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6949   ins_encode %{
 6950     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6951     // to do that and the compiler is using that register as one it can allocate.
 6952     // So we build it all by hand.
 6953     // Address index(noreg, switch_reg, Address::times_1);
 6954     // ArrayAddress dispatch(table, index);
 6955     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6956     __ lea($dest$$Register, $constantaddress);
 6957     __ jmp(dispatch);
 6958   %}
 6959   ins_pipe(pipe_jmp);
 6960 %}
 6961 
 6962 // Conditional move
 6963 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6964 %{
 6965   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6966 
 6967   ins_cost(200); // XXX
 6968   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6969   opcode(0x0F, 0x40);
 6970   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6971   ins_pipe(pipe_cmov_reg);
 6972 %}
 6973 
 6974 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6975   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6976 
 6977   ins_cost(200); // XXX
 6978   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6979   opcode(0x0F, 0x40);
 6980   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6981   ins_pipe(pipe_cmov_reg);
 6982 %}
 6983 
 6984 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6985   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6986   ins_cost(200);
 6987   expand %{
 6988     cmovI_regU(cop, cr, dst, src);
 6989   %}
 6990 %}
 6991 
 6992 // Conditional move
 6993 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6994   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6995 
 6996   ins_cost(250); // XXX
 6997   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6998   opcode(0x0F, 0x40);
 6999   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7000   ins_pipe(pipe_cmov_mem);
 7001 %}
 7002 
 7003 // Conditional move
 7004 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 7005 %{
 7006   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 7007 
 7008   ins_cost(250); // XXX
 7009   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 7010   opcode(0x0F, 0x40);
 7011   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7012   ins_pipe(pipe_cmov_mem);
 7013 %}
 7014 
 7015 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 7016   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 7017   ins_cost(250);
 7018   expand %{
 7019     cmovI_memU(cop, cr, dst, src);
 7020   %}
 7021 %}
 7022 
 7023 // Conditional move
 7024 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 7025 %{
 7026   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7027 
 7028   ins_cost(200); // XXX
 7029   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 7030   opcode(0x0F, 0x40);
 7031   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7032   ins_pipe(pipe_cmov_reg);
 7033 %}
 7034 
 7035 // Conditional move
 7036 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 7037 %{
 7038   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7039 
 7040   ins_cost(200); // XXX
 7041   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 7042   opcode(0x0F, 0x40);
 7043   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7044   ins_pipe(pipe_cmov_reg);
 7045 %}
 7046 
 7047 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 7048   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7049   ins_cost(200);
 7050   expand %{
 7051     cmovN_regU(cop, cr, dst, src);
 7052   %}
 7053 %}
 7054 
 7055 // Conditional move
 7056 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 7057 %{
 7058   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7059 
 7060   ins_cost(200); // XXX
 7061   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 7062   opcode(0x0F, 0x40);
 7063   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7064   ins_pipe(pipe_cmov_reg);  // XXX
 7065 %}
 7066 
 7067 // Conditional move
 7068 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 7069 %{
 7070   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7071 
 7072   ins_cost(200); // XXX
 7073   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 7074   opcode(0x0F, 0x40);
 7075   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7076   ins_pipe(pipe_cmov_reg); // XXX
 7077 %}
 7078 
 7079 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 7080   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7081   ins_cost(200);
 7082   expand %{
 7083     cmovP_regU(cop, cr, dst, src);
 7084   %}
 7085 %}
 7086 
 7087 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7088 // correctly meets the two pointer arguments; one is an incoming
 7089 // register but the other is a memory operand.  ALSO appears to
 7090 // be buggy with implicit null checks.
 7091 //
 7092 //// Conditional move
 7093 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7094 //%{
 7095 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7096 //  ins_cost(250);
 7097 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7098 //  opcode(0x0F,0x40);
 7099 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7100 //  ins_pipe( pipe_cmov_mem );
 7101 //%}
 7102 //
 7103 //// Conditional move
 7104 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7105 //%{
 7106 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7107 //  ins_cost(250);
 7108 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7109 //  opcode(0x0F,0x40);
 7110 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7111 //  ins_pipe( pipe_cmov_mem );
 7112 //%}
 7113 
 7114 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7115 %{
 7116   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7117 
 7118   ins_cost(200); // XXX
 7119   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7120   opcode(0x0F, 0x40);
 7121   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7122   ins_pipe(pipe_cmov_reg);  // XXX
 7123 %}
 7124 
 7125 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7126 %{
 7127   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7128 
 7129   ins_cost(200); // XXX
 7130   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7131   opcode(0x0F, 0x40);
 7132   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7133   ins_pipe(pipe_cmov_mem);  // XXX
 7134 %}
 7135 
 7136 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7137 %{
 7138   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7139 
 7140   ins_cost(200); // XXX
 7141   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7142   opcode(0x0F, 0x40);
 7143   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7144   ins_pipe(pipe_cmov_reg); // XXX
 7145 %}
 7146 
 7147 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7148   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7149   ins_cost(200);
 7150   expand %{
 7151     cmovL_regU(cop, cr, dst, src);
 7152   %}
 7153 %}
 7154 
 7155 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7156 %{
 7157   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7158 
 7159   ins_cost(200); // XXX
 7160   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7161   opcode(0x0F, 0x40);
 7162   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7163   ins_pipe(pipe_cmov_mem); // XXX
 7164 %}
 7165 
 7166 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7167   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7168   ins_cost(200);
 7169   expand %{
 7170     cmovL_memU(cop, cr, dst, src);
 7171   %}
 7172 %}
 7173 
 7174 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7175 %{
 7176   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7177 
 7178   ins_cost(200); // XXX
 7179   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7180             &quot;movss     $dst, $src\n&quot;
 7181     &quot;skip:&quot; %}
 7182   ins_encode %{
 7183     Label Lskip;
 7184     // Invert sense of branch from sense of CMOV
 7185     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7186     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7187     __ bind(Lskip);
 7188   %}
 7189   ins_pipe(pipe_slow);
 7190 %}
 7191 
 7192 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7193 // %{
 7194 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7195 
 7196 //   ins_cost(200); // XXX
 7197 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7198 //             &quot;movss     $dst, $src\n&quot;
 7199 //     &quot;skip:&quot; %}
 7200 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7201 //   ins_pipe(pipe_slow);
 7202 // %}
 7203 
 7204 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7205 %{
 7206   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7207 
 7208   ins_cost(200); // XXX
 7209   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7210             &quot;movss     $dst, $src\n&quot;
 7211     &quot;skip:&quot; %}
 7212   ins_encode %{
 7213     Label Lskip;
 7214     // Invert sense of branch from sense of CMOV
 7215     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7216     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7217     __ bind(Lskip);
 7218   %}
 7219   ins_pipe(pipe_slow);
 7220 %}
 7221 
 7222 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7223   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7224   ins_cost(200);
 7225   expand %{
 7226     cmovF_regU(cop, cr, dst, src);
 7227   %}
 7228 %}
 7229 
 7230 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7231 %{
 7232   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7233 
 7234   ins_cost(200); // XXX
 7235   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7236             &quot;movsd     $dst, $src\n&quot;
 7237     &quot;skip:&quot; %}
 7238   ins_encode %{
 7239     Label Lskip;
 7240     // Invert sense of branch from sense of CMOV
 7241     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7242     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7243     __ bind(Lskip);
 7244   %}
 7245   ins_pipe(pipe_slow);
 7246 %}
 7247 
 7248 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7249 %{
 7250   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7251 
 7252   ins_cost(200); // XXX
 7253   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7254             &quot;movsd     $dst, $src\n&quot;
 7255     &quot;skip:&quot; %}
 7256   ins_encode %{
 7257     Label Lskip;
 7258     // Invert sense of branch from sense of CMOV
 7259     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7260     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7261     __ bind(Lskip);
 7262   %}
 7263   ins_pipe(pipe_slow);
 7264 %}
 7265 
 7266 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7267   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7268   ins_cost(200);
 7269   expand %{
 7270     cmovD_regU(cop, cr, dst, src);
 7271   %}
 7272 %}
 7273 
 7274 //----------Arithmetic Instructions--------------------------------------------
 7275 //----------Addition Instructions----------------------------------------------
 7276 
 7277 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7278 %{
 7279   match(Set dst (AddI dst src));
 7280   effect(KILL cr);
 7281 
 7282   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7283   opcode(0x03);
 7284   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7285   ins_pipe(ialu_reg_reg);
 7286 %}
 7287 
 7288 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7289 %{
 7290   match(Set dst (AddI dst src));
 7291   effect(KILL cr);
 7292 
 7293   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7294   opcode(0x81, 0x00); /* /0 id */
 7295   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7296   ins_pipe( ialu_reg );
 7297 %}
 7298 
 7299 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7300 %{
 7301   match(Set dst (AddI dst (LoadI src)));
 7302   effect(KILL cr);
 7303 
 7304   ins_cost(125); // XXX
 7305   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7306   opcode(0x03);
 7307   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7308   ins_pipe(ialu_reg_mem);
 7309 %}
 7310 
 7311 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7312 %{
 7313   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7314   effect(KILL cr);
 7315 
 7316   ins_cost(150); // XXX
 7317   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7318   opcode(0x01); /* Opcode 01 /r */
 7319   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7320   ins_pipe(ialu_mem_reg);
 7321 %}
 7322 
 7323 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7324 %{
 7325   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7326   effect(KILL cr);
 7327 
 7328   ins_cost(125); // XXX
 7329   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7330   opcode(0x81); /* Opcode 81 /0 id */
 7331   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7332   ins_pipe(ialu_mem_imm);
 7333 %}
 7334 
 7335 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7336 %{
 7337   predicate(UseIncDec);
 7338   match(Set dst (AddI dst src));
 7339   effect(KILL cr);
 7340 
 7341   format %{ &quot;incl    $dst\t# int&quot; %}
 7342   opcode(0xFF, 0x00); // FF /0
 7343   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7344   ins_pipe(ialu_reg);
 7345 %}
 7346 
 7347 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7348 %{
 7349   predicate(UseIncDec);
 7350   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7351   effect(KILL cr);
 7352 
 7353   ins_cost(125); // XXX
 7354   format %{ &quot;incl    $dst\t# int&quot; %}
 7355   opcode(0xFF); /* Opcode FF /0 */
 7356   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7357   ins_pipe(ialu_mem_imm);
 7358 %}
 7359 
 7360 // XXX why does that use AddI
 7361 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7362 %{
 7363   predicate(UseIncDec);
 7364   match(Set dst (AddI dst src));
 7365   effect(KILL cr);
 7366 
 7367   format %{ &quot;decl    $dst\t# int&quot; %}
 7368   opcode(0xFF, 0x01); // FF /1
 7369   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7370   ins_pipe(ialu_reg);
 7371 %}
 7372 
 7373 // XXX why does that use AddI
 7374 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7375 %{
 7376   predicate(UseIncDec);
 7377   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7378   effect(KILL cr);
 7379 
 7380   ins_cost(125); // XXX
 7381   format %{ &quot;decl    $dst\t# int&quot; %}
 7382   opcode(0xFF); /* Opcode FF /1 */
 7383   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7384   ins_pipe(ialu_mem_imm);
 7385 %}
 7386 
 7387 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7388 %{
 7389   match(Set dst (AddI src0 src1));
 7390 
 7391   ins_cost(110);
 7392   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7393   opcode(0x8D); /* 0x8D /r */
 7394   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7395   ins_pipe(ialu_reg_reg);
 7396 %}
 7397 
 7398 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7399 %{
 7400   match(Set dst (AddL dst src));
 7401   effect(KILL cr);
 7402 
 7403   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7404   opcode(0x03);
 7405   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7406   ins_pipe(ialu_reg_reg);
 7407 %}
 7408 
 7409 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7410 %{
 7411   match(Set dst (AddL dst src));
 7412   effect(KILL cr);
 7413 
 7414   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7415   opcode(0x81, 0x00); /* /0 id */
 7416   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7417   ins_pipe( ialu_reg );
 7418 %}
 7419 
 7420 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7421 %{
 7422   match(Set dst (AddL dst (LoadL src)));
 7423   effect(KILL cr);
 7424 
 7425   ins_cost(125); // XXX
 7426   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7427   opcode(0x03);
 7428   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7429   ins_pipe(ialu_reg_mem);
 7430 %}
 7431 
 7432 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7433 %{
 7434   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7435   effect(KILL cr);
 7436 
 7437   ins_cost(150); // XXX
 7438   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7439   opcode(0x01); /* Opcode 01 /r */
 7440   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7441   ins_pipe(ialu_mem_reg);
 7442 %}
 7443 
 7444 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7445 %{
 7446   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7447   effect(KILL cr);
 7448 
 7449   ins_cost(125); // XXX
 7450   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7451   opcode(0x81); /* Opcode 81 /0 id */
 7452   ins_encode(REX_mem_wide(dst),
 7453              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7454   ins_pipe(ialu_mem_imm);
 7455 %}
 7456 
 7457 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7458 %{
 7459   predicate(UseIncDec);
 7460   match(Set dst (AddL dst src));
 7461   effect(KILL cr);
 7462 
 7463   format %{ &quot;incq    $dst\t# long&quot; %}
 7464   opcode(0xFF, 0x00); // FF /0
 7465   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7466   ins_pipe(ialu_reg);
 7467 %}
 7468 
 7469 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7470 %{
 7471   predicate(UseIncDec);
 7472   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7473   effect(KILL cr);
 7474 
 7475   ins_cost(125); // XXX
 7476   format %{ &quot;incq    $dst\t# long&quot; %}
 7477   opcode(0xFF); /* Opcode FF /0 */
 7478   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7479   ins_pipe(ialu_mem_imm);
 7480 %}
 7481 
 7482 // XXX why does that use AddL
 7483 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7484 %{
 7485   predicate(UseIncDec);
 7486   match(Set dst (AddL dst src));
 7487   effect(KILL cr);
 7488 
 7489   format %{ &quot;decq    $dst\t# long&quot; %}
 7490   opcode(0xFF, 0x01); // FF /1
 7491   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7492   ins_pipe(ialu_reg);
 7493 %}
 7494 
 7495 // XXX why does that use AddL
 7496 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7497 %{
 7498   predicate(UseIncDec);
 7499   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7500   effect(KILL cr);
 7501 
 7502   ins_cost(125); // XXX
 7503   format %{ &quot;decq    $dst\t# long&quot; %}
 7504   opcode(0xFF); /* Opcode FF /1 */
 7505   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7506   ins_pipe(ialu_mem_imm);
 7507 %}
 7508 
 7509 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7510 %{
 7511   match(Set dst (AddL src0 src1));
 7512 
 7513   ins_cost(110);
 7514   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7515   opcode(0x8D); /* 0x8D /r */
 7516   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7517   ins_pipe(ialu_reg_reg);
 7518 %}
 7519 
 7520 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7521 %{
 7522   match(Set dst (AddP dst src));
 7523   effect(KILL cr);
 7524 
 7525   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7526   opcode(0x03);
 7527   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7528   ins_pipe(ialu_reg_reg);
 7529 %}
 7530 
 7531 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7532 %{
 7533   match(Set dst (AddP dst src));
 7534   effect(KILL cr);
 7535 
 7536   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7537   opcode(0x81, 0x00); /* /0 id */
 7538   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7539   ins_pipe( ialu_reg );
 7540 %}
 7541 
 7542 // XXX addP mem ops ????
 7543 
 7544 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7545 %{
 7546   match(Set dst (AddP src0 src1));
 7547 
 7548   ins_cost(110);
 7549   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7550   opcode(0x8D); /* 0x8D /r */
 7551   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7552   ins_pipe(ialu_reg_reg);
 7553 %}
 7554 
 7555 instruct checkCastPP(rRegP dst)
 7556 %{
 7557   match(Set dst (CheckCastPP dst));
 7558 
 7559   size(0);
 7560   format %{ &quot;# checkcastPP of $dst&quot; %}
 7561   ins_encode(/* empty encoding */);
 7562   ins_pipe(empty);
 7563 %}
 7564 
 7565 instruct castPP(rRegP dst)
 7566 %{
 7567   match(Set dst (CastPP dst));
 7568 
 7569   size(0);
 7570   format %{ &quot;# castPP of $dst&quot; %}
 7571   ins_encode(/* empty encoding */);
 7572   ins_pipe(empty);
 7573 %}
 7574 
 7575 instruct castII(rRegI dst)
 7576 %{
 7577   match(Set dst (CastII dst));
 7578 
 7579   size(0);
 7580   format %{ &quot;# castII of $dst&quot; %}
 7581   ins_encode(/* empty encoding */);
 7582   ins_cost(0);
 7583   ins_pipe(empty);
 7584 %}
 7585 
 7586 instruct castLL(rRegL dst)
 7587 %{
 7588   match(Set dst (CastLL dst));
 7589 
 7590   size(0);
 7591   format %{ &quot;# castLL of $dst&quot; %}
 7592   ins_encode(/* empty encoding */);
 7593   ins_cost(0);
 7594   ins_pipe(empty);
 7595 %}
 7596 
 7597 // LoadP-locked same as a regular LoadP when used with compare-swap
 7598 instruct loadPLocked(rRegP dst, memory mem)
 7599 %{
 7600   match(Set dst (LoadPLocked mem));
 7601 
 7602   ins_cost(125); // XXX
 7603   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7604   opcode(0x8B);
 7605   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7606   ins_pipe(ialu_reg_mem); // XXX
 7607 %}
 7608 
 7609 // Conditional-store of the updated heap-top.
 7610 // Used during allocation of the shared heap.
 7611 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7612 
 7613 instruct storePConditional(memory heap_top_ptr,
 7614                            rax_RegP oldval, rRegP newval,
 7615                            rFlagsReg cr)
 7616 %{
 7617   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7618   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7619 
 7620   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7621             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7622   opcode(0x0F, 0xB1);
 7623   ins_encode(lock_prefix,
 7624              REX_reg_mem_wide(newval, heap_top_ptr),
 7625              OpcP, OpcS,
 7626              reg_mem(newval, heap_top_ptr));
 7627   ins_pipe(pipe_cmpxchg);
 7628 %}
 7629 
 7630 // Conditional-store of an int value.
 7631 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7632 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7633 %{
 7634   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7635   effect(KILL oldval);
 7636 
 7637   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7638   opcode(0x0F, 0xB1);
 7639   ins_encode(lock_prefix,
 7640              REX_reg_mem(newval, mem),
 7641              OpcP, OpcS,
 7642              reg_mem(newval, mem));
 7643   ins_pipe(pipe_cmpxchg);
 7644 %}
 7645 
 7646 // Conditional-store of a long value.
 7647 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7648 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7649 %{
 7650   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7651   effect(KILL oldval);
 7652 
 7653   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7654   opcode(0x0F, 0xB1);
 7655   ins_encode(lock_prefix,
 7656              REX_reg_mem_wide(newval, mem),
 7657              OpcP, OpcS,
 7658              reg_mem(newval, mem));
 7659   ins_pipe(pipe_cmpxchg);
 7660 %}
 7661 
 7662 
 7663 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7664 instruct compareAndSwapP(rRegI res,
 7665                          memory mem_ptr,
 7666                          rax_RegP oldval, rRegP newval,
 7667                          rFlagsReg cr)
 7668 %{
 7669   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7670   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7671   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7672   effect(KILL cr, KILL oldval);
 7673 
 7674   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7675             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7676             &quot;sete    $res\n\t&quot;
 7677             &quot;movzbl  $res, $res&quot; %}
 7678   opcode(0x0F, 0xB1);
 7679   ins_encode(lock_prefix,
 7680              REX_reg_mem_wide(newval, mem_ptr),
 7681              OpcP, OpcS,
 7682              reg_mem(newval, mem_ptr),
 7683              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7684              REX_reg_breg(res, res), // movzbl
 7685              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7686   ins_pipe( pipe_cmpxchg );
 7687 %}
 7688 
 7689 instruct compareAndSwapL(rRegI res,
 7690                          memory mem_ptr,
 7691                          rax_RegL oldval, rRegL newval,
 7692                          rFlagsReg cr)
 7693 %{
 7694   predicate(VM_Version::supports_cx8());
 7695   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7696   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7697   effect(KILL cr, KILL oldval);
 7698 
 7699   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7700             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7701             &quot;sete    $res\n\t&quot;
 7702             &quot;movzbl  $res, $res&quot; %}
 7703   opcode(0x0F, 0xB1);
 7704   ins_encode(lock_prefix,
 7705              REX_reg_mem_wide(newval, mem_ptr),
 7706              OpcP, OpcS,
 7707              reg_mem(newval, mem_ptr),
 7708              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7709              REX_reg_breg(res, res), // movzbl
 7710              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7711   ins_pipe( pipe_cmpxchg );
 7712 %}
 7713 
 7714 instruct compareAndSwapI(rRegI res,
 7715                          memory mem_ptr,
 7716                          rax_RegI oldval, rRegI newval,
 7717                          rFlagsReg cr)
 7718 %{
 7719   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7720   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7721   effect(KILL cr, KILL oldval);
 7722 
 7723   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7724             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7725             &quot;sete    $res\n\t&quot;
 7726             &quot;movzbl  $res, $res&quot; %}
 7727   opcode(0x0F, 0xB1);
 7728   ins_encode(lock_prefix,
 7729              REX_reg_mem(newval, mem_ptr),
 7730              OpcP, OpcS,
 7731              reg_mem(newval, mem_ptr),
 7732              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7733              REX_reg_breg(res, res), // movzbl
 7734              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7735   ins_pipe( pipe_cmpxchg );
 7736 %}
 7737 
 7738 instruct compareAndSwapB(rRegI res,
 7739                          memory mem_ptr,
 7740                          rax_RegI oldval, rRegI newval,
 7741                          rFlagsReg cr)
 7742 %{
 7743   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7744   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7745   effect(KILL cr, KILL oldval);
 7746 
 7747   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7748             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7749             &quot;sete    $res\n\t&quot;
 7750             &quot;movzbl  $res, $res&quot; %}
 7751   opcode(0x0F, 0xB0);
 7752   ins_encode(lock_prefix,
 7753              REX_breg_mem(newval, mem_ptr),
 7754              OpcP, OpcS,
 7755              reg_mem(newval, mem_ptr),
 7756              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7757              REX_reg_breg(res, res), // movzbl
 7758              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7759   ins_pipe( pipe_cmpxchg );
 7760 %}
 7761 
 7762 instruct compareAndSwapS(rRegI res,
 7763                          memory mem_ptr,
 7764                          rax_RegI oldval, rRegI newval,
 7765                          rFlagsReg cr)
 7766 %{
 7767   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7768   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7769   effect(KILL cr, KILL oldval);
 7770 
 7771   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7772             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7773             &quot;sete    $res\n\t&quot;
 7774             &quot;movzbl  $res, $res&quot; %}
 7775   opcode(0x0F, 0xB1);
 7776   ins_encode(lock_prefix,
 7777              SizePrefix,
 7778              REX_reg_mem(newval, mem_ptr),
 7779              OpcP, OpcS,
 7780              reg_mem(newval, mem_ptr),
 7781              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7782              REX_reg_breg(res, res), // movzbl
 7783              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7784   ins_pipe( pipe_cmpxchg );
 7785 %}
 7786 
 7787 instruct compareAndSwapN(rRegI res,
 7788                           memory mem_ptr,
 7789                           rax_RegN oldval, rRegN newval,
 7790                           rFlagsReg cr) %{
 7791   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7792   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7793   effect(KILL cr, KILL oldval);
 7794 
 7795   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7796             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7797             &quot;sete    $res\n\t&quot;
 7798             &quot;movzbl  $res, $res&quot; %}
 7799   opcode(0x0F, 0xB1);
 7800   ins_encode(lock_prefix,
 7801              REX_reg_mem(newval, mem_ptr),
 7802              OpcP, OpcS,
 7803              reg_mem(newval, mem_ptr),
 7804              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7805              REX_reg_breg(res, res), // movzbl
 7806              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7807   ins_pipe( pipe_cmpxchg );
 7808 %}
 7809 
 7810 instruct compareAndExchangeB(
 7811                          memory mem_ptr,
 7812                          rax_RegI oldval, rRegI newval,
 7813                          rFlagsReg cr)
 7814 %{
 7815   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7816   effect(KILL cr);
 7817 
 7818   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7819             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7820   opcode(0x0F, 0xB0);
 7821   ins_encode(lock_prefix,
 7822              REX_breg_mem(newval, mem_ptr),
 7823              OpcP, OpcS,
 7824              reg_mem(newval, mem_ptr) // lock cmpxchg
 7825              );
 7826   ins_pipe( pipe_cmpxchg );
 7827 %}
 7828 
 7829 instruct compareAndExchangeS(
 7830                          memory mem_ptr,
 7831                          rax_RegI oldval, rRegI newval,
 7832                          rFlagsReg cr)
 7833 %{
 7834   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7835   effect(KILL cr);
 7836 
 7837   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7838             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7839   opcode(0x0F, 0xB1);
 7840   ins_encode(lock_prefix,
 7841              SizePrefix,
 7842              REX_reg_mem(newval, mem_ptr),
 7843              OpcP, OpcS,
 7844              reg_mem(newval, mem_ptr) // lock cmpxchg
 7845              );
 7846   ins_pipe( pipe_cmpxchg );
 7847 %}
 7848 
 7849 instruct compareAndExchangeI(
 7850                          memory mem_ptr,
 7851                          rax_RegI oldval, rRegI newval,
 7852                          rFlagsReg cr)
 7853 %{
 7854   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7855   effect(KILL cr);
 7856 
 7857   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7858             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7859   opcode(0x0F, 0xB1);
 7860   ins_encode(lock_prefix,
 7861              REX_reg_mem(newval, mem_ptr),
 7862              OpcP, OpcS,
 7863              reg_mem(newval, mem_ptr) // lock cmpxchg
 7864              );
 7865   ins_pipe( pipe_cmpxchg );
 7866 %}
 7867 
 7868 instruct compareAndExchangeL(
 7869                          memory mem_ptr,
 7870                          rax_RegL oldval, rRegL newval,
 7871                          rFlagsReg cr)
 7872 %{
 7873   predicate(VM_Version::supports_cx8());
 7874   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7875   effect(KILL cr);
 7876 
 7877   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7878             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7879   opcode(0x0F, 0xB1);
 7880   ins_encode(lock_prefix,
 7881              REX_reg_mem_wide(newval, mem_ptr),
 7882              OpcP, OpcS,
 7883              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7884             );
 7885   ins_pipe( pipe_cmpxchg );
 7886 %}
 7887 
 7888 instruct compareAndExchangeN(
 7889                           memory mem_ptr,
 7890                           rax_RegN oldval, rRegN newval,
 7891                           rFlagsReg cr) %{
 7892   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7893   effect(KILL cr);
 7894 
 7895   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7896             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7897   opcode(0x0F, 0xB1);
 7898   ins_encode(lock_prefix,
 7899              REX_reg_mem(newval, mem_ptr),
 7900              OpcP, OpcS,
 7901              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7902           );
 7903   ins_pipe( pipe_cmpxchg );
 7904 %}
 7905 
 7906 instruct compareAndExchangeP(
 7907                          memory mem_ptr,
 7908                          rax_RegP oldval, rRegP newval,
 7909                          rFlagsReg cr)
 7910 %{
 7911   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7912   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7913   effect(KILL cr);
 7914 
 7915   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7916             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7917   opcode(0x0F, 0xB1);
 7918   ins_encode(lock_prefix,
 7919              REX_reg_mem_wide(newval, mem_ptr),
 7920              OpcP, OpcS,
 7921              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7922           );
 7923   ins_pipe( pipe_cmpxchg );
 7924 %}
 7925 
 7926 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7927   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7928   match(Set dummy (GetAndAddB mem add));
 7929   effect(KILL cr);
 7930   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7931   ins_encode %{
 7932     __ lock();
 7933     __ addb($mem$$Address, $add$$constant);
 7934   %}
 7935   ins_pipe( pipe_cmpxchg );
 7936 %}
 7937 
 7938 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7939   match(Set newval (GetAndAddB mem newval));
 7940   effect(KILL cr);
 7941   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7942   ins_encode %{
 7943     __ lock();
 7944     __ xaddb($mem$$Address, $newval$$Register);
 7945   %}
 7946   ins_pipe( pipe_cmpxchg );
 7947 %}
 7948 
 7949 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7950   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7951   match(Set dummy (GetAndAddS mem add));
 7952   effect(KILL cr);
 7953   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7954   ins_encode %{
 7955     __ lock();
 7956     __ addw($mem$$Address, $add$$constant);
 7957   %}
 7958   ins_pipe( pipe_cmpxchg );
 7959 %}
 7960 
 7961 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7962   match(Set newval (GetAndAddS mem newval));
 7963   effect(KILL cr);
 7964   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7965   ins_encode %{
 7966     __ lock();
 7967     __ xaddw($mem$$Address, $newval$$Register);
 7968   %}
 7969   ins_pipe( pipe_cmpxchg );
 7970 %}
 7971 
 7972 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7973   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7974   match(Set dummy (GetAndAddI mem add));
 7975   effect(KILL cr);
 7976   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7977   ins_encode %{
 7978     __ lock();
 7979     __ addl($mem$$Address, $add$$constant);
 7980   %}
 7981   ins_pipe( pipe_cmpxchg );
 7982 %}
 7983 
 7984 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7985   match(Set newval (GetAndAddI mem newval));
 7986   effect(KILL cr);
 7987   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7988   ins_encode %{
 7989     __ lock();
 7990     __ xaddl($mem$$Address, $newval$$Register);
 7991   %}
 7992   ins_pipe( pipe_cmpxchg );
 7993 %}
 7994 
 7995 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7996   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7997   match(Set dummy (GetAndAddL mem add));
 7998   effect(KILL cr);
 7999   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 8000   ins_encode %{
 8001     __ lock();
 8002     __ addq($mem$$Address, $add$$constant);
 8003   %}
 8004   ins_pipe( pipe_cmpxchg );
 8005 %}
 8006 
 8007 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 8008   match(Set newval (GetAndAddL mem newval));
 8009   effect(KILL cr);
 8010   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 8011   ins_encode %{
 8012     __ lock();
 8013     __ xaddq($mem$$Address, $newval$$Register);
 8014   %}
 8015   ins_pipe( pipe_cmpxchg );
 8016 %}
 8017 
 8018 instruct xchgB( memory mem, rRegI newval) %{
 8019   match(Set newval (GetAndSetB mem newval));
 8020   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 8021   ins_encode %{
 8022     __ xchgb($newval$$Register, $mem$$Address);
 8023   %}
 8024   ins_pipe( pipe_cmpxchg );
 8025 %}
 8026 
 8027 instruct xchgS( memory mem, rRegI newval) %{
 8028   match(Set newval (GetAndSetS mem newval));
 8029   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 8030   ins_encode %{
 8031     __ xchgw($newval$$Register, $mem$$Address);
 8032   %}
 8033   ins_pipe( pipe_cmpxchg );
 8034 %}
 8035 
 8036 instruct xchgI( memory mem, rRegI newval) %{
 8037   match(Set newval (GetAndSetI mem newval));
 8038   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8039   ins_encode %{
 8040     __ xchgl($newval$$Register, $mem$$Address);
 8041   %}
 8042   ins_pipe( pipe_cmpxchg );
 8043 %}
 8044 
 8045 instruct xchgL( memory mem, rRegL newval) %{
 8046   match(Set newval (GetAndSetL mem newval));
 8047   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8048   ins_encode %{
 8049     __ xchgq($newval$$Register, $mem$$Address);
 8050   %}
 8051   ins_pipe( pipe_cmpxchg );
 8052 %}
 8053 
 8054 instruct xchgP( memory mem, rRegP newval) %{
 8055   match(Set newval (GetAndSetP mem newval));
 8056   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 8057   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 8058   ins_encode %{
 8059     __ xchgq($newval$$Register, $mem$$Address);
 8060   %}
 8061   ins_pipe( pipe_cmpxchg );
 8062 %}
 8063 
 8064 instruct xchgN( memory mem, rRegN newval) %{
 8065   match(Set newval (GetAndSetN mem newval));
 8066   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 8067   ins_encode %{
 8068     __ xchgl($newval$$Register, $mem$$Address);
 8069   %}
 8070   ins_pipe( pipe_cmpxchg );
 8071 %}
 8072 
 8073 //----------Abs Instructions-------------------------------------------
 8074 
 8075 // Integer Absolute Instructions
 8076 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 8077 %{
 8078   match(Set dst (AbsI src));
 8079   effect(TEMP dst, TEMP tmp, KILL cr);
 8080   format %{ &quot;movl $tmp, $src\n\t&quot;
 8081             &quot;sarl $tmp, 31\n\t&quot;
 8082             &quot;movl $dst, $src\n\t&quot;
 8083             &quot;xorl $dst, $tmp\n\t&quot;
 8084             &quot;subl $dst, $tmp\n&quot;
 8085           %}
 8086   ins_encode %{
 8087     __ movl($tmp$$Register, $src$$Register);
 8088     __ sarl($tmp$$Register, 31);
 8089     __ movl($dst$$Register, $src$$Register);
 8090     __ xorl($dst$$Register, $tmp$$Register);
 8091     __ subl($dst$$Register, $tmp$$Register);
 8092   %}
 8093 
 8094   ins_pipe(ialu_reg_reg);
 8095 %}
 8096 
 8097 // Long Absolute Instructions
 8098 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8099 %{
 8100   match(Set dst (AbsL src));
 8101   effect(TEMP dst, TEMP tmp, KILL cr);
 8102   format %{ &quot;movq $tmp, $src\n\t&quot;
 8103             &quot;sarq $tmp, 63\n\t&quot;
 8104             &quot;movq $dst, $src\n\t&quot;
 8105             &quot;xorq $dst, $tmp\n\t&quot;
 8106             &quot;subq $dst, $tmp\n&quot;
 8107           %}
 8108   ins_encode %{
 8109     __ movq($tmp$$Register, $src$$Register);
 8110     __ sarq($tmp$$Register, 63);
 8111     __ movq($dst$$Register, $src$$Register);
 8112     __ xorq($dst$$Register, $tmp$$Register);
 8113     __ subq($dst$$Register, $tmp$$Register);
 8114   %}
 8115 
 8116   ins_pipe(ialu_reg_reg);
 8117 %}
 8118 
 8119 //----------Subtraction Instructions-------------------------------------------
 8120 
 8121 // Integer Subtraction Instructions
 8122 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8123 %{
 8124   match(Set dst (SubI dst src));
 8125   effect(KILL cr);
 8126 
 8127   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8128   opcode(0x2B);
 8129   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8130   ins_pipe(ialu_reg_reg);
 8131 %}
 8132 
 8133 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8134 %{
 8135   match(Set dst (SubI dst src));
 8136   effect(KILL cr);
 8137 
 8138   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8139   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8140   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8141   ins_pipe(ialu_reg);
 8142 %}
 8143 
 8144 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8145 %{
 8146   match(Set dst (SubI dst (LoadI src)));
 8147   effect(KILL cr);
 8148 
 8149   ins_cost(125);
 8150   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8151   opcode(0x2B);
 8152   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8153   ins_pipe(ialu_reg_mem);
 8154 %}
 8155 
 8156 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8157 %{
 8158   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8159   effect(KILL cr);
 8160 
 8161   ins_cost(150);
 8162   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8163   opcode(0x29); /* Opcode 29 /r */
 8164   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8165   ins_pipe(ialu_mem_reg);
 8166 %}
 8167 
 8168 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8169 %{
 8170   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8171   effect(KILL cr);
 8172 
 8173   ins_cost(125); // XXX
 8174   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8175   opcode(0x81); /* Opcode 81 /5 id */
 8176   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8177   ins_pipe(ialu_mem_imm);
 8178 %}
 8179 
 8180 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8181 %{
 8182   match(Set dst (SubL dst src));
 8183   effect(KILL cr);
 8184 
 8185   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8186   opcode(0x2B);
 8187   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8188   ins_pipe(ialu_reg_reg);
 8189 %}
 8190 
 8191 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8192 %{
 8193   match(Set dst (SubL dst src));
 8194   effect(KILL cr);
 8195 
 8196   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8197   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8198   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8199   ins_pipe(ialu_reg);
 8200 %}
 8201 
 8202 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8203 %{
 8204   match(Set dst (SubL dst (LoadL src)));
 8205   effect(KILL cr);
 8206 
 8207   ins_cost(125);
 8208   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8209   opcode(0x2B);
 8210   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8211   ins_pipe(ialu_reg_mem);
 8212 %}
 8213 
 8214 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8215 %{
 8216   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8217   effect(KILL cr);
 8218 
 8219   ins_cost(150);
 8220   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8221   opcode(0x29); /* Opcode 29 /r */
 8222   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8223   ins_pipe(ialu_mem_reg);
 8224 %}
 8225 
 8226 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8227 %{
 8228   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8229   effect(KILL cr);
 8230 
 8231   ins_cost(125); // XXX
 8232   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8233   opcode(0x81); /* Opcode 81 /5 id */
 8234   ins_encode(REX_mem_wide(dst),
 8235              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8236   ins_pipe(ialu_mem_imm);
 8237 %}
 8238 
 8239 // Subtract from a pointer
 8240 // XXX hmpf???
 8241 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8242 %{
 8243   match(Set dst (AddP dst (SubI zero src)));
 8244   effect(KILL cr);
 8245 
 8246   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8247   opcode(0x2B);
 8248   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8249   ins_pipe(ialu_reg_reg);
 8250 %}
 8251 
 8252 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8253 %{
 8254   match(Set dst (SubI zero dst));
 8255   effect(KILL cr);
 8256 
 8257   format %{ &quot;negl    $dst\t# int&quot; %}
 8258   opcode(0xF7, 0x03);  // Opcode F7 /3
 8259   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8260   ins_pipe(ialu_reg);
 8261 %}
 8262 
 8263 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8264 %{
 8265   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8266   effect(KILL cr);
 8267 
 8268   format %{ &quot;negl    $dst\t# int&quot; %}
 8269   opcode(0xF7, 0x03);  // Opcode F7 /3
 8270   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8271   ins_pipe(ialu_reg);
 8272 %}
 8273 
 8274 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8275 %{
 8276   match(Set dst (SubL zero dst));
 8277   effect(KILL cr);
 8278 
 8279   format %{ &quot;negq    $dst\t# long&quot; %}
 8280   opcode(0xF7, 0x03);  // Opcode F7 /3
 8281   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8282   ins_pipe(ialu_reg);
 8283 %}
 8284 
 8285 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8286 %{
 8287   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8288   effect(KILL cr);
 8289 
 8290   format %{ &quot;negq    $dst\t# long&quot; %}
 8291   opcode(0xF7, 0x03);  // Opcode F7 /3
 8292   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8293   ins_pipe(ialu_reg);
 8294 %}
 8295 
 8296 //----------Multiplication/Division Instructions-------------------------------
 8297 // Integer Multiplication Instructions
 8298 // Multiply Register
 8299 
 8300 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8301 %{
 8302   match(Set dst (MulI dst src));
 8303   effect(KILL cr);
 8304 
 8305   ins_cost(300);
 8306   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8307   opcode(0x0F, 0xAF);
 8308   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8309   ins_pipe(ialu_reg_reg_alu0);
 8310 %}
 8311 
 8312 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8313 %{
 8314   match(Set dst (MulI src imm));
 8315   effect(KILL cr);
 8316 
 8317   ins_cost(300);
 8318   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8319   opcode(0x69); /* 69 /r id */
 8320   ins_encode(REX_reg_reg(dst, src),
 8321              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8322   ins_pipe(ialu_reg_reg_alu0);
 8323 %}
 8324 
 8325 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8326 %{
 8327   match(Set dst (MulI dst (LoadI src)));
 8328   effect(KILL cr);
 8329 
 8330   ins_cost(350);
 8331   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8332   opcode(0x0F, 0xAF);
 8333   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8334   ins_pipe(ialu_reg_mem_alu0);
 8335 %}
 8336 
 8337 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8338 %{
 8339   match(Set dst (MulI (LoadI src) imm));
 8340   effect(KILL cr);
 8341 
 8342   ins_cost(300);
 8343   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8344   opcode(0x69); /* 69 /r id */
 8345   ins_encode(REX_reg_mem(dst, src),
 8346              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8347   ins_pipe(ialu_reg_mem_alu0);
 8348 %}
 8349 
 8350 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8351 %{
 8352   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8353   effect(KILL cr, KILL src2);
 8354 
 8355   expand %{ mulI_rReg(dst, src1, cr);
 8356            mulI_rReg(src2, src3, cr);
 8357            addI_rReg(dst, src2, cr); %}
 8358 %}
 8359 
 8360 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8361 %{
 8362   match(Set dst (MulL dst src));
 8363   effect(KILL cr);
 8364 
 8365   ins_cost(300);
 8366   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8367   opcode(0x0F, 0xAF);
 8368   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8369   ins_pipe(ialu_reg_reg_alu0);
 8370 %}
 8371 
 8372 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8373 %{
 8374   match(Set dst (MulL src imm));
 8375   effect(KILL cr);
 8376 
 8377   ins_cost(300);
 8378   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8379   opcode(0x69); /* 69 /r id */
 8380   ins_encode(REX_reg_reg_wide(dst, src),
 8381              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8382   ins_pipe(ialu_reg_reg_alu0);
 8383 %}
 8384 
 8385 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8386 %{
 8387   match(Set dst (MulL dst (LoadL src)));
 8388   effect(KILL cr);
 8389 
 8390   ins_cost(350);
 8391   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8392   opcode(0x0F, 0xAF);
 8393   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8394   ins_pipe(ialu_reg_mem_alu0);
 8395 %}
 8396 
 8397 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8398 %{
 8399   match(Set dst (MulL (LoadL src) imm));
 8400   effect(KILL cr);
 8401 
 8402   ins_cost(300);
 8403   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8404   opcode(0x69); /* 69 /r id */
 8405   ins_encode(REX_reg_mem_wide(dst, src),
 8406              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8407   ins_pipe(ialu_reg_mem_alu0);
 8408 %}
 8409 
 8410 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8411 %{
 8412   match(Set dst (MulHiL src rax));
 8413   effect(USE_KILL rax, KILL cr);
 8414 
 8415   ins_cost(300);
 8416   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8417   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8418   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8419   ins_pipe(ialu_reg_reg_alu0);
 8420 %}
 8421 
 8422 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8423                    rFlagsReg cr)
 8424 %{
 8425   match(Set rax (DivI rax div));
 8426   effect(KILL rdx, KILL cr);
 8427 
 8428   ins_cost(30*100+10*100); // XXX
 8429   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8430             &quot;jne,s   normal\n\t&quot;
 8431             &quot;xorl    rdx, rdx\n\t&quot;
 8432             &quot;cmpl    $div, -1\n\t&quot;
 8433             &quot;je,s    done\n&quot;
 8434     &quot;normal: cdql\n\t&quot;
 8435             &quot;idivl   $div\n&quot;
 8436     &quot;done:&quot;        %}
 8437   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8438   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8439   ins_pipe(ialu_reg_reg_alu0);
 8440 %}
 8441 
 8442 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8443                    rFlagsReg cr)
 8444 %{
 8445   match(Set rax (DivL rax div));
 8446   effect(KILL rdx, KILL cr);
 8447 
 8448   ins_cost(30*100+10*100); // XXX
 8449   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8450             &quot;cmpq    rax, rdx\n\t&quot;
 8451             &quot;jne,s   normal\n\t&quot;
 8452             &quot;xorl    rdx, rdx\n\t&quot;
 8453             &quot;cmpq    $div, -1\n\t&quot;
 8454             &quot;je,s    done\n&quot;
 8455     &quot;normal: cdqq\n\t&quot;
 8456             &quot;idivq   $div\n&quot;
 8457     &quot;done:&quot;        %}
 8458   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8459   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8460   ins_pipe(ialu_reg_reg_alu0);
 8461 %}
 8462 
 8463 // Integer DIVMOD with Register, both quotient and mod results
 8464 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8465                              rFlagsReg cr)
 8466 %{
 8467   match(DivModI rax div);
 8468   effect(KILL cr);
 8469 
 8470   ins_cost(30*100+10*100); // XXX
 8471   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8472             &quot;jne,s   normal\n\t&quot;
 8473             &quot;xorl    rdx, rdx\n\t&quot;
 8474             &quot;cmpl    $div, -1\n\t&quot;
 8475             &quot;je,s    done\n&quot;
 8476     &quot;normal: cdql\n\t&quot;
 8477             &quot;idivl   $div\n&quot;
 8478     &quot;done:&quot;        %}
 8479   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8480   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8481   ins_pipe(pipe_slow);
 8482 %}
 8483 
 8484 // Long DIVMOD with Register, both quotient and mod results
 8485 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8486                              rFlagsReg cr)
 8487 %{
 8488   match(DivModL rax div);
 8489   effect(KILL cr);
 8490 
 8491   ins_cost(30*100+10*100); // XXX
 8492   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8493             &quot;cmpq    rax, rdx\n\t&quot;
 8494             &quot;jne,s   normal\n\t&quot;
 8495             &quot;xorl    rdx, rdx\n\t&quot;
 8496             &quot;cmpq    $div, -1\n\t&quot;
 8497             &quot;je,s    done\n&quot;
 8498     &quot;normal: cdqq\n\t&quot;
 8499             &quot;idivq   $div\n&quot;
 8500     &quot;done:&quot;        %}
 8501   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8502   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8503   ins_pipe(pipe_slow);
 8504 %}
 8505 
 8506 //----------- DivL-By-Constant-Expansions--------------------------------------
 8507 // DivI cases are handled by the compiler
 8508 
 8509 // Magic constant, reciprocal of 10
 8510 instruct loadConL_0x6666666666666667(rRegL dst)
 8511 %{
 8512   effect(DEF dst);
 8513 
 8514   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8515   ins_encode(load_immL(dst, 0x6666666666666667));
 8516   ins_pipe(ialu_reg);
 8517 %}
 8518 
 8519 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8520 %{
 8521   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8522 
 8523   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8524   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8525   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8526   ins_pipe(ialu_reg_reg_alu0);
 8527 %}
 8528 
 8529 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8530 %{
 8531   effect(USE_DEF dst, KILL cr);
 8532 
 8533   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8534   opcode(0xC1, 0x7); /* C1 /7 ib */
 8535   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8536   ins_pipe(ialu_reg);
 8537 %}
 8538 
 8539 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8540 %{
 8541   effect(USE_DEF dst, KILL cr);
 8542 
 8543   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8544   opcode(0xC1, 0x7); /* C1 /7 ib */
 8545   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8546   ins_pipe(ialu_reg);
 8547 %}
 8548 
 8549 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8550 %{
 8551   match(Set dst (DivL src div));
 8552 
 8553   ins_cost((5+8)*100);
 8554   expand %{
 8555     rax_RegL rax;                     // Killed temp
 8556     rFlagsReg cr;                     // Killed
 8557     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8558     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8559     sarL_rReg_63(src, cr);            // sarq  src, 63
 8560     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8561     subL_rReg(dst, src, cr);          // subl  rdx, src
 8562   %}
 8563 %}
 8564 
 8565 //-----------------------------------------------------------------------------
 8566 
 8567 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8568                    rFlagsReg cr)
 8569 %{
 8570   match(Set rdx (ModI rax div));
 8571   effect(KILL rax, KILL cr);
 8572 
 8573   ins_cost(300); // XXX
 8574   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8575             &quot;jne,s   normal\n\t&quot;
 8576             &quot;xorl    rdx, rdx\n\t&quot;
 8577             &quot;cmpl    $div, -1\n\t&quot;
 8578             &quot;je,s    done\n&quot;
 8579     &quot;normal: cdql\n\t&quot;
 8580             &quot;idivl   $div\n&quot;
 8581     &quot;done:&quot;        %}
 8582   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8583   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8584   ins_pipe(ialu_reg_reg_alu0);
 8585 %}
 8586 
 8587 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8588                    rFlagsReg cr)
 8589 %{
 8590   match(Set rdx (ModL rax div));
 8591   effect(KILL rax, KILL cr);
 8592 
 8593   ins_cost(300); // XXX
 8594   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8595             &quot;cmpq    rax, rdx\n\t&quot;
 8596             &quot;jne,s   normal\n\t&quot;
 8597             &quot;xorl    rdx, rdx\n\t&quot;
 8598             &quot;cmpq    $div, -1\n\t&quot;
 8599             &quot;je,s    done\n&quot;
 8600     &quot;normal: cdqq\n\t&quot;
 8601             &quot;idivq   $div\n&quot;
 8602     &quot;done:&quot;        %}
 8603   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8604   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8605   ins_pipe(ialu_reg_reg_alu0);
 8606 %}
 8607 
 8608 // Integer Shift Instructions
 8609 // Shift Left by one
 8610 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8611 %{
 8612   match(Set dst (LShiftI dst shift));
 8613   effect(KILL cr);
 8614 
 8615   format %{ &quot;sall    $dst, $shift&quot; %}
 8616   opcode(0xD1, 0x4); /* D1 /4 */
 8617   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8618   ins_pipe(ialu_reg);
 8619 %}
 8620 
 8621 // Shift Left by one
 8622 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8623 %{
 8624   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8625   effect(KILL cr);
 8626 
 8627   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8628   opcode(0xD1, 0x4); /* D1 /4 */
 8629   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8630   ins_pipe(ialu_mem_imm);
 8631 %}
 8632 
 8633 // Shift Left by 8-bit immediate
 8634 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8635 %{
 8636   match(Set dst (LShiftI dst shift));
 8637   effect(KILL cr);
 8638 
 8639   format %{ &quot;sall    $dst, $shift&quot; %}
 8640   opcode(0xC1, 0x4); /* C1 /4 ib */
 8641   ins_encode(reg_opc_imm(dst, shift));
 8642   ins_pipe(ialu_reg);
 8643 %}
 8644 
 8645 // Shift Left by 8-bit immediate
 8646 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8647 %{
 8648   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8649   effect(KILL cr);
 8650 
 8651   format %{ &quot;sall    $dst, $shift&quot; %}
 8652   opcode(0xC1, 0x4); /* C1 /4 ib */
 8653   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8654   ins_pipe(ialu_mem_imm);
 8655 %}
 8656 
 8657 // Shift Left by variable
 8658 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8659 %{
 8660   match(Set dst (LShiftI dst shift));
 8661   effect(KILL cr);
 8662 
 8663   format %{ &quot;sall    $dst, $shift&quot; %}
 8664   opcode(0xD3, 0x4); /* D3 /4 */
 8665   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8666   ins_pipe(ialu_reg_reg);
 8667 %}
 8668 
 8669 // Shift Left by variable
 8670 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8671 %{
 8672   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8673   effect(KILL cr);
 8674 
 8675   format %{ &quot;sall    $dst, $shift&quot; %}
 8676   opcode(0xD3, 0x4); /* D3 /4 */
 8677   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8678   ins_pipe(ialu_mem_reg);
 8679 %}
 8680 
 8681 // Arithmetic shift right by one
 8682 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8683 %{
 8684   match(Set dst (RShiftI dst shift));
 8685   effect(KILL cr);
 8686 
 8687   format %{ &quot;sarl    $dst, $shift&quot; %}
 8688   opcode(0xD1, 0x7); /* D1 /7 */
 8689   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8690   ins_pipe(ialu_reg);
 8691 %}
 8692 
 8693 // Arithmetic shift right by one
 8694 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8695 %{
 8696   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8697   effect(KILL cr);
 8698 
 8699   format %{ &quot;sarl    $dst, $shift&quot; %}
 8700   opcode(0xD1, 0x7); /* D1 /7 */
 8701   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8702   ins_pipe(ialu_mem_imm);
 8703 %}
 8704 
 8705 // Arithmetic Shift Right by 8-bit immediate
 8706 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8707 %{
 8708   match(Set dst (RShiftI dst shift));
 8709   effect(KILL cr);
 8710 
 8711   format %{ &quot;sarl    $dst, $shift&quot; %}
 8712   opcode(0xC1, 0x7); /* C1 /7 ib */
 8713   ins_encode(reg_opc_imm(dst, shift));
 8714   ins_pipe(ialu_mem_imm);
 8715 %}
 8716 
 8717 // Arithmetic Shift Right by 8-bit immediate
 8718 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8719 %{
 8720   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8721   effect(KILL cr);
 8722 
 8723   format %{ &quot;sarl    $dst, $shift&quot; %}
 8724   opcode(0xC1, 0x7); /* C1 /7 ib */
 8725   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8726   ins_pipe(ialu_mem_imm);
 8727 %}
 8728 
 8729 // Arithmetic Shift Right by variable
 8730 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8731 %{
 8732   match(Set dst (RShiftI dst shift));
 8733   effect(KILL cr);
 8734 
 8735   format %{ &quot;sarl    $dst, $shift&quot; %}
 8736   opcode(0xD3, 0x7); /* D3 /7 */
 8737   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8738   ins_pipe(ialu_reg_reg);
 8739 %}
 8740 
 8741 // Arithmetic Shift Right by variable
 8742 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8743 %{
 8744   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8745   effect(KILL cr);
 8746 
 8747   format %{ &quot;sarl    $dst, $shift&quot; %}
 8748   opcode(0xD3, 0x7); /* D3 /7 */
 8749   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8750   ins_pipe(ialu_mem_reg);
 8751 %}
 8752 
 8753 // Logical shift right by one
 8754 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8755 %{
 8756   match(Set dst (URShiftI dst shift));
 8757   effect(KILL cr);
 8758 
 8759   format %{ &quot;shrl    $dst, $shift&quot; %}
 8760   opcode(0xD1, 0x5); /* D1 /5 */
 8761   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8762   ins_pipe(ialu_reg);
 8763 %}
 8764 
 8765 // Logical shift right by one
 8766 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8767 %{
 8768   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8769   effect(KILL cr);
 8770 
 8771   format %{ &quot;shrl    $dst, $shift&quot; %}
 8772   opcode(0xD1, 0x5); /* D1 /5 */
 8773   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8774   ins_pipe(ialu_mem_imm);
 8775 %}
 8776 
 8777 // Logical Shift Right by 8-bit immediate
 8778 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8779 %{
 8780   match(Set dst (URShiftI dst shift));
 8781   effect(KILL cr);
 8782 
 8783   format %{ &quot;shrl    $dst, $shift&quot; %}
 8784   opcode(0xC1, 0x5); /* C1 /5 ib */
 8785   ins_encode(reg_opc_imm(dst, shift));
 8786   ins_pipe(ialu_reg);
 8787 %}
 8788 
 8789 // Logical Shift Right by 8-bit immediate
 8790 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8791 %{
 8792   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8793   effect(KILL cr);
 8794 
 8795   format %{ &quot;shrl    $dst, $shift&quot; %}
 8796   opcode(0xC1, 0x5); /* C1 /5 ib */
 8797   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8798   ins_pipe(ialu_mem_imm);
 8799 %}
 8800 
 8801 // Logical Shift Right by variable
 8802 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8803 %{
 8804   match(Set dst (URShiftI dst shift));
 8805   effect(KILL cr);
 8806 
 8807   format %{ &quot;shrl    $dst, $shift&quot; %}
 8808   opcode(0xD3, 0x5); /* D3 /5 */
 8809   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8810   ins_pipe(ialu_reg_reg);
 8811 %}
 8812 
 8813 // Logical Shift Right by variable
 8814 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8815 %{
 8816   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8817   effect(KILL cr);
 8818 
 8819   format %{ &quot;shrl    $dst, $shift&quot; %}
 8820   opcode(0xD3, 0x5); /* D3 /5 */
 8821   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8822   ins_pipe(ialu_mem_reg);
 8823 %}
 8824 
 8825 // Long Shift Instructions
 8826 // Shift Left by one
 8827 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8828 %{
 8829   match(Set dst (LShiftL dst shift));
 8830   effect(KILL cr);
 8831 
 8832   format %{ &quot;salq    $dst, $shift&quot; %}
 8833   opcode(0xD1, 0x4); /* D1 /4 */
 8834   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8835   ins_pipe(ialu_reg);
 8836 %}
 8837 
 8838 // Shift Left by one
 8839 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8840 %{
 8841   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8842   effect(KILL cr);
 8843 
 8844   format %{ &quot;salq    $dst, $shift&quot; %}
 8845   opcode(0xD1, 0x4); /* D1 /4 */
 8846   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8847   ins_pipe(ialu_mem_imm);
 8848 %}
 8849 
 8850 // Shift Left by 8-bit immediate
 8851 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8852 %{
 8853   match(Set dst (LShiftL dst shift));
 8854   effect(KILL cr);
 8855 
 8856   format %{ &quot;salq    $dst, $shift&quot; %}
 8857   opcode(0xC1, 0x4); /* C1 /4 ib */
 8858   ins_encode(reg_opc_imm_wide(dst, shift));
 8859   ins_pipe(ialu_reg);
 8860 %}
 8861 
 8862 // Shift Left by 8-bit immediate
 8863 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8864 %{
 8865   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8866   effect(KILL cr);
 8867 
 8868   format %{ &quot;salq    $dst, $shift&quot; %}
 8869   opcode(0xC1, 0x4); /* C1 /4 ib */
 8870   ins_encode(REX_mem_wide(dst), OpcP,
 8871              RM_opc_mem(secondary, dst), Con8or32(shift));
 8872   ins_pipe(ialu_mem_imm);
 8873 %}
 8874 
 8875 // Shift Left by variable
 8876 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8877 %{
 8878   match(Set dst (LShiftL dst shift));
 8879   effect(KILL cr);
 8880 
 8881   format %{ &quot;salq    $dst, $shift&quot; %}
 8882   opcode(0xD3, 0x4); /* D3 /4 */
 8883   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8884   ins_pipe(ialu_reg_reg);
 8885 %}
 8886 
 8887 // Shift Left by variable
 8888 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8889 %{
 8890   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8891   effect(KILL cr);
 8892 
 8893   format %{ &quot;salq    $dst, $shift&quot; %}
 8894   opcode(0xD3, 0x4); /* D3 /4 */
 8895   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8896   ins_pipe(ialu_mem_reg);
 8897 %}
 8898 
 8899 // Arithmetic shift right by one
 8900 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8901 %{
 8902   match(Set dst (RShiftL dst shift));
 8903   effect(KILL cr);
 8904 
 8905   format %{ &quot;sarq    $dst, $shift&quot; %}
 8906   opcode(0xD1, 0x7); /* D1 /7 */
 8907   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8908   ins_pipe(ialu_reg);
 8909 %}
 8910 
 8911 // Arithmetic shift right by one
 8912 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8913 %{
 8914   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8915   effect(KILL cr);
 8916 
 8917   format %{ &quot;sarq    $dst, $shift&quot; %}
 8918   opcode(0xD1, 0x7); /* D1 /7 */
 8919   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8920   ins_pipe(ialu_mem_imm);
 8921 %}
 8922 
 8923 // Arithmetic Shift Right by 8-bit immediate
 8924 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8925 %{
 8926   match(Set dst (RShiftL dst shift));
 8927   effect(KILL cr);
 8928 
 8929   format %{ &quot;sarq    $dst, $shift&quot; %}
 8930   opcode(0xC1, 0x7); /* C1 /7 ib */
 8931   ins_encode(reg_opc_imm_wide(dst, shift));
 8932   ins_pipe(ialu_mem_imm);
 8933 %}
 8934 
 8935 // Arithmetic Shift Right by 8-bit immediate
 8936 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8937 %{
 8938   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8939   effect(KILL cr);
 8940 
 8941   format %{ &quot;sarq    $dst, $shift&quot; %}
 8942   opcode(0xC1, 0x7); /* C1 /7 ib */
 8943   ins_encode(REX_mem_wide(dst), OpcP,
 8944              RM_opc_mem(secondary, dst), Con8or32(shift));
 8945   ins_pipe(ialu_mem_imm);
 8946 %}
 8947 
 8948 // Arithmetic Shift Right by variable
 8949 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8950 %{
 8951   match(Set dst (RShiftL dst shift));
 8952   effect(KILL cr);
 8953 
 8954   format %{ &quot;sarq    $dst, $shift&quot; %}
 8955   opcode(0xD3, 0x7); /* D3 /7 */
 8956   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8957   ins_pipe(ialu_reg_reg);
 8958 %}
 8959 
 8960 // Arithmetic Shift Right by variable
 8961 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8962 %{
 8963   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8964   effect(KILL cr);
 8965 
 8966   format %{ &quot;sarq    $dst, $shift&quot; %}
 8967   opcode(0xD3, 0x7); /* D3 /7 */
 8968   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8969   ins_pipe(ialu_mem_reg);
 8970 %}
 8971 
 8972 // Logical shift right by one
 8973 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8974 %{
 8975   match(Set dst (URShiftL dst shift));
 8976   effect(KILL cr);
 8977 
 8978   format %{ &quot;shrq    $dst, $shift&quot; %}
 8979   opcode(0xD1, 0x5); /* D1 /5 */
 8980   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8981   ins_pipe(ialu_reg);
 8982 %}
 8983 
 8984 // Logical shift right by one
 8985 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8986 %{
 8987   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8988   effect(KILL cr);
 8989 
 8990   format %{ &quot;shrq    $dst, $shift&quot; %}
 8991   opcode(0xD1, 0x5); /* D1 /5 */
 8992   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8993   ins_pipe(ialu_mem_imm);
 8994 %}
 8995 
 8996 // Logical Shift Right by 8-bit immediate
 8997 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8998 %{
 8999   match(Set dst (URShiftL dst shift));
 9000   effect(KILL cr);
 9001 
 9002   format %{ &quot;shrq    $dst, $shift&quot; %}
 9003   opcode(0xC1, 0x5); /* C1 /5 ib */
 9004   ins_encode(reg_opc_imm_wide(dst, shift));
 9005   ins_pipe(ialu_reg);
 9006 %}
 9007 
 9008 
 9009 // Logical Shift Right by 8-bit immediate
 9010 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 9011 %{
 9012   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 9013   effect(KILL cr);
 9014 
 9015   format %{ &quot;shrq    $dst, $shift&quot; %}
 9016   opcode(0xC1, 0x5); /* C1 /5 ib */
 9017   ins_encode(REX_mem_wide(dst), OpcP,
 9018              RM_opc_mem(secondary, dst), Con8or32(shift));
 9019   ins_pipe(ialu_mem_imm);
 9020 %}
 9021 
 9022 // Logical Shift Right by variable
 9023 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 9024 %{
 9025   match(Set dst (URShiftL dst shift));
 9026   effect(KILL cr);
 9027 
 9028   format %{ &quot;shrq    $dst, $shift&quot; %}
 9029   opcode(0xD3, 0x5); /* D3 /5 */
 9030   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9031   ins_pipe(ialu_reg_reg);
 9032 %}
 9033 
 9034 // Logical Shift Right by variable
 9035 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 9036 %{
 9037   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 9038   effect(KILL cr);
 9039 
 9040   format %{ &quot;shrq    $dst, $shift&quot; %}
 9041   opcode(0xD3, 0x5); /* D3 /5 */
 9042   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 9043   ins_pipe(ialu_mem_reg);
 9044 %}
 9045 
 9046 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 9047 // This idiom is used by the compiler for the i2b bytecode.
 9048 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 9049 %{
 9050   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 9051 
 9052   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 9053   opcode(0x0F, 0xBE);
 9054   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9055   ins_pipe(ialu_reg_reg);
 9056 %}
 9057 
 9058 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 9059 // This idiom is used by the compiler the i2s bytecode.
 9060 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 9061 %{
 9062   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 9063 
 9064   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 9065   opcode(0x0F, 0xBF);
 9066   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9067   ins_pipe(ialu_reg_reg);
 9068 %}
 9069 
 9070 // ROL/ROR instructions
 9071 
 9072 // ROL expand
 9073 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 9074   effect(KILL cr, USE_DEF dst);
 9075 
 9076   format %{ &quot;roll    $dst&quot; %}
 9077   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9078   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9079   ins_pipe(ialu_reg);
 9080 %}
 9081 
 9082 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 9083   effect(USE_DEF dst, USE shift, KILL cr);
 9084 
 9085   format %{ &quot;roll    $dst, $shift&quot; %}
 9086   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9087   ins_encode( reg_opc_imm(dst, shift) );
 9088   ins_pipe(ialu_reg);
 9089 %}
 9090 
 9091 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9092 %{
 9093   effect(USE_DEF dst, USE shift, KILL cr);
 9094 
 9095   format %{ &quot;roll    $dst, $shift&quot; %}
 9096   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9097   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9098   ins_pipe(ialu_reg_reg);
 9099 %}
 9100 // end of ROL expand
 9101 
 9102 // Rotate Left by one
 9103 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9104 %{
 9105   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9106 
 9107   expand %{
 9108     rolI_rReg_imm1(dst, cr);
 9109   %}
 9110 %}
 9111 
 9112 // Rotate Left by 8-bit immediate
 9113 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9114 %{
 9115   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9116   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9117 
 9118   expand %{
 9119     rolI_rReg_imm8(dst, lshift, cr);
 9120   %}
 9121 %}
 9122 
 9123 // Rotate Left by variable
 9124 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9125 %{
 9126   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9127 
 9128   expand %{
 9129     rolI_rReg_CL(dst, shift, cr);
 9130   %}
 9131 %}
 9132 
 9133 // Rotate Left by variable
 9134 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9135 %{
 9136   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9137 
 9138   expand %{
 9139     rolI_rReg_CL(dst, shift, cr);
 9140   %}
 9141 %}
 9142 
 9143 // ROR expand
 9144 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9145 %{
 9146   effect(USE_DEF dst, KILL cr);
 9147 
 9148   format %{ &quot;rorl    $dst&quot; %}
 9149   opcode(0xD1, 0x1); /* D1 /1 */
 9150   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9151   ins_pipe(ialu_reg);
 9152 %}
 9153 
 9154 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9155 %{
 9156   effect(USE_DEF dst, USE shift, KILL cr);
 9157 
 9158   format %{ &quot;rorl    $dst, $shift&quot; %}
 9159   opcode(0xC1, 0x1); /* C1 /1 ib */
 9160   ins_encode(reg_opc_imm(dst, shift));
 9161   ins_pipe(ialu_reg);
 9162 %}
 9163 
 9164 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9165 %{
 9166   effect(USE_DEF dst, USE shift, KILL cr);
 9167 
 9168   format %{ &quot;rorl    $dst, $shift&quot; %}
 9169   opcode(0xD3, 0x1); /* D3 /1 */
 9170   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9171   ins_pipe(ialu_reg_reg);
 9172 %}
 9173 // end of ROR expand
 9174 
 9175 // Rotate Right by one
 9176 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9177 %{
 9178   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9179 
 9180   expand %{
 9181     rorI_rReg_imm1(dst, cr);
 9182   %}
 9183 %}
 9184 
 9185 // Rotate Right by 8-bit immediate
 9186 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9187 %{
 9188   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9189   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9190 
 9191   expand %{
 9192     rorI_rReg_imm8(dst, rshift, cr);
 9193   %}
 9194 %}
 9195 
 9196 // Rotate Right by variable
 9197 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9198 %{
 9199   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9200 
 9201   expand %{
 9202     rorI_rReg_CL(dst, shift, cr);
 9203   %}
 9204 %}
 9205 
 9206 // Rotate Right by variable
 9207 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9208 %{
 9209   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9210 
 9211   expand %{
 9212     rorI_rReg_CL(dst, shift, cr);
 9213   %}
 9214 %}
 9215 
 9216 // for long rotate
 9217 // ROL expand
 9218 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9219   effect(USE_DEF dst, KILL cr);
 9220 
 9221   format %{ &quot;rolq    $dst&quot; %}
 9222   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9223   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9224   ins_pipe(ialu_reg);
 9225 %}
 9226 
 9227 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9228   effect(USE_DEF dst, USE shift, KILL cr);
 9229 
 9230   format %{ &quot;rolq    $dst, $shift&quot; %}
 9231   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9232   ins_encode( reg_opc_imm_wide(dst, shift) );
 9233   ins_pipe(ialu_reg);
 9234 %}
 9235 
 9236 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9237 %{
 9238   effect(USE_DEF dst, USE shift, KILL cr);
 9239 
 9240   format %{ &quot;rolq    $dst, $shift&quot; %}
 9241   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9242   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9243   ins_pipe(ialu_reg_reg);
 9244 %}
 9245 // end of ROL expand
 9246 
 9247 // Rotate Left by one
 9248 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9249 %{
 9250   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9251 
 9252   expand %{
 9253     rolL_rReg_imm1(dst, cr);
 9254   %}
 9255 %}
 9256 
 9257 // Rotate Left by 8-bit immediate
 9258 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9259 %{
 9260   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9261   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9262 
 9263   expand %{
 9264     rolL_rReg_imm8(dst, lshift, cr);
 9265   %}
 9266 %}
 9267 
 9268 // Rotate Left by variable
 9269 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9270 %{
 9271   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9272 
 9273   expand %{
 9274     rolL_rReg_CL(dst, shift, cr);
 9275   %}
 9276 %}
 9277 
 9278 // Rotate Left by variable
 9279 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9280 %{
 9281   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9282 
 9283   expand %{
 9284     rolL_rReg_CL(dst, shift, cr);
 9285   %}
 9286 %}
 9287 
 9288 // ROR expand
 9289 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9290 %{
 9291   effect(USE_DEF dst, KILL cr);
 9292 
 9293   format %{ &quot;rorq    $dst&quot; %}
 9294   opcode(0xD1, 0x1); /* D1 /1 */
 9295   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9296   ins_pipe(ialu_reg);
 9297 %}
 9298 
 9299 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9300 %{
 9301   effect(USE_DEF dst, USE shift, KILL cr);
 9302 
 9303   format %{ &quot;rorq    $dst, $shift&quot; %}
 9304   opcode(0xC1, 0x1); /* C1 /1 ib */
 9305   ins_encode(reg_opc_imm_wide(dst, shift));
 9306   ins_pipe(ialu_reg);
 9307 %}
 9308 
 9309 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9310 %{
 9311   effect(USE_DEF dst, USE shift, KILL cr);
 9312 
 9313   format %{ &quot;rorq    $dst, $shift&quot; %}
 9314   opcode(0xD3, 0x1); /* D3 /1 */
 9315   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9316   ins_pipe(ialu_reg_reg);
 9317 %}
 9318 // end of ROR expand
 9319 
 9320 // Rotate Right by one
 9321 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9322 %{
 9323   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9324 
 9325   expand %{
 9326     rorL_rReg_imm1(dst, cr);
 9327   %}
 9328 %}
 9329 
 9330 // Rotate Right by 8-bit immediate
 9331 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9332 %{
 9333   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9334   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9335 
 9336   expand %{
 9337     rorL_rReg_imm8(dst, rshift, cr);
 9338   %}
 9339 %}
 9340 
 9341 // Rotate Right by variable
 9342 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9343 %{
 9344   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9345 
 9346   expand %{
 9347     rorL_rReg_CL(dst, shift, cr);
 9348   %}
 9349 %}
 9350 
 9351 // Rotate Right by variable
 9352 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9353 %{
 9354   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9355 
 9356   expand %{
 9357     rorL_rReg_CL(dst, shift, cr);
 9358   %}
 9359 %}
 9360 
 9361 // Logical Instructions
 9362 
 9363 // Integer Logical Instructions
 9364 
 9365 // And Instructions
 9366 // And Register with Register
 9367 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9368 %{
 9369   match(Set dst (AndI dst src));
 9370   effect(KILL cr);
 9371 
 9372   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9373   opcode(0x23);
 9374   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9375   ins_pipe(ialu_reg_reg);
 9376 %}
 9377 
 9378 // And Register with Immediate 255
 9379 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9380 %{
 9381   match(Set dst (AndI dst src));
 9382 
 9383   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9384   opcode(0x0F, 0xB6);
 9385   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9386   ins_pipe(ialu_reg);
 9387 %}
 9388 
 9389 // And Register with Immediate 255 and promote to long
 9390 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9391 %{
 9392   match(Set dst (ConvI2L (AndI src mask)));
 9393 
 9394   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9395   opcode(0x0F, 0xB6);
 9396   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9397   ins_pipe(ialu_reg);
 9398 %}
 9399 
 9400 // And Register with Immediate 65535
 9401 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9402 %{
 9403   match(Set dst (AndI dst src));
 9404 
 9405   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9406   opcode(0x0F, 0xB7);
 9407   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9408   ins_pipe(ialu_reg);
 9409 %}
 9410 
 9411 // And Register with Immediate 65535 and promote to long
 9412 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9413 %{
 9414   match(Set dst (ConvI2L (AndI src mask)));
 9415 
 9416   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9417   opcode(0x0F, 0xB7);
 9418   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9419   ins_pipe(ialu_reg);
 9420 %}
 9421 
 9422 // And Register with Immediate
 9423 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9424 %{
 9425   match(Set dst (AndI dst src));
 9426   effect(KILL cr);
 9427 
 9428   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9429   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9430   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9431   ins_pipe(ialu_reg);
 9432 %}
 9433 
 9434 // And Register with Memory
 9435 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9436 %{
 9437   match(Set dst (AndI dst (LoadI src)));
 9438   effect(KILL cr);
 9439 
 9440   ins_cost(125);
 9441   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9442   opcode(0x23);
 9443   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9444   ins_pipe(ialu_reg_mem);
 9445 %}
 9446 
 9447 // And Memory with Register
 9448 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9449 %{
 9450   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9451   effect(KILL cr);
 9452 
 9453   ins_cost(150);
 9454   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9455   opcode(0x20);
 9456   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9457   ins_pipe(ialu_mem_reg);
 9458 %}
 9459 
 9460 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9461 %{
 9462   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9463   effect(KILL cr);
 9464 
 9465   ins_cost(150);
 9466   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9467   opcode(0x21); /* Opcode 21 /r */
 9468   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9469   ins_pipe(ialu_mem_reg);
 9470 %}
 9471 
 9472 // And Memory with Immediate
 9473 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9474 %{
 9475   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9476   effect(KILL cr);
 9477 
 9478   ins_cost(125);
 9479   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9480   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9481   ins_encode(REX_mem(dst), OpcSE(src),
 9482              RM_opc_mem(secondary, dst), Con8or32(src));
 9483   ins_pipe(ialu_mem_imm);
 9484 %}
 9485 
 9486 // BMI1 instructions
 9487 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9488   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9489   predicate(UseBMI1Instructions);
 9490   effect(KILL cr);
 9491 
 9492   ins_cost(125);
 9493   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9494 
 9495   ins_encode %{
 9496     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9497   %}
 9498   ins_pipe(ialu_reg_mem);
 9499 %}
 9500 
 9501 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9502   match(Set dst (AndI (XorI src1 minus_1) src2));
 9503   predicate(UseBMI1Instructions);
 9504   effect(KILL cr);
 9505 
 9506   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9507 
 9508   ins_encode %{
 9509     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9510   %}
 9511   ins_pipe(ialu_reg);
 9512 %}
 9513 
 9514 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9515   match(Set dst (AndI (SubI imm_zero src) src));
 9516   predicate(UseBMI1Instructions);
 9517   effect(KILL cr);
 9518 
 9519   format %{ &quot;blsil  $dst, $src&quot; %}
 9520 
 9521   ins_encode %{
 9522     __ blsil($dst$$Register, $src$$Register);
 9523   %}
 9524   ins_pipe(ialu_reg);
 9525 %}
 9526 
 9527 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9528   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9529   predicate(UseBMI1Instructions);
 9530   effect(KILL cr);
 9531 
 9532   ins_cost(125);
 9533   format %{ &quot;blsil  $dst, $src&quot; %}
 9534 
 9535   ins_encode %{
 9536     __ blsil($dst$$Register, $src$$Address);
 9537   %}
 9538   ins_pipe(ialu_reg_mem);
 9539 %}
 9540 
 9541 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9542 %{
 9543   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9544   predicate(UseBMI1Instructions);
 9545   effect(KILL cr);
 9546 
 9547   ins_cost(125);
 9548   format %{ &quot;blsmskl $dst, $src&quot; %}
 9549 
 9550   ins_encode %{
 9551     __ blsmskl($dst$$Register, $src$$Address);
 9552   %}
 9553   ins_pipe(ialu_reg_mem);
 9554 %}
 9555 
 9556 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9557 %{
 9558   match(Set dst (XorI (AddI src minus_1) src));
 9559   predicate(UseBMI1Instructions);
 9560   effect(KILL cr);
 9561 
 9562   format %{ &quot;blsmskl $dst, $src&quot; %}
 9563 
 9564   ins_encode %{
 9565     __ blsmskl($dst$$Register, $src$$Register);
 9566   %}
 9567 
 9568   ins_pipe(ialu_reg);
 9569 %}
 9570 
 9571 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9572 %{
 9573   match(Set dst (AndI (AddI src minus_1) src) );
 9574   predicate(UseBMI1Instructions);
 9575   effect(KILL cr);
 9576 
 9577   format %{ &quot;blsrl  $dst, $src&quot; %}
 9578 
 9579   ins_encode %{
 9580     __ blsrl($dst$$Register, $src$$Register);
 9581   %}
 9582 
 9583   ins_pipe(ialu_reg_mem);
 9584 %}
 9585 
 9586 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9587 %{
 9588   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9589   predicate(UseBMI1Instructions);
 9590   effect(KILL cr);
 9591 
 9592   ins_cost(125);
 9593   format %{ &quot;blsrl  $dst, $src&quot; %}
 9594 
 9595   ins_encode %{
 9596     __ blsrl($dst$$Register, $src$$Address);
 9597   %}
 9598 
 9599   ins_pipe(ialu_reg);
 9600 %}
 9601 
 9602 // Or Instructions
 9603 // Or Register with Register
 9604 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9605 %{
 9606   match(Set dst (OrI dst src));
 9607   effect(KILL cr);
 9608 
 9609   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9610   opcode(0x0B);
 9611   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9612   ins_pipe(ialu_reg_reg);
 9613 %}
 9614 
 9615 // Or Register with Immediate
 9616 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9617 %{
 9618   match(Set dst (OrI dst src));
 9619   effect(KILL cr);
 9620 
 9621   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9622   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9623   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9624   ins_pipe(ialu_reg);
 9625 %}
 9626 
 9627 // Or Register with Memory
 9628 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9629 %{
 9630   match(Set dst (OrI dst (LoadI src)));
 9631   effect(KILL cr);
 9632 
 9633   ins_cost(125);
 9634   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9635   opcode(0x0B);
 9636   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9637   ins_pipe(ialu_reg_mem);
 9638 %}
 9639 
 9640 // Or Memory with Register
 9641 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9642 %{
 9643   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9644   effect(KILL cr);
 9645 
 9646   ins_cost(150);
 9647   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9648   opcode(0x08);
 9649   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9650   ins_pipe(ialu_mem_reg);
 9651 %}
 9652 
 9653 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9654 %{
 9655   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9656   effect(KILL cr);
 9657 
 9658   ins_cost(150);
 9659   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9660   opcode(0x09); /* Opcode 09 /r */
 9661   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9662   ins_pipe(ialu_mem_reg);
 9663 %}
 9664 
 9665 // Or Memory with Immediate
 9666 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9667 %{
 9668   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9669   effect(KILL cr);
 9670 
 9671   ins_cost(125);
 9672   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9673   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9674   ins_encode(REX_mem(dst), OpcSE(src),
 9675              RM_opc_mem(secondary, dst), Con8or32(src));
 9676   ins_pipe(ialu_mem_imm);
 9677 %}
 9678 
 9679 // Xor Instructions
 9680 // Xor Register with Register
 9681 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9682 %{
 9683   match(Set dst (XorI dst src));
 9684   effect(KILL cr);
 9685 
 9686   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9687   opcode(0x33);
 9688   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9689   ins_pipe(ialu_reg_reg);
 9690 %}
 9691 
 9692 // Xor Register with Immediate -1
 9693 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9694   match(Set dst (XorI dst imm));
 9695 
 9696   format %{ &quot;not    $dst&quot; %}
 9697   ins_encode %{
 9698      __ notl($dst$$Register);
 9699   %}
 9700   ins_pipe(ialu_reg);
 9701 %}
 9702 
 9703 // Xor Register with Immediate
 9704 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9705 %{
 9706   match(Set dst (XorI dst src));
 9707   effect(KILL cr);
 9708 
 9709   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9710   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9711   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9712   ins_pipe(ialu_reg);
 9713 %}
 9714 
 9715 // Xor Register with Memory
 9716 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9717 %{
 9718   match(Set dst (XorI dst (LoadI src)));
 9719   effect(KILL cr);
 9720 
 9721   ins_cost(125);
 9722   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9723   opcode(0x33);
 9724   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9725   ins_pipe(ialu_reg_mem);
 9726 %}
 9727 
 9728 // Xor Memory with Register
 9729 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9730 %{
 9731   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9732   effect(KILL cr);
 9733 
 9734   ins_cost(150);
 9735   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9736   opcode(0x30);
 9737   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9738   ins_pipe(ialu_mem_reg);
 9739 %}
 9740 
 9741 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9742 %{
 9743   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9744   effect(KILL cr);
 9745 
 9746   ins_cost(150);
 9747   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9748   opcode(0x31); /* Opcode 31 /r */
 9749   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9750   ins_pipe(ialu_mem_reg);
 9751 %}
 9752 
 9753 // Xor Memory with Immediate
 9754 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9755 %{
 9756   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9757   effect(KILL cr);
 9758 
 9759   ins_cost(125);
 9760   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9761   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9762   ins_encode(REX_mem(dst), OpcSE(src),
 9763              RM_opc_mem(secondary, dst), Con8or32(src));
 9764   ins_pipe(ialu_mem_imm);
 9765 %}
 9766 
 9767 
 9768 // Long Logical Instructions
 9769 
 9770 // And Instructions
 9771 // And Register with Register
 9772 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9773 %{
 9774   match(Set dst (AndL dst src));
 9775   effect(KILL cr);
 9776 
 9777   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9778   opcode(0x23);
 9779   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9780   ins_pipe(ialu_reg_reg);
 9781 %}
 9782 
 9783 // And Register with Immediate 255
 9784 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9785 %{
 9786   match(Set dst (AndL dst src));
 9787 
 9788   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9789   opcode(0x0F, 0xB6);
 9790   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9791   ins_pipe(ialu_reg);
 9792 %}
 9793 
 9794 // And Register with Immediate 65535
 9795 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9796 %{
 9797   match(Set dst (AndL dst src));
 9798 
 9799   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9800   opcode(0x0F, 0xB7);
 9801   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9802   ins_pipe(ialu_reg);
 9803 %}
 9804 
 9805 // And Register with Immediate
 9806 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9807 %{
 9808   match(Set dst (AndL dst src));
 9809   effect(KILL cr);
 9810 
 9811   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9812   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9813   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9814   ins_pipe(ialu_reg);
 9815 %}
 9816 
 9817 // And Register with Memory
 9818 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9819 %{
 9820   match(Set dst (AndL dst (LoadL src)));
 9821   effect(KILL cr);
 9822 
 9823   ins_cost(125);
 9824   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9825   opcode(0x23);
 9826   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9827   ins_pipe(ialu_reg_mem);
 9828 %}
 9829 
 9830 // And Memory with Register
 9831 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9832 %{
 9833   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9834   effect(KILL cr);
 9835 
 9836   ins_cost(150);
 9837   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9838   opcode(0x21); /* Opcode 21 /r */
 9839   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9840   ins_pipe(ialu_mem_reg);
 9841 %}
 9842 
 9843 // And Memory with Immediate
 9844 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9845 %{
 9846   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9847   effect(KILL cr);
 9848 
 9849   ins_cost(125);
 9850   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9851   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9852   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9853              RM_opc_mem(secondary, dst), Con8or32(src));
 9854   ins_pipe(ialu_mem_imm);
 9855 %}
 9856 
 9857 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9858 %{
 9859   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9860   // because AND/OR works well enough for 8/32-bit values.
 9861   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9862 
 9863   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9864   effect(KILL cr);
 9865 
 9866   ins_cost(125);
 9867   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9868   ins_encode %{
 9869     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9870   %}
 9871   ins_pipe(ialu_mem_imm);
 9872 %}
 9873 
 9874 // BMI1 instructions
 9875 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9876   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9877   predicate(UseBMI1Instructions);
 9878   effect(KILL cr);
 9879 
 9880   ins_cost(125);
 9881   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9882 
 9883   ins_encode %{
 9884     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9885   %}
 9886   ins_pipe(ialu_reg_mem);
 9887 %}
 9888 
 9889 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9890   match(Set dst (AndL (XorL src1 minus_1) src2));
 9891   predicate(UseBMI1Instructions);
 9892   effect(KILL cr);
 9893 
 9894   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9895 
 9896   ins_encode %{
 9897   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9898   %}
 9899   ins_pipe(ialu_reg_mem);
 9900 %}
 9901 
 9902 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9903   match(Set dst (AndL (SubL imm_zero src) src));
 9904   predicate(UseBMI1Instructions);
 9905   effect(KILL cr);
 9906 
 9907   format %{ &quot;blsiq  $dst, $src&quot; %}
 9908 
 9909   ins_encode %{
 9910     __ blsiq($dst$$Register, $src$$Register);
 9911   %}
 9912   ins_pipe(ialu_reg);
 9913 %}
 9914 
 9915 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9916   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9917   predicate(UseBMI1Instructions);
 9918   effect(KILL cr);
 9919 
 9920   ins_cost(125);
 9921   format %{ &quot;blsiq  $dst, $src&quot; %}
 9922 
 9923   ins_encode %{
 9924     __ blsiq($dst$$Register, $src$$Address);
 9925   %}
 9926   ins_pipe(ialu_reg_mem);
 9927 %}
 9928 
 9929 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9930 %{
 9931   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9932   predicate(UseBMI1Instructions);
 9933   effect(KILL cr);
 9934 
 9935   ins_cost(125);
 9936   format %{ &quot;blsmskq $dst, $src&quot; %}
 9937 
 9938   ins_encode %{
 9939     __ blsmskq($dst$$Register, $src$$Address);
 9940   %}
 9941   ins_pipe(ialu_reg_mem);
 9942 %}
 9943 
 9944 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9945 %{
 9946   match(Set dst (XorL (AddL src minus_1) src));
 9947   predicate(UseBMI1Instructions);
 9948   effect(KILL cr);
 9949 
 9950   format %{ &quot;blsmskq $dst, $src&quot; %}
 9951 
 9952   ins_encode %{
 9953     __ blsmskq($dst$$Register, $src$$Register);
 9954   %}
 9955 
 9956   ins_pipe(ialu_reg);
 9957 %}
 9958 
 9959 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9960 %{
 9961   match(Set dst (AndL (AddL src minus_1) src) );
 9962   predicate(UseBMI1Instructions);
 9963   effect(KILL cr);
 9964 
 9965   format %{ &quot;blsrq  $dst, $src&quot; %}
 9966 
 9967   ins_encode %{
 9968     __ blsrq($dst$$Register, $src$$Register);
 9969   %}
 9970 
 9971   ins_pipe(ialu_reg);
 9972 %}
 9973 
 9974 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9975 %{
 9976   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9977   predicate(UseBMI1Instructions);
 9978   effect(KILL cr);
 9979 
 9980   ins_cost(125);
 9981   format %{ &quot;blsrq  $dst, $src&quot; %}
 9982 
 9983   ins_encode %{
 9984     __ blsrq($dst$$Register, $src$$Address);
 9985   %}
 9986 
 9987   ins_pipe(ialu_reg);
 9988 %}
 9989 
 9990 // Or Instructions
 9991 // Or Register with Register
 9992 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9993 %{
 9994   match(Set dst (OrL dst src));
 9995   effect(KILL cr);
 9996 
 9997   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9998   opcode(0x0B);
 9999   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10000   ins_pipe(ialu_reg_reg);
10001 %}
10002 
10003 // Use any_RegP to match R15 (TLS register) without spilling.
10004 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
10005   match(Set dst (OrL dst (CastP2X src)));
10006   effect(KILL cr);
10007 
10008   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10009   opcode(0x0B);
10010   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10011   ins_pipe(ialu_reg_reg);
10012 %}
10013 
10014 
10015 // Or Register with Immediate
10016 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10017 %{
10018   match(Set dst (OrL dst src));
10019   effect(KILL cr);
10020 
10021   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10022   opcode(0x81, 0x01); /* Opcode 81 /1 id */
10023   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10024   ins_pipe(ialu_reg);
10025 %}
10026 
10027 // Or Register with Memory
10028 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10029 %{
10030   match(Set dst (OrL dst (LoadL src)));
10031   effect(KILL cr);
10032 
10033   ins_cost(125);
10034   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10035   opcode(0x0B);
10036   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10037   ins_pipe(ialu_reg_mem);
10038 %}
10039 
10040 // Or Memory with Register
10041 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10042 %{
10043   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10044   effect(KILL cr);
10045 
10046   ins_cost(150);
10047   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10048   opcode(0x09); /* Opcode 09 /r */
10049   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10050   ins_pipe(ialu_mem_reg);
10051 %}
10052 
10053 // Or Memory with Immediate
10054 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10055 %{
10056   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10057   effect(KILL cr);
10058 
10059   ins_cost(125);
10060   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10061   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10062   ins_encode(REX_mem_wide(dst), OpcSE(src),
10063              RM_opc_mem(secondary, dst), Con8or32(src));
10064   ins_pipe(ialu_mem_imm);
10065 %}
10066 
10067 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
10068 %{
10069   // con should be a pure 64-bit power of 2 immediate
10070   // because AND/OR works well enough for 8/32-bit values.
10071   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
10072 
10073   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
10074   effect(KILL cr);
10075 
10076   ins_cost(125);
10077   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
10078   ins_encode %{
10079     __ btsq($dst$$Address, log2_long($con$$constant));
10080   %}
10081   ins_pipe(ialu_mem_imm);
10082 %}
10083 
10084 // Xor Instructions
10085 // Xor Register with Register
10086 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10087 %{
10088   match(Set dst (XorL dst src));
10089   effect(KILL cr);
10090 
10091   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10092   opcode(0x33);
10093   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10094   ins_pipe(ialu_reg_reg);
10095 %}
10096 
10097 // Xor Register with Immediate -1
10098 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10099   match(Set dst (XorL dst imm));
10100 
10101   format %{ &quot;notq   $dst&quot; %}
10102   ins_encode %{
10103      __ notq($dst$$Register);
10104   %}
10105   ins_pipe(ialu_reg);
10106 %}
10107 
10108 // Xor Register with Immediate
10109 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10110 %{
10111   match(Set dst (XorL dst src));
10112   effect(KILL cr);
10113 
10114   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10115   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10116   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10117   ins_pipe(ialu_reg);
10118 %}
10119 
10120 // Xor Register with Memory
10121 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10122 %{
10123   match(Set dst (XorL dst (LoadL src)));
10124   effect(KILL cr);
10125 
10126   ins_cost(125);
10127   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10128   opcode(0x33);
10129   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10130   ins_pipe(ialu_reg_mem);
10131 %}
10132 
10133 // Xor Memory with Register
10134 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10135 %{
10136   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10137   effect(KILL cr);
10138 
10139   ins_cost(150);
10140   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10141   opcode(0x31); /* Opcode 31 /r */
10142   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10143   ins_pipe(ialu_mem_reg);
10144 %}
10145 
10146 // Xor Memory with Immediate
10147 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10148 %{
10149   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10150   effect(KILL cr);
10151 
10152   ins_cost(125);
10153   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10154   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10155   ins_encode(REX_mem_wide(dst), OpcSE(src),
10156              RM_opc_mem(secondary, dst), Con8or32(src));
10157   ins_pipe(ialu_mem_imm);
10158 %}
10159 
10160 // Convert Int to Boolean
10161 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10162 %{
10163   match(Set dst (Conv2B src));
10164   effect(KILL cr);
10165 
10166   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10167             &quot;setnz   $dst\n\t&quot;
10168             &quot;movzbl  $dst, $dst&quot; %}
10169   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10170              setNZ_reg(dst),
10171              REX_reg_breg(dst, dst), // movzbl
10172              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10173   ins_pipe(pipe_slow); // XXX
10174 %}
10175 
10176 // Convert Pointer to Boolean
10177 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10178 %{
10179   match(Set dst (Conv2B src));
10180   effect(KILL cr);
10181 
10182   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10183             &quot;setnz   $dst\n\t&quot;
10184             &quot;movzbl  $dst, $dst&quot; %}
10185   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10186              setNZ_reg(dst),
10187              REX_reg_breg(dst, dst), // movzbl
10188              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10189   ins_pipe(pipe_slow); // XXX
10190 %}
10191 
10192 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10193 %{
10194   match(Set dst (CmpLTMask p q));
10195   effect(KILL cr);
10196 
10197   ins_cost(400);
10198   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10199             &quot;setlt   $dst\n\t&quot;
10200             &quot;movzbl  $dst, $dst\n\t&quot;
10201             &quot;negl    $dst&quot; %}
10202   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10203              setLT_reg(dst),
10204              REX_reg_breg(dst, dst), // movzbl
10205              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10206              neg_reg(dst));
10207   ins_pipe(pipe_slow);
10208 %}
10209 
10210 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10211 %{
10212   match(Set dst (CmpLTMask dst zero));
10213   effect(KILL cr);
10214 
10215   ins_cost(100);
10216   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10217   ins_encode %{
10218   __ sarl($dst$$Register, 31);
10219   %}
10220   ins_pipe(ialu_reg);
10221 %}
10222 
10223 /* Better to save a register than avoid a branch */
10224 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10225 %{
10226   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10227   effect(KILL cr);
10228   ins_cost(300);
10229   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10230             &quot;jge     done\n\t&quot;
10231             &quot;addl    $p,$y\n&quot;
10232             &quot;done:   &quot; %}
10233   ins_encode %{
10234     Register Rp = $p$$Register;
10235     Register Rq = $q$$Register;
10236     Register Ry = $y$$Register;
10237     Label done;
10238     __ subl(Rp, Rq);
10239     __ jccb(Assembler::greaterEqual, done);
10240     __ addl(Rp, Ry);
10241     __ bind(done);
10242   %}
10243   ins_pipe(pipe_cmplt);
10244 %}
10245 
10246 /* Better to save a register than avoid a branch */
10247 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10248 %{
10249   match(Set y (AndI (CmpLTMask p q) y));
10250   effect(KILL cr);
10251 
10252   ins_cost(300);
10253 
10254   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10255             &quot;jlt     done\n\t&quot;
10256             &quot;xorl    $y, $y\n&quot;
10257             &quot;done:   &quot; %}
10258   ins_encode %{
10259     Register Rp = $p$$Register;
10260     Register Rq = $q$$Register;
10261     Register Ry = $y$$Register;
10262     Label done;
10263     __ cmpl(Rp, Rq);
10264     __ jccb(Assembler::less, done);
10265     __ xorl(Ry, Ry);
10266     __ bind(done);
10267   %}
10268   ins_pipe(pipe_cmplt);
10269 %}
10270 
10271 
10272 //---------- FP Instructions------------------------------------------------
10273 
10274 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10275 %{
10276   match(Set cr (CmpF src1 src2));
10277 
10278   ins_cost(145);
10279   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10280             &quot;jnp,s   exit\n\t&quot;
10281             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10282             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10283             &quot;popfq\n&quot;
10284     &quot;exit:&quot; %}
10285   ins_encode %{
10286     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10287     emit_cmpfp_fixup(_masm);
10288   %}
10289   ins_pipe(pipe_slow);
10290 %}
10291 
10292 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10293   match(Set cr (CmpF src1 src2));
10294 
10295   ins_cost(100);
10296   format %{ &quot;ucomiss $src1, $src2&quot; %}
10297   ins_encode %{
10298     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10299   %}
10300   ins_pipe(pipe_slow);
10301 %}
10302 
10303 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10304 %{
10305   match(Set cr (CmpF src1 (LoadF src2)));
10306 
10307   ins_cost(145);
10308   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10309             &quot;jnp,s   exit\n\t&quot;
10310             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10311             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10312             &quot;popfq\n&quot;
10313     &quot;exit:&quot; %}
10314   ins_encode %{
10315     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10316     emit_cmpfp_fixup(_masm);
10317   %}
10318   ins_pipe(pipe_slow);
10319 %}
10320 
10321 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10322   match(Set cr (CmpF src1 (LoadF src2)));
10323 
10324   ins_cost(100);
10325   format %{ &quot;ucomiss $src1, $src2&quot; %}
10326   ins_encode %{
10327     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10328   %}
10329   ins_pipe(pipe_slow);
10330 %}
10331 
10332 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10333   match(Set cr (CmpF src con));
10334 
10335   ins_cost(145);
10336   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10337             &quot;jnp,s   exit\n\t&quot;
10338             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10339             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10340             &quot;popfq\n&quot;
10341     &quot;exit:&quot; %}
10342   ins_encode %{
10343     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10344     emit_cmpfp_fixup(_masm);
10345   %}
10346   ins_pipe(pipe_slow);
10347 %}
10348 
10349 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10350   match(Set cr (CmpF src con));
10351   ins_cost(100);
10352   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10353   ins_encode %{
10354     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10355   %}
10356   ins_pipe(pipe_slow);
10357 %}
10358 
10359 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10360 %{
10361   match(Set cr (CmpD src1 src2));
10362 
10363   ins_cost(145);
10364   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10365             &quot;jnp,s   exit\n\t&quot;
10366             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10367             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10368             &quot;popfq\n&quot;
10369     &quot;exit:&quot; %}
10370   ins_encode %{
10371     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10372     emit_cmpfp_fixup(_masm);
10373   %}
10374   ins_pipe(pipe_slow);
10375 %}
10376 
10377 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10378   match(Set cr (CmpD src1 src2));
10379 
10380   ins_cost(100);
10381   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10382   ins_encode %{
10383     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10384   %}
10385   ins_pipe(pipe_slow);
10386 %}
10387 
10388 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10389 %{
10390   match(Set cr (CmpD src1 (LoadD src2)));
10391 
10392   ins_cost(145);
10393   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10394             &quot;jnp,s   exit\n\t&quot;
10395             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10396             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10397             &quot;popfq\n&quot;
10398     &quot;exit:&quot; %}
10399   ins_encode %{
10400     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10401     emit_cmpfp_fixup(_masm);
10402   %}
10403   ins_pipe(pipe_slow);
10404 %}
10405 
10406 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10407   match(Set cr (CmpD src1 (LoadD src2)));
10408 
10409   ins_cost(100);
10410   format %{ &quot;ucomisd $src1, $src2&quot; %}
10411   ins_encode %{
10412     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10413   %}
10414   ins_pipe(pipe_slow);
10415 %}
10416 
10417 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10418   match(Set cr (CmpD src con));
10419 
10420   ins_cost(145);
10421   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10422             &quot;jnp,s   exit\n\t&quot;
10423             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10424             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10425             &quot;popfq\n&quot;
10426     &quot;exit:&quot; %}
10427   ins_encode %{
10428     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10429     emit_cmpfp_fixup(_masm);
10430   %}
10431   ins_pipe(pipe_slow);
10432 %}
10433 
10434 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10435   match(Set cr (CmpD src con));
10436   ins_cost(100);
10437   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10438   ins_encode %{
10439     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10440   %}
10441   ins_pipe(pipe_slow);
10442 %}
10443 
10444 // Compare into -1,0,1
10445 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10446 %{
10447   match(Set dst (CmpF3 src1 src2));
10448   effect(KILL cr);
10449 
10450   ins_cost(275);
10451   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10452             &quot;movl    $dst, #-1\n\t&quot;
10453             &quot;jp,s    done\n\t&quot;
10454             &quot;jb,s    done\n\t&quot;
10455             &quot;setne   $dst\n\t&quot;
10456             &quot;movzbl  $dst, $dst\n&quot;
10457     &quot;done:&quot; %}
10458   ins_encode %{
10459     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10460     emit_cmpfp3(_masm, $dst$$Register);
10461   %}
10462   ins_pipe(pipe_slow);
10463 %}
10464 
10465 // Compare into -1,0,1
10466 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10467 %{
10468   match(Set dst (CmpF3 src1 (LoadF src2)));
10469   effect(KILL cr);
10470 
10471   ins_cost(275);
10472   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10473             &quot;movl    $dst, #-1\n\t&quot;
10474             &quot;jp,s    done\n\t&quot;
10475             &quot;jb,s    done\n\t&quot;
10476             &quot;setne   $dst\n\t&quot;
10477             &quot;movzbl  $dst, $dst\n&quot;
10478     &quot;done:&quot; %}
10479   ins_encode %{
10480     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10481     emit_cmpfp3(_masm, $dst$$Register);
10482   %}
10483   ins_pipe(pipe_slow);
10484 %}
10485 
10486 // Compare into -1,0,1
10487 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10488   match(Set dst (CmpF3 src con));
10489   effect(KILL cr);
10490 
10491   ins_cost(275);
10492   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10493             &quot;movl    $dst, #-1\n\t&quot;
10494             &quot;jp,s    done\n\t&quot;
10495             &quot;jb,s    done\n\t&quot;
10496             &quot;setne   $dst\n\t&quot;
10497             &quot;movzbl  $dst, $dst\n&quot;
10498     &quot;done:&quot; %}
10499   ins_encode %{
10500     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10501     emit_cmpfp3(_masm, $dst$$Register);
10502   %}
10503   ins_pipe(pipe_slow);
10504 %}
10505 
10506 // Compare into -1,0,1
10507 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10508 %{
10509   match(Set dst (CmpD3 src1 src2));
10510   effect(KILL cr);
10511 
10512   ins_cost(275);
10513   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10514             &quot;movl    $dst, #-1\n\t&quot;
10515             &quot;jp,s    done\n\t&quot;
10516             &quot;jb,s    done\n\t&quot;
10517             &quot;setne   $dst\n\t&quot;
10518             &quot;movzbl  $dst, $dst\n&quot;
10519     &quot;done:&quot; %}
10520   ins_encode %{
10521     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10522     emit_cmpfp3(_masm, $dst$$Register);
10523   %}
10524   ins_pipe(pipe_slow);
10525 %}
10526 
10527 // Compare into -1,0,1
10528 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10529 %{
10530   match(Set dst (CmpD3 src1 (LoadD src2)));
10531   effect(KILL cr);
10532 
10533   ins_cost(275);
10534   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10535             &quot;movl    $dst, #-1\n\t&quot;
10536             &quot;jp,s    done\n\t&quot;
10537             &quot;jb,s    done\n\t&quot;
10538             &quot;setne   $dst\n\t&quot;
10539             &quot;movzbl  $dst, $dst\n&quot;
10540     &quot;done:&quot; %}
10541   ins_encode %{
10542     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10543     emit_cmpfp3(_masm, $dst$$Register);
10544   %}
10545   ins_pipe(pipe_slow);
10546 %}
10547 
10548 // Compare into -1,0,1
10549 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10550   match(Set dst (CmpD3 src con));
10551   effect(KILL cr);
10552 
10553   ins_cost(275);
10554   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10555             &quot;movl    $dst, #-1\n\t&quot;
10556             &quot;jp,s    done\n\t&quot;
10557             &quot;jb,s    done\n\t&quot;
10558             &quot;setne   $dst\n\t&quot;
10559             &quot;movzbl  $dst, $dst\n&quot;
10560     &quot;done:&quot; %}
10561   ins_encode %{
10562     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10563     emit_cmpfp3(_masm, $dst$$Register);
10564   %}
10565   ins_pipe(pipe_slow);
10566 %}
10567 
10568 //----------Arithmetic Conversion Instructions---------------------------------
10569 
10570 instruct convF2D_reg_reg(regD dst, regF src)
10571 %{
10572   match(Set dst (ConvF2D src));
10573 
10574   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10575   ins_encode %{
10576     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10577   %}
10578   ins_pipe(pipe_slow); // XXX
10579 %}
10580 
10581 instruct convF2D_reg_mem(regD dst, memory src)
10582 %{
10583   match(Set dst (ConvF2D (LoadF src)));
10584 
10585   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10586   ins_encode %{
10587     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10588   %}
10589   ins_pipe(pipe_slow); // XXX
10590 %}
10591 
10592 instruct convD2F_reg_reg(regF dst, regD src)
10593 %{
10594   match(Set dst (ConvD2F src));
10595 
10596   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10597   ins_encode %{
10598     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10599   %}
10600   ins_pipe(pipe_slow); // XXX
10601 %}
10602 
10603 instruct convD2F_reg_mem(regF dst, memory src)
10604 %{
10605   match(Set dst (ConvD2F (LoadD src)));
10606 
10607   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10608   ins_encode %{
10609     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10610   %}
10611   ins_pipe(pipe_slow); // XXX
10612 %}
10613 
10614 // XXX do mem variants
10615 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10616 %{
10617   match(Set dst (ConvF2I src));
10618   effect(KILL cr);
10619   format %{ &quot;convert_f2i $dst,$src&quot; %}
10620   ins_encode %{
10621     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10622   %}
10623   ins_pipe(pipe_slow);
10624 %}
10625 
10626 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10627 %{
10628   match(Set dst (ConvF2L src));
10629   effect(KILL cr);
10630   format %{ &quot;convert_f2l $dst,$src&quot;%}
10631   ins_encode %{
10632     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10633   %}
10634   ins_pipe(pipe_slow);
10635 %}
10636 
10637 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10638 %{
10639   match(Set dst (ConvD2I src));
10640   effect(KILL cr);
10641   format %{ &quot;convert_d2i $dst,$src&quot;%}
10642   ins_encode %{
10643     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10644   %}
10645   ins_pipe(pipe_slow);
10646 %}
10647 
10648 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10649 %{
10650   match(Set dst (ConvD2L src));
10651   effect(KILL cr);
10652   format %{ &quot;convert_d2l $dst,$src&quot;%}
10653   ins_encode %{
10654     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10655   %}
10656   ins_pipe(pipe_slow);
10657 %}
10658 
10659 instruct convI2F_reg_reg(regF dst, rRegI src)
10660 %{
10661   predicate(!UseXmmI2F);
10662   match(Set dst (ConvI2F src));
10663 
10664   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10665   ins_encode %{
10666     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10667   %}
10668   ins_pipe(pipe_slow); // XXX
10669 %}
10670 
10671 instruct convI2F_reg_mem(regF dst, memory src)
10672 %{
10673   match(Set dst (ConvI2F (LoadI src)));
10674 
10675   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10676   ins_encode %{
10677     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10678   %}
10679   ins_pipe(pipe_slow); // XXX
10680 %}
10681 
10682 instruct convI2D_reg_reg(regD dst, rRegI src)
10683 %{
10684   predicate(!UseXmmI2D);
10685   match(Set dst (ConvI2D src));
10686 
10687   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10688   ins_encode %{
10689     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10690   %}
10691   ins_pipe(pipe_slow); // XXX
10692 %}
10693 
10694 instruct convI2D_reg_mem(regD dst, memory src)
10695 %{
10696   match(Set dst (ConvI2D (LoadI src)));
10697 
10698   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10699   ins_encode %{
10700     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10701   %}
10702   ins_pipe(pipe_slow); // XXX
10703 %}
10704 
10705 instruct convXI2F_reg(regF dst, rRegI src)
10706 %{
10707   predicate(UseXmmI2F);
10708   match(Set dst (ConvI2F src));
10709 
10710   format %{ &quot;movdl $dst, $src\n\t&quot;
10711             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10712   ins_encode %{
10713     __ movdl($dst$$XMMRegister, $src$$Register);
10714     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10715   %}
10716   ins_pipe(pipe_slow); // XXX
10717 %}
10718 
10719 instruct convXI2D_reg(regD dst, rRegI src)
10720 %{
10721   predicate(UseXmmI2D);
10722   match(Set dst (ConvI2D src));
10723 
10724   format %{ &quot;movdl $dst, $src\n\t&quot;
10725             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10726   ins_encode %{
10727     __ movdl($dst$$XMMRegister, $src$$Register);
10728     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10729   %}
10730   ins_pipe(pipe_slow); // XXX
10731 %}
10732 
10733 instruct convL2F_reg_reg(regF dst, rRegL src)
10734 %{
10735   match(Set dst (ConvL2F src));
10736 
10737   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10738   ins_encode %{
10739     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10740   %}
10741   ins_pipe(pipe_slow); // XXX
10742 %}
10743 
10744 instruct convL2F_reg_mem(regF dst, memory src)
10745 %{
10746   match(Set dst (ConvL2F (LoadL src)));
10747 
10748   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10749   ins_encode %{
10750     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10751   %}
10752   ins_pipe(pipe_slow); // XXX
10753 %}
10754 
10755 instruct convL2D_reg_reg(regD dst, rRegL src)
10756 %{
10757   match(Set dst (ConvL2D src));
10758 
10759   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10760   ins_encode %{
10761     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10762   %}
10763   ins_pipe(pipe_slow); // XXX
10764 %}
10765 
10766 instruct convL2D_reg_mem(regD dst, memory src)
10767 %{
10768   match(Set dst (ConvL2D (LoadL src)));
10769 
10770   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10771   ins_encode %{
10772     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10773   %}
10774   ins_pipe(pipe_slow); // XXX
10775 %}
10776 
10777 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10778 %{
10779   match(Set dst (ConvI2L src));
10780 
10781   ins_cost(125);
10782   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10783   ins_encode %{
10784     __ movslq($dst$$Register, $src$$Register);
10785   %}
10786   ins_pipe(ialu_reg_reg);
10787 %}
10788 
10789 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10790 // %{
10791 //   match(Set dst (ConvI2L src));
10792 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10793 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10794 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10795 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10796 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10797 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10798 
10799 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10800 //   ins_encode(enc_copy(dst, src));
10801 // //   opcode(0x63); // needs REX.W
10802 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10803 //   ins_pipe(ialu_reg_reg);
10804 // %}
10805 
10806 // Zero-extend convert int to long
10807 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10808 %{
10809   match(Set dst (AndL (ConvI2L src) mask));
10810 
10811   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10812   ins_encode %{
10813     if ($dst$$reg != $src$$reg) {
10814       __ movl($dst$$Register, $src$$Register);
10815     }
10816   %}
10817   ins_pipe(ialu_reg_reg);
10818 %}
10819 
10820 // Zero-extend convert int to long
10821 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10822 %{
10823   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10824 
10825   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10826   ins_encode %{
10827     __ movl($dst$$Register, $src$$Address);
10828   %}
10829   ins_pipe(ialu_reg_mem);
10830 %}
10831 
10832 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10833 %{
10834   match(Set dst (AndL src mask));
10835 
10836   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10837   ins_encode %{
10838     __ movl($dst$$Register, $src$$Register);
10839   %}
10840   ins_pipe(ialu_reg_reg);
10841 %}
10842 
10843 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10844 %{
10845   match(Set dst (ConvL2I src));
10846 
10847   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10848   ins_encode %{
10849     __ movl($dst$$Register, $src$$Register);
10850   %}
10851   ins_pipe(ialu_reg_reg);
10852 %}
10853 
10854 
10855 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10856   match(Set dst (MoveF2I src));
10857   effect(DEF dst, USE src);
10858 
10859   ins_cost(125);
10860   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10861   ins_encode %{
10862     __ movl($dst$$Register, Address(rsp, $src$$disp));
10863   %}
10864   ins_pipe(ialu_reg_mem);
10865 %}
10866 
10867 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10868   match(Set dst (MoveI2F src));
10869   effect(DEF dst, USE src);
10870 
10871   ins_cost(125);
10872   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10873   ins_encode %{
10874     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10875   %}
10876   ins_pipe(pipe_slow);
10877 %}
10878 
10879 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10880   match(Set dst (MoveD2L src));
10881   effect(DEF dst, USE src);
10882 
10883   ins_cost(125);
10884   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10885   ins_encode %{
10886     __ movq($dst$$Register, Address(rsp, $src$$disp));
10887   %}
10888   ins_pipe(ialu_reg_mem);
10889 %}
10890 
10891 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10892   predicate(!UseXmmLoadAndClearUpper);
10893   match(Set dst (MoveL2D src));
10894   effect(DEF dst, USE src);
10895 
10896   ins_cost(125);
10897   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10898   ins_encode %{
10899     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10900   %}
10901   ins_pipe(pipe_slow);
10902 %}
10903 
10904 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10905   predicate(UseXmmLoadAndClearUpper);
10906   match(Set dst (MoveL2D src));
10907   effect(DEF dst, USE src);
10908 
10909   ins_cost(125);
10910   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10911   ins_encode %{
10912     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10913   %}
10914   ins_pipe(pipe_slow);
10915 %}
10916 
10917 
10918 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10919   match(Set dst (MoveF2I src));
10920   effect(DEF dst, USE src);
10921 
10922   ins_cost(95); // XXX
10923   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10924   ins_encode %{
10925     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10926   %}
10927   ins_pipe(pipe_slow);
10928 %}
10929 
10930 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10931   match(Set dst (MoveI2F src));
10932   effect(DEF dst, USE src);
10933 
10934   ins_cost(100);
10935   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10936   ins_encode %{
10937     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10938   %}
10939   ins_pipe( ialu_mem_reg );
10940 %}
10941 
10942 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10943   match(Set dst (MoveD2L src));
10944   effect(DEF dst, USE src);
10945 
10946   ins_cost(95); // XXX
10947   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10948   ins_encode %{
10949     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10950   %}
10951   ins_pipe(pipe_slow);
10952 %}
10953 
10954 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10955   match(Set dst (MoveL2D src));
10956   effect(DEF dst, USE src);
10957 
10958   ins_cost(100);
10959   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10960   ins_encode %{
10961     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10962   %}
10963   ins_pipe(ialu_mem_reg);
10964 %}
10965 
10966 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10967   match(Set dst (MoveF2I src));
10968   effect(DEF dst, USE src);
10969   ins_cost(85);
10970   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10971   ins_encode %{
10972     __ movdl($dst$$Register, $src$$XMMRegister);
10973   %}
10974   ins_pipe( pipe_slow );
10975 %}
10976 
10977 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10978   match(Set dst (MoveD2L src));
10979   effect(DEF dst, USE src);
10980   ins_cost(85);
10981   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10982   ins_encode %{
10983     __ movdq($dst$$Register, $src$$XMMRegister);
10984   %}
10985   ins_pipe( pipe_slow );
10986 %}
10987 
10988 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10989   match(Set dst (MoveI2F src));
10990   effect(DEF dst, USE src);
10991   ins_cost(100);
10992   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10993   ins_encode %{
10994     __ movdl($dst$$XMMRegister, $src$$Register);
10995   %}
10996   ins_pipe( pipe_slow );
10997 %}
10998 
10999 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
11000   match(Set dst (MoveL2D src));
11001   effect(DEF dst, USE src);
11002   ins_cost(100);
11003   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
11004   ins_encode %{
11005      __ movdq($dst$$XMMRegister, $src$$Register);
11006   %}
11007   ins_pipe( pipe_slow );
11008 %}
11009 
11010 
11011 // =======================================================================
11012 // fast clearing of an array
11013 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11014                   Universe dummy, rFlagsReg cr)
11015 %{
11016   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());
11017   match(Set dummy (ClearArray (Binary cnt base) val));
11018   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11019 
11020   format %{ $$template
11021     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
11022     $$emit$$&quot;jg      LARGE\n\t&quot;
11023     $$emit$$&quot;dec     rcx\n\t&quot;
11024     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
11025     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
11026     $$emit$$&quot;dec     rcx\n\t&quot;
11027     $$emit$$&quot;jge     LOOP\n\t&quot;
11028     $$emit$$&quot;jmp     DONE\n\t&quot;
11029     $$emit$$&quot;# LARGE:\n\t&quot;
11030     if (UseFastStosb) {
11031        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11032        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
11033     } else if (UseXMMForObjInit) {
11034        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11035        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11036        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11037        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11038        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11039        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11040        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11041        $$emit$$&quot;add     0x40,rax\n\t&quot;
11042        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11043        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11044        $$emit$$&quot;jge     L_loop\n\t&quot;
11045        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11046        $$emit$$&quot;jl      L_tail\n\t&quot;
11047        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11048        $$emit$$&quot;add     0x20,rax\n\t&quot;
11049        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11050        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11051        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11052        $$emit$$&quot;jle     L_end\n\t&quot;
11053        $$emit$$&quot;dec     rcx\n\t&quot;
11054        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11055        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11056        $$emit$$&quot;add     0x8,rax\n\t&quot;
11057        $$emit$$&quot;dec     rcx\n\t&quot;
11058        $$emit$$&quot;jge     L_sloop\n\t&quot;
11059        $$emit$$&quot;# L_end:\n\t&quot;
11060     } else {
11061        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11062     }
11063     $$emit$$&quot;# DONE&quot;
11064   %}
11065   ins_encode %{
11066     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11067                  $tmp$$XMMRegister, false, false);
11068   %}
11069   ins_pipe(pipe_slow);
11070 %}
11071 
11072 instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11073                   Universe dummy, rFlagsReg cr)
11074 %{
11075   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());
11076   match(Set dummy (ClearArray (Binary cnt base) val));
11077   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11078 
11079   format %{ $$template
11080     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
11081     $$emit$$&quot;jg      LARGE\n\t&quot;
11082     $$emit$$&quot;dec     rcx\n\t&quot;
11083     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
11084     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
11085     $$emit$$&quot;dec     rcx\n\t&quot;
11086     $$emit$$&quot;jge     LOOP\n\t&quot;
11087     $$emit$$&quot;jmp     DONE\n\t&quot;
11088     $$emit$$&quot;# LARGE:\n\t&quot;
11089     if (UseXMMForObjInit) {
11090        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11091        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11092        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11093        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11094        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11095        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11096        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11097        $$emit$$&quot;add     0x40,rax\n\t&quot;
11098        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11099        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11100        $$emit$$&quot;jge     L_loop\n\t&quot;
11101        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11102        $$emit$$&quot;jl      L_tail\n\t&quot;
11103        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11104        $$emit$$&quot;add     0x20,rax\n\t&quot;
11105        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11106        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11107        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11108        $$emit$$&quot;jle     L_end\n\t&quot;
11109        $$emit$$&quot;dec     rcx\n\t&quot;
11110        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11111        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11112        $$emit$$&quot;add     0x8,rax\n\t&quot;
11113        $$emit$$&quot;dec     rcx\n\t&quot;
11114        $$emit$$&quot;jge     L_sloop\n\t&quot;
11115        $$emit$$&quot;# L_end:\n\t&quot;
11116     } else {
11117        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11118     }
11119     $$emit$$&quot;# DONE&quot;
11120   %}
11121   ins_encode %{
11122     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11123                  $tmp$$XMMRegister, false, true);
11124   %}
11125   ins_pipe(pipe_slow);
11126 %}
11127 
11128 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11129                         Universe dummy, rFlagsReg cr)
11130 %{
11131   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());
11132   match(Set dummy (ClearArray (Binary cnt base) val));
11133   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11134 
11135   format %{ $$template
11136     if (UseFastStosb) {
11137        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11138        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11139     } else if (UseXMMForObjInit) {
11140        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11141        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11142        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11143        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11144        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11145        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11146        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11147        $$emit$$&quot;add     0x40,rax\n\t&quot;
11148        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11149        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11150        $$emit$$&quot;jge     L_loop\n\t&quot;
11151        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11152        $$emit$$&quot;jl      L_tail\n\t&quot;
11153        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11154        $$emit$$&quot;add     0x20,rax\n\t&quot;
11155        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11156        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11157        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11158        $$emit$$&quot;jle     L_end\n\t&quot;
11159        $$emit$$&quot;dec     rcx\n\t&quot;
11160        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11161        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11162        $$emit$$&quot;add     0x8,rax\n\t&quot;
11163        $$emit$$&quot;dec     rcx\n\t&quot;
11164        $$emit$$&quot;jge     L_sloop\n\t&quot;
11165        $$emit$$&quot;# L_end:\n\t&quot;
11166     } else {
11167        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11168     }
11169   %}
11170   ins_encode %{
11171     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11172                  $tmp$$XMMRegister, true, false);
11173   %}
11174   ins_pipe(pipe_slow);
11175 %}
11176 
11177 instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val, 
11178                         Universe dummy, rFlagsReg cr)
11179 %{
11180   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());
11181   match(Set dummy (ClearArray (Binary cnt base) val));
11182   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11183 
11184   format %{ $$template
11185     if (UseXMMForObjInit) {
11186        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11187        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11188        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11189        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11190        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11191        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11192        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11193        $$emit$$&quot;add     0x40,rax\n\t&quot;
11194        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11195        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11196        $$emit$$&quot;jge     L_loop\n\t&quot;
11197        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11198        $$emit$$&quot;jl      L_tail\n\t&quot;
11199        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11200        $$emit$$&quot;add     0x20,rax\n\t&quot;
11201        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11202        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11203        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11204        $$emit$$&quot;jle     L_end\n\t&quot;
11205        $$emit$$&quot;dec     rcx\n\t&quot;
11206        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11207        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11208        $$emit$$&quot;add     0x8,rax\n\t&quot;
11209        $$emit$$&quot;dec     rcx\n\t&quot;
11210        $$emit$$&quot;jge     L_sloop\n\t&quot;
11211        $$emit$$&quot;# L_end:\n\t&quot;
11212     } else {
11213        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11214     }
11215   %}
11216   ins_encode %{
11217     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register, 
11218                  $tmp$$XMMRegister, true, true);
11219   %}
11220   ins_pipe(pipe_slow);
11221 %}
11222 
11223 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11224                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11225 %{
11226   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11227   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11228   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11229 
11230   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11231   ins_encode %{
11232     __ string_compare($str1$$Register, $str2$$Register,
11233                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11234                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11235   %}
11236   ins_pipe( pipe_slow );
11237 %}
11238 
11239 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11240                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11241 %{
11242   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11243   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11244   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11245 
11246   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11247   ins_encode %{
11248     __ string_compare($str1$$Register, $str2$$Register,
11249                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11250                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11251   %}
11252   ins_pipe( pipe_slow );
11253 %}
11254 
11255 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11256                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11257 %{
11258   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11259   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11260   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11261 
11262   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11263   ins_encode %{
11264     __ string_compare($str1$$Register, $str2$$Register,
11265                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11266                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11267   %}
11268   ins_pipe( pipe_slow );
11269 %}
11270 
11271 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11272                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11273 %{
11274   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11275   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11276   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11277 
11278   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11279   ins_encode %{
11280     __ string_compare($str2$$Register, $str1$$Register,
11281                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11282                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11283   %}
11284   ins_pipe( pipe_slow );
11285 %}
11286 
11287 // fast search of substring with known size.
11288 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11289                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11290 %{
11291   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11292   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11293   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11294 
11295   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11296   ins_encode %{
11297     int icnt2 = (int)$int_cnt2$$constant;
11298     if (icnt2 &gt;= 16) {
11299       // IndexOf for constant substrings with size &gt;= 16 elements
11300       // which don&#39;t need to be loaded through stack.
11301       __ string_indexofC8($str1$$Register, $str2$$Register,
11302                           $cnt1$$Register, $cnt2$$Register,
11303                           icnt2, $result$$Register,
11304                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11305     } else {
11306       // Small strings are loaded through stack if they cross page boundary.
11307       __ string_indexof($str1$$Register, $str2$$Register,
11308                         $cnt1$$Register, $cnt2$$Register,
11309                         icnt2, $result$$Register,
11310                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11311     }
11312   %}
11313   ins_pipe( pipe_slow );
11314 %}
11315 
11316 // fast search of substring with known size.
11317 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11318                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11319 %{
11320   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11321   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11322   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11323 
11324   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11325   ins_encode %{
11326     int icnt2 = (int)$int_cnt2$$constant;
11327     if (icnt2 &gt;= 8) {
11328       // IndexOf for constant substrings with size &gt;= 8 elements
11329       // which don&#39;t need to be loaded through stack.
11330       __ string_indexofC8($str1$$Register, $str2$$Register,
11331                           $cnt1$$Register, $cnt2$$Register,
11332                           icnt2, $result$$Register,
11333                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11334     } else {
11335       // Small strings are loaded through stack if they cross page boundary.
11336       __ string_indexof($str1$$Register, $str2$$Register,
11337                         $cnt1$$Register, $cnt2$$Register,
11338                         icnt2, $result$$Register,
11339                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11340     }
11341   %}
11342   ins_pipe( pipe_slow );
11343 %}
11344 
11345 // fast search of substring with known size.
11346 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11347                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11348 %{
11349   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11350   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11351   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11352 
11353   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11354   ins_encode %{
11355     int icnt2 = (int)$int_cnt2$$constant;
11356     if (icnt2 &gt;= 8) {
11357       // IndexOf for constant substrings with size &gt;= 8 elements
11358       // which don&#39;t need to be loaded through stack.
11359       __ string_indexofC8($str1$$Register, $str2$$Register,
11360                           $cnt1$$Register, $cnt2$$Register,
11361                           icnt2, $result$$Register,
11362                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11363     } else {
11364       // Small strings are loaded through stack if they cross page boundary.
11365       __ string_indexof($str1$$Register, $str2$$Register,
11366                         $cnt1$$Register, $cnt2$$Register,
11367                         icnt2, $result$$Register,
11368                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11369     }
11370   %}
11371   ins_pipe( pipe_slow );
11372 %}
11373 
11374 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11375                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11376 %{
11377   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11378   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11379   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11380 
11381   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11382   ins_encode %{
11383     __ string_indexof($str1$$Register, $str2$$Register,
11384                       $cnt1$$Register, $cnt2$$Register,
11385                       (-1), $result$$Register,
11386                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11387   %}
11388   ins_pipe( pipe_slow );
11389 %}
11390 
11391 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11392                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11393 %{
11394   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11395   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11396   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11397 
11398   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11399   ins_encode %{
11400     __ string_indexof($str1$$Register, $str2$$Register,
11401                       $cnt1$$Register, $cnt2$$Register,
11402                       (-1), $result$$Register,
11403                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11404   %}
11405   ins_pipe( pipe_slow );
11406 %}
11407 
11408 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11409                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11410 %{
11411   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11412   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11413   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11414 
11415   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11416   ins_encode %{
11417     __ string_indexof($str1$$Register, $str2$$Register,
11418                       $cnt1$$Register, $cnt2$$Register,
11419                       (-1), $result$$Register,
11420                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11421   %}
11422   ins_pipe( pipe_slow );
11423 %}
11424 
11425 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11426                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11427 %{
11428   predicate(UseSSE42Intrinsics);
11429   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11430   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11431   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11432   ins_encode %{
11433     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11434                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11435   %}
11436   ins_pipe( pipe_slow );
11437 %}
11438 
11439 // fast string equals
11440 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11441                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11442 %{
11443   match(Set result (StrEquals (Binary str1 str2) cnt));
11444   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11445 
11446   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11447   ins_encode %{
11448     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11449                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11450                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11451   %}
11452   ins_pipe( pipe_slow );
11453 %}
11454 
11455 // fast array equals
11456 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11457                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11458 %{
11459   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11460   match(Set result (AryEq ary1 ary2));
11461   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11462 
11463   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11464   ins_encode %{
11465     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11466                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11467                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11468   %}
11469   ins_pipe( pipe_slow );
11470 %}
11471 
11472 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11473                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11474 %{
11475   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11476   match(Set result (AryEq ary1 ary2));
11477   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11478 
11479   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11480   ins_encode %{
11481     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11482                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11483                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11484   %}
11485   ins_pipe( pipe_slow );
11486 %}
11487 
11488 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11489                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11490 %{
11491   match(Set result (HasNegatives ary1 len));
11492   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11493 
11494   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11495   ins_encode %{
11496     __ has_negatives($ary1$$Register, $len$$Register,
11497                      $result$$Register, $tmp3$$Register,
11498                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11499   %}
11500   ins_pipe( pipe_slow );
11501 %}
11502 
11503 // fast char[] to byte[] compression
11504 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11505                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11506   match(Set result (StrCompressedCopy src (Binary dst len)));
11507   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11508 
11509   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11510   ins_encode %{
11511     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11512                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11513                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11514   %}
11515   ins_pipe( pipe_slow );
11516 %}
11517 
11518 // fast byte[] to char[] inflation
11519 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11520                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11521   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11522   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11523 
11524   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11525   ins_encode %{
11526     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11527                           $tmp1$$XMMRegister, $tmp2$$Register);
11528   %}
11529   ins_pipe( pipe_slow );
11530 %}
11531 
11532 // encode char[] to byte[] in ISO_8859_1
11533 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11534                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11535                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11536   match(Set result (EncodeISOArray src (Binary dst len)));
11537   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11538 
11539   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11540   ins_encode %{
11541     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11542                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11543                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11544   %}
11545   ins_pipe( pipe_slow );
11546 %}
11547 
11548 //----------Overflow Math Instructions-----------------------------------------
11549 
11550 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11551 %{
11552   match(Set cr (OverflowAddI op1 op2));
11553   effect(DEF cr, USE_KILL op1, USE op2);
11554 
11555   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11556 
11557   ins_encode %{
11558     __ addl($op1$$Register, $op2$$Register);
11559   %}
11560   ins_pipe(ialu_reg_reg);
11561 %}
11562 
11563 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11564 %{
11565   match(Set cr (OverflowAddI op1 op2));
11566   effect(DEF cr, USE_KILL op1, USE op2);
11567 
11568   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11569 
11570   ins_encode %{
11571     __ addl($op1$$Register, $op2$$constant);
11572   %}
11573   ins_pipe(ialu_reg_reg);
11574 %}
11575 
11576 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11577 %{
11578   match(Set cr (OverflowAddL op1 op2));
11579   effect(DEF cr, USE_KILL op1, USE op2);
11580 
11581   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11582   ins_encode %{
11583     __ addq($op1$$Register, $op2$$Register);
11584   %}
11585   ins_pipe(ialu_reg_reg);
11586 %}
11587 
11588 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11589 %{
11590   match(Set cr (OverflowAddL op1 op2));
11591   effect(DEF cr, USE_KILL op1, USE op2);
11592 
11593   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11594   ins_encode %{
11595     __ addq($op1$$Register, $op2$$constant);
11596   %}
11597   ins_pipe(ialu_reg_reg);
11598 %}
11599 
11600 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11601 %{
11602   match(Set cr (OverflowSubI op1 op2));
11603 
11604   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11605   ins_encode %{
11606     __ cmpl($op1$$Register, $op2$$Register);
11607   %}
11608   ins_pipe(ialu_reg_reg);
11609 %}
11610 
11611 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11612 %{
11613   match(Set cr (OverflowSubI op1 op2));
11614 
11615   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11616   ins_encode %{
11617     __ cmpl($op1$$Register, $op2$$constant);
11618   %}
11619   ins_pipe(ialu_reg_reg);
11620 %}
11621 
11622 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11623 %{
11624   match(Set cr (OverflowSubL op1 op2));
11625 
11626   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11627   ins_encode %{
11628     __ cmpq($op1$$Register, $op2$$Register);
11629   %}
11630   ins_pipe(ialu_reg_reg);
11631 %}
11632 
11633 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11634 %{
11635   match(Set cr (OverflowSubL op1 op2));
11636 
11637   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11638   ins_encode %{
11639     __ cmpq($op1$$Register, $op2$$constant);
11640   %}
11641   ins_pipe(ialu_reg_reg);
11642 %}
11643 
11644 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11645 %{
11646   match(Set cr (OverflowSubI zero op2));
11647   effect(DEF cr, USE_KILL op2);
11648 
11649   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11650   ins_encode %{
11651     __ negl($op2$$Register);
11652   %}
11653   ins_pipe(ialu_reg_reg);
11654 %}
11655 
11656 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11657 %{
11658   match(Set cr (OverflowSubL zero op2));
11659   effect(DEF cr, USE_KILL op2);
11660 
11661   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11662   ins_encode %{
11663     __ negq($op2$$Register);
11664   %}
11665   ins_pipe(ialu_reg_reg);
11666 %}
11667 
11668 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11669 %{
11670   match(Set cr (OverflowMulI op1 op2));
11671   effect(DEF cr, USE_KILL op1, USE op2);
11672 
11673   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11674   ins_encode %{
11675     __ imull($op1$$Register, $op2$$Register);
11676   %}
11677   ins_pipe(ialu_reg_reg_alu0);
11678 %}
11679 
11680 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11681 %{
11682   match(Set cr (OverflowMulI op1 op2));
11683   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11684 
11685   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11686   ins_encode %{
11687     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11688   %}
11689   ins_pipe(ialu_reg_reg_alu0);
11690 %}
11691 
11692 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11693 %{
11694   match(Set cr (OverflowMulL op1 op2));
11695   effect(DEF cr, USE_KILL op1, USE op2);
11696 
11697   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11698   ins_encode %{
11699     __ imulq($op1$$Register, $op2$$Register);
11700   %}
11701   ins_pipe(ialu_reg_reg_alu0);
11702 %}
11703 
11704 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11705 %{
11706   match(Set cr (OverflowMulL op1 op2));
11707   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11708 
11709   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11710   ins_encode %{
11711     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11712   %}
11713   ins_pipe(ialu_reg_reg_alu0);
11714 %}
11715 
11716 
11717 //----------Control Flow Instructions------------------------------------------
11718 // Signed compare Instructions
11719 
11720 // XXX more variants!!
11721 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11722 %{
11723   match(Set cr (CmpI op1 op2));
11724   effect(DEF cr, USE op1, USE op2);
11725 
11726   format %{ &quot;cmpl    $op1, $op2&quot; %}
11727   opcode(0x3B);  /* Opcode 3B /r */
11728   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11729   ins_pipe(ialu_cr_reg_reg);
11730 %}
11731 
11732 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11733 %{
11734   match(Set cr (CmpI op1 op2));
11735 
11736   format %{ &quot;cmpl    $op1, $op2&quot; %}
11737   opcode(0x81, 0x07); /* Opcode 81 /7 */
11738   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11739   ins_pipe(ialu_cr_reg_imm);
11740 %}
11741 
11742 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11743 %{
11744   match(Set cr (CmpI op1 (LoadI op2)));
11745 
11746   ins_cost(500); // XXX
11747   format %{ &quot;cmpl    $op1, $op2&quot; %}
11748   opcode(0x3B); /* Opcode 3B /r */
11749   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11750   ins_pipe(ialu_cr_reg_mem);
11751 %}
11752 
11753 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11754 %{
11755   match(Set cr (CmpI src zero));
11756 
11757   format %{ &quot;testl   $src, $src&quot; %}
11758   opcode(0x85);
11759   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11760   ins_pipe(ialu_cr_reg_imm);
11761 %}
11762 
11763 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11764 %{
11765   match(Set cr (CmpI (AndI src con) zero));
11766 
11767   format %{ &quot;testl   $src, $con&quot; %}
11768   opcode(0xF7, 0x00);
11769   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11770   ins_pipe(ialu_cr_reg_imm);
11771 %}
11772 
11773 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11774 %{
11775   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11776 
11777   format %{ &quot;testl   $src, $mem&quot; %}
11778   opcode(0x85);
11779   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11780   ins_pipe(ialu_cr_reg_mem);
11781 %}
11782 
11783 // Fold array properties check
11784 instruct testI_mem_imm(rFlagsReg cr, memory mem, immI con, immI0 zero)
11785 %{
11786   match(Set cr (CmpI (AndI (CastN2I (LoadNKlass mem)) con) zero));
11787 
11788   format %{ &quot;testl   $mem, $con&quot; %}
11789   opcode(0xF7, 0x00);
11790   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(con));
11791   ins_pipe(ialu_mem_imm);
11792 %}
11793 
11794 // Clear array property bits
11795 instruct clear_property_bits(rRegN dst, memory mem, immU31 mask, rFlagsReg cr)
11796 %{
11797   match(Set dst (CastI2N (AndI (CastN2I (LoadNKlass mem)) mask)));
11798   effect(KILL cr);
11799 
11800   format %{ &quot;movl    $dst, $mem\t# clear property bits\n\t&quot;
11801             &quot;andl    $dst, $mask&quot; %}
11802   ins_encode %{
11803     __ movl($dst$$Register, $mem$$Address);
11804     __ andl($dst$$Register, $mask$$constant);
11805   %}
11806   ins_pipe(ialu_reg_mem);
11807 %}
11808 
11809 // Unsigned compare Instructions; really, same as signed except they
11810 // produce an rFlagsRegU instead of rFlagsReg.
11811 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11812 %{
11813   match(Set cr (CmpU op1 op2));
11814 
11815   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11816   opcode(0x3B); /* Opcode 3B /r */
11817   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11818   ins_pipe(ialu_cr_reg_reg);
11819 %}
11820 
11821 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11822 %{
11823   match(Set cr (CmpU op1 op2));
11824 
11825   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11826   opcode(0x81,0x07); /* Opcode 81 /7 */
11827   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11828   ins_pipe(ialu_cr_reg_imm);
11829 %}
11830 
11831 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11832 %{
11833   match(Set cr (CmpU op1 (LoadI op2)));
11834 
11835   ins_cost(500); // XXX
11836   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11837   opcode(0x3B); /* Opcode 3B /r */
11838   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11839   ins_pipe(ialu_cr_reg_mem);
11840 %}
11841 
11842 // // // Cisc-spilled version of cmpU_rReg
11843 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11844 // //%{
11845 // //  match(Set cr (CmpU (LoadI op1) op2));
11846 // //
11847 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11848 // //  ins_cost(500);
11849 // //  opcode(0x39);  /* Opcode 39 /r */
11850 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11851 // //%}
11852 
11853 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11854 %{
11855   match(Set cr (CmpU src zero));
11856 
11857   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11858   opcode(0x85);
11859   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11860   ins_pipe(ialu_cr_reg_imm);
11861 %}
11862 
11863 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11864 %{
11865   match(Set cr (CmpP op1 op2));
11866 
11867   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11868   opcode(0x3B); /* Opcode 3B /r */
11869   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11870   ins_pipe(ialu_cr_reg_reg);
11871 %}
11872 
11873 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11874 %{
11875   match(Set cr (CmpP op1 (LoadP op2)));
11876   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11877 
11878   ins_cost(500); // XXX
11879   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11880   opcode(0x3B); /* Opcode 3B /r */
11881   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11882   ins_pipe(ialu_cr_reg_mem);
11883 %}
11884 
11885 // // // Cisc-spilled version of cmpP_rReg
11886 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11887 // //%{
11888 // //  match(Set cr (CmpP (LoadP op1) op2));
11889 // //
11890 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11891 // //  ins_cost(500);
11892 // //  opcode(0x39);  /* Opcode 39 /r */
11893 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11894 // //%}
11895 
11896 // XXX this is generalized by compP_rReg_mem???
11897 // Compare raw pointer (used in out-of-heap check).
11898 // Only works because non-oop pointers must be raw pointers
11899 // and raw pointers have no anti-dependencies.
11900 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11901 %{
11902   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11903             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11904   match(Set cr (CmpP op1 (LoadP op2)));
11905 
11906   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11907   opcode(0x3B); /* Opcode 3B /r */
11908   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11909   ins_pipe(ialu_cr_reg_mem);
11910 %}
11911 
11912 // This will generate a signed flags result. This should be OK since
11913 // any compare to a zero should be eq/neq.
11914 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11915 %{
11916   match(Set cr (CmpP src zero));
11917 
11918   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11919   opcode(0x85);
11920   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11921   ins_pipe(ialu_cr_reg_imm);
11922 %}
11923 
11924 // This will generate a signed flags result. This should be OK since
11925 // any compare to a zero should be eq/neq.
11926 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11927 %{
11928   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11929             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11930   match(Set cr (CmpP (LoadP op) zero));
11931 
11932   ins_cost(500); // XXX
11933   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11934   opcode(0xF7); /* Opcode F7 /0 */
11935   ins_encode(REX_mem_wide(op),
11936              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11937   ins_pipe(ialu_cr_reg_imm);
11938 %}
11939 
11940 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11941 %{
11942   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
11943             (CompressedKlassPointers::base() == NULL) &amp;&amp;
11944             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11945   match(Set cr (CmpP (LoadP mem) zero));
11946 
11947   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11948   ins_encode %{
11949     __ cmpq(r12, $mem$$Address);
11950   %}
11951   ins_pipe(ialu_cr_reg_mem);
11952 %}
11953 
11954 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11955 %{
11956   match(Set cr (CmpN op1 op2));
11957 
11958   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11959   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11960   ins_pipe(ialu_cr_reg_reg);
11961 %}
11962 
11963 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11964 %{
11965   match(Set cr (CmpN src (LoadN mem)));
11966 
11967   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11968   ins_encode %{
11969     __ cmpl($src$$Register, $mem$$Address);
11970   %}
11971   ins_pipe(ialu_cr_reg_mem);
11972 %}
11973 
11974 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11975   match(Set cr (CmpN op1 op2));
11976 
11977   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11978   ins_encode %{
11979     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11980   %}
11981   ins_pipe(ialu_cr_reg_imm);
11982 %}
11983 
11984 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11985 %{
11986   match(Set cr (CmpN src (LoadN mem)));
11987 
11988   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11989   ins_encode %{
11990     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11991   %}
11992   ins_pipe(ialu_cr_reg_mem);
11993 %}
11994 
11995 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11996   match(Set cr (CmpN op1 op2));
11997 
11998   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
11999   ins_encode %{
12000     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
12001   %}
12002   ins_pipe(ialu_cr_reg_imm);
12003 %}
12004 
12005 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
12006 %{
12007   match(Set cr (CmpN src (LoadNKlass mem)));
12008 
12009   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
12010   ins_encode %{
12011     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
12012   %}
12013   ins_pipe(ialu_cr_reg_mem);
12014 %}
12015 
12016 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
12017   match(Set cr (CmpN src zero));
12018 
12019   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
12020   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
12021   ins_pipe(ialu_cr_reg_imm);
12022 %}
12023 
12024 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
12025 %{
12026   predicate(CompressedOops::base() != NULL);
12027   match(Set cr (CmpN (LoadN mem) zero));
12028 
12029   ins_cost(500); // XXX
12030   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
12031   ins_encode %{
12032     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
12033   %}
12034   ins_pipe(ialu_cr_reg_mem);
12035 %}
12036 
12037 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
12038 %{
12039   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));
12040   match(Set cr (CmpN (LoadN mem) zero));
12041 
12042   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
12043   ins_encode %{
12044     __ cmpl(r12, $mem$$Address);
12045   %}
12046   ins_pipe(ialu_cr_reg_mem);
12047 %}
12048 
12049 // Yanked all unsigned pointer compare operations.
12050 // Pointer compares are done with CmpP which is already unsigned.
12051 
12052 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
12053 %{
12054   match(Set cr (CmpL op1 op2));
12055 
12056   format %{ &quot;cmpq    $op1, $op2&quot; %}
12057   opcode(0x3B);  /* Opcode 3B /r */
12058   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12059   ins_pipe(ialu_cr_reg_reg);
12060 %}
12061 
12062 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
12063 %{
12064   match(Set cr (CmpL op1 op2));
12065 
12066   format %{ &quot;cmpq    $op1, $op2&quot; %}
12067   opcode(0x81, 0x07); /* Opcode 81 /7 */
12068   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12069   ins_pipe(ialu_cr_reg_imm);
12070 %}
12071 
12072 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
12073 %{
12074   match(Set cr (CmpL op1 (LoadL op2)));
12075 
12076   format %{ &quot;cmpq    $op1, $op2&quot; %}
12077   opcode(0x3B); /* Opcode 3B /r */
12078   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12079   ins_pipe(ialu_cr_reg_mem);
12080 %}
12081 
12082 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
12083 %{
12084   match(Set cr (CmpL src zero));
12085 
12086   format %{ &quot;testq   $src, $src&quot; %}
12087   opcode(0x85);
12088   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12089   ins_pipe(ialu_cr_reg_imm);
12090 %}
12091 
12092 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
12093 %{
12094   match(Set cr (CmpL (AndL src con) zero));
12095 
12096   format %{ &quot;testq   $src, $con\t# long&quot; %}
12097   opcode(0xF7, 0x00);
12098   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
12099   ins_pipe(ialu_cr_reg_imm);
12100 %}
12101 
12102 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
12103 %{
12104   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
12105 
12106   format %{ &quot;testq   $src, $mem&quot; %}
12107   opcode(0x85);
12108   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12109   ins_pipe(ialu_cr_reg_mem);
12110 %}
12111 
12112 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
12113 %{
12114   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
12115 
12116   format %{ &quot;testq   $src, $mem&quot; %}
12117   opcode(0x85);
12118   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12119   ins_pipe(ialu_cr_reg_mem);
12120 %}
12121 
12122 // Fold array properties check
12123 instruct testL_reg_mem3(rFlagsReg cr, memory mem, rRegL src, immL0 zero)
12124 %{
12125   match(Set cr (CmpL (AndL (CastP2X (LoadKlass mem)) src) zero));
12126 
12127   format %{ &quot;testq   $src, $mem\t# test array properties&quot; %}
12128   opcode(0x85);
12129   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12130   ins_pipe(ialu_cr_reg_mem);
12131 %}
12132 
12133 // Manifest a CmpL result in an integer register.  Very painful.
12134 // This is the test to avoid.
12135 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
12136 %{
12137   match(Set dst (CmpL3 src1 src2));
12138   effect(KILL flags);
12139 
12140   ins_cost(275); // XXX
12141   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
12142             &quot;movl    $dst, -1\n\t&quot;
12143             &quot;jl,s    done\n\t&quot;
12144             &quot;setne   $dst\n\t&quot;
12145             &quot;movzbl  $dst, $dst\n\t&quot;
12146     &quot;done:&quot; %}
12147   ins_encode(cmpl3_flag(src1, src2, dst));
12148   ins_pipe(pipe_slow);
12149 %}
12150 
12151 // Unsigned long compare Instructions; really, same as signed long except they
12152 // produce an rFlagsRegU instead of rFlagsReg.
12153 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
12154 %{
12155   match(Set cr (CmpUL op1 op2));
12156 
12157   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12158   opcode(0x3B);  /* Opcode 3B /r */
12159   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12160   ins_pipe(ialu_cr_reg_reg);
12161 %}
12162 
12163 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
12164 %{
12165   match(Set cr (CmpUL op1 op2));
12166 
12167   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12168   opcode(0x81, 0x07); /* Opcode 81 /7 */
12169   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12170   ins_pipe(ialu_cr_reg_imm);
12171 %}
12172 
12173 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
12174 %{
12175   match(Set cr (CmpUL op1 (LoadL op2)));
12176 
12177   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12178   opcode(0x3B); /* Opcode 3B /r */
12179   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12180   ins_pipe(ialu_cr_reg_mem);
12181 %}
12182 
12183 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
12184 %{
12185   match(Set cr (CmpUL src zero));
12186 
12187   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
12188   opcode(0x85);
12189   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12190   ins_pipe(ialu_cr_reg_imm);
12191 %}
12192 
12193 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
12194 %{
12195   match(Set cr (CmpI (LoadB mem) imm));
12196 
12197   ins_cost(125);
12198   format %{ &quot;cmpb    $mem, $imm&quot; %}
12199   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
12200   ins_pipe(ialu_cr_reg_mem);
12201 %}
12202 
12203 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
12204 %{
12205   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
12206 
12207   ins_cost(125);
12208   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
12209   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12210   ins_pipe(ialu_cr_reg_mem);
12211 %}
12212 
12213 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
12214 %{
12215   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
12216 
12217   ins_cost(125);
12218   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
12219   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12220   ins_pipe(ialu_cr_reg_mem);
12221 %}
12222 
12223 //----------Max and Min--------------------------------------------------------
12224 // Min Instructions
12225 
12226 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
12227 %{
12228   effect(USE_DEF dst, USE src, USE cr);
12229 
12230   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
12231   opcode(0x0F, 0x4F);
12232   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12233   ins_pipe(pipe_cmov_reg);
12234 %}
12235 
12236 
12237 instruct minI_rReg(rRegI dst, rRegI src)
12238 %{
12239   match(Set dst (MinI dst src));
12240 
12241   ins_cost(200);
12242   expand %{
12243     rFlagsReg cr;
12244     compI_rReg(cr, dst, src);
12245     cmovI_reg_g(dst, src, cr);
12246   %}
12247 %}
12248 
12249 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12250 %{
12251   effect(USE_DEF dst, USE src, USE cr);
12252 
12253   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12254   opcode(0x0F, 0x4C);
12255   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12256   ins_pipe(pipe_cmov_reg);
12257 %}
12258 
12259 
12260 instruct maxI_rReg(rRegI dst, rRegI src)
12261 %{
12262   match(Set dst (MaxI dst src));
12263 
12264   ins_cost(200);
12265   expand %{
12266     rFlagsReg cr;
12267     compI_rReg(cr, dst, src);
12268     cmovI_reg_l(dst, src, cr);
12269   %}
12270 %}
12271 
12272 // ============================================================================
12273 // Branch Instructions
12274 
12275 // Jump Direct - Label defines a relative address from JMP+1
12276 instruct jmpDir(label labl)
12277 %{
12278   match(Goto);
12279   effect(USE labl);
12280 
12281   ins_cost(300);
12282   format %{ &quot;jmp     $labl&quot; %}
12283   size(5);
12284   ins_encode %{
12285     Label* L = $labl$$label;
12286     __ jmp(*L, false); // Always long jump
12287   %}
12288   ins_pipe(pipe_jmp);
12289 %}
12290 
12291 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12292 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12293 %{
12294   match(If cop cr);
12295   effect(USE labl);
12296 
12297   ins_cost(300);
12298   format %{ &quot;j$cop     $labl&quot; %}
12299   size(6);
12300   ins_encode %{
12301     Label* L = $labl$$label;
12302     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12303   %}
12304   ins_pipe(pipe_jcc);
12305 %}
12306 
12307 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12308 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12309 %{
12310   predicate(!n-&gt;has_vector_mask_set());
12311   match(CountedLoopEnd cop cr);
12312   effect(USE labl);
12313 
12314   ins_cost(300);
12315   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12316   size(6);
12317   ins_encode %{
12318     Label* L = $labl$$label;
12319     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12320   %}
12321   ins_pipe(pipe_jcc);
12322 %}
12323 
12324 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12325 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12326   predicate(!n-&gt;has_vector_mask_set());
12327   match(CountedLoopEnd cop cmp);
12328   effect(USE labl);
12329 
12330   ins_cost(300);
12331   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12332   size(6);
12333   ins_encode %{
12334     Label* L = $labl$$label;
12335     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12336   %}
12337   ins_pipe(pipe_jcc);
12338 %}
12339 
12340 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12341   predicate(!n-&gt;has_vector_mask_set());
12342   match(CountedLoopEnd cop cmp);
12343   effect(USE labl);
12344 
12345   ins_cost(200);
12346   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12347   size(6);
12348   ins_encode %{
12349     Label* L = $labl$$label;
12350     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12351   %}
12352   ins_pipe(pipe_jcc);
12353 %}
12354 
12355 // mask version
12356 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12357 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12358 %{
12359   predicate(n-&gt;has_vector_mask_set());
12360   match(CountedLoopEnd cop cr);
12361   effect(USE labl);
12362 
12363   ins_cost(400);
12364   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12365             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12366   size(10);
12367   ins_encode %{
12368     Label* L = $labl$$label;
12369     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12370     __ restorevectmask();
12371   %}
12372   ins_pipe(pipe_jcc);
12373 %}
12374 
12375 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12376 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12377   predicate(n-&gt;has_vector_mask_set());
12378   match(CountedLoopEnd cop cmp);
12379   effect(USE labl);
12380 
12381   ins_cost(400);
12382   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12383             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12384   size(10);
12385   ins_encode %{
12386     Label* L = $labl$$label;
12387     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12388     __ restorevectmask();
12389   %}
12390   ins_pipe(pipe_jcc);
12391 %}
12392 
12393 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12394   predicate(n-&gt;has_vector_mask_set());
12395   match(CountedLoopEnd cop cmp);
12396   effect(USE labl);
12397 
12398   ins_cost(300);
12399   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12400             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12401   size(10);
12402   ins_encode %{
12403     Label* L = $labl$$label;
12404     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12405     __ restorevectmask();
12406   %}
12407   ins_pipe(pipe_jcc);
12408 %}
12409 
12410 // Jump Direct Conditional - using unsigned comparison
12411 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12412   match(If cop cmp);
12413   effect(USE labl);
12414 
12415   ins_cost(300);
12416   format %{ &quot;j$cop,u   $labl&quot; %}
12417   size(6);
12418   ins_encode %{
12419     Label* L = $labl$$label;
12420     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12421   %}
12422   ins_pipe(pipe_jcc);
12423 %}
12424 
12425 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12426   match(If cop cmp);
12427   effect(USE labl);
12428 
12429   ins_cost(200);
12430   format %{ &quot;j$cop,u   $labl&quot; %}
12431   size(6);
12432   ins_encode %{
12433     Label* L = $labl$$label;
12434     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12435   %}
12436   ins_pipe(pipe_jcc);
12437 %}
12438 
12439 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12440   match(If cop cmp);
12441   effect(USE labl);
12442 
12443   ins_cost(200);
12444   format %{ $$template
12445     if ($cop$$cmpcode == Assembler::notEqual) {
12446       $$emit$$&quot;jp,u    $labl\n\t&quot;
12447       $$emit$$&quot;j$cop,u   $labl&quot;
12448     } else {
12449       $$emit$$&quot;jp,u    done\n\t&quot;
12450       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12451       $$emit$$&quot;done:&quot;
12452     }
12453   %}
12454   ins_encode %{
12455     Label* l = $labl$$label;
12456     if ($cop$$cmpcode == Assembler::notEqual) {
12457       __ jcc(Assembler::parity, *l, false);
12458       __ jcc(Assembler::notEqual, *l, false);
12459     } else if ($cop$$cmpcode == Assembler::equal) {
12460       Label done;
12461       __ jccb(Assembler::parity, done);
12462       __ jcc(Assembler::equal, *l, false);
12463       __ bind(done);
12464     } else {
12465        ShouldNotReachHere();
12466     }
12467   %}
12468   ins_pipe(pipe_jcc);
12469 %}
12470 
12471 // ============================================================================
12472 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12473 // superklass array for an instance of the superklass.  Set a hidden
12474 // internal cache on a hit (cache is checked with exposed code in
12475 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12476 // encoding ALSO sets flags.
12477 
12478 instruct partialSubtypeCheck(rdi_RegP result,
12479                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12480                              rFlagsReg cr)
12481 %{
12482   match(Set result (PartialSubtypeCheck sub super));
12483   effect(KILL rcx, KILL cr);
12484 
12485   ins_cost(1100);  // slightly larger than the next version
12486   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12487             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12488             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12489             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12490             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12491             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12492             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12493     &quot;miss:\t&quot; %}
12494 
12495   opcode(0x1); // Force a XOR of RDI
12496   ins_encode(enc_PartialSubtypeCheck());
12497   ins_pipe(pipe_slow);
12498 %}
12499 
12500 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12501                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12502                                      immP0 zero,
12503                                      rdi_RegP result)
12504 %{
12505   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12506   effect(KILL rcx, KILL result);
12507 
12508   ins_cost(1000);
12509   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12510             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12511             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12512             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12513             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12514             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12515     &quot;miss:\t&quot; %}
12516 
12517   opcode(0x0); // No need to XOR RDI
12518   ins_encode(enc_PartialSubtypeCheck());
12519   ins_pipe(pipe_slow);
12520 %}
12521 
12522 // ============================================================================
12523 // Branch Instructions -- short offset versions
12524 //
12525 // These instructions are used to replace jumps of a long offset (the default
12526 // match) with jumps of a shorter offset.  These instructions are all tagged
12527 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12528 // match rules in general matching.  Instead, the ADLC generates a conversion
12529 // method in the MachNode which can be used to do in-place replacement of the
12530 // long variant with the shorter variant.  The compiler will determine if a
12531 // branch can be taken by the is_short_branch_offset() predicate in the machine
12532 // specific code section of the file.
12533 
12534 // Jump Direct - Label defines a relative address from JMP+1
12535 instruct jmpDir_short(label labl) %{
12536   match(Goto);
12537   effect(USE labl);
12538 
12539   ins_cost(300);
12540   format %{ &quot;jmp,s   $labl&quot; %}
12541   size(2);
12542   ins_encode %{
12543     Label* L = $labl$$label;
12544     __ jmpb(*L);
12545   %}
12546   ins_pipe(pipe_jmp);
12547   ins_short_branch(1);
12548 %}
12549 
12550 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12551 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12552   match(If cop cr);
12553   effect(USE labl);
12554 
12555   ins_cost(300);
12556   format %{ &quot;j$cop,s   $labl&quot; %}
12557   size(2);
12558   ins_encode %{
12559     Label* L = $labl$$label;
12560     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12561   %}
12562   ins_pipe(pipe_jcc);
12563   ins_short_branch(1);
12564 %}
12565 
12566 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12567 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12568   match(CountedLoopEnd cop cr);
12569   effect(USE labl);
12570 
12571   ins_cost(300);
12572   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12573   size(2);
12574   ins_encode %{
12575     Label* L = $labl$$label;
12576     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12577   %}
12578   ins_pipe(pipe_jcc);
12579   ins_short_branch(1);
12580 %}
12581 
12582 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12583 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12584   match(CountedLoopEnd cop cmp);
12585   effect(USE labl);
12586 
12587   ins_cost(300);
12588   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12589   size(2);
12590   ins_encode %{
12591     Label* L = $labl$$label;
12592     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12593   %}
12594   ins_pipe(pipe_jcc);
12595   ins_short_branch(1);
12596 %}
12597 
12598 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12599   match(CountedLoopEnd cop cmp);
12600   effect(USE labl);
12601 
12602   ins_cost(300);
12603   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12604   size(2);
12605   ins_encode %{
12606     Label* L = $labl$$label;
12607     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12608   %}
12609   ins_pipe(pipe_jcc);
12610   ins_short_branch(1);
12611 %}
12612 
12613 // Jump Direct Conditional - using unsigned comparison
12614 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12615   match(If cop cmp);
12616   effect(USE labl);
12617 
12618   ins_cost(300);
12619   format %{ &quot;j$cop,us  $labl&quot; %}
12620   size(2);
12621   ins_encode %{
12622     Label* L = $labl$$label;
12623     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12624   %}
12625   ins_pipe(pipe_jcc);
12626   ins_short_branch(1);
12627 %}
12628 
12629 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12630   match(If cop cmp);
12631   effect(USE labl);
12632 
12633   ins_cost(300);
12634   format %{ &quot;j$cop,us  $labl&quot; %}
12635   size(2);
12636   ins_encode %{
12637     Label* L = $labl$$label;
12638     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12639   %}
12640   ins_pipe(pipe_jcc);
12641   ins_short_branch(1);
12642 %}
12643 
12644 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12645   match(If cop cmp);
12646   effect(USE labl);
12647 
12648   ins_cost(300);
12649   format %{ $$template
12650     if ($cop$$cmpcode == Assembler::notEqual) {
12651       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12652       $$emit$$&quot;j$cop,u,s  $labl&quot;
12653     } else {
12654       $$emit$$&quot;jp,u,s  done\n\t&quot;
12655       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12656       $$emit$$&quot;done:&quot;
12657     }
12658   %}
12659   size(4);
12660   ins_encode %{
12661     Label* l = $labl$$label;
12662     if ($cop$$cmpcode == Assembler::notEqual) {
12663       __ jccb(Assembler::parity, *l);
12664       __ jccb(Assembler::notEqual, *l);
12665     } else if ($cop$$cmpcode == Assembler::equal) {
12666       Label done;
12667       __ jccb(Assembler::parity, done);
12668       __ jccb(Assembler::equal, *l);
12669       __ bind(done);
12670     } else {
12671        ShouldNotReachHere();
12672     }
12673   %}
12674   ins_pipe(pipe_jcc);
12675   ins_short_branch(1);
12676 %}
12677 
12678 // ============================================================================
12679 // inlined locking and unlocking
12680 
12681 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12682   predicate(Compile::current()-&gt;use_rtm());
12683   match(Set cr (FastLock object box));
12684   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12685   ins_cost(300);
12686   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12687   ins_encode %{
12688     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12689                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12690                  _counters, _rtm_counters, _stack_rtm_counters,
12691                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12692                  true, ra_-&gt;C-&gt;profile_rtm());
12693   %}
12694   ins_pipe(pipe_slow);
12695 %}
12696 
12697 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
12698   predicate(!Compile::current()-&gt;use_rtm());
12699   match(Set cr (FastLock object box));
12700   effect(TEMP tmp, TEMP scr, USE_KILL box);
12701   ins_cost(300);
12702   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12703   ins_encode %{
12704     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12705                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
12706   %}
12707   ins_pipe(pipe_slow);
12708 %}
12709 
12710 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12711   match(Set cr (FastUnlock object box));
12712   effect(TEMP tmp, USE_KILL box);
12713   ins_cost(300);
12714   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12715   ins_encode %{
12716     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12717   %}
12718   ins_pipe(pipe_slow);
12719 %}
12720 
12721 
12722 // ============================================================================
12723 // Safepoint Instructions
12724 instruct safePoint_poll(rFlagsReg cr)
12725 %{
12726   predicate(!Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12727   match(SafePoint);
12728   effect(KILL cr);
12729 
12730   format %{ &quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;
12731             &quot;# Safepoint: poll for GC&quot; %}
12732   ins_cost(125);
12733   ins_encode %{
12734     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
12735     __ testl(rax, addr);
12736   %}
12737   ins_pipe(ialu_reg_mem);
12738 %}
12739 
12740 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
12741 %{
12742   predicate(Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12743   match(SafePoint poll);
12744   effect(KILL cr, USE poll);
12745 
12746   format %{ &quot;testl   rax, [$poll]\t&quot;
12747             &quot;# Safepoint: poll for GC&quot; %}
12748   ins_cost(125);
12749   ins_encode %{
12750     __ relocate(relocInfo::poll_type);
12751     __ testl(rax, Address($poll$$Register, 0));
12752   %}
12753   ins_pipe(ialu_reg_mem);
12754 %}
12755 
12756 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12757 %{
12758   predicate(SafepointMechanism::uses_thread_local_poll());
12759   match(SafePoint poll);
12760   effect(KILL cr, USE poll);
12761 
12762   format %{ &quot;testl   rax, [$poll]\t&quot;
12763             &quot;# Safepoint: poll for GC&quot; %}
12764   ins_cost(125);
12765   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12766   ins_encode %{
12767     __ relocate(relocInfo::poll_type);
12768     address pre_pc = __ pc();
12769     __ testl(rax, Address($poll$$Register, 0));
12770     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12771   %}
12772   ins_pipe(ialu_reg_mem);
12773 %}
12774 
12775 // ============================================================================
12776 // Procedure Call/Return Instructions
12777 // Call Java Static Instruction
12778 // Note: If this code changes, the corresponding ret_addr_offset() and
12779 //       compute_padding() functions will have to be adjusted.
12780 instruct CallStaticJavaDirect(method meth) %{
12781   match(CallStaticJava);
12782   effect(USE meth);
12783 
12784   ins_cost(300);
12785   format %{ &quot;call,static &quot; %}
12786   opcode(0xE8); /* E8 cd */
12787   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12788   ins_pipe(pipe_slow);
12789   ins_alignment(4);
12790 %}
12791 
12792 // Call Java Dynamic Instruction
12793 // Note: If this code changes, the corresponding ret_addr_offset() and
12794 //       compute_padding() functions will have to be adjusted.
12795 instruct CallDynamicJavaDirect(method meth)
12796 %{
12797   match(CallDynamicJava);
12798   effect(USE meth);
12799 
12800   ins_cost(300);
12801   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12802             &quot;call,dynamic &quot; %}
12803   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12804   ins_pipe(pipe_slow);
12805   ins_alignment(4);
12806 %}
12807 
12808 // Call Runtime Instruction
12809 instruct CallRuntimeDirect(method meth)
12810 %{
12811   match(CallRuntime);
12812   effect(USE meth);
12813 
12814   ins_cost(300);
12815   format %{ &quot;call,runtime &quot; %}
12816   ins_encode(clear_avx, Java_To_Runtime(meth));
12817   ins_pipe(pipe_slow);
12818 %}
12819 
12820 // Call runtime without safepoint
12821 instruct CallLeafDirect(method meth)
12822 %{
12823   match(CallLeaf);
12824   effect(USE meth);
12825 
12826   ins_cost(300);
12827   format %{ &quot;call_leaf,runtime &quot; %}
12828   ins_encode(clear_avx, Java_To_Runtime(meth));
12829   ins_pipe(pipe_slow);
12830 %}
12831 
12832 // Call runtime without safepoint
12833 // entry point is null, target holds the address to call
12834 instruct CallLeafNoFPInDirect(rRegP target)
12835 %{
12836   predicate(n-&gt;as_Call()-&gt;entry_point() == NULL);
12837   match(CallLeafNoFP target);
12838 
12839   ins_cost(300);
12840   format %{ &quot;call_leaf_nofp,runtime indirect &quot; %}
12841   ins_encode %{
12842      __ call($target$$Register);
12843   %}
12844 
12845   ins_pipe(pipe_slow);
12846 %}
12847 
12848 instruct CallLeafNoFPDirect(method meth)
12849 %{
12850   predicate(n-&gt;as_Call()-&gt;entry_point() != NULL);
12851   match(CallLeafNoFP);
12852   effect(USE meth);
12853 
12854   ins_cost(300);
12855   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12856   ins_encode(clear_avx, Java_To_Runtime(meth));
12857   ins_pipe(pipe_slow);
12858 %}
12859 
12860 // Return Instruction
12861 // Remove the return address &amp; jump to it.
12862 // Notice: We always emit a nop after a ret to make sure there is room
12863 // for safepoint patching
12864 instruct Ret()
12865 %{
12866   match(Return);
12867 
12868   format %{ &quot;ret&quot; %}
12869   opcode(0xC3);
12870   ins_encode(OpcP);
12871   ins_pipe(pipe_jmp);
12872 %}
12873 
12874 // Tail Call; Jump from runtime stub to Java code.
12875 // Also known as an &#39;interprocedural jump&#39;.
12876 // Target of jump will eventually return to caller.
12877 // TailJump below removes the return address.
12878 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12879 %{
12880   match(TailCall jump_target method_oop);
12881 
12882   ins_cost(300);
12883   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12884   opcode(0xFF, 0x4); /* Opcode FF /4 */
12885   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12886   ins_pipe(pipe_jmp);
12887 %}
12888 
12889 // Tail Jump; remove the return address; jump to target.
12890 // TailCall above leaves the return address around.
12891 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12892 %{
12893   match(TailJump jump_target ex_oop);
12894 
12895   ins_cost(300);
12896   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12897             &quot;jmp     $jump_target&quot; %}
12898   opcode(0xFF, 0x4); /* Opcode FF /4 */
12899   ins_encode(Opcode(0x5a), // popq rdx
12900              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12901   ins_pipe(pipe_jmp);
12902 %}
12903 
12904 // Create exception oop: created by stack-crawling runtime code.
12905 // Created exception is now available to this handler, and is setup
12906 // just prior to jumping to this handler.  No code emitted.
12907 instruct CreateException(rax_RegP ex_oop)
12908 %{
12909   match(Set ex_oop (CreateEx));
12910 
12911   size(0);
12912   // use the following format syntax
12913   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12914   ins_encode();
12915   ins_pipe(empty);
12916 %}
12917 
12918 // Rethrow exception:
12919 // The exception oop will come in the first argument position.
12920 // Then JUMP (not call) to the rethrow stub code.
12921 instruct RethrowException()
12922 %{
12923   match(Rethrow);
12924 
12925   // use the following format syntax
12926   format %{ &quot;jmp     rethrow_stub&quot; %}
12927   ins_encode(enc_rethrow);
12928   ins_pipe(pipe_jmp);
12929 %}
12930 
12931 // ============================================================================
12932 // This name is KNOWN by the ADLC and cannot be changed.
12933 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12934 // for this guy.
12935 instruct tlsLoadP(r15_RegP dst) %{
12936   match(Set dst (ThreadLocal));
12937   effect(DEF dst);
12938 
12939   size(0);
12940   format %{ &quot;# TLS is in R15&quot; %}
12941   ins_encode( /*empty encoding*/ );
12942   ins_pipe(ialu_reg_reg);
12943 %}
12944 
12945 
12946 //----------PEEPHOLE RULES-----------------------------------------------------
12947 // These must follow all instruction definitions as they use the names
12948 // defined in the instructions definitions.
12949 //
12950 // peepmatch ( root_instr_name [preceding_instruction]* );
12951 //
12952 // peepconstraint %{
12953 // (instruction_number.operand_name relational_op instruction_number.operand_name
12954 //  [, ...] );
12955 // // instruction numbers are zero-based using left to right order in peepmatch
12956 //
12957 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12958 // // provide an instruction_number.operand_name for each operand that appears
12959 // // in the replacement instruction&#39;s match rule
12960 //
12961 // ---------VM FLAGS---------------------------------------------------------
12962 //
12963 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12964 //
12965 // Each peephole rule is given an identifying number starting with zero and
12966 // increasing by one in the order seen by the parser.  An individual peephole
12967 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12968 // on the command-line.
12969 //
12970 // ---------CURRENT LIMITATIONS----------------------------------------------
12971 //
12972 // Only match adjacent instructions in same basic block
12973 // Only equality constraints
12974 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12975 // Only one replacement instruction
12976 //
12977 // ---------EXAMPLE----------------------------------------------------------
12978 //
12979 // // pertinent parts of existing instructions in architecture description
12980 // instruct movI(rRegI dst, rRegI src)
12981 // %{
12982 //   match(Set dst (CopyI src));
12983 // %}
12984 //
12985 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12986 // %{
12987 //   match(Set dst (AddI dst src));
12988 //   effect(KILL cr);
12989 // %}
12990 //
12991 // // Change (inc mov) to lea
12992 // peephole %{
12993 //   // increment preceeded by register-register move
12994 //   peepmatch ( incI_rReg movI );
12995 //   // require that the destination register of the increment
12996 //   // match the destination register of the move
12997 //   peepconstraint ( 0.dst == 1.dst );
12998 //   // construct a replacement instruction that sets
12999 //   // the destination to ( move&#39;s source register + one )
13000 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
13001 // %}
13002 //
13003 
13004 // Implementation no longer uses movX instructions since
13005 // machine-independent system no longer uses CopyX nodes.
13006 //
13007 // peephole
13008 // %{
13009 //   peepmatch (incI_rReg movI);
13010 //   peepconstraint (0.dst == 1.dst);
13011 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
13012 // %}
13013 
13014 // peephole
13015 // %{
13016 //   peepmatch (decI_rReg movI);
13017 //   peepconstraint (0.dst == 1.dst);
13018 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
13019 // %}
13020 
13021 // peephole
13022 // %{
13023 //   peepmatch (addI_rReg_imm movI);
13024 //   peepconstraint (0.dst == 1.dst);
13025 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
13026 // %}
13027 
13028 // peephole
13029 // %{
13030 //   peepmatch (incL_rReg movL);
13031 //   peepconstraint (0.dst == 1.dst);
13032 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
13033 // %}
13034 
13035 // peephole
13036 // %{
13037 //   peepmatch (decL_rReg movL);
13038 //   peepconstraint (0.dst == 1.dst);
13039 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
13040 // %}
13041 
13042 // peephole
13043 // %{
13044 //   peepmatch (addL_rReg_imm movL);
13045 //   peepconstraint (0.dst == 1.dst);
13046 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
13047 // %}
13048 
13049 // peephole
13050 // %{
13051 //   peepmatch (addP_rReg_imm movP);
13052 //   peepconstraint (0.dst == 1.dst);
13053 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
13054 // %}
13055 
13056 // // Change load of spilled value to only a spill
13057 // instruct storeI(memory mem, rRegI src)
13058 // %{
13059 //   match(Set mem (StoreI mem src));
13060 // %}
13061 //
13062 // instruct loadI(rRegI dst, memory mem)
13063 // %{
13064 //   match(Set dst (LoadI mem));
13065 // %}
13066 //
13067 
13068 peephole
13069 %{
13070   peepmatch (loadI storeI);
13071   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
13072   peepreplace (storeI(1.mem 1.mem 1.src));
13073 %}
13074 
13075 peephole
13076 %{
13077   peepmatch (loadL storeL);
13078   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
13079   peepreplace (storeL(1.mem 1.mem 1.src));
13080 %}
13081 
13082 //----------SMARTSPILL RULES---------------------------------------------------
13083 // These must follow all instruction definitions as they use the names
13084 // defined in the instructions definitions.
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
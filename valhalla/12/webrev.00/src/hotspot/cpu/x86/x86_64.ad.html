<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
    1 //
    2 // Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 //
   24 
   25 // AMD64 Architecture Description File
   26 
   27 //----------REGISTER DEFINITION BLOCK------------------------------------------
   28 // This information is used by the matcher and the register allocator to
   29 // describe individual registers and classes of registers within the target
   30 // archtecture.
   31 
   32 register %{
   33 //----------Architecture Description Register Definitions----------------------
   34 // General Registers
   35 // &quot;reg_def&quot;  name ( register save type, C convention save type,
   36 //                   ideal register type, encoding );
   37 // Register Save Types:
   38 //
   39 // NS  = No-Save:       The register allocator assumes that these registers
   40 //                      can be used without saving upon entry to the method, &amp;
   41 //                      that they do not need to be saved at call sites.
   42 //
   43 // SOC = Save-On-Call:  The register allocator assumes that these registers
   44 //                      can be used without saving upon entry to the method,
   45 //                      but that they must be saved at call sites.
   46 //
   47 // SOE = Save-On-Entry: The register allocator assumes that these registers
   48 //                      must be saved before using them upon entry to the
   49 //                      method, but they do not need to be saved at call
   50 //                      sites.
   51 //
   52 // AS  = Always-Save:   The register allocator assumes that these registers
   53 //                      must be saved before using them upon entry to the
   54 //                      method, &amp; that they must be saved at call sites.
   55 //
   56 // Ideal Register Type is used to determine how to save &amp; restore a
   57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
   59 //
   60 // The encoding number is the actual bit-pattern placed into the opcodes.
   61 
   62 // General Registers
   63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
   64 // used as byte registers)
   65 
   66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
   67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
   68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
   69 
   70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
   71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
   72 
   73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
   74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
   75 
   76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
   77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
   78 
   79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
   80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
   81 
   82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
   83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
   84 
   85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
   86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
   87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
   88 
   89 #ifdef _WIN64
   90 
   91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
   92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
   93 
   94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
   95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
   96 
   97 #else
   98 
   99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
  100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  101 
  102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
  103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  104 
  105 #endif
  106 
  107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
  108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
  109 
  110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
  111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
  112 
  113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
  114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
  115 
  116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
  117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
  118 
  119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
  120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
  121 
  122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
  123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
  124 
  125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
  126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
  127 
  128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
  129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
  130 
  131 
  132 // Floating Point Registers
  133 
  134 // Specify priority of register selection within phases of register
  135 // allocation.  Highest priority is first.  A useful heuristic is to
  136 // give registers a low priority when they are required by machine
  137 // instructions, like EAX and EDX on I486, and choose no-save registers
  138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
  139 // which participate in fixed calling sequences should come last.
  140 // Registers which are used as pairs must fall on an even boundary.
  141 
  142 alloc_class chunk0(R10,         R10_H,
  143                    R11,         R11_H,
  144                    R8,          R8_H,
  145                    R9,          R9_H,
  146                    R12,         R12_H,
  147                    RCX,         RCX_H,
  148                    RBX,         RBX_H,
  149                    RDI,         RDI_H,
  150                    RDX,         RDX_H,
  151                    RSI,         RSI_H,
  152                    RAX,         RAX_H,
  153                    RBP,         RBP_H,
  154                    R13,         R13_H,
  155                    R14,         R14_H,
  156                    R15,         R15_H,
  157                    RSP,         RSP_H);
  158 
  159 
  160 //----------Architecture Description Register Classes--------------------------
  161 // Several register classes are automatically defined based upon information in
  162 // this architecture description.
  163 // 1) reg_class inline_cache_reg           ( /* as def&#39;d in frame section */ )
  164 // 2) reg_class compiler_method_oop_reg    ( /* as def&#39;d in frame section */ )
  165 // 2) reg_class interpreter_method_oop_reg ( /* as def&#39;d in frame section */ )
  166 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  167 //
  168 
  169 // Empty register class.
  170 reg_class no_reg();
  171 
  172 // Class for all pointer/long registers
  173 reg_class all_reg(RAX, RAX_H,
  174                   RDX, RDX_H,
  175                   RBP, RBP_H,
  176                   RDI, RDI_H,
  177                   RSI, RSI_H,
  178                   RCX, RCX_H,
  179                   RBX, RBX_H,
  180                   RSP, RSP_H,
  181                   R8,  R8_H,
  182                   R9,  R9_H,
  183                   R10, R10_H,
  184                   R11, R11_H,
  185                   R12, R12_H,
  186                   R13, R13_H,
  187                   R14, R14_H,
  188                   R15, R15_H);
  189 
  190 // Class for all int registers
  191 reg_class all_int_reg(RAX
  192                       RDX,
  193                       RBP,
  194                       RDI,
  195                       RSI,
  196                       RCX,
  197                       RBX,
  198                       R8,
  199                       R9,
  200                       R10,
  201                       R11,
  202                       R12,
  203                       R13,
  204                       R14);
  205 
  206 // Class for all pointer registers
  207 reg_class any_reg %{
  208   return _ANY_REG_mask;
  209 %}
  210 
  211 // Class for all pointer registers (excluding RSP)
  212 reg_class ptr_reg %{
  213   return _PTR_REG_mask;
  214 %}
  215 
  216 // Class for all pointer registers (excluding RSP and RBP)
  217 reg_class ptr_reg_no_rbp %{
  218   return _PTR_REG_NO_RBP_mask;
  219 %}
  220 
  221 // Class for all pointer registers (excluding RAX and RSP)
  222 reg_class ptr_no_rax_reg %{
  223   return _PTR_NO_RAX_REG_mask;
  224 %}
  225 
  226 // Class for all pointer registers (excluding RAX, RBX, and RSP)
  227 reg_class ptr_no_rax_rbx_reg %{
  228   return _PTR_NO_RAX_RBX_REG_mask;
  229 %}
  230 
  231 // Class for all long registers (excluding RSP)
  232 reg_class long_reg %{
  233   return _LONG_REG_mask;
  234 %}
  235 
  236 // Class for all long registers (excluding RAX, RDX and RSP)
  237 reg_class long_no_rax_rdx_reg %{
  238   return _LONG_NO_RAX_RDX_REG_mask;
  239 %}
  240 
  241 // Class for all long registers (excluding RCX and RSP)
  242 reg_class long_no_rcx_reg %{
  243   return _LONG_NO_RCX_REG_mask;
  244 %}
  245 
  246 // Class for all int registers (excluding RSP)
  247 reg_class int_reg %{
  248   return _INT_REG_mask;
  249 %}
  250 
  251 // Class for all int registers (excluding RAX, RDX, and RSP)
  252 reg_class int_no_rax_rdx_reg %{
  253   return _INT_NO_RAX_RDX_REG_mask;
  254 %}
  255 
  256 // Class for all int registers (excluding RCX and RSP)
  257 reg_class int_no_rcx_reg %{
  258   return _INT_NO_RCX_REG_mask;
  259 %}
  260 
  261 // Singleton class for RAX pointer register
  262 reg_class ptr_rax_reg(RAX, RAX_H);
  263 
  264 // Singleton class for RBX pointer register
  265 reg_class ptr_rbx_reg(RBX, RBX_H);
  266 
  267 // Singleton class for RSI pointer register
  268 reg_class ptr_rsi_reg(RSI, RSI_H);
  269 
  270 // Singleton class for RBP pointer register
  271 reg_class ptr_rbp_reg(RBP, RBP_H);
  272 
  273 // Singleton class for RDI pointer register
  274 reg_class ptr_rdi_reg(RDI, RDI_H);
  275 
  276 // Singleton class for stack pointer
  277 reg_class ptr_rsp_reg(RSP, RSP_H);
  278 
  279 // Singleton class for TLS pointer
  280 reg_class ptr_r15_reg(R15, R15_H);
  281 
  282 // Singleton class for RAX long register
  283 reg_class long_rax_reg(RAX, RAX_H);
  284 
  285 // Singleton class for RCX long register
  286 reg_class long_rcx_reg(RCX, RCX_H);
  287 
  288 // Singleton class for RDX long register
  289 reg_class long_rdx_reg(RDX, RDX_H);
  290 
  291 // Singleton class for RAX int register
  292 reg_class int_rax_reg(RAX);
  293 
  294 // Singleton class for RBX int register
  295 reg_class int_rbx_reg(RBX);
  296 
  297 // Singleton class for RCX int register
  298 reg_class int_rcx_reg(RCX);
  299 
  300 // Singleton class for RCX int register
  301 reg_class int_rdx_reg(RDX);
  302 
  303 // Singleton class for RCX int register
  304 reg_class int_rdi_reg(RDI);
  305 
  306 // Singleton class for instruction pointer
  307 // reg_class ip_reg(RIP);
  308 
  309 %}
  310 
  311 //----------SOURCE BLOCK-------------------------------------------------------
  312 // This is a block of C++ code which provides values, functions, and
  313 // definitions necessary in the rest of the architecture description
  314 source_hpp %{
  315 
  316 extern RegMask _ANY_REG_mask;
  317 extern RegMask _PTR_REG_mask;
  318 extern RegMask _PTR_REG_NO_RBP_mask;
  319 extern RegMask _PTR_NO_RAX_REG_mask;
  320 extern RegMask _PTR_NO_RAX_RBX_REG_mask;
  321 extern RegMask _LONG_REG_mask;
  322 extern RegMask _LONG_NO_RAX_RDX_REG_mask;
  323 extern RegMask _LONG_NO_RCX_REG_mask;
  324 extern RegMask _INT_REG_mask;
  325 extern RegMask _INT_NO_RAX_RDX_REG_mask;
  326 extern RegMask _INT_NO_RCX_REG_mask;
  327 
  328 extern RegMask _STACK_OR_PTR_REG_mask;
  329 extern RegMask _STACK_OR_LONG_REG_mask;
  330 extern RegMask _STACK_OR_INT_REG_mask;
  331 
  332 inline const RegMask&amp; STACK_OR_PTR_REG_mask()  { return _STACK_OR_PTR_REG_mask;  }
  333 inline const RegMask&amp; STACK_OR_LONG_REG_mask() { return _STACK_OR_LONG_REG_mask; }
  334 inline const RegMask&amp; STACK_OR_INT_REG_mask()  { return _STACK_OR_INT_REG_mask;  }
  335 
  336 %}
  337 
  338 source %{
  339 #define   RELOC_IMM64    Assembler::imm_operand
  340 #define   RELOC_DISP32   Assembler::disp32_operand
  341 
  342 #define __ _masm.
  343 
  344 RegMask _ANY_REG_mask;
  345 RegMask _PTR_REG_mask;
  346 RegMask _PTR_REG_NO_RBP_mask;
  347 RegMask _PTR_NO_RAX_REG_mask;
  348 RegMask _PTR_NO_RAX_RBX_REG_mask;
  349 RegMask _LONG_REG_mask;
  350 RegMask _LONG_NO_RAX_RDX_REG_mask;
  351 RegMask _LONG_NO_RCX_REG_mask;
  352 RegMask _INT_REG_mask;
  353 RegMask _INT_NO_RAX_RDX_REG_mask;
  354 RegMask _INT_NO_RCX_REG_mask;
  355 RegMask _STACK_OR_PTR_REG_mask;
  356 RegMask _STACK_OR_LONG_REG_mask;
  357 RegMask _STACK_OR_INT_REG_mask;
  358 
  359 static bool need_r12_heapbase() {
  360   return UseCompressedOops || UseCompressedClassPointers;
  361 }
  362 
  363 void reg_mask_init() {
  364   // _ALL_REG_mask is generated by adlc from the all_reg register class below.
  365   // We derive a number of subsets from it.
  366   _ANY_REG_mask = _ALL_REG_mask;
  367 
  368   if (PreserveFramePointer) {
  369     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  370     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  371   }
  372   if (need_r12_heapbase()) {
  373     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  374     _ANY_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()-&gt;next()));
  375   }
  376 
  377   _PTR_REG_mask = _ANY_REG_mask;
  378   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()));
  379   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(rsp-&gt;as_VMReg()-&gt;next()));
  380   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()));
  381   _PTR_REG_mask.Remove(OptoReg::as_OptoReg(r15-&gt;as_VMReg()-&gt;next()));
  382 
  383   _STACK_OR_PTR_REG_mask = _PTR_REG_mask;
  384   _STACK_OR_PTR_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  385 
  386   _PTR_REG_NO_RBP_mask = _PTR_REG_mask;
  387   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  388   _PTR_REG_NO_RBP_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()-&gt;next()));
  389 
  390   _PTR_NO_RAX_REG_mask = _PTR_REG_mask;
  391   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  392   _PTR_NO_RAX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  393 
  394   _PTR_NO_RAX_RBX_REG_mask = _PTR_NO_RAX_REG_mask;
  395   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()));
  396   _PTR_NO_RAX_RBX_REG_mask.Remove(OptoReg::as_OptoReg(rbx-&gt;as_VMReg()-&gt;next()));
  397 
  398   _LONG_REG_mask = _PTR_REG_mask;
  399   _STACK_OR_LONG_REG_mask = _LONG_REG_mask;
  400   _STACK_OR_LONG_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  401 
  402   _LONG_NO_RAX_RDX_REG_mask = _LONG_REG_mask;
  403   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  404   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()-&gt;next()));
  405   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  406   _LONG_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()-&gt;next()));
  407 
  408   _LONG_NO_RCX_REG_mask = _LONG_REG_mask;
  409   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  410   _LONG_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()-&gt;next()));
  411 
  412   _INT_REG_mask = _ALL_INT_REG_mask;
  413   if (PreserveFramePointer) {
  414     _INT_REG_mask.Remove(OptoReg::as_OptoReg(rbp-&gt;as_VMReg()));
  415   }
  416   if (need_r12_heapbase()) {
  417     _INT_REG_mask.Remove(OptoReg::as_OptoReg(r12-&gt;as_VMReg()));
  418   }
  419 
  420   _STACK_OR_INT_REG_mask = _INT_REG_mask;
  421   _STACK_OR_INT_REG_mask.OR(STACK_OR_STACK_SLOTS_mask());
  422 
  423   _INT_NO_RAX_RDX_REG_mask = _INT_REG_mask;
  424   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rax-&gt;as_VMReg()));
  425   _INT_NO_RAX_RDX_REG_mask.Remove(OptoReg::as_OptoReg(rdx-&gt;as_VMReg()));
  426 
  427   _INT_NO_RCX_REG_mask = _INT_REG_mask;
  428   _INT_NO_RCX_REG_mask.Remove(OptoReg::as_OptoReg(rcx-&gt;as_VMReg()));
  429 }
  430 
  431 static bool generate_vzeroupper(Compile* C) {
  432   return (VM_Version::supports_vzeroupper() &amp;&amp; (C-&gt;max_vector_size() &gt; 16 || C-&gt;clear_upper_avx() == true)) ? true: false;  // Generate vzeroupper
  433 }
  434 
  435 static int clear_avx_size() {
  436   return generate_vzeroupper(Compile::current()) ? 3: 0;  // vzeroupper
  437 }
  438 
  439 // !!!!! Special hack to get all types of calls to specify the byte offset
  440 //       from the start of the call to the point where the return address
  441 //       will point.
  442 int MachCallStaticJavaNode::ret_addr_offset()
  443 {
  444   int offset = 5; // 5 bytes from start of call to where return address points
  445   offset += clear_avx_size();
  446   return offset;
  447 }
  448 
  449 int MachCallDynamicJavaNode::ret_addr_offset()
  450 {
  451   int offset = 15; // 15 bytes from start of call to where return address points
  452   offset += clear_avx_size();
  453   return offset;
  454 }
  455 
  456 int MachCallRuntimeNode::ret_addr_offset() {
  457   int offset = 13; // movq r10,#addr; callq (r10)
  458   offset += clear_avx_size();
  459   return offset;
  460 }
  461 
  462 // Indicate if the safepoint node needs the polling page as an input,
  463 // it does if the polling page is more than disp32 away.
  464 bool SafePointNode::needs_polling_address_input()
  465 {
  466   return SafepointMechanism::uses_thread_local_poll() || Assembler::is_polling_page_far();
  467 }
  468 
  469 //
  470 // Compute padding required for nodes which need alignment
  471 //
  472 
  473 // The address of the call instruction needs to be 4-byte aligned to
  474 // ensure that it does not span a cache line so that it can be patched.
  475 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
  476 {
  477   current_offset += clear_avx_size(); // skip vzeroupper
  478   current_offset += 1; // skip call opcode byte
  479   return align_up(current_offset, alignment_required()) - current_offset;
  480 }
  481 
  482 // The address of the call instruction needs to be 4-byte aligned to
  483 // ensure that it does not span a cache line so that it can be patched.
  484 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
  485 {
  486   current_offset += clear_avx_size(); // skip vzeroupper
  487   current_offset += 11; // skip movq instruction + call opcode byte
  488   return align_up(current_offset, alignment_required()) - current_offset;
  489 }
  490 
  491 // EMIT_RM()
  492 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
  493   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
  494   cbuf.insts()-&gt;emit_int8(c);
  495 }
  496 
  497 // EMIT_CC()
  498 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
  499   unsigned char c = (unsigned char) (f1 | f2);
  500   cbuf.insts()-&gt;emit_int8(c);
  501 }
  502 
  503 // EMIT_OPCODE()
  504 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
  505   cbuf.insts()-&gt;emit_int8((unsigned char) code);
  506 }
  507 
  508 // EMIT_OPCODE() w/ relocation information
  509 void emit_opcode(CodeBuffer &amp;cbuf,
  510                  int code, relocInfo::relocType reloc, int offset, int format)
  511 {
  512   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
  513   emit_opcode(cbuf, code);
  514 }
  515 
  516 // EMIT_D8()
  517 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
  518   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
  519 }
  520 
  521 // EMIT_D16()
  522 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
  523   cbuf.insts()-&gt;emit_int16(d16);
  524 }
  525 
  526 // EMIT_D32()
  527 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
  528   cbuf.insts()-&gt;emit_int32(d32);
  529 }
  530 
  531 // EMIT_D64()
  532 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
  533   cbuf.insts()-&gt;emit_int64(d64);
  534 }
  535 
  536 // emit 32 bit value and construct relocation entry from relocInfo::relocType
  537 void emit_d32_reloc(CodeBuffer&amp; cbuf,
  538                     int d32,
  539                     relocInfo::relocType reloc,
  540                     int format)
  541 {
  542   assert(reloc != relocInfo::external_word_type, &quot;use 2-arg emit_d32_reloc&quot;);
  543   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  544   cbuf.insts()-&gt;emit_int32(d32);
  545 }
  546 
  547 // emit 32 bit value and construct relocation entry from RelocationHolder
  548 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
  549 #ifdef ASSERT
  550   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  551       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
  552     assert(Universe::heap()-&gt;is_in((address)(intptr_t)d32), &quot;should be real oop&quot;);
  553     assert(oopDesc::is_oop(cast_to_oop((intptr_t)d32)), &quot;cannot embed broken oops in code&quot;);
  554   }
  555 #endif
  556   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  557   cbuf.insts()-&gt;emit_int32(d32);
  558 }
  559 
  560 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
  561   address next_ip = cbuf.insts_end() + 4;
  562   emit_d32_reloc(cbuf, (int) (addr - next_ip),
  563                  external_word_Relocation::spec(addr),
  564                  RELOC_DISP32);
  565 }
  566 
  567 
  568 // emit 64 bit value and construct relocation entry from relocInfo::relocType
  569 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
  570   cbuf.relocate(cbuf.insts_mark(), reloc, format);
  571   cbuf.insts()-&gt;emit_int64(d64);
  572 }
  573 
  574 // emit 64 bit value and construct relocation entry from RelocationHolder
  575 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
  576 #ifdef ASSERT
  577   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
  578       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
  579     assert(Universe::heap()-&gt;is_in((address)d64), &quot;should be real oop&quot;);
  580     assert(oopDesc::is_oop(cast_to_oop(d64)), &quot;cannot embed broken oops in code&quot;);
  581   }
  582 #endif
  583   cbuf.relocate(cbuf.insts_mark(), rspec, format);
  584   cbuf.insts()-&gt;emit_int64(d64);
  585 }
  586 
  587 // Access stack slot for load or store
  588 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
  589 {
  590   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
  591   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
  592     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
  593     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  594     emit_d8(cbuf, disp);     // Displacement  // R/M byte
  595   } else {
  596     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
  597     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
  598     emit_d32(cbuf, disp);     // Displacement // R/M byte
  599   }
  600 }
  601 
  602    // rRegI ereg, memory mem) %{    // emit_reg_mem
  603 void encode_RegMem(CodeBuffer &amp;cbuf,
  604                    int reg,
  605                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
  606 {
  607   assert(disp_reloc == relocInfo::none, &quot;cannot have disp&quot;);
  608   int regenc = reg &amp; 7;
  609   int baseenc = base &amp; 7;
  610   int indexenc = index &amp; 7;
  611 
  612   // There is no index &amp; no scale, use form without SIB byte
  613   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
  614     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  615     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  616       emit_rm(cbuf, 0x0, regenc, baseenc); // *
  617     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  618       // If 8-bit displacement, mode 0x1
  619       emit_rm(cbuf, 0x1, regenc, baseenc); // *
  620       emit_d8(cbuf, disp);
  621     } else {
  622       // If 32-bit displacement
  623       if (base == -1) { // Special flag for absolute address
  624         emit_rm(cbuf, 0x0, regenc, 0x5); // *
  625         if (disp_reloc != relocInfo::none) {
  626           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  627         } else {
  628           emit_d32(cbuf, disp);
  629         }
  630       } else {
  631         // Normal base + offset
  632         emit_rm(cbuf, 0x2, regenc, baseenc); // *
  633         if (disp_reloc != relocInfo::none) {
  634           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  635         } else {
  636           emit_d32(cbuf, disp);
  637         }
  638       }
  639     }
  640   } else {
  641     // Else, encode with the SIB byte
  642     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
  643     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
  644       // If no displacement
  645       emit_rm(cbuf, 0x0, regenc, 0x4); // *
  646       emit_rm(cbuf, scale, indexenc, baseenc);
  647     } else {
  648       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
  649         // If 8-bit displacement, mode 0x1
  650         emit_rm(cbuf, 0x1, regenc, 0x4); // *
  651         emit_rm(cbuf, scale, indexenc, baseenc);
  652         emit_d8(cbuf, disp);
  653       } else {
  654         // If 32-bit displacement
  655         if (base == 0x04 ) {
  656           emit_rm(cbuf, 0x2, regenc, 0x4);
  657           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
  658         } else {
  659           emit_rm(cbuf, 0x2, regenc, 0x4);
  660           emit_rm(cbuf, scale, indexenc, baseenc); // *
  661         }
  662         if (disp_reloc != relocInfo::none) {
  663           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
  664         } else {
  665           emit_d32(cbuf, disp);
  666         }
  667       }
  668     }
  669   }
  670 }
  671 
  672 // This could be in MacroAssembler but it&#39;s fairly C2 specific
  673 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
  674   Label exit;
  675   __ jccb(Assembler::noParity, exit);
  676   __ pushf();
  677   //
  678   // comiss/ucomiss instructions set ZF,PF,CF flags and
  679   // zero OF,AF,SF for NaN values.
  680   // Fixup flags by zeroing ZF,PF so that compare of NaN
  681   // values returns &#39;less than&#39; result (CF is set).
  682   // Leave the rest of flags unchanged.
  683   //
  684   //    7 6 5 4 3 2 1 0
  685   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
  686   //    0 0 1 0 1 0 1 1   (0x2B)
  687   //
  688   __ andq(Address(rsp, 0), 0xffffff2b);
  689   __ popf();
  690   __ bind(exit);
  691 }
  692 
  693 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
  694   Label done;
  695   __ movl(dst, -1);
  696   __ jcc(Assembler::parity, done);
  697   __ jcc(Assembler::below, done);
  698   __ setb(Assembler::notEqual, dst);
  699   __ movzbl(dst, dst);
  700   __ bind(done);
  701 }
  702 
  703 // Math.min()    # Math.max()
  704 // --------------------------
  705 // ucomis[s/d]   #
  706 // ja   -&gt; b     # a
  707 // jp   -&gt; NaN   # NaN
  708 // jb   -&gt; a     # b
  709 // je            #
  710 // |-jz -&gt; a | b # a &amp; b
  711 // |    -&gt; a     #
  712 void emit_fp_min_max(MacroAssembler&amp; _masm, XMMRegister dst,
  713                      XMMRegister a, XMMRegister b,
  714                      XMMRegister xmmt, Register rt,
  715                      bool min, bool single) {
  716 
  717   Label nan, zero, below, above, done;
  718 
  719   if (single)
  720     __ ucomiss(a, b);
  721   else
  722     __ ucomisd(a, b);
  723 
  724   if (dst-&gt;encoding() != (min ? b : a)-&gt;encoding())
  725     __ jccb(Assembler::above, above); // CF=0 &amp; ZF=0
  726   else
  727     __ jccb(Assembler::above, done);
  728 
  729   __ jccb(Assembler::parity, nan);  // PF=1
  730   __ jccb(Assembler::below, below); // CF=1
  731 
  732   // equal
  733   __ vpxor(xmmt, xmmt, xmmt, Assembler::AVX_128bit);
  734   if (single) {
  735     __ ucomiss(a, xmmt);
  736     __ jccb(Assembler::equal, zero);
  737 
  738     __ movflt(dst, a);
  739     __ jmp(done);
  740   }
  741   else {
  742     __ ucomisd(a, xmmt);
  743     __ jccb(Assembler::equal, zero);
  744 
  745     __ movdbl(dst, a);
  746     __ jmp(done);
  747   }
  748 
  749   __ bind(zero);
  750   if (min)
  751     __ vpor(dst, a, b, Assembler::AVX_128bit);
  752   else
  753     __ vpand(dst, a, b, Assembler::AVX_128bit);
  754 
  755   __ jmp(done);
  756 
  757   __ bind(above);
  758   if (single)
  759     __ movflt(dst, min ? b : a);
  760   else
  761     __ movdbl(dst, min ? b : a);
  762 
  763   __ jmp(done);
  764 
  765   __ bind(nan);
  766   if (single) {
  767     __ movl(rt, 0x7fc00000); // Float.NaN
  768     __ movdl(dst, rt);
  769   }
  770   else {
  771     __ mov64(rt, 0x7ff8000000000000L); // Double.NaN
  772     __ movdq(dst, rt);
  773   }
  774   __ jmp(done);
  775 
  776   __ bind(below);
  777   if (single)
  778     __ movflt(dst, min ? a : b);
  779   else
  780     __ movdbl(dst, min ? a : b);
  781 
  782   __ bind(done);
  783 }
  784 
  785 //=============================================================================
  786 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
  787 
  788 int Compile::ConstantTable::calculate_table_base_offset() const {
  789   return 0;  // absolute addressing, no offset
  790 }
  791 
  792 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  793 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  794   ShouldNotReachHere();
  795 }
  796 
  797 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  798   // Empty encoding
  799 }
  800 
  801 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  802   return 0;
  803 }
  804 
  805 #ifndef PRODUCT
  806 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  807   st-&gt;print(&quot;# MachConstantBaseNode (empty encoding)&quot;);
  808 }
  809 #endif
  810 
  811 
  812 //=============================================================================
  813 #ifndef PRODUCT
  814 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  815   Compile* C = ra_-&gt;C;
  816 
  817   int framesize = C-&gt;frame_size_in_bytes();
  818   int bangsize = C-&gt;bang_size_in_bytes();
  819   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  820   // Remove wordSize for return addr which is already pushed.
  821   framesize -= wordSize;
  822 
  823   if (C-&gt;need_stack_bang(bangsize)) {
  824     framesize -= wordSize;
  825     st-&gt;print(&quot;# stack bang (%d bytes)&quot;, bangsize);
  826     st-&gt;print(&quot;\n\t&quot;);
  827     st-&gt;print(&quot;pushq   rbp\t# Save rbp&quot;);
  828     if (PreserveFramePointer) {
  829         st-&gt;print(&quot;\n\t&quot;);
  830         st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  831     }
  832     if (framesize) {
  833       st-&gt;print(&quot;\n\t&quot;);
  834       st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  835     }
  836   } else {
  837     st-&gt;print(&quot;subq    rsp, #%d\t# Create frame&quot;,framesize);
  838     st-&gt;print(&quot;\n\t&quot;);
  839     framesize -= wordSize;
  840     st-&gt;print(&quot;movq    [rsp + #%d], rbp\t# Save rbp&quot;,framesize);
  841     if (PreserveFramePointer) {
  842       st-&gt;print(&quot;\n\t&quot;);
  843       st-&gt;print(&quot;movq    rbp, rsp\t# Save the caller&#39;s SP into rbp&quot;);
  844       if (framesize &gt; 0) {
  845         st-&gt;print(&quot;\n\t&quot;);
  846         st-&gt;print(&quot;addq    rbp, #%d&quot;, framesize);
  847       }
  848     }
  849   }
  850 
  851   if (VerifyStackAtCalls) {
  852     st-&gt;print(&quot;\n\t&quot;);
  853     framesize -= wordSize;
  854     st-&gt;print(&quot;movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check&quot;,framesize);
  855 #ifdef ASSERT
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;# stack alignment check&quot;);
  858 #endif
  859   }
  860   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  861     st-&gt;print(&quot;\n\t&quot;);
  862     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  863     st-&gt;print(&quot;\n\t&quot;);
  864     st-&gt;print(&quot;je      fast_entry\t&quot;);
  865     st-&gt;print(&quot;\n\t&quot;);
  866     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  867     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  868   }
  869   st-&gt;cr();
  870 }
  871 #endif
  872 
  873 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  874   Compile* C = ra_-&gt;C;
  875   MacroAssembler _masm(&amp;cbuf);
  876 
  877   if (C-&gt;clinit_barrier_on_entry()) {
  878     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  879     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  880 
  881     Label L_skip_barrier;
  882     Register klass = rscratch1;
  883 
  884     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  885     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  886 
  887     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  888 
  889     __ bind(L_skip_barrier);
  890   }
  891 
  892   __ verified_entry(C);
  893   __ bind(*_verified_entry);
  894 
  895   if (C-&gt;stub_function() == NULL) {
  896     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
  897     bs-&gt;nmethod_entry_barrier(&amp;_masm);
  898   }
  899 
  900   C-&gt;set_frame_complete(cbuf.insts_size());
  901 
  902   if (C-&gt;has_mach_constant_base_node()) {
  903     // NOTE: We set the table base offset here because users might be
  904     // emitted before MachConstantBaseNode.
  905     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
  906     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  907   }
  908 }
  909 
  910 int MachPrologNode::reloc() const
  911 {
  912   return 0; // a large enough number
  913 }
  914 
  915 //=============================================================================
  916 #ifndef PRODUCT
  917 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  918 {
  919   Compile* C = ra_-&gt;C;
  920   if (generate_vzeroupper(C)) {
  921     st-&gt;print(&quot;vzeroupper&quot;);
  922     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  923   }
  924 
  925   int framesize = C-&gt;frame_size_in_bytes();
  926   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  927   // Remove word for return adr already pushed
  928   // and RBP
  929   framesize -= 2*wordSize;
  930 
  931   if (framesize) {
  932     st-&gt;print_cr(&quot;addq    rsp, %d\t# Destroy frame&quot;, framesize);
  933     st-&gt;print(&quot;\t&quot;);
  934   }
  935 
  936   st-&gt;print_cr(&quot;popq    rbp&quot;);
  937   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  938     st-&gt;print(&quot;\t&quot;);
  939     if (SafepointMechanism::uses_thread_local_poll()) {
  940       st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  941                    &quot;testl   rax, [rscratch1]\t&quot;
  942                    &quot;# Safepoint: poll for GC&quot;);
  943     } else if (Assembler::is_polling_page_far()) {
  944       st-&gt;print_cr(&quot;movq    rscratch1, #polling_page_address\n\t&quot;
  945                    &quot;testl   rax, [rscratch1]\t&quot;
  946                    &quot;# Safepoint: poll for GC&quot;);
  947     } else {
  948       st-&gt;print_cr(&quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;
  949                    &quot;# Safepoint: poll for GC&quot;);
  950     }
  951   }
  952 }
  953 #endif
  954 
  955 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  956 {
  957   Compile* C = ra_-&gt;C;
  958   MacroAssembler _masm(&amp;cbuf);
  959 
  960   if (generate_vzeroupper(C)) {
  961     // Clear upper bits of YMM registers when current compiled code uses
  962     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  963     __ vzeroupper();
  964   }
  965 
  966   // Subtract two words to account for return address and rbp
  967   int initial_framesize = C-&gt;frame_size_in_bytes() - 2*wordSize;
  968   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;sp_inc_offset());
  969 
  970   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  971     __ reserved_stack_check();
  972   }
  973 
  974   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  975     MacroAssembler _masm(&amp;cbuf);
  976     if (SafepointMechanism::uses_thread_local_poll()) {
  977       __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  978       __ relocate(relocInfo::poll_return_type);
  979       __ testl(rax, Address(rscratch1, 0));
  980     } else {
  981       AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
  982       if (Assembler::is_polling_page_far()) {
  983         __ lea(rscratch1, polling_page);
  984         __ relocate(relocInfo::poll_return_type);
  985         __ testl(rax, Address(rscratch1, 0));
  986       } else {
  987         __ testl(rax, polling_page);
  988       }
  989     }
  990   }
  991 }
  992 
  993 int MachEpilogNode::reloc() const
  994 {
  995   return 2; // a large enough number
  996 }
  997 
  998 const Pipeline* MachEpilogNode::pipeline() const
  999 {
 1000   return MachNode::pipeline_class();
 1001 }
 1002 
 1003 int MachEpilogNode::safepoint_offset() const
 1004 {
 1005   return 0;
 1006 }
 1007 
 1008 //=============================================================================
 1009 
 1010 enum RC {
 1011   rc_bad,
 1012   rc_int,
 1013   rc_float,
 1014   rc_stack
 1015 };
 1016 
 1017 static enum RC rc_class(OptoReg::Name reg)
 1018 {
 1019   if( !OptoReg::is_valid(reg)  ) return rc_bad;
 1020 
 1021   if (OptoReg::is_stack(reg)) return rc_stack;
 1022 
 1023   VMReg r = OptoReg::as_VMReg(reg);
 1024 
 1025   if (r-&gt;is_Register()) return rc_int;
 1026 
 1027   assert(r-&gt;is_XMMRegister(), &quot;must be&quot;);
 1028   return rc_float;
 1029 }
 1030 
 1031 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
 1032 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
 1033                           int src_hi, int dst_hi, uint ireg, outputStream* st);
 1034 
 1035 int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
 1036                      int stack_offset, int reg, uint ireg, outputStream* st);
 1037 
 1038 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
 1039                                       int dst_offset, uint ireg, outputStream* st) {
 1040   if (cbuf) {
 1041     MacroAssembler _masm(cbuf);
 1042     switch (ireg) {
 1043     case Op_VecS:
 1044       __ movq(Address(rsp, -8), rax);
 1045       __ movl(rax, Address(rsp, src_offset));
 1046       __ movl(Address(rsp, dst_offset), rax);
 1047       __ movq(rax, Address(rsp, -8));
 1048       break;
 1049     case Op_VecD:
 1050       __ pushq(Address(rsp, src_offset));
 1051       __ popq (Address(rsp, dst_offset));
 1052       break;
 1053     case Op_VecX:
 1054       __ pushq(Address(rsp, src_offset));
 1055       __ popq (Address(rsp, dst_offset));
 1056       __ pushq(Address(rsp, src_offset+8));
 1057       __ popq (Address(rsp, dst_offset+8));
 1058       break;
 1059     case Op_VecY:
 1060       __ vmovdqu(Address(rsp, -32), xmm0);
 1061       __ vmovdqu(xmm0, Address(rsp, src_offset));
 1062       __ vmovdqu(Address(rsp, dst_offset), xmm0);
 1063       __ vmovdqu(xmm0, Address(rsp, -32));
 1064       break;
 1065     case Op_VecZ:
 1066       __ evmovdquq(Address(rsp, -64), xmm0, 2);
 1067       __ evmovdquq(xmm0, Address(rsp, src_offset), 2);
 1068       __ evmovdquq(Address(rsp, dst_offset), xmm0, 2);
 1069       __ evmovdquq(xmm0, Address(rsp, -64), 2);
 1070       break;
 1071     default:
 1072       ShouldNotReachHere();
 1073     }
 1074 #ifndef PRODUCT
 1075   } else {
 1076     switch (ireg) {
 1077     case Op_VecS:
 1078       st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1079                 &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1080                 &quot;movl    [rsp + #%d], rax\n\t&quot;
 1081                 &quot;movq    rax, [rsp - #8]&quot;,
 1082                 src_offset, dst_offset);
 1083       break;
 1084     case Op_VecD:
 1085       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1086                 &quot;popq    [rsp + #%d]&quot;,
 1087                 src_offset, dst_offset);
 1088       break;
 1089      case Op_VecX:
 1090       st-&gt;print(&quot;pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t&quot;
 1091                 &quot;popq    [rsp + #%d]\n\t&quot;
 1092                 &quot;pushq   [rsp + #%d]\n\t&quot;
 1093                 &quot;popq    [rsp + #%d]&quot;,
 1094                 src_offset, dst_offset, src_offset+8, dst_offset+8);
 1095       break;
 1096     case Op_VecY:
 1097       st-&gt;print(&quot;vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t&quot;
 1098                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1099                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1100                 &quot;vmovdqu xmm0, [rsp - #32]&quot;,
 1101                 src_offset, dst_offset);
 1102       break;
 1103     case Op_VecZ:
 1104       st-&gt;print(&quot;vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t&quot;
 1105                 &quot;vmovdqu xmm0, [rsp + #%d]\n\t&quot;
 1106                 &quot;vmovdqu [rsp + #%d], xmm0\n\t&quot;
 1107                 &quot;vmovdqu xmm0, [rsp - #64]&quot;,
 1108                 src_offset, dst_offset);
 1109       break;
 1110     default:
 1111       ShouldNotReachHere();
 1112     }
 1113 #endif
 1114   }
 1115 }
 1116 
 1117 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
 1118                                        PhaseRegAlloc* ra_,
 1119                                        bool do_size,
 1120                                        outputStream* st) const {
 1121   assert(cbuf != NULL || st  != NULL, &quot;sanity&quot;);
 1122   // Get registers to move
 1123   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
 1124   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
 1125   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
 1126   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
 1127 
 1128   enum RC src_second_rc = rc_class(src_second);
 1129   enum RC src_first_rc = rc_class(src_first);
 1130   enum RC dst_second_rc = rc_class(dst_second);
 1131   enum RC dst_first_rc = rc_class(dst_first);
 1132 
 1133   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
 1134          &quot;must move at least 1 register&quot; );
 1135 
 1136   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
 1137     // Self copy, no move
 1138     return 0;
 1139   }
 1140   if (bottom_type()-&gt;isa_vect() != NULL) {
 1141     uint ireg = ideal_reg();
 1142     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), &quot;sanity&quot;);
 1143     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), &quot;sanity&quot;);
 1144     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
 1145       // mem -&gt; mem
 1146       int src_offset = ra_-&gt;reg2offset(src_first);
 1147       int dst_offset = ra_-&gt;reg2offset(dst_first);
 1148       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
 1149     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
 1150       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
 1151     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
 1152       int stack_offset = ra_-&gt;reg2offset(dst_first);
 1153       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
 1154     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
 1155       int stack_offset = ra_-&gt;reg2offset(src_first);
 1156       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
 1157     } else {
 1158       ShouldNotReachHere();
 1159     }
 1160     return 0;
 1161   }
 1162   if (src_first_rc == rc_stack) {
 1163     // mem -&gt;
 1164     if (dst_first_rc == rc_stack) {
 1165       // mem -&gt; mem
 1166       assert(src_second != dst_first, &quot;overlap&quot;);
 1167       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1168           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1169         // 64-bit
 1170         int src_offset = ra_-&gt;reg2offset(src_first);
 1171         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1172         if (cbuf) {
 1173           MacroAssembler _masm(cbuf);
 1174           __ pushq(Address(rsp, src_offset));
 1175           __ popq (Address(rsp, dst_offset));
 1176 #ifndef PRODUCT
 1177         } else {
 1178           st-&gt;print(&quot;pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t&quot;
 1179                     &quot;popq    [rsp + #%d]&quot;,
 1180                      src_offset, dst_offset);
 1181 #endif
 1182         }
 1183       } else {
 1184         // 32-bit
 1185         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1186         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1187         // No pushl/popl, so:
 1188         int src_offset = ra_-&gt;reg2offset(src_first);
 1189         int dst_offset = ra_-&gt;reg2offset(dst_first);
 1190         if (cbuf) {
 1191           MacroAssembler _masm(cbuf);
 1192           __ movq(Address(rsp, -8), rax);
 1193           __ movl(rax, Address(rsp, src_offset));
 1194           __ movl(Address(rsp, dst_offset), rax);
 1195           __ movq(rax, Address(rsp, -8));
 1196 #ifndef PRODUCT
 1197         } else {
 1198           st-&gt;print(&quot;movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t&quot;
 1199                     &quot;movl    rax, [rsp + #%d]\n\t&quot;
 1200                     &quot;movl    [rsp + #%d], rax\n\t&quot;
 1201                     &quot;movq    rax, [rsp - #8]&quot;,
 1202                      src_offset, dst_offset);
 1203 #endif
 1204         }
 1205       }
 1206       return 0;
 1207     } else if (dst_first_rc == rc_int) {
 1208       // mem -&gt; gpr
 1209       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1210           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1211         // 64-bit
 1212         int offset = ra_-&gt;reg2offset(src_first);
 1213         if (cbuf) {
 1214           MacroAssembler _masm(cbuf);
 1215           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1216 #ifndef PRODUCT
 1217         } else {
 1218           st-&gt;print(&quot;movq    %s, [rsp + #%d]\t# spill&quot;,
 1219                      Matcher::regName[dst_first],
 1220                      offset);
 1221 #endif
 1222         }
 1223       } else {
 1224         // 32-bit
 1225         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1226         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1227         int offset = ra_-&gt;reg2offset(src_first);
 1228         if (cbuf) {
 1229           MacroAssembler _masm(cbuf);
 1230           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1231 #ifndef PRODUCT
 1232         } else {
 1233           st-&gt;print(&quot;movl    %s, [rsp + #%d]\t# spill&quot;,
 1234                      Matcher::regName[dst_first],
 1235                      offset);
 1236 #endif
 1237         }
 1238       }
 1239       return 0;
 1240     } else if (dst_first_rc == rc_float) {
 1241       // mem-&gt; xmm
 1242       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1243           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1244         // 64-bit
 1245         int offset = ra_-&gt;reg2offset(src_first);
 1246         if (cbuf) {
 1247           MacroAssembler _masm(cbuf);
 1248           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1249 #ifndef PRODUCT
 1250         } else {
 1251           st-&gt;print(&quot;%s  %s, [rsp + #%d]\t# spill&quot;,
 1252                      UseXmmLoadAndClearUpper ? &quot;movsd &quot; : &quot;movlpd&quot;,
 1253                      Matcher::regName[dst_first],
 1254                      offset);
 1255 #endif
 1256         }
 1257       } else {
 1258         // 32-bit
 1259         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1260         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1261         int offset = ra_-&gt;reg2offset(src_first);
 1262         if (cbuf) {
 1263           MacroAssembler _masm(cbuf);
 1264           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
 1265 #ifndef PRODUCT
 1266         } else {
 1267           st-&gt;print(&quot;movss   %s, [rsp + #%d]\t# spill&quot;,
 1268                      Matcher::regName[dst_first],
 1269                      offset);
 1270 #endif
 1271         }
 1272       }
 1273       return 0;
 1274     }
 1275   } else if (src_first_rc == rc_int) {
 1276     // gpr -&gt;
 1277     if (dst_first_rc == rc_stack) {
 1278       // gpr -&gt; mem
 1279       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1280           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1281         // 64-bit
 1282         int offset = ra_-&gt;reg2offset(dst_first);
 1283         if (cbuf) {
 1284           MacroAssembler _masm(cbuf);
 1285           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1286 #ifndef PRODUCT
 1287         } else {
 1288           st-&gt;print(&quot;movq    [rsp + #%d], %s\t# spill&quot;,
 1289                      offset,
 1290                      Matcher::regName[src_first]);
 1291 #endif
 1292         }
 1293       } else {
 1294         // 32-bit
 1295         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1296         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1297         int offset = ra_-&gt;reg2offset(dst_first);
 1298         if (cbuf) {
 1299           MacroAssembler _masm(cbuf);
 1300           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
 1301 #ifndef PRODUCT
 1302         } else {
 1303           st-&gt;print(&quot;movl    [rsp + #%d], %s\t# spill&quot;,
 1304                      offset,
 1305                      Matcher::regName[src_first]);
 1306 #endif
 1307         }
 1308       }
 1309       return 0;
 1310     } else if (dst_first_rc == rc_int) {
 1311       // gpr -&gt; gpr
 1312       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1313           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1314         // 64-bit
 1315         if (cbuf) {
 1316           MacroAssembler _masm(cbuf);
 1317           __ movq(as_Register(Matcher::_regEncode[dst_first]),
 1318                   as_Register(Matcher::_regEncode[src_first]));
 1319 #ifndef PRODUCT
 1320         } else {
 1321           st-&gt;print(&quot;movq    %s, %s\t# spill&quot;,
 1322                      Matcher::regName[dst_first],
 1323                      Matcher::regName[src_first]);
 1324 #endif
 1325         }
 1326         return 0;
 1327       } else {
 1328         // 32-bit
 1329         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1330         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1331         if (cbuf) {
 1332           MacroAssembler _masm(cbuf);
 1333           __ movl(as_Register(Matcher::_regEncode[dst_first]),
 1334                   as_Register(Matcher::_regEncode[src_first]));
 1335 #ifndef PRODUCT
 1336         } else {
 1337           st-&gt;print(&quot;movl    %s, %s\t# spill&quot;,
 1338                      Matcher::regName[dst_first],
 1339                      Matcher::regName[src_first]);
 1340 #endif
 1341         }
 1342         return 0;
 1343       }
 1344     } else if (dst_first_rc == rc_float) {
 1345       // gpr -&gt; xmm
 1346       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1347           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1348         // 64-bit
 1349         if (cbuf) {
 1350           MacroAssembler _masm(cbuf);
 1351           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1352 #ifndef PRODUCT
 1353         } else {
 1354           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1355                      Matcher::regName[dst_first],
 1356                      Matcher::regName[src_first]);
 1357 #endif
 1358         }
 1359       } else {
 1360         // 32-bit
 1361         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1362         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1363         if (cbuf) {
 1364           MacroAssembler _masm(cbuf);
 1365           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
 1366 #ifndef PRODUCT
 1367         } else {
 1368           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1369                      Matcher::regName[dst_first],
 1370                      Matcher::regName[src_first]);
 1371 #endif
 1372         }
 1373       }
 1374       return 0;
 1375     }
 1376   } else if (src_first_rc == rc_float) {
 1377     // xmm -&gt;
 1378     if (dst_first_rc == rc_stack) {
 1379       // xmm -&gt; mem
 1380       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1381           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1382         // 64-bit
 1383         int offset = ra_-&gt;reg2offset(dst_first);
 1384         if (cbuf) {
 1385           MacroAssembler _masm(cbuf);
 1386           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1387 #ifndef PRODUCT
 1388         } else {
 1389           st-&gt;print(&quot;movsd   [rsp + #%d], %s\t# spill&quot;,
 1390                      offset,
 1391                      Matcher::regName[src_first]);
 1392 #endif
 1393         }
 1394       } else {
 1395         // 32-bit
 1396         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1397         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1398         int offset = ra_-&gt;reg2offset(dst_first);
 1399         if (cbuf) {
 1400           MacroAssembler _masm(cbuf);
 1401           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
 1402 #ifndef PRODUCT
 1403         } else {
 1404           st-&gt;print(&quot;movss   [rsp + #%d], %s\t# spill&quot;,
 1405                      offset,
 1406                      Matcher::regName[src_first]);
 1407 #endif
 1408         }
 1409       }
 1410       return 0;
 1411     } else if (dst_first_rc == rc_int) {
 1412       // xmm -&gt; gpr
 1413       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1414           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1415         // 64-bit
 1416         if (cbuf) {
 1417           MacroAssembler _masm(cbuf);
 1418           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1419 #ifndef PRODUCT
 1420         } else {
 1421           st-&gt;print(&quot;movdq   %s, %s\t# spill&quot;,
 1422                      Matcher::regName[dst_first],
 1423                      Matcher::regName[src_first]);
 1424 #endif
 1425         }
 1426       } else {
 1427         // 32-bit
 1428         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1429         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1430         if (cbuf) {
 1431           MacroAssembler _masm(cbuf);
 1432           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1433 #ifndef PRODUCT
 1434         } else {
 1435           st-&gt;print(&quot;movdl   %s, %s\t# spill&quot;,
 1436                      Matcher::regName[dst_first],
 1437                      Matcher::regName[src_first]);
 1438 #endif
 1439         }
 1440       }
 1441       return 0;
 1442     } else if (dst_first_rc == rc_float) {
 1443       // xmm -&gt; xmm
 1444       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
 1445           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
 1446         // 64-bit
 1447         if (cbuf) {
 1448           MacroAssembler _masm(cbuf);
 1449           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1450 #ifndef PRODUCT
 1451         } else {
 1452           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1453                      UseXmmRegToRegMoveAll ? &quot;movapd&quot; : &quot;movsd &quot;,
 1454                      Matcher::regName[dst_first],
 1455                      Matcher::regName[src_first]);
 1456 #endif
 1457         }
 1458       } else {
 1459         // 32-bit
 1460         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), &quot;no transform&quot;);
 1461         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), &quot;no transform&quot;);
 1462         if (cbuf) {
 1463           MacroAssembler _masm(cbuf);
 1464           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
 1465 #ifndef PRODUCT
 1466         } else {
 1467           st-&gt;print(&quot;%s  %s, %s\t# spill&quot;,
 1468                      UseXmmRegToRegMoveAll ? &quot;movaps&quot; : &quot;movss &quot;,
 1469                      Matcher::regName[dst_first],
 1470                      Matcher::regName[src_first]);
 1471 #endif
 1472         }
 1473       }
 1474       return 0;
 1475     }
 1476   }
 1477 
 1478   assert(0,&quot; foo &quot;);
 1479   Unimplemented();
 1480   return 0;
 1481 }
 1482 
 1483 #ifndef PRODUCT
 1484 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
 1485   implementation(NULL, ra_, false, st);
 1486 }
 1487 #endif
 1488 
 1489 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1490   implementation(&amp;cbuf, ra_, false, NULL);
 1491 }
 1492 
 1493 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1494   return MachNode::size(ra_);
 1495 }
 1496 
 1497 //=============================================================================
 1498 #ifndef PRODUCT
 1499 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1500 {
 1501   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1502   int reg = ra_-&gt;get_reg_first(this);
 1503   st-&gt;print(&quot;leaq    %s, [rsp + #%d]\t# box lock&quot;,
 1504             Matcher::regName[reg], offset);
 1505 }
 1506 #endif
 1507 
 1508 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1509 {
 1510   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1511   int reg = ra_-&gt;get_encode(this);
 1512   if (offset &gt;= 0x80) {
 1513     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1514     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1515     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1516     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1517     emit_d32(cbuf, offset);
 1518   } else {
 1519     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1520     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1521     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1522     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1523     emit_d8(cbuf, offset);
 1524   }
 1525 }
 1526 
 1527 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1528 {
 1529   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1530   return (offset &lt; 0x80) ? 5 : 8; // REX
 1531 }
 1532 
 1533 //=============================================================================
 1534 #ifndef PRODUCT
 1535 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1536 {
 1537   st-&gt;print_cr(&quot;MachVEPNode&quot;);
 1538 }
 1539 #endif
 1540 
 1541 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1542 {
 1543   MacroAssembler masm(&amp;cbuf);
 1544   if (!_verified) {  
 1545     uint insts_size = cbuf.insts_size();
 1546     if (UseCompressedClassPointers) {
 1547       masm.load_klass(rscratch1, j_rarg0);
 1548       masm.cmpptr(rax, rscratch1);
 1549     } else {
 1550       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1551     }
 1552     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1553   } else {
 1554     // Unpack value type args passed as oop and then jump to
 1555     // the verified entry point (skipping the unverified entry).
 1556     masm.unpack_value_args(ra_-&gt;C, _receiver_only);
 1557     masm.jmp(*_verified_entry);
 1558   }
 1559 }
 1560 
 1561 //=============================================================================
 1562 #ifndef PRODUCT
 1563 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1564 {
 1565   if (UseCompressedClassPointers) {
 1566     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1567     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1568     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1569   } else {
 1570     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1571                  &quot;# Inline cache check&quot;);
 1572   }
 1573   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1574   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1575 }
 1576 #endif
 1577 
 1578 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1579 {
 1580   MacroAssembler masm(&amp;cbuf);
 1581   uint insts_size = cbuf.insts_size();
 1582   if (UseCompressedClassPointers) {
 1583     masm.load_klass(rscratch1, j_rarg0);
 1584     masm.cmpptr(rax, rscratch1);
 1585   } else {
 1586     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1587   }
 1588 
 1589   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1590 
 1591   /* WARNING these NOPs are critical so that verified entry point is properly
 1592      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1593   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1594   if (OptoBreakpoint) {
 1595     // Leave space for int3
 1596     nops_cnt -= 1;
 1597   }
 1598   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1599   if (nops_cnt &gt; 0)
 1600     masm.nop(nops_cnt);
 1601 }
 1602 
 1603 //=============================================================================
 1604 
 1605 int Matcher::regnum_to_fpu_offset(int regnum)
 1606 {
 1607   return regnum - 32; // The FP registers are in the second chunk
 1608 }
 1609 
 1610 // This is UltraSparc specific, true just means we have fast l2f conversion
 1611 const bool Matcher::convL2FSupported(void) {
 1612   return true;
 1613 }
 1614 
 1615 // Is this branch offset short enough that a short branch can be used?
 1616 //
 1617 // NOTE: If the platform does not provide any short branch variants, then
 1618 //       this method should return false for offset 0.
 1619 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1620   // The passed offset is relative to address of the branch.
 1621   // On 86 a branch displacement is calculated relative to address
 1622   // of a next instruction.
 1623   offset -= br_size;
 1624 
 1625   // the short version of jmpConUCF2 contains multiple branches,
 1626   // making the reach slightly less
 1627   if (rule == jmpConUCF2_rule)
 1628     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
 1629   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
 1630 }
 1631 
 1632 const bool Matcher::isSimpleConstant64(jlong value) {
 1633   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1634   //return value == (int) value;  // Cf. storeImmL and immL32.
 1635 
 1636   // Probably always true, even if a temp register is required.
 1637   return true;
 1638 }
 1639 
 1640 // The ecx parameter to rep stosq for the ClearArray node is in words.
 1641 const bool Matcher::init_array_count_is_in_bytes = false;
 1642 
 1643 // No additional cost for CMOVL.
 1644 const int Matcher::long_cmove_cost() { return 0; }
 1645 
 1646 // No CMOVF/CMOVD with SSE2
 1647 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1648 
 1649 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1650 const bool Matcher::require_postalloc_expand = false;
 1651 
 1652 // Do we need to mask the count passed to shift instructions or does
 1653 // the cpu only look at the lower 5/6 bits anyway?
 1654 const bool Matcher::need_masked_shift_count = false;
 1655 
 1656 bool Matcher::narrow_oop_use_complex_address() {
 1657   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1658   return (LogMinObjAlignmentInBytes &lt;= 3);
 1659 }
 1660 
 1661 bool Matcher::narrow_klass_use_complex_address() {
 1662   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1663   return (LogKlassAlignmentInBytes &lt;= 3);
 1664 }
 1665 
 1666 bool Matcher::const_oop_prefer_decode() {
 1667   // Prefer ConN+DecodeN over ConP.
 1668   return true;
 1669 }
 1670 
 1671 bool Matcher::const_klass_prefer_decode() {
 1672   // TODO: Either support matching DecodeNKlass (heap-based) in operand
 1673   //       or condisider the following:
 1674   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 1675   //return CompressedKlassPointers::base() == NULL;
 1676   return true;
 1677 }
 1678 
 1679 // Is it better to copy float constants, or load them directly from
 1680 // memory?  Intel can load a float constant from a direct address,
 1681 // requiring no extra registers.  Most RISCs will have to materialize
 1682 // an address into a register first, so they would do better to copy
 1683 // the constant from stack.
 1684 const bool Matcher::rematerialize_float_constants = true; // XXX
 1685 
 1686 // If CPU can load and store mis-aligned doubles directly then no
 1687 // fixup is needed.  Else we split the double into 2 integer pieces
 1688 // and move it piece-by-piece.  Only happens when passing doubles into
 1689 // C code as the Java calling convention forces doubles to be aligned.
 1690 const bool Matcher::misaligned_doubles_ok = true;
 1691 
 1692 // No-op on amd64
 1693 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
 1694 
 1695 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1696 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1697 
 1698 // Are floats conerted to double when stored to stack during deoptimization?
 1699 // On x64 it is stored without convertion so we can use normal access.
 1700 bool Matcher::float_in_double() { return false; }
 1701 
 1702 // Do ints take an entire long register or just half?
 1703 const bool Matcher::int_in_long = true;
 1704 
 1705 // Return whether or not this register is ever used as an argument.
 1706 // This function is used on startup to build the trampoline stubs in
 1707 // generateOptoStub.  Registers not mentioned will be killed by the VM
 1708 // call in the trampoline, and arguments in those registers not be
 1709 // available to the callee.
 1710 bool Matcher::can_be_java_arg(int reg)
 1711 {
 1712   return
 1713     reg ==  RDI_num || reg == RDI_H_num ||
 1714     reg ==  RSI_num || reg == RSI_H_num ||
 1715     reg ==  RDX_num || reg == RDX_H_num ||
 1716     reg ==  RCX_num || reg == RCX_H_num ||
 1717     reg ==   R8_num || reg ==  R8_H_num ||
 1718     reg ==   R9_num || reg ==  R9_H_num ||
 1719     reg ==  R12_num || reg == R12_H_num ||
 1720     reg == XMM0_num || reg == XMM0b_num ||
 1721     reg == XMM1_num || reg == XMM1b_num ||
 1722     reg == XMM2_num || reg == XMM2b_num ||
 1723     reg == XMM3_num || reg == XMM3b_num ||
 1724     reg == XMM4_num || reg == XMM4b_num ||
 1725     reg == XMM5_num || reg == XMM5b_num ||
 1726     reg == XMM6_num || reg == XMM6b_num ||
 1727     reg == XMM7_num || reg == XMM7b_num;
 1728 }
 1729 
 1730 bool Matcher::is_spillable_arg(int reg)
 1731 {
 1732   return can_be_java_arg(reg);
 1733 }
 1734 
 1735 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1736   // In 64 bit mode a code which use multiply when
 1737   // devisor is constant is faster than hardware
 1738   // DIV instruction (it uses MulHiL).
 1739   return false;
 1740 }
 1741 
 1742 // Register for DIVI projection of divmodI
 1743 RegMask Matcher::divI_proj_mask() {
 1744   return INT_RAX_REG_mask();
 1745 }
 1746 
 1747 // Register for MODI projection of divmodI
 1748 RegMask Matcher::modI_proj_mask() {
 1749   return INT_RDX_REG_mask();
 1750 }
 1751 
 1752 // Register for DIVL projection of divmodL
 1753 RegMask Matcher::divL_proj_mask() {
 1754   return LONG_RAX_REG_mask();
 1755 }
 1756 
 1757 // Register for MODL projection of divmodL
 1758 RegMask Matcher::modL_proj_mask() {
 1759   return LONG_RDX_REG_mask();
 1760 }
 1761 
 1762 // Register for saving SP into on method handle invokes. Not used on x86_64.
 1763 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1764     return NO_REG_mask();
 1765 }
 1766 
 1767 %}
 1768 
 1769 //----------ENCODING BLOCK-----------------------------------------------------
 1770 // This block specifies the encoding classes used by the compiler to
 1771 // output byte streams.  Encoding classes are parameterized macros
 1772 // used by Machine Instruction Nodes in order to generate the bit
 1773 // encoding of the instruction.  Operands specify their base encoding
 1774 // interface with the interface keyword.  There are currently
 1775 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
 1776 // COND_INTER.  REG_INTER causes an operand to generate a function
 1777 // which returns its register number when queried.  CONST_INTER causes
 1778 // an operand to generate a function which returns the value of the
 1779 // constant when queried.  MEMORY_INTER causes an operand to generate
 1780 // four functions which return the Base Register, the Index Register,
 1781 // the Scale Value, and the Offset Value of the operand when queried.
 1782 // COND_INTER causes an operand to generate six functions which return
 1783 // the encoding code (ie - encoding bits for the instruction)
 1784 // associated with each basic boolean condition for a conditional
 1785 // instruction.
 1786 //
 1787 // Instructions specify two basic values for encoding.  Again, a
 1788 // function is available to check if the constant displacement is an
 1789 // oop. They use the ins_encode keyword to specify their encoding
 1790 // classes (which must be a sequence of enc_class names, and their
 1791 // parameters, specified in the encoding block), and they use the
 1792 // opcode keyword to specify, in order, their primary, secondary, and
 1793 // tertiary opcode.  Only the opcode sections which a particular
 1794 // instruction needs for encoding need to be specified.
 1795 encode %{
 1796   // Build emit functions for each basic byte or larger field in the
 1797   // intel encoding scheme (opcode, rm, sib, immediate), and call them
 1798   // from C++ code in the enc_class source block.  Emit functions will
 1799   // live in the main source block for now.  In future, we can
 1800   // generalize this by adding a syntax that specifies the sizes of
 1801   // fields in an order, so that the adlc can build the emit functions
 1802   // automagically
 1803 
 1804   // Emit primary opcode
 1805   enc_class OpcP
 1806   %{
 1807     emit_opcode(cbuf, $primary);
 1808   %}
 1809 
 1810   // Emit secondary opcode
 1811   enc_class OpcS
 1812   %{
 1813     emit_opcode(cbuf, $secondary);
 1814   %}
 1815 
 1816   // Emit tertiary opcode
 1817   enc_class OpcT
 1818   %{
 1819     emit_opcode(cbuf, $tertiary);
 1820   %}
 1821 
 1822   // Emit opcode directly
 1823   enc_class Opcode(immI d8)
 1824   %{
 1825     emit_opcode(cbuf, $d8$$constant);
 1826   %}
 1827 
 1828   // Emit size prefix
 1829   enc_class SizePrefix
 1830   %{
 1831     emit_opcode(cbuf, 0x66);
 1832   %}
 1833 
 1834   enc_class reg(rRegI reg)
 1835   %{
 1836     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
 1837   %}
 1838 
 1839   enc_class reg_reg(rRegI dst, rRegI src)
 1840   %{
 1841     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1842   %}
 1843 
 1844   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
 1845   %{
 1846     emit_opcode(cbuf, $opcode$$constant);
 1847     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
 1848   %}
 1849 
 1850   enc_class cdql_enc(no_rax_rdx_RegI div)
 1851   %{
 1852     // Full implementation of Java idiv and irem; checks for
 1853     // special case as described in JVM spec., p.243 &amp; p.271.
 1854     //
 1855     //         normal case                           special case
 1856     //
 1857     // input : rax: dividend                         min_int
 1858     //         reg: divisor                          -1
 1859     //
 1860     // output: rax: quotient  (= rax idiv reg)       min_int
 1861     //         rdx: remainder (= rax irem reg)       0
 1862     //
 1863     //  Code sequnce:
 1864     //
 1865     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
 1866     //    5:   75 07/08                jne    e &lt;normal&gt;
 1867     //    7:   33 d2                   xor    %edx,%edx
 1868     //  [div &gt;= 8 -&gt; offset + 1]
 1869     //  [REX_B]
 1870     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
 1871     //    c:   74 03/04                je     11 &lt;done&gt;
 1872     // 000000000000000e &lt;normal&gt;:
 1873     //    e:   99                      cltd
 1874     //  [div &gt;= 8 -&gt; offset + 1]
 1875     //  [REX_B]
 1876     //    f:   f7 f9                   idiv   $div
 1877     // 0000000000000011 &lt;done&gt;:
 1878 
 1879     // cmp    $0x80000000,%eax
 1880     emit_opcode(cbuf, 0x3d);
 1881     emit_d8(cbuf, 0x00);
 1882     emit_d8(cbuf, 0x00);
 1883     emit_d8(cbuf, 0x00);
 1884     emit_d8(cbuf, 0x80);
 1885 
 1886     // jne    e &lt;normal&gt;
 1887     emit_opcode(cbuf, 0x75);
 1888     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
 1889 
 1890     // xor    %edx,%edx
 1891     emit_opcode(cbuf, 0x33);
 1892     emit_d8(cbuf, 0xD2);
 1893 
 1894     // cmp    $0xffffffffffffffff,%ecx
 1895     if ($div$$reg &gt;= 8) {
 1896       emit_opcode(cbuf, Assembler::REX_B);
 1897     }
 1898     emit_opcode(cbuf, 0x83);
 1899     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1900     emit_d8(cbuf, 0xFF);
 1901 
 1902     // je     11 &lt;done&gt;
 1903     emit_opcode(cbuf, 0x74);
 1904     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
 1905 
 1906     // &lt;normal&gt;
 1907     // cltd
 1908     emit_opcode(cbuf, 0x99);
 1909 
 1910     // idivl (note: must be emitted by the user of this rule)
 1911     // &lt;done&gt;
 1912   %}
 1913 
 1914   enc_class cdqq_enc(no_rax_rdx_RegL div)
 1915   %{
 1916     // Full implementation of Java ldiv and lrem; checks for
 1917     // special case as described in JVM spec., p.243 &amp; p.271.
 1918     //
 1919     //         normal case                           special case
 1920     //
 1921     // input : rax: dividend                         min_long
 1922     //         reg: divisor                          -1
 1923     //
 1924     // output: rax: quotient  (= rax idiv reg)       min_long
 1925     //         rdx: remainder (= rax irem reg)       0
 1926     //
 1927     //  Code sequnce:
 1928     //
 1929     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
 1930     //    7:   00 00 80
 1931     //    a:   48 39 d0                cmp    %rdx,%rax
 1932     //    d:   75 08                   jne    17 &lt;normal&gt;
 1933     //    f:   33 d2                   xor    %edx,%edx
 1934     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
 1935     //   15:   74 05                   je     1c &lt;done&gt;
 1936     // 0000000000000017 &lt;normal&gt;:
 1937     //   17:   48 99                   cqto
 1938     //   19:   48 f7 f9                idiv   $div
 1939     // 000000000000001c &lt;done&gt;:
 1940 
 1941     // mov    $0x8000000000000000,%rdx
 1942     emit_opcode(cbuf, Assembler::REX_W);
 1943     emit_opcode(cbuf, 0xBA);
 1944     emit_d8(cbuf, 0x00);
 1945     emit_d8(cbuf, 0x00);
 1946     emit_d8(cbuf, 0x00);
 1947     emit_d8(cbuf, 0x00);
 1948     emit_d8(cbuf, 0x00);
 1949     emit_d8(cbuf, 0x00);
 1950     emit_d8(cbuf, 0x00);
 1951     emit_d8(cbuf, 0x80);
 1952 
 1953     // cmp    %rdx,%rax
 1954     emit_opcode(cbuf, Assembler::REX_W);
 1955     emit_opcode(cbuf, 0x39);
 1956     emit_d8(cbuf, 0xD0);
 1957 
 1958     // jne    17 &lt;normal&gt;
 1959     emit_opcode(cbuf, 0x75);
 1960     emit_d8(cbuf, 0x08);
 1961 
 1962     // xor    %edx,%edx
 1963     emit_opcode(cbuf, 0x33);
 1964     emit_d8(cbuf, 0xD2);
 1965 
 1966     // cmp    $0xffffffffffffffff,$div
 1967     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
 1968     emit_opcode(cbuf, 0x83);
 1969     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
 1970     emit_d8(cbuf, 0xFF);
 1971 
 1972     // je     1e &lt;done&gt;
 1973     emit_opcode(cbuf, 0x74);
 1974     emit_d8(cbuf, 0x05);
 1975 
 1976     // &lt;normal&gt;
 1977     // cqto
 1978     emit_opcode(cbuf, Assembler::REX_W);
 1979     emit_opcode(cbuf, 0x99);
 1980 
 1981     // idivq (note: must be emitted by the user of this rule)
 1982     // &lt;done&gt;
 1983   %}
 1984 
 1985   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
 1986   enc_class OpcSE(immI imm)
 1987   %{
 1988     // Emit primary opcode and set sign-extend bit
 1989     // Check for 8-bit immediate, and set sign extend bit in opcode
 1990     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 1991       emit_opcode(cbuf, $primary | 0x02);
 1992     } else {
 1993       // 32-bit immediate
 1994       emit_opcode(cbuf, $primary);
 1995     }
 1996   %}
 1997 
 1998   enc_class OpcSErm(rRegI dst, immI imm)
 1999   %{
 2000     // OpcSEr/m
 2001     int dstenc = $dst$$reg;
 2002     if (dstenc &gt;= 8) {
 2003       emit_opcode(cbuf, Assembler::REX_B);
 2004       dstenc -= 8;
 2005     }
 2006     // Emit primary opcode and set sign-extend bit
 2007     // Check for 8-bit immediate, and set sign extend bit in opcode
 2008     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2009       emit_opcode(cbuf, $primary | 0x02);
 2010     } else {
 2011       // 32-bit immediate
 2012       emit_opcode(cbuf, $primary);
 2013     }
 2014     // Emit r/m byte with secondary opcode, after primary opcode.
 2015     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2016   %}
 2017 
 2018   enc_class OpcSErm_wide(rRegL dst, immI imm)
 2019   %{
 2020     // OpcSEr/m
 2021     int dstenc = $dst$$reg;
 2022     if (dstenc &lt; 8) {
 2023       emit_opcode(cbuf, Assembler::REX_W);
 2024     } else {
 2025       emit_opcode(cbuf, Assembler::REX_WB);
 2026       dstenc -= 8;
 2027     }
 2028     // Emit primary opcode and set sign-extend bit
 2029     // Check for 8-bit immediate, and set sign extend bit in opcode
 2030     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2031       emit_opcode(cbuf, $primary | 0x02);
 2032     } else {
 2033       // 32-bit immediate
 2034       emit_opcode(cbuf, $primary);
 2035     }
 2036     // Emit r/m byte with secondary opcode, after primary opcode.
 2037     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2038   %}
 2039 
 2040   enc_class Con8or32(immI imm)
 2041   %{
 2042     // Check for 8-bit immediate, and set sign extend bit in opcode
 2043     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
 2044       $$$emit8$imm$$constant;
 2045     } else {
 2046       // 32-bit immediate
 2047       $$$emit32$imm$$constant;
 2048     }
 2049   %}
 2050 
 2051   enc_class opc2_reg(rRegI dst)
 2052   %{
 2053     // BSWAP
 2054     emit_cc(cbuf, $secondary, $dst$$reg);
 2055   %}
 2056 
 2057   enc_class opc3_reg(rRegI dst)
 2058   %{
 2059     // BSWAP
 2060     emit_cc(cbuf, $tertiary, $dst$$reg);
 2061   %}
 2062 
 2063   enc_class reg_opc(rRegI div)
 2064   %{
 2065     // INC, DEC, IDIV, IMOD, JMP indirect, ...
 2066     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
 2067   %}
 2068 
 2069   enc_class enc_cmov(cmpOp cop)
 2070   %{
 2071     // CMOV
 2072     $$$emit8$primary;
 2073     emit_cc(cbuf, $secondary, $cop$$cmpcode);
 2074   %}
 2075 
 2076   enc_class enc_PartialSubtypeCheck()
 2077   %{
 2078     Register Rrdi = as_Register(RDI_enc); // result register
 2079     Register Rrax = as_Register(RAX_enc); // super class
 2080     Register Rrcx = as_Register(RCX_enc); // killed
 2081     Register Rrsi = as_Register(RSI_enc); // sub class
 2082     Label miss;
 2083     const bool set_cond_codes = true;
 2084 
 2085     MacroAssembler _masm(&amp;cbuf);
 2086     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
 2087                                      NULL, &amp;miss,
 2088                                      /*set_cond_codes:*/ true);
 2089     if ($primary) {
 2090       __ xorptr(Rrdi, Rrdi);
 2091     }
 2092     __ bind(miss);
 2093   %}
 2094 
 2095   enc_class clear_avx %{
 2096     debug_only(int off0 = cbuf.insts_size());
 2097     if (generate_vzeroupper(Compile::current())) {
 2098       // Clear upper bits of YMM registers to avoid AVX &lt;-&gt; SSE transition penalty
 2099       // Clear upper bits of YMM registers when current compiled code uses
 2100       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 2101       MacroAssembler _masm(&amp;cbuf);
 2102       __ vzeroupper();
 2103     }
 2104     debug_only(int off1 = cbuf.insts_size());
 2105     assert(off1 - off0 == clear_avx_size(), &quot;correct size prediction&quot;);
 2106   %}
 2107 
 2108   enc_class Java_To_Runtime(method meth) %{
 2109     // No relocation needed
 2110     MacroAssembler _masm(&amp;cbuf);
 2111     __ mov64(r10, (int64_t) $meth$$method);
 2112     __ call(r10);
 2113   %}
 2114 
 2115   enc_class Java_To_Interpreter(method meth)
 2116   %{
 2117     // CALL Java_To_Interpreter
 2118     // This is the instruction starting address for relocation info.
 2119     cbuf.set_insts_mark();
 2120     $$$emit8$primary;
 2121     // CALL directly to the runtime
 2122     emit_d32_reloc(cbuf,
 2123                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2124                    runtime_call_Relocation::spec(),
 2125                    RELOC_DISP32);
 2126   %}
 2127 
 2128   enc_class Java_Static_Call(method meth)
 2129   %{
 2130     // JAVA STATIC CALL
 2131     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
 2132     // determine who we intended to call.
 2133     cbuf.set_insts_mark();
 2134     $$$emit8$primary;
 2135 
 2136     if (!_method) {
 2137       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2138                      runtime_call_Relocation::spec(),
 2139                      RELOC_DISP32);
 2140     } else {
 2141       int method_index = resolved_method_index(cbuf);
 2142       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2143                                                   : static_call_Relocation::spec(method_index);
 2144       emit_d32_reloc(cbuf, (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
 2145                      rspec, RELOC_DISP32);
 2146       // Emit stubs for static call.
 2147       address mark = cbuf.insts_mark();
 2148       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
 2149       if (stub == NULL) {
 2150         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2151         return;
 2152       }
 2153 #if INCLUDE_AOT
 2154       CompiledStaticCall::emit_to_aot_stub(cbuf, mark);
 2155 #endif
 2156     }
 2157   %}
 2158 
 2159   enc_class Java_Dynamic_Call(method meth) %{
 2160     MacroAssembler _masm(&amp;cbuf);
 2161     __ ic_call((address)$meth$$method, resolved_method_index(cbuf));
 2162   %}
 2163 
 2164   enc_class Java_Compiled_Call(method meth)
 2165   %{
 2166     // JAVA COMPILED CALL
 2167     int disp = in_bytes(Method:: from_compiled_offset());
 2168 
 2169     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
 2170     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, &quot;compiled_code_offset isn&#39;t small&quot;);
 2171 
 2172     // callq *disp(%rax)
 2173     cbuf.set_insts_mark();
 2174     $$$emit8$primary;
 2175     if (disp &lt; 0x80) {
 2176       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
 2177       emit_d8(cbuf, disp); // Displacement
 2178     } else {
 2179       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
 2180       emit_d32(cbuf, disp); // Displacement
 2181     }
 2182   %}
 2183 
 2184   enc_class reg_opc_imm(rRegI dst, immI8 shift)
 2185   %{
 2186     // SAL, SAR, SHR
 2187     int dstenc = $dst$$reg;
 2188     if (dstenc &gt;= 8) {
 2189       emit_opcode(cbuf, Assembler::REX_B);
 2190       dstenc -= 8;
 2191     }
 2192     $$$emit8$primary;
 2193     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2194     $$$emit8$shift$$constant;
 2195   %}
 2196 
 2197   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
 2198   %{
 2199     // SAL, SAR, SHR
 2200     int dstenc = $dst$$reg;
 2201     if (dstenc &lt; 8) {
 2202       emit_opcode(cbuf, Assembler::REX_W);
 2203     } else {
 2204       emit_opcode(cbuf, Assembler::REX_WB);
 2205       dstenc -= 8;
 2206     }
 2207     $$$emit8$primary;
 2208     emit_rm(cbuf, 0x3, $secondary, dstenc);
 2209     $$$emit8$shift$$constant;
 2210   %}
 2211 
 2212   enc_class load_immI(rRegI dst, immI src)
 2213   %{
 2214     int dstenc = $dst$$reg;
 2215     if (dstenc &gt;= 8) {
 2216       emit_opcode(cbuf, Assembler::REX_B);
 2217       dstenc -= 8;
 2218     }
 2219     emit_opcode(cbuf, 0xB8 | dstenc);
 2220     $$$emit32$src$$constant;
 2221   %}
 2222 
 2223   enc_class load_immL(rRegL dst, immL src)
 2224   %{
 2225     int dstenc = $dst$$reg;
 2226     if (dstenc &lt; 8) {
 2227       emit_opcode(cbuf, Assembler::REX_W);
 2228     } else {
 2229       emit_opcode(cbuf, Assembler::REX_WB);
 2230       dstenc -= 8;
 2231     }
 2232     emit_opcode(cbuf, 0xB8 | dstenc);
 2233     emit_d64(cbuf, $src$$constant);
 2234   %}
 2235 
 2236   enc_class load_immUL32(rRegL dst, immUL32 src)
 2237   %{
 2238     // same as load_immI, but this time we care about zeroes in the high word
 2239     int dstenc = $dst$$reg;
 2240     if (dstenc &gt;= 8) {
 2241       emit_opcode(cbuf, Assembler::REX_B);
 2242       dstenc -= 8;
 2243     }
 2244     emit_opcode(cbuf, 0xB8 | dstenc);
 2245     $$$emit32$src$$constant;
 2246   %}
 2247 
 2248   enc_class load_immL32(rRegL dst, immL32 src)
 2249   %{
 2250     int dstenc = $dst$$reg;
 2251     if (dstenc &lt; 8) {
 2252       emit_opcode(cbuf, Assembler::REX_W);
 2253     } else {
 2254       emit_opcode(cbuf, Assembler::REX_WB);
 2255       dstenc -= 8;
 2256     }
 2257     emit_opcode(cbuf, 0xC7);
 2258     emit_rm(cbuf, 0x03, 0x00, dstenc);
 2259     $$$emit32$src$$constant;
 2260   %}
 2261 
 2262   enc_class load_immP31(rRegP dst, immP32 src)
 2263   %{
 2264     // same as load_immI, but this time we care about zeroes in the high word
 2265     int dstenc = $dst$$reg;
 2266     if (dstenc &gt;= 8) {
 2267       emit_opcode(cbuf, Assembler::REX_B);
 2268       dstenc -= 8;
 2269     }
 2270     emit_opcode(cbuf, 0xB8 | dstenc);
 2271     $$$emit32$src$$constant;
 2272   %}
 2273 
 2274   enc_class load_immP(rRegP dst, immP src)
 2275   %{
 2276     int dstenc = $dst$$reg;
 2277     if (dstenc &lt; 8) {
 2278       emit_opcode(cbuf, Assembler::REX_W);
 2279     } else {
 2280       emit_opcode(cbuf, Assembler::REX_WB);
 2281       dstenc -= 8;
 2282     }
 2283     emit_opcode(cbuf, 0xB8 | dstenc);
 2284     // This next line should be generated from ADLC
 2285     if ($src-&gt;constant_reloc() != relocInfo::none) {
 2286       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
 2287     } else {
 2288       emit_d64(cbuf, $src$$constant);
 2289     }
 2290   %}
 2291 
 2292   enc_class Con32(immI src)
 2293   %{
 2294     // Output immediate
 2295     $$$emit32$src$$constant;
 2296   %}
 2297 
 2298   enc_class Con32F_as_bits(immF src)
 2299   %{
 2300     // Output Float immediate bits
 2301     jfloat jf = $src$$constant;
 2302     jint jf_as_bits = jint_cast(jf);
 2303     emit_d32(cbuf, jf_as_bits);
 2304   %}
 2305 
 2306   enc_class Con16(immI src)
 2307   %{
 2308     // Output immediate
 2309     $$$emit16$src$$constant;
 2310   %}
 2311 
 2312   // How is this different from Con32??? XXX
 2313   enc_class Con_d32(immI src)
 2314   %{
 2315     emit_d32(cbuf,$src$$constant);
 2316   %}
 2317 
 2318   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
 2319     // Output immediate memory reference
 2320     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
 2321     emit_d32(cbuf, 0x00);
 2322   %}
 2323 
 2324   enc_class lock_prefix()
 2325   %{
 2326     emit_opcode(cbuf, 0xF0); // lock
 2327   %}
 2328 
 2329   enc_class REX_mem(memory mem)
 2330   %{
 2331     if ($mem$$base &gt;= 8) {
 2332       if ($mem$$index &lt; 8) {
 2333         emit_opcode(cbuf, Assembler::REX_B);
 2334       } else {
 2335         emit_opcode(cbuf, Assembler::REX_XB);
 2336       }
 2337     } else {
 2338       if ($mem$$index &gt;= 8) {
 2339         emit_opcode(cbuf, Assembler::REX_X);
 2340       }
 2341     }
 2342   %}
 2343 
 2344   enc_class REX_mem_wide(memory mem)
 2345   %{
 2346     if ($mem$$base &gt;= 8) {
 2347       if ($mem$$index &lt; 8) {
 2348         emit_opcode(cbuf, Assembler::REX_WB);
 2349       } else {
 2350         emit_opcode(cbuf, Assembler::REX_WXB);
 2351       }
 2352     } else {
 2353       if ($mem$$index &lt; 8) {
 2354         emit_opcode(cbuf, Assembler::REX_W);
 2355       } else {
 2356         emit_opcode(cbuf, Assembler::REX_WX);
 2357       }
 2358     }
 2359   %}
 2360 
 2361   // for byte regs
 2362   enc_class REX_breg(rRegI reg)
 2363   %{
 2364     if ($reg$$reg &gt;= 4) {
 2365       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2366     }
 2367   %}
 2368 
 2369   // for byte regs
 2370   enc_class REX_reg_breg(rRegI dst, rRegI src)
 2371   %{
 2372     if ($dst$$reg &lt; 8) {
 2373       if ($src$$reg &gt;= 4) {
 2374         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2375       }
 2376     } else {
 2377       if ($src$$reg &lt; 8) {
 2378         emit_opcode(cbuf, Assembler::REX_R);
 2379       } else {
 2380         emit_opcode(cbuf, Assembler::REX_RB);
 2381       }
 2382     }
 2383   %}
 2384 
 2385   // for byte regs
 2386   enc_class REX_breg_mem(rRegI reg, memory mem)
 2387   %{
 2388     if ($reg$$reg &lt; 8) {
 2389       if ($mem$$base &lt; 8) {
 2390         if ($mem$$index &gt;= 8) {
 2391           emit_opcode(cbuf, Assembler::REX_X);
 2392         } else if ($reg$$reg &gt;= 4) {
 2393           emit_opcode(cbuf, Assembler::REX);
 2394         }
 2395       } else {
 2396         if ($mem$$index &lt; 8) {
 2397           emit_opcode(cbuf, Assembler::REX_B);
 2398         } else {
 2399           emit_opcode(cbuf, Assembler::REX_XB);
 2400         }
 2401       }
 2402     } else {
 2403       if ($mem$$base &lt; 8) {
 2404         if ($mem$$index &lt; 8) {
 2405           emit_opcode(cbuf, Assembler::REX_R);
 2406         } else {
 2407           emit_opcode(cbuf, Assembler::REX_RX);
 2408         }
 2409       } else {
 2410         if ($mem$$index &lt; 8) {
 2411           emit_opcode(cbuf, Assembler::REX_RB);
 2412         } else {
 2413           emit_opcode(cbuf, Assembler::REX_RXB);
 2414         }
 2415       }
 2416     }
 2417   %}
 2418 
 2419   enc_class REX_reg(rRegI reg)
 2420   %{
 2421     if ($reg$$reg &gt;= 8) {
 2422       emit_opcode(cbuf, Assembler::REX_B);
 2423     }
 2424   %}
 2425 
 2426   enc_class REX_reg_wide(rRegI reg)
 2427   %{
 2428     if ($reg$$reg &lt; 8) {
 2429       emit_opcode(cbuf, Assembler::REX_W);
 2430     } else {
 2431       emit_opcode(cbuf, Assembler::REX_WB);
 2432     }
 2433   %}
 2434 
 2435   enc_class REX_reg_reg(rRegI dst, rRegI src)
 2436   %{
 2437     if ($dst$$reg &lt; 8) {
 2438       if ($src$$reg &gt;= 8) {
 2439         emit_opcode(cbuf, Assembler::REX_B);
 2440       }
 2441     } else {
 2442       if ($src$$reg &lt; 8) {
 2443         emit_opcode(cbuf, Assembler::REX_R);
 2444       } else {
 2445         emit_opcode(cbuf, Assembler::REX_RB);
 2446       }
 2447     }
 2448   %}
 2449 
 2450   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
 2451   %{
 2452     if ($dst$$reg &lt; 8) {
 2453       if ($src$$reg &lt; 8) {
 2454         emit_opcode(cbuf, Assembler::REX_W);
 2455       } else {
 2456         emit_opcode(cbuf, Assembler::REX_WB);
 2457       }
 2458     } else {
 2459       if ($src$$reg &lt; 8) {
 2460         emit_opcode(cbuf, Assembler::REX_WR);
 2461       } else {
 2462         emit_opcode(cbuf, Assembler::REX_WRB);
 2463       }
 2464     }
 2465   %}
 2466 
 2467   enc_class REX_reg_mem(rRegI reg, memory mem)
 2468   %{
 2469     if ($reg$$reg &lt; 8) {
 2470       if ($mem$$base &lt; 8) {
 2471         if ($mem$$index &gt;= 8) {
 2472           emit_opcode(cbuf, Assembler::REX_X);
 2473         }
 2474       } else {
 2475         if ($mem$$index &lt; 8) {
 2476           emit_opcode(cbuf, Assembler::REX_B);
 2477         } else {
 2478           emit_opcode(cbuf, Assembler::REX_XB);
 2479         }
 2480       }
 2481     } else {
 2482       if ($mem$$base &lt; 8) {
 2483         if ($mem$$index &lt; 8) {
 2484           emit_opcode(cbuf, Assembler::REX_R);
 2485         } else {
 2486           emit_opcode(cbuf, Assembler::REX_RX);
 2487         }
 2488       } else {
 2489         if ($mem$$index &lt; 8) {
 2490           emit_opcode(cbuf, Assembler::REX_RB);
 2491         } else {
 2492           emit_opcode(cbuf, Assembler::REX_RXB);
 2493         }
 2494       }
 2495     }
 2496   %}
 2497 
 2498   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
 2499   %{
 2500     if ($reg$$reg &lt; 8) {
 2501       if ($mem$$base &lt; 8) {
 2502         if ($mem$$index &lt; 8) {
 2503           emit_opcode(cbuf, Assembler::REX_W);
 2504         } else {
 2505           emit_opcode(cbuf, Assembler::REX_WX);
 2506         }
 2507       } else {
 2508         if ($mem$$index &lt; 8) {
 2509           emit_opcode(cbuf, Assembler::REX_WB);
 2510         } else {
 2511           emit_opcode(cbuf, Assembler::REX_WXB);
 2512         }
 2513       }
 2514     } else {
 2515       if ($mem$$base &lt; 8) {
 2516         if ($mem$$index &lt; 8) {
 2517           emit_opcode(cbuf, Assembler::REX_WR);
 2518         } else {
 2519           emit_opcode(cbuf, Assembler::REX_WRX);
 2520         }
 2521       } else {
 2522         if ($mem$$index &lt; 8) {
 2523           emit_opcode(cbuf, Assembler::REX_WRB);
 2524         } else {
 2525           emit_opcode(cbuf, Assembler::REX_WRXB);
 2526         }
 2527       }
 2528     }
 2529   %}
 2530 
 2531   enc_class reg_mem(rRegI ereg, memory mem)
 2532   %{
 2533     // High registers handle in encode_RegMem
 2534     int reg = $ereg$$reg;
 2535     int base = $mem$$base;
 2536     int index = $mem$$index;
 2537     int scale = $mem$$scale;
 2538     int disp = $mem$$disp;
 2539     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
 2540 
 2541     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
 2542   %}
 2543 
 2544   enc_class RM_opc_mem(immI rm_opcode, memory mem)
 2545   %{
 2546     int rm_byte_opcode = $rm_opcode$$constant;
 2547 
 2548     // High registers handle in encode_RegMem
 2549     int base = $mem$$base;
 2550     int index = $mem$$index;
 2551     int scale = $mem$$scale;
 2552     int displace = $mem$$disp;
 2553 
 2554     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
 2555                                             // working with static
 2556                                             // globals
 2557     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
 2558                   disp_reloc);
 2559   %}
 2560 
 2561   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
 2562   %{
 2563     int reg_encoding = $dst$$reg;
 2564     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
 2565     int index        = 0x04;            // 0x04 indicates no index
 2566     int scale        = 0x00;            // 0x00 indicates no scale
 2567     int displace     = $src1$$constant; // 0x00 indicates no displacement
 2568     relocInfo::relocType disp_reloc = relocInfo::none;
 2569     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
 2570                   disp_reloc);
 2571   %}
 2572 
 2573   enc_class neg_reg(rRegI dst)
 2574   %{
 2575     int dstenc = $dst$$reg;
 2576     if (dstenc &gt;= 8) {
 2577       emit_opcode(cbuf, Assembler::REX_B);
 2578       dstenc -= 8;
 2579     }
 2580     // NEG $dst
 2581     emit_opcode(cbuf, 0xF7);
 2582     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2583   %}
 2584 
 2585   enc_class neg_reg_wide(rRegI dst)
 2586   %{
 2587     int dstenc = $dst$$reg;
 2588     if (dstenc &lt; 8) {
 2589       emit_opcode(cbuf, Assembler::REX_W);
 2590     } else {
 2591       emit_opcode(cbuf, Assembler::REX_WB);
 2592       dstenc -= 8;
 2593     }
 2594     // NEG $dst
 2595     emit_opcode(cbuf, 0xF7);
 2596     emit_rm(cbuf, 0x3, 0x03, dstenc);
 2597   %}
 2598 
 2599   enc_class setLT_reg(rRegI dst)
 2600   %{
 2601     int dstenc = $dst$$reg;
 2602     if (dstenc &gt;= 8) {
 2603       emit_opcode(cbuf, Assembler::REX_B);
 2604       dstenc -= 8;
 2605     } else if (dstenc &gt;= 4) {
 2606       emit_opcode(cbuf, Assembler::REX);
 2607     }
 2608     // SETLT $dst
 2609     emit_opcode(cbuf, 0x0F);
 2610     emit_opcode(cbuf, 0x9C);
 2611     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2612   %}
 2613 
 2614   enc_class setNZ_reg(rRegI dst)
 2615   %{
 2616     int dstenc = $dst$$reg;
 2617     if (dstenc &gt;= 8) {
 2618       emit_opcode(cbuf, Assembler::REX_B);
 2619       dstenc -= 8;
 2620     } else if (dstenc &gt;= 4) {
 2621       emit_opcode(cbuf, Assembler::REX);
 2622     }
 2623     // SETNZ $dst
 2624     emit_opcode(cbuf, 0x0F);
 2625     emit_opcode(cbuf, 0x95);
 2626     emit_rm(cbuf, 0x3, 0x0, dstenc);
 2627   %}
 2628 
 2629 
 2630   // Compare the lonogs and set -1, 0, or 1 into dst
 2631   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
 2632   %{
 2633     int src1enc = $src1$$reg;
 2634     int src2enc = $src2$$reg;
 2635     int dstenc = $dst$$reg;
 2636 
 2637     // cmpq $src1, $src2
 2638     if (src1enc &lt; 8) {
 2639       if (src2enc &lt; 8) {
 2640         emit_opcode(cbuf, Assembler::REX_W);
 2641       } else {
 2642         emit_opcode(cbuf, Assembler::REX_WB);
 2643       }
 2644     } else {
 2645       if (src2enc &lt; 8) {
 2646         emit_opcode(cbuf, Assembler::REX_WR);
 2647       } else {
 2648         emit_opcode(cbuf, Assembler::REX_WRB);
 2649       }
 2650     }
 2651     emit_opcode(cbuf, 0x3B);
 2652     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
 2653 
 2654     // movl $dst, -1
 2655     if (dstenc &gt;= 8) {
 2656       emit_opcode(cbuf, Assembler::REX_B);
 2657     }
 2658     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
 2659     emit_d32(cbuf, -1);
 2660 
 2661     // jl,s done
 2662     emit_opcode(cbuf, 0x7C);
 2663     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
 2664 
 2665     // setne $dst
 2666     if (dstenc &gt;= 4) {
 2667       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
 2668     }
 2669     emit_opcode(cbuf, 0x0F);
 2670     emit_opcode(cbuf, 0x95);
 2671     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
 2672 
 2673     // movzbl $dst, $dst
 2674     if (dstenc &gt;= 4) {
 2675       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
 2676     }
 2677     emit_opcode(cbuf, 0x0F);
 2678     emit_opcode(cbuf, 0xB6);
 2679     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
 2680   %}
 2681 
 2682   enc_class Push_ResultXD(regD dst) %{
 2683     MacroAssembler _masm(&amp;cbuf);
 2684     __ fstp_d(Address(rsp, 0));
 2685     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
 2686     __ addptr(rsp, 8);
 2687   %}
 2688 
 2689   enc_class Push_SrcXD(regD src) %{
 2690     MacroAssembler _masm(&amp;cbuf);
 2691     __ subptr(rsp, 8);
 2692     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
 2693     __ fld_d(Address(rsp, 0));
 2694   %}
 2695 
 2696 
 2697   enc_class enc_rethrow()
 2698   %{
 2699     cbuf.set_insts_mark();
 2700     emit_opcode(cbuf, 0xE9); // jmp entry
 2701     emit_d32_reloc(cbuf,
 2702                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
 2703                    runtime_call_Relocation::spec(),
 2704                    RELOC_DISP32);
 2705   %}
 2706 
 2707 %}
 2708 
 2709 
 2710 
 2711 //----------FRAME--------------------------------------------------------------
 2712 // Definition of frame structure and management information.
 2713 //
 2714 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2715 //                             |   (to get allocators register number
 2716 //  G  Owned by    |        |  v    add OptoReg::stack0())
 2717 //  r   CALLER     |        |
 2718 //  o     |        +--------+      pad to even-align allocators stack-slot
 2719 //  w     V        |  pad0  |        numbers; owned by CALLER
 2720 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2721 //  h     ^        |   in   |  5
 2722 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2723 //  |     |        |        |  3
 2724 //  |     |        +--------+
 2725 //  V     |        | old out|      Empty on Intel, window on Sparc
 2726 //        |    old |preserve|      Must be even aligned.
 2727 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
 2728 //        |        |   in   |  3   area for Intel ret address
 2729 //     Owned by    |preserve|      Empty on Sparc.
 2730 //       SELF      +--------+
 2731 //        |        |  pad2  |  2   pad to align old SP
 2732 //        |        +--------+  1
 2733 //        |        | locks  |  0
 2734 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
 2735 //        |        |  pad1  | 11   pad to align new SP
 2736 //        |        +--------+
 2737 //        |        |        | 10
 2738 //        |        | spills |  9   spills
 2739 //        V        |        |  8   (pad0 slot for callee)
 2740 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 2741 //        ^        |  out   |  7
 2742 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 2743 //     Owned by    +--------+
 2744 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 2745 //        |    new |preserve|      Must be even-aligned.
 2746 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 2747 //        |        |        |
 2748 //
 2749 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 2750 //         known from SELF&#39;s arguments and the Java calling convention.
 2751 //         Region 6-7 is determined per call site.
 2752 // Note 2: If the calling convention leaves holes in the incoming argument
 2753 //         area, those holes are owned by SELF.  Holes in the outgoing area
 2754 //         are owned by the CALLEE.  Holes should not be nessecary in the
 2755 //         incoming area, as the Java calling convention is completely under
 2756 //         the control of the AD file.  Doubles can be sorted and packed to
 2757 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 2758 //         varargs C calling conventions.
 2759 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 2760 //         even aligned with pad0 as needed.
 2761 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 2762 //         region 6-11 is even aligned; it may be padded out more so that
 2763 //         the region from SP to FP meets the minimum stack alignment.
 2764 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
 2765 //         alignment.  Region 11, pad1, may be dynamically extended so that
 2766 //         SP meets the minimum alignment.
 2767 
 2768 frame
 2769 %{
 2770   // What direction does stack grow in (assumed to be same for C &amp; Java)
 2771   stack_direction(TOWARDS_LOW);
 2772 
 2773   // These three registers define part of the calling convention
 2774   // between compiled code and the interpreter.
 2775   inline_cache_reg(RAX);                // Inline Cache Register
 2776   interpreter_method_oop_reg(RBX);      // Method Oop Register when
 2777                                         // calling interpreter
 2778 
 2779   // Optional: name the operand used by cisc-spilling to access
 2780   // [stack_pointer + offset]
 2781   cisc_spilling_operand_name(indOffset32);
 2782 
 2783   // Number of stack slots consumed by locking an object
 2784   sync_stack_slots(2);
 2785 
 2786   // Compiled code&#39;s Frame Pointer
 2787   frame_pointer(RSP);
 2788 
 2789   // Interpreter stores its frame pointer in a register which is
 2790   // stored to the stack by I2CAdaptors.
 2791   // I2CAdaptors convert from interpreted java to compiled java.
 2792   interpreter_frame_pointer(RBP);
 2793 
 2794   // Stack alignment requirement
 2795   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
 2796 
 2797   // Number of stack slots between incoming argument block and the start of
 2798   // a new frame.  The PROLOG must add this many slots to the stack.  The
 2799   // EPILOG must remove this many slots.  amd64 needs two slots for
 2800   // return address.
 2801   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
 2802 
 2803   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 2804   // for calls to C.  Supports the var-args backing area for register parms.
 2805   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
 2806 
 2807   // The after-PROLOG location of the return address.  Location of
 2808   // return address specifies a type (REG or STACK) and a number
 2809   // representing the register number (i.e. - use a register name) or
 2810   // stack slot.
 2811   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 2812   // Otherwise, it is above the locks and verification slot and alignment word
 2813   return_addr(STACK - 2 +
 2814               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 2815                         Compile::current()-&gt;fixed_slots()),
 2816                        stack_alignment_in_slots()));
 2817 
 2818   // Body of function which returns an integer array locating
 2819   // arguments either in registers or in stack slots.  Passed an array
 2820   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count.  Stack-slot
 2821   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 2822   // arguments for a CALLEE.  Incoming stack arguments are
 2823   // automatically biased by the preserve_stack_slots field above.
 2824 
 2825   calling_convention
 2826   %{
 2827     // No difference between ingoing/outgoing just pass false
 2828     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 2829   %}
 2830 
 2831   c_calling_convention
 2832   %{
 2833     // This is obviously always outgoing
 2834     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 2835   %}
 2836 
 2837   // Location of compiled Java return values.  Same as C for now.
 2838   return_value
 2839   %{
 2840     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
 2841            &quot;only return normal values&quot;);
 2842 
 2843     static const int lo[Op_RegL + 1] = {
 2844       0,
 2845       0,
 2846       RAX_num,  // Op_RegN
 2847       RAX_num,  // Op_RegI
 2848       RAX_num,  // Op_RegP
 2849       XMM0_num, // Op_RegF
 2850       XMM0_num, // Op_RegD
 2851       RAX_num   // Op_RegL
 2852     };
 2853     static const int hi[Op_RegL + 1] = {
 2854       0,
 2855       0,
 2856       OptoReg::Bad, // Op_RegN
 2857       OptoReg::Bad, // Op_RegI
 2858       RAX_H_num,    // Op_RegP
 2859       OptoReg::Bad, // Op_RegF
 2860       XMM0b_num,    // Op_RegD
 2861       RAX_H_num     // Op_RegL
 2862     };
 2863     // Excluded flags and vector registers.
 2864     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, &quot;missing type&quot;);
 2865     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
 2866   %}
 2867 %}
 2868 
 2869 //----------ATTRIBUTES---------------------------------------------------------
 2870 //----------Operand Attributes-------------------------------------------------
 2871 op_attrib op_cost(0);        // Required cost attribute
 2872 
 2873 //----------Instruction Attributes---------------------------------------------
 2874 ins_attrib ins_cost(100);       // Required cost attribute
 2875 ins_attrib ins_size(8);         // Required size attribute (in bits)
 2876 ins_attrib ins_short_branch(0); // Required flag: is this instruction
 2877                                 // a non-matching short branch variant
 2878                                 // of some long branch?
 2879 ins_attrib ins_alignment(1);    // Required alignment attribute (must
 2880                                 // be a power of 2) specifies the
 2881                                 // alignment that some part of the
 2882                                 // instruction (not necessarily the
 2883                                 // start) requires.  If &gt; 1, a
 2884                                 // compute_padding() function must be
 2885                                 // provided for the instruction
 2886 
 2887 //----------OPERANDS-----------------------------------------------------------
 2888 // Operand definitions must precede instruction definitions for correct parsing
 2889 // in the ADLC because operands constitute user defined types which are used in
 2890 // instruction definitions.
 2891 
 2892 //----------Simple Operands----------------------------------------------------
 2893 // Immediate Operands
 2894 // Integer Immediate
 2895 operand immI()
 2896 %{
 2897   match(ConI);
 2898 
 2899   op_cost(10);
 2900   format %{ %}
 2901   interface(CONST_INTER);
 2902 %}
 2903 
 2904 // Constant for test vs zero
 2905 operand immI0()
 2906 %{
 2907   predicate(n-&gt;get_int() == 0);
 2908   match(ConI);
 2909 
 2910   op_cost(0);
 2911   format %{ %}
 2912   interface(CONST_INTER);
 2913 %}
 2914 
 2915 // Constant for increment
 2916 operand immI1()
 2917 %{
 2918   predicate(n-&gt;get_int() == 1);
 2919   match(ConI);
 2920 
 2921   op_cost(0);
 2922   format %{ %}
 2923   interface(CONST_INTER);
 2924 %}
 2925 
 2926 // Constant for decrement
 2927 operand immI_M1()
 2928 %{
 2929   predicate(n-&gt;get_int() == -1);
 2930   match(ConI);
 2931 
 2932   op_cost(0);
 2933   format %{ %}
 2934   interface(CONST_INTER);
 2935 %}
 2936 
 2937 // Valid scale values for addressing modes
 2938 operand immI2()
 2939 %{
 2940   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
 2941   match(ConI);
 2942 
 2943   format %{ %}
 2944   interface(CONST_INTER);
 2945 %}
 2946 
 2947 operand immI8()
 2948 %{
 2949   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
 2950   match(ConI);
 2951 
 2952   op_cost(5);
 2953   format %{ %}
 2954   interface(CONST_INTER);
 2955 %}
 2956 
 2957 operand immU8()
 2958 %{
 2959   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 255));
 2960   match(ConI);
 2961 
 2962   op_cost(5);
 2963   format %{ %}
 2964   interface(CONST_INTER);
 2965 %}
 2966 
 2967 operand immI16()
 2968 %{
 2969   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
 2970   match(ConI);
 2971 
 2972   op_cost(10);
 2973   format %{ %}
 2974   interface(CONST_INTER);
 2975 %}
 2976 
 2977 // Int Immediate non-negative
 2978 operand immU31()
 2979 %{
 2980   predicate(n-&gt;get_int() &gt;= 0);
 2981   match(ConI);
 2982 
 2983   op_cost(0);
 2984   format %{ %}
 2985   interface(CONST_INTER);
 2986 %}
 2987 
 2988 // Constant for long shifts
 2989 operand immI_32()
 2990 %{
 2991   predicate( n-&gt;get_int() == 32 );
 2992   match(ConI);
 2993 
 2994   op_cost(0);
 2995   format %{ %}
 2996   interface(CONST_INTER);
 2997 %}
 2998 
 2999 // Constant for long shifts
 3000 operand immI_64()
 3001 %{
 3002   predicate( n-&gt;get_int() == 64 );
 3003   match(ConI);
 3004 
 3005   op_cost(0);
 3006   format %{ %}
 3007   interface(CONST_INTER);
 3008 %}
 3009 
 3010 // Pointer Immediate
 3011 operand immP()
 3012 %{
 3013   match(ConP);
 3014 
 3015   op_cost(10);
 3016   format %{ %}
 3017   interface(CONST_INTER);
 3018 %}
 3019 
 3020 // NULL Pointer Immediate
 3021 operand immP0()
 3022 %{
 3023   predicate(n-&gt;get_ptr() == 0);
 3024   match(ConP);
 3025 
 3026   op_cost(5);
 3027   format %{ %}
 3028   interface(CONST_INTER);
 3029 %}
 3030 
 3031 // Pointer Immediate
 3032 operand immN() %{
 3033   match(ConN);
 3034 
 3035   op_cost(10);
 3036   format %{ %}
 3037   interface(CONST_INTER);
 3038 %}
 3039 
 3040 operand immNKlass() %{
 3041   match(ConNKlass);
 3042 
 3043   op_cost(10);
 3044   format %{ %}
 3045   interface(CONST_INTER);
 3046 %}
 3047 
 3048 // NULL Pointer Immediate
 3049 operand immN0() %{
 3050   predicate(n-&gt;get_narrowcon() == 0);
 3051   match(ConN);
 3052 
 3053   op_cost(5);
 3054   format %{ %}
 3055   interface(CONST_INTER);
 3056 %}
 3057 
 3058 operand immP31()
 3059 %{
 3060   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
 3061             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
 3062   match(ConP);
 3063 
 3064   op_cost(5);
 3065   format %{ %}
 3066   interface(CONST_INTER);
 3067 %}
 3068 
 3069 
 3070 // Long Immediate
 3071 operand immL()
 3072 %{
 3073   match(ConL);
 3074 
 3075   op_cost(20);
 3076   format %{ %}
 3077   interface(CONST_INTER);
 3078 %}
 3079 
 3080 // Long Immediate 8-bit
 3081 operand immL8()
 3082 %{
 3083   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
 3084   match(ConL);
 3085 
 3086   op_cost(5);
 3087   format %{ %}
 3088   interface(CONST_INTER);
 3089 %}
 3090 
 3091 // Long Immediate 32-bit unsigned
 3092 operand immUL32()
 3093 %{
 3094   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
 3095   match(ConL);
 3096 
 3097   op_cost(10);
 3098   format %{ %}
 3099   interface(CONST_INTER);
 3100 %}
 3101 
 3102 // Long Immediate 32-bit signed
 3103 operand immL32()
 3104 %{
 3105   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
 3106   match(ConL);
 3107 
 3108   op_cost(15);
 3109   format %{ %}
 3110   interface(CONST_INTER);
 3111 %}
 3112 
 3113 operand immL_Pow2()
 3114 %{
 3115   predicate(is_power_of_2(n-&gt;get_long()));
 3116   match(ConL);
 3117 
 3118   op_cost(15);
 3119   format %{ %}
 3120   interface(CONST_INTER);
 3121 %}
 3122 
 3123 operand immL_NotPow2()
 3124 %{
 3125   predicate(is_power_of_2(~n-&gt;get_long()));
 3126   match(ConL);
 3127 
 3128   op_cost(15);
 3129   format %{ %}
 3130   interface(CONST_INTER);
 3131 %}
 3132 
 3133 // Long Immediate zero
 3134 operand immL0()
 3135 %{
 3136   predicate(n-&gt;get_long() == 0L);
 3137   match(ConL);
 3138 
 3139   op_cost(10);
 3140   format %{ %}
 3141   interface(CONST_INTER);
 3142 %}
 3143 
 3144 // Constant for increment
 3145 operand immL1()
 3146 %{
 3147   predicate(n-&gt;get_long() == 1);
 3148   match(ConL);
 3149 
 3150   format %{ %}
 3151   interface(CONST_INTER);
 3152 %}
 3153 
 3154 // Constant for decrement
 3155 operand immL_M1()
 3156 %{
 3157   predicate(n-&gt;get_long() == -1);
 3158   match(ConL);
 3159 
 3160   format %{ %}
 3161   interface(CONST_INTER);
 3162 %}
 3163 
 3164 // Long Immediate: the value 10
 3165 operand immL10()
 3166 %{
 3167   predicate(n-&gt;get_long() == 10);
 3168   match(ConL);
 3169 
 3170   format %{ %}
 3171   interface(CONST_INTER);
 3172 %}
 3173 
 3174 // Long immediate from 0 to 127.
 3175 // Used for a shorter form of long mul by 10.
 3176 operand immL_127()
 3177 %{
 3178   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
 3179   match(ConL);
 3180 
 3181   op_cost(10);
 3182   format %{ %}
 3183   interface(CONST_INTER);
 3184 %}
 3185 
 3186 // Long Immediate: low 32-bit mask
 3187 operand immL_32bits()
 3188 %{
 3189   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 3190   match(ConL);
 3191   op_cost(20);
 3192 
 3193   format %{ %}
 3194   interface(CONST_INTER);
 3195 %}
 3196 
 3197 // Float Immediate zero
 3198 operand immF0()
 3199 %{
 3200   predicate(jint_cast(n-&gt;getf()) == 0);
 3201   match(ConF);
 3202 
 3203   op_cost(5);
 3204   format %{ %}
 3205   interface(CONST_INTER);
 3206 %}
 3207 
 3208 // Float Immediate
 3209 operand immF()
 3210 %{
 3211   match(ConF);
 3212 
 3213   op_cost(15);
 3214   format %{ %}
 3215   interface(CONST_INTER);
 3216 %}
 3217 
 3218 // Double Immediate zero
 3219 operand immD0()
 3220 %{
 3221   predicate(jlong_cast(n-&gt;getd()) == 0);
 3222   match(ConD);
 3223 
 3224   op_cost(5);
 3225   format %{ %}
 3226   interface(CONST_INTER);
 3227 %}
 3228 
 3229 // Double Immediate
 3230 operand immD()
 3231 %{
 3232   match(ConD);
 3233 
 3234   op_cost(15);
 3235   format %{ %}
 3236   interface(CONST_INTER);
 3237 %}
 3238 
 3239 // Immediates for special shifts (sign extend)
 3240 
 3241 // Constants for increment
 3242 operand immI_16()
 3243 %{
 3244   predicate(n-&gt;get_int() == 16);
 3245   match(ConI);
 3246 
 3247   format %{ %}
 3248   interface(CONST_INTER);
 3249 %}
 3250 
 3251 operand immI_24()
 3252 %{
 3253   predicate(n-&gt;get_int() == 24);
 3254   match(ConI);
 3255 
 3256   format %{ %}
 3257   interface(CONST_INTER);
 3258 %}
 3259 
 3260 // Constant for byte-wide masking
 3261 operand immI_255()
 3262 %{
 3263   predicate(n-&gt;get_int() == 255);
 3264   match(ConI);
 3265 
 3266   format %{ %}
 3267   interface(CONST_INTER);
 3268 %}
 3269 
 3270 // Constant for short-wide masking
 3271 operand immI_65535()
 3272 %{
 3273   predicate(n-&gt;get_int() == 65535);
 3274   match(ConI);
 3275 
 3276   format %{ %}
 3277   interface(CONST_INTER);
 3278 %}
 3279 
 3280 // Constant for byte-wide masking
 3281 operand immL_255()
 3282 %{
 3283   predicate(n-&gt;get_long() == 255);
 3284   match(ConL);
 3285 
 3286   format %{ %}
 3287   interface(CONST_INTER);
 3288 %}
 3289 
 3290 // Constant for short-wide masking
 3291 operand immL_65535()
 3292 %{
 3293   predicate(n-&gt;get_long() == 65535);
 3294   match(ConL);
 3295 
 3296   format %{ %}
 3297   interface(CONST_INTER);
 3298 %}
 3299 
 3300 // Register Operands
 3301 // Integer Register
 3302 operand rRegI()
 3303 %{
 3304   constraint(ALLOC_IN_RC(int_reg));
 3305   match(RegI);
 3306 
 3307   match(rax_RegI);
 3308   match(rbx_RegI);
 3309   match(rcx_RegI);
 3310   match(rdx_RegI);
 3311   match(rdi_RegI);
 3312 
 3313   format %{ %}
 3314   interface(REG_INTER);
 3315 %}
 3316 
 3317 // Special Registers
 3318 operand rax_RegI()
 3319 %{
 3320   constraint(ALLOC_IN_RC(int_rax_reg));
 3321   match(RegI);
 3322   match(rRegI);
 3323 
 3324   format %{ &quot;RAX&quot; %}
 3325   interface(REG_INTER);
 3326 %}
 3327 
 3328 // Special Registers
 3329 operand rbx_RegI()
 3330 %{
 3331   constraint(ALLOC_IN_RC(int_rbx_reg));
 3332   match(RegI);
 3333   match(rRegI);
 3334 
 3335   format %{ &quot;RBX&quot; %}
 3336   interface(REG_INTER);
 3337 %}
 3338 
 3339 operand rcx_RegI()
 3340 %{
 3341   constraint(ALLOC_IN_RC(int_rcx_reg));
 3342   match(RegI);
 3343   match(rRegI);
 3344 
 3345   format %{ &quot;RCX&quot; %}
 3346   interface(REG_INTER);
 3347 %}
 3348 
 3349 operand rdx_RegI()
 3350 %{
 3351   constraint(ALLOC_IN_RC(int_rdx_reg));
 3352   match(RegI);
 3353   match(rRegI);
 3354 
 3355   format %{ &quot;RDX&quot; %}
 3356   interface(REG_INTER);
 3357 %}
 3358 
 3359 operand rdi_RegI()
 3360 %{
 3361   constraint(ALLOC_IN_RC(int_rdi_reg));
 3362   match(RegI);
 3363   match(rRegI);
 3364 
 3365   format %{ &quot;RDI&quot; %}
 3366   interface(REG_INTER);
 3367 %}
 3368 
 3369 operand no_rcx_RegI()
 3370 %{
 3371   constraint(ALLOC_IN_RC(int_no_rcx_reg));
 3372   match(RegI);
 3373   match(rax_RegI);
 3374   match(rbx_RegI);
 3375   match(rdx_RegI);
 3376   match(rdi_RegI);
 3377 
 3378   format %{ %}
 3379   interface(REG_INTER);
 3380 %}
 3381 
 3382 operand no_rax_rdx_RegI()
 3383 %{
 3384   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
 3385   match(RegI);
 3386   match(rbx_RegI);
 3387   match(rcx_RegI);
 3388   match(rdi_RegI);
 3389 
 3390   format %{ %}
 3391   interface(REG_INTER);
 3392 %}
 3393 
 3394 // Pointer Register
 3395 operand any_RegP()
 3396 %{
 3397   constraint(ALLOC_IN_RC(any_reg));
 3398   match(RegP);
 3399   match(rax_RegP);
 3400   match(rbx_RegP);
 3401   match(rdi_RegP);
 3402   match(rsi_RegP);
 3403   match(rbp_RegP);
 3404   match(r15_RegP);
 3405   match(rRegP);
 3406 
 3407   format %{ %}
 3408   interface(REG_INTER);
 3409 %}
 3410 
 3411 operand rRegP()
 3412 %{
 3413   constraint(ALLOC_IN_RC(ptr_reg));
 3414   match(RegP);
 3415   match(rax_RegP);
 3416   match(rbx_RegP);
 3417   match(rdi_RegP);
 3418   match(rsi_RegP);
 3419   match(rbp_RegP);  // See Q&amp;A below about
 3420   match(r15_RegP);  // r15_RegP and rbp_RegP.
 3421 
 3422   format %{ %}
 3423   interface(REG_INTER);
 3424 %}
 3425 
 3426 operand rRegN() %{
 3427   constraint(ALLOC_IN_RC(int_reg));
 3428   match(RegN);
 3429 
 3430   format %{ %}
 3431   interface(REG_INTER);
 3432 %}
 3433 
 3434 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
 3435 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
 3436 // It&#39;s fine for an instruction input that expects rRegP to match a r15_RegP.
 3437 // The output of an instruction is controlled by the allocator, which respects
 3438 // register class masks, not match rules.  Unless an instruction mentions
 3439 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
 3440 // by the allocator as an input.
 3441 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
 3442 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
 3443 // result, RBP is not included in the output of the instruction either.
 3444 
 3445 operand no_rax_RegP()
 3446 %{
 3447   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
 3448   match(RegP);
 3449   match(rbx_RegP);
 3450   match(rsi_RegP);
 3451   match(rdi_RegP);
 3452 
 3453   format %{ %}
 3454   interface(REG_INTER);
 3455 %}
 3456 
 3457 // This operand is not allowed to use RBP even if
 3458 // RBP is not used to hold the frame pointer.
 3459 operand no_rbp_RegP()
 3460 %{
 3461   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
 3462   match(RegP);
 3463   match(rbx_RegP);
 3464   match(rsi_RegP);
 3465   match(rdi_RegP);
 3466 
 3467   format %{ %}
 3468   interface(REG_INTER);
 3469 %}
 3470 
 3471 operand no_rax_rbx_RegP()
 3472 %{
 3473   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
 3474   match(RegP);
 3475   match(rsi_RegP);
 3476   match(rdi_RegP);
 3477 
 3478   format %{ %}
 3479   interface(REG_INTER);
 3480 %}
 3481 
 3482 // Special Registers
 3483 // Return a pointer value
 3484 operand rax_RegP()
 3485 %{
 3486   constraint(ALLOC_IN_RC(ptr_rax_reg));
 3487   match(RegP);
 3488   match(rRegP);
 3489 
 3490   format %{ %}
 3491   interface(REG_INTER);
 3492 %}
 3493 
 3494 // Special Registers
 3495 // Return a compressed pointer value
 3496 operand rax_RegN()
 3497 %{
 3498   constraint(ALLOC_IN_RC(int_rax_reg));
 3499   match(RegN);
 3500   match(rRegN);
 3501 
 3502   format %{ %}
 3503   interface(REG_INTER);
 3504 %}
 3505 
 3506 // Used in AtomicAdd
 3507 operand rbx_RegP()
 3508 %{
 3509   constraint(ALLOC_IN_RC(ptr_rbx_reg));
 3510   match(RegP);
 3511   match(rRegP);
 3512 
 3513   format %{ %}
 3514   interface(REG_INTER);
 3515 %}
 3516 
 3517 operand rsi_RegP()
 3518 %{
 3519   constraint(ALLOC_IN_RC(ptr_rsi_reg));
 3520   match(RegP);
 3521   match(rRegP);
 3522 
 3523   format %{ %}
 3524   interface(REG_INTER);
 3525 %}
 3526 
 3527 operand rbp_RegP()
 3528 %{
 3529   constraint(ALLOC_IN_RC(ptr_rbp_reg));
 3530   match(RegP);
 3531   match(rRegP);
 3532 
 3533   format %{ %}
 3534   interface(REG_INTER);
 3535 %}
 3536 
 3537 // Used in rep stosq
 3538 operand rdi_RegP()
 3539 %{
 3540   constraint(ALLOC_IN_RC(ptr_rdi_reg));
 3541   match(RegP);
 3542   match(rRegP);
 3543 
 3544   format %{ %}
 3545   interface(REG_INTER);
 3546 %}
 3547 
 3548 operand r15_RegP()
 3549 %{
 3550   constraint(ALLOC_IN_RC(ptr_r15_reg));
 3551   match(RegP);
 3552   match(rRegP);
 3553 
 3554   format %{ %}
 3555   interface(REG_INTER);
 3556 %}
 3557 
 3558 operand rRegL()
 3559 %{
 3560   constraint(ALLOC_IN_RC(long_reg));
 3561   match(RegL);
 3562   match(rax_RegL);
 3563   match(rdx_RegL);
 3564 
 3565   format %{ %}
 3566   interface(REG_INTER);
 3567 %}
 3568 
 3569 // Special Registers
 3570 operand no_rax_rdx_RegL()
 3571 %{
 3572   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3573   match(RegL);
 3574   match(rRegL);
 3575 
 3576   format %{ %}
 3577   interface(REG_INTER);
 3578 %}
 3579 
 3580 operand no_rax_RegL()
 3581 %{
 3582   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
 3583   match(RegL);
 3584   match(rRegL);
 3585   match(rdx_RegL);
 3586 
 3587   format %{ %}
 3588   interface(REG_INTER);
 3589 %}
 3590 
 3591 operand no_rcx_RegL()
 3592 %{
 3593   constraint(ALLOC_IN_RC(long_no_rcx_reg));
 3594   match(RegL);
 3595   match(rRegL);
 3596 
 3597   format %{ %}
 3598   interface(REG_INTER);
 3599 %}
 3600 
 3601 operand rax_RegL()
 3602 %{
 3603   constraint(ALLOC_IN_RC(long_rax_reg));
 3604   match(RegL);
 3605   match(rRegL);
 3606 
 3607   format %{ &quot;RAX&quot; %}
 3608   interface(REG_INTER);
 3609 %}
 3610 
 3611 operand rcx_RegL()
 3612 %{
 3613   constraint(ALLOC_IN_RC(long_rcx_reg));
 3614   match(RegL);
 3615   match(rRegL);
 3616 
 3617   format %{ %}
 3618   interface(REG_INTER);
 3619 %}
 3620 
 3621 operand rdx_RegL()
 3622 %{
 3623   constraint(ALLOC_IN_RC(long_rdx_reg));
 3624   match(RegL);
 3625   match(rRegL);
 3626 
 3627   format %{ %}
 3628   interface(REG_INTER);
 3629 %}
 3630 
 3631 // Flags register, used as output of compare instructions
 3632 operand rFlagsReg()
 3633 %{
 3634   constraint(ALLOC_IN_RC(int_flags));
 3635   match(RegFlags);
 3636 
 3637   format %{ &quot;RFLAGS&quot; %}
 3638   interface(REG_INTER);
 3639 %}
 3640 
 3641 // Flags register, used as output of FLOATING POINT compare instructions
 3642 operand rFlagsRegU()
 3643 %{
 3644   constraint(ALLOC_IN_RC(int_flags));
 3645   match(RegFlags);
 3646 
 3647   format %{ &quot;RFLAGS_U&quot; %}
 3648   interface(REG_INTER);
 3649 %}
 3650 
 3651 operand rFlagsRegUCF() %{
 3652   constraint(ALLOC_IN_RC(int_flags));
 3653   match(RegFlags);
 3654   predicate(false);
 3655 
 3656   format %{ &quot;RFLAGS_U_CF&quot; %}
 3657   interface(REG_INTER);
 3658 %}
 3659 
 3660 // Float register operands
 3661 operand regF() %{
 3662    constraint(ALLOC_IN_RC(float_reg));
 3663    match(RegF);
 3664 
 3665    format %{ %}
 3666    interface(REG_INTER);
 3667 %}
 3668 
 3669 // Float register operands
 3670 operand legRegF() %{
 3671    constraint(ALLOC_IN_RC(float_reg_legacy));
 3672    match(RegF);
 3673 
 3674    format %{ %}
 3675    interface(REG_INTER);
 3676 %}
 3677 
 3678 // Float register operands
 3679 operand vlRegF() %{
 3680    constraint(ALLOC_IN_RC(float_reg_vl));
 3681    match(RegF);
 3682 
 3683    format %{ %}
 3684    interface(REG_INTER);
 3685 %}
 3686 
 3687 // Double register operands
 3688 operand regD() %{
 3689    constraint(ALLOC_IN_RC(double_reg));
 3690    match(RegD);
 3691 
 3692    format %{ %}
 3693    interface(REG_INTER);
 3694 %}
 3695 
 3696 // Double register operands
 3697 operand legRegD() %{
 3698    constraint(ALLOC_IN_RC(double_reg_legacy));
 3699    match(RegD);
 3700 
 3701    format %{ %}
 3702    interface(REG_INTER);
 3703 %}
 3704 
 3705 // Double register operands
 3706 operand vlRegD() %{
 3707    constraint(ALLOC_IN_RC(double_reg_vl));
 3708    match(RegD);
 3709 
 3710    format %{ %}
 3711    interface(REG_INTER);
 3712 %}
 3713 
 3714 //----------Memory Operands----------------------------------------------------
 3715 // Direct Memory Operand
 3716 // operand direct(immP addr)
 3717 // %{
 3718 //   match(addr);
 3719 
 3720 //   format %{ &quot;[$addr]&quot; %}
 3721 //   interface(MEMORY_INTER) %{
 3722 //     base(0xFFFFFFFF);
 3723 //     index(0x4);
 3724 //     scale(0x0);
 3725 //     disp($addr);
 3726 //   %}
 3727 // %}
 3728 
 3729 // Indirect Memory Operand
 3730 operand indirect(any_RegP reg)
 3731 %{
 3732   constraint(ALLOC_IN_RC(ptr_reg));
 3733   match(reg);
 3734 
 3735   format %{ &quot;[$reg]&quot; %}
 3736   interface(MEMORY_INTER) %{
 3737     base($reg);
 3738     index(0x4);
 3739     scale(0x0);
 3740     disp(0x0);
 3741   %}
 3742 %}
 3743 
 3744 // Indirect Memory Plus Short Offset Operand
 3745 operand indOffset8(any_RegP reg, immL8 off)
 3746 %{
 3747   constraint(ALLOC_IN_RC(ptr_reg));
 3748   match(AddP reg off);
 3749 
 3750   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3751   interface(MEMORY_INTER) %{
 3752     base($reg);
 3753     index(0x4);
 3754     scale(0x0);
 3755     disp($off);
 3756   %}
 3757 %}
 3758 
 3759 // Indirect Memory Plus Long Offset Operand
 3760 operand indOffset32(any_RegP reg, immL32 off)
 3761 %{
 3762   constraint(ALLOC_IN_RC(ptr_reg));
 3763   match(AddP reg off);
 3764 
 3765   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3766   interface(MEMORY_INTER) %{
 3767     base($reg);
 3768     index(0x4);
 3769     scale(0x0);
 3770     disp($off);
 3771   %}
 3772 %}
 3773 
 3774 // Indirect Memory Plus Index Register Plus Offset Operand
 3775 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
 3776 %{
 3777   constraint(ALLOC_IN_RC(ptr_reg));
 3778   match(AddP (AddP reg lreg) off);
 3779 
 3780   op_cost(10);
 3781   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3782   interface(MEMORY_INTER) %{
 3783     base($reg);
 3784     index($lreg);
 3785     scale(0x0);
 3786     disp($off);
 3787   %}
 3788 %}
 3789 
 3790 // Indirect Memory Plus Index Register Plus Offset Operand
 3791 operand indIndex(any_RegP reg, rRegL lreg)
 3792 %{
 3793   constraint(ALLOC_IN_RC(ptr_reg));
 3794   match(AddP reg lreg);
 3795 
 3796   op_cost(10);
 3797   format %{&quot;[$reg + $lreg]&quot; %}
 3798   interface(MEMORY_INTER) %{
 3799     base($reg);
 3800     index($lreg);
 3801     scale(0x0);
 3802     disp(0x0);
 3803   %}
 3804 %}
 3805 
 3806 // Indirect Memory Times Scale Plus Index Register
 3807 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
 3808 %{
 3809   constraint(ALLOC_IN_RC(ptr_reg));
 3810   match(AddP reg (LShiftL lreg scale));
 3811 
 3812   op_cost(10);
 3813   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 3814   interface(MEMORY_INTER) %{
 3815     base($reg);
 3816     index($lreg);
 3817     scale($scale);
 3818     disp(0x0);
 3819   %}
 3820 %}
 3821 
 3822 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
 3823 %{
 3824   constraint(ALLOC_IN_RC(ptr_reg));
 3825   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3826   match(AddP reg (LShiftL (ConvI2L idx) scale));
 3827 
 3828   op_cost(10);
 3829   format %{&quot;[$reg + pos $idx &lt;&lt; $scale]&quot; %}
 3830   interface(MEMORY_INTER) %{
 3831     base($reg);
 3832     index($idx);
 3833     scale($scale);
 3834     disp(0x0);
 3835   %}
 3836 %}
 3837 
 3838 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 3839 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
 3840 %{
 3841   constraint(ALLOC_IN_RC(ptr_reg));
 3842   match(AddP (AddP reg (LShiftL lreg scale)) off);
 3843 
 3844   op_cost(10);
 3845   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 3846   interface(MEMORY_INTER) %{
 3847     base($reg);
 3848     index($lreg);
 3849     scale($scale);
 3850     disp($off);
 3851   %}
 3852 %}
 3853 
 3854 // Indirect Memory Plus Positive Index Register Plus Offset Operand
 3855 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
 3856 %{
 3857   constraint(ALLOC_IN_RC(ptr_reg));
 3858   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3859   match(AddP (AddP reg (ConvI2L idx)) off);
 3860 
 3861   op_cost(10);
 3862   format %{&quot;[$reg + $off + $idx]&quot; %}
 3863   interface(MEMORY_INTER) %{
 3864     base($reg);
 3865     index($idx);
 3866     scale(0x0);
 3867     disp($off);
 3868   %}
 3869 %}
 3870 
 3871 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3872 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3873 %{
 3874   constraint(ALLOC_IN_RC(ptr_reg));
 3875   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3876   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3877 
 3878   op_cost(10);
 3879   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3880   interface(MEMORY_INTER) %{
 3881     base($reg);
 3882     index($idx);
 3883     scale($scale);
 3884     disp($off);
 3885   %}
 3886 %}
 3887 
 3888 // Indirect Narrow Oop Operand
 3889 operand indCompressedOop(rRegN reg) %{
 3890   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3891   constraint(ALLOC_IN_RC(ptr_reg));
 3892   match(DecodeN reg);
 3893 
 3894   op_cost(10);
 3895   format %{&quot;[R12 + $reg &lt;&lt; 3] (compressed oop addressing)&quot; %}
 3896   interface(MEMORY_INTER) %{
 3897     base(0xc); // R12
 3898     index($reg);
 3899     scale(0x3);
 3900     disp(0x0);
 3901   %}
 3902 %}
 3903 
 3904 // Indirect Narrow Oop Plus Offset Operand
 3905 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3906 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3907 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3908   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3909   constraint(ALLOC_IN_RC(ptr_reg));
 3910   match(AddP (DecodeN reg) off);
 3911 
 3912   op_cost(10);
 3913   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3914   interface(MEMORY_INTER) %{
 3915     base(0xc); // R12
 3916     index($reg);
 3917     scale(0x3);
 3918     disp($off);
 3919   %}
 3920 %}
 3921 
 3922 // Indirect Memory Operand
 3923 operand indirectNarrow(rRegN reg)
 3924 %{
 3925   predicate(CompressedOops::shift() == 0);
 3926   constraint(ALLOC_IN_RC(ptr_reg));
 3927   match(DecodeN reg);
 3928 
 3929   format %{ &quot;[$reg]&quot; %}
 3930   interface(MEMORY_INTER) %{
 3931     base($reg);
 3932     index(0x4);
 3933     scale(0x0);
 3934     disp(0x0);
 3935   %}
 3936 %}
 3937 
 3938 // Indirect Memory Plus Short Offset Operand
 3939 operand indOffset8Narrow(rRegN reg, immL8 off)
 3940 %{
 3941   predicate(CompressedOops::shift() == 0);
 3942   constraint(ALLOC_IN_RC(ptr_reg));
 3943   match(AddP (DecodeN reg) off);
 3944 
 3945   format %{ &quot;[$reg + $off (8-bit)]&quot; %}
 3946   interface(MEMORY_INTER) %{
 3947     base($reg);
 3948     index(0x4);
 3949     scale(0x0);
 3950     disp($off);
 3951   %}
 3952 %}
 3953 
 3954 // Indirect Memory Plus Long Offset Operand
 3955 operand indOffset32Narrow(rRegN reg, immL32 off)
 3956 %{
 3957   predicate(CompressedOops::shift() == 0);
 3958   constraint(ALLOC_IN_RC(ptr_reg));
 3959   match(AddP (DecodeN reg) off);
 3960 
 3961   format %{ &quot;[$reg + $off (32-bit)]&quot; %}
 3962   interface(MEMORY_INTER) %{
 3963     base($reg);
 3964     index(0x4);
 3965     scale(0x0);
 3966     disp($off);
 3967   %}
 3968 %}
 3969 
 3970 // Indirect Memory Plus Index Register Plus Offset Operand
 3971 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
 3972 %{
 3973   predicate(CompressedOops::shift() == 0);
 3974   constraint(ALLOC_IN_RC(ptr_reg));
 3975   match(AddP (AddP (DecodeN reg) lreg) off);
 3976 
 3977   op_cost(10);
 3978   format %{&quot;[$reg + $off + $lreg]&quot; %}
 3979   interface(MEMORY_INTER) %{
 3980     base($reg);
 3981     index($lreg);
 3982     scale(0x0);
 3983     disp($off);
 3984   %}
 3985 %}
 3986 
 3987 // Indirect Memory Plus Index Register Plus Offset Operand
 3988 operand indIndexNarrow(rRegN reg, rRegL lreg)
 3989 %{
 3990   predicate(CompressedOops::shift() == 0);
 3991   constraint(ALLOC_IN_RC(ptr_reg));
 3992   match(AddP (DecodeN reg) lreg);
 3993 
 3994   op_cost(10);
 3995   format %{&quot;[$reg + $lreg]&quot; %}
 3996   interface(MEMORY_INTER) %{
 3997     base($reg);
 3998     index($lreg);
 3999     scale(0x0);
 4000     disp(0x0);
 4001   %}
 4002 %}
 4003 
 4004 // Indirect Memory Times Scale Plus Index Register
 4005 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
 4006 %{
 4007   predicate(CompressedOops::shift() == 0);
 4008   constraint(ALLOC_IN_RC(ptr_reg));
 4009   match(AddP (DecodeN reg) (LShiftL lreg scale));
 4010 
 4011   op_cost(10);
 4012   format %{&quot;[$reg + $lreg &lt;&lt; $scale]&quot; %}
 4013   interface(MEMORY_INTER) %{
 4014     base($reg);
 4015     index($lreg);
 4016     scale($scale);
 4017     disp(0x0);
 4018   %}
 4019 %}
 4020 
 4021 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
 4022 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
 4023 %{
 4024   predicate(CompressedOops::shift() == 0);
 4025   constraint(ALLOC_IN_RC(ptr_reg));
 4026   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
 4027 
 4028   op_cost(10);
 4029   format %{&quot;[$reg + $off + $lreg &lt;&lt; $scale]&quot; %}
 4030   interface(MEMORY_INTER) %{
 4031     base($reg);
 4032     index($lreg);
 4033     scale($scale);
 4034     disp($off);
 4035   %}
 4036 %}
 4037 
 4038 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
 4039 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
 4040 %{
 4041   constraint(ALLOC_IN_RC(ptr_reg));
 4042   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4043   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
 4044 
 4045   op_cost(10);
 4046   format %{&quot;[$reg + $off + $idx]&quot; %}
 4047   interface(MEMORY_INTER) %{
 4048     base($reg);
 4049     index($idx);
 4050     scale(0x0);
 4051     disp($off);
 4052   %}
 4053 %}
 4054 
 4055 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 4056 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
 4057 %{
 4058   constraint(ALLOC_IN_RC(ptr_reg));
 4059   predicate(CompressedOops::shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 4060   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
 4061 
 4062   op_cost(10);
 4063   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 4064   interface(MEMORY_INTER) %{
 4065     base($reg);
 4066     index($idx);
 4067     scale($scale);
 4068     disp($off);
 4069   %}
 4070 %}
 4071 
 4072 //----------Special Memory Operands--------------------------------------------
 4073 // Stack Slot Operand - This operand is used for loading and storing temporary
 4074 //                      values on the stack where a match requires a value to
 4075 //                      flow through memory.
 4076 operand stackSlotP(sRegP reg)
 4077 %{
 4078   constraint(ALLOC_IN_RC(stack_slots));
 4079   // No match rule because this operand is only generated in matching
 4080 
 4081   format %{ &quot;[$reg]&quot; %}
 4082   interface(MEMORY_INTER) %{
 4083     base(0x4);   // RSP
 4084     index(0x4);  // No Index
 4085     scale(0x0);  // No Scale
 4086     disp($reg);  // Stack Offset
 4087   %}
 4088 %}
 4089 
 4090 operand stackSlotI(sRegI reg)
 4091 %{
 4092   constraint(ALLOC_IN_RC(stack_slots));
 4093   // No match rule because this operand is only generated in matching
 4094 
 4095   format %{ &quot;[$reg]&quot; %}
 4096   interface(MEMORY_INTER) %{
 4097     base(0x4);   // RSP
 4098     index(0x4);  // No Index
 4099     scale(0x0);  // No Scale
 4100     disp($reg);  // Stack Offset
 4101   %}
 4102 %}
 4103 
 4104 operand stackSlotF(sRegF reg)
 4105 %{
 4106   constraint(ALLOC_IN_RC(stack_slots));
 4107   // No match rule because this operand is only generated in matching
 4108 
 4109   format %{ &quot;[$reg]&quot; %}
 4110   interface(MEMORY_INTER) %{
 4111     base(0x4);   // RSP
 4112     index(0x4);  // No Index
 4113     scale(0x0);  // No Scale
 4114     disp($reg);  // Stack Offset
 4115   %}
 4116 %}
 4117 
 4118 operand stackSlotD(sRegD reg)
 4119 %{
 4120   constraint(ALLOC_IN_RC(stack_slots));
 4121   // No match rule because this operand is only generated in matching
 4122 
 4123   format %{ &quot;[$reg]&quot; %}
 4124   interface(MEMORY_INTER) %{
 4125     base(0x4);   // RSP
 4126     index(0x4);  // No Index
 4127     scale(0x0);  // No Scale
 4128     disp($reg);  // Stack Offset
 4129   %}
 4130 %}
 4131 operand stackSlotL(sRegL reg)
 4132 %{
 4133   constraint(ALLOC_IN_RC(stack_slots));
 4134   // No match rule because this operand is only generated in matching
 4135 
 4136   format %{ &quot;[$reg]&quot; %}
 4137   interface(MEMORY_INTER) %{
 4138     base(0x4);   // RSP
 4139     index(0x4);  // No Index
 4140     scale(0x0);  // No Scale
 4141     disp($reg);  // Stack Offset
 4142   %}
 4143 %}
 4144 
 4145 //----------Conditional Branch Operands----------------------------------------
 4146 // Comparison Op  - This is the operation of the comparison, and is limited to
 4147 //                  the following set of codes:
 4148 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 4149 //
 4150 // Other attributes of the comparison, such as unsignedness, are specified
 4151 // by the comparison instruction that sets a condition code flags register.
 4152 // That result is represented by a flags operand whose subtype is appropriate
 4153 // to the unsignedness (etc.) of the comparison.
 4154 //
 4155 // Later, the instruction which matches both the Comparison Op (a Bool) and
 4156 // the flags (produced by the Cmp) specifies the coding of the comparison op
 4157 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 4158 
 4159 // Comparision Code
 4160 operand cmpOp()
 4161 %{
 4162   match(Bool);
 4163 
 4164   format %{ &quot;&quot; %}
 4165   interface(COND_INTER) %{
 4166     equal(0x4, &quot;e&quot;);
 4167     not_equal(0x5, &quot;ne&quot;);
 4168     less(0xC, &quot;l&quot;);
 4169     greater_equal(0xD, &quot;ge&quot;);
 4170     less_equal(0xE, &quot;le&quot;);
 4171     greater(0xF, &quot;g&quot;);
 4172     overflow(0x0, &quot;o&quot;);
 4173     no_overflow(0x1, &quot;no&quot;);
 4174   %}
 4175 %}
 4176 
 4177 // Comparison Code, unsigned compare.  Used by FP also, with
 4178 // C2 (unordered) turned into GT or LT already.  The other bits
 4179 // C0 and C3 are turned into Carry &amp; Zero flags.
 4180 operand cmpOpU()
 4181 %{
 4182   match(Bool);
 4183 
 4184   format %{ &quot;&quot; %}
 4185   interface(COND_INTER) %{
 4186     equal(0x4, &quot;e&quot;);
 4187     not_equal(0x5, &quot;ne&quot;);
 4188     less(0x2, &quot;b&quot;);
 4189     greater_equal(0x3, &quot;nb&quot;);
 4190     less_equal(0x6, &quot;be&quot;);
 4191     greater(0x7, &quot;nbe&quot;);
 4192     overflow(0x0, &quot;o&quot;);
 4193     no_overflow(0x1, &quot;no&quot;);
 4194   %}
 4195 %}
 4196 
 4197 
 4198 // Floating comparisons that don&#39;t require any fixup for the unordered case
 4199 operand cmpOpUCF() %{
 4200   match(Bool);
 4201   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4202             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
 4203             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
 4204             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
 4205   format %{ &quot;&quot; %}
 4206   interface(COND_INTER) %{
 4207     equal(0x4, &quot;e&quot;);
 4208     not_equal(0x5, &quot;ne&quot;);
 4209     less(0x2, &quot;b&quot;);
 4210     greater_equal(0x3, &quot;nb&quot;);
 4211     less_equal(0x6, &quot;be&quot;);
 4212     greater(0x7, &quot;nbe&quot;);
 4213     overflow(0x0, &quot;o&quot;);
 4214     no_overflow(0x1, &quot;no&quot;);
 4215   %}
 4216 %}
 4217 
 4218 
 4219 // Floating comparisons that can be fixed up with extra conditional jumps
 4220 operand cmpOpUCF2() %{
 4221   match(Bool);
 4222   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4223             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
 4224   format %{ &quot;&quot; %}
 4225   interface(COND_INTER) %{
 4226     equal(0x4, &quot;e&quot;);
 4227     not_equal(0x5, &quot;ne&quot;);
 4228     less(0x2, &quot;b&quot;);
 4229     greater_equal(0x3, &quot;nb&quot;);
 4230     less_equal(0x6, &quot;be&quot;);
 4231     greater(0x7, &quot;nbe&quot;);
 4232     overflow(0x0, &quot;o&quot;);
 4233     no_overflow(0x1, &quot;no&quot;);
 4234   %}
 4235 %}
 4236 
 4237 //----------OPERAND CLASSES----------------------------------------------------
 4238 // Operand Classes are groups of operands that are used as to simplify
 4239 // instruction definitions by not requiring the AD writer to specify separate
 4240 // instructions for every form of operand when the instruction accepts
 4241 // multiple operand types with the same basic encoding and format.  The classic
 4242 // case of this is memory operands.
 4243 
 4244 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4245                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
 4246                indCompressedOop, indCompressedOopOffset,
 4247                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4248                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4249                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4250 
 4251 //----------PIPELINE-----------------------------------------------------------
 4252 // Rules which define the behavior of the target architectures pipeline.
 4253 pipeline %{
 4254 
 4255 //----------ATTRIBUTES---------------------------------------------------------
 4256 attributes %{
 4257   variable_size_instructions;        // Fixed size instructions
 4258   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4259   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4260   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4261   instruction_fetch_units = 1;       // of 16 bytes
 4262 
 4263   // List of nop instructions
 4264   nops( MachNop );
 4265 %}
 4266 
 4267 //----------RESOURCES----------------------------------------------------------
 4268 // Resources are the functional units available to the machine
 4269 
 4270 // Generic P2/P3 pipeline
 4271 // 3 decoders, only D0 handles big operands; a &quot;bundle&quot; is the limit of
 4272 // 3 instructions decoded per cycle.
 4273 // 2 load/store ops per cycle, 1 branch, 1 FPU,
 4274 // 3 ALU op, only ALU0 handles mul instructions.
 4275 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
 4276            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
 4277            BR, FPU,
 4278            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
 4279 
 4280 //----------PIPELINE DESCRIPTION-----------------------------------------------
 4281 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 4282 
 4283 // Generic P2/P3 pipeline
 4284 pipe_desc(S0, S1, S2, S3, S4, S5);
 4285 
 4286 //----------PIPELINE CLASSES---------------------------------------------------
 4287 // Pipeline Classes describe the stages in which input and output are
 4288 // referenced by the hardware pipeline.
 4289 
 4290 // Naming convention: ialu or fpu
 4291 // Then: _reg
 4292 // Then: _reg if there is a 2nd register
 4293 // Then: _long if it&#39;s a pair of instructions implementing a long
 4294 // Then: _fat if it requires the big decoder
 4295 //   Or: _mem if it requires the big decoder and a memory unit.
 4296 
 4297 // Integer ALU reg operation
 4298 pipe_class ialu_reg(rRegI dst)
 4299 %{
 4300     single_instruction;
 4301     dst    : S4(write);
 4302     dst    : S3(read);
 4303     DECODE : S0;        // any decoder
 4304     ALU    : S3;        // any alu
 4305 %}
 4306 
 4307 // Long ALU reg operation
 4308 pipe_class ialu_reg_long(rRegL dst)
 4309 %{
 4310     instruction_count(2);
 4311     dst    : S4(write);
 4312     dst    : S3(read);
 4313     DECODE : S0(2);     // any 2 decoders
 4314     ALU    : S3(2);     // both alus
 4315 %}
 4316 
 4317 // Integer ALU reg operation using big decoder
 4318 pipe_class ialu_reg_fat(rRegI dst)
 4319 %{
 4320     single_instruction;
 4321     dst    : S4(write);
 4322     dst    : S3(read);
 4323     D0     : S0;        // big decoder only
 4324     ALU    : S3;        // any alu
 4325 %}
 4326 
 4327 // Long ALU reg operation using big decoder
 4328 pipe_class ialu_reg_long_fat(rRegL dst)
 4329 %{
 4330     instruction_count(2);
 4331     dst    : S4(write);
 4332     dst    : S3(read);
 4333     D0     : S0(2);     // big decoder only; twice
 4334     ALU    : S3(2);     // any 2 alus
 4335 %}
 4336 
 4337 // Integer ALU reg-reg operation
 4338 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
 4339 %{
 4340     single_instruction;
 4341     dst    : S4(write);
 4342     src    : S3(read);
 4343     DECODE : S0;        // any decoder
 4344     ALU    : S3;        // any alu
 4345 %}
 4346 
 4347 // Long ALU reg-reg operation
 4348 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
 4349 %{
 4350     instruction_count(2);
 4351     dst    : S4(write);
 4352     src    : S3(read);
 4353     DECODE : S0(2);     // any 2 decoders
 4354     ALU    : S3(2);     // both alus
 4355 %}
 4356 
 4357 // Integer ALU reg-reg operation
 4358 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
 4359 %{
 4360     single_instruction;
 4361     dst    : S4(write);
 4362     src    : S3(read);
 4363     D0     : S0;        // big decoder only
 4364     ALU    : S3;        // any alu
 4365 %}
 4366 
 4367 // Long ALU reg-reg operation
 4368 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
 4369 %{
 4370     instruction_count(2);
 4371     dst    : S4(write);
 4372     src    : S3(read);
 4373     D0     : S0(2);     // big decoder only; twice
 4374     ALU    : S3(2);     // both alus
 4375 %}
 4376 
 4377 // Integer ALU reg-mem operation
 4378 pipe_class ialu_reg_mem(rRegI dst, memory mem)
 4379 %{
 4380     single_instruction;
 4381     dst    : S5(write);
 4382     mem    : S3(read);
 4383     D0     : S0;        // big decoder only
 4384     ALU    : S4;        // any alu
 4385     MEM    : S3;        // any mem
 4386 %}
 4387 
 4388 // Integer mem operation (prefetch)
 4389 pipe_class ialu_mem(memory mem)
 4390 %{
 4391     single_instruction;
 4392     mem    : S3(read);
 4393     D0     : S0;        // big decoder only
 4394     MEM    : S3;        // any mem
 4395 %}
 4396 
 4397 // Integer Store to Memory
 4398 pipe_class ialu_mem_reg(memory mem, rRegI src)
 4399 %{
 4400     single_instruction;
 4401     mem    : S3(read);
 4402     src    : S5(read);
 4403     D0     : S0;        // big decoder only
 4404     ALU    : S4;        // any alu
 4405     MEM    : S3;
 4406 %}
 4407 
 4408 // // Long Store to Memory
 4409 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
 4410 // %{
 4411 //     instruction_count(2);
 4412 //     mem    : S3(read);
 4413 //     src    : S5(read);
 4414 //     D0     : S0(2);          // big decoder only; twice
 4415 //     ALU    : S4(2);     // any 2 alus
 4416 //     MEM    : S3(2);  // Both mems
 4417 // %}
 4418 
 4419 // Integer Store to Memory
 4420 pipe_class ialu_mem_imm(memory mem)
 4421 %{
 4422     single_instruction;
 4423     mem    : S3(read);
 4424     D0     : S0;        // big decoder only
 4425     ALU    : S4;        // any alu
 4426     MEM    : S3;
 4427 %}
 4428 
 4429 // Integer ALU0 reg-reg operation
 4430 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
 4431 %{
 4432     single_instruction;
 4433     dst    : S4(write);
 4434     src    : S3(read);
 4435     D0     : S0;        // Big decoder only
 4436     ALU0   : S3;        // only alu0
 4437 %}
 4438 
 4439 // Integer ALU0 reg-mem operation
 4440 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
 4441 %{
 4442     single_instruction;
 4443     dst    : S5(write);
 4444     mem    : S3(read);
 4445     D0     : S0;        // big decoder only
 4446     ALU0   : S4;        // ALU0 only
 4447     MEM    : S3;        // any mem
 4448 %}
 4449 
 4450 // Integer ALU reg-reg operation
 4451 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
 4452 %{
 4453     single_instruction;
 4454     cr     : S4(write);
 4455     src1   : S3(read);
 4456     src2   : S3(read);
 4457     DECODE : S0;        // any decoder
 4458     ALU    : S3;        // any alu
 4459 %}
 4460 
 4461 // Integer ALU reg-imm operation
 4462 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
 4463 %{
 4464     single_instruction;
 4465     cr     : S4(write);
 4466     src1   : S3(read);
 4467     DECODE : S0;        // any decoder
 4468     ALU    : S3;        // any alu
 4469 %}
 4470 
 4471 // Integer ALU reg-mem operation
 4472 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
 4473 %{
 4474     single_instruction;
 4475     cr     : S4(write);
 4476     src1   : S3(read);
 4477     src2   : S3(read);
 4478     D0     : S0;        // big decoder only
 4479     ALU    : S4;        // any alu
 4480     MEM    : S3;
 4481 %}
 4482 
 4483 // Conditional move reg-reg
 4484 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
 4485 %{
 4486     instruction_count(4);
 4487     y      : S4(read);
 4488     q      : S3(read);
 4489     p      : S3(read);
 4490     DECODE : S0(4);     // any decoder
 4491 %}
 4492 
 4493 // Conditional move reg-reg
 4494 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
 4495 %{
 4496     single_instruction;
 4497     dst    : S4(write);
 4498     src    : S3(read);
 4499     cr     : S3(read);
 4500     DECODE : S0;        // any decoder
 4501 %}
 4502 
 4503 // Conditional move reg-mem
 4504 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
 4505 %{
 4506     single_instruction;
 4507     dst    : S4(write);
 4508     src    : S3(read);
 4509     cr     : S3(read);
 4510     DECODE : S0;        // any decoder
 4511     MEM    : S3;
 4512 %}
 4513 
 4514 // Conditional move reg-reg long
 4515 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
 4516 %{
 4517     single_instruction;
 4518     dst    : S4(write);
 4519     src    : S3(read);
 4520     cr     : S3(read);
 4521     DECODE : S0(2);     // any 2 decoders
 4522 %}
 4523 
 4524 // XXX
 4525 // // Conditional move double reg-reg
 4526 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
 4527 // %{
 4528 //     single_instruction;
 4529 //     dst    : S4(write);
 4530 //     src    : S3(read);
 4531 //     cr     : S3(read);
 4532 //     DECODE : S0;     // any decoder
 4533 // %}
 4534 
 4535 // Float reg-reg operation
 4536 pipe_class fpu_reg(regD dst)
 4537 %{
 4538     instruction_count(2);
 4539     dst    : S3(read);
 4540     DECODE : S0(2);     // any 2 decoders
 4541     FPU    : S3;
 4542 %}
 4543 
 4544 // Float reg-reg operation
 4545 pipe_class fpu_reg_reg(regD dst, regD src)
 4546 %{
 4547     instruction_count(2);
 4548     dst    : S4(write);
 4549     src    : S3(read);
 4550     DECODE : S0(2);     // any 2 decoders
 4551     FPU    : S3;
 4552 %}
 4553 
 4554 // Float reg-reg operation
 4555 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
 4556 %{
 4557     instruction_count(3);
 4558     dst    : S4(write);
 4559     src1   : S3(read);
 4560     src2   : S3(read);
 4561     DECODE : S0(3);     // any 3 decoders
 4562     FPU    : S3(2);
 4563 %}
 4564 
 4565 // Float reg-reg operation
 4566 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
 4567 %{
 4568     instruction_count(4);
 4569     dst    : S4(write);
 4570     src1   : S3(read);
 4571     src2   : S3(read);
 4572     src3   : S3(read);
 4573     DECODE : S0(4);     // any 3 decoders
 4574     FPU    : S3(2);
 4575 %}
 4576 
 4577 // Float reg-reg operation
 4578 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
 4579 %{
 4580     instruction_count(4);
 4581     dst    : S4(write);
 4582     src1   : S3(read);
 4583     src2   : S3(read);
 4584     src3   : S3(read);
 4585     DECODE : S1(3);     // any 3 decoders
 4586     D0     : S0;        // Big decoder only
 4587     FPU    : S3(2);
 4588     MEM    : S3;
 4589 %}
 4590 
 4591 // Float reg-mem operation
 4592 pipe_class fpu_reg_mem(regD dst, memory mem)
 4593 %{
 4594     instruction_count(2);
 4595     dst    : S5(write);
 4596     mem    : S3(read);
 4597     D0     : S0;        // big decoder only
 4598     DECODE : S1;        // any decoder for FPU POP
 4599     FPU    : S4;
 4600     MEM    : S3;        // any mem
 4601 %}
 4602 
 4603 // Float reg-mem operation
 4604 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
 4605 %{
 4606     instruction_count(3);
 4607     dst    : S5(write);
 4608     src1   : S3(read);
 4609     mem    : S3(read);
 4610     D0     : S0;        // big decoder only
 4611     DECODE : S1(2);     // any decoder for FPU POP
 4612     FPU    : S4;
 4613     MEM    : S3;        // any mem
 4614 %}
 4615 
 4616 // Float mem-reg operation
 4617 pipe_class fpu_mem_reg(memory mem, regD src)
 4618 %{
 4619     instruction_count(2);
 4620     src    : S5(read);
 4621     mem    : S3(read);
 4622     DECODE : S0;        // any decoder for FPU PUSH
 4623     D0     : S1;        // big decoder only
 4624     FPU    : S4;
 4625     MEM    : S3;        // any mem
 4626 %}
 4627 
 4628 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
 4629 %{
 4630     instruction_count(3);
 4631     src1   : S3(read);
 4632     src2   : S3(read);
 4633     mem    : S3(read);
 4634     DECODE : S0(2);     // any decoder for FPU PUSH
 4635     D0     : S1;        // big decoder only
 4636     FPU    : S4;
 4637     MEM    : S3;        // any mem
 4638 %}
 4639 
 4640 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
 4641 %{
 4642     instruction_count(3);
 4643     src1   : S3(read);
 4644     src2   : S3(read);
 4645     mem    : S4(read);
 4646     DECODE : S0;        // any decoder for FPU PUSH
 4647     D0     : S0(2);     // big decoder only
 4648     FPU    : S4;
 4649     MEM    : S3(2);     // any mem
 4650 %}
 4651 
 4652 pipe_class fpu_mem_mem(memory dst, memory src1)
 4653 %{
 4654     instruction_count(2);
 4655     src1   : S3(read);
 4656     dst    : S4(read);
 4657     D0     : S0(2);     // big decoder only
 4658     MEM    : S3(2);     // any mem
 4659 %}
 4660 
 4661 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
 4662 %{
 4663     instruction_count(3);
 4664     src1   : S3(read);
 4665     src2   : S3(read);
 4666     dst    : S4(read);
 4667     D0     : S0(3);     // big decoder only
 4668     FPU    : S4;
 4669     MEM    : S3(3);     // any mem
 4670 %}
 4671 
 4672 pipe_class fpu_mem_reg_con(memory mem, regD src1)
 4673 %{
 4674     instruction_count(3);
 4675     src1   : S4(read);
 4676     mem    : S4(read);
 4677     DECODE : S0;        // any decoder for FPU PUSH
 4678     D0     : S0(2);     // big decoder only
 4679     FPU    : S4;
 4680     MEM    : S3(2);     // any mem
 4681 %}
 4682 
 4683 // Float load constant
 4684 pipe_class fpu_reg_con(regD dst)
 4685 %{
 4686     instruction_count(2);
 4687     dst    : S5(write);
 4688     D0     : S0;        // big decoder only for the load
 4689     DECODE : S1;        // any decoder for FPU POP
 4690     FPU    : S4;
 4691     MEM    : S3;        // any mem
 4692 %}
 4693 
 4694 // Float load constant
 4695 pipe_class fpu_reg_reg_con(regD dst, regD src)
 4696 %{
 4697     instruction_count(3);
 4698     dst    : S5(write);
 4699     src    : S3(read);
 4700     D0     : S0;        // big decoder only for the load
 4701     DECODE : S1(2);     // any decoder for FPU POP
 4702     FPU    : S4;
 4703     MEM    : S3;        // any mem
 4704 %}
 4705 
 4706 // UnConditional branch
 4707 pipe_class pipe_jmp(label labl)
 4708 %{
 4709     single_instruction;
 4710     BR   : S3;
 4711 %}
 4712 
 4713 // Conditional branch
 4714 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
 4715 %{
 4716     single_instruction;
 4717     cr    : S1(read);
 4718     BR    : S3;
 4719 %}
 4720 
 4721 // Allocation idiom
 4722 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
 4723 %{
 4724     instruction_count(1); force_serialization;
 4725     fixed_latency(6);
 4726     heap_ptr : S3(read);
 4727     DECODE   : S0(3);
 4728     D0       : S2;
 4729     MEM      : S3;
 4730     ALU      : S3(2);
 4731     dst      : S5(write);
 4732     BR       : S5;
 4733 %}
 4734 
 4735 // Generic big/slow expanded idiom
 4736 pipe_class pipe_slow()
 4737 %{
 4738     instruction_count(10); multiple_bundles; force_serialization;
 4739     fixed_latency(100);
 4740     D0  : S0(2);
 4741     MEM : S3(2);
 4742 %}
 4743 
 4744 // The real do-nothing guy
 4745 pipe_class empty()
 4746 %{
 4747     instruction_count(0);
 4748 %}
 4749 
 4750 // Define the class for the Nop node
 4751 define
 4752 %{
 4753    MachNop = empty;
 4754 %}
 4755 
 4756 %}
 4757 
 4758 //----------INSTRUCTIONS-------------------------------------------------------
 4759 //
 4760 // match      -- States which machine-independent subtree may be replaced
 4761 //               by this instruction.
 4762 // ins_cost   -- The estimated cost of this instruction is used by instruction
 4763 //               selection to identify a minimum cost tree of machine
 4764 //               instructions that matches a tree of machine-independent
 4765 //               instructions.
 4766 // format     -- A string providing the disassembly for this instruction.
 4767 //               The value of an instruction&#39;s operand may be inserted
 4768 //               by referring to it with a &#39;$&#39; prefix.
 4769 // opcode     -- Three instruction opcodes may be provided.  These are referred
 4770 //               to within an encode class as $primary, $secondary, and $tertiary
 4771 //               rrspectively.  The primary opcode is commonly used to
 4772 //               indicate the type of machine instruction, while secondary
 4773 //               and tertiary are often used for prefix options or addressing
 4774 //               modes.
 4775 // ins_encode -- A list of encode classes with parameters. The encode class
 4776 //               name must have been defined in an &#39;enc_class&#39; specification
 4777 //               in the encode section of the architecture description.
 4778 
 4779 
 4780 //----------Load/Store/Move Instructions---------------------------------------
 4781 //----------Load Instructions--------------------------------------------------
 4782 
 4783 // Load Byte (8 bit signed)
 4784 instruct loadB(rRegI dst, memory mem)
 4785 %{
 4786   match(Set dst (LoadB mem));
 4787 
 4788   ins_cost(125);
 4789   format %{ &quot;movsbl  $dst, $mem\t# byte&quot; %}
 4790 
 4791   ins_encode %{
 4792     __ movsbl($dst$$Register, $mem$$Address);
 4793   %}
 4794 
 4795   ins_pipe(ialu_reg_mem);
 4796 %}
 4797 
 4798 // Load Byte (8 bit signed) into Long Register
 4799 instruct loadB2L(rRegL dst, memory mem)
 4800 %{
 4801   match(Set dst (ConvI2L (LoadB mem)));
 4802 
 4803   ins_cost(125);
 4804   format %{ &quot;movsbq  $dst, $mem\t# byte -&gt; long&quot; %}
 4805 
 4806   ins_encode %{
 4807     __ movsbq($dst$$Register, $mem$$Address);
 4808   %}
 4809 
 4810   ins_pipe(ialu_reg_mem);
 4811 %}
 4812 
 4813 // Load Unsigned Byte (8 bit UNsigned)
 4814 instruct loadUB(rRegI dst, memory mem)
 4815 %{
 4816   match(Set dst (LoadUB mem));
 4817 
 4818   ins_cost(125);
 4819   format %{ &quot;movzbl  $dst, $mem\t# ubyte&quot; %}
 4820 
 4821   ins_encode %{
 4822     __ movzbl($dst$$Register, $mem$$Address);
 4823   %}
 4824 
 4825   ins_pipe(ialu_reg_mem);
 4826 %}
 4827 
 4828 // Load Unsigned Byte (8 bit UNsigned) into Long Register
 4829 instruct loadUB2L(rRegL dst, memory mem)
 4830 %{
 4831   match(Set dst (ConvI2L (LoadUB mem)));
 4832 
 4833   ins_cost(125);
 4834   format %{ &quot;movzbq  $dst, $mem\t# ubyte -&gt; long&quot; %}
 4835 
 4836   ins_encode %{
 4837     __ movzbq($dst$$Register, $mem$$Address);
 4838   %}
 4839 
 4840   ins_pipe(ialu_reg_mem);
 4841 %}
 4842 
 4843 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
 4844 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4845   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 4846   effect(KILL cr);
 4847 
 4848   format %{ &quot;movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t&quot;
 4849             &quot;andl    $dst, right_n_bits($mask, 8)&quot; %}
 4850   ins_encode %{
 4851     Register Rdst = $dst$$Register;
 4852     __ movzbq(Rdst, $mem$$Address);
 4853     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
 4854   %}
 4855   ins_pipe(ialu_reg_mem);
 4856 %}
 4857 
 4858 // Load Short (16 bit signed)
 4859 instruct loadS(rRegI dst, memory mem)
 4860 %{
 4861   match(Set dst (LoadS mem));
 4862 
 4863   ins_cost(125);
 4864   format %{ &quot;movswl $dst, $mem\t# short&quot; %}
 4865 
 4866   ins_encode %{
 4867     __ movswl($dst$$Register, $mem$$Address);
 4868   %}
 4869 
 4870   ins_pipe(ialu_reg_mem);
 4871 %}
 4872 
 4873 // Load Short (16 bit signed) to Byte (8 bit signed)
 4874 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4875   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 4876 
 4877   ins_cost(125);
 4878   format %{ &quot;movsbl $dst, $mem\t# short -&gt; byte&quot; %}
 4879   ins_encode %{
 4880     __ movsbl($dst$$Register, $mem$$Address);
 4881   %}
 4882   ins_pipe(ialu_reg_mem);
 4883 %}
 4884 
 4885 // Load Short (16 bit signed) into Long Register
 4886 instruct loadS2L(rRegL dst, memory mem)
 4887 %{
 4888   match(Set dst (ConvI2L (LoadS mem)));
 4889 
 4890   ins_cost(125);
 4891   format %{ &quot;movswq $dst, $mem\t# short -&gt; long&quot; %}
 4892 
 4893   ins_encode %{
 4894     __ movswq($dst$$Register, $mem$$Address);
 4895   %}
 4896 
 4897   ins_pipe(ialu_reg_mem);
 4898 %}
 4899 
 4900 // Load Unsigned Short/Char (16 bit UNsigned)
 4901 instruct loadUS(rRegI dst, memory mem)
 4902 %{
 4903   match(Set dst (LoadUS mem));
 4904 
 4905   ins_cost(125);
 4906   format %{ &quot;movzwl  $dst, $mem\t# ushort/char&quot; %}
 4907 
 4908   ins_encode %{
 4909     __ movzwl($dst$$Register, $mem$$Address);
 4910   %}
 4911 
 4912   ins_pipe(ialu_reg_mem);
 4913 %}
 4914 
 4915 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 4916 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4917   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 4918 
 4919   ins_cost(125);
 4920   format %{ &quot;movsbl $dst, $mem\t# ushort -&gt; byte&quot; %}
 4921   ins_encode %{
 4922     __ movsbl($dst$$Register, $mem$$Address);
 4923   %}
 4924   ins_pipe(ialu_reg_mem);
 4925 %}
 4926 
 4927 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
 4928 instruct loadUS2L(rRegL dst, memory mem)
 4929 %{
 4930   match(Set dst (ConvI2L (LoadUS mem)));
 4931 
 4932   ins_cost(125);
 4933   format %{ &quot;movzwq  $dst, $mem\t# ushort/char -&gt; long&quot; %}
 4934 
 4935   ins_encode %{
 4936     __ movzwq($dst$$Register, $mem$$Address);
 4937   %}
 4938 
 4939   ins_pipe(ialu_reg_mem);
 4940 %}
 4941 
 4942 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
 4943 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 4944   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4945 
 4946   format %{ &quot;movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long&quot; %}
 4947   ins_encode %{
 4948     __ movzbq($dst$$Register, $mem$$Address);
 4949   %}
 4950   ins_pipe(ialu_reg_mem);
 4951 %}
 4952 
 4953 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
 4954 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
 4955   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 4956   effect(KILL cr);
 4957 
 4958   format %{ &quot;movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t&quot;
 4959             &quot;andl    $dst, right_n_bits($mask, 16)&quot; %}
 4960   ins_encode %{
 4961     Register Rdst = $dst$$Register;
 4962     __ movzwq(Rdst, $mem$$Address);
 4963     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
 4964   %}
 4965   ins_pipe(ialu_reg_mem);
 4966 %}
 4967 
 4968 // Load Integer
 4969 instruct loadI(rRegI dst, memory mem)
 4970 %{
 4971   match(Set dst (LoadI mem));
 4972 
 4973   ins_cost(125);
 4974   format %{ &quot;movl    $dst, $mem\t# int&quot; %}
 4975 
 4976   ins_encode %{
 4977     __ movl($dst$$Register, $mem$$Address);
 4978   %}
 4979 
 4980   ins_pipe(ialu_reg_mem);
 4981 %}
 4982 
 4983 // Load Integer (32 bit signed) to Byte (8 bit signed)
 4984 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
 4985   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 4986 
 4987   ins_cost(125);
 4988   format %{ &quot;movsbl  $dst, $mem\t# int -&gt; byte&quot; %}
 4989   ins_encode %{
 4990     __ movsbl($dst$$Register, $mem$$Address);
 4991   %}
 4992   ins_pipe(ialu_reg_mem);
 4993 %}
 4994 
 4995 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
 4996 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
 4997   match(Set dst (AndI (LoadI mem) mask));
 4998 
 4999   ins_cost(125);
 5000   format %{ &quot;movzbl  $dst, $mem\t# int -&gt; ubyte&quot; %}
 5001   ins_encode %{
 5002     __ movzbl($dst$$Register, $mem$$Address);
 5003   %}
 5004   ins_pipe(ialu_reg_mem);
 5005 %}
 5006 
 5007 // Load Integer (32 bit signed) to Short (16 bit signed)
 5008 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
 5009   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 5010 
 5011   ins_cost(125);
 5012   format %{ &quot;movswl  $dst, $mem\t# int -&gt; short&quot; %}
 5013   ins_encode %{
 5014     __ movswl($dst$$Register, $mem$$Address);
 5015   %}
 5016   ins_pipe(ialu_reg_mem);
 5017 %}
 5018 
 5019 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
 5020 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
 5021   match(Set dst (AndI (LoadI mem) mask));
 5022 
 5023   ins_cost(125);
 5024   format %{ &quot;movzwl  $dst, $mem\t# int -&gt; ushort/char&quot; %}
 5025   ins_encode %{
 5026     __ movzwl($dst$$Register, $mem$$Address);
 5027   %}
 5028   ins_pipe(ialu_reg_mem);
 5029 %}
 5030 
 5031 // Load Integer into Long Register
 5032 instruct loadI2L(rRegL dst, memory mem)
 5033 %{
 5034   match(Set dst (ConvI2L (LoadI mem)));
 5035 
 5036   ins_cost(125);
 5037   format %{ &quot;movslq  $dst, $mem\t# int -&gt; long&quot; %}
 5038 
 5039   ins_encode %{
 5040     __ movslq($dst$$Register, $mem$$Address);
 5041   %}
 5042 
 5043   ins_pipe(ialu_reg_mem);
 5044 %}
 5045 
 5046 // Load Integer with mask 0xFF into Long Register
 5047 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
 5048   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5049 
 5050   format %{ &quot;movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long&quot; %}
 5051   ins_encode %{
 5052     __ movzbq($dst$$Register, $mem$$Address);
 5053   %}
 5054   ins_pipe(ialu_reg_mem);
 5055 %}
 5056 
 5057 // Load Integer with mask 0xFFFF into Long Register
 5058 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
 5059   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5060 
 5061   format %{ &quot;movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long&quot; %}
 5062   ins_encode %{
 5063     __ movzwq($dst$$Register, $mem$$Address);
 5064   %}
 5065   ins_pipe(ialu_reg_mem);
 5066 %}
 5067 
 5068 // Load Integer with a 31-bit mask into Long Register
 5069 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
 5070   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 5071   effect(KILL cr);
 5072 
 5073   format %{ &quot;movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t&quot;
 5074             &quot;andl    $dst, $mask&quot; %}
 5075   ins_encode %{
 5076     Register Rdst = $dst$$Register;
 5077     __ movl(Rdst, $mem$$Address);
 5078     __ andl(Rdst, $mask$$constant);
 5079   %}
 5080   ins_pipe(ialu_reg_mem);
 5081 %}
 5082 
 5083 // Load Unsigned Integer into Long Register
 5084 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
 5085 %{
 5086   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5087 
 5088   ins_cost(125);
 5089   format %{ &quot;movl    $dst, $mem\t# uint -&gt; long&quot; %}
 5090 
 5091   ins_encode %{
 5092     __ movl($dst$$Register, $mem$$Address);
 5093   %}
 5094 
 5095   ins_pipe(ialu_reg_mem);
 5096 %}
 5097 
 5098 // Load Long
 5099 instruct loadL(rRegL dst, memory mem)
 5100 %{
 5101   match(Set dst (LoadL mem));
 5102 
 5103   ins_cost(125);
 5104   format %{ &quot;movq    $dst, $mem\t# long&quot; %}
 5105 
 5106   ins_encode %{
 5107     __ movq($dst$$Register, $mem$$Address);
 5108   %}
 5109 
 5110   ins_pipe(ialu_reg_mem); // XXX
 5111 %}
 5112 
 5113 // Load Range
 5114 instruct loadRange(rRegI dst, memory mem)
 5115 %{
 5116   match(Set dst (LoadRange mem));
 5117 
 5118   ins_cost(125); // XXX
 5119   format %{ &quot;movl    $dst, $mem\t# range&quot; %}
 5120   opcode(0x8B);
 5121   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
 5122   ins_pipe(ialu_reg_mem);
 5123 %}
 5124 
 5125 // Load Pointer
 5126 instruct loadP(rRegP dst, memory mem)
 5127 %{
 5128   match(Set dst (LoadP mem));
 5129   predicate(n-&gt;as_Load()-&gt;barrier_data() == 0);
 5130 
 5131   ins_cost(125); // XXX
 5132   format %{ &quot;movq    $dst, $mem\t# ptr&quot; %}
 5133   opcode(0x8B);
 5134   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5135   ins_pipe(ialu_reg_mem); // XXX
 5136 %}
 5137 
 5138 // Load Compressed Pointer
 5139 instruct loadN(rRegN dst, memory mem)
 5140 %{
 5141    match(Set dst (LoadN mem));
 5142 
 5143    ins_cost(125); // XXX
 5144    format %{ &quot;movl    $dst, $mem\t# compressed ptr&quot; %}
 5145    ins_encode %{
 5146      __ movl($dst$$Register, $mem$$Address);
 5147    %}
 5148    ins_pipe(ialu_reg_mem); // XXX
 5149 %}
 5150 
 5151 
 5152 // Load Klass Pointer
 5153 instruct loadKlass(rRegP dst, memory mem)
 5154 %{
 5155   match(Set dst (LoadKlass mem));
 5156 
 5157   ins_cost(125); // XXX
 5158   format %{ &quot;movq    $dst, $mem\t# class&quot; %}
 5159   opcode(0x8B);
 5160   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5161   ins_pipe(ialu_reg_mem); // XXX
 5162 %}
 5163 
 5164 // Load narrow Klass Pointer
 5165 instruct loadNKlass(rRegN dst, memory mem)
 5166 %{
 5167   match(Set dst (LoadNKlass mem));
 5168 
 5169   ins_cost(125); // XXX
 5170   format %{ &quot;movl    $dst, $mem\t# compressed klass ptr&quot; %}
 5171   ins_encode %{
 5172     __ movl($dst$$Register, $mem$$Address);
 5173   %}
 5174   ins_pipe(ialu_reg_mem); // XXX
 5175 %}
 5176 
 5177 // Load Float
 5178 instruct loadF(regF dst, memory mem)
 5179 %{
 5180   match(Set dst (LoadF mem));
 5181 
 5182   ins_cost(145); // XXX
 5183   format %{ &quot;movss   $dst, $mem\t# float&quot; %}
 5184   ins_encode %{
 5185     __ movflt($dst$$XMMRegister, $mem$$Address);
 5186   %}
 5187   ins_pipe(pipe_slow); // XXX
 5188 %}
 5189 
 5190 // Load Float
 5191 instruct MoveF2VL(vlRegF dst, regF src) %{
 5192   match(Set dst src);
 5193   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5194   ins_encode %{
 5195     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5196   %}
 5197   ins_pipe( fpu_reg_reg );
 5198 %}
 5199 
 5200 // Load Float
 5201 instruct MoveF2LEG(legRegF dst, regF src) %{
 5202   match(Set dst src);
 5203   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5204   ins_encode %{
 5205     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5206   %}
 5207   ins_pipe( fpu_reg_reg );
 5208 %}
 5209 
 5210 // Load Float
 5211 instruct MoveVL2F(regF dst, vlRegF src) %{
 5212   match(Set dst src);
 5213   format %{ &quot;movss $dst,$src\t! load float (4 bytes)&quot; %}
 5214   ins_encode %{
 5215     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5216   %}
 5217   ins_pipe( fpu_reg_reg );
 5218 %}
 5219 
 5220 // Load Float
 5221 instruct MoveLEG2F(regF dst, legRegF src) %{
 5222   match(Set dst src);
 5223   format %{ &quot;movss $dst,$src\t# if src != dst load float (4 bytes)&quot; %}
 5224   ins_encode %{
 5225     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 5226   %}
 5227   ins_pipe( fpu_reg_reg );
 5228 %}
 5229 
 5230 // Load Double
 5231 instruct loadD_partial(regD dst, memory mem)
 5232 %{
 5233   predicate(!UseXmmLoadAndClearUpper);
 5234   match(Set dst (LoadD mem));
 5235 
 5236   ins_cost(145); // XXX
 5237   format %{ &quot;movlpd  $dst, $mem\t# double&quot; %}
 5238   ins_encode %{
 5239     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5240   %}
 5241   ins_pipe(pipe_slow); // XXX
 5242 %}
 5243 
 5244 instruct loadD(regD dst, memory mem)
 5245 %{
 5246   predicate(UseXmmLoadAndClearUpper);
 5247   match(Set dst (LoadD mem));
 5248 
 5249   ins_cost(145); // XXX
 5250   format %{ &quot;movsd   $dst, $mem\t# double&quot; %}
 5251   ins_encode %{
 5252     __ movdbl($dst$$XMMRegister, $mem$$Address);
 5253   %}
 5254   ins_pipe(pipe_slow); // XXX
 5255 %}
 5256 
 5257 // Load Double
 5258 instruct MoveD2VL(vlRegD dst, regD src) %{
 5259   match(Set dst src);
 5260   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5261   ins_encode %{
 5262     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5263   %}
 5264   ins_pipe( fpu_reg_reg );
 5265 %}
 5266 
 5267 // Load Double
 5268 instruct MoveD2LEG(legRegD dst, regD src) %{
 5269   match(Set dst src);
 5270   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5271   ins_encode %{
 5272     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5273   %}
 5274   ins_pipe( fpu_reg_reg );
 5275 %}
 5276 
 5277 // Load Double
 5278 instruct MoveVL2D(regD dst, vlRegD src) %{
 5279   match(Set dst src);
 5280   format %{ &quot;movsd $dst,$src\t! load double (8 bytes)&quot; %}
 5281   ins_encode %{
 5282     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5283   %}
 5284   ins_pipe( fpu_reg_reg );
 5285 %}
 5286 
 5287 // Load Double
 5288 instruct MoveLEG2D(regD dst, legRegD src) %{
 5289   match(Set dst src);
 5290   format %{ &quot;movsd $dst,$src\t# if src != dst load double (8 bytes)&quot; %}
 5291   ins_encode %{
 5292     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 5293   %}
 5294   ins_pipe( fpu_reg_reg );
 5295 %}
 5296 
 5297 // Following pseudo code describes the algorithm for max[FD]:
 5298 // Min algorithm is on similar lines
 5299 //  btmp = (b &lt; +0.0) ? a : b
 5300 //  atmp = (b &lt; +0.0) ? b : a
 5301 //  Tmp  = Max_Float(atmp , btmp)
 5302 //  Res  = (atmp == NaN) ? atmp : Tmp
 5303 
 5304 // max = java.lang.Math.max(float a, float b)
 5305 instruct maxF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5306   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5307   match(Set dst (MaxF a b));
 5308   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5309   format %{
 5310      &quot;blendvps         $btmp,$b,$a,$b           \n\t&quot;
 5311      &quot;blendvps         $atmp,$a,$b,$b           \n\t&quot;
 5312      &quot;vmaxss           $tmp,$atmp,$btmp         \n\t&quot;
 5313      &quot;cmpps.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5314      &quot;blendvps         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5315   %}
 5316   ins_encode %{
 5317     int vector_len = Assembler::AVX_128bit;
 5318     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5319     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5320     __ vmaxss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5321     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5322     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5323  %}
 5324   ins_pipe( pipe_slow );
 5325 %}
 5326 
 5327 instruct maxF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5328   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5329   match(Set dst (MaxF a b));
 5330   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5331 
 5332   format %{ &quot;$dst = max($a, $b)\t# intrinsic (float)&quot; %}
 5333   ins_encode %{
 5334     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5335                     false /*min*/, true /*single*/);
 5336   %}
 5337   ins_pipe( pipe_slow );
 5338 %}
 5339 
 5340 // max = java.lang.Math.max(double a, double b)
 5341 instruct maxD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5342   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5343   match(Set dst (MaxD a b));
 5344   effect(USE a, USE b, TEMP atmp, TEMP btmp, TEMP tmp);
 5345   format %{
 5346      &quot;blendvpd         $btmp,$b,$a,$b            \n\t&quot;
 5347      &quot;blendvpd         $atmp,$a,$b,$b            \n\t&quot;
 5348      &quot;vmaxsd           $tmp,$atmp,$btmp          \n\t&quot;
 5349      &quot;cmppd.unordered  $btmp,$atmp,$atmp         \n\t&quot;
 5350      &quot;blendvpd         $dst,$tmp,$atmp,$btmp     \n\t&quot;
 5351   %}
 5352   ins_encode %{
 5353     int vector_len = Assembler::AVX_128bit;
 5354     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, vector_len);
 5355     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $b$$XMMRegister, vector_len);
 5356     __ vmaxsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5357     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5358     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5359   %}
 5360   ins_pipe( pipe_slow );
 5361 %}
 5362 
 5363 instruct maxD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5364   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5365   match(Set dst (MaxD a b));
 5366   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5367 
 5368   format %{ &quot;$dst = max($a, $b)\t# intrinsic (double)&quot; %}
 5369   ins_encode %{
 5370     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5371                     false /*min*/, false /*single*/);
 5372   %}
 5373   ins_pipe( pipe_slow );
 5374 %}
 5375 
 5376 // min = java.lang.Math.min(float a, float b)
 5377 instruct minF_reg(legRegF dst, legRegF a, legRegF b, legRegF tmp, legRegF atmp, legRegF btmp) %{
 5378   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5379   match(Set dst (MinF a b));
 5380   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5381   format %{
 5382      &quot;blendvps         $atmp,$a,$b,$a             \n\t&quot;
 5383      &quot;blendvps         $btmp,$b,$a,$a             \n\t&quot;
 5384      &quot;vminss           $tmp,$atmp,$btmp           \n\t&quot;
 5385      &quot;cmpps.unordered  $btmp,$atmp,$atmp          \n\t&quot;
 5386      &quot;blendvps         $dst,$tmp,$atmp,$btmp      \n\t&quot;
 5387   %}
 5388   ins_encode %{
 5389     int vector_len = Assembler::AVX_128bit;
 5390     __ blendvps($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5391     __ blendvps($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5392     __ vminss($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5393     __ cmpps($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5394     __ blendvps($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5395   %}
 5396   ins_pipe( pipe_slow );
 5397 %}
 5398 
 5399 instruct minF_reduction_reg(legRegF dst, legRegF a, legRegF b, legRegF xmmt, rRegI tmp, rFlagsReg cr) %{
 5400   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5401   match(Set dst (MinF a b));
 5402   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5403 
 5404   format %{ &quot;$dst = min($a, $b)\t# intrinsic (float)&quot; %}
 5405   ins_encode %{
 5406     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5407                     true /*min*/, true /*single*/);
 5408   %}
 5409   ins_pipe( pipe_slow );
 5410 %}
 5411 
 5412 // min = java.lang.Math.min(double a, double b)
 5413 instruct minD_reg(legRegD dst, legRegD a, legRegD b, legRegD tmp, legRegD atmp, legRegD btmp) %{
 5414   predicate(UseAVX &gt; 0 &amp;&amp; !n-&gt;is_reduction());
 5415   match(Set dst (MinD a b));
 5416   effect(USE a, USE b, TEMP tmp, TEMP atmp, TEMP btmp);
 5417   format %{
 5418      &quot;blendvpd         $atmp,$a,$b,$a           \n\t&quot;
 5419      &quot;blendvpd         $btmp,$b,$a,$a           \n\t&quot;
 5420      &quot;vminsd           $tmp,$atmp,$btmp         \n\t&quot;
 5421      &quot;cmppd.unordered  $btmp,$atmp,$atmp        \n\t&quot;
 5422      &quot;blendvpd         $dst,$tmp,$atmp,$btmp    \n\t&quot;
 5423   %}
 5424   ins_encode %{
 5425     int vector_len = Assembler::AVX_128bit;
 5426     __ blendvpd($atmp$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, vector_len);
 5427     __ blendvpd($btmp$$XMMRegister, $b$$XMMRegister, $a$$XMMRegister, $a$$XMMRegister, vector_len);
 5428     __ vminsd($tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister);
 5429     __ cmppd($btmp$$XMMRegister, $atmp$$XMMRegister, $atmp$$XMMRegister, Assembler::_false, vector_len);
 5430     __ blendvpd($dst$$XMMRegister, $tmp$$XMMRegister, $atmp$$XMMRegister, $btmp$$XMMRegister, vector_len);
 5431   %}
 5432   ins_pipe( pipe_slow );
 5433 %}
 5434 
 5435 instruct minD_reduction_reg(legRegD dst, legRegD a, legRegD b, legRegD xmmt, rRegL tmp, rFlagsReg cr) %{
 5436   predicate(UseAVX &gt; 0 &amp;&amp; n-&gt;is_reduction());
 5437   match(Set dst (MinD a b));
 5438   effect(USE a, USE b, TEMP xmmt, TEMP tmp, KILL cr);
 5439 
 5440   format %{ &quot;$dst = min($a, $b)\t# intrinsic (double)&quot; %}
 5441   ins_encode %{
 5442     emit_fp_min_max(_masm, $dst$$XMMRegister, $a$$XMMRegister, $b$$XMMRegister, $xmmt$$XMMRegister, $tmp$$Register,
 5443                     true /*min*/, false /*single*/);
 5444   %}
 5445   ins_pipe( pipe_slow );
 5446 %}
 5447 
 5448 // Load Effective Address
 5449 instruct leaP8(rRegP dst, indOffset8 mem)
 5450 %{
 5451   match(Set dst mem);
 5452 
 5453   ins_cost(110); // XXX
 5454   format %{ &quot;leaq    $dst, $mem\t# ptr 8&quot; %}
 5455   opcode(0x8D);
 5456   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5457   ins_pipe(ialu_reg_reg_fat);
 5458 %}
 5459 
 5460 instruct leaP32(rRegP dst, indOffset32 mem)
 5461 %{
 5462   match(Set dst mem);
 5463 
 5464   ins_cost(110);
 5465   format %{ &quot;leaq    $dst, $mem\t# ptr 32&quot; %}
 5466   opcode(0x8D);
 5467   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5468   ins_pipe(ialu_reg_reg_fat);
 5469 %}
 5470 
 5471 // instruct leaPIdx(rRegP dst, indIndex mem)
 5472 // %{
 5473 //   match(Set dst mem);
 5474 
 5475 //   ins_cost(110);
 5476 //   format %{ &quot;leaq    $dst, $mem\t# ptr idx&quot; %}
 5477 //   opcode(0x8D);
 5478 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5479 //   ins_pipe(ialu_reg_reg_fat);
 5480 // %}
 5481 
 5482 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
 5483 %{
 5484   match(Set dst mem);
 5485 
 5486   ins_cost(110);
 5487   format %{ &quot;leaq    $dst, $mem\t# ptr idxoff&quot; %}
 5488   opcode(0x8D);
 5489   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5490   ins_pipe(ialu_reg_reg_fat);
 5491 %}
 5492 
 5493 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
 5494 %{
 5495   match(Set dst mem);
 5496 
 5497   ins_cost(110);
 5498   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5499   opcode(0x8D);
 5500   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5501   ins_pipe(ialu_reg_reg_fat);
 5502 %}
 5503 
 5504 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
 5505 %{
 5506   match(Set dst mem);
 5507 
 5508   ins_cost(110);
 5509   format %{ &quot;leaq    $dst, $mem\t# ptr idxscale&quot; %}
 5510   opcode(0x8D);
 5511   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5512   ins_pipe(ialu_reg_reg_fat);
 5513 %}
 5514 
 5515 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
 5516 %{
 5517   match(Set dst mem);
 5518 
 5519   ins_cost(110);
 5520   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoff&quot; %}
 5521   opcode(0x8D);
 5522   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5523   ins_pipe(ialu_reg_reg_fat);
 5524 %}
 5525 
 5526 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
 5527 %{
 5528   match(Set dst mem);
 5529 
 5530   ins_cost(110);
 5531   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoff&quot; %}
 5532   opcode(0x8D);
 5533   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5534   ins_pipe(ialu_reg_reg_fat);
 5535 %}
 5536 
 5537 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
 5538 %{
 5539   match(Set dst mem);
 5540 
 5541   ins_cost(110);
 5542   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoff&quot; %}
 5543   opcode(0x8D);
 5544   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5545   ins_pipe(ialu_reg_reg_fat);
 5546 %}
 5547 
 5548 // Load Effective Address which uses Narrow (32-bits) oop
 5549 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
 5550 %{
 5551   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() != 0));
 5552   match(Set dst mem);
 5553 
 5554   ins_cost(110);
 5555   format %{ &quot;leaq    $dst, $mem\t# ptr compressedoopoff32&quot; %}
 5556   opcode(0x8D);
 5557   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5558   ins_pipe(ialu_reg_reg_fat);
 5559 %}
 5560 
 5561 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
 5562 %{
 5563   predicate(CompressedOops::shift() == 0);
 5564   match(Set dst mem);
 5565 
 5566   ins_cost(110); // XXX
 5567   format %{ &quot;leaq    $dst, $mem\t# ptr off8narrow&quot; %}
 5568   opcode(0x8D);
 5569   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5570   ins_pipe(ialu_reg_reg_fat);
 5571 %}
 5572 
 5573 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
 5574 %{
 5575   predicate(CompressedOops::shift() == 0);
 5576   match(Set dst mem);
 5577 
 5578   ins_cost(110);
 5579   format %{ &quot;leaq    $dst, $mem\t# ptr off32narrow&quot; %}
 5580   opcode(0x8D);
 5581   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5582   ins_pipe(ialu_reg_reg_fat);
 5583 %}
 5584 
 5585 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
 5586 %{
 5587   predicate(CompressedOops::shift() == 0);
 5588   match(Set dst mem);
 5589 
 5590   ins_cost(110);
 5591   format %{ &quot;leaq    $dst, $mem\t# ptr idxoffnarrow&quot; %}
 5592   opcode(0x8D);
 5593   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5594   ins_pipe(ialu_reg_reg_fat);
 5595 %}
 5596 
 5597 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
 5598 %{
 5599   predicate(CompressedOops::shift() == 0);
 5600   match(Set dst mem);
 5601 
 5602   ins_cost(110);
 5603   format %{ &quot;leaq    $dst, $mem\t# ptr idxscalenarrow&quot; %}
 5604   opcode(0x8D);
 5605   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5606   ins_pipe(ialu_reg_reg_fat);
 5607 %}
 5608 
 5609 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
 5610 %{
 5611   predicate(CompressedOops::shift() == 0);
 5612   match(Set dst mem);
 5613 
 5614   ins_cost(110);
 5615   format %{ &quot;leaq    $dst, $mem\t# ptr idxscaleoffnarrow&quot; %}
 5616   opcode(0x8D);
 5617   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5618   ins_pipe(ialu_reg_reg_fat);
 5619 %}
 5620 
 5621 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
 5622 %{
 5623   predicate(CompressedOops::shift() == 0);
 5624   match(Set dst mem);
 5625 
 5626   ins_cost(110);
 5627   format %{ &quot;leaq    $dst, $mem\t# ptr posidxoffnarrow&quot; %}
 5628   opcode(0x8D);
 5629   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5630   ins_pipe(ialu_reg_reg_fat);
 5631 %}
 5632 
 5633 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
 5634 %{
 5635   predicate(CompressedOops::shift() == 0);
 5636   match(Set dst mem);
 5637 
 5638   ins_cost(110);
 5639   format %{ &quot;leaq    $dst, $mem\t# ptr posidxscaleoffnarrow&quot; %}
 5640   opcode(0x8D);
 5641   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 5642   ins_pipe(ialu_reg_reg_fat);
 5643 %}
 5644 
 5645 instruct loadConI(rRegI dst, immI src)
 5646 %{
 5647   match(Set dst src);
 5648 
 5649   format %{ &quot;movl    $dst, $src\t# int&quot; %}
 5650   ins_encode(load_immI(dst, src));
 5651   ins_pipe(ialu_reg_fat); // XXX
 5652 %}
 5653 
 5654 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
 5655 %{
 5656   match(Set dst src);
 5657   effect(KILL cr);
 5658 
 5659   ins_cost(50);
 5660   format %{ &quot;xorl    $dst, $dst\t# int&quot; %}
 5661   opcode(0x33); /* + rd */
 5662   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5663   ins_pipe(ialu_reg);
 5664 %}
 5665 
 5666 instruct loadConL(rRegL dst, immL src)
 5667 %{
 5668   match(Set dst src);
 5669 
 5670   ins_cost(150);
 5671   format %{ &quot;movq    $dst, $src\t# long&quot; %}
 5672   ins_encode(load_immL(dst, src));
 5673   ins_pipe(ialu_reg);
 5674 %}
 5675 
 5676 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
 5677 %{
 5678   match(Set dst src);
 5679   effect(KILL cr);
 5680 
 5681   ins_cost(50);
 5682   format %{ &quot;xorl    $dst, $dst\t# long&quot; %}
 5683   opcode(0x33); /* + rd */
 5684   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5685   ins_pipe(ialu_reg); // XXX
 5686 %}
 5687 
 5688 instruct loadConUL32(rRegL dst, immUL32 src)
 5689 %{
 5690   match(Set dst src);
 5691 
 5692   ins_cost(60);
 5693   format %{ &quot;movl    $dst, $src\t# long (unsigned 32-bit)&quot; %}
 5694   ins_encode(load_immUL32(dst, src));
 5695   ins_pipe(ialu_reg);
 5696 %}
 5697 
 5698 instruct loadConL32(rRegL dst, immL32 src)
 5699 %{
 5700   match(Set dst src);
 5701 
 5702   ins_cost(70);
 5703   format %{ &quot;movq    $dst, $src\t# long (32-bit)&quot; %}
 5704   ins_encode(load_immL32(dst, src));
 5705   ins_pipe(ialu_reg);
 5706 %}
 5707 
 5708 instruct loadConP(rRegP dst, immP con) %{
 5709   match(Set dst con);
 5710 
 5711   format %{ &quot;movq    $dst, $con\t# ptr&quot; %}
 5712   ins_encode(load_immP(dst, con));
 5713   ins_pipe(ialu_reg_fat); // XXX
 5714 %}
 5715 
 5716 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
 5717 %{
 5718   match(Set dst src);
 5719   effect(KILL cr);
 5720 
 5721   ins_cost(50);
 5722   format %{ &quot;xorl    $dst, $dst\t# ptr&quot; %}
 5723   opcode(0x33); /* + rd */
 5724   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
 5725   ins_pipe(ialu_reg);
 5726 %}
 5727 
 5728 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
 5729 %{
 5730   match(Set dst src);
 5731   effect(KILL cr);
 5732 
 5733   ins_cost(60);
 5734   format %{ &quot;movl    $dst, $src\t# ptr (positive 32-bit)&quot; %}
 5735   ins_encode(load_immP31(dst, src));
 5736   ins_pipe(ialu_reg);
 5737 %}
 5738 
 5739 instruct loadConF(regF dst, immF con) %{
 5740   match(Set dst con);
 5741   ins_cost(125);
 5742   format %{ &quot;movss   $dst, [$constantaddress]\t# load from constant table: float=$con&quot; %}
 5743   ins_encode %{
 5744     __ movflt($dst$$XMMRegister, $constantaddress($con));
 5745   %}
 5746   ins_pipe(pipe_slow);
 5747 %}
 5748 
 5749 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
 5750   match(Set dst src);
 5751   effect(KILL cr);
 5752   format %{ &quot;xorq    $dst, $src\t# compressed NULL ptr&quot; %}
 5753   ins_encode %{
 5754     __ xorq($dst$$Register, $dst$$Register);
 5755   %}
 5756   ins_pipe(ialu_reg);
 5757 %}
 5758 
 5759 instruct loadConN(rRegN dst, immN src) %{
 5760   match(Set dst src);
 5761 
 5762   ins_cost(125);
 5763   format %{ &quot;movl    $dst, $src\t# compressed ptr&quot; %}
 5764   ins_encode %{
 5765     address con = (address)$src$$constant;
 5766     if (con == NULL) {
 5767       ShouldNotReachHere();
 5768     } else {
 5769       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
 5770     }
 5771   %}
 5772   ins_pipe(ialu_reg_fat); // XXX
 5773 %}
 5774 
 5775 instruct loadConNKlass(rRegN dst, immNKlass src) %{
 5776   match(Set dst src);
 5777 
 5778   ins_cost(125);
 5779   format %{ &quot;movl    $dst, $src\t# compressed klass ptr&quot; %}
 5780   ins_encode %{
 5781     address con = (address)$src$$constant;
 5782     if (con == NULL) {
 5783       ShouldNotReachHere();
 5784     } else {
 5785       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
 5786     }
 5787   %}
 5788   ins_pipe(ialu_reg_fat); // XXX
 5789 %}
 5790 
 5791 instruct loadConF0(regF dst, immF0 src)
 5792 %{
 5793   match(Set dst src);
 5794   ins_cost(100);
 5795 
 5796   format %{ &quot;xorps   $dst, $dst\t# float 0.0&quot; %}
 5797   ins_encode %{
 5798     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
 5799   %}
 5800   ins_pipe(pipe_slow);
 5801 %}
 5802 
 5803 // Use the same format since predicate() can not be used here.
 5804 instruct loadConD(regD dst, immD con) %{
 5805   match(Set dst con);
 5806   ins_cost(125);
 5807   format %{ &quot;movsd   $dst, [$constantaddress]\t# load from constant table: double=$con&quot; %}
 5808   ins_encode %{
 5809     __ movdbl($dst$$XMMRegister, $constantaddress($con));
 5810   %}
 5811   ins_pipe(pipe_slow);
 5812 %}
 5813 
 5814 instruct loadConD0(regD dst, immD0 src)
 5815 %{
 5816   match(Set dst src);
 5817   ins_cost(100);
 5818 
 5819   format %{ &quot;xorpd   $dst, $dst\t# double 0.0&quot; %}
 5820   ins_encode %{
 5821     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
 5822   %}
 5823   ins_pipe(pipe_slow);
 5824 %}
 5825 
 5826 instruct loadSSI(rRegI dst, stackSlotI src)
 5827 %{
 5828   match(Set dst src);
 5829 
 5830   ins_cost(125);
 5831   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 5832   opcode(0x8B);
 5833   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 5834   ins_pipe(ialu_reg_mem);
 5835 %}
 5836 
 5837 instruct loadSSL(rRegL dst, stackSlotL src)
 5838 %{
 5839   match(Set dst src);
 5840 
 5841   ins_cost(125);
 5842   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 5843   opcode(0x8B);
 5844   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5845   ins_pipe(ialu_reg_mem);
 5846 %}
 5847 
 5848 instruct loadSSP(rRegP dst, stackSlotP src)
 5849 %{
 5850   match(Set dst src);
 5851 
 5852   ins_cost(125);
 5853   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 5854   opcode(0x8B);
 5855   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 5856   ins_pipe(ialu_reg_mem);
 5857 %}
 5858 
 5859 instruct loadSSF(regF dst, stackSlotF src)
 5860 %{
 5861   match(Set dst src);
 5862 
 5863   ins_cost(125);
 5864   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 5865   ins_encode %{
 5866     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
 5867   %}
 5868   ins_pipe(pipe_slow); // XXX
 5869 %}
 5870 
 5871 // Use the same format since predicate() can not be used here.
 5872 instruct loadSSD(regD dst, stackSlotD src)
 5873 %{
 5874   match(Set dst src);
 5875 
 5876   ins_cost(125);
 5877   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 5878   ins_encode  %{
 5879     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
 5880   %}
 5881   ins_pipe(pipe_slow); // XXX
 5882 %}
 5883 
 5884 // Prefetch instructions for allocation.
 5885 // Must be safe to execute with invalid address (cannot fault).
 5886 
 5887 instruct prefetchAlloc( memory mem ) %{
 5888   predicate(AllocatePrefetchInstr==3);
 5889   match(PrefetchAllocation mem);
 5890   ins_cost(125);
 5891 
 5892   format %{ &quot;PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified&quot; %}
 5893   ins_encode %{
 5894     __ prefetchw($mem$$Address);
 5895   %}
 5896   ins_pipe(ialu_mem);
 5897 %}
 5898 
 5899 instruct prefetchAllocNTA( memory mem ) %{
 5900   predicate(AllocatePrefetchInstr==0);
 5901   match(PrefetchAllocation mem);
 5902   ins_cost(125);
 5903 
 5904   format %{ &quot;PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write&quot; %}
 5905   ins_encode %{
 5906     __ prefetchnta($mem$$Address);
 5907   %}
 5908   ins_pipe(ialu_mem);
 5909 %}
 5910 
 5911 instruct prefetchAllocT0( memory mem ) %{
 5912   predicate(AllocatePrefetchInstr==1);
 5913   match(PrefetchAllocation mem);
 5914   ins_cost(125);
 5915 
 5916   format %{ &quot;PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write&quot; %}
 5917   ins_encode %{
 5918     __ prefetcht0($mem$$Address);
 5919   %}
 5920   ins_pipe(ialu_mem);
 5921 %}
 5922 
 5923 instruct prefetchAllocT2( memory mem ) %{
 5924   predicate(AllocatePrefetchInstr==2);
 5925   match(PrefetchAllocation mem);
 5926   ins_cost(125);
 5927 
 5928   format %{ &quot;PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write&quot; %}
 5929   ins_encode %{
 5930     __ prefetcht2($mem$$Address);
 5931   %}
 5932   ins_pipe(ialu_mem);
 5933 %}
 5934 
 5935 //----------Store Instructions-------------------------------------------------
 5936 
 5937 // Store Byte
 5938 instruct storeB(memory mem, rRegI src)
 5939 %{
 5940   match(Set mem (StoreB mem src));
 5941 
 5942   ins_cost(125); // XXX
 5943   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 5944   opcode(0x88);
 5945   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
 5946   ins_pipe(ialu_mem_reg);
 5947 %}
 5948 
 5949 // Store Char/Short
 5950 instruct storeC(memory mem, rRegI src)
 5951 %{
 5952   match(Set mem (StoreC mem src));
 5953 
 5954   ins_cost(125); // XXX
 5955   format %{ &quot;movw    $mem, $src\t# char/short&quot; %}
 5956   opcode(0x89);
 5957   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5958   ins_pipe(ialu_mem_reg);
 5959 %}
 5960 
 5961 // Store Integer
 5962 instruct storeI(memory mem, rRegI src)
 5963 %{
 5964   match(Set mem (StoreI mem src));
 5965 
 5966   ins_cost(125); // XXX
 5967   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 5968   opcode(0x89);
 5969   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
 5970   ins_pipe(ialu_mem_reg);
 5971 %}
 5972 
 5973 // Store Long
 5974 instruct storeL(memory mem, rRegL src)
 5975 %{
 5976   match(Set mem (StoreL mem src));
 5977 
 5978   ins_cost(125); // XXX
 5979   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 5980   opcode(0x89);
 5981   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5982   ins_pipe(ialu_mem_reg); // XXX
 5983 %}
 5984 
 5985 // Store Pointer
 5986 instruct storeP(memory mem, any_RegP src)
 5987 %{
 5988   match(Set mem (StoreP mem src));
 5989 
 5990   ins_cost(125); // XXX
 5991   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 5992   opcode(0x89);
 5993   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
 5994   ins_pipe(ialu_mem_reg);
 5995 %}
 5996 
 5997 instruct storeImmP0(memory mem, immP0 zero)
 5998 %{
 5999   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6000   match(Set mem (StoreP mem zero));
 6001 
 6002   ins_cost(125); // XXX
 6003   format %{ &quot;movq    $mem, R12\t# ptr (R12_heapbase==0)&quot; %}
 6004   ins_encode %{
 6005     __ movq($mem$$Address, r12);
 6006   %}
 6007   ins_pipe(ialu_mem_reg);
 6008 %}
 6009 
 6010 // Store NULL Pointer, mark word, or other simple pointer constant.
 6011 instruct storeImmP(memory mem, immP31 src)
 6012 %{
 6013   match(Set mem (StoreP mem src));
 6014 
 6015   ins_cost(150); // XXX
 6016   format %{ &quot;movq    $mem, $src\t# ptr&quot; %}
 6017   opcode(0xC7); /* C7 /0 */
 6018   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6019   ins_pipe(ialu_mem_imm);
 6020 %}
 6021 
 6022 // Store Compressed Pointer
 6023 instruct storeN(memory mem, rRegN src)
 6024 %{
 6025   match(Set mem (StoreN mem src));
 6026 
 6027   ins_cost(125); // XXX
 6028   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6029   ins_encode %{
 6030     __ movl($mem$$Address, $src$$Register);
 6031   %}
 6032   ins_pipe(ialu_mem_reg);
 6033 %}
 6034 
 6035 instruct storeNKlass(memory mem, rRegN src)
 6036 %{
 6037   match(Set mem (StoreNKlass mem src));
 6038 
 6039   ins_cost(125); // XXX
 6040   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6041   ins_encode %{
 6042     __ movl($mem$$Address, $src$$Register);
 6043   %}
 6044   ins_pipe(ialu_mem_reg);
 6045 %}
 6046 
 6047 instruct storeImmN0(memory mem, immN0 zero)
 6048 %{
 6049   predicate(CompressedOops::base() == NULL &amp;&amp; CompressedKlassPointers::base() == NULL);
 6050   match(Set mem (StoreN mem zero));
 6051 
 6052   ins_cost(125); // XXX
 6053   format %{ &quot;movl    $mem, R12\t# compressed ptr (R12_heapbase==0)&quot; %}
 6054   ins_encode %{
 6055     __ movl($mem$$Address, r12);
 6056   %}
 6057   ins_pipe(ialu_mem_reg);
 6058 %}
 6059 
 6060 instruct storeImmN(memory mem, immN src)
 6061 %{
 6062   match(Set mem (StoreN mem src));
 6063 
 6064   ins_cost(150); // XXX
 6065   format %{ &quot;movl    $mem, $src\t# compressed ptr&quot; %}
 6066   ins_encode %{
 6067     address con = (address)$src$$constant;
 6068     if (con == NULL) {
 6069       __ movl($mem$$Address, (int32_t)0);
 6070     } else {
 6071       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
 6072     }
 6073   %}
 6074   ins_pipe(ialu_mem_imm);
 6075 %}
 6076 
 6077 instruct storeImmNKlass(memory mem, immNKlass src)
 6078 %{
 6079   match(Set mem (StoreNKlass mem src));
 6080 
 6081   ins_cost(150); // XXX
 6082   format %{ &quot;movl    $mem, $src\t# compressed klass ptr&quot; %}
 6083   ins_encode %{
 6084     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
 6085   %}
 6086   ins_pipe(ialu_mem_imm);
 6087 %}
 6088 
 6089 // Store Integer Immediate
 6090 instruct storeImmI0(memory mem, immI0 zero)
 6091 %{
 6092   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6093   match(Set mem (StoreI mem zero));
 6094 
 6095   ins_cost(125); // XXX
 6096   format %{ &quot;movl    $mem, R12\t# int (R12_heapbase==0)&quot; %}
 6097   ins_encode %{
 6098     __ movl($mem$$Address, r12);
 6099   %}
 6100   ins_pipe(ialu_mem_reg);
 6101 %}
 6102 
 6103 instruct storeImmI(memory mem, immI src)
 6104 %{
 6105   match(Set mem (StoreI mem src));
 6106 
 6107   ins_cost(150);
 6108   format %{ &quot;movl    $mem, $src\t# int&quot; %}
 6109   opcode(0xC7); /* C7 /0 */
 6110   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6111   ins_pipe(ialu_mem_imm);
 6112 %}
 6113 
 6114 // Store Long Immediate
 6115 instruct storeImmL0(memory mem, immL0 zero)
 6116 %{
 6117   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6118   match(Set mem (StoreL mem zero));
 6119 
 6120   ins_cost(125); // XXX
 6121   format %{ &quot;movq    $mem, R12\t# long (R12_heapbase==0)&quot; %}
 6122   ins_encode %{
 6123     __ movq($mem$$Address, r12);
 6124   %}
 6125   ins_pipe(ialu_mem_reg);
 6126 %}
 6127 
 6128 instruct storeImmL(memory mem, immL32 src)
 6129 %{
 6130   match(Set mem (StoreL mem src));
 6131 
 6132   ins_cost(150);
 6133   format %{ &quot;movq    $mem, $src\t# long&quot; %}
 6134   opcode(0xC7); /* C7 /0 */
 6135   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
 6136   ins_pipe(ialu_mem_imm);
 6137 %}
 6138 
 6139 // Store Short/Char Immediate
 6140 instruct storeImmC0(memory mem, immI0 zero)
 6141 %{
 6142   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6143   match(Set mem (StoreC mem zero));
 6144 
 6145   ins_cost(125); // XXX
 6146   format %{ &quot;movw    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6147   ins_encode %{
 6148     __ movw($mem$$Address, r12);
 6149   %}
 6150   ins_pipe(ialu_mem_reg);
 6151 %}
 6152 
 6153 instruct storeImmI16(memory mem, immI16 src)
 6154 %{
 6155   predicate(UseStoreImmI16);
 6156   match(Set mem (StoreC mem src));
 6157 
 6158   ins_cost(150);
 6159   format %{ &quot;movw    $mem, $src\t# short/char&quot; %}
 6160   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
 6161   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
 6162   ins_pipe(ialu_mem_imm);
 6163 %}
 6164 
 6165 // Store Byte Immediate
 6166 instruct storeImmB0(memory mem, immI0 zero)
 6167 %{
 6168   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6169   match(Set mem (StoreB mem zero));
 6170 
 6171   ins_cost(125); // XXX
 6172   format %{ &quot;movb    $mem, R12\t# short/char (R12_heapbase==0)&quot; %}
 6173   ins_encode %{
 6174     __ movb($mem$$Address, r12);
 6175   %}
 6176   ins_pipe(ialu_mem_reg);
 6177 %}
 6178 
 6179 instruct storeImmB(memory mem, immI8 src)
 6180 %{
 6181   match(Set mem (StoreB mem src));
 6182 
 6183   ins_cost(150); // XXX
 6184   format %{ &quot;movb    $mem, $src\t# byte&quot; %}
 6185   opcode(0xC6); /* C6 /0 */
 6186   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6187   ins_pipe(ialu_mem_imm);
 6188 %}
 6189 
 6190 // Store CMS card-mark Immediate
 6191 instruct storeImmCM0_reg(memory mem, immI0 zero)
 6192 %{
 6193   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6194   match(Set mem (StoreCM mem zero));
 6195 
 6196   ins_cost(125); // XXX
 6197   format %{ &quot;movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)&quot; %}
 6198   ins_encode %{
 6199     __ movb($mem$$Address, r12);
 6200   %}
 6201   ins_pipe(ialu_mem_reg);
 6202 %}
 6203 
 6204 instruct storeImmCM0(memory mem, immI0 src)
 6205 %{
 6206   match(Set mem (StoreCM mem src));
 6207 
 6208   ins_cost(150); // XXX
 6209   format %{ &quot;movb    $mem, $src\t# CMS card-mark byte 0&quot; %}
 6210   opcode(0xC6); /* C6 /0 */
 6211   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
 6212   ins_pipe(ialu_mem_imm);
 6213 %}
 6214 
 6215 // Store Float
 6216 instruct storeF(memory mem, regF src)
 6217 %{
 6218   match(Set mem (StoreF mem src));
 6219 
 6220   ins_cost(95); // XXX
 6221   format %{ &quot;movss   $mem, $src\t# float&quot; %}
 6222   ins_encode %{
 6223     __ movflt($mem$$Address, $src$$XMMRegister);
 6224   %}
 6225   ins_pipe(pipe_slow); // XXX
 6226 %}
 6227 
 6228 // Store immediate Float value (it is faster than store from XMM register)
 6229 instruct storeF0(memory mem, immF0 zero)
 6230 %{
 6231   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6232   match(Set mem (StoreF mem zero));
 6233 
 6234   ins_cost(25); // XXX
 6235   format %{ &quot;movl    $mem, R12\t# float 0. (R12_heapbase==0)&quot; %}
 6236   ins_encode %{
 6237     __ movl($mem$$Address, r12);
 6238   %}
 6239   ins_pipe(ialu_mem_reg);
 6240 %}
 6241 
 6242 instruct storeF_imm(memory mem, immF src)
 6243 %{
 6244   match(Set mem (StoreF mem src));
 6245 
 6246   ins_cost(50);
 6247   format %{ &quot;movl    $mem, $src\t# float&quot; %}
 6248   opcode(0xC7); /* C7 /0 */
 6249   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6250   ins_pipe(ialu_mem_imm);
 6251 %}
 6252 
 6253 // Store Double
 6254 instruct storeD(memory mem, regD src)
 6255 %{
 6256   match(Set mem (StoreD mem src));
 6257 
 6258   ins_cost(95); // XXX
 6259   format %{ &quot;movsd   $mem, $src\t# double&quot; %}
 6260   ins_encode %{
 6261     __ movdbl($mem$$Address, $src$$XMMRegister);
 6262   %}
 6263   ins_pipe(pipe_slow); // XXX
 6264 %}
 6265 
 6266 // Store immediate double 0.0 (it is faster than store from XMM register)
 6267 instruct storeD0_imm(memory mem, immD0 src)
 6268 %{
 6269   predicate(!UseCompressedOops || (CompressedOops::base() != NULL));
 6270   match(Set mem (StoreD mem src));
 6271 
 6272   ins_cost(50);
 6273   format %{ &quot;movq    $mem, $src\t# double 0.&quot; %}
 6274   opcode(0xC7); /* C7 /0 */
 6275   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
 6276   ins_pipe(ialu_mem_imm);
 6277 %}
 6278 
 6279 instruct storeD0(memory mem, immD0 zero)
 6280 %{
 6281   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp; (CompressedKlassPointers::base() == NULL));
 6282   match(Set mem (StoreD mem zero));
 6283 
 6284   ins_cost(25); // XXX
 6285   format %{ &quot;movq    $mem, R12\t# double 0. (R12_heapbase==0)&quot; %}
 6286   ins_encode %{
 6287     __ movq($mem$$Address, r12);
 6288   %}
 6289   ins_pipe(ialu_mem_reg);
 6290 %}
 6291 
 6292 instruct storeSSI(stackSlotI dst, rRegI src)
 6293 %{
 6294   match(Set dst src);
 6295 
 6296   ins_cost(100);
 6297   format %{ &quot;movl    $dst, $src\t# int stk&quot; %}
 6298   opcode(0x89);
 6299   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 6300   ins_pipe( ialu_mem_reg );
 6301 %}
 6302 
 6303 instruct storeSSL(stackSlotL dst, rRegL src)
 6304 %{
 6305   match(Set dst src);
 6306 
 6307   ins_cost(100);
 6308   format %{ &quot;movq    $dst, $src\t# long stk&quot; %}
 6309   opcode(0x89);
 6310   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6311   ins_pipe(ialu_mem_reg);
 6312 %}
 6313 
 6314 instruct storeSSP(stackSlotP dst, rRegP src)
 6315 %{
 6316   match(Set dst src);
 6317 
 6318   ins_cost(100);
 6319   format %{ &quot;movq    $dst, $src\t# ptr stk&quot; %}
 6320   opcode(0x89);
 6321   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 6322   ins_pipe(ialu_mem_reg);
 6323 %}
 6324 
 6325 instruct storeSSF(stackSlotF dst, regF src)
 6326 %{
 6327   match(Set dst src);
 6328 
 6329   ins_cost(95); // XXX
 6330   format %{ &quot;movss   $dst, $src\t# float stk&quot; %}
 6331   ins_encode %{
 6332     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6333   %}
 6334   ins_pipe(pipe_slow); // XXX
 6335 %}
 6336 
 6337 instruct storeSSD(stackSlotD dst, regD src)
 6338 %{
 6339   match(Set dst src);
 6340 
 6341   ins_cost(95); // XXX
 6342   format %{ &quot;movsd   $dst, $src\t# double stk&quot; %}
 6343   ins_encode %{
 6344     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
 6345   %}
 6346   ins_pipe(pipe_slow); // XXX
 6347 %}
 6348 
 6349 instruct cacheWB(indirect addr)
 6350 %{
 6351   predicate(VM_Version::supports_data_cache_line_flush());
 6352   match(CacheWB addr);
 6353 
 6354   ins_cost(100);
 6355   format %{&quot;cache wb $addr&quot; %}
 6356   ins_encode %{
 6357     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
 6358     assert($addr$$disp == 0, &quot;should be&quot;);
 6359     __ cache_wb(Address($addr$$base$$Register, 0));
 6360   %}
 6361   ins_pipe(pipe_slow); // XXX
 6362 %}
 6363 
 6364 instruct cacheWBPreSync()
 6365 %{
 6366   predicate(VM_Version::supports_data_cache_line_flush());
 6367   match(CacheWBPreSync);
 6368 
 6369   ins_cost(100);
 6370   format %{&quot;cache wb presync&quot; %}
 6371   ins_encode %{
 6372     __ cache_wbsync(true);
 6373   %}
 6374   ins_pipe(pipe_slow); // XXX
 6375 %}
 6376 
 6377 instruct cacheWBPostSync()
 6378 %{
 6379   predicate(VM_Version::supports_data_cache_line_flush());
 6380   match(CacheWBPostSync);
 6381 
 6382   ins_cost(100);
 6383   format %{&quot;cache wb postsync&quot; %}
 6384   ins_encode %{
 6385     __ cache_wbsync(false);
 6386   %}
 6387   ins_pipe(pipe_slow); // XXX
 6388 %}
 6389 
 6390 //----------BSWAP Instructions-------------------------------------------------
 6391 instruct bytes_reverse_int(rRegI dst) %{
 6392   match(Set dst (ReverseBytesI dst));
 6393 
 6394   format %{ &quot;bswapl  $dst&quot; %}
 6395   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
 6396   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
 6397   ins_pipe( ialu_reg );
 6398 %}
 6399 
 6400 instruct bytes_reverse_long(rRegL dst) %{
 6401   match(Set dst (ReverseBytesL dst));
 6402 
 6403   format %{ &quot;bswapq  $dst&quot; %}
 6404   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
 6405   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
 6406   ins_pipe( ialu_reg);
 6407 %}
 6408 
 6409 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
 6410   match(Set dst (ReverseBytesUS dst));
 6411   effect(KILL cr);
 6412 
 6413   format %{ &quot;bswapl  $dst\n\t&quot;
 6414             &quot;shrl    $dst,16\n\t&quot; %}
 6415   ins_encode %{
 6416     __ bswapl($dst$$Register);
 6417     __ shrl($dst$$Register, 16);
 6418   %}
 6419   ins_pipe( ialu_reg );
 6420 %}
 6421 
 6422 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
 6423   match(Set dst (ReverseBytesS dst));
 6424   effect(KILL cr);
 6425 
 6426   format %{ &quot;bswapl  $dst\n\t&quot;
 6427             &quot;sar     $dst,16\n\t&quot; %}
 6428   ins_encode %{
 6429     __ bswapl($dst$$Register);
 6430     __ sarl($dst$$Register, 16);
 6431   %}
 6432   ins_pipe( ialu_reg );
 6433 %}
 6434 
 6435 //---------- Zeros Count Instructions ------------------------------------------
 6436 
 6437 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6438   predicate(UseCountLeadingZerosInstruction);
 6439   match(Set dst (CountLeadingZerosI src));
 6440   effect(KILL cr);
 6441 
 6442   format %{ &quot;lzcntl  $dst, $src\t# count leading zeros (int)&quot; %}
 6443   ins_encode %{
 6444     __ lzcntl($dst$$Register, $src$$Register);
 6445   %}
 6446   ins_pipe(ialu_reg);
 6447 %}
 6448 
 6449 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
 6450   predicate(!UseCountLeadingZerosInstruction);
 6451   match(Set dst (CountLeadingZerosI src));
 6452   effect(KILL cr);
 6453 
 6454   format %{ &quot;bsrl    $dst, $src\t# count leading zeros (int)\n\t&quot;
 6455             &quot;jnz     skip\n\t&quot;
 6456             &quot;movl    $dst, -1\n&quot;
 6457       &quot;skip:\n\t&quot;
 6458             &quot;negl    $dst\n\t&quot;
 6459             &quot;addl    $dst, 31&quot; %}
 6460   ins_encode %{
 6461     Register Rdst = $dst$$Register;
 6462     Register Rsrc = $src$$Register;
 6463     Label skip;
 6464     __ bsrl(Rdst, Rsrc);
 6465     __ jccb(Assembler::notZero, skip);
 6466     __ movl(Rdst, -1);
 6467     __ bind(skip);
 6468     __ negl(Rdst);
 6469     __ addl(Rdst, BitsPerInt - 1);
 6470   %}
 6471   ins_pipe(ialu_reg);
 6472 %}
 6473 
 6474 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6475   predicate(UseCountLeadingZerosInstruction);
 6476   match(Set dst (CountLeadingZerosL src));
 6477   effect(KILL cr);
 6478 
 6479   format %{ &quot;lzcntq  $dst, $src\t# count leading zeros (long)&quot; %}
 6480   ins_encode %{
 6481     __ lzcntq($dst$$Register, $src$$Register);
 6482   %}
 6483   ins_pipe(ialu_reg);
 6484 %}
 6485 
 6486 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
 6487   predicate(!UseCountLeadingZerosInstruction);
 6488   match(Set dst (CountLeadingZerosL src));
 6489   effect(KILL cr);
 6490 
 6491   format %{ &quot;bsrq    $dst, $src\t# count leading zeros (long)\n\t&quot;
 6492             &quot;jnz     skip\n\t&quot;
 6493             &quot;movl    $dst, -1\n&quot;
 6494       &quot;skip:\n\t&quot;
 6495             &quot;negl    $dst\n\t&quot;
 6496             &quot;addl    $dst, 63&quot; %}
 6497   ins_encode %{
 6498     Register Rdst = $dst$$Register;
 6499     Register Rsrc = $src$$Register;
 6500     Label skip;
 6501     __ bsrq(Rdst, Rsrc);
 6502     __ jccb(Assembler::notZero, skip);
 6503     __ movl(Rdst, -1);
 6504     __ bind(skip);
 6505     __ negl(Rdst);
 6506     __ addl(Rdst, BitsPerLong - 1);
 6507   %}
 6508   ins_pipe(ialu_reg);
 6509 %}
 6510 
 6511 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6512   predicate(UseCountTrailingZerosInstruction);
 6513   match(Set dst (CountTrailingZerosI src));
 6514   effect(KILL cr);
 6515 
 6516   format %{ &quot;tzcntl    $dst, $src\t# count trailing zeros (int)&quot; %}
 6517   ins_encode %{
 6518     __ tzcntl($dst$$Register, $src$$Register);
 6519   %}
 6520   ins_pipe(ialu_reg);
 6521 %}
 6522 
 6523 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
 6524   predicate(!UseCountTrailingZerosInstruction);
 6525   match(Set dst (CountTrailingZerosI src));
 6526   effect(KILL cr);
 6527 
 6528   format %{ &quot;bsfl    $dst, $src\t# count trailing zeros (int)\n\t&quot;
 6529             &quot;jnz     done\n\t&quot;
 6530             &quot;movl    $dst, 32\n&quot;
 6531       &quot;done:&quot; %}
 6532   ins_encode %{
 6533     Register Rdst = $dst$$Register;
 6534     Label done;
 6535     __ bsfl(Rdst, $src$$Register);
 6536     __ jccb(Assembler::notZero, done);
 6537     __ movl(Rdst, BitsPerInt);
 6538     __ bind(done);
 6539   %}
 6540   ins_pipe(ialu_reg);
 6541 %}
 6542 
 6543 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6544   predicate(UseCountTrailingZerosInstruction);
 6545   match(Set dst (CountTrailingZerosL src));
 6546   effect(KILL cr);
 6547 
 6548   format %{ &quot;tzcntq    $dst, $src\t# count trailing zeros (long)&quot; %}
 6549   ins_encode %{
 6550     __ tzcntq($dst$$Register, $src$$Register);
 6551   %}
 6552   ins_pipe(ialu_reg);
 6553 %}
 6554 
 6555 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
 6556   predicate(!UseCountTrailingZerosInstruction);
 6557   match(Set dst (CountTrailingZerosL src));
 6558   effect(KILL cr);
 6559 
 6560   format %{ &quot;bsfq    $dst, $src\t# count trailing zeros (long)\n\t&quot;
 6561             &quot;jnz     done\n\t&quot;
 6562             &quot;movl    $dst, 64\n&quot;
 6563       &quot;done:&quot; %}
 6564   ins_encode %{
 6565     Register Rdst = $dst$$Register;
 6566     Label done;
 6567     __ bsfq(Rdst, $src$$Register);
 6568     __ jccb(Assembler::notZero, done);
 6569     __ movl(Rdst, BitsPerLong);
 6570     __ bind(done);
 6571   %}
 6572   ins_pipe(ialu_reg);
 6573 %}
 6574 
 6575 
 6576 //---------- Population Count Instructions -------------------------------------
 6577 
 6578 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
 6579   predicate(UsePopCountInstruction);
 6580   match(Set dst (PopCountI src));
 6581   effect(KILL cr);
 6582 
 6583   format %{ &quot;popcnt  $dst, $src&quot; %}
 6584   ins_encode %{
 6585     __ popcntl($dst$$Register, $src$$Register);
 6586   %}
 6587   ins_pipe(ialu_reg);
 6588 %}
 6589 
 6590 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6591   predicate(UsePopCountInstruction);
 6592   match(Set dst (PopCountI (LoadI mem)));
 6593   effect(KILL cr);
 6594 
 6595   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6596   ins_encode %{
 6597     __ popcntl($dst$$Register, $mem$$Address);
 6598   %}
 6599   ins_pipe(ialu_reg);
 6600 %}
 6601 
 6602 // Note: Long.bitCount(long) returns an int.
 6603 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
 6604   predicate(UsePopCountInstruction);
 6605   match(Set dst (PopCountL src));
 6606   effect(KILL cr);
 6607 
 6608   format %{ &quot;popcnt  $dst, $src&quot; %}
 6609   ins_encode %{
 6610     __ popcntq($dst$$Register, $src$$Register);
 6611   %}
 6612   ins_pipe(ialu_reg);
 6613 %}
 6614 
 6615 // Note: Long.bitCount(long) returns an int.
 6616 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
 6617   predicate(UsePopCountInstruction);
 6618   match(Set dst (PopCountL (LoadL mem)));
 6619   effect(KILL cr);
 6620 
 6621   format %{ &quot;popcnt  $dst, $mem&quot; %}
 6622   ins_encode %{
 6623     __ popcntq($dst$$Register, $mem$$Address);
 6624   %}
 6625   ins_pipe(ialu_reg);
 6626 %}
 6627 
 6628 
 6629 //----------MemBar Instructions-----------------------------------------------
 6630 // Memory barrier flavors
 6631 
 6632 instruct membar_acquire()
 6633 %{
 6634   match(MemBarAcquire);
 6635   match(LoadFence);
 6636   ins_cost(0);
 6637 
 6638   size(0);
 6639   format %{ &quot;MEMBAR-acquire ! (empty encoding)&quot; %}
 6640   ins_encode();
 6641   ins_pipe(empty);
 6642 %}
 6643 
 6644 instruct membar_acquire_lock()
 6645 %{
 6646   match(MemBarAcquireLock);
 6647   ins_cost(0);
 6648 
 6649   size(0);
 6650   format %{ &quot;MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)&quot; %}
 6651   ins_encode();
 6652   ins_pipe(empty);
 6653 %}
 6654 
 6655 instruct membar_release()
 6656 %{
 6657   match(MemBarRelease);
 6658   match(StoreFence);
 6659   ins_cost(0);
 6660 
 6661   size(0);
 6662   format %{ &quot;MEMBAR-release ! (empty encoding)&quot; %}
 6663   ins_encode();
 6664   ins_pipe(empty);
 6665 %}
 6666 
 6667 instruct membar_release_lock()
 6668 %{
 6669   match(MemBarReleaseLock);
 6670   ins_cost(0);
 6671 
 6672   size(0);
 6673   format %{ &quot;MEMBAR-release (a FastUnlock follows so empty encoding)&quot; %}
 6674   ins_encode();
 6675   ins_pipe(empty);
 6676 %}
 6677 
 6678 instruct membar_volatile(rFlagsReg cr) %{
 6679   match(MemBarVolatile);
 6680   effect(KILL cr);
 6681   ins_cost(400);
 6682 
 6683   format %{
 6684     $$template
 6685     $$emit$$&quot;lock addl [rsp + #0], 0\t! membar_volatile&quot;
 6686   %}
 6687   ins_encode %{
 6688     __ membar(Assembler::StoreLoad);
 6689   %}
 6690   ins_pipe(pipe_slow);
 6691 %}
 6692 
 6693 instruct unnecessary_membar_volatile()
 6694 %{
 6695   match(MemBarVolatile);
 6696   predicate(Matcher::post_store_load_barrier(n));
 6697   ins_cost(0);
 6698 
 6699   size(0);
 6700   format %{ &quot;MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 6701   ins_encode();
 6702   ins_pipe(empty);
 6703 %}
 6704 
 6705 instruct membar_storestore() %{
 6706   match(MemBarStoreStore);
 6707   ins_cost(0);
 6708 
 6709   size(0);
 6710   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6711   ins_encode( );
 6712   ins_pipe(empty);
 6713 %}
 6714 
 6715 //----------Move Instructions--------------------------------------------------
 6716 
 6717 instruct castX2P(rRegP dst, rRegL src)
 6718 %{
 6719   match(Set dst (CastX2P src));
 6720 
 6721   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6722   ins_encode %{
 6723     if ($dst$$reg != $src$$reg) {
 6724       __ movptr($dst$$Register, $src$$Register);
 6725     }
 6726   %}
 6727   ins_pipe(ialu_reg_reg); // XXX
 6728 %}
 6729 
 6730 instruct castN2X(rRegL dst, rRegN src)
 6731 %{
 6732   match(Set dst (CastP2X src));
 6733 
 6734   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6735   ins_encode %{
 6736     if ($dst$$reg != $src$$reg) {
 6737       __ movptr($dst$$Register, $src$$Register);
 6738     }
 6739   %}
 6740   ins_pipe(ialu_reg_reg); // XXX
 6741 %}
 6742 
 6743 instruct castP2X(rRegL dst, rRegP src)
 6744 %{
 6745   match(Set dst (CastP2X src));
 6746 
 6747   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6748   ins_encode %{
 6749     if ($dst$$reg != $src$$reg) {
 6750       __ movptr($dst$$Register, $src$$Register);
 6751     }
 6752   %}
 6753   ins_pipe(ialu_reg_reg); // XXX
 6754 %}
 6755 
 6756 instruct castN2I(rRegI dst, rRegN src)
 6757 %{
 6758   match(Set dst (CastN2I src));
 6759 
 6760   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6761   ins_encode %{
 6762     if ($dst$$reg != $src$$reg) {
 6763       __ movl($dst$$Register, $src$$Register);
 6764     }
 6765   %}
 6766   ins_pipe(ialu_reg_reg); // XXX
 6767 %}
 6768 
 6769 instruct castI2N(rRegN dst, rRegI src)
 6770 %{
 6771   match(Set dst (CastI2N src));
 6772 
 6773   format %{ &quot;movl    $dst, $src\t# int -&gt; compressed ptr&quot; %}
 6774   ins_encode %{
 6775     if ($dst$$reg != $src$$reg) {
 6776       __ movl($dst$$Register, $src$$Register);
 6777     }
 6778   %}
 6779   ins_pipe(ialu_reg_reg); // XXX
 6780 %}
 6781 
 6782 
 6783 // Convert oop into int for vectors alignment masking
 6784 instruct convP2I(rRegI dst, rRegP src)
 6785 %{
 6786   match(Set dst (ConvL2I (CastP2X src)));
 6787 
 6788   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6789   ins_encode %{
 6790     __ movl($dst$$Register, $src$$Register);
 6791   %}
 6792   ins_pipe(ialu_reg_reg); // XXX
 6793 %}
 6794 
 6795 // Convert compressed oop into int for vectors alignment masking
 6796 // in case of 32bit oops (heap &lt; 4Gb).
 6797 instruct convN2I(rRegI dst, rRegN src)
 6798 %{
 6799   predicate(CompressedOops::shift() == 0);
 6800   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6801 
 6802   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
 6803   ins_encode %{
 6804     __ movl($dst$$Register, $src$$Register);
 6805   %}
 6806   ins_pipe(ialu_reg_reg); // XXX
 6807 %}
 6808 
 6809 // Convert oop pointer into compressed form
 6810 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
 6811   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
 6812   match(Set dst (EncodeP src));
 6813   effect(KILL cr);
 6814   format %{ &quot;encode_heap_oop $dst,$src&quot; %}
 6815   ins_encode %{
 6816     Register s = $src$$Register;
 6817     Register d = $dst$$Register;
 6818     if (s != d) {
 6819       __ movq(d, s);
 6820     }
 6821     __ encode_heap_oop(d);
 6822   %}
 6823   ins_pipe(ialu_reg_long);
 6824 %}
 6825 
 6826 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6827   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
 6828   match(Set dst (EncodeP src));
 6829   effect(KILL cr);
 6830   format %{ &quot;encode_heap_oop_not_null $dst,$src&quot; %}
 6831   ins_encode %{
 6832     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
 6833   %}
 6834   ins_pipe(ialu_reg_long);
 6835 %}
 6836 
 6837 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
 6838   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 6839             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
 6840   match(Set dst (DecodeN src));
 6841   effect(KILL cr);
 6842   format %{ &quot;decode_heap_oop $dst,$src&quot; %}
 6843   ins_encode %{
 6844     Register s = $src$$Register;
 6845     Register d = $dst$$Register;
 6846     if (s != d) {
 6847       __ movq(d, s);
 6848     }
 6849     __ decode_heap_oop(d);
 6850   %}
 6851   ins_pipe(ialu_reg_long);
 6852 %}
 6853 
 6854 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6855   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
 6856             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
 6857   match(Set dst (DecodeN src));
 6858   effect(KILL cr);
 6859   format %{ &quot;decode_heap_oop_not_null $dst,$src&quot; %}
 6860   ins_encode %{
 6861     Register s = $src$$Register;
 6862     Register d = $dst$$Register;
 6863     if (s != d) {
 6864       __ decode_heap_oop_not_null(d, s);
 6865     } else {
 6866       __ decode_heap_oop_not_null(d);
 6867     }
 6868   %}
 6869   ins_pipe(ialu_reg_long);
 6870 %}
 6871 
 6872 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
 6873   match(Set dst (EncodePKlass src));
 6874   effect(KILL cr);
 6875   format %{ &quot;encode_klass_not_null $dst,$src&quot; %}
 6876   ins_encode %{
 6877     __ encode_klass_not_null($dst$$Register, $src$$Register);
 6878   %}
 6879   ins_pipe(ialu_reg_long);
 6880 %}
 6881 
 6882 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
 6883   match(Set dst (DecodeNKlass src));
 6884   effect(KILL cr);
 6885   format %{ &quot;decode_klass_not_null $dst,$src&quot; %}
 6886   ins_encode %{
 6887     Register s = $src$$Register;
 6888     Register d = $dst$$Register;
 6889     if (s != d) {
 6890       __ decode_klass_not_null(d, s);
 6891     } else {
 6892       __ decode_klass_not_null(d);
 6893     }
 6894   %}
 6895   ins_pipe(ialu_reg_long);
 6896 %}
 6897 
 6898 
 6899 //----------Conditional Move---------------------------------------------------
 6900 // Jump
 6901 // dummy instruction for generating temp registers
 6902 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
 6903   match(Jump (LShiftL switch_val shift));
 6904   ins_cost(350);
 6905   predicate(false);
 6906   effect(TEMP dest);
 6907 
 6908   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6909             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t&quot; %}
 6910   ins_encode %{
 6911     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6912     // to do that and the compiler is using that register as one it can allocate.
 6913     // So we build it all by hand.
 6914     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
 6915     // ArrayAddress dispatch(table, index);
 6916     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
 6917     __ lea($dest$$Register, $constantaddress);
 6918     __ jmp(dispatch);
 6919   %}
 6920   ins_pipe(pipe_jmp);
 6921 %}
 6922 
 6923 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
 6924   match(Jump (AddL (LShiftL switch_val shift) offset));
 6925   ins_cost(350);
 6926   effect(TEMP dest);
 6927 
 6928   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6929             &quot;jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t&quot; %}
 6930   ins_encode %{
 6931     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6932     // to do that and the compiler is using that register as one it can allocate.
 6933     // So we build it all by hand.
 6934     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6935     // ArrayAddress dispatch(table, index);
 6936     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
 6937     __ lea($dest$$Register, $constantaddress);
 6938     __ jmp(dispatch);
 6939   %}
 6940   ins_pipe(pipe_jmp);
 6941 %}
 6942 
 6943 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
 6944   match(Jump switch_val);
 6945   ins_cost(350);
 6946   effect(TEMP dest);
 6947 
 6948   format %{ &quot;leaq    $dest, [$constantaddress]\n\t&quot;
 6949             &quot;jmp     [$dest + $switch_val]\n\t&quot; %}
 6950   ins_encode %{
 6951     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
 6952     // to do that and the compiler is using that register as one it can allocate.
 6953     // So we build it all by hand.
 6954     // Address index(noreg, switch_reg, Address::times_1);
 6955     // ArrayAddress dispatch(table, index);
 6956     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
 6957     __ lea($dest$$Register, $constantaddress);
 6958     __ jmp(dispatch);
 6959   %}
 6960   ins_pipe(pipe_jmp);
 6961 %}
 6962 
 6963 // Conditional move
 6964 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
 6965 %{
 6966   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6967 
 6968   ins_cost(200); // XXX
 6969   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6970   opcode(0x0F, 0x40);
 6971   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6972   ins_pipe(pipe_cmov_reg);
 6973 %}
 6974 
 6975 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
 6976   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6977 
 6978   ins_cost(200); // XXX
 6979   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 6980   opcode(0x0F, 0x40);
 6981   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 6982   ins_pipe(pipe_cmov_reg);
 6983 %}
 6984 
 6985 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
 6986   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
 6987   ins_cost(200);
 6988   expand %{
 6989     cmovI_regU(cop, cr, dst, src);
 6990   %}
 6991 %}
 6992 
 6993 // Conditional move
 6994 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
 6995   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 6996 
 6997   ins_cost(250); // XXX
 6998   format %{ &quot;cmovl$cop $dst, $src\t# signed, int&quot; %}
 6999   opcode(0x0F, 0x40);
 7000   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7001   ins_pipe(pipe_cmov_mem);
 7002 %}
 7003 
 7004 // Conditional move
 7005 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
 7006 %{
 7007   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 7008 
 7009   ins_cost(250); // XXX
 7010   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, int&quot; %}
 7011   opcode(0x0F, 0x40);
 7012   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7013   ins_pipe(pipe_cmov_mem);
 7014 %}
 7015 
 7016 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
 7017   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
 7018   ins_cost(250);
 7019   expand %{
 7020     cmovI_memU(cop, cr, dst, src);
 7021   %}
 7022 %}
 7023 
 7024 // Conditional move
 7025 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
 7026 %{
 7027   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7028 
 7029   ins_cost(200); // XXX
 7030   format %{ &quot;cmovl$cop $dst, $src\t# signed, compressed ptr&quot; %}
 7031   opcode(0x0F, 0x40);
 7032   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7033   ins_pipe(pipe_cmov_reg);
 7034 %}
 7035 
 7036 // Conditional move
 7037 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
 7038 %{
 7039   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7040 
 7041   ins_cost(200); // XXX
 7042   format %{ &quot;cmovl$cop $dst, $src\t# unsigned, compressed ptr&quot; %}
 7043   opcode(0x0F, 0x40);
 7044   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7045   ins_pipe(pipe_cmov_reg);
 7046 %}
 7047 
 7048 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
 7049   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
 7050   ins_cost(200);
 7051   expand %{
 7052     cmovN_regU(cop, cr, dst, src);
 7053   %}
 7054 %}
 7055 
 7056 // Conditional move
 7057 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
 7058 %{
 7059   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7060 
 7061   ins_cost(200); // XXX
 7062   format %{ &quot;cmovq$cop $dst, $src\t# signed, ptr&quot; %}
 7063   opcode(0x0F, 0x40);
 7064   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7065   ins_pipe(pipe_cmov_reg);  // XXX
 7066 %}
 7067 
 7068 // Conditional move
 7069 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
 7070 %{
 7071   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7072 
 7073   ins_cost(200); // XXX
 7074   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, ptr&quot; %}
 7075   opcode(0x0F, 0x40);
 7076   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7077   ins_pipe(pipe_cmov_reg); // XXX
 7078 %}
 7079 
 7080 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
 7081   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
 7082   ins_cost(200);
 7083   expand %{
 7084     cmovP_regU(cop, cr, dst, src);
 7085   %}
 7086 %}
 7087 
 7088 // DISABLED: Requires the ADLC to emit a bottom_type call that
 7089 // correctly meets the two pointer arguments; one is an incoming
 7090 // register but the other is a memory operand.  ALSO appears to
 7091 // be buggy with implicit null checks.
 7092 //
 7093 //// Conditional move
 7094 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
 7095 //%{
 7096 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7097 //  ins_cost(250);
 7098 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7099 //  opcode(0x0F,0x40);
 7100 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7101 //  ins_pipe( pipe_cmov_mem );
 7102 //%}
 7103 //
 7104 //// Conditional move
 7105 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
 7106 //%{
 7107 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
 7108 //  ins_cost(250);
 7109 //  format %{ &quot;CMOV$cop $dst,$src\t# ptr&quot; %}
 7110 //  opcode(0x0F,0x40);
 7111 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
 7112 //  ins_pipe( pipe_cmov_mem );
 7113 //%}
 7114 
 7115 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
 7116 %{
 7117   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7118 
 7119   ins_cost(200); // XXX
 7120   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7121   opcode(0x0F, 0x40);
 7122   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7123   ins_pipe(pipe_cmov_reg);  // XXX
 7124 %}
 7125 
 7126 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
 7127 %{
 7128   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7129 
 7130   ins_cost(200); // XXX
 7131   format %{ &quot;cmovq$cop $dst, $src\t# signed, long&quot; %}
 7132   opcode(0x0F, 0x40);
 7133   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7134   ins_pipe(pipe_cmov_mem);  // XXX
 7135 %}
 7136 
 7137 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
 7138 %{
 7139   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7140 
 7141   ins_cost(200); // XXX
 7142   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7143   opcode(0x0F, 0x40);
 7144   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
 7145   ins_pipe(pipe_cmov_reg); // XXX
 7146 %}
 7147 
 7148 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
 7149   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
 7150   ins_cost(200);
 7151   expand %{
 7152     cmovL_regU(cop, cr, dst, src);
 7153   %}
 7154 %}
 7155 
 7156 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
 7157 %{
 7158   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7159 
 7160   ins_cost(200); // XXX
 7161   format %{ &quot;cmovq$cop $dst, $src\t# unsigned, long&quot; %}
 7162   opcode(0x0F, 0x40);
 7163   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
 7164   ins_pipe(pipe_cmov_mem); // XXX
 7165 %}
 7166 
 7167 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
 7168   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
 7169   ins_cost(200);
 7170   expand %{
 7171     cmovL_memU(cop, cr, dst, src);
 7172   %}
 7173 %}
 7174 
 7175 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
 7176 %{
 7177   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7178 
 7179   ins_cost(200); // XXX
 7180   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7181             &quot;movss     $dst, $src\n&quot;
 7182     &quot;skip:&quot; %}
 7183   ins_encode %{
 7184     Label Lskip;
 7185     // Invert sense of branch from sense of CMOV
 7186     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7187     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7188     __ bind(Lskip);
 7189   %}
 7190   ins_pipe(pipe_slow);
 7191 %}
 7192 
 7193 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
 7194 // %{
 7195 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
 7196 
 7197 //   ins_cost(200); // XXX
 7198 //   format %{ &quot;jn$cop    skip\t# signed cmove float\n\t&quot;
 7199 //             &quot;movss     $dst, $src\n&quot;
 7200 //     &quot;skip:&quot; %}
 7201 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
 7202 //   ins_pipe(pipe_slow);
 7203 // %}
 7204 
 7205 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
 7206 %{
 7207   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7208 
 7209   ins_cost(200); // XXX
 7210   format %{ &quot;jn$cop    skip\t# unsigned cmove float\n\t&quot;
 7211             &quot;movss     $dst, $src\n&quot;
 7212     &quot;skip:&quot; %}
 7213   ins_encode %{
 7214     Label Lskip;
 7215     // Invert sense of branch from sense of CMOV
 7216     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7217     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
 7218     __ bind(Lskip);
 7219   %}
 7220   ins_pipe(pipe_slow);
 7221 %}
 7222 
 7223 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
 7224   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
 7225   ins_cost(200);
 7226   expand %{
 7227     cmovF_regU(cop, cr, dst, src);
 7228   %}
 7229 %}
 7230 
 7231 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
 7232 %{
 7233   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7234 
 7235   ins_cost(200); // XXX
 7236   format %{ &quot;jn$cop    skip\t# signed cmove double\n\t&quot;
 7237             &quot;movsd     $dst, $src\n&quot;
 7238     &quot;skip:&quot; %}
 7239   ins_encode %{
 7240     Label Lskip;
 7241     // Invert sense of branch from sense of CMOV
 7242     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7243     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7244     __ bind(Lskip);
 7245   %}
 7246   ins_pipe(pipe_slow);
 7247 %}
 7248 
 7249 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
 7250 %{
 7251   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7252 
 7253   ins_cost(200); // XXX
 7254   format %{ &quot;jn$cop    skip\t# unsigned cmove double\n\t&quot;
 7255             &quot;movsd     $dst, $src\n&quot;
 7256     &quot;skip:&quot; %}
 7257   ins_encode %{
 7258     Label Lskip;
 7259     // Invert sense of branch from sense of CMOV
 7260     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
 7261     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
 7262     __ bind(Lskip);
 7263   %}
 7264   ins_pipe(pipe_slow);
 7265 %}
 7266 
 7267 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
 7268   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
 7269   ins_cost(200);
 7270   expand %{
 7271     cmovD_regU(cop, cr, dst, src);
 7272   %}
 7273 %}
 7274 
 7275 //----------Arithmetic Instructions--------------------------------------------
 7276 //----------Addition Instructions----------------------------------------------
 7277 
 7278 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 7279 %{
 7280   match(Set dst (AddI dst src));
 7281   effect(KILL cr);
 7282 
 7283   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7284   opcode(0x03);
 7285   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 7286   ins_pipe(ialu_reg_reg);
 7287 %}
 7288 
 7289 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 7290 %{
 7291   match(Set dst (AddI dst src));
 7292   effect(KILL cr);
 7293 
 7294   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7295   opcode(0x81, 0x00); /* /0 id */
 7296   ins_encode(OpcSErm(dst, src), Con8or32(src));
 7297   ins_pipe( ialu_reg );
 7298 %}
 7299 
 7300 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 7301 %{
 7302   match(Set dst (AddI dst (LoadI src)));
 7303   effect(KILL cr);
 7304 
 7305   ins_cost(125); // XXX
 7306   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7307   opcode(0x03);
 7308   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 7309   ins_pipe(ialu_reg_mem);
 7310 %}
 7311 
 7312 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 7313 %{
 7314   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7315   effect(KILL cr);
 7316 
 7317   ins_cost(150); // XXX
 7318   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7319   opcode(0x01); /* Opcode 01 /r */
 7320   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 7321   ins_pipe(ialu_mem_reg);
 7322 %}
 7323 
 7324 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
 7325 %{
 7326   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7327   effect(KILL cr);
 7328 
 7329   ins_cost(125); // XXX
 7330   format %{ &quot;addl    $dst, $src\t# int&quot; %}
 7331   opcode(0x81); /* Opcode 81 /0 id */
 7332   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7333   ins_pipe(ialu_mem_imm);
 7334 %}
 7335 
 7336 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
 7337 %{
 7338   predicate(UseIncDec);
 7339   match(Set dst (AddI dst src));
 7340   effect(KILL cr);
 7341 
 7342   format %{ &quot;incl    $dst\t# int&quot; %}
 7343   opcode(0xFF, 0x00); // FF /0
 7344   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7345   ins_pipe(ialu_reg);
 7346 %}
 7347 
 7348 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
 7349 %{
 7350   predicate(UseIncDec);
 7351   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7352   effect(KILL cr);
 7353 
 7354   ins_cost(125); // XXX
 7355   format %{ &quot;incl    $dst\t# int&quot; %}
 7356   opcode(0xFF); /* Opcode FF /0 */
 7357   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
 7358   ins_pipe(ialu_mem_imm);
 7359 %}
 7360 
 7361 // XXX why does that use AddI
 7362 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
 7363 %{
 7364   predicate(UseIncDec);
 7365   match(Set dst (AddI dst src));
 7366   effect(KILL cr);
 7367 
 7368   format %{ &quot;decl    $dst\t# int&quot; %}
 7369   opcode(0xFF, 0x01); // FF /1
 7370   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 7371   ins_pipe(ialu_reg);
 7372 %}
 7373 
 7374 // XXX why does that use AddI
 7375 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
 7376 %{
 7377   predicate(UseIncDec);
 7378   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
 7379   effect(KILL cr);
 7380 
 7381   ins_cost(125); // XXX
 7382   format %{ &quot;decl    $dst\t# int&quot; %}
 7383   opcode(0xFF); /* Opcode FF /1 */
 7384   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
 7385   ins_pipe(ialu_mem_imm);
 7386 %}
 7387 
 7388 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
 7389 %{
 7390   match(Set dst (AddI src0 src1));
 7391 
 7392   ins_cost(110);
 7393   format %{ &quot;addr32 leal $dst, [$src0 + $src1]\t# int&quot; %}
 7394   opcode(0x8D); /* 0x8D /r */
 7395   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7396   ins_pipe(ialu_reg_reg);
 7397 %}
 7398 
 7399 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 7400 %{
 7401   match(Set dst (AddL dst src));
 7402   effect(KILL cr);
 7403 
 7404   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7405   opcode(0x03);
 7406   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7407   ins_pipe(ialu_reg_reg);
 7408 %}
 7409 
 7410 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 7411 %{
 7412   match(Set dst (AddL dst src));
 7413   effect(KILL cr);
 7414 
 7415   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7416   opcode(0x81, 0x00); /* /0 id */
 7417   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7418   ins_pipe( ialu_reg );
 7419 %}
 7420 
 7421 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 7422 %{
 7423   match(Set dst (AddL dst (LoadL src)));
 7424   effect(KILL cr);
 7425 
 7426   ins_cost(125); // XXX
 7427   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7428   opcode(0x03);
 7429   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 7430   ins_pipe(ialu_reg_mem);
 7431 %}
 7432 
 7433 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 7434 %{
 7435   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7436   effect(KILL cr);
 7437 
 7438   ins_cost(150); // XXX
 7439   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7440   opcode(0x01); /* Opcode 01 /r */
 7441   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 7442   ins_pipe(ialu_mem_reg);
 7443 %}
 7444 
 7445 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 7446 %{
 7447   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7448   effect(KILL cr);
 7449 
 7450   ins_cost(125); // XXX
 7451   format %{ &quot;addq    $dst, $src\t# long&quot; %}
 7452   opcode(0x81); /* Opcode 81 /0 id */
 7453   ins_encode(REX_mem_wide(dst),
 7454              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
 7455   ins_pipe(ialu_mem_imm);
 7456 %}
 7457 
 7458 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
 7459 %{
 7460   predicate(UseIncDec);
 7461   match(Set dst (AddL dst src));
 7462   effect(KILL cr);
 7463 
 7464   format %{ &quot;incq    $dst\t# long&quot; %}
 7465   opcode(0xFF, 0x00); // FF /0
 7466   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7467   ins_pipe(ialu_reg);
 7468 %}
 7469 
 7470 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
 7471 %{
 7472   predicate(UseIncDec);
 7473   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7474   effect(KILL cr);
 7475 
 7476   ins_cost(125); // XXX
 7477   format %{ &quot;incq    $dst\t# long&quot; %}
 7478   opcode(0xFF); /* Opcode FF /0 */
 7479   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
 7480   ins_pipe(ialu_mem_imm);
 7481 %}
 7482 
 7483 // XXX why does that use AddL
 7484 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
 7485 %{
 7486   predicate(UseIncDec);
 7487   match(Set dst (AddL dst src));
 7488   effect(KILL cr);
 7489 
 7490   format %{ &quot;decq    $dst\t# long&quot; %}
 7491   opcode(0xFF, 0x01); // FF /1
 7492   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 7493   ins_pipe(ialu_reg);
 7494 %}
 7495 
 7496 // XXX why does that use AddL
 7497 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
 7498 %{
 7499   predicate(UseIncDec);
 7500   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
 7501   effect(KILL cr);
 7502 
 7503   ins_cost(125); // XXX
 7504   format %{ &quot;decq    $dst\t# long&quot; %}
 7505   opcode(0xFF); /* Opcode FF /1 */
 7506   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
 7507   ins_pipe(ialu_mem_imm);
 7508 %}
 7509 
 7510 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
 7511 %{
 7512   match(Set dst (AddL src0 src1));
 7513 
 7514   ins_cost(110);
 7515   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# long&quot; %}
 7516   opcode(0x8D); /* 0x8D /r */
 7517   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
 7518   ins_pipe(ialu_reg_reg);
 7519 %}
 7520 
 7521 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
 7522 %{
 7523   match(Set dst (AddP dst src));
 7524   effect(KILL cr);
 7525 
 7526   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7527   opcode(0x03);
 7528   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 7529   ins_pipe(ialu_reg_reg);
 7530 %}
 7531 
 7532 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
 7533 %{
 7534   match(Set dst (AddP dst src));
 7535   effect(KILL cr);
 7536 
 7537   format %{ &quot;addq    $dst, $src\t# ptr&quot; %}
 7538   opcode(0x81, 0x00); /* /0 id */
 7539   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 7540   ins_pipe( ialu_reg );
 7541 %}
 7542 
 7543 // XXX addP mem ops ????
 7544 
 7545 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
 7546 %{
 7547   match(Set dst (AddP src0 src1));
 7548 
 7549   ins_cost(110);
 7550   format %{ &quot;leaq    $dst, [$src0 + $src1]\t# ptr&quot; %}
 7551   opcode(0x8D); /* 0x8D /r */
 7552   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
 7553   ins_pipe(ialu_reg_reg);
 7554 %}
 7555 
 7556 instruct checkCastPP(rRegP dst)
 7557 %{
 7558   match(Set dst (CheckCastPP dst));
 7559 
 7560   size(0);
 7561   format %{ &quot;# checkcastPP of $dst&quot; %}
 7562   ins_encode(/* empty encoding */);
 7563   ins_pipe(empty);
 7564 %}
 7565 
 7566 instruct castPP(rRegP dst)
 7567 %{
 7568   match(Set dst (CastPP dst));
 7569 
 7570   size(0);
 7571   format %{ &quot;# castPP of $dst&quot; %}
 7572   ins_encode(/* empty encoding */);
 7573   ins_pipe(empty);
 7574 %}
 7575 
 7576 instruct castII(rRegI dst)
 7577 %{
 7578   match(Set dst (CastII dst));
 7579 
 7580   size(0);
 7581   format %{ &quot;# castII of $dst&quot; %}
 7582   ins_encode(/* empty encoding */);
 7583   ins_cost(0);
 7584   ins_pipe(empty);
 7585 %}
 7586 
 7587 instruct castLL(rRegL dst)
 7588 %{
 7589   match(Set dst (CastLL dst));
 7590 
 7591   size(0);
 7592   format %{ &quot;# castLL of $dst&quot; %}
 7593   ins_encode(/* empty encoding */);
 7594   ins_cost(0);
 7595   ins_pipe(empty);
 7596 %}
 7597 
 7598 // LoadP-locked same as a regular LoadP when used with compare-swap
 7599 instruct loadPLocked(rRegP dst, memory mem)
 7600 %{
 7601   match(Set dst (LoadPLocked mem));
 7602 
 7603   ins_cost(125); // XXX
 7604   format %{ &quot;movq    $dst, $mem\t# ptr locked&quot; %}
 7605   opcode(0x8B);
 7606   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
 7607   ins_pipe(ialu_reg_mem); // XXX
 7608 %}
 7609 
 7610 // Conditional-store of the updated heap-top.
 7611 // Used during allocation of the shared heap.
 7612 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
 7613 
 7614 instruct storePConditional(memory heap_top_ptr,
 7615                            rax_RegP oldval, rRegP newval,
 7616                            rFlagsReg cr)
 7617 %{
 7618   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7619   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
 7620 
 7621   format %{ &quot;cmpxchgq $heap_top_ptr, $newval\t# (ptr) &quot;
 7622             &quot;If rax == $heap_top_ptr then store $newval into $heap_top_ptr&quot; %}
 7623   opcode(0x0F, 0xB1);
 7624   ins_encode(lock_prefix,
 7625              REX_reg_mem_wide(newval, heap_top_ptr),
 7626              OpcP, OpcS,
 7627              reg_mem(newval, heap_top_ptr));
 7628   ins_pipe(pipe_cmpxchg);
 7629 %}
 7630 
 7631 // Conditional-store of an int value.
 7632 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7633 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
 7634 %{
 7635   match(Set cr (StoreIConditional mem (Binary oldval newval)));
 7636   effect(KILL oldval);
 7637 
 7638   format %{ &quot;cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7639   opcode(0x0F, 0xB1);
 7640   ins_encode(lock_prefix,
 7641              REX_reg_mem(newval, mem),
 7642              OpcP, OpcS,
 7643              reg_mem(newval, mem));
 7644   ins_pipe(pipe_cmpxchg);
 7645 %}
 7646 
 7647 // Conditional-store of a long value.
 7648 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
 7649 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
 7650 %{
 7651   match(Set cr (StoreLConditional mem (Binary oldval newval)));
 7652   effect(KILL oldval);
 7653 
 7654   format %{ &quot;cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem&quot; %}
 7655   opcode(0x0F, 0xB1);
 7656   ins_encode(lock_prefix,
 7657              REX_reg_mem_wide(newval, mem),
 7658              OpcP, OpcS,
 7659              reg_mem(newval, mem));
 7660   ins_pipe(pipe_cmpxchg);
 7661 %}
 7662 
 7663 
 7664 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 7665 instruct compareAndSwapP(rRegI res,
 7666                          memory mem_ptr,
 7667                          rax_RegP oldval, rRegP newval,
 7668                          rFlagsReg cr)
 7669 %{
 7670   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7671   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
 7672   match(Set res (WeakCompareAndSwapP mem_ptr (Binary oldval newval)));
 7673   effect(KILL cr, KILL oldval);
 7674 
 7675   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7676             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7677             &quot;sete    $res\n\t&quot;
 7678             &quot;movzbl  $res, $res&quot; %}
 7679   opcode(0x0F, 0xB1);
 7680   ins_encode(lock_prefix,
 7681              REX_reg_mem_wide(newval, mem_ptr),
 7682              OpcP, OpcS,
 7683              reg_mem(newval, mem_ptr),
 7684              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7685              REX_reg_breg(res, res), // movzbl
 7686              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7687   ins_pipe( pipe_cmpxchg );
 7688 %}
 7689 
 7690 instruct compareAndSwapL(rRegI res,
 7691                          memory mem_ptr,
 7692                          rax_RegL oldval, rRegL newval,
 7693                          rFlagsReg cr)
 7694 %{
 7695   predicate(VM_Version::supports_cx8());
 7696   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
 7697   match(Set res (WeakCompareAndSwapL mem_ptr (Binary oldval newval)));
 7698   effect(KILL cr, KILL oldval);
 7699 
 7700   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7701             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7702             &quot;sete    $res\n\t&quot;
 7703             &quot;movzbl  $res, $res&quot; %}
 7704   opcode(0x0F, 0xB1);
 7705   ins_encode(lock_prefix,
 7706              REX_reg_mem_wide(newval, mem_ptr),
 7707              OpcP, OpcS,
 7708              reg_mem(newval, mem_ptr),
 7709              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7710              REX_reg_breg(res, res), // movzbl
 7711              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7712   ins_pipe( pipe_cmpxchg );
 7713 %}
 7714 
 7715 instruct compareAndSwapI(rRegI res,
 7716                          memory mem_ptr,
 7717                          rax_RegI oldval, rRegI newval,
 7718                          rFlagsReg cr)
 7719 %{
 7720   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
 7721   match(Set res (WeakCompareAndSwapI mem_ptr (Binary oldval newval)));
 7722   effect(KILL cr, KILL oldval);
 7723 
 7724   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7725             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7726             &quot;sete    $res\n\t&quot;
 7727             &quot;movzbl  $res, $res&quot; %}
 7728   opcode(0x0F, 0xB1);
 7729   ins_encode(lock_prefix,
 7730              REX_reg_mem(newval, mem_ptr),
 7731              OpcP, OpcS,
 7732              reg_mem(newval, mem_ptr),
 7733              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7734              REX_reg_breg(res, res), // movzbl
 7735              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7736   ins_pipe( pipe_cmpxchg );
 7737 %}
 7738 
 7739 instruct compareAndSwapB(rRegI res,
 7740                          memory mem_ptr,
 7741                          rax_RegI oldval, rRegI newval,
 7742                          rFlagsReg cr)
 7743 %{
 7744   match(Set res (CompareAndSwapB mem_ptr (Binary oldval newval)));
 7745   match(Set res (WeakCompareAndSwapB mem_ptr (Binary oldval newval)));
 7746   effect(KILL cr, KILL oldval);
 7747 
 7748   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7749             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7750             &quot;sete    $res\n\t&quot;
 7751             &quot;movzbl  $res, $res&quot; %}
 7752   opcode(0x0F, 0xB0);
 7753   ins_encode(lock_prefix,
 7754              REX_breg_mem(newval, mem_ptr),
 7755              OpcP, OpcS,
 7756              reg_mem(newval, mem_ptr),
 7757              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7758              REX_reg_breg(res, res), // movzbl
 7759              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7760   ins_pipe( pipe_cmpxchg );
 7761 %}
 7762 
 7763 instruct compareAndSwapS(rRegI res,
 7764                          memory mem_ptr,
 7765                          rax_RegI oldval, rRegI newval,
 7766                          rFlagsReg cr)
 7767 %{
 7768   match(Set res (CompareAndSwapS mem_ptr (Binary oldval newval)));
 7769   match(Set res (WeakCompareAndSwapS mem_ptr (Binary oldval newval)));
 7770   effect(KILL cr, KILL oldval);
 7771 
 7772   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7773             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7774             &quot;sete    $res\n\t&quot;
 7775             &quot;movzbl  $res, $res&quot; %}
 7776   opcode(0x0F, 0xB1);
 7777   ins_encode(lock_prefix,
 7778              SizePrefix,
 7779              REX_reg_mem(newval, mem_ptr),
 7780              OpcP, OpcS,
 7781              reg_mem(newval, mem_ptr),
 7782              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7783              REX_reg_breg(res, res), // movzbl
 7784              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7785   ins_pipe( pipe_cmpxchg );
 7786 %}
 7787 
 7788 instruct compareAndSwapN(rRegI res,
 7789                           memory mem_ptr,
 7790                           rax_RegN oldval, rRegN newval,
 7791                           rFlagsReg cr) %{
 7792   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
 7793   match(Set res (WeakCompareAndSwapN mem_ptr (Binary oldval newval)));
 7794   effect(KILL cr, KILL oldval);
 7795 
 7796   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7797             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;
 7798             &quot;sete    $res\n\t&quot;
 7799             &quot;movzbl  $res, $res&quot; %}
 7800   opcode(0x0F, 0xB1);
 7801   ins_encode(lock_prefix,
 7802              REX_reg_mem(newval, mem_ptr),
 7803              OpcP, OpcS,
 7804              reg_mem(newval, mem_ptr),
 7805              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
 7806              REX_reg_breg(res, res), // movzbl
 7807              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
 7808   ins_pipe( pipe_cmpxchg );
 7809 %}
 7810 
 7811 instruct compareAndExchangeB(
 7812                          memory mem_ptr,
 7813                          rax_RegI oldval, rRegI newval,
 7814                          rFlagsReg cr)
 7815 %{
 7816   match(Set oldval (CompareAndExchangeB mem_ptr (Binary oldval newval)));
 7817   effect(KILL cr);
 7818 
 7819   format %{ &quot;cmpxchgb $mem_ptr,$newval\t# &quot;
 7820             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7821   opcode(0x0F, 0xB0);
 7822   ins_encode(lock_prefix,
 7823              REX_breg_mem(newval, mem_ptr),
 7824              OpcP, OpcS,
 7825              reg_mem(newval, mem_ptr) // lock cmpxchg
 7826              );
 7827   ins_pipe( pipe_cmpxchg );
 7828 %}
 7829 
 7830 instruct compareAndExchangeS(
 7831                          memory mem_ptr,
 7832                          rax_RegI oldval, rRegI newval,
 7833                          rFlagsReg cr)
 7834 %{
 7835   match(Set oldval (CompareAndExchangeS mem_ptr (Binary oldval newval)));
 7836   effect(KILL cr);
 7837 
 7838   format %{ &quot;cmpxchgw $mem_ptr,$newval\t# &quot;
 7839             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7840   opcode(0x0F, 0xB1);
 7841   ins_encode(lock_prefix,
 7842              SizePrefix,
 7843              REX_reg_mem(newval, mem_ptr),
 7844              OpcP, OpcS,
 7845              reg_mem(newval, mem_ptr) // lock cmpxchg
 7846              );
 7847   ins_pipe( pipe_cmpxchg );
 7848 %}
 7849 
 7850 instruct compareAndExchangeI(
 7851                          memory mem_ptr,
 7852                          rax_RegI oldval, rRegI newval,
 7853                          rFlagsReg cr)
 7854 %{
 7855   match(Set oldval (CompareAndExchangeI mem_ptr (Binary oldval newval)));
 7856   effect(KILL cr);
 7857 
 7858   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7859             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7860   opcode(0x0F, 0xB1);
 7861   ins_encode(lock_prefix,
 7862              REX_reg_mem(newval, mem_ptr),
 7863              OpcP, OpcS,
 7864              reg_mem(newval, mem_ptr) // lock cmpxchg
 7865              );
 7866   ins_pipe( pipe_cmpxchg );
 7867 %}
 7868 
 7869 instruct compareAndExchangeL(
 7870                          memory mem_ptr,
 7871                          rax_RegL oldval, rRegL newval,
 7872                          rFlagsReg cr)
 7873 %{
 7874   predicate(VM_Version::supports_cx8());
 7875   match(Set oldval (CompareAndExchangeL mem_ptr (Binary oldval newval)));
 7876   effect(KILL cr);
 7877 
 7878   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7879             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot;  %}
 7880   opcode(0x0F, 0xB1);
 7881   ins_encode(lock_prefix,
 7882              REX_reg_mem_wide(newval, mem_ptr),
 7883              OpcP, OpcS,
 7884              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7885             );
 7886   ins_pipe( pipe_cmpxchg );
 7887 %}
 7888 
 7889 instruct compareAndExchangeN(
 7890                           memory mem_ptr,
 7891                           rax_RegN oldval, rRegN newval,
 7892                           rFlagsReg cr) %{
 7893   match(Set oldval (CompareAndExchangeN mem_ptr (Binary oldval newval)));
 7894   effect(KILL cr);
 7895 
 7896   format %{ &quot;cmpxchgl $mem_ptr,$newval\t# &quot;
 7897             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7898   opcode(0x0F, 0xB1);
 7899   ins_encode(lock_prefix,
 7900              REX_reg_mem(newval, mem_ptr),
 7901              OpcP, OpcS,
 7902              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7903           );
 7904   ins_pipe( pipe_cmpxchg );
 7905 %}
 7906 
 7907 instruct compareAndExchangeP(
 7908                          memory mem_ptr,
 7909                          rax_RegP oldval, rRegP newval,
 7910                          rFlagsReg cr)
 7911 %{
 7912   predicate(VM_Version::supports_cx8() &amp;&amp; n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 7913   match(Set oldval (CompareAndExchangeP mem_ptr (Binary oldval newval)));
 7914   effect(KILL cr);
 7915 
 7916   format %{ &quot;cmpxchgq $mem_ptr,$newval\t# &quot;
 7917             &quot;If rax == $mem_ptr then store $newval into $mem_ptr\n\t&quot; %}
 7918   opcode(0x0F, 0xB1);
 7919   ins_encode(lock_prefix,
 7920              REX_reg_mem_wide(newval, mem_ptr),
 7921              OpcP, OpcS,
 7922              reg_mem(newval, mem_ptr)  // lock cmpxchg
 7923           );
 7924   ins_pipe( pipe_cmpxchg );
 7925 %}
 7926 
 7927 instruct xaddB_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7928   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7929   match(Set dummy (GetAndAddB mem add));
 7930   effect(KILL cr);
 7931   format %{ &quot;ADDB  [$mem],$add&quot; %}
 7932   ins_encode %{
 7933     __ lock();
 7934     __ addb($mem$$Address, $add$$constant);
 7935   %}
 7936   ins_pipe( pipe_cmpxchg );
 7937 %}
 7938 
 7939 instruct xaddB( memory mem, rRegI newval, rFlagsReg cr) %{
 7940   match(Set newval (GetAndAddB mem newval));
 7941   effect(KILL cr);
 7942   format %{ &quot;XADDB  [$mem],$newval&quot; %}
 7943   ins_encode %{
 7944     __ lock();
 7945     __ xaddb($mem$$Address, $newval$$Register);
 7946   %}
 7947   ins_pipe( pipe_cmpxchg );
 7948 %}
 7949 
 7950 instruct xaddS_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7951   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7952   match(Set dummy (GetAndAddS mem add));
 7953   effect(KILL cr);
 7954   format %{ &quot;ADDW  [$mem],$add&quot; %}
 7955   ins_encode %{
 7956     __ lock();
 7957     __ addw($mem$$Address, $add$$constant);
 7958   %}
 7959   ins_pipe( pipe_cmpxchg );
 7960 %}
 7961 
 7962 instruct xaddS( memory mem, rRegI newval, rFlagsReg cr) %{
 7963   match(Set newval (GetAndAddS mem newval));
 7964   effect(KILL cr);
 7965   format %{ &quot;XADDW  [$mem],$newval&quot; %}
 7966   ins_encode %{
 7967     __ lock();
 7968     __ xaddw($mem$$Address, $newval$$Register);
 7969   %}
 7970   ins_pipe( pipe_cmpxchg );
 7971 %}
 7972 
 7973 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
 7974   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7975   match(Set dummy (GetAndAddI mem add));
 7976   effect(KILL cr);
 7977   format %{ &quot;ADDL  [$mem],$add&quot; %}
 7978   ins_encode %{
 7979     __ lock();
 7980     __ addl($mem$$Address, $add$$constant);
 7981   %}
 7982   ins_pipe( pipe_cmpxchg );
 7983 %}
 7984 
 7985 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
 7986   match(Set newval (GetAndAddI mem newval));
 7987   effect(KILL cr);
 7988   format %{ &quot;XADDL  [$mem],$newval&quot; %}
 7989   ins_encode %{
 7990     __ lock();
 7991     __ xaddl($mem$$Address, $newval$$Register);
 7992   %}
 7993   ins_pipe( pipe_cmpxchg );
 7994 %}
 7995 
 7996 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
 7997   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 7998   match(Set dummy (GetAndAddL mem add));
 7999   effect(KILL cr);
 8000   format %{ &quot;ADDQ  [$mem],$add&quot; %}
 8001   ins_encode %{
 8002     __ lock();
 8003     __ addq($mem$$Address, $add$$constant);
 8004   %}
 8005   ins_pipe( pipe_cmpxchg );
 8006 %}
 8007 
 8008 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
 8009   match(Set newval (GetAndAddL mem newval));
 8010   effect(KILL cr);
 8011   format %{ &quot;XADDQ  [$mem],$newval&quot; %}
 8012   ins_encode %{
 8013     __ lock();
 8014     __ xaddq($mem$$Address, $newval$$Register);
 8015   %}
 8016   ins_pipe( pipe_cmpxchg );
 8017 %}
 8018 
 8019 instruct xchgB( memory mem, rRegI newval) %{
 8020   match(Set newval (GetAndSetB mem newval));
 8021   format %{ &quot;XCHGB  $newval,[$mem]&quot; %}
 8022   ins_encode %{
 8023     __ xchgb($newval$$Register, $mem$$Address);
 8024   %}
 8025   ins_pipe( pipe_cmpxchg );
 8026 %}
 8027 
 8028 instruct xchgS( memory mem, rRegI newval) %{
 8029   match(Set newval (GetAndSetS mem newval));
 8030   format %{ &quot;XCHGW  $newval,[$mem]&quot; %}
 8031   ins_encode %{
 8032     __ xchgw($newval$$Register, $mem$$Address);
 8033   %}
 8034   ins_pipe( pipe_cmpxchg );
 8035 %}
 8036 
 8037 instruct xchgI( memory mem, rRegI newval) %{
 8038   match(Set newval (GetAndSetI mem newval));
 8039   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8040   ins_encode %{
 8041     __ xchgl($newval$$Register, $mem$$Address);
 8042   %}
 8043   ins_pipe( pipe_cmpxchg );
 8044 %}
 8045 
 8046 instruct xchgL( memory mem, rRegL newval) %{
 8047   match(Set newval (GetAndSetL mem newval));
 8048   format %{ &quot;XCHGL  $newval,[$mem]&quot; %}
 8049   ins_encode %{
 8050     __ xchgq($newval$$Register, $mem$$Address);
 8051   %}
 8052   ins_pipe( pipe_cmpxchg );
 8053 %}
 8054 
 8055 instruct xchgP( memory mem, rRegP newval) %{
 8056   match(Set newval (GetAndSetP mem newval));
 8057   predicate(n-&gt;as_LoadStore()-&gt;barrier_data() == 0);
 8058   format %{ &quot;XCHGQ  $newval,[$mem]&quot; %}
 8059   ins_encode %{
 8060     __ xchgq($newval$$Register, $mem$$Address);
 8061   %}
 8062   ins_pipe( pipe_cmpxchg );
 8063 %}
 8064 
 8065 instruct xchgN( memory mem, rRegN newval) %{
 8066   match(Set newval (GetAndSetN mem newval));
 8067   format %{ &quot;XCHGL  $newval,$mem]&quot; %}
 8068   ins_encode %{
 8069     __ xchgl($newval$$Register, $mem$$Address);
 8070   %}
 8071   ins_pipe( pipe_cmpxchg );
 8072 %}
 8073 
 8074 //----------Abs Instructions-------------------------------------------
 8075 
 8076 // Integer Absolute Instructions
 8077 instruct absI_rReg(rRegI dst, rRegI src, rRegI tmp, rFlagsReg cr)
 8078 %{
 8079   match(Set dst (AbsI src));
 8080   effect(TEMP dst, TEMP tmp, KILL cr);
 8081   format %{ &quot;movl $tmp, $src\n\t&quot;
 8082             &quot;sarl $tmp, 31\n\t&quot;
 8083             &quot;movl $dst, $src\n\t&quot;
 8084             &quot;xorl $dst, $tmp\n\t&quot;
 8085             &quot;subl $dst, $tmp\n&quot;
 8086           %}
 8087   ins_encode %{
 8088     __ movl($tmp$$Register, $src$$Register);
 8089     __ sarl($tmp$$Register, 31);
 8090     __ movl($dst$$Register, $src$$Register);
 8091     __ xorl($dst$$Register, $tmp$$Register);
 8092     __ subl($dst$$Register, $tmp$$Register);
 8093   %}
 8094 
 8095   ins_pipe(ialu_reg_reg);
 8096 %}
 8097 
 8098 // Long Absolute Instructions
 8099 instruct absL_rReg(rRegL dst, rRegL src, rRegL tmp, rFlagsReg cr)
 8100 %{
 8101   match(Set dst (AbsL src));
 8102   effect(TEMP dst, TEMP tmp, KILL cr);
 8103   format %{ &quot;movq $tmp, $src\n\t&quot;
 8104             &quot;sarq $tmp, 63\n\t&quot;
 8105             &quot;movq $dst, $src\n\t&quot;
 8106             &quot;xorq $dst, $tmp\n\t&quot;
 8107             &quot;subq $dst, $tmp\n&quot;
 8108           %}
 8109   ins_encode %{
 8110     __ movq($tmp$$Register, $src$$Register);
 8111     __ sarq($tmp$$Register, 63);
 8112     __ movq($dst$$Register, $src$$Register);
 8113     __ xorq($dst$$Register, $tmp$$Register);
 8114     __ subq($dst$$Register, $tmp$$Register);
 8115   %}
 8116 
 8117   ins_pipe(ialu_reg_reg);
 8118 %}
 8119 
 8120 //----------Subtraction Instructions-------------------------------------------
 8121 
 8122 // Integer Subtraction Instructions
 8123 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8124 %{
 8125   match(Set dst (SubI dst src));
 8126   effect(KILL cr);
 8127 
 8128   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8129   opcode(0x2B);
 8130   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 8131   ins_pipe(ialu_reg_reg);
 8132 %}
 8133 
 8134 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 8135 %{
 8136   match(Set dst (SubI dst src));
 8137   effect(KILL cr);
 8138 
 8139   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8140   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8141   ins_encode(OpcSErm(dst, src), Con8or32(src));
 8142   ins_pipe(ialu_reg);
 8143 %}
 8144 
 8145 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 8146 %{
 8147   match(Set dst (SubI dst (LoadI src)));
 8148   effect(KILL cr);
 8149 
 8150   ins_cost(125);
 8151   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8152   opcode(0x2B);
 8153   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 8154   ins_pipe(ialu_reg_mem);
 8155 %}
 8156 
 8157 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 8158 %{
 8159   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8160   effect(KILL cr);
 8161 
 8162   ins_cost(150);
 8163   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8164   opcode(0x29); /* Opcode 29 /r */
 8165   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 8166   ins_pipe(ialu_mem_reg);
 8167 %}
 8168 
 8169 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
 8170 %{
 8171   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
 8172   effect(KILL cr);
 8173 
 8174   ins_cost(125); // XXX
 8175   format %{ &quot;subl    $dst, $src\t# int&quot; %}
 8176   opcode(0x81); /* Opcode 81 /5 id */
 8177   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8178   ins_pipe(ialu_mem_imm);
 8179 %}
 8180 
 8181 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8182 %{
 8183   match(Set dst (SubL dst src));
 8184   effect(KILL cr);
 8185 
 8186   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8187   opcode(0x2B);
 8188   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8189   ins_pipe(ialu_reg_reg);
 8190 %}
 8191 
 8192 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
 8193 %{
 8194   match(Set dst (SubL dst src));
 8195   effect(KILL cr);
 8196 
 8197   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8198   opcode(0x81, 0x05);  /* Opcode 81 /5 */
 8199   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 8200   ins_pipe(ialu_reg);
 8201 %}
 8202 
 8203 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 8204 %{
 8205   match(Set dst (SubL dst (LoadL src)));
 8206   effect(KILL cr);
 8207 
 8208   ins_cost(125);
 8209   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8210   opcode(0x2B);
 8211   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 8212   ins_pipe(ialu_reg_mem);
 8213 %}
 8214 
 8215 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 8216 %{
 8217   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8218   effect(KILL cr);
 8219 
 8220   ins_cost(150);
 8221   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8222   opcode(0x29); /* Opcode 29 /r */
 8223   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 8224   ins_pipe(ialu_mem_reg);
 8225 %}
 8226 
 8227 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 8228 %{
 8229   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
 8230   effect(KILL cr);
 8231 
 8232   ins_cost(125); // XXX
 8233   format %{ &quot;subq    $dst, $src\t# long&quot; %}
 8234   opcode(0x81); /* Opcode 81 /5 id */
 8235   ins_encode(REX_mem_wide(dst),
 8236              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
 8237   ins_pipe(ialu_mem_imm);
 8238 %}
 8239 
 8240 // Subtract from a pointer
 8241 // XXX hmpf???
 8242 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
 8243 %{
 8244   match(Set dst (AddP dst (SubI zero src)));
 8245   effect(KILL cr);
 8246 
 8247   format %{ &quot;subq    $dst, $src\t# ptr - int&quot; %}
 8248   opcode(0x2B);
 8249   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 8250   ins_pipe(ialu_reg_reg);
 8251 %}
 8252 
 8253 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
 8254 %{
 8255   match(Set dst (SubI zero dst));
 8256   effect(KILL cr);
 8257 
 8258   format %{ &quot;negl    $dst\t# int&quot; %}
 8259   opcode(0xF7, 0x03);  // Opcode F7 /3
 8260   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8261   ins_pipe(ialu_reg);
 8262 %}
 8263 
 8264 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
 8265 %{
 8266   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
 8267   effect(KILL cr);
 8268 
 8269   format %{ &quot;negl    $dst\t# int&quot; %}
 8270   opcode(0xF7, 0x03);  // Opcode F7 /3
 8271   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8272   ins_pipe(ialu_reg);
 8273 %}
 8274 
 8275 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
 8276 %{
 8277   match(Set dst (SubL zero dst));
 8278   effect(KILL cr);
 8279 
 8280   format %{ &quot;negq    $dst\t# long&quot; %}
 8281   opcode(0xF7, 0x03);  // Opcode F7 /3
 8282   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8283   ins_pipe(ialu_reg);
 8284 %}
 8285 
 8286 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
 8287 %{
 8288   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
 8289   effect(KILL cr);
 8290 
 8291   format %{ &quot;negq    $dst\t# long&quot; %}
 8292   opcode(0xF7, 0x03);  // Opcode F7 /3
 8293   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8294   ins_pipe(ialu_reg);
 8295 %}
 8296 
 8297 //----------Multiplication/Division Instructions-------------------------------
 8298 // Integer Multiplication Instructions
 8299 // Multiply Register
 8300 
 8301 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 8302 %{
 8303   match(Set dst (MulI dst src));
 8304   effect(KILL cr);
 8305 
 8306   ins_cost(300);
 8307   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8308   opcode(0x0F, 0xAF);
 8309   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8310   ins_pipe(ialu_reg_reg_alu0);
 8311 %}
 8312 
 8313 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
 8314 %{
 8315   match(Set dst (MulI src imm));
 8316   effect(KILL cr);
 8317 
 8318   ins_cost(300);
 8319   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8320   opcode(0x69); /* 69 /r id */
 8321   ins_encode(REX_reg_reg(dst, src),
 8322              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8323   ins_pipe(ialu_reg_reg_alu0);
 8324 %}
 8325 
 8326 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
 8327 %{
 8328   match(Set dst (MulI dst (LoadI src)));
 8329   effect(KILL cr);
 8330 
 8331   ins_cost(350);
 8332   format %{ &quot;imull   $dst, $src\t# int&quot; %}
 8333   opcode(0x0F, 0xAF);
 8334   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8335   ins_pipe(ialu_reg_mem_alu0);
 8336 %}
 8337 
 8338 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
 8339 %{
 8340   match(Set dst (MulI (LoadI src) imm));
 8341   effect(KILL cr);
 8342 
 8343   ins_cost(300);
 8344   format %{ &quot;imull   $dst, $src, $imm\t# int&quot; %}
 8345   opcode(0x69); /* 69 /r id */
 8346   ins_encode(REX_reg_mem(dst, src),
 8347              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8348   ins_pipe(ialu_reg_mem_alu0);
 8349 %}
 8350 
 8351 instruct mulAddS2I_rReg(rRegI dst, rRegI src1, rRegI src2, rRegI src3, rFlagsReg cr)
 8352 %{
 8353   match(Set dst (MulAddS2I (Binary dst src1) (Binary src2 src3)));
 8354   effect(KILL cr, KILL src2);
 8355 
 8356   expand %{ mulI_rReg(dst, src1, cr);
 8357            mulI_rReg(src2, src3, cr);
 8358            addI_rReg(dst, src2, cr); %}
 8359 %}
 8360 
 8361 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 8362 %{
 8363   match(Set dst (MulL dst src));
 8364   effect(KILL cr);
 8365 
 8366   ins_cost(300);
 8367   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8368   opcode(0x0F, 0xAF);
 8369   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
 8370   ins_pipe(ialu_reg_reg_alu0);
 8371 %}
 8372 
 8373 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
 8374 %{
 8375   match(Set dst (MulL src imm));
 8376   effect(KILL cr);
 8377 
 8378   ins_cost(300);
 8379   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8380   opcode(0x69); /* 69 /r id */
 8381   ins_encode(REX_reg_reg_wide(dst, src),
 8382              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
 8383   ins_pipe(ialu_reg_reg_alu0);
 8384 %}
 8385 
 8386 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
 8387 %{
 8388   match(Set dst (MulL dst (LoadL src)));
 8389   effect(KILL cr);
 8390 
 8391   ins_cost(350);
 8392   format %{ &quot;imulq   $dst, $src\t# long&quot; %}
 8393   opcode(0x0F, 0xAF);
 8394   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
 8395   ins_pipe(ialu_reg_mem_alu0);
 8396 %}
 8397 
 8398 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
 8399 %{
 8400   match(Set dst (MulL (LoadL src) imm));
 8401   effect(KILL cr);
 8402 
 8403   ins_cost(300);
 8404   format %{ &quot;imulq   $dst, $src, $imm\t# long&quot; %}
 8405   opcode(0x69); /* 69 /r id */
 8406   ins_encode(REX_reg_mem_wide(dst, src),
 8407              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
 8408   ins_pipe(ialu_reg_mem_alu0);
 8409 %}
 8410 
 8411 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8412 %{
 8413   match(Set dst (MulHiL src rax));
 8414   effect(USE_KILL rax, KILL cr);
 8415 
 8416   ins_cost(300);
 8417   format %{ &quot;imulq   RDX:RAX, RAX, $src\t# mulhi&quot; %}
 8418   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8419   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8420   ins_pipe(ialu_reg_reg_alu0);
 8421 %}
 8422 
 8423 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8424                    rFlagsReg cr)
 8425 %{
 8426   match(Set rax (DivI rax div));
 8427   effect(KILL rdx, KILL cr);
 8428 
 8429   ins_cost(30*100+10*100); // XXX
 8430   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8431             &quot;jne,s   normal\n\t&quot;
 8432             &quot;xorl    rdx, rdx\n\t&quot;
 8433             &quot;cmpl    $div, -1\n\t&quot;
 8434             &quot;je,s    done\n&quot;
 8435     &quot;normal: cdql\n\t&quot;
 8436             &quot;idivl   $div\n&quot;
 8437     &quot;done:&quot;        %}
 8438   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8439   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8440   ins_pipe(ialu_reg_reg_alu0);
 8441 %}
 8442 
 8443 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8444                    rFlagsReg cr)
 8445 %{
 8446   match(Set rax (DivL rax div));
 8447   effect(KILL rdx, KILL cr);
 8448 
 8449   ins_cost(30*100+10*100); // XXX
 8450   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8451             &quot;cmpq    rax, rdx\n\t&quot;
 8452             &quot;jne,s   normal\n\t&quot;
 8453             &quot;xorl    rdx, rdx\n\t&quot;
 8454             &quot;cmpq    $div, -1\n\t&quot;
 8455             &quot;je,s    done\n&quot;
 8456     &quot;normal: cdqq\n\t&quot;
 8457             &quot;idivq   $div\n&quot;
 8458     &quot;done:&quot;        %}
 8459   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8460   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8461   ins_pipe(ialu_reg_reg_alu0);
 8462 %}
 8463 
 8464 // Integer DIVMOD with Register, both quotient and mod results
 8465 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
 8466                              rFlagsReg cr)
 8467 %{
 8468   match(DivModI rax div);
 8469   effect(KILL cr);
 8470 
 8471   ins_cost(30*100+10*100); // XXX
 8472   format %{ &quot;cmpl    rax, 0x80000000\t# idiv\n\t&quot;
 8473             &quot;jne,s   normal\n\t&quot;
 8474             &quot;xorl    rdx, rdx\n\t&quot;
 8475             &quot;cmpl    $div, -1\n\t&quot;
 8476             &quot;je,s    done\n&quot;
 8477     &quot;normal: cdql\n\t&quot;
 8478             &quot;idivl   $div\n&quot;
 8479     &quot;done:&quot;        %}
 8480   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8481   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8482   ins_pipe(pipe_slow);
 8483 %}
 8484 
 8485 // Long DIVMOD with Register, both quotient and mod results
 8486 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
 8487                              rFlagsReg cr)
 8488 %{
 8489   match(DivModL rax div);
 8490   effect(KILL cr);
 8491 
 8492   ins_cost(30*100+10*100); // XXX
 8493   format %{ &quot;movq    rdx, 0x8000000000000000\t# ldiv\n\t&quot;
 8494             &quot;cmpq    rax, rdx\n\t&quot;
 8495             &quot;jne,s   normal\n\t&quot;
 8496             &quot;xorl    rdx, rdx\n\t&quot;
 8497             &quot;cmpq    $div, -1\n\t&quot;
 8498             &quot;je,s    done\n&quot;
 8499     &quot;normal: cdqq\n\t&quot;
 8500             &quot;idivq   $div\n&quot;
 8501     &quot;done:&quot;        %}
 8502   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8503   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8504   ins_pipe(pipe_slow);
 8505 %}
 8506 
 8507 //----------- DivL-By-Constant-Expansions--------------------------------------
 8508 // DivI cases are handled by the compiler
 8509 
 8510 // Magic constant, reciprocal of 10
 8511 instruct loadConL_0x6666666666666667(rRegL dst)
 8512 %{
 8513   effect(DEF dst);
 8514 
 8515   format %{ &quot;movq    $dst, #0x666666666666667\t# Used in div-by-10&quot; %}
 8516   ins_encode(load_immL(dst, 0x6666666666666667));
 8517   ins_pipe(ialu_reg);
 8518 %}
 8519 
 8520 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
 8521 %{
 8522   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
 8523 
 8524   format %{ &quot;imulq   rdx:rax, rax, $src\t# Used in div-by-10&quot; %}
 8525   opcode(0xF7, 0x5); /* Opcode F7 /5 */
 8526   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
 8527   ins_pipe(ialu_reg_reg_alu0);
 8528 %}
 8529 
 8530 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
 8531 %{
 8532   effect(USE_DEF dst, KILL cr);
 8533 
 8534   format %{ &quot;sarq    $dst, #63\t# Used in div-by-10&quot; %}
 8535   opcode(0xC1, 0x7); /* C1 /7 ib */
 8536   ins_encode(reg_opc_imm_wide(dst, 0x3F));
 8537   ins_pipe(ialu_reg);
 8538 %}
 8539 
 8540 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
 8541 %{
 8542   effect(USE_DEF dst, KILL cr);
 8543 
 8544   format %{ &quot;sarq    $dst, #2\t# Used in div-by-10&quot; %}
 8545   opcode(0xC1, 0x7); /* C1 /7 ib */
 8546   ins_encode(reg_opc_imm_wide(dst, 0x2));
 8547   ins_pipe(ialu_reg);
 8548 %}
 8549 
 8550 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
 8551 %{
 8552   match(Set dst (DivL src div));
 8553 
 8554   ins_cost((5+8)*100);
 8555   expand %{
 8556     rax_RegL rax;                     // Killed temp
 8557     rFlagsReg cr;                     // Killed
 8558     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
 8559     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
 8560     sarL_rReg_63(src, cr);            // sarq  src, 63
 8561     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
 8562     subL_rReg(dst, src, cr);          // subl  rdx, src
 8563   %}
 8564 %}
 8565 
 8566 //-----------------------------------------------------------------------------
 8567 
 8568 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
 8569                    rFlagsReg cr)
 8570 %{
 8571   match(Set rdx (ModI rax div));
 8572   effect(KILL rax, KILL cr);
 8573 
 8574   ins_cost(300); // XXX
 8575   format %{ &quot;cmpl    rax, 0x80000000\t# irem\n\t&quot;
 8576             &quot;jne,s   normal\n\t&quot;
 8577             &quot;xorl    rdx, rdx\n\t&quot;
 8578             &quot;cmpl    $div, -1\n\t&quot;
 8579             &quot;je,s    done\n&quot;
 8580     &quot;normal: cdql\n\t&quot;
 8581             &quot;idivl   $div\n&quot;
 8582     &quot;done:&quot;        %}
 8583   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8584   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
 8585   ins_pipe(ialu_reg_reg_alu0);
 8586 %}
 8587 
 8588 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
 8589                    rFlagsReg cr)
 8590 %{
 8591   match(Set rdx (ModL rax div));
 8592   effect(KILL rax, KILL cr);
 8593 
 8594   ins_cost(300); // XXX
 8595   format %{ &quot;movq    rdx, 0x8000000000000000\t# lrem\n\t&quot;
 8596             &quot;cmpq    rax, rdx\n\t&quot;
 8597             &quot;jne,s   normal\n\t&quot;
 8598             &quot;xorl    rdx, rdx\n\t&quot;
 8599             &quot;cmpq    $div, -1\n\t&quot;
 8600             &quot;je,s    done\n&quot;
 8601     &quot;normal: cdqq\n\t&quot;
 8602             &quot;idivq   $div\n&quot;
 8603     &quot;done:&quot;        %}
 8604   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
 8605   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
 8606   ins_pipe(ialu_reg_reg_alu0);
 8607 %}
 8608 
 8609 // Integer Shift Instructions
 8610 // Shift Left by one
 8611 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8612 %{
 8613   match(Set dst (LShiftI dst shift));
 8614   effect(KILL cr);
 8615 
 8616   format %{ &quot;sall    $dst, $shift&quot; %}
 8617   opcode(0xD1, 0x4); /* D1 /4 */
 8618   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8619   ins_pipe(ialu_reg);
 8620 %}
 8621 
 8622 // Shift Left by one
 8623 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8624 %{
 8625   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8626   effect(KILL cr);
 8627 
 8628   format %{ &quot;sall    $dst, $shift\t&quot; %}
 8629   opcode(0xD1, 0x4); /* D1 /4 */
 8630   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8631   ins_pipe(ialu_mem_imm);
 8632 %}
 8633 
 8634 // Shift Left by 8-bit immediate
 8635 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8636 %{
 8637   match(Set dst (LShiftI dst shift));
 8638   effect(KILL cr);
 8639 
 8640   format %{ &quot;sall    $dst, $shift&quot; %}
 8641   opcode(0xC1, 0x4); /* C1 /4 ib */
 8642   ins_encode(reg_opc_imm(dst, shift));
 8643   ins_pipe(ialu_reg);
 8644 %}
 8645 
 8646 // Shift Left by 8-bit immediate
 8647 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8648 %{
 8649   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8650   effect(KILL cr);
 8651 
 8652   format %{ &quot;sall    $dst, $shift&quot; %}
 8653   opcode(0xC1, 0x4); /* C1 /4 ib */
 8654   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8655   ins_pipe(ialu_mem_imm);
 8656 %}
 8657 
 8658 // Shift Left by variable
 8659 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8660 %{
 8661   match(Set dst (LShiftI dst shift));
 8662   effect(KILL cr);
 8663 
 8664   format %{ &quot;sall    $dst, $shift&quot; %}
 8665   opcode(0xD3, 0x4); /* D3 /4 */
 8666   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8667   ins_pipe(ialu_reg_reg);
 8668 %}
 8669 
 8670 // Shift Left by variable
 8671 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8672 %{
 8673   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
 8674   effect(KILL cr);
 8675 
 8676   format %{ &quot;sall    $dst, $shift&quot; %}
 8677   opcode(0xD3, 0x4); /* D3 /4 */
 8678   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8679   ins_pipe(ialu_mem_reg);
 8680 %}
 8681 
 8682 // Arithmetic shift right by one
 8683 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8684 %{
 8685   match(Set dst (RShiftI dst shift));
 8686   effect(KILL cr);
 8687 
 8688   format %{ &quot;sarl    $dst, $shift&quot; %}
 8689   opcode(0xD1, 0x7); /* D1 /7 */
 8690   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8691   ins_pipe(ialu_reg);
 8692 %}
 8693 
 8694 // Arithmetic shift right by one
 8695 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8696 %{
 8697   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8698   effect(KILL cr);
 8699 
 8700   format %{ &quot;sarl    $dst, $shift&quot; %}
 8701   opcode(0xD1, 0x7); /* D1 /7 */
 8702   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8703   ins_pipe(ialu_mem_imm);
 8704 %}
 8705 
 8706 // Arithmetic Shift Right by 8-bit immediate
 8707 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8708 %{
 8709   match(Set dst (RShiftI dst shift));
 8710   effect(KILL cr);
 8711 
 8712   format %{ &quot;sarl    $dst, $shift&quot; %}
 8713   opcode(0xC1, 0x7); /* C1 /7 ib */
 8714   ins_encode(reg_opc_imm(dst, shift));
 8715   ins_pipe(ialu_mem_imm);
 8716 %}
 8717 
 8718 // Arithmetic Shift Right by 8-bit immediate
 8719 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8720 %{
 8721   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8722   effect(KILL cr);
 8723 
 8724   format %{ &quot;sarl    $dst, $shift&quot; %}
 8725   opcode(0xC1, 0x7); /* C1 /7 ib */
 8726   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8727   ins_pipe(ialu_mem_imm);
 8728 %}
 8729 
 8730 // Arithmetic Shift Right by variable
 8731 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8732 %{
 8733   match(Set dst (RShiftI dst shift));
 8734   effect(KILL cr);
 8735 
 8736   format %{ &quot;sarl    $dst, $shift&quot; %}
 8737   opcode(0xD3, 0x7); /* D3 /7 */
 8738   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8739   ins_pipe(ialu_reg_reg);
 8740 %}
 8741 
 8742 // Arithmetic Shift Right by variable
 8743 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8744 %{
 8745   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
 8746   effect(KILL cr);
 8747 
 8748   format %{ &quot;sarl    $dst, $shift&quot; %}
 8749   opcode(0xD3, 0x7); /* D3 /7 */
 8750   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8751   ins_pipe(ialu_mem_reg);
 8752 %}
 8753 
 8754 // Logical shift right by one
 8755 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
 8756 %{
 8757   match(Set dst (URShiftI dst shift));
 8758   effect(KILL cr);
 8759 
 8760   format %{ &quot;shrl    $dst, $shift&quot; %}
 8761   opcode(0xD1, 0x5); /* D1 /5 */
 8762   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8763   ins_pipe(ialu_reg);
 8764 %}
 8765 
 8766 // Logical shift right by one
 8767 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8768 %{
 8769   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8770   effect(KILL cr);
 8771 
 8772   format %{ &quot;shrl    $dst, $shift&quot; %}
 8773   opcode(0xD1, 0x5); /* D1 /5 */
 8774   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8775   ins_pipe(ialu_mem_imm);
 8776 %}
 8777 
 8778 // Logical Shift Right by 8-bit immediate
 8779 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
 8780 %{
 8781   match(Set dst (URShiftI dst shift));
 8782   effect(KILL cr);
 8783 
 8784   format %{ &quot;shrl    $dst, $shift&quot; %}
 8785   opcode(0xC1, 0x5); /* C1 /5 ib */
 8786   ins_encode(reg_opc_imm(dst, shift));
 8787   ins_pipe(ialu_reg);
 8788 %}
 8789 
 8790 // Logical Shift Right by 8-bit immediate
 8791 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8792 %{
 8793   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8794   effect(KILL cr);
 8795 
 8796   format %{ &quot;shrl    $dst, $shift&quot; %}
 8797   opcode(0xC1, 0x5); /* C1 /5 ib */
 8798   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
 8799   ins_pipe(ialu_mem_imm);
 8800 %}
 8801 
 8802 // Logical Shift Right by variable
 8803 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
 8804 %{
 8805   match(Set dst (URShiftI dst shift));
 8806   effect(KILL cr);
 8807 
 8808   format %{ &quot;shrl    $dst, $shift&quot; %}
 8809   opcode(0xD3, 0x5); /* D3 /5 */
 8810   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 8811   ins_pipe(ialu_reg_reg);
 8812 %}
 8813 
 8814 // Logical Shift Right by variable
 8815 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8816 %{
 8817   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
 8818   effect(KILL cr);
 8819 
 8820   format %{ &quot;shrl    $dst, $shift&quot; %}
 8821   opcode(0xD3, 0x5); /* D3 /5 */
 8822   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
 8823   ins_pipe(ialu_mem_reg);
 8824 %}
 8825 
 8826 // Long Shift Instructions
 8827 // Shift Left by one
 8828 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8829 %{
 8830   match(Set dst (LShiftL dst shift));
 8831   effect(KILL cr);
 8832 
 8833   format %{ &quot;salq    $dst, $shift&quot; %}
 8834   opcode(0xD1, 0x4); /* D1 /4 */
 8835   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8836   ins_pipe(ialu_reg);
 8837 %}
 8838 
 8839 // Shift Left by one
 8840 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8841 %{
 8842   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8843   effect(KILL cr);
 8844 
 8845   format %{ &quot;salq    $dst, $shift&quot; %}
 8846   opcode(0xD1, 0x4); /* D1 /4 */
 8847   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8848   ins_pipe(ialu_mem_imm);
 8849 %}
 8850 
 8851 // Shift Left by 8-bit immediate
 8852 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8853 %{
 8854   match(Set dst (LShiftL dst shift));
 8855   effect(KILL cr);
 8856 
 8857   format %{ &quot;salq    $dst, $shift&quot; %}
 8858   opcode(0xC1, 0x4); /* C1 /4 ib */
 8859   ins_encode(reg_opc_imm_wide(dst, shift));
 8860   ins_pipe(ialu_reg);
 8861 %}
 8862 
 8863 // Shift Left by 8-bit immediate
 8864 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8865 %{
 8866   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8867   effect(KILL cr);
 8868 
 8869   format %{ &quot;salq    $dst, $shift&quot; %}
 8870   opcode(0xC1, 0x4); /* C1 /4 ib */
 8871   ins_encode(REX_mem_wide(dst), OpcP,
 8872              RM_opc_mem(secondary, dst), Con8or32(shift));
 8873   ins_pipe(ialu_mem_imm);
 8874 %}
 8875 
 8876 // Shift Left by variable
 8877 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8878 %{
 8879   match(Set dst (LShiftL dst shift));
 8880   effect(KILL cr);
 8881 
 8882   format %{ &quot;salq    $dst, $shift&quot; %}
 8883   opcode(0xD3, 0x4); /* D3 /4 */
 8884   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8885   ins_pipe(ialu_reg_reg);
 8886 %}
 8887 
 8888 // Shift Left by variable
 8889 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8890 %{
 8891   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
 8892   effect(KILL cr);
 8893 
 8894   format %{ &quot;salq    $dst, $shift&quot; %}
 8895   opcode(0xD3, 0x4); /* D3 /4 */
 8896   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8897   ins_pipe(ialu_mem_reg);
 8898 %}
 8899 
 8900 // Arithmetic shift right by one
 8901 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8902 %{
 8903   match(Set dst (RShiftL dst shift));
 8904   effect(KILL cr);
 8905 
 8906   format %{ &quot;sarq    $dst, $shift&quot; %}
 8907   opcode(0xD1, 0x7); /* D1 /7 */
 8908   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8909   ins_pipe(ialu_reg);
 8910 %}
 8911 
 8912 // Arithmetic shift right by one
 8913 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8914 %{
 8915   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8916   effect(KILL cr);
 8917 
 8918   format %{ &quot;sarq    $dst, $shift&quot; %}
 8919   opcode(0xD1, 0x7); /* D1 /7 */
 8920   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8921   ins_pipe(ialu_mem_imm);
 8922 %}
 8923 
 8924 // Arithmetic Shift Right by 8-bit immediate
 8925 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8926 %{
 8927   match(Set dst (RShiftL dst shift));
 8928   effect(KILL cr);
 8929 
 8930   format %{ &quot;sarq    $dst, $shift&quot; %}
 8931   opcode(0xC1, 0x7); /* C1 /7 ib */
 8932   ins_encode(reg_opc_imm_wide(dst, shift));
 8933   ins_pipe(ialu_mem_imm);
 8934 %}
 8935 
 8936 // Arithmetic Shift Right by 8-bit immediate
 8937 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 8938 %{
 8939   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8940   effect(KILL cr);
 8941 
 8942   format %{ &quot;sarq    $dst, $shift&quot; %}
 8943   opcode(0xC1, 0x7); /* C1 /7 ib */
 8944   ins_encode(REX_mem_wide(dst), OpcP,
 8945              RM_opc_mem(secondary, dst), Con8or32(shift));
 8946   ins_pipe(ialu_mem_imm);
 8947 %}
 8948 
 8949 // Arithmetic Shift Right by variable
 8950 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 8951 %{
 8952   match(Set dst (RShiftL dst shift));
 8953   effect(KILL cr);
 8954 
 8955   format %{ &quot;sarq    $dst, $shift&quot; %}
 8956   opcode(0xD3, 0x7); /* D3 /7 */
 8957   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 8958   ins_pipe(ialu_reg_reg);
 8959 %}
 8960 
 8961 // Arithmetic Shift Right by variable
 8962 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 8963 %{
 8964   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
 8965   effect(KILL cr);
 8966 
 8967   format %{ &quot;sarq    $dst, $shift&quot; %}
 8968   opcode(0xD3, 0x7); /* D3 /7 */
 8969   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8970   ins_pipe(ialu_mem_reg);
 8971 %}
 8972 
 8973 // Logical shift right by one
 8974 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
 8975 %{
 8976   match(Set dst (URShiftL dst shift));
 8977   effect(KILL cr);
 8978 
 8979   format %{ &quot;shrq    $dst, $shift&quot; %}
 8980   opcode(0xD1, 0x5); /* D1 /5 */
 8981   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
 8982   ins_pipe(ialu_reg);
 8983 %}
 8984 
 8985 // Logical shift right by one
 8986 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
 8987 %{
 8988   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 8989   effect(KILL cr);
 8990 
 8991   format %{ &quot;shrq    $dst, $shift&quot; %}
 8992   opcode(0xD1, 0x5); /* D1 /5 */
 8993   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 8994   ins_pipe(ialu_mem_imm);
 8995 %}
 8996 
 8997 // Logical Shift Right by 8-bit immediate
 8998 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
 8999 %{
 9000   match(Set dst (URShiftL dst shift));
 9001   effect(KILL cr);
 9002 
 9003   format %{ &quot;shrq    $dst, $shift&quot; %}
 9004   opcode(0xC1, 0x5); /* C1 /5 ib */
 9005   ins_encode(reg_opc_imm_wide(dst, shift));
 9006   ins_pipe(ialu_reg);
 9007 %}
 9008 
 9009 
 9010 // Logical Shift Right by 8-bit immediate
 9011 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
 9012 %{
 9013   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 9014   effect(KILL cr);
 9015 
 9016   format %{ &quot;shrq    $dst, $shift&quot; %}
 9017   opcode(0xC1, 0x5); /* C1 /5 ib */
 9018   ins_encode(REX_mem_wide(dst), OpcP,
 9019              RM_opc_mem(secondary, dst), Con8or32(shift));
 9020   ins_pipe(ialu_mem_imm);
 9021 %}
 9022 
 9023 // Logical Shift Right by variable
 9024 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
 9025 %{
 9026   match(Set dst (URShiftL dst shift));
 9027   effect(KILL cr);
 9028 
 9029   format %{ &quot;shrq    $dst, $shift&quot; %}
 9030   opcode(0xD3, 0x5); /* D3 /5 */
 9031   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9032   ins_pipe(ialu_reg_reg);
 9033 %}
 9034 
 9035 // Logical Shift Right by variable
 9036 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
 9037 %{
 9038   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
 9039   effect(KILL cr);
 9040 
 9041   format %{ &quot;shrq    $dst, $shift&quot; %}
 9042   opcode(0xD3, 0x5); /* D3 /5 */
 9043   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
 9044   ins_pipe(ialu_mem_reg);
 9045 %}
 9046 
 9047 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
 9048 // This idiom is used by the compiler for the i2b bytecode.
 9049 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
 9050 %{
 9051   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
 9052 
 9053   format %{ &quot;movsbl  $dst, $src\t# i2b&quot; %}
 9054   opcode(0x0F, 0xBE);
 9055   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9056   ins_pipe(ialu_reg_reg);
 9057 %}
 9058 
 9059 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
 9060 // This idiom is used by the compiler the i2s bytecode.
 9061 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
 9062 %{
 9063   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
 9064 
 9065   format %{ &quot;movswl  $dst, $src\t# i2s&quot; %}
 9066   opcode(0x0F, 0xBF);
 9067   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9068   ins_pipe(ialu_reg_reg);
 9069 %}
 9070 
 9071 // ROL/ROR instructions
 9072 
 9073 // ROL expand
 9074 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
 9075   effect(KILL cr, USE_DEF dst);
 9076 
 9077   format %{ &quot;roll    $dst&quot; %}
 9078   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9079   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9080   ins_pipe(ialu_reg);
 9081 %}
 9082 
 9083 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
 9084   effect(USE_DEF dst, USE shift, KILL cr);
 9085 
 9086   format %{ &quot;roll    $dst, $shift&quot; %}
 9087   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9088   ins_encode( reg_opc_imm(dst, shift) );
 9089   ins_pipe(ialu_reg);
 9090 %}
 9091 
 9092 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9093 %{
 9094   effect(USE_DEF dst, USE shift, KILL cr);
 9095 
 9096   format %{ &quot;roll    $dst, $shift&quot; %}
 9097   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9098   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9099   ins_pipe(ialu_reg_reg);
 9100 %}
 9101 // end of ROL expand
 9102 
 9103 // Rotate Left by one
 9104 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9105 %{
 9106   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9107 
 9108   expand %{
 9109     rolI_rReg_imm1(dst, cr);
 9110   %}
 9111 %}
 9112 
 9113 // Rotate Left by 8-bit immediate
 9114 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9115 %{
 9116   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9117   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
 9118 
 9119   expand %{
 9120     rolI_rReg_imm8(dst, lshift, cr);
 9121   %}
 9122 %}
 9123 
 9124 // Rotate Left by variable
 9125 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9126 %{
 9127   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
 9128 
 9129   expand %{
 9130     rolI_rReg_CL(dst, shift, cr);
 9131   %}
 9132 %}
 9133 
 9134 // Rotate Left by variable
 9135 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9136 %{
 9137   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
 9138 
 9139   expand %{
 9140     rolI_rReg_CL(dst, shift, cr);
 9141   %}
 9142 %}
 9143 
 9144 // ROR expand
 9145 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
 9146 %{
 9147   effect(USE_DEF dst, KILL cr);
 9148 
 9149   format %{ &quot;rorl    $dst&quot; %}
 9150   opcode(0xD1, 0x1); /* D1 /1 */
 9151   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9152   ins_pipe(ialu_reg);
 9153 %}
 9154 
 9155 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
 9156 %{
 9157   effect(USE_DEF dst, USE shift, KILL cr);
 9158 
 9159   format %{ &quot;rorl    $dst, $shift&quot; %}
 9160   opcode(0xC1, 0x1); /* C1 /1 ib */
 9161   ins_encode(reg_opc_imm(dst, shift));
 9162   ins_pipe(ialu_reg);
 9163 %}
 9164 
 9165 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
 9166 %{
 9167   effect(USE_DEF dst, USE shift, KILL cr);
 9168 
 9169   format %{ &quot;rorl    $dst, $shift&quot; %}
 9170   opcode(0xD3, 0x1); /* D3 /1 */
 9171   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
 9172   ins_pipe(ialu_reg_reg);
 9173 %}
 9174 // end of ROR expand
 9175 
 9176 // Rotate Right by one
 9177 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9178 %{
 9179   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9180 
 9181   expand %{
 9182     rorI_rReg_imm1(dst, cr);
 9183   %}
 9184 %}
 9185 
 9186 // Rotate Right by 8-bit immediate
 9187 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9188 %{
 9189   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9190   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
 9191 
 9192   expand %{
 9193     rorI_rReg_imm8(dst, rshift, cr);
 9194   %}
 9195 %}
 9196 
 9197 // Rotate Right by variable
 9198 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9199 %{
 9200   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
 9201 
 9202   expand %{
 9203     rorI_rReg_CL(dst, shift, cr);
 9204   %}
 9205 %}
 9206 
 9207 // Rotate Right by variable
 9208 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
 9209 %{
 9210   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
 9211 
 9212   expand %{
 9213     rorI_rReg_CL(dst, shift, cr);
 9214   %}
 9215 %}
 9216 
 9217 // for long rotate
 9218 // ROL expand
 9219 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
 9220   effect(USE_DEF dst, KILL cr);
 9221 
 9222   format %{ &quot;rolq    $dst&quot; %}
 9223   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
 9224   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9225   ins_pipe(ialu_reg);
 9226 %}
 9227 
 9228 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
 9229   effect(USE_DEF dst, USE shift, KILL cr);
 9230 
 9231   format %{ &quot;rolq    $dst, $shift&quot; %}
 9232   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
 9233   ins_encode( reg_opc_imm_wide(dst, shift) );
 9234   ins_pipe(ialu_reg);
 9235 %}
 9236 
 9237 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9238 %{
 9239   effect(USE_DEF dst, USE shift, KILL cr);
 9240 
 9241   format %{ &quot;rolq    $dst, $shift&quot; %}
 9242   opcode(0xD3, 0x0); /* Opcode D3 /0 */
 9243   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9244   ins_pipe(ialu_reg_reg);
 9245 %}
 9246 // end of ROL expand
 9247 
 9248 // Rotate Left by one
 9249 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
 9250 %{
 9251   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9252 
 9253   expand %{
 9254     rolL_rReg_imm1(dst, cr);
 9255   %}
 9256 %}
 9257 
 9258 // Rotate Left by 8-bit immediate
 9259 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
 9260 %{
 9261   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9262   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
 9263 
 9264   expand %{
 9265     rolL_rReg_imm8(dst, lshift, cr);
 9266   %}
 9267 %}
 9268 
 9269 // Rotate Left by variable
 9270 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9271 %{
 9272   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
 9273 
 9274   expand %{
 9275     rolL_rReg_CL(dst, shift, cr);
 9276   %}
 9277 %}
 9278 
 9279 // Rotate Left by variable
 9280 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9281 %{
 9282   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
 9283 
 9284   expand %{
 9285     rolL_rReg_CL(dst, shift, cr);
 9286   %}
 9287 %}
 9288 
 9289 // ROR expand
 9290 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
 9291 %{
 9292   effect(USE_DEF dst, KILL cr);
 9293 
 9294   format %{ &quot;rorq    $dst&quot; %}
 9295   opcode(0xD1, 0x1); /* D1 /1 */
 9296   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9297   ins_pipe(ialu_reg);
 9298 %}
 9299 
 9300 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
 9301 %{
 9302   effect(USE_DEF dst, USE shift, KILL cr);
 9303 
 9304   format %{ &quot;rorq    $dst, $shift&quot; %}
 9305   opcode(0xC1, 0x1); /* C1 /1 ib */
 9306   ins_encode(reg_opc_imm_wide(dst, shift));
 9307   ins_pipe(ialu_reg);
 9308 %}
 9309 
 9310 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
 9311 %{
 9312   effect(USE_DEF dst, USE shift, KILL cr);
 9313 
 9314   format %{ &quot;rorq    $dst, $shift&quot; %}
 9315   opcode(0xD3, 0x1); /* D3 /1 */
 9316   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
 9317   ins_pipe(ialu_reg_reg);
 9318 %}
 9319 // end of ROR expand
 9320 
 9321 // Rotate Right by one
 9322 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
 9323 %{
 9324   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9325 
 9326   expand %{
 9327     rorL_rReg_imm1(dst, cr);
 9328   %}
 9329 %}
 9330 
 9331 // Rotate Right by 8-bit immediate
 9332 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
 9333 %{
 9334   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
 9335   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
 9336 
 9337   expand %{
 9338     rorL_rReg_imm8(dst, rshift, cr);
 9339   %}
 9340 %}
 9341 
 9342 // Rotate Right by variable
 9343 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
 9344 %{
 9345   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
 9346 
 9347   expand %{
 9348     rorL_rReg_CL(dst, shift, cr);
 9349   %}
 9350 %}
 9351 
 9352 // Rotate Right by variable
 9353 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
 9354 %{
 9355   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
 9356 
 9357   expand %{
 9358     rorL_rReg_CL(dst, shift, cr);
 9359   %}
 9360 %}
 9361 
 9362 // Logical Instructions
 9363 
 9364 // Integer Logical Instructions
 9365 
 9366 // And Instructions
 9367 // And Register with Register
 9368 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9369 %{
 9370   match(Set dst (AndI dst src));
 9371   effect(KILL cr);
 9372 
 9373   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9374   opcode(0x23);
 9375   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9376   ins_pipe(ialu_reg_reg);
 9377 %}
 9378 
 9379 // And Register with Immediate 255
 9380 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
 9381 %{
 9382   match(Set dst (AndI dst src));
 9383 
 9384   format %{ &quot;movzbl  $dst, $dst\t# int &amp; 0xFF&quot; %}
 9385   opcode(0x0F, 0xB6);
 9386   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9387   ins_pipe(ialu_reg);
 9388 %}
 9389 
 9390 // And Register with Immediate 255 and promote to long
 9391 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
 9392 %{
 9393   match(Set dst (ConvI2L (AndI src mask)));
 9394 
 9395   format %{ &quot;movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long&quot; %}
 9396   opcode(0x0F, 0xB6);
 9397   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9398   ins_pipe(ialu_reg);
 9399 %}
 9400 
 9401 // And Register with Immediate 65535
 9402 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
 9403 %{
 9404   match(Set dst (AndI dst src));
 9405 
 9406   format %{ &quot;movzwl  $dst, $dst\t# int &amp; 0xFFFF&quot; %}
 9407   opcode(0x0F, 0xB7);
 9408   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9409   ins_pipe(ialu_reg);
 9410 %}
 9411 
 9412 // And Register with Immediate 65535 and promote to long
 9413 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
 9414 %{
 9415   match(Set dst (ConvI2L (AndI src mask)));
 9416 
 9417   format %{ &quot;movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long&quot; %}
 9418   opcode(0x0F, 0xB7);
 9419   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
 9420   ins_pipe(ialu_reg);
 9421 %}
 9422 
 9423 // And Register with Immediate
 9424 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9425 %{
 9426   match(Set dst (AndI dst src));
 9427   effect(KILL cr);
 9428 
 9429   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9430   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9431   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9432   ins_pipe(ialu_reg);
 9433 %}
 9434 
 9435 // And Register with Memory
 9436 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9437 %{
 9438   match(Set dst (AndI dst (LoadI src)));
 9439   effect(KILL cr);
 9440 
 9441   ins_cost(125);
 9442   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9443   opcode(0x23);
 9444   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9445   ins_pipe(ialu_reg_mem);
 9446 %}
 9447 
 9448 // And Memory with Register
 9449 instruct andB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9450 %{
 9451   match(Set dst (StoreB dst (AndI (LoadB dst) src)));
 9452   effect(KILL cr);
 9453 
 9454   ins_cost(150);
 9455   format %{ &quot;andb    $dst, $src\t# byte&quot; %}
 9456   opcode(0x20);
 9457   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9458   ins_pipe(ialu_mem_reg);
 9459 %}
 9460 
 9461 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9462 %{
 9463   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9464   effect(KILL cr);
 9465 
 9466   ins_cost(150);
 9467   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9468   opcode(0x21); /* Opcode 21 /r */
 9469   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9470   ins_pipe(ialu_mem_reg);
 9471 %}
 9472 
 9473 // And Memory with Immediate
 9474 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9475 %{
 9476   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
 9477   effect(KILL cr);
 9478 
 9479   ins_cost(125);
 9480   format %{ &quot;andl    $dst, $src\t# int&quot; %}
 9481   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9482   ins_encode(REX_mem(dst), OpcSE(src),
 9483              RM_opc_mem(secondary, dst), Con8or32(src));
 9484   ins_pipe(ialu_mem_imm);
 9485 %}
 9486 
 9487 // BMI1 instructions
 9488 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
 9489   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
 9490   predicate(UseBMI1Instructions);
 9491   effect(KILL cr);
 9492 
 9493   ins_cost(125);
 9494   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9495 
 9496   ins_encode %{
 9497     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
 9498   %}
 9499   ins_pipe(ialu_reg_mem);
 9500 %}
 9501 
 9502 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
 9503   match(Set dst (AndI (XorI src1 minus_1) src2));
 9504   predicate(UseBMI1Instructions);
 9505   effect(KILL cr);
 9506 
 9507   format %{ &quot;andnl  $dst, $src1, $src2&quot; %}
 9508 
 9509   ins_encode %{
 9510     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
 9511   %}
 9512   ins_pipe(ialu_reg);
 9513 %}
 9514 
 9515 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
 9516   match(Set dst (AndI (SubI imm_zero src) src));
 9517   predicate(UseBMI1Instructions);
 9518   effect(KILL cr);
 9519 
 9520   format %{ &quot;blsil  $dst, $src&quot; %}
 9521 
 9522   ins_encode %{
 9523     __ blsil($dst$$Register, $src$$Register);
 9524   %}
 9525   ins_pipe(ialu_reg);
 9526 %}
 9527 
 9528 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
 9529   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
 9530   predicate(UseBMI1Instructions);
 9531   effect(KILL cr);
 9532 
 9533   ins_cost(125);
 9534   format %{ &quot;blsil  $dst, $src&quot; %}
 9535 
 9536   ins_encode %{
 9537     __ blsil($dst$$Register, $src$$Address);
 9538   %}
 9539   ins_pipe(ialu_reg_mem);
 9540 %}
 9541 
 9542 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9543 %{
 9544   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9545   predicate(UseBMI1Instructions);
 9546   effect(KILL cr);
 9547 
 9548   ins_cost(125);
 9549   format %{ &quot;blsmskl $dst, $src&quot; %}
 9550 
 9551   ins_encode %{
 9552     __ blsmskl($dst$$Register, $src$$Address);
 9553   %}
 9554   ins_pipe(ialu_reg_mem);
 9555 %}
 9556 
 9557 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9558 %{
 9559   match(Set dst (XorI (AddI src minus_1) src));
 9560   predicate(UseBMI1Instructions);
 9561   effect(KILL cr);
 9562 
 9563   format %{ &quot;blsmskl $dst, $src&quot; %}
 9564 
 9565   ins_encode %{
 9566     __ blsmskl($dst$$Register, $src$$Register);
 9567   %}
 9568 
 9569   ins_pipe(ialu_reg);
 9570 %}
 9571 
 9572 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
 9573 %{
 9574   match(Set dst (AndI (AddI src minus_1) src) );
 9575   predicate(UseBMI1Instructions);
 9576   effect(KILL cr);
 9577 
 9578   format %{ &quot;blsrl  $dst, $src&quot; %}
 9579 
 9580   ins_encode %{
 9581     __ blsrl($dst$$Register, $src$$Register);
 9582   %}
 9583 
 9584   ins_pipe(ialu_reg_mem);
 9585 %}
 9586 
 9587 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
 9588 %{
 9589   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
 9590   predicate(UseBMI1Instructions);
 9591   effect(KILL cr);
 9592 
 9593   ins_cost(125);
 9594   format %{ &quot;blsrl  $dst, $src&quot; %}
 9595 
 9596   ins_encode %{
 9597     __ blsrl($dst$$Register, $src$$Address);
 9598   %}
 9599 
 9600   ins_pipe(ialu_reg);
 9601 %}
 9602 
 9603 // Or Instructions
 9604 // Or Register with Register
 9605 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9606 %{
 9607   match(Set dst (OrI dst src));
 9608   effect(KILL cr);
 9609 
 9610   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9611   opcode(0x0B);
 9612   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9613   ins_pipe(ialu_reg_reg);
 9614 %}
 9615 
 9616 // Or Register with Immediate
 9617 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9618 %{
 9619   match(Set dst (OrI dst src));
 9620   effect(KILL cr);
 9621 
 9622   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9623   opcode(0x81, 0x01); /* Opcode 81 /1 id */
 9624   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9625   ins_pipe(ialu_reg);
 9626 %}
 9627 
 9628 // Or Register with Memory
 9629 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9630 %{
 9631   match(Set dst (OrI dst (LoadI src)));
 9632   effect(KILL cr);
 9633 
 9634   ins_cost(125);
 9635   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9636   opcode(0x0B);
 9637   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9638   ins_pipe(ialu_reg_mem);
 9639 %}
 9640 
 9641 // Or Memory with Register
 9642 instruct orB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9643 %{
 9644   match(Set dst (StoreB dst (OrI (LoadB dst) src)));
 9645   effect(KILL cr);
 9646 
 9647   ins_cost(150);
 9648   format %{ &quot;orb    $dst, $src\t# byte&quot; %}
 9649   opcode(0x08);
 9650   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9651   ins_pipe(ialu_mem_reg);
 9652 %}
 9653 
 9654 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9655 %{
 9656   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9657   effect(KILL cr);
 9658 
 9659   ins_cost(150);
 9660   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9661   opcode(0x09); /* Opcode 09 /r */
 9662   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9663   ins_pipe(ialu_mem_reg);
 9664 %}
 9665 
 9666 // Or Memory with Immediate
 9667 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9668 %{
 9669   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
 9670   effect(KILL cr);
 9671 
 9672   ins_cost(125);
 9673   format %{ &quot;orl     $dst, $src\t# int&quot; %}
 9674   opcode(0x81, 0x1); /* Opcode 81 /1 id */
 9675   ins_encode(REX_mem(dst), OpcSE(src),
 9676              RM_opc_mem(secondary, dst), Con8or32(src));
 9677   ins_pipe(ialu_mem_imm);
 9678 %}
 9679 
 9680 // Xor Instructions
 9681 // Xor Register with Register
 9682 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
 9683 %{
 9684   match(Set dst (XorI dst src));
 9685   effect(KILL cr);
 9686 
 9687   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9688   opcode(0x33);
 9689   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
 9690   ins_pipe(ialu_reg_reg);
 9691 %}
 9692 
 9693 // Xor Register with Immediate -1
 9694 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
 9695   match(Set dst (XorI dst imm));
 9696 
 9697   format %{ &quot;not    $dst&quot; %}
 9698   ins_encode %{
 9699      __ notl($dst$$Register);
 9700   %}
 9701   ins_pipe(ialu_reg);
 9702 %}
 9703 
 9704 // Xor Register with Immediate
 9705 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
 9706 %{
 9707   match(Set dst (XorI dst src));
 9708   effect(KILL cr);
 9709 
 9710   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9711   opcode(0x81, 0x06); /* Opcode 81 /6 id */
 9712   ins_encode(OpcSErm(dst, src), Con8or32(src));
 9713   ins_pipe(ialu_reg);
 9714 %}
 9715 
 9716 // Xor Register with Memory
 9717 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
 9718 %{
 9719   match(Set dst (XorI dst (LoadI src)));
 9720   effect(KILL cr);
 9721 
 9722   ins_cost(125);
 9723   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9724   opcode(0x33);
 9725   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
 9726   ins_pipe(ialu_reg_mem);
 9727 %}
 9728 
 9729 // Xor Memory with Register
 9730 instruct xorB_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9731 %{
 9732   match(Set dst (StoreB dst (XorI (LoadB dst) src)));
 9733   effect(KILL cr);
 9734 
 9735   ins_cost(150);
 9736   format %{ &quot;xorb    $dst, $src\t# byte&quot; %}
 9737   opcode(0x30);
 9738   ins_encode(REX_breg_mem(src, dst), OpcP, reg_mem(src, dst));
 9739   ins_pipe(ialu_mem_reg);
 9740 %}
 9741 
 9742 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
 9743 %{
 9744   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9745   effect(KILL cr);
 9746 
 9747   ins_cost(150);
 9748   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9749   opcode(0x31); /* Opcode 31 /r */
 9750   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
 9751   ins_pipe(ialu_mem_reg);
 9752 %}
 9753 
 9754 // Xor Memory with Immediate
 9755 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
 9756 %{
 9757   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
 9758   effect(KILL cr);
 9759 
 9760   ins_cost(125);
 9761   format %{ &quot;xorl    $dst, $src\t# int&quot; %}
 9762   opcode(0x81, 0x6); /* Opcode 81 /6 id */
 9763   ins_encode(REX_mem(dst), OpcSE(src),
 9764              RM_opc_mem(secondary, dst), Con8or32(src));
 9765   ins_pipe(ialu_mem_imm);
 9766 %}
 9767 
 9768 
 9769 // Long Logical Instructions
 9770 
 9771 // And Instructions
 9772 // And Register with Register
 9773 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9774 %{
 9775   match(Set dst (AndL dst src));
 9776   effect(KILL cr);
 9777 
 9778   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9779   opcode(0x23);
 9780   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
 9781   ins_pipe(ialu_reg_reg);
 9782 %}
 9783 
 9784 // And Register with Immediate 255
 9785 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
 9786 %{
 9787   match(Set dst (AndL dst src));
 9788 
 9789   format %{ &quot;movzbq  $dst, $dst\t# long &amp; 0xFF&quot; %}
 9790   opcode(0x0F, 0xB6);
 9791   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9792   ins_pipe(ialu_reg);
 9793 %}
 9794 
 9795 // And Register with Immediate 65535
 9796 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
 9797 %{
 9798   match(Set dst (AndL dst src));
 9799 
 9800   format %{ &quot;movzwq  $dst, $dst\t# long &amp; 0xFFFF&quot; %}
 9801   opcode(0x0F, 0xB7);
 9802   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
 9803   ins_pipe(ialu_reg);
 9804 %}
 9805 
 9806 // And Register with Immediate
 9807 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
 9808 %{
 9809   match(Set dst (AndL dst src));
 9810   effect(KILL cr);
 9811 
 9812   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9813   opcode(0x81, 0x04); /* Opcode 81 /4 */
 9814   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
 9815   ins_pipe(ialu_reg);
 9816 %}
 9817 
 9818 // And Register with Memory
 9819 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
 9820 %{
 9821   match(Set dst (AndL dst (LoadL src)));
 9822   effect(KILL cr);
 9823 
 9824   ins_cost(125);
 9825   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9826   opcode(0x23);
 9827   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
 9828   ins_pipe(ialu_reg_mem);
 9829 %}
 9830 
 9831 // And Memory with Register
 9832 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
 9833 %{
 9834   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9835   effect(KILL cr);
 9836 
 9837   ins_cost(150);
 9838   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9839   opcode(0x21); /* Opcode 21 /r */
 9840   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
 9841   ins_pipe(ialu_mem_reg);
 9842 %}
 9843 
 9844 // And Memory with Immediate
 9845 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
 9846 %{
 9847   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
 9848   effect(KILL cr);
 9849 
 9850   ins_cost(125);
 9851   format %{ &quot;andq    $dst, $src\t# long&quot; %}
 9852   opcode(0x81, 0x4); /* Opcode 81 /4 id */
 9853   ins_encode(REX_mem_wide(dst), OpcSE(src),
 9854              RM_opc_mem(secondary, dst), Con8or32(src));
 9855   ins_pipe(ialu_mem_imm);
 9856 %}
 9857 
 9858 instruct btrL_mem_imm(memory dst, immL_NotPow2 con, rFlagsReg cr)
 9859 %{
 9860   // con should be a pure 64-bit immediate given that not(con) is a power of 2
 9861   // because AND/OR works well enough for 8/32-bit values.
 9862   predicate(log2_long(~n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 30);
 9863 
 9864   match(Set dst (StoreL dst (AndL (LoadL dst) con)));
 9865   effect(KILL cr);
 9866 
 9867   ins_cost(125);
 9868   format %{ &quot;btrq    $dst, log2(not($con))\t# long&quot; %}
 9869   ins_encode %{
 9870     __ btrq($dst$$Address, log2_long(~$con$$constant));
 9871   %}
 9872   ins_pipe(ialu_mem_imm);
 9873 %}
 9874 
 9875 // BMI1 instructions
 9876 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
 9877   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
 9878   predicate(UseBMI1Instructions);
 9879   effect(KILL cr);
 9880 
 9881   ins_cost(125);
 9882   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9883 
 9884   ins_encode %{
 9885     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
 9886   %}
 9887   ins_pipe(ialu_reg_mem);
 9888 %}
 9889 
 9890 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
 9891   match(Set dst (AndL (XorL src1 minus_1) src2));
 9892   predicate(UseBMI1Instructions);
 9893   effect(KILL cr);
 9894 
 9895   format %{ &quot;andnq  $dst, $src1, $src2&quot; %}
 9896 
 9897   ins_encode %{
 9898   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
 9899   %}
 9900   ins_pipe(ialu_reg_mem);
 9901 %}
 9902 
 9903 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
 9904   match(Set dst (AndL (SubL imm_zero src) src));
 9905   predicate(UseBMI1Instructions);
 9906   effect(KILL cr);
 9907 
 9908   format %{ &quot;blsiq  $dst, $src&quot; %}
 9909 
 9910   ins_encode %{
 9911     __ blsiq($dst$$Register, $src$$Register);
 9912   %}
 9913   ins_pipe(ialu_reg);
 9914 %}
 9915 
 9916 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
 9917   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
 9918   predicate(UseBMI1Instructions);
 9919   effect(KILL cr);
 9920 
 9921   ins_cost(125);
 9922   format %{ &quot;blsiq  $dst, $src&quot; %}
 9923 
 9924   ins_encode %{
 9925     __ blsiq($dst$$Register, $src$$Address);
 9926   %}
 9927   ins_pipe(ialu_reg_mem);
 9928 %}
 9929 
 9930 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9931 %{
 9932   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
 9933   predicate(UseBMI1Instructions);
 9934   effect(KILL cr);
 9935 
 9936   ins_cost(125);
 9937   format %{ &quot;blsmskq $dst, $src&quot; %}
 9938 
 9939   ins_encode %{
 9940     __ blsmskq($dst$$Register, $src$$Address);
 9941   %}
 9942   ins_pipe(ialu_reg_mem);
 9943 %}
 9944 
 9945 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9946 %{
 9947   match(Set dst (XorL (AddL src minus_1) src));
 9948   predicate(UseBMI1Instructions);
 9949   effect(KILL cr);
 9950 
 9951   format %{ &quot;blsmskq $dst, $src&quot; %}
 9952 
 9953   ins_encode %{
 9954     __ blsmskq($dst$$Register, $src$$Register);
 9955   %}
 9956 
 9957   ins_pipe(ialu_reg);
 9958 %}
 9959 
 9960 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
 9961 %{
 9962   match(Set dst (AndL (AddL src minus_1) src) );
 9963   predicate(UseBMI1Instructions);
 9964   effect(KILL cr);
 9965 
 9966   format %{ &quot;blsrq  $dst, $src&quot; %}
 9967 
 9968   ins_encode %{
 9969     __ blsrq($dst$$Register, $src$$Register);
 9970   %}
 9971 
 9972   ins_pipe(ialu_reg);
 9973 %}
 9974 
 9975 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
 9976 %{
 9977   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
 9978   predicate(UseBMI1Instructions);
 9979   effect(KILL cr);
 9980 
 9981   ins_cost(125);
 9982   format %{ &quot;blsrq  $dst, $src&quot; %}
 9983 
 9984   ins_encode %{
 9985     __ blsrq($dst$$Register, $src$$Address);
 9986   %}
 9987 
 9988   ins_pipe(ialu_reg);
 9989 %}
 9990 
 9991 // Or Instructions
 9992 // Or Register with Register
 9993 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
 9994 %{
 9995   match(Set dst (OrL dst src));
 9996   effect(KILL cr);
 9997 
 9998   format %{ &quot;orq     $dst, $src\t# long&quot; %}
 9999   opcode(0x0B);
10000   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10001   ins_pipe(ialu_reg_reg);
10002 %}
10003 
10004 // Use any_RegP to match R15 (TLS register) without spilling.
10005 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
10006   match(Set dst (OrL dst (CastP2X src)));
10007   effect(KILL cr);
10008 
10009   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10010   opcode(0x0B);
10011   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10012   ins_pipe(ialu_reg_reg);
10013 %}
10014 
10015 
10016 // Or Register with Immediate
10017 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10018 %{
10019   match(Set dst (OrL dst src));
10020   effect(KILL cr);
10021 
10022   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10023   opcode(0x81, 0x01); /* Opcode 81 /1 id */
10024   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10025   ins_pipe(ialu_reg);
10026 %}
10027 
10028 // Or Register with Memory
10029 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10030 %{
10031   match(Set dst (OrL dst (LoadL src)));
10032   effect(KILL cr);
10033 
10034   ins_cost(125);
10035   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10036   opcode(0x0B);
10037   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10038   ins_pipe(ialu_reg_mem);
10039 %}
10040 
10041 // Or Memory with Register
10042 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10043 %{
10044   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10045   effect(KILL cr);
10046 
10047   ins_cost(150);
10048   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10049   opcode(0x09); /* Opcode 09 /r */
10050   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10051   ins_pipe(ialu_mem_reg);
10052 %}
10053 
10054 // Or Memory with Immediate
10055 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10056 %{
10057   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
10058   effect(KILL cr);
10059 
10060   ins_cost(125);
10061   format %{ &quot;orq     $dst, $src\t# long&quot; %}
10062   opcode(0x81, 0x1); /* Opcode 81 /1 id */
10063   ins_encode(REX_mem_wide(dst), OpcSE(src),
10064              RM_opc_mem(secondary, dst), Con8or32(src));
10065   ins_pipe(ialu_mem_imm);
10066 %}
10067 
10068 instruct btsL_mem_imm(memory dst, immL_Pow2 con, rFlagsReg cr)
10069 %{
10070   // con should be a pure 64-bit power of 2 immediate
10071   // because AND/OR works well enough for 8/32-bit values.
10072   predicate(log2_long(n-&gt;in(3)-&gt;in(2)-&gt;get_long()) &gt; 31);
10073 
10074   match(Set dst (StoreL dst (OrL (LoadL dst) con)));
10075   effect(KILL cr);
10076 
10077   ins_cost(125);
10078   format %{ &quot;btsq    $dst, log2($con)\t# long&quot; %}
10079   ins_encode %{
10080     __ btsq($dst$$Address, log2_long($con$$constant));
10081   %}
10082   ins_pipe(ialu_mem_imm);
10083 %}
10084 
10085 // Xor Instructions
10086 // Xor Register with Register
10087 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
10088 %{
10089   match(Set dst (XorL dst src));
10090   effect(KILL cr);
10091 
10092   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10093   opcode(0x33);
10094   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
10095   ins_pipe(ialu_reg_reg);
10096 %}
10097 
10098 // Xor Register with Immediate -1
10099 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
10100   match(Set dst (XorL dst imm));
10101 
10102   format %{ &quot;notq   $dst&quot; %}
10103   ins_encode %{
10104      __ notq($dst$$Register);
10105   %}
10106   ins_pipe(ialu_reg);
10107 %}
10108 
10109 // Xor Register with Immediate
10110 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
10111 %{
10112   match(Set dst (XorL dst src));
10113   effect(KILL cr);
10114 
10115   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10116   opcode(0x81, 0x06); /* Opcode 81 /6 id */
10117   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
10118   ins_pipe(ialu_reg);
10119 %}
10120 
10121 // Xor Register with Memory
10122 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
10123 %{
10124   match(Set dst (XorL dst (LoadL src)));
10125   effect(KILL cr);
10126 
10127   ins_cost(125);
10128   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10129   opcode(0x33);
10130   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
10131   ins_pipe(ialu_reg_mem);
10132 %}
10133 
10134 // Xor Memory with Register
10135 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
10136 %{
10137   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10138   effect(KILL cr);
10139 
10140   ins_cost(150);
10141   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10142   opcode(0x31); /* Opcode 31 /r */
10143   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
10144   ins_pipe(ialu_mem_reg);
10145 %}
10146 
10147 // Xor Memory with Immediate
10148 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
10149 %{
10150   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
10151   effect(KILL cr);
10152 
10153   ins_cost(125);
10154   format %{ &quot;xorq    $dst, $src\t# long&quot; %}
10155   opcode(0x81, 0x6); /* Opcode 81 /6 id */
10156   ins_encode(REX_mem_wide(dst), OpcSE(src),
10157              RM_opc_mem(secondary, dst), Con8or32(src));
10158   ins_pipe(ialu_mem_imm);
10159 %}
10160 
10161 // Convert Int to Boolean
10162 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
10163 %{
10164   match(Set dst (Conv2B src));
10165   effect(KILL cr);
10166 
10167   format %{ &quot;testl   $src, $src\t# ci2b\n\t&quot;
10168             &quot;setnz   $dst\n\t&quot;
10169             &quot;movzbl  $dst, $dst&quot; %}
10170   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
10171              setNZ_reg(dst),
10172              REX_reg_breg(dst, dst), // movzbl
10173              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10174   ins_pipe(pipe_slow); // XXX
10175 %}
10176 
10177 // Convert Pointer to Boolean
10178 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
10179 %{
10180   match(Set dst (Conv2B src));
10181   effect(KILL cr);
10182 
10183   format %{ &quot;testq   $src, $src\t# cp2b\n\t&quot;
10184             &quot;setnz   $dst\n\t&quot;
10185             &quot;movzbl  $dst, $dst&quot; %}
10186   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
10187              setNZ_reg(dst),
10188              REX_reg_breg(dst, dst), // movzbl
10189              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
10190   ins_pipe(pipe_slow); // XXX
10191 %}
10192 
10193 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
10194 %{
10195   match(Set dst (CmpLTMask p q));
10196   effect(KILL cr);
10197 
10198   ins_cost(400);
10199   format %{ &quot;cmpl    $p, $q\t# cmpLTMask\n\t&quot;
10200             &quot;setlt   $dst\n\t&quot;
10201             &quot;movzbl  $dst, $dst\n\t&quot;
10202             &quot;negl    $dst&quot; %}
10203   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
10204              setLT_reg(dst),
10205              REX_reg_breg(dst, dst), // movzbl
10206              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
10207              neg_reg(dst));
10208   ins_pipe(pipe_slow);
10209 %}
10210 
10211 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
10212 %{
10213   match(Set dst (CmpLTMask dst zero));
10214   effect(KILL cr);
10215 
10216   ins_cost(100);
10217   format %{ &quot;sarl    $dst, #31\t# cmpLTMask0&quot; %}
10218   ins_encode %{
10219   __ sarl($dst$$Register, 31);
10220   %}
10221   ins_pipe(ialu_reg);
10222 %}
10223 
10224 /* Better to save a register than avoid a branch */
10225 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10226 %{
10227   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
10228   effect(KILL cr);
10229   ins_cost(300);
10230   format %{ &quot;subl    $p,$q\t# cadd_cmpLTMask\n\t&quot;
10231             &quot;jge     done\n\t&quot;
10232             &quot;addl    $p,$y\n&quot;
10233             &quot;done:   &quot; %}
10234   ins_encode %{
10235     Register Rp = $p$$Register;
10236     Register Rq = $q$$Register;
10237     Register Ry = $y$$Register;
10238     Label done;
10239     __ subl(Rp, Rq);
10240     __ jccb(Assembler::greaterEqual, done);
10241     __ addl(Rp, Ry);
10242     __ bind(done);
10243   %}
10244   ins_pipe(pipe_cmplt);
10245 %}
10246 
10247 /* Better to save a register than avoid a branch */
10248 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
10249 %{
10250   match(Set y (AndI (CmpLTMask p q) y));
10251   effect(KILL cr);
10252 
10253   ins_cost(300);
10254 
10255   format %{ &quot;cmpl    $p, $q\t# and_cmpLTMask\n\t&quot;
10256             &quot;jlt     done\n\t&quot;
10257             &quot;xorl    $y, $y\n&quot;
10258             &quot;done:   &quot; %}
10259   ins_encode %{
10260     Register Rp = $p$$Register;
10261     Register Rq = $q$$Register;
10262     Register Ry = $y$$Register;
10263     Label done;
10264     __ cmpl(Rp, Rq);
10265     __ jccb(Assembler::less, done);
10266     __ xorl(Ry, Ry);
10267     __ bind(done);
10268   %}
10269   ins_pipe(pipe_cmplt);
10270 %}
10271 
10272 
10273 //---------- FP Instructions------------------------------------------------
10274 
10275 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
10276 %{
10277   match(Set cr (CmpF src1 src2));
10278 
10279   ins_cost(145);
10280   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10281             &quot;jnp,s   exit\n\t&quot;
10282             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10283             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10284             &quot;popfq\n&quot;
10285     &quot;exit:&quot; %}
10286   ins_encode %{
10287     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10288     emit_cmpfp_fixup(_masm);
10289   %}
10290   ins_pipe(pipe_slow);
10291 %}
10292 
10293 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
10294   match(Set cr (CmpF src1 src2));
10295 
10296   ins_cost(100);
10297   format %{ &quot;ucomiss $src1, $src2&quot; %}
10298   ins_encode %{
10299     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10300   %}
10301   ins_pipe(pipe_slow);
10302 %}
10303 
10304 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
10305 %{
10306   match(Set cr (CmpF src1 (LoadF src2)));
10307 
10308   ins_cost(145);
10309   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10310             &quot;jnp,s   exit\n\t&quot;
10311             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10312             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10313             &quot;popfq\n&quot;
10314     &quot;exit:&quot; %}
10315   ins_encode %{
10316     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10317     emit_cmpfp_fixup(_masm);
10318   %}
10319   ins_pipe(pipe_slow);
10320 %}
10321 
10322 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
10323   match(Set cr (CmpF src1 (LoadF src2)));
10324 
10325   ins_cost(100);
10326   format %{ &quot;ucomiss $src1, $src2&quot; %}
10327   ins_encode %{
10328     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10329   %}
10330   ins_pipe(pipe_slow);
10331 %}
10332 
10333 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
10334   match(Set cr (CmpF src con));
10335 
10336   ins_cost(145);
10337   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10338             &quot;jnp,s   exit\n\t&quot;
10339             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10340             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10341             &quot;popfq\n&quot;
10342     &quot;exit:&quot; %}
10343   ins_encode %{
10344     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10345     emit_cmpfp_fixup(_masm);
10346   %}
10347   ins_pipe(pipe_slow);
10348 %}
10349 
10350 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
10351   match(Set cr (CmpF src con));
10352   ins_cost(100);
10353   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con&quot; %}
10354   ins_encode %{
10355     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10356   %}
10357   ins_pipe(pipe_slow);
10358 %}
10359 
10360 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
10361 %{
10362   match(Set cr (CmpD src1 src2));
10363 
10364   ins_cost(145);
10365   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10366             &quot;jnp,s   exit\n\t&quot;
10367             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10368             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10369             &quot;popfq\n&quot;
10370     &quot;exit:&quot; %}
10371   ins_encode %{
10372     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10373     emit_cmpfp_fixup(_masm);
10374   %}
10375   ins_pipe(pipe_slow);
10376 %}
10377 
10378 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
10379   match(Set cr (CmpD src1 src2));
10380 
10381   ins_cost(100);
10382   format %{ &quot;ucomisd $src1, $src2 test&quot; %}
10383   ins_encode %{
10384     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10385   %}
10386   ins_pipe(pipe_slow);
10387 %}
10388 
10389 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
10390 %{
10391   match(Set cr (CmpD src1 (LoadD src2)));
10392 
10393   ins_cost(145);
10394   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10395             &quot;jnp,s   exit\n\t&quot;
10396             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10397             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10398             &quot;popfq\n&quot;
10399     &quot;exit:&quot; %}
10400   ins_encode %{
10401     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10402     emit_cmpfp_fixup(_masm);
10403   %}
10404   ins_pipe(pipe_slow);
10405 %}
10406 
10407 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
10408   match(Set cr (CmpD src1 (LoadD src2)));
10409 
10410   ins_cost(100);
10411   format %{ &quot;ucomisd $src1, $src2&quot; %}
10412   ins_encode %{
10413     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10414   %}
10415   ins_pipe(pipe_slow);
10416 %}
10417 
10418 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
10419   match(Set cr (CmpD src con));
10420 
10421   ins_cost(145);
10422   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10423             &quot;jnp,s   exit\n\t&quot;
10424             &quot;pushfq\t# saw NaN, set CF\n\t&quot;
10425             &quot;andq    [rsp], #0xffffff2b\n\t&quot;
10426             &quot;popfq\n&quot;
10427     &quot;exit:&quot; %}
10428   ins_encode %{
10429     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10430     emit_cmpfp_fixup(_masm);
10431   %}
10432   ins_pipe(pipe_slow);
10433 %}
10434 
10435 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
10436   match(Set cr (CmpD src con));
10437   ins_cost(100);
10438   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con&quot; %}
10439   ins_encode %{
10440     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10441   %}
10442   ins_pipe(pipe_slow);
10443 %}
10444 
10445 // Compare into -1,0,1
10446 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
10447 %{
10448   match(Set dst (CmpF3 src1 src2));
10449   effect(KILL cr);
10450 
10451   ins_cost(275);
10452   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10453             &quot;movl    $dst, #-1\n\t&quot;
10454             &quot;jp,s    done\n\t&quot;
10455             &quot;jb,s    done\n\t&quot;
10456             &quot;setne   $dst\n\t&quot;
10457             &quot;movzbl  $dst, $dst\n&quot;
10458     &quot;done:&quot; %}
10459   ins_encode %{
10460     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
10461     emit_cmpfp3(_masm, $dst$$Register);
10462   %}
10463   ins_pipe(pipe_slow);
10464 %}
10465 
10466 // Compare into -1,0,1
10467 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
10468 %{
10469   match(Set dst (CmpF3 src1 (LoadF src2)));
10470   effect(KILL cr);
10471 
10472   ins_cost(275);
10473   format %{ &quot;ucomiss $src1, $src2\n\t&quot;
10474             &quot;movl    $dst, #-1\n\t&quot;
10475             &quot;jp,s    done\n\t&quot;
10476             &quot;jb,s    done\n\t&quot;
10477             &quot;setne   $dst\n\t&quot;
10478             &quot;movzbl  $dst, $dst\n&quot;
10479     &quot;done:&quot; %}
10480   ins_encode %{
10481     __ ucomiss($src1$$XMMRegister, $src2$$Address);
10482     emit_cmpfp3(_masm, $dst$$Register);
10483   %}
10484   ins_pipe(pipe_slow);
10485 %}
10486 
10487 // Compare into -1,0,1
10488 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
10489   match(Set dst (CmpF3 src con));
10490   effect(KILL cr);
10491 
10492   ins_cost(275);
10493   format %{ &quot;ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t&quot;
10494             &quot;movl    $dst, #-1\n\t&quot;
10495             &quot;jp,s    done\n\t&quot;
10496             &quot;jb,s    done\n\t&quot;
10497             &quot;setne   $dst\n\t&quot;
10498             &quot;movzbl  $dst, $dst\n&quot;
10499     &quot;done:&quot; %}
10500   ins_encode %{
10501     __ ucomiss($src$$XMMRegister, $constantaddress($con));
10502     emit_cmpfp3(_masm, $dst$$Register);
10503   %}
10504   ins_pipe(pipe_slow);
10505 %}
10506 
10507 // Compare into -1,0,1
10508 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
10509 %{
10510   match(Set dst (CmpD3 src1 src2));
10511   effect(KILL cr);
10512 
10513   ins_cost(275);
10514   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10515             &quot;movl    $dst, #-1\n\t&quot;
10516             &quot;jp,s    done\n\t&quot;
10517             &quot;jb,s    done\n\t&quot;
10518             &quot;setne   $dst\n\t&quot;
10519             &quot;movzbl  $dst, $dst\n&quot;
10520     &quot;done:&quot; %}
10521   ins_encode %{
10522     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
10523     emit_cmpfp3(_masm, $dst$$Register);
10524   %}
10525   ins_pipe(pipe_slow);
10526 %}
10527 
10528 // Compare into -1,0,1
10529 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
10530 %{
10531   match(Set dst (CmpD3 src1 (LoadD src2)));
10532   effect(KILL cr);
10533 
10534   ins_cost(275);
10535   format %{ &quot;ucomisd $src1, $src2\n\t&quot;
10536             &quot;movl    $dst, #-1\n\t&quot;
10537             &quot;jp,s    done\n\t&quot;
10538             &quot;jb,s    done\n\t&quot;
10539             &quot;setne   $dst\n\t&quot;
10540             &quot;movzbl  $dst, $dst\n&quot;
10541     &quot;done:&quot; %}
10542   ins_encode %{
10543     __ ucomisd($src1$$XMMRegister, $src2$$Address);
10544     emit_cmpfp3(_masm, $dst$$Register);
10545   %}
10546   ins_pipe(pipe_slow);
10547 %}
10548 
10549 // Compare into -1,0,1
10550 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
10551   match(Set dst (CmpD3 src con));
10552   effect(KILL cr);
10553 
10554   ins_cost(275);
10555   format %{ &quot;ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t&quot;
10556             &quot;movl    $dst, #-1\n\t&quot;
10557             &quot;jp,s    done\n\t&quot;
10558             &quot;jb,s    done\n\t&quot;
10559             &quot;setne   $dst\n\t&quot;
10560             &quot;movzbl  $dst, $dst\n&quot;
10561     &quot;done:&quot; %}
10562   ins_encode %{
10563     __ ucomisd($src$$XMMRegister, $constantaddress($con));
10564     emit_cmpfp3(_masm, $dst$$Register);
10565   %}
10566   ins_pipe(pipe_slow);
10567 %}
10568 
10569 //----------Arithmetic Conversion Instructions---------------------------------
10570 
10571 instruct convF2D_reg_reg(regD dst, regF src)
10572 %{
10573   match(Set dst (ConvF2D src));
10574 
10575   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10576   ins_encode %{
10577     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
10578   %}
10579   ins_pipe(pipe_slow); // XXX
10580 %}
10581 
10582 instruct convF2D_reg_mem(regD dst, memory src)
10583 %{
10584   match(Set dst (ConvF2D (LoadF src)));
10585 
10586   format %{ &quot;cvtss2sd $dst, $src&quot; %}
10587   ins_encode %{
10588     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
10589   %}
10590   ins_pipe(pipe_slow); // XXX
10591 %}
10592 
10593 instruct convD2F_reg_reg(regF dst, regD src)
10594 %{
10595   match(Set dst (ConvD2F src));
10596 
10597   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10598   ins_encode %{
10599     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
10600   %}
10601   ins_pipe(pipe_slow); // XXX
10602 %}
10603 
10604 instruct convD2F_reg_mem(regF dst, memory src)
10605 %{
10606   match(Set dst (ConvD2F (LoadD src)));
10607 
10608   format %{ &quot;cvtsd2ss $dst, $src&quot; %}
10609   ins_encode %{
10610     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
10611   %}
10612   ins_pipe(pipe_slow); // XXX
10613 %}
10614 
10615 // XXX do mem variants
10616 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
10617 %{
10618   match(Set dst (ConvF2I src));
10619   effect(KILL cr);
10620   format %{ &quot;convert_f2i $dst,$src&quot; %}
10621   ins_encode %{
10622     __ convert_f2i($dst$$Register, $src$$XMMRegister);
10623   %}
10624   ins_pipe(pipe_slow);
10625 %}
10626 
10627 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10628 %{
10629   match(Set dst (ConvF2L src));
10630   effect(KILL cr);
10631   format %{ &quot;convert_f2l $dst,$src&quot;%}
10632   ins_encode %{
10633     __ convert_f2l($dst$$Register, $src$$XMMRegister);
10634   %}
10635   ins_pipe(pipe_slow);
10636 %}
10637 
10638 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10639 %{
10640   match(Set dst (ConvD2I src));
10641   effect(KILL cr);
10642   format %{ &quot;convert_d2i $dst,$src&quot;%}
10643   ins_encode %{
10644     __ convert_d2i($dst$$Register, $src$$XMMRegister);
10645   %}
10646   ins_pipe(pipe_slow);
10647 %}
10648 
10649 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10650 %{
10651   match(Set dst (ConvD2L src));
10652   effect(KILL cr);
10653   format %{ &quot;convert_d2l $dst,$src&quot;%}
10654   ins_encode %{
10655     __ convert_d2l($dst$$Register, $src$$XMMRegister);
10656   %}
10657   ins_pipe(pipe_slow);
10658 %}
10659 
10660 instruct convI2F_reg_reg(regF dst, rRegI src)
10661 %{
10662   predicate(!UseXmmI2F);
10663   match(Set dst (ConvI2F src));
10664 
10665   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10666   ins_encode %{
10667     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10668   %}
10669   ins_pipe(pipe_slow); // XXX
10670 %}
10671 
10672 instruct convI2F_reg_mem(regF dst, memory src)
10673 %{
10674   match(Set dst (ConvI2F (LoadI src)));
10675 
10676   format %{ &quot;cvtsi2ssl $dst, $src\t# i2f&quot; %}
10677   ins_encode %{
10678     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10679   %}
10680   ins_pipe(pipe_slow); // XXX
10681 %}
10682 
10683 instruct convI2D_reg_reg(regD dst, rRegI src)
10684 %{
10685   predicate(!UseXmmI2D);
10686   match(Set dst (ConvI2D src));
10687 
10688   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10689   ins_encode %{
10690     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10691   %}
10692   ins_pipe(pipe_slow); // XXX
10693 %}
10694 
10695 instruct convI2D_reg_mem(regD dst, memory src)
10696 %{
10697   match(Set dst (ConvI2D (LoadI src)));
10698 
10699   format %{ &quot;cvtsi2sdl $dst, $src\t# i2d&quot; %}
10700   ins_encode %{
10701     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10702   %}
10703   ins_pipe(pipe_slow); // XXX
10704 %}
10705 
10706 instruct convXI2F_reg(regF dst, rRegI src)
10707 %{
10708   predicate(UseXmmI2F);
10709   match(Set dst (ConvI2F src));
10710 
10711   format %{ &quot;movdl $dst, $src\n\t&quot;
10712             &quot;cvtdq2psl $dst, $dst\t# i2f&quot; %}
10713   ins_encode %{
10714     __ movdl($dst$$XMMRegister, $src$$Register);
10715     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10716   %}
10717   ins_pipe(pipe_slow); // XXX
10718 %}
10719 
10720 instruct convXI2D_reg(regD dst, rRegI src)
10721 %{
10722   predicate(UseXmmI2D);
10723   match(Set dst (ConvI2D src));
10724 
10725   format %{ &quot;movdl $dst, $src\n\t&quot;
10726             &quot;cvtdq2pdl $dst, $dst\t# i2d&quot; %}
10727   ins_encode %{
10728     __ movdl($dst$$XMMRegister, $src$$Register);
10729     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10730   %}
10731   ins_pipe(pipe_slow); // XXX
10732 %}
10733 
10734 instruct convL2F_reg_reg(regF dst, rRegL src)
10735 %{
10736   match(Set dst (ConvL2F src));
10737 
10738   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10739   ins_encode %{
10740     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10741   %}
10742   ins_pipe(pipe_slow); // XXX
10743 %}
10744 
10745 instruct convL2F_reg_mem(regF dst, memory src)
10746 %{
10747   match(Set dst (ConvL2F (LoadL src)));
10748 
10749   format %{ &quot;cvtsi2ssq $dst, $src\t# l2f&quot; %}
10750   ins_encode %{
10751     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10752   %}
10753   ins_pipe(pipe_slow); // XXX
10754 %}
10755 
10756 instruct convL2D_reg_reg(regD dst, rRegL src)
10757 %{
10758   match(Set dst (ConvL2D src));
10759 
10760   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10761   ins_encode %{
10762     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10763   %}
10764   ins_pipe(pipe_slow); // XXX
10765 %}
10766 
10767 instruct convL2D_reg_mem(regD dst, memory src)
10768 %{
10769   match(Set dst (ConvL2D (LoadL src)));
10770 
10771   format %{ &quot;cvtsi2sdq $dst, $src\t# l2d&quot; %}
10772   ins_encode %{
10773     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10774   %}
10775   ins_pipe(pipe_slow); // XXX
10776 %}
10777 
10778 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10779 %{
10780   match(Set dst (ConvI2L src));
10781 
10782   ins_cost(125);
10783   format %{ &quot;movslq  $dst, $src\t# i2l&quot; %}
10784   ins_encode %{
10785     __ movslq($dst$$Register, $src$$Register);
10786   %}
10787   ins_pipe(ialu_reg_reg);
10788 %}
10789 
10790 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10791 // %{
10792 //   match(Set dst (ConvI2L src));
10793 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10794 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10795 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10796 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10797 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10798 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10799 
10800 //   format %{ &quot;movl    $dst, $src\t# unsigned i2l&quot; %}
10801 //   ins_encode(enc_copy(dst, src));
10802 // //   opcode(0x63); // needs REX.W
10803 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10804 //   ins_pipe(ialu_reg_reg);
10805 // %}
10806 
10807 // Zero-extend convert int to long
10808 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10809 %{
10810   match(Set dst (AndL (ConvI2L src) mask));
10811 
10812   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10813   ins_encode %{
10814     if ($dst$$reg != $src$$reg) {
10815       __ movl($dst$$Register, $src$$Register);
10816     }
10817   %}
10818   ins_pipe(ialu_reg_reg);
10819 %}
10820 
10821 // Zero-extend convert int to long
10822 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10823 %{
10824   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10825 
10826   format %{ &quot;movl    $dst, $src\t# i2l zero-extend\n\t&quot; %}
10827   ins_encode %{
10828     __ movl($dst$$Register, $src$$Address);
10829   %}
10830   ins_pipe(ialu_reg_mem);
10831 %}
10832 
10833 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10834 %{
10835   match(Set dst (AndL src mask));
10836 
10837   format %{ &quot;movl    $dst, $src\t# zero-extend long&quot; %}
10838   ins_encode %{
10839     __ movl($dst$$Register, $src$$Register);
10840   %}
10841   ins_pipe(ialu_reg_reg);
10842 %}
10843 
10844 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10845 %{
10846   match(Set dst (ConvL2I src));
10847 
10848   format %{ &quot;movl    $dst, $src\t# l2i&quot; %}
10849   ins_encode %{
10850     __ movl($dst$$Register, $src$$Register);
10851   %}
10852   ins_pipe(ialu_reg_reg);
10853 %}
10854 
10855 
10856 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10857   match(Set dst (MoveF2I src));
10858   effect(DEF dst, USE src);
10859 
10860   ins_cost(125);
10861   format %{ &quot;movl    $dst, $src\t# MoveF2I_stack_reg&quot; %}
10862   ins_encode %{
10863     __ movl($dst$$Register, Address(rsp, $src$$disp));
10864   %}
10865   ins_pipe(ialu_reg_mem);
10866 %}
10867 
10868 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10869   match(Set dst (MoveI2F src));
10870   effect(DEF dst, USE src);
10871 
10872   ins_cost(125);
10873   format %{ &quot;movss   $dst, $src\t# MoveI2F_stack_reg&quot; %}
10874   ins_encode %{
10875     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10876   %}
10877   ins_pipe(pipe_slow);
10878 %}
10879 
10880 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10881   match(Set dst (MoveD2L src));
10882   effect(DEF dst, USE src);
10883 
10884   ins_cost(125);
10885   format %{ &quot;movq    $dst, $src\t# MoveD2L_stack_reg&quot; %}
10886   ins_encode %{
10887     __ movq($dst$$Register, Address(rsp, $src$$disp));
10888   %}
10889   ins_pipe(ialu_reg_mem);
10890 %}
10891 
10892 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10893   predicate(!UseXmmLoadAndClearUpper);
10894   match(Set dst (MoveL2D src));
10895   effect(DEF dst, USE src);
10896 
10897   ins_cost(125);
10898   format %{ &quot;movlpd  $dst, $src\t# MoveL2D_stack_reg&quot; %}
10899   ins_encode %{
10900     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10901   %}
10902   ins_pipe(pipe_slow);
10903 %}
10904 
10905 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10906   predicate(UseXmmLoadAndClearUpper);
10907   match(Set dst (MoveL2D src));
10908   effect(DEF dst, USE src);
10909 
10910   ins_cost(125);
10911   format %{ &quot;movsd   $dst, $src\t# MoveL2D_stack_reg&quot; %}
10912   ins_encode %{
10913     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10914   %}
10915   ins_pipe(pipe_slow);
10916 %}
10917 
10918 
10919 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10920   match(Set dst (MoveF2I src));
10921   effect(DEF dst, USE src);
10922 
10923   ins_cost(95); // XXX
10924   format %{ &quot;movss   $dst, $src\t# MoveF2I_reg_stack&quot; %}
10925   ins_encode %{
10926     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10927   %}
10928   ins_pipe(pipe_slow);
10929 %}
10930 
10931 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10932   match(Set dst (MoveI2F src));
10933   effect(DEF dst, USE src);
10934 
10935   ins_cost(100);
10936   format %{ &quot;movl    $dst, $src\t# MoveI2F_reg_stack&quot; %}
10937   ins_encode %{
10938     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10939   %}
10940   ins_pipe( ialu_mem_reg );
10941 %}
10942 
10943 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10944   match(Set dst (MoveD2L src));
10945   effect(DEF dst, USE src);
10946 
10947   ins_cost(95); // XXX
10948   format %{ &quot;movsd   $dst, $src\t# MoveL2D_reg_stack&quot; %}
10949   ins_encode %{
10950     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10951   %}
10952   ins_pipe(pipe_slow);
10953 %}
10954 
10955 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10956   match(Set dst (MoveL2D src));
10957   effect(DEF dst, USE src);
10958 
10959   ins_cost(100);
10960   format %{ &quot;movq    $dst, $src\t# MoveL2D_reg_stack&quot; %}
10961   ins_encode %{
10962     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10963   %}
10964   ins_pipe(ialu_mem_reg);
10965 %}
10966 
10967 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10968   match(Set dst (MoveF2I src));
10969   effect(DEF dst, USE src);
10970   ins_cost(85);
10971   format %{ &quot;movd    $dst,$src\t# MoveF2I&quot; %}
10972   ins_encode %{
10973     __ movdl($dst$$Register, $src$$XMMRegister);
10974   %}
10975   ins_pipe( pipe_slow );
10976 %}
10977 
10978 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10979   match(Set dst (MoveD2L src));
10980   effect(DEF dst, USE src);
10981   ins_cost(85);
10982   format %{ &quot;movd    $dst,$src\t# MoveD2L&quot; %}
10983   ins_encode %{
10984     __ movdq($dst$$Register, $src$$XMMRegister);
10985   %}
10986   ins_pipe( pipe_slow );
10987 %}
10988 
10989 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10990   match(Set dst (MoveI2F src));
10991   effect(DEF dst, USE src);
10992   ins_cost(100);
10993   format %{ &quot;movd    $dst,$src\t# MoveI2F&quot; %}
10994   ins_encode %{
10995     __ movdl($dst$$XMMRegister, $src$$Register);
10996   %}
10997   ins_pipe( pipe_slow );
10998 %}
10999 
11000 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
11001   match(Set dst (MoveL2D src));
11002   effect(DEF dst, USE src);
11003   ins_cost(100);
11004   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
11005   ins_encode %{
11006      __ movdq($dst$$XMMRegister, $src$$Register);
11007   %}
11008   ins_pipe( pipe_slow );
11009 %}
11010 
11011 
11012 // =======================================================================
11013 // fast clearing of an array
11014 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11015                   Universe dummy, rFlagsReg cr)
11016 %{
11017   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());
11018   match(Set dummy (ClearArray (Binary cnt base) val));
11019   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11020 
11021   format %{ $$template
11022     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
11023     $$emit$$&quot;jg      LARGE\n\t&quot;
11024     $$emit$$&quot;dec     rcx\n\t&quot;
11025     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
11026     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
11027     $$emit$$&quot;dec     rcx\n\t&quot;
11028     $$emit$$&quot;jge     LOOP\n\t&quot;
11029     $$emit$$&quot;jmp     DONE\n\t&quot;
11030     $$emit$$&quot;# LARGE:\n\t&quot;
11031     if (UseFastStosb) {
11032        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11033        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
11034     } else if (UseXMMForObjInit) {
11035        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11036        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11037        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11038        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11039        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11040        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11041        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11042        $$emit$$&quot;add     0x40,rax\n\t&quot;
11043        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11044        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11045        $$emit$$&quot;jge     L_loop\n\t&quot;
11046        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11047        $$emit$$&quot;jl      L_tail\n\t&quot;
11048        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11049        $$emit$$&quot;add     0x20,rax\n\t&quot;
11050        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11051        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11052        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11053        $$emit$$&quot;jle     L_end\n\t&quot;
11054        $$emit$$&quot;dec     rcx\n\t&quot;
11055        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11056        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11057        $$emit$$&quot;add     0x8,rax\n\t&quot;
11058        $$emit$$&quot;dec     rcx\n\t&quot;
11059        $$emit$$&quot;jge     L_sloop\n\t&quot;
11060        $$emit$$&quot;# L_end:\n\t&quot;
11061     } else {
11062        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11063     }
11064     $$emit$$&quot;# DONE&quot;
11065   %}
11066   ins_encode %{
11067     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11068                  $tmp$$XMMRegister, false, false);
11069   %}
11070   ins_pipe(pipe_slow);
11071 %}
11072 
11073 instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11074                   Universe dummy, rFlagsReg cr)
11075 %{
11076   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());
11077   match(Set dummy (ClearArray (Binary cnt base) val));
11078   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11079 
11080   format %{ $$template
11081     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
11082     $$emit$$&quot;jg      LARGE\n\t&quot;
11083     $$emit$$&quot;dec     rcx\n\t&quot;
11084     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
11085     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
11086     $$emit$$&quot;dec     rcx\n\t&quot;
11087     $$emit$$&quot;jge     LOOP\n\t&quot;
11088     $$emit$$&quot;jmp     DONE\n\t&quot;
11089     $$emit$$&quot;# LARGE:\n\t&quot;
11090     if (UseXMMForObjInit) {
11091        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11092        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11093        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11094        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11095        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11096        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11097        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11098        $$emit$$&quot;add     0x40,rax\n\t&quot;
11099        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11100        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11101        $$emit$$&quot;jge     L_loop\n\t&quot;
11102        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11103        $$emit$$&quot;jl      L_tail\n\t&quot;
11104        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11105        $$emit$$&quot;add     0x20,rax\n\t&quot;
11106        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11107        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11108        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11109        $$emit$$&quot;jle     L_end\n\t&quot;
11110        $$emit$$&quot;dec     rcx\n\t&quot;
11111        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11112        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11113        $$emit$$&quot;add     0x8,rax\n\t&quot;
11114        $$emit$$&quot;dec     rcx\n\t&quot;
11115        $$emit$$&quot;jge     L_sloop\n\t&quot;
11116        $$emit$$&quot;# L_end:\n\t&quot;
11117     } else {
11118        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11119     }
11120     $$emit$$&quot;# DONE&quot;
11121   %}
11122   ins_encode %{
11123     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11124                  $tmp$$XMMRegister, false, true);
11125   %}
11126   ins_pipe(pipe_slow);
11127 %}
11128 
11129 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,
11130                         Universe dummy, rFlagsReg cr)
11131 %{
11132   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());
11133   match(Set dummy (ClearArray (Binary cnt base) val));
11134   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11135 
11136   format %{ $$template
11137     if (UseFastStosb) {
11138        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11139        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11140     } else if (UseXMMForObjInit) {
11141        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11142        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11143        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11144        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11145        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11146        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11147        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11148        $$emit$$&quot;add     0x40,rax\n\t&quot;
11149        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11150        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11151        $$emit$$&quot;jge     L_loop\n\t&quot;
11152        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11153        $$emit$$&quot;jl      L_tail\n\t&quot;
11154        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11155        $$emit$$&quot;add     0x20,rax\n\t&quot;
11156        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11157        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11158        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11159        $$emit$$&quot;jle     L_end\n\t&quot;
11160        $$emit$$&quot;dec     rcx\n\t&quot;
11161        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11162        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11163        $$emit$$&quot;add     0x8,rax\n\t&quot;
11164        $$emit$$&quot;dec     rcx\n\t&quot;
11165        $$emit$$&quot;jge     L_sloop\n\t&quot;
11166        $$emit$$&quot;# L_end:\n\t&quot;
11167     } else {
11168        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11169     }
11170   %}
11171   ins_encode %{
11172     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,
11173                  $tmp$$XMMRegister, true, false);
11174   %}
11175   ins_pipe(pipe_slow);
11176 %}
11177 
11178 instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val, 
11179                         Universe dummy, rFlagsReg cr)
11180 %{
11181   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());
11182   match(Set dummy (ClearArray (Binary cnt base) val));
11183   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);
11184 
11185   format %{ $$template
11186     if (UseXMMForObjInit) {
11187        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;
11188        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;
11189        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;
11190        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11191        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
11192        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11193        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;
11194        $$emit$$&quot;add     0x40,rax\n\t&quot;
11195        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11196        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11197        $$emit$$&quot;jge     L_loop\n\t&quot;
11198        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11199        $$emit$$&quot;jl      L_tail\n\t&quot;
11200        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;
11201        $$emit$$&quot;add     0x20,rax\n\t&quot;
11202        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11203        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11204        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11205        $$emit$$&quot;jle     L_end\n\t&quot;
11206        $$emit$$&quot;dec     rcx\n\t&quot;
11207        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11208        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11209        $$emit$$&quot;add     0x8,rax\n\t&quot;
11210        $$emit$$&quot;dec     rcx\n\t&quot;
11211        $$emit$$&quot;jge     L_sloop\n\t&quot;
11212        $$emit$$&quot;# L_end:\n\t&quot;
11213     } else {
11214        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11215     }
11216   %}
11217   ins_encode %{
11218     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register, 
11219                  $tmp$$XMMRegister, true, true);
11220   %}
11221   ins_pipe(pipe_slow);
11222 %}
11223 
11224 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11225                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11226 %{
11227   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11228   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11229   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11230 
11231   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11232   ins_encode %{
11233     __ string_compare($str1$$Register, $str2$$Register,
11234                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11235                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11236   %}
11237   ins_pipe( pipe_slow );
11238 %}
11239 
11240 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11241                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11242 %{
11243   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11244   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11245   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11246 
11247   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11248   ins_encode %{
11249     __ string_compare($str1$$Register, $str2$$Register,
11250                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11251                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
11252   %}
11253   ins_pipe( pipe_slow );
11254 %}
11255 
11256 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11257                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11258 %{
11259   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
11260   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11261   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11262 
11263   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11264   ins_encode %{
11265     __ string_compare($str1$$Register, $str2$$Register,
11266                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11267                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
11268   %}
11269   ins_pipe( pipe_slow );
11270 %}
11271 
11272 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
11273                           rax_RegI result, legRegD tmp1, rFlagsReg cr)
11274 %{
11275   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
11276   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11277   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11278 
11279   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11280   ins_encode %{
11281     __ string_compare($str2$$Register, $str1$$Register,
11282                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
11283                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
11284   %}
11285   ins_pipe( pipe_slow );
11286 %}
11287 
11288 // fast search of substring with known size.
11289 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11290                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11291 %{
11292   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11293   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11294   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11295 
11296   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11297   ins_encode %{
11298     int icnt2 = (int)$int_cnt2$$constant;
11299     if (icnt2 &gt;= 16) {
11300       // IndexOf for constant substrings with size &gt;= 16 elements
11301       // which don&#39;t need to be loaded through stack.
11302       __ string_indexofC8($str1$$Register, $str2$$Register,
11303                           $cnt1$$Register, $cnt2$$Register,
11304                           icnt2, $result$$Register,
11305                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11306     } else {
11307       // Small strings are loaded through stack if they cross page boundary.
11308       __ string_indexof($str1$$Register, $str2$$Register,
11309                         $cnt1$$Register, $cnt2$$Register,
11310                         icnt2, $result$$Register,
11311                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11312     }
11313   %}
11314   ins_pipe( pipe_slow );
11315 %}
11316 
11317 // fast search of substring with known size.
11318 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11319                              rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11320 %{
11321   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11322   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11323   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11324 
11325   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11326   ins_encode %{
11327     int icnt2 = (int)$int_cnt2$$constant;
11328     if (icnt2 &gt;= 8) {
11329       // IndexOf for constant substrings with size &gt;= 8 elements
11330       // which don&#39;t need to be loaded through stack.
11331       __ string_indexofC8($str1$$Register, $str2$$Register,
11332                           $cnt1$$Register, $cnt2$$Register,
11333                           icnt2, $result$$Register,
11334                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11335     } else {
11336       // Small strings are loaded through stack if they cross page boundary.
11337       __ string_indexof($str1$$Register, $str2$$Register,
11338                         $cnt1$$Register, $cnt2$$Register,
11339                         icnt2, $result$$Register,
11340                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11341     }
11342   %}
11343   ins_pipe( pipe_slow );
11344 %}
11345 
11346 // fast search of substring with known size.
11347 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
11348                               rbx_RegI result, legRegD tmp_vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
11349 %{
11350   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11351   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
11352   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
11353 
11354   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $tmp_vec, $cnt1, $cnt2, $tmp&quot; %}
11355   ins_encode %{
11356     int icnt2 = (int)$int_cnt2$$constant;
11357     if (icnt2 &gt;= 8) {
11358       // IndexOf for constant substrings with size &gt;= 8 elements
11359       // which don&#39;t need to be loaded through stack.
11360       __ string_indexofC8($str1$$Register, $str2$$Register,
11361                           $cnt1$$Register, $cnt2$$Register,
11362                           icnt2, $result$$Register,
11363                           $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11364     } else {
11365       // Small strings are loaded through stack if they cross page boundary.
11366       __ string_indexof($str1$$Register, $str2$$Register,
11367                         $cnt1$$Register, $cnt2$$Register,
11368                         icnt2, $result$$Register,
11369                         $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11370     }
11371   %}
11372   ins_pipe( pipe_slow );
11373 %}
11374 
11375 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11376                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11377 %{
11378   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
11379   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11380   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11381 
11382   format %{ &quot;String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11383   ins_encode %{
11384     __ string_indexof($str1$$Register, $str2$$Register,
11385                       $cnt1$$Register, $cnt2$$Register,
11386                       (-1), $result$$Register,
11387                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
11388   %}
11389   ins_pipe( pipe_slow );
11390 %}
11391 
11392 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11393                          rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11394 %{
11395   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
11396   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11397   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11398 
11399   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11400   ins_encode %{
11401     __ string_indexof($str1$$Register, $str2$$Register,
11402                       $cnt1$$Register, $cnt2$$Register,
11403                       (-1), $result$$Register,
11404                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
11405   %}
11406   ins_pipe( pipe_slow );
11407 %}
11408 
11409 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
11410                           rbx_RegI result, legRegD tmp_vec, rcx_RegI tmp, rFlagsReg cr)
11411 %{
11412   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
11413   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
11414   effect(TEMP tmp_vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
11415 
11416   format %{ &quot;String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all&quot; %}
11417   ins_encode %{
11418     __ string_indexof($str1$$Register, $str2$$Register,
11419                       $cnt1$$Register, $cnt2$$Register,
11420                       (-1), $result$$Register,
11421                       $tmp_vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
11422   %}
11423   ins_pipe( pipe_slow );
11424 %}
11425 
11426 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
11427                               rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)
11428 %{
11429   predicate(UseSSE42Intrinsics);
11430   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
11431   effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
11432   format %{ &quot;String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all&quot; %}
11433   ins_encode %{
11434     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
11435                            $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);
11436   %}
11437   ins_pipe( pipe_slow );
11438 %}
11439 
11440 // fast string equals
11441 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
11442                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11443 %{
11444   match(Set result (StrEquals (Binary str1 str2) cnt));
11445   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
11446 
11447   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3&quot; %}
11448   ins_encode %{
11449     __ arrays_equals(false, $str1$$Register, $str2$$Register,
11450                      $cnt$$Register, $result$$Register, $tmp3$$Register,
11451                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11452   %}
11453   ins_pipe( pipe_slow );
11454 %}
11455 
11456 // fast array equals
11457 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11458                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11459 %{
11460   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11461   match(Set result (AryEq ary1 ary2));
11462   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11463 
11464   format %{ &quot;Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11465   ins_encode %{
11466     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11467                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11468                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
11469   %}
11470   ins_pipe( pipe_slow );
11471 %}
11472 
11473 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
11474                        legRegD tmp1, legRegD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
11475 %{
11476   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
11477   match(Set result (AryEq ary1 ary2));
11478   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
11479 
11480   format %{ &quot;Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4&quot; %}
11481   ins_encode %{
11482     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
11483                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
11484                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
11485   %}
11486   ins_pipe( pipe_slow );
11487 %}
11488 
11489 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
11490                        legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr)
11491 %{
11492   match(Set result (HasNegatives ary1 len));
11493   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
11494 
11495   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3&quot; %}
11496   ins_encode %{
11497     __ has_negatives($ary1$$Register, $len$$Register,
11498                      $result$$Register, $tmp3$$Register,
11499                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
11500   %}
11501   ins_pipe( pipe_slow );
11502 %}
11503 
11504 // fast char[] to byte[] compression
11505 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11506                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11507   match(Set result (StrCompressedCopy src (Binary dst len)));
11508   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11509 
11510   format %{ &quot;String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX&quot; %}
11511   ins_encode %{
11512     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
11513                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11514                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11515   %}
11516   ins_pipe( pipe_slow );
11517 %}
11518 
11519 // fast byte[] to char[] inflation
11520 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11521                         legRegD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
11522   match(Set dummy (StrInflatedCopy src (Binary dst len)));
11523   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
11524 
11525   format %{ &quot;String Inflate $src,$dst    // KILL $tmp1, $tmp2&quot; %}
11526   ins_encode %{
11527     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
11528                           $tmp1$$XMMRegister, $tmp2$$Register);
11529   %}
11530   ins_pipe( pipe_slow );
11531 %}
11532 
11533 // encode char[] to byte[] in ISO_8859_1
11534 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
11535                           legRegD tmp1, legRegD tmp2, legRegD tmp3, legRegD tmp4,
11536                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
11537   match(Set result (EncodeISOArray src (Binary dst len)));
11538   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
11539 
11540   format %{ &quot;Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI &quot; %}
11541   ins_encode %{
11542     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
11543                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
11544                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
11545   %}
11546   ins_pipe( pipe_slow );
11547 %}
11548 
11549 //----------Overflow Math Instructions-----------------------------------------
11550 
11551 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11552 %{
11553   match(Set cr (OverflowAddI op1 op2));
11554   effect(DEF cr, USE_KILL op1, USE op2);
11555 
11556   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11557 
11558   ins_encode %{
11559     __ addl($op1$$Register, $op2$$Register);
11560   %}
11561   ins_pipe(ialu_reg_reg);
11562 %}
11563 
11564 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
11565 %{
11566   match(Set cr (OverflowAddI op1 op2));
11567   effect(DEF cr, USE_KILL op1, USE op2);
11568 
11569   format %{ &quot;addl    $op1, $op2\t# overflow check int&quot; %}
11570 
11571   ins_encode %{
11572     __ addl($op1$$Register, $op2$$constant);
11573   %}
11574   ins_pipe(ialu_reg_reg);
11575 %}
11576 
11577 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11578 %{
11579   match(Set cr (OverflowAddL op1 op2));
11580   effect(DEF cr, USE_KILL op1, USE op2);
11581 
11582   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11583   ins_encode %{
11584     __ addq($op1$$Register, $op2$$Register);
11585   %}
11586   ins_pipe(ialu_reg_reg);
11587 %}
11588 
11589 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
11590 %{
11591   match(Set cr (OverflowAddL op1 op2));
11592   effect(DEF cr, USE_KILL op1, USE op2);
11593 
11594   format %{ &quot;addq    $op1, $op2\t# overflow check long&quot; %}
11595   ins_encode %{
11596     __ addq($op1$$Register, $op2$$constant);
11597   %}
11598   ins_pipe(ialu_reg_reg);
11599 %}
11600 
11601 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11602 %{
11603   match(Set cr (OverflowSubI op1 op2));
11604 
11605   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11606   ins_encode %{
11607     __ cmpl($op1$$Register, $op2$$Register);
11608   %}
11609   ins_pipe(ialu_reg_reg);
11610 %}
11611 
11612 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11613 %{
11614   match(Set cr (OverflowSubI op1 op2));
11615 
11616   format %{ &quot;cmpl    $op1, $op2\t# overflow check int&quot; %}
11617   ins_encode %{
11618     __ cmpl($op1$$Register, $op2$$constant);
11619   %}
11620   ins_pipe(ialu_reg_reg);
11621 %}
11622 
11623 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11624 %{
11625   match(Set cr (OverflowSubL op1 op2));
11626 
11627   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11628   ins_encode %{
11629     __ cmpq($op1$$Register, $op2$$Register);
11630   %}
11631   ins_pipe(ialu_reg_reg);
11632 %}
11633 
11634 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11635 %{
11636   match(Set cr (OverflowSubL op1 op2));
11637 
11638   format %{ &quot;cmpq    $op1, $op2\t# overflow check long&quot; %}
11639   ins_encode %{
11640     __ cmpq($op1$$Register, $op2$$constant);
11641   %}
11642   ins_pipe(ialu_reg_reg);
11643 %}
11644 
11645 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
11646 %{
11647   match(Set cr (OverflowSubI zero op2));
11648   effect(DEF cr, USE_KILL op2);
11649 
11650   format %{ &quot;negl    $op2\t# overflow check int&quot; %}
11651   ins_encode %{
11652     __ negl($op2$$Register);
11653   %}
11654   ins_pipe(ialu_reg_reg);
11655 %}
11656 
11657 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
11658 %{
11659   match(Set cr (OverflowSubL zero op2));
11660   effect(DEF cr, USE_KILL op2);
11661 
11662   format %{ &quot;negq    $op2\t# overflow check long&quot; %}
11663   ins_encode %{
11664     __ negq($op2$$Register);
11665   %}
11666   ins_pipe(ialu_reg_reg);
11667 %}
11668 
11669 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
11670 %{
11671   match(Set cr (OverflowMulI op1 op2));
11672   effect(DEF cr, USE_KILL op1, USE op2);
11673 
11674   format %{ &quot;imull    $op1, $op2\t# overflow check int&quot; %}
11675   ins_encode %{
11676     __ imull($op1$$Register, $op2$$Register);
11677   %}
11678   ins_pipe(ialu_reg_reg_alu0);
11679 %}
11680 
11681 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
11682 %{
11683   match(Set cr (OverflowMulI op1 op2));
11684   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11685 
11686   format %{ &quot;imull    $tmp, $op1, $op2\t# overflow check int&quot; %}
11687   ins_encode %{
11688     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
11689   %}
11690   ins_pipe(ialu_reg_reg_alu0);
11691 %}
11692 
11693 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
11694 %{
11695   match(Set cr (OverflowMulL op1 op2));
11696   effect(DEF cr, USE_KILL op1, USE op2);
11697 
11698   format %{ &quot;imulq    $op1, $op2\t# overflow check long&quot; %}
11699   ins_encode %{
11700     __ imulq($op1$$Register, $op2$$Register);
11701   %}
11702   ins_pipe(ialu_reg_reg_alu0);
11703 %}
11704 
11705 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
11706 %{
11707   match(Set cr (OverflowMulL op1 op2));
11708   effect(DEF cr, TEMP tmp, USE op1, USE op2);
11709 
11710   format %{ &quot;imulq    $tmp, $op1, $op2\t# overflow check long&quot; %}
11711   ins_encode %{
11712     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
11713   %}
11714   ins_pipe(ialu_reg_reg_alu0);
11715 %}
11716 
11717 
11718 //----------Control Flow Instructions------------------------------------------
11719 // Signed compare Instructions
11720 
11721 // XXX more variants!!
11722 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
11723 %{
11724   match(Set cr (CmpI op1 op2));
11725   effect(DEF cr, USE op1, USE op2);
11726 
11727   format %{ &quot;cmpl    $op1, $op2&quot; %}
11728   opcode(0x3B);  /* Opcode 3B /r */
11729   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11730   ins_pipe(ialu_cr_reg_reg);
11731 %}
11732 
11733 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
11734 %{
11735   match(Set cr (CmpI op1 op2));
11736 
11737   format %{ &quot;cmpl    $op1, $op2&quot; %}
11738   opcode(0x81, 0x07); /* Opcode 81 /7 */
11739   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11740   ins_pipe(ialu_cr_reg_imm);
11741 %}
11742 
11743 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
11744 %{
11745   match(Set cr (CmpI op1 (LoadI op2)));
11746 
11747   ins_cost(500); // XXX
11748   format %{ &quot;cmpl    $op1, $op2&quot; %}
11749   opcode(0x3B); /* Opcode 3B /r */
11750   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11751   ins_pipe(ialu_cr_reg_mem);
11752 %}
11753 
11754 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11755 %{
11756   match(Set cr (CmpI src zero));
11757 
11758   format %{ &quot;testl   $src, $src&quot; %}
11759   opcode(0x85);
11760   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11761   ins_pipe(ialu_cr_reg_imm);
11762 %}
11763 
11764 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11765 %{
11766   match(Set cr (CmpI (AndI src con) zero));
11767 
11768   format %{ &quot;testl   $src, $con&quot; %}
11769   opcode(0xF7, 0x00);
11770   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11771   ins_pipe(ialu_cr_reg_imm);
11772 %}
11773 
11774 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11775 %{
11776   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11777 
11778   format %{ &quot;testl   $src, $mem&quot; %}
11779   opcode(0x85);
11780   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11781   ins_pipe(ialu_cr_reg_mem);
11782 %}
11783 
11784 // Fold array properties check
11785 instruct testI_mem_imm(rFlagsReg cr, memory mem, immI con, immI0 zero)
11786 %{
11787   match(Set cr (CmpI (AndI (CastN2I (LoadNKlass mem)) con) zero));
11788 
11789   format %{ &quot;testl   $mem, $con&quot; %}
11790   opcode(0xF7, 0x00);
11791   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(con));
11792   ins_pipe(ialu_mem_imm);
11793 %}
11794 
11795 // Clear array property bits
11796 instruct clear_property_bits(rRegN dst, memory mem, immU31 mask, rFlagsReg cr)
11797 %{
11798   match(Set dst (CastI2N (AndI (CastN2I (LoadNKlass mem)) mask)));
11799   effect(KILL cr);
11800 
11801   format %{ &quot;movl    $dst, $mem\t# clear property bits\n\t&quot;
11802             &quot;andl    $dst, $mask&quot; %}
11803   ins_encode %{
11804     __ movl($dst$$Register, $mem$$Address);
11805     __ andl($dst$$Register, $mask$$constant);
11806   %}
11807   ins_pipe(ialu_reg_mem);
11808 %}
11809 
11810 // Unsigned compare Instructions; really, same as signed except they
11811 // produce an rFlagsRegU instead of rFlagsReg.
11812 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11813 %{
11814   match(Set cr (CmpU op1 op2));
11815 
11816   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11817   opcode(0x3B); /* Opcode 3B /r */
11818   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11819   ins_pipe(ialu_cr_reg_reg);
11820 %}
11821 
11822 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11823 %{
11824   match(Set cr (CmpU op1 op2));
11825 
11826   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11827   opcode(0x81,0x07); /* Opcode 81 /7 */
11828   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11829   ins_pipe(ialu_cr_reg_imm);
11830 %}
11831 
11832 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11833 %{
11834   match(Set cr (CmpU op1 (LoadI op2)));
11835 
11836   ins_cost(500); // XXX
11837   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11838   opcode(0x3B); /* Opcode 3B /r */
11839   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11840   ins_pipe(ialu_cr_reg_mem);
11841 %}
11842 
11843 // // // Cisc-spilled version of cmpU_rReg
11844 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11845 // //%{
11846 // //  match(Set cr (CmpU (LoadI op1) op2));
11847 // //
11848 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11849 // //  ins_cost(500);
11850 // //  opcode(0x39);  /* Opcode 39 /r */
11851 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11852 // //%}
11853 
11854 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11855 %{
11856   match(Set cr (CmpU src zero));
11857 
11858   format %{ &quot;testl   $src, $src\t# unsigned&quot; %}
11859   opcode(0x85);
11860   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11861   ins_pipe(ialu_cr_reg_imm);
11862 %}
11863 
11864 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11865 %{
11866   match(Set cr (CmpP op1 op2));
11867 
11868   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11869   opcode(0x3B); /* Opcode 3B /r */
11870   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11871   ins_pipe(ialu_cr_reg_reg);
11872 %}
11873 
11874 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11875 %{
11876   match(Set cr (CmpP op1 (LoadP op2)));
11877   predicate(n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11878 
11879   ins_cost(500); // XXX
11880   format %{ &quot;cmpq    $op1, $op2\t# ptr&quot; %}
11881   opcode(0x3B); /* Opcode 3B /r */
11882   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11883   ins_pipe(ialu_cr_reg_mem);
11884 %}
11885 
11886 // // // Cisc-spilled version of cmpP_rReg
11887 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11888 // //%{
11889 // //  match(Set cr (CmpP (LoadP op1) op2));
11890 // //
11891 // //  format %{ &quot;CMPu   $op1,$op2&quot; %}
11892 // //  ins_cost(500);
11893 // //  opcode(0x39);  /* Opcode 39 /r */
11894 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11895 // //%}
11896 
11897 // XXX this is generalized by compP_rReg_mem???
11898 // Compare raw pointer (used in out-of-heap check).
11899 // Only works because non-oop pointers must be raw pointers
11900 // and raw pointers have no anti-dependencies.
11901 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11902 %{
11903   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none &amp;&amp;
11904             n-&gt;in(2)-&gt;as_Load()-&gt;barrier_data() == 0);
11905   match(Set cr (CmpP op1 (LoadP op2)));
11906 
11907   format %{ &quot;cmpq    $op1, $op2\t# raw ptr&quot; %}
11908   opcode(0x3B); /* Opcode 3B /r */
11909   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11910   ins_pipe(ialu_cr_reg_mem);
11911 %}
11912 
11913 // This will generate a signed flags result. This should be OK since
11914 // any compare to a zero should be eq/neq.
11915 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11916 %{
11917   match(Set cr (CmpP src zero));
11918 
11919   format %{ &quot;testq   $src, $src\t# ptr&quot; %}
11920   opcode(0x85);
11921   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11922   ins_pipe(ialu_cr_reg_imm);
11923 %}
11924 
11925 // This will generate a signed flags result. This should be OK since
11926 // any compare to a zero should be eq/neq.
11927 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11928 %{
11929   predicate((!UseCompressedOops || (CompressedOops::base() != NULL)) &amp;&amp;
11930             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11931   match(Set cr (CmpP (LoadP op) zero));
11932 
11933   ins_cost(500); // XXX
11934   format %{ &quot;testq   $op, 0xffffffffffffffff\t# ptr&quot; %}
11935   opcode(0xF7); /* Opcode F7 /0 */
11936   ins_encode(REX_mem_wide(op),
11937              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11938   ins_pipe(ialu_cr_reg_imm);
11939 %}
11940 
11941 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11942 %{
11943   predicate(UseCompressedOops &amp;&amp; (CompressedOops::base() == NULL) &amp;&amp;
11944             (CompressedKlassPointers::base() == NULL) &amp;&amp;
11945             n-&gt;in(1)-&gt;as_Load()-&gt;barrier_data() == 0);
11946   match(Set cr (CmpP (LoadP mem) zero));
11947 
11948   format %{ &quot;cmpq    R12, $mem\t# ptr (R12_heapbase==0)&quot; %}
11949   ins_encode %{
11950     __ cmpq(r12, $mem$$Address);
11951   %}
11952   ins_pipe(ialu_cr_reg_mem);
11953 %}
11954 
11955 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11956 %{
11957   match(Set cr (CmpN op1 op2));
11958 
11959   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11960   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11961   ins_pipe(ialu_cr_reg_reg);
11962 %}
11963 
11964 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11965 %{
11966   match(Set cr (CmpN src (LoadN mem)));
11967 
11968   format %{ &quot;cmpl    $src, $mem\t# compressed ptr&quot; %}
11969   ins_encode %{
11970     __ cmpl($src$$Register, $mem$$Address);
11971   %}
11972   ins_pipe(ialu_cr_reg_mem);
11973 %}
11974 
11975 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11976   match(Set cr (CmpN op1 op2));
11977 
11978   format %{ &quot;cmpl    $op1, $op2\t# compressed ptr&quot; %}
11979   ins_encode %{
11980     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11981   %}
11982   ins_pipe(ialu_cr_reg_imm);
11983 %}
11984 
11985 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11986 %{
11987   match(Set cr (CmpN src (LoadN mem)));
11988 
11989   format %{ &quot;cmpl    $mem, $src\t# compressed ptr&quot; %}
11990   ins_encode %{
11991     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11992   %}
11993   ins_pipe(ialu_cr_reg_mem);
11994 %}
11995 
11996 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11997   match(Set cr (CmpN op1 op2));
11998 
11999   format %{ &quot;cmpl    $op1, $op2\t# compressed klass ptr&quot; %}
12000   ins_encode %{
12001     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
12002   %}
12003   ins_pipe(ialu_cr_reg_imm);
12004 %}
12005 
12006 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
12007 %{
12008   match(Set cr (CmpN src (LoadNKlass mem)));
12009 
12010   format %{ &quot;cmpl    $mem, $src\t# compressed klass ptr&quot; %}
12011   ins_encode %{
12012     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
12013   %}
12014   ins_pipe(ialu_cr_reg_mem);
12015 %}
12016 
12017 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
12018   match(Set cr (CmpN src zero));
12019 
12020   format %{ &quot;testl   $src, $src\t# compressed ptr&quot; %}
12021   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
12022   ins_pipe(ialu_cr_reg_imm);
12023 %}
12024 
12025 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
12026 %{
12027   predicate(CompressedOops::base() != NULL);
12028   match(Set cr (CmpN (LoadN mem) zero));
12029 
12030   ins_cost(500); // XXX
12031   format %{ &quot;testl   $mem, 0xffffffff\t# compressed ptr&quot; %}
12032   ins_encode %{
12033     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
12034   %}
12035   ins_pipe(ialu_cr_reg_mem);
12036 %}
12037 
12038 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
12039 %{
12040   predicate(CompressedOops::base() == NULL &amp;&amp; (CompressedKlassPointers::base() == NULL));
12041   match(Set cr (CmpN (LoadN mem) zero));
12042 
12043   format %{ &quot;cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)&quot; %}
12044   ins_encode %{
12045     __ cmpl(r12, $mem$$Address);
12046   %}
12047   ins_pipe(ialu_cr_reg_mem);
12048 %}
12049 
12050 // Yanked all unsigned pointer compare operations.
12051 // Pointer compares are done with CmpP which is already unsigned.
12052 
12053 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
12054 %{
12055   match(Set cr (CmpL op1 op2));
12056 
12057   format %{ &quot;cmpq    $op1, $op2&quot; %}
12058   opcode(0x3B);  /* Opcode 3B /r */
12059   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12060   ins_pipe(ialu_cr_reg_reg);
12061 %}
12062 
12063 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
12064 %{
12065   match(Set cr (CmpL op1 op2));
12066 
12067   format %{ &quot;cmpq    $op1, $op2&quot; %}
12068   opcode(0x81, 0x07); /* Opcode 81 /7 */
12069   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12070   ins_pipe(ialu_cr_reg_imm);
12071 %}
12072 
12073 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
12074 %{
12075   match(Set cr (CmpL op1 (LoadL op2)));
12076 
12077   format %{ &quot;cmpq    $op1, $op2&quot; %}
12078   opcode(0x3B); /* Opcode 3B /r */
12079   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12080   ins_pipe(ialu_cr_reg_mem);
12081 %}
12082 
12083 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
12084 %{
12085   match(Set cr (CmpL src zero));
12086 
12087   format %{ &quot;testq   $src, $src&quot; %}
12088   opcode(0x85);
12089   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12090   ins_pipe(ialu_cr_reg_imm);
12091 %}
12092 
12093 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
12094 %{
12095   match(Set cr (CmpL (AndL src con) zero));
12096 
12097   format %{ &quot;testq   $src, $con\t# long&quot; %}
12098   opcode(0xF7, 0x00);
12099   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
12100   ins_pipe(ialu_cr_reg_imm);
12101 %}
12102 
12103 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
12104 %{
12105   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
12106 
12107   format %{ &quot;testq   $src, $mem&quot; %}
12108   opcode(0x85);
12109   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12110   ins_pipe(ialu_cr_reg_mem);
12111 %}
12112 
12113 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
12114 %{
12115   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
12116 
12117   format %{ &quot;testq   $src, $mem&quot; %}
12118   opcode(0x85);
12119   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12120   ins_pipe(ialu_cr_reg_mem);
12121 %}
12122 
12123 // Fold array properties check
12124 instruct testL_reg_mem3(rFlagsReg cr, memory mem, rRegL src, immL0 zero)
12125 %{
12126   match(Set cr (CmpL (AndL (CastP2X (LoadKlass mem)) src) zero));
12127 
12128   format %{ &quot;testq   $src, $mem\t# test array properties&quot; %}
12129   opcode(0x85);
12130   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12131   ins_pipe(ialu_cr_reg_mem);
12132 %}
12133 
12134 // Manifest a CmpL result in an integer register.  Very painful.
12135 // This is the test to avoid.
12136 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
12137 %{
12138   match(Set dst (CmpL3 src1 src2));
12139   effect(KILL flags);
12140 
12141   ins_cost(275); // XXX
12142   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
12143             &quot;movl    $dst, -1\n\t&quot;
12144             &quot;jl,s    done\n\t&quot;
12145             &quot;setne   $dst\n\t&quot;
12146             &quot;movzbl  $dst, $dst\n\t&quot;
12147     &quot;done:&quot; %}
12148   ins_encode(cmpl3_flag(src1, src2, dst));
12149   ins_pipe(pipe_slow);
12150 %}
12151 
12152 // Unsigned long compare Instructions; really, same as signed long except they
12153 // produce an rFlagsRegU instead of rFlagsReg.
12154 instruct compUL_rReg(rFlagsRegU cr, rRegL op1, rRegL op2)
12155 %{
12156   match(Set cr (CmpUL op1 op2));
12157 
12158   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12159   opcode(0x3B);  /* Opcode 3B /r */
12160   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
12161   ins_pipe(ialu_cr_reg_reg);
12162 %}
12163 
12164 instruct compUL_rReg_imm(rFlagsRegU cr, rRegL op1, immL32 op2)
12165 %{
12166   match(Set cr (CmpUL op1 op2));
12167 
12168   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12169   opcode(0x81, 0x07); /* Opcode 81 /7 */
12170   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
12171   ins_pipe(ialu_cr_reg_imm);
12172 %}
12173 
12174 instruct compUL_rReg_mem(rFlagsRegU cr, rRegL op1, memory op2)
12175 %{
12176   match(Set cr (CmpUL op1 (LoadL op2)));
12177 
12178   format %{ &quot;cmpq    $op1, $op2\t# unsigned&quot; %}
12179   opcode(0x3B); /* Opcode 3B /r */
12180   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
12181   ins_pipe(ialu_cr_reg_mem);
12182 %}
12183 
12184 instruct testUL_reg(rFlagsRegU cr, rRegL src, immL0 zero)
12185 %{
12186   match(Set cr (CmpUL src zero));
12187 
12188   format %{ &quot;testq   $src, $src\t# unsigned&quot; %}
12189   opcode(0x85);
12190   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
12191   ins_pipe(ialu_cr_reg_imm);
12192 %}
12193 
12194 instruct compB_mem_imm(rFlagsReg cr, memory mem, immI8 imm)
12195 %{
12196   match(Set cr (CmpI (LoadB mem) imm));
12197 
12198   ins_cost(125);
12199   format %{ &quot;cmpb    $mem, $imm&quot; %}
12200   ins_encode %{ __ cmpb($mem$$Address, $imm$$constant); %}
12201   ins_pipe(ialu_cr_reg_mem);
12202 %}
12203 
12204 instruct testUB_mem_imm(rFlagsReg cr, memory mem, immU8 imm, immI0 zero)
12205 %{
12206   match(Set cr (CmpI (AndI (LoadUB mem) imm) zero));
12207 
12208   ins_cost(125);
12209   format %{ &quot;testb   $mem, $imm\t# ubyte&quot; %}
12210   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12211   ins_pipe(ialu_cr_reg_mem);
12212 %}
12213 
12214 instruct testB_mem_imm(rFlagsReg cr, memory mem, immI8 imm, immI0 zero)
12215 %{
12216   match(Set cr (CmpI (AndI (LoadB mem) imm) zero));
12217 
12218   ins_cost(125);
12219   format %{ &quot;testb   $mem, $imm\t# byte&quot; %}
12220   ins_encode %{ __ testb($mem$$Address, $imm$$constant); %}
12221   ins_pipe(ialu_cr_reg_mem);
12222 %}
12223 
12224 //----------Max and Min--------------------------------------------------------
12225 // Min Instructions
12226 
12227 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
12228 %{
12229   effect(USE_DEF dst, USE src, USE cr);
12230 
12231   format %{ &quot;cmovlgt $dst, $src\t# min&quot; %}
12232   opcode(0x0F, 0x4F);
12233   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12234   ins_pipe(pipe_cmov_reg);
12235 %}
12236 
12237 
12238 instruct minI_rReg(rRegI dst, rRegI src)
12239 %{
12240   match(Set dst (MinI dst src));
12241 
12242   ins_cost(200);
12243   expand %{
12244     rFlagsReg cr;
12245     compI_rReg(cr, dst, src);
12246     cmovI_reg_g(dst, src, cr);
12247   %}
12248 %}
12249 
12250 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
12251 %{
12252   effect(USE_DEF dst, USE src, USE cr);
12253 
12254   format %{ &quot;cmovllt $dst, $src\t# max&quot; %}
12255   opcode(0x0F, 0x4C);
12256   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
12257   ins_pipe(pipe_cmov_reg);
12258 %}
12259 
12260 
12261 instruct maxI_rReg(rRegI dst, rRegI src)
12262 %{
12263   match(Set dst (MaxI dst src));
12264 
12265   ins_cost(200);
12266   expand %{
12267     rFlagsReg cr;
12268     compI_rReg(cr, dst, src);
12269     cmovI_reg_l(dst, src, cr);
12270   %}
12271 %}
12272 
12273 // ============================================================================
12274 // Branch Instructions
12275 
12276 // Jump Direct - Label defines a relative address from JMP+1
12277 instruct jmpDir(label labl)
12278 %{
12279   match(Goto);
12280   effect(USE labl);
12281 
12282   ins_cost(300);
12283   format %{ &quot;jmp     $labl&quot; %}
12284   size(5);
12285   ins_encode %{
12286     Label* L = $labl$$label;
12287     __ jmp(*L, false); // Always long jump
12288   %}
12289   ins_pipe(pipe_jmp);
12290 %}
12291 
12292 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12293 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
12294 %{
12295   match(If cop cr);
12296   effect(USE labl);
12297 
12298   ins_cost(300);
12299   format %{ &quot;j$cop     $labl&quot; %}
12300   size(6);
12301   ins_encode %{
12302     Label* L = $labl$$label;
12303     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12304   %}
12305   ins_pipe(pipe_jcc);
12306 %}
12307 
12308 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12309 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
12310 %{
12311   predicate(!n-&gt;has_vector_mask_set());
12312   match(CountedLoopEnd cop cr);
12313   effect(USE labl);
12314 
12315   ins_cost(300);
12316   format %{ &quot;j$cop     $labl\t# loop end&quot; %}
12317   size(6);
12318   ins_encode %{
12319     Label* L = $labl$$label;
12320     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12321   %}
12322   ins_pipe(pipe_jcc);
12323 %}
12324 
12325 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12326 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12327   predicate(!n-&gt;has_vector_mask_set());
12328   match(CountedLoopEnd cop cmp);
12329   effect(USE labl);
12330 
12331   ins_cost(300);
12332   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12333   size(6);
12334   ins_encode %{
12335     Label* L = $labl$$label;
12336     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12337   %}
12338   ins_pipe(pipe_jcc);
12339 %}
12340 
12341 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12342   predicate(!n-&gt;has_vector_mask_set());
12343   match(CountedLoopEnd cop cmp);
12344   effect(USE labl);
12345 
12346   ins_cost(200);
12347   format %{ &quot;j$cop,u   $labl\t# loop end&quot; %}
12348   size(6);
12349   ins_encode %{
12350     Label* L = $labl$$label;
12351     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12352   %}
12353   ins_pipe(pipe_jcc);
12354 %}
12355 
12356 // mask version
12357 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12358 instruct jmpLoopEnd_and_restoreMask(cmpOp cop, rFlagsReg cr, label labl)
12359 %{
12360   predicate(n-&gt;has_vector_mask_set());
12361   match(CountedLoopEnd cop cr);
12362   effect(USE labl);
12363 
12364   ins_cost(400);
12365   format %{ &quot;j$cop     $labl\t# loop end\n\t&quot;
12366             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12367   size(10);
12368   ins_encode %{
12369     Label* L = $labl$$label;
12370     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12371     __ restorevectmask();
12372   %}
12373   ins_pipe(pipe_jcc);
12374 %}
12375 
12376 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12377 instruct jmpLoopEndU_and_restoreMask(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12378   predicate(n-&gt;has_vector_mask_set());
12379   match(CountedLoopEnd cop cmp);
12380   effect(USE labl);
12381 
12382   ins_cost(400);
12383   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12384             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12385   size(10);
12386   ins_encode %{
12387     Label* L = $labl$$label;
12388     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12389     __ restorevectmask();
12390   %}
12391   ins_pipe(pipe_jcc);
12392 %}
12393 
12394 instruct jmpLoopEndUCF_and_restoreMask(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12395   predicate(n-&gt;has_vector_mask_set());
12396   match(CountedLoopEnd cop cmp);
12397   effect(USE labl);
12398 
12399   ins_cost(300);
12400   format %{ &quot;j$cop,u   $labl\t# loop end\n\t&quot;
12401             &quot;restorevectmask \t# vector mask restore for loops&quot; %}
12402   size(10);
12403   ins_encode %{
12404     Label* L = $labl$$label;
12405     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12406     __ restorevectmask();
12407   %}
12408   ins_pipe(pipe_jcc);
12409 %}
12410 
12411 // Jump Direct Conditional - using unsigned comparison
12412 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12413   match(If cop cmp);
12414   effect(USE labl);
12415 
12416   ins_cost(300);
12417   format %{ &quot;j$cop,u   $labl&quot; %}
12418   size(6);
12419   ins_encode %{
12420     Label* L = $labl$$label;
12421     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12422   %}
12423   ins_pipe(pipe_jcc);
12424 %}
12425 
12426 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12427   match(If cop cmp);
12428   effect(USE labl);
12429 
12430   ins_cost(200);
12431   format %{ &quot;j$cop,u   $labl&quot; %}
12432   size(6);
12433   ins_encode %{
12434     Label* L = $labl$$label;
12435     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
12436   %}
12437   ins_pipe(pipe_jcc);
12438 %}
12439 
12440 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12441   match(If cop cmp);
12442   effect(USE labl);
12443 
12444   ins_cost(200);
12445   format %{ $$template
12446     if ($cop$$cmpcode == Assembler::notEqual) {
12447       $$emit$$&quot;jp,u    $labl\n\t&quot;
12448       $$emit$$&quot;j$cop,u   $labl&quot;
12449     } else {
12450       $$emit$$&quot;jp,u    done\n\t&quot;
12451       $$emit$$&quot;j$cop,u   $labl\n\t&quot;
12452       $$emit$$&quot;done:&quot;
12453     }
12454   %}
12455   ins_encode %{
12456     Label* l = $labl$$label;
12457     if ($cop$$cmpcode == Assembler::notEqual) {
12458       __ jcc(Assembler::parity, *l, false);
12459       __ jcc(Assembler::notEqual, *l, false);
12460     } else if ($cop$$cmpcode == Assembler::equal) {
12461       Label done;
12462       __ jccb(Assembler::parity, done);
12463       __ jcc(Assembler::equal, *l, false);
12464       __ bind(done);
12465     } else {
12466        ShouldNotReachHere();
12467     }
12468   %}
12469   ins_pipe(pipe_jcc);
12470 %}
12471 
12472 // ============================================================================
12473 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary
12474 // superklass array for an instance of the superklass.  Set a hidden
12475 // internal cache on a hit (cache is checked with exposed code in
12476 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
12477 // encoding ALSO sets flags.
12478 
12479 instruct partialSubtypeCheck(rdi_RegP result,
12480                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12481                              rFlagsReg cr)
12482 %{
12483   match(Set result (PartialSubtypeCheck sub super));
12484   effect(KILL rcx, KILL cr);
12485 
12486   ins_cost(1100);  // slightly larger than the next version
12487   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12488             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12489             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12490             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t&quot;
12491             &quot;jne,s   miss\t\t# Missed: rdi not-zero\n\t&quot;
12492             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12493             &quot;xorq    $result, $result\t\t Hit: rdi zero\n\t&quot;
12494     &quot;miss:\t&quot; %}
12495 
12496   opcode(0x1); // Force a XOR of RDI
12497   ins_encode(enc_PartialSubtypeCheck());
12498   ins_pipe(pipe_slow);
12499 %}
12500 
12501 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
12502                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
12503                                      immP0 zero,
12504                                      rdi_RegP result)
12505 %{
12506   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
12507   effect(KILL rcx, KILL result);
12508 
12509   ins_cost(1000);
12510   format %{ &quot;movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t&quot;
12511             &quot;movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t&quot;
12512             &quot;addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t&quot;
12513             &quot;repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t&quot;
12514             &quot;jne,s   miss\t\t# Missed: flags nz\n\t&quot;
12515             &quot;movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t&quot;
12516     &quot;miss:\t&quot; %}
12517 
12518   opcode(0x0); // No need to XOR RDI
12519   ins_encode(enc_PartialSubtypeCheck());
12520   ins_pipe(pipe_slow);
12521 %}
12522 
12523 // ============================================================================
12524 // Branch Instructions -- short offset versions
12525 //
12526 // These instructions are used to replace jumps of a long offset (the default
12527 // match) with jumps of a shorter offset.  These instructions are all tagged
12528 // with the ins_short_branch attribute, which causes the ADLC to suppress the
12529 // match rules in general matching.  Instead, the ADLC generates a conversion
12530 // method in the MachNode which can be used to do in-place replacement of the
12531 // long variant with the shorter variant.  The compiler will determine if a
12532 // branch can be taken by the is_short_branch_offset() predicate in the machine
12533 // specific code section of the file.
12534 
12535 // Jump Direct - Label defines a relative address from JMP+1
12536 instruct jmpDir_short(label labl) %{
12537   match(Goto);
12538   effect(USE labl);
12539 
12540   ins_cost(300);
12541   format %{ &quot;jmp,s   $labl&quot; %}
12542   size(2);
12543   ins_encode %{
12544     Label* L = $labl$$label;
12545     __ jmpb(*L);
12546   %}
12547   ins_pipe(pipe_jmp);
12548   ins_short_branch(1);
12549 %}
12550 
12551 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12552 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
12553   match(If cop cr);
12554   effect(USE labl);
12555 
12556   ins_cost(300);
12557   format %{ &quot;j$cop,s   $labl&quot; %}
12558   size(2);
12559   ins_encode %{
12560     Label* L = $labl$$label;
12561     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12562   %}
12563   ins_pipe(pipe_jcc);
12564   ins_short_branch(1);
12565 %}
12566 
12567 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12568 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
12569   match(CountedLoopEnd cop cr);
12570   effect(USE labl);
12571 
12572   ins_cost(300);
12573   format %{ &quot;j$cop,s   $labl\t# loop end&quot; %}
12574   size(2);
12575   ins_encode %{
12576     Label* L = $labl$$label;
12577     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12578   %}
12579   ins_pipe(pipe_jcc);
12580   ins_short_branch(1);
12581 %}
12582 
12583 // Jump Direct Conditional - Label defines a relative address from Jcc+1
12584 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12585   match(CountedLoopEnd cop cmp);
12586   effect(USE labl);
12587 
12588   ins_cost(300);
12589   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12590   size(2);
12591   ins_encode %{
12592     Label* L = $labl$$label;
12593     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12594   %}
12595   ins_pipe(pipe_jcc);
12596   ins_short_branch(1);
12597 %}
12598 
12599 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12600   match(CountedLoopEnd cop cmp);
12601   effect(USE labl);
12602 
12603   ins_cost(300);
12604   format %{ &quot;j$cop,us  $labl\t# loop end&quot; %}
12605   size(2);
12606   ins_encode %{
12607     Label* L = $labl$$label;
12608     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12609   %}
12610   ins_pipe(pipe_jcc);
12611   ins_short_branch(1);
12612 %}
12613 
12614 // Jump Direct Conditional - using unsigned comparison
12615 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
12616   match(If cop cmp);
12617   effect(USE labl);
12618 
12619   ins_cost(300);
12620   format %{ &quot;j$cop,us  $labl&quot; %}
12621   size(2);
12622   ins_encode %{
12623     Label* L = $labl$$label;
12624     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12625   %}
12626   ins_pipe(pipe_jcc);
12627   ins_short_branch(1);
12628 %}
12629 
12630 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
12631   match(If cop cmp);
12632   effect(USE labl);
12633 
12634   ins_cost(300);
12635   format %{ &quot;j$cop,us  $labl&quot; %}
12636   size(2);
12637   ins_encode %{
12638     Label* L = $labl$$label;
12639     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
12640   %}
12641   ins_pipe(pipe_jcc);
12642   ins_short_branch(1);
12643 %}
12644 
12645 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
12646   match(If cop cmp);
12647   effect(USE labl);
12648 
12649   ins_cost(300);
12650   format %{ $$template
12651     if ($cop$$cmpcode == Assembler::notEqual) {
12652       $$emit$$&quot;jp,u,s  $labl\n\t&quot;
12653       $$emit$$&quot;j$cop,u,s  $labl&quot;
12654     } else {
12655       $$emit$$&quot;jp,u,s  done\n\t&quot;
12656       $$emit$$&quot;j$cop,u,s  $labl\n\t&quot;
12657       $$emit$$&quot;done:&quot;
12658     }
12659   %}
12660   size(4);
12661   ins_encode %{
12662     Label* l = $labl$$label;
12663     if ($cop$$cmpcode == Assembler::notEqual) {
12664       __ jccb(Assembler::parity, *l);
12665       __ jccb(Assembler::notEqual, *l);
12666     } else if ($cop$$cmpcode == Assembler::equal) {
12667       Label done;
12668       __ jccb(Assembler::parity, done);
12669       __ jccb(Assembler::equal, *l);
12670       __ bind(done);
12671     } else {
12672        ShouldNotReachHere();
12673     }
12674   %}
12675   ins_pipe(pipe_jcc);
12676   ins_short_branch(1);
12677 %}
12678 
12679 // ============================================================================
12680 // inlined locking and unlocking
12681 
12682 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
12683   predicate(Compile::current()-&gt;use_rtm());
12684   match(Set cr (FastLock object box));
12685   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
12686   ins_cost(300);
12687   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2&quot; %}
12688   ins_encode %{
12689     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12690                  $scr$$Register, $cx1$$Register, $cx2$$Register,
12691                  _counters, _rtm_counters, _stack_rtm_counters,
12692                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12693                  true, ra_-&gt;C-&gt;profile_rtm());
12694   %}
12695   ins_pipe(pipe_slow);
12696 %}
12697 
12698 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
12699   predicate(!Compile::current()-&gt;use_rtm());
12700   match(Set cr (FastLock object box));
12701   effect(TEMP tmp, TEMP scr, USE_KILL box);
12702   ins_cost(300);
12703   format %{ &quot;fastlock $object,$box\t! kills $box,$tmp,$scr&quot; %}
12704   ins_encode %{
12705     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
12706                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
12707   %}
12708   ins_pipe(pipe_slow);
12709 %}
12710 
12711 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
12712   match(Set cr (FastUnlock object box));
12713   effect(TEMP tmp, USE_KILL box);
12714   ins_cost(300);
12715   format %{ &quot;fastunlock $object,$box\t! kills $box,$tmp&quot; %}
12716   ins_encode %{
12717     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
12718   %}
12719   ins_pipe(pipe_slow);
12720 %}
12721 
12722 
12723 // ============================================================================
12724 // Safepoint Instructions
12725 instruct safePoint_poll(rFlagsReg cr)
12726 %{
12727   predicate(!Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12728   match(SafePoint);
12729   effect(KILL cr);
12730 
12731   format %{ &quot;testl   rax, [rip + #offset_to_poll_page]\t&quot;
12732             &quot;# Safepoint: poll for GC&quot; %}
12733   ins_cost(125);
12734   ins_encode %{
12735     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
12736     __ testl(rax, addr);
12737   %}
12738   ins_pipe(ialu_reg_mem);
12739 %}
12740 
12741 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
12742 %{
12743   predicate(Assembler::is_polling_page_far() &amp;&amp; SafepointMechanism::uses_global_page_poll());
12744   match(SafePoint poll);
12745   effect(KILL cr, USE poll);
12746 
12747   format %{ &quot;testl   rax, [$poll]\t&quot;
12748             &quot;# Safepoint: poll for GC&quot; %}
12749   ins_cost(125);
12750   ins_encode %{
12751     __ relocate(relocInfo::poll_type);
12752     __ testl(rax, Address($poll$$Register, 0));
12753   %}
12754   ins_pipe(ialu_reg_mem);
12755 %}
12756 
12757 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
12758 %{
12759   predicate(SafepointMechanism::uses_thread_local_poll());
12760   match(SafePoint poll);
12761   effect(KILL cr, USE poll);
12762 
12763   format %{ &quot;testl   rax, [$poll]\t&quot;
12764             &quot;# Safepoint: poll for GC&quot; %}
12765   ins_cost(125);
12766   size(4); /* setting an explicit size will cause debug builds to assert if size is incorrect */
12767   ins_encode %{
12768     __ relocate(relocInfo::poll_type);
12769     address pre_pc = __ pc();
12770     __ testl(rax, Address($poll$$Register, 0));
12771     assert(nativeInstruction_at(pre_pc)-&gt;is_safepoint_poll(), &quot;must emit test %%eax [reg]&quot;);
12772   %}
12773   ins_pipe(ialu_reg_mem);
12774 %}
12775 
12776 // ============================================================================
12777 // Procedure Call/Return Instructions
12778 // Call Java Static Instruction
12779 // Note: If this code changes, the corresponding ret_addr_offset() and
12780 //       compute_padding() functions will have to be adjusted.
12781 instruct CallStaticJavaDirect(method meth) %{
12782   match(CallStaticJava);
12783   effect(USE meth);
12784 
12785   ins_cost(300);
12786   format %{ &quot;call,static &quot; %}
12787   opcode(0xE8); /* E8 cd */
12788   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
12789   ins_pipe(pipe_slow);
12790   ins_alignment(4);
12791 %}
12792 
12793 // Call Java Dynamic Instruction
12794 // Note: If this code changes, the corresponding ret_addr_offset() and
12795 //       compute_padding() functions will have to be adjusted.
12796 instruct CallDynamicJavaDirect(method meth)
12797 %{
12798   match(CallDynamicJava);
12799   effect(USE meth);
12800 
12801   ins_cost(300);
12802   format %{ &quot;movq    rax, #Universe::non_oop_word()\n\t&quot;
12803             &quot;call,dynamic &quot; %}
12804   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
12805   ins_pipe(pipe_slow);
12806   ins_alignment(4);
12807 %}
12808 
12809 // Call Runtime Instruction
12810 instruct CallRuntimeDirect(method meth)
12811 %{
12812   match(CallRuntime);
12813   effect(USE meth);
12814 
12815   ins_cost(300);
12816   format %{ &quot;call,runtime &quot; %}
12817   ins_encode(clear_avx, Java_To_Runtime(meth));
12818   ins_pipe(pipe_slow);
12819 %}
12820 
12821 // Call runtime without safepoint
12822 instruct CallLeafDirect(method meth)
12823 %{
12824   match(CallLeaf);
12825   effect(USE meth);
12826 
12827   ins_cost(300);
12828   format %{ &quot;call_leaf,runtime &quot; %}
12829   ins_encode(clear_avx, Java_To_Runtime(meth));
12830   ins_pipe(pipe_slow);
12831 %}
12832 
12833 // Call runtime without safepoint
12834 // entry point is null, target holds the address to call
12835 instruct CallLeafNoFPInDirect(rRegP target)
12836 %{
12837   predicate(n-&gt;as_Call()-&gt;entry_point() == NULL);
12838   match(CallLeafNoFP target);
12839 
12840   ins_cost(300);
12841   format %{ &quot;call_leaf_nofp,runtime indirect &quot; %}
12842   ins_encode %{
12843      __ call($target$$Register);
12844   %}
12845 
12846   ins_pipe(pipe_slow);
12847 %}
12848 
12849 instruct CallLeafNoFPDirect(method meth)
12850 %{
12851   predicate(n-&gt;as_Call()-&gt;entry_point() != NULL);
12852   match(CallLeafNoFP);
12853   effect(USE meth);
12854 
12855   ins_cost(300);
12856   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12857   ins_encode(clear_avx, Java_To_Runtime(meth));
12858   ins_pipe(pipe_slow);
12859 %}
12860 
12861 // Return Instruction
12862 // Remove the return address &amp; jump to it.
12863 // Notice: We always emit a nop after a ret to make sure there is room
12864 // for safepoint patching
12865 instruct Ret()
12866 %{
12867   match(Return);
12868 
12869   format %{ &quot;ret&quot; %}
12870   opcode(0xC3);
12871   ins_encode(OpcP);
12872   ins_pipe(pipe_jmp);
12873 %}
12874 
12875 // Tail Call; Jump from runtime stub to Java code.
12876 // Also known as an &#39;interprocedural jump&#39;.
12877 // Target of jump will eventually return to caller.
12878 // TailJump below removes the return address.
12879 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
12880 %{
12881   match(TailCall jump_target method_oop);
12882 
12883   ins_cost(300);
12884   format %{ &quot;jmp     $jump_target\t# rbx holds method oop&quot; %}
12885   opcode(0xFF, 0x4); /* Opcode FF /4 */
12886   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
12887   ins_pipe(pipe_jmp);
12888 %}
12889 
12890 // Tail Jump; remove the return address; jump to target.
12891 // TailCall above leaves the return address around.
12892 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
12893 %{
12894   match(TailJump jump_target ex_oop);
12895 
12896   ins_cost(300);
12897   format %{ &quot;popq    rdx\t# pop return address\n\t&quot;
12898             &quot;jmp     $jump_target&quot; %}
12899   opcode(0xFF, 0x4); /* Opcode FF /4 */
12900   ins_encode(Opcode(0x5a), // popq rdx
12901              REX_reg(jump_target), OpcP, reg_opc(jump_target));
12902   ins_pipe(pipe_jmp);
12903 %}
12904 
12905 // Create exception oop: created by stack-crawling runtime code.
12906 // Created exception is now available to this handler, and is setup
12907 // just prior to jumping to this handler.  No code emitted.
12908 instruct CreateException(rax_RegP ex_oop)
12909 %{
12910   match(Set ex_oop (CreateEx));
12911 
12912   size(0);
12913   // use the following format syntax
12914   format %{ &quot;# exception oop is in rax; no code emitted&quot; %}
12915   ins_encode();
12916   ins_pipe(empty);
12917 %}
12918 
12919 // Rethrow exception:
12920 // The exception oop will come in the first argument position.
12921 // Then JUMP (not call) to the rethrow stub code.
12922 instruct RethrowException()
12923 %{
12924   match(Rethrow);
12925 
12926   // use the following format syntax
12927   format %{ &quot;jmp     rethrow_stub&quot; %}
12928   ins_encode(enc_rethrow);
12929   ins_pipe(pipe_jmp);
12930 %}
12931 
12932 // ============================================================================
12933 // This name is KNOWN by the ADLC and cannot be changed.
12934 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
12935 // for this guy.
12936 instruct tlsLoadP(r15_RegP dst) %{
12937   match(Set dst (ThreadLocal));
12938   effect(DEF dst);
12939 
12940   size(0);
12941   format %{ &quot;# TLS is in R15&quot; %}
12942   ins_encode( /*empty encoding*/ );
12943   ins_pipe(ialu_reg_reg);
12944 %}
12945 
12946 
12947 //----------PEEPHOLE RULES-----------------------------------------------------
12948 // These must follow all instruction definitions as they use the names
12949 // defined in the instructions definitions.
12950 //
12951 // peepmatch ( root_instr_name [preceding_instruction]* );
12952 //
12953 // peepconstraint %{
12954 // (instruction_number.operand_name relational_op instruction_number.operand_name
12955 //  [, ...] );
12956 // // instruction numbers are zero-based using left to right order in peepmatch
12957 //
12958 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
12959 // // provide an instruction_number.operand_name for each operand that appears
12960 // // in the replacement instruction&#39;s match rule
12961 //
12962 // ---------VM FLAGS---------------------------------------------------------
12963 //
12964 // All peephole optimizations can be turned off using -XX:-OptoPeephole
12965 //
12966 // Each peephole rule is given an identifying number starting with zero and
12967 // increasing by one in the order seen by the parser.  An individual peephole
12968 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
12969 // on the command-line.
12970 //
12971 // ---------CURRENT LIMITATIONS----------------------------------------------
12972 //
12973 // Only match adjacent instructions in same basic block
12974 // Only equality constraints
12975 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12976 // Only one replacement instruction
12977 //
12978 // ---------EXAMPLE----------------------------------------------------------
12979 //
12980 // // pertinent parts of existing instructions in architecture description
12981 // instruct movI(rRegI dst, rRegI src)
12982 // %{
12983 //   match(Set dst (CopyI src));
12984 // %}
12985 //
12986 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12987 // %{
12988 //   match(Set dst (AddI dst src));
12989 //   effect(KILL cr);
12990 // %}
12991 //
12992 // // Change (inc mov) to lea
12993 // peephole %{
12994 //   // increment preceeded by register-register move
12995 //   peepmatch ( incI_rReg movI );
12996 //   // require that the destination register of the increment
12997 //   // match the destination register of the move
12998 //   peepconstraint ( 0.dst == 1.dst );
12999 //   // construct a replacement instruction that sets
13000 //   // the destination to ( move&#39;s source register + one )
13001 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
13002 // %}
13003 //
13004 
13005 // Implementation no longer uses movX instructions since
13006 // machine-independent system no longer uses CopyX nodes.
13007 //
13008 // peephole
13009 // %{
13010 //   peepmatch (incI_rReg movI);
13011 //   peepconstraint (0.dst == 1.dst);
13012 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
13013 // %}
13014 
13015 // peephole
13016 // %{
13017 //   peepmatch (decI_rReg movI);
13018 //   peepconstraint (0.dst == 1.dst);
13019 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
13020 // %}
13021 
13022 // peephole
13023 // %{
13024 //   peepmatch (addI_rReg_imm movI);
13025 //   peepconstraint (0.dst == 1.dst);
13026 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
13027 // %}
13028 
13029 // peephole
13030 // %{
13031 //   peepmatch (incL_rReg movL);
13032 //   peepconstraint (0.dst == 1.dst);
13033 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
13034 // %}
13035 
13036 // peephole
13037 // %{
13038 //   peepmatch (decL_rReg movL);
13039 //   peepconstraint (0.dst == 1.dst);
13040 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
13041 // %}
13042 
13043 // peephole
13044 // %{
13045 //   peepmatch (addL_rReg_imm movL);
13046 //   peepconstraint (0.dst == 1.dst);
13047 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
13048 // %}
13049 
13050 // peephole
13051 // %{
13052 //   peepmatch (addP_rReg_imm movP);
13053 //   peepconstraint (0.dst == 1.dst);
13054 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
13055 // %}
13056 
13057 // // Change load of spilled value to only a spill
13058 // instruct storeI(memory mem, rRegI src)
13059 // %{
13060 //   match(Set mem (StoreI mem src));
13061 // %}
13062 //
13063 // instruct loadI(rRegI dst, memory mem)
13064 // %{
13065 //   match(Set dst (LoadI mem));
13066 // %}
13067 //
13068 
13069 peephole
13070 %{
13071   peepmatch (loadI storeI);
13072   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
13073   peepreplace (storeI(1.mem 1.mem 1.src));
13074 %}
13075 
13076 peephole
13077 %{
13078   peepmatch (loadL storeL);
13079   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
13080   peepreplace (storeL(1.mem 1.mem 1.src));
13081 %}
13082 
13083 //----------SMARTSPILL RULES---------------------------------------------------
13084 // These must follow all instruction definitions as they use the names
13085 // defined in the instructions definitions.
    </pre>
  </body>
</html>
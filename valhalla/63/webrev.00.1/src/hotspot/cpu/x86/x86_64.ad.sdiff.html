<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/x86_64.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_LinearScan.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86_64.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 
<span class="line-removed">  870   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-removed">  871   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-removed">  872 </span>
  873   if (C-&gt;clinit_barrier_on_entry()) {
  874     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  875     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  876 
  877     Label L_skip_barrier;
  878     Register klass = rscratch1;
  879 
  880     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  881     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  882 
  883     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  884 
  885     __ bind(L_skip_barrier);
  886   }
  887 
<span class="line-modified">  888   __ verified_entry(framesize, C-&gt;output()-&gt;need_stack_bang(bangsize)?bangsize:0, false, C-&gt;stub_function() != NULL);</span>






  889 
  890   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  891 
  892   if (C-&gt;has_mach_constant_base_node()) {
  893     // NOTE: We set the table base offset here because users might be
  894     // emitted before MachConstantBaseNode.
  895     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  896     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  897   }
  898 }
  899 
<span class="line-removed">  900 uint MachPrologNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed">  901 {</span>
<span class="line-removed">  902   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed">  903                               // the hard way</span>
<span class="line-removed">  904 }</span>
<span class="line-removed">  905 </span>
  906 int MachPrologNode::reloc() const
  907 {
  908   return 0; // a large enough number
  909 }
  910 
  911 //=============================================================================
  912 #ifndef PRODUCT
  913 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  914 {
  915   Compile* C = ra_-&gt;C;
  916   if (generate_vzeroupper(C)) {
  917     st-&gt;print(&quot;vzeroupper&quot;);
  918     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  919   }
  920 
  921   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  922   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  923   // Remove word for return adr already pushed
  924   // and RBP
  925   framesize -= 2*wordSize;
</pre>
<hr />
<pre>
  933   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  934     st-&gt;print(&quot;\t&quot;);
  935     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  936                  &quot;testl   rax, [rscratch1]\t&quot;
  937                  &quot;# Safepoint: poll for GC&quot;);
  938   }
  939 }
  940 #endif
  941 
  942 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  943 {
  944   Compile* C = ra_-&gt;C;
  945   MacroAssembler _masm(&amp;cbuf);
  946 
  947   if (generate_vzeroupper(C)) {
  948     // Clear upper bits of YMM registers when current compiled code uses
  949     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  950     __ vzeroupper();
  951   }
  952 
<span class="line-modified">  953   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  954   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);</span>
<span class="line-modified">  955   // Remove word for return adr already pushed</span>
<span class="line-removed">  956   // and RBP</span>
<span class="line-removed">  957   framesize -= 2*wordSize;</span>
<span class="line-removed">  958 </span>
<span class="line-removed">  959   // Note that VerifyStackAtCalls&#39; Majik cookie does not change the frame size popped here</span>
<span class="line-removed">  960 </span>
<span class="line-removed">  961   if (framesize) {</span>
<span class="line-removed">  962     emit_opcode(cbuf, Assembler::REX_W);</span>
<span class="line-removed">  963     if (framesize &lt; 0x80) {</span>
<span class="line-removed">  964       emit_opcode(cbuf, 0x83); // addq rsp, #framesize</span>
<span class="line-removed">  965       emit_rm(cbuf, 0x3, 0x00, RSP_enc);</span>
<span class="line-removed">  966       emit_d8(cbuf, framesize);</span>
<span class="line-removed">  967     } else {</span>
<span class="line-removed">  968       emit_opcode(cbuf, 0x81); // addq rsp, #framesize</span>
<span class="line-removed">  969       emit_rm(cbuf, 0x3, 0x00, RSP_enc);</span>
<span class="line-removed">  970       emit_d32(cbuf, framesize);</span>
<span class="line-removed">  971     }</span>
<span class="line-removed">  972   }</span>
<span class="line-removed">  973 </span>
<span class="line-removed">  974   // popq rbp</span>
<span class="line-removed">  975   emit_opcode(cbuf, 0x58 | RBP_enc);</span>
  976 
  977   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  978     __ reserved_stack_check();
  979   }
  980 
  981   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  982     MacroAssembler _masm(&amp;cbuf);
  983     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  984     __ relocate(relocInfo::poll_return_type);
  985     __ testl(rax, Address(rscratch1, 0));
  986   }
  987 }
  988 
<span class="line-removed">  989 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed">  990 {</span>
<span class="line-removed">  991   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed">  992                               // the hard way</span>
<span class="line-removed">  993 }</span>
<span class="line-removed">  994 </span>
  995 int MachEpilogNode::reloc() const
  996 {
  997   return 2; // a large enough number
  998 }
  999 
 1000 const Pipeline* MachEpilogNode::pipeline() const
 1001 {
 1002   return MachNode::pipeline_class();
 1003 }
 1004 
 1005 //=============================================================================
 1006 
 1007 enum RC {
 1008   rc_bad,
 1009   rc_int,
 1010   rc_float,
 1011   rc_stack
 1012 };
 1013 
 1014 static enum RC rc_class(OptoReg::Name reg)
</pre>
<hr />
<pre>
 1510     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1511     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1512     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1513     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1514     emit_d32(cbuf, offset);
 1515   } else {
 1516     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1517     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1518     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1519     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1520     emit_d8(cbuf, offset);
 1521   }
 1522 }
 1523 
 1524 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1525 {
 1526   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1527   return (offset &lt; 0x80) ? 5 : 8; // REX
 1528 }
 1529 




























 1530 //=============================================================================
 1531 #ifndef PRODUCT
 1532 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1533 {
 1534   if (UseCompressedClassPointers) {
 1535     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1536     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1537     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1538   } else {
 1539     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1540                  &quot;# Inline cache check&quot;);
 1541   }
 1542   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1543   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1544 }
 1545 #endif
 1546 
 1547 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1548 {
 1549   MacroAssembler masm(&amp;cbuf);
</pre>
<hr />
<pre>
 1552     masm.load_klass(rscratch1, j_rarg0);
 1553     masm.cmpptr(rax, rscratch1);
 1554   } else {
 1555     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1556   }
 1557 
 1558   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1559 
 1560   /* WARNING these NOPs are critical so that verified entry point is properly
 1561      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1562   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1563   if (OptoBreakpoint) {
 1564     // Leave space for int3
 1565     nops_cnt -= 1;
 1566   }
 1567   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1568   if (nops_cnt &gt; 0)
 1569     masm.nop(nops_cnt);
 1570 }
 1571 
<span class="line-removed"> 1572 uint MachUEPNode::size(PhaseRegAlloc* ra_) const</span>
<span class="line-removed"> 1573 {</span>
<span class="line-removed"> 1574   return MachNode::size(ra_); // too many variables; just compute it</span>
<span class="line-removed"> 1575                               // the hard way</span>
<span class="line-removed"> 1576 }</span>
<span class="line-removed"> 1577 </span>
<span class="line-removed"> 1578 </span>
 1579 //=============================================================================
 1580 
 1581 int Matcher::regnum_to_fpu_offset(int regnum)
 1582 {
 1583   return regnum - 32; // The FP registers are in the second chunk
 1584 }
 1585 
 1586 // This is UltraSparc specific, true just means we have fast l2f conversion
 1587 const bool Matcher::convL2FSupported(void) {
 1588   return true;
 1589 }
 1590 
 1591 // Is this branch offset short enough that a short branch can be used?
 1592 //
 1593 // NOTE: If the platform does not provide any short branch variants, then
 1594 //       this method should return false for offset 0.
 1595 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1596   // The passed offset is relative to address of the branch.
 1597   // On 86 a branch displacement is calculated relative to address
 1598   // of a next instruction.
</pre>
<hr />
<pre>
 3844   %}
 3845 %}
 3846 
 3847 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3848 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3849 %{
 3850   constraint(ALLOC_IN_RC(ptr_reg));
 3851   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3852   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3853 
 3854   op_cost(10);
 3855   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3856   interface(MEMORY_INTER) %{
 3857     base($reg);
 3858     index($idx);
 3859     scale($scale);
 3860     disp($off);
 3861   %}
 3862 %}
 3863 
















 3864 // Indirect Narrow Oop Plus Offset Operand
 3865 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3866 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3867 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3868   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3869   constraint(ALLOC_IN_RC(ptr_reg));
 3870   match(AddP (DecodeN reg) off);
 3871 
 3872   op_cost(10);
 3873   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3874   interface(MEMORY_INTER) %{
 3875     base(0xc); // R12
 3876     index($reg);
 3877     scale(0x3);
 3878     disp($off);
 3879   %}
 3880 %}
 3881 
 3882 // Indirect Memory Operand
 3883 operand indirectNarrow(rRegN reg)
</pre>
<hr />
<pre>
 4186     equal(0x4, &quot;e&quot;);
 4187     not_equal(0x5, &quot;ne&quot;);
 4188     less(0x2, &quot;b&quot;);
 4189     greater_equal(0x3, &quot;nb&quot;);
 4190     less_equal(0x6, &quot;be&quot;);
 4191     greater(0x7, &quot;nbe&quot;);
 4192     overflow(0x0, &quot;o&quot;);
 4193     no_overflow(0x1, &quot;no&quot;);
 4194   %}
 4195 %}
 4196 
 4197 //----------OPERAND CLASSES----------------------------------------------------
 4198 // Operand Classes are groups of operands that are used as to simplify
 4199 // instruction definitions by not requiring the AD writer to specify separate
 4200 // instructions for every form of operand when the instruction accepts
 4201 // multiple operand types with the same basic encoding and format.  The classic
 4202 // case of this is memory operands.
 4203 
 4204 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4205                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
<span class="line-modified"> 4206                indCompressedOopOffset,</span>
 4207                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4208                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4209                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4210 
 4211 //----------PIPELINE-----------------------------------------------------------
 4212 // Rules which define the behavior of the target architectures pipeline.
 4213 pipeline %{
 4214 
 4215 //----------ATTRIBUTES---------------------------------------------------------
 4216 attributes %{
 4217   variable_size_instructions;        // Fixed size instructions
 4218   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4219   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4220   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4221   instruction_fetch_units = 1;       // of 16 bytes
 4222 
 4223   // List of nop instructions
 4224   nops( MachNop );
 4225 %}
 4226 
</pre>
<hr />
<pre>
 6670   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6671   ins_encode( );
 6672   ins_pipe(empty);
 6673 %}
 6674 
 6675 //----------Move Instructions--------------------------------------------------
 6676 
 6677 instruct castX2P(rRegP dst, rRegL src)
 6678 %{
 6679   match(Set dst (CastX2P src));
 6680 
 6681   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6682   ins_encode %{
 6683     if ($dst$$reg != $src$$reg) {
 6684       __ movptr($dst$$Register, $src$$Register);
 6685     }
 6686   %}
 6687   ins_pipe(ialu_reg_reg); // XXX
 6688 %}
 6689 













 6690 instruct castP2X(rRegL dst, rRegP src)
 6691 %{
 6692   match(Set dst (CastP2X src));
 6693 
 6694   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6695   ins_encode %{
 6696     if ($dst$$reg != $src$$reg) {
 6697       __ movptr($dst$$Register, $src$$Register);
 6698     }
 6699   %}
 6700   ins_pipe(ialu_reg_reg); // XXX
 6701 %}
 6702 



























 6703 // Convert oop into int for vectors alignment masking
 6704 instruct convP2I(rRegI dst, rRegP src)
 6705 %{
 6706   match(Set dst (ConvL2I (CastP2X src)));
 6707 
 6708   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6709   ins_encode %{
 6710     __ movl($dst$$Register, $src$$Register);
 6711   %}
 6712   ins_pipe(ialu_reg_reg); // XXX
 6713 %}
 6714 
 6715 // Convert compressed oop into int for vectors alignment masking
 6716 // in case of 32bit oops (heap &lt; 4Gb).
 6717 instruct convN2I(rRegI dst, rRegN src)
 6718 %{
 6719   predicate(CompressedOops::shift() == 0);
 6720   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6721 
 6722   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
</pre>
<hr />
<pre>
10903   ins_encode %{
10904     __ movdl($dst$$XMMRegister, $src$$Register);
10905   %}
10906   ins_pipe( pipe_slow );
10907 %}
10908 
10909 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10910   match(Set dst (MoveL2D src));
10911   effect(DEF dst, USE src);
10912   ins_cost(100);
10913   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10914   ins_encode %{
10915      __ movdq($dst$$XMMRegister, $src$$Register);
10916   %}
10917   ins_pipe( pipe_slow );
10918 %}
10919 
10920 
10921 // =======================================================================
10922 // fast clearing of an array
<span class="line-modified">10923 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,</span>
10924                   Universe dummy, rFlagsReg cr)
10925 %{
<span class="line-modified">10926   predicate(!((ClearArrayNode*)n)-&gt;is_large());</span>
<span class="line-modified">10927   match(Set dummy (ClearArray cnt base));</span>
<span class="line-modified">10928   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);</span>
10929 
10930   format %{ $$template
<span class="line-removed">10931     $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
10932     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10933     $$emit$$&quot;jg      LARGE\n\t&quot;
10934     $$emit$$&quot;dec     rcx\n\t&quot;
10935     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10936     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10937     $$emit$$&quot;dec     rcx\n\t&quot;
10938     $$emit$$&quot;jge     LOOP\n\t&quot;
10939     $$emit$$&quot;jmp     DONE\n\t&quot;
10940     $$emit$$&quot;# LARGE:\n\t&quot;
10941     if (UseFastStosb) {
10942        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10943        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10944     } else if (UseXMMForObjInit) {
<span class="line-modified">10945        $$emit$$&quot;mov     rdi,rax\n\t&quot;</span>
<span class="line-modified">10946        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;</span>

10947        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10948        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">10949        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
<span class="line-modified">10950        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;</span>
10951        $$emit$$&quot;add     0x40,rax\n\t&quot;
10952        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
10953        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
10954        $$emit$$&quot;jge     L_loop\n\t&quot;
10955        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10956        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">10957        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
10958        $$emit$$&quot;add     0x20,rax\n\t&quot;
10959        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
10960        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
10961        $$emit$$&quot;add     0x4,rcx\n\t&quot;
10962        $$emit$$&quot;jle     L_end\n\t&quot;
10963        $$emit$$&quot;dec     rcx\n\t&quot;
10964        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
10965        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
10966        $$emit$$&quot;add     0x8,rax\n\t&quot;
10967        $$emit$$&quot;dec     rcx\n\t&quot;
10968        $$emit$$&quot;jge     L_sloop\n\t&quot;
10969        $$emit$$&quot;# L_end:\n\t&quot;
10970     } else {
10971        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
10972     }
10973     $$emit$$&quot;# DONE&quot;
10974   %}
10975   ins_encode %{
<span class="line-modified">10976     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,</span>
<span class="line-modified">10977                  $tmp$$XMMRegister, false);</span>
10978   %}
10979   ins_pipe(pipe_slow);
10980 %}
10981 
<span class="line-modified">10982 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegI zero,</span>
























































10983                         Universe dummy, rFlagsReg cr)
10984 %{
<span class="line-modified">10985   predicate(((ClearArrayNode*)n)-&gt;is_large());</span>
<span class="line-modified">10986   match(Set dummy (ClearArray cnt base));</span>
<span class="line-modified">10987   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL zero, KILL cr);</span>
10988 
10989   format %{ $$template
10990     if (UseFastStosb) {
<span class="line-removed">10991        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
10992        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10993        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
10994     } else if (UseXMMForObjInit) {
<span class="line-modified">10995        $$emit$$&quot;mov     rdi,rax\t# ClearArray:\n\t&quot;</span>
<span class="line-modified">10996        $$emit$$&quot;vpxor   ymm0,ymm0,ymm0\n\t&quot;</span>

10997        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10998        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">10999        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
<span class="line-modified">11000        $$emit$$&quot;vmovdqu ymm0,0x20(rax)\n\t&quot;</span>
11001        $$emit$$&quot;add     0x40,rax\n\t&quot;
11002        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11003        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11004        $$emit$$&quot;jge     L_loop\n\t&quot;
11005        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11006        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">11007        $$emit$$&quot;vmovdqu ymm0,(rax)\n\t&quot;</span>
11008        $$emit$$&quot;add     0x20,rax\n\t&quot;
11009        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11010        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11011        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11012        $$emit$$&quot;jle     L_end\n\t&quot;
11013        $$emit$$&quot;dec     rcx\n\t&quot;
11014        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11015        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11016        $$emit$$&quot;add     0x8,rax\n\t&quot;
11017        $$emit$$&quot;dec     rcx\n\t&quot;
11018        $$emit$$&quot;jge     L_sloop\n\t&quot;
11019        $$emit$$&quot;# L_end:\n\t&quot;
11020     } else {
<span class="line-removed">11021        $$emit$$&quot;xorq    rax, rax\t# ClearArray:\n\t&quot;</span>
11022        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11023     }
11024   %}
11025   ins_encode %{
<span class="line-modified">11026     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register,</span>
<span class="line-modified">11027                  $tmp$$XMMRegister, true);</span>














































11028   %}
11029   ins_pipe(pipe_slow);
11030 %}
11031 
11032 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11033                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11034 %{
11035   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11036   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11037   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11038 
11039   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11040   ins_encode %{
11041     __ string_compare($str1$$Register, $str2$$Register,
11042                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11043                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11044   %}
11045   ins_pipe( pipe_slow );
11046 %}
11047 
</pre>
<hr />
<pre>
11572 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11573 %{
11574   match(Set cr (CmpI (AndI src con) zero));
11575 
11576   format %{ &quot;testl   $src, $con&quot; %}
11577   opcode(0xF7, 0x00);
11578   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11579   ins_pipe(ialu_cr_reg_imm);
11580 %}
11581 
11582 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11583 %{
11584   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11585 
11586   format %{ &quot;testl   $src, $mem&quot; %}
11587   opcode(0x85);
11588   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11589   ins_pipe(ialu_cr_reg_mem);
11590 %}
11591 











11592 // Unsigned compare Instructions; really, same as signed except they
11593 // produce an rFlagsRegU instead of rFlagsReg.
11594 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11595 %{
11596   match(Set cr (CmpU op1 op2));
11597 
11598   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11599   opcode(0x3B); /* Opcode 3B /r */
11600   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11601   ins_pipe(ialu_cr_reg_reg);
11602 %}
11603 
11604 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11605 %{
11606   match(Set cr (CmpU op1 op2));
11607 
11608   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11609   opcode(0x81,0x07); /* Opcode 81 /7 */
11610   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11611   ins_pipe(ialu_cr_reg_imm);
</pre>
<hr />
<pre>
11885 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11886 %{
11887   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11888 
11889   format %{ &quot;testq   $src, $mem&quot; %}
11890   opcode(0x85);
11891   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11892   ins_pipe(ialu_cr_reg_mem);
11893 %}
11894 
11895 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
11896 %{
11897   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
11898 
11899   format %{ &quot;testq   $src, $mem&quot; %}
11900   opcode(0x85);
11901   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11902   ins_pipe(ialu_cr_reg_mem);
11903 %}
11904 











11905 // Manifest a CmpL result in an integer register.  Very painful.
11906 // This is the test to avoid.
11907 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11908 %{
11909   match(Set dst (CmpL3 src1 src2));
11910   effect(KILL flags);
11911 
11912   ins_cost(275); // XXX
11913   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
11914             &quot;movl    $dst, -1\n\t&quot;
11915             &quot;jl,s    done\n\t&quot;
11916             &quot;setne   $dst\n\t&quot;
11917             &quot;movzbl  $dst, $dst\n\t&quot;
11918     &quot;done:&quot; %}
11919   ins_encode(cmpl3_flag(src1, src2, dst));
11920   ins_pipe(pipe_slow);
11921 %}
11922 
11923 // Unsigned long compare Instructions; really, same as signed long except they
11924 // produce an rFlagsRegU instead of rFlagsReg.
</pre>
<hr />
<pre>
12552 
12553   ins_cost(300);
12554   format %{ &quot;call,runtime &quot; %}
12555   ins_encode(clear_avx, Java_To_Runtime(meth));
12556   ins_pipe(pipe_slow);
12557 %}
12558 
12559 // Call runtime without safepoint
12560 instruct CallLeafDirect(method meth)
12561 %{
12562   match(CallLeaf);
12563   effect(USE meth);
12564 
12565   ins_cost(300);
12566   format %{ &quot;call_leaf,runtime &quot; %}
12567   ins_encode(clear_avx, Java_To_Runtime(meth));
12568   ins_pipe(pipe_slow);
12569 %}
12570 
12571 // Call runtime without safepoint















12572 instruct CallLeafNoFPDirect(method meth)
12573 %{

12574   match(CallLeafNoFP);
12575   effect(USE meth);
12576 
12577   ins_cost(300);
12578   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12579   ins_encode(clear_avx, Java_To_Runtime(meth));
12580   ins_pipe(pipe_slow);
12581 %}
12582 
12583 // Return Instruction
12584 // Remove the return address &amp; jump to it.
12585 // Notice: We always emit a nop after a ret to make sure there is room
12586 // for safepoint patching
12587 instruct Ret()
12588 %{
12589   match(Return);
12590 
12591   format %{ &quot;ret&quot; %}
12592   opcode(0xC3);
12593   ins_encode(OpcP);
</pre>
</td>
<td>
<hr />
<pre>
  850     st-&gt;print(&quot;# stack alignment check&quot;);
  851 #endif
  852   }
  853   if (C-&gt;stub_function() != NULL &amp;&amp; BarrierSet::barrier_set()-&gt;barrier_set_nmethod() != NULL) {
  854     st-&gt;print(&quot;\n\t&quot;);
  855     st-&gt;print(&quot;cmpl    [r15_thread + #disarmed_offset], #disarmed_value\t&quot;);
  856     st-&gt;print(&quot;\n\t&quot;);
  857     st-&gt;print(&quot;je      fast_entry\t&quot;);
  858     st-&gt;print(&quot;\n\t&quot;);
  859     st-&gt;print(&quot;call    #nmethod_entry_barrier_stub\t&quot;);
  860     st-&gt;print(&quot;\n\tfast_entry:&quot;);
  861   }
  862   st-&gt;cr();
  863 }
  864 #endif
  865 
  866 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  867   Compile* C = ra_-&gt;C;
  868   MacroAssembler _masm(&amp;cbuf);
  869 



  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(VM_Version::supports_fast_class_init_checks(), &quot;sanity&quot;);
  872     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  873 
  874     Label L_skip_barrier;
  875     Register klass = rscratch1;
  876 
  877     __ mov_metadata(klass, C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ clinit_barrier(klass, r15_thread, &amp;L_skip_barrier /*L_fast_path*/);
  879 
  880     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
  881 
  882     __ bind(L_skip_barrier);
  883   }
  884 
<span class="line-modified">  885   __ verified_entry(C);</span>
<span class="line-added">  886   __ bind(*_verified_entry);</span>
<span class="line-added">  887 </span>
<span class="line-added">  888   if (C-&gt;stub_function() == NULL) {</span>
<span class="line-added">  889     BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added">  890     bs-&gt;nmethod_entry_barrier(&amp;_masm);</span>
<span class="line-added">  891   }</span>
  892 
  893   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());
  894 
  895   if (C-&gt;has_mach_constant_base_node()) {
  896     // NOTE: We set the table base offset here because users might be
  897     // emitted before MachConstantBaseNode.
  898     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();
  899     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  900   }
  901 }
  902 






  903 int MachPrologNode::reloc() const
  904 {
  905   return 0; // a large enough number
  906 }
  907 
  908 //=============================================================================
  909 #ifndef PRODUCT
  910 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
  911 {
  912   Compile* C = ra_-&gt;C;
  913   if (generate_vzeroupper(C)) {
  914     st-&gt;print(&quot;vzeroupper&quot;);
  915     st-&gt;cr(); st-&gt;print(&quot;\t&quot;);
  916   }
  917 
  918   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();
  919   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
  920   // Remove word for return adr already pushed
  921   // and RBP
  922   framesize -= 2*wordSize;
</pre>
<hr />
<pre>
  930   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  931     st-&gt;print(&quot;\t&quot;);
  932     st-&gt;print_cr(&quot;movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t&quot;
  933                  &quot;testl   rax, [rscratch1]\t&quot;
  934                  &quot;# Safepoint: poll for GC&quot;);
  935   }
  936 }
  937 #endif
  938 
  939 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
  940 {
  941   Compile* C = ra_-&gt;C;
  942   MacroAssembler _masm(&amp;cbuf);
  943 
  944   if (generate_vzeroupper(C)) {
  945     // Clear upper bits of YMM registers when current compiled code uses
  946     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
  947     __ vzeroupper();
  948   }
  949 
<span class="line-modified">  950   // Subtract two words to account for return address and rbp</span>
<span class="line-modified">  951   int initial_framesize = C-&gt;output()-&gt;frame_size_in_bytes() - 2*wordSize;</span>
<span class="line-modified">  952   __ remove_frame(initial_framesize, C-&gt;needs_stack_repair(), C-&gt;output()-&gt;sp_inc_offset());</span>




















  953 
  954   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  955     __ reserved_stack_check();
  956   }
  957 
  958   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
  959     MacroAssembler _masm(&amp;cbuf);
  960     __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
  961     __ relocate(relocInfo::poll_return_type);
  962     __ testl(rax, Address(rscratch1, 0));
  963   }
  964 }
  965 






  966 int MachEpilogNode::reloc() const
  967 {
  968   return 2; // a large enough number
  969 }
  970 
  971 const Pipeline* MachEpilogNode::pipeline() const
  972 {
  973   return MachNode::pipeline_class();
  974 }
  975 
  976 //=============================================================================
  977 
  978 enum RC {
  979   rc_bad,
  980   rc_int,
  981   rc_float,
  982   rc_stack
  983 };
  984 
  985 static enum RC rc_class(OptoReg::Name reg)
</pre>
<hr />
<pre>
 1481     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1482     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1483     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
 1484     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1485     emit_d32(cbuf, offset);
 1486   } else {
 1487     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
 1488     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
 1489     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
 1490     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
 1491     emit_d8(cbuf, offset);
 1492   }
 1493 }
 1494 
 1495 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
 1496 {
 1497   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1498   return (offset &lt; 0x80) ? 5 : 8; // REX
 1499 }
 1500 
<span class="line-added"> 1501 //=============================================================================</span>
<span class="line-added"> 1502 #ifndef PRODUCT</span>
<span class="line-added"> 1503 void MachVEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const</span>
<span class="line-added"> 1504 {</span>
<span class="line-added"> 1505   st-&gt;print_cr(&quot;MachVEPNode&quot;);</span>
<span class="line-added"> 1506 }</span>
<span class="line-added"> 1507 #endif</span>
<span class="line-added"> 1508 </span>
<span class="line-added"> 1509 void MachVEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const</span>
<span class="line-added"> 1510 {</span>
<span class="line-added"> 1511   MacroAssembler masm(&amp;cbuf);</span>
<span class="line-added"> 1512   if (!_verified) {  </span>
<span class="line-added"> 1513     uint insts_size = cbuf.insts_size();</span>
<span class="line-added"> 1514     if (UseCompressedClassPointers) {</span>
<span class="line-added"> 1515       masm.load_klass(rscratch1, j_rarg0);</span>
<span class="line-added"> 1516       masm.cmpptr(rax, rscratch1);</span>
<span class="line-added"> 1517     } else {</span>
<span class="line-added"> 1518       masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));</span>
<span class="line-added"> 1519     }</span>
<span class="line-added"> 1520     masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));</span>
<span class="line-added"> 1521   } else {</span>
<span class="line-added"> 1522     // Unpack value type args passed as oop and then jump to</span>
<span class="line-added"> 1523     // the verified entry point (skipping the unverified entry).</span>
<span class="line-added"> 1524     masm.unpack_value_args(ra_-&gt;C, _receiver_only);</span>
<span class="line-added"> 1525     masm.jmp(*_verified_entry);</span>
<span class="line-added"> 1526   }</span>
<span class="line-added"> 1527 }</span>
<span class="line-added"> 1528 </span>
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 1532 {
 1533   if (UseCompressedClassPointers) {
 1534     st-&gt;print_cr(&quot;movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass&quot;);
 1535     st-&gt;print_cr(&quot;\tdecode_klass_not_null rscratch1, rscratch1&quot;);
 1536     st-&gt;print_cr(&quot;\tcmpq    rax, rscratch1\t # Inline cache check&quot;);
 1537   } else {
 1538     st-&gt;print_cr(&quot;\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t&quot;
 1539                  &quot;# Inline cache check&quot;);
 1540   }
 1541   st-&gt;print_cr(&quot;\tjne     SharedRuntime::_ic_miss_stub&quot;);
 1542   st-&gt;print_cr(&quot;\tnop\t# nops to align entry point&quot;);
 1543 }
 1544 #endif
 1545 
 1546 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 1547 {
 1548   MacroAssembler masm(&amp;cbuf);
</pre>
<hr />
<pre>
 1551     masm.load_klass(rscratch1, j_rarg0);
 1552     masm.cmpptr(rax, rscratch1);
 1553   } else {
 1554     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
 1555   }
 1556 
 1557   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
 1558 
 1559   /* WARNING these NOPs are critical so that verified entry point is properly
 1560      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
 1561   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
 1562   if (OptoBreakpoint) {
 1563     // Leave space for int3
 1564     nops_cnt -= 1;
 1565   }
 1566   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
 1567   if (nops_cnt &gt; 0)
 1568     masm.nop(nops_cnt);
 1569 }
 1570 







 1571 //=============================================================================
 1572 
 1573 int Matcher::regnum_to_fpu_offset(int regnum)
 1574 {
 1575   return regnum - 32; // The FP registers are in the second chunk
 1576 }
 1577 
 1578 // This is UltraSparc specific, true just means we have fast l2f conversion
 1579 const bool Matcher::convL2FSupported(void) {
 1580   return true;
 1581 }
 1582 
 1583 // Is this branch offset short enough that a short branch can be used?
 1584 //
 1585 // NOTE: If the platform does not provide any short branch variants, then
 1586 //       this method should return false for offset 0.
 1587 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1588   // The passed offset is relative to address of the branch.
 1589   // On 86 a branch displacement is calculated relative to address
 1590   // of a next instruction.
</pre>
<hr />
<pre>
 3836   %}
 3837 %}
 3838 
 3839 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
 3840 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
 3841 %{
 3842   constraint(ALLOC_IN_RC(ptr_reg));
 3843   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
 3844   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
 3845 
 3846   op_cost(10);
 3847   format %{&quot;[$reg + $off + $idx &lt;&lt; $scale]&quot; %}
 3848   interface(MEMORY_INTER) %{
 3849     base($reg);
 3850     index($idx);
 3851     scale($scale);
 3852     disp($off);
 3853   %}
 3854 %}
 3855 
<span class="line-added"> 3856 // Indirect Narrow Oop Operand</span>
<span class="line-added"> 3857 operand indCompressedOop(rRegN reg) %{</span>
<span class="line-added"> 3858   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));</span>
<span class="line-added"> 3859   constraint(ALLOC_IN_RC(ptr_reg));</span>
<span class="line-added"> 3860   match(DecodeN reg);</span>
<span class="line-added"> 3861 </span>
<span class="line-added"> 3862   op_cost(10);</span>
<span class="line-added"> 3863   format %{&quot;[R12 + $reg &lt;&lt; 3] (compressed oop addressing)&quot; %}</span>
<span class="line-added"> 3864   interface(MEMORY_INTER) %{</span>
<span class="line-added"> 3865     base(0xc); // R12</span>
<span class="line-added"> 3866     index($reg);</span>
<span class="line-added"> 3867     scale(0x3);</span>
<span class="line-added"> 3868     disp(0x0);</span>
<span class="line-added"> 3869   %}</span>
<span class="line-added"> 3870 %}</span>
<span class="line-added"> 3871 </span>
 3872 // Indirect Narrow Oop Plus Offset Operand
 3873 // Note: x86 architecture doesn&#39;t support &quot;scale * index + offset&quot; without a base
 3874 // we can&#39;t free r12 even with CompressedOops::base() == NULL.
 3875 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
 3876   predicate(UseCompressedOops &amp;&amp; (CompressedOops::shift() == Address::times_8));
 3877   constraint(ALLOC_IN_RC(ptr_reg));
 3878   match(AddP (DecodeN reg) off);
 3879 
 3880   op_cost(10);
 3881   format %{&quot;[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)&quot; %}
 3882   interface(MEMORY_INTER) %{
 3883     base(0xc); // R12
 3884     index($reg);
 3885     scale(0x3);
 3886     disp($off);
 3887   %}
 3888 %}
 3889 
 3890 // Indirect Memory Operand
 3891 operand indirectNarrow(rRegN reg)
</pre>
<hr />
<pre>
 4194     equal(0x4, &quot;e&quot;);
 4195     not_equal(0x5, &quot;ne&quot;);
 4196     less(0x2, &quot;b&quot;);
 4197     greater_equal(0x3, &quot;nb&quot;);
 4198     less_equal(0x6, &quot;be&quot;);
 4199     greater(0x7, &quot;nbe&quot;);
 4200     overflow(0x0, &quot;o&quot;);
 4201     no_overflow(0x1, &quot;no&quot;);
 4202   %}
 4203 %}
 4204 
 4205 //----------OPERAND CLASSES----------------------------------------------------
 4206 // Operand Classes are groups of operands that are used as to simplify
 4207 // instruction definitions by not requiring the AD writer to specify separate
 4208 // instructions for every form of operand when the instruction accepts
 4209 // multiple operand types with the same basic encoding and format.  The classic
 4210 // case of this is memory operands.
 4211 
 4212 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
 4213                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
<span class="line-modified"> 4214                indCompressedOop, indCompressedOopOffset,</span>
 4215                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
 4216                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
 4217                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
 4218 
 4219 //----------PIPELINE-----------------------------------------------------------
 4220 // Rules which define the behavior of the target architectures pipeline.
 4221 pipeline %{
 4222 
 4223 //----------ATTRIBUTES---------------------------------------------------------
 4224 attributes %{
 4225   variable_size_instructions;        // Fixed size instructions
 4226   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
 4227   instruction_unit_size = 1;         // An instruction is 1 bytes long
 4228   instruction_fetch_unit_size = 16;  // The processor fetches one line
 4229   instruction_fetch_units = 1;       // of 16 bytes
 4230 
 4231   // List of nop instructions
 4232   nops( MachNop );
 4233 %}
 4234 
</pre>
<hr />
<pre>
 6678   format %{ &quot;MEMBAR-storestore (empty encoding)&quot; %}
 6679   ins_encode( );
 6680   ins_pipe(empty);
 6681 %}
 6682 
 6683 //----------Move Instructions--------------------------------------------------
 6684 
 6685 instruct castX2P(rRegP dst, rRegL src)
 6686 %{
 6687   match(Set dst (CastX2P src));
 6688 
 6689   format %{ &quot;movq    $dst, $src\t# long-&gt;ptr&quot; %}
 6690   ins_encode %{
 6691     if ($dst$$reg != $src$$reg) {
 6692       __ movptr($dst$$Register, $src$$Register);
 6693     }
 6694   %}
 6695   ins_pipe(ialu_reg_reg); // XXX
 6696 %}
 6697 
<span class="line-added"> 6698 instruct castN2X(rRegL dst, rRegN src)</span>
<span class="line-added"> 6699 %{</span>
<span class="line-added"> 6700   match(Set dst (CastP2X src));</span>
<span class="line-added"> 6701 </span>
<span class="line-added"> 6702   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}</span>
<span class="line-added"> 6703   ins_encode %{</span>
<span class="line-added"> 6704     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6705       __ movptr($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6706     }</span>
<span class="line-added"> 6707   %}</span>
<span class="line-added"> 6708   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6709 %}</span>
<span class="line-added"> 6710 </span>
 6711 instruct castP2X(rRegL dst, rRegP src)
 6712 %{
 6713   match(Set dst (CastP2X src));
 6714 
 6715   format %{ &quot;movq    $dst, $src\t# ptr -&gt; long&quot; %}
 6716   ins_encode %{
 6717     if ($dst$$reg != $src$$reg) {
 6718       __ movptr($dst$$Register, $src$$Register);
 6719     }
 6720   %}
 6721   ins_pipe(ialu_reg_reg); // XXX
 6722 %}
 6723 
<span class="line-added"> 6724 instruct castN2I(rRegI dst, rRegN src)</span>
<span class="line-added"> 6725 %{</span>
<span class="line-added"> 6726   match(Set dst (CastN2I src));</span>
<span class="line-added"> 6727 </span>
<span class="line-added"> 6728   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}</span>
<span class="line-added"> 6729   ins_encode %{</span>
<span class="line-added"> 6730     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6731       __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6732     }</span>
<span class="line-added"> 6733   %}</span>
<span class="line-added"> 6734   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6735 %}</span>
<span class="line-added"> 6736 </span>
<span class="line-added"> 6737 instruct castI2N(rRegN dst, rRegI src)</span>
<span class="line-added"> 6738 %{</span>
<span class="line-added"> 6739   match(Set dst (CastI2N src));</span>
<span class="line-added"> 6740 </span>
<span class="line-added"> 6741   format %{ &quot;movl    $dst, $src\t# int -&gt; compressed ptr&quot; %}</span>
<span class="line-added"> 6742   ins_encode %{</span>
<span class="line-added"> 6743     if ($dst$$reg != $src$$reg) {</span>
<span class="line-added"> 6744       __ movl($dst$$Register, $src$$Register);</span>
<span class="line-added"> 6745     }</span>
<span class="line-added"> 6746   %}</span>
<span class="line-added"> 6747   ins_pipe(ialu_reg_reg); // XXX</span>
<span class="line-added"> 6748 %}</span>
<span class="line-added"> 6749 </span>
<span class="line-added"> 6750 </span>
 6751 // Convert oop into int for vectors alignment masking
 6752 instruct convP2I(rRegI dst, rRegP src)
 6753 %{
 6754   match(Set dst (ConvL2I (CastP2X src)));
 6755 
 6756   format %{ &quot;movl    $dst, $src\t# ptr -&gt; int&quot; %}
 6757   ins_encode %{
 6758     __ movl($dst$$Register, $src$$Register);
 6759   %}
 6760   ins_pipe(ialu_reg_reg); // XXX
 6761 %}
 6762 
 6763 // Convert compressed oop into int for vectors alignment masking
 6764 // in case of 32bit oops (heap &lt; 4Gb).
 6765 instruct convN2I(rRegI dst, rRegN src)
 6766 %{
 6767   predicate(CompressedOops::shift() == 0);
 6768   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 6769 
 6770   format %{ &quot;movl    $dst, $src\t# compressed ptr -&gt; int&quot; %}
</pre>
<hr />
<pre>
10951   ins_encode %{
10952     __ movdl($dst$$XMMRegister, $src$$Register);
10953   %}
10954   ins_pipe( pipe_slow );
10955 %}
10956 
10957 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10958   match(Set dst (MoveL2D src));
10959   effect(DEF dst, USE src);
10960   ins_cost(100);
10961   format %{ &quot;movd    $dst,$src\t# MoveL2D&quot; %}
10962   ins_encode %{
10963      __ movdq($dst$$XMMRegister, $src$$Register);
10964   %}
10965   ins_pipe( pipe_slow );
10966 %}
10967 
10968 
10969 // =======================================================================
10970 // fast clearing of an array
<span class="line-modified">10971 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
10972                   Universe dummy, rFlagsReg cr)
10973 %{
<span class="line-modified">10974   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-modified">10975   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-modified">10976   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
10977 
10978   format %{ $$template

10979     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;
10980     $$emit$$&quot;jg      LARGE\n\t&quot;
10981     $$emit$$&quot;dec     rcx\n\t&quot;
10982     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;
10983     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;
10984     $$emit$$&quot;dec     rcx\n\t&quot;
10985     $$emit$$&quot;jge     LOOP\n\t&quot;
10986     $$emit$$&quot;jmp     DONE\n\t&quot;
10987     $$emit$$&quot;# LARGE:\n\t&quot;
10988     if (UseFastStosb) {
10989        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
10990        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--\n\t&quot;
10991     } else if (UseXMMForObjInit) {
<span class="line-modified">10992        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-modified">10993        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">10994        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
10995        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
10996        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">10997        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-modified">10998        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
10999        $$emit$$&quot;add     0x40,rax\n\t&quot;
11000        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11001        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11002        $$emit$$&quot;jge     L_loop\n\t&quot;
11003        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11004        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">11005        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
11006        $$emit$$&quot;add     0x20,rax\n\t&quot;
11007        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11008        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11009        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11010        $$emit$$&quot;jle     L_end\n\t&quot;
11011        $$emit$$&quot;dec     rcx\n\t&quot;
11012        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11013        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11014        $$emit$$&quot;add     0x8,rax\n\t&quot;
11015        $$emit$$&quot;dec     rcx\n\t&quot;
11016        $$emit$$&quot;jge     L_sloop\n\t&quot;
11017        $$emit$$&quot;# L_end:\n\t&quot;
11018     } else {
11019        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;
11020     }
11021     $$emit$$&quot;# DONE&quot;
11022   %}
11023   ins_encode %{
<span class="line-modified">11024     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-modified">11025                  $tmp$$XMMRegister, false, false);</span>
11026   %}
11027   ins_pipe(pipe_slow);
11028 %}
11029 
<span class="line-modified">11030 instruct rep_stos_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
<span class="line-added">11031                   Universe dummy, rFlagsReg cr)</span>
<span class="line-added">11032 %{</span>
<span class="line-added">11033   predicate(!((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-added">11034   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-added">11035   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
<span class="line-added">11036 </span>
<span class="line-added">11037   format %{ $$template</span>
<span class="line-added">11038     $$emit$$&quot;cmp     InitArrayShortSize,rcx\n\t&quot;</span>
<span class="line-added">11039     $$emit$$&quot;jg      LARGE\n\t&quot;</span>
<span class="line-added">11040     $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11041     $$emit$$&quot;js      DONE\t# Zero length\n\t&quot;</span>
<span class="line-added">11042     $$emit$$&quot;mov     rax,(rdi,rcx,8)\t# LOOP\n\t&quot;</span>
<span class="line-added">11043     $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11044     $$emit$$&quot;jge     LOOP\n\t&quot;</span>
<span class="line-added">11045     $$emit$$&quot;jmp     DONE\n\t&quot;</span>
<span class="line-added">11046     $$emit$$&quot;# LARGE:\n\t&quot;</span>
<span class="line-added">11047     if (UseXMMForObjInit) {</span>
<span class="line-added">11048        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-added">11049        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11050        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11051        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;</span>
<span class="line-added">11052        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;</span>
<span class="line-added">11053        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11054        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
<span class="line-added">11055        $$emit$$&quot;add     0x40,rax\n\t&quot;</span>
<span class="line-added">11056        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;</span>
<span class="line-added">11057        $$emit$$&quot;sub     0x8,rcx\n\t&quot;</span>
<span class="line-added">11058        $$emit$$&quot;jge     L_loop\n\t&quot;</span>
<span class="line-added">11059        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11060        $$emit$$&quot;jl      L_tail\n\t&quot;</span>
<span class="line-added">11061        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11062        $$emit$$&quot;add     0x20,rax\n\t&quot;</span>
<span class="line-added">11063        $$emit$$&quot;sub     0x4,rcx\n\t&quot;</span>
<span class="line-added">11064        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;</span>
<span class="line-added">11065        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11066        $$emit$$&quot;jle     L_end\n\t&quot;</span>
<span class="line-added">11067        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11068        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;</span>
<span class="line-added">11069        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;</span>
<span class="line-added">11070        $$emit$$&quot;add     0x8,rax\n\t&quot;</span>
<span class="line-added">11071        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11072        $$emit$$&quot;jge     L_sloop\n\t&quot;</span>
<span class="line-added">11073        $$emit$$&quot;# L_end:\n\t&quot;</span>
<span class="line-added">11074     } else {</span>
<span class="line-added">11075        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--\n\t&quot;</span>
<span class="line-added">11076     }</span>
<span class="line-added">11077     $$emit$$&quot;# DONE&quot;</span>
<span class="line-added">11078   %}</span>
<span class="line-added">11079   ins_encode %{</span>
<span class="line-added">11080     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-added">11081                  $tmp$$XMMRegister, false, true);</span>
<span class="line-added">11082   %}</span>
<span class="line-added">11083   ins_pipe(pipe_slow);</span>
<span class="line-added">11084 %}</span>
<span class="line-added">11085 </span>
<span class="line-added">11086 instruct rep_stos_large(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val,</span>
11087                         Universe dummy, rFlagsReg cr)
11088 %{
<span class="line-modified">11089   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; !((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-modified">11090   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-modified">11091   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
11092 
11093   format %{ $$template
11094     if (UseFastStosb) {

11095        $$emit$$&quot;shlq    rcx,3\t# Convert doublewords to bytes\n\t&quot;
11096        $$emit$$&quot;rep     stosb\t# Store rax to *rdi++ while rcx--&quot;
11097     } else if (UseXMMForObjInit) {
<span class="line-modified">11098        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-modified">11099        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11100        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
11101        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;
11102        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;
<span class="line-modified">11103        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-modified">11104        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
11105        $$emit$$&quot;add     0x40,rax\n\t&quot;
11106        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;
11107        $$emit$$&quot;sub     0x8,rcx\n\t&quot;
11108        $$emit$$&quot;jge     L_loop\n\t&quot;
11109        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11110        $$emit$$&quot;jl      L_tail\n\t&quot;
<span class="line-modified">11111        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
11112        $$emit$$&quot;add     0x20,rax\n\t&quot;
11113        $$emit$$&quot;sub     0x4,rcx\n\t&quot;
11114        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;
11115        $$emit$$&quot;add     0x4,rcx\n\t&quot;
11116        $$emit$$&quot;jle     L_end\n\t&quot;
11117        $$emit$$&quot;dec     rcx\n\t&quot;
11118        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;
11119        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;
11120        $$emit$$&quot;add     0x8,rax\n\t&quot;
11121        $$emit$$&quot;dec     rcx\n\t&quot;
11122        $$emit$$&quot;jge     L_sloop\n\t&quot;
11123        $$emit$$&quot;# L_end:\n\t&quot;
11124     } else {

11125        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;
11126     }
11127   %}
11128   ins_encode %{
<span class="line-modified">11129     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register,</span>
<span class="line-modified">11130                  $tmp$$XMMRegister, true, false);</span>
<span class="line-added">11131   %}</span>
<span class="line-added">11132   ins_pipe(pipe_slow);</span>
<span class="line-added">11133 %}</span>
<span class="line-added">11134 </span>
<span class="line-added">11135 instruct rep_stos_large_word_copy(rcx_RegL cnt, rdi_RegP base, regD tmp, rax_RegL val, </span>
<span class="line-added">11136                         Universe dummy, rFlagsReg cr)</span>
<span class="line-added">11137 %{</span>
<span class="line-added">11138   predicate(((ClearArrayNode*)n)-&gt;is_large() &amp;&amp; ((ClearArrayNode*)n)-&gt;word_copy_only());</span>
<span class="line-added">11139   match(Set dummy (ClearArray (Binary cnt base) val));</span>
<span class="line-added">11140   effect(USE_KILL cnt, USE_KILL base, TEMP tmp, KILL cr);</span>
<span class="line-added">11141 </span>
<span class="line-added">11142   format %{ $$template</span>
<span class="line-added">11143     if (UseXMMForObjInit) {</span>
<span class="line-added">11144        $$emit$$&quot;movdq   $tmp, $val\n\t&quot;</span>
<span class="line-added">11145        $$emit$$&quot;punpcklqdq $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11146        $$emit$$&quot;vinserti128_high $tmp, $tmp\n\t&quot;</span>
<span class="line-added">11147        $$emit$$&quot;jmpq    L_zero_64_bytes\n\t&quot;</span>
<span class="line-added">11148        $$emit$$&quot;# L_loop:\t# 64-byte LOOP\n\t&quot;</span>
<span class="line-added">11149        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11150        $$emit$$&quot;vmovdqu $tmp,0x20(rax)\n\t&quot;</span>
<span class="line-added">11151        $$emit$$&quot;add     0x40,rax\n\t&quot;</span>
<span class="line-added">11152        $$emit$$&quot;# L_zero_64_bytes:\n\t&quot;</span>
<span class="line-added">11153        $$emit$$&quot;sub     0x8,rcx\n\t&quot;</span>
<span class="line-added">11154        $$emit$$&quot;jge     L_loop\n\t&quot;</span>
<span class="line-added">11155        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11156        $$emit$$&quot;jl      L_tail\n\t&quot;</span>
<span class="line-added">11157        $$emit$$&quot;vmovdqu $tmp,(rax)\n\t&quot;</span>
<span class="line-added">11158        $$emit$$&quot;add     0x20,rax\n\t&quot;</span>
<span class="line-added">11159        $$emit$$&quot;sub     0x4,rcx\n\t&quot;</span>
<span class="line-added">11160        $$emit$$&quot;# L_tail:\t# Clearing tail bytes\n\t&quot;</span>
<span class="line-added">11161        $$emit$$&quot;add     0x4,rcx\n\t&quot;</span>
<span class="line-added">11162        $$emit$$&quot;jle     L_end\n\t&quot;</span>
<span class="line-added">11163        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11164        $$emit$$&quot;# L_sloop:\t# 8-byte short loop\n\t&quot;</span>
<span class="line-added">11165        $$emit$$&quot;vmovq   xmm0,(rax)\n\t&quot;</span>
<span class="line-added">11166        $$emit$$&quot;add     0x8,rax\n\t&quot;</span>
<span class="line-added">11167        $$emit$$&quot;dec     rcx\n\t&quot;</span>
<span class="line-added">11168        $$emit$$&quot;jge     L_sloop\n\t&quot;</span>
<span class="line-added">11169        $$emit$$&quot;# L_end:\n\t&quot;</span>
<span class="line-added">11170     } else {</span>
<span class="line-added">11171        $$emit$$&quot;rep     stosq\t# Store rax to *rdi++ while rcx--&quot;</span>
<span class="line-added">11172     }</span>
<span class="line-added">11173   %}</span>
<span class="line-added">11174   ins_encode %{</span>
<span class="line-added">11175     __ clear_mem($base$$Register, $cnt$$Register, $val$$Register, </span>
<span class="line-added">11176                  $tmp$$XMMRegister, true, true);</span>
11177   %}
11178   ins_pipe(pipe_slow);
11179 %}
11180 
11181 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
11182                          rax_RegI result, legRegD tmp1, rFlagsReg cr)
11183 %{
11184   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
11185   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
11186   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
11187 
11188   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1&quot; %}
11189   ins_encode %{
11190     __ string_compare($str1$$Register, $str2$$Register,
11191                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
11192                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
11193   %}
11194   ins_pipe( pipe_slow );
11195 %}
11196 
</pre>
<hr />
<pre>
11721 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11722 %{
11723   match(Set cr (CmpI (AndI src con) zero));
11724 
11725   format %{ &quot;testl   $src, $con&quot; %}
11726   opcode(0xF7, 0x00);
11727   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11728   ins_pipe(ialu_cr_reg_imm);
11729 %}
11730 
11731 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11732 %{
11733   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11734 
11735   format %{ &quot;testl   $src, $mem&quot; %}
11736   opcode(0x85);
11737   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11738   ins_pipe(ialu_cr_reg_mem);
11739 %}
11740 
<span class="line-added">11741 // Fold array properties check</span>
<span class="line-added">11742 instruct testI_mem_imm(rFlagsReg cr, memory mem, immI con, immI0 zero)</span>
<span class="line-added">11743 %{</span>
<span class="line-added">11744   match(Set cr (CmpI (AndI (CastN2I (LoadNKlass mem)) con) zero));</span>
<span class="line-added">11745 </span>
<span class="line-added">11746   format %{ &quot;testl   $mem, $con&quot; %}</span>
<span class="line-added">11747   opcode(0xF7, 0x00);</span>
<span class="line-added">11748   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(con));</span>
<span class="line-added">11749   ins_pipe(ialu_mem_imm);</span>
<span class="line-added">11750 %}</span>
<span class="line-added">11751 </span>
11752 // Unsigned compare Instructions; really, same as signed except they
11753 // produce an rFlagsRegU instead of rFlagsReg.
11754 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11755 %{
11756   match(Set cr (CmpU op1 op2));
11757 
11758   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11759   opcode(0x3B); /* Opcode 3B /r */
11760   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11761   ins_pipe(ialu_cr_reg_reg);
11762 %}
11763 
11764 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11765 %{
11766   match(Set cr (CmpU op1 op2));
11767 
11768   format %{ &quot;cmpl    $op1, $op2\t# unsigned&quot; %}
11769   opcode(0x81,0x07); /* Opcode 81 /7 */
11770   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11771   ins_pipe(ialu_cr_reg_imm);
</pre>
<hr />
<pre>
12045 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
12046 %{
12047   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
12048 
12049   format %{ &quot;testq   $src, $mem&quot; %}
12050   opcode(0x85);
12051   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12052   ins_pipe(ialu_cr_reg_mem);
12053 %}
12054 
12055 instruct testL_reg_mem2(rFlagsReg cr, rRegP src, memory mem, immL0 zero)
12056 %{
12057   match(Set cr (CmpL (AndL (CastP2X src) (LoadL mem)) zero));
12058 
12059   format %{ &quot;testq   $src, $mem&quot; %}
12060   opcode(0x85);
12061   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
12062   ins_pipe(ialu_cr_reg_mem);
12063 %}
12064 
<span class="line-added">12065 // Fold array properties check</span>
<span class="line-added">12066 instruct testL_reg_mem3(rFlagsReg cr, memory mem, rRegL src, immL0 zero)</span>
<span class="line-added">12067 %{</span>
<span class="line-added">12068   match(Set cr (CmpL (AndL (CastP2X (LoadKlass mem)) src) zero));</span>
<span class="line-added">12069 </span>
<span class="line-added">12070   format %{ &quot;testq   $src, $mem\t# test array properties&quot; %}</span>
<span class="line-added">12071   opcode(0x85);</span>
<span class="line-added">12072   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));</span>
<span class="line-added">12073   ins_pipe(ialu_cr_reg_mem);</span>
<span class="line-added">12074 %}</span>
<span class="line-added">12075 </span>
12076 // Manifest a CmpL result in an integer register.  Very painful.
12077 // This is the test to avoid.
12078 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
12079 %{
12080   match(Set dst (CmpL3 src1 src2));
12081   effect(KILL flags);
12082 
12083   ins_cost(275); // XXX
12084   format %{ &quot;cmpq    $src1, $src2\t# CmpL3\n\t&quot;
12085             &quot;movl    $dst, -1\n\t&quot;
12086             &quot;jl,s    done\n\t&quot;
12087             &quot;setne   $dst\n\t&quot;
12088             &quot;movzbl  $dst, $dst\n\t&quot;
12089     &quot;done:&quot; %}
12090   ins_encode(cmpl3_flag(src1, src2, dst));
12091   ins_pipe(pipe_slow);
12092 %}
12093 
12094 // Unsigned long compare Instructions; really, same as signed long except they
12095 // produce an rFlagsRegU instead of rFlagsReg.
</pre>
<hr />
<pre>
12723 
12724   ins_cost(300);
12725   format %{ &quot;call,runtime &quot; %}
12726   ins_encode(clear_avx, Java_To_Runtime(meth));
12727   ins_pipe(pipe_slow);
12728 %}
12729 
12730 // Call runtime without safepoint
12731 instruct CallLeafDirect(method meth)
12732 %{
12733   match(CallLeaf);
12734   effect(USE meth);
12735 
12736   ins_cost(300);
12737   format %{ &quot;call_leaf,runtime &quot; %}
12738   ins_encode(clear_avx, Java_To_Runtime(meth));
12739   ins_pipe(pipe_slow);
12740 %}
12741 
12742 // Call runtime without safepoint
<span class="line-added">12743 // entry point is null, target holds the address to call</span>
<span class="line-added">12744 instruct CallLeafNoFPInDirect(rRegP target)</span>
<span class="line-added">12745 %{</span>
<span class="line-added">12746   predicate(n-&gt;as_Call()-&gt;entry_point() == NULL);</span>
<span class="line-added">12747   match(CallLeafNoFP target);</span>
<span class="line-added">12748 </span>
<span class="line-added">12749   ins_cost(300);</span>
<span class="line-added">12750   format %{ &quot;call_leaf_nofp,runtime indirect &quot; %}</span>
<span class="line-added">12751   ins_encode %{</span>
<span class="line-added">12752      __ call($target$$Register);</span>
<span class="line-added">12753   %}</span>
<span class="line-added">12754 </span>
<span class="line-added">12755   ins_pipe(pipe_slow);</span>
<span class="line-added">12756 %}</span>
<span class="line-added">12757 </span>
12758 instruct CallLeafNoFPDirect(method meth)
12759 %{
<span class="line-added">12760   predicate(n-&gt;as_Call()-&gt;entry_point() != NULL);</span>
12761   match(CallLeafNoFP);
12762   effect(USE meth);
12763 
12764   ins_cost(300);
12765   format %{ &quot;call_leaf_nofp,runtime &quot; %}
12766   ins_encode(clear_avx, Java_To_Runtime(meth));
12767   ins_pipe(pipe_slow);
12768 %}
12769 
12770 // Return Instruction
12771 // Remove the return address &amp; jump to it.
12772 // Notice: We always emit a nop after a ret to make sure there is room
12773 // for safepoint patching
12774 instruct Ret()
12775 %{
12776   match(Return);
12777 
12778   format %{ &quot;ret&quot; %}
12779   opcode(0xC3);
12780   ins_encode(OpcP);
</pre>
</td>
</tr>
</table>
<center><a href="x86_32.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../share/c1/c1_LinearScan.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
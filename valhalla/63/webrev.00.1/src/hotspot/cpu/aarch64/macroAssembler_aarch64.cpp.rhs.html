<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &lt;sys/types.h&gt;
  27 
  28 #include &quot;precompiled.hpp&quot;
  29 #include &quot;jvm.h&quot;
  30 #include &quot;asm/assembler.hpp&quot;
  31 #include &quot;asm/assembler.inline.hpp&quot;
  32 #include &quot;gc/shared/barrierSet.hpp&quot;
  33 #include &quot;gc/shared/cardTable.hpp&quot;
  34 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  35 #include &quot;gc/shared/cardTableBarrierSet.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;compiler/disassembler.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;nativeInst_aarch64.hpp&quot;
  41 #include &quot;oops/accessDecorators.hpp&quot;
  42 #include &quot;oops/compressedOops.inline.hpp&quot;
  43 #include &quot;oops/klass.inline.hpp&quot;
  44 #include &quot;runtime/biasedLocking.hpp&quot;
  45 #include &quot;runtime/icache.hpp&quot;
  46 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  47 #include &quot;runtime/jniHandles.inline.hpp&quot;
  48 #include &quot;runtime/sharedRuntime.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  49 #include &quot;runtime/signature_cc.hpp&quot;</span>
  50 #include &quot;runtime/thread.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;
  52 #ifdef COMPILER1
  53 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  54 #endif
  55 #ifdef COMPILER2
  56 #include &quot;oops/oop.hpp&quot;
  57 #include &quot;opto/compile.hpp&quot;
  58 #include &quot;opto/node.hpp&quot;
  59 #include &quot;opto/output.hpp&quot;
  60 #endif
  61 
  62 #ifdef PRODUCT
  63 #define BLOCK_COMMENT(str) /* nothing */
  64 #define STOP(error) stop(error)
  65 #else
  66 #define BLOCK_COMMENT(str) block_comment(str)
  67 #define STOP(error) block_comment(error); stop(error)
  68 #endif
  69 
  70 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  71 
  72 // Patch any kind of instruction; there may be several instructions.
  73 // Return the total length (in bytes) of the instructions.
  74 int MacroAssembler::pd_patch_instruction_size(address branch, address target) {
  75   int instructions = 1;
  76   assert((uint64_t)target &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
  77   long offset = (target - branch) &gt;&gt; 2;
  78   unsigned insn = *(unsigned*)branch;
  79   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b111011) == 0b011000) {
  80     // Load register (literal)
  81     Instruction_aarch64::spatch(branch, 23, 5, offset);
  82   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
  83     // Unconditional branch (immediate)
  84     Instruction_aarch64::spatch(branch, 25, 0, offset);
  85   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
  86     // Conditional branch (immediate)
  87     Instruction_aarch64::spatch(branch, 23, 5, offset);
  88   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
  89     // Compare &amp; branch (immediate)
  90     Instruction_aarch64::spatch(branch, 23, 5, offset);
  91   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {
  92     // Test &amp; branch (immediate)
  93     Instruction_aarch64::spatch(branch, 18, 5, offset);
  94   } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
  95     // PC-rel. addressing
  96     offset = target-branch;
  97     int shift = Instruction_aarch64::extract(insn, 31, 31);
  98     if (shift) {
  99       u_int64_t dest = (u_int64_t)target;
 100       uint64_t pc_page = (uint64_t)branch &gt;&gt; 12;
 101       uint64_t adr_page = (uint64_t)target &gt;&gt; 12;
 102       unsigned offset_lo = dest &amp; 0xfff;
 103       offset = adr_page - pc_page;
 104 
 105       // We handle 4 types of PC relative addressing
 106       //   1 - adrp    Rx, target_page
 107       //       ldr/str Ry, [Rx, #offset_in_page]
 108       //   2 - adrp    Rx, target_page
 109       //       add     Ry, Rx, #offset_in_page
 110       //   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 111       //       movk    Rx, #imm16&lt;&lt;32
 112       //   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 113       // In the first 3 cases we must check that Rx is the same in the adrp and the
 114       // subsequent ldr/str, add or movk instruction. Otherwise we could accidentally end
 115       // up treating a type 4 relocation as a type 1, 2 or 3 just because it happened
 116       // to be followed by a random unrelated ldr/str, add or movk instruction.
 117       //
 118       unsigned insn2 = ((unsigned*)branch)[1];
 119       if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &amp;&amp;
 120                 Instruction_aarch64::extract(insn, 4, 0) ==
 121                         Instruction_aarch64::extract(insn2, 9, 5)) {
 122         // Load/store register (unsigned immediate)
 123         unsigned size = Instruction_aarch64::extract(insn2, 31, 30);
 124         Instruction_aarch64::patch(branch + sizeof (unsigned),
 125                                     21, 10, offset_lo &gt;&gt; size);
 126         guarantee(((dest &gt;&gt; size) &lt;&lt; size) == dest, &quot;misaligned target&quot;);
 127         instructions = 2;
 128       } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &amp;&amp;
 129                 Instruction_aarch64::extract(insn, 4, 0) ==
 130                         Instruction_aarch64::extract(insn2, 4, 0)) {
 131         // add (immediate)
 132         Instruction_aarch64::patch(branch + sizeof (unsigned),
 133                                    21, 10, offset_lo);
 134         instructions = 2;
 135       } else if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110 &amp;&amp;
 136                    Instruction_aarch64::extract(insn, 4, 0) ==
 137                      Instruction_aarch64::extract(insn2, 4, 0)) {
 138         // movk #imm16&lt;&lt;32
 139         Instruction_aarch64::patch(branch + 4, 20, 5, (uint64_t)target &gt;&gt; 32);
 140         long dest = ((long)target &amp; 0xffffffffL) | ((long)branch &amp; 0xffff00000000L);
 141         long pc_page = (long)branch &gt;&gt; 12;
 142         long adr_page = (long)dest &gt;&gt; 12;
 143         offset = adr_page - pc_page;
 144         instructions = 2;
 145       }
 146     }
 147     int offset_lo = offset &amp; 3;
 148     offset &gt;&gt;= 2;
 149     Instruction_aarch64::spatch(branch, 23, 5, offset);
 150     Instruction_aarch64::patch(branch, 30, 29, offset_lo);
 151   } else if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010100) {
 152     u_int64_t dest = (u_int64_t)target;
 153     // Move wide constant
 154     assert(nativeInstruction_at(branch+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 155     assert(nativeInstruction_at(branch+8)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 156     Instruction_aarch64::patch(branch, 20, 5, dest &amp; 0xffff);
 157     Instruction_aarch64::patch(branch+4, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 158     Instruction_aarch64::patch(branch+8, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 159     assert(target_addr_for_insn(branch) == target, &quot;should be&quot;);
 160     instructions = 3;
 161   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 162              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 163     // nothing to do
 164     assert(target == 0, &quot;did not expect to relocate target for polling page load&quot;);
 165   } else {
 166     ShouldNotReachHere();
 167   }
 168   return instructions * NativeInstruction::instruction_size;
 169 }
 170 
 171 int MacroAssembler::patch_oop(address insn_addr, address o) {
 172   int instructions;
 173   unsigned insn = *(unsigned*)insn_addr;
 174   assert(nativeInstruction_at(insn_addr+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 175 
 176   // OOPs are either narrow (32 bits) or wide (48 bits).  We encode
 177   // narrow OOPs by setting the upper 16 bits in the first
 178   // instruction.
 179   if (Instruction_aarch64::extract(insn, 31, 21) == 0b11010010101) {
 180     // Move narrow OOP
 181     narrowOop n = CompressedOops::encode((oop)o);
 182     Instruction_aarch64::patch(insn_addr, 20, 5, n &gt;&gt; 16);
 183     Instruction_aarch64::patch(insn_addr+4, 20, 5, n &amp; 0xffff);
 184     instructions = 2;
 185   } else {
 186     // Move wide OOP
 187     assert(nativeInstruction_at(insn_addr+8)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 188     uintptr_t dest = (uintptr_t)o;
 189     Instruction_aarch64::patch(insn_addr, 20, 5, dest &amp; 0xffff);
 190     Instruction_aarch64::patch(insn_addr+4, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 191     Instruction_aarch64::patch(insn_addr+8, 20, 5, (dest &gt;&gt;= 16) &amp; 0xffff);
 192     instructions = 3;
 193   }
 194   return instructions * NativeInstruction::instruction_size;
 195 }
 196 
 197 int MacroAssembler::patch_narrow_klass(address insn_addr, narrowKlass n) {
 198   // Metatdata pointers are either narrow (32 bits) or wide (48 bits).
 199   // We encode narrow ones by setting the upper 16 bits in the first
 200   // instruction.
 201   NativeInstruction *insn = nativeInstruction_at(insn_addr);
 202   assert(Instruction_aarch64::extract(insn-&gt;encoding(), 31, 21) == 0b11010010101 &amp;&amp;
 203          nativeInstruction_at(insn_addr+4)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 204 
 205   Instruction_aarch64::patch(insn_addr, 20, 5, n &gt;&gt; 16);
 206   Instruction_aarch64::patch(insn_addr+4, 20, 5, n &amp; 0xffff);
 207   return 2 * NativeInstruction::instruction_size;
 208 }
 209 
 210 address MacroAssembler::target_addr_for_insn(address insn_addr, unsigned insn) {
 211   long offset = 0;
 212   if ((Instruction_aarch64::extract(insn, 29, 24) &amp; 0b011011) == 0b00011000) {
 213     // Load register (literal)
 214     offset = Instruction_aarch64::sextract(insn, 23, 5);
 215     return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 216   } else if (Instruction_aarch64::extract(insn, 30, 26) == 0b00101) {
 217     // Unconditional branch (immediate)
 218     offset = Instruction_aarch64::sextract(insn, 25, 0);
 219   } else if (Instruction_aarch64::extract(insn, 31, 25) == 0b0101010) {
 220     // Conditional branch (immediate)
 221     offset = Instruction_aarch64::sextract(insn, 23, 5);
 222   } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011010) {
 223     // Compare &amp; branch (immediate)
 224     offset = Instruction_aarch64::sextract(insn, 23, 5);
 225    } else if (Instruction_aarch64::extract(insn, 30, 25) == 0b011011) {
 226     // Test &amp; branch (immediate)
 227     offset = Instruction_aarch64::sextract(insn, 18, 5);
 228   } else if (Instruction_aarch64::extract(insn, 28, 24) == 0b10000) {
 229     // PC-rel. addressing
 230     offset = Instruction_aarch64::extract(insn, 30, 29);
 231     offset |= Instruction_aarch64::sextract(insn, 23, 5) &lt;&lt; 2;
 232     int shift = Instruction_aarch64::extract(insn, 31, 31) ? 12 : 0;
 233     if (shift) {
 234       offset &lt;&lt;= shift;
 235       uint64_t target_page = ((uint64_t)insn_addr) + offset;
 236       target_page &amp;= ((uint64_t)-1) &lt;&lt; shift;
 237       // Return the target address for the following sequences
 238       //   1 - adrp    Rx, target_page
 239       //       ldr/str Ry, [Rx, #offset_in_page]
 240       //   2 - adrp    Rx, target_page
 241       //       add     Ry, Rx, #offset_in_page
 242       //   3 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 243       //       movk    Rx, #imm12&lt;&lt;32
 244       //   4 - adrp    Rx, target_page (page aligned reloc, offset == 0)
 245       //
 246       // In the first two cases  we check that the register is the same and
 247       // return the target_page + the offset within the page.
 248       // Otherwise we assume it is a page aligned relocation and return
 249       // the target page only.
 250       //
 251       unsigned insn2 = ((unsigned*)insn_addr)[1];
 252       if (Instruction_aarch64::extract(insn2, 29, 24) == 0b111001 &amp;&amp;
 253                 Instruction_aarch64::extract(insn, 4, 0) ==
 254                         Instruction_aarch64::extract(insn2, 9, 5)) {
 255         // Load/store register (unsigned immediate)
 256         unsigned int byte_offset = Instruction_aarch64::extract(insn2, 21, 10);
 257         unsigned int size = Instruction_aarch64::extract(insn2, 31, 30);
 258         return address(target_page + (byte_offset &lt;&lt; size));
 259       } else if (Instruction_aarch64::extract(insn2, 31, 22) == 0b1001000100 &amp;&amp;
 260                 Instruction_aarch64::extract(insn, 4, 0) ==
 261                         Instruction_aarch64::extract(insn2, 4, 0)) {
 262         // add (immediate)
 263         unsigned int byte_offset = Instruction_aarch64::extract(insn2, 21, 10);
 264         return address(target_page + byte_offset);
 265       } else {
 266         if (Instruction_aarch64::extract(insn2, 31, 21) == 0b11110010110  &amp;&amp;
 267                Instruction_aarch64::extract(insn, 4, 0) ==
 268                  Instruction_aarch64::extract(insn2, 4, 0)) {
 269           target_page = (target_page &amp; 0xffffffff) |
 270                          ((uint64_t)Instruction_aarch64::extract(insn2, 20, 5) &lt;&lt; 32);
 271         }
 272         return (address)target_page;
 273       }
 274     } else {
 275       ShouldNotReachHere();
 276     }
 277   } else if (Instruction_aarch64::extract(insn, 31, 23) == 0b110100101) {
 278     u_int32_t *insns = (u_int32_t *)insn_addr;
 279     // Move wide constant: movz, movk, movk.  See movptr().
 280     assert(nativeInstruction_at(insns+1)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 281     assert(nativeInstruction_at(insns+2)-&gt;is_movk(), &quot;wrong insns in patch&quot;);
 282     return address(u_int64_t(Instruction_aarch64::extract(insns[0], 20, 5))
 283                    + (u_int64_t(Instruction_aarch64::extract(insns[1], 20, 5)) &lt;&lt; 16)
 284                    + (u_int64_t(Instruction_aarch64::extract(insns[2], 20, 5)) &lt;&lt; 32));
 285   } else if (Instruction_aarch64::extract(insn, 31, 22) == 0b1011100101 &amp;&amp;
 286              Instruction_aarch64::extract(insn, 4, 0) == 0b11111) {
 287     return 0;
 288   } else {
 289     ShouldNotReachHere();
 290   }
 291   return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
 292 }
 293 
 294 void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
 295   ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));
 296   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
 297 }
 298 
 299 // Just like safepoint_poll, but use an acquiring load for thread-
 300 // local polling.
 301 //
 302 // We need an acquire here to ensure that any subsequent load of the
 303 // global SafepointSynchronize::_state flag is ordered after this load
 304 // of the local Thread::_polling page.  We don&#39;t want this poll to
 305 // return false (i.e. not safepointing) and a later poll of the global
 306 // SafepointSynchronize::_state spuriously to return true.
 307 //
 308 // This is to avoid a race when we&#39;re in a native-&gt;Java transition
 309 // racing the code which wakes up from a safepoint.
 310 //
 311 void MacroAssembler::safepoint_poll_acquire(Label&amp; slow_path) {
 312   lea(rscratch1, Address(rthread, Thread::polling_page_offset()));
 313   ldar(rscratch1, rscratch1);
 314   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);
 315 }
 316 
 317 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 318   // we must set sp to zero to clear frame
 319   str(zr, Address(rthread, JavaThread::last_Java_sp_offset()));
 320 
 321   // must clear fp, so that compiled frames are not confused; it is
 322   // possible that we need it only for debugging
 323   if (clear_fp) {
 324     str(zr, Address(rthread, JavaThread::last_Java_fp_offset()));
 325   }
 326 
 327   // Always clear the pc because it could have been set by make_walkable()
 328   str(zr, Address(rthread, JavaThread::last_Java_pc_offset()));
 329 }
 330 
 331 // Calls to C land
 332 //
 333 // When entering C land, the rfp, &amp; resp of the last Java frame have to be recorded
 334 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
 335 // has to be reset to 0. This is required to allow proper stack traversal.
 336 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 337                                          Register last_java_fp,
 338                                          Register last_java_pc,
 339                                          Register scratch) {
 340 
 341   if (last_java_pc-&gt;is_valid()) {
 342       str(last_java_pc, Address(rthread,
 343                                 JavaThread::frame_anchor_offset()
 344                                 + JavaFrameAnchor::last_Java_pc_offset()));
 345     }
 346 
 347   // determine last_java_sp register
 348   if (last_java_sp == sp) {
 349     mov(scratch, sp);
 350     last_java_sp = scratch;
 351   } else if (!last_java_sp-&gt;is_valid()) {
 352     last_java_sp = esp;
 353   }
 354 
 355   str(last_java_sp, Address(rthread, JavaThread::last_Java_sp_offset()));
 356 
 357   // last_java_fp is optional
 358   if (last_java_fp-&gt;is_valid()) {
 359     str(last_java_fp, Address(rthread, JavaThread::last_Java_fp_offset()));
 360   }
 361 }
 362 
 363 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 364                                          Register last_java_fp,
 365                                          address  last_java_pc,
 366                                          Register scratch) {
 367   assert(last_java_pc != NULL, &quot;must provide a valid PC&quot;);
 368 
 369   adr(scratch, last_java_pc);
 370   str(scratch, Address(rthread,
 371                        JavaThread::frame_anchor_offset()
 372                        + JavaFrameAnchor::last_Java_pc_offset()));
 373 
 374   set_last_Java_frame(last_java_sp, last_java_fp, noreg, scratch);
 375 }
 376 
 377 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 378                                          Register last_java_fp,
 379                                          Label &amp;L,
 380                                          Register scratch) {
 381   if (L.is_bound()) {
 382     set_last_Java_frame(last_java_sp, last_java_fp, target(L), scratch);
 383   } else {
 384     InstructionMark im(this);
 385     L.add_patch_at(code(), locator());
 386     set_last_Java_frame(last_java_sp, last_java_fp, pc() /* Patched later */, scratch);
 387   }
 388 }
 389 
 390 void MacroAssembler::far_call(Address entry, CodeBuffer *cbuf, Register tmp) {
 391   assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
 392   assert(CodeCache::find_blob(entry.target()) != NULL,
 393          &quot;destination of far call not found in code cache&quot;);
 394   if (far_branches()) {
 395     unsigned long offset;
 396     // We can use ADRP here because we know that the total size of
 397     // the code cache cannot exceed 2Gb.
 398     adrp(tmp, entry, offset);
 399     add(tmp, tmp, offset);
 400     if (cbuf) cbuf-&gt;set_insts_mark();
 401     blr(tmp);
 402   } else {
 403     if (cbuf) cbuf-&gt;set_insts_mark();
 404     bl(entry);
 405   }
 406 }
 407 
 408 void MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {
 409   assert(ReservedCodeCacheSize &lt; 4*G, &quot;branch out of range&quot;);
 410   assert(CodeCache::find_blob(entry.target()) != NULL,
 411          &quot;destination of far call not found in code cache&quot;);
 412   if (far_branches()) {
 413     unsigned long offset;
 414     // We can use ADRP here because we know that the total size of
 415     // the code cache cannot exceed 2Gb.
 416     adrp(tmp, entry, offset);
 417     add(tmp, tmp, offset);
 418     if (cbuf) cbuf-&gt;set_insts_mark();
 419     br(tmp);
 420   } else {
 421     if (cbuf) cbuf-&gt;set_insts_mark();
 422     b(entry);
 423   }
 424 }
 425 
 426 void MacroAssembler::reserved_stack_check() {
 427     // testing if reserved zone needs to be enabled
 428     Label no_reserved_zone_enabling;
 429 
 430     ldr(rscratch1, Address(rthread, JavaThread::reserved_stack_activation_offset()));
 431     cmp(sp, rscratch1);
 432     br(Assembler::LO, no_reserved_zone_enabling);
 433 
 434     enter();   // LR and FP are live.
 435     lea(rscratch1, CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone));
 436     mov(c_rarg0, rthread);
 437     blr(rscratch1);
 438     leave();
 439 
 440     // We have already removed our own frame.
 441     // throw_delayed_StackOverflowError will think that it&#39;s been
 442     // called by our caller.
 443     lea(rscratch1, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
 444     br(rscratch1);
 445     should_not_reach_here();
 446 
 447     bind(no_reserved_zone_enabling);
 448 }
 449 
 450 int MacroAssembler::biased_locking_enter(Register lock_reg,
 451                                          Register obj_reg,
 452                                          Register swap_reg,
 453                                          Register tmp_reg,
 454                                          bool swap_reg_contains_mark,
 455                                          Label&amp; done,
 456                                          Label* slow_case,
 457                                          BiasedLockingCounters* counters) {
 458   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 459   assert_different_registers(lock_reg, obj_reg, swap_reg);
 460 
 461   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL)
 462     counters = BiasedLocking::counters();
 463 
 464   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg, rscratch1, rscratch2, noreg);
 465   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
 466   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
 467   Address klass_addr     (obj_reg, oopDesc::klass_offset_in_bytes());
 468   Address saved_mark_addr(lock_reg, 0);
 469 
 470   // Biased locking
 471   // See whether the lock is currently biased toward our thread and
 472   // whether the epoch is still valid
 473   // Note that the runtime guarantees sufficient alignment of JavaThread
 474   // pointers to allow age to be placed into low bits
 475   // First check to see whether biasing is even enabled for this object
 476   Label cas_label;
 477   int null_check_offset = -1;
 478   if (!swap_reg_contains_mark) {
 479     null_check_offset = offset();
 480     ldr(swap_reg, mark_addr);
 481   }
 482   andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);
 483   cmp(tmp_reg, (u1)markWord::biased_lock_pattern);
 484   br(Assembler::NE, cas_label);
 485   // The bias pattern is present in the object&#39;s header. Need to check
 486   // whether the bias owner and the epoch are both still current.
 487   load_prototype_header(tmp_reg, obj_reg);
 488   orr(tmp_reg, tmp_reg, rthread);
 489   eor(tmp_reg, swap_reg, tmp_reg);
 490   andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));
 491   if (counters != NULL) {
 492     Label around;
 493     cbnz(tmp_reg, around);
 494     atomic_incw(Address((address)counters-&gt;biased_lock_entry_count_addr()), tmp_reg, rscratch1, rscratch2);
 495     b(done);
 496     bind(around);
 497   } else {
 498     cbz(tmp_reg, done);
 499   }
 500 
 501   Label try_revoke_bias;
 502   Label try_rebias;
 503 
 504   // At this point we know that the header has the bias pattern and
 505   // that we are not the bias owner in the current epoch. We need to
 506   // figure out more details about the state of the header in order to
 507   // know what operations can be legally performed on the object&#39;s
 508   // header.
 509 
 510   // If the low three bits in the xor result aren&#39;t clear, that means
 511   // the prototype header is no longer biased and we have to revoke
 512   // the bias on this object.
 513   andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);
 514   cbnz(rscratch1, try_revoke_bias);
 515 
 516   // Biasing is still enabled for this data type. See whether the
 517   // epoch of the current bias is still valid, meaning that the epoch
 518   // bits of the mark word are equal to the epoch bits of the
 519   // prototype header. (Note that the prototype header&#39;s epoch bits
 520   // only change at a safepoint.) If not, attempt to rebias the object
 521   // toward the current thread. Note that we must be absolutely sure
 522   // that the current epoch is invalid in order to do this because
 523   // otherwise the manipulations it performs on the mark word are
 524   // illegal.
 525   andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);
 526   cbnz(rscratch1, try_rebias);
 527 
 528   // The epoch of the current bias is still valid but we know nothing
 529   // about the owner; it might be set or it might be clear. Try to
 530   // acquire the bias of the object using an atomic operation. If this
 531   // fails we will go in to the runtime to revoke the object&#39;s bias.
 532   // Note that we first construct the presumed unbiased header so we
 533   // don&#39;t accidentally blow away another thread&#39;s valid bias.
 534   {
 535     Label here;
 536     mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
 537     andr(swap_reg, swap_reg, rscratch1);
 538     orr(tmp_reg, swap_reg, rthread);
 539     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);
 540     // If the biasing toward our thread failed, this means that
 541     // another thread succeeded in biasing it toward itself and we
 542     // need to revoke that bias. The revocation will occur in the
 543     // interpreter runtime in the slow case.
 544     bind(here);
 545     if (counters != NULL) {
 546       atomic_incw(Address((address)counters-&gt;anonymously_biased_lock_entry_count_addr()),
 547                   tmp_reg, rscratch1, rscratch2);
 548     }
 549   }
 550   b(done);
 551 
 552   bind(try_rebias);
 553   // At this point we know the epoch has expired, meaning that the
 554   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
 555   // circumstances _only_, we are allowed to use the current header&#39;s
 556   // value as the comparison value when doing the cas to acquire the
 557   // bias in the current epoch. In other words, we allow transfer of
 558   // the bias from one thread to another directly in this situation.
 559   //
 560   // FIXME: due to a lack of registers we currently blow away the age
 561   // bits in this situation. Should attempt to preserve them.
 562   {
 563     Label here;
 564     load_prototype_header(tmp_reg, obj_reg);
 565     orr(tmp_reg, rthread, tmp_reg);
 566     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, slow_case);
 567     // If the biasing toward our thread failed, then another thread
 568     // succeeded in biasing it toward itself and we need to revoke that
 569     // bias. The revocation will occur in the runtime in the slow case.
 570     bind(here);
 571     if (counters != NULL) {
 572       atomic_incw(Address((address)counters-&gt;rebiased_lock_entry_count_addr()),
 573                   tmp_reg, rscratch1, rscratch2);
 574     }
 575   }
 576   b(done);
 577 
 578   bind(try_revoke_bias);
 579   // The prototype mark in the klass doesn&#39;t have the bias bit set any
 580   // more, indicating that objects of this data type are not supposed
 581   // to be biased any more. We are going to try to reset the mark of
 582   // this object to the prototype value and fall through to the
 583   // CAS-based locking scheme. Note that if our CAS fails, it means
 584   // that another thread raced us for the privilege of revoking the
 585   // bias of this particular object, so it&#39;s okay to continue in the
 586   // normal locking code.
 587   //
 588   // FIXME: due to a lack of registers we currently blow away the age
 589   // bits in this situation. Should attempt to preserve them.
 590   {
 591     Label here, nope;
 592     load_prototype_header(tmp_reg, obj_reg);
 593     cmpxchg_obj_header(swap_reg, tmp_reg, obj_reg, rscratch1, here, &amp;nope);
 594     bind(here);
 595 
 596     // Fall through to the normal CAS-based lock, because no matter what
 597     // the result of the above CAS, some thread must have succeeded in
 598     // removing the bias bit from the object&#39;s header.
 599     if (counters != NULL) {
 600       atomic_incw(Address((address)counters-&gt;revoked_lock_entry_count_addr()), tmp_reg,
 601                   rscratch1, rscratch2);
 602     }
 603     bind(nope);
 604   }
 605 
 606   bind(cas_label);
 607 
 608   return null_check_offset;
 609 }
 610 
 611 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
 612   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
 613 
 614   // Check for biased locking unlock case, which is a no-op
 615   // Note: we do not have to check the thread ID for two reasons.
 616   // First, the interpreter checks for IllegalMonitorStateException at
 617   // a higher level. Second, if the bias was revoked while we held the
 618   // lock, the object could not be rebiased toward another thread, so
 619   // the bias bit would be clear.
 620   ldr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
 621   andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);
 622   cmp(temp_reg, (u1)markWord::biased_lock_pattern);
 623   br(Assembler::EQ, done);
 624 }
 625 
 626 static void pass_arg0(MacroAssembler* masm, Register arg) {
 627   if (c_rarg0 != arg ) {
 628     masm-&gt;mov(c_rarg0, arg);
 629   }
 630 }
 631 
 632 static void pass_arg1(MacroAssembler* masm, Register arg) {
 633   if (c_rarg1 != arg ) {
 634     masm-&gt;mov(c_rarg1, arg);
 635   }
 636 }
 637 
 638 static void pass_arg2(MacroAssembler* masm, Register arg) {
 639   if (c_rarg2 != arg ) {
 640     masm-&gt;mov(c_rarg2, arg);
 641   }
 642 }
 643 
 644 static void pass_arg3(MacroAssembler* masm, Register arg) {
 645   if (c_rarg3 != arg ) {
 646     masm-&gt;mov(c_rarg3, arg);
 647   }
 648 }
 649 
 650 void MacroAssembler::call_VM_base(Register oop_result,
 651                                   Register java_thread,
 652                                   Register last_java_sp,
 653                                   address  entry_point,
 654                                   int      number_of_arguments,
 655                                   bool     check_exceptions) {
 656    // determine java_thread register
 657   if (!java_thread-&gt;is_valid()) {
 658     java_thread = rthread;
 659   }
 660 
 661   // determine last_java_sp register
 662   if (!last_java_sp-&gt;is_valid()) {
 663     last_java_sp = esp;
 664   }
 665 
 666   // debugging support
 667   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
 668   assert(java_thread == rthread, &quot;unexpected register&quot;);
 669 #ifdef ASSERT
 670   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
 671   // if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);
 672 #endif // ASSERT
 673 
 674   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
 675   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
 676 
 677   // push java thread (becomes first argument of C function)
 678 
 679   mov(c_rarg0, java_thread);
 680 
 681   // set last Java frame before call
 682   assert(last_java_sp != rfp, &quot;can&#39;t use rfp&quot;);
 683 
 684   Label l;
 685   set_last_Java_frame(last_java_sp, rfp, l, rscratch1);
 686 
 687   // do the call, remove parameters
 688   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments, &amp;l);
 689 
 690   // reset last Java frame
 691   // Only interpreter should have to clear fp
 692   reset_last_Java_frame(true);
 693 
 694    // C++ interp handles this in the interpreter
 695   check_and_handle_popframe(java_thread);
 696   check_and_handle_earlyret(java_thread);
 697 
 698   if (check_exceptions) {
 699     // check for pending exceptions (java_thread is set upon return)
 700     ldr(rscratch1, Address(java_thread, in_bytes(Thread::pending_exception_offset())));
 701     Label ok;
 702     cbz(rscratch1, ok);
 703     lea(rscratch1, RuntimeAddress(StubRoutines::forward_exception_entry()));
 704     br(rscratch1);
 705     bind(ok);
 706   }
 707 
 708   // get oop result if there is one and reset the value in the thread
 709   if (oop_result-&gt;is_valid()) {
 710     get_vm_result(oop_result, java_thread);
 711   }
 712 }
 713 
 714 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
 715   call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);
 716 }
 717 
 718 // Maybe emit a call via a trampoline.  If the code cache is small
 719 // trampolines won&#39;t be emitted.
 720 
 721 address MacroAssembler::trampoline_call(Address entry, CodeBuffer *cbuf) {
 722   assert(JavaThread::current()-&gt;is_Compiler_thread(), &quot;just checking&quot;);
 723   assert(entry.rspec().type() == relocInfo::runtime_call_type
 724          || entry.rspec().type() == relocInfo::opt_virtual_call_type
 725          || entry.rspec().type() == relocInfo::static_call_type
 726          || entry.rspec().type() == relocInfo::virtual_call_type, &quot;wrong reloc type&quot;);
 727 
 728   // We need a trampoline if branches are far.
 729   if (far_branches()) {
 730     bool in_scratch_emit_size = false;
 731 #ifdef COMPILER2
 732     // We don&#39;t want to emit a trampoline if C2 is generating dummy
 733     // code during its branch shortening phase.
 734     CompileTask* task = ciEnv::current()-&gt;task();
 735     in_scratch_emit_size =
 736       (task != NULL &amp;&amp; is_c2_compile(task-&gt;comp_level()) &amp;&amp;
 737        Compile::current()-&gt;output()-&gt;in_scratch_emit_size());
 738 #endif
 739     if (!in_scratch_emit_size) {
 740       address stub = emit_trampoline_stub(offset(), entry.target());
 741       if (stub == NULL) {
 742         return NULL; // CodeCache is full
 743       }
 744     }
 745   }
 746 
 747   if (cbuf) cbuf-&gt;set_insts_mark();
 748   relocate(entry.rspec());
 749   if (!far_branches()) {
 750     bl(entry.target());
 751   } else {
 752     bl(pc());
 753   }
 754   // just need to return a non-null address
 755   return pc();
 756 }
 757 
 758 
 759 // Emit a trampoline stub for a call to a target which is too far away.
 760 //
 761 // code sequences:
 762 //
 763 // call-site:
 764 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 765 //
 766 // Related trampoline stub for this call site in the stub section:
 767 //   load the call target from the constant pool
 768 //   branch (LR still points to the call site above)
 769 
 770 address MacroAssembler::emit_trampoline_stub(int insts_call_instruction_offset,
 771                                              address dest) {
 772   // Max stub size: alignment nop, TrampolineStub.
 773   address stub = start_a_stub(NativeInstruction::instruction_size
 774                    + NativeCallTrampolineStub::instruction_size);
 775   if (stub == NULL) {
 776     return NULL;  // CodeBuffer::expand failed
 777   }
 778 
 779   // Create a trampoline stub relocation which relates this trampoline stub
 780   // with the call instruction at insts_call_instruction_offset in the
 781   // instructions code-section.
 782   align(wordSize);
 783   relocate(trampoline_stub_Relocation::spec(code()-&gt;insts()-&gt;start()
 784                                             + insts_call_instruction_offset));
 785   const int stub_start_offset = offset();
 786 
 787   // Now, create the trampoline stub&#39;s code:
 788   // - load the call
 789   // - call
 790   Label target;
 791   ldr(rscratch1, target);
 792   br(rscratch1);
 793   bind(target);
 794   assert(offset() - stub_start_offset == NativeCallTrampolineStub::data_offset,
 795          &quot;should be&quot;);
 796   emit_int64((int64_t)dest);
 797 
 798   const address stub_start_addr = addr_at(stub_start_offset);
 799 
 800   assert(is_NativeCallTrampolineStub_at(stub_start_addr), &quot;doesn&#39;t look like a trampoline&quot;);
 801 
 802   end_a_stub();
 803   return stub_start_addr;
 804 }
 805 
 806 void MacroAssembler::emit_static_call_stub() {
 807   // CompiledDirectStaticCall::set_to_interpreted knows the
 808   // exact layout of this stub.
 809 
 810   isb();
 811   mov_metadata(rmethod, (Metadata*)NULL);
 812 
 813   // Jump to the entry point of the i2c stub.
 814   movptr(rscratch1, 0);
 815   br(rscratch1);
 816 }
 817 
 818 void MacroAssembler::c2bool(Register x) {
 819   // implements x == 0 ? 0 : 1
 820   // note: must only look at least-significant byte of x
 821   //       since C-style booleans are stored in one byte
 822   //       only! (was bug)
 823   tst(x, 0xff);
 824   cset(x, Assembler::NE);
 825 }
 826 
 827 address MacroAssembler::ic_call(address entry, jint method_index) {
 828   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
 829   // address const_ptr = long_constant((jlong)Universe::non_oop_word());
 830   // unsigned long offset;
 831   // ldr_constant(rscratch2, const_ptr);
 832   movptr(rscratch2, (uintptr_t)Universe::non_oop_word());
 833   return trampoline_call(Address(entry, rh));
 834 }
 835 
 836 // Implementation of call_VM versions
 837 
 838 void MacroAssembler::call_VM(Register oop_result,
 839                              address entry_point,
 840                              bool check_exceptions) {
 841   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
 842 }
 843 
 844 void MacroAssembler::call_VM(Register oop_result,
 845                              address entry_point,
 846                              Register arg_1,
 847                              bool check_exceptions) {
 848   pass_arg1(this, arg_1);
 849   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
 850 }
 851 
 852 void MacroAssembler::call_VM(Register oop_result,
 853                              address entry_point,
 854                              Register arg_1,
 855                              Register arg_2,
 856                              bool check_exceptions) {
 857   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 858   pass_arg2(this, arg_2);
 859   pass_arg1(this, arg_1);
 860   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
 861 }
 862 
 863 void MacroAssembler::call_VM(Register oop_result,
 864                              address entry_point,
 865                              Register arg_1,
 866                              Register arg_2,
 867                              Register arg_3,
 868                              bool check_exceptions) {
 869   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
 870   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
 871   pass_arg3(this, arg_3);
 872 
 873   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 874   pass_arg2(this, arg_2);
 875 
 876   pass_arg1(this, arg_1);
 877   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
 878 }
 879 
 880 void MacroAssembler::call_VM(Register oop_result,
 881                              Register last_java_sp,
 882                              address entry_point,
 883                              int number_of_arguments,
 884                              bool check_exceptions) {
 885   call_VM_base(oop_result, rthread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
 886 }
 887 
 888 void MacroAssembler::call_VM(Register oop_result,
 889                              Register last_java_sp,
 890                              address entry_point,
 891                              Register arg_1,
 892                              bool check_exceptions) {
 893   pass_arg1(this, arg_1);
 894   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
 895 }
 896 
 897 void MacroAssembler::call_VM(Register oop_result,
 898                              Register last_java_sp,
 899                              address entry_point,
 900                              Register arg_1,
 901                              Register arg_2,
 902                              bool check_exceptions) {
 903 
 904   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 905   pass_arg2(this, arg_2);
 906   pass_arg1(this, arg_1);
 907   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
 908 }
 909 
 910 void MacroAssembler::call_VM(Register oop_result,
 911                              Register last_java_sp,
 912                              address entry_point,
 913                              Register arg_1,
 914                              Register arg_2,
 915                              Register arg_3,
 916                              bool check_exceptions) {
 917   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
 918   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
 919   pass_arg3(this, arg_3);
 920   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
 921   pass_arg2(this, arg_2);
 922   pass_arg1(this, arg_1);
 923   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
 924 }
 925 
 926 
 927 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
 928   ldr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
 929   str(zr, Address(java_thread, JavaThread::vm_result_offset()));
 930   verify_oop(oop_result, &quot;broken oop in call_VM_base&quot;);
 931 }
 932 
 933 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
 934   ldr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
 935   str(zr, Address(java_thread, JavaThread::vm_result_2_offset()));
 936 }
 937 
 938 void MacroAssembler::align(int modulus) {
 939   while (offset() % modulus != 0) nop();
 940 }
 941 
 942 // these are no-ops overridden by InterpreterMacroAssembler
 943 
 944 void MacroAssembler::check_and_handle_earlyret(Register java_thread) { }
 945 
 946 void MacroAssembler::check_and_handle_popframe(Register java_thread) { }
 947 
 948 
 949 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
 950                                                       Register tmp,
 951                                                       int offset) {
 952   intptr_t value = *delayed_value_addr;
 953   if (value != 0)
 954     return RegisterOrConstant(value + offset);
 955 
 956   // load indirectly to solve generation ordering problem
 957   ldr(tmp, ExternalAddress((address) delayed_value_addr));
 958 
 959   if (offset != 0)
 960     add(tmp, tmp, offset);
 961 
 962   return RegisterOrConstant(tmp);
 963 }
 964 
 965 // Look up the method for a megamorphic invokeinterface call.
 966 // The target method is determined by &lt;intf_klass, itable_index&gt;.
 967 // The receiver klass is in recv_klass.
 968 // On success, the result will be in method_result, and execution falls through.
 969 // On failure, execution transfers to the given label.
 970 void MacroAssembler::lookup_interface_method(Register recv_klass,
 971                                              Register intf_klass,
 972                                              RegisterOrConstant itable_index,
 973                                              Register method_result,
 974                                              Register scan_temp,
 975                                              Label&amp; L_no_such_interface,
 976                          bool return_method) {
 977   assert_different_registers(recv_klass, intf_klass, scan_temp);
 978   assert_different_registers(method_result, intf_klass, scan_temp);
 979   assert(recv_klass != method_result || !return_method,
 980      &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
 981   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
 982          &quot;caller must use same register for non-constant itable index as for method&quot;);
 983 
 984   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
 985   int vtable_base = in_bytes(Klass::vtable_start_offset());
 986   int itentry_off = itableMethodEntry::method_offset_in_bytes();
 987   int scan_step   = itableOffsetEntry::size() * wordSize;
 988   int vte_size    = vtableEntry::size_in_bytes();
 989   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
 990 
 991   ldrw(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
 992 
 993   // %%% Could store the aligned, prescaled offset in the klassoop.
 994   // lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
 995   lea(scan_temp, Address(recv_klass, scan_temp, Address::lsl(3)));
 996   add(scan_temp, scan_temp, vtable_base);
 997 
 998   if (return_method) {
 999     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
1000     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
1001     // lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
1002     lea(recv_klass, Address(recv_klass, itable_index, Address::lsl(3)));
1003     if (itentry_off)
1004       add(recv_klass, recv_klass, itentry_off);
1005   }
1006 
1007   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
1008   //   if (scan-&gt;interface() == intf) {
1009   //     result = (klass + scan-&gt;offset() + itable_index);
1010   //   }
1011   // }
1012   Label search, found_method;
1013 
1014   for (int peel = 1; peel &gt;= 0; peel--) {
1015     ldr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
1016     cmp(intf_klass, method_result);
1017 
1018     if (peel) {
1019       br(Assembler::EQ, found_method);
1020     } else {
1021       br(Assembler::NE, search);
1022       // (invert the test to fall through to found_method...)
1023     }
1024 
1025     if (!peel)  break;
1026 
1027     bind(search);
1028 
1029     // Check that the previous entry is non-null.  A null entry means that
1030     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
1031     // same as when the caller was compiled.
1032     cbz(method_result, L_no_such_interface);
1033     add(scan_temp, scan_temp, scan_step);
1034   }
1035 
1036   bind(found_method);
1037 
1038   // Got a hit.
1039   if (return_method) {
1040     ldrw(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
1041     ldr(method_result, Address(recv_klass, scan_temp, Address::uxtw(0)));
1042   }
1043 }
1044 
1045 // virtual method calling
1046 void MacroAssembler::lookup_virtual_method(Register recv_klass,
1047                                            RegisterOrConstant vtable_index,
1048                                            Register method_result) {
1049   const int base = in_bytes(Klass::vtable_start_offset());
1050   assert(vtableEntry::size() * wordSize == 8,
1051          &quot;adjust the scaling in the code below&quot;);
1052   int vtable_offset_in_bytes = base + vtableEntry::method_offset_in_bytes();
1053 
1054   if (vtable_index.is_register()) {
1055     lea(method_result, Address(recv_klass,
1056                                vtable_index.as_register(),
1057                                Address::lsl(LogBytesPerWord)));
1058     ldr(method_result, Address(method_result, vtable_offset_in_bytes));
1059   } else {
1060     vtable_offset_in_bytes += vtable_index.as_constant() * wordSize;
1061     ldr(method_result,
1062         form_address(rscratch1, recv_klass, vtable_offset_in_bytes, 0));
1063   }
1064 }
1065 
1066 void MacroAssembler::check_klass_subtype(Register sub_klass,
1067                            Register super_klass,
1068                            Register temp_reg,
1069                            Label&amp; L_success) {
1070   Label L_failure;
1071   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
1072   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
1073   bind(L_failure);
1074 }
1075 
1076 
1077 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
1078                                                    Register super_klass,
1079                                                    Register temp_reg,
1080                                                    Label* L_success,
1081                                                    Label* L_failure,
1082                                                    Label* L_slow_path,
1083                                         RegisterOrConstant super_check_offset) {
1084   assert_different_registers(sub_klass, super_klass, temp_reg);
1085   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
1086   if (super_check_offset.is_register()) {
1087     assert_different_registers(sub_klass, super_klass,
1088                                super_check_offset.as_register());
1089   } else if (must_load_sco) {
1090     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
1091   }
1092 
1093   Label L_fallthrough;
1094   int label_nulls = 0;
1095   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
1096   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
1097   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
1098   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
1099 
1100   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
1101   int sco_offset = in_bytes(Klass::super_check_offset_offset());
1102   Address super_check_offset_addr(super_klass, sco_offset);
1103 
1104   // Hacked jmp, which may only be used just before L_fallthrough.
1105 #define final_jmp(label)                                                \
1106   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
1107   else                            b(label)                /*omit semi*/
1108 
1109   // If the pointers are equal, we are done (e.g., String[] elements).
1110   // This self-check enables sharing of secondary supertype arrays among
1111   // non-primary types such as array-of-interface.  Otherwise, each such
1112   // type would need its own customized SSA.
1113   // We move this check to the front of the fast path because many
1114   // type checks are in fact trivially successful in this manner,
1115   // so we get a nicely predicted branch right at the start of the check.
1116   cmp(sub_klass, super_klass);
1117   br(Assembler::EQ, *L_success);
1118 
1119   // Check the supertype display:
1120   if (must_load_sco) {
1121     ldrw(temp_reg, super_check_offset_addr);
1122     super_check_offset = RegisterOrConstant(temp_reg);
1123   }
1124   Address super_check_addr(sub_klass, super_check_offset);
1125   ldr(rscratch1, super_check_addr);
1126   cmp(super_klass, rscratch1); // load displayed supertype
1127 
1128   // This check has worked decisively for primary supers.
1129   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
1130   // (Secondary supers are interfaces and very deeply nested subtypes.)
1131   // This works in the same check above because of a tricky aliasing
1132   // between the super_cache and the primary super display elements.
1133   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
1134   // Note that the cache is updated below if it does not help us find
1135   // what we need immediately.
1136   // So if it was a primary super, we can just fail immediately.
1137   // Otherwise, it&#39;s the slow path for us (no success at this point).
1138 
1139   if (super_check_offset.is_register()) {
1140     br(Assembler::EQ, *L_success);
1141     subs(zr, super_check_offset.as_register(), sc_offset);
1142     if (L_failure == &amp;L_fallthrough) {
1143       br(Assembler::EQ, *L_slow_path);
1144     } else {
1145       br(Assembler::NE, *L_failure);
1146       final_jmp(*L_slow_path);
1147     }
1148   } else if (super_check_offset.as_constant() == sc_offset) {
1149     // Need a slow path; fast failure is impossible.
1150     if (L_slow_path == &amp;L_fallthrough) {
1151       br(Assembler::EQ, *L_success);
1152     } else {
1153       br(Assembler::NE, *L_slow_path);
1154       final_jmp(*L_success);
1155     }
1156   } else {
1157     // No slow path; it&#39;s a fast decision.
1158     if (L_failure == &amp;L_fallthrough) {
1159       br(Assembler::EQ, *L_success);
1160     } else {
1161       br(Assembler::NE, *L_failure);
1162       final_jmp(*L_success);
1163     }
1164   }
1165 
1166   bind(L_fallthrough);
1167 
1168 #undef final_jmp
1169 }
1170 
1171 // These two are taken from x86, but they look generally useful
1172 
1173 // scans count pointer sized words at [addr] for occurence of value,
1174 // generic
1175 void MacroAssembler::repne_scan(Register addr, Register value, Register count,
1176                                 Register scratch) {
1177   Label Lloop, Lexit;
1178   cbz(count, Lexit);
1179   bind(Lloop);
1180   ldr(scratch, post(addr, wordSize));
1181   cmp(value, scratch);
1182   br(EQ, Lexit);
1183   sub(count, count, 1);
1184   cbnz(count, Lloop);
1185   bind(Lexit);
1186 }
1187 
1188 // scans count 4 byte words at [addr] for occurence of value,
1189 // generic
1190 void MacroAssembler::repne_scanw(Register addr, Register value, Register count,
1191                                 Register scratch) {
1192   Label Lloop, Lexit;
1193   cbz(count, Lexit);
1194   bind(Lloop);
1195   ldrw(scratch, post(addr, wordSize));
1196   cmpw(value, scratch);
1197   br(EQ, Lexit);
1198   sub(count, count, 1);
1199   cbnz(count, Lloop);
1200   bind(Lexit);
1201 }
1202 
1203 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
1204                                                    Register super_klass,
1205                                                    Register temp_reg,
1206                                                    Register temp2_reg,
1207                                                    Label* L_success,
1208                                                    Label* L_failure,
1209                                                    bool set_cond_codes) {
1210   assert_different_registers(sub_klass, super_klass, temp_reg);
1211   if (temp2_reg != noreg)
1212     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg, rscratch1);
1213 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
1214 
1215   Label L_fallthrough;
1216   int label_nulls = 0;
1217   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
1218   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
1219   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
1220 
1221   // a couple of useful fields in sub_klass:
1222   int ss_offset = in_bytes(Klass::secondary_supers_offset());
1223   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
1224   Address secondary_supers_addr(sub_klass, ss_offset);
1225   Address super_cache_addr(     sub_klass, sc_offset);
1226 
1227   BLOCK_COMMENT(&quot;check_klass_subtype_slow_path&quot;);
1228 
1229   // Do a linear scan of the secondary super-klass chain.
1230   // This code is rarely used, so simplicity is a virtue here.
1231   // The repne_scan instruction uses fixed registers, which we must spill.
1232   // Don&#39;t worry too much about pre-existing connections with the input regs.
1233 
1234   assert(sub_klass != r0, &quot;killed reg&quot;); // killed by mov(r0, super)
1235   assert(sub_klass != r2, &quot;killed reg&quot;); // killed by lea(r2, &amp;pst_counter)
1236 
1237   RegSet pushed_registers;
1238   if (!IS_A_TEMP(r2))    pushed_registers += r2;
1239   if (!IS_A_TEMP(r5))    pushed_registers += r5;
1240 
1241   if (super_klass != r0 || UseCompressedOops) {
1242     if (!IS_A_TEMP(r0))   pushed_registers += r0;
1243   }
1244 
1245   push(pushed_registers, sp);
1246 
1247   // Get super_klass value into r0 (even if it was in r5 or r2).
1248   if (super_klass != r0) {
1249     mov(r0, super_klass);
1250   }
1251 
1252 #ifndef PRODUCT
1253   mov(rscratch2, (address)&amp;SharedRuntime::_partial_subtype_ctr);
1254   Address pst_counter_addr(rscratch2);
1255   ldr(rscratch1, pst_counter_addr);
1256   add(rscratch1, rscratch1, 1);
1257   str(rscratch1, pst_counter_addr);
1258 #endif //PRODUCT
1259 
1260   // We will consult the secondary-super array.
1261   ldr(r5, secondary_supers_addr);
1262   // Load the array length.
1263   ldrw(r2, Address(r5, Array&lt;Klass*&gt;::length_offset_in_bytes()));
1264   // Skip to start of data.
1265   add(r5, r5, Array&lt;Klass*&gt;::base_offset_in_bytes());
1266 
1267   cmp(sp, zr); // Clear Z flag; SP is never zero
1268   // Scan R2 words at [R5] for an occurrence of R0.
1269   // Set NZ/Z based on last compare.
1270   repne_scan(r5, r0, r2, rscratch1);
1271 
1272   // Unspill the temp. registers:
1273   pop(pushed_registers, sp);
1274 
1275   br(Assembler::NE, *L_failure);
1276 
1277   // Success.  Cache the super we found and proceed in triumph.
1278   str(super_klass, super_cache_addr);
1279 
1280   if (L_success != &amp;L_fallthrough) {
1281     b(*L_success);
1282   }
1283 
1284 #undef IS_A_TEMP
1285 
1286   bind(L_fallthrough);
1287 }
1288 
1289 void MacroAssembler::clinit_barrier(Register klass, Register scratch, Label* L_fast_path, Label* L_slow_path) {
1290   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
1291   assert_different_registers(klass, rthread, scratch);
1292 
1293   Label L_fallthrough, L_tmp;
1294   if (L_fast_path == NULL) {
1295     L_fast_path = &amp;L_fallthrough;
1296   } else if (L_slow_path == NULL) {
1297     L_slow_path = &amp;L_fallthrough;
1298   }
1299   // Fast path check: class is fully initialized
1300   ldrb(scratch, Address(klass, InstanceKlass::init_state_offset()));
1301   subs(zr, scratch, InstanceKlass::fully_initialized);
1302   br(Assembler::EQ, *L_fast_path);
1303 
1304   // Fast path check: current thread is initializer thread
1305   ldr(scratch, Address(klass, InstanceKlass::init_thread_offset()));
1306   cmp(rthread, scratch);
1307 
1308   if (L_slow_path == &amp;L_fallthrough) {
1309     br(Assembler::EQ, *L_fast_path);
1310     bind(*L_slow_path);
1311   } else if (L_fast_path == &amp;L_fallthrough) {
1312     br(Assembler::NE, *L_slow_path);
1313     bind(*L_fast_path);
1314   } else {
1315     Unimplemented();
1316   }
1317 }
1318 
1319 void MacroAssembler::verify_oop(Register reg, const char* s) {
<a name="2" id="anc2"></a><span class="line-modified">1320   if (!VerifyOops || VerifyAdapterSharing) {</span>
<span class="line-added">1321     // Below address of the code string confuses VerifyAdapterSharing</span>
<span class="line-added">1322     // because it may differ between otherwise equivalent adapters.</span>
<span class="line-added">1323     return;</span>
<span class="line-added">1324   }</span>
1325 
1326   // Pass register number to verify_oop_subroutine
1327   const char* b = NULL;
1328   {
1329     ResourceMark rm;
1330     stringStream ss;
1331     ss.print(&quot;verify_oop: %s: %s&quot;, reg-&gt;name(), s);
1332     b = code_string(ss.as_string());
1333   }
1334   BLOCK_COMMENT(&quot;verify_oop {&quot;);
1335 
1336   stp(r0, rscratch1, Address(pre(sp, -2 * wordSize)));
1337   stp(rscratch2, lr, Address(pre(sp, -2 * wordSize)));
1338 
1339   mov(r0, reg);
1340   mov(rscratch1, (address)b);
1341 
1342   // call indirectly to solve generation ordering problem
1343   lea(rscratch2, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
1344   ldr(rscratch2, Address(rscratch2));
1345   blr(rscratch2);
1346 
1347   ldp(rscratch2, lr, Address(post(sp, 2 * wordSize)));
1348   ldp(r0, rscratch1, Address(post(sp, 2 * wordSize)));
1349 
1350   BLOCK_COMMENT(&quot;} verify_oop&quot;);
1351 }
1352 
1353 void MacroAssembler::verify_oop_addr(Address addr, const char* s) {
<a name="3" id="anc3"></a><span class="line-modified">1354   if (!VerifyOops || VerifyAdapterSharing) {</span>
<span class="line-added">1355     // Below address of the code string confuses VerifyAdapterSharing</span>
<span class="line-added">1356     // because it may differ between otherwise equivalent adapters.</span>
<span class="line-added">1357     return;</span>
<span class="line-added">1358   }</span>
1359 
1360   const char* b = NULL;
1361   {
1362     ResourceMark rm;
1363     stringStream ss;
1364     ss.print(&quot;verify_oop_addr: %s&quot;, s);
1365     b = code_string(ss.as_string());
1366   }
1367   BLOCK_COMMENT(&quot;verify_oop_addr {&quot;);
1368 
1369   stp(r0, rscratch1, Address(pre(sp, -2 * wordSize)));
1370   stp(rscratch2, lr, Address(pre(sp, -2 * wordSize)));
1371 
1372   // addr may contain sp so we will have to adjust it based on the
1373   // pushes that we just did.
1374   if (addr.uses(sp)) {
1375     lea(r0, addr);
1376     ldr(r0, Address(r0, 4 * wordSize));
1377   } else {
1378     ldr(r0, addr);
1379   }
1380   mov(rscratch1, (address)b);
1381 
1382   // call indirectly to solve generation ordering problem
1383   lea(rscratch2, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
1384   ldr(rscratch2, Address(rscratch2));
1385   blr(rscratch2);
1386 
1387   ldp(rscratch2, lr, Address(post(sp, 2 * wordSize)));
1388   ldp(r0, rscratch1, Address(post(sp, 2 * wordSize)));
1389 
1390   BLOCK_COMMENT(&quot;} verify_oop_addr&quot;);
1391 }
1392 
1393 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
1394                                          int extra_slot_offset) {
1395   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
1396   int stackElementSize = Interpreter::stackElementSize;
1397   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
1398 #ifdef ASSERT
1399   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
1400   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
1401 #endif
1402   if (arg_slot.is_constant()) {
1403     return Address(esp, arg_slot.as_constant() * stackElementSize
1404                    + offset);
1405   } else {
1406     add(rscratch1, esp, arg_slot.as_register(),
1407         ext::uxtx, exact_log2(stackElementSize));
1408     return Address(rscratch1, offset);
1409   }
1410 }
1411 
1412 void MacroAssembler::call_VM_leaf_base(address entry_point,
1413                                        int number_of_arguments,
1414                                        Label *retaddr) {
1415   Label E, L;
1416 
1417   stp(rscratch1, rmethod, Address(pre(sp, -2 * wordSize)));
1418 
1419   mov(rscratch1, entry_point);
1420   blr(rscratch1);
1421   if (retaddr)
1422     bind(*retaddr);
1423 
1424   ldp(rscratch1, rmethod, Address(post(sp, 2 * wordSize)));
1425   maybe_isb();
1426 }
1427 
1428 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1429   call_VM_leaf_base(entry_point, number_of_arguments);
1430 }
1431 
1432 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1433   pass_arg0(this, arg_0);
1434   call_VM_leaf_base(entry_point, 1);
1435 }
1436 
1437 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1438   pass_arg0(this, arg_0);
1439   pass_arg1(this, arg_1);
1440   call_VM_leaf_base(entry_point, 2);
1441 }
1442 
1443 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0,
1444                                   Register arg_1, Register arg_2) {
1445   pass_arg0(this, arg_0);
1446   pass_arg1(this, arg_1);
1447   pass_arg2(this, arg_2);
1448   call_VM_leaf_base(entry_point, 3);
1449 }
1450 
<a name="4" id="anc4"></a><span class="line-added">1451 void MacroAssembler::super_call_VM_leaf(address entry_point) {</span>
<span class="line-added">1452   MacroAssembler::call_VM_leaf_base(entry_point, 1);</span>
<span class="line-added">1453 }</span>
<span class="line-added">1454 </span>
1455 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1456   pass_arg0(this, arg_0);
1457   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1458 }
1459 
1460 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1461 
1462   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1463   pass_arg1(this, arg_1);
1464   pass_arg0(this, arg_0);
1465   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1466 }
1467 
1468 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1469   assert(arg_0 != c_rarg2, &quot;smashed arg&quot;);
1470   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
1471   pass_arg2(this, arg_2);
1472   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1473   pass_arg1(this, arg_1);
1474   pass_arg0(this, arg_0);
1475   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1476 }
1477 
1478 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1479   assert(arg_0 != c_rarg3, &quot;smashed arg&quot;);
1480   assert(arg_1 != c_rarg3, &quot;smashed arg&quot;);
1481   assert(arg_2 != c_rarg3, &quot;smashed arg&quot;);
1482   pass_arg3(this, arg_3);
1483   assert(arg_0 != c_rarg2, &quot;smashed arg&quot;);
1484   assert(arg_1 != c_rarg2, &quot;smashed arg&quot;);
1485   pass_arg2(this, arg_2);
1486   assert(arg_0 != c_rarg1, &quot;smashed arg&quot;);
1487   pass_arg1(this, arg_1);
1488   pass_arg0(this, arg_0);
1489   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1490 }
1491 
1492 void MacroAssembler::null_check(Register reg, int offset) {
1493   if (needs_explicit_null_check(offset)) {
1494     // provoke OS NULL exception if reg = NULL by
1495     // accessing M[reg] w/o changing any registers
1496     // NOTE: this is plenty to provoke a segv
1497     ldr(zr, Address(reg));
1498   } else {
1499     // nothing to do, (later) access of M[reg + offset]
1500     // will provoke OS NULL exception if reg = NULL
1501   }
1502 }
1503 
<a name="5" id="anc5"></a><span class="line-added">1504 void MacroAssembler::test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value) {</span>
<span class="line-added">1505   ldrw(temp_reg, Address(klass, Klass::access_flags_offset()));</span>
<span class="line-added">1506   andr(temp_reg, temp_reg, JVM_ACC_VALUE);</span>
<span class="line-added">1507   cbnz(temp_reg, is_value);</span>
<span class="line-added">1508 }</span>
<span class="line-added">1509 </span>
<span class="line-added">1510 void MacroAssembler::test_field_is_flattenable(Register flags, Register temp_reg, Label&amp; is_flattenable) {</span>
<span class="line-added">1511   (void) temp_reg; // keep signature uniform with x86</span>
<span class="line-added">1512   tbnz(flags, ConstantPoolCacheEntry::is_flattenable_field_shift, is_flattenable);</span>
<span class="line-added">1513 }</span>
<span class="line-added">1514 </span>
<span class="line-added">1515 void MacroAssembler::test_field_is_not_flattenable(Register flags, Register temp_reg, Label&amp; not_flattenable) {</span>
<span class="line-added">1516   (void) temp_reg; // keep signature uniform with x86</span>
<span class="line-added">1517   tbz(flags, ConstantPoolCacheEntry::is_flattenable_field_shift, not_flattenable);</span>
<span class="line-added">1518 }</span>
<span class="line-added">1519 </span>
<span class="line-added">1520 void MacroAssembler::test_field_is_flattened(Register flags, Register temp_reg, Label&amp; is_flattened) {</span>
<span class="line-added">1521   (void) temp_reg; // keep signature uniform with x86</span>
<span class="line-added">1522   tbnz(flags, ConstantPoolCacheEntry::is_flattened_field_shift, is_flattened);</span>
<span class="line-added">1523 }</span>
<span class="line-added">1524 </span>
<span class="line-added">1525 void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg, Label&amp; is_flattened_array) {</span>
<span class="line-added">1526   load_storage_props(temp_reg, oop);</span>
<span class="line-added">1527   andr(temp_reg, temp_reg, ArrayStorageProperties::flattened_value);</span>
<span class="line-added">1528   cbnz(temp_reg, is_flattened_array);</span>
<span class="line-added">1529 }</span>
<span class="line-added">1530 </span>
<span class="line-added">1531 void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&amp; is_null_free_array) {</span>
<span class="line-added">1532   load_storage_props(temp_reg, oop);</span>
<span class="line-added">1533   andr(temp_reg, temp_reg, ArrayStorageProperties::null_free_value);</span>
<span class="line-added">1534   cbnz(temp_reg, is_null_free_array);</span>
<span class="line-added">1535 }</span>
<span class="line-added">1536 </span>
1537 // MacroAssembler protected routines needed to implement
1538 // public methods
1539 
1540 void MacroAssembler::mov(Register r, Address dest) {
1541   code_section()-&gt;relocate(pc(), dest.rspec());
1542   u_int64_t imm64 = (u_int64_t)dest.target();
1543   movptr(r, imm64);
1544 }
1545 
1546 // Move a constant pointer into r.  In AArch64 mode the virtual
1547 // address space is 48 bits in size, so we only need three
1548 // instructions to create a patchable instruction sequence that can
1549 // reach anywhere.
1550 void MacroAssembler::movptr(Register r, uintptr_t imm64) {
1551 #ifndef PRODUCT
1552   {
1553     char buffer[64];
1554     snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
1555     block_comment(buffer);
1556   }
1557 #endif
1558   assert(imm64 &lt; (1ul &lt;&lt; 48), &quot;48-bit overflow in address constant&quot;);
1559   movz(r, imm64 &amp; 0xffff);
1560   imm64 &gt;&gt;= 16;
1561   movk(r, imm64 &amp; 0xffff, 16);
1562   imm64 &gt;&gt;= 16;
1563   movk(r, imm64 &amp; 0xffff, 32);
1564 }
1565 
1566 // Macro to mov replicated immediate to vector register.
1567 //  Vd will get the following values for different arrangements in T
1568 //   imm32 == hex 000000gh  T8B:  Vd = ghghghghghghghgh
1569 //   imm32 == hex 000000gh  T16B: Vd = ghghghghghghghghghghghghghghghgh
1570 //   imm32 == hex 0000efgh  T4H:  Vd = efghefghefghefgh
1571 //   imm32 == hex 0000efgh  T8H:  Vd = efghefghefghefghefghefghefghefgh
1572 //   imm32 == hex abcdefgh  T2S:  Vd = abcdefghabcdefgh
1573 //   imm32 == hex abcdefgh  T4S:  Vd = abcdefghabcdefghabcdefghabcdefgh
1574 //   T1D/T2D: invalid
1575 void MacroAssembler::mov(FloatRegister Vd, SIMD_Arrangement T, u_int32_t imm32) {
1576   assert(T != T1D &amp;&amp; T != T2D, &quot;invalid arrangement&quot;);
1577   if (T == T8B || T == T16B) {
1578     assert((imm32 &amp; ~0xff) == 0, &quot;extraneous bits in unsigned imm32 (T8B/T16B)&quot;);
1579     movi(Vd, T, imm32 &amp; 0xff, 0);
1580     return;
1581   }
1582   u_int32_t nimm32 = ~imm32;
1583   if (T == T4H || T == T8H) {
1584     assert((imm32  &amp; ~0xffff) == 0, &quot;extraneous bits in unsigned imm32 (T4H/T8H)&quot;);
1585     imm32 &amp;= 0xffff;
1586     nimm32 &amp;= 0xffff;
1587   }
1588   u_int32_t x = imm32;
1589   int movi_cnt = 0;
1590   int movn_cnt = 0;
1591   while (x) { if (x &amp; 0xff) movi_cnt++; x &gt;&gt;= 8; }
1592   x = nimm32;
1593   while (x) { if (x &amp; 0xff) movn_cnt++; x &gt;&gt;= 8; }
1594   if (movn_cnt &lt; movi_cnt) imm32 = nimm32;
1595   unsigned lsl = 0;
1596   while (imm32 &amp;&amp; (imm32 &amp; 0xff) == 0) { lsl += 8; imm32 &gt;&gt;= 8; }
1597   if (movn_cnt &lt; movi_cnt)
1598     mvni(Vd, T, imm32 &amp; 0xff, lsl);
1599   else
1600     movi(Vd, T, imm32 &amp; 0xff, lsl);
1601   imm32 &gt;&gt;= 8; lsl += 8;
1602   while (imm32) {
1603     while ((imm32 &amp; 0xff) == 0) { lsl += 8; imm32 &gt;&gt;= 8; }
1604     if (movn_cnt &lt; movi_cnt)
1605       bici(Vd, T, imm32 &amp; 0xff, lsl);
1606     else
1607       orri(Vd, T, imm32 &amp; 0xff, lsl);
1608     lsl += 8; imm32 &gt;&gt;= 8;
1609   }
1610 }
1611 
1612 void MacroAssembler::mov_immediate64(Register dst, u_int64_t imm64)
1613 {
1614 #ifndef PRODUCT
1615   {
1616     char buffer[64];
1617     snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX64, imm64);
1618     block_comment(buffer);
1619   }
1620 #endif
1621   if (operand_valid_for_logical_immediate(false, imm64)) {
1622     orr(dst, zr, imm64);
1623   } else {
1624     // we can use a combination of MOVZ or MOVN with
1625     // MOVK to build up the constant
1626     u_int64_t imm_h[4];
1627     int zero_count = 0;
1628     int neg_count = 0;
1629     int i;
1630     for (i = 0; i &lt; 4; i++) {
1631       imm_h[i] = ((imm64 &gt;&gt; (i * 16)) &amp; 0xffffL);
1632       if (imm_h[i] == 0) {
1633         zero_count++;
1634       } else if (imm_h[i] == 0xffffL) {
1635         neg_count++;
1636       }
1637     }
1638     if (zero_count == 4) {
1639       // one MOVZ will do
1640       movz(dst, 0);
1641     } else if (neg_count == 4) {
1642       // one MOVN will do
1643       movn(dst, 0);
1644     } else if (zero_count == 3) {
1645       for (i = 0; i &lt; 4; i++) {
1646         if (imm_h[i] != 0L) {
1647           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1648           break;
1649         }
1650       }
1651     } else if (neg_count == 3) {
1652       // one MOVN will do
1653       for (int i = 0; i &lt; 4; i++) {
1654         if (imm_h[i] != 0xffffL) {
1655           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1656           break;
1657         }
1658       }
1659     } else if (zero_count == 2) {
1660       // one MOVZ and one MOVK will do
1661       for (i = 0; i &lt; 3; i++) {
1662         if (imm_h[i] != 0L) {
1663           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1664           i++;
1665           break;
1666         }
1667       }
1668       for (;i &lt; 4; i++) {
1669         if (imm_h[i] != 0L) {
1670           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1671         }
1672       }
1673     } else if (neg_count == 2) {
1674       // one MOVN and one MOVK will do
1675       for (i = 0; i &lt; 4; i++) {
1676         if (imm_h[i] != 0xffffL) {
1677           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1678           i++;
1679           break;
1680         }
1681       }
1682       for (;i &lt; 4; i++) {
1683         if (imm_h[i] != 0xffffL) {
1684           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1685         }
1686       }
1687     } else if (zero_count == 1) {
1688       // one MOVZ and two MOVKs will do
1689       for (i = 0; i &lt; 4; i++) {
1690         if (imm_h[i] != 0L) {
1691           movz(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1692           i++;
1693           break;
1694         }
1695       }
1696       for (;i &lt; 4; i++) {
1697         if (imm_h[i] != 0x0L) {
1698           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1699         }
1700       }
1701     } else if (neg_count == 1) {
1702       // one MOVN and two MOVKs will do
1703       for (i = 0; i &lt; 4; i++) {
1704         if (imm_h[i] != 0xffffL) {
1705           movn(dst, (u_int32_t)imm_h[i] ^ 0xffffL, (i &lt;&lt; 4));
1706           i++;
1707           break;
1708         }
1709       }
1710       for (;i &lt; 4; i++) {
1711         if (imm_h[i] != 0xffffL) {
1712           movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1713         }
1714       }
1715     } else {
1716       // use a MOVZ and 3 MOVKs (makes it easier to debug)
1717       movz(dst, (u_int32_t)imm_h[0], 0);
1718       for (i = 1; i &lt; 4; i++) {
1719         movk(dst, (u_int32_t)imm_h[i], (i &lt;&lt; 4));
1720       }
1721     }
1722   }
1723 }
1724 
1725 void MacroAssembler::mov_immediate32(Register dst, u_int32_t imm32)
1726 {
1727 #ifndef PRODUCT
1728     {
1729       char buffer[64];
1730       snprintf(buffer, sizeof(buffer), &quot;0x%&quot; PRIX32, imm32);
1731       block_comment(buffer);
1732     }
1733 #endif
1734   if (operand_valid_for_logical_immediate(true, imm32)) {
1735     orrw(dst, zr, imm32);
1736   } else {
1737     // we can use MOVZ, MOVN or two calls to MOVK to build up the
1738     // constant
1739     u_int32_t imm_h[2];
1740     imm_h[0] = imm32 &amp; 0xffff;
1741     imm_h[1] = ((imm32 &gt;&gt; 16) &amp; 0xffff);
1742     if (imm_h[0] == 0) {
1743       movzw(dst, imm_h[1], 16);
1744     } else if (imm_h[0] == 0xffff) {
1745       movnw(dst, imm_h[1] ^ 0xffff, 16);
1746     } else if (imm_h[1] == 0) {
1747       movzw(dst, imm_h[0], 0);
1748     } else if (imm_h[1] == 0xffff) {
1749       movnw(dst, imm_h[0] ^ 0xffff, 0);
1750     } else {
1751       // use a MOVZ and MOVK (makes it easier to debug)
1752       movzw(dst, imm_h[0], 0);
1753       movkw(dst, imm_h[1], 16);
1754     }
1755   }
1756 }
1757 
1758 // Form an address from base + offset in Rd.  Rd may or may
1759 // not actually be used: you must use the Address that is returned.
1760 // It is up to you to ensure that the shift provided matches the size
1761 // of your data.
1762 Address MacroAssembler::form_address(Register Rd, Register base, long byte_offset, int shift) {
1763   if (Address::offset_ok_for_immed(byte_offset, shift))
1764     // It fits; no need for any heroics
1765     return Address(base, byte_offset);
1766 
1767   // Don&#39;t do anything clever with negative or misaligned offsets
1768   unsigned mask = (1 &lt;&lt; shift) - 1;
1769   if (byte_offset &lt; 0 || byte_offset &amp; mask) {
1770     mov(Rd, byte_offset);
1771     add(Rd, base, Rd);
1772     return Address(Rd);
1773   }
1774 
1775   // See if we can do this with two 12-bit offsets
1776   {
1777     unsigned long word_offset = byte_offset &gt;&gt; shift;
1778     unsigned long masked_offset = word_offset &amp; 0xfff000;
1779     if (Address::offset_ok_for_immed(word_offset - masked_offset, 0)
1780         &amp;&amp; Assembler::operand_valid_for_add_sub_immediate(masked_offset &lt;&lt; shift)) {
1781       add(Rd, base, masked_offset &lt;&lt; shift);
1782       word_offset -= masked_offset;
1783       return Address(Rd, word_offset &lt;&lt; shift);
1784     }
1785   }
1786 
1787   // Do it the hard way
1788   mov(Rd, byte_offset);
1789   add(Rd, base, Rd);
1790   return Address(Rd);
1791 }
1792 
1793 void MacroAssembler::atomic_incw(Register counter_addr, Register tmp, Register tmp2) {
1794   if (UseLSE) {
1795     mov(tmp, 1);
1796     ldadd(Assembler::word, tmp, zr, counter_addr);
1797     return;
1798   }
1799   Label retry_load;
1800   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
1801     prfm(Address(counter_addr), PSTL1STRM);
1802   bind(retry_load);
1803   // flush and load exclusive from the memory location
1804   ldxrw(tmp, counter_addr);
1805   addw(tmp, tmp, 1);
1806   // if we store+flush with no intervening write tmp wil be zero
1807   stxrw(tmp2, tmp, counter_addr);
1808   cbnzw(tmp2, retry_load);
1809 }
1810 
1811 
1812 int MacroAssembler::corrected_idivl(Register result, Register ra, Register rb,
1813                                     bool want_remainder, Register scratch)
1814 {
1815   // Full implementation of Java idiv and irem.  The function
1816   // returns the (pc) offset of the div instruction - may be needed
1817   // for implicit exceptions.
1818   //
1819   // constraint : ra/rb =/= scratch
1820   //         normal case
1821   //
1822   // input : ra: dividend
1823   //         rb: divisor
1824   //
1825   // result: either
1826   //         quotient  (= ra idiv rb)
1827   //         remainder (= ra irem rb)
1828 
1829   assert(ra != scratch &amp;&amp; rb != scratch, &quot;reg cannot be scratch&quot;);
1830 
1831   int idivl_offset = offset();
1832   if (! want_remainder) {
1833     sdivw(result, ra, rb);
1834   } else {
1835     sdivw(scratch, ra, rb);
1836     Assembler::msubw(result, scratch, rb, ra);
1837   }
1838 
1839   return idivl_offset;
1840 }
1841 
1842 int MacroAssembler::corrected_idivq(Register result, Register ra, Register rb,
1843                                     bool want_remainder, Register scratch)
1844 {
1845   // Full implementation of Java ldiv and lrem.  The function
1846   // returns the (pc) offset of the div instruction - may be needed
1847   // for implicit exceptions.
1848   //
1849   // constraint : ra/rb =/= scratch
1850   //         normal case
1851   //
1852   // input : ra: dividend
1853   //         rb: divisor
1854   //
1855   // result: either
1856   //         quotient  (= ra idiv rb)
1857   //         remainder (= ra irem rb)
1858 
1859   assert(ra != scratch &amp;&amp; rb != scratch, &quot;reg cannot be scratch&quot;);
1860 
1861   int idivq_offset = offset();
1862   if (! want_remainder) {
1863     sdiv(result, ra, rb);
1864   } else {
1865     sdiv(scratch, ra, rb);
1866     Assembler::msub(result, scratch, rb, ra);
1867   }
1868 
1869   return idivq_offset;
1870 }
1871 
1872 void MacroAssembler::membar(Membar_mask_bits order_constraint) {
1873   address prev = pc() - NativeMembar::instruction_size;
1874   address last = code()-&gt;last_insn();
1875   if (last != NULL &amp;&amp; nativeInstruction_at(last)-&gt;is_Membar() &amp;&amp; prev == last) {
1876     NativeMembar *bar = NativeMembar_at(prev);
1877     // We are merging two memory barrier instructions.  On AArch64 we
1878     // can do this simply by ORing them together.
1879     bar-&gt;set_kind(bar-&gt;get_kind() | order_constraint);
1880     BLOCK_COMMENT(&quot;merged membar&quot;);
1881   } else {
1882     code()-&gt;set_last_insn(pc());
1883     dmb(Assembler::barrier(order_constraint));
1884   }
1885 }
1886 
1887 bool MacroAssembler::try_merge_ldst(Register rt, const Address &amp;adr, size_t size_in_bytes, bool is_store) {
1888   if (ldst_can_merge(rt, adr, size_in_bytes, is_store)) {
1889     merge_ldst(rt, adr, size_in_bytes, is_store);
1890     code()-&gt;clear_last_insn();
1891     return true;
1892   } else {
1893     assert(size_in_bytes == 8 || size_in_bytes == 4, &quot;only 8 bytes or 4 bytes load/store is supported.&quot;);
1894     const unsigned mask = size_in_bytes - 1;
1895     if (adr.getMode() == Address::base_plus_offset &amp;&amp;
1896         (adr.offset() &amp; mask) == 0) { // only supports base_plus_offset.
1897       code()-&gt;set_last_insn(pc());
1898     }
1899     return false;
1900   }
1901 }
1902 
1903 void MacroAssembler::ldr(Register Rx, const Address &amp;adr) {
1904   // We always try to merge two adjacent loads into one ldp.
1905   if (!try_merge_ldst(Rx, adr, 8, false)) {
1906     Assembler::ldr(Rx, adr);
1907   }
1908 }
1909 
1910 void MacroAssembler::ldrw(Register Rw, const Address &amp;adr) {
1911   // We always try to merge two adjacent loads into one ldp.
1912   if (!try_merge_ldst(Rw, adr, 4, false)) {
1913     Assembler::ldrw(Rw, adr);
1914   }
1915 }
1916 
1917 void MacroAssembler::str(Register Rx, const Address &amp;adr) {
1918   // We always try to merge two adjacent stores into one stp.
1919   if (!try_merge_ldst(Rx, adr, 8, true)) {
1920     Assembler::str(Rx, adr);
1921   }
1922 }
1923 
1924 void MacroAssembler::strw(Register Rw, const Address &amp;adr) {
1925   // We always try to merge two adjacent stores into one stp.
1926   if (!try_merge_ldst(Rw, adr, 4, true)) {
1927     Assembler::strw(Rw, adr);
1928   }
1929 }
1930 
1931 // MacroAssembler routines found actually to be needed
1932 
1933 void MacroAssembler::push(Register src)
1934 {
1935   str(src, Address(pre(esp, -1 * wordSize)));
1936 }
1937 
1938 void MacroAssembler::pop(Register dst)
1939 {
1940   ldr(dst, Address(post(esp, 1 * wordSize)));
1941 }
1942 
1943 // Note: load_unsigned_short used to be called load_unsigned_word.
1944 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
1945   int off = offset();
1946   ldrh(dst, src);
1947   return off;
1948 }
1949 
1950 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
1951   int off = offset();
1952   ldrb(dst, src);
1953   return off;
1954 }
1955 
1956 int MacroAssembler::load_signed_short(Register dst, Address src) {
1957   int off = offset();
1958   ldrsh(dst, src);
1959   return off;
1960 }
1961 
1962 int MacroAssembler::load_signed_byte(Register dst, Address src) {
1963   int off = offset();
1964   ldrsb(dst, src);
1965   return off;
1966 }
1967 
1968 int MacroAssembler::load_signed_short32(Register dst, Address src) {
1969   int off = offset();
1970   ldrshw(dst, src);
1971   return off;
1972 }
1973 
1974 int MacroAssembler::load_signed_byte32(Register dst, Address src) {
1975   int off = offset();
1976   ldrsbw(dst, src);
1977   return off;
1978 }
1979 
1980 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
1981   switch (size_in_bytes) {
1982   case  8:  ldr(dst, src); break;
1983   case  4:  ldrw(dst, src); break;
1984   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
1985   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
1986   default:  ShouldNotReachHere();
1987   }
1988 }
1989 
1990 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
1991   switch (size_in_bytes) {
1992   case  8:  str(src, dst); break;
1993   case  4:  strw(src, dst); break;
1994   case  2:  strh(src, dst); break;
1995   case  1:  strb(src, dst); break;
1996   default:  ShouldNotReachHere();
1997   }
1998 }
1999 
2000 void MacroAssembler::decrementw(Register reg, int value)
2001 {
2002   if (value &lt; 0)  { incrementw(reg, -value);      return; }
2003   if (value == 0) {                               return; }
2004   if (value &lt; (1 &lt;&lt; 12)) { subw(reg, reg, value); return; }
2005   /* else */ {
2006     guarantee(reg != rscratch2, &quot;invalid dst for register decrement&quot;);
2007     movw(rscratch2, (unsigned)value);
2008     subw(reg, reg, rscratch2);
2009   }
2010 }
2011 
2012 void MacroAssembler::decrement(Register reg, int value)
2013 {
2014   if (value &lt; 0)  { increment(reg, -value);      return; }
2015   if (value == 0) {                              return; }
2016   if (value &lt; (1 &lt;&lt; 12)) { sub(reg, reg, value); return; }
2017   /* else */ {
2018     assert(reg != rscratch2, &quot;invalid dst for register decrement&quot;);
2019     mov(rscratch2, (unsigned long)value);
2020     sub(reg, reg, rscratch2);
2021   }
2022 }
2023 
2024 void MacroAssembler::decrementw(Address dst, int value)
2025 {
2026   assert(!dst.uses(rscratch1), &quot;invalid dst for address decrement&quot;);
2027   if (dst.getMode() == Address::literal) {
2028     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2029     lea(rscratch2, dst);
2030     dst = Address(rscratch2);
2031   }
2032   ldrw(rscratch1, dst);
2033   decrementw(rscratch1, value);
2034   strw(rscratch1, dst);
2035 }
2036 
2037 void MacroAssembler::decrement(Address dst, int value)
2038 {
2039   assert(!dst.uses(rscratch1), &quot;invalid address for decrement&quot;);
2040   if (dst.getMode() == Address::literal) {
2041     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2042     lea(rscratch2, dst);
2043     dst = Address(rscratch2);
2044   }
2045   ldr(rscratch1, dst);
2046   decrement(rscratch1, value);
2047   str(rscratch1, dst);
2048 }
2049 
2050 void MacroAssembler::incrementw(Register reg, int value)
2051 {
2052   if (value &lt; 0)  { decrementw(reg, -value);      return; }
2053   if (value == 0) {                               return; }
2054   if (value &lt; (1 &lt;&lt; 12)) { addw(reg, reg, value); return; }
2055   /* else */ {
2056     assert(reg != rscratch2, &quot;invalid dst for register increment&quot;);
2057     movw(rscratch2, (unsigned)value);
2058     addw(reg, reg, rscratch2);
2059   }
2060 }
2061 
2062 void MacroAssembler::increment(Register reg, int value)
2063 {
2064   if (value &lt; 0)  { decrement(reg, -value);      return; }
2065   if (value == 0) {                              return; }
2066   if (value &lt; (1 &lt;&lt; 12)) { add(reg, reg, value); return; }
2067   /* else */ {
2068     assert(reg != rscratch2, &quot;invalid dst for register increment&quot;);
2069     movw(rscratch2, (unsigned)value);
2070     add(reg, reg, rscratch2);
2071   }
2072 }
2073 
2074 void MacroAssembler::incrementw(Address dst, int value)
2075 {
2076   assert(!dst.uses(rscratch1), &quot;invalid dst for address increment&quot;);
2077   if (dst.getMode() == Address::literal) {
2078     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2079     lea(rscratch2, dst);
2080     dst = Address(rscratch2);
2081   }
2082   ldrw(rscratch1, dst);
2083   incrementw(rscratch1, value);
2084   strw(rscratch1, dst);
2085 }
2086 
2087 void MacroAssembler::increment(Address dst, int value)
2088 {
2089   assert(!dst.uses(rscratch1), &quot;invalid dst for address increment&quot;);
2090   if (dst.getMode() == Address::literal) {
2091     assert(abs(value) &lt; (1 &lt;&lt; 12), &quot;invalid value and address mode combination&quot;);
2092     lea(rscratch2, dst);
2093     dst = Address(rscratch2);
2094   }
2095   ldr(rscratch1, dst);
2096   increment(rscratch1, value);
2097   str(rscratch1, dst);
2098 }
2099 
2100 
2101 void MacroAssembler::pusha() {
2102   push(0x7fffffff, sp);
2103 }
2104 
2105 void MacroAssembler::popa() {
2106   pop(0x7fffffff, sp);
2107 }
2108 
2109 // Push lots of registers in the bit set supplied.  Don&#39;t push sp.
2110 // Return the number of words pushed
2111 int MacroAssembler::push(unsigned int bitset, Register stack) {
2112   int words_pushed = 0;
2113 
2114   // Scan bitset to accumulate register pairs
2115   unsigned char regs[32];
2116   int count = 0;
2117   for (int reg = 0; reg &lt;= 30; reg++) {
2118     if (1 &amp; bitset)
2119       regs[count++] = reg;
2120     bitset &gt;&gt;= 1;
2121   }
2122   regs[count++] = zr-&gt;encoding_nocheck();
2123   count &amp;= ~1;  // Only push an even nuber of regs
2124 
2125   if (count) {
2126     stp(as_Register(regs[0]), as_Register(regs[1]),
2127        Address(pre(stack, -count * wordSize)));
2128     words_pushed += 2;
2129   }
2130   for (int i = 2; i &lt; count; i += 2) {
2131     stp(as_Register(regs[i]), as_Register(regs[i+1]),
2132        Address(stack, i * wordSize));
2133     words_pushed += 2;
2134   }
2135 
2136   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2137 
2138   return count;
2139 }
2140 
2141 int MacroAssembler::pop(unsigned int bitset, Register stack) {
2142   int words_pushed = 0;
2143 
2144   // Scan bitset to accumulate register pairs
2145   unsigned char regs[32];
2146   int count = 0;
2147   for (int reg = 0; reg &lt;= 30; reg++) {
2148     if (1 &amp; bitset)
2149       regs[count++] = reg;
2150     bitset &gt;&gt;= 1;
2151   }
2152   regs[count++] = zr-&gt;encoding_nocheck();
2153   count &amp;= ~1;
2154 
2155   for (int i = 2; i &lt; count; i += 2) {
2156     ldp(as_Register(regs[i]), as_Register(regs[i+1]),
2157        Address(stack, i * wordSize));
2158     words_pushed += 2;
2159   }
2160   if (count) {
2161     ldp(as_Register(regs[0]), as_Register(regs[1]),
2162        Address(post(stack, count * wordSize)));
2163     words_pushed += 2;
2164   }
2165 
2166   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2167 
2168   return count;
2169 }
2170 
2171 // Push lots of registers in the bit set supplied.  Don&#39;t push sp.
2172 // Return the number of words pushed
2173 int MacroAssembler::push_fp(unsigned int bitset, Register stack) {
2174   int words_pushed = 0;
2175 
2176   // Scan bitset to accumulate register pairs
2177   unsigned char regs[32];
2178   int count = 0;
2179   for (int reg = 0; reg &lt;= 31; reg++) {
2180     if (1 &amp; bitset)
2181       regs[count++] = reg;
2182     bitset &gt;&gt;= 1;
2183   }
2184   regs[count++] = zr-&gt;encoding_nocheck();
2185   count &amp;= ~1;  // Only push an even number of regs
2186 
2187   // Always pushing full 128 bit registers.
2188   if (count) {
2189     stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -count * wordSize * 2)));
2190     words_pushed += 2;
2191   }
2192   for (int i = 2; i &lt; count; i += 2) {
2193     stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));
2194     words_pushed += 2;
2195   }
2196 
2197   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2198   return count;
2199 }
2200 
2201 int MacroAssembler::pop_fp(unsigned int bitset, Register stack) {
2202   int words_pushed = 0;
2203 
2204   // Scan bitset to accumulate register pairs
2205   unsigned char regs[32];
2206   int count = 0;
2207   for (int reg = 0; reg &lt;= 31; reg++) {
2208     if (1 &amp; bitset)
2209       regs[count++] = reg;
2210     bitset &gt;&gt;= 1;
2211   }
2212   regs[count++] = zr-&gt;encoding_nocheck();
2213   count &amp;= ~1;
2214 
2215   for (int i = 2; i &lt; count; i += 2) {
2216     ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));
2217     words_pushed += 2;
2218   }
2219   if (count) {
2220     ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, count * wordSize * 2)));
2221     words_pushed += 2;
2222   }
2223 
2224   assert(words_pushed == count, &quot;oops, pushed != count&quot;);
2225 
2226   return count;
2227 }
2228 
2229 #ifdef ASSERT
2230 void MacroAssembler::verify_heapbase(const char* msg) {
2231 #if 0
2232   assert (UseCompressedOops || UseCompressedClassPointers, &quot;should be compressed&quot;);
2233   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
2234   if (!UseCompressedOops || Universe::ptr_base() == NULL) {
2235     // rheapbase is allocated as general register
2236     return;
2237   }
2238   if (CheckCompressedOops) {
2239     Label ok;
2240     push(1 &lt;&lt; rscratch1-&gt;encoding(), sp); // cmpptr trashes rscratch1
2241     cmpptr(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
2242     br(Assembler::EQ, ok);
2243     stop(msg);
2244     bind(ok);
2245     pop(1 &lt;&lt; rscratch1-&gt;encoding(), sp);
2246   }
2247 #endif
2248 }
2249 #endif
2250 
2251 void MacroAssembler::resolve_jobject(Register value, Register thread, Register tmp) {
2252   Label done, not_weak;
2253   cbz(value, done);           // Use NULL as-is.
2254 
2255   STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);
2256   tbz(r0, 0, not_weak);    // Test for jweak tag.
2257 
2258   // Resolve jweak.
2259   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,
2260                  Address(value, -JNIHandles::weak_tag_value), tmp, thread);
2261   verify_oop(value);
2262   b(done);
2263 
2264   bind(not_weak);
2265   // Resolve (untagged) jobject.
2266   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
2267   verify_oop(value);
2268   bind(done);
2269 }
2270 
2271 void MacroAssembler::stop(const char* msg) {
2272   address ip = pc();
2273   pusha();
2274   mov(c_rarg0, (address)msg);
2275   mov(c_rarg1, (address)ip);
2276   mov(c_rarg2, sp);
2277   mov(c_rarg3, CAST_FROM_FN_PTR(address, MacroAssembler::debug64));
2278   blr(c_rarg3);
2279   hlt(0);
2280 }
2281 
2282 void MacroAssembler::warn(const char* msg) {
2283   pusha();
2284   mov(c_rarg0, (address)msg);
2285   mov(lr, CAST_FROM_FN_PTR(address, warning));
2286   blr(lr);
2287   popa();
2288 }
2289 
2290 void MacroAssembler::unimplemented(const char* what) {
2291   const char* buf = NULL;
2292   {
2293     ResourceMark rm;
2294     stringStream ss;
2295     ss.print(&quot;unimplemented: %s&quot;, what);
2296     buf = code_string(ss.as_string());
2297   }
2298   stop(buf);
2299 }
2300 
2301 // If a constant does not fit in an immediate field, generate some
2302 // number of MOV instructions and then perform the operation.
2303 void MacroAssembler::wrap_add_sub_imm_insn(Register Rd, Register Rn, unsigned imm,
2304                                            add_sub_imm_insn insn1,
2305                                            add_sub_reg_insn insn2) {
2306   assert(Rd != zr, &quot;Rd = zr and not setting flags?&quot;);
2307   if (operand_valid_for_add_sub_immediate((int)imm)) {
2308     (this-&gt;*insn1)(Rd, Rn, imm);
2309   } else {
2310     if (uabs(imm) &lt; (1 &lt;&lt; 24)) {
2311        (this-&gt;*insn1)(Rd, Rn, imm &amp; -(1 &lt;&lt; 12));
2312        (this-&gt;*insn1)(Rd, Rd, imm &amp; ((1 &lt;&lt; 12)-1));
2313     } else {
2314        assert_different_registers(Rd, Rn);
2315        mov(Rd, (uint64_t)imm);
2316        (this-&gt;*insn2)(Rd, Rn, Rd, LSL, 0);
2317     }
2318   }
2319 }
2320 
2321 // Seperate vsn which sets the flags. Optimisations are more restricted
2322 // because we must set the flags correctly.
2323 void MacroAssembler::wrap_adds_subs_imm_insn(Register Rd, Register Rn, unsigned imm,
2324                                            add_sub_imm_insn insn1,
2325                                            add_sub_reg_insn insn2) {
2326   if (operand_valid_for_add_sub_immediate((int)imm)) {
2327     (this-&gt;*insn1)(Rd, Rn, imm);
2328   } else {
2329     assert_different_registers(Rd, Rn);
2330     assert(Rd != zr, &quot;overflow in immediate operand&quot;);
2331     mov(Rd, (uint64_t)imm);
2332     (this-&gt;*insn2)(Rd, Rn, Rd, LSL, 0);
2333   }
2334 }
2335 
2336 
2337 void MacroAssembler::add(Register Rd, Register Rn, RegisterOrConstant increment) {
2338   if (increment.is_register()) {
2339     add(Rd, Rn, increment.as_register());
2340   } else {
2341     add(Rd, Rn, increment.as_constant());
2342   }
2343 }
2344 
2345 void MacroAssembler::addw(Register Rd, Register Rn, RegisterOrConstant increment) {
2346   if (increment.is_register()) {
2347     addw(Rd, Rn, increment.as_register());
2348   } else {
2349     addw(Rd, Rn, increment.as_constant());
2350   }
2351 }
2352 
2353 void MacroAssembler::sub(Register Rd, Register Rn, RegisterOrConstant decrement) {
2354   if (decrement.is_register()) {
2355     sub(Rd, Rn, decrement.as_register());
2356   } else {
2357     sub(Rd, Rn, decrement.as_constant());
2358   }
2359 }
2360 
2361 void MacroAssembler::subw(Register Rd, Register Rn, RegisterOrConstant decrement) {
2362   if (decrement.is_register()) {
2363     subw(Rd, Rn, decrement.as_register());
2364   } else {
2365     subw(Rd, Rn, decrement.as_constant());
2366   }
2367 }
2368 
2369 void MacroAssembler::reinit_heapbase()
2370 {
2371   if (UseCompressedOops) {
2372     if (Universe::is_fully_initialized()) {
2373       mov(rheapbase, CompressedOops::ptrs_base());
2374     } else {
2375       lea(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
2376       ldr(rheapbase, Address(rheapbase));
2377     }
2378   }
2379 }
2380 
2381 // this simulates the behaviour of the x86 cmpxchg instruction using a
2382 // load linked/store conditional pair. we use the acquire/release
2383 // versions of these instructions so that we flush pending writes as
2384 // per Java semantics.
2385 
2386 // n.b the x86 version assumes the old value to be compared against is
2387 // in rax and updates rax with the value located in memory if the
2388 // cmpxchg fails. we supply a register for the old value explicitly
2389 
2390 // the aarch64 load linked/store conditional instructions do not
2391 // accept an offset. so, unlike x86, we must provide a plain register
2392 // to identify the memory word to be compared/exchanged rather than a
2393 // register+offset Address.
2394 
2395 void MacroAssembler::cmpxchgptr(Register oldv, Register newv, Register addr, Register tmp,
2396                                 Label &amp;succeed, Label *fail) {
2397   // oldv holds comparison value
2398   // newv holds value to write in exchange
2399   // addr identifies memory word to compare against/update
2400   if (UseLSE) {
2401     mov(tmp, oldv);
2402     casal(Assembler::xword, oldv, newv, addr);
2403     cmp(tmp, oldv);
2404     br(Assembler::EQ, succeed);
2405     membar(AnyAny);
2406   } else {
2407     Label retry_load, nope;
2408     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2409       prfm(Address(addr), PSTL1STRM);
2410     bind(retry_load);
2411     // flush and load exclusive from the memory location
2412     // and fail if it is not what we expect
2413     ldaxr(tmp, addr);
2414     cmp(tmp, oldv);
2415     br(Assembler::NE, nope);
2416     // if we store+flush with no intervening write tmp wil be zero
2417     stlxr(tmp, newv, addr);
2418     cbzw(tmp, succeed);
2419     // retry so we only ever return after a load fails to compare
2420     // ensures we don&#39;t return a stale value after a failed write.
2421     b(retry_load);
2422     // if the memory word differs we return it in oldv and signal a fail
2423     bind(nope);
2424     membar(AnyAny);
2425     mov(oldv, tmp);
2426   }
2427   if (fail)
2428     b(*fail);
2429 }
2430 
2431 void MacroAssembler::cmpxchg_obj_header(Register oldv, Register newv, Register obj, Register tmp,
2432                                         Label &amp;succeed, Label *fail) {
2433   assert(oopDesc::mark_offset_in_bytes() == 0, &quot;assumption&quot;);
2434   cmpxchgptr(oldv, newv, obj, tmp, succeed, fail);
2435 }
2436 
2437 void MacroAssembler::cmpxchgw(Register oldv, Register newv, Register addr, Register tmp,
2438                                 Label &amp;succeed, Label *fail) {
2439   // oldv holds comparison value
2440   // newv holds value to write in exchange
2441   // addr identifies memory word to compare against/update
2442   // tmp returns 0/1 for success/failure
2443   if (UseLSE) {
2444     mov(tmp, oldv);
2445     casal(Assembler::word, oldv, newv, addr);
2446     cmp(tmp, oldv);
2447     br(Assembler::EQ, succeed);
2448     membar(AnyAny);
2449   } else {
2450     Label retry_load, nope;
2451     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2452       prfm(Address(addr), PSTL1STRM);
2453     bind(retry_load);
2454     // flush and load exclusive from the memory location
2455     // and fail if it is not what we expect
2456     ldaxrw(tmp, addr);
2457     cmp(tmp, oldv);
2458     br(Assembler::NE, nope);
2459     // if we store+flush with no intervening write tmp wil be zero
2460     stlxrw(tmp, newv, addr);
2461     cbzw(tmp, succeed);
2462     // retry so we only ever return after a load fails to compare
2463     // ensures we don&#39;t return a stale value after a failed write.
2464     b(retry_load);
2465     // if the memory word differs we return it in oldv and signal a fail
2466     bind(nope);
2467     membar(AnyAny);
2468     mov(oldv, tmp);
2469   }
2470   if (fail)
2471     b(*fail);
2472 }
2473 
2474 // A generic CAS; success or failure is in the EQ flag.  A weak CAS
2475 // doesn&#39;t retry and may fail spuriously.  If the oldval is wanted,
2476 // Pass a register for the result, otherwise pass noreg.
2477 
2478 // Clobbers rscratch1
2479 void MacroAssembler::cmpxchg(Register addr, Register expected,
2480                              Register new_val,
2481                              enum operand_size size,
2482                              bool acquire, bool release,
2483                              bool weak,
2484                              Register result) {
2485   if (result == noreg)  result = rscratch1;
2486   BLOCK_COMMENT(&quot;cmpxchg {&quot;);
2487   if (UseLSE) {
2488     mov(result, expected);
2489     lse_cas(result, new_val, addr, size, acquire, release, /*not_pair*/ true);
2490     compare_eq(result, expected, size);
2491   } else {
2492     Label retry_load, done;
2493     if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))
2494       prfm(Address(addr), PSTL1STRM);
2495     bind(retry_load);
2496     load_exclusive(result, addr, size, acquire);
2497     compare_eq(result, expected, size);
2498     br(Assembler::NE, done);
2499     store_exclusive(rscratch1, new_val, addr, size, release);
2500     if (weak) {
2501       cmpw(rscratch1, 0u);  // If the store fails, return NE to our caller.
2502     } else {
2503       cbnzw(rscratch1, retry_load);
2504     }
2505     bind(done);
2506   }
2507   BLOCK_COMMENT(&quot;} cmpxchg&quot;);
2508 }
2509 
2510 // A generic comparison. Only compares for equality, clobbers rscratch1.
2511 void MacroAssembler::compare_eq(Register rm, Register rn, enum operand_size size) {
2512   if (size == xword) {
2513     cmp(rm, rn);
2514   } else if (size == word) {
2515     cmpw(rm, rn);
2516   } else if (size == halfword) {
2517     eorw(rscratch1, rm, rn);
2518     ands(zr, rscratch1, 0xffff);
2519   } else if (size == byte) {
2520     eorw(rscratch1, rm, rn);
2521     ands(zr, rscratch1, 0xff);
2522   } else {
2523     ShouldNotReachHere();
2524   }
2525 }
2526 
2527 
2528 static bool different(Register a, RegisterOrConstant b, Register c) {
2529   if (b.is_constant())
2530     return a != c;
2531   else
2532     return a != b.as_register() &amp;&amp; a != c &amp;&amp; b.as_register() != c;
2533 }
2534 
2535 #define ATOMIC_OP(NAME, LDXR, OP, IOP, AOP, STXR, sz)                   \
2536 void MacroAssembler::atomic_##NAME(Register prev, RegisterOrConstant incr, Register addr) { \
2537   if (UseLSE) {                                                         \
2538     prev = prev-&gt;is_valid() ? prev : zr;                                \
2539     if (incr.is_register()) {                                           \
2540       AOP(sz, incr.as_register(), prev, addr);                          \
2541     } else {                                                            \
2542       mov(rscratch2, incr.as_constant());                               \
2543       AOP(sz, rscratch2, prev, addr);                                   \
2544     }                                                                   \
2545     return;                                                             \
2546   }                                                                     \
2547   Register result = rscratch2;                                          \
2548   if (prev-&gt;is_valid())                                                 \
2549     result = different(prev, incr, addr) ? prev : rscratch2;            \
2550                                                                         \
2551   Label retry_load;                                                     \
2552   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))         \
2553     prfm(Address(addr), PSTL1STRM);                                     \
2554   bind(retry_load);                                                     \
2555   LDXR(result, addr);                                                   \
2556   OP(rscratch1, result, incr);                                          \
2557   STXR(rscratch2, rscratch1, addr);                                     \
2558   cbnzw(rscratch2, retry_load);                                         \
2559   if (prev-&gt;is_valid() &amp;&amp; prev != result) {                             \
2560     IOP(prev, rscratch1, incr);                                         \
2561   }                                                                     \
2562 }
2563 
2564 ATOMIC_OP(add, ldxr, add, sub, ldadd, stxr, Assembler::xword)
2565 ATOMIC_OP(addw, ldxrw, addw, subw, ldadd, stxrw, Assembler::word)
2566 ATOMIC_OP(addal, ldaxr, add, sub, ldaddal, stlxr, Assembler::xword)
2567 ATOMIC_OP(addalw, ldaxrw, addw, subw, ldaddal, stlxrw, Assembler::word)
2568 
2569 #undef ATOMIC_OP
2570 
2571 #define ATOMIC_XCHG(OP, AOP, LDXR, STXR, sz)                            \
2572 void MacroAssembler::atomic_##OP(Register prev, Register newv, Register addr) { \
2573   if (UseLSE) {                                                         \
2574     prev = prev-&gt;is_valid() ? prev : zr;                                \
2575     AOP(sz, newv, prev, addr);                                          \
2576     return;                                                             \
2577   }                                                                     \
2578   Register result = rscratch2;                                          \
2579   if (prev-&gt;is_valid())                                                 \
2580     result = different(prev, newv, addr) ? prev : rscratch2;            \
2581                                                                         \
2582   Label retry_load;                                                     \
2583   if ((VM_Version::features() &amp; VM_Version::CPU_STXR_PREFETCH))         \
2584     prfm(Address(addr), PSTL1STRM);                                     \
2585   bind(retry_load);                                                     \
2586   LDXR(result, addr);                                                   \
2587   STXR(rscratch1, newv, addr);                                          \
2588   cbnzw(rscratch1, retry_load);                                         \
2589   if (prev-&gt;is_valid() &amp;&amp; prev != result)                               \
2590     mov(prev, result);                                                  \
2591 }
2592 
2593 ATOMIC_XCHG(xchg, swp, ldxr, stxr, Assembler::xword)
2594 ATOMIC_XCHG(xchgw, swp, ldxrw, stxrw, Assembler::word)
2595 ATOMIC_XCHG(xchgal, swpal, ldaxr, stlxr, Assembler::xword)
2596 ATOMIC_XCHG(xchgalw, swpal, ldaxrw, stlxrw, Assembler::word)
2597 
2598 #undef ATOMIC_XCHG
2599 
2600 #ifndef PRODUCT
2601 extern &quot;C&quot; void findpc(intptr_t x);
2602 #endif
2603 
2604 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[])
2605 {
2606   // In order to get locks to work, we need to fake a in_VM state
2607   if (ShowMessageBoxOnError ) {
2608     JavaThread* thread = JavaThread::current();
2609     JavaThreadState saved_state = thread-&gt;thread_state();
2610     thread-&gt;set_thread_state(_thread_in_vm);
2611 #ifndef PRODUCT
2612     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
2613       ttyLocker ttyl;
2614       BytecodeCounter::print();
2615     }
2616 #endif
2617     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
2618       ttyLocker ttyl;
2619       tty-&gt;print_cr(&quot; pc = 0x%016lx&quot;, pc);
2620 #ifndef PRODUCT
2621       tty-&gt;cr();
2622       findpc(pc);
2623       tty-&gt;cr();
2624 #endif
2625       tty-&gt;print_cr(&quot; r0 = 0x%016lx&quot;, regs[0]);
2626       tty-&gt;print_cr(&quot; r1 = 0x%016lx&quot;, regs[1]);
2627       tty-&gt;print_cr(&quot; r2 = 0x%016lx&quot;, regs[2]);
2628       tty-&gt;print_cr(&quot; r3 = 0x%016lx&quot;, regs[3]);
2629       tty-&gt;print_cr(&quot; r4 = 0x%016lx&quot;, regs[4]);
2630       tty-&gt;print_cr(&quot; r5 = 0x%016lx&quot;, regs[5]);
2631       tty-&gt;print_cr(&quot; r6 = 0x%016lx&quot;, regs[6]);
2632       tty-&gt;print_cr(&quot; r7 = 0x%016lx&quot;, regs[7]);
2633       tty-&gt;print_cr(&quot; r8 = 0x%016lx&quot;, regs[8]);
2634       tty-&gt;print_cr(&quot; r9 = 0x%016lx&quot;, regs[9]);
2635       tty-&gt;print_cr(&quot;r10 = 0x%016lx&quot;, regs[10]);
2636       tty-&gt;print_cr(&quot;r11 = 0x%016lx&quot;, regs[11]);
2637       tty-&gt;print_cr(&quot;r12 = 0x%016lx&quot;, regs[12]);
2638       tty-&gt;print_cr(&quot;r13 = 0x%016lx&quot;, regs[13]);
2639       tty-&gt;print_cr(&quot;r14 = 0x%016lx&quot;, regs[14]);
2640       tty-&gt;print_cr(&quot;r15 = 0x%016lx&quot;, regs[15]);
2641       tty-&gt;print_cr(&quot;r16 = 0x%016lx&quot;, regs[16]);
2642       tty-&gt;print_cr(&quot;r17 = 0x%016lx&quot;, regs[17]);
2643       tty-&gt;print_cr(&quot;r18 = 0x%016lx&quot;, regs[18]);
2644       tty-&gt;print_cr(&quot;r19 = 0x%016lx&quot;, regs[19]);
2645       tty-&gt;print_cr(&quot;r20 = 0x%016lx&quot;, regs[20]);
2646       tty-&gt;print_cr(&quot;r21 = 0x%016lx&quot;, regs[21]);
2647       tty-&gt;print_cr(&quot;r22 = 0x%016lx&quot;, regs[22]);
2648       tty-&gt;print_cr(&quot;r23 = 0x%016lx&quot;, regs[23]);
2649       tty-&gt;print_cr(&quot;r24 = 0x%016lx&quot;, regs[24]);
2650       tty-&gt;print_cr(&quot;r25 = 0x%016lx&quot;, regs[25]);
2651       tty-&gt;print_cr(&quot;r26 = 0x%016lx&quot;, regs[26]);
2652       tty-&gt;print_cr(&quot;r27 = 0x%016lx&quot;, regs[27]);
2653       tty-&gt;print_cr(&quot;r28 = 0x%016lx&quot;, regs[28]);
2654       tty-&gt;print_cr(&quot;r30 = 0x%016lx&quot;, regs[30]);
2655       tty-&gt;print_cr(&quot;r31 = 0x%016lx&quot;, regs[31]);
2656       BREAKPOINT;
2657     }
2658   }
2659   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
2660 }
2661 
2662 void MacroAssembler::push_call_clobbered_registers() {
2663   int step = 4 * wordSize;
2664   push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
2665   sub(sp, sp, step);
2666   mov(rscratch1, -step);
2667   // Push v0-v7, v16-v31.
2668   for (int i = 31; i&gt;= 4; i -= 4) {
2669     if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
2670       st1(as_FloatRegister(i-3), as_FloatRegister(i-2), as_FloatRegister(i-1),
2671           as_FloatRegister(i), T1D, Address(post(sp, rscratch1)));
2672   }
2673   st1(as_FloatRegister(0), as_FloatRegister(1), as_FloatRegister(2),
2674       as_FloatRegister(3), T1D, Address(sp));
2675 }
2676 
2677 void MacroAssembler::pop_call_clobbered_registers() {
2678   for (int i = 0; i &lt; 32; i += 4) {
2679     if (i &lt;= v7-&gt;encoding() || i &gt;= v16-&gt;encoding())
2680       ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2681           as_FloatRegister(i+3), T1D, Address(post(sp, 4 * wordSize)));
2682   }
2683 
2684   pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2), sp);
2685 }
2686 
2687 void MacroAssembler::push_CPU_state(bool save_vectors) {
2688   int step = (save_vectors ? 8 : 4) * wordSize;
2689   push(0x3fffffff, sp);         // integer registers except lr &amp; sp
2690   mov(rscratch1, -step);
2691   sub(sp, sp, step);
2692   for (int i = 28; i &gt;= 4; i -= 4) {
2693     st1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2694         as_FloatRegister(i+3), save_vectors ? T2D : T1D, Address(post(sp, rscratch1)));
2695   }
2696   st1(v0, v1, v2, v3, save_vectors ? T2D : T1D, sp);
2697 }
2698 
2699 void MacroAssembler::pop_CPU_state(bool restore_vectors) {
2700   int step = (restore_vectors ? 8 : 4) * wordSize;
2701   for (int i = 0; i &lt;= 28; i += 4)
2702     ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),
2703         as_FloatRegister(i+3), restore_vectors ? T2D : T1D, Address(post(sp, step)));
2704   pop(0x3fffffff, sp);         // integer registers except lr &amp; sp
2705 }
2706 
2707 /**
2708  * Helpers for multiply_to_len().
2709  */
2710 void MacroAssembler::add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,
2711                                      Register src1, Register src2) {
2712   adds(dest_lo, dest_lo, src1);
2713   adc(dest_hi, dest_hi, zr);
2714   adds(dest_lo, dest_lo, src2);
2715   adc(final_dest_hi, dest_hi, zr);
2716 }
2717 
2718 // Generate an address from (r + r1 extend offset).  &quot;size&quot; is the
2719 // size of the operand.  The result may be in rscratch2.
2720 Address MacroAssembler::offsetted_address(Register r, Register r1,
2721                                           Address::extend ext, int offset, int size) {
2722   if (offset || (ext.shift() % size != 0)) {
2723     lea(rscratch2, Address(r, r1, ext));
2724     return Address(rscratch2, offset);
2725   } else {
2726     return Address(r, r1, ext);
2727   }
2728 }
2729 
2730 Address MacroAssembler::spill_address(int size, int offset, Register tmp)
2731 {
2732   assert(offset &gt;= 0, &quot;spill to negative address?&quot;);
2733   // Offset reachable ?
2734   //   Not aligned - 9 bits signed offset
2735   //   Aligned - 12 bits unsigned offset shifted
2736   Register base = sp;
2737   if ((offset &amp; (size-1)) &amp;&amp; offset &gt;= (1&lt;&lt;8)) {
2738     add(tmp, base, offset &amp; ((1&lt;&lt;12)-1));
2739     base = tmp;
2740     offset &amp;= -1u&lt;&lt;12;
2741   }
2742 
2743   if (offset &gt;= (1&lt;&lt;12) * size) {
2744     add(tmp, base, offset &amp; (((1&lt;&lt;12)-1)&lt;&lt;12));
2745     base = tmp;
2746     offset &amp;= ~(((1&lt;&lt;12)-1)&lt;&lt;12);
2747   }
2748 
2749   return Address(base, offset);
2750 }
2751 
2752 // Checks whether offset is aligned.
2753 // Returns true if it is, else false.
2754 bool MacroAssembler::merge_alignment_check(Register base,
2755                                            size_t size,
2756                                            long cur_offset,
2757                                            long prev_offset) const {
2758   if (AvoidUnalignedAccesses) {
2759     if (base == sp) {
2760       // Checks whether low offset if aligned to pair of registers.
2761       long pair_mask = size * 2 - 1;
2762       long offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;
2763       return (offset &amp; pair_mask) == 0;
2764     } else { // If base is not sp, we can&#39;t guarantee the access is aligned.
2765       return false;
2766     }
2767   } else {
2768     long mask = size - 1;
2769     // Load/store pair instruction only supports element size aligned offset.
2770     return (cur_offset &amp; mask) == 0 &amp;&amp; (prev_offset &amp; mask) == 0;
2771   }
2772 }
2773 
2774 // Checks whether current and previous loads/stores can be merged.
2775 // Returns true if it can be merged, else false.
2776 bool MacroAssembler::ldst_can_merge(Register rt,
2777                                     const Address &amp;adr,
2778                                     size_t cur_size_in_bytes,
2779                                     bool is_store) const {
2780   address prev = pc() - NativeInstruction::instruction_size;
2781   address last = code()-&gt;last_insn();
2782 
2783   if (last == NULL || !nativeInstruction_at(last)-&gt;is_Imm_LdSt()) {
2784     return false;
2785   }
2786 
2787   if (adr.getMode() != Address::base_plus_offset || prev != last) {
2788     return false;
2789   }
2790 
2791   NativeLdSt* prev_ldst = NativeLdSt_at(prev);
2792   size_t prev_size_in_bytes = prev_ldst-&gt;size_in_bytes();
2793 
2794   assert(prev_size_in_bytes == 4 || prev_size_in_bytes == 8, &quot;only supports 64/32bit merging.&quot;);
2795   assert(cur_size_in_bytes == 4 || cur_size_in_bytes == 8, &quot;only supports 64/32bit merging.&quot;);
2796 
2797   if (cur_size_in_bytes != prev_size_in_bytes || is_store != prev_ldst-&gt;is_store()) {
2798     return false;
2799   }
2800 
2801   long max_offset = 63 * prev_size_in_bytes;
2802   long min_offset = -64 * prev_size_in_bytes;
2803 
2804   assert(prev_ldst-&gt;is_not_pre_post_index(), &quot;pre-index or post-index is not supported to be merged.&quot;);
2805 
2806   // Only same base can be merged.
2807   if (adr.base() != prev_ldst-&gt;base()) {
2808     return false;
2809   }
2810 
2811   long cur_offset = adr.offset();
2812   long prev_offset = prev_ldst-&gt;offset();
2813   size_t diff = abs(cur_offset - prev_offset);
2814   if (diff != prev_size_in_bytes) {
2815     return false;
2816   }
2817 
2818   // Following cases can not be merged:
2819   // ldr x2, [x2, #8]
2820   // ldr x3, [x2, #16]
2821   // or:
2822   // ldr x2, [x3, #8]
2823   // ldr x2, [x3, #16]
2824   // If t1 and t2 is the same in &quot;ldp t1, t2, [xn, #imm]&quot;, we&#39;ll get SIGILL.
2825   if (!is_store &amp;&amp; (adr.base() == prev_ldst-&gt;target() || rt == prev_ldst-&gt;target())) {
2826     return false;
2827   }
2828 
2829   long low_offset = prev_offset &gt; cur_offset ? cur_offset : prev_offset;
2830   // Offset range must be in ldp/stp instruction&#39;s range.
2831   if (low_offset &gt; max_offset || low_offset &lt; min_offset) {
2832     return false;
2833   }
2834 
2835   if (merge_alignment_check(adr.base(), prev_size_in_bytes, cur_offset, prev_offset)) {
2836     return true;
2837   }
2838 
2839   return false;
2840 }
2841 
2842 // Merge current load/store with previous load/store into ldp/stp.
2843 void MacroAssembler::merge_ldst(Register rt,
2844                                 const Address &amp;adr,
2845                                 size_t cur_size_in_bytes,
2846                                 bool is_store) {
2847 
2848   assert(ldst_can_merge(rt, adr, cur_size_in_bytes, is_store) == true, &quot;cur and prev must be able to be merged.&quot;);
2849 
2850   Register rt_low, rt_high;
2851   address prev = pc() - NativeInstruction::instruction_size;
2852   NativeLdSt* prev_ldst = NativeLdSt_at(prev);
2853 
2854   long offset;
2855 
2856   if (adr.offset() &lt; prev_ldst-&gt;offset()) {
2857     offset = adr.offset();
2858     rt_low = rt;
2859     rt_high = prev_ldst-&gt;target();
2860   } else {
2861     offset = prev_ldst-&gt;offset();
2862     rt_low = prev_ldst-&gt;target();
2863     rt_high = rt;
2864   }
2865 
2866   Address adr_p = Address(prev_ldst-&gt;base(), offset);
2867   // Overwrite previous generated binary.
2868   code_section()-&gt;set_end(prev);
2869 
2870   const int sz = prev_ldst-&gt;size_in_bytes();
2871   assert(sz == 8 || sz == 4, &quot;only supports 64/32bit merging.&quot;);
2872   if (!is_store) {
2873     BLOCK_COMMENT(&quot;merged ldr pair&quot;);
2874     if (sz == 8) {
2875       ldp(rt_low, rt_high, adr_p);
2876     } else {
2877       ldpw(rt_low, rt_high, adr_p);
2878     }
2879   } else {
2880     BLOCK_COMMENT(&quot;merged str pair&quot;);
2881     if (sz == 8) {
2882       stp(rt_low, rt_high, adr_p);
2883     } else {
2884       stpw(rt_low, rt_high, adr_p);
2885     }
2886   }
2887 }
2888 
2889 /**
2890  * Multiply 64 bit by 64 bit first loop.
2891  */
2892 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
2893                                            Register y, Register y_idx, Register z,
2894                                            Register carry, Register product,
2895                                            Register idx, Register kdx) {
2896   //
2897   //  jlong carry, x[], y[], z[];
2898   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
2899   //    huge_128 product = y[idx] * x[xstart] + carry;
2900   //    z[kdx] = (jlong)product;
2901   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
2902   //  }
2903   //  z[xstart] = carry;
2904   //
2905 
2906   Label L_first_loop, L_first_loop_exit;
2907   Label L_one_x, L_one_y, L_multiply;
2908 
2909   subsw(xstart, xstart, 1);
2910   br(Assembler::MI, L_one_x);
2911 
2912   lea(rscratch1, Address(x, xstart, Address::lsl(LogBytesPerInt)));
2913   ldr(x_xstart, Address(rscratch1));
2914   ror(x_xstart, x_xstart, 32); // convert big-endian to little-endian
2915 
2916   bind(L_first_loop);
2917   subsw(idx, idx, 1);
2918   br(Assembler::MI, L_first_loop_exit);
2919   subsw(idx, idx, 1);
2920   br(Assembler::MI, L_one_y);
2921   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
2922   ldr(y_idx, Address(rscratch1));
2923   ror(y_idx, y_idx, 32); // convert big-endian to little-endian
2924   bind(L_multiply);
2925 
2926   // AArch64 has a multiply-accumulate instruction that we can&#39;t use
2927   // here because it has no way to process carries, so we have to use
2928   // separate add and adc instructions.  Bah.
2929   umulh(rscratch1, x_xstart, y_idx); // x_xstart * y_idx -&gt; rscratch1:product
2930   mul(product, x_xstart, y_idx);
2931   adds(product, product, carry);
2932   adc(carry, rscratch1, zr);   // x_xstart * y_idx + carry -&gt; carry:product
2933 
2934   subw(kdx, kdx, 2);
2935   ror(product, product, 32); // back to big-endian
2936   str(product, offsetted_address(z, kdx, Address::uxtw(LogBytesPerInt), 0, BytesPerLong));
2937 
2938   b(L_first_loop);
2939 
2940   bind(L_one_y);
2941   ldrw(y_idx, Address(y,  0));
2942   b(L_multiply);
2943 
2944   bind(L_one_x);
2945   ldrw(x_xstart, Address(x,  0));
2946   b(L_first_loop);
2947 
2948   bind(L_first_loop_exit);
2949 }
2950 
2951 /**
2952  * Multiply 128 bit by 128. Unrolled inner loop.
2953  *
2954  */
2955 void MacroAssembler::multiply_128_x_128_loop(Register y, Register z,
2956                                              Register carry, Register carry2,
2957                                              Register idx, Register jdx,
2958                                              Register yz_idx1, Register yz_idx2,
2959                                              Register tmp, Register tmp3, Register tmp4,
2960                                              Register tmp6, Register product_hi) {
2961 
2962   //   jlong carry, x[], y[], z[];
2963   //   int kdx = ystart+1;
2964   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
2965   //     huge_128 tmp3 = (y[idx+1] * product_hi) + z[kdx+idx+1] + carry;
2966   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
2967   //     huge_128 tmp4 = (y[idx]   * product_hi) + z[kdx+idx] + carry2;
2968   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
2969   //     z[kdx+idx+1] = (jlong)tmp3;
2970   //     z[kdx+idx] = (jlong)tmp4;
2971   //   }
2972   //   idx += 2;
2973   //   if (idx &gt; 0) {
2974   //     yz_idx1 = (y[idx] * product_hi) + z[kdx+idx] + carry;
2975   //     z[kdx+idx] = (jlong)yz_idx1;
2976   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
2977   //   }
2978   //
2979 
2980   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
2981 
2982   lsrw(jdx, idx, 2);
2983 
2984   bind(L_third_loop);
2985 
2986   subsw(jdx, jdx, 1);
2987   br(Assembler::MI, L_third_loop_exit);
2988   subw(idx, idx, 4);
2989 
2990   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
2991 
2992   ldp(yz_idx2, yz_idx1, Address(rscratch1, 0));
2993 
2994   lea(tmp6, Address(z, idx, Address::uxtw(LogBytesPerInt)));
2995 
2996   ror(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
2997   ror(yz_idx2, yz_idx2, 32);
2998 
2999   ldp(rscratch2, rscratch1, Address(tmp6, 0));
3000 
3001   mul(tmp3, product_hi, yz_idx1);  //  yz_idx1 * product_hi -&gt; tmp4:tmp3
3002   umulh(tmp4, product_hi, yz_idx1);
3003 
3004   ror(rscratch1, rscratch1, 32); // convert big-endian to little-endian
3005   ror(rscratch2, rscratch2, 32);
3006 
3007   mul(tmp, product_hi, yz_idx2);   //  yz_idx2 * product_hi -&gt; carry2:tmp
3008   umulh(carry2, product_hi, yz_idx2);
3009 
3010   // propagate sum of both multiplications into carry:tmp4:tmp3
3011   adds(tmp3, tmp3, carry);
3012   adc(tmp4, tmp4, zr);
3013   adds(tmp3, tmp3, rscratch1);
3014   adcs(tmp4, tmp4, tmp);
3015   adc(carry, carry2, zr);
3016   adds(tmp4, tmp4, rscratch2);
3017   adc(carry, carry, zr);
3018 
3019   ror(tmp3, tmp3, 32); // convert little-endian to big-endian
3020   ror(tmp4, tmp4, 32);
3021   stp(tmp4, tmp3, Address(tmp6, 0));
3022 
3023   b(L_third_loop);
3024   bind (L_third_loop_exit);
3025 
3026   andw (idx, idx, 0x3);
3027   cbz(idx, L_post_third_loop_done);
3028 
3029   Label L_check_1;
3030   subsw(idx, idx, 2);
3031   br(Assembler::MI, L_check_1);
3032 
3033   lea(rscratch1, Address(y, idx, Address::uxtw(LogBytesPerInt)));
3034   ldr(yz_idx1, Address(rscratch1, 0));
3035   ror(yz_idx1, yz_idx1, 32);
3036   mul(tmp3, product_hi, yz_idx1);  //  yz_idx1 * product_hi -&gt; tmp4:tmp3
3037   umulh(tmp4, product_hi, yz_idx1);
3038   lea(rscratch1, Address(z, idx, Address::uxtw(LogBytesPerInt)));
3039   ldr(yz_idx2, Address(rscratch1, 0));
3040   ror(yz_idx2, yz_idx2, 32);
3041 
3042   add2_with_carry(carry, tmp4, tmp3, carry, yz_idx2);
3043 
3044   ror(tmp3, tmp3, 32);
3045   str(tmp3, Address(rscratch1, 0));
3046 
3047   bind (L_check_1);
3048 
3049   andw (idx, idx, 0x1);
3050   subsw(idx, idx, 1);
3051   br(Assembler::MI, L_post_third_loop_done);
3052   ldrw(tmp4, Address(y, idx, Address::uxtw(LogBytesPerInt)));
3053   mul(tmp3, tmp4, product_hi);  //  tmp4 * product_hi -&gt; carry2:tmp3
3054   umulh(carry2, tmp4, product_hi);
3055   ldrw(tmp4, Address(z, idx, Address::uxtw(LogBytesPerInt)));
3056 
3057   add2_with_carry(carry2, tmp3, tmp4, carry);
3058 
3059   strw(tmp3, Address(z, idx, Address::uxtw(LogBytesPerInt)));
3060   extr(carry, carry2, tmp3, 32);
3061 
3062   bind(L_post_third_loop_done);
3063 }
3064 
3065 /**
3066  * Code for BigInteger::multiplyToLen() instrinsic.
3067  *
3068  * r0: x
3069  * r1: xlen
3070  * r2: y
3071  * r3: ylen
3072  * r4:  z
3073  * r5: zlen
3074  * r10: tmp1
3075  * r11: tmp2
3076  * r12: tmp3
3077  * r13: tmp4
3078  * r14: tmp5
3079  * r15: tmp6
3080  * r16: tmp7
3081  *
3082  */
3083 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen,
3084                                      Register z, Register zlen,
3085                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4,
3086                                      Register tmp5, Register tmp6, Register product_hi) {
3087 
3088   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);
3089 
3090   const Register idx = tmp1;
3091   const Register kdx = tmp2;
3092   const Register xstart = tmp3;
3093 
3094   const Register y_idx = tmp4;
3095   const Register carry = tmp5;
3096   const Register product  = xlen;
3097   const Register x_xstart = zlen;  // reuse register
3098 
3099   // First Loop.
3100   //
3101   //  final static long LONG_MASK = 0xffffffffL;
3102   //  int xstart = xlen - 1;
3103   //  int ystart = ylen - 1;
3104   //  long carry = 0;
3105   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
3106   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
3107   //    z[kdx] = (int)product;
3108   //    carry = product &gt;&gt;&gt; 32;
3109   //  }
3110   //  z[xstart] = (int)carry;
3111   //
3112 
3113   movw(idx, ylen);      // idx = ylen;
3114   movw(kdx, zlen);      // kdx = xlen+ylen;
3115   mov(carry, zr);       // carry = 0;
3116 
3117   Label L_done;
3118 
3119   movw(xstart, xlen);
3120   subsw(xstart, xstart, 1);
3121   br(Assembler::MI, L_done);
3122 
3123   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
3124 
3125   Label L_second_loop;
3126   cbzw(kdx, L_second_loop);
3127 
3128   Label L_carry;
3129   subw(kdx, kdx, 1);
3130   cbzw(kdx, L_carry);
3131 
3132   strw(carry, Address(z, kdx, Address::uxtw(LogBytesPerInt)));
3133   lsr(carry, carry, 32);
3134   subw(kdx, kdx, 1);
3135 
3136   bind(L_carry);
3137   strw(carry, Address(z, kdx, Address::uxtw(LogBytesPerInt)));
3138 
3139   // Second and third (nested) loops.
3140   //
3141   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
3142   //   carry = 0;
3143   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
3144   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
3145   //                    (z[k] &amp; LONG_MASK) + carry;
3146   //     z[k] = (int)product;
3147   //     carry = product &gt;&gt;&gt; 32;
3148   //   }
3149   //   z[i] = (int)carry;
3150   // }
3151   //
3152   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = product_hi
3153 
3154   const Register jdx = tmp1;
3155 
3156   bind(L_second_loop);
3157   mov(carry, zr);                // carry = 0;
3158   movw(jdx, ylen);               // j = ystart+1
3159 
3160   subsw(xstart, xstart, 1);      // i = xstart-1;
3161   br(Assembler::MI, L_done);
3162 
3163   str(z, Address(pre(sp, -4 * wordSize)));
3164 
3165   Label L_last_x;
3166   lea(z, offsetted_address(z, xstart, Address::uxtw(LogBytesPerInt), 4, BytesPerInt)); // z = z + k - j
3167   subsw(xstart, xstart, 1);       // i = xstart-1;
3168   br(Assembler::MI, L_last_x);
3169 
3170   lea(rscratch1, Address(x, xstart, Address::uxtw(LogBytesPerInt)));
3171   ldr(product_hi, Address(rscratch1));
3172   ror(product_hi, product_hi, 32);  // convert big-endian to little-endian
3173 
3174   Label L_third_loop_prologue;
3175   bind(L_third_loop_prologue);
3176 
3177   str(ylen, Address(sp, wordSize));
3178   stp(x, xstart, Address(sp, 2 * wordSize));
3179   multiply_128_x_128_loop(y, z, carry, x, jdx, ylen, product,
3180                           tmp2, x_xstart, tmp3, tmp4, tmp6, product_hi);
3181   ldp(z, ylen, Address(post(sp, 2 * wordSize)));
3182   ldp(x, xlen, Address(post(sp, 2 * wordSize)));   // copy old xstart -&gt; xlen
3183 
3184   addw(tmp3, xlen, 1);
3185   strw(carry, Address(z, tmp3, Address::uxtw(LogBytesPerInt)));
3186   subsw(tmp3, tmp3, 1);
3187   br(Assembler::MI, L_done);
3188 
3189   lsr(carry, carry, 32);
3190   strw(carry, Address(z, tmp3, Address::uxtw(LogBytesPerInt)));
3191   b(L_second_loop);
3192 
3193   // Next infrequent code is moved outside loops.
3194   bind(L_last_x);
3195   ldrw(product_hi, Address(x,  0));
3196   b(L_third_loop_prologue);
3197 
3198   bind(L_done);
3199 }
3200 
3201 // Code for BigInteger::mulAdd instrinsic
3202 // out     = r0
3203 // in      = r1
3204 // offset  = r2  (already out.length-offset)
3205 // len     = r3
3206 // k       = r4
3207 //
3208 // pseudo code from java implementation:
3209 // carry = 0;
3210 // offset = out.length-offset - 1;
3211 // for (int j=len-1; j &gt;= 0; j--) {
3212 //     product = (in[j] &amp; LONG_MASK) * kLong + (out[offset] &amp; LONG_MASK) + carry;
3213 //     out[offset--] = (int)product;
3214 //     carry = product &gt;&gt;&gt; 32;
3215 // }
3216 // return (int)carry;
3217 void MacroAssembler::mul_add(Register out, Register in, Register offset,
3218       Register len, Register k) {
3219     Label LOOP, END;
3220     // pre-loop
3221     cmp(len, zr); // cmp, not cbz/cbnz: to use condition twice =&gt; less branches
3222     csel(out, zr, out, Assembler::EQ);
3223     br(Assembler::EQ, END);
3224     add(in, in, len, LSL, 2); // in[j+1] address
3225     add(offset, out, offset, LSL, 2); // out[offset + 1] address
3226     mov(out, zr); // used to keep carry now
3227     BIND(LOOP);
3228     ldrw(rscratch1, Address(pre(in, -4)));
3229     madd(rscratch1, rscratch1, k, out);
3230     ldrw(rscratch2, Address(pre(offset, -4)));
3231     add(rscratch1, rscratch1, rscratch2);
3232     strw(rscratch1, Address(offset));
3233     lsr(out, rscratch1, 32);
3234     subs(len, len, 1);
3235     br(Assembler::NE, LOOP);
3236     BIND(END);
3237 }
3238 
3239 /**
3240  * Emits code to update CRC-32 with a byte value according to constants in table
3241  *
3242  * @param [in,out]crc   Register containing the crc.
3243  * @param [in]val       Register containing the byte to fold into the CRC.
3244  * @param [in]table     Register containing the table of crc constants.
3245  *
3246  * uint32_t crc;
3247  * val = crc_table[(val ^ crc) &amp; 0xFF];
3248  * crc = val ^ (crc &gt;&gt; 8);
3249  *
3250  */
3251 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
3252   eor(val, val, crc);
3253   andr(val, val, 0xff);
3254   ldrw(val, Address(table, val, Address::lsl(2)));
3255   eor(crc, val, crc, Assembler::LSR, 8);
3256 }
3257 
3258 /**
3259  * Emits code to update CRC-32 with a 32-bit value according to tables 0 to 3
3260  *
3261  * @param [in,out]crc   Register containing the crc.
3262  * @param [in]v         Register containing the 32-bit to fold into the CRC.
3263  * @param [in]table0    Register containing table 0 of crc constants.
3264  * @param [in]table1    Register containing table 1 of crc constants.
3265  * @param [in]table2    Register containing table 2 of crc constants.
3266  * @param [in]table3    Register containing table 3 of crc constants.
3267  *
3268  * uint32_t crc;
3269  *   v = crc ^ v
3270  *   crc = table3[v&amp;0xff]^table2[(v&gt;&gt;8)&amp;0xff]^table1[(v&gt;&gt;16)&amp;0xff]^table0[v&gt;&gt;24]
3271  *
3272  */
3273 void MacroAssembler::update_word_crc32(Register crc, Register v, Register tmp,
3274         Register table0, Register table1, Register table2, Register table3,
3275         bool upper) {
3276   eor(v, crc, v, upper ? LSR:LSL, upper ? 32:0);
3277   uxtb(tmp, v);
3278   ldrw(crc, Address(table3, tmp, Address::lsl(2)));
3279   ubfx(tmp, v, 8, 8);
3280   ldrw(tmp, Address(table2, tmp, Address::lsl(2)));
3281   eor(crc, crc, tmp);
3282   ubfx(tmp, v, 16, 8);
3283   ldrw(tmp, Address(table1, tmp, Address::lsl(2)));
3284   eor(crc, crc, tmp);
3285   ubfx(tmp, v, 24, 8);
3286   ldrw(tmp, Address(table0, tmp, Address::lsl(2)));
3287   eor(crc, crc, tmp);
3288 }
3289 
3290 void MacroAssembler::kernel_crc32_using_crc32(Register crc, Register buf,
3291         Register len, Register tmp0, Register tmp1, Register tmp2,
3292         Register tmp3) {
3293     Label CRC_by64_loop, CRC_by4_loop, CRC_by1_loop, CRC_less64, CRC_by64_pre, CRC_by32_loop, CRC_less32, L_exit;
3294     assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2, tmp3);
3295 
3296     mvnw(crc, crc);
3297 
3298     subs(len, len, 128);
3299     br(Assembler::GE, CRC_by64_pre);
3300   BIND(CRC_less64);
3301     adds(len, len, 128-32);
3302     br(Assembler::GE, CRC_by32_loop);
3303   BIND(CRC_less32);
3304     adds(len, len, 32-4);
3305     br(Assembler::GE, CRC_by4_loop);
3306     adds(len, len, 4);
3307     br(Assembler::GT, CRC_by1_loop);
3308     b(L_exit);
3309 
3310   BIND(CRC_by32_loop);
3311     ldp(tmp0, tmp1, Address(post(buf, 16)));
3312     subs(len, len, 32);
3313     crc32x(crc, crc, tmp0);
3314     ldr(tmp2, Address(post(buf, 8)));
3315     crc32x(crc, crc, tmp1);
3316     ldr(tmp3, Address(post(buf, 8)));
3317     crc32x(crc, crc, tmp2);
3318     crc32x(crc, crc, tmp3);
3319     br(Assembler::GE, CRC_by32_loop);
3320     cmn(len, 32);
3321     br(Assembler::NE, CRC_less32);
3322     b(L_exit);
3323 
3324   BIND(CRC_by4_loop);
3325     ldrw(tmp0, Address(post(buf, 4)));
3326     subs(len, len, 4);
3327     crc32w(crc, crc, tmp0);
3328     br(Assembler::GE, CRC_by4_loop);
3329     adds(len, len, 4);
3330     br(Assembler::LE, L_exit);
3331   BIND(CRC_by1_loop);
3332     ldrb(tmp0, Address(post(buf, 1)));
3333     subs(len, len, 1);
3334     crc32b(crc, crc, tmp0);
3335     br(Assembler::GT, CRC_by1_loop);
3336     b(L_exit);
3337 
3338   BIND(CRC_by64_pre);
3339     sub(buf, buf, 8);
3340     ldp(tmp0, tmp1, Address(buf, 8));
3341     crc32x(crc, crc, tmp0);
3342     ldr(tmp2, Address(buf, 24));
3343     crc32x(crc, crc, tmp1);
3344     ldr(tmp3, Address(buf, 32));
3345     crc32x(crc, crc, tmp2);
3346     ldr(tmp0, Address(buf, 40));
3347     crc32x(crc, crc, tmp3);
3348     ldr(tmp1, Address(buf, 48));
3349     crc32x(crc, crc, tmp0);
3350     ldr(tmp2, Address(buf, 56));
3351     crc32x(crc, crc, tmp1);
3352     ldr(tmp3, Address(pre(buf, 64)));
3353 
3354     b(CRC_by64_loop);
3355 
3356     align(CodeEntryAlignment);
3357   BIND(CRC_by64_loop);
3358     subs(len, len, 64);
3359     crc32x(crc, crc, tmp2);
3360     ldr(tmp0, Address(buf, 8));
3361     crc32x(crc, crc, tmp3);
3362     ldr(tmp1, Address(buf, 16));
3363     crc32x(crc, crc, tmp0);
3364     ldr(tmp2, Address(buf, 24));
3365     crc32x(crc, crc, tmp1);
3366     ldr(tmp3, Address(buf, 32));
3367     crc32x(crc, crc, tmp2);
3368     ldr(tmp0, Address(buf, 40));
3369     crc32x(crc, crc, tmp3);
3370     ldr(tmp1, Address(buf, 48));
3371     crc32x(crc, crc, tmp0);
3372     ldr(tmp2, Address(buf, 56));
3373     crc32x(crc, crc, tmp1);
3374     ldr(tmp3, Address(pre(buf, 64)));
3375     br(Assembler::GE, CRC_by64_loop);
3376 
3377     // post-loop
3378     crc32x(crc, crc, tmp2);
3379     crc32x(crc, crc, tmp3);
3380 
3381     sub(len, len, 64);
3382     add(buf, buf, 8);
3383     cmn(len, 128);
3384     br(Assembler::NE, CRC_less64);
3385   BIND(L_exit);
3386     mvnw(crc, crc);
3387 }
3388 
3389 /**
3390  * @param crc   register containing existing CRC (32-bit)
3391  * @param buf   register pointing to input byte buffer (byte*)
3392  * @param len   register containing number of bytes
3393  * @param table register that will contain address of CRC table
3394  * @param tmp   scratch register
3395  */
3396 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len,
3397         Register table0, Register table1, Register table2, Register table3,
3398         Register tmp, Register tmp2, Register tmp3) {
3399   Label L_by16, L_by16_loop, L_by4, L_by4_loop, L_by1, L_by1_loop, L_exit;
3400   unsigned long offset;
3401 
3402   if (UseCRC32) {
3403       kernel_crc32_using_crc32(crc, buf, len, table0, table1, table2, table3);
3404       return;
3405   }
3406 
3407     mvnw(crc, crc);
3408 
3409     adrp(table0, ExternalAddress(StubRoutines::crc_table_addr()), offset);
3410     if (offset) add(table0, table0, offset);
3411     add(table1, table0, 1*256*sizeof(juint));
3412     add(table2, table0, 2*256*sizeof(juint));
3413     add(table3, table0, 3*256*sizeof(juint));
3414 
3415   if (UseNeon) {
3416       cmp(len, (u1)64);
3417       br(Assembler::LT, L_by16);
3418       eor(v16, T16B, v16, v16);
3419 
3420     Label L_fold;
3421 
3422       add(tmp, table0, 4*256*sizeof(juint)); // Point at the Neon constants
3423 
3424       ld1(v0, v1, T2D, post(buf, 32));
3425       ld1r(v4, T2D, post(tmp, 8));
3426       ld1r(v5, T2D, post(tmp, 8));
3427       ld1r(v6, T2D, post(tmp, 8));
3428       ld1r(v7, T2D, post(tmp, 8));
3429       mov(v16, T4S, 0, crc);
3430 
3431       eor(v0, T16B, v0, v16);
3432       sub(len, len, 64);
3433 
3434     BIND(L_fold);
3435       pmull(v22, T8H, v0, v5, T8B);
3436       pmull(v20, T8H, v0, v7, T8B);
3437       pmull(v23, T8H, v0, v4, T8B);
3438       pmull(v21, T8H, v0, v6, T8B);
3439 
3440       pmull2(v18, T8H, v0, v5, T16B);
3441       pmull2(v16, T8H, v0, v7, T16B);
3442       pmull2(v19, T8H, v0, v4, T16B);
3443       pmull2(v17, T8H, v0, v6, T16B);
3444 
3445       uzp1(v24, T8H, v20, v22);
3446       uzp2(v25, T8H, v20, v22);
3447       eor(v20, T16B, v24, v25);
3448 
3449       uzp1(v26, T8H, v16, v18);
3450       uzp2(v27, T8H, v16, v18);
3451       eor(v16, T16B, v26, v27);
3452 
3453       ushll2(v22, T4S, v20, T8H, 8);
3454       ushll(v20, T4S, v20, T4H, 8);
3455 
3456       ushll2(v18, T4S, v16, T8H, 8);
3457       ushll(v16, T4S, v16, T4H, 8);
3458 
3459       eor(v22, T16B, v23, v22);
3460       eor(v18, T16B, v19, v18);
3461       eor(v20, T16B, v21, v20);
3462       eor(v16, T16B, v17, v16);
3463 
3464       uzp1(v17, T2D, v16, v20);
3465       uzp2(v21, T2D, v16, v20);
3466       eor(v17, T16B, v17, v21);
3467 
3468       ushll2(v20, T2D, v17, T4S, 16);
3469       ushll(v16, T2D, v17, T2S, 16);
3470 
3471       eor(v20, T16B, v20, v22);
3472       eor(v16, T16B, v16, v18);
3473 
3474       uzp1(v17, T2D, v20, v16);
3475       uzp2(v21, T2D, v20, v16);
3476       eor(v28, T16B, v17, v21);
3477 
3478       pmull(v22, T8H, v1, v5, T8B);
3479       pmull(v20, T8H, v1, v7, T8B);
3480       pmull(v23, T8H, v1, v4, T8B);
3481       pmull(v21, T8H, v1, v6, T8B);
3482 
3483       pmull2(v18, T8H, v1, v5, T16B);
3484       pmull2(v16, T8H, v1, v7, T16B);
3485       pmull2(v19, T8H, v1, v4, T16B);
3486       pmull2(v17, T8H, v1, v6, T16B);
3487 
3488       ld1(v0, v1, T2D, post(buf, 32));
3489 
3490       uzp1(v24, T8H, v20, v22);
3491       uzp2(v25, T8H, v20, v22);
3492       eor(v20, T16B, v24, v25);
3493 
3494       uzp1(v26, T8H, v16, v18);
3495       uzp2(v27, T8H, v16, v18);
3496       eor(v16, T16B, v26, v27);
3497 
3498       ushll2(v22, T4S, v20, T8H, 8);
3499       ushll(v20, T4S, v20, T4H, 8);
3500 
3501       ushll2(v18, T4S, v16, T8H, 8);
3502       ushll(v16, T4S, v16, T4H, 8);
3503 
3504       eor(v22, T16B, v23, v22);
3505       eor(v18, T16B, v19, v18);
3506       eor(v20, T16B, v21, v20);
3507       eor(v16, T16B, v17, v16);
3508 
3509       uzp1(v17, T2D, v16, v20);
3510       uzp2(v21, T2D, v16, v20);
3511       eor(v16, T16B, v17, v21);
3512 
3513       ushll2(v20, T2D, v16, T4S, 16);
3514       ushll(v16, T2D, v16, T2S, 16);
3515 
3516       eor(v20, T16B, v22, v20);
3517       eor(v16, T16B, v16, v18);
3518 
3519       uzp1(v17, T2D, v20, v16);
3520       uzp2(v21, T2D, v20, v16);
3521       eor(v20, T16B, v17, v21);
3522 
3523       shl(v16, T2D, v28, 1);
3524       shl(v17, T2D, v20, 1);
3525 
3526       eor(v0, T16B, v0, v16);
3527       eor(v1, T16B, v1, v17);
3528 
3529       subs(len, len, 32);
3530       br(Assembler::GE, L_fold);
3531 
3532       mov(crc, 0);
3533       mov(tmp, v0, T1D, 0);
3534       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3535       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3536       mov(tmp, v0, T1D, 1);
3537       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3538       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3539       mov(tmp, v1, T1D, 0);
3540       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3541       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3542       mov(tmp, v1, T1D, 1);
3543       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3544       update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3545 
3546       add(len, len, 32);
3547   }
3548 
3549   BIND(L_by16);
3550     subs(len, len, 16);
3551     br(Assembler::GE, L_by16_loop);
3552     adds(len, len, 16-4);
3553     br(Assembler::GE, L_by4_loop);
3554     adds(len, len, 4);
3555     br(Assembler::GT, L_by1_loop);
3556     b(L_exit);
3557 
3558   BIND(L_by4_loop);
3559     ldrw(tmp, Address(post(buf, 4)));
3560     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3);
3561     subs(len, len, 4);
3562     br(Assembler::GE, L_by4_loop);
3563     adds(len, len, 4);
3564     br(Assembler::LE, L_exit);
3565   BIND(L_by1_loop);
3566     subs(len, len, 1);
3567     ldrb(tmp, Address(post(buf, 1)));
3568     update_byte_crc32(crc, tmp, table0);
3569     br(Assembler::GT, L_by1_loop);
3570     b(L_exit);
3571 
3572     align(CodeEntryAlignment);
3573   BIND(L_by16_loop);
3574     subs(len, len, 16);
3575     ldp(tmp, tmp3, Address(post(buf, 16)));
3576     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, false);
3577     update_word_crc32(crc, tmp, tmp2, table0, table1, table2, table3, true);
3578     update_word_crc32(crc, tmp3, tmp2, table0, table1, table2, table3, false);
3579     update_word_crc32(crc, tmp3, tmp2, table0, table1, table2, table3, true);
3580     br(Assembler::GE, L_by16_loop);
3581     adds(len, len, 16-4);
3582     br(Assembler::GE, L_by4_loop);
3583     adds(len, len, 4);
3584     br(Assembler::GT, L_by1_loop);
3585   BIND(L_exit);
3586     mvnw(crc, crc);
3587 }
3588 
3589 void MacroAssembler::kernel_crc32c_using_crc32c(Register crc, Register buf,
3590         Register len, Register tmp0, Register tmp1, Register tmp2,
3591         Register tmp3) {
3592     Label CRC_by64_loop, CRC_by4_loop, CRC_by1_loop, CRC_less64, CRC_by64_pre, CRC_by32_loop, CRC_less32, L_exit;
3593     assert_different_registers(crc, buf, len, tmp0, tmp1, tmp2, tmp3);
3594 
3595     subs(len, len, 128);
3596     br(Assembler::GE, CRC_by64_pre);
3597   BIND(CRC_less64);
3598     adds(len, len, 128-32);
3599     br(Assembler::GE, CRC_by32_loop);
3600   BIND(CRC_less32);
3601     adds(len, len, 32-4);
3602     br(Assembler::GE, CRC_by4_loop);
3603     adds(len, len, 4);
3604     br(Assembler::GT, CRC_by1_loop);
3605     b(L_exit);
3606 
3607   BIND(CRC_by32_loop);
3608     ldp(tmp0, tmp1, Address(post(buf, 16)));
3609     subs(len, len, 32);
3610     crc32cx(crc, crc, tmp0);
3611     ldr(tmp2, Address(post(buf, 8)));
3612     crc32cx(crc, crc, tmp1);
3613     ldr(tmp3, Address(post(buf, 8)));
3614     crc32cx(crc, crc, tmp2);
3615     crc32cx(crc, crc, tmp3);
3616     br(Assembler::GE, CRC_by32_loop);
3617     cmn(len, 32);
3618     br(Assembler::NE, CRC_less32);
3619     b(L_exit);
3620 
3621   BIND(CRC_by4_loop);
3622     ldrw(tmp0, Address(post(buf, 4)));
3623     subs(len, len, 4);
3624     crc32cw(crc, crc, tmp0);
3625     br(Assembler::GE, CRC_by4_loop);
3626     adds(len, len, 4);
3627     br(Assembler::LE, L_exit);
3628   BIND(CRC_by1_loop);
3629     ldrb(tmp0, Address(post(buf, 1)));
3630     subs(len, len, 1);
3631     crc32cb(crc, crc, tmp0);
3632     br(Assembler::GT, CRC_by1_loop);
3633     b(L_exit);
3634 
3635   BIND(CRC_by64_pre);
3636     sub(buf, buf, 8);
3637     ldp(tmp0, tmp1, Address(buf, 8));
3638     crc32cx(crc, crc, tmp0);
3639     ldr(tmp2, Address(buf, 24));
3640     crc32cx(crc, crc, tmp1);
3641     ldr(tmp3, Address(buf, 32));
3642     crc32cx(crc, crc, tmp2);
3643     ldr(tmp0, Address(buf, 40));
3644     crc32cx(crc, crc, tmp3);
3645     ldr(tmp1, Address(buf, 48));
3646     crc32cx(crc, crc, tmp0);
3647     ldr(tmp2, Address(buf, 56));
3648     crc32cx(crc, crc, tmp1);
3649     ldr(tmp3, Address(pre(buf, 64)));
3650 
3651     b(CRC_by64_loop);
3652 
3653     align(CodeEntryAlignment);
3654   BIND(CRC_by64_loop);
3655     subs(len, len, 64);
3656     crc32cx(crc, crc, tmp2);
3657     ldr(tmp0, Address(buf, 8));
3658     crc32cx(crc, crc, tmp3);
3659     ldr(tmp1, Address(buf, 16));
3660     crc32cx(crc, crc, tmp0);
3661     ldr(tmp2, Address(buf, 24));
3662     crc32cx(crc, crc, tmp1);
3663     ldr(tmp3, Address(buf, 32));
3664     crc32cx(crc, crc, tmp2);
3665     ldr(tmp0, Address(buf, 40));
3666     crc32cx(crc, crc, tmp3);
3667     ldr(tmp1, Address(buf, 48));
3668     crc32cx(crc, crc, tmp0);
3669     ldr(tmp2, Address(buf, 56));
3670     crc32cx(crc, crc, tmp1);
3671     ldr(tmp3, Address(pre(buf, 64)));
3672     br(Assembler::GE, CRC_by64_loop);
3673 
3674     // post-loop
3675     crc32cx(crc, crc, tmp2);
3676     crc32cx(crc, crc, tmp3);
3677 
3678     sub(len, len, 64);
3679     add(buf, buf, 8);
3680     cmn(len, 128);
3681     br(Assembler::NE, CRC_less64);
3682   BIND(L_exit);
3683 }
3684 
3685 /**
3686  * @param crc   register containing existing CRC (32-bit)
3687  * @param buf   register pointing to input byte buffer (byte*)
3688  * @param len   register containing number of bytes
3689  * @param table register that will contain address of CRC table
3690  * @param tmp   scratch register
3691  */
3692 void MacroAssembler::kernel_crc32c(Register crc, Register buf, Register len,
3693         Register table0, Register table1, Register table2, Register table3,
3694         Register tmp, Register tmp2, Register tmp3) {
3695   kernel_crc32c_using_crc32c(crc, buf, len, table0, table1, table2, table3);
3696 }
3697 
3698 
3699 SkipIfEqual::SkipIfEqual(
3700     MacroAssembler* masm, const bool* flag_addr, bool value) {
3701   _masm = masm;
3702   unsigned long offset;
3703   _masm-&gt;adrp(rscratch1, ExternalAddress((address)flag_addr), offset);
3704   _masm-&gt;ldrb(rscratch1, Address(rscratch1, offset));
3705   _masm-&gt;cbzw(rscratch1, _label);
3706 }
3707 
3708 SkipIfEqual::~SkipIfEqual() {
3709   _masm-&gt;bind(_label);
3710 }
3711 
3712 void MacroAssembler::addptr(const Address &amp;dst, int32_t src) {
3713   Address adr;
3714   switch(dst.getMode()) {
3715   case Address::base_plus_offset:
3716     // This is the expected mode, although we allow all the other
3717     // forms below.
3718     adr = form_address(rscratch2, dst.base(), dst.offset(), LogBytesPerWord);
3719     break;
3720   default:
3721     lea(rscratch2, dst);
3722     adr = Address(rscratch2);
3723     break;
3724   }
3725   ldr(rscratch1, adr);
3726   add(rscratch1, rscratch1, src);
3727   str(rscratch1, adr);
3728 }
3729 
3730 void MacroAssembler::cmpptr(Register src1, Address src2) {
3731   unsigned long offset;
3732   adrp(rscratch1, src2, offset);
3733   ldr(rscratch1, Address(rscratch1, offset));
3734   cmp(src1, rscratch1);
3735 }
3736 
3737 void MacroAssembler::cmpoop(Register obj1, Register obj2) {
3738   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3739   bs-&gt;obj_equals(this, obj1, obj2);
3740 }
3741 
3742 void MacroAssembler::load_method_holder(Register holder, Register method) {
3743   ldr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
3744   ldr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
3745   ldr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
3746 }
3747 
<a name="6" id="anc6"></a><span class="line-modified">3748 void MacroAssembler::load_metadata(Register dst, Register src) {</span>
3749   if (UseCompressedClassPointers) {
3750     ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));
<a name="7" id="anc7"></a>
3751   } else {
3752     ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));
3753   }
3754 }
3755 
<a name="8" id="anc8"></a><span class="line-added">3756 void MacroAssembler::load_klass(Register dst, Register src) {</span>
<span class="line-added">3757   load_metadata(dst, src);</span>
<span class="line-added">3758   if (UseCompressedClassPointers) {</span>
<span class="line-added">3759     andr(dst, dst, oopDesc::compressed_klass_mask());</span>
<span class="line-added">3760     decode_klass_not_null(dst);</span>
<span class="line-added">3761   } else {</span>
<span class="line-added">3762     ubfm(dst, dst, 0, 63 - oopDesc::storage_props_nof_bits);</span>
<span class="line-added">3763   }</span>
<span class="line-added">3764 }</span>
<span class="line-added">3765 </span>
3766 // ((OopHandle)result).resolve();
3767 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
3768   // OopHandle::resolve is an indirection.
3769   access_load_at(T_OBJECT, IN_NATIVE, result, Address(result, 0), tmp, noreg);
3770 }
3771 
3772 void MacroAssembler::load_mirror(Register dst, Register method, Register tmp) {
3773   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
3774   ldr(dst, Address(rmethod, Method::const_offset()));
3775   ldr(dst, Address(dst, ConstMethod::constants_offset()));
3776   ldr(dst, Address(dst, ConstantPool::pool_holder_offset_in_bytes()));
3777   ldr(dst, Address(dst, mirror_offset));
3778   resolve_oop_handle(dst, tmp);
3779 }
3780 
<a name="9" id="anc9"></a><span class="line-added">3781 void MacroAssembler::load_storage_props(Register dst, Register src) {</span>
<span class="line-added">3782   load_metadata(dst, src);</span>
<span class="line-added">3783   if (UseCompressedClassPointers) {</span>
<span class="line-added">3784     asrw(dst, dst, oopDesc::narrow_storage_props_shift);</span>
<span class="line-added">3785   } else {</span>
<span class="line-added">3786     asr(dst, dst, oopDesc::wide_storage_props_shift);</span>
<span class="line-added">3787   }</span>
<span class="line-added">3788 }</span>
<span class="line-added">3789 </span>
3790 void MacroAssembler::cmp_klass(Register oop, Register trial_klass, Register tmp) {
3791   if (UseCompressedClassPointers) {
3792     ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
3793     if (CompressedKlassPointers::base() == NULL) {
3794       cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());
3795       return;
3796     } else if (((uint64_t)CompressedKlassPointers::base() &amp; 0xffffffff) == 0
3797                &amp;&amp; CompressedKlassPointers::shift() == 0) {
3798       // Only the bottom 32 bits matter
3799       cmpw(trial_klass, tmp);
3800       return;
3801     }
3802     decode_klass_not_null(tmp);
3803   } else {
3804     ldr(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));
3805   }
3806   cmp(trial_klass, tmp);
3807 }
3808 
3809 void MacroAssembler::load_prototype_header(Register dst, Register src) {
3810   load_klass(dst, src);
3811   ldr(dst, Address(dst, Klass::prototype_header_offset()));
3812 }
3813 
3814 void MacroAssembler::store_klass(Register dst, Register src) {
3815   // FIXME: Should this be a store release?  concurrent gcs assumes
3816   // klass length is valid if klass field is not null.
3817   if (UseCompressedClassPointers) {
3818     encode_klass_not_null(src);
3819     strw(src, Address(dst, oopDesc::klass_offset_in_bytes()));
3820   } else {
3821     str(src, Address(dst, oopDesc::klass_offset_in_bytes()));
3822   }
3823 }
3824 
3825 void MacroAssembler::store_klass_gap(Register dst, Register src) {
3826   if (UseCompressedClassPointers) {
3827     // Store to klass gap in destination
3828     strw(src, Address(dst, oopDesc::klass_gap_offset_in_bytes()));
3829   }
3830 }
3831 
3832 // Algorithm must match CompressedOops::encode.
3833 void MacroAssembler::encode_heap_oop(Register d, Register s) {
3834 #ifdef ASSERT
3835   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
3836 #endif
3837   verify_oop(s, &quot;broken oop in encode_heap_oop&quot;);
3838   if (CompressedOops::base() == NULL) {
3839     if (CompressedOops::shift() != 0) {
3840       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3841       lsr(d, s, LogMinObjAlignmentInBytes);
3842     } else {
3843       mov(d, s);
3844     }
3845   } else {
3846     subs(d, s, rheapbase);
3847     csel(d, d, zr, Assembler::HS);
3848     lsr(d, d, LogMinObjAlignmentInBytes);
3849 
3850     /*  Old algorithm: is this any worse?
3851     Label nonnull;
3852     cbnz(r, nonnull);
3853     sub(r, r, rheapbase);
3854     bind(nonnull);
3855     lsr(r, r, LogMinObjAlignmentInBytes);
3856     */
3857   }
3858 }
3859 
3860 void MacroAssembler::encode_heap_oop_not_null(Register r) {
3861 #ifdef ASSERT
3862   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
3863   if (CheckCompressedOops) {
3864     Label ok;
3865     cbnz(r, ok);
3866     stop(&quot;null oop passed to encode_heap_oop_not_null&quot;);
3867     bind(ok);
3868   }
3869 #endif
3870   verify_oop(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
3871   if (CompressedOops::base() != NULL) {
3872     sub(r, r, rheapbase);
3873   }
3874   if (CompressedOops::shift() != 0) {
3875     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3876     lsr(r, r, LogMinObjAlignmentInBytes);
3877   }
3878 }
3879 
3880 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
3881 #ifdef ASSERT
3882   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
3883   if (CheckCompressedOops) {
3884     Label ok;
3885     cbnz(src, ok);
3886     stop(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
3887     bind(ok);
3888   }
3889 #endif
3890   verify_oop(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
3891 
3892   Register data = src;
3893   if (CompressedOops::base() != NULL) {
3894     sub(dst, src, rheapbase);
3895     data = dst;
3896   }
3897   if (CompressedOops::shift() != 0) {
3898     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3899     lsr(dst, data, LogMinObjAlignmentInBytes);
3900     data = dst;
3901   }
3902   if (data == src)
3903     mov(dst, src);
3904 }
3905 
3906 void  MacroAssembler::decode_heap_oop(Register d, Register s) {
3907 #ifdef ASSERT
3908   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
3909 #endif
3910   if (CompressedOops::base() == NULL) {
3911     if (CompressedOops::shift() != 0 || d != s) {
3912       lsl(d, s, CompressedOops::shift());
3913     }
3914   } else {
3915     Label done;
3916     if (d != s)
3917       mov(d, s);
3918     cbz(s, done);
3919     add(d, rheapbase, s, Assembler::LSL, LogMinObjAlignmentInBytes);
3920     bind(done);
3921   }
3922   verify_oop(d, &quot;broken oop in decode_heap_oop&quot;);
3923 }
3924 
3925 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
3926   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
3927   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3928   // Cannot assert, unverified entry point counts instructions (see .ad file)
3929   // vtableStubs also counts instructions in pd_code_size_limit.
3930   // Also do not verify_oop as this is called by verify_oop.
3931   if (CompressedOops::shift() != 0) {
3932     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3933     if (CompressedOops::base() != NULL) {
3934       add(r, rheapbase, r, Assembler::LSL, LogMinObjAlignmentInBytes);
3935     } else {
3936       add(r, zr, r, Assembler::LSL, LogMinObjAlignmentInBytes);
3937     }
3938   } else {
3939     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
3940   }
3941 }
3942 
3943 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
3944   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
3945   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
3946   // Cannot assert, unverified entry point counts instructions (see .ad file)
3947   // vtableStubs also counts instructions in pd_code_size_limit.
3948   // Also do not verify_oop as this is called by verify_oop.
3949   if (CompressedOops::shift() != 0) {
3950     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
3951     if (CompressedOops::base() != NULL) {
3952       add(dst, rheapbase, src, Assembler::LSL, LogMinObjAlignmentInBytes);
3953     } else {
3954       add(dst, zr, src, Assembler::LSL, LogMinObjAlignmentInBytes);
3955     }
3956   } else {
3957     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
3958     if (dst != src) {
3959       mov(dst, src);
3960     }
3961   }
3962 }
3963 
3964 MacroAssembler::KlassDecodeMode MacroAssembler::_klass_decode_mode(KlassDecodeNone);
3965 
3966 MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode() {
3967   assert(UseCompressedClassPointers, &quot;not using compressed class pointers&quot;);
3968   assert(Metaspace::initialized(), &quot;metaspace not initialized yet&quot;);
3969 
3970   if (_klass_decode_mode != KlassDecodeNone) {
3971     return _klass_decode_mode;
3972   }
3973 
3974   assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift()
3975          || 0 == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
3976 
3977   if (CompressedKlassPointers::base() == NULL) {
3978     return (_klass_decode_mode = KlassDecodeZero);
3979   }
3980 
3981   if (operand_valid_for_logical_immediate(
3982         /*is32*/false, (uint64_t)CompressedKlassPointers::base())) {
3983     const uint64_t range_mask =
3984       (1UL &lt;&lt; log2_intptr(CompressedKlassPointers::range())) - 1;
3985     if (((uint64_t)CompressedKlassPointers::base() &amp; range_mask) == 0) {
3986       return (_klass_decode_mode = KlassDecodeXor);
3987     }
3988   }
3989 
3990   const uint64_t shifted_base =
3991     (uint64_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift();
3992   guarantee((shifted_base &amp; 0xffff0000ffffffff) == 0,
3993             &quot;compressed class base bad alignment&quot;);
3994 
3995   return (_klass_decode_mode = KlassDecodeMovk);
3996 }
3997 
3998 void MacroAssembler::encode_klass_not_null(Register dst, Register src) {
3999   switch (klass_decode_mode()) {
4000   case KlassDecodeZero:
4001     if (CompressedKlassPointers::shift() != 0) {
4002       lsr(dst, src, LogKlassAlignmentInBytes);
4003     } else {
4004       if (dst != src) mov(dst, src);
4005     }
4006     break;
4007 
4008   case KlassDecodeXor:
4009     if (CompressedKlassPointers::shift() != 0) {
4010       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
4011       lsr(dst, dst, LogKlassAlignmentInBytes);
4012     } else {
4013       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
4014     }
4015     break;
4016 
4017   case KlassDecodeMovk:
4018     if (CompressedKlassPointers::shift() != 0) {
4019       ubfx(dst, src, LogKlassAlignmentInBytes, 32);
4020     } else {
4021       movw(dst, src);
4022     }
4023     break;
4024 
4025   case KlassDecodeNone:
4026     ShouldNotReachHere();
4027     break;
4028   }
4029 }
4030 
4031 void MacroAssembler::encode_klass_not_null(Register r) {
4032   encode_klass_not_null(r, r);
4033 }
4034 
4035 void  MacroAssembler::decode_klass_not_null(Register dst, Register src) {
4036   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4037 
4038   switch (klass_decode_mode()) {
4039   case KlassDecodeZero:
4040     if (CompressedKlassPointers::shift() != 0) {
4041       lsl(dst, src, LogKlassAlignmentInBytes);
4042     } else {
4043       if (dst != src) mov(dst, src);
4044     }
4045     break;
4046 
4047   case KlassDecodeXor:
4048     if (CompressedKlassPointers::shift() != 0) {
4049       lsl(dst, src, LogKlassAlignmentInBytes);
4050       eor(dst, dst, (uint64_t)CompressedKlassPointers::base());
4051     } else {
4052       eor(dst, src, (uint64_t)CompressedKlassPointers::base());
4053     }
4054     break;
4055 
4056   case KlassDecodeMovk: {
4057     const uint64_t shifted_base =
4058       (uint64_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift();
4059 
4060     if (dst != src) movw(dst, src);
4061     movk(dst, shifted_base &gt;&gt; 32, 32);
4062 
4063     if (CompressedKlassPointers::shift() != 0) {
4064       lsl(dst, dst, LogKlassAlignmentInBytes);
4065     }
4066 
4067     break;
4068   }
4069 
4070   case KlassDecodeNone:
4071     ShouldNotReachHere();
4072     break;
4073   }
4074 }
4075 
4076 void  MacroAssembler::decode_klass_not_null(Register r) {
4077   decode_klass_not_null(r, r);
4078 }
4079 
4080 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4081 #ifdef ASSERT
4082   {
4083     ThreadInVMfromUnknown tiv;
4084     assert (UseCompressedOops, &quot;should only be used for compressed oops&quot;);
4085     assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4086     assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4087     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4088   }
4089 #endif
4090   int oop_index = oop_recorder()-&gt;find_index(obj);
4091   InstructionMark im(this);
4092   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4093   code_section()-&gt;relocate(inst_mark(), rspec);
4094   movz(dst, 0xDEAD, 16);
4095   movk(dst, 0xBEEF);
4096 }
4097 
4098 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4099   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4100   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4101   int index = oop_recorder()-&gt;find_index(k);
4102   assert(! Universe::heap()-&gt;is_in(k), &quot;should not be an oop&quot;);
4103 
4104   InstructionMark im(this);
4105   RelocationHolder rspec = metadata_Relocation::spec(index);
4106   code_section()-&gt;relocate(inst_mark(), rspec);
4107   narrowKlass nk = CompressedKlassPointers::encode(k);
4108   movz(dst, (nk &gt;&gt; 16), 16);
4109   movk(dst, nk &amp; 0xffff);
4110 }
4111 
4112 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators,
4113                                     Register dst, Address src,
4114                                     Register tmp1, Register thread_tmp) {
4115   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4116   decorators = AccessInternal::decorator_fixup(decorators);
4117   bool as_raw = (decorators &amp; AS_RAW) != 0;
4118   if (as_raw) {
4119     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4120   } else {
4121     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4122   }
4123 }
4124 
4125 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators,
4126                                      Address dst, Register src,
<a name="10" id="anc10"></a><span class="line-modified">4127                                      Register tmp1, Register thread_tmp, Register tmp3) {</span>
<span class="line-added">4128 </span>
4129   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4130   decorators = AccessInternal::decorator_fixup(decorators);
4131   bool as_raw = (decorators &amp; AS_RAW) != 0;
4132   if (as_raw) {
<a name="11" id="anc11"></a><span class="line-modified">4133     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, thread_tmp, tmp3);</span>
4134   } else {
<a name="12" id="anc12"></a><span class="line-modified">4135     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, thread_tmp, tmp3);</span>
4136   }
4137 }
4138 
4139 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4140   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4141   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4142     decorators |= ACCESS_READ | ACCESS_WRITE;
4143   }
4144   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4145   return bs-&gt;resolve(this, decorators, obj);
4146 }
4147 
4148 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4149                                    Register thread_tmp, DecoratorSet decorators) {
4150   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4151 }
4152 
4153 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4154                                             Register thread_tmp, DecoratorSet decorators) {
4155   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4156 }
4157 
4158 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
<a name="13" id="anc13"></a><span class="line-modified">4159                                     Register thread_tmp, Register tmp3, DecoratorSet decorators) {</span>
<span class="line-modified">4160   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp, tmp3);</span>
4161 }
4162 
4163 // Used for storing NULLs.
4164 void MacroAssembler::store_heap_oop_null(Address dst) {
<a name="14" id="anc14"></a><span class="line-modified">4165   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);</span>
4166 }
4167 
4168 Address MacroAssembler::allocate_metadata_address(Metadata* obj) {
4169   assert(oop_recorder() != NULL, &quot;this assembler needs a Recorder&quot;);
4170   int index = oop_recorder()-&gt;allocate_metadata_index(obj);
4171   RelocationHolder rspec = metadata_Relocation::spec(index);
4172   return Address((address)obj, rspec);
4173 }
4174 
4175 // Move an oop into a register.  immediate is true if we want
4176 // immediate instrcutions, i.e. we are not going to patch this
4177 // instruction while the code is being executed by another thread.  In
4178 // that case we can use move immediates rather than the constant pool.
4179 void MacroAssembler::movoop(Register dst, jobject obj, bool immediate) {
4180   int oop_index;
4181   if (obj == NULL) {
4182     oop_index = oop_recorder()-&gt;allocate_oop_index(obj);
4183   } else {
4184 #ifdef ASSERT
4185     {
4186       ThreadInVMfromUnknown tiv;
4187       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;should be real oop&quot;);
4188     }
4189 #endif
4190     oop_index = oop_recorder()-&gt;find_index(obj);
4191   }
4192   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4193   if (! immediate) {
4194     address dummy = address(uintptr_t(pc()) &amp; -wordSize); // A nearby aligned address
4195     ldr_constant(dst, Address(dummy, rspec));
4196   } else
4197     mov(dst, Address((address)obj, rspec));
4198 }
4199 
4200 // Move a metadata address into a register.
4201 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
4202   int oop_index;
4203   if (obj == NULL) {
4204     oop_index = oop_recorder()-&gt;allocate_metadata_index(obj);
4205   } else {
4206     oop_index = oop_recorder()-&gt;find_index(obj);
4207   }
4208   RelocationHolder rspec = metadata_Relocation::spec(oop_index);
4209   mov(dst, Address((address)obj, rspec));
4210 }
4211 
4212 Address MacroAssembler::constant_oop_address(jobject obj) {
4213 #ifdef ASSERT
4214   {
4215     ThreadInVMfromUnknown tiv;
4216     assert(oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4217     assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(obj)), &quot;not an oop&quot;);
4218   }
4219 #endif
4220   int oop_index = oop_recorder()-&gt;find_index(obj);
4221   return Address((address)obj, oop_Relocation::spec(oop_index));
4222 }
4223 
4224 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
4225 void MacroAssembler::tlab_allocate(Register obj,
4226                                    Register var_size_in_bytes,
4227                                    int con_size_in_bytes,
4228                                    Register t1,
4229                                    Register t2,
4230                                    Label&amp; slow_case) {
4231   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4232   bs-&gt;tlab_allocate(this, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
4233 }
4234 
4235 // Defines obj, preserves var_size_in_bytes
4236 void MacroAssembler::eden_allocate(Register obj,
4237                                    Register var_size_in_bytes,
4238                                    int con_size_in_bytes,
4239                                    Register t1,
4240                                    Label&amp; slow_case) {
4241   BarrierSetAssembler *bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4242   bs-&gt;eden_allocate(this, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
4243 }
4244 
4245 // Zero words; len is in bytes
4246 // Destroys all registers except addr
4247 // len must be a nonzero multiple of wordSize
4248 void MacroAssembler::zero_memory(Register addr, Register len, Register t1) {
4249   assert_different_registers(addr, len, t1, rscratch1, rscratch2);
4250 
4251 #ifdef ASSERT
4252   { Label L;
4253     tst(len, BytesPerWord - 1);
4254     br(Assembler::EQ, L);
4255     stop(&quot;len is not a multiple of BytesPerWord&quot;);
4256     bind(L);
4257   }
4258 #endif
4259 
4260 #ifndef PRODUCT
4261   block_comment(&quot;zero memory&quot;);
4262 #endif
4263 
4264   Label loop;
4265   Label entry;
4266 
4267 //  Algorithm:
4268 //
4269 //    scratch1 = cnt &amp; 7;
4270 //    cnt -= scratch1;
4271 //    p += scratch1;
4272 //    switch (scratch1) {
4273 //      do {
4274 //        cnt -= 8;
4275 //          p[-8] = 0;
4276 //        case 7:
4277 //          p[-7] = 0;
4278 //        case 6:
4279 //          p[-6] = 0;
4280 //          // ...
4281 //        case 1:
4282 //          p[-1] = 0;
4283 //        case 0:
4284 //          p += 8;
4285 //      } while (cnt);
4286 //    }
4287 
4288   const int unroll = 8; // Number of str(zr) instructions we&#39;ll unroll
4289 
4290   lsr(len, len, LogBytesPerWord);
4291   andr(rscratch1, len, unroll - 1);  // tmp1 = cnt % unroll
4292   sub(len, len, rscratch1);      // cnt -= unroll
4293   // t1 always points to the end of the region we&#39;re about to zero
4294   add(t1, addr, rscratch1, Assembler::LSL, LogBytesPerWord);
4295   adr(rscratch2, entry);
4296   sub(rscratch2, rscratch2, rscratch1, Assembler::LSL, 2);
4297   br(rscratch2);
4298   bind(loop);
4299   sub(len, len, unroll);
4300   for (int i = -unroll; i &lt; 0; i++)
4301     Assembler::str(zr, Address(t1, i * wordSize));
4302   bind(entry);
4303   add(t1, t1, unroll * wordSize);
4304   cbnz(len, loop);
4305 }
4306 
4307 void MacroAssembler::verify_tlab() {
4308 #ifdef ASSERT
4309   if (UseTLAB &amp;&amp; VerifyOops) {
4310     Label next, ok;
4311 
4312     stp(rscratch2, rscratch1, Address(pre(sp, -16)));
4313 
4314     ldr(rscratch2, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));
4315     ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_start_offset())));
4316     cmp(rscratch2, rscratch1);
4317     br(Assembler::HS, next);
4318     STOP(&quot;assert(top &gt;= start)&quot;);
4319     should_not_reach_here();
4320 
4321     bind(next);
4322     ldr(rscratch2, Address(rthread, in_bytes(JavaThread::tlab_end_offset())));
4323     ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));
4324     cmp(rscratch2, rscratch1);
4325     br(Assembler::HS, ok);
4326     STOP(&quot;assert(top &lt;= end)&quot;);
4327     should_not_reach_here();
4328 
4329     bind(ok);
4330     ldp(rscratch2, rscratch1, Address(post(sp, 16)));
4331   }
4332 #endif
4333 }
4334 
4335 // Writes to stack successive pages until offset reached to check for
4336 // stack overflow + shadow pages.  This clobbers tmp.
4337 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
4338   assert_different_registers(tmp, size, rscratch1);
4339   mov(tmp, sp);
4340   // Bang stack for total size given plus shadow page size.
4341   // Bang one page at a time because large size can bang beyond yellow and
4342   // red zones.
4343   Label loop;
4344   mov(rscratch1, os::vm_page_size());
4345   bind(loop);
4346   lea(tmp, Address(tmp, -os::vm_page_size()));
4347   subsw(size, size, rscratch1);
4348   str(size, Address(tmp));
4349   br(Assembler::GT, loop);
4350 
4351   // Bang down shadow pages too.
4352   // At this point, (tmp-0) is the last address touched, so don&#39;t
4353   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
4354   // was post-decremented.)  Skip this address by starting at i=1, and
4355   // touch a few more pages below.  N.B.  It is important to touch all
4356   // the way down to and including i=StackShadowPages.
4357   for (int i = 0; i &lt; (int)(JavaThread::stack_shadow_zone_size() / os::vm_page_size()) - 1; i++) {
4358     // this could be any sized move but this is can be a debugging crumb
4359     // so the bigger the better.
4360     lea(tmp, Address(tmp, -os::vm_page_size()));
4361     str(size, Address(tmp));
4362   }
4363 }
4364 
4365 // Move the address of the polling page into dest.
4366 void MacroAssembler::get_polling_page(Register dest, relocInfo::relocType rtype) {
4367   ldr(dest, Address(rthread, Thread::polling_page_offset()));
4368 }
4369 
4370 // Move the address of the polling page into r, then read the polling
4371 // page.
4372 address MacroAssembler::fetch_and_read_polling_page(Register r, relocInfo::relocType rtype) {
4373   get_polling_page(r, rtype);
4374   return read_polling_page(r, rtype);
4375 }
4376 
4377 // Read the polling page.  The address of the polling page must
4378 // already be in r.
4379 address MacroAssembler::read_polling_page(Register r, relocInfo::relocType rtype) {
4380   InstructionMark im(this);
4381   code_section()-&gt;relocate(inst_mark(), rtype);
4382   ldrw(zr, Address(r, 0));
4383   return inst_mark();
4384 }
4385 
4386 void MacroAssembler::adrp(Register reg1, const Address &amp;dest, unsigned long &amp;byte_offset) {
4387   relocInfo::relocType rtype = dest.rspec().reloc()-&gt;type();
4388   unsigned long low_page = (unsigned long)CodeCache::low_bound() &gt;&gt; 12;
4389   unsigned long high_page = (unsigned long)(CodeCache::high_bound()-1) &gt;&gt; 12;
4390   unsigned long dest_page = (unsigned long)dest.target() &gt;&gt; 12;
4391   long offset_low = dest_page - low_page;
4392   long offset_high = dest_page - high_page;
4393 
4394   assert(is_valid_AArch64_address(dest.target()), &quot;bad address&quot;);
4395   assert(dest.getMode() == Address::literal, &quot;ADRP must be applied to a literal address&quot;);
4396 
4397   InstructionMark im(this);
4398   code_section()-&gt;relocate(inst_mark(), dest.rspec());
4399   // 8143067: Ensure that the adrp can reach the dest from anywhere within
4400   // the code cache so that if it is relocated we know it will still reach
4401   if (offset_high &gt;= -(1&lt;&lt;20) &amp;&amp; offset_low &lt; (1&lt;&lt;20)) {
4402     _adrp(reg1, dest.target());
4403   } else {
4404     unsigned long target = (unsigned long)dest.target();
4405     unsigned long adrp_target
4406       = (target &amp; 0xffffffffUL) | ((unsigned long)pc() &amp; 0xffff00000000UL);
4407 
4408     _adrp(reg1, (address)adrp_target);
4409     movk(reg1, target &gt;&gt; 32, 32);
4410   }
4411   byte_offset = (unsigned long)dest.target() &amp; 0xfff;
4412 }
4413 
4414 void MacroAssembler::load_byte_map_base(Register reg) {
4415   CardTable::CardValue* byte_map_base =
4416     ((CardTableBarrierSet*)(BarrierSet::barrier_set()))-&gt;card_table()-&gt;byte_map_base();
4417 
4418   if (is_valid_AArch64_address((address)byte_map_base)) {
4419     // Strictly speaking the byte_map_base isn&#39;t an address at all,
4420     // and it might even be negative.
4421     unsigned long offset;
4422     adrp(reg, ExternalAddress((address)byte_map_base), offset);
4423     // We expect offset to be zero with most collectors.
4424     if (offset != 0) {
4425       add(reg, reg, offset);
4426     }
4427   } else {
4428     mov(reg, (uint64_t)byte_map_base);
4429   }
4430 }
4431 
4432 void MacroAssembler::build_frame(int framesize) {
4433   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4434   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4435     sub(sp, sp, framesize);
4436     stp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4437     if (PreserveFramePointer) add(rfp, sp, framesize - 2 * wordSize);
4438   } else {
4439     stp(rfp, lr, Address(pre(sp, -2 * wordSize)));
4440     if (PreserveFramePointer) mov(rfp, sp);
4441     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4442       sub(sp, sp, framesize - 2 * wordSize);
4443     else {
4444       mov(rscratch1, framesize - 2 * wordSize);
4445       sub(sp, sp, rscratch1);
4446     }
4447   }
4448 }
4449 
4450 void MacroAssembler::remove_frame(int framesize) {
4451   assert(framesize &gt; 0, &quot;framesize must be &gt; 0&quot;);
4452   if (framesize &lt; ((1 &lt;&lt; 9) + 2 * wordSize)) {
4453     ldp(rfp, lr, Address(sp, framesize - 2 * wordSize));
4454     add(sp, sp, framesize);
4455   } else {
4456     if (framesize &lt; ((1 &lt;&lt; 12) + 2 * wordSize))
4457       add(sp, sp, framesize - 2 * wordSize);
4458     else {
4459       mov(rscratch1, framesize - 2 * wordSize);
4460       add(sp, sp, rscratch1);
4461     }
4462     ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
4463   }
4464 }
4465 
4466 
4467 // This method checks if provided byte array contains byte with highest bit set.
4468 void MacroAssembler::has_negatives(Register ary1, Register len, Register result) {
4469     // Simple and most common case of aligned small array which is not at the
4470     // end of memory page is placed here. All other cases are in stub.
4471     Label LOOP, END, STUB, STUB_LONG, SET_RESULT, DONE;
4472     const uint64_t UPPER_BIT_MASK=0x8080808080808080;
4473     assert_different_registers(ary1, len, result);
4474 
4475     cmpw(len, 0);
4476     br(LE, SET_RESULT);
4477     cmpw(len, 4 * wordSize);
4478     br(GE, STUB_LONG); // size &gt; 32 then go to stub
4479 
4480     int shift = 64 - exact_log2(os::vm_page_size());
4481     lsl(rscratch1, ary1, shift);
4482     mov(rscratch2, (size_t)(4 * wordSize) &lt;&lt; shift);
4483     adds(rscratch2, rscratch1, rscratch2);  // At end of page?
4484     br(CS, STUB); // at the end of page then go to stub
4485     subs(len, len, wordSize);
4486     br(LT, END);
4487 
4488   BIND(LOOP);
4489     ldr(rscratch1, Address(post(ary1, wordSize)));
4490     tst(rscratch1, UPPER_BIT_MASK);
4491     br(NE, SET_RESULT);
4492     subs(len, len, wordSize);
4493     br(GE, LOOP);
4494     cmpw(len, -wordSize);
4495     br(EQ, SET_RESULT);
4496 
4497   BIND(END);
4498     ldr(result, Address(ary1));
4499     sub(len, zr, len, LSL, 3); // LSL 3 is to get bits from bytes
4500     lslv(result, result, len);
4501     tst(result, UPPER_BIT_MASK);
4502     b(SET_RESULT);
4503 
4504   BIND(STUB);
4505     RuntimeAddress has_neg =  RuntimeAddress(StubRoutines::aarch64::has_negatives());
4506     assert(has_neg.target() != NULL, &quot;has_negatives stub has not been generated&quot;);
4507     trampoline_call(has_neg);
4508     b(DONE);
4509 
4510   BIND(STUB_LONG);
4511     RuntimeAddress has_neg_long =  RuntimeAddress(
4512             StubRoutines::aarch64::has_negatives_long());
4513     assert(has_neg_long.target() != NULL, &quot;has_negatives stub has not been generated&quot;);
4514     trampoline_call(has_neg_long);
4515     b(DONE);
4516 
4517   BIND(SET_RESULT);
4518     cset(result, NE); // set true or false
4519 
4520   BIND(DONE);
4521 }
4522 
4523 void MacroAssembler::arrays_equals(Register a1, Register a2, Register tmp3,
4524                                    Register tmp4, Register tmp5, Register result,
4525                                    Register cnt1, int elem_size) {
4526   Label DONE, SAME;
4527   Register tmp1 = rscratch1;
4528   Register tmp2 = rscratch2;
4529   Register cnt2 = tmp2;  // cnt2 only used in array length compare
4530   int elem_per_word = wordSize/elem_size;
4531   int log_elem_size = exact_log2(elem_size);
4532   int length_offset = arrayOopDesc::length_offset_in_bytes();
4533   int base_offset
4534     = arrayOopDesc::base_offset_in_bytes(elem_size == 2 ? T_CHAR : T_BYTE);
4535   int stubBytesThreshold = 3 * 64 + (UseSIMDForArrayEquals ? 0 : 16);
4536 
4537   assert(elem_size == 1 || elem_size == 2, &quot;must be char or byte&quot;);
4538   assert_different_registers(a1, a2, result, cnt1, rscratch1, rscratch2);
4539 
4540 #ifndef PRODUCT
4541   {
4542     const char kind = (elem_size == 2) ? &#39;U&#39; : &#39;L&#39;;
4543     char comment[64];
4544     snprintf(comment, sizeof comment, &quot;array_equals%c{&quot;, kind);
4545     BLOCK_COMMENT(comment);
4546   }
4547 #endif
4548 
4549   // if (a1 == a2)
4550   //     return true;
4551   cmpoop(a1, a2); // May have read barriers for a1 and a2.
4552   br(EQ, SAME);
4553 
4554   if (UseSimpleArrayEquals) {
4555     Label NEXT_WORD, SHORT, TAIL03, TAIL01, A_MIGHT_BE_NULL, A_IS_NOT_NULL;
4556     // if (a1 == null || a2 == null)
4557     //     return false;
4558     // a1 &amp; a2 == 0 means (some-pointer is null) or
4559     // (very-rare-or-even-probably-impossible-pointer-values)
4560     // so, we can save one branch in most cases
4561     tst(a1, a2);
4562     mov(result, false);
4563     br(EQ, A_MIGHT_BE_NULL);
4564     // if (a1.length != a2.length)
4565     //      return false;
4566     bind(A_IS_NOT_NULL);
4567     ldrw(cnt1, Address(a1, length_offset));
4568     ldrw(cnt2, Address(a2, length_offset));
4569     eorw(tmp5, cnt1, cnt2);
4570     cbnzw(tmp5, DONE);
4571     lea(a1, Address(a1, base_offset));
4572     lea(a2, Address(a2, base_offset));
4573     // Check for short strings, i.e. smaller than wordSize.
4574     subs(cnt1, cnt1, elem_per_word);
4575     br(Assembler::LT, SHORT);
4576     // Main 8 byte comparison loop.
4577     bind(NEXT_WORD); {
4578       ldr(tmp1, Address(post(a1, wordSize)));
4579       ldr(tmp2, Address(post(a2, wordSize)));
4580       subs(cnt1, cnt1, elem_per_word);
4581       eor(tmp5, tmp1, tmp2);
4582       cbnz(tmp5, DONE);
4583     } br(GT, NEXT_WORD);
4584     // Last longword.  In the case where length == 4 we compare the
4585     // same longword twice, but that&#39;s still faster than another
4586     // conditional branch.
4587     // cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when
4588     // length == 4.
4589     if (log_elem_size &gt; 0)
4590       lsl(cnt1, cnt1, log_elem_size);
4591     ldr(tmp3, Address(a1, cnt1));
4592     ldr(tmp4, Address(a2, cnt1));
4593     eor(tmp5, tmp3, tmp4);
4594     cbnz(tmp5, DONE);
4595     b(SAME);
4596     bind(A_MIGHT_BE_NULL);
4597     // in case both a1 and a2 are not-null, proceed with loads
4598     cbz(a1, DONE);
4599     cbz(a2, DONE);
4600     b(A_IS_NOT_NULL);
4601     bind(SHORT);
4602 
4603     tbz(cnt1, 2 - log_elem_size, TAIL03); // 0-7 bytes left.
4604     {
4605       ldrw(tmp1, Address(post(a1, 4)));
4606       ldrw(tmp2, Address(post(a2, 4)));
4607       eorw(tmp5, tmp1, tmp2);
4608       cbnzw(tmp5, DONE);
4609     }
4610     bind(TAIL03);
4611     tbz(cnt1, 1 - log_elem_size, TAIL01); // 0-3 bytes left.
4612     {
4613       ldrh(tmp3, Address(post(a1, 2)));
4614       ldrh(tmp4, Address(post(a2, 2)));
4615       eorw(tmp5, tmp3, tmp4);
4616       cbnzw(tmp5, DONE);
4617     }
4618     bind(TAIL01);
4619     if (elem_size == 1) { // Only needed when comparing byte arrays.
4620       tbz(cnt1, 0, SAME); // 0-1 bytes left.
4621       {
4622         ldrb(tmp1, a1);
4623         ldrb(tmp2, a2);
4624         eorw(tmp5, tmp1, tmp2);
4625         cbnzw(tmp5, DONE);
4626       }
4627     }
4628   } else {
4629     Label NEXT_DWORD, SHORT, TAIL, TAIL2, STUB, EARLY_OUT,
4630         CSET_EQ, LAST_CHECK;
4631     mov(result, false);
4632     cbz(a1, DONE);
4633     ldrw(cnt1, Address(a1, length_offset));
4634     cbz(a2, DONE);
4635     ldrw(cnt2, Address(a2, length_offset));
4636     // on most CPUs a2 is still &quot;locked&quot;(surprisingly) in ldrw and it&#39;s
4637     // faster to perform another branch before comparing a1 and a2
4638     cmp(cnt1, (u1)elem_per_word);
4639     br(LE, SHORT); // short or same
4640     ldr(tmp3, Address(pre(a1, base_offset)));
4641     subs(zr, cnt1, stubBytesThreshold);
4642     br(GE, STUB);
4643     ldr(tmp4, Address(pre(a2, base_offset)));
4644     sub(tmp5, zr, cnt1, LSL, 3 + log_elem_size);
4645     cmp(cnt2, cnt1);
4646     br(NE, DONE);
4647 
4648     // Main 16 byte comparison loop with 2 exits
4649     bind(NEXT_DWORD); {
4650       ldr(tmp1, Address(pre(a1, wordSize)));
4651       ldr(tmp2, Address(pre(a2, wordSize)));
4652       subs(cnt1, cnt1, 2 * elem_per_word);
4653       br(LE, TAIL);
4654       eor(tmp4, tmp3, tmp4);
4655       cbnz(tmp4, DONE);
4656       ldr(tmp3, Address(pre(a1, wordSize)));
4657       ldr(tmp4, Address(pre(a2, wordSize)));
4658       cmp(cnt1, (u1)elem_per_word);
4659       br(LE, TAIL2);
4660       cmp(tmp1, tmp2);
4661     } br(EQ, NEXT_DWORD);
4662     b(DONE);
4663 
4664     bind(TAIL);
4665     eor(tmp4, tmp3, tmp4);
4666     eor(tmp2, tmp1, tmp2);
4667     lslv(tmp2, tmp2, tmp5);
4668     orr(tmp5, tmp4, tmp2);
4669     cmp(tmp5, zr);
4670     b(CSET_EQ);
4671 
4672     bind(TAIL2);
4673     eor(tmp2, tmp1, tmp2);
4674     cbnz(tmp2, DONE);
4675     b(LAST_CHECK);
4676 
4677     bind(STUB);
4678     ldr(tmp4, Address(pre(a2, base_offset)));
4679     cmp(cnt2, cnt1);
4680     br(NE, DONE);
4681     if (elem_size == 2) { // convert to byte counter
4682       lsl(cnt1, cnt1, 1);
4683     }
4684     eor(tmp5, tmp3, tmp4);
4685     cbnz(tmp5, DONE);
4686     RuntimeAddress stub = RuntimeAddress(StubRoutines::aarch64::large_array_equals());
4687     assert(stub.target() != NULL, &quot;array_equals_long stub has not been generated&quot;);
4688     trampoline_call(stub);
4689     b(DONE);
4690 
4691     bind(EARLY_OUT);
4692     // (a1 != null &amp;&amp; a2 == null) || (a1 != null &amp;&amp; a2 != null &amp;&amp; a1 == a2)
4693     // so, if a2 == null =&gt; return false(0), else return true, so we can return a2
4694     mov(result, a2);
4695     b(DONE);
4696     bind(SHORT);
4697     cmp(cnt2, cnt1);
4698     br(NE, DONE);
4699     cbz(cnt1, SAME);
4700     sub(tmp5, zr, cnt1, LSL, 3 + log_elem_size);
4701     ldr(tmp3, Address(a1, base_offset));
4702     ldr(tmp4, Address(a2, base_offset));
4703     bind(LAST_CHECK);
4704     eor(tmp4, tmp3, tmp4);
4705     lslv(tmp5, tmp4, tmp5);
4706     cmp(tmp5, zr);
4707     bind(CSET_EQ);
4708     cset(result, EQ);
4709     b(DONE);
4710   }
4711 
4712   bind(SAME);
4713   mov(result, true);
4714   // That&#39;s it.
4715   bind(DONE);
4716 
4717   BLOCK_COMMENT(&quot;} array_equals&quot;);
4718 }
4719 
4720 // Compare Strings
4721 
4722 // For Strings we&#39;re passed the address of the first characters in a1
4723 // and a2 and the length in cnt1.
4724 // elem_size is the element size in bytes: either 1 or 2.
4725 // There are two implementations.  For arrays &gt;= 8 bytes, all
4726 // comparisons (including the final one, which may overlap) are
4727 // performed 8 bytes at a time.  For strings &lt; 8 bytes, we compare a
4728 // halfword, then a short, and then a byte.
4729 
4730 void MacroAssembler::string_equals(Register a1, Register a2,
4731                                    Register result, Register cnt1, int elem_size)
4732 {
4733   Label SAME, DONE, SHORT, NEXT_WORD;
4734   Register tmp1 = rscratch1;
4735   Register tmp2 = rscratch2;
4736   Register cnt2 = tmp2;  // cnt2 only used in array length compare
4737 
4738   assert(elem_size == 1 || elem_size == 2, &quot;must be 2 or 1 byte&quot;);
4739   assert_different_registers(a1, a2, result, cnt1, rscratch1, rscratch2);
4740 
4741 #ifndef PRODUCT
4742   {
4743     const char kind = (elem_size == 2) ? &#39;U&#39; : &#39;L&#39;;
4744     char comment[64];
4745     snprintf(comment, sizeof comment, &quot;{string_equals%c&quot;, kind);
4746     BLOCK_COMMENT(comment);
4747   }
4748 #endif
4749 
4750   mov(result, false);
4751 
4752   // Check for short strings, i.e. smaller than wordSize.
4753   subs(cnt1, cnt1, wordSize);
4754   br(Assembler::LT, SHORT);
4755   // Main 8 byte comparison loop.
4756   bind(NEXT_WORD); {
4757     ldr(tmp1, Address(post(a1, wordSize)));
4758     ldr(tmp2, Address(post(a2, wordSize)));
4759     subs(cnt1, cnt1, wordSize);
4760     eor(tmp1, tmp1, tmp2);
4761     cbnz(tmp1, DONE);
4762   } br(GT, NEXT_WORD);
4763   // Last longword.  In the case where length == 4 we compare the
4764   // same longword twice, but that&#39;s still faster than another
4765   // conditional branch.
4766   // cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when
4767   // length == 4.
4768   ldr(tmp1, Address(a1, cnt1));
4769   ldr(tmp2, Address(a2, cnt1));
4770   eor(tmp2, tmp1, tmp2);
4771   cbnz(tmp2, DONE);
4772   b(SAME);
4773 
4774   bind(SHORT);
4775   Label TAIL03, TAIL01;
4776 
4777   tbz(cnt1, 2, TAIL03); // 0-7 bytes left.
4778   {
4779     ldrw(tmp1, Address(post(a1, 4)));
4780     ldrw(tmp2, Address(post(a2, 4)));
4781     eorw(tmp1, tmp1, tmp2);
4782     cbnzw(tmp1, DONE);
4783   }
4784   bind(TAIL03);
4785   tbz(cnt1, 1, TAIL01); // 0-3 bytes left.
4786   {
4787     ldrh(tmp1, Address(post(a1, 2)));
4788     ldrh(tmp2, Address(post(a2, 2)));
4789     eorw(tmp1, tmp1, tmp2);
4790     cbnzw(tmp1, DONE);
4791   }
4792   bind(TAIL01);
4793   if (elem_size == 1) { // Only needed when comparing 1-byte elements
4794     tbz(cnt1, 0, SAME); // 0-1 bytes left.
4795     {
4796       ldrb(tmp1, a1);
4797       ldrb(tmp2, a2);
4798       eorw(tmp1, tmp1, tmp2);
4799       cbnzw(tmp1, DONE);
4800     }
4801   }
4802   // Arrays are equal.
4803   bind(SAME);
4804   mov(result, true);
4805 
4806   // That&#39;s it.
4807   bind(DONE);
4808   BLOCK_COMMENT(&quot;} string_equals&quot;);
4809 }
4810 
4811 
4812 // The size of the blocks erased by the zero_blocks stub.  We must
4813 // handle anything smaller than this ourselves in zero_words().
4814 const int MacroAssembler::zero_words_block_size = 8;
4815 
4816 // zero_words() is used by C2 ClearArray patterns.  It is as small as
4817 // possible, handling small word counts locally and delegating
4818 // anything larger to the zero_blocks stub.  It is expanded many times
4819 // in compiled code, so it is important to keep it short.
4820 
4821 // ptr:   Address of a buffer to be zeroed.
4822 // cnt:   Count in HeapWords.
4823 //
4824 // ptr, cnt, rscratch1, and rscratch2 are clobbered.
4825 void MacroAssembler::zero_words(Register ptr, Register cnt)
4826 {
4827   assert(is_power_of_2(zero_words_block_size), &quot;adjust this&quot;);
4828   assert(ptr == r10 &amp;&amp; cnt == r11, &quot;mismatch in register usage&quot;);
4829 
4830   BLOCK_COMMENT(&quot;zero_words {&quot;);
4831   cmp(cnt, (u1)zero_words_block_size);
4832   Label around;
4833   br(LO, around);
4834   {
4835     RuntimeAddress zero_blocks =  RuntimeAddress(StubRoutines::aarch64::zero_blocks());
4836     assert(zero_blocks.target() != NULL, &quot;zero_blocks stub has not been generated&quot;);
4837     if (StubRoutines::aarch64::complete()) {
4838       trampoline_call(zero_blocks);
4839     } else {
4840       bl(zero_blocks);
4841     }
4842   }
4843   bind(around);
4844   for (int i = zero_words_block_size &gt;&gt; 1; i &gt; 1; i &gt;&gt;= 1) {
4845     Label l;
4846     tbz(cnt, exact_log2(i), l);
4847     for (int j = 0; j &lt; i; j += 2) {
4848       stp(zr, zr, post(ptr, 16));
4849     }
4850     bind(l);
4851   }
4852   {
4853     Label l;
4854     tbz(cnt, 0, l);
4855     str(zr, Address(ptr));
4856     bind(l);
4857   }
4858   BLOCK_COMMENT(&quot;} zero_words&quot;);
4859 }
4860 
4861 // base:         Address of a buffer to be zeroed, 8 bytes aligned.
4862 // cnt:          Immediate count in HeapWords.
4863 #define SmallArraySize (18 * BytesPerLong)
4864 void MacroAssembler::zero_words(Register base, u_int64_t cnt)
4865 {
4866   BLOCK_COMMENT(&quot;zero_words {&quot;);
4867   int i = cnt &amp; 1;  // store any odd word to start
4868   if (i) str(zr, Address(base));
4869 
4870   if (cnt &lt;= SmallArraySize / BytesPerLong) {
4871     for (; i &lt; (int)cnt; i += 2)
4872       stp(zr, zr, Address(base, i * wordSize));
4873   } else {
4874     const int unroll = 4; // Number of stp(zr, zr) instructions we&#39;ll unroll
4875     int remainder = cnt % (2 * unroll);
4876     for (; i &lt; remainder; i += 2)
4877       stp(zr, zr, Address(base, i * wordSize));
4878 
4879     Label loop;
4880     Register cnt_reg = rscratch1;
4881     Register loop_base = rscratch2;
4882     cnt = cnt - remainder;
4883     mov(cnt_reg, cnt);
4884     // adjust base and prebias by -2 * wordSize so we can pre-increment
4885     add(loop_base, base, (remainder - 2) * wordSize);
4886     bind(loop);
4887     sub(cnt_reg, cnt_reg, 2 * unroll);
4888     for (i = 1; i &lt; unroll; i++)
4889       stp(zr, zr, Address(loop_base, 2 * i * wordSize));
4890     stp(zr, zr, Address(pre(loop_base, 2 * unroll * wordSize)));
4891     cbnz(cnt_reg, loop);
4892   }
4893   BLOCK_COMMENT(&quot;} zero_words&quot;);
4894 }
4895 
4896 // Zero blocks of memory by using DC ZVA.
4897 //
4898 // Aligns the base address first sufficently for DC ZVA, then uses
4899 // DC ZVA repeatedly for every full block.  cnt is the size to be
4900 // zeroed in HeapWords.  Returns the count of words left to be zeroed
4901 // in cnt.
4902 //
4903 // NOTE: This is intended to be used in the zero_blocks() stub.  If
4904 // you want to use it elsewhere, note that cnt must be &gt;= 2*zva_length.
4905 void MacroAssembler::zero_dcache_blocks(Register base, Register cnt) {
4906   Register tmp = rscratch1;
4907   Register tmp2 = rscratch2;
4908   int zva_length = VM_Version::zva_length();
4909   Label initial_table_end, loop_zva;
4910   Label fini;
4911 
4912   // Base must be 16 byte aligned. If not just return and let caller handle it
4913   tst(base, 0x0f);
4914   br(Assembler::NE, fini);
4915   // Align base with ZVA length.
4916   neg(tmp, base);
4917   andr(tmp, tmp, zva_length - 1);
4918 
4919   // tmp: the number of bytes to be filled to align the base with ZVA length.
4920   add(base, base, tmp);
4921   sub(cnt, cnt, tmp, Assembler::ASR, 3);
4922   adr(tmp2, initial_table_end);
4923   sub(tmp2, tmp2, tmp, Assembler::LSR, 2);
4924   br(tmp2);
4925 
4926   for (int i = -zva_length + 16; i &lt; 0; i += 16)
4927     stp(zr, zr, Address(base, i));
4928   bind(initial_table_end);
4929 
4930   sub(cnt, cnt, zva_length &gt;&gt; 3);
4931   bind(loop_zva);
4932   dc(Assembler::ZVA, base);
4933   subs(cnt, cnt, zva_length &gt;&gt; 3);
4934   add(base, base, zva_length);
4935   br(Assembler::GE, loop_zva);
4936   add(cnt, cnt, zva_length &gt;&gt; 3); // count not zeroed by DC ZVA
4937   bind(fini);
4938 }
4939 
4940 // base:   Address of a buffer to be filled, 8 bytes aligned.
4941 // cnt:    Count in 8-byte unit.
4942 // value:  Value to be filled with.
4943 // base will point to the end of the buffer after filling.
4944 void MacroAssembler::fill_words(Register base, Register cnt, Register value)
4945 {
4946 //  Algorithm:
4947 //
4948 //    scratch1 = cnt &amp; 7;
4949 //    cnt -= scratch1;
4950 //    p += scratch1;
4951 //    switch (scratch1) {
4952 //      do {
4953 //        cnt -= 8;
4954 //          p[-8] = v;
4955 //        case 7:
4956 //          p[-7] = v;
4957 //        case 6:
4958 //          p[-6] = v;
4959 //          // ...
4960 //        case 1:
4961 //          p[-1] = v;
4962 //        case 0:
4963 //          p += 8;
4964 //      } while (cnt);
4965 //    }
4966 
4967   assert_different_registers(base, cnt, value, rscratch1, rscratch2);
4968 
4969   Label fini, skip, entry, loop;
4970   const int unroll = 8; // Number of stp instructions we&#39;ll unroll
4971 
4972   cbz(cnt, fini);
4973   tbz(base, 3, skip);
4974   str(value, Address(post(base, 8)));
4975   sub(cnt, cnt, 1);
4976   bind(skip);
4977 
4978   andr(rscratch1, cnt, (unroll-1) * 2);
4979   sub(cnt, cnt, rscratch1);
4980   add(base, base, rscratch1, Assembler::LSL, 3);
4981   adr(rscratch2, entry);
4982   sub(rscratch2, rscratch2, rscratch1, Assembler::LSL, 1);
4983   br(rscratch2);
4984 
4985   bind(loop);
4986   add(base, base, unroll * 16);
4987   for (int i = -unroll; i &lt; 0; i++)
4988     stp(value, value, Address(base, i * 16));
4989   bind(entry);
4990   subs(cnt, cnt, unroll * 2);
4991   br(Assembler::GE, loop);
4992 
4993   tbz(cnt, 0, fini);
4994   str(value, Address(post(base, 8)));
4995   bind(fini);
4996 }
4997 
4998 // Intrinsic for sun/nio/cs/ISO_8859_1$Encoder.implEncodeISOArray and
4999 // java/lang/StringUTF16.compress.
5000 void MacroAssembler::encode_iso_array(Register src, Register dst,
5001                       Register len, Register result,
5002                       FloatRegister Vtmp1, FloatRegister Vtmp2,
5003                       FloatRegister Vtmp3, FloatRegister Vtmp4)
5004 {
5005     Label DONE, SET_RESULT, NEXT_32, NEXT_32_PRFM, LOOP_8, NEXT_8, LOOP_1, NEXT_1,
5006         NEXT_32_START, NEXT_32_PRFM_START;
5007     Register tmp1 = rscratch1, tmp2 = rscratch2;
5008 
5009       mov(result, len); // Save initial len
5010 
5011       cmp(len, (u1)8); // handle shortest strings first
5012       br(LT, LOOP_1);
5013       cmp(len, (u1)32);
5014       br(LT, NEXT_8);
5015       // The following code uses the SIMD &#39;uzp1&#39; and &#39;uzp2&#39; instructions
5016       // to convert chars to bytes
5017       if (SoftwarePrefetchHintDistance &gt;= 0) {
5018         ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
5019         subs(tmp2, len, SoftwarePrefetchHintDistance/2 + 16);
5020         br(LE, NEXT_32_START);
5021         b(NEXT_32_PRFM_START);
5022         BIND(NEXT_32_PRFM);
5023           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
5024         BIND(NEXT_32_PRFM_START);
5025           prfm(Address(src, SoftwarePrefetchHintDistance));
5026           orr(v4, T16B, Vtmp1, Vtmp2);
5027           orr(v5, T16B, Vtmp3, Vtmp4);
5028           uzp1(Vtmp1, T16B, Vtmp1, Vtmp2);
5029           uzp1(Vtmp3, T16B, Vtmp3, Vtmp4);
5030           uzp2(v5, T16B, v4, v5); // high bytes
5031           umov(tmp2, v5, D, 1);
5032           fmovd(tmp1, v5);
5033           orr(tmp1, tmp1, tmp2);
5034           cbnz(tmp1, LOOP_8);
5035           stpq(Vtmp1, Vtmp3, dst);
5036           sub(len, len, 32);
5037           add(dst, dst, 32);
5038           add(src, src, 64);
5039           subs(tmp2, len, SoftwarePrefetchHintDistance/2 + 16);
5040           br(GE, NEXT_32_PRFM);
5041           cmp(len, (u1)32);
5042           br(LT, LOOP_8);
5043         BIND(NEXT_32);
5044           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
5045         BIND(NEXT_32_START);
5046       } else {
5047         BIND(NEXT_32);
5048           ld1(Vtmp1, Vtmp2, Vtmp3, Vtmp4, T8H, src);
5049       }
5050       prfm(Address(src, SoftwarePrefetchHintDistance));
5051       uzp1(v4, T16B, Vtmp1, Vtmp2);
5052       uzp1(v5, T16B, Vtmp3, Vtmp4);
5053       orr(Vtmp1, T16B, Vtmp1, Vtmp2);
5054       orr(Vtmp3, T16B, Vtmp3, Vtmp4);
5055       uzp2(Vtmp1, T16B, Vtmp1, Vtmp3); // high bytes
5056       umov(tmp2, Vtmp1, D, 1);
5057       fmovd(tmp1, Vtmp1);
5058       orr(tmp1, tmp1, tmp2);
5059       cbnz(tmp1, LOOP_8);
5060       stpq(v4, v5, dst);
5061       sub(len, len, 32);
5062       add(dst, dst, 32);
5063       add(src, src, 64);
5064       cmp(len, (u1)32);
5065       br(GE, NEXT_32);
5066       cbz(len, DONE);
5067 
5068     BIND(LOOP_8);
5069       cmp(len, (u1)8);
5070       br(LT, LOOP_1);
5071     BIND(NEXT_8);
5072       ld1(Vtmp1, T8H, src);
5073       uzp1(Vtmp2, T16B, Vtmp1, Vtmp1); // low bytes
5074       uzp2(Vtmp3, T16B, Vtmp1, Vtmp1); // high bytes
5075       fmovd(tmp1, Vtmp3);
5076       cbnz(tmp1, NEXT_1);
5077       strd(Vtmp2, dst);
5078 
5079       sub(len, len, 8);
5080       add(dst, dst, 8);
5081       add(src, src, 16);
5082       cmp(len, (u1)8);
5083       br(GE, NEXT_8);
5084 
5085     BIND(LOOP_1);
5086 
5087     cbz(len, DONE);
5088     BIND(NEXT_1);
5089       ldrh(tmp1, Address(post(src, 2)));
5090       tst(tmp1, 0xff00);
5091       br(NE, SET_RESULT);
5092       strb(tmp1, Address(post(dst, 1)));
5093       subs(len, len, 1);
5094       br(GT, NEXT_1);
5095 
5096     BIND(SET_RESULT);
5097       sub(result, result, len); // Return index where we stopped
5098                                 // Return len == 0 if we processed all
5099                                 // characters
5100     BIND(DONE);
5101 }
5102 
5103 
5104 // Inflate byte[] array to char[].
5105 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
5106                                         FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,
5107                                         Register tmp4) {
5108   Label big, done, after_init, to_stub;
5109 
5110   assert_different_registers(src, dst, len, tmp4, rscratch1);
5111 
5112   fmovd(vtmp1, zr);
5113   lsrw(tmp4, len, 3);
5114   bind(after_init);
5115   cbnzw(tmp4, big);
5116   // Short string: less than 8 bytes.
5117   {
5118     Label loop, tiny;
5119 
5120     cmpw(len, 4);
5121     br(LT, tiny);
5122     // Use SIMD to do 4 bytes.
5123     ldrs(vtmp2, post(src, 4));
5124     zip1(vtmp3, T8B, vtmp2, vtmp1);
5125     subw(len, len, 4);
5126     strd(vtmp3, post(dst, 8));
5127 
5128     cbzw(len, done);
5129 
5130     // Do the remaining bytes by steam.
5131     bind(loop);
5132     ldrb(tmp4, post(src, 1));
5133     strh(tmp4, post(dst, 2));
5134     subw(len, len, 1);
5135 
5136     bind(tiny);
5137     cbnz(len, loop);
5138 
5139     b(done);
5140   }
5141 
5142   if (SoftwarePrefetchHintDistance &gt;= 0) {
5143     bind(to_stub);
5144       RuntimeAddress stub =  RuntimeAddress(StubRoutines::aarch64::large_byte_array_inflate());
5145       assert(stub.target() != NULL, &quot;large_byte_array_inflate stub has not been generated&quot;);
5146       trampoline_call(stub);
5147       b(after_init);
5148   }
5149 
5150   // Unpack the bytes 8 at a time.
5151   bind(big);
5152   {
5153     Label loop, around, loop_last, loop_start;
5154 
5155     if (SoftwarePrefetchHintDistance &gt;= 0) {
5156       const int large_loop_threshold = (64 + 16)/8;
5157       ldrd(vtmp2, post(src, 8));
5158       andw(len, len, 7);
5159       cmp(tmp4, (u1)large_loop_threshold);
5160       br(GE, to_stub);
5161       b(loop_start);
5162 
5163       bind(loop);
5164       ldrd(vtmp2, post(src, 8));
5165       bind(loop_start);
5166       subs(tmp4, tmp4, 1);
5167       br(EQ, loop_last);
5168       zip1(vtmp2, T16B, vtmp2, vtmp1);
5169       ldrd(vtmp3, post(src, 8));
5170       st1(vtmp2, T8H, post(dst, 16));
5171       subs(tmp4, tmp4, 1);
5172       zip1(vtmp3, T16B, vtmp3, vtmp1);
5173       st1(vtmp3, T8H, post(dst, 16));
5174       br(NE, loop);
5175       b(around);
5176       bind(loop_last);
5177       zip1(vtmp2, T16B, vtmp2, vtmp1);
5178       st1(vtmp2, T8H, post(dst, 16));
5179       bind(around);
5180       cbz(len, done);
5181     } else {
5182       andw(len, len, 7);
5183       bind(loop);
5184       ldrd(vtmp2, post(src, 8));
5185       sub(tmp4, tmp4, 1);
5186       zip1(vtmp3, T16B, vtmp2, vtmp1);
5187       st1(vtmp3, T8H, post(dst, 16));
5188       cbnz(tmp4, loop);
5189     }
5190   }
5191 
5192   // Do the tail of up to 8 bytes.
5193   add(src, src, len);
5194   ldrd(vtmp3, Address(src, -8));
5195   add(dst, dst, len, ext::uxtw, 1);
5196   zip1(vtmp3, T16B, vtmp3, vtmp1);
5197   strq(vtmp3, Address(dst, -16));
5198 
5199   bind(done);
5200 }
5201 
5202 // Compress char[] array to byte[].
5203 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
5204                                          FloatRegister tmp1Reg, FloatRegister tmp2Reg,
5205                                          FloatRegister tmp3Reg, FloatRegister tmp4Reg,
5206                                          Register result) {
5207   encode_iso_array(src, dst, len, result,
5208                    tmp1Reg, tmp2Reg, tmp3Reg, tmp4Reg);
5209   cmp(len, zr);
5210   csel(result, result, zr, EQ);
5211 }
5212 
5213 // get_thread() can be called anywhere inside generated code so we
5214 // need to save whatever non-callee save context might get clobbered
5215 // by the call to JavaThread::aarch64_get_thread_helper() or, indeed,
5216 // the call setup code.
5217 //
5218 // aarch64_get_thread_helper() clobbers only r0, r1, and flags.
5219 //
5220 void MacroAssembler::get_thread(Register dst) {
5221   RegSet saved_regs = RegSet::range(r0, r1) + lr - dst;
5222   push(saved_regs, sp);
5223 
5224   mov(lr, CAST_FROM_FN_PTR(address, JavaThread::aarch64_get_thread_helper));
5225   blr(lr);
5226   if (dst != c_rarg0) {
5227     mov(dst, c_rarg0);
5228   }
5229 
5230   pop(saved_regs, sp);
5231 }
5232 
<a name="15" id="anc15"></a><span class="line-added">5233 // C2 compiled method&#39;s prolog code</span>
<span class="line-added">5234 // Moved here from aarch64.ad to support Valhalla code belows</span>
<span class="line-added">5235 void MacroAssembler::verified_entry(Compile* C, int sp_inc) {</span>
<span class="line-added">5236 </span>
<span class="line-added">5237 // n.b. frame size includes space for return pc and rfp</span>
<span class="line-added">5238   const long framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-added">5239   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2 * wordSize alignment&quot;);</span>
<span class="line-added">5240 </span>
<span class="line-added">5241   // insert a nop at the start of the prolog so we can patch in a</span>
<span class="line-added">5242   // branch if we need to invalidate the method later</span>
<span class="line-added">5243   nop();</span>
<span class="line-added">5244 </span>
<span class="line-added">5245   int bangsize = C-&gt;bang_size_in_bytes();</span>
<span class="line-added">5246   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging)</span>
<span class="line-added">5247      generate_stack_overflow_check(bangsize);</span>
<span class="line-added">5248 </span>
<span class="line-added">5249   build_frame(framesize);</span>
<span class="line-added">5250 </span>
<span class="line-added">5251   if (VerifyStackAtCalls) {</span>
<span class="line-added">5252     Unimplemented();</span>
<span class="line-added">5253   }</span>
<span class="line-added">5254 }</span>
<span class="line-added">5255 </span>
<span class="line-added">5256 int MacroAssembler::store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {</span>
<span class="line-added">5257   // A value type might be returned. If fields are in registers we</span>
<span class="line-added">5258   // need to allocate a value type instance and initialize it with</span>
<span class="line-added">5259   // the value of the fields.</span>
<span class="line-added">5260   Label skip;</span>
<span class="line-added">5261   // We only need a new buffered value if a new one is not returned</span>
<span class="line-added">5262   cmp(r0, (u1) 1);</span>
<span class="line-added">5263   br(Assembler::EQ, skip);</span>
<span class="line-added">5264   int call_offset = -1;</span>
<span class="line-added">5265 </span>
<span class="line-added">5266   Label slow_case;</span>
<span class="line-added">5267 </span>
<span class="line-added">5268   // Try to allocate a new buffered value (from the heap)</span>
<span class="line-added">5269   if (UseTLAB) {</span>
<span class="line-added">5270 </span>
<span class="line-added">5271     if (vk != NULL) {</span>
<span class="line-added">5272       // Called from C1, where the return type is statically known.</span>
<span class="line-added">5273       mov(r1, (intptr_t)vk-&gt;get_ValueKlass());</span>
<span class="line-added">5274       jint lh = vk-&gt;layout_helper();</span>
<span class="line-added">5275       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);</span>
<span class="line-added">5276       mov(r14, lh);</span>
<span class="line-added">5277     } else {</span>
<span class="line-added">5278        // Call from interpreter. R0 contains ((the ValueKlass* of the return type) | 0x01)</span>
<span class="line-added">5279        andr(r1, r0, -2);</span>
<span class="line-added">5280        // get obj size</span>
<span class="line-added">5281        ldrw(r14, Address(rscratch1 /*klass*/, Klass::layout_helper_offset()));</span>
<span class="line-added">5282     }</span>
<span class="line-added">5283 </span>
<span class="line-added">5284      ldr(r13, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));</span>
<span class="line-added">5285 </span>
<span class="line-added">5286      // check whether we have space in TLAB,</span>
<span class="line-added">5287      // rscratch1 contains pointer to just allocated obj</span>
<span class="line-added">5288       lea(r14, Address(r13, r14));</span>
<span class="line-added">5289       ldr(rscratch1, Address(rthread, in_bytes(JavaThread::tlab_end_offset())));</span>
<span class="line-added">5290 </span>
<span class="line-added">5291       cmp(r14, rscratch1);</span>
<span class="line-added">5292       br(Assembler::GT, slow_case);</span>
<span class="line-added">5293 </span>
<span class="line-added">5294       // OK we have room in TLAB,</span>
<span class="line-added">5295       // Set new TLAB top</span>
<span class="line-added">5296       str(r14, Address(rthread, in_bytes(JavaThread::tlab_top_offset())));</span>
<span class="line-added">5297 </span>
<span class="line-added">5298       // Set new class always locked</span>
<span class="line-added">5299       mov(rscratch1, (uint64_t) markWord::always_locked_prototype().value());</span>
<span class="line-added">5300       str(rscratch1, Address(r13, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-added">5301 </span>
<span class="line-added">5302       store_klass_gap(r13, zr);  // zero klass gap for compressed oops</span>
<span class="line-added">5303       if (vk == NULL) {</span>
<span class="line-added">5304         // store_klass corrupts rbx, so save it in rax for later use (interpreter case only).</span>
<span class="line-added">5305          mov(r0, r1);</span>
<span class="line-added">5306       }</span>
<span class="line-added">5307 </span>
<span class="line-added">5308       store_klass(r13, r1);  // klass</span>
<span class="line-added">5309 </span>
<span class="line-added">5310       if (vk != NULL) {</span>
<span class="line-added">5311         // FIXME -- do the packing in-line to avoid the runtime call</span>
<span class="line-added">5312         mov(r0, r13);</span>
<span class="line-added">5313         far_call(RuntimeAddress(vk-&gt;pack_handler())); // no need for call info as this will not safepoint.</span>
<span class="line-added">5314       } else {</span>
<span class="line-added">5315 </span>
<span class="line-added">5316         // We have our new buffered value, initialize its fields with a</span>
<span class="line-added">5317         // value class specific handler</span>
<span class="line-added">5318         ldr(r1, Address(r0, InstanceKlass::adr_valueklass_fixed_block_offset()));</span>
<span class="line-added">5319         ldr(r1, Address(r1, ValueKlass::pack_handler_offset()));</span>
<span class="line-added">5320 </span>
<span class="line-added">5321         // Mov new class to r0 and call pack_handler</span>
<span class="line-added">5322         mov(r0, r13);</span>
<span class="line-added">5323         blr(r1);</span>
<span class="line-added">5324       }</span>
<span class="line-added">5325       b(skip);</span>
<span class="line-added">5326   }</span>
<span class="line-added">5327 </span>
<span class="line-added">5328   bind(slow_case);</span>
<span class="line-added">5329   // We failed to allocate a new value, fall back to a runtime</span>
<span class="line-added">5330   // call. Some oop field may be live in some registers but we can&#39;t</span>
<span class="line-added">5331   // tell. That runtime call will take care of preserving them</span>
<span class="line-added">5332   // across a GC if there&#39;s one.</span>
<span class="line-added">5333 </span>
<span class="line-added">5334 </span>
<span class="line-added">5335   if (from_interpreter) {</span>
<span class="line-added">5336     super_call_VM_leaf(StubRoutines::store_value_type_fields_to_buf());</span>
<span class="line-added">5337   } else {</span>
<span class="line-added">5338     ldr(rscratch1, RuntimeAddress(StubRoutines::store_value_type_fields_to_buf()));</span>
<span class="line-added">5339     blr(rscratch1);</span>
<span class="line-added">5340     call_offset = offset();</span>
<span class="line-added">5341   }</span>
<span class="line-added">5342 </span>
<span class="line-added">5343   bind(skip);</span>
<span class="line-added">5344   return call_offset;</span>
<span class="line-added">5345 }</span>
<span class="line-added">5346 </span>
<span class="line-added">5347 // Move a value between registers/stack slots and update the reg_state</span>
<span class="line-added">5348 bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {</span>
<span class="line-added">5349   if (reg_state[to-&gt;value()] == reg_written) {</span>
<span class="line-added">5350     return true; // Already written</span>
<span class="line-added">5351   }</span>
<span class="line-added">5352 </span>
<span class="line-added">5353   if (from != to &amp;&amp; bt != T_VOID) {</span>
<span class="line-added">5354     if (reg_state[to-&gt;value()] == reg_readonly) {</span>
<span class="line-added">5355       return false; // Not yet writable</span>
<span class="line-added">5356     }</span>
<span class="line-added">5357     if (from-&gt;is_reg()) {</span>
<span class="line-added">5358       if (to-&gt;is_reg()) {</span>
<span class="line-added">5359         mov(to-&gt;as_Register(), from-&gt;as_Register());</span>
<span class="line-added">5360       } else {</span>
<span class="line-added">5361         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="line-added">5362         Address to_addr = Address(sp, st_off);</span>
<span class="line-added">5363         if (from-&gt;is_FloatRegister()) {</span>
<span class="line-added">5364           if (bt == T_DOUBLE) {</span>
<span class="line-added">5365              strd(from-&gt;as_FloatRegister(), to_addr);</span>
<span class="line-added">5366           } else {</span>
<span class="line-added">5367              assert(bt == T_FLOAT, &quot;must be float&quot;);</span>
<span class="line-added">5368              strs(from-&gt;as_FloatRegister(), to_addr);</span>
<span class="line-added">5369           }</span>
<span class="line-added">5370         } else {</span>
<span class="line-added">5371           str(from-&gt;as_Register(), to_addr);</span>
<span class="line-added">5372         }</span>
<span class="line-added">5373       }</span>
<span class="line-added">5374     } else {</span>
<span class="line-added">5375       Address from_addr = Address(sp, from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset);</span>
<span class="line-added">5376       if (to-&gt;is_reg()) {</span>
<span class="line-added">5377         if (to-&gt;is_FloatRegister()) {</span>
<span class="line-added">5378           if (bt == T_DOUBLE) {</span>
<span class="line-added">5379              ldrd(to-&gt;as_FloatRegister(), from_addr);</span>
<span class="line-added">5380           } else {</span>
<span class="line-added">5381             assert(bt == T_FLOAT, &quot;must be float&quot;);</span>
<span class="line-added">5382             ldrs(to-&gt;as_FloatRegister(), from_addr);</span>
<span class="line-added">5383           }</span>
<span class="line-added">5384         } else {</span>
<span class="line-added">5385           ldr(to-&gt;as_Register(), from_addr);</span>
<span class="line-added">5386         }</span>
<span class="line-added">5387       } else {</span>
<span class="line-added">5388         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="line-added">5389         ldr(rscratch1, from_addr);</span>
<span class="line-added">5390         str(rscratch1, Address(sp, st_off));</span>
<span class="line-added">5391       }</span>
<span class="line-added">5392     }</span>
<span class="line-added">5393   }</span>
<span class="line-added">5394 </span>
<span class="line-added">5395   // Update register states</span>
<span class="line-added">5396   reg_state[from-&gt;value()] = reg_writable;</span>
<span class="line-added">5397   reg_state[to-&gt;value()] = reg_written;</span>
<span class="line-added">5398   return true;</span>
<span class="line-added">5399 }</span>
<span class="line-added">5400 </span>
<span class="line-added">5401 // Read all fields from a value type oop and store the values in registers/stack slots</span>
<span class="line-added">5402 bool MacroAssembler::unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to,</span>
<span class="line-added">5403                                          int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {</span>
<span class="line-added">5404   Register fromReg = from-&gt;is_reg() ? from-&gt;as_Register() : noreg;</span>
<span class="line-added">5405   assert(sig-&gt;at(sig_index)._bt == T_VOID, &quot;should be at end delimiter&quot;);</span>
<span class="line-added">5406 </span>
<span class="line-added">5407 </span>
<span class="line-added">5408   int vt = 1;</span>
<span class="line-added">5409   bool done = true;</span>
<span class="line-added">5410   bool mark_done = true;</span>
<span class="line-added">5411   do {</span>
<span class="line-added">5412     sig_index--;</span>
<span class="line-added">5413     BasicType bt = sig-&gt;at(sig_index)._bt;</span>
<span class="line-added">5414     if (bt == T_VALUETYPE) {</span>
<span class="line-added">5415       vt--;</span>
<span class="line-added">5416     } else if (bt == T_VOID &amp;&amp;</span>
<span class="line-added">5417                sig-&gt;at(sig_index-1)._bt != T_LONG &amp;&amp;</span>
<span class="line-added">5418                sig-&gt;at(sig_index-1)._bt != T_DOUBLE) {</span>
<span class="line-added">5419       vt++;</span>
<span class="line-added">5420     } else if (SigEntry::is_reserved_entry(sig, sig_index)) {</span>
<span class="line-added">5421       to_index--; // Ignore this</span>
<span class="line-added">5422     } else {</span>
<span class="line-added">5423       assert(to_index &gt;= 0, &quot;invalid to_index&quot;);</span>
<span class="line-added">5424       VMRegPair pair_to = regs_to[to_index--];</span>
<span class="line-added">5425       VMReg to = pair_to.first();</span>
<span class="line-added">5426 </span>
<span class="line-added">5427       if (bt == T_VOID) continue;</span>
<span class="line-added">5428 </span>
<span class="line-added">5429       int idx = (int) to-&gt;value();</span>
<span class="line-added">5430       if (reg_state[idx] == reg_readonly) {</span>
<span class="line-added">5431          if (idx != from-&gt;value()) {</span>
<span class="line-added">5432            mark_done = false;</span>
<span class="line-added">5433          }</span>
<span class="line-added">5434          done = false;</span>
<span class="line-added">5435          continue;</span>
<span class="line-added">5436       } else if (reg_state[idx] == reg_written) {</span>
<span class="line-added">5437         continue;</span>
<span class="line-added">5438       } else {</span>
<span class="line-added">5439         assert(reg_state[idx] == reg_writable, &quot;must be writable&quot;);</span>
<span class="line-added">5440         reg_state[idx] = reg_written;</span>
<span class="line-added">5441       }</span>
<span class="line-added">5442 </span>
<span class="line-added">5443       if (fromReg == noreg) {</span>
<span class="line-added">5444         int st_off = from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="line-added">5445         ldr(rscratch2, Address(sp, st_off));</span>
<span class="line-added">5446         fromReg = rscratch2;</span>
<span class="line-added">5447       }</span>
<span class="line-added">5448 </span>
<span class="line-added">5449       int off = sig-&gt;at(sig_index)._offset;</span>
<span class="line-added">5450       assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="line-added">5451       bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);</span>
<span class="line-added">5452 </span>
<span class="line-added">5453       Address fromAddr = Address(fromReg, off);</span>
<span class="line-added">5454       bool is_signed = (bt != T_CHAR) &amp;&amp; (bt != T_BOOLEAN);</span>
<span class="line-added">5455 </span>
<span class="line-added">5456       if (!to-&gt;is_FloatRegister()) {</span>
<span class="line-added">5457 </span>
<span class="line-added">5458         Register dst = to-&gt;is_stack() ? rscratch1 : to-&gt;as_Register();</span>
<span class="line-added">5459 </span>
<span class="line-added">5460         if (is_oop) {</span>
<span class="line-added">5461           load_heap_oop(dst, fromAddr);</span>
<span class="line-added">5462         } else {</span>
<span class="line-added">5463           load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);</span>
<span class="line-added">5464         }</span>
<span class="line-added">5465         if (to-&gt;is_stack()) {</span>
<span class="line-added">5466           int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="line-added">5467           str(dst, Address(sp, st_off));</span>
<span class="line-added">5468         }</span>
<span class="line-added">5469       } else {</span>
<span class="line-added">5470         if (bt == T_DOUBLE) {</span>
<span class="line-added">5471           ldrd(to-&gt;as_FloatRegister(), fromAddr);</span>
<span class="line-added">5472         } else {</span>
<span class="line-added">5473           assert(bt == T_FLOAT, &quot;must be float&quot;);</span>
<span class="line-added">5474           ldrs(to-&gt;as_FloatRegister(), fromAddr);</span>
<span class="line-added">5475         }</span>
<span class="line-added">5476      }</span>
<span class="line-added">5477 </span>
<span class="line-added">5478     }</span>
<span class="line-added">5479 </span>
<span class="line-added">5480   } while (vt != 0);</span>
<span class="line-added">5481 </span>
<span class="line-added">5482   if (mark_done &amp;&amp; reg_state[from-&gt;value()] != reg_written) {</span>
<span class="line-added">5483     // This is okay because no one else will write to that slot</span>
<span class="line-added">5484     reg_state[from-&gt;value()] = reg_writable;</span>
<span class="line-added">5485   }</span>
<span class="line-added">5486   return done;</span>
<span class="line-added">5487 }</span>
<span class="line-added">5488 </span>
<span class="line-added">5489 // Pack fields back into a value type oop</span>
<span class="line-added">5490 bool MacroAssembler::pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,</span>
<span class="line-added">5491                                        VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="line-added">5492                                        int ret_off, int extra_stack_offset) {</span>
<span class="line-added">5493   assert(sig-&gt;at(sig_index)._bt == T_VALUETYPE, &quot;should be at end delimiter&quot;);</span>
<span class="line-added">5494   assert(to-&gt;is_valid(), &quot;must be&quot;);</span>
<span class="line-added">5495 </span>
<span class="line-added">5496   if (reg_state[to-&gt;value()] == reg_written) {</span>
<span class="line-added">5497     skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);</span>
<span class="line-added">5498     return true; // Already written</span>
<span class="line-added">5499   }</span>
<span class="line-added">5500 </span>
<span class="line-added">5501   Register val_array = r0;</span>
<span class="line-added">5502   Register val_obj_tmp = r11;</span>
<span class="line-added">5503   Register from_reg_tmp = r10;</span>
<span class="line-added">5504   Register tmp1 = r14;</span>
<span class="line-added">5505   Register tmp2 = r13;</span>
<span class="line-added">5506   Register tmp3 = r1;</span>
<span class="line-added">5507   Register val_obj = to-&gt;is_stack() ? val_obj_tmp : to-&gt;as_Register();</span>
<span class="line-added">5508 </span>
<span class="line-added">5509   if (reg_state[to-&gt;value()] == reg_readonly) {</span>
<span class="line-added">5510     if (!is_reg_in_unpacked_fields(sig, sig_index, to, regs_from, regs_from_count, from_index)) {</span>
<span class="line-added">5511       skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);</span>
<span class="line-added">5512       return false; // Not yet writable</span>
<span class="line-added">5513     }</span>
<span class="line-added">5514     val_obj = val_obj_tmp;</span>
<span class="line-added">5515   }</span>
<span class="line-added">5516 </span>
<span class="line-added">5517   int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_VALUETYPE);</span>
<span class="line-added">5518   load_heap_oop(val_obj, Address(val_array, index));</span>
<span class="line-added">5519 </span>
<span class="line-added">5520   ScalarizedValueArgsStream stream(sig, sig_index, regs_from, regs_from_count, from_index);</span>
<span class="line-added">5521   VMRegPair from_pair;</span>
<span class="line-added">5522   BasicType bt;</span>
<span class="line-added">5523 </span>
<span class="line-added">5524   while (stream.next(from_pair, bt)) {</span>
<span class="line-added">5525     int off = sig-&gt;at(stream.sig_cc_index())._offset;</span>
<span class="line-added">5526     assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="line-added">5527     bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);</span>
<span class="line-added">5528     size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;</span>
<span class="line-added">5529 </span>
<span class="line-added">5530     VMReg from_r1 = from_pair.first();</span>
<span class="line-added">5531     VMReg from_r2 = from_pair.second();</span>
<span class="line-added">5532 </span>
<span class="line-added">5533     // Pack the scalarized field into the value object.</span>
<span class="line-added">5534     Address dst(val_obj, off);</span>
<span class="line-added">5535 </span>
<span class="line-added">5536     if (!from_r1-&gt;is_FloatRegister()) {</span>
<span class="line-added">5537       Register from_reg;</span>
<span class="line-added">5538       if (from_r1-&gt;is_stack()) {</span>
<span class="line-added">5539         from_reg = from_reg_tmp;</span>
<span class="line-added">5540         int ld_off = from_r1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="line-added">5541         load_sized_value(from_reg, Address(sp, ld_off), size_in_bytes, /* is_signed */ false);</span>
<span class="line-added">5542       } else {</span>
<span class="line-added">5543         from_reg = from_r1-&gt;as_Register();</span>
<span class="line-added">5544       }</span>
<span class="line-added">5545 </span>
<span class="line-added">5546       if (is_oop) {</span>
<span class="line-added">5547         DecoratorSet decorators = IN_HEAP | ACCESS_WRITE;</span>
<span class="line-added">5548         store_heap_oop(dst, from_reg, tmp1, tmp2, tmp3, decorators);</span>
<span class="line-added">5549       } else {</span>
<span class="line-added">5550         store_sized_value(dst, from_reg, size_in_bytes);</span>
<span class="line-added">5551       }</span>
<span class="line-added">5552     } else {</span>
<span class="line-added">5553       if (from_r2-&gt;is_valid()) {</span>
<span class="line-added">5554         strd(from_r1-&gt;as_FloatRegister(), dst);</span>
<span class="line-added">5555       } else {</span>
<span class="line-added">5556         strs(from_r1-&gt;as_FloatRegister(), dst);</span>
<span class="line-added">5557       }</span>
<span class="line-added">5558     }</span>
<span class="line-added">5559 </span>
<span class="line-added">5560     reg_state[from_r1-&gt;value()] = reg_writable;</span>
<span class="line-added">5561   }</span>
<span class="line-added">5562   sig_index = stream.sig_cc_index();</span>
<span class="line-added">5563   from_index = stream.regs_cc_index();</span>
<span class="line-added">5564 </span>
<span class="line-added">5565   assert(reg_state[to-&gt;value()] == reg_writable, &quot;must have already been read&quot;);</span>
<span class="line-added">5566   bool success = move_helper(val_obj-&gt;as_VMReg(), to, T_OBJECT, reg_state, ret_off, extra_stack_offset);</span>
<span class="line-added">5567   assert(success, &quot;to register must be writeable&quot;);</span>
<span class="line-added">5568 </span>
<span class="line-added">5569   return true;</span>
<span class="line-added">5570 }</span>
<span class="line-added">5571 </span>
<span class="line-added">5572 // Unpack all value type arguments passed as oops</span>
<span class="line-added">5573 void MacroAssembler::unpack_value_args(Compile* C, bool receiver_only) {</span>
<span class="line-added">5574   int sp_inc = unpack_value_args_common(C, receiver_only);</span>
<span class="line-added">5575   // Emit code for verified entry and save increment for stack repair on return</span>
<span class="line-added">5576   verified_entry(C, sp_inc);</span>
<span class="line-added">5577 }</span>
<span class="line-added">5578 </span>
<span class="line-added">5579 int MacroAssembler::shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,</span>
<span class="line-added">5580                                        BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-added">5581                                        int args_passed, int args_on_stack, VMRegPair* regs,            // from</span>
<span class="line-added">5582                                        int args_passed_to, int args_on_stack_to, VMRegPair* regs_to) { // to</span>
<span class="line-added">5583   // Check if we need to extend the stack for packing/unpacking</span>
<span class="line-added">5584   int sp_inc = (args_on_stack_to - args_on_stack) * VMRegImpl::stack_slot_size;</span>
<span class="line-added">5585   if (sp_inc &gt; 0) {</span>
<span class="line-added">5586     sp_inc = align_up(sp_inc, StackAlignmentInBytes);</span>
<span class="line-added">5587     if (!is_packing) {</span>
<span class="line-added">5588       // Save the return address, adjust the stack (make sure it is properly</span>
<span class="line-added">5589       // 16-byte aligned) and copy the return address to the new top of the stack.</span>
<span class="line-added">5590       // (Note: C1 does this in C1_MacroAssembler::scalarized_entry).</span>
<span class="line-added">5591       // FIXME: We need not to preserve return address on aarch64</span>
<span class="line-added">5592       pop(rscratch1);</span>
<span class="line-added">5593       sub(sp, sp, sp_inc);</span>
<span class="line-added">5594       push(rscratch1);</span>
<span class="line-added">5595     }</span>
<span class="line-added">5596   } else {</span>
<span class="line-added">5597     // The scalarized calling convention needs less stack space than the unscalarized one.</span>
<span class="line-added">5598     // No need to extend the stack, the caller will take care of these adjustments.</span>
<span class="line-added">5599     sp_inc = 0;</span>
<span class="line-added">5600   }</span>
<span class="line-added">5601 </span>
<span class="line-added">5602   int ret_off; // make sure we don&#39;t overwrite the return address</span>
<span class="line-added">5603   if (is_packing) {</span>
<span class="line-added">5604     // For C1 code, the VVEP doesn&#39;t have reserved slots, so we store the returned address at</span>
<span class="line-added">5605     // rsp[0] during shuffling.</span>
<span class="line-added">5606     ret_off = 0;</span>
<span class="line-added">5607   } else {</span>
<span class="line-added">5608     // C2 code ensures that sp_inc is a reserved slot.</span>
<span class="line-added">5609     ret_off = sp_inc;</span>
<span class="line-added">5610   }</span>
<span class="line-added">5611 </span>
<span class="line-added">5612   return shuffle_value_args_common(is_packing, receiver_only, extra_stack_offset,</span>
<span class="line-added">5613                                    sig_bt, sig_cc,</span>
<span class="line-added">5614                                    args_passed, args_on_stack, regs,</span>
<span class="line-added">5615                                    args_passed_to, args_on_stack_to, regs_to,</span>
<span class="line-added">5616                                    sp_inc, ret_off);</span>
<span class="line-added">5617 }</span>
<span class="line-added">5618 </span>
<span class="line-added">5619 VMReg MacroAssembler::spill_reg_for(VMReg reg) {</span>
<span class="line-added">5620   return (reg-&gt;is_FloatRegister()) ? v0-&gt;as_VMReg() : r14-&gt;as_VMReg();</span>
<span class="line-added">5621 }</span>
<span class="line-added">5622 </span>
5623 void MacroAssembler::cache_wb(Address line) {
5624   assert(line.getMode() == Address::base_plus_offset, &quot;mode should be base_plus_offset&quot;);
5625   assert(line.index() == noreg, &quot;index should be noreg&quot;);
5626   assert(line.offset() == 0, &quot;offset should be 0&quot;);
5627   // would like to assert this
5628   // assert(line._ext.shift == 0, &quot;shift should be zero&quot;);
5629   if (VM_Version::supports_dcpop()) {
5630     // writeback using clear virtual address to point of persistence
5631     dc(Assembler::CVAP, line.base());
5632   } else {
5633     // no need to generate anything as Unsafe.writebackMemory should
5634     // never invoke this stub
5635   }
5636 }
5637 
5638 void MacroAssembler::cache_wbsync(bool is_pre) {
5639   // we only need a barrier post sync
5640   if (!is_pre) {
5641     membar(Assembler::AnyAny);
5642   }
5643 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
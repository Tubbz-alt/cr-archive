<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/jvmci/jvmciCodeInstaller.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;code/compiledIC.hpp&quot;
  26 #include &quot;compiler/compileBroker.hpp&quot;
  27 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  28 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  29 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  30 #include &quot;memory/universe.hpp&quot;
  31 #include &quot;oops/compressedOops.inline.hpp&quot;
  32 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  33 #include &quot;runtime/jniHandles.inline.hpp&quot;
  34 #include &quot;runtime/sharedRuntime.hpp&quot;
  35 #include &quot;utilities/align.hpp&quot;
  36 
  37 // frequently used constants
  38 // Allocate them with new so they are never destroyed (otherwise, a
  39 // forced exit could destroy these objects while they are still in
  40 // use).
  41 ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantOopWriteValue(NULL);
  42 ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(-1);
  43 ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue((jint)0);
  44 ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(1);
  45 ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(2);
  46 LocationValue*         CodeInstaller::_illegal_value = new (ResourceObj::C_HEAP, mtJVMCI) LocationValue(Location());
  47 MarkerValue*           CodeInstaller::_virtual_byte_array_marker = new (ResourceObj::C_HEAP, mtJVMCI) MarkerValue();
  48 
  49 VMReg CodeInstaller::getVMRegFromLocation(JVMCIObject location, int total_frame_size, JVMCI_TRAPS) {
  50   if (location.is_null()) {
  51     JVMCI_THROW_NULL(NullPointerException);
  52   }
  53 
  54   JVMCIObject reg = jvmci_env()-&gt;get_code_Location_reg(location);
  55   jint offset = jvmci_env()-&gt;get_code_Location_offset(location);
  56 
  57   if (reg.is_non_null()) {
  58     // register
  59     jint number = jvmci_env()-&gt;get_code_Register_number(reg);
  60     VMReg vmReg = CodeInstaller::get_hotspot_reg(number, JVMCI_CHECK_NULL);
  61     if (offset % 4 == 0) {
  62       return vmReg-&gt;next(offset / 4);
  63     } else {
  64       JVMCI_ERROR_NULL(&quot;unaligned subregister offset %d in oop map&quot;, offset);
  65     }
  66   } else {
  67     // stack slot
  68     if (offset % 4 == 0) {
  69       VMReg vmReg = VMRegImpl::stack2reg(offset / 4);
  70       if (!OopMapValue::legal_vm_reg_name(vmReg)) {
  71         // This restriction only applies to VMRegs that are used in OopMap but
  72         // since that&#39;s the only use of VMRegs it&#39;s simplest to put this test
  73         // here.  This test should also be equivalent legal_vm_reg_name but JVMCI
  74         // clients can use max_oop_map_stack_stack_offset to detect this problem
  75         // directly.  The asserts just ensure that the tests are in agreement.
  76         assert(offset &gt; CompilerToVM::Data::max_oop_map_stack_offset(), &quot;illegal VMReg&quot;);
  77         JVMCI_ERROR_NULL(&quot;stack offset %d is too large to be encoded in OopMap (max %d)&quot;,
  78                          offset, CompilerToVM::Data::max_oop_map_stack_offset());
  79       }
  80       assert(OopMapValue::legal_vm_reg_name(vmReg), &quot;illegal VMReg&quot;);
  81       return vmReg;
  82     } else {
  83       JVMCI_ERROR_NULL(&quot;unaligned stack offset %d in oop map&quot;, offset);
  84     }
  85   }
  86 }
  87 
  88 // creates a HotSpot oop map out of the byte arrays provided by DebugInfo
  89 OopMap* CodeInstaller::create_oop_map(JVMCIObject debug_info, JVMCI_TRAPS) {
  90   JVMCIObject reference_map = jvmci_env()-&gt;get_DebugInfo_referenceMap(debug_info);
  91   if (reference_map.is_null()) {
  92     JVMCI_THROW_NULL(NullPointerException);
  93   }
  94   if (!jvmci_env()-&gt;isa_HotSpotReferenceMap(reference_map)) {
  95     JVMCI_ERROR_NULL(&quot;unknown reference map: %s&quot;, jvmci_env()-&gt;klass_name(reference_map));
  96   }
  97   if (!_has_wide_vector &amp;&amp; SharedRuntime::is_wide_vector(jvmci_env()-&gt;get_HotSpotReferenceMap_maxRegisterSize(reference_map))) {
  98     if (SharedRuntime::polling_page_vectors_safepoint_handler_blob() == NULL) {
  99       JVMCI_ERROR_NULL(&quot;JVMCI is producing code using vectors larger than the runtime supports&quot;);
 100     }
 101     _has_wide_vector = true;
 102   }
 103   OopMap* map = new OopMap(_total_frame_size, _parameter_count);
 104   JVMCIObjectArray objects = jvmci_env()-&gt;get_HotSpotReferenceMap_objects(reference_map);
 105   JVMCIObjectArray derivedBase = jvmci_env()-&gt;get_HotSpotReferenceMap_derivedBase(reference_map);
 106   JVMCIPrimitiveArray sizeInBytes = jvmci_env()-&gt;get_HotSpotReferenceMap_sizeInBytes(reference_map);
 107   if (objects.is_null() || derivedBase.is_null() || sizeInBytes.is_null()) {
 108     JVMCI_THROW_NULL(NullPointerException);
 109   }
 110   if (JVMCIENV-&gt;get_length(objects) != JVMCIENV-&gt;get_length(derivedBase) || JVMCIENV-&gt;get_length(objects) != JVMCIENV-&gt;get_length(sizeInBytes)) {
 111     JVMCI_ERROR_NULL(&quot;arrays in reference map have different sizes: %d %d %d&quot;, JVMCIENV-&gt;get_length(objects), JVMCIENV-&gt;get_length(derivedBase), JVMCIENV-&gt;get_length(sizeInBytes));
 112   }
 113   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(objects); i++) {
 114     JVMCIObject location = JVMCIENV-&gt;get_object_at(objects, i);
 115     JVMCIObject baseLocation = JVMCIENV-&gt;get_object_at(derivedBase, i);
 116     jint bytes = JVMCIENV-&gt;get_int_at(sizeInBytes, i);
 117 
 118     VMReg vmReg = getVMRegFromLocation(location, _total_frame_size, JVMCI_CHECK_NULL);
 119     if (baseLocation.is_non_null()) {
 120       // derived oop
 121 #ifdef _LP64
 122       if (bytes == 8) {
 123 #else
 124       if (bytes == 4) {
 125 #endif
 126         VMReg baseReg = getVMRegFromLocation(baseLocation, _total_frame_size, JVMCI_CHECK_NULL);
 127         map-&gt;set_derived_oop(vmReg, baseReg);
 128       } else {
 129         JVMCI_ERROR_NULL(&quot;invalid derived oop size in ReferenceMap: %d&quot;, bytes);
 130       }
 131 #ifdef _LP64
 132     } else if (bytes == 8) {
 133       // wide oop
 134       map-&gt;set_oop(vmReg);
 135     } else if (bytes == 4) {
 136       // narrow oop
 137       map-&gt;set_narrowoop(vmReg);
 138 #else
 139     } else if (bytes == 4) {
 140       map-&gt;set_oop(vmReg);
 141 #endif
 142     } else {
 143       JVMCI_ERROR_NULL(&quot;invalid oop size in ReferenceMap: %d&quot;, bytes);
 144     }
 145   }
 146 
 147   JVMCIObject callee_save_info = jvmci_env()-&gt;get_DebugInfo_calleeSaveInfo(debug_info);
 148   if (callee_save_info.is_non_null()) {
 149     JVMCIObjectArray registers = jvmci_env()-&gt;get_RegisterSaveLayout_registers(callee_save_info);
 150     JVMCIPrimitiveArray slots = jvmci_env()-&gt;get_RegisterSaveLayout_slots(callee_save_info);
 151     for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(slots); i++) {
 152       JVMCIObject jvmci_reg = JVMCIENV-&gt;get_object_at(registers, i);
 153       jint jvmci_reg_number = jvmci_env()-&gt;get_code_Register_number(jvmci_reg);
 154       VMReg hotspot_reg = CodeInstaller::get_hotspot_reg(jvmci_reg_number, JVMCI_CHECK_NULL);
 155       // HotSpot stack slots are 4 bytes
 156       jint jvmci_slot = JVMCIENV-&gt;get_int_at(slots, i);
 157       jint hotspot_slot = jvmci_slot * VMRegImpl::slots_per_word;
 158       VMReg hotspot_slot_as_reg = VMRegImpl::stack2reg(hotspot_slot);
 159       map-&gt;set_callee_saved(hotspot_slot_as_reg, hotspot_reg);
 160 #ifdef _LP64
 161       // (copied from generate_oop_map() in c1_Runtime1_x86.cpp)
 162       VMReg hotspot_slot_hi_as_reg = VMRegImpl::stack2reg(hotspot_slot + 1);
 163       map-&gt;set_callee_saved(hotspot_slot_hi_as_reg, hotspot_reg-&gt;next());
 164 #endif
 165     }
 166   }
 167   return map;
 168 }
 169 
 170 #if INCLUDE_AOT
 171 AOTOopRecorder::AOTOopRecorder(CodeInstaller* code_inst, Arena* arena, bool deduplicate) : OopRecorder(arena, deduplicate) {
 172   _code_inst = code_inst;
 173   _meta_refs = new GrowableArray&lt;jobject&gt;();
 174 }
 175 
 176 int AOTOopRecorder::nr_meta_refs() const {
 177   return _meta_refs-&gt;length();
 178 }
 179 
 180 jobject AOTOopRecorder::meta_element(int pos) const {
 181   return _meta_refs-&gt;at(pos);
 182 }
 183 
 184 int AOTOopRecorder::find_index(Metadata* h) {
 185   JavaThread* THREAD = JavaThread::current();
 186   JVMCIEnv* JVMCIENV = _code_inst-&gt;jvmci_env();
 187   int oldCount = metadata_count();
 188   int index =  this-&gt;OopRecorder::find_index(h);
 189   int newCount = metadata_count();
 190 
 191   if (oldCount == newCount) {
 192     // found a match
 193     return index;
 194   }
 195 
 196   vmassert(index + 1 == newCount, &quot;must be last&quot;);
 197 
 198   JVMCIKlassHandle klass(THREAD);
 199   JVMCIObject result;
 200   guarantee(h != NULL,
 201             &quot;If DebugInformationRecorder::describe_scope passes NULL oldCount == newCount must hold.&quot;);
 202   if (h-&gt;is_klass()) {
 203     klass = (Klass*) h;
 204     result = JVMCIENV-&gt;get_jvmci_type(klass, JVMCI_CATCH);
 205   } else if (h-&gt;is_method()) {
 206     Method* method = (Method*) h;
 207     methodHandle mh(THREAD, method);
 208     result = JVMCIENV-&gt;get_jvmci_method(mh, JVMCI_CATCH);
 209   }
 210   jobject ref = JVMCIENV-&gt;get_jobject(result);
 211   record_meta_ref(ref, index);
 212 
 213   return index;
 214 }
 215 
 216 int AOTOopRecorder::find_index(jobject h) {
 217   if (h == NULL) {
 218     return 0;
 219   }
 220   oop javaMirror = JNIHandles::resolve(h);
 221   Klass* klass = java_lang_Class::as_Klass(javaMirror);
 222   return find_index(klass);
 223 }
 224 
 225 void AOTOopRecorder::record_meta_ref(jobject o, int index) {
 226   assert(index &gt; 0, &quot;must be 1..n&quot;);
 227   index -= 1; // reduce by one to convert to array index
 228 
 229   assert(index == _meta_refs-&gt;length(), &quot;must be last&quot;);
 230   _meta_refs-&gt;append(o);
 231 }
 232 #endif // INCLUDE_AOT
 233 
 234 void* CodeInstaller::record_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS) {
 235   /*
 236    * This method needs to return a raw (untyped) pointer, since the value of a pointer to the base
 237    * class is in general not equal to the pointer of the subclass. When patching metaspace pointers,
 238    * the compiler expects a direct pointer to the subclass (Klass* or Method*), not a pointer to the
 239    * base class (Metadata* or MetaspaceObj*).
 240    */
 241   JVMCIObject obj = jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_metaspaceObject(constant);
 242   if (jvmci_env()-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {
 243     Klass* klass = JVMCIENV-&gt;asKlass(obj);
 244     assert(!jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant), &quot;unexpected compressed klass pointer %s @ &quot; INTPTR_FORMAT, klass-&gt;name()-&gt;as_C_string(), p2i(klass));
 245     int index = _oop_recorder-&gt;find_index(klass);
 246     section-&gt;relocate(dest, metadata_Relocation::spec(index));
 247     TRACE_jvmci_3(&quot;metadata[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), klass-&gt;name()-&gt;as_C_string());
 248     return klass;
 249   } else if (jvmci_env()-&gt;isa_HotSpotResolvedJavaMethodImpl(obj)) {
 250     Method* method = jvmci_env()-&gt;asMethod(obj);
 251     assert(!jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant), &quot;unexpected compressed method pointer %s @ &quot; INTPTR_FORMAT, method-&gt;name()-&gt;as_C_string(), p2i(method));
 252     int index = _oop_recorder-&gt;find_index(method);
 253     section-&gt;relocate(dest, metadata_Relocation::spec(index));
 254     TRACE_jvmci_3(&quot;metadata[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), method-&gt;name()-&gt;as_C_string());
 255     return method;
 256   } else {
 257     JVMCI_ERROR_NULL(&quot;unexpected metadata reference for constant of type %s&quot;, jvmci_env()-&gt;klass_name(obj));
 258   }
 259 }
 260 
 261 #ifdef _LP64
 262 narrowKlass CodeInstaller::record_narrow_metadata_reference(CodeSection* section, address dest, JVMCIObject constant, JVMCI_TRAPS) {
 263   JVMCIObject obj = jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_metaspaceObject(constant);
 264   assert(jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant), &quot;unexpected uncompressed pointer&quot;);
 265 
 266   if (!jvmci_env()-&gt;isa_HotSpotResolvedObjectTypeImpl(obj)) {
 267     JVMCI_ERROR_0(&quot;unexpected compressed pointer of type %s&quot;, jvmci_env()-&gt;klass_name(obj));
 268   }
 269 
 270   Klass* klass = JVMCIENV-&gt;asKlass(obj);
 271   int index = _oop_recorder-&gt;find_index(klass);
 272   section-&gt;relocate(dest, metadata_Relocation::spec(index));
 273   TRACE_jvmci_3(&quot;narrowKlass[%d of %d] = %s&quot;, index, _oop_recorder-&gt;metadata_count(), klass-&gt;name()-&gt;as_C_string());
 274   return CompressedKlassPointers::encode(klass);
 275 }
 276 #endif
 277 
 278 Location::Type CodeInstaller::get_oop_type(JVMCIObject value) {
 279   JVMCIObject valueKind = jvmci_env()-&gt;get_Value_valueKind(value);
 280   JVMCIObject platformKind = jvmci_env()-&gt;get_ValueKind_platformKind(valueKind);
 281 
 282   if (jvmci_env()-&gt;equals(platformKind, word_kind())) {
 283     return Location::oop;
 284   } else {
 285     return Location::narrowoop;
 286   }
 287 }
 288 
 289 ScopeValue* CodeInstaller::get_scope_value(JVMCIObject value, BasicType type, GrowableArray&lt;ScopeValue*&gt;* objects, ScopeValue* &amp;second, JVMCI_TRAPS) {
 290   second = NULL;
 291   if (value.is_null()) {
 292     JVMCI_THROW_NULL(NullPointerException);
 293   } else if (JVMCIENV-&gt;equals(value, jvmci_env()-&gt;get_Value_ILLEGAL())) {
 294     if (type != T_ILLEGAL) {
 295       JVMCI_ERROR_NULL(&quot;unexpected illegal value, expected %s&quot;, basictype_to_str(type));
 296     }
 297     return _illegal_value;
 298   } else if (jvmci_env()-&gt;isa_RegisterValue(value)) {
 299     JVMCIObject reg = jvmci_env()-&gt;get_RegisterValue_reg(value);
 300     jint number = jvmci_env()-&gt;get_code_Register_number(reg);
 301     VMReg hotspotRegister = get_hotspot_reg(number, JVMCI_CHECK_NULL);
 302     if (is_general_purpose_reg(hotspotRegister)) {
 303       Location::Type locationType;
 304       if (type == T_OBJECT) {
 305         locationType = get_oop_type(value);
 306       } else if (type == T_LONG) {
 307         locationType = Location::lng;
 308       } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {
 309         locationType = Location::int_in_long;
 310       } else {
 311         JVMCI_ERROR_NULL(&quot;unexpected type %s in cpu register&quot;, basictype_to_str(type));
 312       }
 313       ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));
 314       if (type == T_LONG) {
 315         second = value;
 316       }
 317       return value;
 318     } else {
 319       Location::Type locationType;
 320       if (type == T_FLOAT) {
 321         // this seems weird, but the same value is used in c1_LinearScan
 322         locationType = Location::normal;
 323       } else if (type == T_DOUBLE) {
 324         locationType = Location::dbl;
 325       } else {
 326         JVMCI_ERROR_NULL(&quot;unexpected type %s in floating point register&quot;, basictype_to_str(type));
 327       }
 328       ScopeValue* value = new LocationValue(Location::new_reg_loc(locationType, hotspotRegister));
 329       if (type == T_DOUBLE) {
 330         second = value;
 331       }
 332       return value;
 333     }
 334   } else if (jvmci_env()-&gt;isa_StackSlot(value)) {
 335     jint offset = jvmci_env()-&gt;get_StackSlot_offset(value);
 336     if (jvmci_env()-&gt;get_StackSlot_addFrameSize(value)) {
 337       offset += _total_frame_size;
 338     }
 339 
 340     Location::Type locationType;
 341     if (type == T_OBJECT) {
 342       locationType = get_oop_type(value);
 343     } else if (type == T_LONG) {
 344       locationType = Location::lng;
 345     } else if (type == T_DOUBLE) {
 346       locationType = Location::dbl;
 347     } else if (type == T_INT || type == T_FLOAT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_BOOLEAN) {
 348       locationType = Location::normal;
 349     } else {
 350       JVMCI_ERROR_NULL(&quot;unexpected type %s in stack slot&quot;, basictype_to_str(type));
 351     }
 352     ScopeValue* value = new LocationValue(Location::new_stk_loc(locationType, offset));
 353     if (type == T_DOUBLE || type == T_LONG) {
 354       second = value;
 355     }
 356     return value;
 357   } else if (jvmci_env()-&gt;isa_JavaConstant(value)) {
 358     if (jvmci_env()-&gt;isa_PrimitiveConstant(value)) {
 359       if (jvmci_env()-&gt;isa_RawConstant(value)) {
 360         jlong prim = jvmci_env()-&gt;get_PrimitiveConstant_primitive(value);
 361         return new ConstantLongValue(prim);
 362       } else {
 363         BasicType constantType = jvmci_env()-&gt;kindToBasicType(jvmci_env()-&gt;get_PrimitiveConstant_kind(value), JVMCI_CHECK_NULL);
 364         if (type != constantType) {
 365           JVMCI_ERROR_NULL(&quot;primitive constant type doesn&#39;t match, expected %s but got %s&quot;, basictype_to_str(type), basictype_to_str(constantType));
 366         }
 367         if (type == T_INT || type == T_FLOAT) {
 368           jint prim = (jint)jvmci_env()-&gt;get_PrimitiveConstant_primitive(value);
 369           switch (prim) {
 370             case -1: return _int_m1_scope_value;
 371             case  0: return _int_0_scope_value;
 372             case  1: return _int_1_scope_value;
 373             case  2: return _int_2_scope_value;
 374             default: return new ConstantIntValue(prim);
 375           }
 376         } else if (type == T_LONG || type == T_DOUBLE) {
 377           jlong prim = jvmci_env()-&gt;get_PrimitiveConstant_primitive(value);
 378           second = _int_1_scope_value;
 379           return new ConstantLongValue(prim);
 380         } else {
 381           JVMCI_ERROR_NULL(&quot;unexpected primitive constant type %s&quot;, basictype_to_str(type));
 382         }
 383       }
 384     } else if (jvmci_env()-&gt;isa_NullConstant(value) || jvmci_env()-&gt;isa_HotSpotCompressedNullConstant(value)) {
 385       if (type == T_OBJECT) {
 386         return _oop_null_scope_value;
 387       } else {
 388         JVMCI_ERROR_NULL(&quot;unexpected null constant, expected %s&quot;, basictype_to_str(type));
 389       }
 390     } else if (jvmci_env()-&gt;isa_HotSpotObjectConstantImpl(value)) {
 391       if (type == T_OBJECT) {
 392         Handle obj = jvmci_env()-&gt;asConstant(value, JVMCI_CHECK_NULL);
 393         if (obj == NULL) {
 394           JVMCI_ERROR_NULL(&quot;null value must be in NullConstant&quot;);
 395         }
 396         return new ConstantOopWriteValue(JNIHandles::make_local(obj()));
 397       } else {
 398         JVMCI_ERROR_NULL(&quot;unexpected object constant, expected %s&quot;, basictype_to_str(type));
 399       }
 400     }
 401   } else if (jvmci_env()-&gt;isa_VirtualObject(value)) {
 402     if (type == T_OBJECT) {
 403       int id = jvmci_env()-&gt;get_VirtualObject_id(value);
 404       if (0 &lt;= id &amp;&amp; id &lt; objects-&gt;length()) {
 405         ScopeValue* object = objects-&gt;at(id);
 406         if (object != NULL) {
 407           return object;
 408         }
 409       }
 410       JVMCI_ERROR_NULL(&quot;unknown virtual object id %d&quot;, id);
 411     } else {
 412       JVMCI_ERROR_NULL(&quot;unexpected virtual object, expected %s&quot;, basictype_to_str(type));
 413     }
 414   }
 415 
 416   JVMCI_ERROR_NULL(&quot;unexpected value in scope: %s&quot;, jvmci_env()-&gt;klass_name(value))
 417 }
 418 
 419 void CodeInstaller::record_object_value(ObjectValue* sv, JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS) {
 420   JVMCIObject type = jvmci_env()-&gt;get_VirtualObject_type(value);
 421   int id = jvmci_env()-&gt;get_VirtualObject_id(value);
 422   Klass* klass = JVMCIENV-&gt;asKlass(type);
 423   bool isLongArray = klass == Universe::longArrayKlassObj();
 424   bool isByteArray = klass == Universe::byteArrayKlassObj();
 425 
 426   JVMCIObjectArray values = jvmci_env()-&gt;get_VirtualObject_values(value);
 427   JVMCIObjectArray slotKinds = jvmci_env()-&gt;get_VirtualObject_slotKinds(value);
 428   for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(values); i++) {
 429     ScopeValue* cur_second = NULL;
 430     JVMCIObject object = JVMCIENV-&gt;get_object_at(values, i);
 431     BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);
 432     ScopeValue* value;
 433     if (JVMCIENV-&gt;equals(object, jvmci_env()-&gt;get_Value_ILLEGAL())) {
 434       if (isByteArray &amp;&amp; type == T_ILLEGAL) {
 435         /*
 436          * The difference between a virtualized large access and a deferred write is the kind stored in the slotKinds
 437          * of the virtual object: in the virtualization case, the kind is illegal, in the deferred write case, the kind
 438          * is access stack kind (an int).
 439          */
 440         value = _virtual_byte_array_marker;
 441       } else {
 442         value = _illegal_value;
 443         if (type == T_DOUBLE || type == T_LONG) {
 444             cur_second = _illegal_value;
 445         }
 446       }
 447     } else {
 448       value = get_scope_value(object, type, objects, cur_second, JVMCI_CHECK);
 449     }
 450 
 451     if (isLongArray &amp;&amp; cur_second == NULL) {
 452       // we&#39;re trying to put ints into a long array... this isn&#39;t really valid, but it&#39;s used for some optimizations.
 453       // add an int 0 constant
 454       cur_second = _int_0_scope_value;
 455     }
 456 
 457     if (isByteArray &amp;&amp; cur_second != NULL &amp;&amp; (type == T_DOUBLE || type == T_LONG)) {
 458       // we are trying to write a long in a byte Array. We will need to count the illegals to restore the type of
 459       // the thing we put inside.
 460       cur_second = NULL;
 461     }
 462 
 463     if (cur_second != NULL) {
 464       sv-&gt;field_values()-&gt;append(cur_second);
 465     }
 466     assert(value != NULL, &quot;missing value&quot;);
 467     sv-&gt;field_values()-&gt;append(value);
 468   }
 469 }
 470 
 471 MonitorValue* CodeInstaller::get_monitor_value(JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS) {
 472   if (value.is_null()) {
 473     JVMCI_THROW_NULL(NullPointerException);
 474   }
 475   if (!jvmci_env()-&gt;isa_StackLockValue(value)) {
 476     JVMCI_ERROR_NULL(&quot;Monitors must be of type StackLockValue, got %s&quot;, jvmci_env()-&gt;klass_name(value));
 477   }
 478 
 479   ScopeValue* second = NULL;
 480   ScopeValue* owner_value = get_scope_value(jvmci_env()-&gt;get_StackLockValue_owner(value), T_OBJECT, objects, second, JVMCI_CHECK_NULL);
 481   assert(second == NULL, &quot;monitor cannot occupy two stack slots&quot;);
 482 
 483   ScopeValue* lock_data_value = get_scope_value(jvmci_env()-&gt;get_StackLockValue_slot(value), T_LONG, objects, second, JVMCI_CHECK_NULL);
 484   assert(second == lock_data_value, &quot;monitor is LONG value that occupies two stack slots&quot;);
 485   assert(lock_data_value-&gt;is_location(), &quot;invalid monitor location&quot;);
 486   Location lock_data_loc = ((LocationValue*)lock_data_value)-&gt;location();
 487 
 488   bool eliminated = false;
 489   if (jvmci_env()-&gt;get_StackLockValue_eliminated(value)) {
 490     eliminated = true;
 491   }
 492 
 493   return new MonitorValue(owner_value, lock_data_loc, eliminated);
 494 }
 495 
 496 void CodeInstaller::initialize_dependencies(JVMCIObject compiled_code, OopRecorder* oop_recorder, JVMCI_TRAPS) {
 497   JavaThread* thread = JavaThread::current();
 498   CompilerThread* compilerThread = thread-&gt;is_Compiler_thread() ? thread-&gt;as_CompilerThread() : NULL;
 499   _oop_recorder = oop_recorder;
 500   _dependencies = new Dependencies(&amp;_arena, _oop_recorder, compilerThread != NULL ? compilerThread-&gt;log() : NULL);
 501   JVMCIObjectArray assumptions = jvmci_env()-&gt;get_HotSpotCompiledCode_assumptions(compiled_code);
 502   if (assumptions.is_non_null()) {
 503     int length = JVMCIENV-&gt;get_length(assumptions);
 504     for (int i = 0; i &lt; length; ++i) {
 505       JVMCIObject assumption = JVMCIENV-&gt;get_object_at(assumptions, i);
 506       if (assumption.is_non_null()) {
 507         if (jvmci_env()-&gt;isa_Assumptions_NoFinalizableSubclass(assumption)) {
 508           assumption_NoFinalizableSubclass(assumption);
 509         } else if (jvmci_env()-&gt;isa_Assumptions_ConcreteSubtype(assumption)) {
 510           assumption_ConcreteSubtype(assumption);
 511         } else if (jvmci_env()-&gt;isa_Assumptions_LeafType(assumption)) {
 512           assumption_LeafType(assumption);
 513         } else if (jvmci_env()-&gt;isa_Assumptions_ConcreteMethod(assumption)) {
 514           assumption_ConcreteMethod(assumption);
 515         } else if (jvmci_env()-&gt;isa_Assumptions_CallSiteTargetValue(assumption)) {
 516           assumption_CallSiteTargetValue(assumption, JVMCI_CHECK);
 517         } else {
 518           JVMCI_ERROR(&quot;unexpected Assumption subclass %s&quot;, jvmci_env()-&gt;klass_name(assumption));
 519         }
 520       }
 521     }
 522   }
 523   if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
 524     JVMCIObjectArray methods = jvmci_env()-&gt;get_HotSpotCompiledCode_methods(compiled_code);
 525     if (methods.is_non_null()) {
 526       int length = JVMCIENV-&gt;get_length(methods);
 527       for (int i = 0; i &lt; length; ++i) {
 528         JVMCIObject method_handle = JVMCIENV-&gt;get_object_at(methods, i);
 529         Method* method = jvmci_env()-&gt;asMethod(method_handle);
 530         _dependencies-&gt;assert_evol_method(method);
 531       }
 532     }
 533   }
 534 }
 535 
 536 #if INCLUDE_AOT
 537 RelocBuffer::~RelocBuffer() {
 538   FREE_C_HEAP_ARRAY(char, _buffer);
 539 }
 540 
 541 address RelocBuffer::begin() const {
 542   if (_buffer != NULL) {
 543     return (address) _buffer;
 544   }
 545   return (address) _static_buffer;
 546 }
 547 
 548 void RelocBuffer::set_size(size_t bytes) {
 549   assert(bytes &lt;= _size, &quot;can&#39;t grow in size!&quot;);
 550   _size = bytes;
 551 }
 552 
 553 void RelocBuffer::ensure_size(size_t bytes) {
 554   assert(_buffer == NULL, &quot;can only be used once&quot;);
 555   assert(_size == 0, &quot;can only be used once&quot;);
 556   if (bytes &gt;= RelocBuffer::stack_size) {
 557     _buffer = NEW_C_HEAP_ARRAY(char, bytes, mtJVMCI);
 558   }
 559   _size = bytes;
 560 }
 561 
 562 JVMCI::CodeInstallResult CodeInstaller::gather_metadata(JVMCIObject target, JVMCIObject compiled_code, CodeMetadata&amp; metadata, JVMCI_TRAPS) {
 563   assert(JVMCIENV-&gt;is_hotspot(), &quot;AOT code is executed only in HotSpot mode&quot;);
 564   CodeBuffer buffer(&quot;JVMCI Compiler CodeBuffer for Metadata&quot;);
 565   AOTOopRecorder* recorder = new AOTOopRecorder(this, &amp;_arena, true);
 566   initialize_dependencies(compiled_code, recorder, JVMCI_CHECK_OK);
 567 
 568   metadata.set_oop_recorder(recorder);
 569 
 570   // Get instructions and constants CodeSections early because we need it.
 571   _instructions = buffer.insts();
 572   _constants = buffer.consts();
 573   buffer.set_immutable_PIC(_immutable_pic_compilation);
 574 
 575   initialize_fields(target, compiled_code, JVMCI_CHECK_OK);
 576   JVMCI::CodeInstallResult result = initialize_buffer(buffer, false, JVMCI_CHECK_OK);
 577   if (result != JVMCI::ok) {
 578     return result;
 579   }
 580 
 581   _debug_recorder-&gt;pcs_size(); // create the sentinel record
 582 
 583   assert(_debug_recorder-&gt;pcs_length() &gt;= 2, &quot;must be at least 2&quot;);
 584 
 585   metadata.set_pc_desc(_debug_recorder-&gt;pcs(), _debug_recorder-&gt;pcs_length());
 586   metadata.set_scopes(_debug_recorder-&gt;stream()-&gt;buffer(), _debug_recorder-&gt;data_size());
 587   metadata.set_exception_table(&amp;_exception_handler_table);
 588   metadata.set_implicit_exception_table(&amp;_implicit_exception_table);
 589 
 590   RelocBuffer* reloc_buffer = metadata.get_reloc_buffer();
 591 
 592   reloc_buffer-&gt;ensure_size(buffer.total_relocation_size());
 593   size_t size = (size_t) buffer.copy_relocations_to(reloc_buffer-&gt;begin(), (CodeBuffer::csize_t) reloc_buffer-&gt;size(), true);
 594   reloc_buffer-&gt;set_size(size);
 595   return JVMCI::ok;
 596 }
 597 #endif // INCLUDE_AOT
 598 
 599 // constructor used to create a method
 600 JVMCI::CodeInstallResult CodeInstaller::install(JVMCICompiler* compiler,
 601     JVMCIObject target,
 602     JVMCIObject compiled_code,
 603     CodeBlob*&amp; cb,
 604     JVMCIObject installed_code,
 605     FailedSpeculation** failed_speculations,
 606     char* speculations,
 607     int speculations_len,
 608     JVMCI_TRAPS) {
 609 
 610   CodeBuffer buffer(&quot;JVMCI Compiler CodeBuffer&quot;);
 611   OopRecorder* recorder = new OopRecorder(&amp;_arena, true);
 612   initialize_dependencies(compiled_code, recorder, JVMCI_CHECK_OK);
 613 
 614   // Get instructions and constants CodeSections early because we need it.
 615   _instructions = buffer.insts();
 616   _constants = buffer.consts();
 617 #if INCLUDE_AOT
 618   buffer.set_immutable_PIC(_immutable_pic_compilation);
 619 #endif
 620 
 621   initialize_fields(target, compiled_code, JVMCI_CHECK_OK);
 622   JVMCI::CodeInstallResult result = initialize_buffer(buffer, true, JVMCI_CHECK_OK);
 623   if (result != JVMCI::ok) {
 624     return result;
 625   }
 626 
 627   int stack_slots = _total_frame_size / HeapWordSize; // conversion to words
 628 
 629   if (!jvmci_env()-&gt;isa_HotSpotCompiledNmethod(compiled_code)) {
 630     JVMCIObject stubName = jvmci_env()-&gt;get_HotSpotCompiledCode_name(compiled_code);
 631     if (stubName.is_null()) {
 632       JVMCI_ERROR_OK(&quot;stub should have a name&quot;);
 633     }
 634     char* name = strdup(jvmci_env()-&gt;as_utf8_string(stubName));
 635     cb = RuntimeStub::new_runtime_stub(name,
 636                                        &amp;buffer,
 637                                        _offsets.value(CodeOffsets::Frame_Complete),
 638                                        stack_slots,
 639                                        _debug_recorder-&gt;_oopmaps,
 640                                        false);
 641     result = JVMCI::ok;
 642   } else {
 643     JVMCICompileState* compile_state = (JVMCICompileState*) (address) jvmci_env()-&gt;get_HotSpotCompiledNmethod_compileState(compiled_code);
 644     if (compile_state != NULL) {
 645       jvmci_env()-&gt;set_compile_state(compile_state);
 646     }
 647 
 648     Thread* thread = Thread::current();
 649 
 650     methodHandle method(thread, jvmci_env()-&gt;asMethod(jvmci_env()-&gt;get_HotSpotCompiledNmethod_method(compiled_code)));
 651     jint entry_bci = jvmci_env()-&gt;get_HotSpotCompiledNmethod_entryBCI(compiled_code);
 652     bool has_unsafe_access = jvmci_env()-&gt;get_HotSpotCompiledNmethod_hasUnsafeAccess(compiled_code) == JNI_TRUE;
 653     jint id = jvmci_env()-&gt;get_HotSpotCompiledNmethod_id(compiled_code);
 654     if (id == -1) {
 655       // Make sure a valid compile_id is associated with every compile
 656       id = CompileBroker::assign_compile_id_unlocked(thread, method, entry_bci);
 657       jvmci_env()-&gt;set_HotSpotCompiledNmethod_id(compiled_code, id);
 658     }
 659     if (!jvmci_env()-&gt;isa_HotSpotNmethod(installed_code)) {
 660       JVMCI_THROW_MSG_(IllegalArgumentException, &quot;InstalledCode object must be a HotSpotNmethod when installing a HotSpotCompiledNmethod&quot;, JVMCI::ok);
 661     }
 662 
 663     JVMCIObject mirror = installed_code;
 664     nmethod* nm = NULL;
 665     result = runtime()-&gt;register_method(jvmci_env(), method, nm, entry_bci, &amp;_offsets, _orig_pc_offset, &amp;buffer,
 666                                         stack_slots, _debug_recorder-&gt;_oopmaps, &amp;_exception_handler_table, &amp;_implicit_exception_table,
 667                                         compiler, _debug_recorder, _dependencies, id,
 668                                         has_unsafe_access, _has_wide_vector, compiled_code, mirror,
 669                                         failed_speculations, speculations, speculations_len);
 670     cb = nm-&gt;as_codeblob_or_null();
 671     if (nm != NULL &amp;&amp; compile_state == NULL) {
 672       // This compile didn&#39;t come through the CompileBroker so perform the printing here
 673       DirectiveSet* directive = DirectivesStack::getMatchingDirective(method, compiler);
 674       nm-&gt;maybe_print_nmethod(directive);
 675       DirectivesStack::release(directive);
 676     }
 677   }
 678 
 679   if (cb != NULL) {
 680     // Make sure the pre-calculated constants section size was correct.
 681     guarantee((cb-&gt;code_begin() - cb-&gt;content_begin()) &gt;= _constants_size, &quot;%d &lt; %d&quot;, (int)(cb-&gt;code_begin() - cb-&gt;content_begin()), _constants_size);
 682   }
 683   return result;
 684 }
 685 
 686 void CodeInstaller::initialize_fields(JVMCIObject target, JVMCIObject compiled_code, JVMCI_TRAPS) {
 687   if (jvmci_env()-&gt;isa_HotSpotCompiledNmethod(compiled_code)) {
 688     JVMCIObject hotspotJavaMethod = jvmci_env()-&gt;get_HotSpotCompiledNmethod_method(compiled_code);
 689     Thread* thread = Thread::current();
 690     methodHandle method(thread, jvmci_env()-&gt;asMethod(hotspotJavaMethod));
 691     _parameter_count = method-&gt;size_of_parameters();
 692     TRACE_jvmci_2(&quot;installing code for %s&quot;, method-&gt;name_and_sig_as_C_string());
 693   } else {
 694     // Must be a HotSpotCompiledRuntimeStub.
 695     // Only used in OopMap constructor for non-product builds
 696     _parameter_count = 0;
 697   }
 698   _sites_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_sites(compiled_code);
 699 
 700   _code_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_targetCode(compiled_code);
 701   _code_size = jvmci_env()-&gt;get_HotSpotCompiledCode_targetCodeSize(compiled_code);
 702   _total_frame_size = jvmci_env()-&gt;get_HotSpotCompiledCode_totalFrameSize(compiled_code);
 703 
 704   JVMCIObject deoptRescueSlot = jvmci_env()-&gt;get_HotSpotCompiledCode_deoptRescueSlot(compiled_code);
 705   if (deoptRescueSlot.is_null()) {
 706     _orig_pc_offset = -1;
 707   } else {
 708     _orig_pc_offset = jvmci_env()-&gt;get_StackSlot_offset(deoptRescueSlot);
 709     if (jvmci_env()-&gt;get_StackSlot_addFrameSize(deoptRescueSlot)) {
 710       _orig_pc_offset += _total_frame_size;
 711     }
 712     if (_orig_pc_offset &lt; 0) {
 713       JVMCI_ERROR(&quot;invalid deopt rescue slot: %d&quot;, _orig_pc_offset);
 714     }
 715   }
 716 
 717   // Pre-calculate the constants section size.  This is required for PC-relative addressing.
 718   _data_section_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_dataSection(compiled_code);
 719   if ((_constants-&gt;alignment() % jvmci_env()-&gt;get_HotSpotCompiledCode_dataSectionAlignment(compiled_code)) != 0) {
 720     JVMCI_ERROR(&quot;invalid data section alignment: %d&quot;, jvmci_env()-&gt;get_HotSpotCompiledCode_dataSectionAlignment(compiled_code));
 721   }
 722   _constants_size = JVMCIENV-&gt;get_length(data_section());
 723 
 724   _data_section_patches_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_dataSectionPatches(compiled_code);
 725 
 726 #ifndef PRODUCT
 727   _comments_handle = jvmci_env()-&gt;get_HotSpotCompiledCode_comments(compiled_code);
 728 #endif
 729 
 730   _next_call_type = INVOKE_INVALID;
 731 
 732   _has_wide_vector = false;
 733 
 734   JVMCIObject arch = jvmci_env()-&gt;get_TargetDescription_arch(target);
 735   _word_kind_handle = jvmci_env()-&gt;get_Architecture_wordKind(arch);
 736 }
 737 
 738 int CodeInstaller::estimate_stubs_size(JVMCI_TRAPS) {
 739   // Estimate the number of static and aot call stubs that might be emitted.
 740   int static_call_stubs = 0;
 741   int aot_call_stubs = 0;
 742   int trampoline_stubs = 0;
 743   JVMCIObjectArray sites = this-&gt;sites();
 744   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(sites); i++) {
 745     JVMCIObject site = JVMCIENV-&gt;get_object_at(sites, i);
 746     if (!site.is_null()) {
 747       if (jvmci_env()-&gt;isa_site_Mark(site)) {
 748         JVMCIObject id_obj = jvmci_env()-&gt;get_site_Mark_id(site);
 749         if (id_obj.is_non_null()) {
 750           if (!jvmci_env()-&gt;is_boxing_object(T_INT, id_obj)) {
 751             JVMCI_ERROR_0(&quot;expected Integer id, got %s&quot;, jvmci_env()-&gt;klass_name(id_obj));
 752           }
 753           jint id = jvmci_env()-&gt;get_boxed_value(T_INT, id_obj).i;
 754           switch (id) {
 755             case INVOKEINTERFACE:
 756             case INVOKEVIRTUAL:
 757               trampoline_stubs++;
 758               break;
 759             case INVOKESTATIC:
 760             case INVOKESPECIAL:
 761               static_call_stubs++;
 762               trampoline_stubs++;
 763               break;
 764             default:
 765               break;
 766           }
 767         }
 768       }
 769 #if INCLUDE_AOT
 770       if (UseAOT &amp;&amp; jvmci_env()-&gt;isa_site_Call(site)) {
 771         JVMCIObject target = jvmci_env()-&gt; get_site_Call_target(site);
 772         if (!jvmci_env()-&gt;isa_HotSpotForeignCallTarget(target)) {
 773           // Add far aot trampolines.
 774           aot_call_stubs++;
 775         }
 776       }
 777 #endif
 778     }
 779   }
 780   int size = static_call_stubs * CompiledStaticCall::to_interp_stub_size();
 781   size += trampoline_stubs * CompiledStaticCall::to_trampoline_stub_size();
 782 #if INCLUDE_AOT
 783   size += aot_call_stubs * CompiledStaticCall::to_aot_stub_size();
 784 #endif
 785   return size;
 786 }
 787 
 788 // perform data and call relocation on the CodeBuffer
 789 JVMCI::CodeInstallResult CodeInstaller::initialize_buffer(CodeBuffer&amp; buffer, bool check_size, JVMCI_TRAPS) {
 790   HandleMark hm;
 791   JVMCIObjectArray sites = this-&gt;sites();
 792   int locs_buffer_size = JVMCIENV-&gt;get_length(sites) * (relocInfo::length_limit + sizeof(relocInfo));
 793 
 794   // Allocate enough space in the stub section for the static call
 795   // stubs.  Stubs have extra relocs but they are managed by the stub
 796   // section itself so they don&#39;t need to be accounted for in the
 797   // locs_buffer above.
 798   int stubs_size = estimate_stubs_size(JVMCI_CHECK_OK);
 799   int total_size = align_up(_code_size, buffer.insts()-&gt;alignment()) + align_up(_constants_size, buffer.consts()-&gt;alignment()) + align_up(stubs_size, buffer.stubs()-&gt;alignment());
 800 
 801   if (check_size &amp;&amp; total_size &gt; JVMCINMethodSizeLimit) {
 802     return JVMCI::code_too_large;
 803   }
 804 
 805   buffer.initialize(total_size, locs_buffer_size);
 806   if (buffer.blob() == NULL) {
 807     return JVMCI::cache_full;
 808   }
 809   buffer.initialize_stubs_size(stubs_size);
 810   buffer.initialize_consts_size(_constants_size);
 811 
 812   _debug_recorder = new DebugInformationRecorder(_oop_recorder);
 813   _debug_recorder-&gt;set_oopmaps(new OopMapSet());
 814 
 815   buffer.initialize_oop_recorder(_oop_recorder);
 816 
 817   // copy the constant data into the newly created CodeBuffer
 818   address end_data = _constants-&gt;start() + _constants_size;
 819   JVMCIENV-&gt;copy_bytes_to(data_section(), (jbyte*) _constants-&gt;start(), 0, _constants_size);
 820   _constants-&gt;set_end(end_data);
 821 
 822   // copy the code into the newly created CodeBuffer
 823   address end_pc = _instructions-&gt;start() + _code_size;
 824   guarantee(_instructions-&gt;allocates2(end_pc), &quot;initialize should have reserved enough space for all the code&quot;);
 825   JVMCIENV-&gt;copy_bytes_to(code(), (jbyte*) _instructions-&gt;start(), 0, _code_size);
 826   _instructions-&gt;set_end(end_pc);
 827 
 828   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(data_section_patches()); i++) {
 829     // HandleMark hm(THREAD);
 830     JVMCIObject patch = JVMCIENV-&gt;get_object_at(data_section_patches(), i);
 831     if (patch.is_null()) {
 832       JVMCI_THROW_(NullPointerException, JVMCI::ok);
 833     }
 834     JVMCIObject reference = jvmci_env()-&gt;get_site_DataPatch_reference(patch);
 835     if (reference.is_null()) {
 836       JVMCI_THROW_(NullPointerException, JVMCI::ok);
 837     }
 838     if (!jvmci_env()-&gt;isa_site_ConstantReference(reference)) {
 839       JVMCI_ERROR_OK(&quot;invalid patch in data section: %s&quot;, jvmci_env()-&gt;klass_name(reference));
 840     }
 841     JVMCIObject constant = jvmci_env()-&gt;get_site_ConstantReference_constant(reference);
 842     if (constant.is_null()) {
 843       JVMCI_THROW_(NullPointerException, JVMCI::ok);
 844     }
 845     address dest = _constants-&gt;start() + jvmci_env()-&gt;get_site_Site_pcOffset(patch);
 846     if (jvmci_env()-&gt;isa_HotSpotMetaspaceConstantImpl(constant)) {
 847       if (jvmci_env()-&gt;get_HotSpotMetaspaceConstantImpl_compressed(constant)) {
 848 #ifdef _LP64
 849         *((narrowKlass*) dest) = record_narrow_metadata_reference(_constants, dest, constant, JVMCI_CHECK_OK);
 850 #else
 851         JVMCI_ERROR_OK(&quot;unexpected compressed Klass* in 32-bit mode&quot;);
 852 #endif
 853       } else {
 854         *((void**) dest) = record_metadata_reference(_constants, dest, constant, JVMCI_CHECK_OK);
 855       }
 856     } else if (jvmci_env()-&gt;isa_HotSpotObjectConstantImpl(constant)) {
 857       Handle obj = jvmci_env()-&gt;asConstant(constant, JVMCI_CHECK_OK);
 858       jobject value = JNIHandles::make_local(obj());
 859       int oop_index = _oop_recorder-&gt;find_index(value);
 860 
 861       if (jvmci_env()-&gt;get_HotSpotObjectConstantImpl_compressed(constant)) {
 862 #ifdef _LP64
 863         _constants-&gt;relocate(dest, oop_Relocation::spec(oop_index), relocInfo::narrow_oop_in_const);
 864 #else
 865         JVMCI_ERROR_OK(&quot;unexpected compressed oop in 32-bit mode&quot;);
 866 #endif
 867       } else {
 868         _constants-&gt;relocate(dest, oop_Relocation::spec(oop_index));
 869       }
 870     } else {
 871       JVMCI_ERROR_OK(&quot;invalid constant in data section: %s&quot;, jvmci_env()-&gt;klass_name(constant));
 872     }
 873   }
 874   jint last_pc_offset = -1;
 875   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(sites); i++) {
 876     // HandleMark hm(THREAD);
 877     JVMCIObject site = JVMCIENV-&gt;get_object_at(sites, i);
 878     if (site.is_null()) {
 879       JVMCI_THROW_(NullPointerException, JVMCI::ok);
 880     }
 881 
 882     jint pc_offset = jvmci_env()-&gt;get_site_Site_pcOffset(site);
 883 
 884     if (jvmci_env()-&gt;isa_site_Call(site)) {
 885       TRACE_jvmci_4(&quot;call at %i&quot;, pc_offset);
 886       site_Call(buffer, pc_offset, site, JVMCI_CHECK_OK);
 887     } else if (jvmci_env()-&gt;isa_site_Infopoint(site)) {
 888       // three reasons for infopoints denote actual safepoints
 889       JVMCIObject reason = jvmci_env()-&gt;get_site_Infopoint_reason(site);
 890       if (JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_SAFEPOINT()) ||
 891           JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_CALL()) ||
 892           JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_IMPLICIT_EXCEPTION())) {
 893         TRACE_jvmci_4(&quot;safepoint at %i&quot;, pc_offset);
 894         site_Safepoint(buffer, pc_offset, site, JVMCI_CHECK_OK);
 895         if (_orig_pc_offset &lt; 0) {
 896           JVMCI_ERROR_OK(&quot;method contains safepoint, but has no deopt rescue slot&quot;);
 897         }
 898         if (JVMCIENV-&gt;equals(reason, jvmci_env()-&gt;get_site_InfopointReason_IMPLICIT_EXCEPTION())) {
 899           TRACE_jvmci_4(&quot;implicit exception at %i&quot;, pc_offset);
 900           _implicit_exception_table.add_deoptimize(pc_offset);
 901         }
 902       } else {
 903         TRACE_jvmci_4(&quot;infopoint at %i&quot;, pc_offset);
 904         site_Infopoint(buffer, pc_offset, site, JVMCI_CHECK_OK);
 905       }
 906     } else if (jvmci_env()-&gt;isa_site_DataPatch(site)) {
 907       TRACE_jvmci_4(&quot;datapatch at %i&quot;, pc_offset);
 908       site_DataPatch(buffer, pc_offset, site, JVMCI_CHECK_OK);
 909     } else if (jvmci_env()-&gt;isa_site_Mark(site)) {
 910       TRACE_jvmci_4(&quot;mark at %i&quot;, pc_offset);
 911       site_Mark(buffer, pc_offset, site, JVMCI_CHECK_OK);
 912     } else if (jvmci_env()-&gt;isa_site_ExceptionHandler(site)) {
 913       TRACE_jvmci_4(&quot;exceptionhandler at %i&quot;, pc_offset);
 914       site_ExceptionHandler(pc_offset, site);
 915     } else {
 916       JVMCI_ERROR_OK(&quot;unexpected site subclass: %s&quot;, jvmci_env()-&gt;klass_name(site));
 917     }
 918     last_pc_offset = pc_offset;
 919 
 920     JavaThread* thread = JavaThread::current();
 921     if (SafepointMechanism::should_block(thread)) {
 922       // this is a hacky way to force a safepoint check but nothing else was jumping out at me.
 923       ThreadToNativeFromVM ttnfv(thread);
 924     }
 925   }
 926 
 927 #ifndef PRODUCT
 928   if (comments().is_non_null()) {
 929     for (int i = 0; i &lt; JVMCIENV-&gt;get_length(comments()); i++) {
 930       JVMCIObject comment = JVMCIENV-&gt;get_object_at(comments(), i);
 931       assert(jvmci_env()-&gt;isa_HotSpotCompiledCode_Comment(comment), &quot;cce&quot;);
 932       jint offset = jvmci_env()-&gt;get_HotSpotCompiledCode_Comment_pcOffset(comment);
 933       const char* text = jvmci_env()-&gt;as_utf8_string(jvmci_env()-&gt;get_HotSpotCompiledCode_Comment_text(comment));
 934       buffer.block_comment(offset, text);
 935     }
 936   }
 937 #endif
 938   return JVMCI::ok;
 939 }
 940 
 941 void CodeInstaller::assumption_NoFinalizableSubclass(JVMCIObject assumption) {
 942   JVMCIObject receiverType_handle = jvmci_env()-&gt;get_Assumptions_NoFinalizableSubclass_receiverType(assumption);
 943   Klass* receiverType = jvmci_env()-&gt;asKlass(receiverType_handle);
 944   _dependencies-&gt;assert_has_no_finalizable_subclasses(receiverType);
 945 }
 946 
 947 void CodeInstaller::assumption_ConcreteSubtype(JVMCIObject assumption) {
 948   JVMCIObject context_handle = jvmci_env()-&gt;get_Assumptions_ConcreteSubtype_context(assumption);
 949   JVMCIObject subtype_handle = jvmci_env()-&gt;get_Assumptions_ConcreteSubtype_subtype(assumption);
 950   Klass* context = jvmci_env()-&gt;asKlass(context_handle);
 951   Klass* subtype = jvmci_env()-&gt;asKlass(subtype_handle);
 952 
 953   assert(context-&gt;is_abstract(), &quot;&quot;);
 954   _dependencies-&gt;assert_abstract_with_unique_concrete_subtype(context, subtype);
 955 }
 956 
 957 void CodeInstaller::assumption_LeafType(JVMCIObject assumption) {
 958   JVMCIObject context_handle = jvmci_env()-&gt;get_Assumptions_LeafType_context(assumption);
 959   Klass* context = jvmci_env()-&gt;asKlass(context_handle);
 960 
 961   _dependencies-&gt;assert_leaf_type(context);
 962 }
 963 
 964 void CodeInstaller::assumption_ConcreteMethod(JVMCIObject assumption) {
 965   JVMCIObject impl_handle = jvmci_env()-&gt;get_Assumptions_ConcreteMethod_impl(assumption);
 966   JVMCIObject context_handle = jvmci_env()-&gt;get_Assumptions_ConcreteMethod_context(assumption);
 967 
 968   Method* impl = jvmci_env()-&gt;asMethod(impl_handle);
 969   Klass* context = jvmci_env()-&gt;asKlass(context_handle);
 970 
 971   _dependencies-&gt;assert_unique_concrete_method(context, impl);
 972 }
 973 
 974 void CodeInstaller::assumption_CallSiteTargetValue(JVMCIObject assumption, JVMCI_TRAPS) {
 975   JVMCIObject callSiteConstant = jvmci_env()-&gt;get_Assumptions_CallSiteTargetValue_callSite(assumption);
 976   Handle callSite = jvmci_env()-&gt;asConstant(callSiteConstant, JVMCI_CHECK);
 977   JVMCIObject methodConstant = jvmci_env()-&gt;get_Assumptions_CallSiteTargetValue_methodHandle(assumption);
 978   Handle methodHandle = jvmci_env()-&gt;asConstant(methodConstant, JVMCI_CHECK);
 979   _dependencies-&gt;assert_call_site_target_value(callSite(), methodHandle());
 980 }
 981 
 982 void CodeInstaller::site_ExceptionHandler(jint pc_offset, JVMCIObject exc) {
 983   jint handler_offset = jvmci_env()-&gt;get_site_ExceptionHandler_handlerPos(exc);
 984 
 985   // Subtable header
 986   _exception_handler_table.add_entry(HandlerTableEntry(1, pc_offset, 0));
 987 
 988   // Subtable entry
 989   _exception_handler_table.add_entry(HandlerTableEntry(-1, handler_offset, 0));
 990 }
 991 
 992 // If deoptimization happens, the interpreter should reexecute these bytecodes.
 993 // This function mainly helps the compilers to set up the reexecute bit.
 994 static bool bytecode_should_reexecute(Bytecodes::Code code) {
 995   switch (code) {
 996     case Bytecodes::_invokedynamic:
 997     case Bytecodes::_invokevirtual:
 998     case Bytecodes::_invokeinterface:
 999     case Bytecodes::_invokespecial:
1000     case Bytecodes::_invokestatic:
1001       return false;
1002     default:
1003       return true;
1004     }
1005   return true;
1006 }
1007 
1008 GrowableArray&lt;ScopeValue*&gt;* CodeInstaller::record_virtual_objects(JVMCIObject debug_info, JVMCI_TRAPS) {
1009   JVMCIObjectArray virtualObjects = jvmci_env()-&gt;get_DebugInfo_virtualObjectMapping(debug_info);
1010   if (virtualObjects.is_null()) {
1011     return NULL;
1012   }
1013   GrowableArray&lt;ScopeValue*&gt;* objects = new GrowableArray&lt;ScopeValue*&gt;(JVMCIENV-&gt;get_length(virtualObjects), JVMCIENV-&gt;get_length(virtualObjects), NULL);
1014   // Create the unique ObjectValues
1015   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(virtualObjects); i++) {
1016     // HandleMark hm(THREAD);
1017     JVMCIObject value = JVMCIENV-&gt;get_object_at(virtualObjects, i);
1018     int id = jvmci_env()-&gt;get_VirtualObject_id(value);
1019     JVMCIObject type = jvmci_env()-&gt;get_VirtualObject_type(value);
1020     bool is_auto_box = jvmci_env()-&gt;get_VirtualObject_isAutoBox(value);
1021     Klass* klass = jvmci_env()-&gt;asKlass(type);
1022     oop javaMirror = klass-&gt;java_mirror();
1023     ScopeValue *klass_sv = new ConstantOopWriteValue(JNIHandles::make_local(Thread::current(), javaMirror));
1024     ObjectValue* sv = is_auto_box ? new AutoBoxObjectValue(id, klass_sv) : new ObjectValue(id, klass_sv);
1025     if (id &lt; 0 || id &gt;= objects-&gt;length()) {
1026       JVMCI_ERROR_NULL(&quot;virtual object id %d out of bounds&quot;, id);
1027     }
1028     if (objects-&gt;at(id) != NULL) {
1029       JVMCI_ERROR_NULL(&quot;duplicate virtual object id %d&quot;, id);
1030     }
1031     objects-&gt;at_put(id, sv);
1032   }
1033   // All the values which could be referenced by the VirtualObjects
1034   // exist, so now describe all the VirtualObjects themselves.
1035   for (int i = 0; i &lt; JVMCIENV-&gt;get_length(virtualObjects); i++) {
1036     // HandleMark hm(THREAD);
1037     JVMCIObject value = JVMCIENV-&gt;get_object_at(virtualObjects, i);
1038     int id = jvmci_env()-&gt;get_VirtualObject_id(value);
1039     record_object_value(objects-&gt;at(id)-&gt;as_ObjectValue(), value, objects, JVMCI_CHECK_NULL);
1040   }
1041   _debug_recorder-&gt;dump_object_pool(objects);
1042   return objects;
1043 }
1044 
1045 void CodeInstaller::record_scope(jint pc_offset, JVMCIObject debug_info, ScopeMode scope_mode, bool return_oop, JVMCI_TRAPS) {
1046   JVMCIObject position = jvmci_env()-&gt;get_DebugInfo_bytecodePosition(debug_info);
1047   if (position.is_null()) {
1048     // Stubs do not record scope info, just oop maps
1049     return;
1050   }
1051 
1052   GrowableArray&lt;ScopeValue*&gt;* objectMapping;
1053   if (scope_mode == CodeInstaller::FullFrame) {
1054     objectMapping = record_virtual_objects(debug_info, JVMCI_CHECK);
1055   } else {
1056     objectMapping = NULL;
1057   }
1058   record_scope(pc_offset, position, scope_mode, objectMapping, return_oop, JVMCI_CHECK);
1059 }
1060 
1061 int CodeInstaller::map_jvmci_bci(int bci) {
1062   if (bci &lt; 0) {
1063     if (bci == jvmci_env()-&gt;get_BytecodeFrame_BEFORE_BCI()) {
1064       return BeforeBci;
1065     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_AFTER_BCI()) {
1066       return AfterBci;
1067     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_UNWIND_BCI()) {
1068       return UnwindBci;
1069     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_AFTER_EXCEPTION_BCI()) {
1070       return AfterExceptionBci;
1071     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_UNKNOWN_BCI()) {
1072       return UnknownBci;
1073     } else if (bci == jvmci_env()-&gt;get_BytecodeFrame_INVALID_FRAMESTATE_BCI()) {
1074       return InvalidFrameStateBci;
1075     }
1076     ShouldNotReachHere();
1077   }
1078   return bci;
1079 }
1080 
1081 void CodeInstaller::record_scope(jint pc_offset, JVMCIObject position, ScopeMode scope_mode, GrowableArray&lt;ScopeValue*&gt;* objects, bool return_oop, JVMCI_TRAPS) {
1082   JVMCIObject frame;
1083   if (scope_mode == CodeInstaller::FullFrame) {
1084     if (!jvmci_env()-&gt;isa_BytecodeFrame(position)) {
1085       JVMCI_ERROR(&quot;Full frame expected for debug info at %i&quot;, pc_offset);
1086     }
1087     frame = position;
1088   }
1089   JVMCIObject caller_frame = jvmci_env()-&gt;get_BytecodePosition_caller(position);
1090   if (caller_frame.is_non_null()) {
1091     record_scope(pc_offset, caller_frame, scope_mode, objects, return_oop, JVMCI_CHECK);
1092   }
1093 
1094   JVMCIObject hotspot_method = jvmci_env()-&gt;get_BytecodePosition_method(position);
1095   Thread* thread = Thread::current();
1096   methodHandle method(thread, jvmci_env()-&gt;asMethod(hotspot_method));
1097   jint bci = map_jvmci_bci(jvmci_env()-&gt;get_BytecodePosition_bci(position));
1098   if (bci == jvmci_env()-&gt;get_BytecodeFrame_BEFORE_BCI()) {
1099     bci = SynchronizationEntryBCI;
1100   }
1101 
1102   TRACE_jvmci_2(&quot;Recording scope pc_offset=%d bci=%d method=%s&quot;, pc_offset, bci, method-&gt;name_and_sig_as_C_string());
1103 
1104   bool reexecute = false;
1105   if (frame.is_non_null()) {
1106     if (bci &lt; 0){
1107        reexecute = false;
1108     } else {
1109       Bytecodes::Code code = Bytecodes::java_code_at(method(), method-&gt;bcp_from(bci));
1110       reexecute = bytecode_should_reexecute(code);
1111       if (frame.is_non_null()) {
1112         reexecute = (jvmci_env()-&gt;get_BytecodeFrame_duringCall(frame) == JNI_FALSE);
1113       }
1114     }
1115   }
1116 
1117   DebugToken* locals_token = NULL;
1118   DebugToken* expressions_token = NULL;
1119   DebugToken* monitors_token = NULL;
1120   bool throw_exception = false;
1121 
1122   if (frame.is_non_null()) {
1123     jint local_count = jvmci_env()-&gt;get_BytecodeFrame_numLocals(frame);
1124     jint expression_count = jvmci_env()-&gt;get_BytecodeFrame_numStack(frame);
1125     jint monitor_count = jvmci_env()-&gt;get_BytecodeFrame_numLocks(frame);
1126     JVMCIObjectArray values = jvmci_env()-&gt;get_BytecodeFrame_values(frame);
1127     JVMCIObjectArray slotKinds = jvmci_env()-&gt;get_BytecodeFrame_slotKinds(frame);
1128 
1129     if (values.is_null() || slotKinds.is_null()) {
1130       JVMCI_THROW(NullPointerException);
1131     }
1132     if (local_count + expression_count + monitor_count != JVMCIENV-&gt;get_length(values)) {
1133       JVMCI_ERROR(&quot;unexpected values length %d in scope (%d locals, %d expressions, %d monitors)&quot;, JVMCIENV-&gt;get_length(values), local_count, expression_count, monitor_count);
1134     }
1135     if (local_count + expression_count != JVMCIENV-&gt;get_length(slotKinds)) {
1136       JVMCI_ERROR(&quot;unexpected slotKinds length %d in scope (%d locals, %d expressions)&quot;, JVMCIENV-&gt;get_length(slotKinds), local_count, expression_count);
1137     }
1138 
1139     GrowableArray&lt;ScopeValue*&gt;* locals = local_count &gt; 0 ? new GrowableArray&lt;ScopeValue*&gt; (local_count) : NULL;
1140     GrowableArray&lt;ScopeValue*&gt;* expressions = expression_count &gt; 0 ? new GrowableArray&lt;ScopeValue*&gt; (expression_count) : NULL;
1141     GrowableArray&lt;MonitorValue*&gt;* monitors = monitor_count &gt; 0 ? new GrowableArray&lt;MonitorValue*&gt; (monitor_count) : NULL;
1142 
1143     TRACE_jvmci_2(&quot;Scope at bci %d with %d values&quot;, bci, JVMCIENV-&gt;get_length(values));
1144     TRACE_jvmci_2(&quot;%d locals %d expressions, %d monitors&quot;, local_count, expression_count, monitor_count);
1145 
1146     for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(values); i++) {
1147       // HandleMark hm(THREAD);
1148       ScopeValue* second = NULL;
1149       JVMCIObject value = JVMCIENV-&gt;get_object_at(values, i);
1150       if (i &lt; local_count) {
1151         BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);
1152         ScopeValue* first = get_scope_value(value, type, objects, second, JVMCI_CHECK);
1153         if (second != NULL) {
1154           locals-&gt;append(second);
1155         }
1156         locals-&gt;append(first);
1157       } else if (i &lt; local_count + expression_count) {
1158         BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);
1159         ScopeValue* first = get_scope_value(value, type, objects, second, JVMCI_CHECK);
1160         if (second != NULL) {
1161           expressions-&gt;append(second);
1162         }
1163         expressions-&gt;append(first);
1164       } else {
1165         MonitorValue *monitor = get_monitor_value(value, objects, JVMCI_CHECK);
1166         monitors-&gt;append(monitor);
1167       }
1168       if (second != NULL) {
1169         i++;
1170         if (i &gt;= JVMCIENV-&gt;get_length(values) || !JVMCIENV-&gt;equals(JVMCIENV-&gt;get_object_at(values, i), jvmci_env()-&gt;get_Value_ILLEGAL())) {
1171           JVMCI_ERROR(&quot;double-slot value not followed by Value.ILLEGAL&quot;);
1172         }
1173       }
1174     }
1175 
1176     locals_token = _debug_recorder-&gt;create_scope_values(locals);
1177     expressions_token = _debug_recorder-&gt;create_scope_values(expressions);
1178     monitors_token = _debug_recorder-&gt;create_monitor_values(monitors);
1179 
1180     throw_exception = jvmci_env()-&gt;get_BytecodeFrame_rethrowException(frame) == JNI_TRUE;
1181   }
1182 
<a name="1" id="anc1"></a><span class="line-modified">1183   _debug_recorder-&gt;describe_scope(pc_offset, method, NULL, bci, reexecute, throw_exception, false, return_oop,</span>
1184                                   locals_token, expressions_token, monitors_token);
1185 }
1186 
1187 void CodeInstaller::site_Safepoint(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {
1188   JVMCIObject debug_info = jvmci_env()-&gt;get_site_Infopoint_debugInfo(site);
1189   if (debug_info.is_null()) {
1190     JVMCI_ERROR(&quot;debug info expected at safepoint at %i&quot;, pc_offset);
1191   }
1192 
1193   // address instruction = _instructions-&gt;start() + pc_offset;
1194   // jint next_pc_offset = Assembler::locate_next_instruction(instruction) - _instructions-&gt;start();
1195   OopMap *map = create_oop_map(debug_info, JVMCI_CHECK);
1196   _debug_recorder-&gt;add_safepoint(pc_offset, map);
1197   record_scope(pc_offset, debug_info, CodeInstaller::FullFrame, JVMCI_CHECK);
1198   _debug_recorder-&gt;end_safepoint(pc_offset);
1199 }
1200 
1201 void CodeInstaller::site_Infopoint(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {
1202   JVMCIObject debug_info = jvmci_env()-&gt;get_site_Infopoint_debugInfo(site);
1203   if (debug_info.is_null()) {
1204     JVMCI_ERROR(&quot;debug info expected at infopoint at %i&quot;, pc_offset);
1205   }
1206 
1207   // We&#39;d like to check that pc_offset is greater than the
1208   // last pc recorded with _debug_recorder (raising an exception if not)
1209   // but DebugInformationRecorder doesn&#39;t have sufficient public API.
1210 
1211   _debug_recorder-&gt;add_non_safepoint(pc_offset);
1212   record_scope(pc_offset, debug_info, CodeInstaller::BytecodePosition, JVMCI_CHECK);
1213   _debug_recorder-&gt;end_non_safepoint(pc_offset);
1214 }
1215 
1216 void CodeInstaller::site_Call(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {
1217   JVMCIObject target = jvmci_env()-&gt;get_site_Call_target(site);
1218   JVMCIObject hotspot_method; // JavaMethod
1219   JVMCIObject foreign_call;
1220 
1221   if (jvmci_env()-&gt;isa_HotSpotForeignCallTarget(target)) {
1222     foreign_call = target;
1223   } else {
1224     hotspot_method = target;
1225   }
1226 
1227   JVMCIObject debug_info = jvmci_env()-&gt;get_site_Infopoint_debugInfo(site);
1228 
1229   assert(hotspot_method.is_non_null() ^ foreign_call.is_non_null(), &quot;Call site needs exactly one type&quot;);
1230 
1231   NativeInstruction* inst = nativeInstruction_at(_instructions-&gt;start() + pc_offset);
1232   jint next_pc_offset = CodeInstaller::pd_next_offset(inst, pc_offset, hotspot_method, JVMCI_CHECK);
1233 
1234   if (debug_info.is_non_null()) {
1235     OopMap *map = create_oop_map(debug_info, JVMCI_CHECK);
1236     _debug_recorder-&gt;add_safepoint(next_pc_offset, map);
1237 
1238     bool return_oop = hotspot_method.is_non_null() &amp;&amp; jvmci_env()-&gt;asMethod(hotspot_method)-&gt;is_returning_oop();
1239 
1240     record_scope(next_pc_offset, debug_info, CodeInstaller::FullFrame, return_oop, JVMCI_CHECK);
1241   }
1242 
1243   if (foreign_call.is_non_null()) {
1244     jlong foreign_call_destination = jvmci_env()-&gt;get_HotSpotForeignCallTarget_address(foreign_call);
1245     if (_immutable_pic_compilation) {
1246       // Use fake short distance during PIC compilation.
1247       foreign_call_destination = (jlong)(_instructions-&gt;start() + pc_offset);
1248     }
1249     CodeInstaller::pd_relocate_ForeignCall(inst, foreign_call_destination, JVMCI_CHECK);
1250   } else { // method != NULL
1251     if (debug_info.is_null()) {
1252       JVMCI_ERROR(&quot;debug info expected at call at %i&quot;, pc_offset);
1253     }
1254 
1255     TRACE_jvmci_3(&quot;method call&quot;);
1256     CodeInstaller::pd_relocate_JavaMethod(buffer, hotspot_method, pc_offset, JVMCI_CHECK);
1257     if (_next_call_type == INVOKESTATIC || _next_call_type == INVOKESPECIAL) {
1258       // Need a static call stub for transitions from compiled to interpreted.
1259       CompiledStaticCall::emit_to_interp_stub(buffer, _instructions-&gt;start() + pc_offset);
1260     }
1261 #if INCLUDE_AOT
1262     // Trampoline to far aot code.
1263     CompiledStaticCall::emit_to_aot_stub(buffer, _instructions-&gt;start() + pc_offset);
1264 #endif
1265   }
1266 
1267   _next_call_type = INVOKE_INVALID;
1268 
1269   if (debug_info.is_non_null()) {
1270     _debug_recorder-&gt;end_safepoint(next_pc_offset);
1271   }
1272 }
1273 
1274 void CodeInstaller::site_DataPatch(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {
1275   JVMCIObject reference = jvmci_env()-&gt;get_site_DataPatch_reference(site);
1276   if (reference.is_null()) {
1277     JVMCI_THROW(NullPointerException);
1278   } else if (jvmci_env()-&gt;isa_site_ConstantReference(reference)) {
1279     JVMCIObject constant = jvmci_env()-&gt;get_site_ConstantReference_constant(reference);
1280     if (constant.is_null()) {
1281       JVMCI_THROW(NullPointerException);
1282     } else if (jvmci_env()-&gt;isa_DirectHotSpotObjectConstantImpl(constant)) {
1283       if (!JVMCIENV-&gt;is_hotspot()) {
1284         JVMCIObject string = JVMCIENV-&gt;call_HotSpotJVMCIRuntime_callToString(constant, JVMCI_CHECK);
1285         const char* to_string = JVMCIENV-&gt;as_utf8_string(string);
1286         JVMCI_THROW_MSG(IllegalArgumentException, err_msg(&quot;Direct object constant reached the backend: %s&quot;, to_string));
1287       }
1288       if (!_immutable_pic_compilation) {
1289         // Do not patch during PIC compilation.
1290         pd_patch_OopConstant(pc_offset, constant, JVMCI_CHECK);
1291       }
1292     } else if (jvmci_env()-&gt;isa_IndirectHotSpotObjectConstantImpl(constant)) {
1293       if (!_immutable_pic_compilation) {
1294         // Do not patch during PIC compilation.
1295         pd_patch_OopConstant(pc_offset, constant, JVMCI_CHECK);
1296       }
1297     } else if (jvmci_env()-&gt;isa_HotSpotMetaspaceConstantImpl(constant)) {
1298       if (!_immutable_pic_compilation) {
1299         pd_patch_MetaspaceConstant(pc_offset, constant, JVMCI_CHECK);
1300       }
1301 #if INCLUDE_AOT
1302     } else if (jvmci_env()-&gt;isa_HotSpotSentinelConstant(constant)) {
1303       if (!_immutable_pic_compilation) {
1304         JVMCI_ERROR(&quot;sentinel constant not supported for normal compiles: %s&quot;, jvmci_env()-&gt;klass_name(constant));
1305       }
1306 #endif
1307     } else {
1308       JVMCI_ERROR(&quot;unknown constant type in data patch: %s&quot;, jvmci_env()-&gt;klass_name(constant));
1309     }
1310   } else if (jvmci_env()-&gt;isa_site_DataSectionReference(reference)) {
1311     int data_offset = jvmci_env()-&gt;get_site_DataSectionReference_offset(reference);
1312     if (0 &lt;= data_offset &amp;&amp; data_offset &lt; _constants_size) {
1313       pd_patch_DataSectionReference(pc_offset, data_offset, JVMCI_CHECK);
1314     } else {
1315       JVMCI_ERROR(&quot;data offset 0x%X points outside data section (size 0x%X)&quot;, data_offset, _constants_size);
1316     }
1317   } else {
1318     JVMCI_ERROR(&quot;unknown data patch type: %s&quot;, jvmci_env()-&gt;klass_name(reference));
1319   }
1320 }
1321 
1322 void CodeInstaller::site_Mark(CodeBuffer&amp; buffer, jint pc_offset, JVMCIObject site, JVMCI_TRAPS) {
1323   JVMCIObject id_obj = jvmci_env()-&gt;get_site_Mark_id(site);
1324 
1325   if (id_obj.is_non_null()) {
1326     if (!jvmci_env()-&gt;is_boxing_object(T_INT, id_obj)) {
1327       JVMCI_ERROR(&quot;expected Integer id, got %s&quot;, jvmci_env()-&gt;klass_name(id_obj));
1328     }
1329     jint id = jvmci_env()-&gt;get_boxed_value(T_INT, id_obj).i;
1330 
1331     address pc = _instructions-&gt;start() + pc_offset;
1332 
1333     switch (id) {
1334       case UNVERIFIED_ENTRY:
1335         _offsets.set_value(CodeOffsets::Entry, pc_offset);
1336         break;
1337       case VERIFIED_ENTRY:
1338         _offsets.set_value(CodeOffsets::Verified_Entry, pc_offset);
<a name="2" id="anc2"></a>

1339         break;
1340       case OSR_ENTRY:
1341         _offsets.set_value(CodeOffsets::OSR_Entry, pc_offset);
1342         break;
1343       case EXCEPTION_HANDLER_ENTRY:
1344         _offsets.set_value(CodeOffsets::Exceptions, pc_offset);
1345         break;
1346       case DEOPT_HANDLER_ENTRY:
1347         _offsets.set_value(CodeOffsets::Deopt, pc_offset);
1348         break;
1349       case FRAME_COMPLETE:
1350         _offsets.set_value(CodeOffsets::Frame_Complete, pc_offset);
1351         break;
1352       case INVOKEVIRTUAL:
1353       case INVOKEINTERFACE:
1354       case INLINE_INVOKE:
1355       case INVOKESTATIC:
1356       case INVOKESPECIAL:
1357         _next_call_type = (MarkId) id;
1358         _invoke_mark_pc = pc;
1359         break;
1360       case POLL_NEAR:
1361       case POLL_FAR:
1362       case POLL_RETURN_NEAR:
1363       case POLL_RETURN_FAR:
1364         pd_relocate_poll(pc, id, JVMCI_CHECK);
1365         break;
1366       case CARD_TABLE_SHIFT:
1367       case CARD_TABLE_ADDRESS:
1368       case HEAP_TOP_ADDRESS:
1369       case HEAP_END_ADDRESS:
1370       case NARROW_KLASS_BASE_ADDRESS:
1371       case NARROW_OOP_BASE_ADDRESS:
1372       case CRC_TABLE_ADDRESS:
1373       case LOG_OF_HEAP_REGION_GRAIN_BYTES:
1374       case INLINE_CONTIGUOUS_ALLOCATION_SUPPORTED:
1375         break;
1376       default:
1377         JVMCI_ERROR(&quot;invalid mark id: %d&quot;, id);
1378         break;
1379     }
1380   }
1381 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
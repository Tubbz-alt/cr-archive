<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 546       if (scratch_i != *merge_cp_length_p) {
 547         // The new entry in *merge_cp_p is at a different index than
 548         // the new entry in scratch_cp so we need to map the index values.
 549         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 550       }
 551       (*merge_cp_length_p)++;
 552     } break;
 553 
 554     // At this stage, Class or UnresolvedClass could be in scratch_cp, but not
 555     // ClassIndex
 556     case JVM_CONSTANT_ClassIndex: // fall through
 557 
 558     // Invalid is used as the tag for the second constant pool entry
 559     // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
 560     // not be seen by itself.
 561     case JVM_CONSTANT_Invalid: // fall through
 562 
 563     // At this stage, String could be here, but not StringIndex
 564     case JVM_CONSTANT_StringIndex: // fall through
 565 
<span class="line-modified"> 566     // At this stage JVM_CONSTANT_UnresolvedClassInError should not be</span>
<span class="line-removed"> 567     // here</span>
 568     case JVM_CONSTANT_UnresolvedClassInError: // fall through
 569 
 570     default:
 571     {
 572       // leave a breadcrumb
 573       jbyte bad_value = scratch_cp-&gt;tag_at(scratch_i).value();
 574       ShouldNotReachHere();
 575     } break;
 576   } // end switch tag value
 577 } // end append_entry()
 578 
 579 
 580 int VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle&amp; scratch_cp,
 581       int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 582 
 583   int new_ref_i = ref_i;
 584   bool match = (ref_i &lt; *merge_cp_length_p) &amp;&amp;
 585                scratch_cp-&gt;compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);
 586 
 587   if (!match) {
</pre>
</td>
<td>
<hr />
<pre>
 546       if (scratch_i != *merge_cp_length_p) {
 547         // The new entry in *merge_cp_p is at a different index than
 548         // the new entry in scratch_cp so we need to map the index values.
 549         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 550       }
 551       (*merge_cp_length_p)++;
 552     } break;
 553 
 554     // At this stage, Class or UnresolvedClass could be in scratch_cp, but not
 555     // ClassIndex
 556     case JVM_CONSTANT_ClassIndex: // fall through
 557 
 558     // Invalid is used as the tag for the second constant pool entry
 559     // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
 560     // not be seen by itself.
 561     case JVM_CONSTANT_Invalid: // fall through
 562 
 563     // At this stage, String could be here, but not StringIndex
 564     case JVM_CONSTANT_StringIndex: // fall through
 565 
<span class="line-modified"> 566     // At this stage JVM_CONSTANT_UnresolvedClassInError should not be here</span>

 567     case JVM_CONSTANT_UnresolvedClassInError: // fall through
 568 
 569     default:
 570     {
 571       // leave a breadcrumb
 572       jbyte bad_value = scratch_cp-&gt;tag_at(scratch_i).value();
 573       ShouldNotReachHere();
 574     } break;
 575   } // end switch tag value
 576 } // end append_entry()
 577 
 578 
 579 int VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle&amp; scratch_cp,
 580       int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 581 
 582   int new_ref_i = ref_i;
 583   bool match = (ref_i &lt; *merge_cp_length_p) &amp;&amp;
 584                scratch_cp-&gt;compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);
 585 
 586   if (!match) {
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
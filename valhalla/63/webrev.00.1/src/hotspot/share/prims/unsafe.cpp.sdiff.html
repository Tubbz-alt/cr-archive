<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/unsafe.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="methodHandles.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="whitebox.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/unsafe.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;jfr/jfrEvents.hpp&quot;
  32 #include &quot;memory/allocation.inline.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;


  34 #include &quot;oops/access.inline.hpp&quot;
  35 #include &quot;oops/fieldStreams.inline.hpp&quot;
  36 #include &quot;oops/objArrayOop.inline.hpp&quot;
  37 #include &quot;oops/oop.inline.hpp&quot;
  38 #include &quot;oops/typeArrayOop.inline.hpp&quot;



  39 #include &quot;prims/unsafe.hpp&quot;

  40 #include &quot;runtime/globals.hpp&quot;
  41 #include &quot;runtime/handles.inline.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/jniHandles.inline.hpp&quot;
  44 #include &quot;runtime/orderAccess.hpp&quot;
  45 #include &quot;runtime/reflection.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;runtime/thread.hpp&quot;
  48 #include &quot;runtime/threadSMR.hpp&quot;
  49 #include &quot;runtime/vm_version.hpp&quot;
  50 #include &quot;services/threadService.hpp&quot;
  51 #include &quot;utilities/align.hpp&quot;
  52 #include &quot;utilities/copy.hpp&quot;
  53 #include &quot;utilities/dtrace.hpp&quot;
  54 #include &quot;utilities/macros.hpp&quot;
  55 
  56 /**
  57  * Implementation of the jdk.internal.misc.Unsafe class
  58  */
  59 
</pre>
<hr />
<pre>
 128   if (p != NULL) {
 129     p = Access&lt;&gt;::resolve(p);
 130   }
 131 
 132   if (sizeof(char*) == sizeof(jint)) {   // (this constant folds!)
 133     return cast_from_oop&lt;address&gt;(p) + (jint) byte_offset;
 134   } else {
 135     return cast_from_oop&lt;address&gt;(p) +        byte_offset;
 136   }
 137 }
 138 
 139 // Externally callable versions:
 140 // (Use these in compiler intrinsics which emulate unsafe primitives.)
 141 jlong Unsafe_field_offset_to_byte_offset(jlong field_offset) {
 142   return field_offset;
 143 }
 144 jlong Unsafe_field_offset_from_byte_offset(jlong byte_offset) {
 145   return byte_offset;
 146 }
 147 
<span class="line-removed"> 148 </span>
 149 ///// Data read/writes on the Java heap and in native (off-heap) memory
 150 
 151 /**
 152  * Helper class to wrap memory accesses in JavaThread::doing_unsafe_access()
 153  */
 154 class GuardUnsafeAccess {
 155   JavaThread* _thread;
 156 
 157 public:
 158   GuardUnsafeAccess(JavaThread* thread) : _thread(thread) {
 159     // native/off-heap access which may raise SIGBUS if accessing
 160     // memory mapped file data in a region of the file which has
 161     // been truncated and is now invalid.
 162     _thread-&gt;set_doing_unsafe_access(true);
 163   }
 164 
 165   ~GuardUnsafeAccess() {
 166     _thread-&gt;set_doing_unsafe_access(false);
 167   }
 168 };
</pre>
<hr />
<pre>
 213     : _thread(thread), _obj(JNIHandles::resolve(obj)), _offset((ptrdiff_t)offset) {
 214     assert_field_offset_sane(_obj, offset);
 215   }
 216 
 217   T get() {
 218     if (_obj == NULL) {
 219       GuardUnsafeAccess guard(_thread);
 220       T ret = RawAccess&lt;&gt;::load(addr());
 221       return normalize_for_read(ret);
 222     } else {
 223       T ret = HeapAccess&lt;&gt;::load_at(_obj, _offset);
 224       return normalize_for_read(ret);
 225     }
 226   }
 227 
 228   void put(T x) {
 229     if (_obj == NULL) {
 230       GuardUnsafeAccess guard(_thread);
 231       RawAccess&lt;&gt;::store(addr(), normalize_for_write(x));
 232     } else {

 233       HeapAccess&lt;&gt;::store_at(_obj, _offset, normalize_for_write(x));
 234     }
 235   }
 236 
<span class="line-removed"> 237 </span>
 238   T get_volatile() {
 239     if (_obj == NULL) {
 240       GuardUnsafeAccess guard(_thread);
 241       volatile T ret = RawAccess&lt;MO_SEQ_CST&gt;::load(addr());
 242       return normalize_for_read(ret);
 243     } else {
 244       T ret = HeapAccess&lt;MO_SEQ_CST&gt;::load_at(_obj, _offset);
 245       return normalize_for_read(ret);
 246     }
 247   }
 248 
 249   void put_volatile(T x) {
 250     if (_obj == NULL) {
 251       GuardUnsafeAccess guard(_thread);
 252       RawAccess&lt;MO_SEQ_CST&gt;::store(addr(), normalize_for_write(x));
 253     } else {
 254       HeapAccess&lt;MO_SEQ_CST&gt;::store_at(_obj, _offset, normalize_for_write(x));
 255     }
 256   }
 257 };
 258 






























































 259 // These functions allow a null base pointer with an arbitrary address.
 260 // But if the base pointer is non-null, the offset should make some sense.
 261 // That is, it should be in the range [0, MAX_OBJECT_SIZE].
 262 UNSAFE_ENTRY(jobject, Unsafe_GetReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 263   oop p = JNIHandles::resolve(obj);
 264   assert_field_offset_sane(p, offset);
 265   oop v = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(p, offset);
 266   return JNIHandles::make_local(env, v);
 267 } UNSAFE_END
 268 
 269 UNSAFE_ENTRY(void, Unsafe_PutReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 270   oop x = JNIHandles::resolve(x_h);
 271   oop p = JNIHandles::resolve(obj);
 272   assert_field_offset_sane(p, offset);

 273   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 274 } UNSAFE_END
 275 


























































 276 UNSAFE_ENTRY(jobject, Unsafe_GetReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 277   oop p = JNIHandles::resolve(obj);
 278   assert_field_offset_sane(p, offset);
 279   oop v = HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_load_at(p, offset);
 280   return JNIHandles::make_local(env, v);
 281 } UNSAFE_END
 282 
 283 UNSAFE_ENTRY(void, Unsafe_PutReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 284   oop x = JNIHandles::resolve(x_h);
 285   oop p = JNIHandles::resolve(obj);
 286   assert_field_offset_sane(p, offset);
 287   HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 288 } UNSAFE_END
 289 
 290 UNSAFE_ENTRY(jobject, Unsafe_GetUncompressedObject(JNIEnv *env, jobject unsafe, jlong addr)) {
 291   oop v = *(oop*) (address) addr;
 292   return JNIHandles::make_local(env, v);
 293 } UNSAFE_END
 294 
 295 #define DEFINE_GETSETOOP(java_type, Type) \
</pre>
<hr />
<pre>
 592   return false;
 593 }
 594 UNSAFE_END
 595 
 596 static void getBaseAndScale(int&amp; base, int&amp; scale, jclass clazz, TRAPS) {
 597   assert(clazz != NULL, &quot;clazz must not be NULL&quot;);
 598 
 599   oop mirror = JNIHandles::resolve_non_null(clazz);
 600   Klass* k = java_lang_Class::as_Klass(mirror);
 601 
 602   if (k == NULL || !k-&gt;is_array_klass()) {
 603     THROW(vmSymbols::java_lang_InvalidClassException());
 604   } else if (k-&gt;is_objArray_klass()) {
 605     base  = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
 606     scale = heapOopSize;
 607   } else if (k-&gt;is_typeArray_klass()) {
 608     TypeArrayKlass* tak = TypeArrayKlass::cast(k);
 609     base  = tak-&gt;array_header_in_bytes();
 610     assert(base == arrayOopDesc::base_offset_in_bytes(tak-&gt;element_type()), &quot;array_header_size semantics ok&quot;);
 611     scale = (1 &lt;&lt; tak-&gt;log2_element_size());





 612   } else {
 613     ShouldNotReachHere();
 614   }
 615 }
 616 
 617 UNSAFE_ENTRY(jint, Unsafe_ArrayBaseOffset0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 618   int base = 0, scale = 0;
 619   getBaseAndScale(base, scale, clazz, CHECK_0);
 620 
 621   return field_offset_from_byte_offset(base);
 622 } UNSAFE_END
 623 
 624 
 625 UNSAFE_ENTRY(jint, Unsafe_ArrayIndexScale0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 626   int base = 0, scale = 0;
 627   getBaseAndScale(base, scale, clazz, CHECK_0);
 628 
 629   // This VM packs both fields and array elements down to the byte.
 630   // But watch out:  If this changes, so that array references for
 631   // a given primitive type (say, T_BOOLEAN) use different memory units
 632   // than fields, this method MUST return zero for such arrays.
 633   // For example, the VM used to store sub-word sized fields in full
 634   // words in the object layout, so that accessors like getByte(Object,int)
 635   // did not really do what one might expect for arrays.  Therefore,
 636   // this function used to report a zero scale factor, so that the user
 637   // would know not to attempt to access sub-word array elements.
 638   // // Code for unpacked fields:
 639   // if (scale &lt; wordSize)  return 0;
 640 
 641   // The following allows for a pretty general fieldOffset cookie scheme,
 642   // but requires it to be linear in byte offset.
 643   return field_offset_from_byte_offset(scale) - field_offset_from_byte_offset(0);
 644 } UNSAFE_END
 645 
 646 






 647 static inline void throw_new(JNIEnv *env, const char *ename) {
 648   jclass cls = env-&gt;FindClass(ename);
 649   if (env-&gt;ExceptionCheck()) {
 650     env-&gt;ExceptionClear();
 651     tty-&gt;print_cr(&quot;Unsafe: cannot throw %s because FindClass has failed&quot;, ename);
 652     return;
 653   }
 654 
 655   env-&gt;ThrowNew(cls, NULL);
 656 }
 657 
 658 static jclass Unsafe_DefineClass_impl(JNIEnv *env, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd) {
 659   // Code lifted from JDK 1.3 ClassLoader.c
 660 
 661   jbyte *body;
 662   char *utfName = NULL;
 663   jclass result = 0;
 664   char buf[128];
 665 
 666   assert(data != NULL, &quot;Class bytes must not be NULL&quot;);
</pre>
<hr />
<pre>
1051 
1052 
1053 /// JVM_RegisterUnsafeMethods
1054 
1055 #define ADR &quot;J&quot;
1056 
1057 #define LANG &quot;Ljava/lang/&quot;
1058 
1059 #define OBJ LANG &quot;Object;&quot;
1060 #define CLS LANG &quot;Class;&quot;
1061 #define FLD LANG &quot;reflect/Field;&quot;
1062 #define THR LANG &quot;Throwable;&quot;
1063 
1064 #define DC_Args  LANG &quot;String;[BII&quot; LANG &quot;ClassLoader;&quot; &quot;Ljava/security/ProtectionDomain;&quot;
1065 #define DAC_Args CLS &quot;[B[&quot; OBJ
1066 
1067 #define CC (char*)  /*cast a literal from (const char*)*/
1068 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
1069 
1070 #define DECLARE_GETPUTOOP(Type, Desc) \
<span class="line-modified">1071     {CC &quot;get&quot; #Type,      CC &quot;(&quot; OBJ &quot;J)&quot; #Desc,       FN_PTR(Unsafe_Get##Type)}, \</span>
<span class="line-modified">1072     {CC &quot;put&quot; #Type,      CC &quot;(&quot; OBJ &quot;J&quot; #Desc &quot;)V&quot;,   FN_PTR(Unsafe_Put##Type)}, \</span>
<span class="line-modified">1073     {CC &quot;get&quot; #Type &quot;Volatile&quot;,      CC &quot;(&quot; OBJ &quot;J)&quot; #Desc,       FN_PTR(Unsafe_Get##Type##Volatile)}, \</span>
<span class="line-modified">1074     {CC &quot;put&quot; #Type &quot;Volatile&quot;,      CC &quot;(&quot; OBJ &quot;J&quot; #Desc &quot;)V&quot;,   FN_PTR(Unsafe_Put##Type##Volatile)}</span>
1075 
1076 
1077 static JNINativeMethod jdk_internal_misc_Unsafe_methods[] = {
1078     {CC &quot;getReference&quot;,         CC &quot;(&quot; OBJ &quot;J)&quot; OBJ &quot;&quot;,   FN_PTR(Unsafe_GetReference)},
1079     {CC &quot;putReference&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;)V&quot;,  FN_PTR(Unsafe_PutReference)},
1080     {CC &quot;getReferenceVolatile&quot;, CC &quot;(&quot; OBJ &quot;J)&quot; OBJ,      FN_PTR(Unsafe_GetReferenceVolatile)},
1081     {CC &quot;putReferenceVolatile&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;)V&quot;,  FN_PTR(Unsafe_PutReferenceVolatile)},
1082 








1083     {CC &quot;getUncompressedObject&quot;, CC &quot;(&quot; ADR &quot;)&quot; OBJ,  FN_PTR(Unsafe_GetUncompressedObject)},
1084 
1085     DECLARE_GETPUTOOP(Boolean, Z),
1086     DECLARE_GETPUTOOP(Byte, B),
1087     DECLARE_GETPUTOOP(Short, S),
1088     DECLARE_GETPUTOOP(Char, C),
1089     DECLARE_GETPUTOOP(Int, I),
1090     DECLARE_GETPUTOOP(Long, J),
1091     DECLARE_GETPUTOOP(Float, F),
1092     DECLARE_GETPUTOOP(Double, D),
1093 
1094     {CC &quot;allocateMemory0&quot;,    CC &quot;(J)&quot; ADR,              FN_PTR(Unsafe_AllocateMemory0)},
1095     {CC &quot;reallocateMemory0&quot;,  CC &quot;(&quot; ADR &quot;J)&quot; ADR,       FN_PTR(Unsafe_ReallocateMemory0)},
1096     {CC &quot;freeMemory0&quot;,        CC &quot;(&quot; ADR &quot;)V&quot;,           FN_PTR(Unsafe_FreeMemory0)},
1097 
1098     {CC &quot;objectFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_ObjectFieldOffset0)},
1099     {CC &quot;objectFieldOffset1&quot;, CC &quot;(&quot; CLS LANG &quot;String;)J&quot;, FN_PTR(Unsafe_ObjectFieldOffset1)},
1100     {CC &quot;staticFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_StaticFieldOffset0)},
1101     {CC &quot;staticFieldBase0&quot;,   CC &quot;(&quot; FLD &quot;)&quot; OBJ,        FN_PTR(Unsafe_StaticFieldBase0)},
1102     {CC &quot;ensureClassInitialized0&quot;, CC &quot;(&quot; CLS &quot;)V&quot;,      FN_PTR(Unsafe_EnsureClassInitialized0)},
1103     {CC &quot;arrayBaseOffset0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayBaseOffset0)},
1104     {CC &quot;arrayIndexScale0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayIndexScale0)},

1105 
1106     {CC &quot;defineClass0&quot;,       CC &quot;(&quot; DC_Args &quot;)&quot; CLS,    FN_PTR(Unsafe_DefineClass0)},
1107     {CC &quot;allocateInstance&quot;,   CC &quot;(&quot; CLS &quot;)&quot; OBJ,        FN_PTR(Unsafe_AllocateInstance)},
1108     {CC &quot;throwException&quot;,     CC &quot;(&quot; THR &quot;)V&quot;,           FN_PTR(Unsafe_ThrowException)},
1109     {CC &quot;compareAndSetReference&quot;,CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)Z&quot;, FN_PTR(Unsafe_CompareAndSetReference)},
1110     {CC &quot;compareAndSetInt&quot;,   CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetInt)},
1111     {CC &quot;compareAndSetLong&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetLong)},
1112     {CC &quot;compareAndExchangeReference&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)&quot; OBJ, FN_PTR(Unsafe_CompareAndExchangeReference)},
1113     {CC &quot;compareAndExchangeInt&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)I&quot;, FN_PTR(Unsafe_CompareAndExchangeInt)},
1114     {CC &quot;compareAndExchangeLong&quot;, CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)J&quot;, FN_PTR(Unsafe_CompareAndExchangeLong)},
1115 
1116     {CC &quot;park&quot;,               CC &quot;(ZJ)V&quot;,                FN_PTR(Unsafe_Park)},
1117     {CC &quot;unpark&quot;,             CC &quot;(&quot; OBJ &quot;)V&quot;,           FN_PTR(Unsafe_Unpark)},
1118 
1119     {CC &quot;getLoadAverage0&quot;,    CC &quot;([DI)I&quot;,               FN_PTR(Unsafe_GetLoadAverage0)},
1120 
1121     {CC &quot;copyMemory0&quot;,        CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJ)V&quot;, FN_PTR(Unsafe_CopyMemory0)},
1122     {CC &quot;copySwapMemory0&quot;,    CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJJ)V&quot;, FN_PTR(Unsafe_CopySwapMemory0)},
1123     {CC &quot;writeback0&quot;,         CC &quot;(&quot; &quot;J&quot; &quot;)V&quot;,           FN_PTR(Unsafe_WriteBack0)},
1124     {CC &quot;writebackPreSync0&quot;,  CC &quot;()V&quot;,                  FN_PTR(Unsafe_WriteBackPreSync0)},
</pre>
</td>
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jni.h&quot;
  27 #include &quot;jvm.h&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;jfr/jfrEvents.hpp&quot;
  32 #include &quot;memory/allocation.inline.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  34 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added">  35 #include &quot;logging/logStream.hpp&quot;</span>
  36 #include &quot;oops/access.inline.hpp&quot;
  37 #include &quot;oops/fieldStreams.inline.hpp&quot;
  38 #include &quot;oops/objArrayOop.inline.hpp&quot;
  39 #include &quot;oops/oop.inline.hpp&quot;
  40 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  41 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  42 #include &quot;oops/valueArrayOop.inline.hpp&quot;</span>
<span class="line-added">  43 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  44 #include &quot;prims/unsafe.hpp&quot;
<span class="line-added">  45 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;</span>
  46 #include &quot;runtime/globals.hpp&quot;
  47 #include &quot;runtime/handles.inline.hpp&quot;
  48 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  49 #include &quot;runtime/jniHandles.inline.hpp&quot;
  50 #include &quot;runtime/orderAccess.hpp&quot;
  51 #include &quot;runtime/reflection.hpp&quot;
  52 #include &quot;runtime/sharedRuntime.hpp&quot;
  53 #include &quot;runtime/thread.hpp&quot;
  54 #include &quot;runtime/threadSMR.hpp&quot;
  55 #include &quot;runtime/vm_version.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/copy.hpp&quot;
  59 #include &quot;utilities/dtrace.hpp&quot;
  60 #include &quot;utilities/macros.hpp&quot;
  61 
  62 /**
  63  * Implementation of the jdk.internal.misc.Unsafe class
  64  */
  65 
</pre>
<hr />
<pre>
 134   if (p != NULL) {
 135     p = Access&lt;&gt;::resolve(p);
 136   }
 137 
 138   if (sizeof(char*) == sizeof(jint)) {   // (this constant folds!)
 139     return cast_from_oop&lt;address&gt;(p) + (jint) byte_offset;
 140   } else {
 141     return cast_from_oop&lt;address&gt;(p) +        byte_offset;
 142   }
 143 }
 144 
 145 // Externally callable versions:
 146 // (Use these in compiler intrinsics which emulate unsafe primitives.)
 147 jlong Unsafe_field_offset_to_byte_offset(jlong field_offset) {
 148   return field_offset;
 149 }
 150 jlong Unsafe_field_offset_from_byte_offset(jlong byte_offset) {
 151   return byte_offset;
 152 }
 153 

 154 ///// Data read/writes on the Java heap and in native (off-heap) memory
 155 
 156 /**
 157  * Helper class to wrap memory accesses in JavaThread::doing_unsafe_access()
 158  */
 159 class GuardUnsafeAccess {
 160   JavaThread* _thread;
 161 
 162 public:
 163   GuardUnsafeAccess(JavaThread* thread) : _thread(thread) {
 164     // native/off-heap access which may raise SIGBUS if accessing
 165     // memory mapped file data in a region of the file which has
 166     // been truncated and is now invalid.
 167     _thread-&gt;set_doing_unsafe_access(true);
 168   }
 169 
 170   ~GuardUnsafeAccess() {
 171     _thread-&gt;set_doing_unsafe_access(false);
 172   }
 173 };
</pre>
<hr />
<pre>
 218     : _thread(thread), _obj(JNIHandles::resolve(obj)), _offset((ptrdiff_t)offset) {
 219     assert_field_offset_sane(_obj, offset);
 220   }
 221 
 222   T get() {
 223     if (_obj == NULL) {
 224       GuardUnsafeAccess guard(_thread);
 225       T ret = RawAccess&lt;&gt;::load(addr());
 226       return normalize_for_read(ret);
 227     } else {
 228       T ret = HeapAccess&lt;&gt;::load_at(_obj, _offset);
 229       return normalize_for_read(ret);
 230     }
 231   }
 232 
 233   void put(T x) {
 234     if (_obj == NULL) {
 235       GuardUnsafeAccess guard(_thread);
 236       RawAccess&lt;&gt;::store(addr(), normalize_for_write(x));
 237     } else {
<span class="line-added"> 238       assert(!_obj-&gt;is_value() || _obj-&gt;mark().is_larval_state(), &quot;must be an object instance or a larval value&quot;);</span>
 239       HeapAccess&lt;&gt;::store_at(_obj, _offset, normalize_for_write(x));
 240     }
 241   }
 242 

 243   T get_volatile() {
 244     if (_obj == NULL) {
 245       GuardUnsafeAccess guard(_thread);
 246       volatile T ret = RawAccess&lt;MO_SEQ_CST&gt;::load(addr());
 247       return normalize_for_read(ret);
 248     } else {
 249       T ret = HeapAccess&lt;MO_SEQ_CST&gt;::load_at(_obj, _offset);
 250       return normalize_for_read(ret);
 251     }
 252   }
 253 
 254   void put_volatile(T x) {
 255     if (_obj == NULL) {
 256       GuardUnsafeAccess guard(_thread);
 257       RawAccess&lt;MO_SEQ_CST&gt;::store(addr(), normalize_for_write(x));
 258     } else {
 259       HeapAccess&lt;MO_SEQ_CST&gt;::store_at(_obj, _offset, normalize_for_write(x));
 260     }
 261   }
 262 };
 263 
<span class="line-added"> 264 #ifdef ASSERT</span>
<span class="line-added"> 265 /*</span>
<span class="line-added"> 266  * Get the field descriptor of the field of the given object at the given offset.</span>
<span class="line-added"> 267  */</span>
<span class="line-added"> 268 static bool get_field_descriptor(oop p, jlong offset, fieldDescriptor* fd) {</span>
<span class="line-added"> 269   bool found = false;</span>
<span class="line-added"> 270   Klass* k = p-&gt;klass();</span>
<span class="line-added"> 271   if (k-&gt;is_instance_klass()) {</span>
<span class="line-added"> 272     InstanceKlass* ik = InstanceKlass::cast(k);</span>
<span class="line-added"> 273     found = ik-&gt;find_field_from_offset((int)offset, false, fd);</span>
<span class="line-added"> 274     if (!found &amp;&amp; ik-&gt;is_mirror_instance_klass()) {</span>
<span class="line-added"> 275       Klass* k2 = java_lang_Class::as_Klass(p);</span>
<span class="line-added"> 276       if (k2-&gt;is_instance_klass()) {</span>
<span class="line-added"> 277         ik = InstanceKlass::cast(k2);</span>
<span class="line-added"> 278         found = ik-&gt;find_field_from_offset((int)offset, true, fd);</span>
<span class="line-added"> 279       }</span>
<span class="line-added"> 280     }</span>
<span class="line-added"> 281   }</span>
<span class="line-added"> 282   return found;</span>
<span class="line-added"> 283 }</span>
<span class="line-added"> 284 #endif // ASSERT</span>
<span class="line-added"> 285 </span>
<span class="line-added"> 286 static void assert_and_log_unsafe_value_access(oop p, jlong offset, ValueKlass* vk) {</span>
<span class="line-added"> 287   Klass* k = p-&gt;klass();</span>
<span class="line-added"> 288 #ifdef ASSERT</span>
<span class="line-added"> 289   if (k-&gt;is_instance_klass()) {</span>
<span class="line-added"> 290     assert_field_offset_sane(p, offset);</span>
<span class="line-added"> 291     fieldDescriptor fd;</span>
<span class="line-added"> 292     bool found = get_field_descriptor(p, offset, &amp;fd);</span>
<span class="line-added"> 293     if (found) {</span>
<span class="line-added"> 294       assert(found, &quot;value field not found&quot;);</span>
<span class="line-added"> 295       assert(fd.is_flattened(), &quot;field not flat&quot;);</span>
<span class="line-added"> 296     } else {</span>
<span class="line-added"> 297       if (log_is_enabled(Trace, valuetypes)) {</span>
<span class="line-added"> 298         log_trace(valuetypes)(&quot;not a field in %s at offset &quot; SIZE_FORMAT_HEX,</span>
<span class="line-added"> 299                               p-&gt;klass()-&gt;external_name(), offset);</span>
<span class="line-added"> 300       }</span>
<span class="line-added"> 301     }</span>
<span class="line-added"> 302   } else if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 303     ValueArrayKlass* vak = ValueArrayKlass::cast(k);</span>
<span class="line-added"> 304     int index = (offset - vak-&gt;array_header_in_bytes()) / vak-&gt;element_byte_size();</span>
<span class="line-added"> 305     address dest = (address)((valueArrayOop)p)-&gt;value_at_addr(index, vak-&gt;layout_helper());</span>
<span class="line-added"> 306     assert(dest == (cast_from_oop&lt;address&gt;(p) + offset), &quot;invalid offset&quot;);</span>
<span class="line-added"> 307   } else {</span>
<span class="line-added"> 308     ShouldNotReachHere();</span>
<span class="line-added"> 309   }</span>
<span class="line-added"> 310 #endif // ASSERT</span>
<span class="line-added"> 311   if (log_is_enabled(Trace, valuetypes)) {</span>
<span class="line-added"> 312     if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 313       ValueArrayKlass* vak = ValueArrayKlass::cast(k);</span>
<span class="line-added"> 314       int index = (offset - vak-&gt;array_header_in_bytes()) / vak-&gt;element_byte_size();</span>
<span class="line-added"> 315       address dest = (address)((valueArrayOop)p)-&gt;value_at_addr(index, vak-&gt;layout_helper());</span>
<span class="line-added"> 316       log_trace(valuetypes)(&quot;%s array type %s index %d element size %d offset &quot; SIZE_FORMAT_HEX &quot; at &quot; INTPTR_FORMAT,</span>
<span class="line-added"> 317                             p-&gt;klass()-&gt;external_name(), vak-&gt;external_name(),</span>
<span class="line-added"> 318                             index, vak-&gt;element_byte_size(), offset, p2i(dest));</span>
<span class="line-added"> 319     } else {</span>
<span class="line-added"> 320       log_trace(valuetypes)(&quot;%s field type %s at offset &quot; SIZE_FORMAT_HEX,</span>
<span class="line-added"> 321                             p-&gt;klass()-&gt;external_name(), vk-&gt;external_name(), offset);</span>
<span class="line-added"> 322     }</span>
<span class="line-added"> 323   }</span>
<span class="line-added"> 324 }</span>
<span class="line-added"> 325 </span>
 326 // These functions allow a null base pointer with an arbitrary address.
 327 // But if the base pointer is non-null, the offset should make some sense.
 328 // That is, it should be in the range [0, MAX_OBJECT_SIZE].
 329 UNSAFE_ENTRY(jobject, Unsafe_GetReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 330   oop p = JNIHandles::resolve(obj);
 331   assert_field_offset_sane(p, offset);
 332   oop v = HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_load_at(p, offset);
 333   return JNIHandles::make_local(env, v);
 334 } UNSAFE_END
 335 
 336 UNSAFE_ENTRY(void, Unsafe_PutReference(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 337   oop x = JNIHandles::resolve(x_h);
 338   oop p = JNIHandles::resolve(obj);
 339   assert_field_offset_sane(p, offset);
<span class="line-added"> 340   assert(!p-&gt;is_value() || p-&gt;mark().is_larval_state(), &quot;must be an object instance or a larval value&quot;);</span>
 341   HeapAccess&lt;ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 342 } UNSAFE_END
 343 
<span class="line-added"> 344 UNSAFE_ENTRY(jlong, Unsafe_ValueHeaderSize(JNIEnv *env, jobject unsafe, jclass c)) {</span>
<span class="line-added"> 345   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));</span>
<span class="line-added"> 346   ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="line-added"> 347   return vk-&gt;first_field_offset();</span>
<span class="line-added"> 348 } UNSAFE_END</span>
<span class="line-added"> 349 </span>
<span class="line-added"> 350 UNSAFE_ENTRY(jboolean, Unsafe_IsFlattenedArray(JNIEnv *env, jobject unsafe, jclass c)) {</span>
<span class="line-added"> 351   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(c));</span>
<span class="line-added"> 352   return k-&gt;is_valueArray_klass();</span>
<span class="line-added"> 353 } UNSAFE_END</span>
<span class="line-added"> 354 </span>
<span class="line-added"> 355 UNSAFE_ENTRY(jobject, Unsafe_UninitializedDefaultValue(JNIEnv *env, jobject unsafe, jclass vc)) {</span>
<span class="line-added"> 356   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));</span>
<span class="line-added"> 357   ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="line-added"> 358   oop v = vk-&gt;default_value();</span>
<span class="line-added"> 359   return JNIHandles::make_local(env, v);</span>
<span class="line-added"> 360 } UNSAFE_END</span>
<span class="line-added"> 361 </span>
<span class="line-added"> 362 UNSAFE_ENTRY(jobject, Unsafe_GetValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc)) {</span>
<span class="line-added"> 363   oop base = JNIHandles::resolve(obj);</span>
<span class="line-added"> 364   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));</span>
<span class="line-added"> 365   ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="line-added"> 366   assert_and_log_unsafe_value_access(base, offset, vk);</span>
<span class="line-added"> 367   Handle base_h(THREAD, base);</span>
<span class="line-added"> 368   oop v = vk-&gt;read_flattened_field(base_h(), offset, CHECK_NULL);</span>
<span class="line-added"> 369   return JNIHandles::make_local(env, v);</span>
<span class="line-added"> 370 } UNSAFE_END</span>
<span class="line-added"> 371 </span>
<span class="line-added"> 372 UNSAFE_ENTRY(void, Unsafe_PutValue(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jclass vc, jobject value)) {</span>
<span class="line-added"> 373   oop base = JNIHandles::resolve(obj);</span>
<span class="line-added"> 374   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(vc));</span>
<span class="line-added"> 375   ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="line-added"> 376   assert(!base-&gt;is_value() || base-&gt;mark().is_larval_state(), &quot;must be an object instance or a larval value&quot;);</span>
<span class="line-added"> 377   assert_and_log_unsafe_value_access(base, offset, vk);</span>
<span class="line-added"> 378   oop v = JNIHandles::resolve(value);</span>
<span class="line-added"> 379   vk-&gt;write_flattened_field(base, offset, v, CHECK);</span>
<span class="line-added"> 380 } UNSAFE_END</span>
<span class="line-added"> 381 </span>
<span class="line-added"> 382 UNSAFE_ENTRY(jobject, Unsafe_MakePrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {</span>
<span class="line-added"> 383   oop v = JNIHandles::resolve_non_null(value);</span>
<span class="line-added"> 384   assert(v-&gt;is_value(), &quot;must be a value instance&quot;);</span>
<span class="line-added"> 385   Handle vh(THREAD, v);</span>
<span class="line-added"> 386   ValueKlass* vk = ValueKlass::cast(v-&gt;klass());</span>
<span class="line-added"> 387   instanceOop new_value = vk-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added"> 388   vk-&gt;value_copy_oop_to_new_oop(vh(),  new_value);</span>
<span class="line-added"> 389   markWord mark = new_value-&gt;mark();</span>
<span class="line-added"> 390   new_value-&gt;set_mark(mark.enter_larval_state());</span>
<span class="line-added"> 391   return JNIHandles::make_local(env, new_value);</span>
<span class="line-added"> 392 } UNSAFE_END</span>
<span class="line-added"> 393 </span>
<span class="line-added"> 394 UNSAFE_ENTRY(jobject, Unsafe_FinishPrivateBuffer(JNIEnv *env, jobject unsafe, jobject value)) {</span>
<span class="line-added"> 395   oop v = JNIHandles::resolve(value);</span>
<span class="line-added"> 396   assert(v-&gt;mark().is_larval_state(), &quot;must be a larval value&quot;);</span>
<span class="line-added"> 397   markWord mark = v-&gt;mark();</span>
<span class="line-added"> 398   v-&gt;set_mark(mark.exit_larval_state());</span>
<span class="line-added"> 399   return JNIHandles::make_local(env, v);</span>
<span class="line-added"> 400 } UNSAFE_END</span>
<span class="line-added"> 401 </span>
 402 UNSAFE_ENTRY(jobject, Unsafe_GetReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) {
 403   oop p = JNIHandles::resolve(obj);
 404   assert_field_offset_sane(p, offset);
 405   oop v = HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_load_at(p, offset);
 406   return JNIHandles::make_local(env, v);
 407 } UNSAFE_END
 408 
 409 UNSAFE_ENTRY(void, Unsafe_PutReferenceVolatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jobject x_h)) {
 410   oop x = JNIHandles::resolve(x_h);
 411   oop p = JNIHandles::resolve(obj);
 412   assert_field_offset_sane(p, offset);
 413   HeapAccess&lt;MO_SEQ_CST | ON_UNKNOWN_OOP_REF&gt;::oop_store_at(p, offset, x);
 414 } UNSAFE_END
 415 
 416 UNSAFE_ENTRY(jobject, Unsafe_GetUncompressedObject(JNIEnv *env, jobject unsafe, jlong addr)) {
 417   oop v = *(oop*) (address) addr;
 418   return JNIHandles::make_local(env, v);
 419 } UNSAFE_END
 420 
 421 #define DEFINE_GETSETOOP(java_type, Type) \
</pre>
<hr />
<pre>
 718   return false;
 719 }
 720 UNSAFE_END
 721 
 722 static void getBaseAndScale(int&amp; base, int&amp; scale, jclass clazz, TRAPS) {
 723   assert(clazz != NULL, &quot;clazz must not be NULL&quot;);
 724 
 725   oop mirror = JNIHandles::resolve_non_null(clazz);
 726   Klass* k = java_lang_Class::as_Klass(mirror);
 727 
 728   if (k == NULL || !k-&gt;is_array_klass()) {
 729     THROW(vmSymbols::java_lang_InvalidClassException());
 730   } else if (k-&gt;is_objArray_klass()) {
 731     base  = arrayOopDesc::base_offset_in_bytes(T_OBJECT);
 732     scale = heapOopSize;
 733   } else if (k-&gt;is_typeArray_klass()) {
 734     TypeArrayKlass* tak = TypeArrayKlass::cast(k);
 735     base  = tak-&gt;array_header_in_bytes();
 736     assert(base == arrayOopDesc::base_offset_in_bytes(tak-&gt;element_type()), &quot;array_header_size semantics ok&quot;);
 737     scale = (1 &lt;&lt; tak-&gt;log2_element_size());
<span class="line-added"> 738   } else if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 739     ValueArrayKlass* vak = ValueArrayKlass::cast(k);</span>
<span class="line-added"> 740     ValueKlass* vklass = vak-&gt;element_klass();</span>
<span class="line-added"> 741     base = vak-&gt;array_header_in_bytes();</span>
<span class="line-added"> 742     scale = vak-&gt;element_byte_size();</span>
 743   } else {
 744     ShouldNotReachHere();
 745   }
 746 }
 747 
 748 UNSAFE_ENTRY(jint, Unsafe_ArrayBaseOffset0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 749   int base = 0, scale = 0;
 750   getBaseAndScale(base, scale, clazz, CHECK_0);
 751 
 752   return field_offset_from_byte_offset(base);
 753 } UNSAFE_END
 754 
 755 
 756 UNSAFE_ENTRY(jint, Unsafe_ArrayIndexScale0(JNIEnv *env, jobject unsafe, jclass clazz)) {
 757   int base = 0, scale = 0;
 758   getBaseAndScale(base, scale, clazz, CHECK_0);
 759 
 760   // This VM packs both fields and array elements down to the byte.
 761   // But watch out:  If this changes, so that array references for
 762   // a given primitive type (say, T_BOOLEAN) use different memory units
 763   // than fields, this method MUST return zero for such arrays.
 764   // For example, the VM used to store sub-word sized fields in full
 765   // words in the object layout, so that accessors like getByte(Object,int)
 766   // did not really do what one might expect for arrays.  Therefore,
 767   // this function used to report a zero scale factor, so that the user
 768   // would know not to attempt to access sub-word array elements.
 769   // // Code for unpacked fields:
 770   // if (scale &lt; wordSize)  return 0;
 771 
 772   // The following allows for a pretty general fieldOffset cookie scheme,
 773   // but requires it to be linear in byte offset.
 774   return field_offset_from_byte_offset(scale) - field_offset_from_byte_offset(0);
 775 } UNSAFE_END
 776 
 777 
<span class="line-added"> 778 UNSAFE_ENTRY(jlong, Unsafe_GetObjectSize0(JNIEnv* env, jobject o, jobject obj))</span>
<span class="line-added"> 779   oop p = JNIHandles::resolve(obj);</span>
<span class="line-added"> 780   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;</span>
<span class="line-added"> 781 UNSAFE_END</span>
<span class="line-added"> 782 </span>
<span class="line-added"> 783 </span>
 784 static inline void throw_new(JNIEnv *env, const char *ename) {
 785   jclass cls = env-&gt;FindClass(ename);
 786   if (env-&gt;ExceptionCheck()) {
 787     env-&gt;ExceptionClear();
 788     tty-&gt;print_cr(&quot;Unsafe: cannot throw %s because FindClass has failed&quot;, ename);
 789     return;
 790   }
 791 
 792   env-&gt;ThrowNew(cls, NULL);
 793 }
 794 
 795 static jclass Unsafe_DefineClass_impl(JNIEnv *env, jstring name, jbyteArray data, int offset, int length, jobject loader, jobject pd) {
 796   // Code lifted from JDK 1.3 ClassLoader.c
 797 
 798   jbyte *body;
 799   char *utfName = NULL;
 800   jclass result = 0;
 801   char buf[128];
 802 
 803   assert(data != NULL, &quot;Class bytes must not be NULL&quot;);
</pre>
<hr />
<pre>
1188 
1189 
1190 /// JVM_RegisterUnsafeMethods
1191 
1192 #define ADR &quot;J&quot;
1193 
1194 #define LANG &quot;Ljava/lang/&quot;
1195 
1196 #define OBJ LANG &quot;Object;&quot;
1197 #define CLS LANG &quot;Class;&quot;
1198 #define FLD LANG &quot;reflect/Field;&quot;
1199 #define THR LANG &quot;Throwable;&quot;
1200 
1201 #define DC_Args  LANG &quot;String;[BII&quot; LANG &quot;ClassLoader;&quot; &quot;Ljava/security/ProtectionDomain;&quot;
1202 #define DAC_Args CLS &quot;[B[&quot; OBJ
1203 
1204 #define CC (char*)  /*cast a literal from (const char*)*/
1205 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
1206 
1207 #define DECLARE_GETPUTOOP(Type, Desc) \
<span class="line-modified">1208     {CC &quot;get&quot;  #Type,      CC &quot;(&quot; OBJ &quot;J)&quot; #Desc,                 FN_PTR(Unsafe_Get##Type)}, \</span>
<span class="line-modified">1209     {CC &quot;put&quot;  #Type,      CC &quot;(&quot; OBJ &quot;J&quot; #Desc &quot;)V&quot;,             FN_PTR(Unsafe_Put##Type)}, \</span>
<span class="line-modified">1210     {CC &quot;get&quot;  #Type &quot;Volatile&quot;,      CC &quot;(&quot; OBJ &quot;J)&quot; #Desc,      FN_PTR(Unsafe_Get##Type##Volatile)}, \</span>
<span class="line-modified">1211     {CC &quot;put&quot;  #Type &quot;Volatile&quot;,      CC &quot;(&quot; OBJ &quot;J&quot; #Desc &quot;)V&quot;,  FN_PTR(Unsafe_Put##Type##Volatile)}</span>
1212 
1213 
1214 static JNINativeMethod jdk_internal_misc_Unsafe_methods[] = {
1215     {CC &quot;getReference&quot;,         CC &quot;(&quot; OBJ &quot;J)&quot; OBJ &quot;&quot;,   FN_PTR(Unsafe_GetReference)},
1216     {CC &quot;putReference&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;)V&quot;,  FN_PTR(Unsafe_PutReference)},
1217     {CC &quot;getReferenceVolatile&quot;, CC &quot;(&quot; OBJ &quot;J)&quot; OBJ,      FN_PTR(Unsafe_GetReferenceVolatile)},
1218     {CC &quot;putReferenceVolatile&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;)V&quot;,  FN_PTR(Unsafe_PutReferenceVolatile)},
1219 
<span class="line-added">1220     {CC &quot;isFlattenedArray&quot;, CC &quot;(&quot; CLS &quot;)Z&quot;,                     FN_PTR(Unsafe_IsFlattenedArray)},</span>
<span class="line-added">1221     {CC &quot;getValue&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; CLS &quot;)&quot; OBJ,          FN_PTR(Unsafe_GetValue)},</span>
<span class="line-added">1222     {CC &quot;putValue&quot;,         CC &quot;(&quot; OBJ &quot;J&quot; CLS OBJ &quot;)V&quot;,         FN_PTR(Unsafe_PutValue)},</span>
<span class="line-added">1223     {CC &quot;uninitializedDefaultValue&quot;, CC &quot;(&quot; CLS &quot;)&quot; OBJ,         FN_PTR(Unsafe_UninitializedDefaultValue)},</span>
<span class="line-added">1224     {CC &quot;makePrivateBuffer&quot;,     CC &quot;(&quot; OBJ &quot;)&quot; OBJ,             FN_PTR(Unsafe_MakePrivateBuffer)},</span>
<span class="line-added">1225     {CC &quot;finishPrivateBuffer&quot;,   CC &quot;(&quot; OBJ &quot;)&quot; OBJ,             FN_PTR(Unsafe_FinishPrivateBuffer)},</span>
<span class="line-added">1226     {CC &quot;valueHeaderSize&quot;,       CC &quot;(&quot; CLS &quot;)J&quot;,                FN_PTR(Unsafe_ValueHeaderSize)},</span>
<span class="line-added">1227 </span>
1228     {CC &quot;getUncompressedObject&quot;, CC &quot;(&quot; ADR &quot;)&quot; OBJ,  FN_PTR(Unsafe_GetUncompressedObject)},
1229 
1230     DECLARE_GETPUTOOP(Boolean, Z),
1231     DECLARE_GETPUTOOP(Byte, B),
1232     DECLARE_GETPUTOOP(Short, S),
1233     DECLARE_GETPUTOOP(Char, C),
1234     DECLARE_GETPUTOOP(Int, I),
1235     DECLARE_GETPUTOOP(Long, J),
1236     DECLARE_GETPUTOOP(Float, F),
1237     DECLARE_GETPUTOOP(Double, D),
1238 
1239     {CC &quot;allocateMemory0&quot;,    CC &quot;(J)&quot; ADR,              FN_PTR(Unsafe_AllocateMemory0)},
1240     {CC &quot;reallocateMemory0&quot;,  CC &quot;(&quot; ADR &quot;J)&quot; ADR,       FN_PTR(Unsafe_ReallocateMemory0)},
1241     {CC &quot;freeMemory0&quot;,        CC &quot;(&quot; ADR &quot;)V&quot;,           FN_PTR(Unsafe_FreeMemory0)},
1242 
1243     {CC &quot;objectFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_ObjectFieldOffset0)},
1244     {CC &quot;objectFieldOffset1&quot;, CC &quot;(&quot; CLS LANG &quot;String;)J&quot;, FN_PTR(Unsafe_ObjectFieldOffset1)},
1245     {CC &quot;staticFieldOffset0&quot;, CC &quot;(&quot; FLD &quot;)J&quot;,           FN_PTR(Unsafe_StaticFieldOffset0)},
1246     {CC &quot;staticFieldBase0&quot;,   CC &quot;(&quot; FLD &quot;)&quot; OBJ,        FN_PTR(Unsafe_StaticFieldBase0)},
1247     {CC &quot;ensureClassInitialized0&quot;, CC &quot;(&quot; CLS &quot;)V&quot;,      FN_PTR(Unsafe_EnsureClassInitialized0)},
1248     {CC &quot;arrayBaseOffset0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayBaseOffset0)},
1249     {CC &quot;arrayIndexScale0&quot;,   CC &quot;(&quot; CLS &quot;)I&quot;,           FN_PTR(Unsafe_ArrayIndexScale0)},
<span class="line-added">1250     {CC &quot;getObjectSize0&quot;,     CC &quot;(Ljava/lang/Object;)J&quot;, FN_PTR(Unsafe_GetObjectSize0)},</span>
1251 
1252     {CC &quot;defineClass0&quot;,       CC &quot;(&quot; DC_Args &quot;)&quot; CLS,    FN_PTR(Unsafe_DefineClass0)},
1253     {CC &quot;allocateInstance&quot;,   CC &quot;(&quot; CLS &quot;)&quot; OBJ,        FN_PTR(Unsafe_AllocateInstance)},
1254     {CC &quot;throwException&quot;,     CC &quot;(&quot; THR &quot;)V&quot;,           FN_PTR(Unsafe_ThrowException)},
1255     {CC &quot;compareAndSetReference&quot;,CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)Z&quot;, FN_PTR(Unsafe_CompareAndSetReference)},
1256     {CC &quot;compareAndSetInt&quot;,   CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetInt)},
1257     {CC &quot;compareAndSetLong&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSetLong)},
1258     {CC &quot;compareAndExchangeReference&quot;, CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;&quot; OBJ &quot;)&quot; OBJ, FN_PTR(Unsafe_CompareAndExchangeReference)},
1259     {CC &quot;compareAndExchangeInt&quot;,  CC &quot;(&quot; OBJ &quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)I&quot;, FN_PTR(Unsafe_CompareAndExchangeInt)},
1260     {CC &quot;compareAndExchangeLong&quot;, CC &quot;(&quot; OBJ &quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)J&quot;, FN_PTR(Unsafe_CompareAndExchangeLong)},
1261 
1262     {CC &quot;park&quot;,               CC &quot;(ZJ)V&quot;,                FN_PTR(Unsafe_Park)},
1263     {CC &quot;unpark&quot;,             CC &quot;(&quot; OBJ &quot;)V&quot;,           FN_PTR(Unsafe_Unpark)},
1264 
1265     {CC &quot;getLoadAverage0&quot;,    CC &quot;([DI)I&quot;,               FN_PTR(Unsafe_GetLoadAverage0)},
1266 
1267     {CC &quot;copyMemory0&quot;,        CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJ)V&quot;, FN_PTR(Unsafe_CopyMemory0)},
1268     {CC &quot;copySwapMemory0&quot;,    CC &quot;(&quot; OBJ &quot;J&quot; OBJ &quot;JJJ)V&quot;, FN_PTR(Unsafe_CopySwapMemory0)},
1269     {CC &quot;writeback0&quot;,         CC &quot;(&quot; &quot;J&quot; &quot;)V&quot;,           FN_PTR(Unsafe_WriteBack0)},
1270     {CC &quot;writebackPreSync0&quot;,  CC &quot;()V&quot;,                  FN_PTR(Unsafe_WriteBackPreSync0)},
</pre>
</td>
</tr>
</table>
<center><a href="methodHandles.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="whitebox.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/systemDictionary.hpp&quot;
  33 #include &quot;classfile/verifier.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compileBroker.hpp&quot;
  36 #include &quot;interpreter/oopMapCache.hpp&quot;
  37 #include &quot;interpreter/rewriter.hpp&quot;
  38 #include &quot;jfr/jfrEvents.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/metadataFactory.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/annotations.hpp&quot;
  45 #include &quot;oops/constantPool.hpp&quot;
  46 #include &quot;oops/fieldStreams.inline.hpp&quot;
  47 #include &quot;oops/klassVtable.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;oops/recordComponent.hpp&quot;
  50 #include &quot;prims/jvmtiImpl.hpp&quot;
  51 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  52 #include &quot;prims/jvmtiThreadState.inline.hpp&quot;
  53 #include &quot;prims/resolvedMethodTable.hpp&quot;
  54 #include &quot;prims/methodComparator.hpp&quot;
  55 #include &quot;runtime/atomic.hpp&quot;
  56 #include &quot;runtime/deoptimization.hpp&quot;
  57 #include &quot;runtime/handles.inline.hpp&quot;
  58 #include &quot;runtime/jniHandles.inline.hpp&quot;
  59 #include &quot;runtime/relocator.hpp&quot;
  60 #include &quot;runtime/safepointVerifiers.hpp&quot;
  61 #include &quot;utilities/bitMap.inline.hpp&quot;
  62 #include &quot;utilities/events.hpp&quot;
  63 
  64 Array&lt;Method*&gt;* VM_RedefineClasses::_old_methods = NULL;
  65 Array&lt;Method*&gt;* VM_RedefineClasses::_new_methods = NULL;
  66 Method**  VM_RedefineClasses::_matching_old_methods = NULL;
  67 Method**  VM_RedefineClasses::_matching_new_methods = NULL;
  68 Method**  VM_RedefineClasses::_deleted_methods      = NULL;
  69 Method**  VM_RedefineClasses::_added_methods        = NULL;
  70 int       VM_RedefineClasses::_matching_methods_length = 0;
  71 int       VM_RedefineClasses::_deleted_methods_length  = 0;
  72 int       VM_RedefineClasses::_added_methods_length    = 0;
  73 bool      VM_RedefineClasses::_has_redefined_Object = false;
  74 bool      VM_RedefineClasses::_has_null_class_loader = false;
  75 u8        VM_RedefineClasses::_id_counter = 0;
  76 
  77 VM_RedefineClasses::VM_RedefineClasses(jint class_count,
  78                                        const jvmtiClassDefinition *class_defs,
  79                                        JvmtiClassLoadKind class_load_kind) {
  80   _class_count = class_count;
  81   _class_defs = class_defs;
  82   _class_load_kind = class_load_kind;
  83   _any_class_has_resolved_methods = false;
  84   _res = JVMTI_ERROR_NONE;
  85   _the_class = NULL;
  86   _has_redefined_Object = false;
  87   _has_null_class_loader = false;
  88   _id = next_id();
  89 }
  90 
  91 static inline InstanceKlass* get_ik(jclass def) {
  92   oop mirror = JNIHandles::resolve_non_null(def);
  93   return InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
  94 }
  95 
  96 // If any of the classes are being redefined, wait
  97 // Parallel constant pool merging leads to indeterminate constant pools.
  98 void VM_RedefineClasses::lock_classes() {
  99   MonitorLocker ml(RedefineClasses_lock);
 100   bool has_redefined;
 101   do {
 102     has_redefined = false;
 103     // Go through classes each time until none are being redefined.
 104     for (int i = 0; i &lt; _class_count; i++) {
 105       if (get_ik(_class_defs[i].klass)-&gt;is_being_redefined()) {
 106         ml.wait();
 107         has_redefined = true;
 108         break;  // for loop
 109       }
 110     }
 111   } while (has_redefined);
 112   for (int i = 0; i &lt; _class_count; i++) {
 113     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(true);
 114   }
 115   ml.notify_all();
 116 }
 117 
 118 void VM_RedefineClasses::unlock_classes() {
 119   MonitorLocker ml(RedefineClasses_lock);
 120   for (int i = 0; i &lt; _class_count; i++) {
 121     assert(get_ik(_class_defs[i].klass)-&gt;is_being_redefined(),
 122            &quot;should be being redefined to get here&quot;);
 123     get_ik(_class_defs[i].klass)-&gt;set_is_being_redefined(false);
 124   }
 125   ml.notify_all();
 126 }
 127 
 128 bool VM_RedefineClasses::doit_prologue() {
 129   if (_class_count == 0) {
 130     _res = JVMTI_ERROR_NONE;
 131     return false;
 132   }
 133   if (_class_defs == NULL) {
 134     _res = JVMTI_ERROR_NULL_POINTER;
 135     return false;
 136   }
 137 
 138   for (int i = 0; i &lt; _class_count; i++) {
 139     if (_class_defs[i].klass == NULL) {
 140       _res = JVMTI_ERROR_INVALID_CLASS;
 141       return false;
 142     }
 143     if (_class_defs[i].class_byte_count == 0) {
 144       _res = JVMTI_ERROR_INVALID_CLASS_FORMAT;
 145       return false;
 146     }
 147     if (_class_defs[i].class_bytes == NULL) {
 148       _res = JVMTI_ERROR_NULL_POINTER;
 149       return false;
 150     }
 151 
 152     oop mirror = JNIHandles::resolve_non_null(_class_defs[i].klass);
 153     // classes for primitives, arrays, hidden and vm unsafe anonymous classes
 154     // cannot be redefined.
 155     if (!is_modifiable_class(mirror)) {
 156       _res = JVMTI_ERROR_UNMODIFIABLE_CLASS;
 157       return false;
 158     }
 159   }
 160 
 161   // Start timer after all the sanity checks; not quite accurate, but
 162   // better than adding a bunch of stop() calls.
 163   if (log_is_enabled(Info, redefine, class, timer)) {
 164     _timer_vm_op_prologue.start();
 165   }
 166 
 167   lock_classes();
 168   // We first load new class versions in the prologue, because somewhere down the
 169   // call chain it is required that the current thread is a Java thread.
 170   _res = load_new_class_versions(Thread::current());
 171   if (_res != JVMTI_ERROR_NONE) {
 172     // free any successfully created classes, since none are redefined
 173     for (int i = 0; i &lt; _class_count; i++) {
 174       if (_scratch_classes[i] != NULL) {
 175         ClassLoaderData* cld = _scratch_classes[i]-&gt;class_loader_data();
 176         // Free the memory for this class at class unloading time.  Not before
 177         // because CMS might think this is still live.
 178         InstanceKlass* ik = get_ik(_class_defs[i].klass);
 179         if (ik-&gt;get_cached_class_file() == _scratch_classes[i]-&gt;get_cached_class_file()) {
 180           // Don&#39;t double-free cached_class_file copied from the original class if error.
 181           _scratch_classes[i]-&gt;set_cached_class_file(NULL);
 182         }
 183         cld-&gt;add_to_deallocate_list(InstanceKlass::cast(_scratch_classes[i]));
 184       }
 185     }
 186     // Free os::malloc allocated memory in load_new_class_version.
 187     os::free(_scratch_classes);
 188     _timer_vm_op_prologue.stop();
 189     unlock_classes();
 190     return false;
 191   }
 192 
 193   _timer_vm_op_prologue.stop();
 194   return true;
 195 }
 196 
 197 void VM_RedefineClasses::doit() {
 198   Thread *thread = Thread::current();
 199 
 200 #if INCLUDE_CDS
 201   if (UseSharedSpaces) {
 202     // Sharing is enabled so we remap the shared readonly space to
 203     // shared readwrite, private just in case we need to redefine
 204     // a shared class. We do the remap during the doit() phase of
 205     // the safepoint to be safer.
 206     if (!MetaspaceShared::remap_shared_readonly_as_readwrite()) {
 207       log_info(redefine, class, load)(&quot;failed to remap shared readonly space to readwrite, private&quot;);
 208       _res = JVMTI_ERROR_INTERNAL;
 209       return;
 210     }
 211   }
 212 #endif
 213 
 214   // Mark methods seen on stack and everywhere else so old methods are not
 215   // cleaned up if they&#39;re on the stack.
 216   MetadataOnStackMark md_on_stack(/*walk_all_metadata*/true, /*redefinition_walk*/true);
 217   HandleMark hm(thread);   // make sure any handles created are deleted
 218                            // before the stack walk again.
 219 
 220   for (int i = 0; i &lt; _class_count; i++) {
 221     redefine_single_class(_class_defs[i].klass, _scratch_classes[i], thread);
 222   }
 223 
 224   // Flush all compiled code that depends on the classes redefined.
 225   flush_dependent_code();
 226 
 227   // Adjust constantpool caches and vtables for all classes
 228   // that reference methods of the evolved classes.
 229   // Have to do this after all classes are redefined and all methods that
 230   // are redefined are marked as old.
 231   AdjustAndCleanMetadata adjust_and_clean_metadata(thread);
 232   ClassLoaderDataGraph::classes_do(&amp;adjust_and_clean_metadata);
 233 
 234   // JSR-292 support
 235   if (_any_class_has_resolved_methods) {
 236     bool trace_name_printed = false;
 237     ResolvedMethodTable::adjust_method_entries(&amp;trace_name_printed);
 238   }
 239 
 240   // Increment flag indicating that some invariants are no longer true.
 241   // See jvmtiExport.hpp for detailed explanation.
 242   JvmtiExport::increment_redefinition_count();
 243 
 244   // check_class() is optionally called for product bits, but is
 245   // always called for non-product bits.
 246 #ifdef PRODUCT
 247   if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
 248 #endif
 249     log_trace(redefine, class, obsolete, metadata)(&quot;calling check_class&quot;);
 250     CheckClass check_class(thread);
 251     ClassLoaderDataGraph::classes_do(&amp;check_class);
 252 #ifdef PRODUCT
 253   }
 254 #endif
 255 
 256   // Clean up any metadata now unreferenced while MetadataOnStackMark is set.
 257   ClassLoaderDataGraph::clean_deallocate_lists(false);
 258 }
 259 
 260 void VM_RedefineClasses::doit_epilogue() {
 261   unlock_classes();
 262 
 263   // Free os::malloc allocated memory.
 264   os::free(_scratch_classes);
 265 
 266   // Reset the_class to null for error printing.
 267   _the_class = NULL;
 268 
 269   if (log_is_enabled(Info, redefine, class, timer)) {
 270     // Used to have separate timers for &quot;doit&quot; and &quot;all&quot;, but the timer
 271     // overhead skewed the measurements.
 272     julong doit_time = _timer_rsc_phase1.milliseconds() +
 273                        _timer_rsc_phase2.milliseconds();
 274     julong all_time = _timer_vm_op_prologue.milliseconds() + doit_time;
 275 
 276     log_info(redefine, class, timer)
 277       (&quot;vm_op: all=&quot; JULONG_FORMAT &quot;  prologue=&quot; JULONG_FORMAT &quot;  doit=&quot; JULONG_FORMAT,
 278        all_time, (julong)_timer_vm_op_prologue.milliseconds(), doit_time);
 279     log_info(redefine, class, timer)
 280       (&quot;redefine_single_class: phase1=&quot; JULONG_FORMAT &quot;  phase2=&quot; JULONG_FORMAT,
 281        (julong)_timer_rsc_phase1.milliseconds(), (julong)_timer_rsc_phase2.milliseconds());
 282   }
 283 }
 284 
 285 bool VM_RedefineClasses::is_modifiable_class(oop klass_mirror) {
 286   // classes for primitives cannot be redefined
 287   if (java_lang_Class::is_primitive(klass_mirror)) {
 288     return false;
 289   }
 290   Klass* k = java_lang_Class::as_Klass(klass_mirror);
 291   // classes for arrays cannot be redefined
 292   if (k == NULL || !k-&gt;is_instance_klass()) {
 293     return false;
 294   }
 295 
 296   // Cannot redefine or retransform a hidden or an unsafe anonymous class.
 297   if (InstanceKlass::cast(k)-&gt;is_hidden() ||
 298       InstanceKlass::cast(k)-&gt;is_unsafe_anonymous()) {
 299     return false;
 300   }
 301   return true;
 302 }
 303 
 304 // Append the current entry at scratch_i in scratch_cp to *merge_cp_p
 305 // where the end of *merge_cp_p is specified by *merge_cp_length_p. For
 306 // direct CP entries, there is just the current entry to append. For
 307 // indirect and double-indirect CP entries, there are zero or more
 308 // referenced CP entries along with the current entry to append.
 309 // Indirect and double-indirect CP entries are handled by recursive
 310 // calls to append_entry() as needed. The referenced CP entries are
 311 // always appended to *merge_cp_p before the referee CP entry. These
 312 // referenced CP entries may already exist in *merge_cp_p in which case
 313 // there is nothing extra to append and only the current entry is
 314 // appended.
 315 void VM_RedefineClasses::append_entry(const constantPoolHandle&amp; scratch_cp,
 316        int scratch_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p,
 317        TRAPS) {
 318 
 319   // append is different depending on entry tag type
 320   switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
 321 
 322     // The old verifier is implemented outside the VM. It loads classes,
 323     // but does not resolve constant pool entries directly so we never
 324     // see Class entries here with the old verifier. Similarly the old
 325     // verifier does not like Class entries in the input constant pool.
 326     // The split-verifier is implemented in the VM so it can optionally
 327     // and directly resolve constant pool entries to load classes. The
 328     // split-verifier can accept either Class entries or UnresolvedClass
 329     // entries in the input constant pool. We revert the appended copy
 330     // back to UnresolvedClass so that either verifier will be happy
 331     // with the constant pool entry.
 332     //
 333     // this is an indirect CP entry so it needs special handling
 334     case JVM_CONSTANT_Class:
 335     case JVM_CONSTANT_UnresolvedClass:
 336     {
 337       int name_i = scratch_cp-&gt;klass_name_index_at(scratch_i);
 338       int new_name_i = find_or_append_indirect_entry(scratch_cp, name_i, merge_cp_p,
 339                                                      merge_cp_length_p, THREAD);
 340 
 341       if (new_name_i != name_i) {
 342         log_trace(redefine, class, constantpool)
 343           (&quot;Class entry@%d name_index change: %d to %d&quot;,
 344            *merge_cp_length_p, name_i, new_name_i);
 345       }
 346 
 347       (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(*merge_cp_length_p, new_name_i);
 348       if (scratch_i != *merge_cp_length_p) {
 349         // The new entry in *merge_cp_p is at a different index than
 350         // the new entry in scratch_cp so we need to map the index values.
 351         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 352       }
 353       (*merge_cp_length_p)++;
 354     } break;
 355 
 356     // these are direct CP entries so they can be directly appended,
 357     // but double and long take two constant pool entries
 358     case JVM_CONSTANT_Double:  // fall through
 359     case JVM_CONSTANT_Long:
 360     {
 361       ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,
 362         THREAD);
 363 
 364       if (scratch_i != *merge_cp_length_p) {
 365         // The new entry in *merge_cp_p is at a different index than
 366         // the new entry in scratch_cp so we need to map the index values.
 367         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 368       }
 369       (*merge_cp_length_p) += 2;
 370     } break;
 371 
 372     // these are direct CP entries so they can be directly appended
 373     case JVM_CONSTANT_Float:   // fall through
 374     case JVM_CONSTANT_Integer: // fall through
 375     case JVM_CONSTANT_Utf8:    // fall through
 376 
 377     // This was an indirect CP entry, but it has been changed into
 378     // Symbol*s so this entry can be directly appended.
 379     case JVM_CONSTANT_String:      // fall through
 380     {
 381       ConstantPool::copy_entry_to(scratch_cp, scratch_i, *merge_cp_p, *merge_cp_length_p,
 382         THREAD);
 383 
 384       if (scratch_i != *merge_cp_length_p) {
 385         // The new entry in *merge_cp_p is at a different index than
 386         // the new entry in scratch_cp so we need to map the index values.
 387         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 388       }
 389       (*merge_cp_length_p)++;
 390     } break;
 391 
 392     // this is an indirect CP entry so it needs special handling
 393     case JVM_CONSTANT_NameAndType:
 394     {
 395       int name_ref_i = scratch_cp-&gt;name_ref_index_at(scratch_i);
 396       int new_name_ref_i = find_or_append_indirect_entry(scratch_cp, name_ref_i, merge_cp_p,
 397                                                          merge_cp_length_p, THREAD);
 398 
 399       int signature_ref_i = scratch_cp-&gt;signature_ref_index_at(scratch_i);
 400       int new_signature_ref_i = find_or_append_indirect_entry(scratch_cp, signature_ref_i,
 401                                                               merge_cp_p, merge_cp_length_p,
 402                                                               THREAD);
 403 
 404       // If the referenced entries already exist in *merge_cp_p, then
 405       // both new_name_ref_i and new_signature_ref_i will both be 0.
 406       // In that case, all we are appending is the current entry.
 407       if (new_name_ref_i != name_ref_i) {
 408         log_trace(redefine, class, constantpool)
 409           (&quot;NameAndType entry@%d name_ref_index change: %d to %d&quot;,
 410            *merge_cp_length_p, name_ref_i, new_name_ref_i);
 411       }
 412       if (new_signature_ref_i != signature_ref_i) {
 413         log_trace(redefine, class, constantpool)
 414           (&quot;NameAndType entry@%d signature_ref_index change: %d to %d&quot;,
 415            *merge_cp_length_p, signature_ref_i, new_signature_ref_i);
 416       }
 417 
 418       (*merge_cp_p)-&gt;name_and_type_at_put(*merge_cp_length_p,
 419         new_name_ref_i, new_signature_ref_i);
 420       if (scratch_i != *merge_cp_length_p) {
 421         // The new entry in *merge_cp_p is at a different index than
 422         // the new entry in scratch_cp so we need to map the index values.
 423         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 424       }
 425       (*merge_cp_length_p)++;
 426     } break;
 427 
 428     // this is a double-indirect CP entry so it needs special handling
 429     case JVM_CONSTANT_Fieldref:           // fall through
 430     case JVM_CONSTANT_InterfaceMethodref: // fall through
 431     case JVM_CONSTANT_Methodref:
 432     {
 433       int klass_ref_i = scratch_cp-&gt;uncached_klass_ref_index_at(scratch_i);
 434       int new_klass_ref_i = find_or_append_indirect_entry(scratch_cp, klass_ref_i,
 435                                                           merge_cp_p, merge_cp_length_p, THREAD);
 436 
 437       int name_and_type_ref_i = scratch_cp-&gt;uncached_name_and_type_ref_index_at(scratch_i);
 438       int new_name_and_type_ref_i = find_or_append_indirect_entry(scratch_cp, name_and_type_ref_i,
 439                                                           merge_cp_p, merge_cp_length_p, THREAD);
 440 
 441       const char *entry_name = NULL;
 442       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
 443       case JVM_CONSTANT_Fieldref:
 444         entry_name = &quot;Fieldref&quot;;
 445         (*merge_cp_p)-&gt;field_at_put(*merge_cp_length_p, new_klass_ref_i,
 446           new_name_and_type_ref_i);
 447         break;
 448       case JVM_CONSTANT_InterfaceMethodref:
 449         entry_name = &quot;IFMethodref&quot;;
 450         (*merge_cp_p)-&gt;interface_method_at_put(*merge_cp_length_p,
 451           new_klass_ref_i, new_name_and_type_ref_i);
 452         break;
 453       case JVM_CONSTANT_Methodref:
 454         entry_name = &quot;Methodref&quot;;
 455         (*merge_cp_p)-&gt;method_at_put(*merge_cp_length_p, new_klass_ref_i,
 456           new_name_and_type_ref_i);
 457         break;
 458       default:
 459         guarantee(false, &quot;bad switch&quot;);
 460         break;
 461       }
 462 
 463       if (klass_ref_i != new_klass_ref_i) {
 464         log_trace(redefine, class, constantpool)
 465           (&quot;%s entry@%d class_index changed: %d to %d&quot;, entry_name, *merge_cp_length_p, klass_ref_i, new_klass_ref_i);
 466       }
 467       if (name_and_type_ref_i != new_name_and_type_ref_i) {
 468         log_trace(redefine, class, constantpool)
 469           (&quot;%s entry@%d name_and_type_index changed: %d to %d&quot;,
 470            entry_name, *merge_cp_length_p, name_and_type_ref_i, new_name_and_type_ref_i);
 471       }
 472 
 473       if (scratch_i != *merge_cp_length_p) {
 474         // The new entry in *merge_cp_p is at a different index than
 475         // the new entry in scratch_cp so we need to map the index values.
 476         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 477       }
 478       (*merge_cp_length_p)++;
 479     } break;
 480 
 481     // this is an indirect CP entry so it needs special handling
 482     case JVM_CONSTANT_MethodType:
 483     {
 484       int ref_i = scratch_cp-&gt;method_type_index_at(scratch_i);
 485       int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
 486                                                     merge_cp_length_p, THREAD);
 487       if (new_ref_i != ref_i) {
 488         log_trace(redefine, class, constantpool)
 489           (&quot;MethodType entry@%d ref_index change: %d to %d&quot;, *merge_cp_length_p, ref_i, new_ref_i);
 490       }
 491       (*merge_cp_p)-&gt;method_type_index_at_put(*merge_cp_length_p, new_ref_i);
 492       if (scratch_i != *merge_cp_length_p) {
 493         // The new entry in *merge_cp_p is at a different index than
 494         // the new entry in scratch_cp so we need to map the index values.
 495         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 496       }
 497       (*merge_cp_length_p)++;
 498     } break;
 499 
 500     // this is an indirect CP entry so it needs special handling
 501     case JVM_CONSTANT_MethodHandle:
 502     {
 503       int ref_kind = scratch_cp-&gt;method_handle_ref_kind_at(scratch_i);
 504       int ref_i = scratch_cp-&gt;method_handle_index_at(scratch_i);
 505       int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
 506                                                     merge_cp_length_p, THREAD);
 507       if (new_ref_i != ref_i) {
 508         log_trace(redefine, class, constantpool)
 509           (&quot;MethodHandle entry@%d ref_index change: %d to %d&quot;, *merge_cp_length_p, ref_i, new_ref_i);
 510       }
 511       (*merge_cp_p)-&gt;method_handle_index_at_put(*merge_cp_length_p, ref_kind, new_ref_i);
 512       if (scratch_i != *merge_cp_length_p) {
 513         // The new entry in *merge_cp_p is at a different index than
 514         // the new entry in scratch_cp so we need to map the index values.
 515         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 516       }
 517       (*merge_cp_length_p)++;
 518     } break;
 519 
 520     // this is an indirect CP entry so it needs special handling
 521     case JVM_CONSTANT_Dynamic:  // fall through
 522     case JVM_CONSTANT_InvokeDynamic:
 523     {
 524       // Index of the bootstrap specifier in the operands array
 525       int old_bs_i = scratch_cp-&gt;bootstrap_methods_attribute_index(scratch_i);
 526       int new_bs_i = find_or_append_operand(scratch_cp, old_bs_i, merge_cp_p,
 527                                             merge_cp_length_p, THREAD);
 528       // The bootstrap method NameAndType_info index
 529       int old_ref_i = scratch_cp-&gt;bootstrap_name_and_type_ref_index_at(scratch_i);
 530       int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
 531                                                     merge_cp_length_p, THREAD);
 532       if (new_bs_i != old_bs_i) {
 533         log_trace(redefine, class, constantpool)
 534           (&quot;Dynamic entry@%d bootstrap_method_attr_index change: %d to %d&quot;,
 535            *merge_cp_length_p, old_bs_i, new_bs_i);
 536       }
 537       if (new_ref_i != old_ref_i) {
 538         log_trace(redefine, class, constantpool)
 539           (&quot;Dynamic entry@%d name_and_type_index change: %d to %d&quot;, *merge_cp_length_p, old_ref_i, new_ref_i);
 540       }
 541 
 542       if (scratch_cp-&gt;tag_at(scratch_i).is_dynamic_constant())
 543         (*merge_cp_p)-&gt;dynamic_constant_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
 544       else
 545         (*merge_cp_p)-&gt;invoke_dynamic_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
 546       if (scratch_i != *merge_cp_length_p) {
 547         // The new entry in *merge_cp_p is at a different index than
 548         // the new entry in scratch_cp so we need to map the index values.
 549         map_index(scratch_cp, scratch_i, *merge_cp_length_p);
 550       }
 551       (*merge_cp_length_p)++;
 552     } break;
 553 
 554     // At this stage, Class or UnresolvedClass could be in scratch_cp, but not
 555     // ClassIndex
 556     case JVM_CONSTANT_ClassIndex: // fall through
 557 
 558     // Invalid is used as the tag for the second constant pool entry
 559     // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
 560     // not be seen by itself.
 561     case JVM_CONSTANT_Invalid: // fall through
 562 
 563     // At this stage, String could be here, but not StringIndex
 564     case JVM_CONSTANT_StringIndex: // fall through
 565 
 566     // At this stage JVM_CONSTANT_UnresolvedClassInError should not be here
 567     case JVM_CONSTANT_UnresolvedClassInError: // fall through
 568 
 569     default:
 570     {
 571       // leave a breadcrumb
 572       jbyte bad_value = scratch_cp-&gt;tag_at(scratch_i).value();
 573       ShouldNotReachHere();
 574     } break;
 575   } // end switch tag value
 576 } // end append_entry()
 577 
 578 
 579 int VM_RedefineClasses::find_or_append_indirect_entry(const constantPoolHandle&amp; scratch_cp,
 580       int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 581 
 582   int new_ref_i = ref_i;
 583   bool match = (ref_i &lt; *merge_cp_length_p) &amp;&amp;
 584                scratch_cp-&gt;compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);
 585 
 586   if (!match) {
 587     // forward reference in *merge_cp_p or not a direct match
 588     int found_i = scratch_cp-&gt;find_matching_entry(ref_i, *merge_cp_p, THREAD);
 589     if (found_i != 0) {
 590       guarantee(found_i != ref_i, &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
 591       // Found a matching entry somewhere else in *merge_cp_p so just need a mapping entry.
 592       new_ref_i = found_i;
 593       map_index(scratch_cp, ref_i, found_i);
 594     } else {
 595       // no match found so we have to append this entry to *merge_cp_p
 596       append_entry(scratch_cp, ref_i, merge_cp_p, merge_cp_length_p, THREAD);
 597       // The above call to append_entry() can only append one entry
 598       // so the post call query of *merge_cp_length_p is only for
 599       // the sake of consistency.
 600       new_ref_i = *merge_cp_length_p - 1;
 601     }
 602   }
 603 
 604   return new_ref_i;
 605 } // end find_or_append_indirect_entry()
 606 
 607 
 608 // Append a bootstrap specifier into the merge_cp operands that is semantically equal
 609 // to the scratch_cp operands bootstrap specifier passed by the old_bs_i index.
 610 // Recursively append new merge_cp entries referenced by the new bootstrap specifier.
 611 void VM_RedefineClasses::append_operand(const constantPoolHandle&amp; scratch_cp, int old_bs_i,
 612        constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 613 
 614   int old_ref_i = scratch_cp-&gt;operand_bootstrap_method_ref_index_at(old_bs_i);
 615   int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
 616                                                 merge_cp_length_p, THREAD);
 617   if (new_ref_i != old_ref_i) {
 618     log_trace(redefine, class, constantpool)
 619       (&quot;operands entry@%d bootstrap method ref_index change: %d to %d&quot;, _operands_cur_length, old_ref_i, new_ref_i);
 620   }
 621 
 622   Array&lt;u2&gt;* merge_ops = (*merge_cp_p)-&gt;operands();
 623   int new_bs_i = _operands_cur_length;
 624   // We have _operands_cur_length == 0 when the merge_cp operands is empty yet.
 625   // However, the operand_offset_at(0) was set in the extend_operands() call.
 626   int new_base = (new_bs_i == 0) ? (*merge_cp_p)-&gt;operand_offset_at(0)
 627                                  : (*merge_cp_p)-&gt;operand_next_offset_at(new_bs_i - 1);
 628   int argc     = scratch_cp-&gt;operand_argument_count_at(old_bs_i);
 629 
 630   ConstantPool::operand_offset_at_put(merge_ops, _operands_cur_length, new_base);
 631   merge_ops-&gt;at_put(new_base++, new_ref_i);
 632   merge_ops-&gt;at_put(new_base++, argc);
 633 
 634   for (int i = 0; i &lt; argc; i++) {
 635     int old_arg_ref_i = scratch_cp-&gt;operand_argument_index_at(old_bs_i, i);
 636     int new_arg_ref_i = find_or_append_indirect_entry(scratch_cp, old_arg_ref_i, merge_cp_p,
 637                                                       merge_cp_length_p, THREAD);
 638     merge_ops-&gt;at_put(new_base++, new_arg_ref_i);
 639     if (new_arg_ref_i != old_arg_ref_i) {
 640       log_trace(redefine, class, constantpool)
 641         (&quot;operands entry@%d bootstrap method argument ref_index change: %d to %d&quot;,
 642          _operands_cur_length, old_arg_ref_i, new_arg_ref_i);
 643     }
 644   }
 645   if (old_bs_i != _operands_cur_length) {
 646     // The bootstrap specifier in *merge_cp_p is at a different index than
 647     // that in scratch_cp so we need to map the index values.
 648     map_operand_index(old_bs_i, new_bs_i);
 649   }
 650   _operands_cur_length++;
 651 } // end append_operand()
 652 
 653 
 654 int VM_RedefineClasses::find_or_append_operand(const constantPoolHandle&amp; scratch_cp,
 655       int old_bs_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
 656 
 657   int new_bs_i = old_bs_i; // bootstrap specifier index
 658   bool match = (old_bs_i &lt; _operands_cur_length) &amp;&amp;
 659                scratch_cp-&gt;compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i, THREAD);
 660 
 661   if (!match) {
 662     // forward reference in *merge_cp_p or not a direct match
 663     int found_i = scratch_cp-&gt;find_matching_operand(old_bs_i, *merge_cp_p,
 664                                                     _operands_cur_length, THREAD);
 665     if (found_i != -1) {
 666       guarantee(found_i != old_bs_i, &quot;compare_operand_to() and find_matching_operand() disagree&quot;);
 667       // found a matching operand somewhere else in *merge_cp_p so just need a mapping
 668       new_bs_i = found_i;
 669       map_operand_index(old_bs_i, found_i);
 670     } else {
 671       // no match found so we have to append this bootstrap specifier to *merge_cp_p
 672       append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p, THREAD);
 673       new_bs_i = _operands_cur_length - 1;
 674     }
 675   }
 676   return new_bs_i;
 677 } // end find_or_append_operand()
 678 
 679 
 680 void VM_RedefineClasses::finalize_operands_merge(const constantPoolHandle&amp; merge_cp, TRAPS) {
 681   if (merge_cp-&gt;operands() == NULL) {
 682     return;
 683   }
 684   // Shrink the merge_cp operands
 685   merge_cp-&gt;shrink_operands(_operands_cur_length, CHECK);
 686 
 687   if (log_is_enabled(Trace, redefine, class, constantpool)) {
 688     // don&#39;t want to loop unless we are tracing
 689     int count = 0;
 690     for (int i = 1; i &lt; _operands_index_map_p-&gt;length(); i++) {
 691       int value = _operands_index_map_p-&gt;at(i);
 692       if (value != -1) {
 693         log_trace(redefine, class, constantpool)(&quot;operands_index_map[%d]: old=%d new=%d&quot;, count, i, value);
 694         count++;
 695       }
 696     }
 697   }
 698   // Clean-up
 699   _operands_index_map_p = NULL;
 700   _operands_cur_length = 0;
 701   _operands_index_map_count = 0;
 702 } // end finalize_operands_merge()
 703 
 704 // Symbol* comparator for qsort
 705 // The caller must have an active ResourceMark.
 706 static int symcmp(const void* a, const void* b) {
 707   char* astr = (*(Symbol**)a)-&gt;as_C_string();
 708   char* bstr = (*(Symbol**)b)-&gt;as_C_string();
 709   return strcmp(astr, bstr);
 710 }
 711 
 712 static jvmtiError check_nest_attributes(InstanceKlass* the_class,
 713                                         InstanceKlass* scratch_class) {
 714   // Check whether the class NestHost attribute has been changed.
 715   Thread* thread = Thread::current();
 716   ResourceMark rm(thread);
 717   u2 the_nest_host_idx = the_class-&gt;nest_host_index();
 718   u2 scr_nest_host_idx = scratch_class-&gt;nest_host_index();
 719 
 720   if (the_nest_host_idx != 0 &amp;&amp; scr_nest_host_idx != 0) {
 721     Symbol* the_sym = the_class-&gt;constants()-&gt;klass_name_at(the_nest_host_idx);
 722     Symbol* scr_sym = scratch_class-&gt;constants()-&gt;klass_name_at(scr_nest_host_idx);
 723     if (the_sym != scr_sym) {
 724       log_trace(redefine, class, nestmates)
 725         (&quot;redefined class %s attribute change error: NestHost class: %s replaced with: %s&quot;,
 726          the_class-&gt;external_name(), the_sym-&gt;as_C_string(), scr_sym-&gt;as_C_string());
 727       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 728     }
 729   } else if ((the_nest_host_idx == 0) ^ (scr_nest_host_idx == 0)) {
 730     const char* action_str = (the_nest_host_idx != 0) ? &quot;removed&quot; : &quot;added&quot;;
 731     log_trace(redefine, class, nestmates)
 732       (&quot;redefined class %s attribute change error: NestHost attribute %s&quot;,
 733        the_class-&gt;external_name(), action_str);
 734     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 735   }
 736 
 737   // Check whether the class NestMembers attribute has been changed.
 738   Array&lt;u2&gt;* the_nest_members = the_class-&gt;nest_members();
 739   Array&lt;u2&gt;* scr_nest_members = scratch_class-&gt;nest_members();
 740   bool the_members_exists = the_nest_members != Universe::the_empty_short_array();
 741   bool scr_members_exists = scr_nest_members != Universe::the_empty_short_array();
 742 
 743   int members_len = the_nest_members-&gt;length();
 744   if (the_members_exists &amp;&amp; scr_members_exists) {
 745     if (members_len != scr_nest_members-&gt;length()) {
 746       log_trace(redefine, class, nestmates)
 747         (&quot;redefined class %s attribute change error: NestMember len=%d changed to len=%d&quot;,
 748          the_class-&gt;external_name(), members_len, scr_nest_members-&gt;length());
 749       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 750     }
 751 
 752     // The order of entries in the NestMembers array is not specified so we
 753     // have to explicitly check for the same contents. We do this by copying
 754     // the referenced symbols into their own arrays, sorting them and then
 755     // comparing each element pair.
 756 
 757     Symbol** the_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, members_len);
 758     Symbol** scr_syms = NEW_RESOURCE_ARRAY_RETURN_NULL(Symbol*, members_len);
 759 
 760     if (the_syms == NULL || scr_syms == NULL) {
 761       return JVMTI_ERROR_OUT_OF_MEMORY;
 762     }
 763 
 764     for (int i = 0; i &lt; members_len; i++) {
 765       int the_cp_index = the_nest_members-&gt;at(i);
 766       int scr_cp_index = scr_nest_members-&gt;at(i);
 767       the_syms[i] = the_class-&gt;constants()-&gt;klass_name_at(the_cp_index);
 768       scr_syms[i] = scratch_class-&gt;constants()-&gt;klass_name_at(scr_cp_index);
 769     }
 770 
 771     qsort(the_syms, members_len, sizeof(Symbol*), symcmp);
 772     qsort(scr_syms, members_len, sizeof(Symbol*), symcmp);
 773 
 774     for (int i = 0; i &lt; members_len; i++) {
 775       if (the_syms[i] != scr_syms[i]) {
 776         log_trace(redefine, class, nestmates)
 777           (&quot;redefined class %s attribute change error: NestMembers[%d]: %s changed to %s&quot;,
 778            the_class-&gt;external_name(), i, the_syms[i]-&gt;as_C_string(), scr_syms[i]-&gt;as_C_string());
 779         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 780       }
 781     }
 782   } else if (the_members_exists ^ scr_members_exists) {
 783     const char* action_str = (the_members_exists) ? &quot;removed&quot; : &quot;added&quot;;
 784     log_trace(redefine, class, nestmates)
 785       (&quot;redefined class %s attribute change error: NestMembers attribute %s&quot;,
 786        the_class-&gt;external_name(), action_str);
 787     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 788   }
 789 
 790   return JVMTI_ERROR_NONE;
 791 }
 792 
 793 // Return an error status if the class Record attribute was changed.
 794 static jvmtiError check_record_attribute(InstanceKlass* the_class, InstanceKlass* scratch_class) {
 795   // Get lists of record components.
 796   Array&lt;RecordComponent*&gt;* the_record = the_class-&gt;record_components();
 797   Array&lt;RecordComponent*&gt;* scr_record = scratch_class-&gt;record_components();
 798   bool the_record_exists = the_record != NULL;
 799   bool scr_record_exists = scr_record != NULL;
 800 
 801   if (the_record_exists &amp;&amp; scr_record_exists) {
 802     int the_num_components = the_record-&gt;length();
 803     int scr_num_components = scr_record-&gt;length();
 804     if (the_num_components != scr_num_components) {
 805       log_trace(redefine, class, record)
 806         (&quot;redefined class %s attribute change error: Record num_components=%d changed to num_components=%d&quot;,
 807          the_class-&gt;external_name(), the_num_components, scr_num_components);
 808       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 809     }
 810 
 811     // Compare each field in each record component.
 812     ConstantPool* the_cp =  the_class-&gt;constants();
 813     ConstantPool* scr_cp =  scratch_class-&gt;constants();
 814     for (int x = 0; x &lt; the_num_components; x++) {
 815       RecordComponent* the_component = the_record-&gt;at(x);
 816       RecordComponent* scr_component = scr_record-&gt;at(x);
 817       const Symbol* const the_name = the_cp-&gt;symbol_at(the_component-&gt;name_index());
 818       const Symbol* const scr_name = scr_cp-&gt;symbol_at(scr_component-&gt;name_index());
 819       const Symbol* const the_descr = the_cp-&gt;symbol_at(the_component-&gt;descriptor_index());
 820       const Symbol* const scr_descr = scr_cp-&gt;symbol_at(scr_component-&gt;descriptor_index());
 821       if (the_name != scr_name || the_descr != scr_descr) {
 822         log_trace(redefine, class, record)
 823           (&quot;redefined class %s attribute change error: Record name_index, descriptor_index, and/or attributes_count changed&quot;,
 824            the_class-&gt;external_name());
 825         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 826       }
 827 
 828       int the_gen_sig = the_component-&gt;generic_signature_index();
 829       int scr_gen_sig = scr_component-&gt;generic_signature_index();
 830       const Symbol* const the_gen_sig_sym = (the_gen_sig == 0 ? NULL :
 831         the_cp-&gt;symbol_at(the_component-&gt;generic_signature_index()));
 832       const Symbol* const scr_gen_sig_sym = (scr_gen_sig == 0 ? NULL :
 833         scr_cp-&gt;symbol_at(scr_component-&gt;generic_signature_index()));
 834       if (the_gen_sig_sym != scr_gen_sig_sym) {
 835         log_trace(redefine, class, record)
 836           (&quot;redefined class %s attribute change error: Record generic_signature attribute changed&quot;,
 837            the_class-&gt;external_name());
 838         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 839       }
 840 
 841       // It&#39;s okay if a record component&#39;s annotations were changed.
 842     }
 843 
 844   } else if (the_record_exists ^ scr_record_exists) {
 845     const char* action_str = (the_record_exists) ? &quot;removed&quot; : &quot;added&quot;;
 846     log_trace(redefine, class, record)
 847       (&quot;redefined class %s attribute change error: Record attribute %s&quot;,
 848        the_class-&gt;external_name(), action_str);
 849     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
 850   }
 851 
 852   return JVMTI_ERROR_NONE;
 853 }
 854 
 855 
 856 static bool can_add_or_delete(Method* m) {
 857       // Compatibility mode
 858   return (AllowRedefinitionToAddDeleteMethods &amp;&amp;
 859           (m-&gt;is_private() &amp;&amp; (m-&gt;is_static() || m-&gt;is_final())));
 860 }
 861 
 862 jvmtiError VM_RedefineClasses::compare_and_normalize_class_versions(
 863              InstanceKlass* the_class,
 864              InstanceKlass* scratch_class) {
 865   int i;
 866 
 867   // Check superclasses, or rather their names, since superclasses themselves can be
 868   // requested to replace.
 869   // Check for NULL superclass first since this might be java.lang.Object
 870   if (the_class-&gt;super() != scratch_class-&gt;super() &amp;&amp;
 871       (the_class-&gt;super() == NULL || scratch_class-&gt;super() == NULL ||
 872        the_class-&gt;super()-&gt;name() !=
 873        scratch_class-&gt;super()-&gt;name())) {
 874     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 875   }
 876 
 877   // Check if the number, names and order of directly implemented interfaces are the same.
 878   // I think in principle we should just check if the sets of names of directly implemented
 879   // interfaces are the same, i.e. the order of declaration (which, however, if changed in the
 880   // .java file, also changes in .class file) should not matter. However, comparing sets is
 881   // technically a bit more difficult, and, more importantly, I am not sure at present that the
 882   // order of interfaces does not matter on the implementation level, i.e. that the VM does not
 883   // rely on it somewhere.
 884   Array&lt;InstanceKlass*&gt;* k_interfaces = the_class-&gt;local_interfaces();
 885   Array&lt;InstanceKlass*&gt;* k_new_interfaces = scratch_class-&gt;local_interfaces();
 886   int n_intfs = k_interfaces-&gt;length();
 887   if (n_intfs != k_new_interfaces-&gt;length()) {
 888     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 889   }
 890   for (i = 0; i &lt; n_intfs; i++) {
 891     if (k_interfaces-&gt;at(i)-&gt;name() !=
 892         k_new_interfaces-&gt;at(i)-&gt;name()) {
 893       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
 894     }
 895   }
 896 
 897   // Check whether class is in the error init state.
 898   if (the_class-&gt;is_in_error_state()) {
 899     // TBD #5057930: special error code is needed in 1.6
 900     return JVMTI_ERROR_INVALID_CLASS;
 901   }
 902 
 903   // Check whether the nest-related attributes have been changed.
 904   jvmtiError err = check_nest_attributes(the_class, scratch_class);
 905   if (err != JVMTI_ERROR_NONE) {
 906     return err;
 907   }
 908 
 909   // Check whether the Record attribute has been changed.
 910   err = check_record_attribute(the_class, scratch_class);
 911   if (err != JVMTI_ERROR_NONE) {
 912     return err;
 913   }
 914 
 915   // Check whether class modifiers are the same.
 916   jushort old_flags = (jushort) the_class-&gt;access_flags().get_flags();
 917   jushort new_flags = (jushort) scratch_class-&gt;access_flags().get_flags();
 918   if (old_flags != new_flags) {
 919     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
 920   }
 921 
 922   // Check if the number, names, types and order of fields declared in these classes
 923   // are the same.
 924   JavaFieldStream old_fs(the_class);
 925   JavaFieldStream new_fs(scratch_class);
 926   for (; !old_fs.done() &amp;&amp; !new_fs.done(); old_fs.next(), new_fs.next()) {
 927     // access
 928     old_flags = old_fs.access_flags().as_short();
 929     new_flags = new_fs.access_flags().as_short();
 930     if ((old_flags ^ new_flags) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS) {
 931       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 932     }
 933     // offset
 934     if (old_fs.offset() != new_fs.offset()) {
 935       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 936     }
 937     // name and signature
 938     Symbol* name_sym1 = the_class-&gt;constants()-&gt;symbol_at(old_fs.name_index());
 939     Symbol* sig_sym1 = the_class-&gt;constants()-&gt;symbol_at(old_fs.signature_index());
 940     Symbol* name_sym2 = scratch_class-&gt;constants()-&gt;symbol_at(new_fs.name_index());
 941     Symbol* sig_sym2 = scratch_class-&gt;constants()-&gt;symbol_at(new_fs.signature_index());
 942     if (name_sym1 != name_sym2 || sig_sym1 != sig_sym2) {
 943       return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 944     }
 945   }
 946 
 947   // If both streams aren&#39;t done then we have a differing number of
 948   // fields.
 949   if (!old_fs.done() || !new_fs.done()) {
 950     return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
 951   }
 952 
 953   // Do a parallel walk through the old and new methods. Detect
 954   // cases where they match (exist in both), have been added in
 955   // the new methods, or have been deleted (exist only in the
 956   // old methods).  The class file parser places methods in order
 957   // by method name, but does not order overloaded methods by
 958   // signature.  In order to determine what fate befell the methods,
 959   // this code places the overloaded new methods that have matching
 960   // old methods in the same order as the old methods and places
 961   // new overloaded methods at the end of overloaded methods of
 962   // that name. The code for this order normalization is adapted
 963   // from the algorithm used in InstanceKlass::find_method().
 964   // Since we are swapping out of order entries as we find them,
 965   // we only have to search forward through the overloaded methods.
 966   // Methods which are added and have the same name as an existing
 967   // method (but different signature) will be put at the end of
 968   // the methods with that name, and the name mismatch code will
 969   // handle them.
 970   Array&lt;Method*&gt;* k_old_methods(the_class-&gt;methods());
 971   Array&lt;Method*&gt;* k_new_methods(scratch_class-&gt;methods());
 972   int n_old_methods = k_old_methods-&gt;length();
 973   int n_new_methods = k_new_methods-&gt;length();
 974   Thread* thread = Thread::current();
 975 
 976   int ni = 0;
 977   int oi = 0;
 978   while (true) {
 979     Method* k_old_method;
 980     Method* k_new_method;
 981     enum { matched, added, deleted, undetermined } method_was = undetermined;
 982 
 983     if (oi &gt;= n_old_methods) {
 984       if (ni &gt;= n_new_methods) {
 985         break; // we&#39;ve looked at everything, done
 986       }
 987       // New method at the end
 988       k_new_method = k_new_methods-&gt;at(ni);
 989       method_was = added;
 990     } else if (ni &gt;= n_new_methods) {
 991       // Old method, at the end, is deleted
 992       k_old_method = k_old_methods-&gt;at(oi);
 993       method_was = deleted;
 994     } else {
 995       // There are more methods in both the old and new lists
 996       k_old_method = k_old_methods-&gt;at(oi);
 997       k_new_method = k_new_methods-&gt;at(ni);
 998       if (k_old_method-&gt;name() != k_new_method-&gt;name()) {
 999         // Methods are sorted by method name, so a mismatch means added
1000         // or deleted
1001         if (k_old_method-&gt;name()-&gt;fast_compare(k_new_method-&gt;name()) &gt; 0) {
1002           method_was = added;
1003         } else {
1004           method_was = deleted;
1005         }
1006       } else if (k_old_method-&gt;signature() == k_new_method-&gt;signature()) {
1007         // Both the name and signature match
1008         method_was = matched;
1009       } else {
1010         // The name matches, but the signature doesn&#39;t, which means we have to
1011         // search forward through the new overloaded methods.
1012         int nj;  // outside the loop for post-loop check
1013         for (nj = ni + 1; nj &lt; n_new_methods; nj++) {
1014           Method* m = k_new_methods-&gt;at(nj);
1015           if (k_old_method-&gt;name() != m-&gt;name()) {
1016             // reached another method name so no more overloaded methods
1017             method_was = deleted;
1018             break;
1019           }
1020           if (k_old_method-&gt;signature() == m-&gt;signature()) {
1021             // found a match so swap the methods
1022             k_new_methods-&gt;at_put(ni, m);
1023             k_new_methods-&gt;at_put(nj, k_new_method);
1024             k_new_method = m;
1025             method_was = matched;
1026             break;
1027           }
1028         }
1029 
1030         if (nj &gt;= n_new_methods) {
1031           // reached the end without a match; so method was deleted
1032           method_was = deleted;
1033         }
1034       }
1035     }
1036 
1037     switch (method_was) {
1038     case matched:
1039       // methods match, be sure modifiers do too
1040       old_flags = (jushort) k_old_method-&gt;access_flags().get_flags();
1041       new_flags = (jushort) k_new_method-&gt;access_flags().get_flags();
1042       if ((old_flags ^ new_flags) &amp; ~(JVM_ACC_NATIVE)) {
1043         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED;
1044       }
1045       {
1046         u2 new_num = k_new_method-&gt;method_idnum();
1047         u2 old_num = k_old_method-&gt;method_idnum();
1048         if (new_num != old_num) {
1049           Method* idnum_owner = scratch_class-&gt;method_with_idnum(old_num);
1050           if (idnum_owner != NULL) {
1051             // There is already a method assigned this idnum -- switch them
1052             // Take current and original idnum from the new_method
1053             idnum_owner-&gt;set_method_idnum(new_num);
1054             idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1055           }
1056           // Take current and original idnum from the old_method
1057           k_new_method-&gt;set_method_idnum(old_num);
1058           k_new_method-&gt;set_orig_method_idnum(k_old_method-&gt;orig_method_idnum());
1059           if (thread-&gt;has_pending_exception()) {
1060             return JVMTI_ERROR_OUT_OF_MEMORY;
1061           }
1062         }
1063       }
1064       log_trace(redefine, class, normalize)
1065         (&quot;Method matched: new: %s [%d] == old: %s [%d]&quot;,
1066          k_new_method-&gt;name_and_sig_as_C_string(), ni, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1067       // advance to next pair of methods
1068       ++oi;
1069       ++ni;
1070       break;
1071     case added:
1072       // method added, see if it is OK
1073       if (!can_add_or_delete(k_new_method)) {
1074         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1075       }
1076       {
1077         u2 num = the_class-&gt;next_method_idnum();
1078         if (num == ConstMethod::UNSET_IDNUM) {
1079           // cannot add any more methods
1080           return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1081         }
1082         u2 new_num = k_new_method-&gt;method_idnum();
1083         Method* idnum_owner = scratch_class-&gt;method_with_idnum(num);
1084         if (idnum_owner != NULL) {
1085           // There is already a method assigned this idnum -- switch them
1086           // Take current and original idnum from the new_method
1087           idnum_owner-&gt;set_method_idnum(new_num);
1088           idnum_owner-&gt;set_orig_method_idnum(k_new_method-&gt;orig_method_idnum());
1089         }
1090         k_new_method-&gt;set_method_idnum(num);
1091         k_new_method-&gt;set_orig_method_idnum(num);
1092         if (thread-&gt;has_pending_exception()) {
1093           return JVMTI_ERROR_OUT_OF_MEMORY;
1094         }
1095       }
1096       log_trace(redefine, class, normalize)
1097         (&quot;Method added: new: %s [%d]&quot;, k_new_method-&gt;name_and_sig_as_C_string(), ni);
1098       ++ni; // advance to next new method
1099       break;
1100     case deleted:
1101       // method deleted, see if it is OK
1102       if (!can_add_or_delete(k_old_method)) {
1103         return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1104       }
1105       log_trace(redefine, class, normalize)
1106         (&quot;Method deleted: old: %s [%d]&quot;, k_old_method-&gt;name_and_sig_as_C_string(), oi);
1107       ++oi; // advance to next old method
1108       break;
1109     default:
1110       ShouldNotReachHere();
1111     }
1112   }
1113 
1114   return JVMTI_ERROR_NONE;
1115 }
1116 
1117 
1118 // Find new constant pool index value for old constant pool index value
1119 // by seaching the index map. Returns zero (0) if there is no mapped
1120 // value for the old constant pool index.
1121 int VM_RedefineClasses::find_new_index(int old_index) {
1122   if (_index_map_count == 0) {
1123     // map is empty so nothing can be found
1124     return 0;
1125   }
1126 
1127   if (old_index &lt; 1 || old_index &gt;= _index_map_p-&gt;length()) {
1128     // The old_index is out of range so it is not mapped. This should
1129     // not happen in regular constant pool merging use, but it can
1130     // happen if a corrupt annotation is processed.
1131     return 0;
1132   }
1133 
1134   int value = _index_map_p-&gt;at(old_index);
1135   if (value == -1) {
1136     // the old_index is not mapped
1137     return 0;
1138   }
1139 
1140   return value;
1141 } // end find_new_index()
1142 
1143 
1144 // Find new bootstrap specifier index value for old bootstrap specifier index
1145 // value by seaching the index map. Returns unused index (-1) if there is
1146 // no mapped value for the old bootstrap specifier index.
1147 int VM_RedefineClasses::find_new_operand_index(int old_index) {
1148   if (_operands_index_map_count == 0) {
1149     // map is empty so nothing can be found
1150     return -1;
1151   }
1152 
1153   if (old_index == -1 || old_index &gt;= _operands_index_map_p-&gt;length()) {
1154     // The old_index is out of range so it is not mapped.
1155     // This should not happen in regular constant pool merging use.
1156     return -1;
1157   }
1158 
1159   int value = _operands_index_map_p-&gt;at(old_index);
1160   if (value == -1) {
1161     // the old_index is not mapped
1162     return -1;
1163   }
1164 
1165   return value;
1166 } // end find_new_operand_index()
1167 
1168 
1169 // Returns true if the current mismatch is due to a resolved/unresolved
1170 // class pair. Otherwise, returns false.
1171 bool VM_RedefineClasses::is_unresolved_class_mismatch(const constantPoolHandle&amp; cp1,
1172        int index1, const constantPoolHandle&amp; cp2, int index2) {
1173 
1174   jbyte t1 = cp1-&gt;tag_at(index1).value();
1175   if (t1 != JVM_CONSTANT_Class &amp;&amp; t1 != JVM_CONSTANT_UnresolvedClass) {
1176     return false;  // wrong entry type; not our special case
1177   }
1178 
1179   jbyte t2 = cp2-&gt;tag_at(index2).value();
1180   if (t2 != JVM_CONSTANT_Class &amp;&amp; t2 != JVM_CONSTANT_UnresolvedClass) {
1181     return false;  // wrong entry type; not our special case
1182   }
1183 
1184   if (t1 == t2) {
1185     return false;  // not a mismatch; not our special case
1186   }
1187 
1188   char *s1 = cp1-&gt;klass_name_at(index1)-&gt;as_C_string();
1189   char *s2 = cp2-&gt;klass_name_at(index2)-&gt;as_C_string();
1190   if (strcmp(s1, s2) != 0) {
1191     return false;  // strings don&#39;t match; not our special case
1192   }
1193 
1194   return true;  // made it through the gauntlet; this is our special case
1195 } // end is_unresolved_class_mismatch()
1196 
1197 
1198 jvmtiError VM_RedefineClasses::load_new_class_versions(TRAPS) {
1199 
1200   // For consistency allocate memory using os::malloc wrapper.
1201   _scratch_classes = (InstanceKlass**)
1202     os::malloc(sizeof(InstanceKlass*) * _class_count, mtClass);
1203   if (_scratch_classes == NULL) {
1204     return JVMTI_ERROR_OUT_OF_MEMORY;
1205   }
1206   // Zero initialize the _scratch_classes array.
1207   for (int i = 0; i &lt; _class_count; i++) {
1208     _scratch_classes[i] = NULL;
1209   }
1210 
1211   ResourceMark rm(THREAD);
1212 
1213   JvmtiThreadState *state = JvmtiThreadState::state_for(JavaThread::current());
1214   // state can only be NULL if the current thread is exiting which
1215   // should not happen since we&#39;re trying to do a RedefineClasses
1216   guarantee(state != NULL, &quot;exiting thread calling load_new_class_versions&quot;);
1217   for (int i = 0; i &lt; _class_count; i++) {
1218     // Create HandleMark so that any handles created while loading new class
1219     // versions are deleted. Constant pools are deallocated while merging
1220     // constant pools
1221     HandleMark hm(THREAD);
1222     InstanceKlass* the_class = get_ik(_class_defs[i].klass);
1223     Symbol*  the_class_sym = the_class-&gt;name();
1224 
1225     log_debug(redefine, class, load)
1226       (&quot;loading name=%s kind=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
1227        the_class-&gt;external_name(), _class_load_kind, os::available_memory() &gt;&gt; 10);
1228 
1229     ClassFileStream st((u1*)_class_defs[i].class_bytes,
1230                        _class_defs[i].class_byte_count,
1231                        &quot;__VM_RedefineClasses__&quot;,
1232                        ClassFileStream::verify);
1233 
1234     // Parse the stream.
1235     Handle the_class_loader(THREAD, the_class-&gt;class_loader());
1236     Handle protection_domain(THREAD, the_class-&gt;protection_domain());
1237     // Set redefined class handle in JvmtiThreadState class.
1238     // This redefined class is sent to agent event handler for class file
1239     // load hook event.
1240     state-&gt;set_class_being_redefined(the_class, _class_load_kind);
1241 
1242     ClassLoadInfo cl_info(protection_domain);
1243     InstanceKlass* scratch_class = SystemDictionary::parse_stream(
1244                                                       the_class_sym,
1245                                                       the_class_loader,
1246                                                       &amp;st,
1247                                                       cl_info,
1248                                                       THREAD);
1249     // Clear class_being_redefined just to be sure.
1250     state-&gt;clear_class_being_redefined();
1251 
1252     // TODO: if this is retransform, and nothing changed we can skip it
1253 
1254     // Need to clean up allocated InstanceKlass if there&#39;s an error so assign
1255     // the result here. Caller deallocates all the scratch classes in case of
1256     // an error.
1257     _scratch_classes[i] = scratch_class;
1258 
1259     if (HAS_PENDING_EXCEPTION) {
1260       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1261       log_info(redefine, class, load, exceptions)(&quot;parse_stream exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1262       CLEAR_PENDING_EXCEPTION;
1263 
1264       if (ex_name == vmSymbols::java_lang_UnsupportedClassVersionError()) {
1265         return JVMTI_ERROR_UNSUPPORTED_VERSION;
1266       } else if (ex_name == vmSymbols::java_lang_ClassFormatError()) {
1267         return JVMTI_ERROR_INVALID_CLASS_FORMAT;
1268       } else if (ex_name == vmSymbols::java_lang_ClassCircularityError()) {
1269         return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
1270       } else if (ex_name == vmSymbols::java_lang_NoClassDefFoundError()) {
1271         // The message will be &quot;XXX (wrong name: YYY)&quot;
1272         return JVMTI_ERROR_NAMES_DONT_MATCH;
1273       } else if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1274         return JVMTI_ERROR_OUT_OF_MEMORY;
1275       } else {  // Just in case more exceptions can be thrown..
1276         return JVMTI_ERROR_FAILS_VERIFICATION;
1277       }
1278     }
1279 
1280     // Ensure class is linked before redefine
1281     if (!the_class-&gt;is_linked()) {
1282       the_class-&gt;link_class(THREAD);
1283       if (HAS_PENDING_EXCEPTION) {
1284         Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1285         log_info(redefine, class, load, exceptions)(&quot;link_class exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1286         CLEAR_PENDING_EXCEPTION;
1287         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1288           return JVMTI_ERROR_OUT_OF_MEMORY;
1289         } else {
1290           return JVMTI_ERROR_INTERNAL;
1291         }
1292       }
1293     }
1294 
1295     // Do the validity checks in compare_and_normalize_class_versions()
1296     // before verifying the byte codes. By doing these checks first, we
1297     // limit the number of functions that require redirection from
1298     // the_class to scratch_class. In particular, we don&#39;t have to
1299     // modify JNI GetSuperclass() and thus won&#39;t change its performance.
1300     jvmtiError res = compare_and_normalize_class_versions(the_class,
1301                        scratch_class);
1302     if (res != JVMTI_ERROR_NONE) {
1303       return res;
1304     }
1305 
1306     // verify what the caller passed us
1307     {
1308       // The bug 6214132 caused the verification to fail.
1309       // Information about the_class and scratch_class is temporarily
1310       // recorded into jvmtiThreadState. This data is used to redirect
1311       // the_class to scratch_class in the JVM_* functions called by the
1312       // verifier. Please, refer to jvmtiThreadState.hpp for the detailed
1313       // description.
1314       RedefineVerifyMark rvm(the_class, scratch_class, state);
1315       Verifier::verify(scratch_class, true, THREAD);
1316     }
1317 
1318     if (HAS_PENDING_EXCEPTION) {
1319       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1320       log_info(redefine, class, load, exceptions)(&quot;verify_byte_codes exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1321       CLEAR_PENDING_EXCEPTION;
1322       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1323         return JVMTI_ERROR_OUT_OF_MEMORY;
1324       } else {
1325         // tell the caller the bytecodes are bad
1326         return JVMTI_ERROR_FAILS_VERIFICATION;
1327       }
1328     }
1329 
1330     res = merge_cp_and_rewrite(the_class, scratch_class, THREAD);
1331     if (HAS_PENDING_EXCEPTION) {
1332       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1333       log_info(redefine, class, load, exceptions)(&quot;merge_cp_and_rewrite exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1334       CLEAR_PENDING_EXCEPTION;
1335       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1336         return JVMTI_ERROR_OUT_OF_MEMORY;
1337       } else {
1338         return JVMTI_ERROR_INTERNAL;
1339       }
1340     }
1341 
1342     if (VerifyMergedCPBytecodes) {
1343       // verify what we have done during constant pool merging
1344       {
1345         RedefineVerifyMark rvm(the_class, scratch_class, state);
1346         Verifier::verify(scratch_class, true, THREAD);
1347       }
1348 
1349       if (HAS_PENDING_EXCEPTION) {
1350         Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1351         log_info(redefine, class, load, exceptions)
1352           (&quot;verify_byte_codes post merge-CP exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1353         CLEAR_PENDING_EXCEPTION;
1354         if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1355           return JVMTI_ERROR_OUT_OF_MEMORY;
1356         } else {
1357           // tell the caller that constant pool merging screwed up
1358           return JVMTI_ERROR_INTERNAL;
1359         }
1360       }
1361     }
1362 
1363     Rewriter::rewrite(scratch_class, THREAD);
1364     if (!HAS_PENDING_EXCEPTION) {
1365       scratch_class-&gt;link_methods(THREAD);
1366     }
1367     if (HAS_PENDING_EXCEPTION) {
1368       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1369       log_info(redefine, class, load, exceptions)
1370         (&quot;Rewriter::rewrite or link_methods exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1371       CLEAR_PENDING_EXCEPTION;
1372       if (ex_name == vmSymbols::java_lang_OutOfMemoryError()) {
1373         return JVMTI_ERROR_OUT_OF_MEMORY;
1374       } else {
1375         return JVMTI_ERROR_INTERNAL;
1376       }
1377     }
1378 
1379     log_debug(redefine, class, load)
1380       (&quot;loaded name=%s (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;, the_class-&gt;external_name(), os::available_memory() &gt;&gt; 10);
1381   }
1382 
1383   return JVMTI_ERROR_NONE;
1384 }
1385 
1386 
1387 // Map old_index to new_index as needed. scratch_cp is only needed
1388 // for log calls.
1389 void VM_RedefineClasses::map_index(const constantPoolHandle&amp; scratch_cp,
1390        int old_index, int new_index) {
1391   if (find_new_index(old_index) != 0) {
1392     // old_index is already mapped
1393     return;
1394   }
1395 
1396   if (old_index == new_index) {
1397     // no mapping is needed
1398     return;
1399   }
1400 
1401   _index_map_p-&gt;at_put(old_index, new_index);
1402   _index_map_count++;
1403 
1404   log_trace(redefine, class, constantpool)
1405     (&quot;mapped tag %d at index %d to %d&quot;, scratch_cp-&gt;tag_at(old_index).value(), old_index, new_index);
1406 } // end map_index()
1407 
1408 
1409 // Map old_index to new_index as needed.
1410 void VM_RedefineClasses::map_operand_index(int old_index, int new_index) {
1411   if (find_new_operand_index(old_index) != -1) {
1412     // old_index is already mapped
1413     return;
1414   }
1415 
1416   if (old_index == new_index) {
1417     // no mapping is needed
1418     return;
1419   }
1420 
1421   _operands_index_map_p-&gt;at_put(old_index, new_index);
1422   _operands_index_map_count++;
1423 
1424   log_trace(redefine, class, constantpool)(&quot;mapped bootstrap specifier at index %d to %d&quot;, old_index, new_index);
1425 } // end map_index()
1426 
1427 
1428 // Merge old_cp and scratch_cp and return the results of the merge via
1429 // merge_cp_p. The number of entries in *merge_cp_p is returned via
1430 // merge_cp_length_p. The entries in old_cp occupy the same locations
1431 // in *merge_cp_p. Also creates a map of indices from entries in
1432 // scratch_cp to the corresponding entry in *merge_cp_p. Index map
1433 // entries are only created for entries in scratch_cp that occupy a
1434 // different location in *merged_cp_p.
1435 bool VM_RedefineClasses::merge_constant_pools(const constantPoolHandle&amp; old_cp,
1436        const constantPoolHandle&amp; scratch_cp, constantPoolHandle *merge_cp_p,
1437        int *merge_cp_length_p, TRAPS) {
1438 
1439   if (merge_cp_p == NULL) {
1440     assert(false, &quot;caller must provide scratch constantPool&quot;);
1441     return false; // robustness
1442   }
1443   if (merge_cp_length_p == NULL) {
1444     assert(false, &quot;caller must provide scratch CP length&quot;);
1445     return false; // robustness
1446   }
1447   // Worst case we need old_cp-&gt;length() + scratch_cp()-&gt;length(),
1448   // but the caller might be smart so make sure we have at least
1449   // the minimum.
1450   if ((*merge_cp_p)-&gt;length() &lt; old_cp-&gt;length()) {
1451     assert(false, &quot;merge area too small&quot;);
1452     return false; // robustness
1453   }
1454 
1455   log_info(redefine, class, constantpool)(&quot;old_cp_len=%d, scratch_cp_len=%d&quot;, old_cp-&gt;length(), scratch_cp-&gt;length());
1456 
1457   {
1458     // Pass 0:
1459     // The old_cp is copied to *merge_cp_p; this means that any code
1460     // using old_cp does not have to change. This work looks like a
1461     // perfect fit for ConstantPool*::copy_cp_to(), but we need to
1462     // handle one special case:
1463     // - revert JVM_CONSTANT_Class to JVM_CONSTANT_UnresolvedClass
1464     // This will make verification happy.
1465 
1466     int old_i;  // index into old_cp
1467 
1468     // index zero (0) is not used in constantPools
1469     for (old_i = 1; old_i &lt; old_cp-&gt;length(); old_i++) {
1470       // leave debugging crumb
1471       jbyte old_tag = old_cp-&gt;tag_at(old_i).value();
1472       switch (old_tag) {
1473       case JVM_CONSTANT_Class:
1474       case JVM_CONSTANT_UnresolvedClass:
1475         // revert the copy to JVM_CONSTANT_UnresolvedClass
1476         // May be resolving while calling this so do the same for
1477         // JVM_CONSTANT_UnresolvedClass (klass_name_at() deals with transition)
1478         (*merge_cp_p)-&gt;temp_unresolved_klass_at_put(old_i,
1479           old_cp-&gt;klass_name_index_at(old_i));
1480         break;
1481 
1482       case JVM_CONSTANT_Double:
1483       case JVM_CONSTANT_Long:
1484         // just copy the entry to *merge_cp_p, but double and long take
1485         // two constant pool entries
1486         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);
1487         old_i++;
1488         break;
1489 
1490       default:
1491         // just copy the entry to *merge_cp_p
1492         ConstantPool::copy_entry_to(old_cp, old_i, *merge_cp_p, old_i, CHECK_false);
1493         break;
1494       }
1495     } // end for each old_cp entry
1496 
1497     ConstantPool::copy_operands(old_cp, *merge_cp_p, CHECK_false);
1498     (*merge_cp_p)-&gt;extend_operands(scratch_cp, CHECK_false);
1499 
1500     // We don&#39;t need to sanity check that *merge_cp_length_p is within
1501     // *merge_cp_p bounds since we have the minimum on-entry check above.
1502     (*merge_cp_length_p) = old_i;
1503   }
1504 
1505   // merge_cp_len should be the same as old_cp-&gt;length() at this point
1506   // so this trace message is really a &quot;warm-and-breathing&quot; message.
1507   log_debug(redefine, class, constantpool)(&quot;after pass 0: merge_cp_len=%d&quot;, *merge_cp_length_p);
1508 
1509   int scratch_i;  // index into scratch_cp
1510   {
1511     // Pass 1a:
1512     // Compare scratch_cp entries to the old_cp entries that we have
1513     // already copied to *merge_cp_p. In this pass, we are eliminating
1514     // exact duplicates (matching entry at same index) so we only
1515     // compare entries in the common indice range.
1516     int increment = 1;
1517     int pass1a_length = MIN2(old_cp-&gt;length(), scratch_cp-&gt;length());
1518     for (scratch_i = 1; scratch_i &lt; pass1a_length; scratch_i += increment) {
1519       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1520       case JVM_CONSTANT_Double:
1521       case JVM_CONSTANT_Long:
1522         // double and long take two constant pool entries
1523         increment = 2;
1524         break;
1525 
1526       default:
1527         increment = 1;
1528         break;
1529       }
1530 
1531       bool match = scratch_cp-&gt;compare_entry_to(scratch_i, *merge_cp_p,
1532         scratch_i, CHECK_false);
1533       if (match) {
1534         // found a match at the same index so nothing more to do
1535         continue;
1536       } else if (is_unresolved_class_mismatch(scratch_cp, scratch_i,
1537                                               *merge_cp_p, scratch_i)) {
1538         // The mismatch in compare_entry_to() above is because of a
1539         // resolved versus unresolved class entry at the same index
1540         // with the same string value. Since Pass 0 reverted any
1541         // class entries to unresolved class entries in *merge_cp_p,
1542         // we go with the unresolved class entry.
1543         continue;
1544       }
1545 
1546       int found_i = scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p,
1547         CHECK_false);
1548       if (found_i != 0) {
1549         guarantee(found_i != scratch_i,
1550           &quot;compare_entry_to() and find_matching_entry() do not agree&quot;);
1551 
1552         // Found a matching entry somewhere else in *merge_cp_p so
1553         // just need a mapping entry.
1554         map_index(scratch_cp, scratch_i, found_i);
1555         continue;
1556       }
1557 
1558       // The find_matching_entry() call above could fail to find a match
1559       // due to a resolved versus unresolved class or string entry situation
1560       // like we solved above with the is_unresolved_*_mismatch() calls.
1561       // However, we would have to call is_unresolved_*_mismatch() over
1562       // all of *merge_cp_p (potentially) and that doesn&#39;t seem to be
1563       // worth the time.
1564 
1565       // No match found so we have to append this entry and any unique
1566       // referenced entries to *merge_cp_p.
1567       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
1568         CHECK_false);
1569     }
1570   }
1571 
1572   log_debug(redefine, class, constantpool)
1573     (&quot;after pass 1a: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1574      *merge_cp_length_p, scratch_i, _index_map_count);
1575 
1576   if (scratch_i &lt; scratch_cp-&gt;length()) {
1577     // Pass 1b:
1578     // old_cp is smaller than scratch_cp so there are entries in
1579     // scratch_cp that we have not yet processed. We take care of
1580     // those now.
1581     int increment = 1;
1582     for (; scratch_i &lt; scratch_cp-&gt;length(); scratch_i += increment) {
1583       switch (scratch_cp-&gt;tag_at(scratch_i).value()) {
1584       case JVM_CONSTANT_Double:
1585       case JVM_CONSTANT_Long:
1586         // double and long take two constant pool entries
1587         increment = 2;
1588         break;
1589 
1590       default:
1591         increment = 1;
1592         break;
1593       }
1594 
1595       int found_i =
1596         scratch_cp-&gt;find_matching_entry(scratch_i, *merge_cp_p, CHECK_false);
1597       if (found_i != 0) {
1598         // Found a matching entry somewhere else in *merge_cp_p so
1599         // just need a mapping entry.
1600         map_index(scratch_cp, scratch_i, found_i);
1601         continue;
1602       }
1603 
1604       // No match found so we have to append this entry and any unique
1605       // referenced entries to *merge_cp_p.
1606       append_entry(scratch_cp, scratch_i, merge_cp_p, merge_cp_length_p,
1607         CHECK_false);
1608     }
1609 
1610     log_debug(redefine, class, constantpool)
1611       (&quot;after pass 1b: merge_cp_len=%d, scratch_i=%d, index_map_len=%d&quot;,
1612        *merge_cp_length_p, scratch_i, _index_map_count);
1613   }
1614   finalize_operands_merge(*merge_cp_p, THREAD);
1615 
1616   return true;
1617 } // end merge_constant_pools()
1618 
1619 
1620 // Scoped object to clean up the constant pool(s) created for merging
1621 class MergeCPCleaner {
1622   ClassLoaderData*   _loader_data;
1623   ConstantPool*      _cp;
1624   ConstantPool*      _scratch_cp;
1625  public:
1626   MergeCPCleaner(ClassLoaderData* loader_data, ConstantPool* merge_cp) :
1627                  _loader_data(loader_data), _cp(merge_cp), _scratch_cp(NULL) {}
1628   ~MergeCPCleaner() {
1629     _loader_data-&gt;add_to_deallocate_list(_cp);
1630     if (_scratch_cp != NULL) {
1631       _loader_data-&gt;add_to_deallocate_list(_scratch_cp);
1632     }
1633   }
1634   void add_scratch_cp(ConstantPool* scratch_cp) { _scratch_cp = scratch_cp; }
1635 };
1636 
1637 // Merge constant pools between the_class and scratch_class and
1638 // potentially rewrite bytecodes in scratch_class to use the merged
1639 // constant pool.
1640 jvmtiError VM_RedefineClasses::merge_cp_and_rewrite(
1641              InstanceKlass* the_class, InstanceKlass* scratch_class,
1642              TRAPS) {
1643   // worst case merged constant pool length is old and new combined
1644   int merge_cp_length = the_class-&gt;constants()-&gt;length()
1645         + scratch_class-&gt;constants()-&gt;length();
1646 
1647   // Constant pools are not easily reused so we allocate a new one
1648   // each time.
1649   // merge_cp is created unsafe for concurrent GC processing.  It
1650   // should be marked safe before discarding it. Even though
1651   // garbage,  if it crosses a card boundary, it may be scanned
1652   // in order to find the start of the first complete object on the card.
1653   ClassLoaderData* loader_data = the_class-&gt;class_loader_data();
1654   ConstantPool* merge_cp_oop =
1655     ConstantPool::allocate(loader_data,
1656                            merge_cp_length,
1657                            CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1658   MergeCPCleaner cp_cleaner(loader_data, merge_cp_oop);
1659 
1660   HandleMark hm(THREAD);  // make sure handles are cleared before
1661                           // MergeCPCleaner clears out merge_cp_oop
1662   constantPoolHandle merge_cp(THREAD, merge_cp_oop);
1663 
1664   // Get constants() from the old class because it could have been rewritten
1665   // while we were at a safepoint allocating a new constant pool.
1666   constantPoolHandle old_cp(THREAD, the_class-&gt;constants());
1667   constantPoolHandle scratch_cp(THREAD, scratch_class-&gt;constants());
1668 
1669   // If the length changed, the class was redefined out from under us. Return
1670   // an error.
1671   if (merge_cp_length != the_class-&gt;constants()-&gt;length()
1672          + scratch_class-&gt;constants()-&gt;length()) {
1673     return JVMTI_ERROR_INTERNAL;
1674   }
1675 
1676   // Update the version number of the constant pools (may keep scratch_cp)
1677   merge_cp-&gt;increment_and_save_version(old_cp-&gt;version());
1678   scratch_cp-&gt;increment_and_save_version(old_cp-&gt;version());
1679 
1680   ResourceMark rm(THREAD);
1681   _index_map_count = 0;
1682   _index_map_p = new intArray(scratch_cp-&gt;length(), scratch_cp-&gt;length(), -1);
1683 
1684   _operands_cur_length = ConstantPool::operand_array_length(old_cp-&gt;operands());
1685   _operands_index_map_count = 0;
1686   int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp-&gt;operands());
1687   _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);
1688 
1689   // reference to the cp holder is needed for copy_operands()
1690   merge_cp-&gt;set_pool_holder(scratch_class);
1691   bool result = merge_constant_pools(old_cp, scratch_cp, &amp;merge_cp,
1692                   &amp;merge_cp_length, THREAD);
1693   merge_cp-&gt;set_pool_holder(NULL);
1694 
1695   if (!result) {
1696     // The merge can fail due to memory allocation failure or due
1697     // to robustness checks.
1698     return JVMTI_ERROR_INTERNAL;
1699   }
1700 
1701   if (old_cp-&gt;has_dynamic_constant()) {
1702     merge_cp-&gt;set_has_dynamic_constant();
1703     scratch_cp-&gt;set_has_dynamic_constant();
1704   }
1705 
1706   log_info(redefine, class, constantpool)(&quot;merge_cp_len=%d, index_map_len=%d&quot;, merge_cp_length, _index_map_count);
1707 
1708   if (_index_map_count == 0) {
1709     // there is nothing to map between the new and merged constant pools
1710 
1711     if (old_cp-&gt;length() == scratch_cp-&gt;length()) {
1712       // The old and new constant pools are the same length and the
1713       // index map is empty. This means that the three constant pools
1714       // are equivalent (but not the same). Unfortunately, the new
1715       // constant pool has not gone through link resolution nor have
1716       // the new class bytecodes gone through constant pool cache
1717       // rewriting so we can&#39;t use the old constant pool with the new
1718       // class.
1719 
1720       // toss the merged constant pool at return
1721     } else if (old_cp-&gt;length() &lt; scratch_cp-&gt;length()) {
1722       // The old constant pool has fewer entries than the new constant
1723       // pool and the index map is empty. This means the new constant
1724       // pool is a superset of the old constant pool. However, the old
1725       // class bytecodes have already gone through constant pool cache
1726       // rewriting so we can&#39;t use the new constant pool with the old
1727       // class.
1728 
1729       // toss the merged constant pool at return
1730     } else {
1731       // The old constant pool has more entries than the new constant
1732       // pool and the index map is empty. This means that both the old
1733       // and merged constant pools are supersets of the new constant
1734       // pool.
1735 
1736       // Replace the new constant pool with a shrunken copy of the
1737       // merged constant pool
1738       set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1739                             CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1740       // The new constant pool replaces scratch_cp so have cleaner clean it up.
1741       // It can&#39;t be cleaned up while there are handles to it.
1742       cp_cleaner.add_scratch_cp(scratch_cp());
1743     }
1744   } else {
1745     if (log_is_enabled(Trace, redefine, class, constantpool)) {
1746       // don&#39;t want to loop unless we are tracing
1747       int count = 0;
1748       for (int i = 1; i &lt; _index_map_p-&gt;length(); i++) {
1749         int value = _index_map_p-&gt;at(i);
1750 
1751         if (value != -1) {
1752           log_trace(redefine, class, constantpool)(&quot;index_map[%d]: old=%d new=%d&quot;, count, i, value);
1753           count++;
1754         }
1755       }
1756     }
1757 
1758     // We have entries mapped between the new and merged constant pools
1759     // so we have to rewrite some constant pool references.
1760     if (!rewrite_cp_refs(scratch_class, THREAD)) {
1761       return JVMTI_ERROR_INTERNAL;
1762     }
1763 
1764     // Replace the new constant pool with a shrunken copy of the
1765     // merged constant pool so now the rewritten bytecodes have
1766     // valid references; the previous new constant pool will get
1767     // GCed.
1768     set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1769                           CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
1770     // The new constant pool replaces scratch_cp so have cleaner clean it up.
1771     // It can&#39;t be cleaned up while there are handles to it.
1772     cp_cleaner.add_scratch_cp(scratch_cp());
1773   }
1774 
1775   return JVMTI_ERROR_NONE;
1776 } // end merge_cp_and_rewrite()
1777 
1778 
1779 // Rewrite constant pool references in klass scratch_class.
1780 bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class,
1781        TRAPS) {
1782 
1783   // rewrite constant pool references in the nest attributes:
1784   if (!rewrite_cp_refs_in_nest_attributes(scratch_class)) {
1785     // propagate failure back to caller
1786     return false;
1787   }
1788 
1789   // rewrite constant pool references in the Record attribute:
1790   if (!rewrite_cp_refs_in_record_attribute(scratch_class, THREAD)) {
1791     // propagate failure back to caller
1792     return false;
1793   }
1794 
1795   // rewrite constant pool references in the methods:
1796   if (!rewrite_cp_refs_in_methods(scratch_class, THREAD)) {
1797     // propagate failure back to caller
1798     return false;
1799   }
1800 
1801   // rewrite constant pool references in the class_annotations:
1802   if (!rewrite_cp_refs_in_class_annotations(scratch_class, THREAD)) {
1803     // propagate failure back to caller
1804     return false;
1805   }
1806 
1807   // rewrite constant pool references in the fields_annotations:
1808   if (!rewrite_cp_refs_in_fields_annotations(scratch_class, THREAD)) {
1809     // propagate failure back to caller
1810     return false;
1811   }
1812 
1813   // rewrite constant pool references in the methods_annotations:
1814   if (!rewrite_cp_refs_in_methods_annotations(scratch_class, THREAD)) {
1815     // propagate failure back to caller
1816     return false;
1817   }
1818 
1819   // rewrite constant pool references in the methods_parameter_annotations:
1820   if (!rewrite_cp_refs_in_methods_parameter_annotations(scratch_class,
1821          THREAD)) {
1822     // propagate failure back to caller
1823     return false;
1824   }
1825 
1826   // rewrite constant pool references in the methods_default_annotations:
1827   if (!rewrite_cp_refs_in_methods_default_annotations(scratch_class,
1828          THREAD)) {
1829     // propagate failure back to caller
1830     return false;
1831   }
1832 
1833   // rewrite constant pool references in the class_type_annotations:
1834   if (!rewrite_cp_refs_in_class_type_annotations(scratch_class, THREAD)) {
1835     // propagate failure back to caller
1836     return false;
1837   }
1838 
1839   // rewrite constant pool references in the fields_type_annotations:
1840   if (!rewrite_cp_refs_in_fields_type_annotations(scratch_class, THREAD)) {
1841     // propagate failure back to caller
1842     return false;
1843   }
1844 
1845   // rewrite constant pool references in the methods_type_annotations:
1846   if (!rewrite_cp_refs_in_methods_type_annotations(scratch_class, THREAD)) {
1847     // propagate failure back to caller
1848     return false;
1849   }
1850 
1851   // There can be type annotations in the Code part of a method_info attribute.
1852   // These annotations are not accessible, even by reflection.
1853   // Currently they are not even parsed by the ClassFileParser.
1854   // If runtime access is added they will also need to be rewritten.
1855 
1856   // rewrite source file name index:
1857   u2 source_file_name_idx = scratch_class-&gt;source_file_name_index();
1858   if (source_file_name_idx != 0) {
1859     u2 new_source_file_name_idx = find_new_index(source_file_name_idx);
1860     if (new_source_file_name_idx != 0) {
1861       scratch_class-&gt;set_source_file_name_index(new_source_file_name_idx);
1862     }
1863   }
1864 
1865   // rewrite class generic signature index:
1866   u2 generic_signature_index = scratch_class-&gt;generic_signature_index();
1867   if (generic_signature_index != 0) {
1868     u2 new_generic_signature_index = find_new_index(generic_signature_index);
1869     if (new_generic_signature_index != 0) {
1870       scratch_class-&gt;set_generic_signature_index(new_generic_signature_index);
1871     }
1872   }
1873 
1874   return true;
1875 } // end rewrite_cp_refs()
1876 
1877 // Rewrite constant pool references in the NestHost and NestMembers attributes.
1878 bool VM_RedefineClasses::rewrite_cp_refs_in_nest_attributes(
1879        InstanceKlass* scratch_class) {
1880 
1881   u2 cp_index = scratch_class-&gt;nest_host_index();
1882   if (cp_index != 0) {
1883     scratch_class-&gt;set_nest_host_index(find_new_index(cp_index));
1884   }
1885   Array&lt;u2&gt;* nest_members = scratch_class-&gt;nest_members();
1886   for (int i = 0; i &lt; nest_members-&gt;length(); i++) {
1887     u2 cp_index = nest_members-&gt;at(i);
1888     nest_members-&gt;at_put(i, find_new_index(cp_index));
1889   }
1890   return true;
1891 }
1892 
1893 // Rewrite constant pool references in the Record attribute.
1894 bool VM_RedefineClasses::rewrite_cp_refs_in_record_attribute(
1895        InstanceKlass* scratch_class, TRAPS) {
1896   Array&lt;RecordComponent*&gt;* components = scratch_class-&gt;record_components();
1897   if (components != NULL) {
1898     for (int i = 0; i &lt; components-&gt;length(); i++) {
1899       RecordComponent* component = components-&gt;at(i);
1900       u2 cp_index = component-&gt;name_index();
1901       component-&gt;set_name_index(find_new_index(cp_index));
1902       cp_index = component-&gt;descriptor_index();
1903       component-&gt;set_descriptor_index(find_new_index(cp_index));
1904       cp_index = component-&gt;generic_signature_index();
1905       if (cp_index != 0) {
1906         component-&gt;set_generic_signature_index(find_new_index(cp_index));
1907       }
1908 
1909       AnnotationArray* annotations = component-&gt;annotations();
1910       if (annotations != NULL &amp;&amp; annotations-&gt;length() != 0) {
1911         int byte_i = 0;  // byte index into annotations
1912         if (!rewrite_cp_refs_in_annotations_typeArray(annotations, byte_i, THREAD)) {
1913           log_debug(redefine, class, annotation)(&quot;bad record_component_annotations at %d&quot;, i);
1914           // propagate failure back to caller
1915           return false;
1916         }
1917       }
1918 
1919       AnnotationArray* type_annotations = component-&gt;type_annotations();
1920       if (type_annotations != NULL &amp;&amp; type_annotations-&gt;length() != 0) {
1921         int byte_i = 0;  // byte index into annotations
1922         if (!rewrite_cp_refs_in_annotations_typeArray(type_annotations, byte_i, THREAD)) {
1923           log_debug(redefine, class, annotation)(&quot;bad record_component_type_annotations at %d&quot;, i);
1924           // propagate failure back to caller
1925           return false;
1926         }
1927       }
1928     }
1929   }
1930   return true;
1931 }
1932 
1933 // Rewrite constant pool references in the methods.
1934 bool VM_RedefineClasses::rewrite_cp_refs_in_methods(
1935        InstanceKlass* scratch_class, TRAPS) {
1936 
1937   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
1938 
1939   if (methods == NULL || methods-&gt;length() == 0) {
1940     // no methods so nothing to do
1941     return true;
1942   }
1943 
1944   // rewrite constant pool references in the methods:
1945   for (int i = methods-&gt;length() - 1; i &gt;= 0; i--) {
1946     methodHandle method(THREAD, methods-&gt;at(i));
1947     methodHandle new_method;
1948     rewrite_cp_refs_in_method(method, &amp;new_method, THREAD);
1949     if (!new_method.is_null()) {
1950       // the method has been replaced so save the new method version
1951       // even in the case of an exception.  original method is on the
1952       // deallocation list.
1953       methods-&gt;at_put(i, new_method());
1954     }
1955     if (HAS_PENDING_EXCEPTION) {
1956       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1957       log_info(redefine, class, load, exceptions)(&quot;rewrite_cp_refs_in_method exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1958       // Need to clear pending exception here as the super caller sets
1959       // the JVMTI_ERROR_INTERNAL if the returned value is false.
1960       CLEAR_PENDING_EXCEPTION;
1961       return false;
1962     }
1963   }
1964 
1965   return true;
1966 }
1967 
1968 
1969 // Rewrite constant pool references in the specific method. This code
1970 // was adapted from Rewriter::rewrite_method().
1971 void VM_RedefineClasses::rewrite_cp_refs_in_method(methodHandle method,
1972        methodHandle *new_method_p, TRAPS) {
1973 
1974   *new_method_p = methodHandle();  // default is no new method
1975 
1976   // We cache a pointer to the bytecodes here in code_base. If GC
1977   // moves the Method*, then the bytecodes will also move which
1978   // will likely cause a crash. We create a NoSafepointVerifier
1979   // object to detect whether we pass a possible safepoint in this
1980   // code block.
1981   NoSafepointVerifier nsv;
1982 
1983   // Bytecodes and their length
1984   address code_base = method-&gt;code_base();
1985   int code_length = method-&gt;code_size();
1986 
1987   int bc_length;
1988   for (int bci = 0; bci &lt; code_length; bci += bc_length) {
1989     address bcp = code_base + bci;
1990     Bytecodes::Code c = (Bytecodes::Code)(*bcp);
1991 
1992     bc_length = Bytecodes::length_for(c);
1993     if (bc_length == 0) {
1994       // More complicated bytecodes report a length of zero so
1995       // we have to try again a slightly different way.
1996       bc_length = Bytecodes::length_at(method(), bcp);
1997     }
1998 
1999     assert(bc_length != 0, &quot;impossible bytecode length&quot;);
2000 
2001     switch (c) {
2002       case Bytecodes::_ldc:
2003       {
2004         int cp_index = *(bcp + 1);
2005         int new_index = find_new_index(cp_index);
2006 
2007         if (StressLdcRewrite &amp;&amp; new_index == 0) {
2008           // If we are stressing ldc -&gt; ldc_w rewriting, then we
2009           // always need a new_index value.
2010           new_index = cp_index;
2011         }
2012         if (new_index != 0) {
2013           // the original index is mapped so we have more work to do
2014           if (!StressLdcRewrite &amp;&amp; new_index &lt;= max_jubyte) {
2015             // The new value can still use ldc instead of ldc_w
2016             // unless we are trying to stress ldc -&gt; ldc_w rewriting
2017             log_trace(redefine, class, constantpool)
2018               (&quot;%s@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c), p2i(bcp), cp_index, new_index);
2019             *(bcp + 1) = new_index;
2020           } else {
2021             log_trace(redefine, class, constantpool)
2022               (&quot;%s-&gt;ldc_w@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c), p2i(bcp), cp_index, new_index);
2023             // the new value needs ldc_w instead of ldc
2024             u_char inst_buffer[4]; // max instruction size is 4 bytes
2025             bcp = (address)inst_buffer;
2026             // construct new instruction sequence
2027             *bcp = Bytecodes::_ldc_w;
2028             bcp++;
2029             // Rewriter::rewrite_method() does not rewrite ldc -&gt; ldc_w.
2030             // See comment below for difference between put_Java_u2()
2031             // and put_native_u2().
2032             Bytes::put_Java_u2(bcp, new_index);
2033 
2034             Relocator rc(method, NULL /* no RelocatorListener needed */);
2035             methodHandle m;
2036             {
2037               PauseNoSafepointVerifier pnsv(&amp;nsv);
2038 
2039               // ldc is 2 bytes and ldc_w is 3 bytes
2040               m = rc.insert_space_at(bci, 3, inst_buffer, CHECK);
2041             }
2042 
2043             // return the new method so that the caller can update
2044             // the containing class
2045             *new_method_p = method = m;
2046             // switch our bytecode processing loop from the old method
2047             // to the new method
2048             code_base = method-&gt;code_base();
2049             code_length = method-&gt;code_size();
2050             bcp = code_base + bci;
2051             c = (Bytecodes::Code)(*bcp);
2052             bc_length = Bytecodes::length_for(c);
2053             assert(bc_length != 0, &quot;sanity check&quot;);
2054           } // end we need ldc_w instead of ldc
2055         } // end if there is a mapped index
2056       } break;
2057 
2058       // these bytecodes have a two-byte constant pool index
2059       case Bytecodes::_anewarray      : // fall through
2060       case Bytecodes::_checkcast      : // fall through
2061       case Bytecodes::_getfield       : // fall through
2062       case Bytecodes::_getstatic      : // fall through
2063       case Bytecodes::_instanceof     : // fall through
2064       case Bytecodes::_invokedynamic  : // fall through
2065       case Bytecodes::_invokeinterface: // fall through
2066       case Bytecodes::_invokespecial  : // fall through
2067       case Bytecodes::_invokestatic   : // fall through
2068       case Bytecodes::_invokevirtual  : // fall through
2069       case Bytecodes::_ldc_w          : // fall through
2070       case Bytecodes::_ldc2_w         : // fall through
2071       case Bytecodes::_multianewarray : // fall through
2072       case Bytecodes::_new            : // fall through
2073       case Bytecodes::_putfield       : // fall through
2074       case Bytecodes::_putstatic      :
2075       {
2076         address p = bcp + 1;
2077         int cp_index = Bytes::get_Java_u2(p);
2078         int new_index = find_new_index(cp_index);
2079         if (new_index != 0) {
2080           // the original index is mapped so update w/ new value
2081           log_trace(redefine, class, constantpool)
2082             (&quot;%s@&quot; INTPTR_FORMAT &quot; old=%d, new=%d&quot;, Bytecodes::name(c),p2i(bcp), cp_index, new_index);
2083           // Rewriter::rewrite_method() uses put_native_u2() in this
2084           // situation because it is reusing the constant pool index
2085           // location for a native index into the ConstantPoolCache.
2086           // Since we are updating the constant pool index prior to
2087           // verification and ConstantPoolCache initialization, we
2088           // need to keep the new index in Java byte order.
2089           Bytes::put_Java_u2(p, new_index);
2090         }
2091       } break;
2092       default:
2093         break;
2094     }
2095   } // end for each bytecode
2096 
2097   // We also need to rewrite the parameter name indexes, if there is
2098   // method parameter data present
2099   if(method-&gt;has_method_parameters()) {
2100     const int len = method-&gt;method_parameters_length();
2101     MethodParametersElement* elem = method-&gt;method_parameters_start();
2102 
2103     for (int i = 0; i &lt; len; i++) {
2104       const u2 cp_index = elem[i].name_cp_index;
2105       const u2 new_cp_index = find_new_index(cp_index);
2106       if (new_cp_index != 0) {
2107         elem[i].name_cp_index = new_cp_index;
2108       }
2109     }
2110   }
2111 } // end rewrite_cp_refs_in_method()
2112 
2113 
2114 // Rewrite constant pool references in the class_annotations field.
2115 bool VM_RedefineClasses::rewrite_cp_refs_in_class_annotations(
2116        InstanceKlass* scratch_class, TRAPS) {
2117 
2118   AnnotationArray* class_annotations = scratch_class-&gt;class_annotations();
2119   if (class_annotations == NULL || class_annotations-&gt;length() == 0) {
2120     // no class_annotations so nothing to do
2121     return true;
2122   }
2123 
2124   log_debug(redefine, class, annotation)(&quot;class_annotations length=%d&quot;, class_annotations-&gt;length());
2125 
2126   int byte_i = 0;  // byte index into class_annotations
2127   return rewrite_cp_refs_in_annotations_typeArray(class_annotations, byte_i,
2128            THREAD);
2129 }
2130 
2131 
2132 // Rewrite constant pool references in an annotations typeArray. This
2133 // &quot;structure&quot; is adapted from the RuntimeVisibleAnnotations_attribute
2134 // that is described in section 4.8.15 of the 2nd-edition of the VM spec:
2135 //
2136 // annotations_typeArray {
2137 //   u2 num_annotations;
2138 //   annotation annotations[num_annotations];
2139 // }
2140 //
2141 bool VM_RedefineClasses::rewrite_cp_refs_in_annotations_typeArray(
2142        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2143 
2144   if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2145     // not enough room for num_annotations field
2146     log_debug(redefine, class, annotation)(&quot;length() is too small for num_annotations field&quot;);
2147     return false;
2148   }
2149 
2150   u2 num_annotations = Bytes::get_Java_u2((address)
2151                          annotations_typeArray-&gt;adr_at(byte_i_ref));
2152   byte_i_ref += 2;
2153 
2154   log_debug(redefine, class, annotation)(&quot;num_annotations=%d&quot;, num_annotations);
2155 
2156   int calc_num_annotations = 0;
2157   for (; calc_num_annotations &lt; num_annotations; calc_num_annotations++) {
2158     if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2159            byte_i_ref, THREAD)) {
2160       log_debug(redefine, class, annotation)(&quot;bad annotation_struct at %d&quot;, calc_num_annotations);
2161       // propagate failure back to caller
2162       return false;
2163     }
2164   }
2165   assert(num_annotations == calc_num_annotations, &quot;sanity check&quot;);
2166 
2167   return true;
2168 } // end rewrite_cp_refs_in_annotations_typeArray()
2169 
2170 
2171 // Rewrite constant pool references in the annotation struct portion of
2172 // an annotations_typeArray. This &quot;structure&quot; is from section 4.8.15 of
2173 // the 2nd-edition of the VM spec:
2174 //
2175 // struct annotation {
2176 //   u2 type_index;
2177 //   u2 num_element_value_pairs;
2178 //   {
2179 //     u2 element_name_index;
2180 //     element_value value;
2181 //   } element_value_pairs[num_element_value_pairs];
2182 // }
2183 //
2184 bool VM_RedefineClasses::rewrite_cp_refs_in_annotation_struct(
2185        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2186   if ((byte_i_ref + 2 + 2) &gt; annotations_typeArray-&gt;length()) {
2187     // not enough room for smallest annotation_struct
2188     log_debug(redefine, class, annotation)(&quot;length() is too small for annotation_struct&quot;);
2189     return false;
2190   }
2191 
2192   u2 type_index = rewrite_cp_ref_in_annotation_data(annotations_typeArray,
2193                     byte_i_ref, &quot;type_index&quot;, THREAD);
2194 
2195   u2 num_element_value_pairs = Bytes::get_Java_u2((address)
2196                                  annotations_typeArray-&gt;adr_at(byte_i_ref));
2197   byte_i_ref += 2;
2198 
2199   log_debug(redefine, class, annotation)
2200     (&quot;type_index=%d  num_element_value_pairs=%d&quot;, type_index, num_element_value_pairs);
2201 
2202   int calc_num_element_value_pairs = 0;
2203   for (; calc_num_element_value_pairs &lt; num_element_value_pairs;
2204        calc_num_element_value_pairs++) {
2205     if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2206       // not enough room for another element_name_index, let alone
2207       // the rest of another component
2208       log_debug(redefine, class, annotation)(&quot;length() is too small for element_name_index&quot;);
2209       return false;
2210     }
2211 
2212     u2 element_name_index = rewrite_cp_ref_in_annotation_data(
2213                               annotations_typeArray, byte_i_ref,
2214                               &quot;element_name_index&quot;, THREAD);
2215 
2216     log_debug(redefine, class, annotation)(&quot;element_name_index=%d&quot;, element_name_index);
2217 
2218     if (!rewrite_cp_refs_in_element_value(annotations_typeArray,
2219            byte_i_ref, THREAD)) {
2220       log_debug(redefine, class, annotation)(&quot;bad element_value at %d&quot;, calc_num_element_value_pairs);
2221       // propagate failure back to caller
2222       return false;
2223     }
2224   } // end for each component
2225   assert(num_element_value_pairs == calc_num_element_value_pairs,
2226     &quot;sanity check&quot;);
2227 
2228   return true;
2229 } // end rewrite_cp_refs_in_annotation_struct()
2230 
2231 
2232 // Rewrite a constant pool reference at the current position in
2233 // annotations_typeArray if needed. Returns the original constant
2234 // pool reference if a rewrite was not needed or the new constant
2235 // pool reference if a rewrite was needed.
2236 u2 VM_RedefineClasses::rewrite_cp_ref_in_annotation_data(
2237      AnnotationArray* annotations_typeArray, int &amp;byte_i_ref,
2238      const char * trace_mesg, TRAPS) {
2239 
2240   address cp_index_addr = (address)
2241     annotations_typeArray-&gt;adr_at(byte_i_ref);
2242   u2 old_cp_index = Bytes::get_Java_u2(cp_index_addr);
2243   u2 new_cp_index = find_new_index(old_cp_index);
2244   if (new_cp_index != 0) {
2245     log_debug(redefine, class, annotation)(&quot;mapped old %s=%d&quot;, trace_mesg, old_cp_index);
2246     Bytes::put_Java_u2(cp_index_addr, new_cp_index);
2247     old_cp_index = new_cp_index;
2248   }
2249   byte_i_ref += 2;
2250   return old_cp_index;
2251 }
2252 
2253 
2254 // Rewrite constant pool references in the element_value portion of an
2255 // annotations_typeArray. This &quot;structure&quot; is from section 4.8.15.1 of
2256 // the 2nd-edition of the VM spec:
2257 //
2258 // struct element_value {
2259 //   u1 tag;
2260 //   union {
2261 //     u2 const_value_index;
2262 //     {
2263 //       u2 type_name_index;
2264 //       u2 const_name_index;
2265 //     } enum_const_value;
2266 //     u2 class_info_index;
2267 //     annotation annotation_value;
2268 //     struct {
2269 //       u2 num_values;
2270 //       element_value values[num_values];
2271 //     } array_value;
2272 //   } value;
2273 // }
2274 //
2275 bool VM_RedefineClasses::rewrite_cp_refs_in_element_value(
2276        AnnotationArray* annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
2277 
2278   if ((byte_i_ref + 1) &gt; annotations_typeArray-&gt;length()) {
2279     // not enough room for a tag let alone the rest of an element_value
2280     log_debug(redefine, class, annotation)(&quot;length() is too small for a tag&quot;);
2281     return false;
2282   }
2283 
2284   u1 tag = annotations_typeArray-&gt;at(byte_i_ref);
2285   byte_i_ref++;
2286   log_debug(redefine, class, annotation)(&quot;tag=&#39;%c&#39;&quot;, tag);
2287 
2288   switch (tag) {
2289     // These BaseType tag values are from Table 4.2 in VM spec:
2290     case JVM_SIGNATURE_BYTE:
2291     case JVM_SIGNATURE_CHAR:
2292     case JVM_SIGNATURE_DOUBLE:
2293     case JVM_SIGNATURE_FLOAT:
2294     case JVM_SIGNATURE_INT:
2295     case JVM_SIGNATURE_LONG:
2296     case JVM_SIGNATURE_SHORT:
2297     case JVM_SIGNATURE_BOOLEAN:
2298 
2299     // The remaining tag values are from Table 4.8 in the 2nd-edition of
2300     // the VM spec:
2301     case &#39;s&#39;:
2302     {
2303       // For the above tag values (including the BaseType values),
2304       // value.const_value_index is right union field.
2305 
2306       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2307         // not enough room for a const_value_index
2308         log_debug(redefine, class, annotation)(&quot;length() is too small for a const_value_index&quot;);
2309         return false;
2310       }
2311 
2312       u2 const_value_index = rewrite_cp_ref_in_annotation_data(
2313                                annotations_typeArray, byte_i_ref,
2314                                &quot;const_value_index&quot;, THREAD);
2315 
2316       log_debug(redefine, class, annotation)(&quot;const_value_index=%d&quot;, const_value_index);
2317     } break;
2318 
2319     case &#39;e&#39;:
2320     {
2321       // for the above tag value, value.enum_const_value is right union field
2322 
2323       if ((byte_i_ref + 4) &gt; annotations_typeArray-&gt;length()) {
2324         // not enough room for a enum_const_value
2325         log_debug(redefine, class, annotation)(&quot;length() is too small for a enum_const_value&quot;);
2326         return false;
2327       }
2328 
2329       u2 type_name_index = rewrite_cp_ref_in_annotation_data(
2330                              annotations_typeArray, byte_i_ref,
2331                              &quot;type_name_index&quot;, THREAD);
2332 
2333       u2 const_name_index = rewrite_cp_ref_in_annotation_data(
2334                               annotations_typeArray, byte_i_ref,
2335                               &quot;const_name_index&quot;, THREAD);
2336 
2337       log_debug(redefine, class, annotation)
2338         (&quot;type_name_index=%d  const_name_index=%d&quot;, type_name_index, const_name_index);
2339     } break;
2340 
2341     case &#39;c&#39;:
2342     {
2343       // for the above tag value, value.class_info_index is right union field
2344 
2345       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2346         // not enough room for a class_info_index
2347         log_debug(redefine, class, annotation)(&quot;length() is too small for a class_info_index&quot;);
2348         return false;
2349       }
2350 
2351       u2 class_info_index = rewrite_cp_ref_in_annotation_data(
2352                               annotations_typeArray, byte_i_ref,
2353                               &quot;class_info_index&quot;, THREAD);
2354 
2355       log_debug(redefine, class, annotation)(&quot;class_info_index=%d&quot;, class_info_index);
2356     } break;
2357 
2358     case &#39;@&#39;:
2359       // For the above tag value, value.attr_value is the right union
2360       // field. This is a nested annotation.
2361       if (!rewrite_cp_refs_in_annotation_struct(annotations_typeArray,
2362              byte_i_ref, THREAD)) {
2363         // propagate failure back to caller
2364         return false;
2365       }
2366       break;
2367 
2368     case JVM_SIGNATURE_ARRAY:
2369     {
2370       if ((byte_i_ref + 2) &gt; annotations_typeArray-&gt;length()) {
2371         // not enough room for a num_values field
2372         log_debug(redefine, class, annotation)(&quot;length() is too small for a num_values field&quot;);
2373         return false;
2374       }
2375 
2376       // For the above tag value, value.array_value is the right union
2377       // field. This is an array of nested element_value.
2378       u2 num_values = Bytes::get_Java_u2((address)
2379                         annotations_typeArray-&gt;adr_at(byte_i_ref));
2380       byte_i_ref += 2;
2381       log_debug(redefine, class, annotation)(&quot;num_values=%d&quot;, num_values);
2382 
2383       int calc_num_values = 0;
2384       for (; calc_num_values &lt; num_values; calc_num_values++) {
2385         if (!rewrite_cp_refs_in_element_value(
2386                annotations_typeArray, byte_i_ref, THREAD)) {
2387           log_debug(redefine, class, annotation)(&quot;bad nested element_value at %d&quot;, calc_num_values);
2388           // propagate failure back to caller
2389           return false;
2390         }
2391       }
2392       assert(num_values == calc_num_values, &quot;sanity check&quot;);
2393     } break;
2394 
2395     default:
2396       log_debug(redefine, class, annotation)(&quot;bad tag=0x%x&quot;, tag);
2397       return false;
2398   } // end decode tag field
2399 
2400   return true;
2401 } // end rewrite_cp_refs_in_element_value()
2402 
2403 
2404 // Rewrite constant pool references in a fields_annotations field.
2405 bool VM_RedefineClasses::rewrite_cp_refs_in_fields_annotations(
2406        InstanceKlass* scratch_class, TRAPS) {
2407 
2408   Array&lt;AnnotationArray*&gt;* fields_annotations = scratch_class-&gt;fields_annotations();
2409 
2410   if (fields_annotations == NULL || fields_annotations-&gt;length() == 0) {
2411     // no fields_annotations so nothing to do
2412     return true;
2413   }
2414 
2415   log_debug(redefine, class, annotation)(&quot;fields_annotations length=%d&quot;, fields_annotations-&gt;length());
2416 
2417   for (int i = 0; i &lt; fields_annotations-&gt;length(); i++) {
2418     AnnotationArray* field_annotations = fields_annotations-&gt;at(i);
2419     if (field_annotations == NULL || field_annotations-&gt;length() == 0) {
2420       // this field does not have any annotations so skip it
2421       continue;
2422     }
2423 
2424     int byte_i = 0;  // byte index into field_annotations
2425     if (!rewrite_cp_refs_in_annotations_typeArray(field_annotations, byte_i,
2426            THREAD)) {
2427       log_debug(redefine, class, annotation)(&quot;bad field_annotations at %d&quot;, i);
2428       // propagate failure back to caller
2429       return false;
2430     }
2431   }
2432 
2433   return true;
2434 } // end rewrite_cp_refs_in_fields_annotations()
2435 
2436 
2437 // Rewrite constant pool references in a methods_annotations field.
2438 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_annotations(
2439        InstanceKlass* scratch_class, TRAPS) {
2440 
2441   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2442     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2443     AnnotationArray* method_annotations = m-&gt;constMethod()-&gt;method_annotations();
2444 
2445     if (method_annotations == NULL || method_annotations-&gt;length() == 0) {
2446       // this method does not have any annotations so skip it
2447       continue;
2448     }
2449 
2450     int byte_i = 0;  // byte index into method_annotations
2451     if (!rewrite_cp_refs_in_annotations_typeArray(method_annotations, byte_i,
2452            THREAD)) {
2453       log_debug(redefine, class, annotation)(&quot;bad method_annotations at %d&quot;, i);
2454       // propagate failure back to caller
2455       return false;
2456     }
2457   }
2458 
2459   return true;
2460 } // end rewrite_cp_refs_in_methods_annotations()
2461 
2462 
2463 // Rewrite constant pool references in a methods_parameter_annotations
2464 // field. This &quot;structure&quot; is adapted from the
2465 // RuntimeVisibleParameterAnnotations_attribute described in section
2466 // 4.8.17 of the 2nd-edition of the VM spec:
2467 //
2468 // methods_parameter_annotations_typeArray {
2469 //   u1 num_parameters;
2470 //   {
2471 //     u2 num_annotations;
2472 //     annotation annotations[num_annotations];
2473 //   } parameter_annotations[num_parameters];
2474 // }
2475 //
2476 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_parameter_annotations(
2477        InstanceKlass* scratch_class, TRAPS) {
2478 
2479   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2480     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2481     AnnotationArray* method_parameter_annotations = m-&gt;constMethod()-&gt;parameter_annotations();
2482     if (method_parameter_annotations == NULL
2483         || method_parameter_annotations-&gt;length() == 0) {
2484       // this method does not have any parameter annotations so skip it
2485       continue;
2486     }
2487 
2488     if (method_parameter_annotations-&gt;length() &lt; 1) {
2489       // not enough room for a num_parameters field
2490       log_debug(redefine, class, annotation)(&quot;length() is too small for a num_parameters field at %d&quot;, i);
2491       return false;
2492     }
2493 
2494     int byte_i = 0;  // byte index into method_parameter_annotations
2495 
2496     u1 num_parameters = method_parameter_annotations-&gt;at(byte_i);
2497     byte_i++;
2498 
2499     log_debug(redefine, class, annotation)(&quot;num_parameters=%d&quot;, num_parameters);
2500 
2501     int calc_num_parameters = 0;
2502     for (; calc_num_parameters &lt; num_parameters; calc_num_parameters++) {
2503       if (!rewrite_cp_refs_in_annotations_typeArray(
2504              method_parameter_annotations, byte_i, THREAD)) {
2505         log_debug(redefine, class, annotation)(&quot;bad method_parameter_annotations at %d&quot;, calc_num_parameters);
2506         // propagate failure back to caller
2507         return false;
2508       }
2509     }
2510     assert(num_parameters == calc_num_parameters, &quot;sanity check&quot;);
2511   }
2512 
2513   return true;
2514 } // end rewrite_cp_refs_in_methods_parameter_annotations()
2515 
2516 
2517 // Rewrite constant pool references in a methods_default_annotations
2518 // field. This &quot;structure&quot; is adapted from the AnnotationDefault_attribute
2519 // that is described in section 4.8.19 of the 2nd-edition of the VM spec:
2520 //
2521 // methods_default_annotations_typeArray {
2522 //   element_value default_value;
2523 // }
2524 //
2525 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_default_annotations(
2526        InstanceKlass* scratch_class, TRAPS) {
2527 
2528   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2529     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2530     AnnotationArray* method_default_annotations = m-&gt;constMethod()-&gt;default_annotations();
2531     if (method_default_annotations == NULL
2532         || method_default_annotations-&gt;length() == 0) {
2533       // this method does not have any default annotations so skip it
2534       continue;
2535     }
2536 
2537     int byte_i = 0;  // byte index into method_default_annotations
2538 
2539     if (!rewrite_cp_refs_in_element_value(
2540            method_default_annotations, byte_i, THREAD)) {
2541       log_debug(redefine, class, annotation)(&quot;bad default element_value at %d&quot;, i);
2542       // propagate failure back to caller
2543       return false;
2544     }
2545   }
2546 
2547   return true;
2548 } // end rewrite_cp_refs_in_methods_default_annotations()
2549 
2550 
2551 // Rewrite constant pool references in a class_type_annotations field.
2552 bool VM_RedefineClasses::rewrite_cp_refs_in_class_type_annotations(
2553        InstanceKlass* scratch_class, TRAPS) {
2554 
2555   AnnotationArray* class_type_annotations = scratch_class-&gt;class_type_annotations();
2556   if (class_type_annotations == NULL || class_type_annotations-&gt;length() == 0) {
2557     // no class_type_annotations so nothing to do
2558     return true;
2559   }
2560 
2561   log_debug(redefine, class, annotation)(&quot;class_type_annotations length=%d&quot;, class_type_annotations-&gt;length());
2562 
2563   int byte_i = 0;  // byte index into class_type_annotations
2564   return rewrite_cp_refs_in_type_annotations_typeArray(class_type_annotations,
2565       byte_i, &quot;ClassFile&quot;, THREAD);
2566 } // end rewrite_cp_refs_in_class_type_annotations()
2567 
2568 
2569 // Rewrite constant pool references in a fields_type_annotations field.
2570 bool VM_RedefineClasses::rewrite_cp_refs_in_fields_type_annotations(
2571        InstanceKlass* scratch_class, TRAPS) {
2572 
2573   Array&lt;AnnotationArray*&gt;* fields_type_annotations = scratch_class-&gt;fields_type_annotations();
2574   if (fields_type_annotations == NULL || fields_type_annotations-&gt;length() == 0) {
2575     // no fields_type_annotations so nothing to do
2576     return true;
2577   }
2578 
2579   log_debug(redefine, class, annotation)(&quot;fields_type_annotations length=%d&quot;, fields_type_annotations-&gt;length());
2580 
2581   for (int i = 0; i &lt; fields_type_annotations-&gt;length(); i++) {
2582     AnnotationArray* field_type_annotations = fields_type_annotations-&gt;at(i);
2583     if (field_type_annotations == NULL || field_type_annotations-&gt;length() == 0) {
2584       // this field does not have any annotations so skip it
2585       continue;
2586     }
2587 
2588     int byte_i = 0;  // byte index into field_type_annotations
2589     if (!rewrite_cp_refs_in_type_annotations_typeArray(field_type_annotations,
2590            byte_i, &quot;field_info&quot;, THREAD)) {
2591       log_debug(redefine, class, annotation)(&quot;bad field_type_annotations at %d&quot;, i);
2592       // propagate failure back to caller
2593       return false;
2594     }
2595   }
2596 
2597   return true;
2598 } // end rewrite_cp_refs_in_fields_type_annotations()
2599 
2600 
2601 // Rewrite constant pool references in a methods_type_annotations field.
2602 bool VM_RedefineClasses::rewrite_cp_refs_in_methods_type_annotations(
2603        InstanceKlass* scratch_class, TRAPS) {
2604 
2605   for (int i = 0; i &lt; scratch_class-&gt;methods()-&gt;length(); i++) {
2606     Method* m = scratch_class-&gt;methods()-&gt;at(i);
2607     AnnotationArray* method_type_annotations = m-&gt;constMethod()-&gt;type_annotations();
2608 
2609     if (method_type_annotations == NULL || method_type_annotations-&gt;length() == 0) {
2610       // this method does not have any annotations so skip it
2611       continue;
2612     }
2613 
2614     log_debug(redefine, class, annotation)(&quot;methods type_annotations length=%d&quot;, method_type_annotations-&gt;length());
2615 
2616     int byte_i = 0;  // byte index into method_type_annotations
2617     if (!rewrite_cp_refs_in_type_annotations_typeArray(method_type_annotations,
2618            byte_i, &quot;method_info&quot;, THREAD)) {
2619       log_debug(redefine, class, annotation)(&quot;bad method_type_annotations at %d&quot;, i);
2620       // propagate failure back to caller
2621       return false;
2622     }
2623   }
2624 
2625   return true;
2626 } // end rewrite_cp_refs_in_methods_type_annotations()
2627 
2628 
2629 // Rewrite constant pool references in a type_annotations
2630 // field. This &quot;structure&quot; is adapted from the
2631 // RuntimeVisibleTypeAnnotations_attribute described in
2632 // section 4.7.20 of the Java SE 8 Edition of the VM spec:
2633 //
2634 // type_annotations_typeArray {
2635 //   u2              num_annotations;
2636 //   type_annotation annotations[num_annotations];
2637 // }
2638 //
2639 bool VM_RedefineClasses::rewrite_cp_refs_in_type_annotations_typeArray(
2640        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2641        const char * location_mesg, TRAPS) {
2642 
2643   if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2644     // not enough room for num_annotations field
2645     log_debug(redefine, class, annotation)(&quot;length() is too small for num_annotations field&quot;);
2646     return false;
2647   }
2648 
2649   u2 num_annotations = Bytes::get_Java_u2((address)
2650                          type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2651   byte_i_ref += 2;
2652 
2653   log_debug(redefine, class, annotation)(&quot;num_type_annotations=%d&quot;, num_annotations);
2654 
2655   int calc_num_annotations = 0;
2656   for (; calc_num_annotations &lt; num_annotations; calc_num_annotations++) {
2657     if (!rewrite_cp_refs_in_type_annotation_struct(type_annotations_typeArray,
2658            byte_i_ref, location_mesg, THREAD)) {
2659       log_debug(redefine, class, annotation)(&quot;bad type_annotation_struct at %d&quot;, calc_num_annotations);
2660       // propagate failure back to caller
2661       return false;
2662     }
2663   }
2664   assert(num_annotations == calc_num_annotations, &quot;sanity check&quot;);
2665 
2666   if (byte_i_ref != type_annotations_typeArray-&gt;length()) {
2667     log_debug(redefine, class, annotation)
2668       (&quot;read wrong amount of bytes at end of processing type_annotations_typeArray (%d of %d bytes were read)&quot;,
2669        byte_i_ref, type_annotations_typeArray-&gt;length());
2670     return false;
2671   }
2672 
2673   return true;
2674 } // end rewrite_cp_refs_in_type_annotations_typeArray()
2675 
2676 
2677 // Rewrite constant pool references in a type_annotation
2678 // field. This &quot;structure&quot; is adapted from the
2679 // RuntimeVisibleTypeAnnotations_attribute described in
2680 // section 4.7.20 of the Java SE 8 Edition of the VM spec:
2681 //
2682 // type_annotation {
2683 //   u1 target_type;
2684 //   union {
2685 //     type_parameter_target;
2686 //     supertype_target;
2687 //     type_parameter_bound_target;
2688 //     empty_target;
2689 //     method_formal_parameter_target;
2690 //     throws_target;
2691 //     localvar_target;
2692 //     catch_target;
2693 //     offset_target;
2694 //     type_argument_target;
2695 //   } target_info;
2696 //   type_path target_path;
2697 //   annotation anno;
2698 // }
2699 //
2700 bool VM_RedefineClasses::rewrite_cp_refs_in_type_annotation_struct(
2701        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2702        const char * location_mesg, TRAPS) {
2703 
2704   if (!skip_type_annotation_target(type_annotations_typeArray,
2705          byte_i_ref, location_mesg, THREAD)) {
2706     return false;
2707   }
2708 
2709   if (!skip_type_annotation_type_path(type_annotations_typeArray,
2710          byte_i_ref, THREAD)) {
2711     return false;
2712   }
2713 
2714   if (!rewrite_cp_refs_in_annotation_struct(type_annotations_typeArray,
2715          byte_i_ref, THREAD)) {
2716     return false;
2717   }
2718 
2719   return true;
2720 } // end rewrite_cp_refs_in_type_annotation_struct()
2721 
2722 
2723 // Read, verify and skip over the target_type and target_info part
2724 // so that rewriting can continue in the later parts of the struct.
2725 //
2726 // u1 target_type;
2727 // union {
2728 //   type_parameter_target;
2729 //   supertype_target;
2730 //   type_parameter_bound_target;
2731 //   empty_target;
2732 //   method_formal_parameter_target;
2733 //   throws_target;
2734 //   localvar_target;
2735 //   catch_target;
2736 //   offset_target;
2737 //   type_argument_target;
2738 // } target_info;
2739 //
2740 bool VM_RedefineClasses::skip_type_annotation_target(
2741        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref,
2742        const char * location_mesg, TRAPS) {
2743 
2744   if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2745     // not enough room for a target_type let alone the rest of a type_annotation
2746     log_debug(redefine, class, annotation)(&quot;length() is too small for a target_type&quot;);
2747     return false;
2748   }
2749 
2750   u1 target_type = type_annotations_typeArray-&gt;at(byte_i_ref);
2751   byte_i_ref += 1;
2752   log_debug(redefine, class, annotation)(&quot;target_type=0x%.2x&quot;, target_type);
2753   log_debug(redefine, class, annotation)(&quot;location=%s&quot;, location_mesg);
2754 
2755   // Skip over target_info
2756   switch (target_type) {
2757     case 0x00:
2758     // kind: type parameter declaration of generic class or interface
2759     // location: ClassFile
2760     case 0x01:
2761     // kind: type parameter declaration of generic method or constructor
2762     // location: method_info
2763 
2764     {
2765       // struct:
2766       // type_parameter_target {
2767       //   u1 type_parameter_index;
2768       // }
2769       //
2770       if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2771         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_parameter_target&quot;);
2772         return false;
2773       }
2774 
2775       u1 type_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2776       byte_i_ref += 1;
2777 
2778       log_debug(redefine, class, annotation)(&quot;type_parameter_target: type_parameter_index=%d&quot;, type_parameter_index);
2779     } break;
2780 
2781     case 0x10:
2782     // kind: type in extends clause of class or interface declaration
2783     //       (including the direct superclass of an unsafe anonymous class declaration),
2784     //       or in implements clause of interface declaration
2785     // location: ClassFile
2786 
2787     {
2788       // struct:
2789       // supertype_target {
2790       //   u2 supertype_index;
2791       // }
2792       //
2793       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2794         log_debug(redefine, class, annotation)(&quot;length() is too small for a supertype_target&quot;);
2795         return false;
2796       }
2797 
2798       u2 supertype_index = Bytes::get_Java_u2((address)
2799                              type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2800       byte_i_ref += 2;
2801 
2802       log_debug(redefine, class, annotation)(&quot;supertype_target: supertype_index=%d&quot;, supertype_index);
2803     } break;
2804 
2805     case 0x11:
2806     // kind: type in bound of type parameter declaration of generic class or interface
2807     // location: ClassFile
2808     case 0x12:
2809     // kind: type in bound of type parameter declaration of generic method or constructor
2810     // location: method_info
2811 
2812     {
2813       // struct:
2814       // type_parameter_bound_target {
2815       //   u1 type_parameter_index;
2816       //   u1 bound_index;
2817       // }
2818       //
2819       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2820         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_parameter_bound_target&quot;);
2821         return false;
2822       }
2823 
2824       u1 type_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2825       byte_i_ref += 1;
2826       u1 bound_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2827       byte_i_ref += 1;
2828 
2829       log_debug(redefine, class, annotation)
2830         (&quot;type_parameter_bound_target: type_parameter_index=%d, bound_index=%d&quot;, type_parameter_index, bound_index);
2831     } break;
2832 
2833     case 0x13:
2834     // kind: type in field declaration
2835     // location: field_info
2836     case 0x14:
2837     // kind: return type of method, or type of newly constructed object
2838     // location: method_info
2839     case 0x15:
2840     // kind: receiver type of method or constructor
2841     // location: method_info
2842 
2843     {
2844       // struct:
2845       // empty_target {
2846       // }
2847       //
2848       log_debug(redefine, class, annotation)(&quot;empty_target&quot;);
2849     } break;
2850 
2851     case 0x16:
2852     // kind: type in formal parameter declaration of method, constructor, or lambda expression
2853     // location: method_info
2854 
2855     {
2856       // struct:
2857       // formal_parameter_target {
2858       //   u1 formal_parameter_index;
2859       // }
2860       //
2861       if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
2862         log_debug(redefine, class, annotation)(&quot;length() is too small for a formal_parameter_target&quot;);
2863         return false;
2864       }
2865 
2866       u1 formal_parameter_index = type_annotations_typeArray-&gt;at(byte_i_ref);
2867       byte_i_ref += 1;
2868 
2869       log_debug(redefine, class, annotation)
2870         (&quot;formal_parameter_target: formal_parameter_index=%d&quot;, formal_parameter_index);
2871     } break;
2872 
2873     case 0x17:
2874     // kind: type in throws clause of method or constructor
2875     // location: method_info
2876 
2877     {
2878       // struct:
2879       // throws_target {
2880       //   u2 throws_type_index
2881       // }
2882       //
2883       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2884         log_debug(redefine, class, annotation)(&quot;length() is too small for a throws_target&quot;);
2885         return false;
2886       }
2887 
2888       u2 throws_type_index = Bytes::get_Java_u2((address)
2889                                type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2890       byte_i_ref += 2;
2891 
2892       log_debug(redefine, class, annotation)(&quot;throws_target: throws_type_index=%d&quot;, throws_type_index);
2893     } break;
2894 
2895     case 0x40:
2896     // kind: type in local variable declaration
2897     // location: Code
2898     case 0x41:
2899     // kind: type in resource variable declaration
2900     // location: Code
2901 
2902     {
2903       // struct:
2904       // localvar_target {
2905       //   u2 table_length;
2906       //   struct {
2907       //     u2 start_pc;
2908       //     u2 length;
2909       //     u2 index;
2910       //   } table[table_length];
2911       // }
2912       //
2913       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2914         // not enough room for a table_length let alone the rest of a localvar_target
2915         log_debug(redefine, class, annotation)(&quot;length() is too small for a localvar_target table_length&quot;);
2916         return false;
2917       }
2918 
2919       u2 table_length = Bytes::get_Java_u2((address)
2920                           type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2921       byte_i_ref += 2;
2922 
2923       log_debug(redefine, class, annotation)(&quot;localvar_target: table_length=%d&quot;, table_length);
2924 
2925       int table_struct_size = 2 + 2 + 2; // 3 u2 variables per table entry
2926       int table_size = table_length * table_struct_size;
2927 
2928       if ((byte_i_ref + table_size) &gt; type_annotations_typeArray-&gt;length()) {
2929         // not enough room for a table
2930         log_debug(redefine, class, annotation)(&quot;length() is too small for a table array of length %d&quot;, table_length);
2931         return false;
2932       }
2933 
2934       // Skip over table
2935       byte_i_ref += table_size;
2936     } break;
2937 
2938     case 0x42:
2939     // kind: type in exception parameter declaration
2940     // location: Code
2941 
2942     {
2943       // struct:
2944       // catch_target {
2945       //   u2 exception_table_index;
2946       // }
2947       //
2948       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2949         log_debug(redefine, class, annotation)(&quot;length() is too small for a catch_target&quot;);
2950         return false;
2951       }
2952 
2953       u2 exception_table_index = Bytes::get_Java_u2((address)
2954                                    type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2955       byte_i_ref += 2;
2956 
2957       log_debug(redefine, class, annotation)(&quot;catch_target: exception_table_index=%d&quot;, exception_table_index);
2958     } break;
2959 
2960     case 0x43:
2961     // kind: type in instanceof expression
2962     // location: Code
2963     case 0x44:
2964     // kind: type in new expression
2965     // location: Code
2966     case 0x45:
2967     // kind: type in method reference expression using ::new
2968     // location: Code
2969     case 0x46:
2970     // kind: type in method reference expression using ::Identifier
2971     // location: Code
2972 
2973     {
2974       // struct:
2975       // offset_target {
2976       //   u2 offset;
2977       // }
2978       //
2979       if ((byte_i_ref + 2) &gt; type_annotations_typeArray-&gt;length()) {
2980         log_debug(redefine, class, annotation)(&quot;length() is too small for a offset_target&quot;);
2981         return false;
2982       }
2983 
2984       u2 offset = Bytes::get_Java_u2((address)
2985                     type_annotations_typeArray-&gt;adr_at(byte_i_ref));
2986       byte_i_ref += 2;
2987 
2988       log_debug(redefine, class, annotation)(&quot;offset_target: offset=%d&quot;, offset);
2989     } break;
2990 
2991     case 0x47:
2992     // kind: type in cast expression
2993     // location: Code
2994     case 0x48:
2995     // kind: type argument for generic constructor in new expression or
2996     //       explicit constructor invocation statement
2997     // location: Code
2998     case 0x49:
2999     // kind: type argument for generic method in method invocation expression
3000     // location: Code
3001     case 0x4A:
3002     // kind: type argument for generic constructor in method reference expression using ::new
3003     // location: Code
3004     case 0x4B:
3005     // kind: type argument for generic method in method reference expression using ::Identifier
3006     // location: Code
3007 
3008     {
3009       // struct:
3010       // type_argument_target {
3011       //   u2 offset;
3012       //   u1 type_argument_index;
3013       // }
3014       //
3015       if ((byte_i_ref + 3) &gt; type_annotations_typeArray-&gt;length()) {
3016         log_debug(redefine, class, annotation)(&quot;length() is too small for a type_argument_target&quot;);
3017         return false;
3018       }
3019 
3020       u2 offset = Bytes::get_Java_u2((address)
3021                     type_annotations_typeArray-&gt;adr_at(byte_i_ref));
3022       byte_i_ref += 2;
3023       u1 type_argument_index = type_annotations_typeArray-&gt;at(byte_i_ref);
3024       byte_i_ref += 1;
3025 
3026       log_debug(redefine, class, annotation)
3027         (&quot;type_argument_target: offset=%d, type_argument_index=%d&quot;, offset, type_argument_index);
3028     } break;
3029 
3030     default:
3031       log_debug(redefine, class, annotation)(&quot;unknown target_type&quot;);
3032 #ifdef ASSERT
3033       ShouldNotReachHere();
3034 #endif
3035       return false;
3036   }
3037 
3038   return true;
3039 } // end skip_type_annotation_target()
3040 
3041 
3042 // Read, verify and skip over the type_path part so that rewriting
3043 // can continue in the later parts of the struct.
3044 //
3045 // type_path {
3046 //   u1 path_length;
3047 //   {
3048 //     u1 type_path_kind;
3049 //     u1 type_argument_index;
3050 //   } path[path_length];
3051 // }
3052 //
3053 bool VM_RedefineClasses::skip_type_annotation_type_path(
3054        AnnotationArray* type_annotations_typeArray, int &amp;byte_i_ref, TRAPS) {
3055 
3056   if ((byte_i_ref + 1) &gt; type_annotations_typeArray-&gt;length()) {
3057     // not enough room for a path_length let alone the rest of the type_path
3058     log_debug(redefine, class, annotation)(&quot;length() is too small for a type_path&quot;);
3059     return false;
3060   }
3061 
3062   u1 path_length = type_annotations_typeArray-&gt;at(byte_i_ref);
3063   byte_i_ref += 1;
3064 
3065   log_debug(redefine, class, annotation)(&quot;type_path: path_length=%d&quot;, path_length);
3066 
3067   int calc_path_length = 0;
3068   for (; calc_path_length &lt; path_length; calc_path_length++) {
3069     if ((byte_i_ref + 1 + 1) &gt; type_annotations_typeArray-&gt;length()) {
3070       // not enough room for a path
3071       log_debug(redefine, class, annotation)
3072         (&quot;length() is too small for path entry %d of %d&quot;, calc_path_length, path_length);
3073       return false;
3074     }
3075 
3076     u1 type_path_kind = type_annotations_typeArray-&gt;at(byte_i_ref);
3077     byte_i_ref += 1;
3078     u1 type_argument_index = type_annotations_typeArray-&gt;at(byte_i_ref);
3079     byte_i_ref += 1;
3080 
3081     log_debug(redefine, class, annotation)
3082       (&quot;type_path: path[%d]: type_path_kind=%d, type_argument_index=%d&quot;,
3083        calc_path_length, type_path_kind, type_argument_index);
3084 
3085     if (type_path_kind &gt; 3 || (type_path_kind != 3 &amp;&amp; type_argument_index != 0)) {
3086       // not enough room for a path
3087       log_debug(redefine, class, annotation)(&quot;inconsistent type_path values&quot;);
3088       return false;
3089     }
3090   }
3091   assert(path_length == calc_path_length, &quot;sanity check&quot;);
3092 
3093   return true;
3094 } // end skip_type_annotation_type_path()
3095 
3096 
3097 // Rewrite constant pool references in the method&#39;s stackmap table.
3098 // These &quot;structures&quot; are adapted from the StackMapTable_attribute that
3099 // is described in section 4.8.4 of the 6.0 version of the VM spec
3100 // (dated 2005.10.26):
3101 // file:///net/quincunx.sfbay/export/gbracha/ClassFile-Java6.pdf
3102 //
3103 // stack_map {
3104 //   u2 number_of_entries;
3105 //   stack_map_frame entries[number_of_entries];
3106 // }
3107 //
3108 void VM_RedefineClasses::rewrite_cp_refs_in_stack_map_table(
3109        const methodHandle&amp; method, TRAPS) {
3110 
3111   if (!method-&gt;has_stackmap_table()) {
3112     return;
3113   }
3114 
3115   AnnotationArray* stackmap_data = method-&gt;stackmap_data();
3116   address stackmap_p = (address)stackmap_data-&gt;adr_at(0);
3117   address stackmap_end = stackmap_p + stackmap_data-&gt;length();
3118 
3119   assert(stackmap_p + 2 &lt;= stackmap_end, &quot;no room for number_of_entries&quot;);
3120   u2 number_of_entries = Bytes::get_Java_u2(stackmap_p);
3121   stackmap_p += 2;
3122 
3123   log_debug(redefine, class, stackmap)(&quot;number_of_entries=%u&quot;, number_of_entries);
3124 
3125   // walk through each stack_map_frame
3126   u2 calc_number_of_entries = 0;
3127   for (; calc_number_of_entries &lt; number_of_entries; calc_number_of_entries++) {
3128     // The stack_map_frame structure is a u1 frame_type followed by
3129     // 0 or more bytes of data:
3130     //
3131     // union stack_map_frame {
3132     //   same_frame;
3133     //   same_locals_1_stack_item_frame;
3134     //   same_locals_1_stack_item_frame_extended;
3135     //   chop_frame;
3136     //   same_frame_extended;
3137     //   append_frame;
3138     //   full_frame;
3139     // }
3140 
3141     assert(stackmap_p + 1 &lt;= stackmap_end, &quot;no room for frame_type&quot;);
3142     u1 frame_type = *stackmap_p;
3143     stackmap_p++;
3144 
3145     // same_frame {
3146     //   u1 frame_type = SAME; /* 0-63 */
3147     // }
3148     if (frame_type &lt;= 63) {
3149       // nothing more to do for same_frame
3150     }
3151 
3152     // same_locals_1_stack_item_frame {
3153     //   u1 frame_type = SAME_LOCALS_1_STACK_ITEM; /* 64-127 */
3154     //   verification_type_info stack[1];
3155     // }
3156     else if (frame_type &gt;= 64 &amp;&amp; frame_type &lt;= 127) {
3157       rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3158         calc_number_of_entries, frame_type, THREAD);
3159     }
3160 
3161     // reserved for future use
3162     else if (frame_type &gt;= 128 &amp;&amp; frame_type &lt;= 246) {
3163       // nothing more to do for reserved frame_types
3164     }
3165 
3166     // same_locals_1_stack_item_frame_extended {
3167     //   u1 frame_type = SAME_LOCALS_1_STACK_ITEM_EXTENDED; /* 247 */
3168     //   u2 offset_delta;
3169     //   verification_type_info stack[1];
3170     // }
3171     else if (frame_type == 247) {
3172       stackmap_p += 2;
3173       rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3174         calc_number_of_entries, frame_type, THREAD);
3175     }
3176 
3177     // chop_frame {
3178     //   u1 frame_type = CHOP; /* 248-250 */
3179     //   u2 offset_delta;
3180     // }
3181     else if (frame_type &gt;= 248 &amp;&amp; frame_type &lt;= 250) {
3182       stackmap_p += 2;
3183     }
3184 
3185     // same_frame_extended {
3186     //   u1 frame_type = SAME_FRAME_EXTENDED; /* 251*/
3187     //   u2 offset_delta;
3188     // }
3189     else if (frame_type == 251) {
3190       stackmap_p += 2;
3191     }
3192 
3193     // append_frame {
3194     //   u1 frame_type = APPEND; /* 252-254 */
3195     //   u2 offset_delta;
3196     //   verification_type_info locals[frame_type - 251];
3197     // }
3198     else if (frame_type &gt;= 252 &amp;&amp; frame_type &lt;= 254) {
3199       assert(stackmap_p + 2 &lt;= stackmap_end,
3200         &quot;no room for offset_delta&quot;);
3201       stackmap_p += 2;
3202       u1 len = frame_type - 251;
3203       for (u1 i = 0; i &lt; len; i++) {
3204         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3205           calc_number_of_entries, frame_type, THREAD);
3206       }
3207     }
3208 
3209     // full_frame {
3210     //   u1 frame_type = FULL_FRAME; /* 255 */
3211     //   u2 offset_delta;
3212     //   u2 number_of_locals;
3213     //   verification_type_info locals[number_of_locals];
3214     //   u2 number_of_stack_items;
3215     //   verification_type_info stack[number_of_stack_items];
3216     // }
3217     else if (frame_type == 255) {
3218       assert(stackmap_p + 2 + 2 &lt;= stackmap_end,
3219         &quot;no room for smallest full_frame&quot;);
3220       stackmap_p += 2;
3221 
3222       u2 number_of_locals = Bytes::get_Java_u2(stackmap_p);
3223       stackmap_p += 2;
3224 
3225       for (u2 locals_i = 0; locals_i &lt; number_of_locals; locals_i++) {
3226         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3227           calc_number_of_entries, frame_type, THREAD);
3228       }
3229 
3230       // Use the largest size for the number_of_stack_items, but only get
3231       // the right number of bytes.
3232       u2 number_of_stack_items = Bytes::get_Java_u2(stackmap_p);
3233       stackmap_p += 2;
3234 
3235       for (u2 stack_i = 0; stack_i &lt; number_of_stack_items; stack_i++) {
3236         rewrite_cp_refs_in_verification_type_info(stackmap_p, stackmap_end,
3237           calc_number_of_entries, frame_type, THREAD);
3238       }
3239     }
3240   } // end while there is a stack_map_frame
3241   assert(number_of_entries == calc_number_of_entries, &quot;sanity check&quot;);
3242 } // end rewrite_cp_refs_in_stack_map_table()
3243 
3244 
3245 // Rewrite constant pool references in the verification type info
3246 // portion of the method&#39;s stackmap table. These &quot;structures&quot; are
3247 // adapted from the StackMapTable_attribute that is described in
3248 // section 4.8.4 of the 6.0 version of the VM spec (dated 2005.10.26):
3249 // file:///net/quincunx.sfbay/export/gbracha/ClassFile-Java6.pdf
3250 //
3251 // The verification_type_info structure is a u1 tag followed by 0 or
3252 // more bytes of data:
3253 //
3254 // union verification_type_info {
3255 //   Top_variable_info;
3256 //   Integer_variable_info;
3257 //   Float_variable_info;
3258 //   Long_variable_info;
3259 //   Double_variable_info;
3260 //   Null_variable_info;
3261 //   UninitializedThis_variable_info;
3262 //   Object_variable_info;
3263 //   Uninitialized_variable_info;
3264 // }
3265 //
3266 void VM_RedefineClasses::rewrite_cp_refs_in_verification_type_info(
3267        address&amp; stackmap_p_ref, address stackmap_end, u2 frame_i,
3268        u1 frame_type, TRAPS) {
3269 
3270   assert(stackmap_p_ref + 1 &lt;= stackmap_end, &quot;no room for tag&quot;);
3271   u1 tag = *stackmap_p_ref;
3272   stackmap_p_ref++;
3273 
3274   switch (tag) {
3275   // Top_variable_info {
3276   //   u1 tag = ITEM_Top; /* 0 */
3277   // }
3278   // verificationType.hpp has zero as ITEM_Bogus instead of ITEM_Top
3279   case 0:  // fall through
3280 
3281   // Integer_variable_info {
3282   //   u1 tag = ITEM_Integer; /* 1 */
3283   // }
3284   case ITEM_Integer:  // fall through
3285 
3286   // Float_variable_info {
3287   //   u1 tag = ITEM_Float; /* 2 */
3288   // }
3289   case ITEM_Float:  // fall through
3290 
3291   // Double_variable_info {
3292   //   u1 tag = ITEM_Double; /* 3 */
3293   // }
3294   case ITEM_Double:  // fall through
3295 
3296   // Long_variable_info {
3297   //   u1 tag = ITEM_Long; /* 4 */
3298   // }
3299   case ITEM_Long:  // fall through
3300 
3301   // Null_variable_info {
3302   //   u1 tag = ITEM_Null; /* 5 */
3303   // }
3304   case ITEM_Null:  // fall through
3305 
3306   // UninitializedThis_variable_info {
3307   //   u1 tag = ITEM_UninitializedThis; /* 6 */
3308   // }
3309   case ITEM_UninitializedThis:
3310     // nothing more to do for the above tag types
3311     break;
3312 
3313   // Object_variable_info {
3314   //   u1 tag = ITEM_Object; /* 7 */
3315   //   u2 cpool_index;
3316   // }
3317   case ITEM_Object:
3318   {
3319     assert(stackmap_p_ref + 2 &lt;= stackmap_end, &quot;no room for cpool_index&quot;);
3320     u2 cpool_index = Bytes::get_Java_u2(stackmap_p_ref);
3321     u2 new_cp_index = find_new_index(cpool_index);
3322     if (new_cp_index != 0) {
3323       log_debug(redefine, class, stackmap)(&quot;mapped old cpool_index=%d&quot;, cpool_index);
3324       Bytes::put_Java_u2(stackmap_p_ref, new_cp_index);
3325       cpool_index = new_cp_index;
3326     }
3327     stackmap_p_ref += 2;
3328 
3329     log_debug(redefine, class, stackmap)
3330       (&quot;frame_i=%u, frame_type=%u, cpool_index=%d&quot;, frame_i, frame_type, cpool_index);
3331   } break;
3332 
3333   // Uninitialized_variable_info {
3334   //   u1 tag = ITEM_Uninitialized; /* 8 */
3335   //   u2 offset;
3336   // }
3337   case ITEM_Uninitialized:
3338     assert(stackmap_p_ref + 2 &lt;= stackmap_end, &quot;no room for offset&quot;);
3339     stackmap_p_ref += 2;
3340     break;
3341 
3342   default:
3343     log_debug(redefine, class, stackmap)(&quot;frame_i=%u, frame_type=%u, bad tag=0x%x&quot;, frame_i, frame_type, tag);
3344     ShouldNotReachHere();
3345     break;
3346   } // end switch (tag)
3347 } // end rewrite_cp_refs_in_verification_type_info()
3348 
3349 
3350 // Change the constant pool associated with klass scratch_class to
3351 // scratch_cp. If shrink is true, then scratch_cp_length elements
3352 // are copied from scratch_cp to a smaller constant pool and the
3353 // smaller constant pool is associated with scratch_class.
3354 void VM_RedefineClasses::set_new_constant_pool(
3355        ClassLoaderData* loader_data,
3356        InstanceKlass* scratch_class, constantPoolHandle scratch_cp,
3357        int scratch_cp_length, TRAPS) {
3358   assert(scratch_cp-&gt;length() &gt;= scratch_cp_length, &quot;sanity check&quot;);
3359 
3360   // scratch_cp is a merged constant pool and has enough space for a
3361   // worst case merge situation. We want to associate the minimum
3362   // sized constant pool with the klass to save space.
3363   ConstantPool* cp = ConstantPool::allocate(loader_data, scratch_cp_length, CHECK);
3364   constantPoolHandle smaller_cp(THREAD, cp);
3365 
3366   // preserve version() value in the smaller copy
3367   int version = scratch_cp-&gt;version();
3368   assert(version != 0, &quot;sanity check&quot;);
3369   smaller_cp-&gt;set_version(version);
3370 
3371   // attach klass to new constant pool
3372   // reference to the cp holder is needed for copy_operands()
3373   smaller_cp-&gt;set_pool_holder(scratch_class);
3374 
3375   if (scratch_cp-&gt;has_dynamic_constant()) {
3376     smaller_cp-&gt;set_has_dynamic_constant();
3377   }
3378 
3379   scratch_cp-&gt;copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
3380   if (HAS_PENDING_EXCEPTION) {
3381     // Exception is handled in the caller
3382     loader_data-&gt;add_to_deallocate_list(smaller_cp());
3383     return;
3384   }
3385   scratch_cp = smaller_cp;
3386 
3387   // attach new constant pool to klass
3388   scratch_class-&gt;set_constants(scratch_cp());
3389   scratch_cp-&gt;initialize_unresolved_klasses(loader_data, CHECK);
3390 
3391   int i;  // for portability
3392 
3393   // update each field in klass to use new constant pool indices as needed
3394   for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {
3395     jshort cur_index = fs.name_index();
3396     jshort new_index = find_new_index(cur_index);
3397     if (new_index != 0) {
3398       log_trace(redefine, class, constantpool)(&quot;field-name_index change: %d to %d&quot;, cur_index, new_index);
3399       fs.set_name_index(new_index);
3400     }
3401     cur_index = fs.signature_index();
3402     new_index = find_new_index(cur_index);
3403     if (new_index != 0) {
3404       log_trace(redefine, class, constantpool)(&quot;field-signature_index change: %d to %d&quot;, cur_index, new_index);
3405       fs.set_signature_index(new_index);
3406     }
3407     cur_index = fs.initval_index();
3408     new_index = find_new_index(cur_index);
3409     if (new_index != 0) {
3410       log_trace(redefine, class, constantpool)(&quot;field-initval_index change: %d to %d&quot;, cur_index, new_index);
3411       fs.set_initval_index(new_index);
3412     }
3413     cur_index = fs.generic_signature_index();
3414     new_index = find_new_index(cur_index);
3415     if (new_index != 0) {
3416       log_trace(redefine, class, constantpool)(&quot;field-generic_signature change: %d to %d&quot;, cur_index, new_index);
3417       fs.set_generic_signature_index(new_index);
3418     }
3419   } // end for each field
3420 
3421   // Update constant pool indices in the inner classes info to use
3422   // new constant indices as needed. The inner classes info is a
3423   // quadruple:
3424   // (inner_class_info, outer_class_info, inner_name, inner_access_flags)
3425   InnerClassesIterator iter(scratch_class);
3426   for (; !iter.done(); iter.next()) {
3427     int cur_index = iter.inner_class_info_index();
3428     if (cur_index == 0) {
3429       continue;  // JVM spec. allows null inner class refs so skip it
3430     }
3431     int new_index = find_new_index(cur_index);
3432     if (new_index != 0) {
3433       log_trace(redefine, class, constantpool)(&quot;inner_class_info change: %d to %d&quot;, cur_index, new_index);
3434       iter.set_inner_class_info_index(new_index);
3435     }
3436     cur_index = iter.outer_class_info_index();
3437     new_index = find_new_index(cur_index);
3438     if (new_index != 0) {
3439       log_trace(redefine, class, constantpool)(&quot;outer_class_info change: %d to %d&quot;, cur_index, new_index);
3440       iter.set_outer_class_info_index(new_index);
3441     }
3442     cur_index = iter.inner_name_index();
3443     new_index = find_new_index(cur_index);
3444     if (new_index != 0) {
3445       log_trace(redefine, class, constantpool)(&quot;inner_name change: %d to %d&quot;, cur_index, new_index);
3446       iter.set_inner_name_index(new_index);
3447     }
3448   } // end for each inner class
3449 
3450   // Attach each method in klass to the new constant pool and update
3451   // to use new constant pool indices as needed:
3452   Array&lt;Method*&gt;* methods = scratch_class-&gt;methods();
3453   for (i = methods-&gt;length() - 1; i &gt;= 0; i--) {
3454     methodHandle method(THREAD, methods-&gt;at(i));
3455     method-&gt;set_constants(scratch_cp());
3456 
3457     int new_index = find_new_index(method-&gt;name_index());
3458     if (new_index != 0) {
3459       log_trace(redefine, class, constantpool)
3460         (&quot;method-name_index change: %d to %d&quot;, method-&gt;name_index(), new_index);
3461       method-&gt;set_name_index(new_index);
3462     }
3463     new_index = find_new_index(method-&gt;signature_index());
3464     if (new_index != 0) {
3465       log_trace(redefine, class, constantpool)
3466         (&quot;method-signature_index change: %d to %d&quot;, method-&gt;signature_index(), new_index);
3467       method-&gt;set_signature_index(new_index);
3468     }
3469     new_index = find_new_index(method-&gt;generic_signature_index());
3470     if (new_index != 0) {
3471       log_trace(redefine, class, constantpool)
3472         (&quot;method-generic_signature_index change: %d to %d&quot;, method-&gt;generic_signature_index(), new_index);
3473       method-&gt;set_generic_signature_index(new_index);
3474     }
3475 
3476     // Update constant pool indices in the method&#39;s checked exception
3477     // table to use new constant indices as needed.
3478     int cext_length = method-&gt;checked_exceptions_length();
3479     if (cext_length &gt; 0) {
3480       CheckedExceptionElement * cext_table =
3481         method-&gt;checked_exceptions_start();
3482       for (int j = 0; j &lt; cext_length; j++) {
3483         int cur_index = cext_table[j].class_cp_index;
3484         int new_index = find_new_index(cur_index);
3485         if (new_index != 0) {
3486           log_trace(redefine, class, constantpool)(&quot;cext-class_cp_index change: %d to %d&quot;, cur_index, new_index);
3487           cext_table[j].class_cp_index = (u2)new_index;
3488         }
3489       } // end for each checked exception table entry
3490     } // end if there are checked exception table entries
3491 
3492     // Update each catch type index in the method&#39;s exception table
3493     // to use new constant pool indices as needed. The exception table
3494     // holds quadruple entries of the form:
3495     //   (beg_bci, end_bci, handler_bci, klass_index)
3496 
3497     ExceptionTable ex_table(method());
3498     int ext_length = ex_table.length();
3499 
3500     for (int j = 0; j &lt; ext_length; j ++) {
3501       int cur_index = ex_table.catch_type_index(j);
3502       int new_index = find_new_index(cur_index);
3503       if (new_index != 0) {
3504         log_trace(redefine, class, constantpool)(&quot;ext-klass_index change: %d to %d&quot;, cur_index, new_index);
3505         ex_table.set_catch_type_index(j, new_index);
3506       }
3507     } // end for each exception table entry
3508 
3509     // Update constant pool indices in the method&#39;s local variable
3510     // table to use new constant indices as needed. The local variable
3511     // table hold sextuple entries of the form:
3512     // (start_pc, length, name_index, descriptor_index, signature_index, slot)
3513     int lvt_length = method-&gt;localvariable_table_length();
3514     if (lvt_length &gt; 0) {
3515       LocalVariableTableElement * lv_table =
3516         method-&gt;localvariable_table_start();
3517       for (int j = 0; j &lt; lvt_length; j++) {
3518         int cur_index = lv_table[j].name_cp_index;
3519         int new_index = find_new_index(cur_index);
3520         if (new_index != 0) {
3521           log_trace(redefine, class, constantpool)(&quot;lvt-name_cp_index change: %d to %d&quot;, cur_index, new_index);
3522           lv_table[j].name_cp_index = (u2)new_index;
3523         }
3524         cur_index = lv_table[j].descriptor_cp_index;
3525         new_index = find_new_index(cur_index);
3526         if (new_index != 0) {
3527           log_trace(redefine, class, constantpool)(&quot;lvt-descriptor_cp_index change: %d to %d&quot;, cur_index, new_index);
3528           lv_table[j].descriptor_cp_index = (u2)new_index;
3529         }
3530         cur_index = lv_table[j].signature_cp_index;
3531         new_index = find_new_index(cur_index);
3532         if (new_index != 0) {
3533           log_trace(redefine, class, constantpool)(&quot;lvt-signature_cp_index change: %d to %d&quot;, cur_index, new_index);
3534           lv_table[j].signature_cp_index = (u2)new_index;
3535         }
3536       } // end for each local variable table entry
3537     } // end if there are local variable table entries
3538 
3539     rewrite_cp_refs_in_stack_map_table(method, THREAD);
3540   } // end for each method
3541 } // end set_new_constant_pool()
3542 
3543 
3544 // Unevolving classes may point to methods of the_class directly
3545 // from their constant pool caches, itables, and/or vtables. We
3546 // use the ClassLoaderDataGraph::classes_do() facility and this helper
3547 // to fix up these pointers.  MethodData also points to old methods and
3548 // must be cleaned.
3549 
3550 // Adjust cpools and vtables closure
3551 void VM_RedefineClasses::AdjustAndCleanMetadata::do_klass(Klass* k) {
3552 
3553   // This is a very busy routine. We don&#39;t want too much tracing
3554   // printed out.
3555   bool trace_name_printed = false;
3556 
3557   // If the class being redefined is java.lang.Object, we need to fix all
3558   // array class vtables also
3559   if (k-&gt;is_array_klass() &amp;&amp; _has_redefined_Object) {
3560     k-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3561 
3562   } else if (k-&gt;is_instance_klass()) {
3563     HandleMark hm(_thread);
3564     InstanceKlass *ik = InstanceKlass::cast(k);
3565 
3566     // Clean MethodData of this class&#39;s methods so they don&#39;t refer to
3567     // old methods that are no longer running.
3568     Array&lt;Method*&gt;* methods = ik-&gt;methods();
3569     int num_methods = methods-&gt;length();
3570     for (int index = 0; index &lt; num_methods; ++index) {
3571       if (methods-&gt;at(index)-&gt;method_data() != NULL) {
3572         methods-&gt;at(index)-&gt;method_data()-&gt;clean_weak_method_links();
3573       }
3574     }
3575 
3576     // HotSpot specific optimization! HotSpot does not currently
3577     // support delegation from the bootstrap class loader to a
3578     // user-defined class loader. This means that if the bootstrap
3579     // class loader is the initiating class loader, then it will also
3580     // be the defining class loader. This also means that classes
3581     // loaded by the bootstrap class loader cannot refer to classes
3582     // loaded by a user-defined class loader. Note: a user-defined
3583     // class loader can delegate to the bootstrap class loader.
3584     //
3585     // If the current class being redefined has a user-defined class
3586     // loader as its defining class loader, then we can skip all
3587     // classes loaded by the bootstrap class loader.
3588     if (!_has_null_class_loader &amp;&amp; ik-&gt;class_loader() == NULL) {
3589       return;
3590     }
3591 
3592     // Adjust all vtables, default methods and itables, to clean out old methods.
3593     ResourceMark rm(_thread);
3594     if (ik-&gt;vtable_length() &gt; 0) {
3595       ik-&gt;vtable().adjust_method_entries(&amp;trace_name_printed);
3596       ik-&gt;adjust_default_methods(&amp;trace_name_printed);
3597     }
3598 
3599     if (ik-&gt;itable_length() &gt; 0) {
3600       ik-&gt;itable().adjust_method_entries(&amp;trace_name_printed);
3601     }
3602 
3603     // The constant pools in other classes (other_cp) can refer to
3604     // old methods.  We have to update method information in
3605     // other_cp&#39;s cache. If other_cp has a previous version, then we
3606     // have to repeat the process for each previous version. The
3607     // constant pool cache holds the Method*s for non-virtual
3608     // methods and for virtual, final methods.
3609     //
3610     // Special case: if the current class being redefined, then new_cp
3611     // has already been attached to the_class and old_cp has already
3612     // been added as a previous version. The new_cp doesn&#39;t have any
3613     // cached references to old methods so it doesn&#39;t need to be
3614     // updated. We can simply start with the previous version(s) in
3615     // that case.
3616     ConstantPoolCache* cp_cache;
3617 
3618     if (!ik-&gt;is_being_redefined()) {
3619       // this klass&#39; constant pool cache may need adjustment
3620       ConstantPool* other_cp = ik-&gt;constants();
3621       cp_cache = other_cp-&gt;cache();
3622       if (cp_cache != NULL) {
3623         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3624       }
3625     }
3626 
3627     // the previous versions&#39; constant pool caches may need adjustment
3628     for (InstanceKlass* pv_node = ik-&gt;previous_versions();
3629          pv_node != NULL;
3630          pv_node = pv_node-&gt;previous_versions()) {
3631       cp_cache = pv_node-&gt;constants()-&gt;cache();
3632       if (cp_cache != NULL) {
3633         cp_cache-&gt;adjust_method_entries(&amp;trace_name_printed);
3634       }
3635     }
3636   }
3637 }
3638 
3639 void VM_RedefineClasses::update_jmethod_ids(Thread* thread) {
3640   for (int j = 0; j &lt; _matching_methods_length; ++j) {
3641     Method* old_method = _matching_old_methods[j];
3642     jmethodID jmid = old_method-&gt;find_jmethod_id_or_null();
3643     if (jmid != NULL) {
3644       // There is a jmethodID, change it to point to the new method
3645       methodHandle new_method_h(thread, _matching_new_methods[j]);
3646       Method::change_method_associated_with_jmethod_id(jmid, new_method_h());
3647       assert(Method::resolve_jmethod_id(jmid) == _matching_new_methods[j],
3648              &quot;should be replaced&quot;);
3649     }
3650   }
3651 }
3652 
3653 int VM_RedefineClasses::check_methods_and_mark_as_obsolete() {
3654   int emcp_method_count = 0;
3655   int obsolete_count = 0;
3656   int old_index = 0;
3657   for (int j = 0; j &lt; _matching_methods_length; ++j, ++old_index) {
3658     Method* old_method = _matching_old_methods[j];
3659     Method* new_method = _matching_new_methods[j];
3660     Method* old_array_method;
3661 
3662     // Maintain an old_index into the _old_methods array by skipping
3663     // deleted methods
3664     while ((old_array_method = _old_methods-&gt;at(old_index)) != old_method) {
3665       ++old_index;
3666     }
3667 
3668     if (MethodComparator::methods_EMCP(old_method, new_method)) {
3669       // The EMCP definition from JSR-163 requires the bytecodes to be
3670       // the same with the exception of constant pool indices which may
3671       // differ. However, the constants referred to by those indices
3672       // must be the same.
3673       //
3674       // We use methods_EMCP() for comparison since constant pool
3675       // merging can remove duplicate constant pool entries that were
3676       // present in the old method and removed from the rewritten new
3677       // method. A faster binary comparison function would consider the
3678       // old and new methods to be different when they are actually
3679       // EMCP.
3680       //
3681       // The old and new methods are EMCP and you would think that we
3682       // could get rid of one of them here and now and save some space.
3683       // However, the concept of EMCP only considers the bytecodes and
3684       // the constant pool entries in the comparison. Other things,
3685       // e.g., the line number table (LNT) or the local variable table
3686       // (LVT) don&#39;t count in the comparison. So the new (and EMCP)
3687       // method can have a new LNT that we need so we can&#39;t just
3688       // overwrite the new method with the old method.
3689       //
3690       // When this routine is called, we have already attached the new
3691       // methods to the_class so the old methods are effectively
3692       // overwritten. However, if an old method is still executing,
3693       // then the old method cannot be collected until sometime after
3694       // the old method call has returned. So the overwriting of old
3695       // methods by new methods will save us space except for those
3696       // (hopefully few) old methods that are still executing.
3697       //
3698       // A method refers to a ConstMethod* and this presents another
3699       // possible avenue to space savings. The ConstMethod* in the
3700       // new method contains possibly new attributes (LNT, LVT, etc).
3701       // At first glance, it seems possible to save space by replacing
3702       // the ConstMethod* in the old method with the ConstMethod*
3703       // from the new method. The old and new methods would share the
3704       // same ConstMethod* and we would save the space occupied by
3705       // the old ConstMethod*. However, the ConstMethod* contains
3706       // a back reference to the containing method. Sharing the
3707       // ConstMethod* between two methods could lead to confusion in
3708       // the code that uses the back reference. This would lead to
3709       // brittle code that could be broken in non-obvious ways now or
3710       // in the future.
3711       //
3712       // Another possibility is to copy the ConstMethod* from the new
3713       // method to the old method and then overwrite the new method with
3714       // the old method. Since the ConstMethod* contains the bytecodes
3715       // for the method embedded in the oop, this option would change
3716       // the bytecodes out from under any threads executing the old
3717       // method and make the thread&#39;s bcp invalid. Since EMCP requires
3718       // that the bytecodes be the same modulo constant pool indices, it
3719       // is straight forward to compute the correct new bcp in the new
3720       // ConstMethod* from the old bcp in the old ConstMethod*. The
3721       // time consuming part would be searching all the frames in all
3722       // of the threads to find all of the calls to the old method.
3723       //
3724       // It looks like we will have to live with the limited savings
3725       // that we get from effectively overwriting the old methods
3726       // when the new methods are attached to the_class.
3727 
3728       // Count number of methods that are EMCP.  The method will be marked
3729       // old but not obsolete if it is EMCP.
3730       emcp_method_count++;
3731 
3732       // An EMCP method is _not_ obsolete. An obsolete method has a
3733       // different jmethodID than the current method. An EMCP method
3734       // has the same jmethodID as the current method. Having the
3735       // same jmethodID for all EMCP versions of a method allows for
3736       // a consistent view of the EMCP methods regardless of which
3737       // EMCP method you happen to have in hand. For example, a
3738       // breakpoint set in one EMCP method will work for all EMCP
3739       // versions of the method including the current one.
3740     } else {
3741       // mark obsolete methods as such
3742       old_method-&gt;set_is_obsolete();
3743       obsolete_count++;
3744 
3745       // obsolete methods need a unique idnum so they become new entries in
3746       // the jmethodID cache in InstanceKlass
3747       assert(old_method-&gt;method_idnum() == new_method-&gt;method_idnum(), &quot;must match&quot;);
3748       u2 num = InstanceKlass::cast(_the_class)-&gt;next_method_idnum();
3749       if (num != ConstMethod::UNSET_IDNUM) {
3750         old_method-&gt;set_method_idnum(num);
3751       }
3752 
3753       // With tracing we try not to &quot;yack&quot; too much. The position of
3754       // this trace assumes there are fewer obsolete methods than
3755       // EMCP methods.
3756       if (log_is_enabled(Trace, redefine, class, obsolete, mark)) {
3757         ResourceMark rm;
3758         log_trace(redefine, class, obsolete, mark)
3759           (&quot;mark %s(%s) as obsolete&quot;, old_method-&gt;name()-&gt;as_C_string(), old_method-&gt;signature()-&gt;as_C_string());
3760       }
3761     }
3762     old_method-&gt;set_is_old();
3763   }
3764   for (int i = 0; i &lt; _deleted_methods_length; ++i) {
3765     Method* old_method = _deleted_methods[i];
3766 
3767     assert(!old_method-&gt;has_vtable_index(),
3768            &quot;cannot delete methods with vtable entries&quot;);;
3769 
3770     // Mark all deleted methods as old, obsolete and deleted
3771     old_method-&gt;set_is_deleted();
3772     old_method-&gt;set_is_old();
3773     old_method-&gt;set_is_obsolete();
3774     ++obsolete_count;
3775     // With tracing we try not to &quot;yack&quot; too much. The position of
3776     // this trace assumes there are fewer obsolete methods than
3777     // EMCP methods.
3778     if (log_is_enabled(Trace, redefine, class, obsolete, mark)) {
3779       ResourceMark rm;
3780       log_trace(redefine, class, obsolete, mark)
3781         (&quot;mark deleted %s(%s) as obsolete&quot;, old_method-&gt;name()-&gt;as_C_string(), old_method-&gt;signature()-&gt;as_C_string());
3782     }
3783   }
3784   assert((emcp_method_count + obsolete_count) == _old_methods-&gt;length(),
3785     &quot;sanity check&quot;);
3786   log_trace(redefine, class, obsolete, mark)(&quot;EMCP_cnt=%d, obsolete_cnt=%d&quot;, emcp_method_count, obsolete_count);
3787   return emcp_method_count;
3788 }
3789 
3790 // This internal class transfers the native function registration from old methods
3791 // to new methods.  It is designed to handle both the simple case of unchanged
3792 // native methods and the complex cases of native method prefixes being added and/or
3793 // removed.
3794 // It expects only to be used during the VM_RedefineClasses op (a safepoint).
3795 //
3796 // This class is used after the new methods have been installed in &quot;the_class&quot;.
3797 //
3798 // So, for example, the following must be handled.  Where &#39;m&#39; is a method and
3799 // a number followed by an underscore is a prefix.
3800 //
3801 //                                      Old Name    New Name
3802 // Simple transfer to new method        m       -&gt;  m
3803 // Add prefix                           m       -&gt;  1_m
3804 // Remove prefix                        1_m     -&gt;  m
3805 // Simultaneous add of prefixes         m       -&gt;  3_2_1_m
3806 // Simultaneous removal of prefixes     3_2_1_m -&gt;  m
3807 // Simultaneous add and remove          1_m     -&gt;  2_m
3808 // Same, caused by prefix removal only  3_2_1_m -&gt;  3_2_m
3809 //
3810 class TransferNativeFunctionRegistration {
3811  private:
3812   InstanceKlass* the_class;
3813   int prefix_count;
3814   char** prefixes;
3815 
3816   // Recursively search the binary tree of possibly prefixed method names.
3817   // Iteration could be used if all agents were well behaved. Full tree walk is
3818   // more resilent to agents not cleaning up intermediate methods.
3819   // Branch at each depth in the binary tree is:
3820   //    (1) without the prefix.
3821   //    (2) with the prefix.
3822   // where &#39;prefix&#39; is the prefix at that &#39;depth&#39; (first prefix, second prefix,...)
3823   Method* search_prefix_name_space(int depth, char* name_str, size_t name_len,
3824                                      Symbol* signature) {
3825     TempNewSymbol name_symbol = SymbolTable::probe(name_str, (int)name_len);
3826     if (name_symbol != NULL) {
3827       Method* method = the_class-&gt;lookup_method(name_symbol, signature);
3828       if (method != NULL) {
3829         // Even if prefixed, intermediate methods must exist.
3830         if (method-&gt;is_native()) {
3831           // Wahoo, we found a (possibly prefixed) version of the method, return it.
3832           return method;
3833         }
3834         if (depth &lt; prefix_count) {
3835           // Try applying further prefixes (other than this one).
3836           method = search_prefix_name_space(depth+1, name_str, name_len, signature);
3837           if (method != NULL) {
3838             return method; // found
3839           }
3840 
3841           // Try adding this prefix to the method name and see if it matches
3842           // another method name.
3843           char* prefix = prefixes[depth];
3844           size_t prefix_len = strlen(prefix);
3845           size_t trial_len = name_len + prefix_len;
3846           char* trial_name_str = NEW_RESOURCE_ARRAY(char, trial_len + 1);
3847           strcpy(trial_name_str, prefix);
3848           strcat(trial_name_str, name_str);
3849           method = search_prefix_name_space(depth+1, trial_name_str, trial_len,
3850                                             signature);
3851           if (method != NULL) {
3852             // If found along this branch, it was prefixed, mark as such
3853             method-&gt;set_is_prefixed_native();
3854             return method; // found
3855           }
3856         }
3857       }
3858     }
3859     return NULL;  // This whole branch bore nothing
3860   }
3861 
3862   // Return the method name with old prefixes stripped away.
3863   char* method_name_without_prefixes(Method* method) {
3864     Symbol* name = method-&gt;name();
3865     char* name_str = name-&gt;as_utf8();
3866 
3867     // Old prefixing may be defunct, strip prefixes, if any.
3868     for (int i = prefix_count-1; i &gt;= 0; i--) {
3869       char* prefix = prefixes[i];
3870       size_t prefix_len = strlen(prefix);
3871       if (strncmp(prefix, name_str, prefix_len) == 0) {
3872         name_str += prefix_len;
3873       }
3874     }
3875     return name_str;
3876   }
3877 
3878   // Strip any prefixes off the old native method, then try to find a
3879   // (possibly prefixed) new native that matches it.
3880   Method* strip_and_search_for_new_native(Method* method) {
3881     ResourceMark rm;
3882     char* name_str = method_name_without_prefixes(method);
3883     return search_prefix_name_space(0, name_str, strlen(name_str),
3884                                     method-&gt;signature());
3885   }
3886 
3887  public:
3888 
3889   // Construct a native method transfer processor for this class.
3890   TransferNativeFunctionRegistration(InstanceKlass* _the_class) {
3891     assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
3892 
3893     the_class = _the_class;
3894     prefixes = JvmtiExport::get_all_native_method_prefixes(&amp;prefix_count);
3895   }
3896 
3897   // Attempt to transfer any of the old or deleted methods that are native
3898   void transfer_registrations(Method** old_methods, int methods_length) {
3899     for (int j = 0; j &lt; methods_length; j++) {
3900       Method* old_method = old_methods[j];
3901 
3902       if (old_method-&gt;is_native() &amp;&amp; old_method-&gt;has_native_function()) {
3903         Method* new_method = strip_and_search_for_new_native(old_method);
3904         if (new_method != NULL) {
3905           // Actually set the native function in the new method.
3906           // Redefine does not send events (except CFLH), certainly not this
3907           // behind the scenes re-registration.
3908           new_method-&gt;set_native_function(old_method-&gt;native_function(),
3909                               !Method::native_bind_event_is_interesting);
3910         }
3911       }
3912     }
3913   }
3914 };
3915 
3916 // Don&#39;t lose the association between a native method and its JNI function.
3917 void VM_RedefineClasses::transfer_old_native_function_registrations(InstanceKlass* the_class) {
3918   TransferNativeFunctionRegistration transfer(the_class);
3919   transfer.transfer_registrations(_deleted_methods, _deleted_methods_length);
3920   transfer.transfer_registrations(_matching_old_methods, _matching_methods_length);
3921 }
3922 
3923 // Deoptimize all compiled code that depends on this class.
3924 //
3925 // If the can_redefine_classes capability is obtained in the onload
3926 // phase then the compiler has recorded all dependencies from startup.
3927 // In that case we need only deoptimize and throw away all compiled code
3928 // that depends on the class.
3929 //
3930 // If can_redefine_classes is obtained sometime after the onload
3931 // phase then the dependency information may be incomplete. In that case
3932 // the first call to RedefineClasses causes all compiled code to be
3933 // thrown away. As can_redefine_classes has been obtained then
3934 // all future compilations will record dependencies so second and
3935 // subsequent calls to RedefineClasses need only throw away code
3936 // that depends on the class.
3937 //
3938 
3939 // First step is to walk the code cache for each class redefined and mark
3940 // dependent methods.  Wait until all classes are processed to deoptimize everything.
3941 void VM_RedefineClasses::mark_dependent_code(InstanceKlass* ik) {
3942   assert_locked_or_safepoint(Compile_lock);
3943 
3944   // All dependencies have been recorded from startup or this is a second or
3945   // subsequent use of RedefineClasses
3946   if (JvmtiExport::all_dependencies_are_recorded()) {
3947     CodeCache::mark_for_evol_deoptimization(ik);
3948   }
3949 }
3950 
3951 void VM_RedefineClasses::flush_dependent_code() {
3952   assert(SafepointSynchronize::is_at_safepoint(), &quot;sanity check&quot;);
3953 
3954   bool deopt_needed;
3955 
3956   // This is the first redefinition, mark all the nmethods for deoptimization
3957   if (!JvmtiExport::all_dependencies_are_recorded()) {
3958     log_debug(redefine, class, nmethod)(&quot;Marked all nmethods for deopt&quot;);
3959     CodeCache::mark_all_nmethods_for_evol_deoptimization();
3960     deopt_needed = true;
3961   } else {
3962     int deopt = CodeCache::mark_dependents_for_evol_deoptimization();
3963     log_debug(redefine, class, nmethod)(&quot;Marked %d dependent nmethods for deopt&quot;, deopt);
3964     deopt_needed = (deopt != 0);
3965   }
3966 
3967   if (deopt_needed) {
3968     CodeCache::flush_evol_dependents();
3969   }
3970 
3971   // From now on we know that the dependency information is complete
3972   JvmtiExport::set_all_dependencies_are_recorded(true);
3973 }
3974 
3975 void VM_RedefineClasses::compute_added_deleted_matching_methods() {
3976   Method* old_method;
3977   Method* new_method;
3978 
3979   _matching_old_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
3980   _matching_new_methods = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
3981   _added_methods        = NEW_RESOURCE_ARRAY(Method*, _new_methods-&gt;length());
3982   _deleted_methods      = NEW_RESOURCE_ARRAY(Method*, _old_methods-&gt;length());
3983 
3984   _matching_methods_length = 0;
3985   _deleted_methods_length  = 0;
3986   _added_methods_length    = 0;
3987 
3988   int nj = 0;
3989   int oj = 0;
3990   while (true) {
3991     if (oj &gt;= _old_methods-&gt;length()) {
3992       if (nj &gt;= _new_methods-&gt;length()) {
3993         break; // we&#39;ve looked at everything, done
3994       }
3995       // New method at the end
3996       new_method = _new_methods-&gt;at(nj);
3997       _added_methods[_added_methods_length++] = new_method;
3998       ++nj;
3999     } else if (nj &gt;= _new_methods-&gt;length()) {
4000       // Old method, at the end, is deleted
4001       old_method = _old_methods-&gt;at(oj);
4002       _deleted_methods[_deleted_methods_length++] = old_method;
4003       ++oj;
4004     } else {
4005       old_method = _old_methods-&gt;at(oj);
4006       new_method = _new_methods-&gt;at(nj);
4007       if (old_method-&gt;name() == new_method-&gt;name()) {
4008         if (old_method-&gt;signature() == new_method-&gt;signature()) {
4009           _matching_old_methods[_matching_methods_length  ] = old_method;
4010           _matching_new_methods[_matching_methods_length++] = new_method;
4011           ++nj;
4012           ++oj;
4013         } else {
4014           // added overloaded have already been moved to the end,
4015           // so this is a deleted overloaded method
4016           _deleted_methods[_deleted_methods_length++] = old_method;
4017           ++oj;
4018         }
4019       } else { // names don&#39;t match
4020         if (old_method-&gt;name()-&gt;fast_compare(new_method-&gt;name()) &gt; 0) {
4021           // new method
4022           _added_methods[_added_methods_length++] = new_method;
4023           ++nj;
4024         } else {
4025           // deleted method
4026           _deleted_methods[_deleted_methods_length++] = old_method;
4027           ++oj;
4028         }
4029       }
4030     }
4031   }
4032   assert(_matching_methods_length + _deleted_methods_length == _old_methods-&gt;length(), &quot;sanity&quot;);
4033   assert(_matching_methods_length + _added_methods_length == _new_methods-&gt;length(), &quot;sanity&quot;);
4034 }
4035 
4036 
4037 void VM_RedefineClasses::swap_annotations(InstanceKlass* the_class,
4038                                           InstanceKlass* scratch_class) {
4039   // Swap annotation fields values
4040   Annotations* old_annotations = the_class-&gt;annotations();
4041   the_class-&gt;set_annotations(scratch_class-&gt;annotations());
4042   scratch_class-&gt;set_annotations(old_annotations);
4043 }
4044 
4045 
4046 // Install the redefinition of a class:
4047 //    - house keeping (flushing breakpoints and caches, deoptimizing
4048 //      dependent compiled code)
4049 //    - replacing parts in the_class with parts from scratch_class
4050 //    - adding a weak reference to track the obsolete but interesting
4051 //      parts of the_class
4052 //    - adjusting constant pool caches and vtables in other classes
4053 //      that refer to methods in the_class. These adjustments use the
4054 //      ClassLoaderDataGraph::classes_do() facility which only allows
4055 //      a helper method to be specified. The interesting parameters
4056 //      that we would like to pass to the helper method are saved in
4057 //      static global fields in the VM operation.
4058 void VM_RedefineClasses::redefine_single_class(jclass the_jclass,
4059        InstanceKlass* scratch_class, TRAPS) {
4060 
4061   HandleMark hm(THREAD);   // make sure handles from this call are freed
4062 
4063   if (log_is_enabled(Info, redefine, class, timer)) {
4064     _timer_rsc_phase1.start();
4065   }
4066 
4067   InstanceKlass* the_class = get_ik(the_jclass);
4068 
4069   // Set some flags to control and optimize adjusting method entries
4070   _has_redefined_Object |= the_class == SystemDictionary::Object_klass();
4071   _has_null_class_loader |= the_class-&gt;class_loader() == NULL;
4072 
4073   // Remove all breakpoints in methods of this class
4074   JvmtiBreakpoints&amp; jvmti_breakpoints = JvmtiCurrentBreakpoints::get_jvmti_breakpoints();
4075   jvmti_breakpoints.clearall_in_class_at_safepoint(the_class);
4076 
4077   // Mark all compiled code that depends on this class
4078   mark_dependent_code(the_class);
4079 
4080   _old_methods = the_class-&gt;methods();
4081   _new_methods = scratch_class-&gt;methods();
4082   _the_class = the_class;
4083   compute_added_deleted_matching_methods();
4084   update_jmethod_ids(THREAD);
4085 
4086   _any_class_has_resolved_methods = the_class-&gt;has_resolved_methods() || _any_class_has_resolved_methods;
4087 
4088   // Attach new constant pool to the original klass. The original
4089   // klass still refers to the old constant pool (for now).
4090   scratch_class-&gt;constants()-&gt;set_pool_holder(the_class);
4091 
4092 #if 0
4093   // In theory, with constant pool merging in place we should be able
4094   // to save space by using the new, merged constant pool in place of
4095   // the old constant pool(s). By &quot;pool(s)&quot; I mean the constant pool in
4096   // the klass version we are replacing now and any constant pool(s) in
4097   // previous versions of klass. Nice theory, doesn&#39;t work in practice.
4098   // When this code is enabled, even simple programs throw NullPointer
4099   // exceptions. I&#39;m guessing that this is caused by some constant pool
4100   // cache difference between the new, merged constant pool and the
4101   // constant pool that was just being used by the klass. I&#39;m keeping
4102   // this code around to archive the idea, but the code has to remain
4103   // disabled for now.
4104 
4105   // Attach each old method to the new constant pool. This can be
4106   // done here since we are past the bytecode verification and
4107   // constant pool optimization phases.
4108   for (int i = _old_methods-&gt;length() - 1; i &gt;= 0; i--) {
4109     Method* method = _old_methods-&gt;at(i);
4110     method-&gt;set_constants(scratch_class-&gt;constants());
4111   }
4112 
4113   // NOTE: this doesn&#39;t work because you can redefine the same class in two
4114   // threads, each getting their own constant pool data appended to the
4115   // original constant pool.  In order for the new methods to work when they
4116   // become old methods, they need to keep their updated copy of the constant pool.
4117 
4118   {
4119     // walk all previous versions of the klass
4120     InstanceKlass *ik = the_class;
4121     PreviousVersionWalker pvw(ik);
4122     do {
4123       ik = pvw.next_previous_version();
4124       if (ik != NULL) {
4125 
4126         // attach previous version of klass to the new constant pool
4127         ik-&gt;set_constants(scratch_class-&gt;constants());
4128 
4129         // Attach each method in the previous version of klass to the
4130         // new constant pool
4131         Array&lt;Method*&gt;* prev_methods = ik-&gt;methods();
4132         for (int i = prev_methods-&gt;length() - 1; i &gt;= 0; i--) {
4133           Method* method = prev_methods-&gt;at(i);
4134           method-&gt;set_constants(scratch_class-&gt;constants());
4135         }
4136       }
4137     } while (ik != NULL);
4138   }
4139 #endif
4140 
4141   // Replace methods and constantpool
4142   the_class-&gt;set_methods(_new_methods);
4143   scratch_class-&gt;set_methods(_old_methods);     // To prevent potential GCing of the old methods,
4144                                           // and to be able to undo operation easily.
4145 
4146   Array&lt;int&gt;* old_ordering = the_class-&gt;method_ordering();
4147   the_class-&gt;set_method_ordering(scratch_class-&gt;method_ordering());
4148   scratch_class-&gt;set_method_ordering(old_ordering);
4149 
4150   ConstantPool* old_constants = the_class-&gt;constants();
4151   the_class-&gt;set_constants(scratch_class-&gt;constants());
4152   scratch_class-&gt;set_constants(old_constants);  // See the previous comment.
4153 #if 0
4154   // We are swapping the guts of &quot;the new class&quot; with the guts of &quot;the
4155   // class&quot;. Since the old constant pool has just been attached to &quot;the
4156   // new class&quot;, it seems logical to set the pool holder in the old
4157   // constant pool also. However, doing this will change the observable
4158   // class hierarchy for any old methods that are still executing. A
4159   // method can query the identity of its &quot;holder&quot; and this query uses
4160   // the method&#39;s constant pool link to find the holder. The change in
4161   // holding class from &quot;the class&quot; to &quot;the new class&quot; can confuse
4162   // things.
4163   //
4164   // Setting the old constant pool&#39;s holder will also cause
4165   // verification done during vtable initialization below to fail.
4166   // During vtable initialization, the vtable&#39;s class is verified to be
4167   // a subtype of the method&#39;s holder. The vtable&#39;s class is &quot;the
4168   // class&quot; and the method&#39;s holder is gotten from the constant pool
4169   // link in the method itself. For &quot;the class&quot;&#39;s directly implemented
4170   // methods, the method holder is &quot;the class&quot; itself (as gotten from
4171   // the new constant pool). The check works fine in this case. The
4172   // check also works fine for methods inherited from super classes.
4173   //
4174   // Miranda methods are a little more complicated. A miranda method is
4175   // provided by an interface when the class implementing the interface
4176   // does not provide its own method.  These interfaces are implemented
4177   // internally as an InstanceKlass. These special instanceKlasses
4178   // share the constant pool of the class that &quot;implements&quot; the
4179   // interface. By sharing the constant pool, the method holder of a
4180   // miranda method is the class that &quot;implements&quot; the interface. In a
4181   // non-redefine situation, the subtype check works fine. However, if
4182   // the old constant pool&#39;s pool holder is modified, then the check
4183   // fails because there is no class hierarchy relationship between the
4184   // vtable&#39;s class and &quot;the new class&quot;.
4185 
4186   old_constants-&gt;set_pool_holder(scratch_class());
4187 #endif
4188 
4189   // track number of methods that are EMCP for add_previous_version() call below
4190   int emcp_method_count = check_methods_and_mark_as_obsolete();
4191   transfer_old_native_function_registrations(the_class);
4192 
4193   // The class file bytes from before any retransformable agents mucked
4194   // with them was cached on the scratch class, move to the_class.
4195   // Note: we still want to do this if nothing needed caching since it
4196   // should get cleared in the_class too.
4197   if (the_class-&gt;get_cached_class_file() == 0) {
4198     // the_class doesn&#39;t have a cache yet so copy it
4199     the_class-&gt;set_cached_class_file(scratch_class-&gt;get_cached_class_file());
4200   }
4201   else if (scratch_class-&gt;get_cached_class_file() !=
4202            the_class-&gt;get_cached_class_file()) {
4203     // The same class can be present twice in the scratch classes list or there
4204     // are multiple concurrent RetransformClasses calls on different threads.
4205     // In such cases we have to deallocate scratch_class cached_class_file.
4206     os::free(scratch_class-&gt;get_cached_class_file());
4207   }
4208 
4209   // NULL out in scratch class to not delete twice.  The class to be redefined
4210   // always owns these bytes.
4211   scratch_class-&gt;set_cached_class_file(NULL);
4212 
4213   // Replace inner_classes
4214   Array&lt;u2&gt;* old_inner_classes = the_class-&gt;inner_classes();
4215   the_class-&gt;set_inner_classes(scratch_class-&gt;inner_classes());
4216   scratch_class-&gt;set_inner_classes(old_inner_classes);
4217 
4218   // Initialize the vtable and interface table after
4219   // methods have been rewritten
4220   // no exception should happen here since we explicitly
4221   // do not check loader constraints.
4222   // compare_and_normalize_class_versions has already checked:
4223   //  - classloaders unchanged, signatures unchanged
4224   //  - all instanceKlasses for redefined classes reused &amp; contents updated
4225   the_class-&gt;vtable().initialize_vtable(false, THREAD);
4226   the_class-&gt;itable().initialize_itable(false, THREAD);
4227   assert(!HAS_PENDING_EXCEPTION || (THREAD-&gt;pending_exception()-&gt;is_a(SystemDictionary::ThreadDeath_klass())), &quot;redefine exception&quot;);
4228 
4229   // Leave arrays of jmethodIDs and itable index cache unchanged
4230 
4231   // Copy the &quot;source file name&quot; attribute from new class version
4232   the_class-&gt;set_source_file_name_index(
4233     scratch_class-&gt;source_file_name_index());
4234 
4235   // Copy the &quot;source debug extension&quot; attribute from new class version
4236   the_class-&gt;set_source_debug_extension(
4237     scratch_class-&gt;source_debug_extension(),
4238     scratch_class-&gt;source_debug_extension() == NULL ? 0 :
4239     (int)strlen(scratch_class-&gt;source_debug_extension()));
4240 
4241   // Use of javac -g could be different in the old and the new
4242   if (scratch_class-&gt;access_flags().has_localvariable_table() !=
4243       the_class-&gt;access_flags().has_localvariable_table()) {
4244 
4245     AccessFlags flags = the_class-&gt;access_flags();
4246     if (scratch_class-&gt;access_flags().has_localvariable_table()) {
4247       flags.set_has_localvariable_table();
4248     } else {
4249       flags.clear_has_localvariable_table();
4250     }
4251     the_class-&gt;set_access_flags(flags);
4252   }
4253 
4254   swap_annotations(the_class, scratch_class);
4255 
4256   // Replace minor version number of class file
4257   u2 old_minor_version = the_class-&gt;minor_version();
4258   the_class-&gt;set_minor_version(scratch_class-&gt;minor_version());
4259   scratch_class-&gt;set_minor_version(old_minor_version);
4260 
4261   // Replace major version number of class file
4262   u2 old_major_version = the_class-&gt;major_version();
4263   the_class-&gt;set_major_version(scratch_class-&gt;major_version());
4264   scratch_class-&gt;set_major_version(old_major_version);
4265 
4266   // Replace CP indexes for class and name+type of enclosing method
4267   u2 old_class_idx  = the_class-&gt;enclosing_method_class_index();
4268   u2 old_method_idx = the_class-&gt;enclosing_method_method_index();
4269   the_class-&gt;set_enclosing_method_indices(
4270     scratch_class-&gt;enclosing_method_class_index(),
4271     scratch_class-&gt;enclosing_method_method_index());
4272   scratch_class-&gt;set_enclosing_method_indices(old_class_idx, old_method_idx);
4273 
4274   // Replace fingerprint data
4275   the_class-&gt;set_has_passed_fingerprint_check(scratch_class-&gt;has_passed_fingerprint_check());
4276   the_class-&gt;store_fingerprint(scratch_class-&gt;get_stored_fingerprint());
4277 
4278   the_class-&gt;set_has_been_redefined();
4279 
4280   if (!the_class-&gt;should_be_initialized()) {
4281     // Class was already initialized, so AOT has only seen the original version.
4282     // We need to let AOT look at it again.
4283     AOTLoader::load_for_klass(the_class, THREAD);
4284   }
4285 
4286   // keep track of previous versions of this class
4287   the_class-&gt;add_previous_version(scratch_class, emcp_method_count);
4288 
4289   _timer_rsc_phase1.stop();
4290   if (log_is_enabled(Info, redefine, class, timer)) {
4291     _timer_rsc_phase2.start();
4292   }
4293 
4294   if (the_class-&gt;oop_map_cache() != NULL) {
4295     // Flush references to any obsolete methods from the oop map cache
4296     // so that obsolete methods are not pinned.
4297     the_class-&gt;oop_map_cache()-&gt;flush_obsolete_entries();
4298   }
4299 
4300   increment_class_counter((InstanceKlass *)the_class, THREAD);
4301 
4302   if (EventClassRedefinition::is_enabled()) {
4303     EventClassRedefinition event;
4304     event.set_classModificationCount(java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4305     event.set_redefinedClass(the_class);
4306     event.set_redefinitionId(_id);
4307     event.commit();
4308   }
4309 
4310   {
4311     ResourceMark rm(THREAD);
4312     // increment the classRedefinedCount field in the_class and in any
4313     // direct and indirect subclasses of the_class
4314     log_info(redefine, class, load)
4315       (&quot;redefined name=%s, count=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
4316        the_class-&gt;external_name(), java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()), os::available_memory() &gt;&gt; 10);
4317     Events::log_redefinition(THREAD, &quot;redefined class name=%s, count=%d&quot;,
4318                              the_class-&gt;external_name(),
4319                              java_lang_Class::classRedefinedCount(the_class-&gt;java_mirror()));
4320 
4321   }
4322   _timer_rsc_phase2.stop();
4323 
4324 } // end redefine_single_class()
4325 
4326 
4327 // Increment the classRedefinedCount field in the specific InstanceKlass
4328 // and in all direct and indirect subclasses.
4329 void VM_RedefineClasses::increment_class_counter(InstanceKlass *ik, TRAPS) {
4330   oop class_mirror = ik-&gt;java_mirror();
4331   Klass* class_oop = java_lang_Class::as_Klass(class_mirror);
4332   int new_count = java_lang_Class::classRedefinedCount(class_mirror) + 1;
4333   java_lang_Class::set_classRedefinedCount(class_mirror, new_count);
4334 
4335   if (class_oop != _the_class) {
4336     // _the_class count is printed at end of redefine_single_class()
4337     log_debug(redefine, class, subclass)(&quot;updated count in subclass=%s to %d&quot;, ik-&gt;external_name(), new_count);
4338   }
4339 
4340   for (Klass *subk = ik-&gt;subklass(); subk != NULL;
4341        subk = subk-&gt;next_sibling()) {
4342     if (subk-&gt;is_instance_klass()) {
4343       // Only update instanceKlasses
4344       InstanceKlass *subik = InstanceKlass::cast(subk);
4345       // recursively do subclasses of the current subclass
4346       increment_class_counter(subik, THREAD);
4347     }
4348   }
4349 }
4350 
4351 void VM_RedefineClasses::CheckClass::do_klass(Klass* k) {
4352   bool no_old_methods = true;  // be optimistic
4353 
4354   // Both array and instance classes have vtables.
4355   // a vtable should never contain old or obsolete methods
4356   ResourceMark rm(_thread);
4357   if (k-&gt;vtable_length() &gt; 0 &amp;&amp;
4358       !k-&gt;vtable().check_no_old_or_obsolete_entries()) {
4359     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4360       log_trace(redefine, class, obsolete, metadata)
4361         (&quot;klassVtable::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4362          k-&gt;signature_name());
4363       k-&gt;vtable().dump_vtable();
4364     }
4365     no_old_methods = false;
4366   }
4367 
4368   if (k-&gt;is_instance_klass()) {
4369     HandleMark hm(_thread);
4370     InstanceKlass *ik = InstanceKlass::cast(k);
4371 
4372     // an itable should never contain old or obsolete methods
4373     if (ik-&gt;itable_length() &gt; 0 &amp;&amp;
4374         !ik-&gt;itable().check_no_old_or_obsolete_entries()) {
4375       if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4376         log_trace(redefine, class, obsolete, metadata)
4377           (&quot;klassItable::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4378            ik-&gt;signature_name());
4379         ik-&gt;itable().dump_itable();
4380       }
4381       no_old_methods = false;
4382     }
4383 
4384     // the constant pool cache should never contain non-deleted old or obsolete methods
4385     if (ik-&gt;constants() != NULL &amp;&amp;
4386         ik-&gt;constants()-&gt;cache() != NULL &amp;&amp;
4387         !ik-&gt;constants()-&gt;cache()-&gt;check_no_old_or_obsolete_entries()) {
4388       if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4389         log_trace(redefine, class, obsolete, metadata)
4390           (&quot;cp-cache::check_no_old_or_obsolete_entries failure -- OLD or OBSOLETE method found -- class: %s&quot;,
4391            ik-&gt;signature_name());
4392         ik-&gt;constants()-&gt;cache()-&gt;dump_cache();
4393       }
4394       no_old_methods = false;
4395     }
4396   }
4397 
4398   // print and fail guarantee if old methods are found.
4399   if (!no_old_methods) {
4400     if (log_is_enabled(Trace, redefine, class, obsolete, metadata)) {
4401       dump_methods();
4402     } else {
4403       log_trace(redefine, class)(&quot;Use the &#39;-Xlog:redefine+class*:&#39; option &quot;
4404         &quot;to see more info about the following guarantee() failure.&quot;);
4405     }
4406     guarantee(false, &quot;OLD and/or OBSOLETE method(s) found&quot;);
4407   }
4408 }
4409 
4410 u8 VM_RedefineClasses::next_id() {
4411   while (true) {
4412     u8 id = _id_counter;
4413     u8 next_id = id + 1;
4414     u8 result = Atomic::cmpxchg(&amp;_id_counter, id, next_id);
4415     if (result == id) {
4416       return next_id;
4417     }
4418   }
4419 }
4420 
4421 void VM_RedefineClasses::dump_methods() {
4422   int j;
4423   log_trace(redefine, class, dump)(&quot;_old_methods --&quot;);
4424   for (j = 0; j &lt; _old_methods-&gt;length(); ++j) {
4425     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4426     Method* m = _old_methods-&gt;at(j);
4427     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4428     m-&gt;access_flags().print_on(&amp;log_stream);
4429     log_stream.print(&quot; --  &quot;);
4430     m-&gt;print_name(&amp;log_stream);
4431     log_stream.cr();
4432   }
4433   log_trace(redefine, class, dump)(&quot;_new_methods --&quot;);
4434   for (j = 0; j &lt; _new_methods-&gt;length(); ++j) {
4435     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4436     Method* m = _new_methods-&gt;at(j);
4437     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4438     m-&gt;access_flags().print_on(&amp;log_stream);
4439     log_stream.print(&quot; --  &quot;);
4440     m-&gt;print_name(&amp;log_stream);
4441     log_stream.cr();
4442   }
4443   log_trace(redefine, class, dump)(&quot;_matching_methods --&quot;);
4444   for (j = 0; j &lt; _matching_methods_length; ++j) {
4445     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4446     Method* m = _matching_old_methods[j];
4447     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4448     m-&gt;access_flags().print_on(&amp;log_stream);
4449     log_stream.print(&quot; --  &quot;);
4450     m-&gt;print_name();
4451     log_stream.cr();
4452 
4453     m = _matching_new_methods[j];
4454     log_stream.print(&quot;      (%5d)  &quot;, m-&gt;vtable_index());
4455     m-&gt;access_flags().print_on(&amp;log_stream);
4456     log_stream.cr();
4457   }
4458   log_trace(redefine, class, dump)(&quot;_deleted_methods --&quot;);
4459   for (j = 0; j &lt; _deleted_methods_length; ++j) {
4460     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4461     Method* m = _deleted_methods[j];
4462     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4463     m-&gt;access_flags().print_on(&amp;log_stream);
4464     log_stream.print(&quot; --  &quot;);
4465     m-&gt;print_name(&amp;log_stream);
4466     log_stream.cr();
4467   }
4468   log_trace(redefine, class, dump)(&quot;_added_methods --&quot;);
4469   for (j = 0; j &lt; _added_methods_length; ++j) {
4470     LogStreamHandle(Trace, redefine, class, dump) log_stream;
4471     Method* m = _added_methods[j];
4472     log_stream.print(&quot;%4d  (%5d)  &quot;, j, m-&gt;vtable_index());
4473     m-&gt;access_flags().print_on(&amp;log_stream);
4474     log_stream.print(&quot; --  &quot;);
4475     m-&gt;print_name(&amp;log_stream);
4476     log_stream.cr();
4477   }
4478 }
4479 
4480 void VM_RedefineClasses::print_on_error(outputStream* st) const {
4481   VM_Operation::print_on_error(st);
4482   if (_the_class != NULL) {
4483     ResourceMark rm;
4484     st-&gt;print_cr(&quot;, redefining class %s&quot;, _the_class-&gt;external_name());
4485   }
4486 }
    </pre>
  </body>
</html>
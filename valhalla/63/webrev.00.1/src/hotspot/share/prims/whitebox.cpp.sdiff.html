<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="unsafe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/whitebox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;compiler/methodMatcher.hpp&quot;
  37 #include &quot;compiler/directivesParser.hpp&quot;
  38 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  39 #include &quot;gc/shared/gcConfig.hpp&quot;
  40 #include &quot;gc/shared/genArguments.hpp&quot;
  41 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  42 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  43 #include &quot;memory/filemap.hpp&quot;
  44 #include &quot;memory/heapShared.inline.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
<span class="line-modified">  47 #include &quot;memory/iterator.hpp&quot;</span>
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;memory/oopFactory.hpp&quot;
  51 #include &quot;oops/array.hpp&quot;
  52 #include &quot;oops/compressedOops.hpp&quot;

  53 #include &quot;oops/constantPool.inline.hpp&quot;
  54 #include &quot;oops/method.inline.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;

  58 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  59 #include &quot;prims/resolvedMethodTable.hpp&quot;
  60 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  61 #include &quot;prims/whitebox.inline.hpp&quot;
  62 #include &quot;runtime/arguments.hpp&quot;
  63 #include &quot;runtime/atomic.hpp&quot;
  64 #include &quot;runtime/deoptimization.hpp&quot;
  65 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  66 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  67 #include &quot;runtime/frame.inline.hpp&quot;
  68 #include &quot;runtime/handles.inline.hpp&quot;
  69 #include &quot;runtime/handshake.hpp&quot;
  70 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  71 #include &quot;runtime/javaCalls.hpp&quot;
  72 #include &quot;runtime/jniHandles.inline.hpp&quot;
  73 #include &quot;runtime/os.hpp&quot;
  74 #include &quot;runtime/sweeper.hpp&quot;
  75 #include &quot;runtime/thread.hpp&quot;
  76 #include &quot;runtime/threadSMR.hpp&quot;
  77 #include &quot;runtime/vm_version.hpp&quot;
</pre>
<hr />
<pre>
1820 
1821 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1822   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1823   ConstantPool* cp = ik-&gt;constants();
1824   if (cp-&gt;cache() == NULL) {
1825     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), &quot;Constant pool does not have a cache&quot;);
1826   }
1827   jint cpci = index;
1828   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1829   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1830     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool cache index is out of range&quot;);
1831   }
1832   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1833   return cpi;
1834 WB_END
1835 
1836 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1837   return ConstantPool::encode_invokedynamic_index(index);
1838 WB_END
1839 




























































































1840 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1841   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1842   VMThread::execute(&amp;clear_ics);
1843 WB_END
1844 
1845 template &lt;typename T&gt;
1846 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1847   assert(value != NULL, &quot;sanity&quot;);
1848   if (method == NULL || name == NULL) {
1849     return false;
1850   }
1851   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1852   CHECK_JNI_EXCEPTION_(env, false);
1853   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1854   // can&#39;t be in VM when we call JNI
1855   ThreadToNativeFromVM ttnfv(thread);
1856   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1857   CHECK_JNI_EXCEPTION_(env, false);
1858   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1859   env-&gt;ReleaseStringUTFChars(name, flag_name);
</pre>
<hr />
<pre>
2397                                                       (void*)&amp;WB_DefineModule },
2398   {CC&quot;AddModuleExports&quot;,   CC&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,
2399                                                       (void*)&amp;WB_AddModuleExports },
2400   {CC&quot;AddReadsModule&quot;,     CC&quot;(Ljava/lang/Object;Ljava/lang/Object;)V&quot;,
2401                                                       (void*)&amp;WB_AddReadsModule },
2402   {CC&quot;AddModuleExportsToAllUnnamed&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2403                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2404   {CC&quot;AddModuleExportsToAll&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2405                                                       (void*)&amp;WB_AddModuleExportsToAll },
2406   {CC&quot;assertMatchingSafepointCalls&quot;, CC&quot;(ZZ)V&quot;,       (void*)&amp;WB_AssertMatchingSafepointCalls },
2407   {CC&quot;assertSpecialLock&quot;,  CC&quot;(ZZ)V&quot;,                 (void*)&amp;WB_AssertSpecialLock },
2408   {CC&quot;isMonitorInflated0&quot;, CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsMonitorInflated  },
2409   {CC&quot;forceSafepoint&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_ForceSafepoint     },
2410   {CC&quot;getConstantPool0&quot;,   CC&quot;(Ljava/lang/Class;)J&quot;,  (void*)&amp;WB_GetConstantPool    },
2411   {CC&quot;getConstantPoolCacheIndexTag0&quot;, CC&quot;()I&quot;,  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2412   {CC&quot;getConstantPoolCacheLength0&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,  (void*)&amp;WB_GetConstantPoolCacheLength},
2413   {CC&quot;remapInstructionOperandFromCPCache0&quot;,
2414       CC&quot;(Ljava/lang/Class;I)I&quot;,                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2415   {CC&quot;encodeConstantPoolIndyIndex0&quot;,
2416       CC&quot;(I)I&quot;,                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},






2417   {CC&quot;getMethodBooleanOption&quot;,
2418       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2419                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2420   {CC&quot;getMethodIntxOption&quot;,
2421       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2422                                                       (void*)&amp;WB_GetMethodIntxOption},
2423   {CC&quot;getMethodUintxOption&quot;,
2424       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2425                                                       (void*)&amp;WB_GetMethodUintxOption},
2426   {CC&quot;getMethodDoubleOption&quot;,
2427       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;&quot;,
2428                                                       (void*)&amp;WB_GetMethodDoubleOption},
2429   {CC&quot;getMethodStringOption&quot;,
2430       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;&quot;,
2431                                                       (void*)&amp;WB_GetMethodStringOption},
2432   {CC&quot;getDefaultArchivePath&quot;,             CC&quot;()Ljava/lang/String;&quot;,
2433                                                       (void*)&amp;WB_GetDefaultArchivePath},
2434   {CC&quot;isSharingEnabled&quot;,   CC&quot;()Z&quot;,                   (void*)&amp;WB_IsSharingEnabled},
2435   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2436   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
</pre>
</td>
<td>
<hr />
<pre>
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;compiler/methodMatcher.hpp&quot;
  37 #include &quot;compiler/directivesParser.hpp&quot;
  38 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  39 #include &quot;gc/shared/gcConfig.hpp&quot;
  40 #include &quot;gc/shared/genArguments.hpp&quot;
  41 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  42 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  43 #include &quot;memory/filemap.hpp&quot;
  44 #include &quot;memory/heapShared.inline.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
<span class="line-modified">  47 #include &quot;memory/iterator.inline.hpp&quot;</span>
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;memory/oopFactory.hpp&quot;
  51 #include &quot;oops/array.hpp&quot;
  52 #include &quot;oops/compressedOops.hpp&quot;
<span class="line-added">  53 #include &quot;oops/compressedOops.inline.hpp&quot;</span>
  54 #include &quot;oops/constantPool.inline.hpp&quot;
  55 #include &quot;oops/method.inline.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  59 #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  61 #include &quot;prims/resolvedMethodTable.hpp&quot;
  62 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  63 #include &quot;prims/whitebox.inline.hpp&quot;
  64 #include &quot;runtime/arguments.hpp&quot;
  65 #include &quot;runtime/atomic.hpp&quot;
  66 #include &quot;runtime/deoptimization.hpp&quot;
  67 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  68 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  69 #include &quot;runtime/frame.inline.hpp&quot;
  70 #include &quot;runtime/handles.inline.hpp&quot;
  71 #include &quot;runtime/handshake.hpp&quot;
  72 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/os.hpp&quot;
  76 #include &quot;runtime/sweeper.hpp&quot;
  77 #include &quot;runtime/thread.hpp&quot;
  78 #include &quot;runtime/threadSMR.hpp&quot;
  79 #include &quot;runtime/vm_version.hpp&quot;
</pre>
<hr />
<pre>
1822 
1823 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1824   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1825   ConstantPool* cp = ik-&gt;constants();
1826   if (cp-&gt;cache() == NULL) {
1827     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), &quot;Constant pool does not have a cache&quot;);
1828   }
1829   jint cpci = index;
1830   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1831   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1832     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool cache index is out of range&quot;);
1833   }
1834   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1835   return cpi;
1836 WB_END
1837 
1838 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1839   return ConstantPool::encode_invokedynamic_index(index);
1840 WB_END
1841 
<span class="line-added">1842 WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))</span>
<span class="line-added">1843   oop aoop = JNIHandles::resolve(thing);</span>
<span class="line-added">1844   if (!aoop-&gt;is_instance()) {</span>
<span class="line-added">1845     return NULL;</span>
<span class="line-added">1846   }</span>
<span class="line-added">1847   instanceHandle ih(THREAD, (instanceOop) aoop);</span>
<span class="line-added">1848   InstanceKlass* klass = InstanceKlass::cast(aoop-&gt;klass());</span>
<span class="line-added">1849   if (klass-&gt;nonstatic_oop_map_count() == 0) {</span>
<span class="line-added">1850     return NULL;</span>
<span class="line-added">1851   }</span>
<span class="line-added">1852   const OopMapBlock* map = klass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">1853   const OopMapBlock* const end = map + klass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">1854   int oop_count = 0;</span>
<span class="line-added">1855   while (map &lt; end) {</span>
<span class="line-added">1856     oop_count += map-&gt;count();</span>
<span class="line-added">1857     map++;</span>
<span class="line-added">1858   }</span>
<span class="line-added">1859 </span>
<span class="line-added">1860   objArrayOop result_array =</span>
<span class="line-added">1861       oopFactory::new_objArray(SystemDictionary::Object_klass(), oop_count, CHECK_NULL);</span>
<span class="line-added">1862   map = klass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">1863   instanceOop ioop = ih();</span>
<span class="line-added">1864   int index = 0;</span>
<span class="line-added">1865   while (map &lt; end) {</span>
<span class="line-added">1866     int offset = map-&gt;offset();</span>
<span class="line-added">1867     for (unsigned int j = 0; j &lt; map-&gt;count(); j++) {</span>
<span class="line-added">1868       result_array-&gt;obj_at_put(index++, ioop-&gt;obj_field(offset));</span>
<span class="line-added">1869       offset += heapOopSize;</span>
<span class="line-added">1870     }</span>
<span class="line-added">1871     map++;</span>
<span class="line-added">1872   }</span>
<span class="line-added">1873   return (jobjectArray)JNIHandles::make_local(env, result_array);</span>
<span class="line-added">1874 WB_END</span>
<span class="line-added">1875 </span>
<span class="line-added">1876 class CollectOops : public BasicOopIterateClosure {</span>
<span class="line-added">1877  public:</span>
<span class="line-added">1878   GrowableArray&lt;Handle&gt;* array;</span>
<span class="line-added">1879 </span>
<span class="line-added">1880   objArrayOop create_results(TRAPS) {</span>
<span class="line-added">1881     objArrayOop result_array =</span>
<span class="line-added">1882         oopFactory::new_objArray(SystemDictionary::Object_klass(), array-&gt;length(), CHECK_NULL);</span>
<span class="line-added">1883     for (int i = 0 ; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">1884       result_array-&gt;obj_at_put(i, array-&gt;at(i)());</span>
<span class="line-added">1885     }</span>
<span class="line-added">1886     return result_array;</span>
<span class="line-added">1887   }</span>
<span class="line-added">1888 </span>
<span class="line-added">1889   jobjectArray create_jni_result(JNIEnv* env, TRAPS) {</span>
<span class="line-added">1890     return (jobjectArray)JNIHandles::make_local(env, create_results(THREAD));</span>
<span class="line-added">1891   }</span>
<span class="line-added">1892 </span>
<span class="line-added">1893   void add_oop(oop o) {</span>
<span class="line-added">1894     // Value might be oop, but JLS can&#39;t see as Object, just iterate through it...</span>
<span class="line-added">1895     if (o != NULL &amp;&amp; o-&gt;is_value()) {</span>
<span class="line-added">1896       o-&gt;oop_iterate(this);</span>
<span class="line-added">1897     } else {</span>
<span class="line-added">1898       array-&gt;append(Handle(Thread::current(), o));</span>
<span class="line-added">1899     }</span>
<span class="line-added">1900   }</span>
<span class="line-added">1901 </span>
<span class="line-added">1902   void do_oop(oop* o) { add_oop(*o); }</span>
<span class="line-added">1903   void do_oop(narrowOop* v) { add_oop(CompressedOops::decode(*v)); }</span>
<span class="line-added">1904 };</span>
<span class="line-added">1905 </span>
<span class="line-added">1906 </span>
<span class="line-added">1907 WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))</span>
<span class="line-added">1908   ResourceMark rm(THREAD);</span>
<span class="line-added">1909   GrowableArray&lt;Handle&gt;* array = new GrowableArray&lt;Handle&gt;(128);</span>
<span class="line-added">1910   CollectOops collectOops;</span>
<span class="line-added">1911   collectOops.array = array;</span>
<span class="line-added">1912 </span>
<span class="line-added">1913   JNIHandles::resolve(thing)-&gt;oop_iterate(&amp;collectOops);</span>
<span class="line-added">1914 </span>
<span class="line-added">1915   return collectOops.create_jni_result(env, THREAD);</span>
<span class="line-added">1916 WB_END</span>
<span class="line-added">1917 </span>
<span class="line-added">1918 WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))</span>
<span class="line-added">1919   ResourceMark rm(THREAD);</span>
<span class="line-added">1920   GrowableArray&lt;Handle&gt;* array = new GrowableArray&lt;Handle&gt;(128);</span>
<span class="line-added">1921   CollectOops collectOops;</span>
<span class="line-added">1922   collectOops.array = array;</span>
<span class="line-added">1923   StackFrameStream sfs(thread);</span>
<span class="line-added">1924   while (depth &gt; 0) { // Skip the native WB API frame</span>
<span class="line-added">1925     sfs.next();</span>
<span class="line-added">1926     frame* f = sfs.current();</span>
<span class="line-added">1927     f-&gt;oops_do(&amp;collectOops, NULL, sfs.register_map());</span>
<span class="line-added">1928     depth--;</span>
<span class="line-added">1929   }</span>
<span class="line-added">1930   return collectOops.create_jni_result(env, THREAD);</span>
<span class="line-added">1931 WB_END</span>
<span class="line-added">1932 </span>
<span class="line-added">1933 </span>
1934 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1935   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1936   VMThread::execute(&amp;clear_ics);
1937 WB_END
1938 
1939 template &lt;typename T&gt;
1940 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1941   assert(value != NULL, &quot;sanity&quot;);
1942   if (method == NULL || name == NULL) {
1943     return false;
1944   }
1945   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1946   CHECK_JNI_EXCEPTION_(env, false);
1947   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1948   // can&#39;t be in VM when we call JNI
1949   ThreadToNativeFromVM ttnfv(thread);
1950   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1951   CHECK_JNI_EXCEPTION_(env, false);
1952   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1953   env-&gt;ReleaseStringUTFChars(name, flag_name);
</pre>
<hr />
<pre>
2491                                                       (void*)&amp;WB_DefineModule },
2492   {CC&quot;AddModuleExports&quot;,   CC&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,
2493                                                       (void*)&amp;WB_AddModuleExports },
2494   {CC&quot;AddReadsModule&quot;,     CC&quot;(Ljava/lang/Object;Ljava/lang/Object;)V&quot;,
2495                                                       (void*)&amp;WB_AddReadsModule },
2496   {CC&quot;AddModuleExportsToAllUnnamed&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2497                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2498   {CC&quot;AddModuleExportsToAll&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2499                                                       (void*)&amp;WB_AddModuleExportsToAll },
2500   {CC&quot;assertMatchingSafepointCalls&quot;, CC&quot;(ZZ)V&quot;,       (void*)&amp;WB_AssertMatchingSafepointCalls },
2501   {CC&quot;assertSpecialLock&quot;,  CC&quot;(ZZ)V&quot;,                 (void*)&amp;WB_AssertSpecialLock },
2502   {CC&quot;isMonitorInflated0&quot;, CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsMonitorInflated  },
2503   {CC&quot;forceSafepoint&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_ForceSafepoint     },
2504   {CC&quot;getConstantPool0&quot;,   CC&quot;(Ljava/lang/Class;)J&quot;,  (void*)&amp;WB_GetConstantPool    },
2505   {CC&quot;getConstantPoolCacheIndexTag0&quot;, CC&quot;()I&quot;,  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2506   {CC&quot;getConstantPoolCacheLength0&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,  (void*)&amp;WB_GetConstantPoolCacheLength},
2507   {CC&quot;remapInstructionOperandFromCPCache0&quot;,
2508       CC&quot;(Ljava/lang/Class;I)I&quot;,                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2509   {CC&quot;encodeConstantPoolIndyIndex0&quot;,
2510       CC&quot;(I)I&quot;,                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
<span class="line-added">2511   {CC&quot;getObjectsViaKlassOopMaps0&quot;,</span>
<span class="line-added">2512       CC&quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;,    (void*)&amp;WB_getObjectsViaKlassOopMaps},</span>
<span class="line-added">2513   {CC&quot;getObjectsViaOopIterator0&quot;,</span>
<span class="line-added">2514           CC&quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;,(void*)&amp;WB_getObjectsViaOopIterator},</span>
<span class="line-added">2515   {CC&quot;getObjectsViaFrameOopIterator&quot;,</span>
<span class="line-added">2516       CC&quot;(I)[Ljava/lang/Object;&quot;,                     (void*)&amp;WB_getObjectsViaFrameOopIterator},</span>
2517   {CC&quot;getMethodBooleanOption&quot;,
2518       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2519                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2520   {CC&quot;getMethodIntxOption&quot;,
2521       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2522                                                       (void*)&amp;WB_GetMethodIntxOption},
2523   {CC&quot;getMethodUintxOption&quot;,
2524       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2525                                                       (void*)&amp;WB_GetMethodUintxOption},
2526   {CC&quot;getMethodDoubleOption&quot;,
2527       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;&quot;,
2528                                                       (void*)&amp;WB_GetMethodDoubleOption},
2529   {CC&quot;getMethodStringOption&quot;,
2530       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;&quot;,
2531                                                       (void*)&amp;WB_GetMethodStringOption},
2532   {CC&quot;getDefaultArchivePath&quot;,             CC&quot;()Ljava/lang/String;&quot;,
2533                                                       (void*)&amp;WB_GetDefaultArchivePath},
2534   {CC&quot;isSharingEnabled&quot;,   CC&quot;()Z&quot;,                   (void*)&amp;WB_IsSharingEnabled},
2535   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2536   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
</pre>
</td>
</tr>
</table>
<center><a href="unsafe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../runtime/arguments.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
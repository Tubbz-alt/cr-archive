<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="safepoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/stringTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/compiledIC.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/compiledMethod.inline.hpp&quot;
  35 #include &quot;code/scopeDesc.hpp&quot;
  36 #include &quot;code/vtableStubs.hpp&quot;
  37 #include &quot;compiler/abstractCompiler.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
  39 #include &quot;compiler/disassembler.hpp&quot;
  40 #include &quot;gc/shared/barrierSet.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  42 #include &quot;interpreter/interpreter.hpp&quot;
  43 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  44 #include &quot;jfr/jfrEvents.hpp&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;memory/metaspaceShared.hpp&quot;

  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;


  49 #include &quot;oops/klass.hpp&quot;
  50 #include &quot;oops/method.inline.hpp&quot;
  51 #include &quot;oops/objArrayKlass.hpp&quot;

  52 #include &quot;oops/oop.inline.hpp&quot;

  53 #include &quot;prims/forte.hpp&quot;
  54 #include &quot;prims/jvmtiExport.hpp&quot;
  55 #include &quot;prims/methodHandles.hpp&quot;
  56 #include &quot;prims/nativeLookup.hpp&quot;
  57 #include &quot;runtime/arguments.hpp&quot;
  58 #include &quot;runtime/atomic.hpp&quot;
  59 #include &quot;runtime/biasedLocking.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/stubRoutines.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vframeArray.hpp&quot;
  70 #include &quot;utilities/copy.hpp&quot;
  71 #include &quot;utilities/dtrace.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;
  73 #include &quot;utilities/hashtable.inline.hpp&quot;
  74 #include &quot;utilities/macros.hpp&quot;
  75 #include &quot;utilities/xmlstream.hpp&quot;
  76 #ifdef COMPILER1
  77 #include &quot;c1/c1_Runtime1.hpp&quot;
  78 #endif
  79 
  80 // Shared stub locations
  81 RuntimeStub*        SharedRuntime::_wrong_method_blob;
  82 RuntimeStub*        SharedRuntime::_wrong_method_abstract_blob;
  83 RuntimeStub*        SharedRuntime::_ic_miss_blob;
  84 RuntimeStub*        SharedRuntime::_resolve_opt_virtual_call_blob;
  85 RuntimeStub*        SharedRuntime::_resolve_virtual_call_blob;
  86 RuntimeStub*        SharedRuntime::_resolve_static_call_blob;
<span class="line-removed">  87 address             SharedRuntime::_resolve_static_call_entry;</span>
  88 
  89 DeoptimizationBlob* SharedRuntime::_deopt_blob;
  90 SafepointBlob*      SharedRuntime::_polling_page_vectors_safepoint_handler_blob;
  91 SafepointBlob*      SharedRuntime::_polling_page_safepoint_handler_blob;
  92 SafepointBlob*      SharedRuntime::_polling_page_return_handler_blob;
  93 
  94 #ifdef COMPILER2
  95 UncommonTrapBlob*   SharedRuntime::_uncommon_trap_blob;
  96 #endif // COMPILER2
  97 
  98 
  99 //----------------------------generate_stubs-----------------------------------
 100 void SharedRuntime::generate_stubs() {
 101   _wrong_method_blob                   = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method),          &quot;wrong_method_stub&quot;);
 102   _wrong_method_abstract_blob          = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract), &quot;wrong_method_abstract_stub&quot;);
 103   _ic_miss_blob                        = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss),  &quot;ic_miss_stub&quot;);
 104   _resolve_opt_virtual_call_blob       = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C),   &quot;resolve_opt_virtual_call&quot;);
 105   _resolve_virtual_call_blob           = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C),       &quot;resolve_virtual_call&quot;);
 106   _resolve_static_call_blob            = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C),        &quot;resolve_static_call&quot;);
<span class="line-removed"> 107   _resolve_static_call_entry           = _resolve_static_call_blob-&gt;entry_point();</span>
 108 
 109 #if COMPILER2_OR_JVMCI
 110   // Vectors are generated only by C2 and JVMCI.
 111   bool support_wide = is_wide_vector(MaxVectorSize);
 112   if (support_wide) {
 113     _polling_page_vectors_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_VECTOR_LOOP);
 114   }
 115 #endif // COMPILER2_OR_JVMCI
 116   _polling_page_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_LOOP);
 117   _polling_page_return_handler_blob    = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_RETURN);
 118 
 119   generate_deopt_blob();
 120 
 121 #ifdef COMPILER2
 122   generate_uncommon_trap_blob();
 123 #endif // COMPILER2
 124 }
 125 
 126 #include &lt;math.h&gt;
 127 
</pre>
<hr />
<pre>
1034   }
1035   return NULL;
1036 }
1037 
1038 // Finds receiver, CallInfo (i.e. receiver method), and calling bytecode
1039 // for a call current in progress, i.e., arguments has been pushed on stack
1040 // but callee has not been invoked yet.  Caller frame must be compiled.
1041 Handle SharedRuntime::find_callee_info_helper(JavaThread* thread,
1042                                               vframeStream&amp; vfst,
1043                                               Bytecodes::Code&amp; bc,
1044                                               CallInfo&amp; callinfo, TRAPS) {
1045   Handle receiver;
1046   Handle nullHandle;  //create a handy null handle for exception returns
1047 
1048   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1049 
1050   // Find caller and bci from vframe
1051   methodHandle caller(THREAD, vfst.method());
1052   int          bci   = vfst.bci();
1053 















1054   Bytecode_invoke bytecode(caller, bci);
1055   int bytecode_index = bytecode.index();
1056   bc = bytecode.invoke_code();
1057 
1058   methodHandle attached_method(THREAD, extract_attached_method(vfst));
1059   if (attached_method.not_null()) {
1060     Method* callee = bytecode.static_target(CHECK_NH);
1061     vmIntrinsics::ID id = callee-&gt;intrinsic_id();
1062     // When VM replaces MH.invokeBasic/linkTo* call with a direct/virtual call,
1063     // it attaches statically resolved method to the call site.
1064     if (MethodHandles::is_signature_polymorphic(id) &amp;&amp;
1065         MethodHandles::is_signature_polymorphic_intrinsic(id)) {
1066       bc = MethodHandles::signature_polymorphic_intrinsic_bytecode(id);
1067 
1068       // Adjust invocation mode according to the attached method.
1069       switch (bc) {
1070         case Bytecodes::_invokevirtual:
1071           if (attached_method-&gt;method_holder()-&gt;is_interface()) {
1072             bc = Bytecodes::_invokeinterface;
1073           }
1074           break;
1075         case Bytecodes::_invokeinterface:
1076           if (!attached_method-&gt;method_holder()-&gt;is_interface()) {
1077             bc = Bytecodes::_invokevirtual;
1078           }
1079           break;
1080         case Bytecodes::_invokehandle:
1081           if (!MethodHandles::is_signature_polymorphic_method(attached_method())) {
1082             bc = attached_method-&gt;is_static() ? Bytecodes::_invokestatic
1083                                               : Bytecodes::_invokevirtual;
1084           }
1085           break;
1086         default:
1087           break;
1088       }






1089     }
1090   }
1091 
1092   assert(bc != Bytecodes::_illegal, &quot;not initialized&quot;);
1093 
1094   bool has_receiver = bc != Bytecodes::_invokestatic &amp;&amp;
1095                       bc != Bytecodes::_invokedynamic &amp;&amp;
1096                       bc != Bytecodes::_invokehandle;

1097 
1098   // Find receiver for non-static call
1099   if (has_receiver) {
1100     // This register map must be update since we need to find the receiver for
1101     // compiled frames. The receiver might be in a register.
1102     RegisterMap reg_map2(thread);
1103     frame stubFrame   = thread-&gt;last_frame();
1104     // Caller-frame is a compiled frame
1105     frame callerFrame = stubFrame.sender(&amp;reg_map2);

1106 
<span class="line-modified">1107     if (attached_method.is_null()) {</span>
<span class="line-modified">1108       Method* callee = bytecode.static_target(CHECK_NH);</span>





1109       if (callee == NULL) {
1110         THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
1111       }
1112     }
<span class="line-modified">1113 </span>
<span class="line-modified">1114     // Retrieve from a compiled argument list</span>
<span class="line-modified">1115     receiver = Handle(THREAD, callerFrame.retrieve_receiver(&amp;reg_map2));</span>
<span class="line-modified">1116 </span>
<span class="line-modified">1117     if (receiver.is_null()) {</span>
<span class="line-modified">1118       THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);</span>








1119     }
1120   }
1121 
1122   // Resolve method
1123   if (attached_method.not_null()) {
1124     // Parameterized by attached method.
<span class="line-modified">1125     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, CHECK_NH);</span>
1126   } else {
1127     // Parameterized by bytecode.
1128     constantPoolHandle constants(THREAD, caller-&gt;constants());
1129     LinkResolver::resolve_invoke(callinfo, receiver, constants, bytecode_index, bc, CHECK_NH);
1130   }
1131 
1132 #ifdef ASSERT
1133   // Check that the receiver klass is of the right subtype and that it is initialized for virtual calls
<span class="line-modified">1134   if (has_receiver) {</span>
1135     assert(receiver.not_null(), &quot;should have thrown exception&quot;);
1136     Klass* receiver_klass = receiver-&gt;klass();
1137     Klass* rk = NULL;
1138     if (attached_method.not_null()) {
1139       // In case there&#39;s resolved method attached, use its holder during the check.
1140       rk = attached_method-&gt;method_holder();
1141     } else {
1142       // Klass is already loaded.
1143       constantPoolHandle constants(THREAD, caller-&gt;constants());
1144       rk = constants-&gt;klass_ref_at(bytecode_index, CHECK_NH);
1145     }
1146     Klass* static_receiver_klass = rk;
1147     assert(receiver_klass-&gt;is_subtype_of(static_receiver_klass),
1148            &quot;actual receiver must be subclass of static receiver klass&quot;);
1149     if (receiver_klass-&gt;is_instance_klass()) {
1150       if (InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized()) {
1151         tty-&gt;print_cr(&quot;ERROR: Klass not yet initialized!!&quot;);
1152         receiver_klass-&gt;print();
1153       }
1154       assert(!InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized(), &quot;receiver_klass must be initialized&quot;);
</pre>
<hr />
<pre>
1173     RegisterMap reg_map(thread, false);
1174     frame fr = thread-&gt;last_frame();
1175     assert(fr.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1176     fr = fr.sender(&amp;reg_map);
1177     assert(fr.is_entry_frame(), &quot;must be&quot;);
1178     // fr is now pointing to the entry frame.
1179     callee_method = methodHandle(THREAD, fr.entry_frame_call_wrapper()-&gt;callee_method());
1180   } else {
1181     Bytecodes::Code bc;
1182     CallInfo callinfo;
1183     find_callee_info_helper(thread, vfst, bc, callinfo, CHECK_(methodHandle()));
1184     callee_method = methodHandle(THREAD, callinfo.selected_method());
1185   }
1186   assert(callee_method()-&gt;is_method(), &quot;must be&quot;);
1187   return callee_method;
1188 }
1189 
1190 // Resolves a call.
1191 methodHandle SharedRuntime::resolve_helper(JavaThread *thread,
1192                                            bool is_virtual,
<span class="line-modified">1193                                            bool is_optimized, TRAPS) {</span>

1194   methodHandle callee_method;
<span class="line-modified">1195   callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, THREAD);</span>
1196   if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
1197     int retry_count = 0;
1198     while (!HAS_PENDING_EXCEPTION &amp;&amp; callee_method-&gt;is_old() &amp;&amp;
1199            callee_method-&gt;method_holder() != SystemDictionary::Object_klass()) {
1200       // If has a pending exception then there is no need to re-try to
1201       // resolve this method.
1202       // If the method has been redefined, we need to try again.
1203       // Hack: we have no way to update the vtables of arrays, so don&#39;t
1204       // require that java.lang.Object has been updated.
1205 
1206       // It is very unlikely that method is redefined more than 100 times
1207       // in the middle of resolve. If it is looping here more than 100 times
1208       // means then there could be a bug here.
1209       guarantee((retry_count++ &lt; 100),
1210                 &quot;Could not resolve to latest version of redefined method&quot;);
1211       // method is redefined in the middle of resolve so re-try.
<span class="line-modified">1212       callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, THREAD);</span>
1213     }
1214   }
1215   return callee_method;
1216 }
1217 
1218 // This fails if resolution required refilling of IC stubs
1219 bool SharedRuntime::resolve_sub_helper_internal(methodHandle callee_method, const frame&amp; caller_frame,
1220                                                 CompiledMethod* caller_nm, bool is_virtual, bool is_optimized,
1221                                                 Handle receiver, CallInfo&amp; call_info, Bytecodes::Code invoke_code, TRAPS) {
1222   StaticCallInfo static_call_info;
1223   CompiledICInfo virtual_call_info;
1224 
1225   // Make sure the callee nmethod does not get deoptimized and removed before
1226   // we are done patching the code.
1227   CompiledMethod* callee = callee_method-&gt;code();
1228 
1229   if (callee != NULL) {
1230     assert(callee-&gt;is_compiled(), &quot;must be nmethod for patching&quot;);
1231   }
1232 
1233   if (callee != NULL &amp;&amp; !callee-&gt;is_in_use()) {
1234     // Patch call site to C2I adapter if callee nmethod is deoptimized or unloaded.
1235     callee = NULL;
1236   }
1237   nmethodLocker nl_callee(callee);
1238 #ifdef ASSERT
1239   address dest_entry_point = callee == NULL ? 0 : callee-&gt;entry_point(); // used below
1240 #endif
1241 
1242   bool is_nmethod = caller_nm-&gt;is_nmethod();

1243 
1244   if (is_virtual) {
<span class="line-modified">1245     assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);</span>







1246     bool static_bound = call_info.resolved_method()-&gt;can_be_statically_bound();
<span class="line-modified">1247     Klass* klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();</span>
<span class="line-modified">1248     CompiledIC::compute_monomorphic_entry(callee_method, klass,</span>
<span class="line-removed">1249                      is_optimized, static_bound, is_nmethod, virtual_call_info,</span>
1250                      CHECK_false);
1251   } else {
1252     // static call
<span class="line-modified">1253     CompiledStaticCall::compute_entry(callee_method, is_nmethod, static_call_info);</span>
1254   }
1255 
1256   // grab lock, check for deoptimization and potentially patch caller
1257   {
1258     CompiledICLocker ml(caller_nm);
1259 
1260     // Lock blocks for safepoint during which both nmethods can change state.
1261 
1262     // Now that we are ready to patch if the Method* was redefined then
1263     // don&#39;t update call site and let the caller retry.
1264     // Don&#39;t update call site if callee nmethod was unloaded or deoptimized.
1265     // Don&#39;t update call site if callee nmethod was replaced by an other nmethod
1266     // which may happen when multiply alive nmethod (tiered compilation)
1267     // will be supported.
1268     if (!callee_method-&gt;is_old() &amp;&amp;
1269         (callee == NULL || (callee-&gt;is_in_use() &amp;&amp; callee_method-&gt;code() == callee))) {
1270       NoSafepointVerifier nsv;
1271 #ifdef ASSERT
1272       // We must not try to patch to jump to an already unloaded method.
1273       if (dest_entry_point != 0) {
</pre>
<hr />
<pre>
1285         }
1286       } else {
1287         if (VM_Version::supports_fast_class_init_checks() &amp;&amp;
1288             invoke_code == Bytecodes::_invokestatic &amp;&amp;
1289             callee_method-&gt;needs_clinit_barrier() &amp;&amp;
1290             callee != NULL &amp;&amp; (callee-&gt;is_compiled_by_jvmci() || callee-&gt;is_aot())) {
1291           return true; // skip patching for JVMCI or AOT code
1292         }
1293         CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_before(caller_frame.pc());
1294         if (ssc-&gt;is_clean()) ssc-&gt;set(static_call_info);
1295       }
1296     }
1297   } // unlock CompiledICLocker
1298   return true;
1299 }
1300 
1301 // Resolves a call.  The compilers generate code for calls that go here
1302 // and are patched with the real destination of the call.
1303 methodHandle SharedRuntime::resolve_sub_helper(JavaThread *thread,
1304                                                bool is_virtual,
<span class="line-modified">1305                                                bool is_optimized, TRAPS) {</span>

1306 
1307   ResourceMark rm(thread);
1308   RegisterMap cbl_map(thread, false);
1309   frame caller_frame = thread-&gt;last_frame().sender(&amp;cbl_map);
1310 
1311   CodeBlob* caller_cb = caller_frame.cb();
1312   guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
1313   CompiledMethod* caller_nm = caller_cb-&gt;as_compiled_method_or_null();

1314 
1315   // make sure caller is not getting deoptimized
1316   // and removed before we are done with it.
1317   // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1318   nmethodLocker caller_lock(caller_nm);
1319 
1320   // determine call info &amp; receiver
1321   // note: a) receiver is NULL for static calls
1322   //       b) an exception is thrown if receiver is NULL for non-static calls
1323   CallInfo call_info;
1324   Bytecodes::Code invoke_code = Bytecodes::_illegal;
1325   Handle receiver = find_callee_info(thread, invoke_code,
1326                                      call_info, CHECK_(methodHandle()));
1327   methodHandle callee_method(THREAD, call_info.selected_method());
1328 
1329   assert((!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokestatic ) ||
1330          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokespecial) ||
1331          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokehandle ) ||
1332          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokedynamic) ||
1333          ( is_virtual &amp;&amp; invoke_code != Bytecodes::_invokestatic ), &quot;inconsistent bytecode&quot;);
</pre>
<hr />
<pre>
1395       return callee_method;
1396     } else {
1397       InlineCacheBuffer::refill_ic_stubs();
1398     }
1399   }
1400 
1401 }
1402 
1403 
1404 // Inline caches exist only in compiled code
1405 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_ic_miss(JavaThread* thread))
1406 #ifdef ASSERT
1407   RegisterMap reg_map(thread, false);
1408   frame stub_frame = thread-&gt;last_frame();
1409   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1410   frame caller_frame = stub_frame.sender(&amp;reg_map);
1411   assert(!caller_frame.is_interpreted_frame() &amp;&amp; !caller_frame.is_entry_frame(), &quot;unexpected frame&quot;);
1412 #endif /* ASSERT */
1413 
1414   methodHandle callee_method;


1415   JRT_BLOCK
<span class="line-modified">1416     callee_method = SharedRuntime::handle_ic_miss_helper(thread, CHECK_NULL);</span>
1417     // Return Method* through TLS
1418     thread-&gt;set_vm_result_2(callee_method());
1419   JRT_BLOCK_END
1420   // return compiled code entry point after potential safepoints
<span class="line-modified">1421   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-removed">1422   return callee_method-&gt;verified_code_entry();</span>
1423 JRT_END
1424 
1425 
1426 // Handle call site that has been made non-entrant
1427 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* thread))
1428   // 6243940 We might end up in here if the callee is deoptimized
1429   // as we race to call it.  We don&#39;t want to take a safepoint if
1430   // the caller was interpreted because the caller frame will look
1431   // interpreted to the stack walkers and arguments are now
1432   // &quot;compiled&quot; so it is much better to make this transition
1433   // invisible to the stack walking code. The i2c path will
1434   // place the callee method in the callee_target. It is stashed
1435   // there because if we try and find the callee by normal means a
1436   // safepoint is possible and have trouble gc&#39;ing the compiled args.
1437   RegisterMap reg_map(thread, false);
1438   frame stub_frame = thread-&gt;last_frame();
1439   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1440   frame caller_frame = stub_frame.sender(&amp;reg_map);
1441 
1442   if (caller_frame.is_interpreted_frame() ||
</pre>
<hr />
<pre>
1445     guarantee(callee != NULL &amp;&amp; callee-&gt;is_method(), &quot;bad handshake&quot;);
1446     thread-&gt;set_vm_result_2(callee);
1447     thread-&gt;set_callee_target(NULL);
1448     if (caller_frame.is_entry_frame() &amp;&amp; VM_Version::supports_fast_class_init_checks()) {
1449       // Bypass class initialization checks in c2i when caller is in native.
1450       // JNI calls to static methods don&#39;t have class initialization checks.
1451       // Fast class initialization checks are present in c2i adapters and call into
1452       // SharedRuntime::handle_wrong_method() on the slow path.
1453       //
1454       // JVM upcalls may land here as well, but there&#39;s a proper check present in
1455       // LinkResolver::resolve_static_call (called from JavaCalls::call_static),
1456       // so bypassing it in c2i adapter is benign.
1457       return callee-&gt;get_c2i_no_clinit_check_entry();
1458     } else {
1459       return callee-&gt;get_c2i_entry();
1460     }
1461   }
1462 
1463   // Must be compiled to compiled path which is safe to stackwalk
1464   methodHandle callee_method;



1465   JRT_BLOCK
1466     // Force resolving of caller (if we called from compiled frame)
<span class="line-modified">1467     callee_method = SharedRuntime::reresolve_call_site(thread, CHECK_NULL);</span>
1468     thread-&gt;set_vm_result_2(callee_method());
1469   JRT_BLOCK_END
1470   // return compiled code entry point after potential safepoints
<span class="line-modified">1471   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-removed">1472   return callee_method-&gt;verified_code_entry();</span>
1473 JRT_END
1474 
1475 // Handle abstract method call
1476 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* thread))
1477   // Verbose error message for AbstractMethodError.
1478   // Get the called method from the invoke bytecode.
1479   vframeStream vfst(thread, true);
1480   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1481   methodHandle caller(thread, vfst.method());
1482   Bytecode_invoke invoke(caller, vfst.bci());
1483   DEBUG_ONLY( invoke.verify(); )
1484 
1485   // Find the compiled caller frame.
1486   RegisterMap reg_map(thread);
1487   frame stubFrame = thread-&gt;last_frame();
1488   assert(stubFrame.is_runtime_frame(), &quot;must be&quot;);
1489   frame callerFrame = stubFrame.sender(&amp;reg_map);
1490   assert(callerFrame.is_compiled_frame(), &quot;must be&quot;);
1491 
1492   // Install exception and return forward entry.
1493   address res = StubRoutines::throw_AbstractMethodError_entry();
1494   JRT_BLOCK
1495     methodHandle callee(thread, invoke.static_target(thread));
1496     if (!callee.is_null()) {
1497       oop recv = callerFrame.retrieve_receiver(&amp;reg_map);
1498       Klass *recv_klass = (recv != NULL) ? recv-&gt;klass() : NULL;
1499       LinkResolver::throw_abstract_method_error(callee, recv_klass, thread);
1500       res = StubRoutines::forward_exception_entry();
1501     }
1502   JRT_BLOCK_END
1503   return res;
1504 JRT_END
1505 
1506 
1507 // resolve a static call and patch code
1508 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread *thread ))
1509   methodHandle callee_method;

1510   JRT_BLOCK
<span class="line-modified">1511     callee_method = SharedRuntime::resolve_helper(thread, false, false, CHECK_NULL);</span>
1512     thread-&gt;set_vm_result_2(callee_method());
1513   JRT_BLOCK_END
1514   // return compiled code entry point after potential safepoints
<span class="line-modified">1515   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-modified">1516   return callee_method-&gt;verified_code_entry();</span>


1517 JRT_END
1518 
1519 
1520 // resolve virtual call and update inline cache to monomorphic
1521 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread *thread ))
1522   methodHandle callee_method;

1523   JRT_BLOCK
<span class="line-modified">1524     callee_method = SharedRuntime::resolve_helper(thread, true, false, CHECK_NULL);</span>
1525     thread-&gt;set_vm_result_2(callee_method());
1526   JRT_BLOCK_END
1527   // return compiled code entry point after potential safepoints
<span class="line-modified">1528   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-modified">1529   return callee_method-&gt;verified_code_entry();</span>


1530 JRT_END
1531 
1532 
1533 // Resolve a virtual call that can be statically bound (e.g., always
1534 // monomorphic, so it has no inline cache).  Patch code to resolved target.
1535 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread *thread))
1536   methodHandle callee_method;

1537   JRT_BLOCK
<span class="line-modified">1538     callee_method = SharedRuntime::resolve_helper(thread, true, true, CHECK_NULL);</span>
1539     thread-&gt;set_vm_result_2(callee_method());
1540   JRT_BLOCK_END
1541   // return compiled code entry point after potential safepoints
<span class="line-modified">1542   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-modified">1543   return callee_method-&gt;verified_code_entry();</span>


1544 JRT_END
1545 
1546 // The handle_ic_miss_helper_internal function returns false if it failed due
1547 // to either running out of vtable stubs or ic stubs due to IC transitions
1548 // to transitional states. The needs_ic_stub_refill value will be set if
1549 // the failure was due to running out of IC stubs, in which case handle_ic_miss_helper
1550 // refills the IC stubs and tries again.
1551 bool SharedRuntime::handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm,
1552                                                    const frame&amp; caller_frame, methodHandle callee_method,
1553                                                    Bytecodes::Code bc, CallInfo&amp; call_info,
<span class="line-modified">1554                                                    bool&amp; needs_ic_stub_refill, TRAPS) {</span>
1555   CompiledICLocker ml(caller_nm);
1556   CompiledIC* inline_cache = CompiledIC_before(caller_nm, caller_frame.pc());
1557   bool should_be_mono = false;
1558   if (inline_cache-&gt;is_optimized()) {
1559     if (TraceCallFixup) {
1560       ResourceMark rm(THREAD);
1561       tty-&gt;print(&quot;OPTIMIZED IC miss (%s) call to&quot;, Bytecodes::name(bc));
1562       callee_method-&gt;print_short_name(tty);
1563       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1564     }

1565     should_be_mono = true;
1566   } else if (inline_cache-&gt;is_icholder_call()) {
1567     CompiledICHolder* ic_oop = inline_cache-&gt;cached_icholder();
1568     if (ic_oop != NULL) {
1569       if (!ic_oop-&gt;is_loader_alive()) {
1570         // Deferred IC cleaning due to concurrent class unloading
1571         if (!inline_cache-&gt;set_to_clean()) {
1572           needs_ic_stub_refill = true;
1573           return false;
1574         }
1575       } else if (receiver()-&gt;klass() == ic_oop-&gt;holder_klass()) {
1576         // This isn&#39;t a real miss. We must have seen that compiled code
1577         // is now available and we want the call site converted to a
1578         // monomorphic compiled call site.
1579         // We can&#39;t assert for callee_method-&gt;code() != NULL because it
1580         // could have been deoptimized in the meantime
1581         if (TraceCallFixup) {
1582           ResourceMark rm(THREAD);
1583           tty-&gt;print(&quot;FALSE IC miss (%s) converting to compiled call to&quot;, Bytecodes::name(bc));
1584           callee_method-&gt;print_short_name(tty);
1585           tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1586         }
1587         should_be_mono = true;
1588       }
1589     }
1590   }
1591 
1592   if (should_be_mono) {
1593     // We have a path that was monomorphic but was going interpreted
1594     // and now we have (or had) a compiled entry. We correct the IC
1595     // by using a new icBuffer.
1596     CompiledICInfo info;
1597     Klass* receiver_klass = receiver()-&gt;klass();
1598     inline_cache-&gt;compute_monomorphic_entry(callee_method,
1599                                             receiver_klass,
1600                                             inline_cache-&gt;is_optimized(),
1601                                             false, caller_nm-&gt;is_nmethod(),

1602                                             info, CHECK_false);
1603     if (!inline_cache-&gt;set_to_monomorphic(info)) {
1604       needs_ic_stub_refill = true;
1605       return false;
1606     }
1607   } else if (!inline_cache-&gt;is_megamorphic() &amp;&amp; !inline_cache-&gt;is_clean()) {
1608     // Potential change to megamorphic
1609 
<span class="line-modified">1610     bool successful = inline_cache-&gt;set_to_megamorphic(&amp;call_info, bc, needs_ic_stub_refill, CHECK_false);</span>
1611     if (needs_ic_stub_refill) {
1612       return false;
1613     }
1614     if (!successful) {
1615       if (!inline_cache-&gt;set_to_clean()) {
1616         needs_ic_stub_refill = true;
1617         return false;
1618       }
1619     }
1620   } else {
1621     // Either clean or megamorphic
1622   }
1623   return true;
1624 }
1625 
<span class="line-modified">1626 methodHandle SharedRuntime::handle_ic_miss_helper(JavaThread *thread, TRAPS) {</span>
1627   ResourceMark rm(thread);
1628   CallInfo call_info;
1629   Bytecodes::Code bc;
1630 
1631   // receiver is NULL for static calls. An exception is thrown for NULL
1632   // receivers for non-static calls
1633   Handle receiver = find_callee_info(thread, bc, call_info,
1634                                      CHECK_(methodHandle()));
1635   // Compiler1 can produce virtual call sites that can actually be statically bound
1636   // If we fell thru to below we would think that the site was going megamorphic
1637   // when in fact the site can never miss. Worse because we&#39;d think it was megamorphic
1638   // we&#39;d try and do a vtable dispatch however methods that can be statically bound
1639   // don&#39;t have vtable entries (vtable_index &lt; 0) and we&#39;d blow up. So we force a
1640   // reresolution of the  call site (as if we did a handle_wrong_method and not an
1641   // plain ic_miss) and the site will be converted to an optimized virtual call site
1642   // never to miss again. I don&#39;t believe C2 will produce code like this but if it
1643   // did this would still be the correct thing to do for it too, hence no ifdef.
1644   //
1645   if (call_info.resolved_method()-&gt;can_be_statically_bound()) {
<span class="line-modified">1646     methodHandle callee_method = SharedRuntime::reresolve_call_site(thread, CHECK_(methodHandle()));</span>


1647     if (TraceCallFixup) {
1648       RegisterMap reg_map(thread, false);
1649       frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1650       ResourceMark rm(thread);
1651       tty-&gt;print(&quot;converting IC miss to reresolve (%s) call to&quot;, Bytecodes::name(bc));
1652       callee_method-&gt;print_short_name(tty);
1653       tty-&gt;print_cr(&quot; from pc: &quot; INTPTR_FORMAT, p2i(caller_frame.pc()));
1654       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1655     }
1656     return callee_method;
1657   }
1658 
1659   methodHandle callee_method(thread, call_info.selected_method());
1660 
1661 #ifndef PRODUCT
1662   Atomic::inc(&amp;_ic_miss_ctr);
1663 
1664   // Statistics &amp; Tracing
1665   if (TraceCallFixup) {
1666     ResourceMark rm(thread);
</pre>
<hr />
<pre>
1676     // produce statistics under the lock
1677     trace_ic_miss(f.pc());
1678   }
1679 #endif
1680 
1681   // install an event collector so that when a vtable stub is created the
1682   // profiler can be notified via a DYNAMIC_CODE_GENERATED event. The
1683   // event can&#39;t be posted when the stub is created as locks are held
1684   // - instead the event will be deferred until the event collector goes
1685   // out of scope.
1686   JvmtiDynamicCodeEventCollector event_collector;
1687 
1688   // Update inline cache to megamorphic. Skip update if we are called from interpreted.
1689   // Transitioning IC caches may require transition stubs. If we run out
1690   // of transition stubs, we have to drop locks and perform a safepoint
1691   // that refills them.
1692   RegisterMap reg_map(thread, false);
1693   frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1694   CodeBlob* cb = caller_frame.cb();
1695   CompiledMethod* caller_nm = cb-&gt;as_compiled_method();

1696 
1697   for (;;) {
1698     ICRefillVerifier ic_refill_verifier;
1699     bool needs_ic_stub_refill = false;
1700     bool successful = handle_ic_miss_helper_internal(receiver, caller_nm, caller_frame, callee_method,
<span class="line-modified">1701                                                      bc, call_info, needs_ic_stub_refill, CHECK_(methodHandle()));</span>
1702     if (successful || !needs_ic_stub_refill) {
1703       return callee_method;
1704     } else {
1705       InlineCacheBuffer::refill_ic_stubs();
1706     }
1707   }
1708 }
1709 
1710 static bool clear_ic_at_addr(CompiledMethod* caller_nm, address call_addr, bool is_static_call) {
1711   CompiledICLocker ml(caller_nm);
1712   if (is_static_call) {
1713     CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_at(call_addr);
1714     if (!ssc-&gt;is_clean()) {
1715       return ssc-&gt;set_to_clean();
1716     }
1717   } else {
1718     // compiled, dispatched call (which used to call an interpreted method)
1719     CompiledIC* inline_cache = CompiledIC_at(caller_nm, call_addr);
1720     if (!inline_cache-&gt;is_clean()) {
1721       return inline_cache-&gt;set_to_clean();
1722     }
1723   }
1724   return true;
1725 }
1726 
1727 //
1728 // Resets a call-site in compiled code so it will get resolved again.
1729 // This routines handles both virtual call sites, optimized virtual call
1730 // sites, and static call sites. Typically used to change a call sites
1731 // destination from compiled to interpreted.
1732 //
<span class="line-modified">1733 methodHandle SharedRuntime::reresolve_call_site(JavaThread *thread, TRAPS) {</span>
1734   ResourceMark rm(thread);
1735   RegisterMap reg_map(thread, false);
1736   frame stub_frame = thread-&gt;last_frame();
1737   assert(stub_frame.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1738   frame caller = stub_frame.sender(&amp;reg_map);
1739 
1740   // Do nothing if the frame isn&#39;t a live compiled frame.
1741   // nmethod could be deoptimized by the time we get here
1742   // so no update to the caller is needed.
1743 
1744   if (caller.is_compiled_frame() &amp;&amp; !caller.is_deoptimized_frame()) {
1745 
1746     address pc = caller.pc();
1747 
1748     // Check for static or virtual call
<span class="line-modified">1749     bool is_static_call = false;</span>
1750     CompiledMethod* caller_nm = CodeCache::find_compiled(pc);
1751 
1752     // Default call_addr is the location of the &quot;basic&quot; call.
1753     // Determine the address of the call we a reresolving. With
1754     // Inline Caches we will always find a recognizable call.
1755     // With Inline Caches disabled we may or may not find a
1756     // recognizable call. We will always find a call for static
1757     // calls and for optimized virtual calls. For vanilla virtual
1758     // calls it depends on the state of the UseInlineCaches switch.
1759     //
1760     // With Inline Caches disabled we can get here for a virtual call
1761     // for two reasons:
1762     //   1 - calling an abstract method. The vtable for abstract methods
1763     //       will run us thru handle_wrong_method and we will eventually
1764     //       end up in the interpreter to throw the ame.
1765     //   2 - a racing deoptimization. We could be doing a vanilla vtable
1766     //       call and between the time we fetch the entry address and
1767     //       we jump to it the target gets deoptimized. Similar to 1
1768     //       we will wind up in the interprter (thru a c2i with c2).
1769     //
</pre>
<hr />
<pre>
1774       CompiledICLocker ml(caller_nm);
1775       // Location of call instruction
1776       call_addr = caller_nm-&gt;call_instruction_address(pc);
1777     }
1778     // Make sure nmethod doesn&#39;t get deoptimized and removed until
1779     // this is done with it.
1780     // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1781     nmethodLocker nmlock(caller_nm);
1782 
1783     if (call_addr != NULL) {
1784       RelocIterator iter(caller_nm, call_addr, call_addr+1);
1785       int ret = iter.next(); // Get item
1786       if (ret) {
1787         assert(iter.addr() == call_addr, &quot;must find call&quot;);
1788         if (iter.type() == relocInfo::static_call_type) {
1789           is_static_call = true;
1790         } else {
1791           assert(iter.type() == relocInfo::virtual_call_type ||
1792                  iter.type() == relocInfo::opt_virtual_call_type
1793                 , &quot;unexpected relocInfo. type&quot;);

1794         }
1795       } else {
1796         assert(!UseInlineCaches, &quot;relocation info. must exist for this address&quot;);
1797       }
1798 
1799       // Cleaning the inline cache will force a new resolve. This is more robust
1800       // than directly setting it to the new destination, since resolving of calls
1801       // is always done through the same code path. (experience shows that it
1802       // leads to very hard to track down bugs, if an inline cache gets updated
1803       // to a wrong method). It should not be performance critical, since the
1804       // resolve is only done once.
1805 
1806       for (;;) {
1807         ICRefillVerifier ic_refill_verifier;
1808         if (!clear_ic_at_addr(caller_nm, call_addr, is_static_call)) {
1809           InlineCacheBuffer::refill_ic_stubs();
1810         } else {
1811           break;
1812         }
1813       }
1814     }
1815   }
1816 
1817   methodHandle callee_method = find_callee_method(thread, CHECK_(methodHandle()));
1818 
<span class="line-removed">1819 </span>
1820 #ifndef PRODUCT
1821   Atomic::inc(&amp;_wrong_method_ctr);
1822 
1823   if (TraceCallFixup) {
1824     ResourceMark rm(thread);
1825     tty-&gt;print(&quot;handle_wrong_method reresolving call to&quot;);
1826     callee_method-&gt;print_short_name(tty);
1827     tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1828   }
1829 #endif
1830 
1831   return callee_method;
1832 }
1833 
1834 address SharedRuntime::handle_unsafe_access(JavaThread* thread, address next_pc) {
1835   // The faulting unsafe accesses should be changed to throw the error
1836   // synchronously instead. Meanwhile the faulting instruction will be
1837   // skipped over (effectively turning it into a no-op) and an
1838   // asynchronous exception will be raised which the thread will
1839   // handle at a later point. If the instruction is a load it will
</pre>
<hr />
<pre>
1894     }
1895   } else {
1896     if (TraceCallFixup) {
1897       tty-&gt;print(&quot;already patched callsite at &quot; INTPTR_FORMAT &quot; to compiled code for&quot;, p2i(caller_pc));
1898       moop-&gt;print_short_name(tty);
1899       tty-&gt;print_cr(&quot; to &quot; INTPTR_FORMAT, p2i(entry_point));
1900     }
1901   }
1902   return false;
1903 }
1904 
1905 // ---------------------------------------------------------------------------
1906 // We are calling the interpreter via a c2i. Normally this would mean that
1907 // we were called by a compiled method. However we could have lost a race
1908 // where we went int -&gt; i2c -&gt; c2i and so the caller could in fact be
1909 // interpreted. If the caller is compiled we attempt to patch the caller
1910 // so he no longer calls into the interpreter.
1911 JRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))
1912   Method* moop(method);
1913 
<span class="line-removed">1914   address entry_point = moop-&gt;from_compiled_entry_no_trampoline();</span>
<span class="line-removed">1915 </span>
1916   // It&#39;s possible that deoptimization can occur at a call site which hasn&#39;t
1917   // been resolved yet, in which case this function will be called from
1918   // an nmethod that has been patched for deopt and we can ignore the
1919   // request for a fixup.
1920   // Also it is possible that we lost a race in that from_compiled_entry
1921   // is now back to the i2c in that case we don&#39;t need to patch and if
1922   // we did we&#39;d leap into space because the callsite needs to use
1923   // &quot;to interpreter&quot; stub in order to load up the Method*. Don&#39;t
1924   // ask me how I know this...
1925 
1926   CodeBlob* cb = CodeCache::find_blob(caller_pc);
<span class="line-modified">1927   if (cb == NULL || !cb-&gt;is_compiled() || entry_point == moop-&gt;get_c2i_entry()) {</span>




1928     return;
1929   }
1930 
1931   // The check above makes sure this is a nmethod.
1932   CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
1933   assert(nm, &quot;must be&quot;);
1934 
1935   // Get the return PC for the passed caller PC.
1936   address return_pc = caller_pc + frame::pc_return_offset;
1937 
1938   // There is a benign race here. We could be attempting to patch to a compiled
1939   // entry point at the same time the callee is being deoptimized. If that is
1940   // the case then entry_point may in fact point to a c2i and we&#39;d patch the
1941   // call site with the same old data. clear_code will set code() to NULL
1942   // at the end of it. If we happen to see that NULL then we can skip trying
1943   // to patch. If we hit the window where the callee has a c2i in the
1944   // from_compiled_entry and the NULL isn&#39;t present yet then we lose the race
1945   // and patch the code with the same old data. Asi es la vida.
1946 
1947   if (moop-&gt;code() == NULL) return;
</pre>
<hr />
<pre>
2268  private:
2269   enum {
2270     _basic_type_bits = 4,
2271     _basic_type_mask = right_n_bits(_basic_type_bits),
2272     _basic_types_per_int = BitsPerInt / _basic_type_bits,
2273     _compact_int_count = 3
2274   };
2275   // TO DO:  Consider integrating this with a more global scheme for compressing signatures.
2276   // For now, 4 bits per components (plus T_VOID gaps after double/long) is not excessive.
2277 
2278   union {
2279     int  _compact[_compact_int_count];
2280     int* _fingerprint;
2281   } _value;
2282   int _length; // A negative length indicates the fingerprint is in the compact form,
2283                // Otherwise _value._fingerprint is the array.
2284 
2285   // Remap BasicTypes that are handled equivalently by the adapters.
2286   // These are correct for the current system but someday it might be
2287   // necessary to make this mapping platform dependent.
<span class="line-modified">2288   static int adapter_encoding(BasicType in) {</span>
2289     switch (in) {
2290       case T_BOOLEAN:
2291       case T_BYTE:
2292       case T_SHORT:
<span class="line-modified">2293       case T_CHAR:</span>
<span class="line-modified">2294         // There are all promoted to T_INT in the calling convention</span>
<span class="line-modified">2295         return T_INT;</span>













2296 
2297       case T_OBJECT:
2298       case T_ARRAY:
2299         // In other words, we assume that any register good enough for
2300         // an int or long is good enough for a managed pointer.
2301 #ifdef _LP64
2302         return T_LONG;
2303 #else
2304         return T_INT;
2305 #endif
2306 
2307       case T_INT:
2308       case T_LONG:
2309       case T_FLOAT:
2310       case T_DOUBLE:
2311       case T_VOID:
2312         return in;
2313 
2314       default:
2315         ShouldNotReachHere();
2316         return T_CONFLICT;
2317     }
2318   }
2319 
2320  public:
<span class="line-modified">2321   AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {</span>
2322     // The fingerprint is based on the BasicType signature encoded
2323     // into an array of ints with eight entries per int.

2324     int* ptr;
2325     int len = (total_args_passed + (_basic_types_per_int-1)) / _basic_types_per_int;
2326     if (len &lt;= _compact_int_count) {
2327       assert(_compact_int_count == 3, &quot;else change next line&quot;);
2328       _value._compact[0] = _value._compact[1] = _value._compact[2] = 0;
2329       // Storing the signature encoded as signed chars hits about 98%
2330       // of the time.
2331       _length = -len;
2332       ptr = _value._compact;
2333     } else {
2334       _length = len;
2335       _value._fingerprint = NEW_C_HEAP_ARRAY(int, _length, mtCode);
2336       ptr = _value._fingerprint;
2337     }
2338 
2339     // Now pack the BasicTypes with 8 per int
2340     int sig_index = 0;


2341     for (int index = 0; index &lt; len; index++) {
2342       int value = 0;
2343       for (int byte = 0; byte &lt; _basic_types_per_int; byte++) {
<span class="line-modified">2344         int bt = ((sig_index &lt; total_args_passed)</span>
<span class="line-modified">2345                   ? adapter_encoding(sig_bt[sig_index++])</span>
<span class="line-modified">2346                   : 0);</span>

















2347         assert((bt &amp; _basic_type_mask) == bt, &quot;must fit in 4 bits&quot;);
2348         value = (value &lt;&lt; _basic_type_bits) | bt;
2349       }
2350       ptr[index] = value;
2351     }

2352   }
2353 
2354   ~AdapterFingerPrint() {
2355     if (_length &gt; 0) {
2356       FREE_C_HEAP_ARRAY(int, _value._fingerprint);
2357     }
2358   }
2359 
2360   int value(int index) {
2361     if (_length &lt; 0) {
2362       return _value._compact[index];
2363     }
2364     return _value._fingerprint[index];
2365   }
2366   int length() {
2367     if (_length &lt; 0) return -_length;
2368     return _length;
2369   }
2370 
2371   bool is_compact() {
</pre>
<hr />
<pre>
2417 
2418  private:
2419 
2420 #ifndef PRODUCT
2421   static int _lookups; // number of calls to lookup
2422   static int _buckets; // number of buckets checked
2423   static int _equals;  // number of buckets checked with matching hash
2424   static int _hits;    // number of successful lookups
2425   static int _compact; // number of equals calls with compact signature
2426 #endif
2427 
2428   AdapterHandlerEntry* bucket(int i) {
2429     return (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::bucket(i);
2430   }
2431 
2432  public:
2433   AdapterHandlerTable()
2434     : BasicHashtable&lt;mtCode&gt;(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }
2435 
2436   // Create a new entry suitable for insertion in the table
<span class="line-modified">2437   AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {</span>


2438     AdapterHandlerEntry* entry = (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::new_entry(fingerprint-&gt;compute_hash());
<span class="line-modified">2439     entry-&gt;init(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>

2440     if (DumpSharedSpaces) {
2441       ((CDSAdapterHandlerEntry*)entry)-&gt;init();
2442     }
2443     return entry;
2444   }
2445 
2446   // Insert an entry into the table
2447   void add(AdapterHandlerEntry* entry) {
2448     int index = hash_to_index(entry-&gt;hash());
2449     add_entry(index, entry);
2450   }
2451 
2452   void free_entry(AdapterHandlerEntry* entry) {
2453     entry-&gt;deallocate();
2454     BasicHashtable&lt;mtCode&gt;::free_entry(entry);
2455   }
2456 
2457   // Find a entry with the same fingerprint if it exists
<span class="line-modified">2458   AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt) {</span>
2459     NOT_PRODUCT(_lookups++);
<span class="line-modified">2460     AdapterFingerPrint fp(total_args_passed, sig_bt);</span>
2461     unsigned int hash = fp.compute_hash();
2462     int index = hash_to_index(hash);
2463     for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
2464       NOT_PRODUCT(_buckets++);
2465       if (e-&gt;hash() == hash) {
2466         NOT_PRODUCT(_equals++);
2467         if (fp.equals(e-&gt;fingerprint())) {
2468 #ifndef PRODUCT
2469           if (fp.is_compact()) _compact++;
2470           _hits++;
2471 #endif
2472           return e;
2473         }
2474       }
2475     }
2476     return NULL;
2477   }
2478 
2479 #ifndef PRODUCT
2480   void print_statistics() {
</pre>
<hr />
<pre>
2536   bool has_next() {
2537     return _current != NULL;
2538   }
2539   AdapterHandlerEntry* next() {
2540     if (_current != NULL) {
2541       AdapterHandlerEntry* result = _current;
2542       _current = _current-&gt;next();
2543       if (_current == NULL) scan();
2544       return result;
2545     } else {
2546       return NULL;
2547     }
2548   }
2549 };
2550 
2551 
2552 // ---------------------------------------------------------------------------
2553 // Implementation of AdapterHandlerLibrary
2554 AdapterHandlerTable* AdapterHandlerLibrary::_adapters = NULL;
2555 AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = NULL;
<span class="line-modified">2556 const int AdapterHandlerLibrary_size = 16*K;</span>
2557 BufferBlob* AdapterHandlerLibrary::_buffer = NULL;
2558 
2559 BufferBlob* AdapterHandlerLibrary::buffer_blob() {
2560   // Should be called only when AdapterHandlerLibrary_lock is active.
2561   if (_buffer == NULL) // Initialize lazily
2562       _buffer = BufferBlob::create(&quot;adapters&quot;, AdapterHandlerLibrary_size);
2563   return _buffer;
2564 }
2565 
2566 extern &quot;C&quot; void unexpected_adapter_call() {
2567   ShouldNotCallThis();
2568 }
2569 
2570 void AdapterHandlerLibrary::initialize() {
2571   if (_adapters != NULL) return;
2572   _adapters = new AdapterHandlerTable();
2573 
2574   // Create a special handler for abstract methods.  Abstract methods
2575   // are never compiled so an i2c entry is somewhat meaningless, but
2576   // throw AbstractMethodError just in case.
2577   // Pass wrong_method_abstract for the c2i transitions to return
2578   // AbstractMethodError for invalid invocations.
2579   address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();
<span class="line-modified">2580   _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, NULL),</span>
2581                                                               StubRoutines::throw_AbstractMethodError_entry(),

2582                                                               wrong_method_abstract, wrong_method_abstract);
2583 }
2584 
2585 AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint,
2586                                                       address i2c_entry,
2587                                                       address c2i_entry,


2588                                                       address c2i_unverified_entry,

2589                                                       address c2i_no_clinit_check_entry) {
<span class="line-modified">2590   return _adapters-&gt;new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>















2591 }
2592 
2593 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(const methodHandle&amp; method) {
2594   AdapterHandlerEntry* entry = get_adapter0(method);
2595   if (entry != NULL &amp;&amp; method-&gt;is_shared()) {
2596     // See comments around Method::link_method()
2597     MutexLocker mu(AdapterHandlerLibrary_lock);
2598     if (method-&gt;adapter() == NULL) {
2599       method-&gt;update_adapter_trampoline(entry);
2600     }
<span class="line-modified">2601     address trampoline = method-&gt;from_compiled_entry();</span>
<span class="line-modified">2602     if (*(int*)trampoline == 0) {</span>
<span class="line-modified">2603       CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());</span>
<span class="line-modified">2604       MacroAssembler _masm(&amp;buffer);</span>
<span class="line-modified">2605       SharedRuntime::generate_trampoline(&amp;_masm, entry-&gt;get_c2i_entry());</span>
<span class="line-modified">2606       assert(*(int*)trampoline != 0, &quot;Instruction(s) for trampoline must not be encoded as zeros.&quot;);</span>
<span class="line-modified">2607       _masm.flush();</span>

2608 
<span class="line-modified">2609       if (PrintInterpreter) {</span>
<span class="line-modified">2610         Disassembler::decode(buffer.insts_begin(), buffer.insts_end());</span>


























2611       }


2612     }
2613   }



2614 
<span class="line-modified">2615   return entry;</span>



























































































































































2616 }
2617 
2618 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter0(const methodHandle&amp; method) {
2619   // Use customized signature handler.  Need to lock around updates to
2620   // the AdapterHandlerTable (it is not safe for concurrent readers
2621   // and a single writer: this could be fixed if it becomes a
2622   // problem).
2623 
2624   ResourceMark rm;
2625 
<span class="line-modified">2626   NOT_PRODUCT(int insts_size);</span>
2627   AdapterBlob* new_adapter = NULL;
2628   AdapterHandlerEntry* entry = NULL;
2629   AdapterFingerPrint* fingerprint = NULL;

2630   {
2631     MutexLocker mu(AdapterHandlerLibrary_lock);
2632     // make sure data structure is initialized
2633     initialize();
2634 
<span class="line-modified">2635     if (method-&gt;is_abstract()) {</span>
<span class="line-modified">2636       return _abstract_method_handler;</span>


2637     }






2638 
<span class="line-modified">2639     // Fill in the signature array, for the calling-convention call.</span>
<span class="line-modified">2640     int total_args_passed = method-&gt;size_of_parameters(); // All args on stack</span>



2641 
<span class="line-modified">2642     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);</span>
<span class="line-modified">2643     VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);</span>
<span class="line-modified">2644     int i = 0;</span>
<span class="line-modified">2645     if (!method-&gt;is_static())  // Pass in receiver first</span>
<span class="line-modified">2646       sig_bt[i++] = T_OBJECT;</span>
<span class="line-modified">2647     for (SignatureStream ss(method-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-modified">2648       sig_bt[i++] = ss.type();  // Collect remaining bits of signature</span>
<span class="line-modified">2649       if (ss.type() == T_LONG || ss.type() == T_DOUBLE)</span>
<span class="line-modified">2650         sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots</span>






2651     }
<span class="line-removed">2652     assert(i == total_args_passed, &quot;&quot;);</span>
2653 
2654     // Lookup method signature&#39;s fingerprint
<span class="line-modified">2655     entry = _adapters-&gt;lookup(total_args_passed, sig_bt);</span>
2656 
2657 #ifdef ASSERT
2658     AdapterHandlerEntry* shared_entry = NULL;
2659     // Start adapter sharing verification only after the VM is booted.
2660     if (VerifyAdapterSharing &amp;&amp; (entry != NULL)) {
2661       shared_entry = entry;
2662       entry = NULL;
2663     }
2664 #endif
2665 
2666     if (entry != NULL) {
2667       return entry;
2668     }
2669 
<span class="line-modified">2670     // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage</span>
<span class="line-removed">2671     int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, false);</span>
<span class="line-removed">2672 </span>
<span class="line-removed">2673     // Make a C heap allocated version of the fingerprint to store in the adapter</span>
2674     fingerprint = new AdapterFingerPrint(total_args_passed, sig_bt);
2675 
2676     // StubRoutines::code2() is initialized after this function can be called. As a result,
2677     // VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated
2678     // prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C
2679     // stub that ensure that an I2C stub is called from an interpreter frame.
2680     bool contains_all_checks = StubRoutines::code2() != NULL;
2681 
2682     // Create I2C &amp; C2I handlers
2683     BufferBlob* buf = buffer_blob(); // the temporary code buffer in CodeCache
2684     if (buf != NULL) {
2685       CodeBuffer buffer(buf);
2686       short buffer_locs[20];
2687       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
2688                                              sizeof(buffer_locs)/sizeof(relocInfo));
2689 
2690       MacroAssembler _masm(&amp;buffer);
2691       entry = SharedRuntime::generate_i2c2i_adapters(&amp;_masm,
<span class="line-modified">2692                                                      total_args_passed,</span>
<span class="line-modified">2693                                                      comp_args_on_stack,</span>
<span class="line-removed">2694                                                      sig_bt,</span>
2695                                                      regs,
<span class="line-modified">2696                                                      fingerprint);</span>













2697 #ifdef ASSERT
2698       if (VerifyAdapterSharing) {
2699         if (shared_entry != NULL) {



2700           assert(shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size()), &quot;code must match&quot;);
2701           // Release the one just created and return the original
2702           _adapters-&gt;free_entry(entry);
2703           return shared_entry;
2704         } else  {
2705           entry-&gt;save_code(buf-&gt;code_begin(), buffer.insts_size());
2706         }
2707       }
2708 #endif
2709 
<span class="line-removed">2710       new_adapter = AdapterBlob::create(&amp;buffer);</span>
2711       NOT_PRODUCT(insts_size = buffer.insts_size());
2712     }
2713     if (new_adapter == NULL) {
2714       // CodeCache is full, disable compilation
2715       // Ought to log this but compile log is only per compile thread
2716       // and we&#39;re some non descript Java thread.
2717       return NULL; // Out of CodeCache space
2718     }
2719     entry-&gt;relocate(new_adapter-&gt;content_begin());
2720 #ifndef PRODUCT
2721     // debugging suppport
2722     if (PrintAdapterHandlers || PrintStubCode) {
2723       ttyLocker ttyl;
2724       entry-&gt;print_adapter_on(tty);
2725       tty-&gt;print_cr(&quot;i2c argument handler #%d for: %s %s %s (%d bytes generated)&quot;,
2726                     _adapters-&gt;number_of_entries(), (method-&gt;is_static() ? &quot;static&quot; : &quot;receiver&quot;),
2727                     method-&gt;signature()-&gt;as_C_string(), fingerprint-&gt;as_string(), insts_size);
2728       tty-&gt;print_cr(&quot;c2i argument handler starts at %p&quot;, entry-&gt;get_c2i_entry());
2729       if (Verbose || PrintStubCode) {
2730         address first_pc = entry-&gt;base_address();
</pre>
<hr />
<pre>
2746     char blob_id[256];
2747     jio_snprintf(blob_id,
2748                  sizeof(blob_id),
2749                  &quot;%s(%s)@&quot; PTR_FORMAT,
2750                  new_adapter-&gt;name(),
2751                  fingerprint-&gt;as_string(),
2752                  new_adapter-&gt;content_begin());
2753     Forte::register_stub(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
2754 
2755     if (JvmtiExport::should_post_dynamic_code_generated()) {
2756       JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
2757     }
2758   }
2759   return entry;
2760 }
2761 
2762 address AdapterHandlerEntry::base_address() {
2763   address base = _i2c_entry;
2764   if (base == NULL)  base = _c2i_entry;
2765   assert(base &lt;= _c2i_entry || _c2i_entry == NULL, &quot;&quot;);


2766   assert(base &lt;= _c2i_unverified_entry || _c2i_unverified_entry == NULL, &quot;&quot;);

2767   assert(base &lt;= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == NULL, &quot;&quot;);
2768   return base;
2769 }
2770 
2771 void AdapterHandlerEntry::relocate(address new_base) {
2772   address old_base = base_address();
2773   assert(old_base != NULL, &quot;&quot;);
2774   ptrdiff_t delta = new_base - old_base;
2775   if (_i2c_entry != NULL)
2776     _i2c_entry += delta;
2777   if (_c2i_entry != NULL)
2778     _c2i_entry += delta;




2779   if (_c2i_unverified_entry != NULL)
2780     _c2i_unverified_entry += delta;


2781   if (_c2i_no_clinit_check_entry != NULL)
2782     _c2i_no_clinit_check_entry += delta;
2783   assert(base_address() == new_base, &quot;&quot;);
2784 }
2785 
2786 
2787 void AdapterHandlerEntry::deallocate() {
2788   delete _fingerprint;



2789 #ifdef ASSERT
2790   FREE_C_HEAP_ARRAY(unsigned char, _saved_code);
2791 #endif
2792 }
2793 
2794 
2795 #ifdef ASSERT
2796 // Capture the code before relocation so that it can be compared
2797 // against other versions.  If the code is captured after relocation
2798 // then relative instructions won&#39;t be equivalent.
2799 void AdapterHandlerEntry::save_code(unsigned char* buffer, int length) {
2800   _saved_code = NEW_C_HEAP_ARRAY(unsigned char, length, mtCode);
2801   _saved_code_length = length;
2802   memcpy(_saved_code, buffer, length);
2803 }
2804 
2805 
2806 bool AdapterHandlerEntry::compare_code(unsigned char* buffer, int length) {
2807   if (length != _saved_code_length) {
2808     return false;
</pre>
<hr />
<pre>
2846 
2847 
2848     ResourceMark rm;
2849     BufferBlob*  buf = buffer_blob(); // the temporary code buffer in CodeCache
2850     if (buf != NULL) {
2851       CodeBuffer buffer(buf);
2852       double locs_buf[20];
2853       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)locs_buf, sizeof(locs_buf) / sizeof(relocInfo));
2854       MacroAssembler _masm(&amp;buffer);
2855 
2856       // Fill in the signature array, for the calling-convention call.
2857       const int total_args_passed = method-&gt;size_of_parameters();
2858 
2859       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);
2860       VMRegPair*   regs = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);
2861       int i=0;
2862       if (!method-&gt;is_static())  // Pass in receiver first
2863         sig_bt[i++] = T_OBJECT;
2864       SignatureStream ss(method-&gt;signature());
2865       for (; !ss.at_return_type(); ss.next()) {
<span class="line-modified">2866         sig_bt[i++] = ss.type();  // Collect remaining bits of signature</span>

2867         if (ss.type() == T_LONG || ss.type() == T_DOUBLE)
2868           sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots
2869       }
2870       assert(i == total_args_passed, &quot;&quot;);
2871       BasicType ret_type = ss.type();
2872 
2873       // Now get the compiled-Java layout as input (or output) arguments.
2874       // NOTE: Stubs for compiled entry points of method handle intrinsics
2875       // are just trampolines so the argument registers must be outgoing ones.
2876       const bool is_outgoing = method-&gt;is_method_handle_intrinsic();
2877       int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, is_outgoing);
2878 
2879       // Generate the compiled-to-native wrapper code
2880       nm = SharedRuntime::generate_native_wrapper(&amp;_masm, method, compile_id, sig_bt, regs, ret_type, critical_entry);
2881 
2882       if (nm != NULL) {
2883         {
2884           MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
2885           if (nm-&gt;make_in_use()) {
2886             method-&gt;set_code(method, nm);
</pre>
<hr />
<pre>
3094   AdapterHandlerTableIterator iter(_adapters);
3095   while (iter.has_next()) {
3096     AdapterHandlerEntry* a = iter.next();
3097     if (b == CodeCache::find_blob(a-&gt;get_i2c_entry())) {
3098       st-&gt;print(&quot;Adapter for signature: &quot;);
3099       a-&gt;print_adapter_on(tty);
3100       return;
3101     }
3102   }
3103   assert(false, &quot;Should have found handler&quot;);
3104 }
3105 
3106 void AdapterHandlerEntry::print_adapter_on(outputStream* st) const {
3107   st-&gt;print(&quot;AHE@&quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(this), fingerprint()-&gt;as_string());
3108   if (get_i2c_entry() != NULL) {
3109     st-&gt;print(&quot; i2c: &quot; INTPTR_FORMAT, p2i(get_i2c_entry()));
3110   }
3111   if (get_c2i_entry() != NULL) {
3112     st-&gt;print(&quot; c2i: &quot; INTPTR_FORMAT, p2i(get_c2i_entry()));
3113   }






3114   if (get_c2i_unverified_entry() != NULL) {
<span class="line-modified">3115     st-&gt;print(&quot; c2iUV: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));</span>



3116   }
3117   if (get_c2i_no_clinit_check_entry() != NULL) {
3118     st-&gt;print(&quot; c2iNCI: &quot; INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));
3119   }
3120   st-&gt;cr();
3121 }
3122 
3123 #if INCLUDE_CDS
3124 
3125 void CDSAdapterHandlerEntry::init() {
3126   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
3127   _c2i_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());


3128   _adapter_trampoline = (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*));
3129 };
3130 
3131 #endif // INCLUDE_CDS
3132 
3133 
3134 #ifndef PRODUCT
3135 
3136 void AdapterHandlerLibrary::print_statistics() {
3137   _adapters-&gt;print_statistics();
3138 }
3139 
3140 #endif /* PRODUCT */
3141 
3142 JRT_LEAF(void, SharedRuntime::enable_stack_reserved_zone(JavaThread* thread))
3143   assert(thread-&gt;is_Java_thread(), &quot;Only Java threads have a stack reserved zone&quot;);
3144   if (thread-&gt;stack_reserved_zone_disabled()) {
3145   thread-&gt;enable_stack_reserved_zone();
3146   }
3147   thread-&gt;set_reserved_stack_activation(thread-&gt;stack_base());
</pre>
<hr />
<pre>
3193       break;
3194     } else {
3195       fr = fr.java_sender();
3196     }
3197   }
3198   return activation;
3199 }
3200 
3201 void SharedRuntime::on_slowpath_allocation_exit(JavaThread* thread) {
3202   // After any safepoint, just before going back to compiled code,
3203   // we inform the GC that we will be doing initializing writes to
3204   // this object in the future without emitting card-marks, so
3205   // GC may take any compensating steps.
3206 
3207   oop new_obj = thread-&gt;vm_result();
3208   if (new_obj == NULL) return;
3209 
3210   BarrierSet *bs = BarrierSet::barrier_set();
3211   bs-&gt;on_slowpath_allocation_exit(thread, new_obj);
3212 }














































































































































































































</pre>
</td>
<td>
<hr />
<pre>
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/stringTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/compiledIC.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/compiledMethod.inline.hpp&quot;
  35 #include &quot;code/scopeDesc.hpp&quot;
  36 #include &quot;code/vtableStubs.hpp&quot;
  37 #include &quot;compiler/abstractCompiler.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
  39 #include &quot;compiler/disassembler.hpp&quot;
  40 #include &quot;gc/shared/barrierSet.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  42 #include &quot;interpreter/interpreter.hpp&quot;
  43 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  44 #include &quot;jfr/jfrEvents.hpp&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;memory/metaspaceShared.hpp&quot;
<span class="line-added">  47 #include &quot;memory/oopFactory.hpp&quot;</span>
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
<span class="line-added">  50 #include &quot;oops/access.hpp&quot;</span>
<span class="line-added">  51 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  52 #include &quot;oops/klass.hpp&quot;
  53 #include &quot;oops/method.inline.hpp&quot;
  54 #include &quot;oops/objArrayKlass.hpp&quot;
<span class="line-added">  55 #include &quot;oops/objArrayOop.inline.hpp&quot;</span>
  56 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  57 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  58 #include &quot;prims/forte.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/methodHandles.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;runtime/arguments.hpp&quot;
  63 #include &quot;runtime/atomic.hpp&quot;
  64 #include &quot;runtime/biasedLocking.hpp&quot;
  65 #include &quot;runtime/frame.inline.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/init.hpp&quot;
  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  69 #include &quot;runtime/java.hpp&quot;
  70 #include &quot;runtime/javaCalls.hpp&quot;
  71 #include &quot;runtime/sharedRuntime.hpp&quot;
  72 #include &quot;runtime/stubRoutines.hpp&quot;
  73 #include &quot;runtime/vframe.inline.hpp&quot;
  74 #include &quot;runtime/vframeArray.hpp&quot;
  75 #include &quot;utilities/copy.hpp&quot;
  76 #include &quot;utilities/dtrace.hpp&quot;
  77 #include &quot;utilities/events.hpp&quot;
  78 #include &quot;utilities/hashtable.inline.hpp&quot;
  79 #include &quot;utilities/macros.hpp&quot;
  80 #include &quot;utilities/xmlstream.hpp&quot;
  81 #ifdef COMPILER1
  82 #include &quot;c1/c1_Runtime1.hpp&quot;
  83 #endif
  84 
  85 // Shared stub locations
  86 RuntimeStub*        SharedRuntime::_wrong_method_blob;
  87 RuntimeStub*        SharedRuntime::_wrong_method_abstract_blob;
  88 RuntimeStub*        SharedRuntime::_ic_miss_blob;
  89 RuntimeStub*        SharedRuntime::_resolve_opt_virtual_call_blob;
  90 RuntimeStub*        SharedRuntime::_resolve_virtual_call_blob;
  91 RuntimeStub*        SharedRuntime::_resolve_static_call_blob;

  92 
  93 DeoptimizationBlob* SharedRuntime::_deopt_blob;
  94 SafepointBlob*      SharedRuntime::_polling_page_vectors_safepoint_handler_blob;
  95 SafepointBlob*      SharedRuntime::_polling_page_safepoint_handler_blob;
  96 SafepointBlob*      SharedRuntime::_polling_page_return_handler_blob;
  97 
  98 #ifdef COMPILER2
  99 UncommonTrapBlob*   SharedRuntime::_uncommon_trap_blob;
 100 #endif // COMPILER2
 101 
 102 
 103 //----------------------------generate_stubs-----------------------------------
 104 void SharedRuntime::generate_stubs() {
 105   _wrong_method_blob                   = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method),          &quot;wrong_method_stub&quot;);
 106   _wrong_method_abstract_blob          = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract), &quot;wrong_method_abstract_stub&quot;);
 107   _ic_miss_blob                        = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss),  &quot;ic_miss_stub&quot;);
 108   _resolve_opt_virtual_call_blob       = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C),   &quot;resolve_opt_virtual_call&quot;);
 109   _resolve_virtual_call_blob           = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C),       &quot;resolve_virtual_call&quot;);
 110   _resolve_static_call_blob            = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C),        &quot;resolve_static_call&quot;);

 111 
 112 #if COMPILER2_OR_JVMCI
 113   // Vectors are generated only by C2 and JVMCI.
 114   bool support_wide = is_wide_vector(MaxVectorSize);
 115   if (support_wide) {
 116     _polling_page_vectors_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_VECTOR_LOOP);
 117   }
 118 #endif // COMPILER2_OR_JVMCI
 119   _polling_page_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_LOOP);
 120   _polling_page_return_handler_blob    = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_RETURN);
 121 
 122   generate_deopt_blob();
 123 
 124 #ifdef COMPILER2
 125   generate_uncommon_trap_blob();
 126 #endif // COMPILER2
 127 }
 128 
 129 #include &lt;math.h&gt;
 130 
</pre>
<hr />
<pre>
1037   }
1038   return NULL;
1039 }
1040 
1041 // Finds receiver, CallInfo (i.e. receiver method), and calling bytecode
1042 // for a call current in progress, i.e., arguments has been pushed on stack
1043 // but callee has not been invoked yet.  Caller frame must be compiled.
1044 Handle SharedRuntime::find_callee_info_helper(JavaThread* thread,
1045                                               vframeStream&amp; vfst,
1046                                               Bytecodes::Code&amp; bc,
1047                                               CallInfo&amp; callinfo, TRAPS) {
1048   Handle receiver;
1049   Handle nullHandle;  //create a handy null handle for exception returns
1050 
1051   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1052 
1053   // Find caller and bci from vframe
1054   methodHandle caller(THREAD, vfst.method());
1055   int          bci   = vfst.bci();
1056 
<span class="line-added">1057   // Substitutability test implementation piggy backs on static call resolution</span>
<span class="line-added">1058   Bytecodes::Code code = caller-&gt;java_code_at(bci);</span>
<span class="line-added">1059   if (code == Bytecodes::_if_acmpeq || code == Bytecodes::_if_acmpne) {</span>
<span class="line-added">1060     bc = Bytecodes::_invokestatic;</span>
<span class="line-added">1061     methodHandle attached_method(THREAD, extract_attached_method(vfst));</span>
<span class="line-added">1062     assert(attached_method.not_null(), &quot;must have attached method&quot;);</span>
<span class="line-added">1063     SystemDictionary::ValueBootstrapMethods_klass()-&gt;initialize(CHECK_NH);</span>
<span class="line-added">1064     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, false, CHECK_NH);</span>
<span class="line-added">1065 #ifdef ASSERT</span>
<span class="line-added">1066     Method* is_subst = SystemDictionary::ValueBootstrapMethods_klass()-&gt;find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());</span>
<span class="line-added">1067     assert(callinfo.selected_method() == is_subst, &quot;must be isSubstitutable method&quot;);</span>
<span class="line-added">1068 #endif</span>
<span class="line-added">1069     return receiver;</span>
<span class="line-added">1070   }</span>
<span class="line-added">1071 </span>
1072   Bytecode_invoke bytecode(caller, bci);
1073   int bytecode_index = bytecode.index();
1074   bc = bytecode.invoke_code();
1075 
1076   methodHandle attached_method(THREAD, extract_attached_method(vfst));
1077   if (attached_method.not_null()) {
1078     Method* callee = bytecode.static_target(CHECK_NH);
1079     vmIntrinsics::ID id = callee-&gt;intrinsic_id();
1080     // When VM replaces MH.invokeBasic/linkTo* call with a direct/virtual call,
1081     // it attaches statically resolved method to the call site.
1082     if (MethodHandles::is_signature_polymorphic(id) &amp;&amp;
1083         MethodHandles::is_signature_polymorphic_intrinsic(id)) {
1084       bc = MethodHandles::signature_polymorphic_intrinsic_bytecode(id);
1085 
1086       // Adjust invocation mode according to the attached method.
1087       switch (bc) {
1088         case Bytecodes::_invokevirtual:
1089           if (attached_method-&gt;method_holder()-&gt;is_interface()) {
1090             bc = Bytecodes::_invokeinterface;
1091           }
1092           break;
1093         case Bytecodes::_invokeinterface:
1094           if (!attached_method-&gt;method_holder()-&gt;is_interface()) {
1095             bc = Bytecodes::_invokevirtual;
1096           }
1097           break;
1098         case Bytecodes::_invokehandle:
1099           if (!MethodHandles::is_signature_polymorphic_method(attached_method())) {
1100             bc = attached_method-&gt;is_static() ? Bytecodes::_invokestatic
1101                                               : Bytecodes::_invokevirtual;
1102           }
1103           break;
1104         default:
1105           break;
1106       }
<span class="line-added">1107     } else {</span>
<span class="line-added">1108       assert(attached_method-&gt;has_scalarized_args(), &quot;invalid use of attached method&quot;);</span>
<span class="line-added">1109       if (!attached_method-&gt;method_holder()-&gt;is_value()) {</span>
<span class="line-added">1110         // Ignore the attached method in this case to not confuse below code</span>
<span class="line-added">1111         attached_method = methodHandle(thread, NULL);</span>
<span class="line-added">1112       }</span>
1113     }
1114   }
1115 
1116   assert(bc != Bytecodes::_illegal, &quot;not initialized&quot;);
1117 
1118   bool has_receiver = bc != Bytecodes::_invokestatic &amp;&amp;
1119                       bc != Bytecodes::_invokedynamic &amp;&amp;
1120                       bc != Bytecodes::_invokehandle;
<span class="line-added">1121   bool check_null_and_abstract = true;</span>
1122 
1123   // Find receiver for non-static call
1124   if (has_receiver) {
1125     // This register map must be update since we need to find the receiver for
1126     // compiled frames. The receiver might be in a register.
1127     RegisterMap reg_map2(thread);
1128     frame stubFrame   = thread-&gt;last_frame();
1129     // Caller-frame is a compiled frame
1130     frame callerFrame = stubFrame.sender(&amp;reg_map2);
<span class="line-added">1131     bool caller_is_c1 = false;</span>
1132 
<span class="line-modified">1133     if (callerFrame.is_compiled_frame() &amp;&amp; !callerFrame.is_deoptimized_frame()) {</span>
<span class="line-modified">1134       caller_is_c1 = callerFrame.cb()-&gt;is_compiled_by_c1();</span>
<span class="line-added">1135     }</span>
<span class="line-added">1136 </span>
<span class="line-added">1137     Method* callee = attached_method();</span>
<span class="line-added">1138     if (callee == NULL) {</span>
<span class="line-added">1139       callee = bytecode.static_target(CHECK_NH);</span>
1140       if (callee == NULL) {
1141         THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
1142       }
1143     }
<span class="line-modified">1144     if (!caller_is_c1 &amp;&amp; callee-&gt;has_scalarized_args() &amp;&amp; callee-&gt;method_holder()-&gt;is_value()) {</span>
<span class="line-modified">1145       // If the receiver is a value type that is passed as fields, no oop is available.</span>
<span class="line-modified">1146       // Resolve the call without receiver null checking.</span>
<span class="line-modified">1147       assert(attached_method.not_null() &amp;&amp; !attached_method-&gt;is_abstract(), &quot;must have non-abstract attached method&quot;);</span>
<span class="line-modified">1148       if (bc == Bytecodes::_invokeinterface) {</span>
<span class="line-modified">1149         bc = Bytecodes::_invokevirtual; // C2 optimistically replaces interface calls by virtual calls</span>
<span class="line-added">1150       }</span>
<span class="line-added">1151       check_null_and_abstract = false;</span>
<span class="line-added">1152     } else {</span>
<span class="line-added">1153       // Retrieve from a compiled argument list</span>
<span class="line-added">1154       receiver = Handle(THREAD, callerFrame.retrieve_receiver(&amp;reg_map2));</span>
<span class="line-added">1155       if (receiver.is_null()) {</span>
<span class="line-added">1156         THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);</span>
<span class="line-added">1157       }</span>
1158     }
1159   }
1160 
1161   // Resolve method
1162   if (attached_method.not_null()) {
1163     // Parameterized by attached method.
<span class="line-modified">1164     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, check_null_and_abstract, CHECK_NH);</span>
1165   } else {
1166     // Parameterized by bytecode.
1167     constantPoolHandle constants(THREAD, caller-&gt;constants());
1168     LinkResolver::resolve_invoke(callinfo, receiver, constants, bytecode_index, bc, CHECK_NH);
1169   }
1170 
1171 #ifdef ASSERT
1172   // Check that the receiver klass is of the right subtype and that it is initialized for virtual calls
<span class="line-modified">1173   if (has_receiver &amp;&amp; check_null_and_abstract) {</span>
1174     assert(receiver.not_null(), &quot;should have thrown exception&quot;);
1175     Klass* receiver_klass = receiver-&gt;klass();
1176     Klass* rk = NULL;
1177     if (attached_method.not_null()) {
1178       // In case there&#39;s resolved method attached, use its holder during the check.
1179       rk = attached_method-&gt;method_holder();
1180     } else {
1181       // Klass is already loaded.
1182       constantPoolHandle constants(THREAD, caller-&gt;constants());
1183       rk = constants-&gt;klass_ref_at(bytecode_index, CHECK_NH);
1184     }
1185     Klass* static_receiver_klass = rk;
1186     assert(receiver_klass-&gt;is_subtype_of(static_receiver_klass),
1187            &quot;actual receiver must be subclass of static receiver klass&quot;);
1188     if (receiver_klass-&gt;is_instance_klass()) {
1189       if (InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized()) {
1190         tty-&gt;print_cr(&quot;ERROR: Klass not yet initialized!!&quot;);
1191         receiver_klass-&gt;print();
1192       }
1193       assert(!InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized(), &quot;receiver_klass must be initialized&quot;);
</pre>
<hr />
<pre>
1212     RegisterMap reg_map(thread, false);
1213     frame fr = thread-&gt;last_frame();
1214     assert(fr.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1215     fr = fr.sender(&amp;reg_map);
1216     assert(fr.is_entry_frame(), &quot;must be&quot;);
1217     // fr is now pointing to the entry frame.
1218     callee_method = methodHandle(THREAD, fr.entry_frame_call_wrapper()-&gt;callee_method());
1219   } else {
1220     Bytecodes::Code bc;
1221     CallInfo callinfo;
1222     find_callee_info_helper(thread, vfst, bc, callinfo, CHECK_(methodHandle()));
1223     callee_method = methodHandle(THREAD, callinfo.selected_method());
1224   }
1225   assert(callee_method()-&gt;is_method(), &quot;must be&quot;);
1226   return callee_method;
1227 }
1228 
1229 // Resolves a call.
1230 methodHandle SharedRuntime::resolve_helper(JavaThread *thread,
1231                                            bool is_virtual,
<span class="line-modified">1232                                            bool is_optimized,</span>
<span class="line-added">1233                                            bool* caller_is_c1, TRAPS) {</span>
1234   methodHandle callee_method;
<span class="line-modified">1235   callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, caller_is_c1, THREAD);</span>
1236   if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
1237     int retry_count = 0;
1238     while (!HAS_PENDING_EXCEPTION &amp;&amp; callee_method-&gt;is_old() &amp;&amp;
1239            callee_method-&gt;method_holder() != SystemDictionary::Object_klass()) {
1240       // If has a pending exception then there is no need to re-try to
1241       // resolve this method.
1242       // If the method has been redefined, we need to try again.
1243       // Hack: we have no way to update the vtables of arrays, so don&#39;t
1244       // require that java.lang.Object has been updated.
1245 
1246       // It is very unlikely that method is redefined more than 100 times
1247       // in the middle of resolve. If it is looping here more than 100 times
1248       // means then there could be a bug here.
1249       guarantee((retry_count++ &lt; 100),
1250                 &quot;Could not resolve to latest version of redefined method&quot;);
1251       // method is redefined in the middle of resolve so re-try.
<span class="line-modified">1252       callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, caller_is_c1, THREAD);</span>
1253     }
1254   }
1255   return callee_method;
1256 }
1257 
1258 // This fails if resolution required refilling of IC stubs
1259 bool SharedRuntime::resolve_sub_helper_internal(methodHandle callee_method, const frame&amp; caller_frame,
1260                                                 CompiledMethod* caller_nm, bool is_virtual, bool is_optimized,
1261                                                 Handle receiver, CallInfo&amp; call_info, Bytecodes::Code invoke_code, TRAPS) {
1262   StaticCallInfo static_call_info;
1263   CompiledICInfo virtual_call_info;
1264 
1265   // Make sure the callee nmethod does not get deoptimized and removed before
1266   // we are done patching the code.
1267   CompiledMethod* callee = callee_method-&gt;code();
1268 
1269   if (callee != NULL) {
1270     assert(callee-&gt;is_compiled(), &quot;must be nmethod for patching&quot;);
1271   }
1272 
1273   if (callee != NULL &amp;&amp; !callee-&gt;is_in_use()) {
1274     // Patch call site to C2I adapter if callee nmethod is deoptimized or unloaded.
1275     callee = NULL;
1276   }
1277   nmethodLocker nl_callee(callee);
1278 #ifdef ASSERT
1279   address dest_entry_point = callee == NULL ? 0 : callee-&gt;entry_point(); // used below
1280 #endif
1281 
1282   bool is_nmethod = caller_nm-&gt;is_nmethod();
<span class="line-added">1283   bool caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();</span>
1284 
1285   if (is_virtual) {
<span class="line-modified">1286     Klass* receiver_klass = NULL;</span>
<span class="line-added">1287     if (ValueTypePassFieldsAsArgs &amp;&amp; !caller_is_c1 &amp;&amp; callee_method-&gt;method_holder()-&gt;is_value()) {</span>
<span class="line-added">1288       // If the receiver is a value type that is passed as fields, no oop is available</span>
<span class="line-added">1289       receiver_klass = callee_method-&gt;method_holder();</span>
<span class="line-added">1290     } else {</span>
<span class="line-added">1291       assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);</span>
<span class="line-added">1292       receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();</span>
<span class="line-added">1293     }</span>
1294     bool static_bound = call_info.resolved_method()-&gt;can_be_statically_bound();
<span class="line-modified">1295     CompiledIC::compute_monomorphic_entry(callee_method, receiver_klass,</span>
<span class="line-modified">1296                      is_optimized, static_bound, is_nmethod, caller_is_c1, virtual_call_info,</span>

1297                      CHECK_false);
1298   } else {
1299     // static call
<span class="line-modified">1300     CompiledStaticCall::compute_entry(callee_method, caller_nm, static_call_info);</span>
1301   }
1302 
1303   // grab lock, check for deoptimization and potentially patch caller
1304   {
1305     CompiledICLocker ml(caller_nm);
1306 
1307     // Lock blocks for safepoint during which both nmethods can change state.
1308 
1309     // Now that we are ready to patch if the Method* was redefined then
1310     // don&#39;t update call site and let the caller retry.
1311     // Don&#39;t update call site if callee nmethod was unloaded or deoptimized.
1312     // Don&#39;t update call site if callee nmethod was replaced by an other nmethod
1313     // which may happen when multiply alive nmethod (tiered compilation)
1314     // will be supported.
1315     if (!callee_method-&gt;is_old() &amp;&amp;
1316         (callee == NULL || (callee-&gt;is_in_use() &amp;&amp; callee_method-&gt;code() == callee))) {
1317       NoSafepointVerifier nsv;
1318 #ifdef ASSERT
1319       // We must not try to patch to jump to an already unloaded method.
1320       if (dest_entry_point != 0) {
</pre>
<hr />
<pre>
1332         }
1333       } else {
1334         if (VM_Version::supports_fast_class_init_checks() &amp;&amp;
1335             invoke_code == Bytecodes::_invokestatic &amp;&amp;
1336             callee_method-&gt;needs_clinit_barrier() &amp;&amp;
1337             callee != NULL &amp;&amp; (callee-&gt;is_compiled_by_jvmci() || callee-&gt;is_aot())) {
1338           return true; // skip patching for JVMCI or AOT code
1339         }
1340         CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_before(caller_frame.pc());
1341         if (ssc-&gt;is_clean()) ssc-&gt;set(static_call_info);
1342       }
1343     }
1344   } // unlock CompiledICLocker
1345   return true;
1346 }
1347 
1348 // Resolves a call.  The compilers generate code for calls that go here
1349 // and are patched with the real destination of the call.
1350 methodHandle SharedRuntime::resolve_sub_helper(JavaThread *thread,
1351                                                bool is_virtual,
<span class="line-modified">1352                                                bool is_optimized,</span>
<span class="line-added">1353                                                bool* caller_is_c1, TRAPS) {</span>
1354 
1355   ResourceMark rm(thread);
1356   RegisterMap cbl_map(thread, false);
1357   frame caller_frame = thread-&gt;last_frame().sender(&amp;cbl_map);
1358 
1359   CodeBlob* caller_cb = caller_frame.cb();
1360   guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
1361   CompiledMethod* caller_nm = caller_cb-&gt;as_compiled_method_or_null();
<span class="line-added">1362   *caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();</span>
1363 
1364   // make sure caller is not getting deoptimized
1365   // and removed before we are done with it.
1366   // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1367   nmethodLocker caller_lock(caller_nm);
1368 
1369   // determine call info &amp; receiver
1370   // note: a) receiver is NULL for static calls
1371   //       b) an exception is thrown if receiver is NULL for non-static calls
1372   CallInfo call_info;
1373   Bytecodes::Code invoke_code = Bytecodes::_illegal;
1374   Handle receiver = find_callee_info(thread, invoke_code,
1375                                      call_info, CHECK_(methodHandle()));
1376   methodHandle callee_method(THREAD, call_info.selected_method());
1377 
1378   assert((!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokestatic ) ||
1379          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokespecial) ||
1380          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokehandle ) ||
1381          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokedynamic) ||
1382          ( is_virtual &amp;&amp; invoke_code != Bytecodes::_invokestatic ), &quot;inconsistent bytecode&quot;);
</pre>
<hr />
<pre>
1444       return callee_method;
1445     } else {
1446       InlineCacheBuffer::refill_ic_stubs();
1447     }
1448   }
1449 
1450 }
1451 
1452 
1453 // Inline caches exist only in compiled code
1454 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_ic_miss(JavaThread* thread))
1455 #ifdef ASSERT
1456   RegisterMap reg_map(thread, false);
1457   frame stub_frame = thread-&gt;last_frame();
1458   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1459   frame caller_frame = stub_frame.sender(&amp;reg_map);
1460   assert(!caller_frame.is_interpreted_frame() &amp;&amp; !caller_frame.is_entry_frame(), &quot;unexpected frame&quot;);
1461 #endif /* ASSERT */
1462 
1463   methodHandle callee_method;
<span class="line-added">1464   bool is_optimized = false;</span>
<span class="line-added">1465   bool caller_is_c1 = false;</span>
1466   JRT_BLOCK
<span class="line-modified">1467     callee_method = SharedRuntime::handle_ic_miss_helper(thread, is_optimized, caller_is_c1, CHECK_NULL);</span>
1468     // Return Method* through TLS
1469     thread-&gt;set_vm_result_2(callee_method());
1470   JRT_BLOCK_END
1471   // return compiled code entry point after potential safepoints
<span class="line-modified">1472   return entry_for_handle_wrong_method(callee_method, false, is_optimized, caller_is_c1);</span>

1473 JRT_END
1474 
1475 
1476 // Handle call site that has been made non-entrant
1477 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* thread))
1478   // 6243940 We might end up in here if the callee is deoptimized
1479   // as we race to call it.  We don&#39;t want to take a safepoint if
1480   // the caller was interpreted because the caller frame will look
1481   // interpreted to the stack walkers and arguments are now
1482   // &quot;compiled&quot; so it is much better to make this transition
1483   // invisible to the stack walking code. The i2c path will
1484   // place the callee method in the callee_target. It is stashed
1485   // there because if we try and find the callee by normal means a
1486   // safepoint is possible and have trouble gc&#39;ing the compiled args.
1487   RegisterMap reg_map(thread, false);
1488   frame stub_frame = thread-&gt;last_frame();
1489   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1490   frame caller_frame = stub_frame.sender(&amp;reg_map);
1491 
1492   if (caller_frame.is_interpreted_frame() ||
</pre>
<hr />
<pre>
1495     guarantee(callee != NULL &amp;&amp; callee-&gt;is_method(), &quot;bad handshake&quot;);
1496     thread-&gt;set_vm_result_2(callee);
1497     thread-&gt;set_callee_target(NULL);
1498     if (caller_frame.is_entry_frame() &amp;&amp; VM_Version::supports_fast_class_init_checks()) {
1499       // Bypass class initialization checks in c2i when caller is in native.
1500       // JNI calls to static methods don&#39;t have class initialization checks.
1501       // Fast class initialization checks are present in c2i adapters and call into
1502       // SharedRuntime::handle_wrong_method() on the slow path.
1503       //
1504       // JVM upcalls may land here as well, but there&#39;s a proper check present in
1505       // LinkResolver::resolve_static_call (called from JavaCalls::call_static),
1506       // so bypassing it in c2i adapter is benign.
1507       return callee-&gt;get_c2i_no_clinit_check_entry();
1508     } else {
1509       return callee-&gt;get_c2i_entry();
1510     }
1511   }
1512 
1513   // Must be compiled to compiled path which is safe to stackwalk
1514   methodHandle callee_method;
<span class="line-added">1515   bool is_static_call = false;</span>
<span class="line-added">1516   bool is_optimized = false;</span>
<span class="line-added">1517   bool caller_is_c1 = false;</span>
1518   JRT_BLOCK
1519     // Force resolving of caller (if we called from compiled frame)
<span class="line-modified">1520     callee_method = SharedRuntime::reresolve_call_site(thread, is_static_call, is_optimized, caller_is_c1, CHECK_NULL);</span>
1521     thread-&gt;set_vm_result_2(callee_method());
1522   JRT_BLOCK_END
1523   // return compiled code entry point after potential safepoints
<span class="line-modified">1524   return entry_for_handle_wrong_method(callee_method, is_static_call, is_optimized, caller_is_c1);</span>

1525 JRT_END
1526 
1527 // Handle abstract method call
1528 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* thread))
1529   // Verbose error message for AbstractMethodError.
1530   // Get the called method from the invoke bytecode.
1531   vframeStream vfst(thread, true);
1532   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1533   methodHandle caller(thread, vfst.method());
1534   Bytecode_invoke invoke(caller, vfst.bci());
1535   DEBUG_ONLY( invoke.verify(); )
1536 
1537   // Find the compiled caller frame.
1538   RegisterMap reg_map(thread);
1539   frame stubFrame = thread-&gt;last_frame();
1540   assert(stubFrame.is_runtime_frame(), &quot;must be&quot;);
1541   frame callerFrame = stubFrame.sender(&amp;reg_map);
1542   assert(callerFrame.is_compiled_frame(), &quot;must be&quot;);
1543 
1544   // Install exception and return forward entry.
1545   address res = StubRoutines::throw_AbstractMethodError_entry();
1546   JRT_BLOCK
1547     methodHandle callee(thread, invoke.static_target(thread));
1548     if (!callee.is_null()) {
1549       oop recv = callerFrame.retrieve_receiver(&amp;reg_map);
1550       Klass *recv_klass = (recv != NULL) ? recv-&gt;klass() : NULL;
1551       LinkResolver::throw_abstract_method_error(callee, recv_klass, thread);
1552       res = StubRoutines::forward_exception_entry();
1553     }
1554   JRT_BLOCK_END
1555   return res;
1556 JRT_END
1557 
1558 
1559 // resolve a static call and patch code
1560 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread *thread ))
1561   methodHandle callee_method;
<span class="line-added">1562   bool caller_is_c1;</span>
1563   JRT_BLOCK
<span class="line-modified">1564     callee_method = SharedRuntime::resolve_helper(thread, false, false, &amp;caller_is_c1, CHECK_NULL);</span>
1565     thread-&gt;set_vm_result_2(callee_method());
1566   JRT_BLOCK_END
1567   // return compiled code entry point after potential safepoints
<span class="line-modified">1568   address entry = caller_is_c1 ?</span>
<span class="line-modified">1569     callee_method-&gt;verified_value_code_entry() : callee_method-&gt;verified_code_entry();</span>
<span class="line-added">1570   assert(entry != NULL, &quot;Jump to zero!&quot;);</span>
<span class="line-added">1571   return entry;</span>
1572 JRT_END
1573 
1574 
1575 // resolve virtual call and update inline cache to monomorphic
1576 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread *thread ))
1577   methodHandle callee_method;
<span class="line-added">1578   bool caller_is_c1;</span>
1579   JRT_BLOCK
<span class="line-modified">1580     callee_method = SharedRuntime::resolve_helper(thread, true, false, &amp;caller_is_c1, CHECK_NULL);</span>
1581     thread-&gt;set_vm_result_2(callee_method());
1582   JRT_BLOCK_END
1583   // return compiled code entry point after potential safepoints
<span class="line-modified">1584   address entry = caller_is_c1 ?</span>
<span class="line-modified">1585     callee_method-&gt;verified_value_code_entry() : callee_method-&gt;verified_value_ro_code_entry();</span>
<span class="line-added">1586   assert(entry != NULL, &quot;Jump to zero!&quot;);</span>
<span class="line-added">1587   return entry;</span>
1588 JRT_END
1589 
1590 
1591 // Resolve a virtual call that can be statically bound (e.g., always
1592 // monomorphic, so it has no inline cache).  Patch code to resolved target.
1593 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread *thread))
1594   methodHandle callee_method;
<span class="line-added">1595   bool caller_is_c1;</span>
1596   JRT_BLOCK
<span class="line-modified">1597     callee_method = SharedRuntime::resolve_helper(thread, true, true, &amp;caller_is_c1, CHECK_NULL);</span>
1598     thread-&gt;set_vm_result_2(callee_method());
1599   JRT_BLOCK_END
1600   // return compiled code entry point after potential safepoints
<span class="line-modified">1601   address entry = caller_is_c1 ?</span>
<span class="line-modified">1602     callee_method-&gt;verified_value_code_entry() : callee_method-&gt;verified_code_entry();</span>
<span class="line-added">1603   assert(entry != NULL, &quot;Jump to zero!&quot;);</span>
<span class="line-added">1604   return entry;</span>
1605 JRT_END
1606 
1607 // The handle_ic_miss_helper_internal function returns false if it failed due
1608 // to either running out of vtable stubs or ic stubs due to IC transitions
1609 // to transitional states. The needs_ic_stub_refill value will be set if
1610 // the failure was due to running out of IC stubs, in which case handle_ic_miss_helper
1611 // refills the IC stubs and tries again.
1612 bool SharedRuntime::handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm,
1613                                                    const frame&amp; caller_frame, methodHandle callee_method,
1614                                                    Bytecodes::Code bc, CallInfo&amp; call_info,
<span class="line-modified">1615                                                    bool&amp; needs_ic_stub_refill, bool&amp; is_optimized, bool caller_is_c1, TRAPS) {</span>
1616   CompiledICLocker ml(caller_nm);
1617   CompiledIC* inline_cache = CompiledIC_before(caller_nm, caller_frame.pc());
1618   bool should_be_mono = false;
1619   if (inline_cache-&gt;is_optimized()) {
1620     if (TraceCallFixup) {
1621       ResourceMark rm(THREAD);
1622       tty-&gt;print(&quot;OPTIMIZED IC miss (%s) call to&quot;, Bytecodes::name(bc));
1623       callee_method-&gt;print_short_name(tty);
1624       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1625     }
<span class="line-added">1626     is_optimized = true;</span>
1627     should_be_mono = true;
1628   } else if (inline_cache-&gt;is_icholder_call()) {
1629     CompiledICHolder* ic_oop = inline_cache-&gt;cached_icholder();
1630     if (ic_oop != NULL) {
1631       if (!ic_oop-&gt;is_loader_alive()) {
1632         // Deferred IC cleaning due to concurrent class unloading
1633         if (!inline_cache-&gt;set_to_clean()) {
1634           needs_ic_stub_refill = true;
1635           return false;
1636         }
1637       } else if (receiver()-&gt;klass() == ic_oop-&gt;holder_klass()) {
1638         // This isn&#39;t a real miss. We must have seen that compiled code
1639         // is now available and we want the call site converted to a
1640         // monomorphic compiled call site.
1641         // We can&#39;t assert for callee_method-&gt;code() != NULL because it
1642         // could have been deoptimized in the meantime
1643         if (TraceCallFixup) {
1644           ResourceMark rm(THREAD);
1645           tty-&gt;print(&quot;FALSE IC miss (%s) converting to compiled call to&quot;, Bytecodes::name(bc));
1646           callee_method-&gt;print_short_name(tty);
1647           tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1648         }
1649         should_be_mono = true;
1650       }
1651     }
1652   }
1653 
1654   if (should_be_mono) {
1655     // We have a path that was monomorphic but was going interpreted
1656     // and now we have (or had) a compiled entry. We correct the IC
1657     // by using a new icBuffer.
1658     CompiledICInfo info;
1659     Klass* receiver_klass = receiver()-&gt;klass();
1660     inline_cache-&gt;compute_monomorphic_entry(callee_method,
1661                                             receiver_klass,
1662                                             inline_cache-&gt;is_optimized(),
1663                                             false, caller_nm-&gt;is_nmethod(),
<span class="line-added">1664                                             caller_nm-&gt;is_compiled_by_c1(),</span>
1665                                             info, CHECK_false);
1666     if (!inline_cache-&gt;set_to_monomorphic(info)) {
1667       needs_ic_stub_refill = true;
1668       return false;
1669     }
1670   } else if (!inline_cache-&gt;is_megamorphic() &amp;&amp; !inline_cache-&gt;is_clean()) {
1671     // Potential change to megamorphic
1672 
<span class="line-modified">1673     bool successful = inline_cache-&gt;set_to_megamorphic(&amp;call_info, bc, needs_ic_stub_refill, caller_is_c1, CHECK_false);</span>
1674     if (needs_ic_stub_refill) {
1675       return false;
1676     }
1677     if (!successful) {
1678       if (!inline_cache-&gt;set_to_clean()) {
1679         needs_ic_stub_refill = true;
1680         return false;
1681       }
1682     }
1683   } else {
1684     // Either clean or megamorphic
1685   }
1686   return true;
1687 }
1688 
<span class="line-modified">1689 methodHandle SharedRuntime::handle_ic_miss_helper(JavaThread *thread, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS) {</span>
1690   ResourceMark rm(thread);
1691   CallInfo call_info;
1692   Bytecodes::Code bc;
1693 
1694   // receiver is NULL for static calls. An exception is thrown for NULL
1695   // receivers for non-static calls
1696   Handle receiver = find_callee_info(thread, bc, call_info,
1697                                      CHECK_(methodHandle()));
1698   // Compiler1 can produce virtual call sites that can actually be statically bound
1699   // If we fell thru to below we would think that the site was going megamorphic
1700   // when in fact the site can never miss. Worse because we&#39;d think it was megamorphic
1701   // we&#39;d try and do a vtable dispatch however methods that can be statically bound
1702   // don&#39;t have vtable entries (vtable_index &lt; 0) and we&#39;d blow up. So we force a
1703   // reresolution of the  call site (as if we did a handle_wrong_method and not an
1704   // plain ic_miss) and the site will be converted to an optimized virtual call site
1705   // never to miss again. I don&#39;t believe C2 will produce code like this but if it
1706   // did this would still be the correct thing to do for it too, hence no ifdef.
1707   //
1708   if (call_info.resolved_method()-&gt;can_be_statically_bound()) {
<span class="line-modified">1709     bool is_static_call = false;</span>
<span class="line-added">1710     methodHandle callee_method = SharedRuntime::reresolve_call_site(thread, is_static_call, is_optimized, caller_is_c1, CHECK_(methodHandle()));</span>
<span class="line-added">1711     assert(!is_static_call, &quot;IC miss at static call?&quot;);</span>
1712     if (TraceCallFixup) {
1713       RegisterMap reg_map(thread, false);
1714       frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1715       ResourceMark rm(thread);
1716       tty-&gt;print(&quot;converting IC miss to reresolve (%s) call to&quot;, Bytecodes::name(bc));
1717       callee_method-&gt;print_short_name(tty);
1718       tty-&gt;print_cr(&quot; from pc: &quot; INTPTR_FORMAT, p2i(caller_frame.pc()));
1719       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1720     }
1721     return callee_method;
1722   }
1723 
1724   methodHandle callee_method(thread, call_info.selected_method());
1725 
1726 #ifndef PRODUCT
1727   Atomic::inc(&amp;_ic_miss_ctr);
1728 
1729   // Statistics &amp; Tracing
1730   if (TraceCallFixup) {
1731     ResourceMark rm(thread);
</pre>
<hr />
<pre>
1741     // produce statistics under the lock
1742     trace_ic_miss(f.pc());
1743   }
1744 #endif
1745 
1746   // install an event collector so that when a vtable stub is created the
1747   // profiler can be notified via a DYNAMIC_CODE_GENERATED event. The
1748   // event can&#39;t be posted when the stub is created as locks are held
1749   // - instead the event will be deferred until the event collector goes
1750   // out of scope.
1751   JvmtiDynamicCodeEventCollector event_collector;
1752 
1753   // Update inline cache to megamorphic. Skip update if we are called from interpreted.
1754   // Transitioning IC caches may require transition stubs. If we run out
1755   // of transition stubs, we have to drop locks and perform a safepoint
1756   // that refills them.
1757   RegisterMap reg_map(thread, false);
1758   frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1759   CodeBlob* cb = caller_frame.cb();
1760   CompiledMethod* caller_nm = cb-&gt;as_compiled_method();
<span class="line-added">1761   caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();</span>
1762 
1763   for (;;) {
1764     ICRefillVerifier ic_refill_verifier;
1765     bool needs_ic_stub_refill = false;
1766     bool successful = handle_ic_miss_helper_internal(receiver, caller_nm, caller_frame, callee_method,
<span class="line-modified">1767                                                      bc, call_info, needs_ic_stub_refill, is_optimized, caller_is_c1, CHECK_(methodHandle()));</span>
1768     if (successful || !needs_ic_stub_refill) {
1769       return callee_method;
1770     } else {
1771       InlineCacheBuffer::refill_ic_stubs();
1772     }
1773   }
1774 }
1775 
1776 static bool clear_ic_at_addr(CompiledMethod* caller_nm, address call_addr, bool is_static_call) {
1777   CompiledICLocker ml(caller_nm);
1778   if (is_static_call) {
1779     CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_at(call_addr);
1780     if (!ssc-&gt;is_clean()) {
1781       return ssc-&gt;set_to_clean();
1782     }
1783   } else {
1784     // compiled, dispatched call (which used to call an interpreted method)
1785     CompiledIC* inline_cache = CompiledIC_at(caller_nm, call_addr);
1786     if (!inline_cache-&gt;is_clean()) {
1787       return inline_cache-&gt;set_to_clean();
1788     }
1789   }
1790   return true;
1791 }
1792 
1793 //
1794 // Resets a call-site in compiled code so it will get resolved again.
1795 // This routines handles both virtual call sites, optimized virtual call
1796 // sites, and static call sites. Typically used to change a call sites
1797 // destination from compiled to interpreted.
1798 //
<span class="line-modified">1799 methodHandle SharedRuntime::reresolve_call_site(JavaThread *thread, bool&amp; is_static_call, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS) {</span>
1800   ResourceMark rm(thread);
1801   RegisterMap reg_map(thread, false);
1802   frame stub_frame = thread-&gt;last_frame();
1803   assert(stub_frame.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1804   frame caller = stub_frame.sender(&amp;reg_map);
1805 
1806   // Do nothing if the frame isn&#39;t a live compiled frame.
1807   // nmethod could be deoptimized by the time we get here
1808   // so no update to the caller is needed.
1809 
1810   if (caller.is_compiled_frame() &amp;&amp; !caller.is_deoptimized_frame()) {
1811 
1812     address pc = caller.pc();
1813 
1814     // Check for static or virtual call
<span class="line-modified">1815     CompiledMethod* caller_nm = CodeCache::find_compiled(pc);</span>
1816     caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
1817 
1818     // Default call_addr is the location of the &quot;basic&quot; call.
1819     // Determine the address of the call we a reresolving. With
1820     // Inline Caches we will always find a recognizable call.
1821     // With Inline Caches disabled we may or may not find a
1822     // recognizable call. We will always find a call for static
1823     // calls and for optimized virtual calls. For vanilla virtual
1824     // calls it depends on the state of the UseInlineCaches switch.
1825     //
1826     // With Inline Caches disabled we can get here for a virtual call
1827     // for two reasons:
1828     //   1 - calling an abstract method. The vtable for abstract methods
1829     //       will run us thru handle_wrong_method and we will eventually
1830     //       end up in the interpreter to throw the ame.
1831     //   2 - a racing deoptimization. We could be doing a vanilla vtable
1832     //       call and between the time we fetch the entry address and
1833     //       we jump to it the target gets deoptimized. Similar to 1
1834     //       we will wind up in the interprter (thru a c2i with c2).
1835     //
</pre>
<hr />
<pre>
1840       CompiledICLocker ml(caller_nm);
1841       // Location of call instruction
1842       call_addr = caller_nm-&gt;call_instruction_address(pc);
1843     }
1844     // Make sure nmethod doesn&#39;t get deoptimized and removed until
1845     // this is done with it.
1846     // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1847     nmethodLocker nmlock(caller_nm);
1848 
1849     if (call_addr != NULL) {
1850       RelocIterator iter(caller_nm, call_addr, call_addr+1);
1851       int ret = iter.next(); // Get item
1852       if (ret) {
1853         assert(iter.addr() == call_addr, &quot;must find call&quot;);
1854         if (iter.type() == relocInfo::static_call_type) {
1855           is_static_call = true;
1856         } else {
1857           assert(iter.type() == relocInfo::virtual_call_type ||
1858                  iter.type() == relocInfo::opt_virtual_call_type
1859                 , &quot;unexpected relocInfo. type&quot;);
<span class="line-added">1860           is_optimized = (iter.type() == relocInfo::opt_virtual_call_type);</span>
1861         }
1862       } else {
1863         assert(!UseInlineCaches, &quot;relocation info. must exist for this address&quot;);
1864       }
1865 
1866       // Cleaning the inline cache will force a new resolve. This is more robust
1867       // than directly setting it to the new destination, since resolving of calls
1868       // is always done through the same code path. (experience shows that it
1869       // leads to very hard to track down bugs, if an inline cache gets updated
1870       // to a wrong method). It should not be performance critical, since the
1871       // resolve is only done once.
1872 
1873       for (;;) {
1874         ICRefillVerifier ic_refill_verifier;
1875         if (!clear_ic_at_addr(caller_nm, call_addr, is_static_call)) {
1876           InlineCacheBuffer::refill_ic_stubs();
1877         } else {
1878           break;
1879         }
1880       }
1881     }
1882   }
1883 
1884   methodHandle callee_method = find_callee_method(thread, CHECK_(methodHandle()));
1885 

1886 #ifndef PRODUCT
1887   Atomic::inc(&amp;_wrong_method_ctr);
1888 
1889   if (TraceCallFixup) {
1890     ResourceMark rm(thread);
1891     tty-&gt;print(&quot;handle_wrong_method reresolving call to&quot;);
1892     callee_method-&gt;print_short_name(tty);
1893     tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1894   }
1895 #endif
1896 
1897   return callee_method;
1898 }
1899 
1900 address SharedRuntime::handle_unsafe_access(JavaThread* thread, address next_pc) {
1901   // The faulting unsafe accesses should be changed to throw the error
1902   // synchronously instead. Meanwhile the faulting instruction will be
1903   // skipped over (effectively turning it into a no-op) and an
1904   // asynchronous exception will be raised which the thread will
1905   // handle at a later point. If the instruction is a load it will
</pre>
<hr />
<pre>
1960     }
1961   } else {
1962     if (TraceCallFixup) {
1963       tty-&gt;print(&quot;already patched callsite at &quot; INTPTR_FORMAT &quot; to compiled code for&quot;, p2i(caller_pc));
1964       moop-&gt;print_short_name(tty);
1965       tty-&gt;print_cr(&quot; to &quot; INTPTR_FORMAT, p2i(entry_point));
1966     }
1967   }
1968   return false;
1969 }
1970 
1971 // ---------------------------------------------------------------------------
1972 // We are calling the interpreter via a c2i. Normally this would mean that
1973 // we were called by a compiled method. However we could have lost a race
1974 // where we went int -&gt; i2c -&gt; c2i and so the caller could in fact be
1975 // interpreted. If the caller is compiled we attempt to patch the caller
1976 // so he no longer calls into the interpreter.
1977 JRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))
1978   Method* moop(method);
1979 


1980   // It&#39;s possible that deoptimization can occur at a call site which hasn&#39;t
1981   // been resolved yet, in which case this function will be called from
1982   // an nmethod that has been patched for deopt and we can ignore the
1983   // request for a fixup.
1984   // Also it is possible that we lost a race in that from_compiled_entry
1985   // is now back to the i2c in that case we don&#39;t need to patch and if
1986   // we did we&#39;d leap into space because the callsite needs to use
1987   // &quot;to interpreter&quot; stub in order to load up the Method*. Don&#39;t
1988   // ask me how I know this...
1989 
1990   CodeBlob* cb = CodeCache::find_blob(caller_pc);
<span class="line-modified">1991   if (cb == NULL || !cb-&gt;is_compiled()) {</span>
<span class="line-added">1992     return;</span>
<span class="line-added">1993   }</span>
<span class="line-added">1994   address entry_point = moop-&gt;from_compiled_entry_no_trampoline(cb-&gt;is_compiled_by_c1());</span>
<span class="line-added">1995   if (entry_point == moop-&gt;get_c2i_entry()) {</span>
1996     return;
1997   }
1998 
1999   // The check above makes sure this is a nmethod.
2000   CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
2001   assert(nm, &quot;must be&quot;);
2002 
2003   // Get the return PC for the passed caller PC.
2004   address return_pc = caller_pc + frame::pc_return_offset;
2005 
2006   // There is a benign race here. We could be attempting to patch to a compiled
2007   // entry point at the same time the callee is being deoptimized. If that is
2008   // the case then entry_point may in fact point to a c2i and we&#39;d patch the
2009   // call site with the same old data. clear_code will set code() to NULL
2010   // at the end of it. If we happen to see that NULL then we can skip trying
2011   // to patch. If we hit the window where the callee has a c2i in the
2012   // from_compiled_entry and the NULL isn&#39;t present yet then we lose the race
2013   // and patch the code with the same old data. Asi es la vida.
2014 
2015   if (moop-&gt;code() == NULL) return;
</pre>
<hr />
<pre>
2336  private:
2337   enum {
2338     _basic_type_bits = 4,
2339     _basic_type_mask = right_n_bits(_basic_type_bits),
2340     _basic_types_per_int = BitsPerInt / _basic_type_bits,
2341     _compact_int_count = 3
2342   };
2343   // TO DO:  Consider integrating this with a more global scheme for compressing signatures.
2344   // For now, 4 bits per components (plus T_VOID gaps after double/long) is not excessive.
2345 
2346   union {
2347     int  _compact[_compact_int_count];
2348     int* _fingerprint;
2349   } _value;
2350   int _length; // A negative length indicates the fingerprint is in the compact form,
2351                // Otherwise _value._fingerprint is the array.
2352 
2353   // Remap BasicTypes that are handled equivalently by the adapters.
2354   // These are correct for the current system but someday it might be
2355   // necessary to make this mapping platform dependent.
<span class="line-modified">2356   static int adapter_encoding(BasicType in, bool is_valuetype) {</span>
2357     switch (in) {
2358       case T_BOOLEAN:
2359       case T_BYTE:
2360       case T_SHORT:
<span class="line-modified">2361       case T_CHAR: {</span>
<span class="line-modified">2362         if (is_valuetype) {</span>
<span class="line-modified">2363           // Do not widen value type field types</span>
<span class="line-added">2364           assert(ValueTypePassFieldsAsArgs, &quot;must be enabled&quot;);</span>
<span class="line-added">2365           return in;</span>
<span class="line-added">2366         } else {</span>
<span class="line-added">2367           // They are all promoted to T_INT in the calling convention</span>
<span class="line-added">2368           return T_INT;</span>
<span class="line-added">2369         }</span>
<span class="line-added">2370       }</span>
<span class="line-added">2371 </span>
<span class="line-added">2372       case T_VALUETYPE: {</span>
<span class="line-added">2373         // If value types are passed as fields, return &#39;in&#39; to differentiate</span>
<span class="line-added">2374         // between a T_VALUETYPE and a T_OBJECT in the signature.</span>
<span class="line-added">2375         return ValueTypePassFieldsAsArgs ? in : adapter_encoding(T_OBJECT, false);</span>
<span class="line-added">2376       }</span>
2377 
2378       case T_OBJECT:
2379       case T_ARRAY:
2380         // In other words, we assume that any register good enough for
2381         // an int or long is good enough for a managed pointer.
2382 #ifdef _LP64
2383         return T_LONG;
2384 #else
2385         return T_INT;
2386 #endif
2387 
2388       case T_INT:
2389       case T_LONG:
2390       case T_FLOAT:
2391       case T_DOUBLE:
2392       case T_VOID:
2393         return in;
2394 
2395       default:
2396         ShouldNotReachHere();
2397         return T_CONFLICT;
2398     }
2399   }
2400 
2401  public:
<span class="line-modified">2402   AdapterFingerPrint(const GrowableArray&lt;SigEntry&gt;* sig, bool has_ro_adapter = false) {</span>
2403     // The fingerprint is based on the BasicType signature encoded
2404     // into an array of ints with eight entries per int.
<span class="line-added">2405     int total_args_passed = (sig != NULL) ? sig-&gt;length() : 0;</span>
2406     int* ptr;
2407     int len = (total_args_passed + (_basic_types_per_int-1)) / _basic_types_per_int;
2408     if (len &lt;= _compact_int_count) {
2409       assert(_compact_int_count == 3, &quot;else change next line&quot;);
2410       _value._compact[0] = _value._compact[1] = _value._compact[2] = 0;
2411       // Storing the signature encoded as signed chars hits about 98%
2412       // of the time.
2413       _length = -len;
2414       ptr = _value._compact;
2415     } else {
2416       _length = len;
2417       _value._fingerprint = NEW_C_HEAP_ARRAY(int, _length, mtCode);
2418       ptr = _value._fingerprint;
2419     }
2420 
2421     // Now pack the BasicTypes with 8 per int
2422     int sig_index = 0;
<span class="line-added">2423     BasicType prev_sbt = T_ILLEGAL;</span>
<span class="line-added">2424     int vt_count = 0;</span>
2425     for (int index = 0; index &lt; len; index++) {
2426       int value = 0;
2427       for (int byte = 0; byte &lt; _basic_types_per_int; byte++) {
<span class="line-modified">2428         int bt = 0;</span>
<span class="line-modified">2429         if (sig_index &lt; total_args_passed) {</span>
<span class="line-modified">2430           BasicType sbt = sig-&gt;at(sig_index++)._bt;</span>
<span class="line-added">2431           if (ValueTypePassFieldsAsArgs &amp;&amp; sbt == T_VALUETYPE) {</span>
<span class="line-added">2432             // Found start of value type in signature</span>
<span class="line-added">2433             vt_count++;</span>
<span class="line-added">2434             if (sig_index == 1 &amp;&amp; has_ro_adapter) {</span>
<span class="line-added">2435               // With a ro_adapter, replace receiver value type delimiter by T_VOID to prevent matching</span>
<span class="line-added">2436               // with other adapters that have the same value type as first argument and no receiver.</span>
<span class="line-added">2437               sbt = T_VOID;</span>
<span class="line-added">2438             }</span>
<span class="line-added">2439           } else if (ValueTypePassFieldsAsArgs &amp;&amp; sbt == T_VOID &amp;&amp;</span>
<span class="line-added">2440                      prev_sbt != T_LONG &amp;&amp; prev_sbt != T_DOUBLE) {</span>
<span class="line-added">2441             // Found end of value type in signature</span>
<span class="line-added">2442             vt_count--;</span>
<span class="line-added">2443             assert(vt_count &gt;= 0, &quot;invalid vt_count&quot;);</span>
<span class="line-added">2444           }</span>
<span class="line-added">2445           bt = adapter_encoding(sbt, vt_count &gt; 0);</span>
<span class="line-added">2446           prev_sbt = sbt;</span>
<span class="line-added">2447         }</span>
2448         assert((bt &amp; _basic_type_mask) == bt, &quot;must fit in 4 bits&quot;);
2449         value = (value &lt;&lt; _basic_type_bits) | bt;
2450       }
2451       ptr[index] = value;
2452     }
<span class="line-added">2453     assert(vt_count == 0, &quot;invalid vt_count&quot;);</span>
2454   }
2455 
2456   ~AdapterFingerPrint() {
2457     if (_length &gt; 0) {
2458       FREE_C_HEAP_ARRAY(int, _value._fingerprint);
2459     }
2460   }
2461 
2462   int value(int index) {
2463     if (_length &lt; 0) {
2464       return _value._compact[index];
2465     }
2466     return _value._fingerprint[index];
2467   }
2468   int length() {
2469     if (_length &lt; 0) return -_length;
2470     return _length;
2471   }
2472 
2473   bool is_compact() {
</pre>
<hr />
<pre>
2519 
2520  private:
2521 
2522 #ifndef PRODUCT
2523   static int _lookups; // number of calls to lookup
2524   static int _buckets; // number of buckets checked
2525   static int _equals;  // number of buckets checked with matching hash
2526   static int _hits;    // number of successful lookups
2527   static int _compact; // number of equals calls with compact signature
2528 #endif
2529 
2530   AdapterHandlerEntry* bucket(int i) {
2531     return (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::bucket(i);
2532   }
2533 
2534  public:
2535   AdapterHandlerTable()
2536     : BasicHashtable&lt;mtCode&gt;(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }
2537 
2538   // Create a new entry suitable for insertion in the table
<span class="line-modified">2539   AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry,</span>
<span class="line-added">2540                                  address c2i_value_entry, address c2i_value_ro_entry,</span>
<span class="line-added">2541                                  address c2i_unverified_entry, address c2i_unverified_value_entry, address c2i_no_clinit_check_entry) {</span>
2542     AdapterHandlerEntry* entry = (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::new_entry(fingerprint-&gt;compute_hash());
<span class="line-modified">2543     entry-&gt;init(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry,</span>
<span class="line-added">2544                 c2i_unverified_entry, c2i_unverified_value_entry, c2i_no_clinit_check_entry);</span>
2545     if (DumpSharedSpaces) {
2546       ((CDSAdapterHandlerEntry*)entry)-&gt;init();
2547     }
2548     return entry;
2549   }
2550 
2551   // Insert an entry into the table
2552   void add(AdapterHandlerEntry* entry) {
2553     int index = hash_to_index(entry-&gt;hash());
2554     add_entry(index, entry);
2555   }
2556 
2557   void free_entry(AdapterHandlerEntry* entry) {
2558     entry-&gt;deallocate();
2559     BasicHashtable&lt;mtCode&gt;::free_entry(entry);
2560   }
2561 
2562   // Find a entry with the same fingerprint if it exists
<span class="line-modified">2563   AdapterHandlerEntry* lookup(const GrowableArray&lt;SigEntry&gt;* sig, bool has_ro_adapter = false) {</span>
2564     NOT_PRODUCT(_lookups++);
<span class="line-modified">2565     AdapterFingerPrint fp(sig, has_ro_adapter);</span>
2566     unsigned int hash = fp.compute_hash();
2567     int index = hash_to_index(hash);
2568     for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
2569       NOT_PRODUCT(_buckets++);
2570       if (e-&gt;hash() == hash) {
2571         NOT_PRODUCT(_equals++);
2572         if (fp.equals(e-&gt;fingerprint())) {
2573 #ifndef PRODUCT
2574           if (fp.is_compact()) _compact++;
2575           _hits++;
2576 #endif
2577           return e;
2578         }
2579       }
2580     }
2581     return NULL;
2582   }
2583 
2584 #ifndef PRODUCT
2585   void print_statistics() {
</pre>
<hr />
<pre>
2641   bool has_next() {
2642     return _current != NULL;
2643   }
2644   AdapterHandlerEntry* next() {
2645     if (_current != NULL) {
2646       AdapterHandlerEntry* result = _current;
2647       _current = _current-&gt;next();
2648       if (_current == NULL) scan();
2649       return result;
2650     } else {
2651       return NULL;
2652     }
2653   }
2654 };
2655 
2656 
2657 // ---------------------------------------------------------------------------
2658 // Implementation of AdapterHandlerLibrary
2659 AdapterHandlerTable* AdapterHandlerLibrary::_adapters = NULL;
2660 AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = NULL;
<span class="line-modified">2661 const int AdapterHandlerLibrary_size = 32*K;</span>
2662 BufferBlob* AdapterHandlerLibrary::_buffer = NULL;
2663 
2664 BufferBlob* AdapterHandlerLibrary::buffer_blob() {
2665   // Should be called only when AdapterHandlerLibrary_lock is active.
2666   if (_buffer == NULL) // Initialize lazily
2667       _buffer = BufferBlob::create(&quot;adapters&quot;, AdapterHandlerLibrary_size);
2668   return _buffer;
2669 }
2670 
2671 extern &quot;C&quot; void unexpected_adapter_call() {
2672   ShouldNotCallThis();
2673 }
2674 
2675 void AdapterHandlerLibrary::initialize() {
2676   if (_adapters != NULL) return;
2677   _adapters = new AdapterHandlerTable();
2678 
2679   // Create a special handler for abstract methods.  Abstract methods
2680   // are never compiled so an i2c entry is somewhat meaningless, but
2681   // throw AbstractMethodError just in case.
2682   // Pass wrong_method_abstract for the c2i transitions to return
2683   // AbstractMethodError for invalid invocations.
2684   address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();
<span class="line-modified">2685   _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),</span>
2686                                                               StubRoutines::throw_AbstractMethodError_entry(),
<span class="line-added">2687                                                               wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,</span>
2688                                                               wrong_method_abstract, wrong_method_abstract);
2689 }
2690 
2691 AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint,
2692                                                       address i2c_entry,
2693                                                       address c2i_entry,
<span class="line-added">2694                                                       address c2i_value_entry,</span>
<span class="line-added">2695                                                       address c2i_value_ro_entry,</span>
2696                                                       address c2i_unverified_entry,
<span class="line-added">2697                                                       address c2i_unverified_value_entry,</span>
2698                                                       address c2i_no_clinit_check_entry) {
<span class="line-modified">2699   return _adapters-&gt;new_entry(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry, c2i_unverified_entry,</span>
<span class="line-added">2700                               c2i_unverified_value_entry, c2i_no_clinit_check_entry);</span>
<span class="line-added">2701 }</span>
<span class="line-added">2702 </span>
<span class="line-added">2703 static void generate_trampoline(address trampoline, address destination) {</span>
<span class="line-added">2704   if (*(int*)trampoline == 0) {</span>
<span class="line-added">2705     CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());</span>
<span class="line-added">2706     MacroAssembler _masm(&amp;buffer);</span>
<span class="line-added">2707     SharedRuntime::generate_trampoline(&amp;_masm, destination);</span>
<span class="line-added">2708     assert(*(int*)trampoline != 0, &quot;Instruction(s) for trampoline must not be encoded as zeros.&quot;);</span>
<span class="line-added">2709       _masm.flush();</span>
<span class="line-added">2710 </span>
<span class="line-added">2711     if (PrintInterpreter) {</span>
<span class="line-added">2712       Disassembler::decode(buffer.insts_begin(), buffer.insts_end());</span>
<span class="line-added">2713     }</span>
<span class="line-added">2714   }</span>
2715 }
2716 
2717 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(const methodHandle&amp; method) {
2718   AdapterHandlerEntry* entry = get_adapter0(method);
2719   if (entry != NULL &amp;&amp; method-&gt;is_shared()) {
2720     // See comments around Method::link_method()
2721     MutexLocker mu(AdapterHandlerLibrary_lock);
2722     if (method-&gt;adapter() == NULL) {
2723       method-&gt;update_adapter_trampoline(entry);
2724     }
<span class="line-modified">2725     generate_trampoline(method-&gt;from_compiled_entry(),          entry-&gt;get_c2i_entry());</span>
<span class="line-modified">2726     generate_trampoline(method-&gt;from_compiled_value_ro_entry(), entry-&gt;get_c2i_value_ro_entry());</span>
<span class="line-modified">2727     generate_trampoline(method-&gt;from_compiled_value_entry(),    entry-&gt;get_c2i_value_entry());</span>
<span class="line-modified">2728   }</span>
<span class="line-modified">2729 </span>
<span class="line-modified">2730   return entry;</span>
<span class="line-modified">2731 }</span>
<span class="line-added">2732 </span>
2733 
<span class="line-modified">2734 CompiledEntrySignature::CompiledEntrySignature(Method* method) :</span>
<span class="line-modified">2735   _method(method), _num_value_args(0), _has_value_recv(false),</span>
<span class="line-added">2736   _sig_cc(NULL), _sig_cc_ro(NULL), _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),</span>
<span class="line-added">2737   _args_on_stack(0), _args_on_stack_cc(0), _args_on_stack_cc_ro(0),</span>
<span class="line-added">2738   _c1_needs_stack_repair(false), _c2_needs_stack_repair(false), _has_scalarized_args(false) {</span>
<span class="line-added">2739   _has_reserved_entries = false;</span>
<span class="line-added">2740   _sig = new GrowableArray&lt;SigEntry&gt;(method-&gt;size_of_parameters());</span>
<span class="line-added">2741 </span>
<span class="line-added">2742 }</span>
<span class="line-added">2743 </span>
<span class="line-added">2744 int CompiledEntrySignature::compute_scalarized_cc(GrowableArray&lt;SigEntry&gt;*&amp; sig_cc, VMRegPair*&amp; regs_cc, bool scalar_receiver) {</span>
<span class="line-added">2745   InstanceKlass* holder = _method-&gt;method_holder();</span>
<span class="line-added">2746   sig_cc = new GrowableArray&lt;SigEntry&gt;(_method-&gt;size_of_parameters());</span>
<span class="line-added">2747   if (!_method-&gt;is_static()) {</span>
<span class="line-added">2748     if (holder-&gt;is_value() &amp;&amp; scalar_receiver &amp;&amp; ValueKlass::cast(holder)-&gt;is_scalarizable()) {</span>
<span class="line-added">2749       sig_cc-&gt;appendAll(ValueKlass::cast(holder)-&gt;extended_sig());</span>
<span class="line-added">2750     } else {</span>
<span class="line-added">2751       SigEntry::add_entry(sig_cc, T_OBJECT);</span>
<span class="line-added">2752     }</span>
<span class="line-added">2753   }</span>
<span class="line-added">2754   Thread* THREAD = Thread::current();</span>
<span class="line-added">2755   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">2756     if (ss.type() == T_VALUETYPE) {</span>
<span class="line-added">2757       ValueKlass* vk = ss.as_value_klass(holder);</span>
<span class="line-added">2758       if (vk-&gt;is_scalarizable()) {</span>
<span class="line-added">2759         sig_cc-&gt;appendAll(vk-&gt;extended_sig());</span>
<span class="line-added">2760       } else {</span>
<span class="line-added">2761         SigEntry::add_entry(sig_cc, T_OBJECT);</span>
2762       }
<span class="line-added">2763     } else {</span>
<span class="line-added">2764       SigEntry::add_entry(sig_cc, ss.type());</span>
2765     }
2766   }
<span class="line-added">2767   regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, sig_cc-&gt;length() + 2);</span>
<span class="line-added">2768   return SharedRuntime::java_calling_convention(sig_cc, regs_cc);</span>
<span class="line-added">2769 }</span>
2770 
<span class="line-modified">2771 int CompiledEntrySignature::insert_reserved_entry(int ret_off) {</span>
<span class="line-added">2772   // Find index in signature that belongs to return address slot</span>
<span class="line-added">2773   BasicType bt = T_ILLEGAL;</span>
<span class="line-added">2774   int i = 0;</span>
<span class="line-added">2775   for (uint off = 0; i &lt; _sig_cc-&gt;length(); ++i) {</span>
<span class="line-added">2776     if (SigEntry::skip_value_delimiters(_sig_cc, i)) {</span>
<span class="line-added">2777       VMReg first = _regs_cc[off++].first();</span>
<span class="line-added">2778       if (first-&gt;is_valid() &amp;&amp; first-&gt;is_stack()) {</span>
<span class="line-added">2779         // Select a type for the reserved entry that will end up on the stack</span>
<span class="line-added">2780         bt = _sig_cc-&gt;at(i)._bt;</span>
<span class="line-added">2781         if (((int)first-&gt;reg2stack() + VMRegImpl::slots_per_word) == ret_off) {</span>
<span class="line-added">2782           break; // Index of the return address found</span>
<span class="line-added">2783         }</span>
<span class="line-added">2784       }</span>
<span class="line-added">2785     }</span>
<span class="line-added">2786   }</span>
<span class="line-added">2787   // Insert reserved entry and re-compute calling convention</span>
<span class="line-added">2788   SigEntry::insert_reserved_entry(_sig_cc, i, bt);</span>
<span class="line-added">2789   return SharedRuntime::java_calling_convention(_sig_cc, _regs_cc);</span>
<span class="line-added">2790 }</span>
<span class="line-added">2791 </span>
<span class="line-added">2792 // See if we can save space by sharing the same entry for VVEP and VVEP(RO),</span>
<span class="line-added">2793 // or the same entry for VEP and VVEP(RO).</span>
<span class="line-added">2794 CodeOffsets::Entries CompiledEntrySignature::c1_value_ro_entry_type() const {</span>
<span class="line-added">2795   if (!has_scalarized_args()) {</span>
<span class="line-added">2796     // VEP/VVEP/VVEP(RO) all share the same entry. There&#39;s no packing.</span>
<span class="line-added">2797     return CodeOffsets::Verified_Entry;</span>
<span class="line-added">2798   }</span>
<span class="line-added">2799   if (_method-&gt;is_static()) {</span>
<span class="line-added">2800     // Static methods don&#39;t need VVEP(RO)</span>
<span class="line-added">2801     return CodeOffsets::Verified_Entry;</span>
<span class="line-added">2802   }</span>
<span class="line-added">2803 </span>
<span class="line-added">2804   if (has_value_recv()) {</span>
<span class="line-added">2805     if (num_value_args() == 1) {</span>
<span class="line-added">2806       // Share same entry for VVEP and VVEP(RO).</span>
<span class="line-added">2807       // This is quite common: we have an instance method in a ValueKlass that has</span>
<span class="line-added">2808       // no value args other than &lt;this&gt;.</span>
<span class="line-added">2809       return CodeOffsets::Verified_Value_Entry;</span>
<span class="line-added">2810     } else {</span>
<span class="line-added">2811       assert(num_value_args() &gt; 1, &quot;must be&quot;);</span>
<span class="line-added">2812       // No sharing:</span>
<span class="line-added">2813       //   VVEP(RO) -- &lt;this&gt; is passed as object</span>
<span class="line-added">2814       //   VEP      -- &lt;this&gt; is passed as fields</span>
<span class="line-added">2815       return CodeOffsets::Verified_Value_Entry_RO;</span>
<span class="line-added">2816     }</span>
<span class="line-added">2817   }</span>
<span class="line-added">2818 </span>
<span class="line-added">2819   // Either a static method, or &lt;this&gt; is not a value type</span>
<span class="line-added">2820   if (args_on_stack_cc() != args_on_stack_cc_ro() || _has_reserved_entries) {</span>
<span class="line-added">2821     // No sharing:</span>
<span class="line-added">2822     // Some arguments are passed on the stack, and we have inserted reserved entries</span>
<span class="line-added">2823     // into the VEP, but we never insert reserved entries into the VVEP(RO).</span>
<span class="line-added">2824     return CodeOffsets::Verified_Value_Entry_RO;</span>
<span class="line-added">2825   } else {</span>
<span class="line-added">2826     // Share same entry for VEP and VVEP(RO).</span>
<span class="line-added">2827     return CodeOffsets::Verified_Entry;</span>
<span class="line-added">2828   }</span>
<span class="line-added">2829 }</span>
<span class="line-added">2830 </span>
<span class="line-added">2831 </span>
<span class="line-added">2832 void CompiledEntrySignature::compute_calling_conventions() {</span>
<span class="line-added">2833   // Get the (non-scalarized) signature and check for value type arguments</span>
<span class="line-added">2834   if (!_method-&gt;is_static()) {</span>
<span class="line-added">2835     if (_method-&gt;method_holder()-&gt;is_value() &amp;&amp; ValueKlass::cast(_method-&gt;method_holder())-&gt;is_scalarizable()) {</span>
<span class="line-added">2836       _has_value_recv = true;</span>
<span class="line-added">2837       _num_value_args++;</span>
<span class="line-added">2838     }</span>
<span class="line-added">2839     SigEntry::add_entry(_sig, T_OBJECT);</span>
<span class="line-added">2840   }</span>
<span class="line-added">2841   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">2842     BasicType bt = ss.type();</span>
<span class="line-added">2843     if (bt == T_VALUETYPE) {</span>
<span class="line-added">2844       if (ss.as_value_klass(_method-&gt;method_holder())-&gt;is_scalarizable()) {</span>
<span class="line-added">2845         _num_value_args++;</span>
<span class="line-added">2846       }</span>
<span class="line-added">2847       bt = T_OBJECT;</span>
<span class="line-added">2848     }</span>
<span class="line-added">2849     SigEntry::add_entry(_sig, bt);</span>
<span class="line-added">2850   }</span>
<span class="line-added">2851   if (_method-&gt;is_abstract() &amp;&amp; !(ValueTypePassFieldsAsArgs &amp;&amp; has_value_arg())) {</span>
<span class="line-added">2852     return;</span>
<span class="line-added">2853   }</span>
<span class="line-added">2854 </span>
<span class="line-added">2855   // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage</span>
<span class="line-added">2856   _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig-&gt;length());</span>
<span class="line-added">2857   _args_on_stack = SharedRuntime::java_calling_convention(_sig, _regs);</span>
<span class="line-added">2858 </span>
<span class="line-added">2859   // Now compute the scalarized calling convention if there are value types in the signature</span>
<span class="line-added">2860   _sig_cc = _sig;</span>
<span class="line-added">2861   _sig_cc_ro = _sig;</span>
<span class="line-added">2862   _regs_cc = _regs;</span>
<span class="line-added">2863   _regs_cc_ro = _regs;</span>
<span class="line-added">2864   _args_on_stack_cc = _args_on_stack;</span>
<span class="line-added">2865   _args_on_stack_cc_ro = _args_on_stack;</span>
<span class="line-added">2866 </span>
<span class="line-added">2867   if (ValueTypePassFieldsAsArgs &amp;&amp; has_value_arg() &amp;&amp; !_method-&gt;is_native()) {</span>
<span class="line-added">2868     _args_on_stack_cc = compute_scalarized_cc(_sig_cc, _regs_cc, /* scalar_receiver = */ true);</span>
<span class="line-added">2869 </span>
<span class="line-added">2870     _sig_cc_ro = _sig_cc;</span>
<span class="line-added">2871     _regs_cc_ro = _regs_cc;</span>
<span class="line-added">2872     _args_on_stack_cc_ro = _args_on_stack_cc;</span>
<span class="line-added">2873     if (_has_value_recv || _args_on_stack_cc &gt; _args_on_stack) {</span>
<span class="line-added">2874       // For interface calls, we need another entry point / adapter to unpack the receiver</span>
<span class="line-added">2875       _args_on_stack_cc_ro = compute_scalarized_cc(_sig_cc_ro, _regs_cc_ro, /* scalar_receiver = */ false);</span>
<span class="line-added">2876     }</span>
<span class="line-added">2877 </span>
<span class="line-added">2878     // Compute the stack extension that is required to convert between the calling conventions.</span>
<span class="line-added">2879     // The stack slots at these offsets are occupied by the return address with the unscalarized</span>
<span class="line-added">2880     // calling convention. Don&#39;t use them for arguments with the scalarized calling convention.</span>
<span class="line-added">2881     int ret_off    = _args_on_stack_cc - _args_on_stack;</span>
<span class="line-added">2882     int ret_off_ro = _args_on_stack_cc - _args_on_stack_cc_ro;</span>
<span class="line-added">2883     assert(ret_off_ro &lt;= 0 || ret_off &gt; 0, &quot;receiver unpacking requires more stack space than expected&quot;);</span>
<span class="line-added">2884 </span>
<span class="line-added">2885     if (ret_off &gt; 0) {</span>
<span class="line-added">2886       // Make sure the stack of the scalarized calling convention with the reserved</span>
<span class="line-added">2887       // entries (2 slots each) remains 16-byte (4 slots) aligned after stack extension.</span>
<span class="line-added">2888       int alignment = StackAlignmentInBytes / VMRegImpl::stack_slot_size;</span>
<span class="line-added">2889       if (ret_off_ro != ret_off &amp;&amp; ret_off_ro &gt;= 0) {</span>
<span class="line-added">2890         ret_off    += 4; // Account for two reserved entries (4 slots)</span>
<span class="line-added">2891         ret_off_ro += 4;</span>
<span class="line-added">2892         ret_off     = align_up(ret_off, alignment);</span>
<span class="line-added">2893         ret_off_ro  = align_up(ret_off_ro, alignment);</span>
<span class="line-added">2894         // TODO can we avoid wasting a stack slot here?</span>
<span class="line-added">2895         //assert(ret_off != ret_off_ro, &quot;fail&quot;);</span>
<span class="line-added">2896         if (ret_off &gt; ret_off_ro) {</span>
<span class="line-added">2897           swap(ret_off, ret_off_ro); // Sort by offset</span>
<span class="line-added">2898         }</span>
<span class="line-added">2899         _args_on_stack_cc = insert_reserved_entry(ret_off);</span>
<span class="line-added">2900         _args_on_stack_cc = insert_reserved_entry(ret_off_ro);</span>
<span class="line-added">2901       } else {</span>
<span class="line-added">2902         ret_off += 2; // Account for one reserved entry (2 slots)</span>
<span class="line-added">2903         ret_off = align_up(ret_off, alignment);</span>
<span class="line-added">2904         _args_on_stack_cc = insert_reserved_entry(ret_off);</span>
<span class="line-added">2905       }</span>
<span class="line-added">2906 </span>
<span class="line-added">2907       _has_reserved_entries = true;</span>
<span class="line-added">2908     }</span>
<span class="line-added">2909 </span>
<span class="line-added">2910     // Upper bound on stack arguments to avoid hitting the argument limit and</span>
<span class="line-added">2911     // bailing out of compilation (&quot;unsupported incoming calling sequence&quot;).</span>
<span class="line-added">2912     // TODO we need a reasonable limit (flag?) here</span>
<span class="line-added">2913     if (_args_on_stack_cc &gt; 50) {</span>
<span class="line-added">2914       // Don&#39;t scalarize value type arguments</span>
<span class="line-added">2915       _sig_cc = _sig;</span>
<span class="line-added">2916       _sig_cc_ro = _sig;</span>
<span class="line-added">2917       _regs_cc = _regs;</span>
<span class="line-added">2918       _regs_cc_ro = _regs;</span>
<span class="line-added">2919       _args_on_stack_cc = _args_on_stack;</span>
<span class="line-added">2920       _args_on_stack_cc_ro = _args_on_stack;</span>
<span class="line-added">2921     } else {</span>
<span class="line-added">2922       _c1_needs_stack_repair = (_args_on_stack_cc &lt; _args_on_stack) || (_args_on_stack_cc_ro &lt; _args_on_stack);</span>
<span class="line-added">2923       _c2_needs_stack_repair = (_args_on_stack_cc &gt; _args_on_stack) || (_args_on_stack_cc &gt; _args_on_stack_cc_ro);</span>
<span class="line-added">2924       _has_scalarized_args = true;</span>
<span class="line-added">2925     }</span>
<span class="line-added">2926   }</span>
2927 }
2928 
2929 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter0(const methodHandle&amp; method) {
2930   // Use customized signature handler.  Need to lock around updates to
2931   // the AdapterHandlerTable (it is not safe for concurrent readers
2932   // and a single writer: this could be fixed if it becomes a
2933   // problem).
2934 
2935   ResourceMark rm;
2936 
<span class="line-modified">2937   NOT_PRODUCT(int insts_size = 0);</span>
2938   AdapterBlob* new_adapter = NULL;
2939   AdapterHandlerEntry* entry = NULL;
2940   AdapterFingerPrint* fingerprint = NULL;
<span class="line-added">2941 </span>
2942   {
2943     MutexLocker mu(AdapterHandlerLibrary_lock);
2944     // make sure data structure is initialized
2945     initialize();
2946 
<span class="line-modified">2947     CompiledEntrySignature ces(method());</span>
<span class="line-modified">2948     {</span>
<span class="line-added">2949        MutexUnlocker mul(AdapterHandlerLibrary_lock);</span>
<span class="line-added">2950        ces.compute_calling_conventions();</span>
2951     }
<span class="line-added">2952     GrowableArray&lt;SigEntry&gt;&amp; sig       = ces.sig();</span>
<span class="line-added">2953     GrowableArray&lt;SigEntry&gt;&amp; sig_cc    = ces.sig_cc();</span>
<span class="line-added">2954     GrowableArray&lt;SigEntry&gt;&amp; sig_cc_ro = ces.sig_cc_ro();</span>
<span class="line-added">2955     VMRegPair* regs         = ces.regs();</span>
<span class="line-added">2956     VMRegPair* regs_cc      = ces.regs_cc();</span>
<span class="line-added">2957     VMRegPair* regs_cc_ro   = ces.regs_cc_ro();</span>
2958 
<span class="line-modified">2959     if (ces.has_scalarized_args()) {</span>
<span class="line-modified">2960       method-&gt;set_has_scalarized_args(true);</span>
<span class="line-added">2961       method-&gt;set_c1_needs_stack_repair(ces.c1_needs_stack_repair());</span>
<span class="line-added">2962       method-&gt;set_c2_needs_stack_repair(ces.c2_needs_stack_repair());</span>
<span class="line-added">2963     }</span>
2964 
<span class="line-modified">2965     if (method-&gt;is_abstract()) {</span>
<span class="line-modified">2966       if (ces.has_scalarized_args()) {</span>
<span class="line-modified">2967         // Save a C heap allocated version of the signature for abstract methods with scalarized value type arguments</span>
<span class="line-modified">2968         address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();</span>
<span class="line-modified">2969         entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),</span>
<span class="line-modified">2970                                                  StubRoutines::throw_AbstractMethodError_entry(),</span>
<span class="line-modified">2971                                                  wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,</span>
<span class="line-modified">2972                                                  wrong_method_abstract, wrong_method_abstract);</span>
<span class="line-modified">2973         GrowableArray&lt;SigEntry&gt;* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;SigEntry&gt;(sig_cc_ro.length(), true);</span>
<span class="line-added">2974         heap_sig-&gt;appendAll(&amp;sig_cc_ro);</span>
<span class="line-added">2975         entry-&gt;set_sig_cc(heap_sig);</span>
<span class="line-added">2976         return entry;</span>
<span class="line-added">2977       } else {</span>
<span class="line-added">2978         return _abstract_method_handler;</span>
<span class="line-added">2979       }</span>
2980     }

2981 
2982     // Lookup method signature&#39;s fingerprint
<span class="line-modified">2983     entry = _adapters-&gt;lookup(&amp;sig_cc, regs_cc != regs_cc_ro);</span>
2984 
2985 #ifdef ASSERT
2986     AdapterHandlerEntry* shared_entry = NULL;
2987     // Start adapter sharing verification only after the VM is booted.
2988     if (VerifyAdapterSharing &amp;&amp; (entry != NULL)) {
2989       shared_entry = entry;
2990       entry = NULL;
2991     }
2992 #endif
2993 
2994     if (entry != NULL) {
2995       return entry;
2996     }
2997 
<span class="line-modified">2998     // Make a C heap allocated version of the fingerprint to store in the adapter</span>



2999     fingerprint = new AdapterFingerPrint(&amp;sig_cc, regs_cc != regs_cc_ro);
3000 
3001     // StubRoutines::code2() is initialized after this function can be called. As a result,
3002     // VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated
3003     // prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C
3004     // stub that ensure that an I2C stub is called from an interpreter frame.
3005     bool contains_all_checks = StubRoutines::code2() != NULL;
3006 
3007     // Create I2C &amp; C2I handlers
3008     BufferBlob* buf = buffer_blob(); // the temporary code buffer in CodeCache
3009     if (buf != NULL) {
3010       CodeBuffer buffer(buf);
3011       short buffer_locs[20];
3012       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3013                                              sizeof(buffer_locs)/sizeof(relocInfo));
3014 
3015       MacroAssembler _masm(&amp;buffer);
3016       entry = SharedRuntime::generate_i2c2i_adapters(&amp;_masm,
<span class="line-modified">3017                                                      ces.args_on_stack(),</span>
<span class="line-modified">3018                                                      &amp;sig,</span>

3019                                                      regs,
<span class="line-modified">3020                                                      &amp;sig_cc,</span>
<span class="line-added">3021                                                      regs_cc,</span>
<span class="line-added">3022                                                      &amp;sig_cc_ro,</span>
<span class="line-added">3023                                                      regs_cc_ro,</span>
<span class="line-added">3024                                                      fingerprint,</span>
<span class="line-added">3025                                                      new_adapter);</span>
<span class="line-added">3026 </span>
<span class="line-added">3027       if (ces.has_scalarized_args()) {</span>
<span class="line-added">3028         // Save a C heap allocated version of the scalarized signature and store it in the adapter</span>
<span class="line-added">3029         GrowableArray&lt;SigEntry&gt;* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;SigEntry&gt;(sig_cc.length(), true);</span>
<span class="line-added">3030         heap_sig-&gt;appendAll(&amp;sig_cc);</span>
<span class="line-added">3031         entry-&gt;set_sig_cc(heap_sig);</span>
<span class="line-added">3032       }</span>
<span class="line-added">3033 </span>
3034 #ifdef ASSERT
3035       if (VerifyAdapterSharing) {
3036         if (shared_entry != NULL) {
<span class="line-added">3037           if (!shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size())) {</span>
<span class="line-added">3038             method-&gt;print();</span>
<span class="line-added">3039           }</span>
3040           assert(shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size()), &quot;code must match&quot;);
3041           // Release the one just created and return the original
3042           _adapters-&gt;free_entry(entry);
3043           return shared_entry;
3044         } else  {
3045           entry-&gt;save_code(buf-&gt;code_begin(), buffer.insts_size());
3046         }
3047       }
3048 #endif
3049 

3050       NOT_PRODUCT(insts_size = buffer.insts_size());
3051     }
3052     if (new_adapter == NULL) {
3053       // CodeCache is full, disable compilation
3054       // Ought to log this but compile log is only per compile thread
3055       // and we&#39;re some non descript Java thread.
3056       return NULL; // Out of CodeCache space
3057     }
3058     entry-&gt;relocate(new_adapter-&gt;content_begin());
3059 #ifndef PRODUCT
3060     // debugging suppport
3061     if (PrintAdapterHandlers || PrintStubCode) {
3062       ttyLocker ttyl;
3063       entry-&gt;print_adapter_on(tty);
3064       tty-&gt;print_cr(&quot;i2c argument handler #%d for: %s %s %s (%d bytes generated)&quot;,
3065                     _adapters-&gt;number_of_entries(), (method-&gt;is_static() ? &quot;static&quot; : &quot;receiver&quot;),
3066                     method-&gt;signature()-&gt;as_C_string(), fingerprint-&gt;as_string(), insts_size);
3067       tty-&gt;print_cr(&quot;c2i argument handler starts at %p&quot;, entry-&gt;get_c2i_entry());
3068       if (Verbose || PrintStubCode) {
3069         address first_pc = entry-&gt;base_address();
</pre>
<hr />
<pre>
3085     char blob_id[256];
3086     jio_snprintf(blob_id,
3087                  sizeof(blob_id),
3088                  &quot;%s(%s)@&quot; PTR_FORMAT,
3089                  new_adapter-&gt;name(),
3090                  fingerprint-&gt;as_string(),
3091                  new_adapter-&gt;content_begin());
3092     Forte::register_stub(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
3093 
3094     if (JvmtiExport::should_post_dynamic_code_generated()) {
3095       JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
3096     }
3097   }
3098   return entry;
3099 }
3100 
3101 address AdapterHandlerEntry::base_address() {
3102   address base = _i2c_entry;
3103   if (base == NULL)  base = _c2i_entry;
3104   assert(base &lt;= _c2i_entry || _c2i_entry == NULL, &quot;&quot;);
<span class="line-added">3105   assert(base &lt;= _c2i_value_entry || _c2i_value_entry == NULL, &quot;&quot;);</span>
<span class="line-added">3106   assert(base &lt;= _c2i_value_ro_entry || _c2i_value_ro_entry == NULL, &quot;&quot;);</span>
3107   assert(base &lt;= _c2i_unverified_entry || _c2i_unverified_entry == NULL, &quot;&quot;);
<span class="line-added">3108   assert(base &lt;= _c2i_unverified_value_entry || _c2i_unverified_value_entry == NULL, &quot;&quot;);</span>
3109   assert(base &lt;= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == NULL, &quot;&quot;);
3110   return base;
3111 }
3112 
3113 void AdapterHandlerEntry::relocate(address new_base) {
3114   address old_base = base_address();
3115   assert(old_base != NULL, &quot;&quot;);
3116   ptrdiff_t delta = new_base - old_base;
3117   if (_i2c_entry != NULL)
3118     _i2c_entry += delta;
3119   if (_c2i_entry != NULL)
3120     _c2i_entry += delta;
<span class="line-added">3121   if (_c2i_value_entry != NULL)</span>
<span class="line-added">3122     _c2i_value_entry += delta;</span>
<span class="line-added">3123   if (_c2i_value_ro_entry != NULL)</span>
<span class="line-added">3124     _c2i_value_ro_entry += delta;</span>
3125   if (_c2i_unverified_entry != NULL)
3126     _c2i_unverified_entry += delta;
<span class="line-added">3127   if (_c2i_unverified_value_entry != NULL)</span>
<span class="line-added">3128     _c2i_unverified_value_entry += delta;</span>
3129   if (_c2i_no_clinit_check_entry != NULL)
3130     _c2i_no_clinit_check_entry += delta;
3131   assert(base_address() == new_base, &quot;&quot;);
3132 }
3133 
3134 
3135 void AdapterHandlerEntry::deallocate() {
3136   delete _fingerprint;
<span class="line-added">3137   if (_sig_cc != NULL) {</span>
<span class="line-added">3138     delete _sig_cc;</span>
<span class="line-added">3139   }</span>
3140 #ifdef ASSERT
3141   FREE_C_HEAP_ARRAY(unsigned char, _saved_code);
3142 #endif
3143 }
3144 
3145 
3146 #ifdef ASSERT
3147 // Capture the code before relocation so that it can be compared
3148 // against other versions.  If the code is captured after relocation
3149 // then relative instructions won&#39;t be equivalent.
3150 void AdapterHandlerEntry::save_code(unsigned char* buffer, int length) {
3151   _saved_code = NEW_C_HEAP_ARRAY(unsigned char, length, mtCode);
3152   _saved_code_length = length;
3153   memcpy(_saved_code, buffer, length);
3154 }
3155 
3156 
3157 bool AdapterHandlerEntry::compare_code(unsigned char* buffer, int length) {
3158   if (length != _saved_code_length) {
3159     return false;
</pre>
<hr />
<pre>
3197 
3198 
3199     ResourceMark rm;
3200     BufferBlob*  buf = buffer_blob(); // the temporary code buffer in CodeCache
3201     if (buf != NULL) {
3202       CodeBuffer buffer(buf);
3203       double locs_buf[20];
3204       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)locs_buf, sizeof(locs_buf) / sizeof(relocInfo));
3205       MacroAssembler _masm(&amp;buffer);
3206 
3207       // Fill in the signature array, for the calling-convention call.
3208       const int total_args_passed = method-&gt;size_of_parameters();
3209 
3210       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);
3211       VMRegPair*   regs = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);
3212       int i=0;
3213       if (!method-&gt;is_static())  // Pass in receiver first
3214         sig_bt[i++] = T_OBJECT;
3215       SignatureStream ss(method-&gt;signature());
3216       for (; !ss.at_return_type(); ss.next()) {
<span class="line-modified">3217         BasicType bt = ss.type();</span>
<span class="line-added">3218         sig_bt[i++] = bt;  // Collect remaining bits of signature</span>
3219         if (ss.type() == T_LONG || ss.type() == T_DOUBLE)
3220           sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots
3221       }
3222       assert(i == total_args_passed, &quot;&quot;);
3223       BasicType ret_type = ss.type();
3224 
3225       // Now get the compiled-Java layout as input (or output) arguments.
3226       // NOTE: Stubs for compiled entry points of method handle intrinsics
3227       // are just trampolines so the argument registers must be outgoing ones.
3228       const bool is_outgoing = method-&gt;is_method_handle_intrinsic();
3229       int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, is_outgoing);
3230 
3231       // Generate the compiled-to-native wrapper code
3232       nm = SharedRuntime::generate_native_wrapper(&amp;_masm, method, compile_id, sig_bt, regs, ret_type, critical_entry);
3233 
3234       if (nm != NULL) {
3235         {
3236           MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
3237           if (nm-&gt;make_in_use()) {
3238             method-&gt;set_code(method, nm);
</pre>
<hr />
<pre>
3446   AdapterHandlerTableIterator iter(_adapters);
3447   while (iter.has_next()) {
3448     AdapterHandlerEntry* a = iter.next();
3449     if (b == CodeCache::find_blob(a-&gt;get_i2c_entry())) {
3450       st-&gt;print(&quot;Adapter for signature: &quot;);
3451       a-&gt;print_adapter_on(tty);
3452       return;
3453     }
3454   }
3455   assert(false, &quot;Should have found handler&quot;);
3456 }
3457 
3458 void AdapterHandlerEntry::print_adapter_on(outputStream* st) const {
3459   st-&gt;print(&quot;AHE@&quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(this), fingerprint()-&gt;as_string());
3460   if (get_i2c_entry() != NULL) {
3461     st-&gt;print(&quot; i2c: &quot; INTPTR_FORMAT, p2i(get_i2c_entry()));
3462   }
3463   if (get_c2i_entry() != NULL) {
3464     st-&gt;print(&quot; c2i: &quot; INTPTR_FORMAT, p2i(get_c2i_entry()));
3465   }
<span class="line-added">3466   if (get_c2i_entry() != NULL) {</span>
<span class="line-added">3467     st-&gt;print(&quot; c2iVE: &quot; INTPTR_FORMAT, p2i(get_c2i_value_entry()));</span>
<span class="line-added">3468   }</span>
<span class="line-added">3469   if (get_c2i_entry() != NULL) {</span>
<span class="line-added">3470     st-&gt;print(&quot; c2iVROE: &quot; INTPTR_FORMAT, p2i(get_c2i_value_ro_entry()));</span>
<span class="line-added">3471   }</span>
3472   if (get_c2i_unverified_entry() != NULL) {
<span class="line-modified">3473     st-&gt;print(&quot; c2iUE: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));</span>
<span class="line-added">3474   }</span>
<span class="line-added">3475   if (get_c2i_unverified_entry() != NULL) {</span>
<span class="line-added">3476     st-&gt;print(&quot; c2iUVE: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_value_entry()));</span>
3477   }
3478   if (get_c2i_no_clinit_check_entry() != NULL) {
3479     st-&gt;print(&quot; c2iNCI: &quot; INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));
3480   }
3481   st-&gt;cr();
3482 }
3483 
3484 #if INCLUDE_CDS
3485 
3486 void CDSAdapterHandlerEntry::init() {
3487   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
3488   _c2i_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());
<span class="line-added">3489   _c2i_value_ro_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());</span>
<span class="line-added">3490   _c2i_value_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());</span>
3491   _adapter_trampoline = (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*));
3492 };
3493 
3494 #endif // INCLUDE_CDS
3495 
3496 
3497 #ifndef PRODUCT
3498 
3499 void AdapterHandlerLibrary::print_statistics() {
3500   _adapters-&gt;print_statistics();
3501 }
3502 
3503 #endif /* PRODUCT */
3504 
3505 JRT_LEAF(void, SharedRuntime::enable_stack_reserved_zone(JavaThread* thread))
3506   assert(thread-&gt;is_Java_thread(), &quot;Only Java threads have a stack reserved zone&quot;);
3507   if (thread-&gt;stack_reserved_zone_disabled()) {
3508   thread-&gt;enable_stack_reserved_zone();
3509   }
3510   thread-&gt;set_reserved_stack_activation(thread-&gt;stack_base());
</pre>
<hr />
<pre>
3556       break;
3557     } else {
3558       fr = fr.java_sender();
3559     }
3560   }
3561   return activation;
3562 }
3563 
3564 void SharedRuntime::on_slowpath_allocation_exit(JavaThread* thread) {
3565   // After any safepoint, just before going back to compiled code,
3566   // we inform the GC that we will be doing initializing writes to
3567   // this object in the future without emitting card-marks, so
3568   // GC may take any compensating steps.
3569 
3570   oop new_obj = thread-&gt;vm_result();
3571   if (new_obj == NULL) return;
3572 
3573   BarrierSet *bs = BarrierSet::barrier_set();
3574   bs-&gt;on_slowpath_allocation_exit(thread, new_obj);
3575 }
<span class="line-added">3576 </span>
<span class="line-added">3577 // We are at a compiled code to interpreter call. We need backing</span>
<span class="line-added">3578 // buffers for all value type arguments. Allocate an object array to</span>
<span class="line-added">3579 // hold them (convenient because once we&#39;re done with it we don&#39;t have</span>
<span class="line-added">3580 // to worry about freeing it).</span>
<span class="line-added">3581 oop SharedRuntime::allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS) {</span>
<span class="line-added">3582   assert(ValueTypePassFieldsAsArgs, &quot;no reason to call this&quot;);</span>
<span class="line-added">3583   ResourceMark rm;</span>
<span class="line-added">3584 </span>
<span class="line-added">3585   int nb_slots = 0;</span>
<span class="line-added">3586   InstanceKlass* holder = callee-&gt;method_holder();</span>
<span class="line-added">3587   allocate_receiver &amp;= !callee-&gt;is_static() &amp;&amp; holder-&gt;is_value();</span>
<span class="line-added">3588   if (allocate_receiver) {</span>
<span class="line-added">3589     nb_slots++;</span>
<span class="line-added">3590   }</span>
<span class="line-added">3591   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">3592     if (ss.type() == T_VALUETYPE) {</span>
<span class="line-added">3593       nb_slots++;</span>
<span class="line-added">3594     }</span>
<span class="line-added">3595   }</span>
<span class="line-added">3596   objArrayOop array_oop = oopFactory::new_objectArray(nb_slots, CHECK_NULL);</span>
<span class="line-added">3597   objArrayHandle array(THREAD, array_oop);</span>
<span class="line-added">3598   int i = 0;</span>
<span class="line-added">3599   if (allocate_receiver) {</span>
<span class="line-added">3600     ValueKlass* vk = ValueKlass::cast(holder);</span>
<span class="line-added">3601     oop res = vk-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3602     array-&gt;obj_at_put(i, res);</span>
<span class="line-added">3603     i++;</span>
<span class="line-added">3604   }</span>
<span class="line-added">3605   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-added">3606     if (ss.type() == T_VALUETYPE) {</span>
<span class="line-added">3607       ValueKlass* vk = ss.as_value_klass(holder);</span>
<span class="line-added">3608       oop res = vk-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">3609       array-&gt;obj_at_put(i, res);</span>
<span class="line-added">3610       i++;</span>
<span class="line-added">3611     }</span>
<span class="line-added">3612   }</span>
<span class="line-added">3613   return array();</span>
<span class="line-added">3614 }</span>
<span class="line-added">3615 </span>
<span class="line-added">3616 JRT_ENTRY(void, SharedRuntime::allocate_value_types(JavaThread* thread, Method* callee_method, bool allocate_receiver))</span>
<span class="line-added">3617   methodHandle callee(thread, callee_method);</span>
<span class="line-added">3618   oop array = SharedRuntime::allocate_value_types_impl(thread, callee, allocate_receiver, CHECK);</span>
<span class="line-added">3619   thread-&gt;set_vm_result(array);</span>
<span class="line-added">3620   thread-&gt;set_vm_result_2(callee()); // TODO: required to keep callee live?</span>
<span class="line-added">3621 JRT_END</span>
<span class="line-added">3622 </span>
<span class="line-added">3623 // TODO remove this once the AARCH64 dependency is gone</span>
<span class="line-added">3624 // Iterate over the array of heap allocated value types and apply the GC post barrier to all reference fields.</span>
<span class="line-added">3625 // This is called from the C2I adapter after value type arguments are heap allocated and initialized.</span>
<span class="line-added">3626 JRT_LEAF(void, SharedRuntime::apply_post_barriers(JavaThread* thread, objArrayOopDesc* array))</span>
<span class="line-added">3627 {</span>
<span class="line-added">3628   assert(ValueTypePassFieldsAsArgs, &quot;no reason to call this&quot;);</span>
<span class="line-added">3629   assert(oopDesc::is_oop(array), &quot;should be oop&quot;);</span>
<span class="line-added">3630   for (int i = 0; i &lt; array-&gt;length(); ++i) {</span>
<span class="line-added">3631     instanceOop valueOop = (instanceOop)array-&gt;obj_at(i);</span>
<span class="line-added">3632     ValueKlass* vk = ValueKlass::cast(valueOop-&gt;klass());</span>
<span class="line-added">3633     if (vk-&gt;contains_oops()) {</span>
<span class="line-added">3634       const address dst_oop_addr = ((address) (void*) valueOop);</span>
<span class="line-added">3635       OopMapBlock* map = vk-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">3636       OopMapBlock* const end = map + vk-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">3637       while (map != end) {</span>
<span class="line-added">3638         address doop_address = dst_oop_addr + map-&gt;offset();</span>
<span class="line-added">3639         barrier_set_cast&lt;ModRefBarrierSet&gt;(BarrierSet::barrier_set())-&gt;</span>
<span class="line-added">3640           write_ref_array((HeapWord*) doop_address, map-&gt;count());</span>
<span class="line-added">3641         map++;</span>
<span class="line-added">3642       }</span>
<span class="line-added">3643     }</span>
<span class="line-added">3644   }</span>
<span class="line-added">3645 }</span>
<span class="line-added">3646 JRT_END</span>
<span class="line-added">3647 </span>
<span class="line-added">3648 // We&#39;re returning from an interpreted method: load each field into a</span>
<span class="line-added">3649 // register following the calling convention</span>
<span class="line-added">3650 JRT_LEAF(void, SharedRuntime::load_value_type_fields_in_regs(JavaThread* thread, oopDesc* res))</span>
<span class="line-added">3651 {</span>
<span class="line-added">3652   assert(res-&gt;klass()-&gt;is_value(), &quot;only value types here&quot;);</span>
<span class="line-added">3653   ResourceMark rm;</span>
<span class="line-added">3654   RegisterMap reg_map(thread);</span>
<span class="line-added">3655   frame stubFrame = thread-&gt;last_frame();</span>
<span class="line-added">3656   frame callerFrame = stubFrame.sender(&amp;reg_map);</span>
<span class="line-added">3657   assert(callerFrame.is_interpreted_frame(), &quot;should be coming from interpreter&quot;);</span>
<span class="line-added">3658 </span>
<span class="line-added">3659   ValueKlass* vk = ValueKlass::cast(res-&gt;klass());</span>
<span class="line-added">3660 </span>
<span class="line-added">3661   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();</span>
<span class="line-added">3662   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();</span>
<span class="line-added">3663 </span>
<span class="line-added">3664   if (regs == NULL) {</span>
<span class="line-added">3665     // The fields of the value klass don&#39;t fit in registers, bail out</span>
<span class="line-added">3666     return;</span>
<span class="line-added">3667   }</span>
<span class="line-added">3668 </span>
<span class="line-added">3669   int j = 1;</span>
<span class="line-added">3670   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {</span>
<span class="line-added">3671     BasicType bt = sig_vk-&gt;at(i)._bt;</span>
<span class="line-added">3672     if (bt == T_VALUETYPE) {</span>
<span class="line-added">3673       continue;</span>
<span class="line-added">3674     }</span>
<span class="line-added">3675     if (bt == T_VOID) {</span>
<span class="line-added">3676       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||</span>
<span class="line-added">3677           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {</span>
<span class="line-added">3678         j++;</span>
<span class="line-added">3679       }</span>
<span class="line-added">3680       continue;</span>
<span class="line-added">3681     }</span>
<span class="line-added">3682     int off = sig_vk-&gt;at(i)._offset;</span>
<span class="line-added">3683     assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="line-added">3684     VMRegPair pair = regs-&gt;at(j);</span>
<span class="line-added">3685     address loc = reg_map.location(pair.first());</span>
<span class="line-added">3686     switch(bt) {</span>
<span class="line-added">3687     case T_BOOLEAN:</span>
<span class="line-added">3688       *(jboolean*)loc = res-&gt;bool_field(off);</span>
<span class="line-added">3689       break;</span>
<span class="line-added">3690     case T_CHAR:</span>
<span class="line-added">3691       *(jchar*)loc = res-&gt;char_field(off);</span>
<span class="line-added">3692       break;</span>
<span class="line-added">3693     case T_BYTE:</span>
<span class="line-added">3694       *(jbyte*)loc = res-&gt;byte_field(off);</span>
<span class="line-added">3695       break;</span>
<span class="line-added">3696     case T_SHORT:</span>
<span class="line-added">3697       *(jshort*)loc = res-&gt;short_field(off);</span>
<span class="line-added">3698       break;</span>
<span class="line-added">3699     case T_INT: {</span>
<span class="line-added">3700       *(jint*)loc = res-&gt;int_field(off);</span>
<span class="line-added">3701       break;</span>
<span class="line-added">3702     }</span>
<span class="line-added">3703     case T_LONG:</span>
<span class="line-added">3704 #ifdef _LP64</span>
<span class="line-added">3705       *(intptr_t*)loc = res-&gt;long_field(off);</span>
<span class="line-added">3706 #else</span>
<span class="line-added">3707       Unimplemented();</span>
<span class="line-added">3708 #endif</span>
<span class="line-added">3709       break;</span>
<span class="line-added">3710     case T_OBJECT:</span>
<span class="line-added">3711     case T_ARRAY: {</span>
<span class="line-added">3712       *(oop*)loc = res-&gt;obj_field(off);</span>
<span class="line-added">3713       break;</span>
<span class="line-added">3714     }</span>
<span class="line-added">3715     case T_FLOAT:</span>
<span class="line-added">3716       *(jfloat*)loc = res-&gt;float_field(off);</span>
<span class="line-added">3717       break;</span>
<span class="line-added">3718     case T_DOUBLE:</span>
<span class="line-added">3719       *(jdouble*)loc = res-&gt;double_field(off);</span>
<span class="line-added">3720       break;</span>
<span class="line-added">3721     default:</span>
<span class="line-added">3722       ShouldNotReachHere();</span>
<span class="line-added">3723     }</span>
<span class="line-added">3724     j++;</span>
<span class="line-added">3725   }</span>
<span class="line-added">3726   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);</span>
<span class="line-added">3727 </span>
<span class="line-added">3728 #ifdef ASSERT</span>
<span class="line-added">3729   VMRegPair pair = regs-&gt;at(0);</span>
<span class="line-added">3730   address loc = reg_map.location(pair.first());</span>
<span class="line-added">3731   assert(*(oopDesc**)loc == res, &quot;overwritten object&quot;);</span>
<span class="line-added">3732 #endif</span>
<span class="line-added">3733 </span>
<span class="line-added">3734   thread-&gt;set_vm_result(res);</span>
<span class="line-added">3735 }</span>
<span class="line-added">3736 JRT_END</span>
<span class="line-added">3737 </span>
<span class="line-added">3738 // We&#39;ve returned to an interpreted method, the interpreter needs a</span>
<span class="line-added">3739 // reference to a value type instance. Allocate it and initialize it</span>
<span class="line-added">3740 // from field&#39;s values in registers.</span>
<span class="line-added">3741 JRT_BLOCK_ENTRY(void, SharedRuntime::store_value_type_fields_to_buf(JavaThread* thread, intptr_t res))</span>
<span class="line-added">3742 {</span>
<span class="line-added">3743   ResourceMark rm;</span>
<span class="line-added">3744   RegisterMap reg_map(thread);</span>
<span class="line-added">3745   frame stubFrame = thread-&gt;last_frame();</span>
<span class="line-added">3746   frame callerFrame = stubFrame.sender(&amp;reg_map);</span>
<span class="line-added">3747 </span>
<span class="line-added">3748 #ifdef ASSERT</span>
<span class="line-added">3749   ValueKlass* verif_vk = ValueKlass::returned_value_klass(reg_map);</span>
<span class="line-added">3750 #endif</span>
<span class="line-added">3751 </span>
<span class="line-added">3752   if (!is_set_nth_bit(res, 0)) {</span>
<span class="line-added">3753     // We&#39;re not returning with value type fields in registers (the</span>
<span class="line-added">3754     // calling convention didn&#39;t allow it for this value klass)</span>
<span class="line-added">3755     assert(!Metaspace::contains((void*)res), &quot;should be oop or pointer in buffer area&quot;);</span>
<span class="line-added">3756     thread-&gt;set_vm_result((oopDesc*)res);</span>
<span class="line-added">3757     assert(verif_vk == NULL, &quot;broken calling convention&quot;);</span>
<span class="line-added">3758     return;</span>
<span class="line-added">3759   }</span>
<span class="line-added">3760 </span>
<span class="line-added">3761   clear_nth_bit(res, 0);</span>
<span class="line-added">3762   ValueKlass* vk = (ValueKlass*)res;</span>
<span class="line-added">3763   assert(verif_vk == vk, &quot;broken calling convention&quot;);</span>
<span class="line-added">3764   assert(Metaspace::contains((void*)res), &quot;should be klass&quot;);</span>
<span class="line-added">3765 </span>
<span class="line-added">3766   // Allocate handles for every oop field so they are safe in case of</span>
<span class="line-added">3767   // a safepoint when allocating</span>
<span class="line-added">3768   GrowableArray&lt;Handle&gt; handles;</span>
<span class="line-added">3769   vk-&gt;save_oop_fields(reg_map, handles);</span>
<span class="line-added">3770 </span>
<span class="line-added">3771   // It&#39;s unsafe to safepoint until we are here</span>
<span class="line-added">3772   JRT_BLOCK;</span>
<span class="line-added">3773   {</span>
<span class="line-added">3774     Thread* THREAD = thread;</span>
<span class="line-added">3775     oop vt = vk-&gt;realloc_result(reg_map, handles, CHECK);</span>
<span class="line-added">3776     thread-&gt;set_vm_result(vt);</span>
<span class="line-added">3777   }</span>
<span class="line-added">3778   JRT_BLOCK_END;</span>
<span class="line-added">3779 }</span>
<span class="line-added">3780 JRT_END</span>
<span class="line-added">3781 </span>
</pre>
</td>
</tr>
</table>
<center><a href="safepoint.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
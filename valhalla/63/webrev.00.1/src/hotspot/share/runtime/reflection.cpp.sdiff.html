<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/reflection.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepoint.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/reflection.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/verifier.hpp&quot;
  33 #include &quot;classfile/vmSymbols.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;

  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  44 #include &quot;prims/jvmtiExport.hpp&quot;
  45 #include &quot;runtime/arguments.hpp&quot;
  46 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  47 #include &quot;runtime/handles.inline.hpp&quot;
  48 #include &quot;runtime/javaCalls.hpp&quot;
  49 #include &quot;runtime/reflection.hpp&quot;
  50 #include &quot;runtime/reflectionUtils.hpp&quot;
  51 #include &quot;runtime/signature.hpp&quot;
  52 #include &quot;runtime/thread.inline.hpp&quot;
  53 #include &quot;runtime/vframe.inline.hpp&quot;

  54 
  55 static void trace_class_resolution(oop mirror) {
  56   if (mirror == NULL || java_lang_Class::is_primitive(mirror)) {
  57     return;
  58   }
  59   Klass* to_class = java_lang_Class::as_Klass(mirror);
  60   ResourceMark rm;
  61   int line_number = -1;
  62   const char * source_file = NULL;
  63   Klass* caller = NULL;
  64   JavaThread* jthread = JavaThread::current();
  65   if (jthread-&gt;has_last_Java_frame()) {
  66     vframeStream vfst(jthread);
  67     // skip over any frames belonging to java.lang.Class
  68     while (!vfst.at_end() &amp;&amp;
  69            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  70       vfst.next();
  71     }
  72     if (!vfst.at_end()) {
  73       // this frame is a likely suspect
</pre>
<hr />
<pre>
 329   else {
 330     return Universe::typeArrayKlassObj(type);
 331   }
 332 }
 333 
 334 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
 335   if (element_mirror == NULL) {
 336     THROW_0(vmSymbols::java_lang_NullPointerException());
 337   }
 338   if (length &lt; 0) {
 339     THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
 340   }
 341   if (java_lang_Class::is_primitive(element_mirror)) {
 342     Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 343     return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);
 344   } else {
 345     Klass* k = java_lang_Class::as_Klass(element_mirror);
 346     if (k-&gt;is_array_klass() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) {
 347       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 348     }
<span class="line-modified"> 349     return oopFactory::new_objArray(k, length, THREAD);</span>




 350   }
 351 }
 352 
 353 
 354 arrayOop Reflection::reflect_new_multi_array(oop element_mirror, typeArrayOop dim_array, TRAPS) {
 355   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
 356   assert(TypeArrayKlass::cast(dim_array-&gt;klass())-&gt;element_type() == T_INT, &quot;just checking&quot;);
 357 
 358   if (element_mirror == NULL) {
 359     THROW_0(vmSymbols::java_lang_NullPointerException());
 360   }
 361 
 362   int len = dim_array-&gt;length();
 363   if (len &lt;= 0 || len &gt; MAX_DIM) {
 364     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 365   }
 366 
 367   jint dimensions[MAX_DIM];   // C array copy of intArrayOop
 368   for (int i = 0; i &lt; len; i++) {
 369     int d = dim_array-&gt;int_at(i);
</pre>
<hr />
<pre>
 771     }
 772     if (!ss.at_return_type()) {
 773       mirrors-&gt;obj_at_put(index++, mirror);
 774     } else if (return_type != NULL) {
 775       // Collect return type as well
 776       assert(ss.at_return_type(), &quot;return type should be present&quot;);
 777       *return_type = mirror;
 778     }
 779   }
 780   assert(index == parameter_count, &quot;invalid parameter count&quot;);
 781   return mirrors;
 782 }
 783 
 784 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 785   return method-&gt;resolved_checked_exceptions(THREAD);
 786 }
 787 
 788 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
 789   ResolvingSignatureStream ss(signature, k, false);
 790   oop nt = ss.as_java_mirror(SignatureStream::NCDFError, CHECK_NH);
<span class="line-removed"> 791   if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="line-removed"> 792     trace_class_resolution(nt);</span>
<span class="line-removed"> 793   }</span>
 794   return Handle(THREAD, nt);
 795 }
 796 
 797 
 798 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
 799   // Allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
<span class="line-modified"> 800   assert(!method()-&gt;is_initializer() ||</span>
<span class="line-removed"> 801          (for_constant_pool_access &amp;&amp; method()-&gt;is_static()),</span>
 802          &quot;should call new_constructor instead&quot;);
 803   InstanceKlass* holder = method-&gt;method_holder();
 804   int slot = method-&gt;method_idnum();
 805 
 806   Symbol*  signature  = method-&gt;signature();
 807   int parameter_count = ArgumentCount(signature).size();
 808   oop return_type_oop = NULL;
 809   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 810   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 811 
 812   Handle return_type(THREAD, return_type_oop);
 813 
 814   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 815 
 816   if (exception_types.is_null()) return NULL;
 817 
 818   Symbol*  method_name = method-&gt;name();
 819   oop name_oop = StringTable::intern(method_name, CHECK_NULL);
 820   Handle name = Handle(THREAD, name_oop);
 821   if (name == NULL) return NULL;
</pre>
<hr />
<pre>
 831   java_lang_reflect_Method::set_parameter_types(mh(), parameter_types());
 832   java_lang_reflect_Method::set_exception_types(mh(), exception_types());
 833   java_lang_reflect_Method::set_modifiers(mh(), modifiers);
 834   java_lang_reflect_Method::set_override(mh(), false);
 835   if (method-&gt;generic_signature() != NULL) {
 836     Symbol*  gs = method-&gt;generic_signature();
 837     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 838     java_lang_reflect_Method::set_signature(mh(), sig());
 839   }
 840   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 841   java_lang_reflect_Method::set_annotations(mh(), an_oop);
 842   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 843   java_lang_reflect_Method::set_parameter_annotations(mh(), an_oop);
 844   an_oop = Annotations::make_java_array(method-&gt;annotation_default(), CHECK_NULL);
 845   java_lang_reflect_Method::set_annotation_default(mh(), an_oop);
 846   return mh();
 847 }
 848 
 849 
 850 oop Reflection::new_constructor(const methodHandle&amp; method, TRAPS) {
<span class="line-modified"> 851   assert(method()-&gt;is_initializer(), &quot;should call new_method instead&quot;);</span>


 852 
 853   InstanceKlass* holder = method-&gt;method_holder();
 854   int slot = method-&gt;method_idnum();
 855 
 856   Symbol*  signature  = method-&gt;signature();
 857   int parameter_count = ArgumentCount(signature).size();
 858   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);
 859   if (parameter_types.is_null()) return NULL;
 860 
 861   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 862   if (exception_types.is_null()) return NULL;
 863 
 864   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 865 
 866   Handle ch = java_lang_reflect_Constructor::create(CHECK_NULL);
 867 
 868   java_lang_reflect_Constructor::set_clazz(ch(), holder-&gt;java_mirror());
 869   java_lang_reflect_Constructor::set_slot(ch(), slot);
 870   java_lang_reflect_Constructor::set_parameter_types(ch(), parameter_types());
 871   java_lang_reflect_Constructor::set_exception_types(ch(), exception_types());
</pre>
<hr />
<pre>
 881   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 882   java_lang_reflect_Constructor::set_parameter_annotations(ch(), an_oop);
 883   return ch();
 884 }
 885 
 886 
 887 oop Reflection::new_field(fieldDescriptor* fd, TRAPS) {
 888   Symbol*  field_name = fd-&gt;name();
 889   oop name_oop = StringTable::intern(field_name, CHECK_NULL);
 890   Handle name = Handle(THREAD, name_oop);
 891   Symbol*  signature  = fd-&gt;signature();
 892   InstanceKlass* holder = fd-&gt;field_holder();
 893   Handle type = new_type(signature, holder, CHECK_NULL);
 894   Handle rh  = java_lang_reflect_Field::create(CHECK_NULL);
 895 
 896   java_lang_reflect_Field::set_clazz(rh(), fd-&gt;field_holder()-&gt;java_mirror());
 897   java_lang_reflect_Field::set_slot(rh(), fd-&gt;index());
 898   java_lang_reflect_Field::set_name(rh(), name());
 899   java_lang_reflect_Field::set_type(rh(), type());
 900   // Note the ACC_ANNOTATION bit, which is a per-class access flag, is never set here.
<span class="line-modified"> 901   java_lang_reflect_Field::set_modifiers(rh(), fd-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS);</span>









 902   java_lang_reflect_Field::set_override(rh(), false);
 903   if (fd-&gt;has_generic_signature()) {
 904     Symbol*  gs = fd-&gt;generic_signature();
 905     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 906     java_lang_reflect_Field::set_signature(rh(), sig());
 907   }
 908   typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;annotations(), CHECK_NULL);
 909   java_lang_reflect_Field::set_annotations(rh(), an_oop);
 910   return rh();
 911 }
 912 
 913 oop Reflection::new_parameter(Handle method, int index, Symbol* sym,
 914                               int flags, TRAPS) {
 915 
 916   Handle rh = java_lang_reflect_Parameter::create(CHECK_NULL);
 917 
 918   if(NULL != sym) {
 919     Handle name = java_lang_String::create_from_symbol(sym, CHECK_NULL);
 920     java_lang_reflect_Parameter::set_name(rh(), name());
 921   } else {
</pre>
<hr />
<pre>
1156     if (rtype == T_BOOLEAN || rtype == T_BYTE || rtype == T_CHAR || rtype == T_SHORT) {
1157       narrow((jvalue*)result.get_value_addr(), rtype, CHECK_NULL);
1158     }
1159     return Reflection::box((jvalue*)result.get_value_addr(), rtype, THREAD);
1160   }
1161 }
1162 
1163 // This would be nicer if, say, java.lang.reflect.Method was a subclass
1164 // of java.lang.reflect.Constructor
1165 
1166 oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
1167   oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
1168   int slot               = java_lang_reflect_Method::slot(method_mirror);
1169   bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
1170   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
1171 
1172   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
1173   BasicType rtype;
1174   if (java_lang_Class::is_primitive(return_type_mirror)) {
1175     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);


1176   } else {
1177     rtype = T_OBJECT;
1178   }
1179 
1180   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1181   Method* m = klass-&gt;method_with_idnum(slot);
1182   if (m == NULL) {
1183     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1184   }
1185   methodHandle method(THREAD, m);
1186 
1187   return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
1188 }
1189 
1190 
1191 oop Reflection::invoke_constructor(oop constructor_mirror, objArrayHandle args, TRAPS) {
1192   oop mirror             = java_lang_reflect_Constructor::clazz(constructor_mirror);
1193   int slot               = java_lang_reflect_Constructor::slot(constructor_mirror);
1194   bool override          = java_lang_reflect_Constructor::override(constructor_mirror) != 0;
1195   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Constructor::parameter_types(constructor_mirror)));
1196 
1197   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1198   Method* m = klass-&gt;method_with_idnum(slot);
1199   if (m == NULL) {
1200     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1201   }
1202   methodHandle method(THREAD, m);
1203   assert(method-&gt;name() == vmSymbols::object_initializer_name(), &quot;invalid constructor&quot;);
1204 
1205   // Make sure klass gets initialize
1206   klass-&gt;initialize(CHECK_NULL);
1207 
1208   // Create new instance (the receiver)
1209   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);










1210   Handle receiver = klass-&gt;allocate_instance_handle(CHECK_NULL);
1211 
1212   // Ignore result from call and return receiver
1213   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
1214   return receiver();
1215 }
</pre>
</td>
<td>
<hr />
<pre>
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/javaClasses.inline.hpp&quot;
  28 #include &quot;classfile/moduleEntry.hpp&quot;
  29 #include &quot;classfile/packageEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/verifier.hpp&quot;
  33 #include &quot;classfile/vmSymbols.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/instanceKlass.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  43 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/jvmtiExport.hpp&quot;
  46 #include &quot;runtime/arguments.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;runtime/javaCalls.hpp&quot;
  50 #include &quot;runtime/reflection.hpp&quot;
  51 #include &quot;runtime/reflectionUtils.hpp&quot;
  52 #include &quot;runtime/signature.hpp&quot;
  53 #include &quot;runtime/thread.inline.hpp&quot;
  54 #include &quot;runtime/vframe.inline.hpp&quot;
<span class="line-added">  55 #include &quot;utilities/globalDefinitions.hpp&quot;</span>
  56 
  57 static void trace_class_resolution(oop mirror) {
  58   if (mirror == NULL || java_lang_Class::is_primitive(mirror)) {
  59     return;
  60   }
  61   Klass* to_class = java_lang_Class::as_Klass(mirror);
  62   ResourceMark rm;
  63   int line_number = -1;
  64   const char * source_file = NULL;
  65   Klass* caller = NULL;
  66   JavaThread* jthread = JavaThread::current();
  67   if (jthread-&gt;has_last_Java_frame()) {
  68     vframeStream vfst(jthread);
  69     // skip over any frames belonging to java.lang.Class
  70     while (!vfst.at_end() &amp;&amp;
  71            vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class()) {
  72       vfst.next();
  73     }
  74     if (!vfst.at_end()) {
  75       // this frame is a likely suspect
</pre>
<hr />
<pre>
 331   else {
 332     return Universe::typeArrayKlassObj(type);
 333   }
 334 }
 335 
 336 arrayOop Reflection::reflect_new_array(oop element_mirror, jint length, TRAPS) {
 337   if (element_mirror == NULL) {
 338     THROW_0(vmSymbols::java_lang_NullPointerException());
 339   }
 340   if (length &lt; 0) {
 341     THROW_MSG_0(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
 342   }
 343   if (java_lang_Class::is_primitive(element_mirror)) {
 344     Klass* tak = basic_type_mirror_to_arrayklass(element_mirror, CHECK_NULL);
 345     return TypeArrayKlass::cast(tak)-&gt;allocate(length, THREAD);
 346   } else {
 347     Klass* k = java_lang_Class::as_Klass(element_mirror);
 348     if (k-&gt;is_array_klass() &amp;&amp; ArrayKlass::cast(k)-&gt;dimension() &gt;= MAX_DIM) {
 349       THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 350     }
<span class="line-modified"> 351     if (k-&gt;is_value()) {</span>
<span class="line-added"> 352       return oopFactory::new_valueArray(k, length, THREAD);</span>
<span class="line-added"> 353     } else {</span>
<span class="line-added"> 354       return oopFactory::new_objArray(k, length, THREAD);</span>
<span class="line-added"> 355     }</span>
 356   }
 357 }
 358 
 359 
 360 arrayOop Reflection::reflect_new_multi_array(oop element_mirror, typeArrayOop dim_array, TRAPS) {
 361   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
 362   assert(TypeArrayKlass::cast(dim_array-&gt;klass())-&gt;element_type() == T_INT, &quot;just checking&quot;);
 363 
 364   if (element_mirror == NULL) {
 365     THROW_0(vmSymbols::java_lang_NullPointerException());
 366   }
 367 
 368   int len = dim_array-&gt;length();
 369   if (len &lt;= 0 || len &gt; MAX_DIM) {
 370     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
 371   }
 372 
 373   jint dimensions[MAX_DIM];   // C array copy of intArrayOop
 374   for (int i = 0; i &lt; len; i++) {
 375     int d = dim_array-&gt;int_at(i);
</pre>
<hr />
<pre>
 777     }
 778     if (!ss.at_return_type()) {
 779       mirrors-&gt;obj_at_put(index++, mirror);
 780     } else if (return_type != NULL) {
 781       // Collect return type as well
 782       assert(ss.at_return_type(), &quot;return type should be present&quot;);
 783       *return_type = mirror;
 784     }
 785   }
 786   assert(index == parameter_count, &quot;invalid parameter count&quot;);
 787   return mirrors;
 788 }
 789 
 790 static objArrayHandle get_exception_types(const methodHandle&amp; method, TRAPS) {
 791   return method-&gt;resolved_checked_exceptions(THREAD);
 792 }
 793 
 794 static Handle new_type(Symbol* signature, Klass* k, TRAPS) {
 795   ResolvingSignatureStream ss(signature, k, false);
 796   oop nt = ss.as_java_mirror(SignatureStream::NCDFError, CHECK_NH);



 797   return Handle(THREAD, nt);
 798 }
 799 
 800 
 801 oop Reflection::new_method(const methodHandle&amp; method, bool for_constant_pool_access, TRAPS) {
 802   // Allow sun.reflect.ConstantPool to refer to &lt;clinit&gt; methods as java.lang.reflect.Methods.
<span class="line-modified"> 803   assert(!method()-&gt;name()-&gt;starts_with(&#39;&lt;&#39;) || for_constant_pool_access,</span>

 804          &quot;should call new_constructor instead&quot;);
 805   InstanceKlass* holder = method-&gt;method_holder();
 806   int slot = method-&gt;method_idnum();
 807 
 808   Symbol*  signature  = method-&gt;signature();
 809   int parameter_count = ArgumentCount(signature).size();
 810   oop return_type_oop = NULL;
 811   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, &amp;return_type_oop, CHECK_NULL);
 812   if (parameter_types.is_null() || return_type_oop == NULL) return NULL;
 813 
 814   Handle return_type(THREAD, return_type_oop);
 815 
 816   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 817 
 818   if (exception_types.is_null()) return NULL;
 819 
 820   Symbol*  method_name = method-&gt;name();
 821   oop name_oop = StringTable::intern(method_name, CHECK_NULL);
 822   Handle name = Handle(THREAD, name_oop);
 823   if (name == NULL) return NULL;
</pre>
<hr />
<pre>
 833   java_lang_reflect_Method::set_parameter_types(mh(), parameter_types());
 834   java_lang_reflect_Method::set_exception_types(mh(), exception_types());
 835   java_lang_reflect_Method::set_modifiers(mh(), modifiers);
 836   java_lang_reflect_Method::set_override(mh(), false);
 837   if (method-&gt;generic_signature() != NULL) {
 838     Symbol*  gs = method-&gt;generic_signature();
 839     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 840     java_lang_reflect_Method::set_signature(mh(), sig());
 841   }
 842   typeArrayOop an_oop = Annotations::make_java_array(method-&gt;annotations(), CHECK_NULL);
 843   java_lang_reflect_Method::set_annotations(mh(), an_oop);
 844   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 845   java_lang_reflect_Method::set_parameter_annotations(mh(), an_oop);
 846   an_oop = Annotations::make_java_array(method-&gt;annotation_default(), CHECK_NULL);
 847   java_lang_reflect_Method::set_annotation_default(mh(), an_oop);
 848   return mh();
 849 }
 850 
 851 
 852 oop Reflection::new_constructor(const methodHandle&amp; method, TRAPS) {
<span class="line-modified"> 853   assert(method()-&gt;is_object_constructor() ||</span>
<span class="line-added"> 854          method()-&gt;is_static_init_factory(),</span>
<span class="line-added"> 855          &quot;should call new_method instead&quot;);</span>
 856 
 857   InstanceKlass* holder = method-&gt;method_holder();
 858   int slot = method-&gt;method_idnum();
 859 
 860   Symbol*  signature  = method-&gt;signature();
 861   int parameter_count = ArgumentCount(signature).size();
 862   objArrayHandle parameter_types = get_parameter_types(method, parameter_count, NULL, CHECK_NULL);
 863   if (parameter_types.is_null()) return NULL;
 864 
 865   objArrayHandle exception_types = get_exception_types(method, CHECK_NULL);
 866   if (exception_types.is_null()) return NULL;
 867 
 868   const int modifiers = method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
 869 
 870   Handle ch = java_lang_reflect_Constructor::create(CHECK_NULL);
 871 
 872   java_lang_reflect_Constructor::set_clazz(ch(), holder-&gt;java_mirror());
 873   java_lang_reflect_Constructor::set_slot(ch(), slot);
 874   java_lang_reflect_Constructor::set_parameter_types(ch(), parameter_types());
 875   java_lang_reflect_Constructor::set_exception_types(ch(), exception_types());
</pre>
<hr />
<pre>
 885   an_oop = Annotations::make_java_array(method-&gt;parameter_annotations(), CHECK_NULL);
 886   java_lang_reflect_Constructor::set_parameter_annotations(ch(), an_oop);
 887   return ch();
 888 }
 889 
 890 
 891 oop Reflection::new_field(fieldDescriptor* fd, TRAPS) {
 892   Symbol*  field_name = fd-&gt;name();
 893   oop name_oop = StringTable::intern(field_name, CHECK_NULL);
 894   Handle name = Handle(THREAD, name_oop);
 895   Symbol*  signature  = fd-&gt;signature();
 896   InstanceKlass* holder = fd-&gt;field_holder();
 897   Handle type = new_type(signature, holder, CHECK_NULL);
 898   Handle rh  = java_lang_reflect_Field::create(CHECK_NULL);
 899 
 900   java_lang_reflect_Field::set_clazz(rh(), fd-&gt;field_holder()-&gt;java_mirror());
 901   java_lang_reflect_Field::set_slot(rh(), fd-&gt;index());
 902   java_lang_reflect_Field::set_name(rh(), name());
 903   java_lang_reflect_Field::set_type(rh(), type());
 904   // Note the ACC_ANNOTATION bit, which is a per-class access flag, is never set here.
<span class="line-modified"> 905   int modifiers = fd-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-added"> 906   if (fd-&gt;is_flattenable()) {</span>
<span class="line-added"> 907     modifiers |= JVM_ACC_FIELD_FLATTENABLE;</span>
<span class="line-added"> 908     // JVM_ACC_FLATTENABLE should not be set in LWorld.  set_is_flattenable should be re-examined.</span>
<span class="line-added"> 909     modifiers &amp;= ~JVM_ACC_FLATTENABLE;</span>
<span class="line-added"> 910   }</span>
<span class="line-added"> 911   if (fd-&gt;is_flattened()) {</span>
<span class="line-added"> 912     modifiers |= JVM_ACC_FIELD_FLATTENED;</span>
<span class="line-added"> 913   }</span>
<span class="line-added"> 914   java_lang_reflect_Field::set_modifiers(rh(), modifiers);</span>
 915   java_lang_reflect_Field::set_override(rh(), false);
 916   if (fd-&gt;has_generic_signature()) {
 917     Symbol*  gs = fd-&gt;generic_signature();
 918     Handle sig = java_lang_String::create_from_symbol(gs, CHECK_NULL);
 919     java_lang_reflect_Field::set_signature(rh(), sig());
 920   }
 921   typeArrayOop an_oop = Annotations::make_java_array(fd-&gt;annotations(), CHECK_NULL);
 922   java_lang_reflect_Field::set_annotations(rh(), an_oop);
 923   return rh();
 924 }
 925 
 926 oop Reflection::new_parameter(Handle method, int index, Symbol* sym,
 927                               int flags, TRAPS) {
 928 
 929   Handle rh = java_lang_reflect_Parameter::create(CHECK_NULL);
 930 
 931   if(NULL != sym) {
 932     Handle name = java_lang_String::create_from_symbol(sym, CHECK_NULL);
 933     java_lang_reflect_Parameter::set_name(rh(), name());
 934   } else {
</pre>
<hr />
<pre>
1169     if (rtype == T_BOOLEAN || rtype == T_BYTE || rtype == T_CHAR || rtype == T_SHORT) {
1170       narrow((jvalue*)result.get_value_addr(), rtype, CHECK_NULL);
1171     }
1172     return Reflection::box((jvalue*)result.get_value_addr(), rtype, THREAD);
1173   }
1174 }
1175 
1176 // This would be nicer if, say, java.lang.reflect.Method was a subclass
1177 // of java.lang.reflect.Constructor
1178 
1179 oop Reflection::invoke_method(oop method_mirror, Handle receiver, objArrayHandle args, TRAPS) {
1180   oop mirror             = java_lang_reflect_Method::clazz(method_mirror);
1181   int slot               = java_lang_reflect_Method::slot(method_mirror);
1182   bool override          = java_lang_reflect_Method::override(method_mirror) != 0;
1183   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Method::parameter_types(method_mirror)));
1184 
1185   oop return_type_mirror = java_lang_reflect_Method::return_type(method_mirror);
1186   BasicType rtype;
1187   if (java_lang_Class::is_primitive(return_type_mirror)) {
1188     rtype = basic_type_mirror_to_basic_type(return_type_mirror, CHECK_NULL);
<span class="line-added">1189   } else if (java_lang_Class::as_Klass(return_type_mirror)-&gt;is_value()) {</span>
<span class="line-added">1190     rtype = T_VALUETYPE;</span>
1191   } else {
1192     rtype = T_OBJECT;
1193   }
1194 
1195   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1196   Method* m = klass-&gt;method_with_idnum(slot);
1197   if (m == NULL) {
1198     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1199   }
1200   methodHandle method(THREAD, m);
1201 
1202   return invoke(klass, method, receiver, override, ptypes, rtype, args, true, THREAD);
1203 }
1204 
1205 
1206 oop Reflection::invoke_constructor(oop constructor_mirror, objArrayHandle args, TRAPS) {
1207   oop mirror             = java_lang_reflect_Constructor::clazz(constructor_mirror);
1208   int slot               = java_lang_reflect_Constructor::slot(constructor_mirror);
1209   bool override          = java_lang_reflect_Constructor::override(constructor_mirror) != 0;
1210   objArrayHandle ptypes(THREAD, objArrayOop(java_lang_reflect_Constructor::parameter_types(constructor_mirror)));
1211 
1212   InstanceKlass* klass = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1213   Method* m = klass-&gt;method_with_idnum(slot);
1214   if (m == NULL) {
1215     THROW_MSG_0(vmSymbols::java_lang_InternalError(), &quot;invoke&quot;);
1216   }
1217   methodHandle method(THREAD, m);
1218   assert(method-&gt;name() == vmSymbols::object_initializer_name(), &quot;invalid constructor&quot;);
1219 
1220   // Make sure klass gets initialize
1221   klass-&gt;initialize(CHECK_NULL);
1222 
1223   // Create new instance (the receiver)
1224   klass-&gt;check_valid_for_instantiation(false, CHECK_NULL);
<span class="line-added">1225 </span>
<span class="line-added">1226   // Special case for factory methods</span>
<span class="line-added">1227   if (!method-&gt;signature()-&gt;is_void_method_signature()) {</span>
<span class="line-added">1228     assert(klass-&gt;is_value(), &quot;inline classes must use factory methods&quot;);</span>
<span class="line-added">1229     Handle no_receiver; // null instead of receiver</span>
<span class="line-added">1230     return invoke(klass, method, no_receiver, override, ptypes, T_VALUETYPE, args, false, CHECK_NULL);</span>
<span class="line-added">1231   }</span>
<span class="line-added">1232 </span>
<span class="line-added">1233   // main branch of code creates a non-inline object:</span>
<span class="line-added">1234   assert(!klass-&gt;is_value(), &quot;classic constructors are only for non-inline classes&quot;);</span>
1235   Handle receiver = klass-&gt;allocate_instance_handle(CHECK_NULL);
1236 
1237   // Ignore result from call and return receiver
1238   invoke(klass, method, receiver, override, ptypes, T_VOID, args, false, CHECK_NULL);
1239   return receiver();
1240 }
</pre>
</td>
</tr>
</table>
<center><a href="globals.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="safepoint.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
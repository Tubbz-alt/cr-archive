<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/sharedRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_SHAREDRUNTIME_HPP
 26 #define SHARE_RUNTIME_SHAREDRUNTIME_HPP
 27 

 28 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
 29 #include &quot;interpreter/bytecodeTracer.hpp&quot;
 30 #include &quot;interpreter/linkResolver.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/resourceArea.hpp&quot;

 33 #include &quot;utilities/hashtable.hpp&quot;
 34 #include &quot;utilities/macros.hpp&quot;
 35 
 36 class AdapterHandlerEntry;
 37 class AdapterHandlerTable;
 38 class AdapterFingerPrint;
 39 class vframeStream;

 40 
 41 // Runtime is the base class for various runtime interfaces
 42 // (InterpreterRuntime, CompilerRuntime, etc.). It provides
 43 // shared functionality such as exception forwarding (C++ to
 44 // Java exceptions), locking/unlocking mechanisms, statistical
 45 // information, etc.
 46 
 47 class SharedRuntime: AllStatic {
 48   friend class VMStructs;
 49 
 50  private:
 51   static bool resolve_sub_helper_internal(methodHandle callee_method, const frame&amp; caller_frame,
 52                                           CompiledMethod* caller_nm, bool is_virtual, bool is_optimized,
 53                                           Handle receiver, CallInfo&amp; call_info, Bytecodes::Code invoke_code, TRAPS);
 54   static methodHandle resolve_sub_helper(JavaThread *thread,
 55                                          bool is_virtual,
<span class="line-modified"> 56                                          bool is_optimized, TRAPS);</span>

 57 
 58   // Shared stub locations
 59 
 60   static RuntimeStub*        _wrong_method_blob;
 61   static RuntimeStub*        _wrong_method_abstract_blob;
 62   static RuntimeStub*        _ic_miss_blob;
 63   static RuntimeStub*        _resolve_opt_virtual_call_blob;
 64   static RuntimeStub*        _resolve_virtual_call_blob;
 65   static RuntimeStub*        _resolve_static_call_blob;
<span class="line-removed"> 66   static address             _resolve_static_call_entry;</span>
 67 
 68   static DeoptimizationBlob* _deopt_blob;
 69 
 70   static SafepointBlob*      _polling_page_vectors_safepoint_handler_blob;
 71   static SafepointBlob*      _polling_page_safepoint_handler_blob;
 72   static SafepointBlob*      _polling_page_return_handler_blob;
 73 
 74 #ifdef COMPILER2
 75   static UncommonTrapBlob*   _uncommon_trap_blob;
 76 #endif // COMPILER2
 77 
 78 #ifndef PRODUCT
 79   // Counters
 80   static int     _nof_megamorphic_calls;         // total # of megamorphic calls (through vtable)
 81 #endif // !PRODUCT
 82 
 83  private:
 84   enum { POLL_AT_RETURN,  POLL_AT_LOOP, POLL_AT_VECTOR_LOOP };
 85   static SafepointBlob* generate_handler_blob(address call_ptr, int poll_type);
 86   static RuntimeStub*   generate_resolve_blob(address destination, const char* name);
<span class="line-removed"> 87 </span>
 88  public:
 89   static void generate_stubs(void);
 90 
 91   // max bytes for each dtrace string parameter
 92   enum { max_dtrace_string_size = 256 };
 93 
 94   // The following arithmetic routines are used on platforms that do
 95   // not have machine instructions to implement their functionality.
 96   // Do not remove these.
 97 
 98   // long arithmetics
 99   static jlong   lmul(jlong y, jlong x);
100   static jlong   ldiv(jlong y, jlong x);
101   static jlong   lrem(jlong y, jlong x);
102 
103   // float and double remainder
104   static jfloat  frem(jfloat  x, jfloat  y);
105   static jdouble drem(jdouble x, jdouble y);
106 
107 
</pre>
<hr />
<pre>
301   static char* generate_class_cast_message(JavaThread* thr, Klass* caster_klass);
302 
303   // Fill in the &quot;X cannot be cast to a Y&quot; message for ClassCastException
304   //
305   // @param caster_klass the class of the object we are casting
306   // @param target_klass the target klass attempt
307   // @return the dynamically allocated exception message (must be freed
308   // by the caller using a resource mark)
309   //
310   // This version does not require access the frame, so it can be called
311   // from interpreted code
312   // The caller (or one of it&#39;s callers) must use a ResourceMark
313   // in order to correctly free the result.
314   //
315   static char* generate_class_cast_message(Klass* caster_klass, Klass* target_klass, Symbol* target_klass_name = NULL);
316 
317   // Resolves a call site- may patch in the destination of the call into the
318   // compiled code.
319   static methodHandle resolve_helper(JavaThread *thread,
320                                      bool is_virtual,
<span class="line-modified">321                                      bool is_optimized, TRAPS);</span>

322 
323  private:
324   // deopt blob
325   static void generate_deopt_blob(void);
326 
327   static bool handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm, const frame&amp; caller_frame,
328                                              methodHandle callee_method, Bytecodes::Code bc, CallInfo&amp; call_info,
<span class="line-modified">329                                              bool&amp; needs_ic_stub_refill, TRAPS);</span>
330 
331  public:
332   static DeoptimizationBlob* deopt_blob(void)      { return _deopt_blob; }
333 
334   // Resets a call-site in compiled code so it will get resolved again.
<span class="line-modified">335   static methodHandle reresolve_call_site(JavaThread *thread, TRAPS);</span>
336 
337   // In the code prolog, if the klass comparison fails, the inline cache
338   // misses and the call site is patched to megamorphic
<span class="line-modified">339   static methodHandle handle_ic_miss_helper(JavaThread* thread, TRAPS);</span>
340 
341   // Find the method that called us.
342   static methodHandle find_callee_method(JavaThread* thread, TRAPS);
343 
344   static void monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);
345 
346   static void monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);
347 













348  private:
349   static Handle find_callee_info(JavaThread* thread,
350                                  Bytecodes::Code&amp; bc,
351                                  CallInfo&amp; callinfo, TRAPS);
352   static Handle find_callee_info_helper(JavaThread* thread,
353                                         vframeStream&amp; vfst,
354                                         Bytecodes::Code&amp; bc,
355                                         CallInfo&amp; callinfo, TRAPS);
356 
357   static Method* extract_attached_method(vframeStream&amp; vfst);
358 
<span class="line-removed">359   static address clean_virtual_call_entry();</span>
<span class="line-removed">360   static address clean_opt_virtual_call_entry();</span>
<span class="line-removed">361   static address clean_static_call_entry();</span>
<span class="line-removed">362 </span>
363 #if defined(X86) &amp;&amp; defined(COMPILER1)
364   // For Object.hashCode, System.identityHashCode try to pull hashCode from object header if available.
365   static void inline_check_hashcode_from_object_header(MacroAssembler* masm, const methodHandle&amp; method, Register obj_reg, Register result);
366 #endif // X86 &amp;&amp; COMPILER1
367 
368  public:
369 
370   // Read the array of BasicTypes from a Java signature, and compute where
371   // compiled Java code would like to put the results.  Values in reg_lo and
372   // reg_hi refer to 4-byte quantities.  Values less than SharedInfo::stack0 are
373   // registers, those above refer to 4-byte stack slots.  All stack slots are
374   // based off of the window top.  SharedInfo::stack0 refers to the first usable
375   // slot in the bottom of the frame. SharedInfo::stack0+1 refers to the memory word
376   // 4-bytes higher. So for sparc because the register window save area is at
377   // the bottom of the frame the first 16 words will be skipped and SharedInfo::stack0
378   // will be just above it. (
379   // return value is the maximum number of VMReg stack slots the convention will use.
380   static int java_calling_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed, int is_outgoing);








381 
382   static void check_member_name_argument_is_last_argument(const methodHandle&amp; method,
383                                                           const BasicType* sig_bt,
384                                                           const VMRegPair* regs) NOT_DEBUG_RETURN;
385 
386   // Ditto except for calling C
387   //
388   // C argument in register AND stack slot.
389   // Some architectures require that an argument must be passed in a register
390   // AND in a stack slot. These architectures provide a second VMRegPair array
391   // to be filled by the c_calling_convention method. On other architectures,
392   // NULL is being passed as the second VMRegPair array, so arguments are either
393   // passed in a register OR in a stack slot.
394   static int c_calling_convention(const BasicType *sig_bt, VMRegPair *regs, VMRegPair *regs2,
395                                   int total_args_passed);
396 
397   static size_t trampoline_size();
398 
399   static void generate_trampoline(MacroAssembler *masm, address destination);
400 
</pre>
<hr />
<pre>
408   // by the time we reach the blob there is compiled code available. This allows
409   // the blob to pass the incoming stack pointer (the sender sp) in a known
410   // location for the interpreter to record. This is used by the frame code
411   // to correct the sender code to match up with the stack pointer when the
412   // thread left the compiled code. In addition it allows the interpreter
413   // to remove the space the c2i adapter allocated to do its argument conversion.
414 
415   // Although a c2i blob will always run interpreted even if compiled code is
416   // present if we see that compiled code is present the compiled call site
417   // will be patched/re-resolved so that later calls will run compiled.
418 
419   // Additionally a c2i blob need to have a unverified entry because it can be reached
420   // in situations where the call site is an inlined cache site and may go megamorphic.
421 
422   // A i2c adapter is simpler than the c2i adapter. This is because it is assumed
423   // that the interpreter before it does any call dispatch will record the current
424   // stack pointer in the interpreter frame. On return it will restore the stack
425   // pointer as needed. This means the i2c adapter code doesn&#39;t need any special
426   // handshaking path with compiled code to keep the stack walking correct.
427 
<span class="line-modified">428   static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *_masm,</span>
<span class="line-modified">429                                                       int total_args_passed,</span>
<span class="line-modified">430                                                       int max_arg,</span>
<span class="line-modified">431                                                       const BasicType *sig_bt,</span>
<span class="line-modified">432                                                       const VMRegPair *regs,</span>
<span class="line-modified">433                                                       AdapterFingerPrint* fingerprint);</span>




434 
435   static void gen_i2c_adapter(MacroAssembler *_masm,
<span class="line-modified">436                               int total_args_passed,</span>
<span class="line-removed">437                               int comp_args_on_stack,</span>
438                               const BasicType *sig_bt,
439                               const VMRegPair *regs);
440 
441   // OSR support
442 
443   // OSR_migration_begin will extract the jvm state from an interpreter
444   // frame (locals, monitors) and store the data in a piece of C heap
445   // storage. This then allows the interpreter frame to be removed from the
446   // stack and the OSR nmethod to be called. That method is called with a
447   // pointer to the C heap storage. This pointer is the return value from
448   // OSR_migration_begin.
449 
450   static intptr_t* OSR_migration_begin(JavaThread *thread);
451 
452   // OSR_migration_end is a trivial routine. It is called after the compiled
453   // method has extracted the jvm state from the C heap that OSR_migration_begin
454   // created. It&#39;s entire job is to simply free this storage.
455   static void OSR_migration_end(intptr_t* buf);
456 
457   // Convert a sig into a calling convention register layout
</pre>
<hr />
<pre>
495   static void block_for_jni_critical(JavaThread* thread);
496 
497   // Pin/Unpin object
498   static oopDesc* pin_object(JavaThread* thread, oopDesc* obj);
499   static void unpin_object(JavaThread* thread, oopDesc* obj);
500 
501   // A compiled caller has just called the interpreter, but compiled code
502   // exists.  Patch the caller so he no longer calls into the interpreter.
503   static void fixup_callers_callsite(Method* moop, address ret_pc);
504   static bool should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb);
505 
506   // Slow-path Locking and Unlocking
507   static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
508   static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
509 
510   // Resolving of calls
511   static address resolve_static_call_C     (JavaThread *thread);
512   static address resolve_virtual_call_C    (JavaThread *thread);
513   static address resolve_opt_virtual_call_C(JavaThread *thread);
514 



515   // arraycopy, the non-leaf version.  (See StubRoutines for all the leaf calls.)
516   static void slow_arraycopy_C(oopDesc* src,  jint src_pos,
517                                oopDesc* dest, jint dest_pos,
518                                jint length, JavaThread* thread);
519 
520   // handle ic miss with caller being compiled code
521   // wrong method handling (inline cache misses, zombie methods)
522   static address handle_wrong_method(JavaThread* thread);
523   static address handle_wrong_method_abstract(JavaThread* thread);
524   static address handle_wrong_method_ic_miss(JavaThread* thread);



525 
526   static address handle_unsafe_access(JavaThread* thread, address next_pc);
527 

528 #ifndef PRODUCT
529 
530   // Collect and print inline cache miss statistics
531  private:
532   enum { maxICmiss_count = 100 };
533   static int     _ICmiss_index;                  // length of IC miss histogram
534   static int     _ICmiss_count[maxICmiss_count]; // miss counts
535   static address _ICmiss_at[maxICmiss_count];    // miss addresses
536   static void trace_ic_miss(address at);
537 
538  public:
539   static int _throw_null_ctr;                    // throwing a null-pointer exception
540   static int _ic_miss_ctr;                       // total # of IC misses
541   static int _wrong_method_ctr;
542   static int _resolve_static_ctr;
543   static int _resolve_virtual_ctr;
544   static int _resolve_opt_virtual_ctr;
545   static int _implicit_null_throws;
546   static int _implicit_div0_throws;
547 
</pre>
<hr />
<pre>
622 // Rmethod-&gt;_i2i_entry.  On entry, the interpreted frame has not yet been
623 // setup.  Compiled frames are fixed-size and the args are likely not in the
624 // right place.  Hence all the args will likely be copied into the
625 // interpreter&#39;s frame, forcing that frame to grow.  The compiled frame&#39;s
626 // outgoing stack args will be dead after the copy.
627 //
628 // Native wrappers, like adapters, marshal arguments.  Unlike adapters they
629 // also perform an official frame push &amp; pop.  They have a call to the native
630 // routine in their middles and end in a return (instead of ending in a jump).
631 // The native wrappers are stored in real nmethods instead of the BufferBlobs
632 // used by the adapters.  The code generation happens here because it&#39;s very
633 // similar to what the adapters have to do.
634 
635 class AdapterHandlerEntry : public BasicHashtableEntry&lt;mtCode&gt; {
636   friend class AdapterHandlerTable;
637 
638  private:
639   AdapterFingerPrint* _fingerprint;
640   address _i2c_entry;
641   address _c2i_entry;


642   address _c2i_unverified_entry;

643   address _c2i_no_clinit_check_entry;
644 



645 #ifdef ASSERT
646   // Captures code and signature used to generate this adapter when
647   // verifying adapter equivalence.
648   unsigned char* _saved_code;
649   int            _saved_code_length;
650 #endif
651 
<span class="line-modified">652   void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {</span>

653     _fingerprint = fingerprint;
654     _i2c_entry = i2c_entry;
655     _c2i_entry = c2i_entry;


656     _c2i_unverified_entry = c2i_unverified_entry;

657     _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;

658 #ifdef ASSERT
659     _saved_code = NULL;
660     _saved_code_length = 0;
661 #endif
662   }
663 
664   void deallocate();
665 
666   // should never be used
667   AdapterHandlerEntry();
668 
669  public:
670   address get_i2c_entry()                  const { return _i2c_entry; }
671   address get_c2i_entry()                  const { return _c2i_entry; }


672   address get_c2i_unverified_entry()       const { return _c2i_unverified_entry; }

673   address get_c2i_no_clinit_check_entry()  const { return _c2i_no_clinit_check_entry; }
674 
675   address base_address();
676   void relocate(address new_base);
677 




678   AdapterFingerPrint* fingerprint() const { return _fingerprint; }
679 
680   AdapterHandlerEntry* next() {
681     return (AdapterHandlerEntry*)BasicHashtableEntry&lt;mtCode&gt;::next();
682   }
683 
684 #ifdef ASSERT
685   // Used to verify that code generated for shared adapters is equivalent
686   void save_code   (unsigned char* code, int length);
687   bool compare_code(unsigned char* code, int length);
688 #endif
689 
690   //virtual void print_on(outputStream* st) const;  DO NOT USE
691   void print_adapter_on(outputStream* st) const;
692 };
693 
694 // This class is used only with DumpSharedSpaces==true. It holds extra information
695 // that&#39;s used only during CDS dump time.
696 // For details, see comments around Method::link_method()
697 class CDSAdapterHandlerEntry: public AdapterHandlerEntry {
<span class="line-modified">698   address               _c2i_entry_trampoline;   // allocated from shared spaces &quot;MC&quot; region</span>
<span class="line-modified">699   AdapterHandlerEntry** _adapter_trampoline;     // allocated from shared spaces &quot;MD&quot; region</span>


700 
701 public:
702   address get_c2i_entry_trampoline()             const { return _c2i_entry_trampoline; }


703   AdapterHandlerEntry** get_adapter_trampoline() const { return _adapter_trampoline; }
704   void init() NOT_CDS_RETURN;
705 };
706 
707 
708 class AdapterHandlerLibrary: public AllStatic {
709  private:
710   static BufferBlob* _buffer; // the temporary code buffer in CodeCache
711   static AdapterHandlerTable* _adapters;
712   static AdapterHandlerEntry* _abstract_method_handler;
713   static BufferBlob* buffer_blob();
714   static void initialize();
715   static AdapterHandlerEntry* get_adapter0(const methodHandle&amp; method);
716 
717  public:
718 
719   static AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint,
<span class="line-modified">720                                         address i2c_entry,</span>
<span class="line-modified">721                                         address c2i_entry,</span>
<span class="line-removed">722                                         address c2i_unverified_entry,</span>
<span class="line-removed">723                                         address c2i_no_clinit_check_entry = NULL);</span>
724   static void create_native_wrapper(const methodHandle&amp; method);
725   static AdapterHandlerEntry* get_adapter(const methodHandle&amp; method);
726 
727   static void print_handler(const CodeBlob* b) { print_handler_on(tty, b); }
728   static void print_handler_on(outputStream* st, const CodeBlob* b);
729   static bool contains(const CodeBlob* b);
730 #ifndef PRODUCT
731   static void print_statistics();
732 #endif // PRODUCT
733 
734 };
735 






























































736 #endif // SHARE_RUNTIME_SHAREDRUNTIME_HPP
</pre>
</td>
<td>
<hr />
<pre>
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_RUNTIME_SHAREDRUNTIME_HPP
 26 #define SHARE_RUNTIME_SHAREDRUNTIME_HPP
 27 
<span class="line-added"> 28 #include &quot;asm/codeBuffer.hpp&quot;</span>
 29 #include &quot;interpreter/bytecodeHistogram.hpp&quot;
 30 #include &quot;interpreter/bytecodeTracer.hpp&quot;
 31 #include &quot;interpreter/linkResolver.hpp&quot;
 32 #include &quot;memory/allocation.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added"> 34 #include &quot;runtime/signature.hpp&quot;</span>
 35 #include &quot;utilities/hashtable.hpp&quot;
 36 #include &quot;utilities/macros.hpp&quot;
 37 
 38 class AdapterHandlerEntry;
 39 class AdapterHandlerTable;
 40 class AdapterFingerPrint;
 41 class vframeStream;
<span class="line-added"> 42 class SigEntry;</span>
 43 
 44 // Runtime is the base class for various runtime interfaces
 45 // (InterpreterRuntime, CompilerRuntime, etc.). It provides
 46 // shared functionality such as exception forwarding (C++ to
 47 // Java exceptions), locking/unlocking mechanisms, statistical
 48 // information, etc.
 49 
 50 class SharedRuntime: AllStatic {
 51   friend class VMStructs;
 52 
 53  private:
 54   static bool resolve_sub_helper_internal(methodHandle callee_method, const frame&amp; caller_frame,
 55                                           CompiledMethod* caller_nm, bool is_virtual, bool is_optimized,
 56                                           Handle receiver, CallInfo&amp; call_info, Bytecodes::Code invoke_code, TRAPS);
 57   static methodHandle resolve_sub_helper(JavaThread *thread,
 58                                          bool is_virtual,
<span class="line-modified"> 59                                          bool is_optimized,</span>
<span class="line-added"> 60                                          bool* caller_is_c1, TRAPS);</span>
 61 
 62   // Shared stub locations
 63 
 64   static RuntimeStub*        _wrong_method_blob;
 65   static RuntimeStub*        _wrong_method_abstract_blob;
 66   static RuntimeStub*        _ic_miss_blob;
 67   static RuntimeStub*        _resolve_opt_virtual_call_blob;
 68   static RuntimeStub*        _resolve_virtual_call_blob;
 69   static RuntimeStub*        _resolve_static_call_blob;

 70 
 71   static DeoptimizationBlob* _deopt_blob;
 72 
 73   static SafepointBlob*      _polling_page_vectors_safepoint_handler_blob;
 74   static SafepointBlob*      _polling_page_safepoint_handler_blob;
 75   static SafepointBlob*      _polling_page_return_handler_blob;
 76 
 77 #ifdef COMPILER2
 78   static UncommonTrapBlob*   _uncommon_trap_blob;
 79 #endif // COMPILER2
 80 
 81 #ifndef PRODUCT
 82   // Counters
 83   static int     _nof_megamorphic_calls;         // total # of megamorphic calls (through vtable)
 84 #endif // !PRODUCT
 85 
 86  private:
 87   enum { POLL_AT_RETURN,  POLL_AT_LOOP, POLL_AT_VECTOR_LOOP };
 88   static SafepointBlob* generate_handler_blob(address call_ptr, int poll_type);
 89   static RuntimeStub*   generate_resolve_blob(address destination, const char* name);

 90  public:
 91   static void generate_stubs(void);
 92 
 93   // max bytes for each dtrace string parameter
 94   enum { max_dtrace_string_size = 256 };
 95 
 96   // The following arithmetic routines are used on platforms that do
 97   // not have machine instructions to implement their functionality.
 98   // Do not remove these.
 99 
100   // long arithmetics
101   static jlong   lmul(jlong y, jlong x);
102   static jlong   ldiv(jlong y, jlong x);
103   static jlong   lrem(jlong y, jlong x);
104 
105   // float and double remainder
106   static jfloat  frem(jfloat  x, jfloat  y);
107   static jdouble drem(jdouble x, jdouble y);
108 
109 
</pre>
<hr />
<pre>
303   static char* generate_class_cast_message(JavaThread* thr, Klass* caster_klass);
304 
305   // Fill in the &quot;X cannot be cast to a Y&quot; message for ClassCastException
306   //
307   // @param caster_klass the class of the object we are casting
308   // @param target_klass the target klass attempt
309   // @return the dynamically allocated exception message (must be freed
310   // by the caller using a resource mark)
311   //
312   // This version does not require access the frame, so it can be called
313   // from interpreted code
314   // The caller (or one of it&#39;s callers) must use a ResourceMark
315   // in order to correctly free the result.
316   //
317   static char* generate_class_cast_message(Klass* caster_klass, Klass* target_klass, Symbol* target_klass_name = NULL);
318 
319   // Resolves a call site- may patch in the destination of the call into the
320   // compiled code.
321   static methodHandle resolve_helper(JavaThread *thread,
322                                      bool is_virtual,
<span class="line-modified">323                                      bool is_optimized,</span>
<span class="line-added">324                                      bool* caller_is_c1, TRAPS);</span>
325 
326  private:
327   // deopt blob
328   static void generate_deopt_blob(void);
329 
330   static bool handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm, const frame&amp; caller_frame,
331                                              methodHandle callee_method, Bytecodes::Code bc, CallInfo&amp; call_info,
<span class="line-modified">332                                              bool&amp; needs_ic_stub_refill, bool&amp; is_optimized, bool caller_is_c1, TRAPS);</span>
333 
334  public:
335   static DeoptimizationBlob* deopt_blob(void)      { return _deopt_blob; }
336 
337   // Resets a call-site in compiled code so it will get resolved again.
<span class="line-modified">338   static methodHandle reresolve_call_site(JavaThread *thread, bool&amp; is_static_call, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS);</span>
339 
340   // In the code prolog, if the klass comparison fails, the inline cache
341   // misses and the call site is patched to megamorphic
<span class="line-modified">342   static methodHandle handle_ic_miss_helper(JavaThread* thread, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS);</span>
343 
344   // Find the method that called us.
345   static methodHandle find_callee_method(JavaThread* thread, TRAPS);
346 
347   static void monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);
348 
349   static void monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);
350 
<span class="line-added">351   static address entry_for_handle_wrong_method(methodHandle callee_method, bool is_static_call, bool is_optimized, bool caller_is_c1) {</span>
<span class="line-added">352     assert(callee_method-&gt;verified_code_entry() != NULL, &quot;Jump to zero!&quot;);</span>
<span class="line-added">353     assert(callee_method-&gt;verified_value_code_entry() != NULL, &quot;Jump to zero!&quot;);</span>
<span class="line-added">354     assert(callee_method-&gt;verified_value_ro_code_entry() != NULL, &quot;Jump to zero!&quot;);</span>
<span class="line-added">355     if (caller_is_c1) {</span>
<span class="line-added">356       return callee_method-&gt;verified_value_code_entry();</span>
<span class="line-added">357     } else if (is_static_call || is_optimized) {</span>
<span class="line-added">358       return callee_method-&gt;verified_code_entry();</span>
<span class="line-added">359     } else {</span>
<span class="line-added">360       return callee_method-&gt;verified_value_ro_code_entry();</span>
<span class="line-added">361     }</span>
<span class="line-added">362   }</span>
<span class="line-added">363 </span>
364  private:
365   static Handle find_callee_info(JavaThread* thread,
366                                  Bytecodes::Code&amp; bc,
367                                  CallInfo&amp; callinfo, TRAPS);
368   static Handle find_callee_info_helper(JavaThread* thread,
369                                         vframeStream&amp; vfst,
370                                         Bytecodes::Code&amp; bc,
371                                         CallInfo&amp; callinfo, TRAPS);
372 
373   static Method* extract_attached_method(vframeStream&amp; vfst);
374 




375 #if defined(X86) &amp;&amp; defined(COMPILER1)
376   // For Object.hashCode, System.identityHashCode try to pull hashCode from object header if available.
377   static void inline_check_hashcode_from_object_header(MacroAssembler* masm, const methodHandle&amp; method, Register obj_reg, Register result);
378 #endif // X86 &amp;&amp; COMPILER1
379 
380  public:
381 
382   // Read the array of BasicTypes from a Java signature, and compute where
383   // compiled Java code would like to put the results.  Values in reg_lo and
384   // reg_hi refer to 4-byte quantities.  Values less than SharedInfo::stack0 are
385   // registers, those above refer to 4-byte stack slots.  All stack slots are
386   // based off of the window top.  SharedInfo::stack0 refers to the first usable
387   // slot in the bottom of the frame. SharedInfo::stack0+1 refers to the memory word
388   // 4-bytes higher. So for sparc because the register window save area is at
389   // the bottom of the frame the first 16 words will be skipped and SharedInfo::stack0
390   // will be just above it. (
391   // return value is the maximum number of VMReg stack slots the convention will use.
392   static int java_calling_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed, int is_outgoing);
<span class="line-added">393   static int java_calling_convention(const GrowableArray&lt;SigEntry&gt;* sig, VMRegPair* regs) {</span>
<span class="line-added">394     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sig-&gt;length());</span>
<span class="line-added">395     int total_args_passed = SigEntry::fill_sig_bt(sig, sig_bt);</span>
<span class="line-added">396     return java_calling_convention(sig_bt, regs, total_args_passed, false);</span>
<span class="line-added">397   }</span>
<span class="line-added">398   static int java_return_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed);</span>
<span class="line-added">399   static const uint java_return_convention_max_int;</span>
<span class="line-added">400   static const uint java_return_convention_max_float;</span>
401 
402   static void check_member_name_argument_is_last_argument(const methodHandle&amp; method,
403                                                           const BasicType* sig_bt,
404                                                           const VMRegPair* regs) NOT_DEBUG_RETURN;
405 
406   // Ditto except for calling C
407   //
408   // C argument in register AND stack slot.
409   // Some architectures require that an argument must be passed in a register
410   // AND in a stack slot. These architectures provide a second VMRegPair array
411   // to be filled by the c_calling_convention method. On other architectures,
412   // NULL is being passed as the second VMRegPair array, so arguments are either
413   // passed in a register OR in a stack slot.
414   static int c_calling_convention(const BasicType *sig_bt, VMRegPair *regs, VMRegPair *regs2,
415                                   int total_args_passed);
416 
417   static size_t trampoline_size();
418 
419   static void generate_trampoline(MacroAssembler *masm, address destination);
420 
</pre>
<hr />
<pre>
428   // by the time we reach the blob there is compiled code available. This allows
429   // the blob to pass the incoming stack pointer (the sender sp) in a known
430   // location for the interpreter to record. This is used by the frame code
431   // to correct the sender code to match up with the stack pointer when the
432   // thread left the compiled code. In addition it allows the interpreter
433   // to remove the space the c2i adapter allocated to do its argument conversion.
434 
435   // Although a c2i blob will always run interpreted even if compiled code is
436   // present if we see that compiled code is present the compiled call site
437   // will be patched/re-resolved so that later calls will run compiled.
438 
439   // Additionally a c2i blob need to have a unverified entry because it can be reached
440   // in situations where the call site is an inlined cache site and may go megamorphic.
441 
442   // A i2c adapter is simpler than the c2i adapter. This is because it is assumed
443   // that the interpreter before it does any call dispatch will record the current
444   // stack pointer in the interpreter frame. On return it will restore the stack
445   // pointer as needed. This means the i2c adapter code doesn&#39;t need any special
446   // handshaking path with compiled code to keep the stack walking correct.
447 
<span class="line-modified">448   static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *masm,</span>
<span class="line-modified">449                                                       int comp_args_on_stack,</span>
<span class="line-modified">450                                                       const GrowableArray&lt;SigEntry&gt;* sig,</span>
<span class="line-modified">451                                                       const VMRegPair* regs,</span>
<span class="line-modified">452                                                       const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-modified">453                                                       const VMRegPair* regs_cc,</span>
<span class="line-added">454                                                       const GrowableArray&lt;SigEntry&gt;* sig_cc_ro,</span>
<span class="line-added">455                                                       const VMRegPair* regs_cc_ro,</span>
<span class="line-added">456                                                       AdapterFingerPrint* fingerprint,</span>
<span class="line-added">457                                                       AdapterBlob*&amp; new_adapter);</span>
458 
459   static void gen_i2c_adapter(MacroAssembler *_masm,
<span class="line-modified">460                               int comp_args_on_stack,</span>

461                               const GrowableArray&lt;SigEntry&gt;* sig,
462                               const VMRegPair *regs);
463 
464   // OSR support
465 
466   // OSR_migration_begin will extract the jvm state from an interpreter
467   // frame (locals, monitors) and store the data in a piece of C heap
468   // storage. This then allows the interpreter frame to be removed from the
469   // stack and the OSR nmethod to be called. That method is called with a
470   // pointer to the C heap storage. This pointer is the return value from
471   // OSR_migration_begin.
472 
473   static intptr_t* OSR_migration_begin(JavaThread *thread);
474 
475   // OSR_migration_end is a trivial routine. It is called after the compiled
476   // method has extracted the jvm state from the C heap that OSR_migration_begin
477   // created. It&#39;s entire job is to simply free this storage.
478   static void OSR_migration_end(intptr_t* buf);
479 
480   // Convert a sig into a calling convention register layout
</pre>
<hr />
<pre>
518   static void block_for_jni_critical(JavaThread* thread);
519 
520   // Pin/Unpin object
521   static oopDesc* pin_object(JavaThread* thread, oopDesc* obj);
522   static void unpin_object(JavaThread* thread, oopDesc* obj);
523 
524   // A compiled caller has just called the interpreter, but compiled code
525   // exists.  Patch the caller so he no longer calls into the interpreter.
526   static void fixup_callers_callsite(Method* moop, address ret_pc);
527   static bool should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb);
528 
529   // Slow-path Locking and Unlocking
530   static void complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
531   static void complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread);
532 
533   // Resolving of calls
534   static address resolve_static_call_C     (JavaThread *thread);
535   static address resolve_virtual_call_C    (JavaThread *thread);
536   static address resolve_opt_virtual_call_C(JavaThread *thread);
537 
<span class="line-added">538   static void load_value_type_fields_in_regs(JavaThread *thread, oopDesc* res);</span>
<span class="line-added">539   static void store_value_type_fields_to_buf(JavaThread *thread, intptr_t res);</span>
<span class="line-added">540 </span>
541   // arraycopy, the non-leaf version.  (See StubRoutines for all the leaf calls.)
542   static void slow_arraycopy_C(oopDesc* src,  jint src_pos,
543                                oopDesc* dest, jint dest_pos,
544                                jint length, JavaThread* thread);
545 
546   // handle ic miss with caller being compiled code
547   // wrong method handling (inline cache misses, zombie methods)
548   static address handle_wrong_method(JavaThread* thread);
549   static address handle_wrong_method_abstract(JavaThread* thread);
550   static address handle_wrong_method_ic_miss(JavaThread* thread);
<span class="line-added">551   static void allocate_value_types(JavaThread* thread, Method* callee, bool allocate_receiver);</span>
<span class="line-added">552   static oop allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS);</span>
<span class="line-added">553   static void apply_post_barriers(JavaThread* thread, objArrayOopDesc* array);</span>
554 
555   static address handle_unsafe_access(JavaThread* thread, address next_pc);
556 
<span class="line-added">557   static BufferedValueTypeBlob* generate_buffered_value_type_adapter(const ValueKlass* vk);</span>
558 #ifndef PRODUCT
559 
560   // Collect and print inline cache miss statistics
561  private:
562   enum { maxICmiss_count = 100 };
563   static int     _ICmiss_index;                  // length of IC miss histogram
564   static int     _ICmiss_count[maxICmiss_count]; // miss counts
565   static address _ICmiss_at[maxICmiss_count];    // miss addresses
566   static void trace_ic_miss(address at);
567 
568  public:
569   static int _throw_null_ctr;                    // throwing a null-pointer exception
570   static int _ic_miss_ctr;                       // total # of IC misses
571   static int _wrong_method_ctr;
572   static int _resolve_static_ctr;
573   static int _resolve_virtual_ctr;
574   static int _resolve_opt_virtual_ctr;
575   static int _implicit_null_throws;
576   static int _implicit_div0_throws;
577 
</pre>
<hr />
<pre>
652 // Rmethod-&gt;_i2i_entry.  On entry, the interpreted frame has not yet been
653 // setup.  Compiled frames are fixed-size and the args are likely not in the
654 // right place.  Hence all the args will likely be copied into the
655 // interpreter&#39;s frame, forcing that frame to grow.  The compiled frame&#39;s
656 // outgoing stack args will be dead after the copy.
657 //
658 // Native wrappers, like adapters, marshal arguments.  Unlike adapters they
659 // also perform an official frame push &amp; pop.  They have a call to the native
660 // routine in their middles and end in a return (instead of ending in a jump).
661 // The native wrappers are stored in real nmethods instead of the BufferBlobs
662 // used by the adapters.  The code generation happens here because it&#39;s very
663 // similar to what the adapters have to do.
664 
665 class AdapterHandlerEntry : public BasicHashtableEntry&lt;mtCode&gt; {
666   friend class AdapterHandlerTable;
667 
668  private:
669   AdapterFingerPrint* _fingerprint;
670   address _i2c_entry;
671   address _c2i_entry;
<span class="line-added">672   address _c2i_value_entry;</span>
<span class="line-added">673   address _c2i_value_ro_entry;</span>
674   address _c2i_unverified_entry;
<span class="line-added">675   address _c2i_unverified_value_entry;</span>
676   address _c2i_no_clinit_check_entry;
677 
<span class="line-added">678   // Support for scalarized value type calling convention</span>
<span class="line-added">679   const GrowableArray&lt;SigEntry&gt;* _sig_cc;</span>
<span class="line-added">680 </span>
681 #ifdef ASSERT
682   // Captures code and signature used to generate this adapter when
683   // verifying adapter equivalence.
684   unsigned char* _saved_code;
685   int            _saved_code_length;
686 #endif
687 
<span class="line-modified">688   void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_value_entry,</span>
<span class="line-added">689             address c2i_value_ro_entry, address c2i_unverified_entry, address c2i_unverified_value_entry, address c2i_no_clinit_check_entry) {</span>
690     _fingerprint = fingerprint;
691     _i2c_entry = i2c_entry;
692     _c2i_entry = c2i_entry;
<span class="line-added">693     _c2i_value_entry = c2i_value_entry;</span>
<span class="line-added">694     _c2i_value_ro_entry = c2i_value_ro_entry;</span>
695     _c2i_unverified_entry = c2i_unverified_entry;
<span class="line-added">696     _c2i_unverified_value_entry = c2i_unverified_value_entry;</span>
697     _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;
<span class="line-added">698     _sig_cc = NULL;</span>
699 #ifdef ASSERT
700     _saved_code = NULL;
701     _saved_code_length = 0;
702 #endif
703   }
704 
705   void deallocate();
706 
707   // should never be used
708   AdapterHandlerEntry();
709 
710  public:
711   address get_i2c_entry()                  const { return _i2c_entry; }
712   address get_c2i_entry()                  const { return _c2i_entry; }
<span class="line-added">713   address get_c2i_value_entry()            const { return _c2i_value_entry; }</span>
<span class="line-added">714   address get_c2i_value_ro_entry()         const { return _c2i_value_ro_entry; }</span>
715   address get_c2i_unverified_entry()       const { return _c2i_unverified_entry; }
<span class="line-added">716   address get_c2i_unverified_value_entry() const { return _c2i_unverified_value_entry; }</span>
717   address get_c2i_no_clinit_check_entry()  const { return _c2i_no_clinit_check_entry; }
718 
719   address base_address();
720   void relocate(address new_base);
721 
<span class="line-added">722   // Support for scalarized value type calling convention</span>
<span class="line-added">723   void set_sig_cc(const GrowableArray&lt;SigEntry&gt;* sig)  { _sig_cc = sig; }</span>
<span class="line-added">724   const GrowableArray&lt;SigEntry&gt;* get_sig_cc()    const { return _sig_cc; }</span>
<span class="line-added">725 </span>
726   AdapterFingerPrint* fingerprint() const { return _fingerprint; }
727 
728   AdapterHandlerEntry* next() {
729     return (AdapterHandlerEntry*)BasicHashtableEntry&lt;mtCode&gt;::next();
730   }
731 
732 #ifdef ASSERT
733   // Used to verify that code generated for shared adapters is equivalent
734   void save_code   (unsigned char* code, int length);
735   bool compare_code(unsigned char* code, int length);
736 #endif
737 
738   //virtual void print_on(outputStream* st) const;  DO NOT USE
739   void print_adapter_on(outputStream* st) const;
740 };
741 
742 // This class is used only with DumpSharedSpaces==true. It holds extra information
743 // that&#39;s used only during CDS dump time.
744 // For details, see comments around Method::link_method()
745 class CDSAdapterHandlerEntry: public AdapterHandlerEntry {
<span class="line-modified">746   address               _c2i_entry_trampoline;           // allocated from shared spaces &quot;MC&quot; region</span>
<span class="line-modified">747   address               _c2i_value_ro_entry_trampoline;  // allocated from shared spaces &quot;MC&quot; region</span>
<span class="line-added">748   address               _c2i_value_entry_trampoline;     // allocated from shared spaces &quot;MC&quot; region</span>
<span class="line-added">749   AdapterHandlerEntry** _adapter_trampoline;             // allocated from shared spaces &quot;MD&quot; region</span>
750 
751 public:
752   address get_c2i_entry_trampoline()             const { return _c2i_entry_trampoline; }
<span class="line-added">753   address get_c2i_value_ro_entry_trampoline()    const { return _c2i_value_ro_entry_trampoline; }</span>
<span class="line-added">754   address get_c2i_value_entry_trampoline()       const { return _c2i_value_entry_trampoline; }</span>
755   AdapterHandlerEntry** get_adapter_trampoline() const { return _adapter_trampoline; }
756   void init() NOT_CDS_RETURN;
757 };
758 
759 
760 class AdapterHandlerLibrary: public AllStatic {
761  private:
762   static BufferBlob* _buffer; // the temporary code buffer in CodeCache
763   static AdapterHandlerTable* _adapters;
764   static AdapterHandlerEntry* _abstract_method_handler;
765   static BufferBlob* buffer_blob();
766   static void initialize();
767   static AdapterHandlerEntry* get_adapter0(const methodHandle&amp; method);
768 
769  public:
770 
771   static AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint,
<span class="line-modified">772                                         address i2c_entry, address c2i_entry, address c2i_value_entry, address c2i_value_ro_entry,</span>
<span class="line-modified">773                                         address c2i_unverified_entry, address c2i_unverified_value_entry, address c2i_no_clinit_check_entry = NULL);</span>


774   static void create_native_wrapper(const methodHandle&amp; method);
775   static AdapterHandlerEntry* get_adapter(const methodHandle&amp; method);
776 
777   static void print_handler(const CodeBlob* b) { print_handler_on(tty, b); }
778   static void print_handler_on(outputStream* st, const CodeBlob* b);
779   static bool contains(const CodeBlob* b);
780 #ifndef PRODUCT
781   static void print_statistics();
782 #endif // PRODUCT
783 
784 };
785 
<span class="line-added">786 // Utility class for computing the calling convention of the 3 types</span>
<span class="line-added">787 // of compiled method entries:</span>
<span class="line-added">788 //     Method::_from_compiled_entry               - sig_cc</span>
<span class="line-added">789 //     Method::_from_compiled_value_ro_entry      - sig_cc_ro</span>
<span class="line-added">790 //     Method::_from_compiled_value_entry         - sig</span>
<span class="line-added">791 class CompiledEntrySignature : public StackObj {</span>
<span class="line-added">792   Method* _method;</span>
<span class="line-added">793   int  _num_value_args;</span>
<span class="line-added">794   bool _has_value_recv;</span>
<span class="line-added">795   GrowableArray&lt;SigEntry&gt; *_sig;</span>
<span class="line-added">796   GrowableArray&lt;SigEntry&gt; *_sig_cc;</span>
<span class="line-added">797   GrowableArray&lt;SigEntry&gt; *_sig_cc_ro;</span>
<span class="line-added">798   VMRegPair* _regs;</span>
<span class="line-added">799   VMRegPair* _regs_cc;</span>
<span class="line-added">800   VMRegPair* _regs_cc_ro;</span>
<span class="line-added">801 </span>
<span class="line-added">802   int _args_on_stack;</span>
<span class="line-added">803   int _args_on_stack_cc;</span>
<span class="line-added">804   int _args_on_stack_cc_ro;</span>
<span class="line-added">805 </span>
<span class="line-added">806   bool _c1_needs_stack_repair;</span>
<span class="line-added">807   bool _c2_needs_stack_repair;</span>
<span class="line-added">808   bool _has_scalarized_args;</span>
<span class="line-added">809   bool _has_reserved_entries;</span>
<span class="line-added">810 </span>
<span class="line-added">811 public:</span>
<span class="line-added">812   Method* method()                     const { return _method; }</span>
<span class="line-added">813 </span>
<span class="line-added">814   // Used by Method::_from_compiled_value_entry</span>
<span class="line-added">815   GrowableArray&lt;SigEntry&gt;&amp; sig()       const { return *_sig; }</span>
<span class="line-added">816 </span>
<span class="line-added">817   // Used by Method::_from_compiled_entry</span>
<span class="line-added">818   GrowableArray&lt;SigEntry&gt;&amp; sig_cc()    const { return *_sig_cc; }</span>
<span class="line-added">819 </span>
<span class="line-added">820   // Used by Method::_from_compiled_value_ro_entry</span>
<span class="line-added">821   GrowableArray&lt;SigEntry&gt;&amp; sig_cc_ro() const { return *_sig_cc_ro; }</span>
<span class="line-added">822 </span>
<span class="line-added">823   VMRegPair* regs()                    const { return _regs; }</span>
<span class="line-added">824   VMRegPair* regs_cc()                 const { return _regs_cc; }</span>
<span class="line-added">825   VMRegPair* regs_cc_ro()              const { return _regs_cc_ro; }</span>
<span class="line-added">826 </span>
<span class="line-added">827   int args_on_stack()                  const { return _args_on_stack; }</span>
<span class="line-added">828   int args_on_stack_cc()               const { return _args_on_stack_cc; }</span>
<span class="line-added">829   int args_on_stack_cc_ro()            const { return _args_on_stack_cc_ro; }</span>
<span class="line-added">830 </span>
<span class="line-added">831   int  num_value_args()                const { return _num_value_args; }</span>
<span class="line-added">832   bool has_value_arg()                 const { return _num_value_args &gt; 0;  }</span>
<span class="line-added">833   bool has_value_recv()                const { return _has_value_recv; }</span>
<span class="line-added">834 </span>
<span class="line-added">835   bool has_scalarized_args()           const { return _has_scalarized_args; }</span>
<span class="line-added">836   bool c1_needs_stack_repair()         const { return _c1_needs_stack_repair; }</span>
<span class="line-added">837   bool c2_needs_stack_repair()         const { return _c2_needs_stack_repair; }</span>
<span class="line-added">838   CodeOffsets::Entries c1_value_ro_entry_type() const;</span>
<span class="line-added">839 </span>
<span class="line-added">840   CompiledEntrySignature(Method* method);</span>
<span class="line-added">841   void compute_calling_conventions();</span>
<span class="line-added">842 </span>
<span class="line-added">843 private:</span>
<span class="line-added">844   int compute_scalarized_cc(GrowableArray&lt;SigEntry&gt;*&amp; sig_cc, VMRegPair*&amp; regs_cc, bool scalar_receiver);</span>
<span class="line-added">845   int insert_reserved_entry(int ret_off);</span>
<span class="line-added">846 };</span>
<span class="line-added">847 </span>
848 #endif // SHARE_RUNTIME_SHAREDRUNTIME_HPP
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/stringTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/compiledIC.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/compiledMethod.inline.hpp&quot;
  35 #include &quot;code/scopeDesc.hpp&quot;
  36 #include &quot;code/vtableStubs.hpp&quot;
  37 #include &quot;compiler/abstractCompiler.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
  39 #include &quot;compiler/disassembler.hpp&quot;
  40 #include &quot;gc/shared/barrierSet.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  42 #include &quot;interpreter/interpreter.hpp&quot;
  43 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  44 #include &quot;jfr/jfrEvents.hpp&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;memory/metaspaceShared.hpp&quot;
<a name="1" id="anc1"></a>
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
<a name="2" id="anc2"></a>

  49 #include &quot;oops/klass.hpp&quot;
  50 #include &quot;oops/method.inline.hpp&quot;
  51 #include &quot;oops/objArrayKlass.hpp&quot;
<a name="3" id="anc3"></a>
  52 #include &quot;oops/oop.inline.hpp&quot;
<a name="4" id="anc4"></a>
  53 #include &quot;prims/forte.hpp&quot;
  54 #include &quot;prims/jvmtiExport.hpp&quot;
  55 #include &quot;prims/methodHandles.hpp&quot;
  56 #include &quot;prims/nativeLookup.hpp&quot;
  57 #include &quot;runtime/arguments.hpp&quot;
  58 #include &quot;runtime/atomic.hpp&quot;
  59 #include &quot;runtime/biasedLocking.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/stubRoutines.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vframeArray.hpp&quot;
  70 #include &quot;utilities/copy.hpp&quot;
  71 #include &quot;utilities/dtrace.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;
  73 #include &quot;utilities/hashtable.inline.hpp&quot;
  74 #include &quot;utilities/macros.hpp&quot;
  75 #include &quot;utilities/xmlstream.hpp&quot;
  76 #ifdef COMPILER1
  77 #include &quot;c1/c1_Runtime1.hpp&quot;
  78 #endif
  79 
  80 // Shared stub locations
  81 RuntimeStub*        SharedRuntime::_wrong_method_blob;
  82 RuntimeStub*        SharedRuntime::_wrong_method_abstract_blob;
  83 RuntimeStub*        SharedRuntime::_ic_miss_blob;
  84 RuntimeStub*        SharedRuntime::_resolve_opt_virtual_call_blob;
  85 RuntimeStub*        SharedRuntime::_resolve_virtual_call_blob;
  86 RuntimeStub*        SharedRuntime::_resolve_static_call_blob;
<a name="5" id="anc5"></a><span class="line-removed">  87 address             SharedRuntime::_resolve_static_call_entry;</span>
  88 
  89 DeoptimizationBlob* SharedRuntime::_deopt_blob;
  90 SafepointBlob*      SharedRuntime::_polling_page_vectors_safepoint_handler_blob;
  91 SafepointBlob*      SharedRuntime::_polling_page_safepoint_handler_blob;
  92 SafepointBlob*      SharedRuntime::_polling_page_return_handler_blob;
  93 
  94 #ifdef COMPILER2
  95 UncommonTrapBlob*   SharedRuntime::_uncommon_trap_blob;
  96 #endif // COMPILER2
  97 
  98 
  99 //----------------------------generate_stubs-----------------------------------
 100 void SharedRuntime::generate_stubs() {
 101   _wrong_method_blob                   = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method),          &quot;wrong_method_stub&quot;);
 102   _wrong_method_abstract_blob          = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract), &quot;wrong_method_abstract_stub&quot;);
 103   _ic_miss_blob                        = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss),  &quot;ic_miss_stub&quot;);
 104   _resolve_opt_virtual_call_blob       = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C),   &quot;resolve_opt_virtual_call&quot;);
 105   _resolve_virtual_call_blob           = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C),       &quot;resolve_virtual_call&quot;);
 106   _resolve_static_call_blob            = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C),        &quot;resolve_static_call&quot;);
<a name="6" id="anc6"></a><span class="line-removed"> 107   _resolve_static_call_entry           = _resolve_static_call_blob-&gt;entry_point();</span>
 108 
 109 #if COMPILER2_OR_JVMCI
 110   // Vectors are generated only by C2 and JVMCI.
 111   bool support_wide = is_wide_vector(MaxVectorSize);
 112   if (support_wide) {
 113     _polling_page_vectors_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_VECTOR_LOOP);
 114   }
 115 #endif // COMPILER2_OR_JVMCI
 116   _polling_page_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_LOOP);
 117   _polling_page_return_handler_blob    = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_RETURN);
 118 
 119   generate_deopt_blob();
 120 
 121 #ifdef COMPILER2
 122   generate_uncommon_trap_blob();
 123 #endif // COMPILER2
 124 }
 125 
 126 #include &lt;math.h&gt;
 127 
 128 // Implementation of SharedRuntime
 129 
 130 #ifndef PRODUCT
 131 // For statistics
 132 int SharedRuntime::_ic_miss_ctr = 0;
 133 int SharedRuntime::_wrong_method_ctr = 0;
 134 int SharedRuntime::_resolve_static_ctr = 0;
 135 int SharedRuntime::_resolve_virtual_ctr = 0;
 136 int SharedRuntime::_resolve_opt_virtual_ctr = 0;
 137 int SharedRuntime::_implicit_null_throws = 0;
 138 int SharedRuntime::_implicit_div0_throws = 0;
 139 int SharedRuntime::_throw_null_ctr = 0;
 140 
 141 int SharedRuntime::_nof_normal_calls = 0;
 142 int SharedRuntime::_nof_optimized_calls = 0;
 143 int SharedRuntime::_nof_inlined_calls = 0;
 144 int SharedRuntime::_nof_megamorphic_calls = 0;
 145 int SharedRuntime::_nof_static_calls = 0;
 146 int SharedRuntime::_nof_inlined_static_calls = 0;
 147 int SharedRuntime::_nof_interface_calls = 0;
 148 int SharedRuntime::_nof_optimized_interface_calls = 0;
 149 int SharedRuntime::_nof_inlined_interface_calls = 0;
 150 int SharedRuntime::_nof_megamorphic_interface_calls = 0;
 151 int SharedRuntime::_nof_removable_exceptions = 0;
 152 
 153 int SharedRuntime::_new_instance_ctr=0;
 154 int SharedRuntime::_new_array_ctr=0;
 155 int SharedRuntime::_multi1_ctr=0;
 156 int SharedRuntime::_multi2_ctr=0;
 157 int SharedRuntime::_multi3_ctr=0;
 158 int SharedRuntime::_multi4_ctr=0;
 159 int SharedRuntime::_multi5_ctr=0;
 160 int SharedRuntime::_mon_enter_stub_ctr=0;
 161 int SharedRuntime::_mon_exit_stub_ctr=0;
 162 int SharedRuntime::_mon_enter_ctr=0;
 163 int SharedRuntime::_mon_exit_ctr=0;
 164 int SharedRuntime::_partial_subtype_ctr=0;
 165 int SharedRuntime::_jbyte_array_copy_ctr=0;
 166 int SharedRuntime::_jshort_array_copy_ctr=0;
 167 int SharedRuntime::_jint_array_copy_ctr=0;
 168 int SharedRuntime::_jlong_array_copy_ctr=0;
 169 int SharedRuntime::_oop_array_copy_ctr=0;
 170 int SharedRuntime::_checkcast_array_copy_ctr=0;
 171 int SharedRuntime::_unsafe_array_copy_ctr=0;
 172 int SharedRuntime::_generic_array_copy_ctr=0;
 173 int SharedRuntime::_slow_array_copy_ctr=0;
 174 int SharedRuntime::_find_handler_ctr=0;
 175 int SharedRuntime::_rethrow_ctr=0;
 176 
 177 int     SharedRuntime::_ICmiss_index                    = 0;
 178 int     SharedRuntime::_ICmiss_count[SharedRuntime::maxICmiss_count];
 179 address SharedRuntime::_ICmiss_at[SharedRuntime::maxICmiss_count];
 180 
 181 
 182 void SharedRuntime::trace_ic_miss(address at) {
 183   for (int i = 0; i &lt; _ICmiss_index; i++) {
 184     if (_ICmiss_at[i] == at) {
 185       _ICmiss_count[i]++;
 186       return;
 187     }
 188   }
 189   int index = _ICmiss_index++;
 190   if (_ICmiss_index &gt;= maxICmiss_count) _ICmiss_index = maxICmiss_count - 1;
 191   _ICmiss_at[index] = at;
 192   _ICmiss_count[index] = 1;
 193 }
 194 
 195 void SharedRuntime::print_ic_miss_histogram() {
 196   if (ICMissHistogram) {
 197     tty-&gt;print_cr(&quot;IC Miss Histogram:&quot;);
 198     int tot_misses = 0;
 199     for (int i = 0; i &lt; _ICmiss_index; i++) {
 200       tty-&gt;print_cr(&quot;  at: &quot; INTPTR_FORMAT &quot;  nof: %d&quot;, p2i(_ICmiss_at[i]), _ICmiss_count[i]);
 201       tot_misses += _ICmiss_count[i];
 202     }
 203     tty-&gt;print_cr(&quot;Total IC misses: %7d&quot;, tot_misses);
 204   }
 205 }
 206 #endif // PRODUCT
 207 
 208 
 209 JRT_LEAF(jlong, SharedRuntime::lmul(jlong y, jlong x))
 210   return x * y;
 211 JRT_END
 212 
 213 
 214 JRT_LEAF(jlong, SharedRuntime::ldiv(jlong y, jlong x))
 215   if (x == min_jlong &amp;&amp; y == CONST64(-1)) {
 216     return x;
 217   } else {
 218     return x / y;
 219   }
 220 JRT_END
 221 
 222 
 223 JRT_LEAF(jlong, SharedRuntime::lrem(jlong y, jlong x))
 224   if (x == min_jlong &amp;&amp; y == CONST64(-1)) {
 225     return 0;
 226   } else {
 227     return x % y;
 228   }
 229 JRT_END
 230 
 231 
 232 const juint  float_sign_mask  = 0x7FFFFFFF;
 233 const juint  float_infinity   = 0x7F800000;
 234 const julong double_sign_mask = CONST64(0x7FFFFFFFFFFFFFFF);
 235 const julong double_infinity  = CONST64(0x7FF0000000000000);
 236 
 237 JRT_LEAF(jfloat, SharedRuntime::frem(jfloat  x, jfloat  y))
 238 #ifdef _WIN64
 239   // 64-bit Windows on amd64 returns the wrong values for
 240   // infinity operands.
 241   union { jfloat f; juint i; } xbits, ybits;
 242   xbits.f = x;
 243   ybits.f = y;
 244   // x Mod Infinity == x unless x is infinity
 245   if (((xbits.i &amp; float_sign_mask) != float_infinity) &amp;&amp;
 246        ((ybits.i &amp; float_sign_mask) == float_infinity) ) {
 247     return x;
 248   }
 249   return ((jfloat)fmod_winx64((double)x, (double)y));
 250 #else
 251   return ((jfloat)fmod((double)x,(double)y));
 252 #endif
 253 JRT_END
 254 
 255 
 256 JRT_LEAF(jdouble, SharedRuntime::drem(jdouble x, jdouble y))
 257 #ifdef _WIN64
 258   union { jdouble d; julong l; } xbits, ybits;
 259   xbits.d = x;
 260   ybits.d = y;
 261   // x Mod Infinity == x unless x is infinity
 262   if (((xbits.l &amp; double_sign_mask) != double_infinity) &amp;&amp;
 263        ((ybits.l &amp; double_sign_mask) == double_infinity) ) {
 264     return x;
 265   }
 266   return ((jdouble)fmod_winx64((double)x, (double)y));
 267 #else
 268   return ((jdouble)fmod((double)x,(double)y));
 269 #endif
 270 JRT_END
 271 
 272 #ifdef __SOFTFP__
 273 JRT_LEAF(jfloat, SharedRuntime::fadd(jfloat x, jfloat y))
 274   return x + y;
 275 JRT_END
 276 
 277 JRT_LEAF(jfloat, SharedRuntime::fsub(jfloat x, jfloat y))
 278   return x - y;
 279 JRT_END
 280 
 281 JRT_LEAF(jfloat, SharedRuntime::fmul(jfloat x, jfloat y))
 282   return x * y;
 283 JRT_END
 284 
 285 JRT_LEAF(jfloat, SharedRuntime::fdiv(jfloat x, jfloat y))
 286   return x / y;
 287 JRT_END
 288 
 289 JRT_LEAF(jdouble, SharedRuntime::dadd(jdouble x, jdouble y))
 290   return x + y;
 291 JRT_END
 292 
 293 JRT_LEAF(jdouble, SharedRuntime::dsub(jdouble x, jdouble y))
 294   return x - y;
 295 JRT_END
 296 
 297 JRT_LEAF(jdouble, SharedRuntime::dmul(jdouble x, jdouble y))
 298   return x * y;
 299 JRT_END
 300 
 301 JRT_LEAF(jdouble, SharedRuntime::ddiv(jdouble x, jdouble y))
 302   return x / y;
 303 JRT_END
 304 
 305 JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))
 306   return (jfloat)x;
 307 JRT_END
 308 
 309 JRT_LEAF(jdouble, SharedRuntime::i2d(jint x))
 310   return (jdouble)x;
 311 JRT_END
 312 
 313 JRT_LEAF(jdouble, SharedRuntime::f2d(jfloat x))
 314   return (jdouble)x;
 315 JRT_END
 316 
 317 JRT_LEAF(int,  SharedRuntime::fcmpl(float x, float y))
 318   return x&gt;y ? 1 : (x==y ? 0 : -1);  /* x&lt;y or is_nan*/
 319 JRT_END
 320 
 321 JRT_LEAF(int,  SharedRuntime::fcmpg(float x, float y))
 322   return x&lt;y ? -1 : (x==y ? 0 : 1);  /* x&gt;y or is_nan */
 323 JRT_END
 324 
 325 JRT_LEAF(int,  SharedRuntime::dcmpl(double x, double y))
 326   return x&gt;y ? 1 : (x==y ? 0 : -1); /* x&lt;y or is_nan */
 327 JRT_END
 328 
 329 JRT_LEAF(int,  SharedRuntime::dcmpg(double x, double y))
 330   return x&lt;y ? -1 : (x==y ? 0 : 1);  /* x&gt;y or is_nan */
 331 JRT_END
 332 
 333 // Functions to return the opposite of the aeabi functions for nan.
 334 JRT_LEAF(int, SharedRuntime::unordered_fcmplt(float x, float y))
 335   return (x &lt; y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 336 JRT_END
 337 
 338 JRT_LEAF(int, SharedRuntime::unordered_dcmplt(double x, double y))
 339   return (x &lt; y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 340 JRT_END
 341 
 342 JRT_LEAF(int, SharedRuntime::unordered_fcmple(float x, float y))
 343   return (x &lt;= y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 344 JRT_END
 345 
 346 JRT_LEAF(int, SharedRuntime::unordered_dcmple(double x, double y))
 347   return (x &lt;= y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 348 JRT_END
 349 
 350 JRT_LEAF(int, SharedRuntime::unordered_fcmpge(float x, float y))
 351   return (x &gt;= y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 352 JRT_END
 353 
 354 JRT_LEAF(int, SharedRuntime::unordered_dcmpge(double x, double y))
 355   return (x &gt;= y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 356 JRT_END
 357 
 358 JRT_LEAF(int, SharedRuntime::unordered_fcmpgt(float x, float y))
 359   return (x &gt; y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 360 JRT_END
 361 
 362 JRT_LEAF(int, SharedRuntime::unordered_dcmpgt(double x, double y))
 363   return (x &gt; y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 364 JRT_END
 365 
 366 // Intrinsics make gcc generate code for these.
 367 float  SharedRuntime::fneg(float f)   {
 368   return -f;
 369 }
 370 
 371 double SharedRuntime::dneg(double f)  {
 372   return -f;
 373 }
 374 
 375 #endif // __SOFTFP__
 376 
 377 #if defined(__SOFTFP__) || defined(E500V2)
 378 // Intrinsics make gcc generate code for these.
 379 double SharedRuntime::dabs(double f)  {
 380   return (f &lt;= (double)0.0) ? (double)0.0 - f : f;
 381 }
 382 
 383 #endif
 384 
 385 #if defined(__SOFTFP__) || defined(PPC)
 386 double SharedRuntime::dsqrt(double f) {
 387   return sqrt(f);
 388 }
 389 #endif
 390 
 391 JRT_LEAF(jint, SharedRuntime::f2i(jfloat  x))
 392   if (g_isnan(x))
 393     return 0;
 394   if (x &gt;= (jfloat) max_jint)
 395     return max_jint;
 396   if (x &lt;= (jfloat) min_jint)
 397     return min_jint;
 398   return (jint) x;
 399 JRT_END
 400 
 401 
 402 JRT_LEAF(jlong, SharedRuntime::f2l(jfloat  x))
 403   if (g_isnan(x))
 404     return 0;
 405   if (x &gt;= (jfloat) max_jlong)
 406     return max_jlong;
 407   if (x &lt;= (jfloat) min_jlong)
 408     return min_jlong;
 409   return (jlong) x;
 410 JRT_END
 411 
 412 
 413 JRT_LEAF(jint, SharedRuntime::d2i(jdouble x))
 414   if (g_isnan(x))
 415     return 0;
 416   if (x &gt;= (jdouble) max_jint)
 417     return max_jint;
 418   if (x &lt;= (jdouble) min_jint)
 419     return min_jint;
 420   return (jint) x;
 421 JRT_END
 422 
 423 
 424 JRT_LEAF(jlong, SharedRuntime::d2l(jdouble x))
 425   if (g_isnan(x))
 426     return 0;
 427   if (x &gt;= (jdouble) max_jlong)
 428     return max_jlong;
 429   if (x &lt;= (jdouble) min_jlong)
 430     return min_jlong;
 431   return (jlong) x;
 432 JRT_END
 433 
 434 
 435 JRT_LEAF(jfloat, SharedRuntime::d2f(jdouble x))
 436   return (jfloat)x;
 437 JRT_END
 438 
 439 
 440 JRT_LEAF(jfloat, SharedRuntime::l2f(jlong x))
 441   return (jfloat)x;
 442 JRT_END
 443 
 444 
 445 JRT_LEAF(jdouble, SharedRuntime::l2d(jlong x))
 446   return (jdouble)x;
 447 JRT_END
 448 
 449 // Exception handling across interpreter/compiler boundaries
 450 //
 451 // exception_handler_for_return_address(...) returns the continuation address.
 452 // The continuation address is the entry point of the exception handler of the
 453 // previous frame depending on the return address.
 454 
 455 address SharedRuntime::raw_exception_handler_for_return_address(JavaThread* thread, address return_address) {
 456   assert(frame::verify_return_pc(return_address), &quot;must be a return address: &quot; INTPTR_FORMAT, p2i(return_address));
 457   assert(thread-&gt;frames_to_pop_failed_realloc() == 0 || Interpreter::contains(return_address), &quot;missed frames to pop?&quot;);
 458 
 459   // Reset method handle flag.
 460   thread-&gt;set_is_method_handle_return(false);
 461 
 462 #if INCLUDE_JVMCI
 463   // JVMCI&#39;s ExceptionHandlerStub expects the thread local exception PC to be clear
 464   // and other exception handler continuations do not read it
 465   thread-&gt;set_exception_pc(NULL);
 466 #endif // INCLUDE_JVMCI
 467 
 468   // The fastest case first
 469   CodeBlob* blob = CodeCache::find_blob(return_address);
 470   CompiledMethod* nm = (blob != NULL) ? blob-&gt;as_compiled_method_or_null() : NULL;
 471   if (nm != NULL) {
 472     // Set flag if return address is a method handle call site.
 473     thread-&gt;set_is_method_handle_return(nm-&gt;is_method_handle_return(return_address));
 474     // native nmethods don&#39;t have exception handlers
 475     assert(!nm-&gt;is_native_method(), &quot;no exception handler&quot;);
 476     assert(nm-&gt;header_begin() != nm-&gt;exception_begin(), &quot;no exception handler&quot;);
 477     if (nm-&gt;is_deopt_pc(return_address)) {
 478       // If we come here because of a stack overflow, the stack may be
 479       // unguarded. Reguard the stack otherwise if we return to the
 480       // deopt blob and the stack bang causes a stack overflow we
 481       // crash.
 482       bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 483       if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 484       if (thread-&gt;reserved_stack_activation() != thread-&gt;stack_base()) {
 485         thread-&gt;set_reserved_stack_activation(thread-&gt;stack_base());
 486       }
 487       assert(guard_pages_enabled, &quot;stack banging in deopt blob may cause crash&quot;);
 488       return SharedRuntime::deopt_blob()-&gt;unpack_with_exception();
 489     } else {
 490       return nm-&gt;exception_begin();
 491     }
 492   }
 493 
 494   // Entry code
 495   if (StubRoutines::returns_to_call_stub(return_address)) {
 496     return StubRoutines::catch_exception_entry();
 497   }
 498   // Interpreted code
 499   if (Interpreter::contains(return_address)) {
 500     return Interpreter::rethrow_exception_entry();
 501   }
 502 
 503   guarantee(blob == NULL || !blob-&gt;is_runtime_stub(), &quot;caller should have skipped stub&quot;);
 504   guarantee(!VtableStubs::contains(return_address), &quot;NULL exceptions in vtables should have been handled already!&quot;);
 505 
 506 #ifndef PRODUCT
 507   { ResourceMark rm;
 508     tty-&gt;print_cr(&quot;No exception handler found for exception at &quot; INTPTR_FORMAT &quot; - potential problems:&quot;, p2i(return_address));
 509     tty-&gt;print_cr(&quot;a) exception happened in (new?) code stubs/buffers that is not handled here&quot;);
 510     tty-&gt;print_cr(&quot;b) other problem&quot;);
 511   }
 512 #endif // PRODUCT
 513 
 514   ShouldNotReachHere();
 515   return NULL;
 516 }
 517 
 518 
 519 JRT_LEAF(address, SharedRuntime::exception_handler_for_return_address(JavaThread* thread, address return_address))
 520   return raw_exception_handler_for_return_address(thread, return_address);
 521 JRT_END
 522 
 523 
 524 address SharedRuntime::get_poll_stub(address pc) {
 525   address stub;
 526   // Look up the code blob
 527   CodeBlob *cb = CodeCache::find_blob(pc);
 528 
 529   // Should be an nmethod
 530   guarantee(cb != NULL &amp;&amp; cb-&gt;is_compiled(), &quot;safepoint polling: pc must refer to an nmethod&quot;);
 531 
 532   // Look up the relocation information
 533   assert(((CompiledMethod*)cb)-&gt;is_at_poll_or_poll_return(pc),
 534     &quot;safepoint polling: type must be poll&quot;);
 535 
 536 #ifdef ASSERT
 537   if (!((NativeInstruction*)pc)-&gt;is_safepoint_poll()) {
 538     tty-&gt;print_cr(&quot;bad pc: &quot; PTR_FORMAT, p2i(pc));
 539     Disassembler::decode(cb);
 540     fatal(&quot;Only polling locations are used for safepoint&quot;);
 541   }
 542 #endif
 543 
 544   bool at_poll_return = ((CompiledMethod*)cb)-&gt;is_at_poll_return(pc);
 545   bool has_wide_vectors = ((CompiledMethod*)cb)-&gt;has_wide_vectors();
 546   if (at_poll_return) {
 547     assert(SharedRuntime::polling_page_return_handler_blob() != NULL,
 548            &quot;polling page return stub not created yet&quot;);
 549     stub = SharedRuntime::polling_page_return_handler_blob()-&gt;entry_point();
 550   } else if (has_wide_vectors) {
 551     assert(SharedRuntime::polling_page_vectors_safepoint_handler_blob() != NULL,
 552            &quot;polling page vectors safepoint stub not created yet&quot;);
 553     stub = SharedRuntime::polling_page_vectors_safepoint_handler_blob()-&gt;entry_point();
 554   } else {
 555     assert(SharedRuntime::polling_page_safepoint_handler_blob() != NULL,
 556            &quot;polling page safepoint stub not created yet&quot;);
 557     stub = SharedRuntime::polling_page_safepoint_handler_blob()-&gt;entry_point();
 558   }
 559   log_debug(safepoint)(&quot;... found polling page %s exception at pc = &quot;
 560                        INTPTR_FORMAT &quot;, stub =&quot; INTPTR_FORMAT,
 561                        at_poll_return ? &quot;return&quot; : &quot;loop&quot;,
 562                        (intptr_t)pc, (intptr_t)stub);
 563   return stub;
 564 }
 565 
 566 
 567 oop SharedRuntime::retrieve_receiver( Symbol* sig, frame caller ) {
 568   assert(caller.is_interpreted_frame(), &quot;&quot;);
 569   int args_size = ArgumentSizeComputer(sig).size() + 1;
 570   assert(args_size &lt;= caller.interpreter_frame_expression_stack_size(), &quot;receiver must be on interpreter stack&quot;);
 571   oop result = cast_to_oop(*caller.interpreter_frame_tos_at(args_size - 1));
 572   assert(Universe::heap()-&gt;is_in(result) &amp;&amp; oopDesc::is_oop(result), &quot;receiver must be an oop&quot;);
 573   return result;
 574 }
 575 
 576 
 577 void SharedRuntime::throw_and_post_jvmti_exception(JavaThread *thread, Handle h_exception) {
 578   if (JvmtiExport::can_post_on_exceptions()) {
 579     vframeStream vfst(thread, true);
 580     methodHandle method = methodHandle(thread, vfst.method());
 581     address bcp = method()-&gt;bcp_from(vfst.bci());
 582     JvmtiExport::post_exception_throw(thread, method(), bcp, h_exception());
 583   }
 584   Exceptions::_throw(thread, __FILE__, __LINE__, h_exception);
 585 }
 586 
 587 void SharedRuntime::throw_and_post_jvmti_exception(JavaThread *thread, Symbol* name, const char *message) {
 588   Handle h_exception = Exceptions::new_exception(thread, name, message);
 589   throw_and_post_jvmti_exception(thread, h_exception);
 590 }
 591 
 592 // The interpreter code to call this tracing function is only
 593 // called/generated when UL is on for redefine, class and has the right level
 594 // and tags. Since obsolete methods are never compiled, we don&#39;t have
 595 // to modify the compilers to generate calls to this function.
 596 //
 597 JRT_LEAF(int, SharedRuntime::rc_trace_method_entry(
 598     JavaThread* thread, Method* method))
 599   if (method-&gt;is_obsolete()) {
 600     // We are calling an obsolete method, but this is not necessarily
 601     // an error. Our method could have been redefined just after we
 602     // fetched the Method* from the constant pool.
 603     ResourceMark rm;
 604     log_trace(redefine, class, obsolete)(&quot;calling obsolete method &#39;%s&#39;&quot;, method-&gt;name_and_sig_as_C_string());
 605   }
 606   return 0;
 607 JRT_END
 608 
 609 // ret_pc points into caller; we are returning caller&#39;s exception handler
 610 // for given exception
 611 address SharedRuntime::compute_compiled_exc_handler(CompiledMethod* cm, address ret_pc, Handle&amp; exception,
 612                                                     bool force_unwind, bool top_frame_only, bool&amp; recursive_exception_occurred) {
 613   assert(cm != NULL, &quot;must exist&quot;);
 614   ResourceMark rm;
 615 
 616 #if INCLUDE_JVMCI
 617   if (cm-&gt;is_compiled_by_jvmci()) {
 618     // lookup exception handler for this pc
 619     int catch_pco = ret_pc - cm-&gt;code_begin();
 620     ExceptionHandlerTable table(cm);
 621     HandlerTableEntry *t = table.entry_for(catch_pco, -1, 0);
 622     if (t != NULL) {
 623       return cm-&gt;code_begin() + t-&gt;pco();
 624     } else {
 625       return Deoptimization::deoptimize_for_missing_exception_handler(cm);
 626     }
 627   }
 628 #endif // INCLUDE_JVMCI
 629 
 630   nmethod* nm = cm-&gt;as_nmethod();
 631   ScopeDesc* sd = nm-&gt;scope_desc_at(ret_pc);
 632   // determine handler bci, if any
 633   EXCEPTION_MARK;
 634 
 635   int handler_bci = -1;
 636   int scope_depth = 0;
 637   if (!force_unwind) {
 638     int bci = sd-&gt;bci();
 639     bool recursive_exception = false;
 640     do {
 641       bool skip_scope_increment = false;
 642       // exception handler lookup
 643       Klass* ek = exception-&gt;klass();
 644       methodHandle mh(THREAD, sd-&gt;method());
 645       handler_bci = Method::fast_exception_handler_bci_for(mh, ek, bci, THREAD);
 646       if (HAS_PENDING_EXCEPTION) {
 647         recursive_exception = true;
 648         // We threw an exception while trying to find the exception handler.
 649         // Transfer the new exception to the exception handle which will
 650         // be set into thread local storage, and do another lookup for an
 651         // exception handler for this exception, this time starting at the
 652         // BCI of the exception handler which caused the exception to be
 653         // thrown (bugs 4307310 and 4546590). Set &quot;exception&quot; reference
 654         // argument to ensure that the correct exception is thrown (4870175).
 655         recursive_exception_occurred = true;
 656         exception = Handle(THREAD, PENDING_EXCEPTION);
 657         CLEAR_PENDING_EXCEPTION;
 658         if (handler_bci &gt;= 0) {
 659           bci = handler_bci;
 660           handler_bci = -1;
 661           skip_scope_increment = true;
 662         }
 663       }
 664       else {
 665         recursive_exception = false;
 666       }
 667       if (!top_frame_only &amp;&amp; handler_bci &lt; 0 &amp;&amp; !skip_scope_increment) {
 668         sd = sd-&gt;sender();
 669         if (sd != NULL) {
 670           bci = sd-&gt;bci();
 671         }
 672         ++scope_depth;
 673       }
 674     } while (recursive_exception || (!top_frame_only &amp;&amp; handler_bci &lt; 0 &amp;&amp; sd != NULL));
 675   }
 676 
 677   // found handling method =&gt; lookup exception handler
 678   int catch_pco = ret_pc - nm-&gt;code_begin();
 679 
 680   ExceptionHandlerTable table(nm);
 681   HandlerTableEntry *t = table.entry_for(catch_pco, handler_bci, scope_depth);
 682   if (t == NULL &amp;&amp; (nm-&gt;is_compiled_by_c1() || handler_bci != -1)) {
 683     // Allow abbreviated catch tables.  The idea is to allow a method
 684     // to materialize its exceptions without committing to the exact
 685     // routing of exceptions.  In particular this is needed for adding
 686     // a synthetic handler to unlock monitors when inlining
 687     // synchronized methods since the unlock path isn&#39;t represented in
 688     // the bytecodes.
 689     t = table.entry_for(catch_pco, -1, 0);
 690   }
 691 
 692 #ifdef COMPILER1
 693   if (t == NULL &amp;&amp; nm-&gt;is_compiled_by_c1()) {
 694     assert(nm-&gt;unwind_handler_begin() != NULL, &quot;&quot;);
 695     return nm-&gt;unwind_handler_begin();
 696   }
 697 #endif
 698 
 699   if (t == NULL) {
 700     ttyLocker ttyl;
 701     tty-&gt;print_cr(&quot;MISSING EXCEPTION HANDLER for pc &quot; INTPTR_FORMAT &quot; and handler bci %d&quot;, p2i(ret_pc), handler_bci);
 702     tty-&gt;print_cr(&quot;   Exception:&quot;);
 703     exception-&gt;print();
 704     tty-&gt;cr();
 705     tty-&gt;print_cr(&quot; Compiled exception table :&quot;);
 706     table.print();
 707     nm-&gt;print_code();
 708     guarantee(false, &quot;missing exception handler&quot;);
 709     return NULL;
 710   }
 711 
 712   return nm-&gt;code_begin() + t-&gt;pco();
 713 }
 714 
 715 JRT_ENTRY(void, SharedRuntime::throw_AbstractMethodError(JavaThread* thread))
 716   // These errors occur only at call sites
 717   throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_AbstractMethodError());
 718 JRT_END
 719 
 720 JRT_ENTRY(void, SharedRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))
 721   // These errors occur only at call sites
 722   throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError(), &quot;vtable stub&quot;);
 723 JRT_END
 724 
 725 JRT_ENTRY(void, SharedRuntime::throw_ArithmeticException(JavaThread* thread))
 726   throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArithmeticException(), &quot;/ by zero&quot;);
 727 JRT_END
 728 
 729 JRT_ENTRY(void, SharedRuntime::throw_NullPointerException(JavaThread* thread))
 730   throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());
 731 JRT_END
 732 
 733 JRT_ENTRY(void, SharedRuntime::throw_NullPointerException_at_call(JavaThread* thread))
 734   // This entry point is effectively only used for NullPointerExceptions which occur at inline
 735   // cache sites (when the callee activation is not yet set up) so we are at a call site
 736   throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());
 737 JRT_END
 738 
 739 JRT_ENTRY(void, SharedRuntime::throw_StackOverflowError(JavaThread* thread))
 740   throw_StackOverflowError_common(thread, false);
 741 JRT_END
 742 
 743 JRT_ENTRY(void, SharedRuntime::throw_delayed_StackOverflowError(JavaThread* thread))
 744   throw_StackOverflowError_common(thread, true);
 745 JRT_END
 746 
 747 void SharedRuntime::throw_StackOverflowError_common(JavaThread* thread, bool delayed) {
 748   // We avoid using the normal exception construction in this case because
 749   // it performs an upcall to Java, and we&#39;re already out of stack space.
 750   Thread* THREAD = thread;
 751   Klass* k = SystemDictionary::StackOverflowError_klass();
 752   oop exception_oop = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK);
 753   if (delayed) {
 754     java_lang_Throwable::set_message(exception_oop,
 755                                      Universe::delayed_stack_overflow_error_message());
 756   }
 757   Handle exception (thread, exception_oop);
 758   if (StackTraceInThrowable) {
 759     java_lang_Throwable::fill_in_stack_trace(exception);
 760   }
 761   // Increment counter for hs_err file reporting
 762   Atomic::inc(&amp;Exceptions::_stack_overflow_errors);
 763   throw_and_post_jvmti_exception(thread, exception);
 764 }
 765 
 766 address SharedRuntime::continuation_for_implicit_exception(JavaThread* thread,
 767                                                            address pc,
 768                                                            ImplicitExceptionKind exception_kind)
 769 {
 770   address target_pc = NULL;
 771 
 772   if (Interpreter::contains(pc)) {
 773 #ifdef CC_INTERP
 774     // C++ interpreter doesn&#39;t throw implicit exceptions
 775     ShouldNotReachHere();
 776 #else
 777     switch (exception_kind) {
 778       case IMPLICIT_NULL:           return Interpreter::throw_NullPointerException_entry();
 779       case IMPLICIT_DIVIDE_BY_ZERO: return Interpreter::throw_ArithmeticException_entry();
 780       case STACK_OVERFLOW:          return Interpreter::throw_StackOverflowError_entry();
 781       default:                      ShouldNotReachHere();
 782     }
 783 #endif // !CC_INTERP
 784   } else {
 785     switch (exception_kind) {
 786       case STACK_OVERFLOW: {
 787         // Stack overflow only occurs upon frame setup; the callee is
 788         // going to be unwound. Dispatch to a shared runtime stub
 789         // which will cause the StackOverflowError to be fabricated
 790         // and processed.
 791         // Stack overflow should never occur during deoptimization:
 792         // the compiled method bangs the stack by as much as the
 793         // interpreter would need in case of a deoptimization. The
 794         // deoptimization blob and uncommon trap blob bang the stack
 795         // in a debug VM to verify the correctness of the compiled
 796         // method stack banging.
 797         assert(thread-&gt;deopt_mark() == NULL, &quot;no stack overflow from deopt blob/uncommon trap&quot;);
 798         Events::log_exception(thread, &quot;StackOverflowError at &quot; INTPTR_FORMAT, p2i(pc));
 799         return StubRoutines::throw_StackOverflowError_entry();
 800       }
 801 
 802       case IMPLICIT_NULL: {
 803         if (VtableStubs::contains(pc)) {
 804           // We haven&#39;t yet entered the callee frame. Fabricate an
 805           // exception and begin dispatching it in the caller. Since
 806           // the caller was at a call site, it&#39;s safe to destroy all
 807           // caller-saved registers, as these entry points do.
 808           VtableStub* vt_stub = VtableStubs::stub_containing(pc);
 809 
 810           // If vt_stub is NULL, then return NULL to signal handler to report the SEGV error.
 811           if (vt_stub == NULL) return NULL;
 812 
 813           if (vt_stub-&gt;is_abstract_method_error(pc)) {
 814             assert(!vt_stub-&gt;is_vtable_stub(), &quot;should never see AbstractMethodErrors from vtable-type VtableStubs&quot;);
 815             Events::log_exception(thread, &quot;AbstractMethodError at &quot; INTPTR_FORMAT, p2i(pc));
 816             // Instead of throwing the abstract method error here directly, we re-resolve
 817             // and will throw the AbstractMethodError during resolve. As a result, we&#39;ll
 818             // get a more detailed error message.
 819             return SharedRuntime::get_handle_wrong_method_stub();
 820           } else {
 821             Events::log_exception(thread, &quot;NullPointerException at vtable entry &quot; INTPTR_FORMAT, p2i(pc));
 822             // Assert that the signal comes from the expected location in stub code.
 823             assert(vt_stub-&gt;is_null_pointer_exception(pc),
 824                    &quot;obtained signal from unexpected location in stub code&quot;);
 825             return StubRoutines::throw_NullPointerException_at_call_entry();
 826           }
 827         } else {
 828           CodeBlob* cb = CodeCache::find_blob(pc);
 829 
 830           // If code blob is NULL, then return NULL to signal handler to report the SEGV error.
 831           if (cb == NULL) return NULL;
 832 
 833           // Exception happened in CodeCache. Must be either:
 834           // 1. Inline-cache check in C2I handler blob,
 835           // 2. Inline-cache check in nmethod, or
 836           // 3. Implicit null exception in nmethod
 837 
 838           if (!cb-&gt;is_compiled()) {
 839             bool is_in_blob = cb-&gt;is_adapter_blob() || cb-&gt;is_method_handles_adapter_blob();
 840             if (!is_in_blob) {
 841               // Allow normal crash reporting to handle this
 842               return NULL;
 843             }
 844             Events::log_exception(thread, &quot;NullPointerException in code blob at &quot; INTPTR_FORMAT, p2i(pc));
 845             // There is no handler here, so we will simply unwind.
 846             return StubRoutines::throw_NullPointerException_at_call_entry();
 847           }
 848 
 849           // Otherwise, it&#39;s a compiled method.  Consult its exception handlers.
 850           CompiledMethod* cm = (CompiledMethod*)cb;
 851           if (cm-&gt;inlinecache_check_contains(pc)) {
 852             // exception happened inside inline-cache check code
 853             // =&gt; the nmethod is not yet active (i.e., the frame
 854             // is not set up yet) =&gt; use return address pushed by
 855             // caller =&gt; don&#39;t push another return address
 856             Events::log_exception(thread, &quot;NullPointerException in IC check &quot; INTPTR_FORMAT, p2i(pc));
 857             return StubRoutines::throw_NullPointerException_at_call_entry();
 858           }
 859 
 860           if (cm-&gt;method()-&gt;is_method_handle_intrinsic()) {
 861             // exception happened inside MH dispatch code, similar to a vtable stub
 862             Events::log_exception(thread, &quot;NullPointerException in MH adapter &quot; INTPTR_FORMAT, p2i(pc));
 863             return StubRoutines::throw_NullPointerException_at_call_entry();
 864           }
 865 
 866 #ifndef PRODUCT
 867           _implicit_null_throws++;
 868 #endif
 869           target_pc = cm-&gt;continuation_for_implicit_null_exception(pc);
 870           // If there&#39;s an unexpected fault, target_pc might be NULL,
 871           // in which case we want to fall through into the normal
 872           // error handling code.
 873         }
 874 
 875         break; // fall through
 876       }
 877 
 878 
 879       case IMPLICIT_DIVIDE_BY_ZERO: {
 880         CompiledMethod* cm = CodeCache::find_compiled(pc);
 881         guarantee(cm != NULL, &quot;must have containing compiled method for implicit division-by-zero exceptions&quot;);
 882 #ifndef PRODUCT
 883         _implicit_div0_throws++;
 884 #endif
 885         target_pc = cm-&gt;continuation_for_implicit_div0_exception(pc);
 886         // If there&#39;s an unexpected fault, target_pc might be NULL,
 887         // in which case we want to fall through into the normal
 888         // error handling code.
 889         break; // fall through
 890       }
 891 
 892       default: ShouldNotReachHere();
 893     }
 894 
 895     assert(exception_kind == IMPLICIT_NULL || exception_kind == IMPLICIT_DIVIDE_BY_ZERO, &quot;wrong implicit exception kind&quot;);
 896 
 897     if (exception_kind == IMPLICIT_NULL) {
 898 #ifndef PRODUCT
 899       // for AbortVMOnException flag
 900       Exceptions::debug_check_abort(&quot;java.lang.NullPointerException&quot;);
 901 #endif //PRODUCT
 902       Events::log_exception(thread, &quot;Implicit null exception at &quot; INTPTR_FORMAT &quot; to &quot; INTPTR_FORMAT, p2i(pc), p2i(target_pc));
 903     } else {
 904 #ifndef PRODUCT
 905       // for AbortVMOnException flag
 906       Exceptions::debug_check_abort(&quot;java.lang.ArithmeticException&quot;);
 907 #endif //PRODUCT
 908       Events::log_exception(thread, &quot;Implicit division by zero exception at &quot; INTPTR_FORMAT &quot; to &quot; INTPTR_FORMAT, p2i(pc), p2i(target_pc));
 909     }
 910     return target_pc;
 911   }
 912 
 913   ShouldNotReachHere();
 914   return NULL;
 915 }
 916 
 917 
 918 /**
 919  * Throws an java/lang/UnsatisfiedLinkError.  The address of this method is
 920  * installed in the native function entry of all native Java methods before
 921  * they get linked to their actual native methods.
 922  *
 923  * \note
 924  * This method actually never gets called!  The reason is because
 925  * the interpreter&#39;s native entries call NativeLookup::lookup() which
 926  * throws the exception when the lookup fails.  The exception is then
 927  * caught and forwarded on the return from NativeLookup::lookup() call
 928  * before the call to the native function.  This might change in the future.
 929  */
 930 JNI_ENTRY(void*, throw_unsatisfied_link_error(JNIEnv* env, ...))
 931 {
 932   // We return a bad value here to make sure that the exception is
 933   // forwarded before we look at the return value.
 934   THROW_(vmSymbols::java_lang_UnsatisfiedLinkError(), (void*)badAddress);
 935 }
 936 JNI_END
 937 
 938 address SharedRuntime::native_method_throw_unsatisfied_link_error_entry() {
 939   return CAST_FROM_FN_PTR(address, &amp;throw_unsatisfied_link_error);
 940 }
 941 
 942 JRT_ENTRY_NO_ASYNC(void, SharedRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))
 943 #if INCLUDE_JVMCI
 944   if (!obj-&gt;klass()-&gt;has_finalizer()) {
 945     return;
 946   }
 947 #endif // INCLUDE_JVMCI
 948   assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
 949   assert(obj-&gt;klass()-&gt;has_finalizer(), &quot;shouldn&#39;t be here otherwise&quot;);
 950   InstanceKlass::register_finalizer(instanceOop(obj), CHECK);
 951 JRT_END
 952 
 953 
 954 jlong SharedRuntime::get_java_tid(Thread* thread) {
 955   if (thread != NULL) {
 956     if (thread-&gt;is_Java_thread()) {
 957       oop obj = ((JavaThread*)thread)-&gt;threadObj();
 958       return (obj == NULL) ? 0 : java_lang_Thread::thread_id(obj);
 959     }
 960   }
 961   return 0;
 962 }
 963 
 964 /**
 965  * This function ought to be a void function, but cannot be because
 966  * it gets turned into a tail-call on sparc, which runs into dtrace bug
 967  * 6254741.  Once that is fixed we can remove the dummy return value.
 968  */
 969 int SharedRuntime::dtrace_object_alloc(oopDesc* o, int size) {
 970   return dtrace_object_alloc_base(Thread::current(), o, size);
 971 }
 972 
 973 int SharedRuntime::dtrace_object_alloc_base(Thread* thread, oopDesc* o, int size) {
 974   assert(DTraceAllocProbes, &quot;wrong call&quot;);
 975   Klass* klass = o-&gt;klass();
 976   Symbol* name = klass-&gt;name();
 977   HOTSPOT_OBJECT_ALLOC(
 978                    get_java_tid(thread),
 979                    (char *) name-&gt;bytes(), name-&gt;utf8_length(), size * HeapWordSize);
 980   return 0;
 981 }
 982 
 983 JRT_LEAF(int, SharedRuntime::dtrace_method_entry(
 984     JavaThread* thread, Method* method))
 985   assert(DTraceMethodProbes, &quot;wrong call&quot;);
 986   Symbol* kname = method-&gt;klass_name();
 987   Symbol* name = method-&gt;name();
 988   Symbol* sig = method-&gt;signature();
 989   HOTSPOT_METHOD_ENTRY(
 990       get_java_tid(thread),
 991       (char *) kname-&gt;bytes(), kname-&gt;utf8_length(),
 992       (char *) name-&gt;bytes(), name-&gt;utf8_length(),
 993       (char *) sig-&gt;bytes(), sig-&gt;utf8_length());
 994   return 0;
 995 JRT_END
 996 
 997 JRT_LEAF(int, SharedRuntime::dtrace_method_exit(
 998     JavaThread* thread, Method* method))
 999   assert(DTraceMethodProbes, &quot;wrong call&quot;);
1000   Symbol* kname = method-&gt;klass_name();
1001   Symbol* name = method-&gt;name();
1002   Symbol* sig = method-&gt;signature();
1003   HOTSPOT_METHOD_RETURN(
1004       get_java_tid(thread),
1005       (char *) kname-&gt;bytes(), kname-&gt;utf8_length(),
1006       (char *) name-&gt;bytes(), name-&gt;utf8_length(),
1007       (char *) sig-&gt;bytes(), sig-&gt;utf8_length());
1008   return 0;
1009 JRT_END
1010 
1011 
1012 // Finds receiver, CallInfo (i.e. receiver method), and calling bytecode)
1013 // for a call current in progress, i.e., arguments has been pushed on stack
1014 // put callee has not been invoked yet.  Used by: resolve virtual/static,
1015 // vtable updates, etc.  Caller frame must be compiled.
1016 Handle SharedRuntime::find_callee_info(JavaThread* thread, Bytecodes::Code&amp; bc, CallInfo&amp; callinfo, TRAPS) {
1017   ResourceMark rm(THREAD);
1018 
1019   // last java frame on stack (which includes native call frames)
1020   vframeStream vfst(thread, true);  // Do not skip and javaCalls
1021 
1022   return find_callee_info_helper(thread, vfst, bc, callinfo, THREAD);
1023 }
1024 
1025 Method* SharedRuntime::extract_attached_method(vframeStream&amp; vfst) {
1026   CompiledMethod* caller = vfst.nm();
1027 
1028   nmethodLocker caller_lock(caller);
1029 
1030   address pc = vfst.frame_pc();
1031   { // Get call instruction under lock because another thread may be busy patching it.
1032     CompiledICLocker ic_locker(caller);
1033     return caller-&gt;attached_method_before_pc(pc);
1034   }
1035   return NULL;
1036 }
1037 
1038 // Finds receiver, CallInfo (i.e. receiver method), and calling bytecode
1039 // for a call current in progress, i.e., arguments has been pushed on stack
1040 // but callee has not been invoked yet.  Caller frame must be compiled.
1041 Handle SharedRuntime::find_callee_info_helper(JavaThread* thread,
1042                                               vframeStream&amp; vfst,
1043                                               Bytecodes::Code&amp; bc,
1044                                               CallInfo&amp; callinfo, TRAPS) {
1045   Handle receiver;
1046   Handle nullHandle;  //create a handy null handle for exception returns
1047 
1048   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1049 
1050   // Find caller and bci from vframe
1051   methodHandle caller(THREAD, vfst.method());
1052   int          bci   = vfst.bci();
1053 
<a name="7" id="anc7"></a>














1054   Bytecode_invoke bytecode(caller, bci);
1055   int bytecode_index = bytecode.index();
1056   bc = bytecode.invoke_code();
1057 
1058   methodHandle attached_method(THREAD, extract_attached_method(vfst));
1059   if (attached_method.not_null()) {
1060     Method* callee = bytecode.static_target(CHECK_NH);
1061     vmIntrinsics::ID id = callee-&gt;intrinsic_id();
1062     // When VM replaces MH.invokeBasic/linkTo* call with a direct/virtual call,
1063     // it attaches statically resolved method to the call site.
1064     if (MethodHandles::is_signature_polymorphic(id) &amp;&amp;
1065         MethodHandles::is_signature_polymorphic_intrinsic(id)) {
1066       bc = MethodHandles::signature_polymorphic_intrinsic_bytecode(id);
1067 
1068       // Adjust invocation mode according to the attached method.
1069       switch (bc) {
1070         case Bytecodes::_invokevirtual:
1071           if (attached_method-&gt;method_holder()-&gt;is_interface()) {
1072             bc = Bytecodes::_invokeinterface;
1073           }
1074           break;
1075         case Bytecodes::_invokeinterface:
1076           if (!attached_method-&gt;method_holder()-&gt;is_interface()) {
1077             bc = Bytecodes::_invokevirtual;
1078           }
1079           break;
1080         case Bytecodes::_invokehandle:
1081           if (!MethodHandles::is_signature_polymorphic_method(attached_method())) {
1082             bc = attached_method-&gt;is_static() ? Bytecodes::_invokestatic
1083                                               : Bytecodes::_invokevirtual;
1084           }
1085           break;
1086         default:
1087           break;
1088       }
<a name="8" id="anc8"></a>





1089     }
1090   }
1091 
1092   assert(bc != Bytecodes::_illegal, &quot;not initialized&quot;);
1093 
1094   bool has_receiver = bc != Bytecodes::_invokestatic &amp;&amp;
1095                       bc != Bytecodes::_invokedynamic &amp;&amp;
1096                       bc != Bytecodes::_invokehandle;
<a name="9" id="anc9"></a>
1097 
1098   // Find receiver for non-static call
1099   if (has_receiver) {
1100     // This register map must be update since we need to find the receiver for
1101     // compiled frames. The receiver might be in a register.
1102     RegisterMap reg_map2(thread);
1103     frame stubFrame   = thread-&gt;last_frame();
1104     // Caller-frame is a compiled frame
1105     frame callerFrame = stubFrame.sender(&amp;reg_map2);
<a name="10" id="anc10"></a>
1106 
<a name="11" id="anc11"></a><span class="line-modified">1107     if (attached_method.is_null()) {</span>
<span class="line-modified">1108       Method* callee = bytecode.static_target(CHECK_NH);</span>





1109       if (callee == NULL) {
1110         THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
1111       }
1112     }
<a name="12" id="anc12"></a><span class="line-modified">1113 </span>
<span class="line-modified">1114     // Retrieve from a compiled argument list</span>
<span class="line-modified">1115     receiver = Handle(THREAD, callerFrame.retrieve_receiver(&amp;reg_map2));</span>
<span class="line-modified">1116 </span>
<span class="line-modified">1117     if (receiver.is_null()) {</span>
<span class="line-modified">1118       THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);</span>








1119     }
1120   }
1121 
1122   // Resolve method
1123   if (attached_method.not_null()) {
1124     // Parameterized by attached method.
<a name="13" id="anc13"></a><span class="line-modified">1125     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, CHECK_NH);</span>
1126   } else {
1127     // Parameterized by bytecode.
1128     constantPoolHandle constants(THREAD, caller-&gt;constants());
1129     LinkResolver::resolve_invoke(callinfo, receiver, constants, bytecode_index, bc, CHECK_NH);
1130   }
1131 
1132 #ifdef ASSERT
1133   // Check that the receiver klass is of the right subtype and that it is initialized for virtual calls
<a name="14" id="anc14"></a><span class="line-modified">1134   if (has_receiver) {</span>
1135     assert(receiver.not_null(), &quot;should have thrown exception&quot;);
1136     Klass* receiver_klass = receiver-&gt;klass();
1137     Klass* rk = NULL;
1138     if (attached_method.not_null()) {
1139       // In case there&#39;s resolved method attached, use its holder during the check.
1140       rk = attached_method-&gt;method_holder();
1141     } else {
1142       // Klass is already loaded.
1143       constantPoolHandle constants(THREAD, caller-&gt;constants());
1144       rk = constants-&gt;klass_ref_at(bytecode_index, CHECK_NH);
1145     }
1146     Klass* static_receiver_klass = rk;
1147     assert(receiver_klass-&gt;is_subtype_of(static_receiver_klass),
1148            &quot;actual receiver must be subclass of static receiver klass&quot;);
1149     if (receiver_klass-&gt;is_instance_klass()) {
1150       if (InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized()) {
1151         tty-&gt;print_cr(&quot;ERROR: Klass not yet initialized!!&quot;);
1152         receiver_klass-&gt;print();
1153       }
1154       assert(!InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized(), &quot;receiver_klass must be initialized&quot;);
1155     }
1156   }
1157 #endif
1158 
1159   return receiver;
1160 }
1161 
1162 methodHandle SharedRuntime::find_callee_method(JavaThread* thread, TRAPS) {
1163   ResourceMark rm(THREAD);
1164   // We need first to check if any Java activations (compiled, interpreted)
1165   // exist on the stack since last JavaCall.  If not, we need
1166   // to get the target method from the JavaCall wrapper.
1167   vframeStream vfst(thread, true);  // Do not skip any javaCalls
1168   methodHandle callee_method;
1169   if (vfst.at_end()) {
1170     // No Java frames were found on stack since we did the JavaCall.
1171     // Hence the stack can only contain an entry_frame.  We need to
1172     // find the target method from the stub frame.
1173     RegisterMap reg_map(thread, false);
1174     frame fr = thread-&gt;last_frame();
1175     assert(fr.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1176     fr = fr.sender(&amp;reg_map);
1177     assert(fr.is_entry_frame(), &quot;must be&quot;);
1178     // fr is now pointing to the entry frame.
1179     callee_method = methodHandle(THREAD, fr.entry_frame_call_wrapper()-&gt;callee_method());
1180   } else {
1181     Bytecodes::Code bc;
1182     CallInfo callinfo;
1183     find_callee_info_helper(thread, vfst, bc, callinfo, CHECK_(methodHandle()));
1184     callee_method = methodHandle(THREAD, callinfo.selected_method());
1185   }
1186   assert(callee_method()-&gt;is_method(), &quot;must be&quot;);
1187   return callee_method;
1188 }
1189 
1190 // Resolves a call.
1191 methodHandle SharedRuntime::resolve_helper(JavaThread *thread,
1192                                            bool is_virtual,
<a name="15" id="anc15"></a><span class="line-modified">1193                                            bool is_optimized, TRAPS) {</span>

1194   methodHandle callee_method;
<a name="16" id="anc16"></a><span class="line-modified">1195   callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, THREAD);</span>
1196   if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
1197     int retry_count = 0;
1198     while (!HAS_PENDING_EXCEPTION &amp;&amp; callee_method-&gt;is_old() &amp;&amp;
1199            callee_method-&gt;method_holder() != SystemDictionary::Object_klass()) {
1200       // If has a pending exception then there is no need to re-try to
1201       // resolve this method.
1202       // If the method has been redefined, we need to try again.
1203       // Hack: we have no way to update the vtables of arrays, so don&#39;t
1204       // require that java.lang.Object has been updated.
1205 
1206       // It is very unlikely that method is redefined more than 100 times
1207       // in the middle of resolve. If it is looping here more than 100 times
1208       // means then there could be a bug here.
1209       guarantee((retry_count++ &lt; 100),
1210                 &quot;Could not resolve to latest version of redefined method&quot;);
1211       // method is redefined in the middle of resolve so re-try.
<a name="17" id="anc17"></a><span class="line-modified">1212       callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, THREAD);</span>
1213     }
1214   }
1215   return callee_method;
1216 }
1217 
1218 // This fails if resolution required refilling of IC stubs
1219 bool SharedRuntime::resolve_sub_helper_internal(methodHandle callee_method, const frame&amp; caller_frame,
1220                                                 CompiledMethod* caller_nm, bool is_virtual, bool is_optimized,
1221                                                 Handle receiver, CallInfo&amp; call_info, Bytecodes::Code invoke_code, TRAPS) {
1222   StaticCallInfo static_call_info;
1223   CompiledICInfo virtual_call_info;
1224 
1225   // Make sure the callee nmethod does not get deoptimized and removed before
1226   // we are done patching the code.
1227   CompiledMethod* callee = callee_method-&gt;code();
1228 
1229   if (callee != NULL) {
1230     assert(callee-&gt;is_compiled(), &quot;must be nmethod for patching&quot;);
1231   }
1232 
1233   if (callee != NULL &amp;&amp; !callee-&gt;is_in_use()) {
1234     // Patch call site to C2I adapter if callee nmethod is deoptimized or unloaded.
1235     callee = NULL;
1236   }
1237   nmethodLocker nl_callee(callee);
1238 #ifdef ASSERT
1239   address dest_entry_point = callee == NULL ? 0 : callee-&gt;entry_point(); // used below
1240 #endif
1241 
1242   bool is_nmethod = caller_nm-&gt;is_nmethod();
<a name="18" id="anc18"></a>
1243 
1244   if (is_virtual) {
<a name="19" id="anc19"></a><span class="line-modified">1245     assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);</span>







1246     bool static_bound = call_info.resolved_method()-&gt;can_be_statically_bound();
<a name="20" id="anc20"></a><span class="line-modified">1247     Klass* klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();</span>
<span class="line-modified">1248     CompiledIC::compute_monomorphic_entry(callee_method, klass,</span>
<span class="line-removed">1249                      is_optimized, static_bound, is_nmethod, virtual_call_info,</span>
1250                      CHECK_false);
1251   } else {
1252     // static call
<a name="21" id="anc21"></a><span class="line-modified">1253     CompiledStaticCall::compute_entry(callee_method, is_nmethod, static_call_info);</span>
1254   }
1255 
1256   // grab lock, check for deoptimization and potentially patch caller
1257   {
1258     CompiledICLocker ml(caller_nm);
1259 
1260     // Lock blocks for safepoint during which both nmethods can change state.
1261 
1262     // Now that we are ready to patch if the Method* was redefined then
1263     // don&#39;t update call site and let the caller retry.
1264     // Don&#39;t update call site if callee nmethod was unloaded or deoptimized.
1265     // Don&#39;t update call site if callee nmethod was replaced by an other nmethod
1266     // which may happen when multiply alive nmethod (tiered compilation)
1267     // will be supported.
1268     if (!callee_method-&gt;is_old() &amp;&amp;
1269         (callee == NULL || (callee-&gt;is_in_use() &amp;&amp; callee_method-&gt;code() == callee))) {
1270       NoSafepointVerifier nsv;
1271 #ifdef ASSERT
1272       // We must not try to patch to jump to an already unloaded method.
1273       if (dest_entry_point != 0) {
1274         CodeBlob* cb = CodeCache::find_blob(dest_entry_point);
1275         assert((cb != NULL) &amp;&amp; cb-&gt;is_compiled() &amp;&amp; (((CompiledMethod*)cb) == callee),
1276                &quot;should not call unloaded nmethod&quot;);
1277       }
1278 #endif
1279       if (is_virtual) {
1280         CompiledIC* inline_cache = CompiledIC_before(caller_nm, caller_frame.pc());
1281         if (inline_cache-&gt;is_clean()) {
1282           if (!inline_cache-&gt;set_to_monomorphic(virtual_call_info)) {
1283             return false;
1284           }
1285         }
1286       } else {
1287         if (VM_Version::supports_fast_class_init_checks() &amp;&amp;
1288             invoke_code == Bytecodes::_invokestatic &amp;&amp;
1289             callee_method-&gt;needs_clinit_barrier() &amp;&amp;
1290             callee != NULL &amp;&amp; (callee-&gt;is_compiled_by_jvmci() || callee-&gt;is_aot())) {
1291           return true; // skip patching for JVMCI or AOT code
1292         }
1293         CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_before(caller_frame.pc());
1294         if (ssc-&gt;is_clean()) ssc-&gt;set(static_call_info);
1295       }
1296     }
1297   } // unlock CompiledICLocker
1298   return true;
1299 }
1300 
1301 // Resolves a call.  The compilers generate code for calls that go here
1302 // and are patched with the real destination of the call.
1303 methodHandle SharedRuntime::resolve_sub_helper(JavaThread *thread,
1304                                                bool is_virtual,
<a name="22" id="anc22"></a><span class="line-modified">1305                                                bool is_optimized, TRAPS) {</span>

1306 
1307   ResourceMark rm(thread);
1308   RegisterMap cbl_map(thread, false);
1309   frame caller_frame = thread-&gt;last_frame().sender(&amp;cbl_map);
1310 
1311   CodeBlob* caller_cb = caller_frame.cb();
1312   guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
1313   CompiledMethod* caller_nm = caller_cb-&gt;as_compiled_method_or_null();
<a name="23" id="anc23"></a>
1314 
1315   // make sure caller is not getting deoptimized
1316   // and removed before we are done with it.
1317   // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1318   nmethodLocker caller_lock(caller_nm);
1319 
1320   // determine call info &amp; receiver
1321   // note: a) receiver is NULL for static calls
1322   //       b) an exception is thrown if receiver is NULL for non-static calls
1323   CallInfo call_info;
1324   Bytecodes::Code invoke_code = Bytecodes::_illegal;
1325   Handle receiver = find_callee_info(thread, invoke_code,
1326                                      call_info, CHECK_(methodHandle()));
1327   methodHandle callee_method(THREAD, call_info.selected_method());
1328 
1329   assert((!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokestatic ) ||
1330          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokespecial) ||
1331          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokehandle ) ||
1332          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokedynamic) ||
1333          ( is_virtual &amp;&amp; invoke_code != Bytecodes::_invokestatic ), &quot;inconsistent bytecode&quot;);
1334 
1335   assert(caller_nm-&gt;is_alive() &amp;&amp; !caller_nm-&gt;is_unloading(), &quot;It should be alive&quot;);
1336 
1337 #ifndef PRODUCT
1338   // tracing/debugging/statistics
1339   int *addr = (is_optimized) ? (&amp;_resolve_opt_virtual_ctr) :
1340                 (is_virtual) ? (&amp;_resolve_virtual_ctr) :
1341                                (&amp;_resolve_static_ctr);
1342   Atomic::inc(addr);
1343 
1344   if (TraceCallFixup) {
1345     ResourceMark rm(thread);
1346     tty-&gt;print(&quot;resolving %s%s (%s) call to&quot;,
1347       (is_optimized) ? &quot;optimized &quot; : &quot;&quot;, (is_virtual) ? &quot;virtual&quot; : &quot;static&quot;,
1348       Bytecodes::name(invoke_code));
1349     callee_method-&gt;print_short_name(tty);
1350     tty-&gt;print_cr(&quot; at pc: &quot; INTPTR_FORMAT &quot; to code: &quot; INTPTR_FORMAT,
1351                   p2i(caller_frame.pc()), p2i(callee_method-&gt;code()));
1352   }
1353 #endif
1354 
1355   if (invoke_code == Bytecodes::_invokestatic) {
1356     assert(callee_method-&gt;method_holder()-&gt;is_initialized() ||
1357            callee_method-&gt;method_holder()-&gt;is_reentrant_initialization(thread),
1358            &quot;invalid class initialization state for invoke_static&quot;);
1359     if (!VM_Version::supports_fast_class_init_checks() &amp;&amp; callee_method-&gt;needs_clinit_barrier()) {
1360       // In order to keep class initialization check, do not patch call
1361       // site for static call when the class is not fully initialized.
1362       // Proper check is enforced by call site re-resolution on every invocation.
1363       //
1364       // When fast class initialization checks are supported (VM_Version::supports_fast_class_init_checks() == true),
1365       // explicit class initialization check is put in nmethod entry (VEP).
1366       assert(callee_method-&gt;method_holder()-&gt;is_linked(), &quot;must be&quot;);
1367       return callee_method;
1368     }
1369   }
1370 
1371   // JSR 292 key invariant:
1372   // If the resolved method is a MethodHandle invoke target, the call
1373   // site must be a MethodHandle call site, because the lambda form might tail-call
1374   // leaving the stack in a state unknown to either caller or callee
1375   // TODO detune for now but we might need it again
1376 //  assert(!callee_method-&gt;is_compiled_lambda_form() ||
1377 //         caller_nm-&gt;is_method_handle_return(caller_frame.pc()), &quot;must be MH call site&quot;);
1378 
1379   // Compute entry points. This might require generation of C2I converter
1380   // frames, so we cannot be holding any locks here. Furthermore, the
1381   // computation of the entry points is independent of patching the call.  We
1382   // always return the entry-point, but we only patch the stub if the call has
1383   // not been deoptimized.  Return values: For a virtual call this is an
1384   // (cached_oop, destination address) pair. For a static call/optimized
1385   // virtual this is just a destination address.
1386 
1387   // Patching IC caches may fail if we run out if transition stubs.
1388   // We refill the ic stubs then and try again.
1389   for (;;) {
1390     ICRefillVerifier ic_refill_verifier;
1391     bool successful = resolve_sub_helper_internal(callee_method, caller_frame, caller_nm,
1392                                                   is_virtual, is_optimized, receiver,
1393                                                   call_info, invoke_code, CHECK_(methodHandle()));
1394     if (successful) {
1395       return callee_method;
1396     } else {
1397       InlineCacheBuffer::refill_ic_stubs();
1398     }
1399   }
1400 
1401 }
1402 
1403 
1404 // Inline caches exist only in compiled code
1405 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_ic_miss(JavaThread* thread))
1406 #ifdef ASSERT
1407   RegisterMap reg_map(thread, false);
1408   frame stub_frame = thread-&gt;last_frame();
1409   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1410   frame caller_frame = stub_frame.sender(&amp;reg_map);
1411   assert(!caller_frame.is_interpreted_frame() &amp;&amp; !caller_frame.is_entry_frame(), &quot;unexpected frame&quot;);
1412 #endif /* ASSERT */
1413 
1414   methodHandle callee_method;
<a name="24" id="anc24"></a>

1415   JRT_BLOCK
<a name="25" id="anc25"></a><span class="line-modified">1416     callee_method = SharedRuntime::handle_ic_miss_helper(thread, CHECK_NULL);</span>
1417     // Return Method* through TLS
1418     thread-&gt;set_vm_result_2(callee_method());
1419   JRT_BLOCK_END
1420   // return compiled code entry point after potential safepoints
<a name="26" id="anc26"></a><span class="line-modified">1421   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-removed">1422   return callee_method-&gt;verified_code_entry();</span>
1423 JRT_END
1424 
1425 
1426 // Handle call site that has been made non-entrant
1427 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* thread))
1428   // 6243940 We might end up in here if the callee is deoptimized
1429   // as we race to call it.  We don&#39;t want to take a safepoint if
1430   // the caller was interpreted because the caller frame will look
1431   // interpreted to the stack walkers and arguments are now
1432   // &quot;compiled&quot; so it is much better to make this transition
1433   // invisible to the stack walking code. The i2c path will
1434   // place the callee method in the callee_target. It is stashed
1435   // there because if we try and find the callee by normal means a
1436   // safepoint is possible and have trouble gc&#39;ing the compiled args.
1437   RegisterMap reg_map(thread, false);
1438   frame stub_frame = thread-&gt;last_frame();
1439   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1440   frame caller_frame = stub_frame.sender(&amp;reg_map);
1441 
1442   if (caller_frame.is_interpreted_frame() ||
1443       caller_frame.is_entry_frame()) {
1444     Method* callee = thread-&gt;callee_target();
1445     guarantee(callee != NULL &amp;&amp; callee-&gt;is_method(), &quot;bad handshake&quot;);
1446     thread-&gt;set_vm_result_2(callee);
1447     thread-&gt;set_callee_target(NULL);
1448     if (caller_frame.is_entry_frame() &amp;&amp; VM_Version::supports_fast_class_init_checks()) {
1449       // Bypass class initialization checks in c2i when caller is in native.
1450       // JNI calls to static methods don&#39;t have class initialization checks.
1451       // Fast class initialization checks are present in c2i adapters and call into
1452       // SharedRuntime::handle_wrong_method() on the slow path.
1453       //
1454       // JVM upcalls may land here as well, but there&#39;s a proper check present in
1455       // LinkResolver::resolve_static_call (called from JavaCalls::call_static),
1456       // so bypassing it in c2i adapter is benign.
1457       return callee-&gt;get_c2i_no_clinit_check_entry();
1458     } else {
1459       return callee-&gt;get_c2i_entry();
1460     }
1461   }
1462 
1463   // Must be compiled to compiled path which is safe to stackwalk
1464   methodHandle callee_method;
<a name="27" id="anc27"></a>


1465   JRT_BLOCK
1466     // Force resolving of caller (if we called from compiled frame)
<a name="28" id="anc28"></a><span class="line-modified">1467     callee_method = SharedRuntime::reresolve_call_site(thread, CHECK_NULL);</span>
1468     thread-&gt;set_vm_result_2(callee_method());
1469   JRT_BLOCK_END
1470   // return compiled code entry point after potential safepoints
<a name="29" id="anc29"></a><span class="line-modified">1471   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-removed">1472   return callee_method-&gt;verified_code_entry();</span>
1473 JRT_END
1474 
1475 // Handle abstract method call
1476 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* thread))
1477   // Verbose error message for AbstractMethodError.
1478   // Get the called method from the invoke bytecode.
1479   vframeStream vfst(thread, true);
1480   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1481   methodHandle caller(thread, vfst.method());
1482   Bytecode_invoke invoke(caller, vfst.bci());
1483   DEBUG_ONLY( invoke.verify(); )
1484 
1485   // Find the compiled caller frame.
1486   RegisterMap reg_map(thread);
1487   frame stubFrame = thread-&gt;last_frame();
1488   assert(stubFrame.is_runtime_frame(), &quot;must be&quot;);
1489   frame callerFrame = stubFrame.sender(&amp;reg_map);
1490   assert(callerFrame.is_compiled_frame(), &quot;must be&quot;);
1491 
1492   // Install exception and return forward entry.
1493   address res = StubRoutines::throw_AbstractMethodError_entry();
1494   JRT_BLOCK
1495     methodHandle callee(thread, invoke.static_target(thread));
1496     if (!callee.is_null()) {
1497       oop recv = callerFrame.retrieve_receiver(&amp;reg_map);
1498       Klass *recv_klass = (recv != NULL) ? recv-&gt;klass() : NULL;
1499       LinkResolver::throw_abstract_method_error(callee, recv_klass, thread);
1500       res = StubRoutines::forward_exception_entry();
1501     }
1502   JRT_BLOCK_END
1503   return res;
1504 JRT_END
1505 
1506 
1507 // resolve a static call and patch code
1508 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread *thread ))
1509   methodHandle callee_method;
<a name="30" id="anc30"></a>
1510   JRT_BLOCK
<a name="31" id="anc31"></a><span class="line-modified">1511     callee_method = SharedRuntime::resolve_helper(thread, false, false, CHECK_NULL);</span>
1512     thread-&gt;set_vm_result_2(callee_method());
1513   JRT_BLOCK_END
1514   // return compiled code entry point after potential safepoints
<a name="32" id="anc32"></a><span class="line-modified">1515   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-modified">1516   return callee_method-&gt;verified_code_entry();</span>


1517 JRT_END
1518 
1519 
1520 // resolve virtual call and update inline cache to monomorphic
1521 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread *thread ))
1522   methodHandle callee_method;
<a name="33" id="anc33"></a>
1523   JRT_BLOCK
<a name="34" id="anc34"></a><span class="line-modified">1524     callee_method = SharedRuntime::resolve_helper(thread, true, false, CHECK_NULL);</span>
1525     thread-&gt;set_vm_result_2(callee_method());
1526   JRT_BLOCK_END
1527   // return compiled code entry point after potential safepoints
<a name="35" id="anc35"></a><span class="line-modified">1528   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-modified">1529   return callee_method-&gt;verified_code_entry();</span>


1530 JRT_END
1531 
1532 
1533 // Resolve a virtual call that can be statically bound (e.g., always
1534 // monomorphic, so it has no inline cache).  Patch code to resolved target.
1535 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread *thread))
1536   methodHandle callee_method;
<a name="36" id="anc36"></a>
1537   JRT_BLOCK
<a name="37" id="anc37"></a><span class="line-modified">1538     callee_method = SharedRuntime::resolve_helper(thread, true, true, CHECK_NULL);</span>
1539     thread-&gt;set_vm_result_2(callee_method());
1540   JRT_BLOCK_END
1541   // return compiled code entry point after potential safepoints
<a name="38" id="anc38"></a><span class="line-modified">1542   assert(callee_method-&gt;verified_code_entry() != NULL, &quot; Jump to zero!&quot;);</span>
<span class="line-modified">1543   return callee_method-&gt;verified_code_entry();</span>


1544 JRT_END
1545 
1546 // The handle_ic_miss_helper_internal function returns false if it failed due
1547 // to either running out of vtable stubs or ic stubs due to IC transitions
1548 // to transitional states. The needs_ic_stub_refill value will be set if
1549 // the failure was due to running out of IC stubs, in which case handle_ic_miss_helper
1550 // refills the IC stubs and tries again.
1551 bool SharedRuntime::handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm,
1552                                                    const frame&amp; caller_frame, methodHandle callee_method,
1553                                                    Bytecodes::Code bc, CallInfo&amp; call_info,
<a name="39" id="anc39"></a><span class="line-modified">1554                                                    bool&amp; needs_ic_stub_refill, TRAPS) {</span>
1555   CompiledICLocker ml(caller_nm);
1556   CompiledIC* inline_cache = CompiledIC_before(caller_nm, caller_frame.pc());
1557   bool should_be_mono = false;
1558   if (inline_cache-&gt;is_optimized()) {
1559     if (TraceCallFixup) {
1560       ResourceMark rm(THREAD);
1561       tty-&gt;print(&quot;OPTIMIZED IC miss (%s) call to&quot;, Bytecodes::name(bc));
1562       callee_method-&gt;print_short_name(tty);
1563       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1564     }
<a name="40" id="anc40"></a>
1565     should_be_mono = true;
1566   } else if (inline_cache-&gt;is_icholder_call()) {
1567     CompiledICHolder* ic_oop = inline_cache-&gt;cached_icholder();
1568     if (ic_oop != NULL) {
1569       if (!ic_oop-&gt;is_loader_alive()) {
1570         // Deferred IC cleaning due to concurrent class unloading
1571         if (!inline_cache-&gt;set_to_clean()) {
1572           needs_ic_stub_refill = true;
1573           return false;
1574         }
1575       } else if (receiver()-&gt;klass() == ic_oop-&gt;holder_klass()) {
1576         // This isn&#39;t a real miss. We must have seen that compiled code
1577         // is now available and we want the call site converted to a
1578         // monomorphic compiled call site.
1579         // We can&#39;t assert for callee_method-&gt;code() != NULL because it
1580         // could have been deoptimized in the meantime
1581         if (TraceCallFixup) {
1582           ResourceMark rm(THREAD);
1583           tty-&gt;print(&quot;FALSE IC miss (%s) converting to compiled call to&quot;, Bytecodes::name(bc));
1584           callee_method-&gt;print_short_name(tty);
1585           tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1586         }
1587         should_be_mono = true;
1588       }
1589     }
1590   }
1591 
1592   if (should_be_mono) {
1593     // We have a path that was monomorphic but was going interpreted
1594     // and now we have (or had) a compiled entry. We correct the IC
1595     // by using a new icBuffer.
1596     CompiledICInfo info;
1597     Klass* receiver_klass = receiver()-&gt;klass();
1598     inline_cache-&gt;compute_monomorphic_entry(callee_method,
1599                                             receiver_klass,
1600                                             inline_cache-&gt;is_optimized(),
1601                                             false, caller_nm-&gt;is_nmethod(),
<a name="41" id="anc41"></a>
1602                                             info, CHECK_false);
1603     if (!inline_cache-&gt;set_to_monomorphic(info)) {
1604       needs_ic_stub_refill = true;
1605       return false;
1606     }
1607   } else if (!inline_cache-&gt;is_megamorphic() &amp;&amp; !inline_cache-&gt;is_clean()) {
1608     // Potential change to megamorphic
1609 
<a name="42" id="anc42"></a><span class="line-modified">1610     bool successful = inline_cache-&gt;set_to_megamorphic(&amp;call_info, bc, needs_ic_stub_refill, CHECK_false);</span>
1611     if (needs_ic_stub_refill) {
1612       return false;
1613     }
1614     if (!successful) {
1615       if (!inline_cache-&gt;set_to_clean()) {
1616         needs_ic_stub_refill = true;
1617         return false;
1618       }
1619     }
1620   } else {
1621     // Either clean or megamorphic
1622   }
1623   return true;
1624 }
1625 
<a name="43" id="anc43"></a><span class="line-modified">1626 methodHandle SharedRuntime::handle_ic_miss_helper(JavaThread *thread, TRAPS) {</span>
1627   ResourceMark rm(thread);
1628   CallInfo call_info;
1629   Bytecodes::Code bc;
1630 
1631   // receiver is NULL for static calls. An exception is thrown for NULL
1632   // receivers for non-static calls
1633   Handle receiver = find_callee_info(thread, bc, call_info,
1634                                      CHECK_(methodHandle()));
1635   // Compiler1 can produce virtual call sites that can actually be statically bound
1636   // If we fell thru to below we would think that the site was going megamorphic
1637   // when in fact the site can never miss. Worse because we&#39;d think it was megamorphic
1638   // we&#39;d try and do a vtable dispatch however methods that can be statically bound
1639   // don&#39;t have vtable entries (vtable_index &lt; 0) and we&#39;d blow up. So we force a
1640   // reresolution of the  call site (as if we did a handle_wrong_method and not an
1641   // plain ic_miss) and the site will be converted to an optimized virtual call site
1642   // never to miss again. I don&#39;t believe C2 will produce code like this but if it
1643   // did this would still be the correct thing to do for it too, hence no ifdef.
1644   //
1645   if (call_info.resolved_method()-&gt;can_be_statically_bound()) {
<a name="44" id="anc44"></a><span class="line-modified">1646     methodHandle callee_method = SharedRuntime::reresolve_call_site(thread, CHECK_(methodHandle()));</span>


1647     if (TraceCallFixup) {
1648       RegisterMap reg_map(thread, false);
1649       frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1650       ResourceMark rm(thread);
1651       tty-&gt;print(&quot;converting IC miss to reresolve (%s) call to&quot;, Bytecodes::name(bc));
1652       callee_method-&gt;print_short_name(tty);
1653       tty-&gt;print_cr(&quot; from pc: &quot; INTPTR_FORMAT, p2i(caller_frame.pc()));
1654       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1655     }
1656     return callee_method;
1657   }
1658 
1659   methodHandle callee_method(thread, call_info.selected_method());
1660 
1661 #ifndef PRODUCT
1662   Atomic::inc(&amp;_ic_miss_ctr);
1663 
1664   // Statistics &amp; Tracing
1665   if (TraceCallFixup) {
1666     ResourceMark rm(thread);
1667     tty-&gt;print(&quot;IC miss (%s) call to&quot;, Bytecodes::name(bc));
1668     callee_method-&gt;print_short_name(tty);
1669     tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1670   }
1671 
1672   if (ICMissHistogram) {
1673     MutexLocker m(VMStatistic_lock);
1674     RegisterMap reg_map(thread, false);
1675     frame f = thread-&gt;last_frame().real_sender(&amp;reg_map);// skip runtime stub
1676     // produce statistics under the lock
1677     trace_ic_miss(f.pc());
1678   }
1679 #endif
1680 
1681   // install an event collector so that when a vtable stub is created the
1682   // profiler can be notified via a DYNAMIC_CODE_GENERATED event. The
1683   // event can&#39;t be posted when the stub is created as locks are held
1684   // - instead the event will be deferred until the event collector goes
1685   // out of scope.
1686   JvmtiDynamicCodeEventCollector event_collector;
1687 
1688   // Update inline cache to megamorphic. Skip update if we are called from interpreted.
1689   // Transitioning IC caches may require transition stubs. If we run out
1690   // of transition stubs, we have to drop locks and perform a safepoint
1691   // that refills them.
1692   RegisterMap reg_map(thread, false);
1693   frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1694   CodeBlob* cb = caller_frame.cb();
1695   CompiledMethod* caller_nm = cb-&gt;as_compiled_method();
<a name="45" id="anc45"></a>
1696 
1697   for (;;) {
1698     ICRefillVerifier ic_refill_verifier;
1699     bool needs_ic_stub_refill = false;
1700     bool successful = handle_ic_miss_helper_internal(receiver, caller_nm, caller_frame, callee_method,
<a name="46" id="anc46"></a><span class="line-modified">1701                                                      bc, call_info, needs_ic_stub_refill, CHECK_(methodHandle()));</span>
1702     if (successful || !needs_ic_stub_refill) {
1703       return callee_method;
1704     } else {
1705       InlineCacheBuffer::refill_ic_stubs();
1706     }
1707   }
1708 }
1709 
1710 static bool clear_ic_at_addr(CompiledMethod* caller_nm, address call_addr, bool is_static_call) {
1711   CompiledICLocker ml(caller_nm);
1712   if (is_static_call) {
1713     CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_at(call_addr);
1714     if (!ssc-&gt;is_clean()) {
1715       return ssc-&gt;set_to_clean();
1716     }
1717   } else {
1718     // compiled, dispatched call (which used to call an interpreted method)
1719     CompiledIC* inline_cache = CompiledIC_at(caller_nm, call_addr);
1720     if (!inline_cache-&gt;is_clean()) {
1721       return inline_cache-&gt;set_to_clean();
1722     }
1723   }
1724   return true;
1725 }
1726 
1727 //
1728 // Resets a call-site in compiled code so it will get resolved again.
1729 // This routines handles both virtual call sites, optimized virtual call
1730 // sites, and static call sites. Typically used to change a call sites
1731 // destination from compiled to interpreted.
1732 //
<a name="47" id="anc47"></a><span class="line-modified">1733 methodHandle SharedRuntime::reresolve_call_site(JavaThread *thread, TRAPS) {</span>
1734   ResourceMark rm(thread);
1735   RegisterMap reg_map(thread, false);
1736   frame stub_frame = thread-&gt;last_frame();
1737   assert(stub_frame.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1738   frame caller = stub_frame.sender(&amp;reg_map);
1739 
1740   // Do nothing if the frame isn&#39;t a live compiled frame.
1741   // nmethod could be deoptimized by the time we get here
1742   // so no update to the caller is needed.
1743 
1744   if (caller.is_compiled_frame() &amp;&amp; !caller.is_deoptimized_frame()) {
1745 
1746     address pc = caller.pc();
1747 
1748     // Check for static or virtual call
<a name="48" id="anc48"></a><span class="line-modified">1749     bool is_static_call = false;</span>
1750     CompiledMethod* caller_nm = CodeCache::find_compiled(pc);
1751 
1752     // Default call_addr is the location of the &quot;basic&quot; call.
1753     // Determine the address of the call we a reresolving. With
1754     // Inline Caches we will always find a recognizable call.
1755     // With Inline Caches disabled we may or may not find a
1756     // recognizable call. We will always find a call for static
1757     // calls and for optimized virtual calls. For vanilla virtual
1758     // calls it depends on the state of the UseInlineCaches switch.
1759     //
1760     // With Inline Caches disabled we can get here for a virtual call
1761     // for two reasons:
1762     //   1 - calling an abstract method. The vtable for abstract methods
1763     //       will run us thru handle_wrong_method and we will eventually
1764     //       end up in the interpreter to throw the ame.
1765     //   2 - a racing deoptimization. We could be doing a vanilla vtable
1766     //       call and between the time we fetch the entry address and
1767     //       we jump to it the target gets deoptimized. Similar to 1
1768     //       we will wind up in the interprter (thru a c2i with c2).
1769     //
1770     address call_addr = NULL;
1771     {
1772       // Get call instruction under lock because another thread may be
1773       // busy patching it.
1774       CompiledICLocker ml(caller_nm);
1775       // Location of call instruction
1776       call_addr = caller_nm-&gt;call_instruction_address(pc);
1777     }
1778     // Make sure nmethod doesn&#39;t get deoptimized and removed until
1779     // this is done with it.
1780     // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1781     nmethodLocker nmlock(caller_nm);
1782 
1783     if (call_addr != NULL) {
1784       RelocIterator iter(caller_nm, call_addr, call_addr+1);
1785       int ret = iter.next(); // Get item
1786       if (ret) {
1787         assert(iter.addr() == call_addr, &quot;must find call&quot;);
1788         if (iter.type() == relocInfo::static_call_type) {
1789           is_static_call = true;
1790         } else {
1791           assert(iter.type() == relocInfo::virtual_call_type ||
1792                  iter.type() == relocInfo::opt_virtual_call_type
1793                 , &quot;unexpected relocInfo. type&quot;);
<a name="49" id="anc49"></a>
1794         }
1795       } else {
1796         assert(!UseInlineCaches, &quot;relocation info. must exist for this address&quot;);
1797       }
1798 
1799       // Cleaning the inline cache will force a new resolve. This is more robust
1800       // than directly setting it to the new destination, since resolving of calls
1801       // is always done through the same code path. (experience shows that it
1802       // leads to very hard to track down bugs, if an inline cache gets updated
1803       // to a wrong method). It should not be performance critical, since the
1804       // resolve is only done once.
1805 
1806       for (;;) {
1807         ICRefillVerifier ic_refill_verifier;
1808         if (!clear_ic_at_addr(caller_nm, call_addr, is_static_call)) {
1809           InlineCacheBuffer::refill_ic_stubs();
1810         } else {
1811           break;
1812         }
1813       }
1814     }
1815   }
1816 
1817   methodHandle callee_method = find_callee_method(thread, CHECK_(methodHandle()));
1818 
<a name="50" id="anc50"></a><span class="line-removed">1819 </span>
1820 #ifndef PRODUCT
1821   Atomic::inc(&amp;_wrong_method_ctr);
1822 
1823   if (TraceCallFixup) {
1824     ResourceMark rm(thread);
1825     tty-&gt;print(&quot;handle_wrong_method reresolving call to&quot;);
1826     callee_method-&gt;print_short_name(tty);
1827     tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1828   }
1829 #endif
1830 
1831   return callee_method;
1832 }
1833 
1834 address SharedRuntime::handle_unsafe_access(JavaThread* thread, address next_pc) {
1835   // The faulting unsafe accesses should be changed to throw the error
1836   // synchronously instead. Meanwhile the faulting instruction will be
1837   // skipped over (effectively turning it into a no-op) and an
1838   // asynchronous exception will be raised which the thread will
1839   // handle at a later point. If the instruction is a load it will
1840   // return garbage.
1841 
1842   // Request an async exception.
1843   thread-&gt;set_pending_unsafe_access_error();
1844 
1845   // Return address of next instruction to execute.
1846   return next_pc;
1847 }
1848 
1849 #ifdef ASSERT
1850 void SharedRuntime::check_member_name_argument_is_last_argument(const methodHandle&amp; method,
1851                                                                 const BasicType* sig_bt,
1852                                                                 const VMRegPair* regs) {
1853   ResourceMark rm;
1854   const int total_args_passed = method-&gt;size_of_parameters();
1855   const VMRegPair*    regs_with_member_name = regs;
1856         VMRegPair* regs_without_member_name = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed - 1);
1857 
1858   const int member_arg_pos = total_args_passed - 1;
1859   assert(member_arg_pos &gt;= 0 &amp;&amp; member_arg_pos &lt; total_args_passed, &quot;oob&quot;);
1860   assert(sig_bt[member_arg_pos] == T_OBJECT, &quot;dispatch argument must be an object&quot;);
1861 
1862   const bool is_outgoing = method-&gt;is_method_handle_intrinsic();
1863   int comp_args_on_stack = java_calling_convention(sig_bt, regs_without_member_name, total_args_passed - 1, is_outgoing);
1864 
1865   for (int i = 0; i &lt; member_arg_pos; i++) {
1866     VMReg a =    regs_with_member_name[i].first();
1867     VMReg b = regs_without_member_name[i].first();
1868     assert(a-&gt;value() == b-&gt;value(), &quot;register allocation mismatch: a=&quot; INTX_FORMAT &quot;, b=&quot; INTX_FORMAT, a-&gt;value(), b-&gt;value());
1869   }
1870   assert(regs_with_member_name[member_arg_pos].first()-&gt;is_valid(), &quot;bad member arg&quot;);
1871 }
1872 #endif
1873 
1874 bool SharedRuntime::should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb) {
1875   if (destination != entry_point) {
1876     CodeBlob* callee = CodeCache::find_blob(destination);
1877     // callee == cb seems weird. It means calling interpreter thru stub.
1878     if (callee != NULL &amp;&amp; (callee == cb || callee-&gt;is_adapter_blob())) {
1879       // static call or optimized virtual
1880       if (TraceCallFixup) {
1881         tty-&gt;print(&quot;fixup callsite           at &quot; INTPTR_FORMAT &quot; to compiled code for&quot;, p2i(caller_pc));
1882         moop-&gt;print_short_name(tty);
1883         tty-&gt;print_cr(&quot; to &quot; INTPTR_FORMAT, p2i(entry_point));
1884       }
1885       return true;
1886     } else {
1887       if (TraceCallFixup) {
1888         tty-&gt;print(&quot;failed to fixup callsite at &quot; INTPTR_FORMAT &quot; to compiled code for&quot;, p2i(caller_pc));
1889         moop-&gt;print_short_name(tty);
1890         tty-&gt;print_cr(&quot; to &quot; INTPTR_FORMAT, p2i(entry_point));
1891       }
1892       // assert is too strong could also be resolve destinations.
1893       // assert(InlineCacheBuffer::contains(destination) || VtableStubs::contains(destination), &quot;must be&quot;);
1894     }
1895   } else {
1896     if (TraceCallFixup) {
1897       tty-&gt;print(&quot;already patched callsite at &quot; INTPTR_FORMAT &quot; to compiled code for&quot;, p2i(caller_pc));
1898       moop-&gt;print_short_name(tty);
1899       tty-&gt;print_cr(&quot; to &quot; INTPTR_FORMAT, p2i(entry_point));
1900     }
1901   }
1902   return false;
1903 }
1904 
1905 // ---------------------------------------------------------------------------
1906 // We are calling the interpreter via a c2i. Normally this would mean that
1907 // we were called by a compiled method. However we could have lost a race
1908 // where we went int -&gt; i2c -&gt; c2i and so the caller could in fact be
1909 // interpreted. If the caller is compiled we attempt to patch the caller
1910 // so he no longer calls into the interpreter.
1911 JRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))
1912   Method* moop(method);
1913 
<a name="51" id="anc51"></a><span class="line-removed">1914   address entry_point = moop-&gt;from_compiled_entry_no_trampoline();</span>
<span class="line-removed">1915 </span>
1916   // It&#39;s possible that deoptimization can occur at a call site which hasn&#39;t
1917   // been resolved yet, in which case this function will be called from
1918   // an nmethod that has been patched for deopt and we can ignore the
1919   // request for a fixup.
1920   // Also it is possible that we lost a race in that from_compiled_entry
1921   // is now back to the i2c in that case we don&#39;t need to patch and if
1922   // we did we&#39;d leap into space because the callsite needs to use
1923   // &quot;to interpreter&quot; stub in order to load up the Method*. Don&#39;t
1924   // ask me how I know this...
1925 
1926   CodeBlob* cb = CodeCache::find_blob(caller_pc);
<a name="52" id="anc52"></a><span class="line-modified">1927   if (cb == NULL || !cb-&gt;is_compiled() || entry_point == moop-&gt;get_c2i_entry()) {</span>




1928     return;
1929   }
1930 
1931   // The check above makes sure this is a nmethod.
1932   CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
1933   assert(nm, &quot;must be&quot;);
1934 
1935   // Get the return PC for the passed caller PC.
1936   address return_pc = caller_pc + frame::pc_return_offset;
1937 
1938   // There is a benign race here. We could be attempting to patch to a compiled
1939   // entry point at the same time the callee is being deoptimized. If that is
1940   // the case then entry_point may in fact point to a c2i and we&#39;d patch the
1941   // call site with the same old data. clear_code will set code() to NULL
1942   // at the end of it. If we happen to see that NULL then we can skip trying
1943   // to patch. If we hit the window where the callee has a c2i in the
1944   // from_compiled_entry and the NULL isn&#39;t present yet then we lose the race
1945   // and patch the code with the same old data. Asi es la vida.
1946 
1947   if (moop-&gt;code() == NULL) return;
1948 
1949   if (nm-&gt;is_in_use()) {
1950     // Expect to find a native call there (unless it was no-inline cache vtable dispatch)
1951     CompiledICLocker ic_locker(nm);
1952     if (NativeCall::is_call_before(return_pc)) {
1953       ResourceMark mark;
1954       NativeCallWrapper* call = nm-&gt;call_wrapper_before(return_pc);
1955       //
1956       // bug 6281185. We might get here after resolving a call site to a vanilla
1957       // virtual call. Because the resolvee uses the verified entry it may then
1958       // see compiled code and attempt to patch the site by calling us. This would
1959       // then incorrectly convert the call site to optimized and its downhill from
1960       // there. If you&#39;re lucky you&#39;ll get the assert in the bugid, if not you&#39;ve
1961       // just made a call site that could be megamorphic into a monomorphic site
1962       // for the rest of its life! Just another racing bug in the life of
1963       // fixup_callers_callsite ...
1964       //
1965       RelocIterator iter(nm, call-&gt;instruction_address(), call-&gt;next_instruction_address());
1966       iter.next();
1967       assert(iter.has_current(), &quot;must have a reloc at java call site&quot;);
1968       relocInfo::relocType typ = iter.reloc()-&gt;type();
1969       if (typ != relocInfo::static_call_type &amp;&amp;
1970            typ != relocInfo::opt_virtual_call_type &amp;&amp;
1971            typ != relocInfo::static_stub_type) {
1972         return;
1973       }
1974       address destination = call-&gt;destination();
1975       if (should_fixup_call_destination(destination, entry_point, caller_pc, moop, cb)) {
1976         call-&gt;set_destination_mt_safe(entry_point);
1977       }
1978     }
1979   }
1980 JRT_END
1981 
1982 
1983 // same as JVM_Arraycopy, but called directly from compiled code
1984 JRT_ENTRY(void, SharedRuntime::slow_arraycopy_C(oopDesc* src,  jint src_pos,
1985                                                 oopDesc* dest, jint dest_pos,
1986                                                 jint length,
1987                                                 JavaThread* thread)) {
1988 #ifndef PRODUCT
1989   _slow_array_copy_ctr++;
1990 #endif
1991   // Check if we have null pointers
1992   if (src == NULL || dest == NULL) {
1993     THROW(vmSymbols::java_lang_NullPointerException());
1994   }
1995   // Do the copy.  The casts to arrayOop are necessary to the copy_array API,
1996   // even though the copy_array API also performs dynamic checks to ensure
1997   // that src and dest are truly arrays (and are conformable).
1998   // The copy_array mechanism is awkward and could be removed, but
1999   // the compilers don&#39;t call this function except as a last resort,
2000   // so it probably doesn&#39;t matter.
2001   src-&gt;klass()-&gt;copy_array((arrayOopDesc*)src, src_pos,
2002                                         (arrayOopDesc*)dest, dest_pos,
2003                                         length, thread);
2004 }
2005 JRT_END
2006 
2007 // The caller of generate_class_cast_message() (or one of its callers)
2008 // must use a ResourceMark in order to correctly free the result.
2009 char* SharedRuntime::generate_class_cast_message(
2010     JavaThread* thread, Klass* caster_klass) {
2011 
2012   // Get target class name from the checkcast instruction
2013   vframeStream vfst(thread, true);
2014   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
2015   Bytecode_checkcast cc(vfst.method(), vfst.method()-&gt;bcp_from(vfst.bci()));
2016   constantPoolHandle cpool(thread, vfst.method()-&gt;constants());
2017   Klass* target_klass = ConstantPool::klass_at_if_loaded(cpool, cc.index());
2018   Symbol* target_klass_name = NULL;
2019   if (target_klass == NULL) {
2020     // This klass should be resolved, but just in case, get the name in the klass slot.
2021     target_klass_name = cpool-&gt;klass_name_at(cc.index());
2022   }
2023   return generate_class_cast_message(caster_klass, target_klass, target_klass_name);
2024 }
2025 
2026 
2027 // The caller of generate_class_cast_message() (or one of its callers)
2028 // must use a ResourceMark in order to correctly free the result.
2029 char* SharedRuntime::generate_class_cast_message(
2030     Klass* caster_klass, Klass* target_klass, Symbol* target_klass_name) {
2031   const char* caster_name = caster_klass-&gt;external_name();
2032 
2033   assert(target_klass != NULL || target_klass_name != NULL, &quot;one must be provided&quot;);
2034   const char* target_name = target_klass == NULL ? target_klass_name-&gt;as_klass_external_name() :
2035                                                    target_klass-&gt;external_name();
2036 
2037   size_t msglen = strlen(caster_name) + strlen(&quot;class &quot;) + strlen(&quot; cannot be cast to class &quot;) + strlen(target_name) + 1;
2038 
2039   const char* caster_klass_description = &quot;&quot;;
2040   const char* target_klass_description = &quot;&quot;;
2041   const char* klass_separator = &quot;&quot;;
2042   if (target_klass != NULL &amp;&amp; caster_klass-&gt;module() == target_klass-&gt;module()) {
2043     caster_klass_description = caster_klass-&gt;joint_in_module_of_loader(target_klass);
2044   } else {
2045     caster_klass_description = caster_klass-&gt;class_in_module_of_loader();
2046     target_klass_description = (target_klass != NULL) ? target_klass-&gt;class_in_module_of_loader() : &quot;&quot;;
2047     klass_separator = (target_klass != NULL) ? &quot;; &quot; : &quot;&quot;;
2048   }
2049 
2050   // add 3 for parenthesis and preceeding space
2051   msglen += strlen(caster_klass_description) + strlen(target_klass_description) + strlen(klass_separator) + 3;
2052 
2053   char* message = NEW_RESOURCE_ARRAY_RETURN_NULL(char, msglen);
2054   if (message == NULL) {
2055     // Shouldn&#39;t happen, but don&#39;t cause even more problems if it does
2056     message = const_cast&lt;char*&gt;(caster_klass-&gt;external_name());
2057   } else {
2058     jio_snprintf(message,
2059                  msglen,
2060                  &quot;class %s cannot be cast to class %s (%s%s%s)&quot;,
2061                  caster_name,
2062                  target_name,
2063                  caster_klass_description,
2064                  klass_separator,
2065                  target_klass_description
2066                  );
2067   }
2068   return message;
2069 }
2070 
2071 JRT_LEAF(void, SharedRuntime::reguard_yellow_pages())
2072   (void) JavaThread::current()-&gt;reguard_stack();
2073 JRT_END
2074 
2075 void SharedRuntime::monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {
2076   if (!SafepointSynchronize::is_synchronizing()) {
2077     // Only try quick_enter() if we&#39;re not trying to reach a safepoint
2078     // so that the calling thread reaches the safepoint more quickly.
2079     if (ObjectSynchronizer::quick_enter(obj, thread, lock)) return;
2080   }
2081   // NO_ASYNC required because an async exception on the state transition destructor
2082   // would leave you with the lock held and it would never be released.
2083   // The normal monitorenter NullPointerException is thrown without acquiring a lock
2084   // and the model is that an exception implies the method failed.
2085   JRT_BLOCK_NO_ASYNC
2086   if (PrintBiasedLockingStatistics) {
2087     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
2088   }
2089   Handle h_obj(THREAD, obj);
2090   ObjectSynchronizer::enter(h_obj, lock, CHECK);
2091   assert(!HAS_PENDING_EXCEPTION, &quot;Should have no exception here&quot;);
2092   JRT_BLOCK_END
2093 }
2094 
2095 // Handles the uncommon case in locking, i.e., contention or an inflated lock.
2096 JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))
2097   SharedRuntime::monitor_enter_helper(obj, lock, thread);
2098 JRT_END
2099 
2100 void SharedRuntime::monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {
2101   assert(JavaThread::current() == thread, &quot;invariant&quot;);
2102   // Exit must be non-blocking, and therefore no exceptions can be thrown.
2103   EXCEPTION_MARK;
2104   ObjectSynchronizer::exit(obj, lock, THREAD);
2105 }
2106 
2107 // Handles the uncommon cases of monitor unlocking in compiled code
2108 JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))
2109   SharedRuntime::monitor_exit_helper(obj, lock, thread);
2110 JRT_END
2111 
2112 #ifndef PRODUCT
2113 
2114 void SharedRuntime::print_statistics() {
2115   ttyLocker ttyl;
2116   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;SharedRuntime&#39;&quot;);
2117 
2118   if (_throw_null_ctr) tty-&gt;print_cr(&quot;%5d implicit null throw&quot;, _throw_null_ctr);
2119 
2120   SharedRuntime::print_ic_miss_histogram();
2121 
2122   if (CountRemovableExceptions) {
2123     if (_nof_removable_exceptions &gt; 0) {
2124       Unimplemented(); // this counter is not yet incremented
2125       tty-&gt;print_cr(&quot;Removable exceptions: %d&quot;, _nof_removable_exceptions);
2126     }
2127   }
2128 
2129   // Dump the JRT_ENTRY counters
2130   if (_new_instance_ctr) tty-&gt;print_cr(&quot;%5d new instance requires GC&quot;, _new_instance_ctr);
2131   if (_new_array_ctr) tty-&gt;print_cr(&quot;%5d new array requires GC&quot;, _new_array_ctr);
2132   if (_multi1_ctr) tty-&gt;print_cr(&quot;%5d multianewarray 1 dim&quot;, _multi1_ctr);
2133   if (_multi2_ctr) tty-&gt;print_cr(&quot;%5d multianewarray 2 dim&quot;, _multi2_ctr);
2134   if (_multi3_ctr) tty-&gt;print_cr(&quot;%5d multianewarray 3 dim&quot;, _multi3_ctr);
2135   if (_multi4_ctr) tty-&gt;print_cr(&quot;%5d multianewarray 4 dim&quot;, _multi4_ctr);
2136   if (_multi5_ctr) tty-&gt;print_cr(&quot;%5d multianewarray 5 dim&quot;, _multi5_ctr);
2137 
2138   tty-&gt;print_cr(&quot;%5d inline cache miss in compiled&quot;, _ic_miss_ctr);
2139   tty-&gt;print_cr(&quot;%5d wrong method&quot;, _wrong_method_ctr);
2140   tty-&gt;print_cr(&quot;%5d unresolved static call site&quot;, _resolve_static_ctr);
2141   tty-&gt;print_cr(&quot;%5d unresolved virtual call site&quot;, _resolve_virtual_ctr);
2142   tty-&gt;print_cr(&quot;%5d unresolved opt virtual call site&quot;, _resolve_opt_virtual_ctr);
2143 
2144   if (_mon_enter_stub_ctr) tty-&gt;print_cr(&quot;%5d monitor enter stub&quot;, _mon_enter_stub_ctr);
2145   if (_mon_exit_stub_ctr) tty-&gt;print_cr(&quot;%5d monitor exit stub&quot;, _mon_exit_stub_ctr);
2146   if (_mon_enter_ctr) tty-&gt;print_cr(&quot;%5d monitor enter slow&quot;, _mon_enter_ctr);
2147   if (_mon_exit_ctr) tty-&gt;print_cr(&quot;%5d monitor exit slow&quot;, _mon_exit_ctr);
2148   if (_partial_subtype_ctr) tty-&gt;print_cr(&quot;%5d slow partial subtype&quot;, _partial_subtype_ctr);
2149   if (_jbyte_array_copy_ctr) tty-&gt;print_cr(&quot;%5d byte array copies&quot;, _jbyte_array_copy_ctr);
2150   if (_jshort_array_copy_ctr) tty-&gt;print_cr(&quot;%5d short array copies&quot;, _jshort_array_copy_ctr);
2151   if (_jint_array_copy_ctr) tty-&gt;print_cr(&quot;%5d int array copies&quot;, _jint_array_copy_ctr);
2152   if (_jlong_array_copy_ctr) tty-&gt;print_cr(&quot;%5d long array copies&quot;, _jlong_array_copy_ctr);
2153   if (_oop_array_copy_ctr) tty-&gt;print_cr(&quot;%5d oop array copies&quot;, _oop_array_copy_ctr);
2154   if (_checkcast_array_copy_ctr) tty-&gt;print_cr(&quot;%5d checkcast array copies&quot;, _checkcast_array_copy_ctr);
2155   if (_unsafe_array_copy_ctr) tty-&gt;print_cr(&quot;%5d unsafe array copies&quot;, _unsafe_array_copy_ctr);
2156   if (_generic_array_copy_ctr) tty-&gt;print_cr(&quot;%5d generic array copies&quot;, _generic_array_copy_ctr);
2157   if (_slow_array_copy_ctr) tty-&gt;print_cr(&quot;%5d slow array copies&quot;, _slow_array_copy_ctr);
2158   if (_find_handler_ctr) tty-&gt;print_cr(&quot;%5d find exception handler&quot;, _find_handler_ctr);
2159   if (_rethrow_ctr) tty-&gt;print_cr(&quot;%5d rethrow handler&quot;, _rethrow_ctr);
2160 
2161   AdapterHandlerLibrary::print_statistics();
2162 
2163   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
2164 }
2165 
2166 inline double percent(int x, int y) {
2167   return 100.0 * x / MAX2(y, 1);
2168 }
2169 
2170 class MethodArityHistogram {
2171  public:
2172   enum { MAX_ARITY = 256 };
2173  private:
2174   static int _arity_histogram[MAX_ARITY];     // histogram of #args
2175   static int _size_histogram[MAX_ARITY];      // histogram of arg size in words
2176   static int _max_arity;                      // max. arity seen
2177   static int _max_size;                       // max. arg size seen
2178 
2179   static void add_method_to_histogram(nmethod* nm) {
2180     if (CompiledMethod::nmethod_access_is_safe(nm)) {
2181       Method* method = nm-&gt;method();
2182       ArgumentCount args(method-&gt;signature());
2183       int arity   = args.size() + (method-&gt;is_static() ? 0 : 1);
2184       int argsize = method-&gt;size_of_parameters();
2185       arity   = MIN2(arity, MAX_ARITY-1);
2186       argsize = MIN2(argsize, MAX_ARITY-1);
2187       int count = method-&gt;compiled_invocation_count();
2188       _arity_histogram[arity]  += count;
2189       _size_histogram[argsize] += count;
2190       _max_arity = MAX2(_max_arity, arity);
2191       _max_size  = MAX2(_max_size, argsize);
2192     }
2193   }
2194 
2195   void print_histogram_helper(int n, int* histo, const char* name) {
2196     const int N = MIN2(5, n);
2197     tty-&gt;print_cr(&quot;\nHistogram of call arity (incl. rcvr, calls to compiled methods only):&quot;);
2198     double sum = 0;
2199     double weighted_sum = 0;
2200     int i;
2201     for (i = 0; i &lt;= n; i++) { sum += histo[i]; weighted_sum += i*histo[i]; }
2202     double rest = sum;
2203     double percent = sum / 100;
2204     for (i = 0; i &lt;= N; i++) {
2205       rest -= histo[i];
2206       tty-&gt;print_cr(&quot;%4d: %7d (%5.1f%%)&quot;, i, histo[i], histo[i] / percent);
2207     }
2208     tty-&gt;print_cr(&quot;rest: %7d (%5.1f%%))&quot;, (int)rest, rest / percent);
2209     tty-&gt;print_cr(&quot;(avg. %s = %3.1f, max = %d)&quot;, name, weighted_sum / sum, n);
2210   }
2211 
2212   void print_histogram() {
2213     tty-&gt;print_cr(&quot;\nHistogram of call arity (incl. rcvr, calls to compiled methods only):&quot;);
2214     print_histogram_helper(_max_arity, _arity_histogram, &quot;arity&quot;);
2215     tty-&gt;print_cr(&quot;\nSame for parameter size (in words):&quot;);
2216     print_histogram_helper(_max_size, _size_histogram, &quot;size&quot;);
2217     tty-&gt;cr();
2218   }
2219 
2220  public:
2221   MethodArityHistogram() {
2222     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
2223     _max_arity = _max_size = 0;
2224     for (int i = 0; i &lt; MAX_ARITY; i++) _arity_histogram[i] = _size_histogram[i] = 0;
2225     CodeCache::nmethods_do(add_method_to_histogram);
2226     print_histogram();
2227   }
2228 };
2229 
2230 int MethodArityHistogram::_arity_histogram[MethodArityHistogram::MAX_ARITY];
2231 int MethodArityHistogram::_size_histogram[MethodArityHistogram::MAX_ARITY];
2232 int MethodArityHistogram::_max_arity;
2233 int MethodArityHistogram::_max_size;
2234 
2235 void SharedRuntime::print_call_statistics(int comp_total) {
2236   tty-&gt;print_cr(&quot;Calls from compiled code:&quot;);
2237   int total  = _nof_normal_calls + _nof_interface_calls + _nof_static_calls;
2238   int mono_c = _nof_normal_calls - _nof_optimized_calls - _nof_megamorphic_calls;
2239   int mono_i = _nof_interface_calls - _nof_optimized_interface_calls - _nof_megamorphic_interface_calls;
2240   tty-&gt;print_cr(&quot;\t%9d   (%4.1f%%) total non-inlined   &quot;, total, percent(total, total));
2241   tty-&gt;print_cr(&quot;\t%9d   (%4.1f%%) virtual calls       &quot;, _nof_normal_calls, percent(_nof_normal_calls, total));
2242   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   inlined          &quot;, _nof_inlined_calls, percent(_nof_inlined_calls, _nof_normal_calls));
2243   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   optimized        &quot;, _nof_optimized_calls, percent(_nof_optimized_calls, _nof_normal_calls));
2244   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   monomorphic      &quot;, mono_c, percent(mono_c, _nof_normal_calls));
2245   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   megamorphic      &quot;, _nof_megamorphic_calls, percent(_nof_megamorphic_calls, _nof_normal_calls));
2246   tty-&gt;print_cr(&quot;\t%9d   (%4.1f%%) interface calls     &quot;, _nof_interface_calls, percent(_nof_interface_calls, total));
2247   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   inlined          &quot;, _nof_inlined_interface_calls, percent(_nof_inlined_interface_calls, _nof_interface_calls));
2248   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   optimized        &quot;, _nof_optimized_interface_calls, percent(_nof_optimized_interface_calls, _nof_interface_calls));
2249   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   monomorphic      &quot;, mono_i, percent(mono_i, _nof_interface_calls));
2250   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   megamorphic      &quot;, _nof_megamorphic_interface_calls, percent(_nof_megamorphic_interface_calls, _nof_interface_calls));
2251   tty-&gt;print_cr(&quot;\t%9d   (%4.1f%%) static/special calls&quot;, _nof_static_calls, percent(_nof_static_calls, total));
2252   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   inlined          &quot;, _nof_inlined_static_calls, percent(_nof_inlined_static_calls, _nof_static_calls));
2253   tty-&gt;cr();
2254   tty-&gt;print_cr(&quot;Note 1: counter updates are not MT-safe.&quot;);
2255   tty-&gt;print_cr(&quot;Note 2: %% in major categories are relative to total non-inlined calls;&quot;);
2256   tty-&gt;print_cr(&quot;        %% in nested categories are relative to their category&quot;);
2257   tty-&gt;print_cr(&quot;        (and thus add up to more than 100%% with inlining)&quot;);
2258   tty-&gt;cr();
2259 
2260   MethodArityHistogram h;
2261 }
2262 #endif
2263 
2264 
2265 // A simple wrapper class around the calling convention information
2266 // that allows sharing of adapters for the same calling convention.
2267 class AdapterFingerPrint : public CHeapObj&lt;mtCode&gt; {
2268  private:
2269   enum {
2270     _basic_type_bits = 4,
2271     _basic_type_mask = right_n_bits(_basic_type_bits),
2272     _basic_types_per_int = BitsPerInt / _basic_type_bits,
2273     _compact_int_count = 3
2274   };
2275   // TO DO:  Consider integrating this with a more global scheme for compressing signatures.
2276   // For now, 4 bits per components (plus T_VOID gaps after double/long) is not excessive.
2277 
2278   union {
2279     int  _compact[_compact_int_count];
2280     int* _fingerprint;
2281   } _value;
2282   int _length; // A negative length indicates the fingerprint is in the compact form,
2283                // Otherwise _value._fingerprint is the array.
2284 
2285   // Remap BasicTypes that are handled equivalently by the adapters.
2286   // These are correct for the current system but someday it might be
2287   // necessary to make this mapping platform dependent.
<a name="53" id="anc53"></a><span class="line-modified">2288   static int adapter_encoding(BasicType in) {</span>
2289     switch (in) {
2290       case T_BOOLEAN:
2291       case T_BYTE:
2292       case T_SHORT:
<a name="54" id="anc54"></a><span class="line-modified">2293       case T_CHAR:</span>
<span class="line-modified">2294         // There are all promoted to T_INT in the calling convention</span>
<span class="line-modified">2295         return T_INT;</span>













2296 
2297       case T_OBJECT:
2298       case T_ARRAY:
2299         // In other words, we assume that any register good enough for
2300         // an int or long is good enough for a managed pointer.
2301 #ifdef _LP64
2302         return T_LONG;
2303 #else
2304         return T_INT;
2305 #endif
2306 
2307       case T_INT:
2308       case T_LONG:
2309       case T_FLOAT:
2310       case T_DOUBLE:
2311       case T_VOID:
2312         return in;
2313 
2314       default:
2315         ShouldNotReachHere();
2316         return T_CONFLICT;
2317     }
2318   }
2319 
2320  public:
<a name="55" id="anc55"></a><span class="line-modified">2321   AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {</span>
2322     // The fingerprint is based on the BasicType signature encoded
2323     // into an array of ints with eight entries per int.
<a name="56" id="anc56"></a>
2324     int* ptr;
2325     int len = (total_args_passed + (_basic_types_per_int-1)) / _basic_types_per_int;
2326     if (len &lt;= _compact_int_count) {
2327       assert(_compact_int_count == 3, &quot;else change next line&quot;);
2328       _value._compact[0] = _value._compact[1] = _value._compact[2] = 0;
2329       // Storing the signature encoded as signed chars hits about 98%
2330       // of the time.
2331       _length = -len;
2332       ptr = _value._compact;
2333     } else {
2334       _length = len;
2335       _value._fingerprint = NEW_C_HEAP_ARRAY(int, _length, mtCode);
2336       ptr = _value._fingerprint;
2337     }
2338 
2339     // Now pack the BasicTypes with 8 per int
2340     int sig_index = 0;
<a name="57" id="anc57"></a>

2341     for (int index = 0; index &lt; len; index++) {
2342       int value = 0;
2343       for (int byte = 0; byte &lt; _basic_types_per_int; byte++) {
<a name="58" id="anc58"></a><span class="line-modified">2344         int bt = ((sig_index &lt; total_args_passed)</span>
<span class="line-modified">2345                   ? adapter_encoding(sig_bt[sig_index++])</span>
<span class="line-modified">2346                   : 0);</span>

















2347         assert((bt &amp; _basic_type_mask) == bt, &quot;must fit in 4 bits&quot;);
2348         value = (value &lt;&lt; _basic_type_bits) | bt;
2349       }
2350       ptr[index] = value;
2351     }
<a name="59" id="anc59"></a>
2352   }
2353 
2354   ~AdapterFingerPrint() {
2355     if (_length &gt; 0) {
2356       FREE_C_HEAP_ARRAY(int, _value._fingerprint);
2357     }
2358   }
2359 
2360   int value(int index) {
2361     if (_length &lt; 0) {
2362       return _value._compact[index];
2363     }
2364     return _value._fingerprint[index];
2365   }
2366   int length() {
2367     if (_length &lt; 0) return -_length;
2368     return _length;
2369   }
2370 
2371   bool is_compact() {
2372     return _length &lt;= 0;
2373   }
2374 
2375   unsigned int compute_hash() {
2376     int hash = 0;
2377     for (int i = 0; i &lt; length(); i++) {
2378       int v = value(i);
2379       hash = (hash &lt;&lt; 8) ^ v ^ (hash &gt;&gt; 5);
2380     }
2381     return (unsigned int)hash;
2382   }
2383 
2384   const char* as_string() {
2385     stringStream st;
2386     st.print(&quot;0x&quot;);
2387     for (int i = 0; i &lt; length(); i++) {
2388       st.print(&quot;%08x&quot;, value(i));
2389     }
2390     return st.as_string();
2391   }
2392 
2393   bool equals(AdapterFingerPrint* other) {
2394     if (other-&gt;_length != _length) {
2395       return false;
2396     }
2397     if (_length &lt; 0) {
2398       assert(_compact_int_count == 3, &quot;else change next line&quot;);
2399       return _value._compact[0] == other-&gt;_value._compact[0] &amp;&amp;
2400              _value._compact[1] == other-&gt;_value._compact[1] &amp;&amp;
2401              _value._compact[2] == other-&gt;_value._compact[2];
2402     } else {
2403       for (int i = 0; i &lt; _length; i++) {
2404         if (_value._fingerprint[i] != other-&gt;_value._fingerprint[i]) {
2405           return false;
2406         }
2407       }
2408     }
2409     return true;
2410   }
2411 };
2412 
2413 
2414 // A hashtable mapping from AdapterFingerPrints to AdapterHandlerEntries
2415 class AdapterHandlerTable : public BasicHashtable&lt;mtCode&gt; {
2416   friend class AdapterHandlerTableIterator;
2417 
2418  private:
2419 
2420 #ifndef PRODUCT
2421   static int _lookups; // number of calls to lookup
2422   static int _buckets; // number of buckets checked
2423   static int _equals;  // number of buckets checked with matching hash
2424   static int _hits;    // number of successful lookups
2425   static int _compact; // number of equals calls with compact signature
2426 #endif
2427 
2428   AdapterHandlerEntry* bucket(int i) {
2429     return (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::bucket(i);
2430   }
2431 
2432  public:
2433   AdapterHandlerTable()
2434     : BasicHashtable&lt;mtCode&gt;(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }
2435 
2436   // Create a new entry suitable for insertion in the table
<a name="60" id="anc60"></a><span class="line-modified">2437   AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {</span>


2438     AdapterHandlerEntry* entry = (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::new_entry(fingerprint-&gt;compute_hash());
<a name="61" id="anc61"></a><span class="line-modified">2439     entry-&gt;init(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>

2440     if (DumpSharedSpaces) {
2441       ((CDSAdapterHandlerEntry*)entry)-&gt;init();
2442     }
2443     return entry;
2444   }
2445 
2446   // Insert an entry into the table
2447   void add(AdapterHandlerEntry* entry) {
2448     int index = hash_to_index(entry-&gt;hash());
2449     add_entry(index, entry);
2450   }
2451 
2452   void free_entry(AdapterHandlerEntry* entry) {
2453     entry-&gt;deallocate();
2454     BasicHashtable&lt;mtCode&gt;::free_entry(entry);
2455   }
2456 
2457   // Find a entry with the same fingerprint if it exists
<a name="62" id="anc62"></a><span class="line-modified">2458   AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt) {</span>
2459     NOT_PRODUCT(_lookups++);
<a name="63" id="anc63"></a><span class="line-modified">2460     AdapterFingerPrint fp(total_args_passed, sig_bt);</span>
2461     unsigned int hash = fp.compute_hash();
2462     int index = hash_to_index(hash);
2463     for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
2464       NOT_PRODUCT(_buckets++);
2465       if (e-&gt;hash() == hash) {
2466         NOT_PRODUCT(_equals++);
2467         if (fp.equals(e-&gt;fingerprint())) {
2468 #ifndef PRODUCT
2469           if (fp.is_compact()) _compact++;
2470           _hits++;
2471 #endif
2472           return e;
2473         }
2474       }
2475     }
2476     return NULL;
2477   }
2478 
2479 #ifndef PRODUCT
2480   void print_statistics() {
2481     ResourceMark rm;
2482     int longest = 0;
2483     int empty = 0;
2484     int total = 0;
2485     int nonempty = 0;
2486     for (int index = 0; index &lt; table_size(); index++) {
2487       int count = 0;
2488       for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
2489         count++;
2490       }
2491       if (count != 0) nonempty++;
2492       if (count == 0) empty++;
2493       if (count &gt; longest) longest = count;
2494       total += count;
2495     }
2496     tty-&gt;print_cr(&quot;AdapterHandlerTable: empty %d longest %d total %d average %f&quot;,
2497                   empty, longest, total, total / (double)nonempty);
2498     tty-&gt;print_cr(&quot;AdapterHandlerTable: lookups %d buckets %d equals %d hits %d compact %d&quot;,
2499                   _lookups, _buckets, _equals, _hits, _compact);
2500   }
2501 #endif
2502 };
2503 
2504 
2505 #ifndef PRODUCT
2506 
2507 int AdapterHandlerTable::_lookups;
2508 int AdapterHandlerTable::_buckets;
2509 int AdapterHandlerTable::_equals;
2510 int AdapterHandlerTable::_hits;
2511 int AdapterHandlerTable::_compact;
2512 
2513 #endif
2514 
2515 class AdapterHandlerTableIterator : public StackObj {
2516  private:
2517   AdapterHandlerTable* _table;
2518   int _index;
2519   AdapterHandlerEntry* _current;
2520 
2521   void scan() {
2522     while (_index &lt; _table-&gt;table_size()) {
2523       AdapterHandlerEntry* a = _table-&gt;bucket(_index);
2524       _index++;
2525       if (a != NULL) {
2526         _current = a;
2527         return;
2528       }
2529     }
2530   }
2531 
2532  public:
2533   AdapterHandlerTableIterator(AdapterHandlerTable* table): _table(table), _index(0), _current(NULL) {
2534     scan();
2535   }
2536   bool has_next() {
2537     return _current != NULL;
2538   }
2539   AdapterHandlerEntry* next() {
2540     if (_current != NULL) {
2541       AdapterHandlerEntry* result = _current;
2542       _current = _current-&gt;next();
2543       if (_current == NULL) scan();
2544       return result;
2545     } else {
2546       return NULL;
2547     }
2548   }
2549 };
2550 
2551 
2552 // ---------------------------------------------------------------------------
2553 // Implementation of AdapterHandlerLibrary
2554 AdapterHandlerTable* AdapterHandlerLibrary::_adapters = NULL;
2555 AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = NULL;
<a name="64" id="anc64"></a><span class="line-modified">2556 const int AdapterHandlerLibrary_size = 16*K;</span>
2557 BufferBlob* AdapterHandlerLibrary::_buffer = NULL;
2558 
2559 BufferBlob* AdapterHandlerLibrary::buffer_blob() {
2560   // Should be called only when AdapterHandlerLibrary_lock is active.
2561   if (_buffer == NULL) // Initialize lazily
2562       _buffer = BufferBlob::create(&quot;adapters&quot;, AdapterHandlerLibrary_size);
2563   return _buffer;
2564 }
2565 
2566 extern &quot;C&quot; void unexpected_adapter_call() {
2567   ShouldNotCallThis();
2568 }
2569 
2570 void AdapterHandlerLibrary::initialize() {
2571   if (_adapters != NULL) return;
2572   _adapters = new AdapterHandlerTable();
2573 
2574   // Create a special handler for abstract methods.  Abstract methods
2575   // are never compiled so an i2c entry is somewhat meaningless, but
2576   // throw AbstractMethodError just in case.
2577   // Pass wrong_method_abstract for the c2i transitions to return
2578   // AbstractMethodError for invalid invocations.
2579   address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();
<a name="65" id="anc65"></a><span class="line-modified">2580   _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, NULL),</span>
2581                                                               StubRoutines::throw_AbstractMethodError_entry(),
<a name="66" id="anc66"></a>
2582                                                               wrong_method_abstract, wrong_method_abstract);
2583 }
2584 
2585 AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint,
2586                                                       address i2c_entry,
2587                                                       address c2i_entry,
<a name="67" id="anc67"></a>

2588                                                       address c2i_unverified_entry,
<a name="68" id="anc68"></a>
2589                                                       address c2i_no_clinit_check_entry) {
<a name="69" id="anc69"></a><span class="line-modified">2590   return _adapters-&gt;new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);</span>















2591 }
2592 
2593 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(const methodHandle&amp; method) {
2594   AdapterHandlerEntry* entry = get_adapter0(method);
2595   if (entry != NULL &amp;&amp; method-&gt;is_shared()) {
2596     // See comments around Method::link_method()
2597     MutexLocker mu(AdapterHandlerLibrary_lock);
2598     if (method-&gt;adapter() == NULL) {
2599       method-&gt;update_adapter_trampoline(entry);
2600     }
<a name="70" id="anc70"></a><span class="line-modified">2601     address trampoline = method-&gt;from_compiled_entry();</span>
<span class="line-modified">2602     if (*(int*)trampoline == 0) {</span>
<span class="line-modified">2603       CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());</span>
<span class="line-modified">2604       MacroAssembler _masm(&amp;buffer);</span>
<span class="line-modified">2605       SharedRuntime::generate_trampoline(&amp;_masm, entry-&gt;get_c2i_entry());</span>
<span class="line-modified">2606       assert(*(int*)trampoline != 0, &quot;Instruction(s) for trampoline must not be encoded as zeros.&quot;);</span>
<span class="line-modified">2607       _masm.flush();</span>

2608 
<a name="71" id="anc71"></a><span class="line-modified">2609       if (PrintInterpreter) {</span>
<span class="line-modified">2610         Disassembler::decode(buffer.insts_begin(), buffer.insts_end());</span>


























2611       }
<a name="72" id="anc72"></a>

2612     }
2613   }
<a name="73" id="anc73"></a>


2614 
<a name="74" id="anc74"></a><span class="line-modified">2615   return entry;</span>



























































































































































2616 }
2617 
2618 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter0(const methodHandle&amp; method) {
2619   // Use customized signature handler.  Need to lock around updates to
2620   // the AdapterHandlerTable (it is not safe for concurrent readers
2621   // and a single writer: this could be fixed if it becomes a
2622   // problem).
2623 
2624   ResourceMark rm;
2625 
<a name="75" id="anc75"></a><span class="line-modified">2626   NOT_PRODUCT(int insts_size);</span>
2627   AdapterBlob* new_adapter = NULL;
2628   AdapterHandlerEntry* entry = NULL;
2629   AdapterFingerPrint* fingerprint = NULL;
<a name="76" id="anc76"></a>
2630   {
2631     MutexLocker mu(AdapterHandlerLibrary_lock);
2632     // make sure data structure is initialized
2633     initialize();
2634 
<a name="77" id="anc77"></a><span class="line-modified">2635     if (method-&gt;is_abstract()) {</span>
<span class="line-modified">2636       return _abstract_method_handler;</span>


2637     }
<a name="78" id="anc78"></a>





2638 
<a name="79" id="anc79"></a><span class="line-modified">2639     // Fill in the signature array, for the calling-convention call.</span>
<span class="line-modified">2640     int total_args_passed = method-&gt;size_of_parameters(); // All args on stack</span>



2641 
<a name="80" id="anc80"></a><span class="line-modified">2642     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);</span>
<span class="line-modified">2643     VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);</span>
<span class="line-modified">2644     int i = 0;</span>
<span class="line-modified">2645     if (!method-&gt;is_static())  // Pass in receiver first</span>
<span class="line-modified">2646       sig_bt[i++] = T_OBJECT;</span>
<span class="line-modified">2647     for (SignatureStream ss(method-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-modified">2648       sig_bt[i++] = ss.type();  // Collect remaining bits of signature</span>
<span class="line-modified">2649       if (ss.type() == T_LONG || ss.type() == T_DOUBLE)</span>
<span class="line-modified">2650         sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots</span>






2651     }
<a name="81" id="anc81"></a><span class="line-removed">2652     assert(i == total_args_passed, &quot;&quot;);</span>
2653 
2654     // Lookup method signature&#39;s fingerprint
<a name="82" id="anc82"></a><span class="line-modified">2655     entry = _adapters-&gt;lookup(total_args_passed, sig_bt);</span>
2656 
2657 #ifdef ASSERT
2658     AdapterHandlerEntry* shared_entry = NULL;
2659     // Start adapter sharing verification only after the VM is booted.
2660     if (VerifyAdapterSharing &amp;&amp; (entry != NULL)) {
2661       shared_entry = entry;
2662       entry = NULL;
2663     }
2664 #endif
2665 
2666     if (entry != NULL) {
2667       return entry;
2668     }
2669 
<a name="83" id="anc83"></a><span class="line-modified">2670     // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage</span>
<span class="line-removed">2671     int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, false);</span>
<span class="line-removed">2672 </span>
<span class="line-removed">2673     // Make a C heap allocated version of the fingerprint to store in the adapter</span>
2674     fingerprint = new AdapterFingerPrint(total_args_passed, sig_bt);
2675 
2676     // StubRoutines::code2() is initialized after this function can be called. As a result,
2677     // VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated
2678     // prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C
2679     // stub that ensure that an I2C stub is called from an interpreter frame.
2680     bool contains_all_checks = StubRoutines::code2() != NULL;
2681 
2682     // Create I2C &amp; C2I handlers
2683     BufferBlob* buf = buffer_blob(); // the temporary code buffer in CodeCache
2684     if (buf != NULL) {
2685       CodeBuffer buffer(buf);
2686       short buffer_locs[20];
2687       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
2688                                              sizeof(buffer_locs)/sizeof(relocInfo));
2689 
2690       MacroAssembler _masm(&amp;buffer);
2691       entry = SharedRuntime::generate_i2c2i_adapters(&amp;_masm,
<a name="84" id="anc84"></a><span class="line-modified">2692                                                      total_args_passed,</span>
<span class="line-modified">2693                                                      comp_args_on_stack,</span>
<span class="line-removed">2694                                                      sig_bt,</span>
2695                                                      regs,
<a name="85" id="anc85"></a><span class="line-modified">2696                                                      fingerprint);</span>













2697 #ifdef ASSERT
2698       if (VerifyAdapterSharing) {
2699         if (shared_entry != NULL) {
<a name="86" id="anc86"></a>


2700           assert(shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size()), &quot;code must match&quot;);
2701           // Release the one just created and return the original
2702           _adapters-&gt;free_entry(entry);
2703           return shared_entry;
2704         } else  {
2705           entry-&gt;save_code(buf-&gt;code_begin(), buffer.insts_size());
2706         }
2707       }
2708 #endif
2709 
<a name="87" id="anc87"></a><span class="line-removed">2710       new_adapter = AdapterBlob::create(&amp;buffer);</span>
2711       NOT_PRODUCT(insts_size = buffer.insts_size());
2712     }
2713     if (new_adapter == NULL) {
2714       // CodeCache is full, disable compilation
2715       // Ought to log this but compile log is only per compile thread
2716       // and we&#39;re some non descript Java thread.
2717       return NULL; // Out of CodeCache space
2718     }
2719     entry-&gt;relocate(new_adapter-&gt;content_begin());
2720 #ifndef PRODUCT
2721     // debugging suppport
2722     if (PrintAdapterHandlers || PrintStubCode) {
2723       ttyLocker ttyl;
2724       entry-&gt;print_adapter_on(tty);
2725       tty-&gt;print_cr(&quot;i2c argument handler #%d for: %s %s %s (%d bytes generated)&quot;,
2726                     _adapters-&gt;number_of_entries(), (method-&gt;is_static() ? &quot;static&quot; : &quot;receiver&quot;),
2727                     method-&gt;signature()-&gt;as_C_string(), fingerprint-&gt;as_string(), insts_size);
2728       tty-&gt;print_cr(&quot;c2i argument handler starts at %p&quot;, entry-&gt;get_c2i_entry());
2729       if (Verbose || PrintStubCode) {
2730         address first_pc = entry-&gt;base_address();
2731         if (first_pc != NULL) {
2732           Disassembler::decode(first_pc, first_pc + insts_size);
2733           tty-&gt;cr();
2734         }
2735       }
2736     }
2737 #endif
2738     // Add the entry only if the entry contains all required checks (see sharedRuntime_xxx.cpp)
2739     // The checks are inserted only if -XX:+VerifyAdapterCalls is specified.
2740     if (contains_all_checks || !VerifyAdapterCalls) {
2741       _adapters-&gt;add(entry);
2742     }
2743   }
2744   // Outside of the lock
2745   if (new_adapter != NULL) {
2746     char blob_id[256];
2747     jio_snprintf(blob_id,
2748                  sizeof(blob_id),
2749                  &quot;%s(%s)@&quot; PTR_FORMAT,
2750                  new_adapter-&gt;name(),
2751                  fingerprint-&gt;as_string(),
2752                  new_adapter-&gt;content_begin());
2753     Forte::register_stub(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
2754 
2755     if (JvmtiExport::should_post_dynamic_code_generated()) {
2756       JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
2757     }
2758   }
2759   return entry;
2760 }
2761 
2762 address AdapterHandlerEntry::base_address() {
2763   address base = _i2c_entry;
2764   if (base == NULL)  base = _c2i_entry;
2765   assert(base &lt;= _c2i_entry || _c2i_entry == NULL, &quot;&quot;);
<a name="88" id="anc88"></a>

2766   assert(base &lt;= _c2i_unverified_entry || _c2i_unverified_entry == NULL, &quot;&quot;);
<a name="89" id="anc89"></a>
2767   assert(base &lt;= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == NULL, &quot;&quot;);
2768   return base;
2769 }
2770 
2771 void AdapterHandlerEntry::relocate(address new_base) {
2772   address old_base = base_address();
2773   assert(old_base != NULL, &quot;&quot;);
2774   ptrdiff_t delta = new_base - old_base;
2775   if (_i2c_entry != NULL)
2776     _i2c_entry += delta;
2777   if (_c2i_entry != NULL)
2778     _c2i_entry += delta;
<a name="90" id="anc90"></a>



2779   if (_c2i_unverified_entry != NULL)
2780     _c2i_unverified_entry += delta;
<a name="91" id="anc91"></a>

2781   if (_c2i_no_clinit_check_entry != NULL)
2782     _c2i_no_clinit_check_entry += delta;
2783   assert(base_address() == new_base, &quot;&quot;);
2784 }
2785 
2786 
2787 void AdapterHandlerEntry::deallocate() {
2788   delete _fingerprint;
<a name="92" id="anc92"></a>


2789 #ifdef ASSERT
2790   FREE_C_HEAP_ARRAY(unsigned char, _saved_code);
2791 #endif
2792 }
2793 
2794 
2795 #ifdef ASSERT
2796 // Capture the code before relocation so that it can be compared
2797 // against other versions.  If the code is captured after relocation
2798 // then relative instructions won&#39;t be equivalent.
2799 void AdapterHandlerEntry::save_code(unsigned char* buffer, int length) {
2800   _saved_code = NEW_C_HEAP_ARRAY(unsigned char, length, mtCode);
2801   _saved_code_length = length;
2802   memcpy(_saved_code, buffer, length);
2803 }
2804 
2805 
2806 bool AdapterHandlerEntry::compare_code(unsigned char* buffer, int length) {
2807   if (length != _saved_code_length) {
2808     return false;
2809   }
2810 
2811   return (memcmp(buffer, _saved_code, length) == 0) ? true : false;
2812 }
2813 #endif
2814 
2815 
2816 /**
2817  * Create a native wrapper for this native method.  The wrapper converts the
2818  * Java-compiled calling convention to the native convention, handles
2819  * arguments, and transitions to native.  On return from the native we transition
2820  * back to java blocking if a safepoint is in progress.
2821  */
2822 void AdapterHandlerLibrary::create_native_wrapper(const methodHandle&amp; method) {
2823   ResourceMark rm;
2824   nmethod* nm = NULL;
2825   address critical_entry = NULL;
2826 
2827   assert(method-&gt;is_native(), &quot;must be native&quot;);
2828   assert(method-&gt;is_method_handle_intrinsic() ||
2829          method-&gt;has_native_function(), &quot;must have something valid to call!&quot;);
2830 
2831   if (CriticalJNINatives &amp;&amp; !method-&gt;is_method_handle_intrinsic()) {
2832     // We perform the I/O with transition to native before acquiring AdapterHandlerLibrary_lock.
2833     critical_entry = NativeLookup::lookup_critical_entry(method);
2834   }
2835 
2836   {
2837     // Perform the work while holding the lock, but perform any printing outside the lock
2838     MutexLocker mu(AdapterHandlerLibrary_lock);
2839     // See if somebody beat us to it
2840     if (method-&gt;code() != NULL) {
2841       return;
2842     }
2843 
2844     const int compile_id = CompileBroker::assign_compile_id(method, CompileBroker::standard_entry_bci);
2845     assert(compile_id &gt; 0, &quot;Must generate native wrapper&quot;);
2846 
2847 
2848     ResourceMark rm;
2849     BufferBlob*  buf = buffer_blob(); // the temporary code buffer in CodeCache
2850     if (buf != NULL) {
2851       CodeBuffer buffer(buf);
2852       double locs_buf[20];
2853       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)locs_buf, sizeof(locs_buf) / sizeof(relocInfo));
2854       MacroAssembler _masm(&amp;buffer);
2855 
2856       // Fill in the signature array, for the calling-convention call.
2857       const int total_args_passed = method-&gt;size_of_parameters();
2858 
2859       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);
2860       VMRegPair*   regs = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);
2861       int i=0;
2862       if (!method-&gt;is_static())  // Pass in receiver first
2863         sig_bt[i++] = T_OBJECT;
2864       SignatureStream ss(method-&gt;signature());
2865       for (; !ss.at_return_type(); ss.next()) {
<a name="93" id="anc93"></a><span class="line-modified">2866         sig_bt[i++] = ss.type();  // Collect remaining bits of signature</span>

2867         if (ss.type() == T_LONG || ss.type() == T_DOUBLE)
2868           sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots
2869       }
2870       assert(i == total_args_passed, &quot;&quot;);
2871       BasicType ret_type = ss.type();
2872 
2873       // Now get the compiled-Java layout as input (or output) arguments.
2874       // NOTE: Stubs for compiled entry points of method handle intrinsics
2875       // are just trampolines so the argument registers must be outgoing ones.
2876       const bool is_outgoing = method-&gt;is_method_handle_intrinsic();
2877       int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, is_outgoing);
2878 
2879       // Generate the compiled-to-native wrapper code
2880       nm = SharedRuntime::generate_native_wrapper(&amp;_masm, method, compile_id, sig_bt, regs, ret_type, critical_entry);
2881 
2882       if (nm != NULL) {
2883         {
2884           MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
2885           if (nm-&gt;make_in_use()) {
2886             method-&gt;set_code(method, nm);
2887           }
2888         }
2889 
2890         DirectiveSet* directive = DirectivesStack::getDefaultDirective(CompileBroker::compiler(CompLevel_simple));
2891         if (directive-&gt;PrintAssemblyOption) {
2892           nm-&gt;print_code();
2893         }
2894         DirectivesStack::release(directive);
2895       }
2896     }
2897   } // Unlock AdapterHandlerLibrary_lock
2898 
2899 
2900   // Install the generated code.
2901   if (nm != NULL) {
2902     const char *msg = method-&gt;is_static() ? &quot;(static)&quot; : &quot;&quot;;
2903     CompileTask::print_ul(nm, msg);
2904     if (PrintCompilation) {
2905       ttyLocker ttyl;
2906       CompileTask::print(tty, nm, msg);
2907     }
2908     nm-&gt;post_compiled_method_load_event();
2909   }
2910 }
2911 
2912 JRT_ENTRY_NO_ASYNC(void, SharedRuntime::block_for_jni_critical(JavaThread* thread))
2913   assert(thread == JavaThread::current(), &quot;must be&quot;);
2914   // The code is about to enter a JNI lazy critical native method and
2915   // _needs_gc is true, so if this thread is already in a critical
2916   // section then just return, otherwise this thread should block
2917   // until needs_gc has been cleared.
2918   if (thread-&gt;in_critical()) {
2919     return;
2920   }
2921   // Lock and unlock a critical section to give the system a chance to block
2922   GCLocker::lock_critical(thread);
2923   GCLocker::unlock_critical(thread);
2924 JRT_END
2925 
2926 JRT_LEAF(oopDesc*, SharedRuntime::pin_object(JavaThread* thread, oopDesc* obj))
2927   assert(Universe::heap()-&gt;supports_object_pinning(), &quot;Why we are here?&quot;);
2928   assert(obj != NULL, &quot;Should not be null&quot;);
2929   oop o(obj);
2930   o = Universe::heap()-&gt;pin_object(thread, o);
2931   assert(o != NULL, &quot;Should not be null&quot;);
2932   return o;
2933 JRT_END
2934 
2935 JRT_LEAF(void, SharedRuntime::unpin_object(JavaThread* thread, oopDesc* obj))
2936   assert(Universe::heap()-&gt;supports_object_pinning(), &quot;Why we are here?&quot;);
2937   assert(obj != NULL, &quot;Should not be null&quot;);
2938   oop o(obj);
2939   Universe::heap()-&gt;unpin_object(thread, o);
2940 JRT_END
2941 
2942 // -------------------------------------------------------------------------
2943 // Java-Java calling convention
2944 // (what you use when Java calls Java)
2945 
2946 //------------------------------name_for_receiver----------------------------------
2947 // For a given signature, return the VMReg for parameter 0.
2948 VMReg SharedRuntime::name_for_receiver() {
2949   VMRegPair regs;
2950   BasicType sig_bt = T_OBJECT;
2951   (void) java_calling_convention(&amp;sig_bt, &amp;regs, 1, true);
2952   // Return argument 0 register.  In the LP64 build pointers
2953   // take 2 registers, but the VM wants only the &#39;main&#39; name.
2954   return regs.first();
2955 }
2956 
2957 VMRegPair *SharedRuntime::find_callee_arguments(Symbol* sig, bool has_receiver, bool has_appendix, int* arg_size) {
2958   // This method is returning a data structure allocating as a
2959   // ResourceObject, so do not put any ResourceMarks in here.
2960 
2961   BasicType *sig_bt = NEW_RESOURCE_ARRAY(BasicType, 256);
2962   VMRegPair *regs = NEW_RESOURCE_ARRAY(VMRegPair, 256);
2963   int cnt = 0;
2964   if (has_receiver) {
2965     sig_bt[cnt++] = T_OBJECT; // Receiver is argument 0; not in signature
2966   }
2967 
2968   for (SignatureStream ss(sig); !ss.at_return_type(); ss.next()) {
2969     BasicType type = ss.type();
2970     sig_bt[cnt++] = type;
2971     if (is_double_word_type(type))
2972       sig_bt[cnt++] = T_VOID;
2973   }
2974 
2975   if (has_appendix) {
2976     sig_bt[cnt++] = T_OBJECT;
2977   }
2978 
2979   assert(cnt &lt; 256, &quot;grow table size&quot;);
2980 
2981   int comp_args_on_stack;
2982   comp_args_on_stack = java_calling_convention(sig_bt, regs, cnt, true);
2983 
2984   // the calling convention doesn&#39;t count out_preserve_stack_slots so
2985   // we must add that in to get &quot;true&quot; stack offsets.
2986 
2987   if (comp_args_on_stack) {
2988     for (int i = 0; i &lt; cnt; i++) {
2989       VMReg reg1 = regs[i].first();
2990       if (reg1-&gt;is_stack()) {
2991         // Yuck
2992         reg1 = reg1-&gt;bias(out_preserve_stack_slots());
2993       }
2994       VMReg reg2 = regs[i].second();
2995       if (reg2-&gt;is_stack()) {
2996         // Yuck
2997         reg2 = reg2-&gt;bias(out_preserve_stack_slots());
2998       }
2999       regs[i].set_pair(reg2, reg1);
3000     }
3001   }
3002 
3003   // results
3004   *arg_size = cnt;
3005   return regs;
3006 }
3007 
3008 // OSR Migration Code
3009 //
3010 // This code is used convert interpreter frames into compiled frames.  It is
3011 // called from very start of a compiled OSR nmethod.  A temp array is
3012 // allocated to hold the interesting bits of the interpreter frame.  All
3013 // active locks are inflated to allow them to move.  The displaced headers and
3014 // active interpreter locals are copied into the temp buffer.  Then we return
3015 // back to the compiled code.  The compiled code then pops the current
3016 // interpreter frame off the stack and pushes a new compiled frame.  Then it
3017 // copies the interpreter locals and displaced headers where it wants.
3018 // Finally it calls back to free the temp buffer.
3019 //
3020 // All of this is done NOT at any Safepoint, nor is any safepoint or GC allowed.
3021 
3022 JRT_LEAF(intptr_t*, SharedRuntime::OSR_migration_begin( JavaThread *thread) )
3023 
3024   //
3025   // This code is dependent on the memory layout of the interpreter local
3026   // array and the monitors. On all of our platforms the layout is identical
3027   // so this code is shared. If some platform lays the their arrays out
3028   // differently then this code could move to platform specific code or
3029   // the code here could be modified to copy items one at a time using
3030   // frame accessor methods and be platform independent.
3031 
3032   frame fr = thread-&gt;last_frame();
3033   assert(fr.is_interpreted_frame(), &quot;&quot;);
3034   assert(fr.interpreter_frame_expression_stack_size()==0, &quot;only handle empty stacks&quot;);
3035 
3036   // Figure out how many monitors are active.
3037   int active_monitor_count = 0;
3038   for (BasicObjectLock *kptr = fr.interpreter_frame_monitor_end();
3039        kptr &lt; fr.interpreter_frame_monitor_begin();
3040        kptr = fr.next_monitor_in_interpreter_frame(kptr) ) {
3041     if (kptr-&gt;obj() != NULL) active_monitor_count++;
3042   }
3043 
3044   // QQQ we could place number of active monitors in the array so that compiled code
3045   // could double check it.
3046 
3047   Method* moop = fr.interpreter_frame_method();
3048   int max_locals = moop-&gt;max_locals();
3049   // Allocate temp buffer, 1 word per local &amp; 2 per active monitor
3050   int buf_size_words = max_locals + active_monitor_count * BasicObjectLock::size();
3051   intptr_t *buf = NEW_C_HEAP_ARRAY(intptr_t,buf_size_words, mtCode);
3052 
3053   // Copy the locals.  Order is preserved so that loading of longs works.
3054   // Since there&#39;s no GC I can copy the oops blindly.
3055   assert(sizeof(HeapWord)==sizeof(intptr_t), &quot;fix this code&quot;);
3056   Copy::disjoint_words((HeapWord*)fr.interpreter_frame_local_at(max_locals-1),
3057                        (HeapWord*)&amp;buf[0],
3058                        max_locals);
3059 
3060   // Inflate locks.  Copy the displaced headers.  Be careful, there can be holes.
3061   int i = max_locals;
3062   for (BasicObjectLock *kptr2 = fr.interpreter_frame_monitor_end();
3063        kptr2 &lt; fr.interpreter_frame_monitor_begin();
3064        kptr2 = fr.next_monitor_in_interpreter_frame(kptr2) ) {
3065     if (kptr2-&gt;obj() != NULL) {         // Avoid &#39;holes&#39; in the monitor array
3066       BasicLock *lock = kptr2-&gt;lock();
3067       // Inflate so the displaced header becomes position-independent
3068       if (lock-&gt;displaced_header().is_unlocked())
3069         ObjectSynchronizer::inflate_helper(kptr2-&gt;obj());
3070       // Now the displaced header is free to move
3071       buf[i++] = (intptr_t)lock-&gt;displaced_header().value();
3072       buf[i++] = cast_from_oop&lt;intptr_t&gt;(kptr2-&gt;obj());
3073     }
3074   }
3075   assert(i - max_locals == active_monitor_count*2, &quot;found the expected number of monitors&quot;);
3076 
3077   return buf;
3078 JRT_END
3079 
3080 JRT_LEAF(void, SharedRuntime::OSR_migration_end( intptr_t* buf) )
3081   FREE_C_HEAP_ARRAY(intptr_t, buf);
3082 JRT_END
3083 
3084 bool AdapterHandlerLibrary::contains(const CodeBlob* b) {
3085   AdapterHandlerTableIterator iter(_adapters);
3086   while (iter.has_next()) {
3087     AdapterHandlerEntry* a = iter.next();
3088     if (b == CodeCache::find_blob(a-&gt;get_i2c_entry())) return true;
3089   }
3090   return false;
3091 }
3092 
3093 void AdapterHandlerLibrary::print_handler_on(outputStream* st, const CodeBlob* b) {
3094   AdapterHandlerTableIterator iter(_adapters);
3095   while (iter.has_next()) {
3096     AdapterHandlerEntry* a = iter.next();
3097     if (b == CodeCache::find_blob(a-&gt;get_i2c_entry())) {
3098       st-&gt;print(&quot;Adapter for signature: &quot;);
3099       a-&gt;print_adapter_on(tty);
3100       return;
3101     }
3102   }
3103   assert(false, &quot;Should have found handler&quot;);
3104 }
3105 
3106 void AdapterHandlerEntry::print_adapter_on(outputStream* st) const {
3107   st-&gt;print(&quot;AHE@&quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(this), fingerprint()-&gt;as_string());
3108   if (get_i2c_entry() != NULL) {
3109     st-&gt;print(&quot; i2c: &quot; INTPTR_FORMAT, p2i(get_i2c_entry()));
3110   }
3111   if (get_c2i_entry() != NULL) {
3112     st-&gt;print(&quot; c2i: &quot; INTPTR_FORMAT, p2i(get_c2i_entry()));
3113   }
<a name="94" id="anc94"></a>





3114   if (get_c2i_unverified_entry() != NULL) {
<a name="95" id="anc95"></a><span class="line-modified">3115     st-&gt;print(&quot; c2iUV: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));</span>



3116   }
3117   if (get_c2i_no_clinit_check_entry() != NULL) {
3118     st-&gt;print(&quot; c2iNCI: &quot; INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));
3119   }
3120   st-&gt;cr();
3121 }
3122 
3123 #if INCLUDE_CDS
3124 
3125 void CDSAdapterHandlerEntry::init() {
3126   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
3127   _c2i_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());
<a name="96" id="anc96"></a>

3128   _adapter_trampoline = (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*));
3129 };
3130 
3131 #endif // INCLUDE_CDS
3132 
3133 
3134 #ifndef PRODUCT
3135 
3136 void AdapterHandlerLibrary::print_statistics() {
3137   _adapters-&gt;print_statistics();
3138 }
3139 
3140 #endif /* PRODUCT */
3141 
3142 JRT_LEAF(void, SharedRuntime::enable_stack_reserved_zone(JavaThread* thread))
3143   assert(thread-&gt;is_Java_thread(), &quot;Only Java threads have a stack reserved zone&quot;);
3144   if (thread-&gt;stack_reserved_zone_disabled()) {
3145   thread-&gt;enable_stack_reserved_zone();
3146   }
3147   thread-&gt;set_reserved_stack_activation(thread-&gt;stack_base());
3148 JRT_END
3149 
3150 frame SharedRuntime::look_for_reserved_stack_annotated_method(JavaThread* thread, frame fr) {
3151   ResourceMark rm(thread);
3152   frame activation;
3153   CompiledMethod* nm = NULL;
3154   int count = 1;
3155 
3156   assert(fr.is_java_frame(), &quot;Must start on Java frame&quot;);
3157 
3158   while (true) {
3159     Method* method = NULL;
3160     bool found = false;
3161     if (fr.is_interpreted_frame()) {
3162       method = fr.interpreter_frame_method();
3163       if (method != NULL &amp;&amp; method-&gt;has_reserved_stack_access()) {
3164         found = true;
3165       }
3166     } else {
3167       CodeBlob* cb = fr.cb();
3168       if (cb != NULL &amp;&amp; cb-&gt;is_compiled()) {
3169         nm = cb-&gt;as_compiled_method();
3170         method = nm-&gt;method();
3171         // scope_desc_near() must be used, instead of scope_desc_at() because on
3172         // SPARC, the pcDesc can be on the delay slot after the call instruction.
3173         for (ScopeDesc *sd = nm-&gt;scope_desc_near(fr.pc()); sd != NULL; sd = sd-&gt;sender()) {
3174           method = sd-&gt;method();
3175           if (method != NULL &amp;&amp; method-&gt;has_reserved_stack_access()) {
3176             found = true;
3177       }
3178     }
3179       }
3180     }
3181     if (found) {
3182       activation = fr;
3183       warning(&quot;Potentially dangerous stack overflow in &quot;
3184               &quot;ReservedStackAccess annotated method %s [%d]&quot;,
3185               method-&gt;name_and_sig_as_C_string(), count++);
3186       EventReservedStackActivation event;
3187       if (event.should_commit()) {
3188         event.set_method(method);
3189         event.commit();
3190       }
3191     }
3192     if (fr.is_first_java_frame()) {
3193       break;
3194     } else {
3195       fr = fr.java_sender();
3196     }
3197   }
3198   return activation;
3199 }
3200 
3201 void SharedRuntime::on_slowpath_allocation_exit(JavaThread* thread) {
3202   // After any safepoint, just before going back to compiled code,
3203   // we inform the GC that we will be doing initializing writes to
3204   // this object in the future without emitting card-marks, so
3205   // GC may take any compensating steps.
3206 
3207   oop new_obj = thread-&gt;vm_result();
3208   if (new_obj == NULL) return;
3209 
3210   BarrierSet *bs = BarrierSet::barrier_set();
3211   bs-&gt;on_slowpath_allocation_exit(thread, new_obj);
3212 }
<a name="97" id="anc97"></a>













































































































































































































<a name="98" id="anc98"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="98" type="hidden" />
</body>
</html>
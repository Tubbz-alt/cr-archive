<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/deoptimization.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/deoptimization.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/debugInfoRec.hpp&quot;
  33 #include &quot;code/nmethod.hpp&quot;
  34 #include &quot;code/pcDesc.hpp&quot;
  35 #include &quot;code/scopeDesc.hpp&quot;
  36 #include &quot;compiler/compilationPolicy.hpp&quot;
  37 #include &quot;interpreter/bytecode.hpp&quot;
  38 #include &quot;interpreter/interpreter.hpp&quot;
  39 #include &quot;interpreter/oopMapCache.hpp&quot;
  40 #include &quot;memory/allocation.inline.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.hpp&quot;
  45 #include &quot;oops/method.hpp&quot;
  46 #include &quot;oops/objArrayKlass.hpp&quot;
  47 #include &quot;oops/objArrayOop.inline.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;oops/fieldStreams.inline.hpp&quot;
  50 #include &quot;oops/typeArrayOop.inline.hpp&quot;



  51 #include &quot;oops/verifyOopClosure.hpp&quot;
  52 #include &quot;prims/jvmtiThreadState.hpp&quot;
  53 #include &quot;runtime/atomic.hpp&quot;
  54 #include &quot;runtime/biasedLocking.hpp&quot;
  55 #include &quot;runtime/deoptimization.hpp&quot;
  56 #include &quot;runtime/fieldDescriptor.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  61 #include &quot;runtime/jniHandles.inline.hpp&quot;
  62 #include &quot;runtime/safepointVerifiers.hpp&quot;
  63 #include &quot;runtime/sharedRuntime.hpp&quot;
  64 #include &quot;runtime/signature.hpp&quot;
  65 #include &quot;runtime/stubRoutines.hpp&quot;
  66 #include &quot;runtime/thread.hpp&quot;
  67 #include &quot;runtime/threadSMR.hpp&quot;
  68 #include &quot;runtime/vframe.hpp&quot;
  69 #include &quot;runtime/vframeArray.hpp&quot;
  70 #include &quot;runtime/vframe_hp.hpp&quot;
</pre>
<hr />
<pre>
 164   return fetch_unroll_info_helper(thread, exec_mode);
 165 JRT_END
 166 
 167 #if COMPILER2_OR_JVMCI
 168 static bool eliminate_allocations(JavaThread* thread, int exec_mode, CompiledMethod* compiled_method,
 169                                   frame&amp; deoptee, RegisterMap&amp; map, GrowableArray&lt;compiledVFrame*&gt;* chunk) {
 170   bool realloc_failures = false;
 171   assert (chunk-&gt;at(0)-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 172 
 173   GrowableArray&lt;ScopeValue*&gt;* objects = chunk-&gt;at(0)-&gt;scope()-&gt;objects();
 174 
 175   // The flag return_oop() indicates call sites which return oop
 176   // in compiled code. Such sites include java method calls,
 177   // runtime calls (for example, used to allocate new objects/arrays
 178   // on slow code path) and any other calls generated in compiled code.
 179   // It is not guaranteed that we can get such information here only
 180   // by analyzing bytecode in deoptimized frames. This is why this flag
 181   // is set during method compilation (see Compile::Process_OopMap_Node()).
 182   // If the previous frame was popped or if we are dispatching an exception,
 183   // we don&#39;t have an oop result.
<span class="line-modified"> 184   bool save_oop_result = chunk-&gt;at(0)-&gt;scope()-&gt;return_oop() &amp;&amp; !thread-&gt;popframe_forcing_deopt_reexecution() &amp;&amp; (exec_mode == Deoptimization::Unpack_deopt);</span>
<span class="line-modified"> 185   Handle return_value;</span>











 186   if (save_oop_result) {
 187     // Reallocation may trigger GC. If deoptimization happened on return from
 188     // call which returns oop we need to save it since it is not in oopmap.
 189     oop result = deoptee.saved_oop_result(&amp;map);
 190     assert(oopDesc::is_oop_or_null(result), &quot;must be oop&quot;);
<span class="line-modified"> 191     return_value = Handle(thread, result);</span>
 192     assert(Universe::heap()-&gt;is_in_or_null(result), &quot;must be heap pointer&quot;);
 193     if (TraceDeoptimization) {
 194       ttyLocker ttyl;
 195       tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));
 196     }
 197   }
<span class="line-modified"> 198   if (objects != NULL) {</span>

 199     JRT_BLOCK
<span class="line-modified"> 200       realloc_failures = Deoptimization::realloc_objects(thread, &amp;deoptee, &amp;map, objects, THREAD);</span>






 201     JRT_END
<span class="line-removed"> 202     bool skip_internal = (compiled_method != NULL) &amp;&amp; !compiled_method-&gt;is_compiled_by_jvmci();</span>
<span class="line-removed"> 203     Deoptimization::reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal);</span>
 204 #ifndef PRODUCT
 205     if (TraceDeoptimization) {
 206       ttyLocker ttyl;
 207       tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));
<span class="line-modified"> 208       Deoptimization::print_objects(objects, realloc_failures);</span>





 209     }
 210 #endif
 211   }
<span class="line-modified"> 212   if (save_oop_result) {</span>
 213     // Restore result.
<span class="line-modified"> 214     deoptee.set_saved_oop_result(&amp;map, return_value());</span>

 215   }
 216   return realloc_failures;
 217 }
 218 
 219 static void eliminate_locks(JavaThread* thread, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
 220 #ifndef PRODUCT
 221   bool first = true;
 222 #endif
 223   for (int i = 0; i &lt; chunk-&gt;length(); i++) {
 224     compiledVFrame* cvf = chunk-&gt;at(i);
 225     assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 226     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
 227     if (monitors-&gt;is_nonempty()) {
 228       Deoptimization::relock_objects(monitors, thread, realloc_failures);
 229 #ifndef PRODUCT
 230       if (PrintDeoptimizationDetails) {
 231         ttyLocker ttyl;
 232         for (int j = 0; j &lt; monitors-&gt;length(); j++) {
 233           MonitorInfo* mi = monitors-&gt;at(j);
 234           if (mi-&gt;eliminated()) {
</pre>
<hr />
<pre>
 495   // its caller&#39;s stack by. If the caller is a compiled frame then
 496   // we pretend that the callee has no parameters so that the
 497   // extension counts for the full amount of locals and not just
 498   // locals-parms. This is because without a c2i adapter the parm
 499   // area as created by the compiled frame will not be usable by
 500   // the interpreter. (Depending on the calling convention there
 501   // may not even be enough space).
 502 
 503   // QQQ I&#39;d rather see this pushed down into last_frame_adjust
 504   // and have it take the sender (aka caller).
 505 
 506   if (deopt_sender.is_compiled_frame() || caller_was_method_handle) {
 507     caller_adjustment = last_frame_adjust(0, callee_locals);
 508   } else if (callee_locals &gt; callee_parameters) {
 509     // The caller frame may need extending to accommodate
 510     // non-parameter locals of the first unpacked interpreted frame.
 511     // Compute that adjustment.
 512     caller_adjustment = last_frame_adjust(callee_parameters, callee_locals);
 513   }
 514 
<span class="line-modified"> 515   // If the sender is deoptimized the we must retrieve the address of the handler</span>
 516   // since the frame will &quot;magically&quot; show the original pc before the deopt
 517   // and we&#39;d undo the deopt.
 518 
 519   frame_pcs[0] = deopt_sender.raw_pc();
 520 
 521   assert(CodeCache::find_blob_unsafe(frame_pcs[0]) != NULL, &quot;bad pc&quot;);
 522 
 523 #if INCLUDE_JVMCI
 524   if (exceptionObject() != NULL) {
 525     thread-&gt;set_exception_oop(exceptionObject());
 526     exec_mode = Unpack_exception;
 527   }
 528 #endif
 529 
 530   if (thread-&gt;frames_to_pop_failed_realloc() &gt; 0 &amp;&amp; exec_mode != Unpack_uncommon_trap) {
 531     assert(thread-&gt;has_pending_exception(), &quot;should have thrown OOME&quot;);
 532     thread-&gt;set_exception_oop(thread-&gt;pending_exception());
 533     thread-&gt;clear_pending_exception();
 534     exec_mode = Unpack_exception;
 535   }
</pre>
<hr />
<pre>
 986 
 987     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
 988     oop obj = NULL;
 989 
 990     if (k-&gt;is_instance_klass()) {
 991 #if INCLUDE_JVMCI || INCLUDE_AOT
 992       CompiledMethod* cm = fr-&gt;cb()-&gt;as_compiled_method_or_null();
 993       if (cm-&gt;is_compiled_by_jvmci() &amp;&amp; sv-&gt;is_auto_box()) {
 994         AutoBoxObjectValue* abv = (AutoBoxObjectValue*) sv;
 995         obj = get_cached_box(abv, fr, reg_map, THREAD);
 996         if (obj != NULL) {
 997           // Set the flag to indicate the box came from a cache, so that we can skip the field reassignment for it.
 998           abv-&gt;set_cached(true);
 999         }
1000       }
1001 #endif // INCLUDE_JVMCI || INCLUDE_AOT
1002       InstanceKlass* ik = InstanceKlass::cast(k);
1003       if (obj == NULL) {
1004         obj = ik-&gt;allocate_instance(THREAD);
1005       }




1006     } else if (k-&gt;is_typeArray_klass()) {
1007       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1008       assert(sv-&gt;field_size() % type2size[ak-&gt;element_type()] == 0, &quot;non-integral array length&quot;);
1009       int len = sv-&gt;field_size() / type2size[ak-&gt;element_type()];
1010       obj = ak-&gt;allocate(len, THREAD);
1011     } else if (k-&gt;is_objArray_klass()) {
1012       ObjArrayKlass* ak = ObjArrayKlass::cast(k);
1013       obj = ak-&gt;allocate(sv-&gt;field_size(), THREAD);
1014     }
1015 
1016     if (obj == NULL) {
1017       failures = true;
1018     }
1019 
1020     assert(sv-&gt;value().is_null(), &quot;redundant reallocation&quot;);
1021     assert(obj != NULL || HAS_PENDING_EXCEPTION, &quot;allocation should succeed or we should get an exception&quot;);
1022     CLEAR_PENDING_EXCEPTION;
1023     sv-&gt;set_value(obj);
1024   }
1025 
1026   if (failures) {
1027     THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), failures);
1028   } else if (pending_exception.not_null()) {
1029     thread-&gt;set_pending_exception(pending_exception(), exception_file, exception_line);
1030   }
1031 
1032   return failures;
1033 }
1034 















1035 #if INCLUDE_JVMCI
1036 /**
1037  * For primitive types whose kind gets &quot;erased&quot; at runtime (shorts become stack ints),
1038  * we need to somehow be able to recover the actual kind to be able to write the correct
1039  * amount of bytes.
1040  * For that purpose, this method assumes that, for an entry spanning n bytes at index i,
1041  * the entries at index n + 1 to n + i are &#39;markers&#39;.
1042  * For example, if we were writing a short at index 4 of a byte array of size 8, the
1043  * expected form of the array would be:
1044  *
1045  * {b0, b1, b2, b3, INT, marker, b6, b7}
1046  *
1047  * Thus, in order to get back the size of the entry, we simply need to count the number
1048  * of marked entries
1049  *
1050  * @param virtualArray the virtualized byte array
1051  * @param i index of the virtual entry we are recovering
1052  * @return The number of bytes the entry spans
1053  */
1054 static int count_number_of_bytes_for_entry(ObjectValue *virtualArray, int i) {
</pre>
<hr />
<pre>
1211       default:
1212         ShouldNotReachHere();
1213     }
1214     index++;
1215   }
1216 }
1217 
1218 // restore fields of an eliminated object array
1219 void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj) {
1220   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
1221     StackValue* value = StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(i));
1222     assert(value-&gt;type() == T_OBJECT, &quot;object element expected&quot;);
1223     obj-&gt;obj_at_put(i, value-&gt;get_obj()());
1224   }
1225 }
1226 
1227 class ReassignedField {
1228 public:
1229   int _offset;
1230   BasicType _type;

1231 public:
1232   ReassignedField() {
1233     _offset = 0;
1234     _type = T_ILLEGAL;

1235   }
1236 };
1237 
1238 int compare(ReassignedField* left, ReassignedField* right) {
1239   return left-&gt;_offset - right-&gt;_offset;
1240 }
1241 
1242 // Restore fields of an eliminated instance object using the same field order
1243 // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
<span class="line-modified">1244 static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal) {</span>

1245   GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
1246   InstanceKlass* ik = klass;
1247   while (ik != NULL) {
1248     for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
1249       if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {
1250         ReassignedField field;
1251         field._offset = fs.offset();
1252         field._type = Signature::basic_type(fs.signature());









1253         fields-&gt;append(field);
1254       }
1255     }
1256     ik = ik-&gt;superklass();
1257   }
1258   fields-&gt;sort(compare);
1259   for (int i = 0; i &lt; fields-&gt;length(); i++) {
1260     intptr_t val;
1261     ScopeValue* scope_field = sv-&gt;field_at(svIndex);
1262     StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);
<span class="line-modified">1263     int offset = fields-&gt;at(i)._offset;</span>
1264     BasicType type = fields-&gt;at(i)._type;
1265     switch (type) {
<span class="line-modified">1266       case T_OBJECT: case T_ARRAY:</span>

1267         assert(value-&gt;type() == T_OBJECT, &quot;Agreement.&quot;);
1268         obj-&gt;obj_field_put(offset, value-&gt;get_obj()());
1269         break;
1270 









1271       // Have to cast to INT (32 bits) pointer to avoid little/big-endian problem.
1272       case T_INT: case T_FLOAT: { // 4 bytes.
1273         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1274         bool big_value = false;
1275         if (i+1 &lt; fields-&gt;length() &amp;&amp; fields-&gt;at(i+1)._type == T_INT) {
1276           if (scope_field-&gt;is_location()) {
1277             Location::Type type = ((LocationValue*) scope_field)-&gt;location().type();
1278             if (type == Location::dbl || type == Location::lng) {
1279               big_value = true;
1280             }
1281           }
1282           if (scope_field-&gt;is_constant_int()) {
1283             ScopeValue* next_scope_field = sv-&gt;field_at(svIndex + 1);
1284             if (next_scope_field-&gt;is_constant_long() || next_scope_field-&gt;is_constant_double()) {
1285               big_value = true;
1286             }
1287           }
1288         }
1289 
1290         if (big_value) {
</pre>
<hr />
<pre>
1331       case T_BYTE:
1332         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1333         val = value-&gt;get_int();
1334         obj-&gt;byte_field_put(offset, (jbyte)*((jint*)&amp;val));
1335         break;
1336 
1337       case T_BOOLEAN:
1338         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1339         val = value-&gt;get_int();
1340         obj-&gt;bool_field_put(offset, (jboolean)*((jint*)&amp;val));
1341         break;
1342 
1343       default:
1344         ShouldNotReachHere();
1345     }
1346     svIndex++;
1347   }
1348   return svIndex;
1349 }
1350 














1351 // restore fields of all eliminated objects and arrays
<span class="line-modified">1352 void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal) {</span>
1353   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1354     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1355     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1356     Handle obj = sv-&gt;value();
1357     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1358     if (PrintDeoptimizationDetails) {
1359       tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
1360     }
1361     if (obj.is_null()) {
1362       continue;
1363     }
1364 #if INCLUDE_JVMCI || INCLUDE_AOT
1365     // Don&#39;t reassign fields of boxes that came from a cache. Caches may be in CDS.
1366     if (sv-&gt;is_auto_box() &amp;&amp; ((AutoBoxObjectValue*) sv)-&gt;is_cached()) {
1367       continue;
1368     }
1369 #endif // INCLUDE_JVMCI || INCLUDE_AOT
1370     if (k-&gt;is_instance_klass()) {
1371       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1372       reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);</span>



1373     } else if (k-&gt;is_typeArray_klass()) {
1374       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1375       reassign_type_array_elements(fr, reg_map, sv, (typeArrayOop) obj(), ak-&gt;element_type());
1376     } else if (k-&gt;is_objArray_klass()) {
1377       reassign_object_array_elements(fr, reg_map, sv, (objArrayOop) obj());
1378     }
1379   }
1380 }
1381 
1382 
1383 // relock objects for which synchronization was eliminated
1384 void Deoptimization::relock_objects(GrowableArray&lt;MonitorInfo*&gt;* monitors, JavaThread* thread, bool realloc_failures) {
1385   for (int i = 0; i &lt; monitors-&gt;length(); i++) {
1386     MonitorInfo* mon_info = monitors-&gt;at(i);
1387     if (mon_info-&gt;eliminated()) {
1388       assert(!mon_info-&gt;owner_is_scalar_replaced() || realloc_failures, &quot;reallocation was missed&quot;);
1389       if (!mon_info-&gt;owner_is_scalar_replaced()) {
1390         Handle obj(thread, mon_info-&gt;owner());
1391         markWord mark = obj-&gt;mark();
1392         if (UseBiasedLocking &amp;&amp; mark.has_bias_pattern()) {
</pre>
<hr />
<pre>
1395           // where the thread-local object is bias locked to the current thread.
1396           assert(mark.is_biased_anonymously() ||
1397                  mark.biased_locker() == thread, &quot;should be locked to current thread&quot;);
1398           // Reset mark word to unbiased prototype.
1399           markWord unbiased_prototype = markWord::prototype().set_age(mark.age());
1400           obj-&gt;set_mark(unbiased_prototype);
1401         }
1402         BasicLock* lock = mon_info-&gt;lock();
1403         ObjectSynchronizer::enter(obj, lock, thread);
1404         assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
1405       }
1406     }
1407   }
1408 }
1409 
1410 
1411 #ifndef PRODUCT
1412 // print information about reallocated objects
1413 void Deoptimization::print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures) {
1414   fieldDescriptor fd;
<span class="line-removed">1415 </span>
1416   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1417     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1418     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
<span class="line-modified">1419     Handle obj = sv-&gt;value();</span>


1420 
<span class="line-modified">1421     tty-&gt;print(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; of type &quot;, p2i(sv-&gt;value()()));</span>
<span class="line-modified">1422     k-&gt;print_value();</span>
<span class="line-modified">1423     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);</span>
<span class="line-modified">1424     if (obj.is_null()) {</span>
<span class="line-modified">1425       tty-&gt;print(&quot; allocation failed&quot;);</span>
<span class="line-modified">1426     } else {</span>
<span class="line-modified">1427       tty-&gt;print(&quot; allocated (%d bytes)&quot;, obj-&gt;size() * HeapWordSize);</span>
<span class="line-modified">1428     }</span>
<span class="line-modified">1429     tty-&gt;cr();</span>

1430 
<span class="line-modified">1431     if (Verbose &amp;&amp; !obj.is_null()) {</span>
<span class="line-modified">1432       k-&gt;oop_print_on(obj(), tty);</span>
<span class="line-removed">1433     }</span>
1434   }
1435 }
1436 #endif
1437 #endif // COMPILER2_OR_JVMCI
1438 
1439 vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
1440   Events::log_deopt_message(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));
1441 
1442 #ifndef PRODUCT
1443   if (PrintDeoptimizationDetails) {
1444     ttyLocker ttyl;
1445     tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
1446     fr.print_on(tty);
1447     tty-&gt;print_cr(&quot;     Virtual frames (innermost first):&quot;);
1448     for (int index = 0; index &lt; chunk-&gt;length(); index++) {
1449       compiledVFrame* vf = chunk-&gt;at(index);
1450       tty-&gt;print(&quot;       %2d - &quot;, index);
1451       vf-&gt;print_value();
1452       int bci = chunk-&gt;at(index)-&gt;raw_bci();
1453       const char* code_name;
</pre>
<hr />
<pre>
1586 
1587     ttyLocker ttyl;
1588     xtty-&gt;begin_head(&quot;deoptimized thread=&#39;&quot; UINTX_FORMAT &quot;&#39; reason=&#39;%s&#39; pc=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;,(uintx)thread-&gt;osthread()-&gt;thread_id(), trap_reason_name(reason), p2i(fr.pc()));
1589     cm-&gt;log_identity(xtty);
1590     xtty-&gt;end_head();
1591     for (ScopeDesc* sd = cm-&gt;scope_desc_at(fr.pc()); ; sd = sd-&gt;sender()) {
1592       xtty-&gt;begin_elem(&quot;jvms bci=&#39;%d&#39;&quot;, sd-&gt;bci());
1593       xtty-&gt;method(sd-&gt;method());
1594       xtty-&gt;end_elem();
1595       if (sd-&gt;is_top())  break;
1596     }
1597     xtty-&gt;tail(&quot;deoptimized&quot;);
1598   }
1599 
1600   // Patch the compiled method so that when execution returns to it we will
1601   // deopt the execution state and return to the interpreter.
1602   fr.deoptimize(thread);
1603 }
1604 
1605 void Deoptimization::deoptimize(JavaThread* thread, frame fr, DeoptReason reason) {
<span class="line-modified">1606   // Deoptimize only if the frame comes from compile code.</span>
1607   // Do not deoptimize the frame which is already patched
1608   // during the execution of the loops below.
1609   if (!fr.is_compiled_frame() || fr.is_deoptimized_frame()) {
1610     return;
1611   }
1612   ResourceMark rm;
1613   DeoptimizationMarker dm;
1614   deoptimize_single_frame(thread, fr, reason);
1615 }
1616 
1617 #if INCLUDE_JVMCI
1618 address Deoptimization::deoptimize_for_missing_exception_handler(CompiledMethod* cm) {
1619   // there is no exception handler for this pc =&gt; deoptimize
1620   cm-&gt;make_not_entrant();
1621 
1622   // Use Deoptimization::deoptimize for all of its side-effects:
1623   // gathering traps statistics, logging...
1624   // it also patches the return pc but we do not care about that
1625   // since we return a continuation to the deopt_blob below.
1626   JavaThread* thread = JavaThread::current();
</pre>
</td>
<td>
<hr />
<pre>
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/debugInfoRec.hpp&quot;
  33 #include &quot;code/nmethod.hpp&quot;
  34 #include &quot;code/pcDesc.hpp&quot;
  35 #include &quot;code/scopeDesc.hpp&quot;
  36 #include &quot;compiler/compilationPolicy.hpp&quot;
  37 #include &quot;interpreter/bytecode.hpp&quot;
  38 #include &quot;interpreter/interpreter.hpp&quot;
  39 #include &quot;interpreter/oopMapCache.hpp&quot;
  40 #include &quot;memory/allocation.inline.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.hpp&quot;
  45 #include &quot;oops/method.hpp&quot;
  46 #include &quot;oops/objArrayKlass.hpp&quot;
  47 #include &quot;oops/objArrayOop.inline.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;oops/fieldStreams.inline.hpp&quot;
  50 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  51 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  52 #include &quot;oops/valueArrayOop.hpp&quot;</span>
<span class="line-added">  53 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  54 #include &quot;oops/verifyOopClosure.hpp&quot;
  55 #include &quot;prims/jvmtiThreadState.hpp&quot;
  56 #include &quot;runtime/atomic.hpp&quot;
  57 #include &quot;runtime/biasedLocking.hpp&quot;
  58 #include &quot;runtime/deoptimization.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.hpp&quot;
  60 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  61 #include &quot;runtime/frame.inline.hpp&quot;
  62 #include &quot;runtime/handles.inline.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepointVerifiers.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/signature.hpp&quot;
  68 #include &quot;runtime/stubRoutines.hpp&quot;
  69 #include &quot;runtime/thread.hpp&quot;
  70 #include &quot;runtime/threadSMR.hpp&quot;
  71 #include &quot;runtime/vframe.hpp&quot;
  72 #include &quot;runtime/vframeArray.hpp&quot;
  73 #include &quot;runtime/vframe_hp.hpp&quot;
</pre>
<hr />
<pre>
 167   return fetch_unroll_info_helper(thread, exec_mode);
 168 JRT_END
 169 
 170 #if COMPILER2_OR_JVMCI
 171 static bool eliminate_allocations(JavaThread* thread, int exec_mode, CompiledMethod* compiled_method,
 172                                   frame&amp; deoptee, RegisterMap&amp; map, GrowableArray&lt;compiledVFrame*&gt;* chunk) {
 173   bool realloc_failures = false;
 174   assert (chunk-&gt;at(0)-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 175 
 176   GrowableArray&lt;ScopeValue*&gt;* objects = chunk-&gt;at(0)-&gt;scope()-&gt;objects();
 177 
 178   // The flag return_oop() indicates call sites which return oop
 179   // in compiled code. Such sites include java method calls,
 180   // runtime calls (for example, used to allocate new objects/arrays
 181   // on slow code path) and any other calls generated in compiled code.
 182   // It is not guaranteed that we can get such information here only
 183   // by analyzing bytecode in deoptimized frames. This is why this flag
 184   // is set during method compilation (see Compile::Process_OopMap_Node()).
 185   // If the previous frame was popped or if we are dispatching an exception,
 186   // we don&#39;t have an oop result.
<span class="line-modified"> 187   ScopeDesc* scope = chunk-&gt;at(0)-&gt;scope();</span>
<span class="line-modified"> 188   bool save_oop_result = scope-&gt;return_oop() &amp;&amp; !thread-&gt;popframe_forcing_deopt_reexecution() &amp;&amp; (exec_mode == Deoptimization::Unpack_deopt);</span>
<span class="line-added"> 189   // In case of the return of multiple values, we must take care</span>
<span class="line-added"> 190   // of all oop return values.</span>
<span class="line-added"> 191   GrowableArray&lt;Handle&gt; return_oops;</span>
<span class="line-added"> 192   ValueKlass* vk = NULL;</span>
<span class="line-added"> 193   if (save_oop_result &amp;&amp; scope-&gt;return_vt()) {</span>
<span class="line-added"> 194     vk = ValueKlass::returned_value_klass(map);</span>
<span class="line-added"> 195     if (vk != NULL) {</span>
<span class="line-added"> 196       vk-&gt;save_oop_fields(map, return_oops);</span>
<span class="line-added"> 197       save_oop_result = false;</span>
<span class="line-added"> 198     }</span>
<span class="line-added"> 199   }</span>
 200   if (save_oop_result) {
 201     // Reallocation may trigger GC. If deoptimization happened on return from
 202     // call which returns oop we need to save it since it is not in oopmap.
 203     oop result = deoptee.saved_oop_result(&amp;map);
 204     assert(oopDesc::is_oop_or_null(result), &quot;must be oop&quot;);
<span class="line-modified"> 205     return_oops.push(Handle(thread, result));</span>
 206     assert(Universe::heap()-&gt;is_in_or_null(result), &quot;must be heap pointer&quot;);
 207     if (TraceDeoptimization) {
 208       ttyLocker ttyl;
 209       tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));
 210     }
 211   }
<span class="line-modified"> 212   if (objects != NULL || vk != NULL) {</span>
<span class="line-added"> 213     bool skip_internal = (compiled_method != NULL) &amp;&amp; !compiled_method-&gt;is_compiled_by_jvmci();</span>
 214     JRT_BLOCK
<span class="line-modified"> 215       if (vk != NULL) {</span>
<span class="line-added"> 216         realloc_failures = Deoptimization::realloc_value_type_result(vk, map, return_oops, THREAD);</span>
<span class="line-added"> 217       }</span>
<span class="line-added"> 218       if (objects != NULL) {</span>
<span class="line-added"> 219         realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &amp;deoptee, &amp;map, objects, THREAD);</span>
<span class="line-added"> 220         Deoptimization::reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal, THREAD);</span>
<span class="line-added"> 221       }</span>
 222     JRT_END


 223 #ifndef PRODUCT
 224     if (TraceDeoptimization) {
 225       ttyLocker ttyl;
 226       tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));
<span class="line-modified"> 227       if (objects != NULL) {</span>
<span class="line-added"> 228         Deoptimization::print_objects(objects, realloc_failures);</span>
<span class="line-added"> 229       } else {</span>
<span class="line-added"> 230         Handle obj = realloc_failures ? Handle() : return_oops.first();</span>
<span class="line-added"> 231         Deoptimization::print_object(vk, obj, realloc_failures);</span>
<span class="line-added"> 232       }</span>
 233     }
 234 #endif
 235   }
<span class="line-modified"> 236   if (save_oop_result || vk != NULL) {</span>
 237     // Restore result.
<span class="line-modified"> 238     assert(return_oops.length() == 1, &quot;no value type&quot;);</span>
<span class="line-added"> 239     deoptee.set_saved_oop_result(&amp;map, return_oops.pop()());</span>
 240   }
 241   return realloc_failures;
 242 }
 243 
 244 static void eliminate_locks(JavaThread* thread, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
 245 #ifndef PRODUCT
 246   bool first = true;
 247 #endif
 248   for (int i = 0; i &lt; chunk-&gt;length(); i++) {
 249     compiledVFrame* cvf = chunk-&gt;at(i);
 250     assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 251     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
 252     if (monitors-&gt;is_nonempty()) {
 253       Deoptimization::relock_objects(monitors, thread, realloc_failures);
 254 #ifndef PRODUCT
 255       if (PrintDeoptimizationDetails) {
 256         ttyLocker ttyl;
 257         for (int j = 0; j &lt; monitors-&gt;length(); j++) {
 258           MonitorInfo* mi = monitors-&gt;at(j);
 259           if (mi-&gt;eliminated()) {
</pre>
<hr />
<pre>
 520   // its caller&#39;s stack by. If the caller is a compiled frame then
 521   // we pretend that the callee has no parameters so that the
 522   // extension counts for the full amount of locals and not just
 523   // locals-parms. This is because without a c2i adapter the parm
 524   // area as created by the compiled frame will not be usable by
 525   // the interpreter. (Depending on the calling convention there
 526   // may not even be enough space).
 527 
 528   // QQQ I&#39;d rather see this pushed down into last_frame_adjust
 529   // and have it take the sender (aka caller).
 530 
 531   if (deopt_sender.is_compiled_frame() || caller_was_method_handle) {
 532     caller_adjustment = last_frame_adjust(0, callee_locals);
 533   } else if (callee_locals &gt; callee_parameters) {
 534     // The caller frame may need extending to accommodate
 535     // non-parameter locals of the first unpacked interpreted frame.
 536     // Compute that adjustment.
 537     caller_adjustment = last_frame_adjust(callee_parameters, callee_locals);
 538   }
 539 
<span class="line-modified"> 540   // If the sender is deoptimized we must retrieve the address of the handler</span>
 541   // since the frame will &quot;magically&quot; show the original pc before the deopt
 542   // and we&#39;d undo the deopt.
 543 
 544   frame_pcs[0] = deopt_sender.raw_pc();
 545 
 546   assert(CodeCache::find_blob_unsafe(frame_pcs[0]) != NULL, &quot;bad pc&quot;);
 547 
 548 #if INCLUDE_JVMCI
 549   if (exceptionObject() != NULL) {
 550     thread-&gt;set_exception_oop(exceptionObject());
 551     exec_mode = Unpack_exception;
 552   }
 553 #endif
 554 
 555   if (thread-&gt;frames_to_pop_failed_realloc() &gt; 0 &amp;&amp; exec_mode != Unpack_uncommon_trap) {
 556     assert(thread-&gt;has_pending_exception(), &quot;should have thrown OOME&quot;);
 557     thread-&gt;set_exception_oop(thread-&gt;pending_exception());
 558     thread-&gt;clear_pending_exception();
 559     exec_mode = Unpack_exception;
 560   }
</pre>
<hr />
<pre>
1011 
1012     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1013     oop obj = NULL;
1014 
1015     if (k-&gt;is_instance_klass()) {
1016 #if INCLUDE_JVMCI || INCLUDE_AOT
1017       CompiledMethod* cm = fr-&gt;cb()-&gt;as_compiled_method_or_null();
1018       if (cm-&gt;is_compiled_by_jvmci() &amp;&amp; sv-&gt;is_auto_box()) {
1019         AutoBoxObjectValue* abv = (AutoBoxObjectValue*) sv;
1020         obj = get_cached_box(abv, fr, reg_map, THREAD);
1021         if (obj != NULL) {
1022           // Set the flag to indicate the box came from a cache, so that we can skip the field reassignment for it.
1023           abv-&gt;set_cached(true);
1024         }
1025       }
1026 #endif // INCLUDE_JVMCI || INCLUDE_AOT
1027       InstanceKlass* ik = InstanceKlass::cast(k);
1028       if (obj == NULL) {
1029         obj = ik-&gt;allocate_instance(THREAD);
1030       }
<span class="line-added">1031     } else if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added">1032       ValueArrayKlass* ak = ValueArrayKlass::cast(k);</span>
<span class="line-added">1033       // Value type array must be zeroed because not all memory is reassigned</span>
<span class="line-added">1034       obj = ak-&gt;allocate(sv-&gt;field_size(), THREAD);</span>
1035     } else if (k-&gt;is_typeArray_klass()) {
1036       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1037       assert(sv-&gt;field_size() % type2size[ak-&gt;element_type()] == 0, &quot;non-integral array length&quot;);
1038       int len = sv-&gt;field_size() / type2size[ak-&gt;element_type()];
1039       obj = ak-&gt;allocate(len, THREAD);
1040     } else if (k-&gt;is_objArray_klass()) {
1041       ObjArrayKlass* ak = ObjArrayKlass::cast(k);
1042       obj = ak-&gt;allocate(sv-&gt;field_size(), THREAD);
1043     }
1044 
1045     if (obj == NULL) {
1046       failures = true;
1047     }
1048 
1049     assert(sv-&gt;value().is_null(), &quot;redundant reallocation&quot;);
1050     assert(obj != NULL || HAS_PENDING_EXCEPTION, &quot;allocation should succeed or we should get an exception&quot;);
1051     CLEAR_PENDING_EXCEPTION;
1052     sv-&gt;set_value(obj);
1053   }
1054 
1055   if (failures) {
1056     THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), failures);
1057   } else if (pending_exception.not_null()) {
1058     thread-&gt;set_pending_exception(pending_exception(), exception_file, exception_line);
1059   }
1060 
1061   return failures;
1062 }
1063 
<span class="line-added">1064 // We&#39;re deoptimizing at the return of a call, value type fields are</span>
<span class="line-added">1065 // in registers. When we go back to the interpreter, it will expect a</span>
<span class="line-added">1066 // reference to a value type instance. Allocate and initialize it from</span>
<span class="line-added">1067 // the register values here.</span>
<span class="line-added">1068 bool Deoptimization::realloc_value_type_result(ValueKlass* vk, const RegisterMap&amp; map, GrowableArray&lt;Handle&gt;&amp; return_oops, TRAPS) {</span>
<span class="line-added">1069   oop new_vt = vk-&gt;realloc_result(map, return_oops, THREAD);</span>
<span class="line-added">1070   if (new_vt == NULL) {</span>
<span class="line-added">1071     CLEAR_PENDING_EXCEPTION;</span>
<span class="line-added">1072     THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), true);</span>
<span class="line-added">1073   }</span>
<span class="line-added">1074   return_oops.clear();</span>
<span class="line-added">1075   return_oops.push(Handle(THREAD, new_vt));</span>
<span class="line-added">1076   return false;</span>
<span class="line-added">1077 }</span>
<span class="line-added">1078 </span>
1079 #if INCLUDE_JVMCI
1080 /**
1081  * For primitive types whose kind gets &quot;erased&quot; at runtime (shorts become stack ints),
1082  * we need to somehow be able to recover the actual kind to be able to write the correct
1083  * amount of bytes.
1084  * For that purpose, this method assumes that, for an entry spanning n bytes at index i,
1085  * the entries at index n + 1 to n + i are &#39;markers&#39;.
1086  * For example, if we were writing a short at index 4 of a byte array of size 8, the
1087  * expected form of the array would be:
1088  *
1089  * {b0, b1, b2, b3, INT, marker, b6, b7}
1090  *
1091  * Thus, in order to get back the size of the entry, we simply need to count the number
1092  * of marked entries
1093  *
1094  * @param virtualArray the virtualized byte array
1095  * @param i index of the virtual entry we are recovering
1096  * @return The number of bytes the entry spans
1097  */
1098 static int count_number_of_bytes_for_entry(ObjectValue *virtualArray, int i) {
</pre>
<hr />
<pre>
1255       default:
1256         ShouldNotReachHere();
1257     }
1258     index++;
1259   }
1260 }
1261 
1262 // restore fields of an eliminated object array
1263 void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj) {
1264   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
1265     StackValue* value = StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(i));
1266     assert(value-&gt;type() == T_OBJECT, &quot;object element expected&quot;);
1267     obj-&gt;obj_at_put(i, value-&gt;get_obj()());
1268   }
1269 }
1270 
1271 class ReassignedField {
1272 public:
1273   int _offset;
1274   BasicType _type;
<span class="line-added">1275   InstanceKlass* _klass;</span>
1276 public:
1277   ReassignedField() {
1278     _offset = 0;
1279     _type = T_ILLEGAL;
<span class="line-added">1280     _klass = NULL;</span>
1281   }
1282 };
1283 
1284 int compare(ReassignedField* left, ReassignedField* right) {
1285   return left-&gt;_offset - right-&gt;_offset;
1286 }
1287 
1288 // Restore fields of an eliminated instance object using the same field order
1289 // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
<span class="line-modified">1290 static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal, int base_offset, TRAPS) {</span>
<span class="line-added">1291 </span>
1292   GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
1293   InstanceKlass* ik = klass;
1294   while (ik != NULL) {
1295     for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
1296       if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {
1297         ReassignedField field;
1298         field._offset = fs.offset();
1299         field._type = Signature::basic_type(fs.signature());
<span class="line-added">1300         if (field._type == T_VALUETYPE) {</span>
<span class="line-added">1301           field._type = T_OBJECT;</span>
<span class="line-added">1302         }</span>
<span class="line-added">1303         if (fs.is_flattened()) {</span>
<span class="line-added">1304           // Resolve klass of flattened value type field</span>
<span class="line-added">1305           Klass* vk = klass-&gt;get_value_field_klass(fs.index());</span>
<span class="line-added">1306           field._klass = ValueKlass::cast(vk);</span>
<span class="line-added">1307           field._type = T_VALUETYPE;</span>
<span class="line-added">1308         }</span>
1309         fields-&gt;append(field);
1310       }
1311     }
1312     ik = ik-&gt;superklass();
1313   }
1314   fields-&gt;sort(compare);
1315   for (int i = 0; i &lt; fields-&gt;length(); i++) {
1316     intptr_t val;
1317     ScopeValue* scope_field = sv-&gt;field_at(svIndex);
1318     StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);
<span class="line-modified">1319     int offset = base_offset + fields-&gt;at(i)._offset;</span>
1320     BasicType type = fields-&gt;at(i)._type;
1321     switch (type) {
<span class="line-modified">1322       case T_OBJECT:</span>
<span class="line-added">1323       case T_ARRAY:</span>
1324         assert(value-&gt;type() == T_OBJECT, &quot;Agreement.&quot;);
1325         obj-&gt;obj_field_put(offset, value-&gt;get_obj()());
1326         break;
1327 
<span class="line-added">1328       case T_VALUETYPE: {</span>
<span class="line-added">1329         // Recursively re-assign flattened value type fields</span>
<span class="line-added">1330         InstanceKlass* vk = fields-&gt;at(i)._klass;</span>
<span class="line-added">1331         assert(vk != NULL, &quot;must be resolved&quot;);</span>
<span class="line-added">1332         offset -= ValueKlass::cast(vk)-&gt;first_field_offset(); // Adjust offset to omit oop header</span>
<span class="line-added">1333         svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, skip_internal, offset, CHECK_0);</span>
<span class="line-added">1334         continue; // Continue because we don&#39;t need to increment svIndex</span>
<span class="line-added">1335       }</span>
<span class="line-added">1336 </span>
1337       // Have to cast to INT (32 bits) pointer to avoid little/big-endian problem.
1338       case T_INT: case T_FLOAT: { // 4 bytes.
1339         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1340         bool big_value = false;
1341         if (i+1 &lt; fields-&gt;length() &amp;&amp; fields-&gt;at(i+1)._type == T_INT) {
1342           if (scope_field-&gt;is_location()) {
1343             Location::Type type = ((LocationValue*) scope_field)-&gt;location().type();
1344             if (type == Location::dbl || type == Location::lng) {
1345               big_value = true;
1346             }
1347           }
1348           if (scope_field-&gt;is_constant_int()) {
1349             ScopeValue* next_scope_field = sv-&gt;field_at(svIndex + 1);
1350             if (next_scope_field-&gt;is_constant_long() || next_scope_field-&gt;is_constant_double()) {
1351               big_value = true;
1352             }
1353           }
1354         }
1355 
1356         if (big_value) {
</pre>
<hr />
<pre>
1397       case T_BYTE:
1398         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1399         val = value-&gt;get_int();
1400         obj-&gt;byte_field_put(offset, (jbyte)*((jint*)&amp;val));
1401         break;
1402 
1403       case T_BOOLEAN:
1404         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1405         val = value-&gt;get_int();
1406         obj-&gt;bool_field_put(offset, (jboolean)*((jint*)&amp;val));
1407         break;
1408 
1409       default:
1410         ShouldNotReachHere();
1411     }
1412     svIndex++;
1413   }
1414   return svIndex;
1415 }
1416 
<span class="line-added">1417 // restore fields of an eliminated value type array</span>
<span class="line-added">1418 void Deoptimization::reassign_value_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, valueArrayOop obj, ValueArrayKlass* vak, TRAPS) {</span>
<span class="line-added">1419   ValueKlass* vk = vak-&gt;element_klass();</span>
<span class="line-added">1420   assert(vk-&gt;flatten_array(), &quot;should only be used for flattened value type arrays&quot;);</span>
<span class="line-added">1421   // Adjust offset to omit oop header</span>
<span class="line-added">1422   int base_offset = arrayOopDesc::base_offset_in_bytes(T_VALUETYPE) - ValueKlass::cast(vk)-&gt;first_field_offset();</span>
<span class="line-added">1423   // Initialize all elements of the flattened value type array</span>
<span class="line-added">1424   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {</span>
<span class="line-added">1425     ScopeValue* val = sv-&gt;field_at(i);</span>
<span class="line-added">1426     int offset = base_offset + (i &lt;&lt; Klass::layout_helper_log2_element_size(vak-&gt;layout_helper()));</span>
<span class="line-added">1427     reassign_fields_by_klass(vk, fr, reg_map, val-&gt;as_ObjectValue(), 0, (oop)obj, false /* skip_internal */, offset, CHECK);</span>
<span class="line-added">1428   }</span>
<span class="line-added">1429 }</span>
<span class="line-added">1430 </span>
1431 // restore fields of all eliminated objects and arrays
<span class="line-modified">1432 void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal, TRAPS) {</span>
1433   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1434     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1435     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1436     Handle obj = sv-&gt;value();
1437     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1438     if (PrintDeoptimizationDetails) {
1439       tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
1440     }
1441     if (obj.is_null()) {
1442       continue;
1443     }
1444 #if INCLUDE_JVMCI || INCLUDE_AOT
1445     // Don&#39;t reassign fields of boxes that came from a cache. Caches may be in CDS.
1446     if (sv-&gt;is_auto_box() &amp;&amp; ((AutoBoxObjectValue*) sv)-&gt;is_cached()) {
1447       continue;
1448     }
1449 #endif // INCLUDE_JVMCI || INCLUDE_AOT
1450     if (k-&gt;is_instance_klass()) {
1451       InstanceKlass* ik = InstanceKlass::cast(k);
<span class="line-modified">1452       reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal, 0, CHECK);</span>
<span class="line-added">1453     } else if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added">1454       ValueArrayKlass* vak = ValueArrayKlass::cast(k);</span>
<span class="line-added">1455       reassign_value_array_elements(fr, reg_map, sv, (valueArrayOop) obj(), vak, CHECK);</span>
1456     } else if (k-&gt;is_typeArray_klass()) {
1457       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1458       reassign_type_array_elements(fr, reg_map, sv, (typeArrayOop) obj(), ak-&gt;element_type());
1459     } else if (k-&gt;is_objArray_klass()) {
1460       reassign_object_array_elements(fr, reg_map, sv, (objArrayOop) obj());
1461     }
1462   }
1463 }
1464 
1465 
1466 // relock objects for which synchronization was eliminated
1467 void Deoptimization::relock_objects(GrowableArray&lt;MonitorInfo*&gt;* monitors, JavaThread* thread, bool realloc_failures) {
1468   for (int i = 0; i &lt; monitors-&gt;length(); i++) {
1469     MonitorInfo* mon_info = monitors-&gt;at(i);
1470     if (mon_info-&gt;eliminated()) {
1471       assert(!mon_info-&gt;owner_is_scalar_replaced() || realloc_failures, &quot;reallocation was missed&quot;);
1472       if (!mon_info-&gt;owner_is_scalar_replaced()) {
1473         Handle obj(thread, mon_info-&gt;owner());
1474         markWord mark = obj-&gt;mark();
1475         if (UseBiasedLocking &amp;&amp; mark.has_bias_pattern()) {
</pre>
<hr />
<pre>
1478           // where the thread-local object is bias locked to the current thread.
1479           assert(mark.is_biased_anonymously() ||
1480                  mark.biased_locker() == thread, &quot;should be locked to current thread&quot;);
1481           // Reset mark word to unbiased prototype.
1482           markWord unbiased_prototype = markWord::prototype().set_age(mark.age());
1483           obj-&gt;set_mark(unbiased_prototype);
1484         }
1485         BasicLock* lock = mon_info-&gt;lock();
1486         ObjectSynchronizer::enter(obj, lock, thread);
1487         assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
1488       }
1489     }
1490   }
1491 }
1492 
1493 
1494 #ifndef PRODUCT
1495 // print information about reallocated objects
1496 void Deoptimization::print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures) {
1497   fieldDescriptor fd;

1498   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1499     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1500     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
<span class="line-modified">1501     print_object(k, sv-&gt;value(), realloc_failures);</span>
<span class="line-added">1502   }</span>
<span class="line-added">1503 }</span>
1504 
<span class="line-modified">1505 void Deoptimization::print_object(Klass* k, Handle obj, bool realloc_failures) {</span>
<span class="line-modified">1506   tty-&gt;print(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; of type &quot;, p2i(obj()));</span>
<span class="line-modified">1507   k-&gt;print_value();</span>
<span class="line-modified">1508   assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);</span>
<span class="line-modified">1509   if (obj.is_null()) {</span>
<span class="line-modified">1510     tty-&gt;print(&quot; allocation failed&quot;);</span>
<span class="line-modified">1511   } else {</span>
<span class="line-modified">1512     tty-&gt;print(&quot; allocated (%d bytes)&quot;, obj-&gt;size() * HeapWordSize);</span>
<span class="line-modified">1513   }</span>
<span class="line-added">1514   tty-&gt;cr();</span>
1515 
<span class="line-modified">1516   if (Verbose &amp;&amp; !obj.is_null()) {</span>
<span class="line-modified">1517     k-&gt;oop_print_on(obj(), tty);</span>

1518   }
1519 }
1520 #endif
1521 #endif // COMPILER2_OR_JVMCI
1522 
1523 vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
1524   Events::log_deopt_message(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));
1525 
1526 #ifndef PRODUCT
1527   if (PrintDeoptimizationDetails) {
1528     ttyLocker ttyl;
1529     tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
1530     fr.print_on(tty);
1531     tty-&gt;print_cr(&quot;     Virtual frames (innermost first):&quot;);
1532     for (int index = 0; index &lt; chunk-&gt;length(); index++) {
1533       compiledVFrame* vf = chunk-&gt;at(index);
1534       tty-&gt;print(&quot;       %2d - &quot;, index);
1535       vf-&gt;print_value();
1536       int bci = chunk-&gt;at(index)-&gt;raw_bci();
1537       const char* code_name;
</pre>
<hr />
<pre>
1670 
1671     ttyLocker ttyl;
1672     xtty-&gt;begin_head(&quot;deoptimized thread=&#39;&quot; UINTX_FORMAT &quot;&#39; reason=&#39;%s&#39; pc=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;,(uintx)thread-&gt;osthread()-&gt;thread_id(), trap_reason_name(reason), p2i(fr.pc()));
1673     cm-&gt;log_identity(xtty);
1674     xtty-&gt;end_head();
1675     for (ScopeDesc* sd = cm-&gt;scope_desc_at(fr.pc()); ; sd = sd-&gt;sender()) {
1676       xtty-&gt;begin_elem(&quot;jvms bci=&#39;%d&#39;&quot;, sd-&gt;bci());
1677       xtty-&gt;method(sd-&gt;method());
1678       xtty-&gt;end_elem();
1679       if (sd-&gt;is_top())  break;
1680     }
1681     xtty-&gt;tail(&quot;deoptimized&quot;);
1682   }
1683 
1684   // Patch the compiled method so that when execution returns to it we will
1685   // deopt the execution state and return to the interpreter.
1686   fr.deoptimize(thread);
1687 }
1688 
1689 void Deoptimization::deoptimize(JavaThread* thread, frame fr, DeoptReason reason) {
<span class="line-modified">1690   // Deoptimize only if the frame comes from compiled code.</span>
1691   // Do not deoptimize the frame which is already patched
1692   // during the execution of the loops below.
1693   if (!fr.is_compiled_frame() || fr.is_deoptimized_frame()) {
1694     return;
1695   }
1696   ResourceMark rm;
1697   DeoptimizationMarker dm;
1698   deoptimize_single_frame(thread, fr, reason);
1699 }
1700 
1701 #if INCLUDE_JVMCI
1702 address Deoptimization::deoptimize_for_missing_exception_handler(CompiledMethod* cm) {
1703   // there is no exception handler for this pc =&gt; deoptimize
1704   cm-&gt;make_not_entrant();
1705 
1706   // Use Deoptimization::deoptimize for all of its side-effects:
1707   // gathering traps statistics, logging...
1708   // it also patches the return pc but we do not care about that
1709   // since we return a continuation to the deopt_blob below.
1710   JavaThread* thread = JavaThread::current();
</pre>
</td>
</tr>
</table>
<center><a href="arguments.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
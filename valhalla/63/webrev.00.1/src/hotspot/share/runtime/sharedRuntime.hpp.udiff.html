<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/sharedRuntime.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/sharedRuntime.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,22 +23,25 @@</span>
   */
  
  #ifndef SHARE_RUNTIME_SHAREDRUNTIME_HPP
  #define SHARE_RUNTIME_SHAREDRUNTIME_HPP
  
<span class="udiff-line-added">+ #include &quot;asm/codeBuffer.hpp&quot;</span>
  #include &quot;interpreter/bytecodeHistogram.hpp&quot;
  #include &quot;interpreter/bytecodeTracer.hpp&quot;
  #include &quot;interpreter/linkResolver.hpp&quot;
  #include &quot;memory/allocation.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
<span class="udiff-line-added">+ #include &quot;runtime/signature.hpp&quot;</span>
  #include &quot;utilities/hashtable.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  
  class AdapterHandlerEntry;
  class AdapterHandlerTable;
  class AdapterFingerPrint;
  class vframeStream;
<span class="udiff-line-added">+ class SigEntry;</span>
  
  // Runtime is the base class for various runtime interfaces
  // (InterpreterRuntime, CompilerRuntime, etc.). It provides
  // shared functionality such as exception forwarding (C++ to
  // Java exceptions), locking/unlocking mechanisms, statistical
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -51,21 +54,21 @@</span>
    static bool resolve_sub_helper_internal(methodHandle callee_method, const frame&amp; caller_frame,
                                            CompiledMethod* caller_nm, bool is_virtual, bool is_optimized,
                                            Handle receiver, CallInfo&amp; call_info, Bytecodes::Code invoke_code, TRAPS);
    static methodHandle resolve_sub_helper(JavaThread *thread,
                                           bool is_virtual,
<span class="udiff-line-modified-removed">-                                          bool is_optimized, TRAPS);</span>
<span class="udiff-line-modified-added">+                                          bool is_optimized,</span>
<span class="udiff-line-added">+                                          bool* caller_is_c1, TRAPS);</span>
  
    // Shared stub locations
  
    static RuntimeStub*        _wrong_method_blob;
    static RuntimeStub*        _wrong_method_abstract_blob;
    static RuntimeStub*        _ic_miss_blob;
    static RuntimeStub*        _resolve_opt_virtual_call_blob;
    static RuntimeStub*        _resolve_virtual_call_blob;
    static RuntimeStub*        _resolve_static_call_blob;
<span class="udiff-line-removed">-   static address             _resolve_static_call_entry;</span>
  
    static DeoptimizationBlob* _deopt_blob;
  
    static SafepointBlob*      _polling_page_vectors_safepoint_handler_blob;
    static SafepointBlob*      _polling_page_safepoint_handler_blob;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -82,11 +85,10 @@</span>
  
   private:
    enum { POLL_AT_RETURN,  POLL_AT_LOOP, POLL_AT_VECTOR_LOOP };
    static SafepointBlob* generate_handler_blob(address call_ptr, int poll_type);
    static RuntimeStub*   generate_resolve_blob(address destination, const char* name);
<span class="udiff-line-removed">- </span>
   public:
    static void generate_stubs(void);
  
    // max bytes for each dtrace string parameter
    enum { max_dtrace_string_size = 256 };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -316,37 +318,51 @@</span>
  
    // Resolves a call site- may patch in the destination of the call into the
    // compiled code.
    static methodHandle resolve_helper(JavaThread *thread,
                                       bool is_virtual,
<span class="udiff-line-modified-removed">-                                      bool is_optimized, TRAPS);</span>
<span class="udiff-line-modified-added">+                                      bool is_optimized,</span>
<span class="udiff-line-added">+                                      bool* caller_is_c1, TRAPS);</span>
  
   private:
    // deopt blob
    static void generate_deopt_blob(void);
  
    static bool handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm, const frame&amp; caller_frame,
                                               methodHandle callee_method, Bytecodes::Code bc, CallInfo&amp; call_info,
<span class="udiff-line-modified-removed">-                                              bool&amp; needs_ic_stub_refill, TRAPS);</span>
<span class="udiff-line-modified-added">+                                              bool&amp; needs_ic_stub_refill, bool&amp; is_optimized, bool caller_is_c1, TRAPS);</span>
  
   public:
    static DeoptimizationBlob* deopt_blob(void)      { return _deopt_blob; }
  
    // Resets a call-site in compiled code so it will get resolved again.
<span class="udiff-line-modified-removed">-   static methodHandle reresolve_call_site(JavaThread *thread, TRAPS);</span>
<span class="udiff-line-modified-added">+   static methodHandle reresolve_call_site(JavaThread *thread, bool&amp; is_static_call, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS);</span>
  
    // In the code prolog, if the klass comparison fails, the inline cache
    // misses and the call site is patched to megamorphic
<span class="udiff-line-modified-removed">-   static methodHandle handle_ic_miss_helper(JavaThread* thread, TRAPS);</span>
<span class="udiff-line-modified-added">+   static methodHandle handle_ic_miss_helper(JavaThread* thread, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS);</span>
  
    // Find the method that called us.
    static methodHandle find_callee_method(JavaThread* thread, TRAPS);
  
    static void monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);
  
    static void monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);
  
<span class="udiff-line-added">+   static address entry_for_handle_wrong_method(methodHandle callee_method, bool is_static_call, bool is_optimized, bool caller_is_c1) {</span>
<span class="udiff-line-added">+     assert(callee_method-&gt;verified_code_entry() != NULL, &quot;Jump to zero!&quot;);</span>
<span class="udiff-line-added">+     assert(callee_method-&gt;verified_value_code_entry() != NULL, &quot;Jump to zero!&quot;);</span>
<span class="udiff-line-added">+     assert(callee_method-&gt;verified_value_ro_code_entry() != NULL, &quot;Jump to zero!&quot;);</span>
<span class="udiff-line-added">+     if (caller_is_c1) {</span>
<span class="udiff-line-added">+       return callee_method-&gt;verified_value_code_entry();</span>
<span class="udiff-line-added">+     } else if (is_static_call || is_optimized) {</span>
<span class="udiff-line-added">+       return callee_method-&gt;verified_code_entry();</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       return callee_method-&gt;verified_value_ro_code_entry();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
   private:
    static Handle find_callee_info(JavaThread* thread,
                                   Bytecodes::Code&amp; bc,
                                   CallInfo&amp; callinfo, TRAPS);
    static Handle find_callee_info_helper(JavaThread* thread,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -354,14 +370,10 @@</span>
                                          Bytecodes::Code&amp; bc,
                                          CallInfo&amp; callinfo, TRAPS);
  
    static Method* extract_attached_method(vframeStream&amp; vfst);
  
<span class="udiff-line-removed">-   static address clean_virtual_call_entry();</span>
<span class="udiff-line-removed">-   static address clean_opt_virtual_call_entry();</span>
<span class="udiff-line-removed">-   static address clean_static_call_entry();</span>
<span class="udiff-line-removed">- </span>
  #if defined(X86) &amp;&amp; defined(COMPILER1)
    // For Object.hashCode, System.identityHashCode try to pull hashCode from object header if available.
    static void inline_check_hashcode_from_object_header(MacroAssembler* masm, const methodHandle&amp; method, Register obj_reg, Register result);
  #endif // X86 &amp;&amp; COMPILER1
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -376,10 +388,18 @@</span>
    // 4-bytes higher. So for sparc because the register window save area is at
    // the bottom of the frame the first 16 words will be skipped and SharedInfo::stack0
    // will be just above it. (
    // return value is the maximum number of VMReg stack slots the convention will use.
    static int java_calling_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed, int is_outgoing);
<span class="udiff-line-added">+   static int java_calling_convention(const GrowableArray&lt;SigEntry&gt;* sig, VMRegPair* regs) {</span>
<span class="udiff-line-added">+     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sig-&gt;length());</span>
<span class="udiff-line-added">+     int total_args_passed = SigEntry::fill_sig_bt(sig, sig_bt);</span>
<span class="udiff-line-added">+     return java_calling_convention(sig_bt, regs, total_args_passed, false);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   static int java_return_convention(const BasicType* sig_bt, VMRegPair* regs, int total_args_passed);</span>
<span class="udiff-line-added">+   static const uint java_return_convention_max_int;</span>
<span class="udiff-line-added">+   static const uint java_return_convention_max_float;</span>
  
    static void check_member_name_argument_is_last_argument(const methodHandle&amp; method,
                                                            const BasicType* sig_bt,
                                                            const VMRegPair* regs) NOT_DEBUG_RETURN;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -423,20 +443,23 @@</span>
    // that the interpreter before it does any call dispatch will record the current
    // stack pointer in the interpreter frame. On return it will restore the stack
    // pointer as needed. This means the i2c adapter code doesn&#39;t need any special
    // handshaking path with compiled code to keep the stack walking correct.
  
<span class="udiff-line-modified-removed">-   static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *_masm,</span>
<span class="udiff-line-modified-removed">-                                                       int total_args_passed,</span>
<span class="udiff-line-modified-removed">-                                                       int max_arg,</span>
<span class="udiff-line-modified-removed">-                                                       const BasicType *sig_bt,</span>
<span class="udiff-line-modified-removed">-                                                       const VMRegPair *regs,</span>
<span class="udiff-line-modified-removed">-                                                       AdapterFingerPrint* fingerprint);</span>
<span class="udiff-line-modified-added">+   static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *masm,</span>
<span class="udiff-line-modified-added">+                                                       int comp_args_on_stack,</span>
<span class="udiff-line-modified-added">+                                                       const GrowableArray&lt;SigEntry&gt;* sig,</span>
<span class="udiff-line-modified-added">+                                                       const VMRegPair* regs,</span>
<span class="udiff-line-modified-added">+                                                       const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="udiff-line-modified-added">+                                                       const VMRegPair* regs_cc,</span>
<span class="udiff-line-added">+                                                       const GrowableArray&lt;SigEntry&gt;* sig_cc_ro,</span>
<span class="udiff-line-added">+                                                       const VMRegPair* regs_cc_ro,</span>
<span class="udiff-line-added">+                                                       AdapterFingerPrint* fingerprint,</span>
<span class="udiff-line-added">+                                                       AdapterBlob*&amp; new_adapter);</span>
  
    static void gen_i2c_adapter(MacroAssembler *_masm,
<span class="udiff-line-modified-removed">-                               int total_args_passed,</span>
<span class="udiff-line-removed">-                               int comp_args_on_stack,</span>
<span class="udiff-line-modified-added">+                               int comp_args_on_stack,</span>
                                const GrowableArray&lt;SigEntry&gt;* sig,
                                const VMRegPair *regs);
  
    // OSR support
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -510,23 +533,30 @@</span>
    // Resolving of calls
    static address resolve_static_call_C     (JavaThread *thread);
    static address resolve_virtual_call_C    (JavaThread *thread);
    static address resolve_opt_virtual_call_C(JavaThread *thread);
  
<span class="udiff-line-added">+   static void load_value_type_fields_in_regs(JavaThread *thread, oopDesc* res);</span>
<span class="udiff-line-added">+   static void store_value_type_fields_to_buf(JavaThread *thread, intptr_t res);</span>
<span class="udiff-line-added">+ </span>
    // arraycopy, the non-leaf version.  (See StubRoutines for all the leaf calls.)
    static void slow_arraycopy_C(oopDesc* src,  jint src_pos,
                                 oopDesc* dest, jint dest_pos,
                                 jint length, JavaThread* thread);
  
    // handle ic miss with caller being compiled code
    // wrong method handling (inline cache misses, zombie methods)
    static address handle_wrong_method(JavaThread* thread);
    static address handle_wrong_method_abstract(JavaThread* thread);
    static address handle_wrong_method_ic_miss(JavaThread* thread);
<span class="udiff-line-added">+   static void allocate_value_types(JavaThread* thread, Method* callee, bool allocate_receiver);</span>
<span class="udiff-line-added">+   static oop allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS);</span>
<span class="udiff-line-added">+   static void apply_post_barriers(JavaThread* thread, objArrayOopDesc* array);</span>
  
    static address handle_unsafe_access(JavaThread* thread, address next_pc);
  
<span class="udiff-line-added">+   static BufferedValueTypeBlob* generate_buffered_value_type_adapter(const ValueKlass* vk);</span>
  #ifndef PRODUCT
  
    // Collect and print inline cache miss statistics
   private:
    enum { maxICmiss_count = 100 };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -637,26 +667,37 @@</span>
  
   private:
    AdapterFingerPrint* _fingerprint;
    address _i2c_entry;
    address _c2i_entry;
<span class="udiff-line-added">+   address _c2i_value_entry;</span>
<span class="udiff-line-added">+   address _c2i_value_ro_entry;</span>
    address _c2i_unverified_entry;
<span class="udiff-line-added">+   address _c2i_unverified_value_entry;</span>
    address _c2i_no_clinit_check_entry;
  
<span class="udiff-line-added">+   // Support for scalarized value type calling convention</span>
<span class="udiff-line-added">+   const GrowableArray&lt;SigEntry&gt;* _sig_cc;</span>
<span class="udiff-line-added">+ </span>
  #ifdef ASSERT
    // Captures code and signature used to generate this adapter when
    // verifying adapter equivalence.
    unsigned char* _saved_code;
    int            _saved_code_length;
  #endif
  
<span class="udiff-line-modified-removed">-   void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry) {</span>
<span class="udiff-line-modified-added">+   void init(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry, address c2i_value_entry,</span>
<span class="udiff-line-added">+             address c2i_value_ro_entry, address c2i_unverified_entry, address c2i_unverified_value_entry, address c2i_no_clinit_check_entry) {</span>
      _fingerprint = fingerprint;
      _i2c_entry = i2c_entry;
      _c2i_entry = c2i_entry;
<span class="udiff-line-added">+     _c2i_value_entry = c2i_value_entry;</span>
<span class="udiff-line-added">+     _c2i_value_ro_entry = c2i_value_ro_entry;</span>
      _c2i_unverified_entry = c2i_unverified_entry;
<span class="udiff-line-added">+     _c2i_unverified_value_entry = c2i_unverified_value_entry;</span>
      _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;
<span class="udiff-line-added">+     _sig_cc = NULL;</span>
  #ifdef ASSERT
      _saved_code = NULL;
      _saved_code_length = 0;
  #endif
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -667,16 +708,23 @@</span>
    AdapterHandlerEntry();
  
   public:
    address get_i2c_entry()                  const { return _i2c_entry; }
    address get_c2i_entry()                  const { return _c2i_entry; }
<span class="udiff-line-added">+   address get_c2i_value_entry()            const { return _c2i_value_entry; }</span>
<span class="udiff-line-added">+   address get_c2i_value_ro_entry()         const { return _c2i_value_ro_entry; }</span>
    address get_c2i_unverified_entry()       const { return _c2i_unverified_entry; }
<span class="udiff-line-added">+   address get_c2i_unverified_value_entry() const { return _c2i_unverified_value_entry; }</span>
    address get_c2i_no_clinit_check_entry()  const { return _c2i_no_clinit_check_entry; }
  
    address base_address();
    void relocate(address new_base);
  
<span class="udiff-line-added">+   // Support for scalarized value type calling convention</span>
<span class="udiff-line-added">+   void set_sig_cc(const GrowableArray&lt;SigEntry&gt;* sig)  { _sig_cc = sig; }</span>
<span class="udiff-line-added">+   const GrowableArray&lt;SigEntry&gt;* get_sig_cc()    const { return _sig_cc; }</span>
<span class="udiff-line-added">+ </span>
    AdapterFingerPrint* fingerprint() const { return _fingerprint; }
  
    AdapterHandlerEntry* next() {
      return (AdapterHandlerEntry*)BasicHashtableEntry&lt;mtCode&gt;::next();
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -693,15 +741,19 @@</span>
  
  // This class is used only with DumpSharedSpaces==true. It holds extra information
  // that&#39;s used only during CDS dump time.
  // For details, see comments around Method::link_method()
  class CDSAdapterHandlerEntry: public AdapterHandlerEntry {
<span class="udiff-line-modified-removed">-   address               _c2i_entry_trampoline;   // allocated from shared spaces &quot;MC&quot; region</span>
<span class="udiff-line-modified-removed">-   AdapterHandlerEntry** _adapter_trampoline;     // allocated from shared spaces &quot;MD&quot; region</span>
<span class="udiff-line-modified-added">+   address               _c2i_entry_trampoline;           // allocated from shared spaces &quot;MC&quot; region</span>
<span class="udiff-line-modified-added">+   address               _c2i_value_ro_entry_trampoline;  // allocated from shared spaces &quot;MC&quot; region</span>
<span class="udiff-line-added">+   address               _c2i_value_entry_trampoline;     // allocated from shared spaces &quot;MC&quot; region</span>
<span class="udiff-line-added">+   AdapterHandlerEntry** _adapter_trampoline;             // allocated from shared spaces &quot;MD&quot; region</span>
  
  public:
    address get_c2i_entry_trampoline()             const { return _c2i_entry_trampoline; }
<span class="udiff-line-added">+   address get_c2i_value_ro_entry_trampoline()    const { return _c2i_value_ro_entry_trampoline; }</span>
<span class="udiff-line-added">+   address get_c2i_value_entry_trampoline()       const { return _c2i_value_entry_trampoline; }</span>
    AdapterHandlerEntry** get_adapter_trampoline() const { return _adapter_trampoline; }
    void init() NOT_CDS_RETURN;
  };
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -715,14 +767,12 @@</span>
    static AdapterHandlerEntry* get_adapter0(const methodHandle&amp; method);
  
   public:
  
    static AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint,
<span class="udiff-line-modified-removed">-                                         address i2c_entry,</span>
<span class="udiff-line-modified-removed">-                                         address c2i_entry,</span>
<span class="udiff-line-removed">-                                         address c2i_unverified_entry,</span>
<span class="udiff-line-removed">-                                         address c2i_no_clinit_check_entry = NULL);</span>
<span class="udiff-line-modified-added">+                                         address i2c_entry, address c2i_entry, address c2i_value_entry, address c2i_value_ro_entry,</span>
<span class="udiff-line-modified-added">+                                         address c2i_unverified_entry, address c2i_unverified_value_entry, address c2i_no_clinit_check_entry = NULL);</span>
    static void create_native_wrapper(const methodHandle&amp; method);
    static AdapterHandlerEntry* get_adapter(const methodHandle&amp; method);
  
    static void print_handler(const CodeBlob* b) { print_handler_on(tty, b); }
    static void print_handler_on(outputStream* st, const CodeBlob* b);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -731,6 +781,68 @@</span>
    static void print_statistics();
  #endif // PRODUCT
  
  };
  
<span class="udiff-line-added">+ // Utility class for computing the calling convention of the 3 types</span>
<span class="udiff-line-added">+ // of compiled method entries:</span>
<span class="udiff-line-added">+ //     Method::_from_compiled_entry               - sig_cc</span>
<span class="udiff-line-added">+ //     Method::_from_compiled_value_ro_entry      - sig_cc_ro</span>
<span class="udiff-line-added">+ //     Method::_from_compiled_value_entry         - sig</span>
<span class="udiff-line-added">+ class CompiledEntrySignature : public StackObj {</span>
<span class="udiff-line-added">+   Method* _method;</span>
<span class="udiff-line-added">+   int  _num_value_args;</span>
<span class="udiff-line-added">+   bool _has_value_recv;</span>
<span class="udiff-line-added">+   GrowableArray&lt;SigEntry&gt; *_sig;</span>
<span class="udiff-line-added">+   GrowableArray&lt;SigEntry&gt; *_sig_cc;</span>
<span class="udiff-line-added">+   GrowableArray&lt;SigEntry&gt; *_sig_cc_ro;</span>
<span class="udiff-line-added">+   VMRegPair* _regs;</span>
<span class="udiff-line-added">+   VMRegPair* _regs_cc;</span>
<span class="udiff-line-added">+   VMRegPair* _regs_cc_ro;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int _args_on_stack;</span>
<span class="udiff-line-added">+   int _args_on_stack_cc;</span>
<span class="udiff-line-added">+   int _args_on_stack_cc_ro;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool _c1_needs_stack_repair;</span>
<span class="udiff-line-added">+   bool _c2_needs_stack_repair;</span>
<span class="udiff-line-added">+   bool _has_scalarized_args;</span>
<span class="udiff-line-added">+   bool _has_reserved_entries;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   Method* method()                     const { return _method; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Used by Method::_from_compiled_value_entry</span>
<span class="udiff-line-added">+   GrowableArray&lt;SigEntry&gt;&amp; sig()       const { return *_sig; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Used by Method::_from_compiled_entry</span>
<span class="udiff-line-added">+   GrowableArray&lt;SigEntry&gt;&amp; sig_cc()    const { return *_sig_cc; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Used by Method::_from_compiled_value_ro_entry</span>
<span class="udiff-line-added">+   GrowableArray&lt;SigEntry&gt;&amp; sig_cc_ro() const { return *_sig_cc_ro; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   VMRegPair* regs()                    const { return _regs; }</span>
<span class="udiff-line-added">+   VMRegPair* regs_cc()                 const { return _regs_cc; }</span>
<span class="udiff-line-added">+   VMRegPair* regs_cc_ro()              const { return _regs_cc_ro; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int args_on_stack()                  const { return _args_on_stack; }</span>
<span class="udiff-line-added">+   int args_on_stack_cc()               const { return _args_on_stack_cc; }</span>
<span class="udiff-line-added">+   int args_on_stack_cc_ro()            const { return _args_on_stack_cc_ro; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int  num_value_args()                const { return _num_value_args; }</span>
<span class="udiff-line-added">+   bool has_value_arg()                 const { return _num_value_args &gt; 0;  }</span>
<span class="udiff-line-added">+   bool has_value_recv()                const { return _has_value_recv; }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool has_scalarized_args()           const { return _has_scalarized_args; }</span>
<span class="udiff-line-added">+   bool c1_needs_stack_repair()         const { return _c1_needs_stack_repair; }</span>
<span class="udiff-line-added">+   bool c2_needs_stack_repair()         const { return _c2_needs_stack_repair; }</span>
<span class="udiff-line-added">+   CodeOffsets::Entries c1_value_ro_entry_type() const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   CompiledEntrySignature(Method* method);</span>
<span class="udiff-line-added">+   void compute_calling_conventions();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ private:</span>
<span class="udiff-line-added">+   int compute_scalarized_cc(GrowableArray&lt;SigEntry&gt;*&amp; sig_cc, VMRegPair*&amp; regs_cc, bool scalar_receiver);</span>
<span class="udiff-line-added">+   int insert_reserved_entry(int ret_off);</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  #endif // SHARE_RUNTIME_SHAREDRUNTIME_HPP
</pre>
<center><a href="sharedRuntime.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="thread.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
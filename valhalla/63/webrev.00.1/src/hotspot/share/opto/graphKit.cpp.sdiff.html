<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/graphKit.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="library_call.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/graphKit.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciUtilities.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;

  28 #include &quot;gc/shared/barrierSet.hpp&quot;
  29 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  30 #include &quot;interpreter/interpreter.hpp&quot;
  31 #include &quot;memory/resourceArea.hpp&quot;
  32 #include &quot;opto/addnode.hpp&quot;
  33 #include &quot;opto/castnode.hpp&quot;
  34 #include &quot;opto/convertnode.hpp&quot;
  35 #include &quot;opto/graphKit.hpp&quot;
  36 #include &quot;opto/idealKit.hpp&quot;
  37 #include &quot;opto/intrinsicnode.hpp&quot;
  38 #include &quot;opto/locknode.hpp&quot;
  39 #include &quot;opto/machnode.hpp&quot;

  40 #include &quot;opto/opaquenode.hpp&quot;
  41 #include &quot;opto/parse.hpp&quot;
  42 #include &quot;opto/rootnode.hpp&quot;
  43 #include &quot;opto/runtime.hpp&quot;
  44 #include &quot;opto/subtypenode.hpp&quot;

  45 #include &quot;runtime/deoptimization.hpp&quot;
  46 #include &quot;runtime/sharedRuntime.hpp&quot;
  47 #include &quot;utilities/bitMap.inline.hpp&quot;
  48 #include &quot;utilities/powerOfTwo.hpp&quot;
  49 
  50 //----------------------------GraphKit-----------------------------------------
  51 // Main utility constructor.
<span class="line-modified">  52 GraphKit::GraphKit(JVMState* jvms)</span>
  53   : Phase(Phase::Parser),
  54     _env(C-&gt;env()),
<span class="line-modified">  55     _gvn(*C-&gt;initial_gvn()),</span>
  56     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
  57 {

  58   _exceptions = jvms-&gt;map()-&gt;next_exception();
  59   if (_exceptions != NULL)  jvms-&gt;map()-&gt;set_next_exception(NULL);
  60   set_jvms(jvms);







  61 }
  62 
  63 // Private constructor for parser.
  64 GraphKit::GraphKit()
  65   : Phase(Phase::Parser),
  66     _env(C-&gt;env()),
  67     _gvn(*C-&gt;initial_gvn()),
  68     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
  69 {
  70   _exceptions = NULL;
  71   set_map(NULL);
  72   debug_only(_sp = -99);
  73   debug_only(set_bci(-99));
  74 }
  75 
  76 
  77 
  78 //---------------------------clean_stack---------------------------------------
  79 // Clear away rubbish from the stack area of the JVM state.
  80 // This destroys any arguments that may be waiting on the stack.
</pre>
<hr />
<pre>
 809           tty-&gt;print_cr(&quot;Zombie local %d: &quot;, local);
 810           jvms-&gt;dump();
 811         }
 812         return false;
 813       }
 814     }
 815   }
 816   return true;
 817 }
 818 
 819 #endif //ASSERT
 820 
 821 // Helper function for enforcing certain bytecodes to reexecute if
 822 // deoptimization happens
 823 static bool should_reexecute_implied_by_bytecode(JVMState *jvms, bool is_anewarray) {
 824   ciMethod* cur_method = jvms-&gt;method();
 825   int       cur_bci   = jvms-&gt;bci();
 826   if (cur_method != NULL &amp;&amp; cur_bci != InvocationEntryBci) {
 827     Bytecodes::Code code = cur_method-&gt;java_code_at_bci(cur_bci);
 828     return Interpreter::bytecode_should_reexecute(code) ||
<span class="line-modified"> 829            (is_anewarray &amp;&amp; code == Bytecodes::_multianewarray);</span>
 830     // Reexecute _multianewarray bytecode which was replaced with
 831     // sequence of [a]newarray. See Parse::do_multianewarray().
 832     //
 833     // Note: interpreter should not have it set since this optimization
 834     // is limited by dimensions and guarded by flag so in some cases
 835     // multianewarray() runtime calls will be generated and
 836     // the bytecode should not be reexecutes (stack will not be reset).
<span class="line-modified"> 837   } else</span>
 838     return false;

 839 }
 840 
 841 // Helper function for adding JVMState and debug information to node
 842 void GraphKit::add_safepoint_edges(SafePointNode* call, bool must_throw) {
 843   // Add the safepoint edges to the call (or other safepoint).
 844 
 845   // Make sure dead locals are set to top.  This
 846   // should help register allocation time and cut down on the size
 847   // of the deoptimization information.
 848   assert(dead_locals_are_killed(), &quot;garbage in debug info before safepoint&quot;);
 849 
 850   // Walk the inline list to fill in the correct set of JVMState&#39;s
 851   // Also fill in the associated edges for each JVMState.
 852 
 853   // If the bytecode needs to be reexecuted we need to put
 854   // the arguments back on the stack.
 855   const bool should_reexecute = jvms()-&gt;should_reexecute();
 856   JVMState* youngest_jvms = should_reexecute ? sync_jvms_for_reexecute() : sync_jvms();
 857 
 858   // NOTE: set_bci (called from sync_jvms) might reset the reexecute bit to
</pre>
<hr />
<pre>
1062       ciSignature* declared_signature = NULL;
1063       ciMethod* ignored_callee = method()-&gt;get_method_at_bci(bci(), ignored_will_link, &amp;declared_signature);
1064       assert(declared_signature != NULL, &quot;cannot be null&quot;);
1065       inputs   = declared_signature-&gt;arg_size_for_bc(code);
1066       int size = declared_signature-&gt;return_type()-&gt;size();
1067       depth = size - inputs;
1068     }
1069     break;
1070 
1071   case Bytecodes::_multianewarray:
1072     {
1073       ciBytecodeStream iter(method());
1074       iter.reset_to_bci(bci());
1075       iter.next();
1076       inputs = iter.get_dimensions();
1077       assert(rsize == 1, &quot;&quot;);
1078       depth = rsize - inputs;
1079     }
1080     break;
1081 









1082   case Bytecodes::_ireturn:
1083   case Bytecodes::_lreturn:
1084   case Bytecodes::_freturn:
1085   case Bytecodes::_dreturn:
1086   case Bytecodes::_areturn:
1087     assert(rsize == -depth, &quot;&quot;);
1088     inputs = rsize;
1089     break;
1090 
1091   case Bytecodes::_jsr:
1092   case Bytecodes::_jsr_w:
1093     inputs = 0;
1094     depth  = 1;                  // S.B. depth=1, not zero
1095     break;
1096 
1097   default:
1098     // bytecode produces a typed result
1099     inputs = rsize - depth;
1100     assert(inputs &gt;= 0, &quot;&quot;);
1101     break;
</pre>
<hr />
<pre>
1144   Node* conv = _gvn.transform( new ConvI2LNode(offset));
1145   Node* mask = _gvn.transform(ConLNode::make((julong) max_juint));
1146   return _gvn.transform( new AndLNode(conv, mask) );
1147 }
1148 
1149 Node* GraphKit::ConvL2I(Node* offset) {
1150   // short-circuit a common case
1151   jlong offset_con = find_long_con(offset, (jlong)Type::OffsetBot);
1152   if (offset_con != (jlong)Type::OffsetBot) {
1153     return intcon((int) offset_con);
1154   }
1155   return _gvn.transform( new ConvL2INode(offset));
1156 }
1157 
1158 //-------------------------load_object_klass-----------------------------------
1159 Node* GraphKit::load_object_klass(Node* obj) {
1160   // Special-case a fresh allocation to avoid building nodes:
1161   Node* akls = AllocateNode::Ideal_klass(obj, &amp;_gvn);
1162   if (akls != NULL)  return akls;
1163   Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());
<span class="line-modified">1164   return _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS));</span>
1165 }
1166 
1167 //-------------------------load_array_length-----------------------------------
1168 Node* GraphKit::load_array_length(Node* array) {
1169   // Special-case a fresh allocation to avoid building nodes:
1170   AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(array, &amp;_gvn);
1171   Node *alen;
1172   if (alloc == NULL) {
1173     Node *r_adr = basic_plus_adr(array, arrayOopDesc::length_offset_in_bytes());
1174     alen = _gvn.transform( new LoadRangeNode(0, immutable_memory(), r_adr, TypeInt::POS));
1175   } else {
1176     alen = alloc-&gt;Ideal_length();
1177     Node* ccast = alloc-&gt;make_ideal_length(_gvn.type(array)-&gt;is_oopptr(), &amp;_gvn);
1178     if (ccast != alen) {
1179       alen = _gvn.transform(ccast);
1180     }
1181   }
1182   return alen;
1183 }
1184 
</pre>
<hr />
<pre>
1187 // the incoming address with NULL casted away.  You are allowed to use the
1188 // not-null value only if you are control dependent on the test.
1189 #ifndef PRODUCT
1190 extern int explicit_null_checks_inserted,
1191            explicit_null_checks_elided;
1192 #endif
1193 Node* GraphKit::null_check_common(Node* value, BasicType type,
1194                                   // optional arguments for variations:
1195                                   bool assert_null,
1196                                   Node* *null_control,
1197                                   bool speculative) {
1198   assert(!assert_null || null_control == NULL, &quot;not both at once&quot;);
1199   if (stopped())  return top();
1200   NOT_PRODUCT(explicit_null_checks_inserted++);
1201 
1202   // Construct NULL check
1203   Node *chk = NULL;
1204   switch(type) {
1205     case T_LONG   : chk = new CmpLNode(value, _gvn.zerocon(T_LONG)); break;
1206     case T_INT    : chk = new CmpINode(value, _gvn.intcon(0)); break;

1207     case T_ARRAY  : // fall through
1208       type = T_OBJECT;  // simplify further tests
1209     case T_OBJECT : {
1210       const Type *t = _gvn.type( value );
1211 
1212       const TypeOopPtr* tp = t-&gt;isa_oopptr();
1213       if (tp != NULL &amp;&amp; tp-&gt;klass() != NULL &amp;&amp; !tp-&gt;klass()-&gt;is_loaded()
1214           // Only for do_null_check, not any of its siblings:
1215           &amp;&amp; !assert_null &amp;&amp; null_control == NULL) {
1216         // Usually, any field access or invocation on an unloaded oop type
1217         // will simply fail to link, since the statically linked class is
1218         // likely also to be unloaded.  However, in -Xcomp mode, sometimes
1219         // the static class is loaded but the sharper oop type is not.
1220         // Rather than checking for this obscure case in lots of places,
1221         // we simply observe that a null check on an unloaded class
1222         // will always be followed by a nonsense operation, so we
1223         // can just issue the uncommon trap here.
1224         // Our access to the unloaded class will only be correct
1225         // after it has been loaded and initialized, which requires
1226         // a trip through the interpreter.
</pre>
<hr />
<pre>
1358   }
1359 
1360   if (assert_null) {
1361     // Cast obj to null on this path.
1362     replace_in_map(value, zerocon(type));
1363     return zerocon(type);
1364   }
1365 
1366   // Cast obj to not-null on this path, if there is no null_control.
1367   // (If there is a null_control, a non-null value may come back to haunt us.)
1368   if (type == T_OBJECT) {
1369     Node* cast = cast_not_null(value, false);
1370     if (null_control == NULL || (*null_control) == top())
1371       replace_in_map(value, cast);
1372     value = cast;
1373   }
1374 
1375   return value;
1376 }
1377 















1378 
1379 //------------------------------cast_not_null----------------------------------
1380 // Cast obj to not-null on this path
1381 Node* GraphKit::cast_not_null(Node* obj, bool do_replace_in_map) {



1382   const Type *t = _gvn.type(obj);
1383   const Type *t_not_null = t-&gt;join_speculative(TypePtr::NOTNULL);
1384   // Object is already not-null?
1385   if( t == t_not_null ) return obj;
1386 
1387   Node *cast = new CastPPNode(obj,t_not_null);
1388   cast-&gt;init_req(0, control());
1389   cast = _gvn.transform( cast );
1390 
1391   // Scan for instances of &#39;obj&#39; in the current JVM mapping.
1392   // These instances are known to be not-null after the test.
1393   if (do_replace_in_map)
1394     replace_in_map(obj, cast);
1395 
1396   return cast;                  // Return casted value
1397 }
1398 
1399 // Sometimes in intrinsics, we implicitly know an object is not null
1400 // (there&#39;s no actual null check) so we can cast it to not null. In
1401 // the course of optimizations, the input to the cast can become null.
</pre>
<hr />
<pre>
1494                           MemNode::MemOrd mo,
1495                           LoadNode::ControlDependency control_dependency,
1496                           bool require_atomic_access,
1497                           bool unaligned,
1498                           bool mismatched,
1499                           bool unsafe,
1500                           uint8_t barrier_data) {
1501   assert(adr_idx != Compile::AliasIdxTop, &quot;use other make_load factory&quot; );
1502   const TypePtr* adr_type = NULL; // debug-mode-only argument
1503   debug_only(adr_type = C-&gt;get_adr_type(adr_idx));
1504   Node* mem = memory(adr_idx);
1505   Node* ld;
1506   if (require_atomic_access &amp;&amp; bt == T_LONG) {
1507     ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);
1508   } else if (require_atomic_access &amp;&amp; bt == T_DOUBLE) {
1509     ld = LoadDNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);
1510   } else {
1511     ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);
1512   }
1513   ld = _gvn.transform(ld);
<span class="line-modified">1514   if (((bt == T_OBJECT) &amp;&amp; C-&gt;do_escape_analysis()) || C-&gt;eliminate_boxing()) {</span>

1515     // Improve graph before escape analysis and boxing elimination.
1516     record_for_igvn(ld);
1517   }
1518   return ld;
1519 }
1520 
1521 Node* GraphKit::store_to_memory(Node* ctl, Node* adr, Node *val, BasicType bt,
1522                                 int adr_idx,
1523                                 MemNode::MemOrd mo,
1524                                 bool require_atomic_access,
1525                                 bool unaligned,
1526                                 bool mismatched,
1527                                 bool unsafe) {
1528   assert(adr_idx != Compile::AliasIdxTop, &quot;use other store_to_memory factory&quot; );
1529   const TypePtr* adr_type = NULL;
1530   debug_only(adr_type = C-&gt;get_adr_type(adr_idx));
1531   Node *mem = memory(adr_idx);
1532   Node* st;
1533   if (require_atomic_access &amp;&amp; bt == T_LONG) {
1534     st = StoreLNode::make_atomic(ctl, mem, adr, adr_type, val, mo);
</pre>
<hr />
<pre>
1545   }
1546   if (unsafe) {
1547     st-&gt;as_Store()-&gt;set_unsafe_access();
1548   }
1549   st = _gvn.transform(st);
1550   set_memory(st, adr_idx);
1551   // Back-to-back stores can only remove intermediate store with DU info
1552   // so push on worklist for optimizer.
1553   if (mem-&gt;req() &gt; MemNode::Address &amp;&amp; adr == mem-&gt;in(MemNode::Address))
1554     record_for_igvn(st);
1555 
1556   return st;
1557 }
1558 
1559 Node* GraphKit::access_store_at(Node* obj,
1560                                 Node* adr,
1561                                 const TypePtr* adr_type,
1562                                 Node* val,
1563                                 const Type* val_type,
1564                                 BasicType bt,
<span class="line-modified">1565                                 DecoratorSet decorators) {</span>

1566   // Transformation of a value which could be NULL pointer (CastPP #NULL)
1567   // could be delayed during Parse (for example, in adjust_map_after_if()).
1568   // Execute transformation here to avoid barrier generation in such case.
1569   if (_gvn.type(val) == TypePtr::NULL_PTR) {
1570     val = _gvn.makecon(TypePtr::NULL_PTR);
1571   }
1572 
1573   if (stopped()) {
1574     return top(); // Dead path ?
1575   }
1576 
1577   assert(val != NULL, &quot;not dead path&quot;);







1578 
1579   C2AccessValuePtr addr(adr, adr_type);
1580   C2AccessValue value(val, val_type);
1581   C2ParseAccess access(this, decorators | C2_WRITE_ACCESS, bt, obj, addr);
1582   if (access.is_raw()) {
1583     return _barrier_set-&gt;BarrierSetC2::store_at(access, value);
1584   } else {
1585     return _barrier_set-&gt;store_at(access, value);
1586   }
1587 }
1588 
1589 Node* GraphKit::access_load_at(Node* obj,   // containing obj
1590                                Node* adr,   // actual adress to store val at
1591                                const TypePtr* adr_type,
1592                                const Type* val_type,
1593                                BasicType bt,
<span class="line-modified">1594                                DecoratorSet decorators) {</span>

1595   if (stopped()) {
1596     return top(); // Dead path ?
1597   }
1598 
1599   C2AccessValuePtr addr(adr, adr_type);
<span class="line-modified">1600   C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, obj, addr);</span>
1601   if (access.is_raw()) {
1602     return _barrier_set-&gt;BarrierSetC2::load_at(access, val_type);
1603   } else {
1604     return _barrier_set-&gt;load_at(access, val_type);
1605   }
1606 }
1607 
1608 Node* GraphKit::access_load(Node* adr,   // actual adress to load val at
1609                             const Type* val_type,
1610                             BasicType bt,
1611                             DecoratorSet decorators) {
1612   if (stopped()) {
1613     return top(); // Dead path ?
1614   }
1615 
1616   C2AccessValuePtr addr(adr, NULL);
1617   C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, NULL, addr);
1618   if (access.is_raw()) {
1619     return _barrier_set-&gt;BarrierSetC2::load_at(access, val_type);
1620   } else {
</pre>
<hr />
<pre>
1678   }
1679 }
1680 
1681 Node* GraphKit::access_atomic_add_at(Node* obj,
1682                                      Node* adr,
1683                                      const TypePtr* adr_type,
1684                                      int alias_idx,
1685                                      Node* new_val,
1686                                      const Type* value_type,
1687                                      BasicType bt,
1688                                      DecoratorSet decorators) {
1689   C2AccessValuePtr addr(adr, adr_type);
1690   C2AtomicParseAccess access(this, decorators | C2_READ_ACCESS | C2_WRITE_ACCESS, bt, obj, addr, alias_idx);
1691   if (access.is_raw()) {
1692     return _barrier_set-&gt;BarrierSetC2::atomic_add_at(access, new_val, value_type);
1693   } else {
1694     return _barrier_set-&gt;atomic_add_at(access, new_val, value_type);
1695   }
1696 }
1697 
<span class="line-modified">1698 void GraphKit::access_clone(Node* src, Node* dst, Node* size, bool is_array) {</span>
<span class="line-modified">1699   return _barrier_set-&gt;clone(this, src, dst, size, is_array);</span>
1700 }
1701 
1702 //-------------------------array_element_address-------------------------
1703 Node* GraphKit::array_element_address(Node* ary, Node* idx, BasicType elembt,
1704                                       const TypeInt* sizetype, Node* ctrl) {
1705   uint shift  = exact_log2(type2aelembytes(elembt));





1706   uint header = arrayOopDesc::base_offset_in_bytes(elembt);
1707 
1708   // short-circuit a common case (saves lots of confusing waste motion)
1709   jint idx_con = find_int_con(idx, -1);
1710   if (idx_con &gt;= 0) {
1711     intptr_t offset = header + ((intptr_t)idx_con &lt;&lt; shift);
1712     return basic_plus_adr(ary, offset);
1713   }
1714 
1715   // must be correct type for alignment purposes
1716   Node* base  = basic_plus_adr(ary, header);
1717   idx = Compile::conv_I2X_index(&amp;_gvn, idx, sizetype, ctrl);
1718   Node* scale = _gvn.transform( new LShiftXNode(idx, intcon(shift)) );
1719   return basic_plus_adr(ary, base, scale);
1720 }
1721 
1722 //-------------------------load_array_element-------------------------
1723 Node* GraphKit::load_array_element(Node* ctl, Node* ary, Node* idx, const TypeAryPtr* arytype) {
1724   const Type* elemtype = arytype-&gt;elem();
1725   BasicType elembt = elemtype-&gt;array_element_basic_type();

1726   Node* adr = array_element_address(ary, idx, elembt, arytype-&gt;size());
1727   if (elembt == T_NARROWOOP) {
1728     elembt = T_OBJECT; // To satisfy switch in LoadNode::make()
1729   }
1730   Node* ld = make_load(ctl, adr, elemtype, elembt, arytype, MemNode::unordered);
1731   return ld;
1732 }
1733 
1734 //-------------------------set_arguments_for_java_call-------------------------
1735 // Arguments (pre-popped from the stack) are taken from the JVMS.
<span class="line-modified">1736 void GraphKit::set_arguments_for_java_call(CallJavaNode* call) {</span>
<span class="line-modified">1737   // Add the call arguments:</span>
<span class="line-modified">1738   uint nargs = call-&gt;method()-&gt;arg_size();</span>
<span class="line-modified">1739   for (uint i = 0; i &lt; nargs; i++) {</span>
<span class="line-modified">1740     Node* arg = argument(i);</span>
<span class="line-modified">1741     call-&gt;init_req(i + TypeFunc::Parms, arg);</span>



































1742   }
1743 }
1744 
1745 //---------------------------set_edges_for_java_call---------------------------
1746 // Connect a newly created call into the current JVMS.
1747 // A return value node (if any) is returned from set_edges_for_java_call.
1748 void GraphKit::set_edges_for_java_call(CallJavaNode* call, bool must_throw, bool separate_io_proj) {
1749 
1750   // Add the predefined inputs:
1751   call-&gt;init_req( TypeFunc::Control, control() );
1752   call-&gt;init_req( TypeFunc::I_O    , i_o() );
1753   call-&gt;init_req( TypeFunc::Memory , reset_memory() );
1754   call-&gt;init_req( TypeFunc::FramePtr, frameptr() );
1755   call-&gt;init_req( TypeFunc::ReturnAdr, top() );
1756 
1757   add_safepoint_edges(call, must_throw);
1758 
1759   Node* xcall = _gvn.transform(call);
1760 
1761   if (xcall == top()) {
1762     set_control(top());
1763     return;
1764   }
1765   assert(xcall == call, &quot;call identity is stable&quot;);
1766 
1767   // Re-use the current map to produce the result.
1768 
1769   set_control(_gvn.transform(new ProjNode(call, TypeFunc::Control)));
1770   set_i_o(    _gvn.transform(new ProjNode(call, TypeFunc::I_O    , separate_io_proj)));
1771   set_all_memory_call(xcall, separate_io_proj);
1772 
1773   //return xcall;   // no need, caller already has it
1774 }
1775 
1776 Node* GraphKit::set_results_for_java_call(CallJavaNode* call, bool separate_io_proj, bool deoptimize) {
1777   if (stopped())  return top();  // maybe the call folded up?
1778 
<span class="line-removed">1779   // Capture the return value, if any.</span>
<span class="line-removed">1780   Node* ret;</span>
<span class="line-removed">1781   if (call-&gt;method() == NULL ||</span>
<span class="line-removed">1782       call-&gt;method()-&gt;return_type()-&gt;basic_type() == T_VOID)</span>
<span class="line-removed">1783         ret = top();</span>
<span class="line-removed">1784   else  ret = _gvn.transform(new ProjNode(call, TypeFunc::Parms));</span>
<span class="line-removed">1785 </span>
1786   // Note:  Since any out-of-line call can produce an exception,
1787   // we always insert an I_O projection from the call into the result.
1788 
1789   make_slow_call_ex(call, env()-&gt;Throwable_klass(), separate_io_proj, deoptimize);
1790 
1791   if (separate_io_proj) {
1792     // The caller requested separate projections be used by the fall
1793     // through and exceptional paths, so replace the projections for
1794     // the fall through path.
1795     set_i_o(_gvn.transform( new ProjNode(call, TypeFunc::I_O) ));
1796     set_all_memory(_gvn.transform( new ProjNode(call, TypeFunc::Memory) ));
1797   }



















1798   return ret;
1799 }
1800 
1801 //--------------------set_predefined_input_for_runtime_call--------------------
1802 // Reading and setting the memory state is way conservative here.
1803 // The real problem is that I am not doing real Type analysis on memory,
1804 // so I cannot distinguish card mark stores from other stores.  Across a GC
1805 // point the Store Barrier and the card mark memory has to agree.  I cannot
1806 // have a card mark store and its barrier split across the GC point from
1807 // either above or below.  Here I get that to happen by reading ALL of memory.
1808 // A better answer would be to separate out card marks from other memory.
1809 // For now, return the input memory state, so that it can be reused
1810 // after the call, if this call has restricted memory effects.
1811 Node* GraphKit::set_predefined_input_for_runtime_call(SafePointNode* call, Node* narrow_mem) {
1812   // Set fixed predefined input arguments
1813   Node* memory = reset_memory();
1814   Node* m = narrow_mem == NULL ? memory : narrow_mem;
1815   call-&gt;init_req( TypeFunc::Control,   control()  );
1816   call-&gt;init_req( TypeFunc::I_O,       top()      ); // does no i/o
1817   call-&gt;init_req( TypeFunc::Memory,    m          ); // may gc ptrs
</pre>
<hr />
<pre>
1868     if (use-&gt;is_MergeMem()) {
1869       wl.push(use);
1870     }
1871   }
1872 }
1873 
1874 // Replace the call with the current state of the kit.
1875 void GraphKit::replace_call(CallNode* call, Node* result, bool do_replaced_nodes) {
1876   JVMState* ejvms = NULL;
1877   if (has_exceptions()) {
1878     ejvms = transfer_exceptions_into_jvms();
1879   }
1880 
1881   ReplacedNodes replaced_nodes = map()-&gt;replaced_nodes();
1882   ReplacedNodes replaced_nodes_exception;
1883   Node* ex_ctl = top();
1884 
1885   SafePointNode* final_state = stop();
1886 
1887   // Find all the needed outputs of this call
<span class="line-modified">1888   CallProjections callprojs;</span>
<span class="line-removed">1889   call-&gt;extract_projections(&amp;callprojs, true);</span>
1890 
1891   Unique_Node_List wl;
1892   Node* init_mem = call-&gt;in(TypeFunc::Memory);
1893   Node* final_mem = final_state-&gt;in(TypeFunc::Memory);
1894   Node* final_ctl = final_state-&gt;in(TypeFunc::Control);
1895   Node* final_io = final_state-&gt;in(TypeFunc::I_O);
1896 
1897   // Replace all the old call edges with the edges from the inlining result
<span class="line-modified">1898   if (callprojs.fallthrough_catchproj != NULL) {</span>
<span class="line-modified">1899     C-&gt;gvn_replace_by(callprojs.fallthrough_catchproj, final_ctl);</span>
1900   }
<span class="line-modified">1901   if (callprojs.fallthrough_memproj != NULL) {</span>
1902     if (final_mem-&gt;is_MergeMem()) {
1903       // Parser&#39;s exits MergeMem was not transformed but may be optimized
1904       final_mem = _gvn.transform(final_mem);
1905     }
<span class="line-modified">1906     C-&gt;gvn_replace_by(callprojs.fallthrough_memproj,   final_mem);</span>
1907     add_mergemem_users_to_worklist(wl, final_mem);
1908   }
<span class="line-modified">1909   if (callprojs.fallthrough_ioproj != NULL) {</span>
<span class="line-modified">1910     C-&gt;gvn_replace_by(callprojs.fallthrough_ioproj,    final_io);</span>
1911   }
1912 
1913   // Replace the result with the new result if it exists and is used
<span class="line-modified">1914   if (callprojs.resproj != NULL &amp;&amp; result != NULL) {</span>
<span class="line-modified">1915     C-&gt;gvn_replace_by(callprojs.resproj, result);</span>

1916   }
1917 
1918   if (ejvms == NULL) {
1919     // No exception edges to simply kill off those paths
<span class="line-modified">1920     if (callprojs.catchall_catchproj != NULL) {</span>
<span class="line-modified">1921       C-&gt;gvn_replace_by(callprojs.catchall_catchproj, C-&gt;top());</span>
1922     }
<span class="line-modified">1923     if (callprojs.catchall_memproj != NULL) {</span>
<span class="line-modified">1924       C-&gt;gvn_replace_by(callprojs.catchall_memproj,   C-&gt;top());</span>
1925     }
<span class="line-modified">1926     if (callprojs.catchall_ioproj != NULL) {</span>
<span class="line-modified">1927       C-&gt;gvn_replace_by(callprojs.catchall_ioproj,    C-&gt;top());</span>
1928     }
1929     // Replace the old exception object with top
<span class="line-modified">1930     if (callprojs.exobj != NULL) {</span>
<span class="line-modified">1931       C-&gt;gvn_replace_by(callprojs.exobj, C-&gt;top());</span>
1932     }
1933   } else {
1934     GraphKit ekit(ejvms);
1935 
1936     // Load my combined exception state into the kit, with all phis transformed:
1937     SafePointNode* ex_map = ekit.combine_and_pop_all_exception_states();
1938     replaced_nodes_exception = ex_map-&gt;replaced_nodes();
1939 
1940     Node* ex_oop = ekit.use_exception_state(ex_map);
1941 
<span class="line-modified">1942     if (callprojs.catchall_catchproj != NULL) {</span>
<span class="line-modified">1943       C-&gt;gvn_replace_by(callprojs.catchall_catchproj, ekit.control());</span>
1944       ex_ctl = ekit.control();
1945     }
<span class="line-modified">1946     if (callprojs.catchall_memproj != NULL) {</span>
1947       Node* ex_mem = ekit.reset_memory();
<span class="line-modified">1948       C-&gt;gvn_replace_by(callprojs.catchall_memproj,   ex_mem);</span>
1949       add_mergemem_users_to_worklist(wl, ex_mem);
1950     }
<span class="line-modified">1951     if (callprojs.catchall_ioproj != NULL) {</span>
<span class="line-modified">1952       C-&gt;gvn_replace_by(callprojs.catchall_ioproj,    ekit.i_o());</span>
1953     }
1954 
1955     // Replace the old exception object with the newly created one
<span class="line-modified">1956     if (callprojs.exobj != NULL) {</span>
<span class="line-modified">1957       C-&gt;gvn_replace_by(callprojs.exobj, ex_oop);</span>
1958     }
1959   }
1960 
1961   // Disconnect the call from the graph
1962   call-&gt;disconnect_inputs(NULL, C);
1963   C-&gt;gvn_replace_by(call, C-&gt;top());
1964 
1965   // Clean up any MergeMems that feed other MergeMems since the
1966   // optimizer doesn&#39;t like that.
1967   while (wl.size() &gt; 0) {
1968     _gvn.transform(wl.pop());
1969   }
1970 
<span class="line-modified">1971   if (callprojs.fallthrough_catchproj != NULL &amp;&amp; !final_ctl-&gt;is_top() &amp;&amp; do_replaced_nodes) {</span>
1972     replaced_nodes.apply(C, final_ctl);
1973   }
1974   if (!ex_ctl-&gt;is_top() &amp;&amp; do_replaced_nodes) {
1975     replaced_nodes_exception.apply(C, ex_ctl);
1976   }
1977 }
1978 
1979 
1980 //------------------------------increment_counter------------------------------
1981 // for statistics: increment a VM counter by 1
1982 
1983 void GraphKit::increment_counter(address counter_addr) {
1984   Node* adr1 = makecon(TypeRawPtr::make(counter_addr));
1985   increment_counter(adr1);
1986 }
1987 
1988 void GraphKit::increment_counter(Node* counter_addr) {
1989   int adr_type = Compile::AliasIdxRaw;
1990   Node* ctrl = control();
1991   Node* cnt  = make_load(ctrl, counter_addr, TypeInt::INT, T_INT, adr_type, MemNode::unordered);
</pre>
<hr />
<pre>
2171     speculative = speculative-&gt;with_inline_depth(jvms()-&gt;depth());
2172   } else if (current_type-&gt;would_improve_ptr(ptr_kind)) {
2173     // Profiling report that null was never seen so we can change the
2174     // speculative type to non null ptr.
2175     if (ptr_kind == ProfileAlwaysNull) {
2176       speculative = TypePtr::NULL_PTR;
2177     } else {
2178       assert(ptr_kind == ProfileNeverNull, &quot;nothing else is an improvement&quot;);
2179       const TypePtr* ptr = TypePtr::NOTNULL;
2180       if (speculative != NULL) {
2181         speculative = speculative-&gt;cast_to_ptr_type(ptr-&gt;ptr())-&gt;is_ptr();
2182       } else {
2183         speculative = ptr;
2184       }
2185     }
2186   }
2187 
2188   if (speculative != current_type-&gt;speculative()) {
2189     // Build a type with a speculative type (what we think we know
2190     // about the type but will need a guard when we use it)
<span class="line-modified">2191     const TypeOopPtr* spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::OffsetBot, TypeOopPtr::InstanceBot, speculative);</span>
2192     // We&#39;re changing the type, we need a new CheckCast node to carry
2193     // the new type. The new type depends on the control: what
2194     // profiling tells us is only valid from here as far as we can
2195     // tell.
2196     Node* cast = new CheckCastPPNode(control(), n, current_type-&gt;remove_speculative()-&gt;join_speculative(spec_type));
2197     cast = _gvn.transform(cast);
2198     replace_in_map(n, cast);
2199     n = cast;
2200   }
2201 
2202   return n;
2203 }
2204 
2205 /**
2206  * Record profiling data from receiver profiling at an invoke with the
2207  * type system so that it can propagate it (speculation)
2208  *
2209  * @param n  receiver node
2210  *
2211  * @return   node with improved type
2212  */
2213 Node* GraphKit::record_profiled_receiver_for_speculation(Node* n) {
2214   if (!UseTypeSpeculation) {
2215     return n;
2216   }
2217   ciKlass* exact_kls = profile_has_unique_klass();
2218   ProfilePtrKind ptr_kind = ProfileMaybeNull;
2219   if ((java_bc() == Bytecodes::_checkcast ||
2220        java_bc() == Bytecodes::_instanceof ||
2221        java_bc() == Bytecodes::_aastore) &amp;&amp;
2222       method()-&gt;method_data()-&gt;is_mature()) {
2223     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
2224     if (data != NULL) {
<span class="line-modified">2225       if (!data-&gt;as_BitData()-&gt;null_seen()) {</span>
<span class="line-modified">2226         ptr_kind = ProfileNeverNull;</span>







2227       } else {
<span class="line-modified">2228         assert(data-&gt;is_ReceiverTypeData(), &quot;bad profile data type&quot;);</span>
<span class="line-modified">2229         ciReceiverTypeData* call = (ciReceiverTypeData*)data-&gt;as_ReceiverTypeData();</span>
<span class="line-modified">2230         uint i = 0;</span>
<span class="line-modified">2231         for (; i &lt; call-&gt;row_limit(); i++) {</span>
<span class="line-modified">2232           ciKlass* receiver = call-&gt;receiver(i);</span>
<span class="line-modified">2233           if (receiver != NULL) {</span>
<span class="line-modified">2234             break;</span>




2235           }

2236         }
<span class="line-removed">2237         ptr_kind = (i == call-&gt;row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;</span>
2238       }
2239     }
2240   }
2241   return record_profile_for_speculation(n, exact_kls, ptr_kind);
2242 }
2243 
2244 /**
2245  * Record profiling data from argument profiling at an invoke with the
2246  * type system so that it can propagate it (speculation)
2247  *
2248  * @param dest_method  target method for the call
2249  * @param bc           what invoke bytecode is this?
2250  */
2251 void GraphKit::record_profiled_arguments_for_speculation(ciMethod* dest_method, Bytecodes::Code bc) {
2252   if (!UseTypeSpeculation) {
2253     return;
2254   }
2255   const TypeFunc* tf    = TypeFunc::make(dest_method);
<span class="line-modified">2256   int             nargs = tf-&gt;domain()-&gt;cnt() - TypeFunc::Parms;</span>
2257   int skip = Bytecodes::has_receiver(bc) ? 1 : 0;
2258   for (int j = skip, i = 0; j &lt; nargs &amp;&amp; i &lt; TypeProfileArgsLimit; j++) {
<span class="line-modified">2259     const Type *targ = tf-&gt;domain()-&gt;field_at(j + TypeFunc::Parms);</span>
2260     if (is_reference_type(targ-&gt;basic_type())) {
2261       ProfilePtrKind ptr_kind = ProfileMaybeNull;
2262       ciKlass* better_type = NULL;
2263       if (method()-&gt;argument_profiled_type(bci(), i, better_type, ptr_kind)) {
2264         record_profile_for_speculation(argument(j), better_type, ptr_kind);
2265       }
2266       i++;
2267     }
2268   }
2269 }
2270 
2271 /**
2272  * Record profiling data from parameter profiling at an invoke with
2273  * the type system so that it can propagate it (speculation)
2274  */
2275 void GraphKit::record_profiled_parameters_for_speculation() {
2276   if (!UseTypeSpeculation) {
2277     return;
2278   }
2279   for (int i = 0, j = 0; i &lt; method()-&gt;arg_size() ; i++) {
</pre>
<hr />
<pre>
2310   if (Matcher::strict_fp_requires_explicit_rounding) {
2311     // If a strict caller invokes a non-strict callee, round a double result.
2312     // A non-strict method may return a double value which has an extended exponent,
2313     // but this must not be visible in a caller which is strict.
2314     BasicType result_type = dest_method-&gt;return_type()-&gt;basic_type();
2315     assert(method() != NULL, &quot;must have caller context&quot;);
2316     if( result_type == T_DOUBLE &amp;&amp; method()-&gt;is_strict() &amp;&amp; !dest_method-&gt;is_strict() ) {
2317       // Destination method&#39;s return value is on top of stack
2318       // dstore_rounding() does gvn.transform
2319       Node *result = pop_pair();
2320       result = dstore_rounding(result);
2321       push_pair(result);
2322     }
2323   }
2324 }
2325 
2326 void GraphKit::round_double_arguments(ciMethod* dest_method) {
2327   if (Matcher::strict_fp_requires_explicit_rounding) {
2328     // (Note:  TypeFunc::make has a cache that makes this fast.)
2329     const TypeFunc* tf    = TypeFunc::make(dest_method);
<span class="line-modified">2330     int             nargs = tf-&gt;domain()-&gt;cnt() - TypeFunc::Parms;</span>
2331     for (int j = 0; j &lt; nargs; j++) {
<span class="line-modified">2332       const Type *targ = tf-&gt;domain()-&gt;field_at(j + TypeFunc::Parms);</span>
2333       if (targ-&gt;basic_type() == T_DOUBLE) {
2334         // If any parameters are doubles, they must be rounded before
2335         // the call, dstore_rounding does gvn.transform
2336         Node *arg = argument(j);
2337         arg = dstore_rounding(arg);
2338         set_argument(j, arg);
2339       }
2340     }
2341   }
2342 }
2343 
2344 // rounding for strict float precision conformance
2345 Node* GraphKit::precision_rounding(Node* n) {
2346   if (Matcher::strict_fp_requires_explicit_rounding) {
2347 #ifdef IA32
2348     if (_method-&gt;flags().is_strict() &amp;&amp; UseSSE == 0) {
2349       return _gvn.transform(new RoundFloatNode(0, n));
2350     }
2351 #else
2352     Unimplemented();
</pre>
<hr />
<pre>
2792 
2793   // Now do a linear scan of the secondary super-klass array.  Again, no real
2794   // performance impact (too rare) but it&#39;s gotta be done.
2795   // Since the code is rarely used, there is no penalty for moving it
2796   // out of line, and it can only improve I-cache density.
2797   // The decision to inline or out-of-line this final check is platform
2798   // dependent, and is found in the AD file definition of PartialSubtypeCheck.
2799   Node* psc = gvn.transform(
2800     new PartialSubtypeCheckNode(*ctrl, subklass, superklass));
2801 
2802   IfNode *iff4 = gen_subtype_check_compare(*ctrl, psc, gvn.zerocon(T_OBJECT), BoolTest::ne, PROB_FAIR, gvn, T_ADDRESS);
2803   r_not_subtype-&gt;init_req(2, gvn.transform(new IfTrueNode (iff4)));
2804   r_ok_subtype -&gt;init_req(3, gvn.transform(new IfFalseNode(iff4)));
2805 
2806   // Return false path; set default control to true path.
2807   *ctrl = gvn.transform(r_ok_subtype);
2808   return gvn.transform(r_not_subtype);
2809 }
2810 
2811 Node* GraphKit::gen_subtype_check(Node* obj_or_subklass, Node* superklass) {




2812   if (ExpandSubTypeCheckAtParseTime) {
2813     MergeMemNode* mem = merged_memory();
2814     Node* ctrl = control();
2815     Node* subklass = obj_or_subklass;
<span class="line-modified">2816     if (!_gvn.type(obj_or_subklass)-&gt;isa_klassptr()) {</span>
2817       subklass = load_object_klass(obj_or_subklass);
2818     }
<span class="line-removed">2819 </span>
2820     Node* n = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, mem, _gvn);
2821     set_control(ctrl);
2822     return n;
2823   }
2824 
<span class="line-removed">2825   const TypePtr* adr_type = TypeKlassPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;Object_klass(), Type::OffsetBot);</span>
2826   Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass));
2827   Node* bol = _gvn.transform(new BoolNode(check, BoolTest::eq));
2828   IfNode* iff = create_and_xform_if(control(), bol, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);
2829   set_control(_gvn.transform(new IfTrueNode(iff)));
2830   return _gvn.transform(new IfFalseNode(iff));
2831 }
2832 
2833 // Profile-driven exact type check:
2834 Node* GraphKit::type_check_receiver(Node* receiver, ciKlass* klass,
2835                                     float prob,
2836                                     Node* *casted_receiver) {
2837   const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);
2838   Node* recv_klass = load_object_klass(receiver);
<span class="line-modified">2839   Node* want_klass = makecon(tklass);</span>
<span class="line-removed">2840   Node* cmp = _gvn.transform( new CmpPNode(recv_klass, want_klass) );</span>
<span class="line-removed">2841   Node* bol = _gvn.transform( new BoolNode(cmp, BoolTest::eq) );</span>
<span class="line-removed">2842   IfNode* iff = create_and_xform_if(control(), bol, prob, COUNT_UNKNOWN);</span>
<span class="line-removed">2843   set_control( _gvn.transform( new IfTrueNode (iff) ));</span>
<span class="line-removed">2844   Node* fail = _gvn.transform( new IfFalseNode(iff) );</span>
<span class="line-removed">2845 </span>
2846   const TypeOopPtr* recv_xtype = tklass-&gt;as_instance_type();
2847   assert(recv_xtype-&gt;klass_is_exact(), &quot;&quot;);
2848 
2849   // Subsume downstream occurrences of receiver with a cast to
2850   // recv_xtype, since now we know what the type will be.
2851   Node* cast = new CheckCastPPNode(control(), receiver, recv_xtype);
<span class="line-modified">2852   (*casted_receiver) = _gvn.transform(cast);</span>






2853   // (User must make the replace_in_map call.)
2854 
2855   return fail;
2856 }
2857 











2858 //------------------------------subtype_check_receiver-------------------------
2859 Node* GraphKit::subtype_check_receiver(Node* receiver, ciKlass* klass,
2860                                        Node** casted_receiver) {
2861   const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);
2862   Node* want_klass = makecon(tklass);
2863 
2864   Node* slow_ctl = gen_subtype_check(receiver, want_klass);
2865 
2866   // Cast receiver after successful check
2867   const TypeOopPtr* recv_type = tklass-&gt;cast_to_exactness(false)-&gt;is_klassptr()-&gt;as_instance_type();
2868   Node* cast = new CheckCastPPNode(control(), receiver, recv_type);
2869   (*casted_receiver) = _gvn.transform(cast);
2870 
2871   return slow_ctl;
2872 }
2873 
2874 //------------------------------seems_never_null-------------------------------
2875 // Use null_seen information if it is available from the profile.
2876 // If we see an unexpected null at a type check we record it and force a
2877 // recompile; the offending check will be recompiled to handle NULLs.
2878 // If we see several offending BCIs, then all checks in the
2879 // method will be recompiled.
2880 bool GraphKit::seems_never_null(Node* obj, ciProfileData* data, bool&amp; speculating) {
2881   speculating = !_gvn.type(obj)-&gt;speculative_maybe_null();
2882   Deoptimization::DeoptReason reason = Deoptimization::reason_null_check(speculating);
2883   if (UncommonNullCast               // Cutout for this technique
2884       &amp;&amp; obj != null()               // And not the -Xcomp stupid case?
2885       &amp;&amp; !too_many_traps(reason)
2886       ) {
2887     if (speculating) {
2888       return true;
2889     }
2890     if (data == NULL)
2891       // Edge case:  no mature data.  Be optimistic here.
2892       return true;
2893     // If the profile has not seen a null, assume it won&#39;t happen.
2894     assert(java_bc() == Bytecodes::_checkcast ||
2895            java_bc() == Bytecodes::_instanceof ||
2896            java_bc() == Bytecodes::_aastore, &quot;MDO must collect null_seen bit here&quot;);



2897     return !data-&gt;as_BitData()-&gt;null_seen();
2898   }
2899   speculating = false;
2900   return false;
2901 }
2902 
2903 void GraphKit::guard_klass_being_initialized(Node* klass) {
2904   int init_state_off = in_bytes(InstanceKlass::init_state_offset());
2905   Node* adr = basic_plus_adr(top(), klass, init_state_off);
2906   Node* init_state = LoadNode::make(_gvn, NULL, immutable_memory(), adr,
2907                                     adr-&gt;bottom_type()-&gt;is_ptr(), TypeInt::BYTE,
2908                                     T_BYTE, MemNode::unordered);
2909   init_state = _gvn.transform(init_state);
2910 
2911   Node* being_initialized_state = makecon(TypeInt::make(InstanceKlass::being_initialized));
2912 
2913   Node* chk = _gvn.transform(new CmpINode(being_initialized_state, init_state));
2914   Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::eq));
2915 
2916   { BuildCutout unless(this, tst, PROB_MAX);
</pre>
<hr />
<pre>
2956 
2957 //------------------------maybe_cast_profiled_receiver-------------------------
2958 // If the profile has seen exactly one type, narrow to exactly that type.
2959 // Subsequent type checks will always fold up.
2960 Node* GraphKit::maybe_cast_profiled_receiver(Node* not_null_obj,
2961                                              ciKlass* require_klass,
2962                                              ciKlass* spec_klass,
2963                                              bool safe_for_replace) {
2964   if (!UseTypeProfile || !TypeProfileCasts) return NULL;
2965 
2966   Deoptimization::DeoptReason reason = Deoptimization::reason_class_check(spec_klass != NULL);
2967 
2968   // Make sure we haven&#39;t already deoptimized from this tactic.
2969   if (too_many_traps_or_recompiles(reason))
2970     return NULL;
2971 
2972   // (No, this isn&#39;t a call, but it&#39;s enough like a virtual call
2973   // to use the same ciMethod accessor to get the profile info...)
2974   // If we have a speculative type use it instead of profiling (which
2975   // may not help us)
<span class="line-modified">2976   ciKlass* exact_kls = spec_klass == NULL ? profile_has_unique_klass() : spec_klass;</span>













2977   if (exact_kls != NULL) {// no cast failures here
2978     if (require_klass == NULL ||
2979         C-&gt;static_subtype_check(require_klass, exact_kls) == Compile::SSC_always_true) {
2980       // If we narrow the type to match what the type profile sees or
2981       // the speculative type, we can then remove the rest of the
2982       // cast.
2983       // This is a win, even if the exact_kls is very specific,
2984       // because downstream operations, such as method calls,
2985       // will often benefit from the sharper type.
2986       Node* exact_obj = not_null_obj; // will get updated in place...
2987       Node* slow_ctl  = type_check_receiver(exact_obj, exact_kls, 1.0,
2988                                             &amp;exact_obj);
2989       { PreserveJVMState pjvms(this);
2990         set_control(slow_ctl);
2991         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
2992       }
2993       if (safe_for_replace) {
2994         replace_in_map(not_null_obj, exact_obj);
2995       }
2996       return exact_obj;
</pre>
<hr />
<pre>
3061 // and the reflective instance-of call.
3062 Node* GraphKit::gen_instanceof(Node* obj, Node* superklass, bool safe_for_replace) {
3063   kill_dead_locals();           // Benefit all the uncommon traps
3064   assert( !stopped(), &quot;dead parse path should be checked in callers&quot; );
3065   assert(!TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(superklass)-&gt;is_klassptr()),
3066          &quot;must check for not-null not-dead klass in callers&quot;);
3067 
3068   // Make the merge point
3069   enum { _obj_path = 1, _fail_path, _null_path, PATH_LIMIT };
3070   RegionNode* region = new RegionNode(PATH_LIMIT);
3071   Node*       phi    = new PhiNode(region, TypeInt::BOOL);
3072   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3073 
3074   ciProfileData* data = NULL;
3075   if (java_bc() == Bytecodes::_instanceof) {  // Only for the bytecode
3076     data = method()-&gt;method_data()-&gt;bci_to_data(bci());
3077   }
3078   bool speculative_not_null = false;
3079   bool never_see_null = (ProfileDynamicTypes  // aggressive use of profile
3080                          &amp;&amp; seems_never_null(obj, data, speculative_not_null));

3081 
3082   // Null check; get casted pointer; set region slot 3
3083   Node* null_ctl = top();
<span class="line-modified">3084   Node* not_null_obj = null_check_oop(obj, &amp;null_ctl, never_see_null, safe_for_replace, speculative_not_null);</span>
3085 
3086   // If not_null_obj is dead, only null-path is taken
3087   if (stopped()) {              // Doing instance-of on a NULL?
3088     set_control(null_ctl);
3089     return intcon(0);
3090   }
3091   region-&gt;init_req(_null_path, null_ctl);
3092   phi   -&gt;init_req(_null_path, intcon(0)); // Set null path value
3093   if (null_ctl == top()) {
3094     // Do this eagerly, so that pattern matches like is_diamond_phi
3095     // will work even during parsing.
3096     assert(_null_path == PATH_LIMIT-1, &quot;delete last&quot;);
3097     region-&gt;del_req(_null_path);
3098     phi   -&gt;del_req(_null_path);
3099   }
3100 
3101   // Do we know the type check always succeed?
<span class="line-modified">3102   bool known_statically = false;</span>
<span class="line-modified">3103   if (_gvn.type(superklass)-&gt;singleton()) {</span>
<span class="line-modified">3104     ciKlass* superk = _gvn.type(superklass)-&gt;is_klassptr()-&gt;klass();</span>
<span class="line-modified">3105     ciKlass* subk = _gvn.type(obj)-&gt;is_oopptr()-&gt;klass();</span>
<span class="line-modified">3106     if (subk != NULL &amp;&amp; subk-&gt;is_loaded()) {</span>
<span class="line-modified">3107       int static_res = C-&gt;static_subtype_check(superk, subk);</span>
<span class="line-modified">3108       known_statically = (static_res == Compile::SSC_always_true || static_res == Compile::SSC_always_false);</span>


3109     }
<span class="line-modified">3110   }</span>
<span class="line-modified">3111 </span>
<span class="line-modified">3112   if (!known_statically) {</span>
<span class="line-modified">3113     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();</span>
<span class="line-modified">3114     // We may not have profiling here or it may not help us. If we</span>
<span class="line-modified">3115     // have a speculative type use it to perform an exact cast.</span>
<span class="line-modified">3116     ciKlass* spec_obj_type = obj_type-&gt;speculative_type();</span>
<span class="line-modified">3117     if (spec_obj_type != NULL || (ProfileDynamicTypes &amp;&amp; data != NULL)) {</span>
<span class="line-modified">3118       Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, NULL, spec_obj_type, safe_for_replace);</span>
<span class="line-modified">3119       if (stopped()) {            // Profile disagrees with this path.</span>
<span class="line-modified">3120         set_control(null_ctl);    // Null is the only remaining possibility.</span>
<span class="line-modified">3121         return intcon(0);</span>
<span class="line-modified">3122       }</span>
<span class="line-modified">3123       if (cast_obj != NULL) {</span>



3124         not_null_obj = cast_obj;
3125       }
3126     }
3127   }
3128 
3129   // Generate the subtype check
3130   Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass);
3131 
3132   // Plug in the success path to the general merge in slot 1.
3133   region-&gt;init_req(_obj_path, control());
3134   phi   -&gt;init_req(_obj_path, intcon(1));
3135 
3136   // Plug in the failing path to the general merge in slot 2.
3137   region-&gt;init_req(_fail_path, not_subtype_ctrl);
3138   phi   -&gt;init_req(_fail_path, intcon(0));
3139 
3140   // Return final merged results
3141   set_control( _gvn.transform(region) );
3142   record_for_igvn(region);
3143 
3144   // If we know the type check always succeeds then we don&#39;t use the
3145   // profiling data at this bytecode. Don&#39;t lose it, feed it to the
3146   // type system as a speculative type.
<span class="line-modified">3147   if (safe_for_replace) {</span>
3148     Node* casted_obj = record_profiled_receiver_for_speculation(obj);
3149     replace_in_map(obj, casted_obj);
3150   }
3151 
3152   return _gvn.transform(phi);
3153 }
3154 
3155 //-------------------------------gen_checkcast---------------------------------
3156 // Generate a checkcast idiom.  Used by both the checkcast bytecode and the
3157 // array store bytecode.  Stack must be as-if BEFORE doing the bytecode so the
3158 // uncommon-trap paths work.  Adjust stack after this call.
3159 // If failure_control is supplied and not null, it is filled in with
3160 // the control edge for the cast failure.  Otherwise, an appropriate
3161 // uncommon trap or exception is thrown.
<span class="line-modified">3162 Node* GraphKit::gen_checkcast(Node *obj, Node* superklass,</span>
<span class="line-removed">3163                               Node* *failure_control) {</span>
3164   kill_dead_locals();           // Benefit all the uncommon traps
<span class="line-modified">3165   const TypeKlassPtr *tk = _gvn.type(superklass)-&gt;is_klassptr();</span>
<span class="line-modified">3166   const Type *toop = TypeOopPtr::make_from_klass(tk-&gt;klass());</span>


3167 
3168   // Fast cutout:  Check the case that the cast is vacuously true.
3169   // This detects the common cases where the test will short-circuit
3170   // away completely.  We do this before we perform the null check,
3171   // because if the test is going to turn into zero code, we don&#39;t
3172   // want a residual null check left around.  (Causes a slowdown,
3173   // for example, in some objArray manipulations, such as a[i]=a[j].)
3174   if (tk-&gt;singleton()) {
<span class="line-modified">3175     const TypeOopPtr* objtp = _gvn.type(obj)-&gt;isa_oopptr();</span>
<span class="line-modified">3176     if (objtp != NULL &amp;&amp; objtp-&gt;klass() != NULL) {</span>
<span class="line-modified">3177       switch (C-&gt;static_subtype_check(tk-&gt;klass(), objtp-&gt;klass())) {</span>








3178       case Compile::SSC_always_true:
3179         // If we know the type check always succeed then we don&#39;t use
3180         // the profiling data at this bytecode. Don&#39;t lose it, feed it
3181         // to the type system as a speculative type.
<span class="line-modified">3182         return record_profiled_receiver_for_speculation(obj);</span>









3183       case Compile::SSC_always_false:
<span class="line-modified">3184         // It needs a null check because a null will *pass* the cast check.</span>
<span class="line-modified">3185         // A non-null value will always produce an exception.</span>
<span class="line-modified">3186         return null_assert(obj);</span>








3187       }
3188     }
3189   }
3190 
3191   ciProfileData* data = NULL;
3192   bool safe_for_replace = false;
3193   if (failure_control == NULL) {        // use MDO in regular case only
3194     assert(java_bc() == Bytecodes::_aastore ||
3195            java_bc() == Bytecodes::_checkcast,
3196            &quot;interpreter profiles type checks only for these BCs&quot;);
<span class="line-modified">3197     data = method()-&gt;method_data()-&gt;bci_to_data(bci());</span>


3198     safe_for_replace = true;
3199   }
3200 
3201   // Make the merge point
3202   enum { _obj_path = 1, _null_path, PATH_LIMIT };
3203   RegionNode* region = new RegionNode(PATH_LIMIT);
3204   Node*       phi    = new PhiNode(region, toop);



3205   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3206 
3207   // Use null-cast information if it is available
3208   bool speculative_not_null = false;
3209   bool never_see_null = ((failure_control == NULL)  // regular case only
3210                          &amp;&amp; seems_never_null(obj, data, speculative_not_null));
3211 
3212   // Null check; get casted pointer; set region slot 3
3213   Node* null_ctl = top();
<span class="line-modified">3214   Node* not_null_obj = null_check_oop(obj, &amp;null_ctl, never_see_null, safe_for_replace, speculative_not_null);</span>







3215 
3216   // If not_null_obj is dead, only null-path is taken
3217   if (stopped()) {              // Doing instance-of on a NULL?
3218     set_control(null_ctl);
3219     return null();
3220   }
3221   region-&gt;init_req(_null_path, null_ctl);
3222   phi   -&gt;init_req(_null_path, null());  // Set null path value
3223   if (null_ctl == top()) {
3224     // Do this eagerly, so that pattern matches like is_diamond_phi
3225     // will work even during parsing.
3226     assert(_null_path == PATH_LIMIT-1, &quot;delete last&quot;);
3227     region-&gt;del_req(_null_path);
3228     phi   -&gt;del_req(_null_path);
3229   }
3230 
3231   Node* cast_obj = NULL;
<span class="line-modified">3232   if (tk-&gt;klass_is_exact()) {</span>
3233     // The following optimization tries to statically cast the speculative type of the object
3234     // (for example obtained during profiling) to the type of the superklass and then do a
3235     // dynamic check that the type of the object is what we expect. To work correctly
3236     // for checkcast and aastore the type of superklass should be exact.
3237     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
3238     // We may not have profiling here or it may not help us. If we have
3239     // a speculative type use it to perform an exact cast.
3240     ciKlass* spec_obj_type = obj_type-&gt;speculative_type();
3241     if (spec_obj_type != NULL || data != NULL) {
3242       cast_obj = maybe_cast_profiled_receiver(not_null_obj, tk-&gt;klass(), spec_obj_type, safe_for_replace);







3243       if (cast_obj != NULL) {
3244         if (failure_control != NULL) // failure is now impossible
3245           (*failure_control) = top();
3246         // adjust the type of the phi to the exact klass:
3247         phi-&gt;raise_bottom_type(_gvn.type(cast_obj)-&gt;meet_speculative(TypePtr::NULL_PTR));
3248       }
3249     }
3250   }
3251 
3252   if (cast_obj == NULL) {
3253     // Generate the subtype check
<span class="line-modified">3254     Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass );</span>
3255 
3256     // Plug in success path into the merge
<span class="line-modified">3257     cast_obj = _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));</span>
3258     // Failure path ends in uncommon trap (or may be dead - failure impossible)
3259     if (failure_control == NULL) {
3260       if (not_subtype_ctrl != top()) { // If failure is possible
3261         PreserveJVMState pjvms(this);
3262         set_control(not_subtype_ctrl);
<span class="line-modified">3263         builtin_throw(Deoptimization::Reason_class_check, load_object_klass(not_null_obj));</span>






3264       }
3265     } else {
3266       (*failure_control) = not_subtype_ctrl;
3267     }
3268   }
3269 
3270   region-&gt;init_req(_obj_path, control());
3271   phi   -&gt;init_req(_obj_path, cast_obj);
3272 
3273   // A merge of NULL or Casted-NotNull obj
3274   Node* res = _gvn.transform(phi);
3275 
3276   // Note I do NOT always &#39;replace_in_map(obj,result)&#39; here.
3277   //  if( tk-&gt;klass()-&gt;can_be_primary_super()  )
3278     // This means that if I successfully store an Object into an array-of-String
3279     // I &#39;forget&#39; that the Object is really now known to be a String.  I have to
3280     // do this because we don&#39;t have true union types for interfaces - if I store
3281     // a Baz into an array-of-Interface and then tell the optimizer it&#39;s an
3282     // Interface, I forget that it&#39;s also a Baz and cannot do Baz-like field
3283     // references to it.  FIX THIS WHEN UNION TYPES APPEAR!
3284   //  replace_in_map( obj, res );
3285 
3286   // Return final merged results
3287   set_control( _gvn.transform(region) );
3288   record_for_igvn(region);
3289 
<span class="line-modified">3290   return record_profiled_receiver_for_speculation(res);</span>

























































































































3291 }
3292 
3293 //------------------------------next_monitor-----------------------------------
3294 // What number should be given to the next monitor?
3295 int GraphKit::next_monitor() {
3296   int current = jvms()-&gt;monitor_depth()* C-&gt;sync_stack_slots();
3297   int next = current + C-&gt;sync_stack_slots();
3298   // Keep the toplevel high water mark current:
3299   if (C-&gt;fixed_slots() &lt; next)  C-&gt;set_fixed_slots(next);
3300   return current;
3301 }
3302 
3303 //------------------------------insert_mem_bar---------------------------------
3304 // Memory barrier to avoid floating things around
3305 // The membar serves as a pinch point between both control and all memory slices.
3306 Node* GraphKit::insert_mem_bar(int opcode, Node* precedent) {
3307   MemBarNode* mb = MemBarNode::make(C, opcode, Compile::AliasIdxBot, precedent);
3308   mb-&gt;init_req(TypeFunc::Control, control());
3309   mb-&gt;init_req(TypeFunc::Memory,  reset_memory());
3310   Node* membar = _gvn.transform(mb);
</pre>
<hr />
<pre>
3338   }
3339   Node* membar = _gvn.transform(mb);
3340   set_control(_gvn.transform(new ProjNode(membar, TypeFunc::Control)));
3341   if (alias_idx == Compile::AliasIdxBot) {
3342     merged_memory()-&gt;set_base_memory(_gvn.transform(new ProjNode(membar, TypeFunc::Memory)));
3343   } else {
3344     set_memory(_gvn.transform(new ProjNode(membar, TypeFunc::Memory)),alias_idx);
3345   }
3346   return membar;
3347 }
3348 
3349 //------------------------------shared_lock------------------------------------
3350 // Emit locking code.
3351 FastLockNode* GraphKit::shared_lock(Node* obj) {
3352   // bci is either a monitorenter bc or InvocationEntryBci
3353   // %%% SynchronizationEntryBCI is redundant; use InvocationEntryBci in interfaces
3354   assert(SynchronizationEntryBCI == InvocationEntryBci, &quot;&quot;);
3355 
3356   if( !GenerateSynchronizationCode )
3357     return NULL;                // Not locking things?

3358   if (stopped())                // Dead monitor?
3359     return NULL;
3360 
3361   assert(dead_locals_are_killed(), &quot;should kill locals before sync. point&quot;);
3362 
3363   // Box the stack location
3364   Node* box = _gvn.transform(new BoxLockNode(next_monitor()));
3365   Node* mem = reset_memory();
3366 
3367   FastLockNode * flock = _gvn.transform(new FastLockNode(0, obj, box) )-&gt;as_FastLock();
3368   if (UseBiasedLocking &amp;&amp; PrintPreciseBiasedLockingStatistics) {
3369     // Create the counters for this fast lock.
3370     flock-&gt;create_lock_counter(sync_jvms()); // sync_jvms used to get current bci
3371   }
3372 
3373   // Create the rtm counters for this fast lock if needed.
3374   flock-&gt;create_rtm_lock_counter(sync_jvms()); // sync_jvms used to get current bci
3375 
3376   // Add monitor to debug info for the slow path.  If we block inside the
3377   // slow path and de-opt, we need the monitor hanging around
</pre>
<hr />
<pre>
3410   }
3411 #endif
3412 
3413   return flock;
3414 }
3415 
3416 
3417 //------------------------------shared_unlock----------------------------------
3418 // Emit unlocking code.
3419 void GraphKit::shared_unlock(Node* box, Node* obj) {
3420   // bci is either a monitorenter bc or InvocationEntryBci
3421   // %%% SynchronizationEntryBCI is redundant; use InvocationEntryBci in interfaces
3422   assert(SynchronizationEntryBCI == InvocationEntryBci, &quot;&quot;);
3423 
3424   if( !GenerateSynchronizationCode )
3425     return;
3426   if (stopped()) {               // Dead monitor?
3427     map()-&gt;pop_monitor();        // Kill monitor from debug info
3428     return;
3429   }

3430 
3431   // Memory barrier to avoid floating things down past the locked region
3432   insert_mem_bar(Op_MemBarReleaseLock);
3433 
3434   const TypeFunc *tf = OptoRuntime::complete_monitor_exit_Type();
3435   UnlockNode *unlock = new UnlockNode(C, tf);
3436 #ifdef ASSERT
3437   unlock-&gt;set_dbg_jvms(sync_jvms());
3438 #endif
3439   uint raw_idx = Compile::AliasIdxRaw;
3440   unlock-&gt;init_req( TypeFunc::Control, control() );
3441   unlock-&gt;init_req( TypeFunc::Memory , memory(raw_idx) );
3442   unlock-&gt;init_req( TypeFunc::I_O    , top() )     ;   // does no i/o
3443   unlock-&gt;init_req( TypeFunc::FramePtr, frameptr() );
3444   unlock-&gt;init_req( TypeFunc::ReturnAdr, top() );
3445 
3446   unlock-&gt;init_req(TypeFunc::Parms + 0, obj);
3447   unlock-&gt;init_req(TypeFunc::Parms + 1, box);
3448   unlock = _gvn.transform(unlock)-&gt;as_Unlock();
3449 
3450   Node* mem = reset_memory();
3451 
3452   // unlock has no side-effects, sets few values
3453   set_predefined_output_for_runtime_call(unlock, mem, TypeRawPtr::BOTTOM);
3454 
3455   // Kill monitor from debug info
3456   map()-&gt;pop_monitor( );
3457 }
3458 
3459 //-------------------------------get_layout_helper-----------------------------
3460 // If the given klass is a constant or known to be an array,
3461 // fetch the constant layout helper value into constant_value
3462 // and return (Node*)NULL.  Otherwise, load the non-constant
3463 // layout helper value, and return the node which represents it.
3464 // This two-faced routine is useful because allocation sites
3465 // almost always feature constant types.
3466 Node* GraphKit::get_layout_helper(Node* klass_node, jint&amp; constant_value) {
3467   const TypeKlassPtr* inst_klass = _gvn.type(klass_node)-&gt;isa_klassptr();
3468   if (!StressReflectiveCode &amp;&amp; inst_klass != NULL) {
3469     ciKlass* klass = inst_klass-&gt;klass();

3470     bool    xklass = inst_klass-&gt;klass_is_exact();
<span class="line-modified">3471     if (xklass || klass-&gt;is_array_klass()) {</span>





3472       jint lhelper = klass-&gt;layout_helper();
3473       if (lhelper != Klass::_lh_neutral_value) {
3474         constant_value = lhelper;
3475         return (Node*) NULL;
3476       }
3477     }
3478   }
3479   constant_value = Klass::_lh_neutral_value;  // put in a known value
3480   Node* lhp = basic_plus_adr(klass_node, klass_node, in_bytes(Klass::layout_helper_offset()));
3481   return make_load(NULL, lhp, TypeInt::INT, T_INT, MemNode::unordered);
3482 }
3483 
3484 // We just put in an allocate/initialize with a big raw-memory effect.
3485 // Hook selected additional alias categories on the initialization.
3486 static void hook_memory_on_init(GraphKit&amp; kit, int alias_idx,
3487                                 MergeMemNode* init_in_merge,
3488                                 Node* init_out_raw) {
3489   DEBUG_ONLY(Node* init_in_raw = init_in_merge-&gt;base_memory());
3490   assert(init_in_merge-&gt;memory_at(alias_idx) == init_in_raw, &quot;&quot;);
3491 
</pre>
<hr />
<pre>
3513 
3514   // a normal slow-call doesn&#39;t change i_o, but an allocation does
3515   // we create a separate i_o projection for the normal control path
3516   set_i_o(_gvn.transform( new ProjNode(allocx, TypeFunc::I_O, false) ) );
3517   Node* rawoop = _gvn.transform( new ProjNode(allocx, TypeFunc::Parms) );
3518 
3519   // put in an initialization barrier
3520   InitializeNode* init = insert_mem_bar_volatile(Op_Initialize, rawidx,
3521                                                  rawoop)-&gt;as_Initialize();
3522   assert(alloc-&gt;initialization() == init,  &quot;2-way macro link must work&quot;);
3523   assert(init -&gt;allocation()     == alloc, &quot;2-way macro link must work&quot;);
3524   {
3525     // Extract memory strands which may participate in the new object&#39;s
3526     // initialization, and source them from the new InitializeNode.
3527     // This will allow us to observe initializations when they occur,
3528     // and link them properly (as a group) to the InitializeNode.
3529     assert(init-&gt;in(InitializeNode::Memory) == malloc, &quot;&quot;);
3530     MergeMemNode* minit_in = MergeMemNode::make(malloc);
3531     init-&gt;set_req(InitializeNode::Memory, minit_in);
3532     record_for_igvn(minit_in); // fold it up later, if possible

3533     Node* minit_out = memory(rawidx);
3534     assert(minit_out-&gt;is_Proj() &amp;&amp; minit_out-&gt;in(0) == init, &quot;&quot;);
3535     // Add an edge in the MergeMem for the header fields so an access
3536     // to one of those has correct memory state
3537     set_memory(minit_out, C-&gt;get_alias_index(oop_type-&gt;add_offset(oopDesc::mark_offset_in_bytes())));
3538     set_memory(minit_out, C-&gt;get_alias_index(oop_type-&gt;add_offset(oopDesc::klass_offset_in_bytes())));
3539     if (oop_type-&gt;isa_aryptr()) {
<span class="line-modified">3540       const TypePtr* telemref = oop_type-&gt;add_offset(Type::OffsetBot);</span>
<span class="line-modified">3541       int            elemidx  = C-&gt;get_alias_index(telemref);</span>
<span class="line-modified">3542       hook_memory_on_init(*this, elemidx, minit_in, minit_out);</span>























3543     } else if (oop_type-&gt;isa_instptr()) {

3544       ciInstanceKlass* ik = oop_type-&gt;klass()-&gt;as_instance_klass();
3545       for (int i = 0, len = ik-&gt;nof_nonstatic_fields(); i &lt; len; i++) {
3546         ciField* field = ik-&gt;nonstatic_field_at(i);
3547         if (field-&gt;offset() &gt;= TrackedInitializationLimit * HeapWordSize)
3548           continue;  // do not bother to track really large numbers of fields
3549         // Find (or create) the alias category for this field:
3550         int fieldidx = C-&gt;alias_type(field)-&gt;index();
3551         hook_memory_on_init(*this, fieldidx, minit_in, minit_out);
3552       }
3553     }
3554   }
3555 
3556   // Cast raw oop to the real thing...
3557   Node* javaoop = new CheckCastPPNode(control(), rawoop, oop_type);
3558   javaoop = _gvn.transform(javaoop);
3559   C-&gt;set_recent_alloc(control(), javaoop);
3560   assert(just_allocated_object(control()) == javaoop, &quot;just allocated&quot;);
3561 
3562 #ifdef ASSERT
3563   { // Verify that the AllocateNode::Ideal_allocation recognizers work:
</pre>
<hr />
<pre>
3574       assert(alloc-&gt;in(AllocateNode::ALength)-&gt;is_top(), &quot;no length, please&quot;);
3575     }
3576   }
3577 #endif //ASSERT
3578 
3579   return javaoop;
3580 }
3581 
3582 //---------------------------new_instance--------------------------------------
3583 // This routine takes a klass_node which may be constant (for a static type)
3584 // or may be non-constant (for reflective code).  It will work equally well
3585 // for either, and the graph will fold nicely if the optimizer later reduces
3586 // the type to a constant.
3587 // The optional arguments are for specialized use by intrinsics:
3588 //  - If &#39;extra_slow_test&#39; if not null is an extra condition for the slow-path.
3589 //  - If &#39;return_size_val&#39;, report the the total object size to the caller.
3590 //  - deoptimize_on_exception controls how Java exceptions are handled (rethrow vs deoptimize)
3591 Node* GraphKit::new_instance(Node* klass_node,
3592                              Node* extra_slow_test,
3593                              Node* *return_size_val,
<span class="line-modified">3594                              bool deoptimize_on_exception) {</span>

3595   // Compute size in doublewords
3596   // The size is always an integral number of doublewords, represented
3597   // as a positive bytewise size stored in the klass&#39;s layout_helper.
3598   // The layout_helper also encodes (in a low bit) the need for a slow path.
3599   jint  layout_con = Klass::_lh_neutral_value;
3600   Node* layout_val = get_layout_helper(klass_node, layout_con);
<span class="line-modified">3601   int   layout_is_con = (layout_val == NULL);</span>
3602 
3603   if (extra_slow_test == NULL)  extra_slow_test = intcon(0);
3604   // Generate the initial go-slow test.  It&#39;s either ALWAYS (return a
3605   // Node for 1) or NEVER (return a NULL) or perhaps (in the reflective
3606   // case) a computed value derived from the layout_helper.
3607   Node* initial_slow_test = NULL;
3608   if (layout_is_con) {
3609     assert(!StressReflectiveCode, &quot;stress mode does not use these paths&quot;);
3610     bool must_go_slow = Klass::layout_helper_needs_slow_path(layout_con);
3611     initial_slow_test = must_go_slow ? intcon(1) : extra_slow_test;
3612   } else {   // reflective case
3613     // This reflective path is used by Unsafe.allocateInstance.
3614     // (It may be stress-tested by specifying StressReflectiveCode.)
3615     // Basically, we want to get into the VM is there&#39;s an illegal argument.
3616     Node* bit = intcon(Klass::_lh_instance_slow_path_bit);
3617     initial_slow_test = _gvn.transform( new AndINode(layout_val, bit) );
3618     if (extra_slow_test != intcon(0)) {
3619       initial_slow_test = _gvn.transform( new OrINode(initial_slow_test, extra_slow_test) );
3620     }
3621     // (Macro-expander will further convert this to a Bool, if necessary.)
</pre>
<hr />
<pre>
3632 
3633     // Clear the low bits to extract layout_helper_size_in_bytes:
3634     assert((int)Klass::_lh_instance_slow_path_bit &lt; BytesPerLong, &quot;clear bit&quot;);
3635     Node* mask = MakeConX(~ (intptr_t)right_n_bits(LogBytesPerLong));
3636     size = _gvn.transform( new AndXNode(size, mask) );
3637   }
3638   if (return_size_val != NULL) {
3639     (*return_size_val) = size;
3640   }
3641 
3642   // This is a precise notnull oop of the klass.
3643   // (Actually, it need not be precise if this is a reflective allocation.)
3644   // It&#39;s what we cast the result to.
3645   const TypeKlassPtr* tklass = _gvn.type(klass_node)-&gt;isa_klassptr();
3646   if (!tklass)  tklass = TypeKlassPtr::OBJECT;
3647   const TypeOopPtr* oop_type = tklass-&gt;as_instance_type();
3648 
3649   // Now generate allocation code
3650 
3651   // The entire memory state is needed for slow path of the allocation
<span class="line-modified">3652   // since GC and deoptimization can happened.</span>
3653   Node *mem = reset_memory();
3654   set_all_memory(mem); // Create new memory state
3655 
3656   AllocateNode* alloc = new AllocateNode(C, AllocateNode::alloc_type(Type::TOP),
3657                                          control(), mem, i_o(),
3658                                          size, klass_node,
<span class="line-modified">3659                                          initial_slow_test);</span>
3660 
3661   return set_output_for_allocation(alloc, oop_type, deoptimize_on_exception);
3662 }
3663 








3664 //-------------------------------new_array-------------------------------------
<span class="line-modified">3665 // helper for both newarray and anewarray</span>
3666 // The &#39;length&#39; parameter is (obviously) the length of the array.
3667 // See comments on new_instance for the meaning of the other arguments.
3668 Node* GraphKit::new_array(Node* klass_node,     // array klass (maybe variable)
3669                           Node* length,         // number of array elements
3670                           int   nargs,          // number of arguments to push back for uncommon trap
3671                           Node* *return_size_val,
3672                           bool deoptimize_on_exception) {
3673   jint  layout_con = Klass::_lh_neutral_value;
3674   Node* layout_val = get_layout_helper(klass_node, layout_con);
<span class="line-modified">3675   int   layout_is_con = (layout_val == NULL);</span>
3676 
3677   if (!layout_is_con &amp;&amp; !StressReflectiveCode &amp;&amp;
3678       !too_many_traps(Deoptimization::Reason_class_check)) {
3679     // This is a reflective array creation site.
3680     // Optimistically assume that it is a subtype of Object[],
3681     // so that we can fold up all the address arithmetic.
3682     layout_con = Klass::array_layout_helper(T_OBJECT);
3683     Node* cmp_lh = _gvn.transform( new CmpINode(layout_val, intcon(layout_con)) );
3684     Node* bol_lh = _gvn.transform( new BoolNode(cmp_lh, BoolTest::eq) );
3685     { BuildCutout unless(this, bol_lh, PROB_MAX);
3686       inc_sp(nargs);
3687       uncommon_trap(Deoptimization::Reason_class_check,
3688                     Deoptimization::Action_maybe_recompile);
3689     }
3690     layout_val = NULL;
3691     layout_is_con = true;
3692   }
3693 
3694   // Generate the initial go-slow test.  Make sure we do not overflow
3695   // if length is huge (near 2Gig) or negative!  We do not need
3696   // exact double-words here, just a close approximation of needed
3697   // double-words.  We can&#39;t add any offset or rounding bits, lest we
3698   // take a size -1 of bytes and make it positive.  Use an unsigned
3699   // compare, so negative sizes look hugely positive.
3700   int fast_size_limit = FastAllocateSizeLimit;
3701   if (layout_is_con) {
3702     assert(!StressReflectiveCode, &quot;stress mode does not use these paths&quot;);
3703     // Increase the size limit if we have exact knowledge of array type.
3704     int log2_esize = Klass::layout_helper_log2_element_size(layout_con);
<span class="line-modified">3705     fast_size_limit &lt;&lt;= (LogBytesPerLong - log2_esize);</span>
3706   }
3707 
3708   Node* initial_slow_cmp  = _gvn.transform( new CmpUNode( length, intcon( fast_size_limit ) ) );
3709   Node* initial_slow_test = _gvn.transform( new BoolNode( initial_slow_cmp, BoolTest::gt ) );
3710 
3711   // --- Size Computation ---
3712   // array_size = round_to_heap(array_header + (length &lt;&lt; elem_shift));
3713   // where round_to_heap(x) == align_to(x, MinObjAlignmentInBytes)
3714   // and align_to(x, y) == ((x + y-1) &amp; ~(y-1))
3715   // The rounding mask is strength-reduced, if possible.
3716   int round_mask = MinObjAlignmentInBytes - 1;
3717   Node* header_size = NULL;
3718   int   header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);
3719   // (T_BYTE has the weakest alignment and size restrictions...)
3720   if (layout_is_con) {
3721     int       hsize  = Klass::layout_helper_header_size(layout_con);
3722     int       eshift = Klass::layout_helper_log2_element_size(layout_con);
<span class="line-modified">3723     BasicType etype  = Klass::layout_helper_element_type(layout_con);</span>
3724     if ((round_mask &amp; ~right_n_bits(eshift)) == 0)
3725       round_mask = 0;  // strength-reduce it if it goes away completely
<span class="line-modified">3726     assert((hsize &amp; right_n_bits(eshift)) == 0, &quot;hsize is pre-rounded&quot;);</span>
3727     assert(header_size_min &lt;= hsize, &quot;generic minimum is smallest&quot;);
3728     header_size_min = hsize;
3729     header_size = intcon(hsize + round_mask);
3730   } else {
3731     Node* hss   = intcon(Klass::_lh_header_size_shift);
3732     Node* hsm   = intcon(Klass::_lh_header_size_mask);
3733     Node* hsize = _gvn.transform( new URShiftINode(layout_val, hss) );
3734     hsize       = _gvn.transform( new AndINode(hsize, hsm) );
3735     Node* mask  = intcon(round_mask);
3736     header_size = _gvn.transform( new AddINode(hsize, mask) );
3737   }
3738 
3739   Node* elem_shift = NULL;
3740   if (layout_is_con) {
3741     int eshift = Klass::layout_helper_log2_element_size(layout_con);
3742     if (eshift != 0)
3743       elem_shift = intcon(eshift);
3744   } else {
3745     // There is no need to mask or shift this value.
3746     // The semantics of LShiftINode include an implicit mask to 0x1F.
</pre>
<hr />
<pre>
3790   // places, one where the length is sharply limited, and the other
3791   // after a successful allocation.
3792   Node* abody = lengthx;
3793   if (elem_shift != NULL)
3794     abody     = _gvn.transform( new LShiftXNode(lengthx, elem_shift) );
3795   Node* size  = _gvn.transform( new AddXNode(headerx, abody) );
3796   if (round_mask != 0) {
3797     Node* mask = MakeConX(~round_mask);
3798     size       = _gvn.transform( new AndXNode(size, mask) );
3799   }
3800   // else if round_mask == 0, the size computation is self-rounding
3801 
3802   if (return_size_val != NULL) {
3803     // This is the size
3804     (*return_size_val) = size;
3805   }
3806 
3807   // Now generate allocation code
3808 
3809   // The entire memory state is needed for slow path of the allocation
<span class="line-modified">3810   // since GC and deoptimization can happened.</span>
3811   Node *mem = reset_memory();
3812   set_all_memory(mem); // Create new memory state
3813 
3814   if (initial_slow_test-&gt;is_Bool()) {
3815     // Hide it behind a CMoveI, or else PhaseIdealLoop::split_up will get sick.
3816     initial_slow_test = initial_slow_test-&gt;as_Bool()-&gt;as_int_value(&amp;_gvn);
3817   }
3818 
















































































3819   // Create the AllocateArrayNode and its result projections
<span class="line-modified">3820   AllocateArrayNode* alloc</span>
<span class="line-modified">3821     = new AllocateArrayNode(C, AllocateArrayNode::alloc_type(TypeInt::INT),</span>
<span class="line-modified">3822                             control(), mem, i_o(),</span>
<span class="line-modified">3823                             size, klass_node,</span>
<span class="line-modified">3824                             initial_slow_test,</span>
<span class="line-modified">3825                             length);</span>
3826 
3827   // Cast to correct type.  Note that the klass_node may be constant or not,
3828   // and in the latter case the actual array type will be inexact also.
3829   // (This happens via a non-constant argument to inline_native_newArray.)
3830   // In any case, the value of klass_node provides the desired array type.
3831   const TypeInt* length_type = _gvn.find_int_type(length);
<span class="line-removed">3832   const TypeOopPtr* ary_type = _gvn.type(klass_node)-&gt;is_klassptr()-&gt;as_instance_type();</span>
3833   if (ary_type-&gt;isa_aryptr() &amp;&amp; length_type != NULL) {
3834     // Try to get a better type than POS for the size
3835     ary_type = ary_type-&gt;is_aryptr()-&gt;cast_to_size(length_type);
3836   }
3837 
3838   Node* javaoop = set_output_for_allocation(alloc, ary_type, deoptimize_on_exception);
3839 
3840   // Cast length on remaining path to be as narrow as possible
3841   if (map()-&gt;find_edge(length) &gt;= 0) {
3842     Node* ccast = alloc-&gt;make_ideal_length(ary_type, &amp;_gvn);
3843     if (ccast != length) {
3844       _gvn.set_type_bottom(ccast);
3845       record_for_igvn(ccast);
3846       replace_in_map(length, ccast);
3847     }
3848   }
3849 
3850   return javaoop;
3851 }
3852 
</pre>
<hr />
<pre>
3970   set_all_memory(ideal.merged_memory());
3971   set_i_o(ideal.i_o());
3972   set_control(ideal.ctrl());
3973 }
3974 
3975 void GraphKit::final_sync(IdealKit&amp; ideal) {
3976   // Final sync IdealKit and graphKit.
3977   sync_kit(ideal);
3978 }
3979 
3980 Node* GraphKit::load_String_length(Node* str, bool set_ctrl) {
3981   Node* len = load_array_length(load_String_value(str, set_ctrl));
3982   Node* coder = load_String_coder(str, set_ctrl);
3983   // Divide length by 2 if coder is UTF16
3984   return _gvn.transform(new RShiftINode(len, coder));
3985 }
3986 
3987 Node* GraphKit::load_String_value(Node* str, bool set_ctrl) {
3988   int value_offset = java_lang_String::value_offset_in_bytes();
3989   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
<span class="line-modified">3990                                                      false, NULL, 0);</span>
3991   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
3992   const TypeAryPtr* value_type = TypeAryPtr::make(TypePtr::NotNull,
<span class="line-modified">3993                                                   TypeAry::make(TypeInt::BYTE, TypeInt::POS),</span>
<span class="line-modified">3994                                                   ciTypeArrayKlass::make(T_BYTE), true, 0);</span>
3995   Node* p = basic_plus_adr(str, str, value_offset);
3996   Node* load = access_load_at(str, p, value_field_type, value_type, T_OBJECT,
3997                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
3998   return load;
3999 }
4000 
4001 Node* GraphKit::load_String_coder(Node* str, bool set_ctrl) {
4002   if (!CompactStrings) {
4003     return intcon(java_lang_String::CODER_UTF16);
4004   }
4005   int coder_offset = java_lang_String::coder_offset_in_bytes();
4006   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
<span class="line-modified">4007                                                      false, NULL, 0);</span>
4008   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4009 
4010   Node* p = basic_plus_adr(str, str, coder_offset);
4011   Node* load = access_load_at(str, p, coder_field_type, TypeInt::BYTE, T_BYTE,
4012                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
4013   return load;
4014 }
4015 
4016 void GraphKit::store_String_value(Node* str, Node* value) {
4017   int value_offset = java_lang_String::value_offset_in_bytes();
4018   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
<span class="line-modified">4019                                                      false, NULL, 0);</span>
4020   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
4021 
4022   access_store_at(str,  basic_plus_adr(str, value_offset), value_field_type,
4023                   value, TypeAryPtr::BYTES, T_OBJECT, IN_HEAP | MO_UNORDERED);
4024 }
4025 
4026 void GraphKit::store_String_coder(Node* str, Node* value) {
4027   int coder_offset = java_lang_String::coder_offset_in_bytes();
4028   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
<span class="line-modified">4029                                                      false, NULL, 0);</span>
4030   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4031 
4032   access_store_at(str, basic_plus_adr(str, coder_offset), coder_field_type,
4033                   value, TypeInt::BYTE, T_BYTE, IN_HEAP | MO_UNORDERED);
4034 }
4035 
4036 // Capture src and dst memory state with a MergeMemNode
4037 Node* GraphKit::capture_memory(const TypePtr* src_type, const TypePtr* dst_type) {
4038   if (src_type == dst_type) {
4039     // Types are equal, we don&#39;t need a MergeMemNode
4040     return memory(src_type);
4041   }
4042   MergeMemNode* merge = MergeMemNode::make(map()-&gt;memory());
4043   record_for_igvn(merge); // fold it up later, if possible
4044   int src_idx = C-&gt;get_alias_index(src_type);
4045   int dst_idx = C-&gt;get_alias_index(dst_type);
4046   merge-&gt;set_memory_at(src_idx, memory(src_idx));
4047   merge-&gt;set_memory_at(dst_idx, memory(dst_idx));
4048   return merge;
4049 }
</pre>
<hr />
<pre>
4120   i_char-&gt;init_req(2, AddI(i_char, intcon(2)));
4121 
4122   set_control(IfFalse(iff));
4123   set_memory(st, TypeAryPtr::BYTES);
4124 }
4125 
4126 Node* GraphKit::make_constant_from_field(ciField* field, Node* obj) {
4127   if (!field-&gt;is_constant()) {
4128     return NULL; // Field not marked as constant.
4129   }
4130   ciInstance* holder = NULL;
4131   if (!field-&gt;is_static()) {
4132     ciObject* const_oop = obj-&gt;bottom_type()-&gt;is_oopptr()-&gt;const_oop();
4133     if (const_oop != NULL &amp;&amp; const_oop-&gt;is_instance()) {
4134       holder = const_oop-&gt;as_instance();
4135     }
4136   }
4137   const Type* con_type = Type::make_constant_from_field(field, holder, field-&gt;layout_type(),
4138                                                         /*is_unsigned_load=*/false);
4139   if (con_type != NULL) {
<span class="line-modified">4140     return makecon(con_type);</span>





4141   }
4142   return NULL;
4143 }









</pre>
</td>
<td>
<hr />
<pre>
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciUtilities.hpp&quot;
  27 #include &quot;compiler/compileLog.hpp&quot;
<span class="line-added">  28 #include &quot;ci/ciValueKlass.hpp&quot;</span>
  29 #include &quot;gc/shared/barrierSet.hpp&quot;
  30 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  31 #include &quot;interpreter/interpreter.hpp&quot;
  32 #include &quot;memory/resourceArea.hpp&quot;
  33 #include &quot;opto/addnode.hpp&quot;
  34 #include &quot;opto/castnode.hpp&quot;
  35 #include &quot;opto/convertnode.hpp&quot;
  36 #include &quot;opto/graphKit.hpp&quot;
  37 #include &quot;opto/idealKit.hpp&quot;
  38 #include &quot;opto/intrinsicnode.hpp&quot;
  39 #include &quot;opto/locknode.hpp&quot;
  40 #include &quot;opto/machnode.hpp&quot;
<span class="line-added">  41 #include &quot;opto/narrowptrnode.hpp&quot;</span>
  42 #include &quot;opto/opaquenode.hpp&quot;
  43 #include &quot;opto/parse.hpp&quot;
  44 #include &quot;opto/rootnode.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/subtypenode.hpp&quot;
<span class="line-added">  47 #include &quot;opto/valuetypenode.hpp&quot;</span>
  48 #include &quot;runtime/deoptimization.hpp&quot;
  49 #include &quot;runtime/sharedRuntime.hpp&quot;
  50 #include &quot;utilities/bitMap.inline.hpp&quot;
  51 #include &quot;utilities/powerOfTwo.hpp&quot;
  52 
  53 //----------------------------GraphKit-----------------------------------------
  54 // Main utility constructor.
<span class="line-modified">  55 GraphKit::GraphKit(JVMState* jvms, PhaseGVN* gvn)</span>
  56   : Phase(Phase::Parser),
  57     _env(C-&gt;env()),
<span class="line-modified">  58     _gvn((gvn != NULL) ? *gvn : *C-&gt;initial_gvn()),</span>
  59     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
  60 {
<span class="line-added">  61   assert(gvn == NULL || !gvn-&gt;is_IterGVN() || gvn-&gt;is_IterGVN()-&gt;delay_transform(), &quot;delay transform should be enabled&quot;);</span>
  62   _exceptions = jvms-&gt;map()-&gt;next_exception();
  63   if (_exceptions != NULL)  jvms-&gt;map()-&gt;set_next_exception(NULL);
  64   set_jvms(jvms);
<span class="line-added">  65 #ifdef ASSERT</span>
<span class="line-added">  66   if (_gvn.is_IterGVN() != NULL) {</span>
<span class="line-added">  67     assert(_gvn.is_IterGVN()-&gt;delay_transform(), &quot;Transformation must be delayed if IterGVN is used&quot;);</span>
<span class="line-added">  68     // Save the initial size of _for_igvn worklist for verification (see ~GraphKit)</span>
<span class="line-added">  69     _worklist_size = _gvn.C-&gt;for_igvn()-&gt;size();</span>
<span class="line-added">  70   }</span>
<span class="line-added">  71 #endif</span>
  72 }
  73 
  74 // Private constructor for parser.
  75 GraphKit::GraphKit()
  76   : Phase(Phase::Parser),
  77     _env(C-&gt;env()),
  78     _gvn(*C-&gt;initial_gvn()),
  79     _barrier_set(BarrierSet::barrier_set()-&gt;barrier_set_c2())
  80 {
  81   _exceptions = NULL;
  82   set_map(NULL);
  83   debug_only(_sp = -99);
  84   debug_only(set_bci(-99));
  85 }
  86 
  87 
  88 
  89 //---------------------------clean_stack---------------------------------------
  90 // Clear away rubbish from the stack area of the JVM state.
  91 // This destroys any arguments that may be waiting on the stack.
</pre>
<hr />
<pre>
 820           tty-&gt;print_cr(&quot;Zombie local %d: &quot;, local);
 821           jvms-&gt;dump();
 822         }
 823         return false;
 824       }
 825     }
 826   }
 827   return true;
 828 }
 829 
 830 #endif //ASSERT
 831 
 832 // Helper function for enforcing certain bytecodes to reexecute if
 833 // deoptimization happens
 834 static bool should_reexecute_implied_by_bytecode(JVMState *jvms, bool is_anewarray) {
 835   ciMethod* cur_method = jvms-&gt;method();
 836   int       cur_bci   = jvms-&gt;bci();
 837   if (cur_method != NULL &amp;&amp; cur_bci != InvocationEntryBci) {
 838     Bytecodes::Code code = cur_method-&gt;java_code_at_bci(cur_bci);
 839     return Interpreter::bytecode_should_reexecute(code) ||
<span class="line-modified"> 840            (is_anewarray &amp;&amp; (code == Bytecodes::_multianewarray));</span>
 841     // Reexecute _multianewarray bytecode which was replaced with
 842     // sequence of [a]newarray. See Parse::do_multianewarray().
 843     //
 844     // Note: interpreter should not have it set since this optimization
 845     // is limited by dimensions and guarded by flag so in some cases
 846     // multianewarray() runtime calls will be generated and
 847     // the bytecode should not be reexecutes (stack will not be reset).
<span class="line-modified"> 848   } else {</span>
 849     return false;
<span class="line-added"> 850   }</span>
 851 }
 852 
 853 // Helper function for adding JVMState and debug information to node
 854 void GraphKit::add_safepoint_edges(SafePointNode* call, bool must_throw) {
 855   // Add the safepoint edges to the call (or other safepoint).
 856 
 857   // Make sure dead locals are set to top.  This
 858   // should help register allocation time and cut down on the size
 859   // of the deoptimization information.
 860   assert(dead_locals_are_killed(), &quot;garbage in debug info before safepoint&quot;);
 861 
 862   // Walk the inline list to fill in the correct set of JVMState&#39;s
 863   // Also fill in the associated edges for each JVMState.
 864 
 865   // If the bytecode needs to be reexecuted we need to put
 866   // the arguments back on the stack.
 867   const bool should_reexecute = jvms()-&gt;should_reexecute();
 868   JVMState* youngest_jvms = should_reexecute ? sync_jvms_for_reexecute() : sync_jvms();
 869 
 870   // NOTE: set_bci (called from sync_jvms) might reset the reexecute bit to
</pre>
<hr />
<pre>
1074       ciSignature* declared_signature = NULL;
1075       ciMethod* ignored_callee = method()-&gt;get_method_at_bci(bci(), ignored_will_link, &amp;declared_signature);
1076       assert(declared_signature != NULL, &quot;cannot be null&quot;);
1077       inputs   = declared_signature-&gt;arg_size_for_bc(code);
1078       int size = declared_signature-&gt;return_type()-&gt;size();
1079       depth = size - inputs;
1080     }
1081     break;
1082 
1083   case Bytecodes::_multianewarray:
1084     {
1085       ciBytecodeStream iter(method());
1086       iter.reset_to_bci(bci());
1087       iter.next();
1088       inputs = iter.get_dimensions();
1089       assert(rsize == 1, &quot;&quot;);
1090       depth = rsize - inputs;
1091     }
1092     break;
1093 
<span class="line-added">1094   case Bytecodes::_withfield: {</span>
<span class="line-added">1095     bool ignored_will_link;</span>
<span class="line-added">1096     ciField* field = method()-&gt;get_field_at_bci(bci(), ignored_will_link);</span>
<span class="line-added">1097     int      size  = field-&gt;type()-&gt;size();</span>
<span class="line-added">1098     inputs = size+1;</span>
<span class="line-added">1099     depth = rsize - inputs;</span>
<span class="line-added">1100     break;</span>
<span class="line-added">1101   }</span>
<span class="line-added">1102 </span>
1103   case Bytecodes::_ireturn:
1104   case Bytecodes::_lreturn:
1105   case Bytecodes::_freturn:
1106   case Bytecodes::_dreturn:
1107   case Bytecodes::_areturn:
1108     assert(rsize == -depth, &quot;&quot;);
1109     inputs = rsize;
1110     break;
1111 
1112   case Bytecodes::_jsr:
1113   case Bytecodes::_jsr_w:
1114     inputs = 0;
1115     depth  = 1;                  // S.B. depth=1, not zero
1116     break;
1117 
1118   default:
1119     // bytecode produces a typed result
1120     inputs = rsize - depth;
1121     assert(inputs &gt;= 0, &quot;&quot;);
1122     break;
</pre>
<hr />
<pre>
1165   Node* conv = _gvn.transform( new ConvI2LNode(offset));
1166   Node* mask = _gvn.transform(ConLNode::make((julong) max_juint));
1167   return _gvn.transform( new AndLNode(conv, mask) );
1168 }
1169 
1170 Node* GraphKit::ConvL2I(Node* offset) {
1171   // short-circuit a common case
1172   jlong offset_con = find_long_con(offset, (jlong)Type::OffsetBot);
1173   if (offset_con != (jlong)Type::OffsetBot) {
1174     return intcon((int) offset_con);
1175   }
1176   return _gvn.transform( new ConvL2INode(offset));
1177 }
1178 
1179 //-------------------------load_object_klass-----------------------------------
1180 Node* GraphKit::load_object_klass(Node* obj) {
1181   // Special-case a fresh allocation to avoid building nodes:
1182   Node* akls = AllocateNode::Ideal_klass(obj, &amp;_gvn);
1183   if (akls != NULL)  return akls;
1184   Node* k_adr = basic_plus_adr(obj, oopDesc::klass_offset_in_bytes());
<span class="line-modified">1185   return _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), k_adr, TypeInstPtr::KLASS, TypeKlassPtr::OBJECT));</span>
1186 }
1187 
1188 //-------------------------load_array_length-----------------------------------
1189 Node* GraphKit::load_array_length(Node* array) {
1190   // Special-case a fresh allocation to avoid building nodes:
1191   AllocateArrayNode* alloc = AllocateArrayNode::Ideal_array_allocation(array, &amp;_gvn);
1192   Node *alen;
1193   if (alloc == NULL) {
1194     Node *r_adr = basic_plus_adr(array, arrayOopDesc::length_offset_in_bytes());
1195     alen = _gvn.transform( new LoadRangeNode(0, immutable_memory(), r_adr, TypeInt::POS));
1196   } else {
1197     alen = alloc-&gt;Ideal_length();
1198     Node* ccast = alloc-&gt;make_ideal_length(_gvn.type(array)-&gt;is_oopptr(), &amp;_gvn);
1199     if (ccast != alen) {
1200       alen = _gvn.transform(ccast);
1201     }
1202   }
1203   return alen;
1204 }
1205 
</pre>
<hr />
<pre>
1208 // the incoming address with NULL casted away.  You are allowed to use the
1209 // not-null value only if you are control dependent on the test.
1210 #ifndef PRODUCT
1211 extern int explicit_null_checks_inserted,
1212            explicit_null_checks_elided;
1213 #endif
1214 Node* GraphKit::null_check_common(Node* value, BasicType type,
1215                                   // optional arguments for variations:
1216                                   bool assert_null,
1217                                   Node* *null_control,
1218                                   bool speculative) {
1219   assert(!assert_null || null_control == NULL, &quot;not both at once&quot;);
1220   if (stopped())  return top();
1221   NOT_PRODUCT(explicit_null_checks_inserted++);
1222 
1223   // Construct NULL check
1224   Node *chk = NULL;
1225   switch(type) {
1226     case T_LONG   : chk = new CmpLNode(value, _gvn.zerocon(T_LONG)); break;
1227     case T_INT    : chk = new CmpINode(value, _gvn.intcon(0)); break;
<span class="line-added">1228     case T_VALUETYPE : // fall through</span>
1229     case T_ARRAY  : // fall through
1230       type = T_OBJECT;  // simplify further tests
1231     case T_OBJECT : {
1232       const Type *t = _gvn.type( value );
1233 
1234       const TypeOopPtr* tp = t-&gt;isa_oopptr();
1235       if (tp != NULL &amp;&amp; tp-&gt;klass() != NULL &amp;&amp; !tp-&gt;klass()-&gt;is_loaded()
1236           // Only for do_null_check, not any of its siblings:
1237           &amp;&amp; !assert_null &amp;&amp; null_control == NULL) {
1238         // Usually, any field access or invocation on an unloaded oop type
1239         // will simply fail to link, since the statically linked class is
1240         // likely also to be unloaded.  However, in -Xcomp mode, sometimes
1241         // the static class is loaded but the sharper oop type is not.
1242         // Rather than checking for this obscure case in lots of places,
1243         // we simply observe that a null check on an unloaded class
1244         // will always be followed by a nonsense operation, so we
1245         // can just issue the uncommon trap here.
1246         // Our access to the unloaded class will only be correct
1247         // after it has been loaded and initialized, which requires
1248         // a trip through the interpreter.
</pre>
<hr />
<pre>
1380   }
1381 
1382   if (assert_null) {
1383     // Cast obj to null on this path.
1384     replace_in_map(value, zerocon(type));
1385     return zerocon(type);
1386   }
1387 
1388   // Cast obj to not-null on this path, if there is no null_control.
1389   // (If there is a null_control, a non-null value may come back to haunt us.)
1390   if (type == T_OBJECT) {
1391     Node* cast = cast_not_null(value, false);
1392     if (null_control == NULL || (*null_control) == top())
1393       replace_in_map(value, cast);
1394     value = cast;
1395   }
1396 
1397   return value;
1398 }
1399 
<span class="line-added">1400 Node* GraphKit::null2default(Node* value, ciValueKlass* vk) {</span>
<span class="line-added">1401   Node* null_ctl = top();</span>
<span class="line-added">1402   value = null_check_oop(value, &amp;null_ctl);</span>
<span class="line-added">1403   if (!null_ctl-&gt;is_top()) {</span>
<span class="line-added">1404     // Return default value if oop is null</span>
<span class="line-added">1405     Node* region = new RegionNode(3);</span>
<span class="line-added">1406     region-&gt;init_req(1, control());</span>
<span class="line-added">1407     region-&gt;init_req(2, null_ctl);</span>
<span class="line-added">1408     value = PhiNode::make(region, value, TypeInstPtr::make(TypePtr::BotPTR, vk));</span>
<span class="line-added">1409     value-&gt;set_req(2, ValueTypeNode::default_oop(gvn(), vk));</span>
<span class="line-added">1410     set_control(gvn().transform(region));</span>
<span class="line-added">1411     value = gvn().transform(value);</span>
<span class="line-added">1412   }</span>
<span class="line-added">1413   return value;</span>
<span class="line-added">1414 }</span>
1415 
1416 //------------------------------cast_not_null----------------------------------
1417 // Cast obj to not-null on this path
1418 Node* GraphKit::cast_not_null(Node* obj, bool do_replace_in_map) {
<span class="line-added">1419   if (obj-&gt;is_ValueType()) {</span>
<span class="line-added">1420     return obj;</span>
<span class="line-added">1421   }</span>
1422   const Type *t = _gvn.type(obj);
1423   const Type *t_not_null = t-&gt;join_speculative(TypePtr::NOTNULL);
1424   // Object is already not-null?
1425   if( t == t_not_null ) return obj;
1426 
1427   Node *cast = new CastPPNode(obj,t_not_null);
1428   cast-&gt;init_req(0, control());
1429   cast = _gvn.transform( cast );
1430 
1431   // Scan for instances of &#39;obj&#39; in the current JVM mapping.
1432   // These instances are known to be not-null after the test.
1433   if (do_replace_in_map)
1434     replace_in_map(obj, cast);
1435 
1436   return cast;                  // Return casted value
1437 }
1438 
1439 // Sometimes in intrinsics, we implicitly know an object is not null
1440 // (there&#39;s no actual null check) so we can cast it to not null. In
1441 // the course of optimizations, the input to the cast can become null.
</pre>
<hr />
<pre>
1534                           MemNode::MemOrd mo,
1535                           LoadNode::ControlDependency control_dependency,
1536                           bool require_atomic_access,
1537                           bool unaligned,
1538                           bool mismatched,
1539                           bool unsafe,
1540                           uint8_t barrier_data) {
1541   assert(adr_idx != Compile::AliasIdxTop, &quot;use other make_load factory&quot; );
1542   const TypePtr* adr_type = NULL; // debug-mode-only argument
1543   debug_only(adr_type = C-&gt;get_adr_type(adr_idx));
1544   Node* mem = memory(adr_idx);
1545   Node* ld;
1546   if (require_atomic_access &amp;&amp; bt == T_LONG) {
1547     ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);
1548   } else if (require_atomic_access &amp;&amp; bt == T_DOUBLE) {
1549     ld = LoadDNode::make_atomic(ctl, mem, adr, adr_type, t, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);
1550   } else {
1551     ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo, control_dependency, unaligned, mismatched, unsafe, barrier_data);
1552   }
1553   ld = _gvn.transform(ld);
<span class="line-modified">1554 </span>
<span class="line-added">1555   if (((bt == T_OBJECT || bt == T_VALUETYPE) &amp;&amp; C-&gt;do_escape_analysis()) || C-&gt;eliminate_boxing()) {</span>
1556     // Improve graph before escape analysis and boxing elimination.
1557     record_for_igvn(ld);
1558   }
1559   return ld;
1560 }
1561 
1562 Node* GraphKit::store_to_memory(Node* ctl, Node* adr, Node *val, BasicType bt,
1563                                 int adr_idx,
1564                                 MemNode::MemOrd mo,
1565                                 bool require_atomic_access,
1566                                 bool unaligned,
1567                                 bool mismatched,
1568                                 bool unsafe) {
1569   assert(adr_idx != Compile::AliasIdxTop, &quot;use other store_to_memory factory&quot; );
1570   const TypePtr* adr_type = NULL;
1571   debug_only(adr_type = C-&gt;get_adr_type(adr_idx));
1572   Node *mem = memory(adr_idx);
1573   Node* st;
1574   if (require_atomic_access &amp;&amp; bt == T_LONG) {
1575     st = StoreLNode::make_atomic(ctl, mem, adr, adr_type, val, mo);
</pre>
<hr />
<pre>
1586   }
1587   if (unsafe) {
1588     st-&gt;as_Store()-&gt;set_unsafe_access();
1589   }
1590   st = _gvn.transform(st);
1591   set_memory(st, adr_idx);
1592   // Back-to-back stores can only remove intermediate store with DU info
1593   // so push on worklist for optimizer.
1594   if (mem-&gt;req() &gt; MemNode::Address &amp;&amp; adr == mem-&gt;in(MemNode::Address))
1595     record_for_igvn(st);
1596 
1597   return st;
1598 }
1599 
1600 Node* GraphKit::access_store_at(Node* obj,
1601                                 Node* adr,
1602                                 const TypePtr* adr_type,
1603                                 Node* val,
1604                                 const Type* val_type,
1605                                 BasicType bt,
<span class="line-modified">1606                                 DecoratorSet decorators,</span>
<span class="line-added">1607                                 bool safe_for_replace) {</span>
1608   // Transformation of a value which could be NULL pointer (CastPP #NULL)
1609   // could be delayed during Parse (for example, in adjust_map_after_if()).
1610   // Execute transformation here to avoid barrier generation in such case.
1611   if (_gvn.type(val) == TypePtr::NULL_PTR) {
1612     val = _gvn.makecon(TypePtr::NULL_PTR);
1613   }
1614 
1615   if (stopped()) {
1616     return top(); // Dead path ?
1617   }
1618 
1619   assert(val != NULL, &quot;not dead path&quot;);
<span class="line-added">1620   if (val-&gt;is_ValueType()) {</span>
<span class="line-added">1621     // Store to non-flattened field. Buffer the inline type and make sure</span>
<span class="line-added">1622     // the store is re-executed if the allocation triggers deoptimization.</span>
<span class="line-added">1623     PreserveReexecuteState preexecs(this);</span>
<span class="line-added">1624     jvms()-&gt;set_should_reexecute(true);</span>
<span class="line-added">1625     val = val-&gt;as_ValueType()-&gt;allocate(this, safe_for_replace)-&gt;get_oop();</span>
<span class="line-added">1626   }</span>
1627 
1628   C2AccessValuePtr addr(adr, adr_type);
1629   C2AccessValue value(val, val_type);
1630   C2ParseAccess access(this, decorators | C2_WRITE_ACCESS, bt, obj, addr);
1631   if (access.is_raw()) {
1632     return _barrier_set-&gt;BarrierSetC2::store_at(access, value);
1633   } else {
1634     return _barrier_set-&gt;store_at(access, value);
1635   }
1636 }
1637 
1638 Node* GraphKit::access_load_at(Node* obj,   // containing obj
1639                                Node* adr,   // actual adress to store val at
1640                                const TypePtr* adr_type,
1641                                const Type* val_type,
1642                                BasicType bt,
<span class="line-modified">1643                                DecoratorSet decorators,</span>
<span class="line-added">1644                                Node* ctl) {</span>
1645   if (stopped()) {
1646     return top(); // Dead path ?
1647   }
1648 
1649   C2AccessValuePtr addr(adr, adr_type);
<span class="line-modified">1650   C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, obj, addr, ctl);</span>
1651   if (access.is_raw()) {
1652     return _barrier_set-&gt;BarrierSetC2::load_at(access, val_type);
1653   } else {
1654     return _barrier_set-&gt;load_at(access, val_type);
1655   }
1656 }
1657 
1658 Node* GraphKit::access_load(Node* adr,   // actual adress to load val at
1659                             const Type* val_type,
1660                             BasicType bt,
1661                             DecoratorSet decorators) {
1662   if (stopped()) {
1663     return top(); // Dead path ?
1664   }
1665 
1666   C2AccessValuePtr addr(adr, NULL);
1667   C2ParseAccess access(this, decorators | C2_READ_ACCESS, bt, NULL, addr);
1668   if (access.is_raw()) {
1669     return _barrier_set-&gt;BarrierSetC2::load_at(access, val_type);
1670   } else {
</pre>
<hr />
<pre>
1728   }
1729 }
1730 
1731 Node* GraphKit::access_atomic_add_at(Node* obj,
1732                                      Node* adr,
1733                                      const TypePtr* adr_type,
1734                                      int alias_idx,
1735                                      Node* new_val,
1736                                      const Type* value_type,
1737                                      BasicType bt,
1738                                      DecoratorSet decorators) {
1739   C2AccessValuePtr addr(adr, adr_type);
1740   C2AtomicParseAccess access(this, decorators | C2_READ_ACCESS | C2_WRITE_ACCESS, bt, obj, addr, alias_idx);
1741   if (access.is_raw()) {
1742     return _barrier_set-&gt;BarrierSetC2::atomic_add_at(access, new_val, value_type);
1743   } else {
1744     return _barrier_set-&gt;atomic_add_at(access, new_val, value_type);
1745   }
1746 }
1747 
<span class="line-modified">1748 void GraphKit::access_clone(Node* src_base, Node* dst_base, Node* countx, bool is_array) {</span>
<span class="line-modified">1749   return _barrier_set-&gt;clone(this, src_base, dst_base, countx, is_array);</span>
1750 }
1751 
1752 //-------------------------array_element_address-------------------------
1753 Node* GraphKit::array_element_address(Node* ary, Node* idx, BasicType elembt,
1754                                       const TypeInt* sizetype, Node* ctrl) {
1755   uint shift  = exact_log2(type2aelembytes(elembt));
<span class="line-added">1756   ciKlass* arytype_klass = _gvn.type(ary)-&gt;is_aryptr()-&gt;klass();</span>
<span class="line-added">1757   if (arytype_klass != NULL &amp;&amp; arytype_klass-&gt;is_value_array_klass()) {</span>
<span class="line-added">1758     ciValueArrayKlass* vak = arytype_klass-&gt;as_value_array_klass();</span>
<span class="line-added">1759     shift = vak-&gt;log2_element_size();</span>
<span class="line-added">1760   }</span>
1761   uint header = arrayOopDesc::base_offset_in_bytes(elembt);
1762 
1763   // short-circuit a common case (saves lots of confusing waste motion)
1764   jint idx_con = find_int_con(idx, -1);
1765   if (idx_con &gt;= 0) {
1766     intptr_t offset = header + ((intptr_t)idx_con &lt;&lt; shift);
1767     return basic_plus_adr(ary, offset);
1768   }
1769 
1770   // must be correct type for alignment purposes
1771   Node* base  = basic_plus_adr(ary, header);
1772   idx = Compile::conv_I2X_index(&amp;_gvn, idx, sizetype, ctrl);
1773   Node* scale = _gvn.transform( new LShiftXNode(idx, intcon(shift)) );
1774   return basic_plus_adr(ary, base, scale);
1775 }
1776 
1777 //-------------------------load_array_element-------------------------
1778 Node* GraphKit::load_array_element(Node* ctl, Node* ary, Node* idx, const TypeAryPtr* arytype) {
1779   const Type* elemtype = arytype-&gt;elem();
1780   BasicType elembt = elemtype-&gt;array_element_basic_type();
<span class="line-added">1781   assert(elembt != T_VALUETYPE, &quot;value types are not supported by this method&quot;);</span>
1782   Node* adr = array_element_address(ary, idx, elembt, arytype-&gt;size());
1783   if (elembt == T_NARROWOOP) {
1784     elembt = T_OBJECT; // To satisfy switch in LoadNode::make()
1785   }
1786   Node* ld = make_load(ctl, adr, elemtype, elembt, arytype, MemNode::unordered);
1787   return ld;
1788 }
1789 
1790 //-------------------------set_arguments_for_java_call-------------------------
1791 // Arguments (pre-popped from the stack) are taken from the JVMS.
<span class="line-modified">1792 void GraphKit::set_arguments_for_java_call(CallJavaNode* call, bool is_late_inline) {</span>
<span class="line-modified">1793   PreserveReexecuteState preexecs(this);</span>
<span class="line-modified">1794   if (EnableValhalla) {</span>
<span class="line-modified">1795     // Make sure the call is re-executed, if buffering of value type arguments triggers deoptimization</span>
<span class="line-modified">1796     jvms()-&gt;set_should_reexecute(true);</span>
<span class="line-modified">1797     int arg_size = method()-&gt;get_declared_signature_at_bci(bci())-&gt;arg_size_for_bc(java_bc());</span>
<span class="line-added">1798     inc_sp(arg_size);</span>
<span class="line-added">1799   }</span>
<span class="line-added">1800   // Add the call arguments</span>
<span class="line-added">1801   const TypeTuple* domain = call-&gt;tf()-&gt;domain_sig();</span>
<span class="line-added">1802   ExtendedSignature sig_cc = ExtendedSignature(call-&gt;method()-&gt;get_sig_cc(), SigEntryFilter());</span>
<span class="line-added">1803   uint nargs = domain-&gt;cnt();</span>
<span class="line-added">1804   for (uint i = TypeFunc::Parms, idx = TypeFunc::Parms; i &lt; nargs; i++) {</span>
<span class="line-added">1805     Node* arg = argument(i-TypeFunc::Parms);</span>
<span class="line-added">1806     const Type* t = domain-&gt;field_at(i);</span>
<span class="line-added">1807     if (call-&gt;method()-&gt;has_scalarized_args() &amp;&amp; t-&gt;is_valuetypeptr() &amp;&amp; !t-&gt;maybe_null()) {</span>
<span class="line-added">1808       // We don&#39;t pass value type arguments by reference but instead pass each field of the value type</span>
<span class="line-added">1809       ValueTypeNode* vt = arg-&gt;as_ValueType();</span>
<span class="line-added">1810       vt-&gt;pass_fields(this, call, sig_cc, idx);</span>
<span class="line-added">1811       // If a value type argument is passed as fields, attach the Method* to the call site</span>
<span class="line-added">1812       // to be able to access the extended signature later via attached_method_before_pc().</span>
<span class="line-added">1813       // For example, see CompiledMethod::preserve_callee_argument_oops().</span>
<span class="line-added">1814       call-&gt;set_override_symbolic_info(true);</span>
<span class="line-added">1815       continue;</span>
<span class="line-added">1816     } else if (arg-&gt;is_ValueType()) {</span>
<span class="line-added">1817       // Pass value type argument via oop to callee</span>
<span class="line-added">1818       if (is_late_inline) {</span>
<span class="line-added">1819         arg = ValueTypePtrNode::make_from_value_type(this, arg-&gt;as_ValueType());</span>
<span class="line-added">1820       } else {</span>
<span class="line-added">1821         arg = arg-&gt;as_ValueType()-&gt;allocate(this)-&gt;get_oop();</span>
<span class="line-added">1822       }</span>
<span class="line-added">1823     }</span>
<span class="line-added">1824     call-&gt;init_req(idx++, arg);</span>
<span class="line-added">1825     // Skip reserved arguments</span>
<span class="line-added">1826     BasicType bt = t-&gt;basic_type();</span>
<span class="line-added">1827     while (SigEntry::next_is_reserved(sig_cc, bt, true)) {</span>
<span class="line-added">1828       call-&gt;init_req(idx++, top());</span>
<span class="line-added">1829       if (type2size[bt] == 2) {</span>
<span class="line-added">1830         call-&gt;init_req(idx++, top());</span>
<span class="line-added">1831       }</span>
<span class="line-added">1832     }</span>
1833   }
1834 }
1835 
1836 //---------------------------set_edges_for_java_call---------------------------
1837 // Connect a newly created call into the current JVMS.
1838 // A return value node (if any) is returned from set_edges_for_java_call.
1839 void GraphKit::set_edges_for_java_call(CallJavaNode* call, bool must_throw, bool separate_io_proj) {
1840 
1841   // Add the predefined inputs:
1842   call-&gt;init_req( TypeFunc::Control, control() );
1843   call-&gt;init_req( TypeFunc::I_O    , i_o() );
1844   call-&gt;init_req( TypeFunc::Memory , reset_memory() );
1845   call-&gt;init_req( TypeFunc::FramePtr, frameptr() );
1846   call-&gt;init_req( TypeFunc::ReturnAdr, top() );
1847 
1848   add_safepoint_edges(call, must_throw);
1849 
1850   Node* xcall = _gvn.transform(call);
1851 
1852   if (xcall == top()) {
1853     set_control(top());
1854     return;
1855   }
1856   assert(xcall == call, &quot;call identity is stable&quot;);
1857 
1858   // Re-use the current map to produce the result.
1859 
1860   set_control(_gvn.transform(new ProjNode(call, TypeFunc::Control)));
1861   set_i_o(    _gvn.transform(new ProjNode(call, TypeFunc::I_O    , separate_io_proj)));
1862   set_all_memory_call(xcall, separate_io_proj);
1863 
1864   //return xcall;   // no need, caller already has it
1865 }
1866 
1867 Node* GraphKit::set_results_for_java_call(CallJavaNode* call, bool separate_io_proj, bool deoptimize) {
1868   if (stopped())  return top();  // maybe the call folded up?
1869 







1870   // Note:  Since any out-of-line call can produce an exception,
1871   // we always insert an I_O projection from the call into the result.
1872 
1873   make_slow_call_ex(call, env()-&gt;Throwable_klass(), separate_io_proj, deoptimize);
1874 
1875   if (separate_io_proj) {
1876     // The caller requested separate projections be used by the fall
1877     // through and exceptional paths, so replace the projections for
1878     // the fall through path.
1879     set_i_o(_gvn.transform( new ProjNode(call, TypeFunc::I_O) ));
1880     set_all_memory(_gvn.transform( new ProjNode(call, TypeFunc::Memory) ));
1881   }
<span class="line-added">1882 </span>
<span class="line-added">1883   // Capture the return value, if any.</span>
<span class="line-added">1884   Node* ret;</span>
<span class="line-added">1885   if (call-&gt;method() == NULL || call-&gt;method()-&gt;return_type()-&gt;basic_type() == T_VOID) {</span>
<span class="line-added">1886     ret = top();</span>
<span class="line-added">1887   } else if (call-&gt;tf()-&gt;returns_value_type_as_fields()) {</span>
<span class="line-added">1888     // Return of multiple values (value type fields): we create a</span>
<span class="line-added">1889     // ValueType node, each field is a projection from the call.</span>
<span class="line-added">1890     ciValueKlass* vk = call-&gt;method()-&gt;return_type()-&gt;as_value_klass();</span>
<span class="line-added">1891     const Array&lt;SigEntry&gt;* sig_array = vk-&gt;extended_sig();</span>
<span class="line-added">1892     GrowableArray&lt;SigEntry&gt; sig = GrowableArray&lt;SigEntry&gt;(sig_array-&gt;length());</span>
<span class="line-added">1893     sig.appendAll(sig_array);</span>
<span class="line-added">1894     ExtendedSignature sig_cc = ExtendedSignature(&amp;sig, SigEntryFilter());</span>
<span class="line-added">1895     uint base_input = TypeFunc::Parms + 1;</span>
<span class="line-added">1896     ret = ValueTypeNode::make_from_multi(this, call, sig_cc, vk, base_input, false);</span>
<span class="line-added">1897   } else {</span>
<span class="line-added">1898     ret = _gvn.transform(new ProjNode(call, TypeFunc::Parms));</span>
<span class="line-added">1899   }</span>
<span class="line-added">1900 </span>
1901   return ret;
1902 }
1903 
1904 //--------------------set_predefined_input_for_runtime_call--------------------
1905 // Reading and setting the memory state is way conservative here.
1906 // The real problem is that I am not doing real Type analysis on memory,
1907 // so I cannot distinguish card mark stores from other stores.  Across a GC
1908 // point the Store Barrier and the card mark memory has to agree.  I cannot
1909 // have a card mark store and its barrier split across the GC point from
1910 // either above or below.  Here I get that to happen by reading ALL of memory.
1911 // A better answer would be to separate out card marks from other memory.
1912 // For now, return the input memory state, so that it can be reused
1913 // after the call, if this call has restricted memory effects.
1914 Node* GraphKit::set_predefined_input_for_runtime_call(SafePointNode* call, Node* narrow_mem) {
1915   // Set fixed predefined input arguments
1916   Node* memory = reset_memory();
1917   Node* m = narrow_mem == NULL ? memory : narrow_mem;
1918   call-&gt;init_req( TypeFunc::Control,   control()  );
1919   call-&gt;init_req( TypeFunc::I_O,       top()      ); // does no i/o
1920   call-&gt;init_req( TypeFunc::Memory,    m          ); // may gc ptrs
</pre>
<hr />
<pre>
1971     if (use-&gt;is_MergeMem()) {
1972       wl.push(use);
1973     }
1974   }
1975 }
1976 
1977 // Replace the call with the current state of the kit.
1978 void GraphKit::replace_call(CallNode* call, Node* result, bool do_replaced_nodes) {
1979   JVMState* ejvms = NULL;
1980   if (has_exceptions()) {
1981     ejvms = transfer_exceptions_into_jvms();
1982   }
1983 
1984   ReplacedNodes replaced_nodes = map()-&gt;replaced_nodes();
1985   ReplacedNodes replaced_nodes_exception;
1986   Node* ex_ctl = top();
1987 
1988   SafePointNode* final_state = stop();
1989 
1990   // Find all the needed outputs of this call
<span class="line-modified">1991   CallProjections* callprojs = call-&gt;extract_projections(true);</span>

1992 
1993   Unique_Node_List wl;
1994   Node* init_mem = call-&gt;in(TypeFunc::Memory);
1995   Node* final_mem = final_state-&gt;in(TypeFunc::Memory);
1996   Node* final_ctl = final_state-&gt;in(TypeFunc::Control);
1997   Node* final_io = final_state-&gt;in(TypeFunc::I_O);
1998 
1999   // Replace all the old call edges with the edges from the inlining result
<span class="line-modified">2000   if (callprojs-&gt;fallthrough_catchproj != NULL) {</span>
<span class="line-modified">2001     C-&gt;gvn_replace_by(callprojs-&gt;fallthrough_catchproj, final_ctl);</span>
2002   }
<span class="line-modified">2003   if (callprojs-&gt;fallthrough_memproj != NULL) {</span>
2004     if (final_mem-&gt;is_MergeMem()) {
2005       // Parser&#39;s exits MergeMem was not transformed but may be optimized
2006       final_mem = _gvn.transform(final_mem);
2007     }
<span class="line-modified">2008     C-&gt;gvn_replace_by(callprojs-&gt;fallthrough_memproj,   final_mem);</span>
2009     add_mergemem_users_to_worklist(wl, final_mem);
2010   }
<span class="line-modified">2011   if (callprojs-&gt;fallthrough_ioproj != NULL) {</span>
<span class="line-modified">2012     C-&gt;gvn_replace_by(callprojs-&gt;fallthrough_ioproj,    final_io);</span>
2013   }
2014 
2015   // Replace the result with the new result if it exists and is used
<span class="line-modified">2016   if (callprojs-&gt;resproj[0] != NULL &amp;&amp; result != NULL) {</span>
<span class="line-modified">2017     assert(callprojs-&gt;nb_resproj == 1, &quot;unexpected number of results&quot;);</span>
<span class="line-added">2018     C-&gt;gvn_replace_by(callprojs-&gt;resproj[0], result);</span>
2019   }
2020 
2021   if (ejvms == NULL) {
2022     // No exception edges to simply kill off those paths
<span class="line-modified">2023     if (callprojs-&gt;catchall_catchproj != NULL) {</span>
<span class="line-modified">2024       C-&gt;gvn_replace_by(callprojs-&gt;catchall_catchproj, C-&gt;top());</span>
2025     }
<span class="line-modified">2026     if (callprojs-&gt;catchall_memproj != NULL) {</span>
<span class="line-modified">2027       C-&gt;gvn_replace_by(callprojs-&gt;catchall_memproj,   C-&gt;top());</span>
2028     }
<span class="line-modified">2029     if (callprojs-&gt;catchall_ioproj != NULL) {</span>
<span class="line-modified">2030       C-&gt;gvn_replace_by(callprojs-&gt;catchall_ioproj,    C-&gt;top());</span>
2031     }
2032     // Replace the old exception object with top
<span class="line-modified">2033     if (callprojs-&gt;exobj != NULL) {</span>
<span class="line-modified">2034       C-&gt;gvn_replace_by(callprojs-&gt;exobj, C-&gt;top());</span>
2035     }
2036   } else {
2037     GraphKit ekit(ejvms);
2038 
2039     // Load my combined exception state into the kit, with all phis transformed:
2040     SafePointNode* ex_map = ekit.combine_and_pop_all_exception_states();
2041     replaced_nodes_exception = ex_map-&gt;replaced_nodes();
2042 
2043     Node* ex_oop = ekit.use_exception_state(ex_map);
2044 
<span class="line-modified">2045     if (callprojs-&gt;catchall_catchproj != NULL) {</span>
<span class="line-modified">2046       C-&gt;gvn_replace_by(callprojs-&gt;catchall_catchproj, ekit.control());</span>
2047       ex_ctl = ekit.control();
2048     }
<span class="line-modified">2049     if (callprojs-&gt;catchall_memproj != NULL) {</span>
2050       Node* ex_mem = ekit.reset_memory();
<span class="line-modified">2051       C-&gt;gvn_replace_by(callprojs-&gt;catchall_memproj,   ex_mem);</span>
2052       add_mergemem_users_to_worklist(wl, ex_mem);
2053     }
<span class="line-modified">2054     if (callprojs-&gt;catchall_ioproj != NULL) {</span>
<span class="line-modified">2055       C-&gt;gvn_replace_by(callprojs-&gt;catchall_ioproj,    ekit.i_o());</span>
2056     }
2057 
2058     // Replace the old exception object with the newly created one
<span class="line-modified">2059     if (callprojs-&gt;exobj != NULL) {</span>
<span class="line-modified">2060       C-&gt;gvn_replace_by(callprojs-&gt;exobj, ex_oop);</span>
2061     }
2062   }
2063 
2064   // Disconnect the call from the graph
2065   call-&gt;disconnect_inputs(NULL, C);
2066   C-&gt;gvn_replace_by(call, C-&gt;top());
2067 
2068   // Clean up any MergeMems that feed other MergeMems since the
2069   // optimizer doesn&#39;t like that.
2070   while (wl.size() &gt; 0) {
2071     _gvn.transform(wl.pop());
2072   }
2073 
<span class="line-modified">2074   if (callprojs-&gt;fallthrough_catchproj != NULL &amp;&amp; !final_ctl-&gt;is_top() &amp;&amp; do_replaced_nodes) {</span>
2075     replaced_nodes.apply(C, final_ctl);
2076   }
2077   if (!ex_ctl-&gt;is_top() &amp;&amp; do_replaced_nodes) {
2078     replaced_nodes_exception.apply(C, ex_ctl);
2079   }
2080 }
2081 
2082 
2083 //------------------------------increment_counter------------------------------
2084 // for statistics: increment a VM counter by 1
2085 
2086 void GraphKit::increment_counter(address counter_addr) {
2087   Node* adr1 = makecon(TypeRawPtr::make(counter_addr));
2088   increment_counter(adr1);
2089 }
2090 
2091 void GraphKit::increment_counter(Node* counter_addr) {
2092   int adr_type = Compile::AliasIdxRaw;
2093   Node* ctrl = control();
2094   Node* cnt  = make_load(ctrl, counter_addr, TypeInt::INT, T_INT, adr_type, MemNode::unordered);
</pre>
<hr />
<pre>
2274     speculative = speculative-&gt;with_inline_depth(jvms()-&gt;depth());
2275   } else if (current_type-&gt;would_improve_ptr(ptr_kind)) {
2276     // Profiling report that null was never seen so we can change the
2277     // speculative type to non null ptr.
2278     if (ptr_kind == ProfileAlwaysNull) {
2279       speculative = TypePtr::NULL_PTR;
2280     } else {
2281       assert(ptr_kind == ProfileNeverNull, &quot;nothing else is an improvement&quot;);
2282       const TypePtr* ptr = TypePtr::NOTNULL;
2283       if (speculative != NULL) {
2284         speculative = speculative-&gt;cast_to_ptr_type(ptr-&gt;ptr())-&gt;is_ptr();
2285       } else {
2286         speculative = ptr;
2287       }
2288     }
2289   }
2290 
2291   if (speculative != current_type-&gt;speculative()) {
2292     // Build a type with a speculative type (what we think we know
2293     // about the type but will need a guard when we use it)
<span class="line-modified">2294     const TypeOopPtr* spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::Offset::bottom, TypeOopPtr::InstanceBot, speculative);</span>
2295     // We&#39;re changing the type, we need a new CheckCast node to carry
2296     // the new type. The new type depends on the control: what
2297     // profiling tells us is only valid from here as far as we can
2298     // tell.
2299     Node* cast = new CheckCastPPNode(control(), n, current_type-&gt;remove_speculative()-&gt;join_speculative(spec_type));
2300     cast = _gvn.transform(cast);
2301     replace_in_map(n, cast);
2302     n = cast;
2303   }
2304 
2305   return n;
2306 }
2307 
2308 /**
2309  * Record profiling data from receiver profiling at an invoke with the
2310  * type system so that it can propagate it (speculation)
2311  *
2312  * @param n  receiver node
2313  *
2314  * @return   node with improved type
2315  */
2316 Node* GraphKit::record_profiled_receiver_for_speculation(Node* n) {
2317   if (!UseTypeSpeculation) {
2318     return n;
2319   }
2320   ciKlass* exact_kls = profile_has_unique_klass();
2321   ProfilePtrKind ptr_kind = ProfileMaybeNull;
2322   if ((java_bc() == Bytecodes::_checkcast ||
2323        java_bc() == Bytecodes::_instanceof ||
2324        java_bc() == Bytecodes::_aastore) &amp;&amp;
2325       method()-&gt;method_data()-&gt;is_mature()) {
2326     ciProfileData* data = method()-&gt;method_data()-&gt;bci_to_data(bci());
2327     if (data != NULL) {
<span class="line-modified">2328       if (java_bc() == Bytecodes::_aastore) {</span>
<span class="line-modified">2329         ciKlass* array_type = NULL;</span>
<span class="line-added">2330         ciKlass* element_type = NULL;</span>
<span class="line-added">2331         ProfilePtrKind element_ptr = ProfileMaybeNull;</span>
<span class="line-added">2332         bool flat_array = true;</span>
<span class="line-added">2333         bool null_free_array = true;</span>
<span class="line-added">2334         method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);</span>
<span class="line-added">2335         exact_kls = element_type;</span>
<span class="line-added">2336         ptr_kind = element_ptr;</span>
2337       } else {
<span class="line-modified">2338         if (!data-&gt;as_BitData()-&gt;null_seen()) {</span>
<span class="line-modified">2339           ptr_kind = ProfileNeverNull;</span>
<span class="line-modified">2340         } else {</span>
<span class="line-modified">2341           assert(data-&gt;is_ReceiverTypeData(), &quot;bad profile data type&quot;);</span>
<span class="line-modified">2342           ciReceiverTypeData* call = (ciReceiverTypeData*)data-&gt;as_ReceiverTypeData();</span>
<span class="line-modified">2343           uint i = 0;</span>
<span class="line-modified">2344           for (; i &lt; call-&gt;row_limit(); i++) {</span>
<span class="line-added">2345             ciKlass* receiver = call-&gt;receiver(i);</span>
<span class="line-added">2346             if (receiver != NULL) {</span>
<span class="line-added">2347               break;</span>
<span class="line-added">2348             }</span>
2349           }
<span class="line-added">2350           ptr_kind = (i == call-&gt;row_limit()) ? ProfileAlwaysNull : ProfileMaybeNull;</span>
2351         }

2352       }
2353     }
2354   }
2355   return record_profile_for_speculation(n, exact_kls, ptr_kind);
2356 }
2357 
2358 /**
2359  * Record profiling data from argument profiling at an invoke with the
2360  * type system so that it can propagate it (speculation)
2361  *
2362  * @param dest_method  target method for the call
2363  * @param bc           what invoke bytecode is this?
2364  */
2365 void GraphKit::record_profiled_arguments_for_speculation(ciMethod* dest_method, Bytecodes::Code bc) {
2366   if (!UseTypeSpeculation) {
2367     return;
2368   }
2369   const TypeFunc* tf    = TypeFunc::make(dest_method);
<span class="line-modified">2370   int             nargs = tf-&gt;domain_sig()-&gt;cnt() - TypeFunc::Parms;</span>
2371   int skip = Bytecodes::has_receiver(bc) ? 1 : 0;
2372   for (int j = skip, i = 0; j &lt; nargs &amp;&amp; i &lt; TypeProfileArgsLimit; j++) {
<span class="line-modified">2373     const Type *targ = tf-&gt;domain_sig()-&gt;field_at(j + TypeFunc::Parms);</span>
2374     if (is_reference_type(targ-&gt;basic_type())) {
2375       ProfilePtrKind ptr_kind = ProfileMaybeNull;
2376       ciKlass* better_type = NULL;
2377       if (method()-&gt;argument_profiled_type(bci(), i, better_type, ptr_kind)) {
2378         record_profile_for_speculation(argument(j), better_type, ptr_kind);
2379       }
2380       i++;
2381     }
2382   }
2383 }
2384 
2385 /**
2386  * Record profiling data from parameter profiling at an invoke with
2387  * the type system so that it can propagate it (speculation)
2388  */
2389 void GraphKit::record_profiled_parameters_for_speculation() {
2390   if (!UseTypeSpeculation) {
2391     return;
2392   }
2393   for (int i = 0, j = 0; i &lt; method()-&gt;arg_size() ; i++) {
</pre>
<hr />
<pre>
2424   if (Matcher::strict_fp_requires_explicit_rounding) {
2425     // If a strict caller invokes a non-strict callee, round a double result.
2426     // A non-strict method may return a double value which has an extended exponent,
2427     // but this must not be visible in a caller which is strict.
2428     BasicType result_type = dest_method-&gt;return_type()-&gt;basic_type();
2429     assert(method() != NULL, &quot;must have caller context&quot;);
2430     if( result_type == T_DOUBLE &amp;&amp; method()-&gt;is_strict() &amp;&amp; !dest_method-&gt;is_strict() ) {
2431       // Destination method&#39;s return value is on top of stack
2432       // dstore_rounding() does gvn.transform
2433       Node *result = pop_pair();
2434       result = dstore_rounding(result);
2435       push_pair(result);
2436     }
2437   }
2438 }
2439 
2440 void GraphKit::round_double_arguments(ciMethod* dest_method) {
2441   if (Matcher::strict_fp_requires_explicit_rounding) {
2442     // (Note:  TypeFunc::make has a cache that makes this fast.)
2443     const TypeFunc* tf    = TypeFunc::make(dest_method);
<span class="line-modified">2444     int             nargs = tf-&gt;domain_sig()-&gt;cnt() - TypeFunc::Parms;</span>
2445     for (int j = 0; j &lt; nargs; j++) {
<span class="line-modified">2446       const Type *targ = tf-&gt;domain_sig()-&gt;field_at(j + TypeFunc::Parms);</span>
2447       if (targ-&gt;basic_type() == T_DOUBLE) {
2448         // If any parameters are doubles, they must be rounded before
2449         // the call, dstore_rounding does gvn.transform
2450         Node *arg = argument(j);
2451         arg = dstore_rounding(arg);
2452         set_argument(j, arg);
2453       }
2454     }
2455   }
2456 }
2457 
2458 // rounding for strict float precision conformance
2459 Node* GraphKit::precision_rounding(Node* n) {
2460   if (Matcher::strict_fp_requires_explicit_rounding) {
2461 #ifdef IA32
2462     if (_method-&gt;flags().is_strict() &amp;&amp; UseSSE == 0) {
2463       return _gvn.transform(new RoundFloatNode(0, n));
2464     }
2465 #else
2466     Unimplemented();
</pre>
<hr />
<pre>
2906 
2907   // Now do a linear scan of the secondary super-klass array.  Again, no real
2908   // performance impact (too rare) but it&#39;s gotta be done.
2909   // Since the code is rarely used, there is no penalty for moving it
2910   // out of line, and it can only improve I-cache density.
2911   // The decision to inline or out-of-line this final check is platform
2912   // dependent, and is found in the AD file definition of PartialSubtypeCheck.
2913   Node* psc = gvn.transform(
2914     new PartialSubtypeCheckNode(*ctrl, subklass, superklass));
2915 
2916   IfNode *iff4 = gen_subtype_check_compare(*ctrl, psc, gvn.zerocon(T_OBJECT), BoolTest::ne, PROB_FAIR, gvn, T_ADDRESS);
2917   r_not_subtype-&gt;init_req(2, gvn.transform(new IfTrueNode (iff4)));
2918   r_ok_subtype -&gt;init_req(3, gvn.transform(new IfFalseNode(iff4)));
2919 
2920   // Return false path; set default control to true path.
2921   *ctrl = gvn.transform(r_ok_subtype);
2922   return gvn.transform(r_not_subtype);
2923 }
2924 
2925 Node* GraphKit::gen_subtype_check(Node* obj_or_subklass, Node* superklass) {
<span class="line-added">2926   const Type* sub_t = _gvn.type(obj_or_subklass);</span>
<span class="line-added">2927   if (sub_t-&gt;isa_valuetype()) {</span>
<span class="line-added">2928     obj_or_subklass = makecon(TypeKlassPtr::make(sub_t-&gt;value_klass()));</span>
<span class="line-added">2929   }</span>
2930   if (ExpandSubTypeCheckAtParseTime) {
2931     MergeMemNode* mem = merged_memory();
2932     Node* ctrl = control();
2933     Node* subklass = obj_or_subklass;
<span class="line-modified">2934     if (!sub_t-&gt;isa_klassptr()) {</span>
2935       subklass = load_object_klass(obj_or_subklass);
2936     }

2937     Node* n = Phase::gen_subtype_check(subklass, superklass, &amp;ctrl, mem, _gvn);
2938     set_control(ctrl);
2939     return n;
2940   }
2941 

2942   Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass));
2943   Node* bol = _gvn.transform(new BoolNode(check, BoolTest::eq));
2944   IfNode* iff = create_and_xform_if(control(), bol, PROB_STATIC_FREQUENT, COUNT_UNKNOWN);
2945   set_control(_gvn.transform(new IfTrueNode(iff)));
2946   return _gvn.transform(new IfFalseNode(iff));
2947 }
2948 
2949 // Profile-driven exact type check:
2950 Node* GraphKit::type_check_receiver(Node* receiver, ciKlass* klass,
2951                                     float prob,
2952                                     Node* *casted_receiver) {
2953   const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);
2954   Node* recv_klass = load_object_klass(receiver);
<span class="line-modified">2955   Node* fail = type_check(recv_klass, tklass, prob);</span>






2956   const TypeOopPtr* recv_xtype = tklass-&gt;as_instance_type();
2957   assert(recv_xtype-&gt;klass_is_exact(), &quot;&quot;);
2958 
2959   // Subsume downstream occurrences of receiver with a cast to
2960   // recv_xtype, since now we know what the type will be.
2961   Node* cast = new CheckCastPPNode(control(), receiver, recv_xtype);
<span class="line-modified">2962   Node* res = _gvn.transform(cast);</span>
<span class="line-added">2963   if (recv_xtype-&gt;is_valuetypeptr() &amp;&amp; recv_xtype-&gt;value_klass()-&gt;is_scalarizable()) {</span>
<span class="line-added">2964     assert(!gvn().type(res)-&gt;maybe_null(), &quot;receiver should never be null&quot;);</span>
<span class="line-added">2965     res = ValueTypeNode::make_from_oop(this, res, recv_xtype-&gt;value_klass());</span>
<span class="line-added">2966   }</span>
<span class="line-added">2967 </span>
<span class="line-added">2968   (*casted_receiver) = res;</span>
2969   // (User must make the replace_in_map call.)
2970 
2971   return fail;
2972 }
2973 
<span class="line-added">2974 Node* GraphKit::type_check(Node* recv_klass, const TypeKlassPtr* tklass,</span>
<span class="line-added">2975                            float prob) {</span>
<span class="line-added">2976   Node* want_klass = makecon(tklass);</span>
<span class="line-added">2977   Node* cmp = _gvn.transform( new CmpPNode(recv_klass, want_klass));</span>
<span class="line-added">2978   Node* bol = _gvn.transform( new BoolNode(cmp, BoolTest::eq) );</span>
<span class="line-added">2979   IfNode* iff = create_and_xform_if(control(), bol, prob, COUNT_UNKNOWN);</span>
<span class="line-added">2980   set_control(  _gvn.transform( new IfTrueNode (iff)));</span>
<span class="line-added">2981   Node* fail = _gvn.transform( new IfFalseNode(iff));</span>
<span class="line-added">2982   return fail;</span>
<span class="line-added">2983 }</span>
<span class="line-added">2984 </span>
2985 //------------------------------subtype_check_receiver-------------------------
2986 Node* GraphKit::subtype_check_receiver(Node* receiver, ciKlass* klass,
2987                                        Node** casted_receiver) {
2988   const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);
2989   Node* want_klass = makecon(tklass);
2990 
2991   Node* slow_ctl = gen_subtype_check(receiver, want_klass);
2992 
2993   // Cast receiver after successful check
2994   const TypeOopPtr* recv_type = tklass-&gt;cast_to_exactness(false)-&gt;is_klassptr()-&gt;as_instance_type();
2995   Node* cast = new CheckCastPPNode(control(), receiver, recv_type);
2996   (*casted_receiver) = _gvn.transform(cast);
2997 
2998   return slow_ctl;
2999 }
3000 
3001 //------------------------------seems_never_null-------------------------------
3002 // Use null_seen information if it is available from the profile.
3003 // If we see an unexpected null at a type check we record it and force a
3004 // recompile; the offending check will be recompiled to handle NULLs.
3005 // If we see several offending BCIs, then all checks in the
3006 // method will be recompiled.
3007 bool GraphKit::seems_never_null(Node* obj, ciProfileData* data, bool&amp; speculating) {
3008   speculating = !_gvn.type(obj)-&gt;speculative_maybe_null();
3009   Deoptimization::DeoptReason reason = Deoptimization::reason_null_check(speculating);
3010   if (UncommonNullCast               // Cutout for this technique
3011       &amp;&amp; obj != null()               // And not the -Xcomp stupid case?
3012       &amp;&amp; !too_many_traps(reason)
3013       ) {
3014     if (speculating) {
3015       return true;
3016     }
3017     if (data == NULL)
3018       // Edge case:  no mature data.  Be optimistic here.
3019       return true;
3020     // If the profile has not seen a null, assume it won&#39;t happen.
3021     assert(java_bc() == Bytecodes::_checkcast ||
3022            java_bc() == Bytecodes::_instanceof ||
3023            java_bc() == Bytecodes::_aastore, &quot;MDO must collect null_seen bit here&quot;);
<span class="line-added">3024     if (java_bc() == Bytecodes::_aastore) {</span>
<span class="line-added">3025       return ((ciArrayLoadStoreData*)data-&gt;as_ArrayLoadStoreData())-&gt;element()-&gt;ptr_kind() == ProfileNeverNull;</span>
<span class="line-added">3026     }</span>
3027     return !data-&gt;as_BitData()-&gt;null_seen();
3028   }
3029   speculating = false;
3030   return false;
3031 }
3032 
3033 void GraphKit::guard_klass_being_initialized(Node* klass) {
3034   int init_state_off = in_bytes(InstanceKlass::init_state_offset());
3035   Node* adr = basic_plus_adr(top(), klass, init_state_off);
3036   Node* init_state = LoadNode::make(_gvn, NULL, immutable_memory(), adr,
3037                                     adr-&gt;bottom_type()-&gt;is_ptr(), TypeInt::BYTE,
3038                                     T_BYTE, MemNode::unordered);
3039   init_state = _gvn.transform(init_state);
3040 
3041   Node* being_initialized_state = makecon(TypeInt::make(InstanceKlass::being_initialized));
3042 
3043   Node* chk = _gvn.transform(new CmpINode(being_initialized_state, init_state));
3044   Node* tst = _gvn.transform(new BoolNode(chk, BoolTest::eq));
3045 
3046   { BuildCutout unless(this, tst, PROB_MAX);
</pre>
<hr />
<pre>
3086 
3087 //------------------------maybe_cast_profiled_receiver-------------------------
3088 // If the profile has seen exactly one type, narrow to exactly that type.
3089 // Subsequent type checks will always fold up.
3090 Node* GraphKit::maybe_cast_profiled_receiver(Node* not_null_obj,
3091                                              ciKlass* require_klass,
3092                                              ciKlass* spec_klass,
3093                                              bool safe_for_replace) {
3094   if (!UseTypeProfile || !TypeProfileCasts) return NULL;
3095 
3096   Deoptimization::DeoptReason reason = Deoptimization::reason_class_check(spec_klass != NULL);
3097 
3098   // Make sure we haven&#39;t already deoptimized from this tactic.
3099   if (too_many_traps_or_recompiles(reason))
3100     return NULL;
3101 
3102   // (No, this isn&#39;t a call, but it&#39;s enough like a virtual call
3103   // to use the same ciMethod accessor to get the profile info...)
3104   // If we have a speculative type use it instead of profiling (which
3105   // may not help us)
<span class="line-modified">3106   ciKlass* exact_kls = spec_klass;</span>
<span class="line-added">3107   if (exact_kls == NULL) {</span>
<span class="line-added">3108     if (java_bc() == Bytecodes::_aastore) {</span>
<span class="line-added">3109       ciKlass* array_type = NULL;</span>
<span class="line-added">3110       ciKlass* element_type = NULL;</span>
<span class="line-added">3111       ProfilePtrKind element_ptr = ProfileMaybeNull;</span>
<span class="line-added">3112       bool flat_array = true;</span>
<span class="line-added">3113       bool null_free_array = true;</span>
<span class="line-added">3114       method()-&gt;array_access_profiled_type(bci(), array_type, element_type, element_ptr, flat_array, null_free_array);</span>
<span class="line-added">3115       exact_kls = element_type;</span>
<span class="line-added">3116     } else {</span>
<span class="line-added">3117       exact_kls = profile_has_unique_klass();</span>
<span class="line-added">3118     }</span>
<span class="line-added">3119   }</span>
3120   if (exact_kls != NULL) {// no cast failures here
3121     if (require_klass == NULL ||
3122         C-&gt;static_subtype_check(require_klass, exact_kls) == Compile::SSC_always_true) {
3123       // If we narrow the type to match what the type profile sees or
3124       // the speculative type, we can then remove the rest of the
3125       // cast.
3126       // This is a win, even if the exact_kls is very specific,
3127       // because downstream operations, such as method calls,
3128       // will often benefit from the sharper type.
3129       Node* exact_obj = not_null_obj; // will get updated in place...
3130       Node* slow_ctl  = type_check_receiver(exact_obj, exact_kls, 1.0,
3131                                             &amp;exact_obj);
3132       { PreserveJVMState pjvms(this);
3133         set_control(slow_ctl);
3134         uncommon_trap_exact(reason, Deoptimization::Action_maybe_recompile);
3135       }
3136       if (safe_for_replace) {
3137         replace_in_map(not_null_obj, exact_obj);
3138       }
3139       return exact_obj;
</pre>
<hr />
<pre>
3204 // and the reflective instance-of call.
3205 Node* GraphKit::gen_instanceof(Node* obj, Node* superklass, bool safe_for_replace) {
3206   kill_dead_locals();           // Benefit all the uncommon traps
3207   assert( !stopped(), &quot;dead parse path should be checked in callers&quot; );
3208   assert(!TypePtr::NULL_PTR-&gt;higher_equal(_gvn.type(superklass)-&gt;is_klassptr()),
3209          &quot;must check for not-null not-dead klass in callers&quot;);
3210 
3211   // Make the merge point
3212   enum { _obj_path = 1, _fail_path, _null_path, PATH_LIMIT };
3213   RegionNode* region = new RegionNode(PATH_LIMIT);
3214   Node*       phi    = new PhiNode(region, TypeInt::BOOL);
3215   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3216 
3217   ciProfileData* data = NULL;
3218   if (java_bc() == Bytecodes::_instanceof) {  // Only for the bytecode
3219     data = method()-&gt;method_data()-&gt;bci_to_data(bci());
3220   }
3221   bool speculative_not_null = false;
3222   bool never_see_null = (ProfileDynamicTypes  // aggressive use of profile
3223                          &amp;&amp; seems_never_null(obj, data, speculative_not_null));
<span class="line-added">3224   bool is_value = obj-&gt;is_ValueType();</span>
3225 
3226   // Null check; get casted pointer; set region slot 3
3227   Node* null_ctl = top();
<span class="line-modified">3228   Node* not_null_obj = is_value ? obj : null_check_oop(obj, &amp;null_ctl, never_see_null, safe_for_replace, speculative_not_null);</span>
3229 
3230   // If not_null_obj is dead, only null-path is taken
3231   if (stopped()) {              // Doing instance-of on a NULL?
3232     set_control(null_ctl);
3233     return intcon(0);
3234   }
3235   region-&gt;init_req(_null_path, null_ctl);
3236   phi   -&gt;init_req(_null_path, intcon(0)); // Set null path value
3237   if (null_ctl == top()) {
3238     // Do this eagerly, so that pattern matches like is_diamond_phi
3239     // will work even during parsing.
3240     assert(_null_path == PATH_LIMIT-1, &quot;delete last&quot;);
3241     region-&gt;del_req(_null_path);
3242     phi   -&gt;del_req(_null_path);
3243   }
3244 
3245   // Do we know the type check always succeed?
<span class="line-modified">3246   if (!is_value) {</span>
<span class="line-modified">3247     bool known_statically = false;</span>
<span class="line-modified">3248     if (_gvn.type(superklass)-&gt;singleton()) {</span>
<span class="line-modified">3249       ciKlass* superk = _gvn.type(superklass)-&gt;is_klassptr()-&gt;klass();</span>
<span class="line-modified">3250       ciKlass* subk = _gvn.type(obj)-&gt;is_oopptr()-&gt;klass();</span>
<span class="line-modified">3251       if (subk != NULL &amp;&amp; subk-&gt;is_loaded()) {</span>
<span class="line-modified">3252         int static_res = C-&gt;static_subtype_check(superk, subk);</span>
<span class="line-added">3253         known_statically = (static_res == Compile::SSC_always_true || static_res == Compile::SSC_always_false);</span>
<span class="line-added">3254       }</span>
3255     }
<span class="line-modified">3256 </span>
<span class="line-modified">3257     if (!known_statically) {</span>
<span class="line-modified">3258       const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();</span>
<span class="line-modified">3259       // We may not have profiling here or it may not help us. If we</span>
<span class="line-modified">3260       // have a speculative type use it to perform an exact cast.</span>
<span class="line-modified">3261       ciKlass* spec_obj_type = obj_type-&gt;speculative_type();</span>
<span class="line-modified">3262       if (spec_obj_type != NULL || (ProfileDynamicTypes &amp;&amp; data != NULL)) {</span>
<span class="line-modified">3263         Node* cast_obj = maybe_cast_profiled_receiver(not_null_obj, NULL, spec_obj_type, safe_for_replace);</span>
<span class="line-modified">3264         if (stopped()) {            // Profile disagrees with this path.</span>
<span class="line-modified">3265           set_control(null_ctl);    // Null is the only remaining possibility.</span>
<span class="line-modified">3266           return intcon(0);</span>
<span class="line-modified">3267         }</span>
<span class="line-modified">3268         if (cast_obj != NULL &amp;&amp;</span>
<span class="line-modified">3269             // A value that&#39;s sometimes null is not something we can optimize well</span>
<span class="line-added">3270             !(cast_obj-&gt;is_ValueType() &amp;&amp; null_ctl != top())) {</span>
<span class="line-added">3271           not_null_obj = cast_obj;</span>
<span class="line-added">3272           is_value = not_null_obj-&gt;is_ValueType();</span>
3273         }
3274       }
3275     }
3276   }
3277 
3278   // Generate the subtype check
3279   Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass);
3280 
3281   // Plug in the success path to the general merge in slot 1.
3282   region-&gt;init_req(_obj_path, control());
3283   phi   -&gt;init_req(_obj_path, intcon(1));
3284 
3285   // Plug in the failing path to the general merge in slot 2.
3286   region-&gt;init_req(_fail_path, not_subtype_ctrl);
3287   phi   -&gt;init_req(_fail_path, intcon(0));
3288 
3289   // Return final merged results
3290   set_control( _gvn.transform(region) );
3291   record_for_igvn(region);
3292 
3293   // If we know the type check always succeeds then we don&#39;t use the
3294   // profiling data at this bytecode. Don&#39;t lose it, feed it to the
3295   // type system as a speculative type.
<span class="line-modified">3296   if (safe_for_replace &amp;&amp; !is_value) {</span>
3297     Node* casted_obj = record_profiled_receiver_for_speculation(obj);
3298     replace_in_map(obj, casted_obj);
3299   }
3300 
3301   return _gvn.transform(phi);
3302 }
3303 
3304 //-------------------------------gen_checkcast---------------------------------
3305 // Generate a checkcast idiom.  Used by both the checkcast bytecode and the
3306 // array store bytecode.  Stack must be as-if BEFORE doing the bytecode so the
3307 // uncommon-trap paths work.  Adjust stack after this call.
3308 // If failure_control is supplied and not null, it is filled in with
3309 // the control edge for the cast failure.  Otherwise, an appropriate
3310 // uncommon trap or exception is thrown.
<span class="line-modified">3311 Node* GraphKit::gen_checkcast(Node *obj, Node* superklass, Node* *failure_control, bool never_null) {</span>

3312   kill_dead_locals();           // Benefit all the uncommon traps
<span class="line-modified">3313   const TypeKlassPtr* tk = _gvn.type(superklass)-&gt;is_klassptr();</span>
<span class="line-modified">3314   const TypeOopPtr* toop = TypeOopPtr::make_from_klass(tk-&gt;klass());</span>
<span class="line-added">3315   assert(!never_null || toop-&gt;is_valuetypeptr(), &quot;must be a value type pointer&quot;);</span>
<span class="line-added">3316   bool is_value = obj-&gt;is_ValueType();</span>
3317 
3318   // Fast cutout:  Check the case that the cast is vacuously true.
3319   // This detects the common cases where the test will short-circuit
3320   // away completely.  We do this before we perform the null check,
3321   // because if the test is going to turn into zero code, we don&#39;t
3322   // want a residual null check left around.  (Causes a slowdown,
3323   // for example, in some objArray manipulations, such as a[i]=a[j].)
3324   if (tk-&gt;singleton()) {
<span class="line-modified">3325     ciKlass* klass = NULL;</span>
<span class="line-modified">3326     if (is_value) {</span>
<span class="line-modified">3327       klass = _gvn.type(obj)-&gt;value_klass();</span>
<span class="line-added">3328     } else {</span>
<span class="line-added">3329       const TypeOopPtr* objtp = _gvn.type(obj)-&gt;isa_oopptr();</span>
<span class="line-added">3330       if (objtp != NULL) {</span>
<span class="line-added">3331         klass = objtp-&gt;klass();</span>
<span class="line-added">3332       }</span>
<span class="line-added">3333     }</span>
<span class="line-added">3334     if (klass != NULL) {</span>
<span class="line-added">3335       switch (C-&gt;static_subtype_check(tk-&gt;klass(), klass)) {</span>
3336       case Compile::SSC_always_true:
3337         // If we know the type check always succeed then we don&#39;t use
3338         // the profiling data at this bytecode. Don&#39;t lose it, feed it
3339         // to the type system as a speculative type.
<span class="line-modified">3340         if (!is_value) {</span>
<span class="line-added">3341           obj = record_profiled_receiver_for_speculation(obj);</span>
<span class="line-added">3342           if (never_null) {</span>
<span class="line-added">3343             obj = null_check(obj);</span>
<span class="line-added">3344           }</span>
<span class="line-added">3345           if (toop-&gt;is_valuetypeptr() &amp;&amp; toop-&gt;value_klass()-&gt;is_scalarizable() &amp;&amp; !gvn().type(obj)-&gt;maybe_null()) {</span>
<span class="line-added">3346             obj = ValueTypeNode::make_from_oop(this, obj, toop-&gt;value_klass());</span>
<span class="line-added">3347           }</span>
<span class="line-added">3348         }</span>
<span class="line-added">3349         return obj;</span>
3350       case Compile::SSC_always_false:
<span class="line-modified">3351         if (is_value || never_null) {</span>
<span class="line-modified">3352           if (!is_value) {</span>
<span class="line-modified">3353             null_check(obj);</span>
<span class="line-added">3354           }</span>
<span class="line-added">3355           // Value type is never null. Always throw an exception.</span>
<span class="line-added">3356           builtin_throw(Deoptimization::Reason_class_check, makecon(TypeKlassPtr::make(klass)));</span>
<span class="line-added">3357           return top();</span>
<span class="line-added">3358         } else {</span>
<span class="line-added">3359           // It needs a null check because a null will *pass* the cast check.</span>
<span class="line-added">3360           return null_assert(obj);</span>
<span class="line-added">3361         }</span>
3362       }
3363     }
3364   }
3365 
3366   ciProfileData* data = NULL;
3367   bool safe_for_replace = false;
3368   if (failure_control == NULL) {        // use MDO in regular case only
3369     assert(java_bc() == Bytecodes::_aastore ||
3370            java_bc() == Bytecodes::_checkcast,
3371            &quot;interpreter profiles type checks only for these BCs&quot;);
<span class="line-modified">3372     if (method()-&gt;method_data()-&gt;is_mature()) {</span>
<span class="line-added">3373       data = method()-&gt;method_data()-&gt;bci_to_data(bci());</span>
<span class="line-added">3374     }</span>
3375     safe_for_replace = true;
3376   }
3377 
3378   // Make the merge point
3379   enum { _obj_path = 1, _null_path, PATH_LIMIT };
3380   RegionNode* region = new RegionNode(PATH_LIMIT);
3381   Node*       phi    = new PhiNode(region, toop);
<span class="line-added">3382   _gvn.set_type(region, Type::CONTROL);</span>
<span class="line-added">3383   _gvn.set_type(phi, toop);</span>
<span class="line-added">3384 </span>
3385   C-&gt;set_has_split_ifs(true); // Has chance for split-if optimization
3386 
3387   // Use null-cast information if it is available
3388   bool speculative_not_null = false;
3389   bool never_see_null = ((failure_control == NULL)  // regular case only
3390                          &amp;&amp; seems_never_null(obj, data, speculative_not_null));
3391 
3392   // Null check; get casted pointer; set region slot 3
3393   Node* null_ctl = top();
<span class="line-modified">3394   Node* not_null_obj = NULL;</span>
<span class="line-added">3395   if (is_value) {</span>
<span class="line-added">3396     not_null_obj = obj;</span>
<span class="line-added">3397   } else if (never_null) {</span>
<span class="line-added">3398     not_null_obj = null_check(obj);</span>
<span class="line-added">3399   } else {</span>
<span class="line-added">3400     not_null_obj = null_check_oop(obj, &amp;null_ctl, never_see_null, safe_for_replace, speculative_not_null);</span>
<span class="line-added">3401   }</span>
3402 
3403   // If not_null_obj is dead, only null-path is taken
3404   if (stopped()) {              // Doing instance-of on a NULL?
3405     set_control(null_ctl);
3406     return null();
3407   }
3408   region-&gt;init_req(_null_path, null_ctl);
3409   phi   -&gt;init_req(_null_path, null());  // Set null path value
3410   if (null_ctl == top()) {
3411     // Do this eagerly, so that pattern matches like is_diamond_phi
3412     // will work even during parsing.
3413     assert(_null_path == PATH_LIMIT-1, &quot;delete last&quot;);
3414     region-&gt;del_req(_null_path);
3415     phi   -&gt;del_req(_null_path);
3416   }
3417 
3418   Node* cast_obj = NULL;
<span class="line-modified">3419   if (!is_value &amp;&amp; tk-&gt;klass_is_exact()) {</span>
3420     // The following optimization tries to statically cast the speculative type of the object
3421     // (for example obtained during profiling) to the type of the superklass and then do a
3422     // dynamic check that the type of the object is what we expect. To work correctly
3423     // for checkcast and aastore the type of superklass should be exact.
3424     const TypeOopPtr* obj_type = _gvn.type(obj)-&gt;is_oopptr();
3425     // We may not have profiling here or it may not help us. If we have
3426     // a speculative type use it to perform an exact cast.
3427     ciKlass* spec_obj_type = obj_type-&gt;speculative_type();
3428     if (spec_obj_type != NULL || data != NULL) {
3429       cast_obj = maybe_cast_profiled_receiver(not_null_obj, tk-&gt;klass(), spec_obj_type, safe_for_replace);
<span class="line-added">3430       if (cast_obj != NULL &amp;&amp; cast_obj-&gt;is_ValueType()) {</span>
<span class="line-added">3431         if (null_ctl != top()) {</span>
<span class="line-added">3432           cast_obj = NULL; // A value that&#39;s sometimes null is not something we can optimize well</span>
<span class="line-added">3433         } else {</span>
<span class="line-added">3434           return cast_obj;</span>
<span class="line-added">3435         }</span>
<span class="line-added">3436       }</span>
3437       if (cast_obj != NULL) {
3438         if (failure_control != NULL) // failure is now impossible
3439           (*failure_control) = top();
3440         // adjust the type of the phi to the exact klass:
3441         phi-&gt;raise_bottom_type(_gvn.type(cast_obj)-&gt;meet_speculative(TypePtr::NULL_PTR));
3442       }
3443     }
3444   }
3445 
3446   if (cast_obj == NULL) {
3447     // Generate the subtype check
<span class="line-modified">3448     Node* not_subtype_ctrl = gen_subtype_check(not_null_obj, superklass);</span>
3449 
3450     // Plug in success path into the merge
<span class="line-modified">3451     cast_obj = is_value ? not_null_obj : _gvn.transform(new CheckCastPPNode(control(), not_null_obj, toop));</span>
3452     // Failure path ends in uncommon trap (or may be dead - failure impossible)
3453     if (failure_control == NULL) {
3454       if (not_subtype_ctrl != top()) { // If failure is possible
3455         PreserveJVMState pjvms(this);
3456         set_control(not_subtype_ctrl);
<span class="line-modified">3457         Node* obj_klass = NULL;</span>
<span class="line-added">3458         if (is_value) {</span>
<span class="line-added">3459           obj_klass = makecon(TypeKlassPtr::make(_gvn.type(not_null_obj)-&gt;value_klass()));</span>
<span class="line-added">3460         } else {</span>
<span class="line-added">3461           obj_klass = load_object_klass(not_null_obj);</span>
<span class="line-added">3462         }</span>
<span class="line-added">3463         builtin_throw(Deoptimization::Reason_class_check, obj_klass);</span>
3464       }
3465     } else {
3466       (*failure_control) = not_subtype_ctrl;
3467     }
3468   }
3469 
3470   region-&gt;init_req(_obj_path, control());
3471   phi   -&gt;init_req(_obj_path, cast_obj);
3472 
3473   // A merge of NULL or Casted-NotNull obj
3474   Node* res = _gvn.transform(phi);
3475 
3476   // Note I do NOT always &#39;replace_in_map(obj,result)&#39; here.
3477   //  if( tk-&gt;klass()-&gt;can_be_primary_super()  )
3478     // This means that if I successfully store an Object into an array-of-String
3479     // I &#39;forget&#39; that the Object is really now known to be a String.  I have to
3480     // do this because we don&#39;t have true union types for interfaces - if I store
3481     // a Baz into an array-of-Interface and then tell the optimizer it&#39;s an
3482     // Interface, I forget that it&#39;s also a Baz and cannot do Baz-like field
3483     // references to it.  FIX THIS WHEN UNION TYPES APPEAR!
3484   //  replace_in_map( obj, res );
3485 
3486   // Return final merged results
3487   set_control( _gvn.transform(region) );
3488   record_for_igvn(region);
3489 
<span class="line-modified">3490   bool not_null_free = !toop-&gt;can_be_value_type();</span>
<span class="line-added">3491   bool not_flattenable = !ValueArrayFlatten || not_null_free || (toop-&gt;is_valuetypeptr() &amp;&amp; !toop-&gt;value_klass()-&gt;flatten_array());</span>
<span class="line-added">3492   if (EnableValhalla &amp;&amp; not_flattenable) {</span>
<span class="line-added">3493     // Check if obj has been loaded from an array</span>
<span class="line-added">3494     obj = obj-&gt;isa_DecodeN() ? obj-&gt;in(1) : obj;</span>
<span class="line-added">3495     Node* array = NULL;</span>
<span class="line-added">3496     if (obj-&gt;isa_Load()) {</span>
<span class="line-added">3497       Node* address = obj-&gt;in(MemNode::Address);</span>
<span class="line-added">3498       if (address-&gt;isa_AddP()) {</span>
<span class="line-added">3499         array = address-&gt;as_AddP()-&gt;in(AddPNode::Base);</span>
<span class="line-added">3500       }</span>
<span class="line-added">3501     } else if (obj-&gt;is_Phi()) {</span>
<span class="line-added">3502       Node* region = obj-&gt;in(0);</span>
<span class="line-added">3503       // TODO make this more robust (see JDK-8231346)</span>
<span class="line-added">3504       if (region-&gt;req() == 3 &amp;&amp; region-&gt;in(2) != NULL &amp;&amp; region-&gt;in(2)-&gt;in(0) != NULL) {</span>
<span class="line-added">3505         IfNode* iff = region-&gt;in(2)-&gt;in(0)-&gt;isa_If();</span>
<span class="line-added">3506         if (iff != NULL) {</span>
<span class="line-added">3507           iff-&gt;is_non_flattened_array_check(&amp;_gvn, &amp;array);</span>
<span class="line-added">3508         }</span>
<span class="line-added">3509       }</span>
<span class="line-added">3510     }</span>
<span class="line-added">3511     if (array != NULL) {</span>
<span class="line-added">3512       const TypeAryPtr* ary_t = _gvn.type(array)-&gt;isa_aryptr();</span>
<span class="line-added">3513       if (ary_t != NULL) {</span>
<span class="line-added">3514         if (!ary_t-&gt;is_not_null_free() &amp;&amp; not_null_free) {</span>
<span class="line-added">3515           // Casting array element to a non-inline-type, mark array as not null-free.</span>
<span class="line-added">3516           Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, ary_t-&gt;cast_to_not_null_free()));</span>
<span class="line-added">3517           replace_in_map(array, cast);</span>
<span class="line-added">3518         } else if (!ary_t-&gt;is_not_flat()) {</span>
<span class="line-added">3519           // Casting array element to a non-flattenable type, mark array as not flat.</span>
<span class="line-added">3520           Node* cast = _gvn.transform(new CheckCastPPNode(control(), array, ary_t-&gt;cast_to_not_flat()));</span>
<span class="line-added">3521           replace_in_map(array, cast);</span>
<span class="line-added">3522         }</span>
<span class="line-added">3523       }</span>
<span class="line-added">3524     }</span>
<span class="line-added">3525   }</span>
<span class="line-added">3526 </span>
<span class="line-added">3527   if (!is_value) {</span>
<span class="line-added">3528     res = record_profiled_receiver_for_speculation(res);</span>
<span class="line-added">3529     if (toop-&gt;is_valuetypeptr() &amp;&amp; toop-&gt;value_klass()-&gt;is_scalarizable() &amp;&amp; !gvn().type(res)-&gt;maybe_null()) {</span>
<span class="line-added">3530       res = ValueTypeNode::make_from_oop(this, res, toop-&gt;value_klass());</span>
<span class="line-added">3531     }</span>
<span class="line-added">3532   }</span>
<span class="line-added">3533   return res;</span>
<span class="line-added">3534 }</span>
<span class="line-added">3535 </span>
<span class="line-added">3536 // Check if &#39;obj&#39; is a value type by checking if it has the always_locked markWord pattern set.</span>
<span class="line-added">3537 Node* GraphKit::is_value_type(Node* obj) {</span>
<span class="line-added">3538   Node* mark_addr = basic_plus_adr(obj, oopDesc::mark_offset_in_bytes());</span>
<span class="line-added">3539   Node* mark = make_load(NULL, mark_addr, TypeX_X, TypeX_X-&gt;basic_type(), MemNode::unordered);</span>
<span class="line-added">3540   Node* mask = _gvn.MakeConX(markWord::always_locked_pattern);</span>
<span class="line-added">3541   Node* andx = _gvn.transform(new AndXNode(mark, mask));</span>
<span class="line-added">3542   Node* cmp = _gvn.transform(new CmpXNode(andx, mask));</span>
<span class="line-added">3543   return _gvn.transform(new BoolNode(cmp, BoolTest::eq));</span>
<span class="line-added">3544 }</span>
<span class="line-added">3545 </span>
<span class="line-added">3546 // Check if &#39;ary&#39; is a non-flattened array</span>
<span class="line-added">3547 Node* GraphKit::is_non_flattened_array(Node* ary) {</span>
<span class="line-added">3548   Node* kls = load_object_klass(ary);</span>
<span class="line-added">3549   Node* tag = load_lh_array_tag(kls);</span>
<span class="line-added">3550   Node* cmp = gen_lh_array_test(kls, Klass::_lh_array_tag_vt_value);</span>
<span class="line-added">3551   return _gvn.transform(new BoolNode(cmp, BoolTest::ne));</span>
<span class="line-added">3552 }</span>
<span class="line-added">3553 </span>
<span class="line-added">3554 // Check if &#39;ary&#39; is a nullable array</span>
<span class="line-added">3555 Node* GraphKit::is_nullable_array(Node* ary) {</span>
<span class="line-added">3556   Node* kls = load_object_klass(ary);</span>
<span class="line-added">3557   Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));</span>
<span class="line-added">3558   Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp-&gt;bottom_type()-&gt;is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));</span>
<span class="line-added">3559   Node* null_free = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_null_free_shift)));</span>
<span class="line-added">3560   null_free = _gvn.transform(new AndINode(null_free, intcon(Klass::_lh_null_free_mask)));</span>
<span class="line-added">3561   Node* cmp = _gvn.transform(new CmpINode(null_free, intcon(0)));</span>
<span class="line-added">3562   return _gvn.transform(new BoolNode(cmp, BoolTest::eq));</span>
<span class="line-added">3563 }</span>
<span class="line-added">3564 </span>
<span class="line-added">3565 // Deoptimize if &#39;ary&#39; is a null-free value type array and &#39;val&#39; is null</span>
<span class="line-added">3566 Node* GraphKit::gen_value_array_null_guard(Node* ary, Node* val, int nargs, bool safe_for_replace) {</span>
<span class="line-added">3567   const Type* val_t = _gvn.type(val);</span>
<span class="line-added">3568   if (val-&gt;is_ValueType() || !TypePtr::NULL_PTR-&gt;higher_equal(val_t)) {</span>
<span class="line-added">3569     return ary; // Never null</span>
<span class="line-added">3570   }</span>
<span class="line-added">3571   RegionNode* region = new RegionNode(3);</span>
<span class="line-added">3572   Node* null_ctl = top();</span>
<span class="line-added">3573   null_check_oop(val, &amp;null_ctl);</span>
<span class="line-added">3574   if (null_ctl != top()) {</span>
<span class="line-added">3575     PreserveJVMState pjvms(this);</span>
<span class="line-added">3576     set_control(null_ctl);</span>
<span class="line-added">3577     {</span>
<span class="line-added">3578       // Deoptimize if null-free array</span>
<span class="line-added">3579       BuildCutout unless(this, is_nullable_array(ary), PROB_MAX);</span>
<span class="line-added">3580       inc_sp(nargs);</span>
<span class="line-added">3581       uncommon_trap(Deoptimization::Reason_null_check,</span>
<span class="line-added">3582                     Deoptimization::Action_none);</span>
<span class="line-added">3583     }</span>
<span class="line-added">3584     region-&gt;init_req(1, control());</span>
<span class="line-added">3585   }</span>
<span class="line-added">3586   region-&gt;init_req(2, control());</span>
<span class="line-added">3587   set_control(_gvn.transform(region));</span>
<span class="line-added">3588   record_for_igvn(region);</span>
<span class="line-added">3589   const TypeAryPtr* ary_t = _gvn.type(ary)-&gt;is_aryptr();</span>
<span class="line-added">3590   if (val_t == TypePtr::NULL_PTR &amp;&amp; !ary_t-&gt;is_not_null_free()) {</span>
<span class="line-added">3591     // Since we were just successfully storing null, the array can&#39;t be null free.</span>
<span class="line-added">3592     ary_t = ary_t-&gt;cast_to_not_null_free();</span>
<span class="line-added">3593     Node* cast = _gvn.transform(new CheckCastPPNode(control(), ary, ary_t));</span>
<span class="line-added">3594     if (safe_for_replace) {</span>
<span class="line-added">3595       replace_in_map(ary, cast);</span>
<span class="line-added">3596     }</span>
<span class="line-added">3597     ary = cast;</span>
<span class="line-added">3598   }</span>
<span class="line-added">3599   return ary;</span>
<span class="line-added">3600 }</span>
<span class="line-added">3601 </span>
<span class="line-added">3602 Node* GraphKit::load_lh_array_tag(Node* kls) {</span>
<span class="line-added">3603   Node* lhp = basic_plus_adr(kls, in_bytes(Klass::layout_helper_offset()));</span>
<span class="line-added">3604   Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp-&gt;bottom_type()-&gt;is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));</span>
<span class="line-added">3605   return _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_array_tag_shift)));</span>
<span class="line-added">3606 }</span>
<span class="line-added">3607 </span>
<span class="line-added">3608 Node* GraphKit::gen_lh_array_test(Node* kls, unsigned int lh_value) {</span>
<span class="line-added">3609   Node* layout_val = load_lh_array_tag(kls);</span>
<span class="line-added">3610   Node* cmp = _gvn.transform(new CmpINode(layout_val, intcon(lh_value)));</span>
<span class="line-added">3611   return cmp;</span>
3612 }
3613 
3614 //------------------------------next_monitor-----------------------------------
3615 // What number should be given to the next monitor?
3616 int GraphKit::next_monitor() {
3617   int current = jvms()-&gt;monitor_depth()* C-&gt;sync_stack_slots();
3618   int next = current + C-&gt;sync_stack_slots();
3619   // Keep the toplevel high water mark current:
3620   if (C-&gt;fixed_slots() &lt; next)  C-&gt;set_fixed_slots(next);
3621   return current;
3622 }
3623 
3624 //------------------------------insert_mem_bar---------------------------------
3625 // Memory barrier to avoid floating things around
3626 // The membar serves as a pinch point between both control and all memory slices.
3627 Node* GraphKit::insert_mem_bar(int opcode, Node* precedent) {
3628   MemBarNode* mb = MemBarNode::make(C, opcode, Compile::AliasIdxBot, precedent);
3629   mb-&gt;init_req(TypeFunc::Control, control());
3630   mb-&gt;init_req(TypeFunc::Memory,  reset_memory());
3631   Node* membar = _gvn.transform(mb);
</pre>
<hr />
<pre>
3659   }
3660   Node* membar = _gvn.transform(mb);
3661   set_control(_gvn.transform(new ProjNode(membar, TypeFunc::Control)));
3662   if (alias_idx == Compile::AliasIdxBot) {
3663     merged_memory()-&gt;set_base_memory(_gvn.transform(new ProjNode(membar, TypeFunc::Memory)));
3664   } else {
3665     set_memory(_gvn.transform(new ProjNode(membar, TypeFunc::Memory)),alias_idx);
3666   }
3667   return membar;
3668 }
3669 
3670 //------------------------------shared_lock------------------------------------
3671 // Emit locking code.
3672 FastLockNode* GraphKit::shared_lock(Node* obj) {
3673   // bci is either a monitorenter bc or InvocationEntryBci
3674   // %%% SynchronizationEntryBCI is redundant; use InvocationEntryBci in interfaces
3675   assert(SynchronizationEntryBCI == InvocationEntryBci, &quot;&quot;);
3676 
3677   if( !GenerateSynchronizationCode )
3678     return NULL;                // Not locking things?
<span class="line-added">3679 </span>
3680   if (stopped())                // Dead monitor?
3681     return NULL;
3682 
3683   assert(dead_locals_are_killed(), &quot;should kill locals before sync. point&quot;);
3684 
3685   // Box the stack location
3686   Node* box = _gvn.transform(new BoxLockNode(next_monitor()));
3687   Node* mem = reset_memory();
3688 
3689   FastLockNode * flock = _gvn.transform(new FastLockNode(0, obj, box) )-&gt;as_FastLock();
3690   if (UseBiasedLocking &amp;&amp; PrintPreciseBiasedLockingStatistics) {
3691     // Create the counters for this fast lock.
3692     flock-&gt;create_lock_counter(sync_jvms()); // sync_jvms used to get current bci
3693   }
3694 
3695   // Create the rtm counters for this fast lock if needed.
3696   flock-&gt;create_rtm_lock_counter(sync_jvms()); // sync_jvms used to get current bci
3697 
3698   // Add monitor to debug info for the slow path.  If we block inside the
3699   // slow path and de-opt, we need the monitor hanging around
</pre>
<hr />
<pre>
3732   }
3733 #endif
3734 
3735   return flock;
3736 }
3737 
3738 
3739 //------------------------------shared_unlock----------------------------------
3740 // Emit unlocking code.
3741 void GraphKit::shared_unlock(Node* box, Node* obj) {
3742   // bci is either a monitorenter bc or InvocationEntryBci
3743   // %%% SynchronizationEntryBCI is redundant; use InvocationEntryBci in interfaces
3744   assert(SynchronizationEntryBCI == InvocationEntryBci, &quot;&quot;);
3745 
3746   if( !GenerateSynchronizationCode )
3747     return;
3748   if (stopped()) {               // Dead monitor?
3749     map()-&gt;pop_monitor();        // Kill monitor from debug info
3750     return;
3751   }
<span class="line-added">3752   assert(!obj-&gt;is_ValueTypeBase(), &quot;should not unlock on value type&quot;);</span>
3753 
3754   // Memory barrier to avoid floating things down past the locked region
3755   insert_mem_bar(Op_MemBarReleaseLock);
3756 
3757   const TypeFunc *tf = OptoRuntime::complete_monitor_exit_Type();
3758   UnlockNode *unlock = new UnlockNode(C, tf);
3759 #ifdef ASSERT
3760   unlock-&gt;set_dbg_jvms(sync_jvms());
3761 #endif
3762   uint raw_idx = Compile::AliasIdxRaw;
3763   unlock-&gt;init_req( TypeFunc::Control, control() );
3764   unlock-&gt;init_req( TypeFunc::Memory , memory(raw_idx) );
3765   unlock-&gt;init_req( TypeFunc::I_O    , top() )     ;   // does no i/o
3766   unlock-&gt;init_req( TypeFunc::FramePtr, frameptr() );
3767   unlock-&gt;init_req( TypeFunc::ReturnAdr, top() );
3768 
3769   unlock-&gt;init_req(TypeFunc::Parms + 0, obj);
3770   unlock-&gt;init_req(TypeFunc::Parms + 1, box);
3771   unlock = _gvn.transform(unlock)-&gt;as_Unlock();
3772 
3773   Node* mem = reset_memory();
3774 
3775   // unlock has no side-effects, sets few values
3776   set_predefined_output_for_runtime_call(unlock, mem, TypeRawPtr::BOTTOM);
3777 
3778   // Kill monitor from debug info
3779   map()-&gt;pop_monitor( );
3780 }
3781 
3782 //-------------------------------get_layout_helper-----------------------------
3783 // If the given klass is a constant or known to be an array,
3784 // fetch the constant layout helper value into constant_value
3785 // and return (Node*)NULL.  Otherwise, load the non-constant
3786 // layout helper value, and return the node which represents it.
3787 // This two-faced routine is useful because allocation sites
3788 // almost always feature constant types.
3789 Node* GraphKit::get_layout_helper(Node* klass_node, jint&amp; constant_value) {
3790   const TypeKlassPtr* inst_klass = _gvn.type(klass_node)-&gt;isa_klassptr();
3791   if (!StressReflectiveCode &amp;&amp; inst_klass != NULL) {
3792     ciKlass* klass = inst_klass-&gt;klass();
<span class="line-added">3793     assert(klass != NULL, &quot;klass should not be NULL&quot;);</span>
3794     bool    xklass = inst_klass-&gt;klass_is_exact();
<span class="line-modified">3795     bool can_be_flattened = false;</span>
<span class="line-added">3796     if (ValueArrayFlatten &amp;&amp; klass-&gt;is_obj_array_klass()) {</span>
<span class="line-added">3797       ciKlass* elem = klass-&gt;as_obj_array_klass()-&gt;element_klass();</span>
<span class="line-added">3798       can_be_flattened = elem-&gt;can_be_value_klass() &amp;&amp; (!elem-&gt;is_valuetype() || elem-&gt;as_value_klass()-&gt;flatten_array());</span>
<span class="line-added">3799     }</span>
<span class="line-added">3800     if (xklass || (klass-&gt;is_array_klass() &amp;&amp; !can_be_flattened)) {</span>
3801       jint lhelper = klass-&gt;layout_helper();
3802       if (lhelper != Klass::_lh_neutral_value) {
3803         constant_value = lhelper;
3804         return (Node*) NULL;
3805       }
3806     }
3807   }
3808   constant_value = Klass::_lh_neutral_value;  // put in a known value
3809   Node* lhp = basic_plus_adr(klass_node, klass_node, in_bytes(Klass::layout_helper_offset()));
3810   return make_load(NULL, lhp, TypeInt::INT, T_INT, MemNode::unordered);
3811 }
3812 
3813 // We just put in an allocate/initialize with a big raw-memory effect.
3814 // Hook selected additional alias categories on the initialization.
3815 static void hook_memory_on_init(GraphKit&amp; kit, int alias_idx,
3816                                 MergeMemNode* init_in_merge,
3817                                 Node* init_out_raw) {
3818   DEBUG_ONLY(Node* init_in_raw = init_in_merge-&gt;base_memory());
3819   assert(init_in_merge-&gt;memory_at(alias_idx) == init_in_raw, &quot;&quot;);
3820 
</pre>
<hr />
<pre>
3842 
3843   // a normal slow-call doesn&#39;t change i_o, but an allocation does
3844   // we create a separate i_o projection for the normal control path
3845   set_i_o(_gvn.transform( new ProjNode(allocx, TypeFunc::I_O, false) ) );
3846   Node* rawoop = _gvn.transform( new ProjNode(allocx, TypeFunc::Parms) );
3847 
3848   // put in an initialization barrier
3849   InitializeNode* init = insert_mem_bar_volatile(Op_Initialize, rawidx,
3850                                                  rawoop)-&gt;as_Initialize();
3851   assert(alloc-&gt;initialization() == init,  &quot;2-way macro link must work&quot;);
3852   assert(init -&gt;allocation()     == alloc, &quot;2-way macro link must work&quot;);
3853   {
3854     // Extract memory strands which may participate in the new object&#39;s
3855     // initialization, and source them from the new InitializeNode.
3856     // This will allow us to observe initializations when they occur,
3857     // and link them properly (as a group) to the InitializeNode.
3858     assert(init-&gt;in(InitializeNode::Memory) == malloc, &quot;&quot;);
3859     MergeMemNode* minit_in = MergeMemNode::make(malloc);
3860     init-&gt;set_req(InitializeNode::Memory, minit_in);
3861     record_for_igvn(minit_in); // fold it up later, if possible
<span class="line-added">3862     _gvn.set_type(minit_in, Type::MEMORY);</span>
3863     Node* minit_out = memory(rawidx);
3864     assert(minit_out-&gt;is_Proj() &amp;&amp; minit_out-&gt;in(0) == init, &quot;&quot;);
3865     // Add an edge in the MergeMem for the header fields so an access
3866     // to one of those has correct memory state
3867     set_memory(minit_out, C-&gt;get_alias_index(oop_type-&gt;add_offset(oopDesc::mark_offset_in_bytes())));
3868     set_memory(minit_out, C-&gt;get_alias_index(oop_type-&gt;add_offset(oopDesc::klass_offset_in_bytes())));
3869     if (oop_type-&gt;isa_aryptr()) {
<span class="line-modified">3870       const TypeAryPtr* arytype = oop_type-&gt;is_aryptr();</span>
<span class="line-modified">3871       if (arytype-&gt;klass()-&gt;is_value_array_klass()) {</span>
<span class="line-modified">3872         // Initially all flattened array accesses share a single slice</span>
<span class="line-added">3873         // but that changes after parsing. Prepare the memory graph so</span>
<span class="line-added">3874         // it can optimize flattened array accesses properly once they</span>
<span class="line-added">3875         // don&#39;t share a single slice.</span>
<span class="line-added">3876         assert(C-&gt;flattened_accesses_share_alias(), &quot;should be set at parse time&quot;);</span>
<span class="line-added">3877         C-&gt;set_flattened_accesses_share_alias(false);</span>
<span class="line-added">3878         ciValueArrayKlass* vak = arytype-&gt;klass()-&gt;as_value_array_klass();</span>
<span class="line-added">3879         ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-added">3880         for (int i = 0, len = vk-&gt;nof_nonstatic_fields(); i &lt; len; i++) {</span>
<span class="line-added">3881           ciField* field = vk-&gt;nonstatic_field_at(i);</span>
<span class="line-added">3882           if (field-&gt;offset() &gt;= TrackedInitializationLimit * HeapWordSize)</span>
<span class="line-added">3883             continue;  // do not bother to track really large numbers of fields</span>
<span class="line-added">3884           int off_in_vt = field-&gt;offset() - vk-&gt;first_field_offset();</span>
<span class="line-added">3885           const TypePtr* adr_type = arytype-&gt;with_field_offset(off_in_vt)-&gt;add_offset(Type::OffsetBot);</span>
<span class="line-added">3886           int fieldidx = C-&gt;get_alias_index(adr_type, true);</span>
<span class="line-added">3887           hook_memory_on_init(*this, fieldidx, minit_in, minit_out);</span>
<span class="line-added">3888         }</span>
<span class="line-added">3889         C-&gt;set_flattened_accesses_share_alias(true);</span>
<span class="line-added">3890         hook_memory_on_init(*this, C-&gt;get_alias_index(TypeAryPtr::VALUES), minit_in, minit_out);</span>
<span class="line-added">3891       } else {</span>
<span class="line-added">3892         const TypePtr* telemref = oop_type-&gt;add_offset(Type::OffsetBot);</span>
<span class="line-added">3893         int            elemidx  = C-&gt;get_alias_index(telemref);</span>
<span class="line-added">3894         hook_memory_on_init(*this, elemidx, minit_in, minit_out);</span>
<span class="line-added">3895       }</span>
3896     } else if (oop_type-&gt;isa_instptr()) {
<span class="line-added">3897       set_memory(minit_out, C-&gt;get_alias_index(oop_type)); // mark word</span>
3898       ciInstanceKlass* ik = oop_type-&gt;klass()-&gt;as_instance_klass();
3899       for (int i = 0, len = ik-&gt;nof_nonstatic_fields(); i &lt; len; i++) {
3900         ciField* field = ik-&gt;nonstatic_field_at(i);
3901         if (field-&gt;offset() &gt;= TrackedInitializationLimit * HeapWordSize)
3902           continue;  // do not bother to track really large numbers of fields
3903         // Find (or create) the alias category for this field:
3904         int fieldidx = C-&gt;alias_type(field)-&gt;index();
3905         hook_memory_on_init(*this, fieldidx, minit_in, minit_out);
3906       }
3907     }
3908   }
3909 
3910   // Cast raw oop to the real thing...
3911   Node* javaoop = new CheckCastPPNode(control(), rawoop, oop_type);
3912   javaoop = _gvn.transform(javaoop);
3913   C-&gt;set_recent_alloc(control(), javaoop);
3914   assert(just_allocated_object(control()) == javaoop, &quot;just allocated&quot;);
3915 
3916 #ifdef ASSERT
3917   { // Verify that the AllocateNode::Ideal_allocation recognizers work:
</pre>
<hr />
<pre>
3928       assert(alloc-&gt;in(AllocateNode::ALength)-&gt;is_top(), &quot;no length, please&quot;);
3929     }
3930   }
3931 #endif //ASSERT
3932 
3933   return javaoop;
3934 }
3935 
3936 //---------------------------new_instance--------------------------------------
3937 // This routine takes a klass_node which may be constant (for a static type)
3938 // or may be non-constant (for reflective code).  It will work equally well
3939 // for either, and the graph will fold nicely if the optimizer later reduces
3940 // the type to a constant.
3941 // The optional arguments are for specialized use by intrinsics:
3942 //  - If &#39;extra_slow_test&#39; if not null is an extra condition for the slow-path.
3943 //  - If &#39;return_size_val&#39;, report the the total object size to the caller.
3944 //  - deoptimize_on_exception controls how Java exceptions are handled (rethrow vs deoptimize)
3945 Node* GraphKit::new_instance(Node* klass_node,
3946                              Node* extra_slow_test,
3947                              Node* *return_size_val,
<span class="line-modified">3948                              bool deoptimize_on_exception,</span>
<span class="line-added">3949                              ValueTypeBaseNode* value_node) {</span>
3950   // Compute size in doublewords
3951   // The size is always an integral number of doublewords, represented
3952   // as a positive bytewise size stored in the klass&#39;s layout_helper.
3953   // The layout_helper also encodes (in a low bit) the need for a slow path.
3954   jint  layout_con = Klass::_lh_neutral_value;
3955   Node* layout_val = get_layout_helper(klass_node, layout_con);
<span class="line-modified">3956   bool  layout_is_con = (layout_val == NULL);</span>
3957 
3958   if (extra_slow_test == NULL)  extra_slow_test = intcon(0);
3959   // Generate the initial go-slow test.  It&#39;s either ALWAYS (return a
3960   // Node for 1) or NEVER (return a NULL) or perhaps (in the reflective
3961   // case) a computed value derived from the layout_helper.
3962   Node* initial_slow_test = NULL;
3963   if (layout_is_con) {
3964     assert(!StressReflectiveCode, &quot;stress mode does not use these paths&quot;);
3965     bool must_go_slow = Klass::layout_helper_needs_slow_path(layout_con);
3966     initial_slow_test = must_go_slow ? intcon(1) : extra_slow_test;
3967   } else {   // reflective case
3968     // This reflective path is used by Unsafe.allocateInstance.
3969     // (It may be stress-tested by specifying StressReflectiveCode.)
3970     // Basically, we want to get into the VM is there&#39;s an illegal argument.
3971     Node* bit = intcon(Klass::_lh_instance_slow_path_bit);
3972     initial_slow_test = _gvn.transform( new AndINode(layout_val, bit) );
3973     if (extra_slow_test != intcon(0)) {
3974       initial_slow_test = _gvn.transform( new OrINode(initial_slow_test, extra_slow_test) );
3975     }
3976     // (Macro-expander will further convert this to a Bool, if necessary.)
</pre>
<hr />
<pre>
3987 
3988     // Clear the low bits to extract layout_helper_size_in_bytes:
3989     assert((int)Klass::_lh_instance_slow_path_bit &lt; BytesPerLong, &quot;clear bit&quot;);
3990     Node* mask = MakeConX(~ (intptr_t)right_n_bits(LogBytesPerLong));
3991     size = _gvn.transform( new AndXNode(size, mask) );
3992   }
3993   if (return_size_val != NULL) {
3994     (*return_size_val) = size;
3995   }
3996 
3997   // This is a precise notnull oop of the klass.
3998   // (Actually, it need not be precise if this is a reflective allocation.)
3999   // It&#39;s what we cast the result to.
4000   const TypeKlassPtr* tklass = _gvn.type(klass_node)-&gt;isa_klassptr();
4001   if (!tklass)  tklass = TypeKlassPtr::OBJECT;
4002   const TypeOopPtr* oop_type = tklass-&gt;as_instance_type();
4003 
4004   // Now generate allocation code
4005 
4006   // The entire memory state is needed for slow path of the allocation
<span class="line-modified">4007   // since GC and deoptimization can happen.</span>
4008   Node *mem = reset_memory();
4009   set_all_memory(mem); // Create new memory state
4010 
4011   AllocateNode* alloc = new AllocateNode(C, AllocateNode::alloc_type(Type::TOP),
4012                                          control(), mem, i_o(),
4013                                          size, klass_node,
<span class="line-modified">4014                                          initial_slow_test, value_node);</span>
4015 
4016   return set_output_for_allocation(alloc, oop_type, deoptimize_on_exception);
4017 }
4018 
<span class="line-added">4019 // With compressed oops, the 64 bit init value for non flattened value</span>
<span class="line-added">4020 // arrays is built from 2 32 bit compressed oops</span>
<span class="line-added">4021 static Node* raw_default_for_coops(Node* default_value, GraphKit&amp; kit) {</span>
<span class="line-added">4022   Node* lower = kit.gvn().transform(new CastP2XNode(kit.control(), default_value));</span>
<span class="line-added">4023   Node* upper = kit.gvn().transform(new LShiftLNode(lower, kit.intcon(32)));</span>
<span class="line-added">4024   return kit.gvn().transform(new OrLNode(lower, upper));</span>
<span class="line-added">4025 }</span>
<span class="line-added">4026 </span>
4027 //-------------------------------new_array-------------------------------------
<span class="line-modified">4028 // helper for newarray and anewarray</span>
4029 // The &#39;length&#39; parameter is (obviously) the length of the array.
4030 // See comments on new_instance for the meaning of the other arguments.
4031 Node* GraphKit::new_array(Node* klass_node,     // array klass (maybe variable)
4032                           Node* length,         // number of array elements
4033                           int   nargs,          // number of arguments to push back for uncommon trap
4034                           Node* *return_size_val,
4035                           bool deoptimize_on_exception) {
4036   jint  layout_con = Klass::_lh_neutral_value;
4037   Node* layout_val = get_layout_helper(klass_node, layout_con);
<span class="line-modified">4038   bool  layout_is_con = (layout_val == NULL);</span>
4039 
4040   if (!layout_is_con &amp;&amp; !StressReflectiveCode &amp;&amp;
4041       !too_many_traps(Deoptimization::Reason_class_check)) {
4042     // This is a reflective array creation site.
4043     // Optimistically assume that it is a subtype of Object[],
4044     // so that we can fold up all the address arithmetic.
4045     layout_con = Klass::array_layout_helper(T_OBJECT);
4046     Node* cmp_lh = _gvn.transform( new CmpINode(layout_val, intcon(layout_con)) );
4047     Node* bol_lh = _gvn.transform( new BoolNode(cmp_lh, BoolTest::eq) );
4048     { BuildCutout unless(this, bol_lh, PROB_MAX);
4049       inc_sp(nargs);
4050       uncommon_trap(Deoptimization::Reason_class_check,
4051                     Deoptimization::Action_maybe_recompile);
4052     }
4053     layout_val = NULL;
4054     layout_is_con = true;
4055   }
4056 
4057   // Generate the initial go-slow test.  Make sure we do not overflow
4058   // if length is huge (near 2Gig) or negative!  We do not need
4059   // exact double-words here, just a close approximation of needed
4060   // double-words.  We can&#39;t add any offset or rounding bits, lest we
4061   // take a size -1 of bytes and make it positive.  Use an unsigned
4062   // compare, so negative sizes look hugely positive.
4063   int fast_size_limit = FastAllocateSizeLimit;
4064   if (layout_is_con) {
4065     assert(!StressReflectiveCode, &quot;stress mode does not use these paths&quot;);
4066     // Increase the size limit if we have exact knowledge of array type.
4067     int log2_esize = Klass::layout_helper_log2_element_size(layout_con);
<span class="line-modified">4068     fast_size_limit &lt;&lt;= MAX2(LogBytesPerLong - log2_esize, 0);</span>
4069   }
4070 
4071   Node* initial_slow_cmp  = _gvn.transform( new CmpUNode( length, intcon( fast_size_limit ) ) );
4072   Node* initial_slow_test = _gvn.transform( new BoolNode( initial_slow_cmp, BoolTest::gt ) );
4073 
4074   // --- Size Computation ---
4075   // array_size = round_to_heap(array_header + (length &lt;&lt; elem_shift));
4076   // where round_to_heap(x) == align_to(x, MinObjAlignmentInBytes)
4077   // and align_to(x, y) == ((x + y-1) &amp; ~(y-1))
4078   // The rounding mask is strength-reduced, if possible.
4079   int round_mask = MinObjAlignmentInBytes - 1;
4080   Node* header_size = NULL;
4081   int   header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);
4082   // (T_BYTE has the weakest alignment and size restrictions...)
4083   if (layout_is_con) {
4084     int       hsize  = Klass::layout_helper_header_size(layout_con);
4085     int       eshift = Klass::layout_helper_log2_element_size(layout_con);
<span class="line-modified">4086     bool is_value_array = Klass::layout_helper_is_valueArray(layout_con);</span>
4087     if ((round_mask &amp; ~right_n_bits(eshift)) == 0)
4088       round_mask = 0;  // strength-reduce it if it goes away completely
<span class="line-modified">4089     assert(is_value_array || (hsize &amp; right_n_bits(eshift)) == 0, &quot;hsize is pre-rounded&quot;);</span>
4090     assert(header_size_min &lt;= hsize, &quot;generic minimum is smallest&quot;);
4091     header_size_min = hsize;
4092     header_size = intcon(hsize + round_mask);
4093   } else {
4094     Node* hss   = intcon(Klass::_lh_header_size_shift);
4095     Node* hsm   = intcon(Klass::_lh_header_size_mask);
4096     Node* hsize = _gvn.transform( new URShiftINode(layout_val, hss) );
4097     hsize       = _gvn.transform( new AndINode(hsize, hsm) );
4098     Node* mask  = intcon(round_mask);
4099     header_size = _gvn.transform( new AddINode(hsize, mask) );
4100   }
4101 
4102   Node* elem_shift = NULL;
4103   if (layout_is_con) {
4104     int eshift = Klass::layout_helper_log2_element_size(layout_con);
4105     if (eshift != 0)
4106       elem_shift = intcon(eshift);
4107   } else {
4108     // There is no need to mask or shift this value.
4109     // The semantics of LShiftINode include an implicit mask to 0x1F.
</pre>
<hr />
<pre>
4153   // places, one where the length is sharply limited, and the other
4154   // after a successful allocation.
4155   Node* abody = lengthx;
4156   if (elem_shift != NULL)
4157     abody     = _gvn.transform( new LShiftXNode(lengthx, elem_shift) );
4158   Node* size  = _gvn.transform( new AddXNode(headerx, abody) );
4159   if (round_mask != 0) {
4160     Node* mask = MakeConX(~round_mask);
4161     size       = _gvn.transform( new AndXNode(size, mask) );
4162   }
4163   // else if round_mask == 0, the size computation is self-rounding
4164 
4165   if (return_size_val != NULL) {
4166     // This is the size
4167     (*return_size_val) = size;
4168   }
4169 
4170   // Now generate allocation code
4171 
4172   // The entire memory state is needed for slow path of the allocation
<span class="line-modified">4173   // since GC and deoptimization can happen.</span>
4174   Node *mem = reset_memory();
4175   set_all_memory(mem); // Create new memory state
4176 
4177   if (initial_slow_test-&gt;is_Bool()) {
4178     // Hide it behind a CMoveI, or else PhaseIdealLoop::split_up will get sick.
4179     initial_slow_test = initial_slow_test-&gt;as_Bool()-&gt;as_int_value(&amp;_gvn);
4180   }
4181 
<span class="line-added">4182   const TypeKlassPtr* ary_klass = _gvn.type(klass_node)-&gt;isa_klassptr();</span>
<span class="line-added">4183   const TypeOopPtr* ary_type = ary_klass-&gt;as_instance_type();</span>
<span class="line-added">4184   const TypeAryPtr* ary_ptr = ary_type-&gt;isa_aryptr();</span>
<span class="line-added">4185 </span>
<span class="line-added">4186   // Value type array variants:</span>
<span class="line-added">4187   // - null-ok:              MyValue.ref[] (ciObjArrayKlass &quot;[LMyValue$ref&quot;)</span>
<span class="line-added">4188   // - null-free:            MyValue.val[] (ciObjArrayKlass &quot;[QMyValue$val&quot;)</span>
<span class="line-added">4189   // - null-free, flattened: MyValue.val[] (ciValueArrayKlass &quot;[QMyValue$val&quot;)</span>
<span class="line-added">4190   // Check if array is a null-free, non-flattened value type array</span>
<span class="line-added">4191   // that needs to be initialized with the default value type.</span>
<span class="line-added">4192   Node* default_value = NULL;</span>
<span class="line-added">4193   Node* raw_default_value = NULL;</span>
<span class="line-added">4194   if (ary_ptr != NULL &amp;&amp; ary_ptr-&gt;klass_is_exact()) {</span>
<span class="line-added">4195     // Array type is known</span>
<span class="line-added">4196     ciKlass* elem_klass = ary_ptr-&gt;klass()-&gt;as_array_klass()-&gt;element_klass();</span>
<span class="line-added">4197     if (elem_klass != NULL &amp;&amp; elem_klass-&gt;is_valuetype()) {</span>
<span class="line-added">4198       ciValueKlass* vk = elem_klass-&gt;as_value_klass();</span>
<span class="line-added">4199       if (!vk-&gt;flatten_array()) {</span>
<span class="line-added">4200         default_value = ValueTypeNode::default_oop(gvn(), vk);</span>
<span class="line-added">4201         if (UseCompressedOops) {</span>
<span class="line-added">4202           default_value = _gvn.transform(new EncodePNode(default_value, default_value-&gt;bottom_type()-&gt;make_narrowoop()));</span>
<span class="line-added">4203           raw_default_value = raw_default_for_coops(default_value, *this);</span>
<span class="line-added">4204         } else {</span>
<span class="line-added">4205           raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));</span>
<span class="line-added">4206         }</span>
<span class="line-added">4207       }</span>
<span class="line-added">4208     }</span>
<span class="line-added">4209   } else if (ary_klass-&gt;klass()-&gt;can_be_value_array_klass()) {</span>
<span class="line-added">4210     // Array type is not known, add runtime checks</span>
<span class="line-added">4211     assert(!ary_klass-&gt;klass_is_exact(), &quot;unexpected exact type&quot;);</span>
<span class="line-added">4212     Node* r = new RegionNode(4);</span>
<span class="line-added">4213     default_value = new PhiNode(r, TypeInstPtr::BOTTOM);</span>
<span class="line-added">4214 </span>
<span class="line-added">4215     // Check if array is an object array</span>
<span class="line-added">4216     Node* cmp = gen_lh_array_test(klass_node, Klass::_lh_array_tag_obj_value);</span>
<span class="line-added">4217     Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));</span>
<span class="line-added">4218     IfNode* iff = create_and_map_if(control(), bol, PROB_FAIR, COUNT_UNKNOWN);</span>
<span class="line-added">4219 </span>
<span class="line-added">4220     // Not an object array, initialize with all zero</span>
<span class="line-added">4221     r-&gt;init_req(1, _gvn.transform(new IfFalseNode(iff)));</span>
<span class="line-added">4222     default_value-&gt;init_req(1, null());</span>
<span class="line-added">4223 </span>
<span class="line-added">4224     // Object array, check if null-free</span>
<span class="line-added">4225     set_control(_gvn.transform(new IfTrueNode(iff)));</span>
<span class="line-added">4226     Node* lhp = basic_plus_adr(klass_node, in_bytes(Klass::layout_helper_offset()));</span>
<span class="line-added">4227     Node* layout_val = _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), lhp, lhp-&gt;bottom_type()-&gt;is_ptr(), TypeInt::INT, T_INT, MemNode::unordered));</span>
<span class="line-added">4228     Node* null_free = _gvn.transform(new RShiftINode(layout_val, intcon(Klass::_lh_null_free_shift)));</span>
<span class="line-added">4229     null_free = _gvn.transform(new AndINode(null_free, intcon(Klass::_lh_null_free_mask)));</span>
<span class="line-added">4230     cmp = _gvn.transform(new CmpINode(null_free, intcon(0)));</span>
<span class="line-added">4231     bol = _gvn.transform(new BoolNode(cmp, BoolTest::ne));</span>
<span class="line-added">4232     iff = create_and_map_if(control(), bol, PROB_FAIR, COUNT_UNKNOWN);</span>
<span class="line-added">4233 </span>
<span class="line-added">4234     // Not null-free, initialize with all zero</span>
<span class="line-added">4235     r-&gt;init_req(2, _gvn.transform(new IfFalseNode(iff)));</span>
<span class="line-added">4236     default_value-&gt;init_req(2, null());</span>
<span class="line-added">4237 </span>
<span class="line-added">4238     // Null-free, non-flattened value array, initialize with the default value</span>
<span class="line-added">4239     set_control(_gvn.transform(new IfTrueNode(iff)));</span>
<span class="line-added">4240     Node* p = basic_plus_adr(klass_node, in_bytes(ArrayKlass::element_klass_offset()));</span>
<span class="line-added">4241     Node* eklass = _gvn.transform(LoadKlassNode::make(_gvn, control(), immutable_memory(), p, TypeInstPtr::KLASS));</span>
<span class="line-added">4242     Node* adr_fixed_block_addr = basic_plus_adr(eklass, in_bytes(InstanceKlass::adr_valueklass_fixed_block_offset()));</span>
<span class="line-added">4243     Node* adr_fixed_block = make_load(control(), adr_fixed_block_addr, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);</span>
<span class="line-added">4244     Node* default_value_offset_addr = basic_plus_adr(adr_fixed_block, in_bytes(ValueKlass::default_value_offset_offset()));</span>
<span class="line-added">4245     Node* default_value_offset = make_load(control(), default_value_offset_addr, TypeInt::INT, T_INT, MemNode::unordered);</span>
<span class="line-added">4246     Node* elem_mirror = load_mirror_from_klass(eklass);</span>
<span class="line-added">4247     Node* default_value_addr = basic_plus_adr(elem_mirror, ConvI2X(default_value_offset));</span>
<span class="line-added">4248     Node* val = access_load_at(elem_mirror, default_value_addr, _gvn.type(default_value_addr)-&gt;is_ptr(), TypeInstPtr::BOTTOM, T_OBJECT, IN_HEAP);</span>
<span class="line-added">4249     r-&gt;init_req(3, control());</span>
<span class="line-added">4250     default_value-&gt;init_req(3, val);</span>
<span class="line-added">4251 </span>
<span class="line-added">4252     set_control(_gvn.transform(r));</span>
<span class="line-added">4253     default_value = _gvn.transform(default_value);</span>
<span class="line-added">4254     if (UseCompressedOops) {</span>
<span class="line-added">4255       default_value = _gvn.transform(new EncodePNode(default_value, default_value-&gt;bottom_type()-&gt;make_narrowoop()));</span>
<span class="line-added">4256       raw_default_value = raw_default_for_coops(default_value, *this);</span>
<span class="line-added">4257     } else {</span>
<span class="line-added">4258       raw_default_value = _gvn.transform(new CastP2XNode(control(), default_value));</span>
<span class="line-added">4259     }</span>
<span class="line-added">4260   }</span>
<span class="line-added">4261 </span>
4262   // Create the AllocateArrayNode and its result projections
<span class="line-modified">4263   AllocateArrayNode* alloc = new AllocateArrayNode(C, AllocateArrayNode::alloc_type(TypeInt::INT),</span>
<span class="line-modified">4264                                                    control(), mem, i_o(),</span>
<span class="line-modified">4265                                                    size, klass_node,</span>
<span class="line-modified">4266                                                    initial_slow_test,</span>
<span class="line-modified">4267                                                    length, default_value,</span>
<span class="line-modified">4268                                                    raw_default_value);</span>
4269 
4270   // Cast to correct type.  Note that the klass_node may be constant or not,
4271   // and in the latter case the actual array type will be inexact also.
4272   // (This happens via a non-constant argument to inline_native_newArray.)
4273   // In any case, the value of klass_node provides the desired array type.
4274   const TypeInt* length_type = _gvn.find_int_type(length);

4275   if (ary_type-&gt;isa_aryptr() &amp;&amp; length_type != NULL) {
4276     // Try to get a better type than POS for the size
4277     ary_type = ary_type-&gt;is_aryptr()-&gt;cast_to_size(length_type);
4278   }
4279 
4280   Node* javaoop = set_output_for_allocation(alloc, ary_type, deoptimize_on_exception);
4281 
4282   // Cast length on remaining path to be as narrow as possible
4283   if (map()-&gt;find_edge(length) &gt;= 0) {
4284     Node* ccast = alloc-&gt;make_ideal_length(ary_type, &amp;_gvn);
4285     if (ccast != length) {
4286       _gvn.set_type_bottom(ccast);
4287       record_for_igvn(ccast);
4288       replace_in_map(length, ccast);
4289     }
4290   }
4291 
4292   return javaoop;
4293 }
4294 
</pre>
<hr />
<pre>
4412   set_all_memory(ideal.merged_memory());
4413   set_i_o(ideal.i_o());
4414   set_control(ideal.ctrl());
4415 }
4416 
4417 void GraphKit::final_sync(IdealKit&amp; ideal) {
4418   // Final sync IdealKit and graphKit.
4419   sync_kit(ideal);
4420 }
4421 
4422 Node* GraphKit::load_String_length(Node* str, bool set_ctrl) {
4423   Node* len = load_array_length(load_String_value(str, set_ctrl));
4424   Node* coder = load_String_coder(str, set_ctrl);
4425   // Divide length by 2 if coder is UTF16
4426   return _gvn.transform(new RShiftINode(len, coder));
4427 }
4428 
4429 Node* GraphKit::load_String_value(Node* str, bool set_ctrl) {
4430   int value_offset = java_lang_String::value_offset_in_bytes();
4431   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
<span class="line-modified">4432                                                      false, NULL, Type::Offset(0), false);</span>
4433   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
4434   const TypeAryPtr* value_type = TypeAryPtr::make(TypePtr::NotNull,
<span class="line-modified">4435                                                   TypeAry::make(TypeInt::BYTE, TypeInt::POS, false, true, true),</span>
<span class="line-modified">4436                                                   ciTypeArrayKlass::make(T_BYTE), true, Type::Offset(0));</span>
4437   Node* p = basic_plus_adr(str, str, value_offset);
4438   Node* load = access_load_at(str, p, value_field_type, value_type, T_OBJECT,
4439                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
4440   return load;
4441 }
4442 
4443 Node* GraphKit::load_String_coder(Node* str, bool set_ctrl) {
4444   if (!CompactStrings) {
4445     return intcon(java_lang_String::CODER_UTF16);
4446   }
4447   int coder_offset = java_lang_String::coder_offset_in_bytes();
4448   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
<span class="line-modified">4449                                                      false, NULL, Type::Offset(0), false);</span>
4450   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4451 
4452   Node* p = basic_plus_adr(str, str, coder_offset);
4453   Node* load = access_load_at(str, p, coder_field_type, TypeInt::BYTE, T_BYTE,
4454                               IN_HEAP | (set_ctrl ? C2_CONTROL_DEPENDENT_LOAD : 0) | MO_UNORDERED);
4455   return load;
4456 }
4457 
4458 void GraphKit::store_String_value(Node* str, Node* value) {
4459   int value_offset = java_lang_String::value_offset_in_bytes();
4460   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
<span class="line-modified">4461                                                      false, NULL, Type::Offset(0), false);</span>
4462   const TypePtr* value_field_type = string_type-&gt;add_offset(value_offset);
4463 
4464   access_store_at(str,  basic_plus_adr(str, value_offset), value_field_type,
4465                   value, TypeAryPtr::BYTES, T_OBJECT, IN_HEAP | MO_UNORDERED);
4466 }
4467 
4468 void GraphKit::store_String_coder(Node* str, Node* value) {
4469   int coder_offset = java_lang_String::coder_offset_in_bytes();
4470   const TypeInstPtr* string_type = TypeInstPtr::make(TypePtr::NotNull, C-&gt;env()-&gt;String_klass(),
<span class="line-modified">4471                                                      false, NULL, Type::Offset(0), false);</span>
4472   const TypePtr* coder_field_type = string_type-&gt;add_offset(coder_offset);
4473 
4474   access_store_at(str, basic_plus_adr(str, coder_offset), coder_field_type,
4475                   value, TypeInt::BYTE, T_BYTE, IN_HEAP | MO_UNORDERED);
4476 }
4477 
4478 // Capture src and dst memory state with a MergeMemNode
4479 Node* GraphKit::capture_memory(const TypePtr* src_type, const TypePtr* dst_type) {
4480   if (src_type == dst_type) {
4481     // Types are equal, we don&#39;t need a MergeMemNode
4482     return memory(src_type);
4483   }
4484   MergeMemNode* merge = MergeMemNode::make(map()-&gt;memory());
4485   record_for_igvn(merge); // fold it up later, if possible
4486   int src_idx = C-&gt;get_alias_index(src_type);
4487   int dst_idx = C-&gt;get_alias_index(dst_type);
4488   merge-&gt;set_memory_at(src_idx, memory(src_idx));
4489   merge-&gt;set_memory_at(dst_idx, memory(dst_idx));
4490   return merge;
4491 }
</pre>
<hr />
<pre>
4562   i_char-&gt;init_req(2, AddI(i_char, intcon(2)));
4563 
4564   set_control(IfFalse(iff));
4565   set_memory(st, TypeAryPtr::BYTES);
4566 }
4567 
4568 Node* GraphKit::make_constant_from_field(ciField* field, Node* obj) {
4569   if (!field-&gt;is_constant()) {
4570     return NULL; // Field not marked as constant.
4571   }
4572   ciInstance* holder = NULL;
4573   if (!field-&gt;is_static()) {
4574     ciObject* const_oop = obj-&gt;bottom_type()-&gt;is_oopptr()-&gt;const_oop();
4575     if (const_oop != NULL &amp;&amp; const_oop-&gt;is_instance()) {
4576       holder = const_oop-&gt;as_instance();
4577     }
4578   }
4579   const Type* con_type = Type::make_constant_from_field(field, holder, field-&gt;layout_type(),
4580                                                         /*is_unsigned_load=*/false);
4581   if (con_type != NULL) {
<span class="line-modified">4582     Node* con = makecon(con_type);</span>
<span class="line-added">4583     if (field-&gt;layout_type() == T_VALUETYPE &amp;&amp; field-&gt;type()-&gt;as_value_klass()-&gt;is_scalarizable() &amp;&amp; !con_type-&gt;maybe_null()) {</span>
<span class="line-added">4584       // Load value type from constant oop</span>
<span class="line-added">4585       con = ValueTypeNode::make_from_oop(this, con, field-&gt;type()-&gt;as_value_klass());</span>
<span class="line-added">4586     }</span>
<span class="line-added">4587     return con;</span>
4588   }
4589   return NULL;
4590 }
<span class="line-added">4591 </span>
<span class="line-added">4592 //---------------------------load_mirror_from_klass----------------------------</span>
<span class="line-added">4593 // Given a klass oop, load its java mirror (a java.lang.Class oop).</span>
<span class="line-added">4594 Node* GraphKit::load_mirror_from_klass(Node* klass) {</span>
<span class="line-added">4595   Node* p = basic_plus_adr(klass, in_bytes(Klass::java_mirror_offset()));</span>
<span class="line-added">4596   Node* load = make_load(NULL, p, TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered);</span>
<span class="line-added">4597   // mirror = ((OopHandle)mirror)-&gt;resolve();</span>
<span class="line-added">4598   return access_load(load, TypeInstPtr::MIRROR, T_OBJECT, IN_NATIVE);</span>
<span class="line-added">4599 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="library_call.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
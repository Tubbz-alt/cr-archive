<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/cfgnode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="castnode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classes.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/cfgnode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,10 ***</span>
<span class="line-new-header">--- 41,11 ---</span>
  #include &quot;opto/mulnode.hpp&quot;
  #include &quot;opto/phaseX.hpp&quot;
  #include &quot;opto/regmask.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
  #include &quot;opto/subnode.hpp&quot;
<span class="line-added">+ #include &quot;opto/valuetypenode.hpp&quot;</span>
  #include &quot;utilities/vmError.hpp&quot;
  
  // Portions of code courtesy of Clifford Click
  
  // Optimization - Graph Style
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,11 ***</span>
    }
  
    return true; // The Region node is unreachable - it is dead.
  }
  
<span class="line-modified">! bool RegionNode::try_clean_mem_phi(PhaseGVN *phase) {</span>
    // Incremental inlining + PhaseStringOpts sometimes produce:
    //
    // cmpP with 1 top input
    //           |
    //          If
<span class="line-new-header">--- 371,11 ---</span>
    }
  
    return true; // The Region node is unreachable - it is dead.
  }
  
<span class="line-modified">! Node* PhiNode::try_clean_mem_phi(PhaseGVN *phase) {</span>
    // Incremental inlining + PhaseStringOpts sometimes produce:
    //
    // cmpP with 1 top input
    //           |
    //          If
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,31 ***</span>
    // the Region stays in the graph. The top input from the cmpP is
    // propagated forward and a subgraph that is useful goes away. The
    // code below replaces the Phi with the MergeMem so that the Region
    // is simplified.
  
<span class="line-modified">!   PhiNode* phi = has_unique_phi();</span>
<span class="line-removed">-   if (phi &amp;&amp; phi-&gt;type() == Type::MEMORY &amp;&amp; req() == 3 &amp;&amp; phi-&gt;is_diamond_phi(true)) {</span>
      MergeMemNode* m = NULL;
<span class="line-modified">!     assert(phi-&gt;req() == 3, &quot;same as region&quot;);</span>
      for (uint i = 1; i &lt; 3; ++i) {
<span class="line-modified">!       Node *mem = phi-&gt;in(i);</span>
<span class="line-modified">!       if (mem &amp;&amp; mem-&gt;is_MergeMem() &amp;&amp; in(i)-&gt;outcnt() == 1) {</span>
          // Nothing is control-dependent on path #i except the region itself.
          m = mem-&gt;as_MergeMem();
          uint j = 3 - i;
<span class="line-modified">!         Node* other = phi-&gt;in(j);</span>
          if (other &amp;&amp; other == m-&gt;base_memory()) {
            // m is a successor memory to other, and is not pinned inside the diamond, so push it out.
            // This will allow the diamond to collapse completely.
<span class="line-modified">!           phase-&gt;is_IterGVN()-&gt;replace_node(phi, m);</span>
<span class="line-removed">-           return true;</span>
          }
        }
      }
    }
<span class="line-modified">!   return false;</span>
  }
  
  //------------------------------Ideal------------------------------------------
  // Return a node which is more &quot;ideal&quot; than the current node.  Must preserve
  // the CFG, but we can still strip out dead paths.
<span class="line-new-header">--- 391,30 ---</span>
    // the Region stays in the graph. The top input from the cmpP is
    // propagated forward and a subgraph that is useful goes away. The
    // code below replaces the Phi with the MergeMem so that the Region
    // is simplified.
  
<span class="line-modified">!   if (type() == Type::MEMORY &amp;&amp; is_diamond_phi(true)) {</span>
      MergeMemNode* m = NULL;
<span class="line-modified">!     assert(req() == 3, &quot;same as region&quot;);</span>
<span class="line-added">+     Node* r = in(0);</span>
      for (uint i = 1; i &lt; 3; ++i) {
<span class="line-modified">!       Node *mem = in(i);</span>
<span class="line-modified">!       if (mem &amp;&amp; mem-&gt;is_MergeMem() &amp;&amp; r-&gt;in(i)-&gt;outcnt() == 1) {</span>
          // Nothing is control-dependent on path #i except the region itself.
          m = mem-&gt;as_MergeMem();
          uint j = 3 - i;
<span class="line-modified">!         Node* other = in(j);</span>
          if (other &amp;&amp; other == m-&gt;base_memory()) {
            // m is a successor memory to other, and is not pinned inside the diamond, so push it out.
            // This will allow the diamond to collapse completely.
<span class="line-modified">!           return m;</span>
          }
        }
      }
    }
<span class="line-modified">!   return NULL;</span>
  }
  
  //------------------------------Ideal------------------------------------------
  // Return a node which is more &quot;ideal&quot; than the current node.  Must preserve
  // the CFG, but we can still strip out dead paths.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 425,12 ***</span>
    // Check for RegionNode with no Phi users and both inputs come from either
    // arm of the same IF.  If found, then the control-flow split is useless.
    bool has_phis = false;
    if (can_reshape) {            // Need DU info to check for Phi users
      has_phis = (has_phi() != NULL);       // Cache result
<span class="line-modified">!     if (has_phis &amp;&amp; try_clean_mem_phi(phase)) {</span>
<span class="line-modified">!       has_phis = false;</span>
      }
  
      if (!has_phis) {            // No Phi users?  Nothing merging?
        for (uint i = 1; i &lt; req()-1; i++) {
          Node *if1 = in(i);
<span class="line-new-header">--- 425,19 ---</span>
    // Check for RegionNode with no Phi users and both inputs come from either
    // arm of the same IF.  If found, then the control-flow split is useless.
    bool has_phis = false;
    if (can_reshape) {            // Need DU info to check for Phi users
      has_phis = (has_phi() != NULL);       // Cache result
<span class="line-modified">!     if (has_phis) {</span>
<span class="line-modified">!       PhiNode* phi = has_unique_phi();</span>
<span class="line-added">+       if (phi != NULL) {</span>
<span class="line-added">+         Node* m = phi-&gt;try_clean_mem_phi(phase);</span>
<span class="line-added">+         if (m != NULL) {</span>
<span class="line-added">+           phase-&gt;is_IterGVN()-&gt;replace_node(phi, m);</span>
<span class="line-added">+           has_phis = false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
      }
  
      if (!has_phis) {            // No Phi users?  Nothing merging?
        for (uint i = 1; i &lt; req()-1; i++) {
          Node *if1 = in(i);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 894,11 ***</span>
  
  //----------------------------make---------------------------------------------
  // create a new phi with edges matching r and set (initially) to x
  PhiNode* PhiNode::make(Node* r, Node* x, const Type *t, const TypePtr* at) {
    uint preds = r-&gt;req();   // Number of predecessor paths
<span class="line-modified">!   assert(t != Type::MEMORY || at == flatten_phi_adr_type(at), &quot;flatten at&quot;);</span>
    PhiNode* p = new PhiNode(r, t, at);
    for (uint j = 1; j &lt; preds; j++) {
      // Fill in all inputs, except those which the region does not yet have
      if (r-&gt;in(j) != NULL)
        p-&gt;init_req(j, x);
<span class="line-new-header">--- 901,11 ---</span>
  
  //----------------------------make---------------------------------------------
  // create a new phi with edges matching r and set (initially) to x
  PhiNode* PhiNode::make(Node* r, Node* x, const Type *t, const TypePtr* at) {
    uint preds = r-&gt;req();   // Number of predecessor paths
<span class="line-modified">!   assert(t != Type::MEMORY || at == flatten_phi_adr_type(at) || (flatten_phi_adr_type(at) == TypeAryPtr::VALUES &amp;&amp; Compile::current()-&gt;flattened_accesses_share_alias()), &quot;flatten at&quot;);</span>
    PhiNode* p = new PhiNode(r, t, at);
    for (uint j = 1; j &lt; preds; j++) {
      // Fill in all inputs, except those which the region does not yet have
      if (r-&gt;in(j) != NULL)
        p-&gt;init_req(j, x);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1104,19 ***</span>
    // convert the one to the other.
    const TypePtr* ttp = _type-&gt;make_ptr();
    const TypeInstPtr* ttip = (ttp != NULL) ? ttp-&gt;isa_instptr() : NULL;
    const TypeKlassPtr* ttkp = (ttp != NULL) ? ttp-&gt;isa_klassptr() : NULL;
    bool is_intf = false;
<span class="line-modified">!   if (ttip != NULL) {</span>
<span class="line-modified">!     ciKlass* k = ttip-&gt;klass();</span>
<span class="line-modified">!     if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_interface())</span>
<span class="line-modified">!       is_intf = true;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   if (ttkp != NULL) {</span>
<span class="line-removed">-     ciKlass* k = ttkp-&gt;klass();</span>
<span class="line-removed">-     if (k-&gt;is_loaded() &amp;&amp; k-&gt;is_interface())</span>
<span class="line-removed">-       is_intf = true;</span>
    }
  
    // Default case: merge all inputs
    const Type *t = Type::TOP;        // Merged type starting value
    for (uint i = 1; i &lt; req(); ++i) {// For all paths in
<span class="line-new-header">--- 1111,14 ---</span>
    // convert the one to the other.
    const TypePtr* ttp = _type-&gt;make_ptr();
    const TypeInstPtr* ttip = (ttp != NULL) ? ttp-&gt;isa_instptr() : NULL;
    const TypeKlassPtr* ttkp = (ttp != NULL) ? ttp-&gt;isa_klassptr() : NULL;
    bool is_intf = false;
<span class="line-modified">!   if (ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {</span>
<span class="line-modified">!     is_intf = true;</span>
<span class="line-modified">!   } else if (ttkp != NULL &amp;&amp; ttkp-&gt;is_loaded() &amp;&amp; ttkp-&gt;klass()-&gt;is_interface()) {</span>
<span class="line-modified">!     is_intf = true;</span>
    }
  
    // Default case: merge all inputs
    const Type *t = Type::TOP;        // Merged type starting value
    for (uint i = 1; i &lt; req(); ++i) {// For all paths in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1169,13 ***</span>
      // both implement interface I, but their meet is at &#39;j/l/O&#39; which
      // doesn&#39;t implement I, we have no way to tell if the result should
      // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
      // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
      // uplift the type.
<span class="line-modified">!     if (!t-&gt;empty() &amp;&amp; ttip &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {</span>
        assert(ft == _type, &quot;&quot;); // Uplift to interface
<span class="line-modified">!     } else if (!t-&gt;empty() &amp;&amp; ttkp &amp;&amp; ttkp-&gt;is_loaded() &amp;&amp; ttkp-&gt;klass()-&gt;is_interface()) {</span>
        assert(ft == _type, &quot;&quot;); // Uplift to interface
      } else {
        // We also have to handle &#39;evil cases&#39; of interface- vs. class-arrays
        Type::get_arrays_base_elements(jt, _type, NULL, &amp;ttip);
        if (!t-&gt;empty() &amp;&amp; ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {
<span class="line-new-header">--- 1171,13 ---</span>
      // both implement interface I, but their meet is at &#39;j/l/O&#39; which
      // doesn&#39;t implement I, we have no way to tell if the result should
      // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
      // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
      // uplift the type.
<span class="line-modified">!     if (!t-&gt;empty() &amp;&amp; ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {</span>
        assert(ft == _type, &quot;&quot;); // Uplift to interface
<span class="line-modified">!     } else if (!t-&gt;empty() &amp;&amp; ttkp != NULL &amp;&amp; ttkp-&gt;is_loaded() &amp;&amp; ttkp-&gt;klass()-&gt;is_interface()) {</span>
        assert(ft == _type, &quot;&quot;); // Uplift to interface
      } else {
        // We also have to handle &#39;evil cases&#39; of interface- vs. class-arrays
        Type::get_arrays_base_elements(jt, _type, NULL, &amp;ttip);
        if (!t-&gt;empty() &amp;&amp; ttip != NULL &amp;&amp; ttip-&gt;is_loaded() &amp;&amp; ttip-&gt;klass()-&gt;is_interface()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1333,10 ***</span>
<span class="line-new-header">--- 1335,18 ---</span>
    if (true_path != 0) {
      Node* id = is_cmove_id(phase, true_path);
      if (id != NULL)  return id;
    }
  
<span class="line-added">+   if (phase-&gt;is_IterGVN()) {</span>
<span class="line-added">+     Node* m = try_clean_mem_phi(phase);</span>
<span class="line-added">+     if (m != NULL) {</span>
<span class="line-added">+       return m;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
    return this;                     // No identity
  }
  
  //-----------------------------unique_input------------------------------------
  // Find the unique value, discounting top, self-loops, and casts.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1828,10 ***</span>
<span class="line-new-header">--- 1838,28 ---</span>
    // Note: During parsing, phis are often transformed before their regions.
    // This means we have to use type_or_null to defend against untyped regions.
    if( phase-&gt;type_or_null(r) == Type::TOP ) // Dead code?
      return NULL;                // No change
  
<span class="line-added">+   // If all inputs are value types of the same type, push the value type node down</span>
<span class="line-added">+   // through the phi because value type nodes should be merged through their input values.</span>
<span class="line-added">+   if (req() &gt; 2 &amp;&amp; in(1) != NULL &amp;&amp; in(1)-&gt;is_ValueTypeBase() &amp;&amp; (can_reshape || in(1)-&gt;is_ValueType())) {</span>
<span class="line-added">+     int opcode = in(1)-&gt;Opcode();</span>
<span class="line-added">+     uint i = 2;</span>
<span class="line-added">+     // Check if inputs are values of the same type</span>
<span class="line-added">+     for (; i &lt; req() &amp;&amp; in(i) &amp;&amp; in(i)-&gt;is_ValueTypeBase() &amp;&amp; in(i)-&gt;cmp(*in(1)); i++) {</span>
<span class="line-added">+       assert(in(i)-&gt;Opcode() == opcode, &quot;mixing pointers and values?&quot;);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (i == req()) {</span>
<span class="line-added">+       ValueTypeBaseNode* vt = in(1)-&gt;as_ValueTypeBase()-&gt;clone_with_phis(phase, in(0));</span>
<span class="line-added">+       for (uint i = 2; i &lt; req(); ++i) {</span>
<span class="line-added">+         vt-&gt;merge_with(phase, in(i)-&gt;as_ValueTypeBase(), i, i == (req()-1));</span>
<span class="line-added">+       }</span>
<span class="line-added">+       return vt;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    Node *top = phase-&gt;C-&gt;top();
    bool new_phi = (outcnt() == 0); // transforming new Phi
    // No change for igvn if new phi is not hooked
    if (new_phi &amp;&amp; can_reshape)
      return NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2571,10 ***</span>
<span class="line-new-header">--- 2599,16 ---</span>
    if( phase-&gt;type(in(1)) == Type::TOP ) return in(1);
    if( phase-&gt;type(in(0)) == Type::TOP ) return in(0);
    // We only come from CatchProj, unless the CatchProj goes away.
    // If the CatchProj is optimized away, then we just carry the
    // exception oop through.
<span class="line-added">+ </span>
<span class="line-added">+   // CheckCastPPNode::Ideal() for value types reuses the exception</span>
<span class="line-added">+   // paths of a call to perform an allocation: we can see a Phi here.</span>
<span class="line-added">+   if (in(1)-&gt;is_Phi()) {</span>
<span class="line-added">+     return this;</span>
<span class="line-added">+   }</span>
    CallNode *call = in(1)-&gt;in(0)-&gt;as_Call();
  
    return ( in(0)-&gt;is_CatchProj() &amp;&amp; in(0)-&gt;in(0)-&gt;in(1) == in(1) )
      ? this
      : call-&gt;in(TypeFunc::Parms);
</pre>
<center><a href="castnode.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classes.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
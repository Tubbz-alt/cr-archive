<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 58   unsigned int _max_nonstatic_oop_maps;
 59 
 60   OopMapBlocksBuilder(unsigned int  max_blocks);
 61   OopMapBlock* last_oop_map() const;
 62   void initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks);
 63   void add(int offset, int count);
 64   void copy(OopMapBlock* dst);
 65   void compact();
 66   void print_on(outputStream* st) const;
 67   void print_value_on(outputStream* st) const;
 68 };
 69 
 70 // Values needed for oopmap and InstanceKlass creation
 71 class FieldLayoutInfo : public ResourceObj {
 72  public:
 73   OopMapBlocksBuilder* oop_map_blocks;
 74   int _instance_size;
 75   int _nonstatic_field_size;
 76   int _static_field_size;
 77   bool  _has_nonstatic_fields;

 78 };
 79 
 80 // Parser for for .class files
 81 //
 82 // The bytes describing the class file structure is read from a Stream object
 83 
 84 class ClassFileParser {
 85   friend class FieldLayoutBuilder;
 86   friend class FieldLayout;
 87 
 88   class ClassAnnotationCollector;
 89   class FieldAllocationCount;
 90   class FieldAnnotationCollector;
 91 
 92  public:
 93   // The ClassFileParser has an associated &quot;publicity&quot; level
 94   // It is used to control which subsystems (if any)
 95   // will observe the parsing (logging, events, tracing).
 96   // Default level is &quot;BROADCAST&quot;, which is equivalent to
 97   // a &quot;public&quot; parsing attempt.
</pre>
<hr />
<pre>
116   const InstanceKlass* _unsafe_anonymous_host;
117   GrowableArray&lt;Handle&gt;* _cp_patches; // overrides for CP entries
118   const bool _is_hidden;
119   const bool _can_access_vm_annotations;
120   int _num_patched_klasses;
121   int _max_num_patched_klasses;
122   int _orig_cp_size;
123   int _first_patched_klass_resolved_index;
124 
125   // Metadata created before the instance klass is created.  Must be deallocated
126   // if not transferred to the InstanceKlass upon successful class loading
127   // in which case these pointers have been set to NULL.
128   const InstanceKlass* _super_klass;
129   ConstantPool* _cp;
130   Array&lt;u2&gt;* _fields;
131   Array&lt;Method*&gt;* _methods;
132   Array&lt;u2&gt;* _inner_classes;
133   Array&lt;u2&gt;* _nest_members;
134   u2 _nest_host;
135   Array&lt;RecordComponent*&gt;* _record_components;

136   Array&lt;InstanceKlass*&gt;* _local_interfaces;
137   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
138   Annotations* _combined_annotations;
139   AnnotationArray* _class_annotations;
140   AnnotationArray* _class_type_annotations;
141   Array&lt;AnnotationArray*&gt;* _fields_annotations;
142   Array&lt;AnnotationArray*&gt;* _fields_type_annotations;
143   InstanceKlass* _klass;  // InstanceKlass* once created.
144   InstanceKlass* _klass_to_deallocate; // an InstanceKlass* to be destroyed
145 
146   ClassAnnotationCollector* _parsed_annotations;
147   FieldAllocationCount* _fac;
148   FieldLayoutInfo* _field_info;
149   const intArray* _method_ordering;
150   GrowableArray&lt;Method*&gt;* _all_mirandas;
151 
152   enum { fixed_buffer_size = 128 };
153   u_char _linenumbertable_buffer[fixed_buffer_size];
154 
155   // Size of Java vtable (in words)
156   int _vtable_size;
157   int _itable_size;
158 
159   int _num_miranda_methods;
160 




161   ReferenceType _rt;
162   Handle _protection_domain;
163   AccessFlags _access_flags;
164 
165   // for tracing and notifications
166   Publicity _pub_level;
167 
168   // Used to keep track of whether a constant pool item 19 or 20 is found.  These
169   // correspond to CONSTANT_Module and CONSTANT_Package tags and are not allowed
170   // in regular class files.  For class file version &gt;= 53, a CFE cannot be thrown
171   // immediately when these are seen because a NCDFE must be thrown if the class&#39;s
172   // access_flags have ACC_MODULE set.  But, the access_flags haven&#39;t been looked
173   // at yet.  So, the bad constant pool item is cached here.  A value of zero
174   // means that no constant pool item 19 or 20 was found.
175   short _bad_constant_seen;
176 
177   // class attributes parsed before the instance klass is created:
178   bool _synthetic_flag;
179   int _sde_length;
180   const char* _sde_buffer;
181   u2 _sourcefile_index;
182   u2 _generic_signature_index;
183 
184   u2 _major_version;
185   u2 _minor_version;
186   u2 _this_class_index;
187   u2 _super_class_index;
188   u2 _itfs_len;
189   u2 _java_fields_count;
190 
191   bool _need_verify;
192   bool _relax_verify;
193 
194   bool _has_nonstatic_concrete_methods;
195   bool _declares_nonstatic_concrete_methods;
196   bool _has_final_method;
197   bool _has_contended_fields;
198 










199   // precomputed flags
200   bool _has_finalizer;
201   bool _has_empty_finalizer;
202   bool _has_vanilla_constructor;
203   int _max_bootstrap_specifier_index;  // detects BSS values
204 
205   void parse_stream(const ClassFileStream* const stream, TRAPS);
206 
207   void mangle_hidden_class_name(InstanceKlass* const ik);
208 
209   void post_process_parsed_stream(const ClassFileStream* const stream,
210                                   ConstantPool* cp,
211                                   TRAPS);
212 
213   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
214   void fix_unsafe_anonymous_class_name(TRAPS);
215 
216   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH,
217                            const ClassInstanceInfo&amp; cl_inst_info, TRAPS);
218 
</pre>
<hr />
<pre>
228   void create_combined_annotations(TRAPS);
229   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
230   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
231   void clear_class_metadata();
232 
233   // Constant pool parsing
234   void parse_constant_pool_entries(const ClassFileStream* const stream,
235                                    ConstantPool* cp,
236                                    const int length,
237                                    TRAPS);
238 
239   void parse_constant_pool(const ClassFileStream* const cfs,
240                            ConstantPool* const cp,
241                            const int length,
242                            TRAPS);
243 
244   // Interface parsing
245   void parse_interfaces(const ClassFileStream* const stream,
246                         const int itfs_len,
247                         ConstantPool* const cp,

248                         bool* has_nonstatic_concrete_methods,

249                         TRAPS);
250 
251   const InstanceKlass* parse_super_class(ConstantPool* const cp,
252                                          const int super_class_index,
253                                          const bool need_verify,
254                                          TRAPS);
255 
256   // Field parsing
257   void parse_field_attributes(const ClassFileStream* const cfs,
258                               u2 attributes_count,
259                               bool is_static,
260                               u2 signature_index,
261                               u2* const constantvalue_index_addr,
262                               bool* const is_synthetic_addr,
263                               u2* const generic_signature_index_addr,
264                               FieldAnnotationCollector* parsed_annotations,
265                               TRAPS);
266 
267   void parse_fields(const ClassFileStream* const cfs,
268                     bool is_interface,

269                     FieldAllocationCount* const fac,
270                     ConstantPool* cp,
271                     const int cp_size,
272                     u2* const java_fields_count_ptr,
273                     TRAPS);
274 
275   // Method parsing
276   Method* parse_method(const ClassFileStream* const cfs,
277                        bool is_interface,

278                        const ConstantPool* cp,
279                        AccessFlags* const promoted_flags,
280                        TRAPS);
281 
282   void parse_methods(const ClassFileStream* const cfs,
283                      bool is_interface,

284                      AccessFlags* const promoted_flags,
285                      bool* const has_final_method,
286                      bool* const declares_nonstatic_concrete_methods,
287                      TRAPS);
288 
289   const unsafe_u2* parse_exception_table(const ClassFileStream* const stream,
290                                          u4 code_length,
291                                          u4 exception_table_length,
292                                          TRAPS);
293 
294   void parse_linenumber_table(u4 code_attribute_length,
295                               u4 code_length,
296                               CompressedLineNumberWriteStream**const write_stream,
297                               TRAPS);
298 
299   const unsafe_u2* parse_localvariable_table(const ClassFileStream* const cfs,
300                                              u4 code_length,
301                                              u2 max_locals,
302                                              u4 code_attribute_length,
303                                              u2* const localvariable_table_length,
</pre>
<hr />
<pre>
420   inline void guarantee_property(bool b,
421                                  const char* msg,
422                                  const char *name,
423                                  TRAPS) const {
424     if (!b) { classfile_parse_error(msg, name, CHECK); }
425   }
426 
427   inline void guarantee_property(bool b,
428                                  const char* msg,
429                                  int index,
430                                  const char *name,
431                                  TRAPS) const {
432     if (!b) { classfile_parse_error(msg, index, name, CHECK); }
433   }
434 
435   void throwIllegalSignature(const char* type,
436                              const Symbol* name,
437                              const Symbol* sig,
438                              TRAPS) const;
439 





440   void verify_constantvalue(const ConstantPool* const cp,
441                             int constantvalue_index,
442                             int signature_index,
443                             TRAPS) const;
444 
445   void verify_legal_utf8(const unsigned char* buffer, int length, TRAPS) const;
446   void verify_legal_class_name(const Symbol* name, TRAPS) const;
447   void verify_legal_field_name(const Symbol* name, TRAPS) const;
448   void verify_legal_method_name(const Symbol* name, TRAPS) const;
449 
450   void verify_legal_field_signature(const Symbol* fieldname,
451                                     const Symbol* signature,
452                                     TRAPS) const;
453   int  verify_legal_method_signature(const Symbol* methodname,
454                                      const Symbol* signature,
455                                      TRAPS) const;
456 
457   void verify_legal_class_modifiers(jint flags, TRAPS) const;
<span class="line-modified">458   void verify_legal_field_modifiers(jint flags, bool is_interface, TRAPS) const;</span>



459   void verify_legal_method_modifiers(jint flags,
460                                      bool is_interface,

461                                      const Symbol* name,
462                                      TRAPS) const;
463 
464   const char* skip_over_field_signature(const char* signature,
465                                         bool void_ok,
466                                         unsigned int length,
467                                         TRAPS) const;
468 
469   bool has_cp_patch_at(int index) const {
470     assert(index &gt;= 0, &quot;oob&quot;);
471     return (_cp_patches != NULL
472             &amp;&amp; index &lt; _cp_patches-&gt;length()
473             &amp;&amp; _cp_patches-&gt;adr_at(index)-&gt;not_null());
474   }
475 
476   Handle cp_patch_at(int index) const {
477     assert(has_cp_patch_at(index), &quot;oob&quot;);
478     return _cp_patches-&gt;at(index);
479   }
480 
</pre>
<hr />
<pre>
519                                int runtime_visible_parameter_annotations_length,
520                                const u1* runtime_invisible_parameter_annotations,
521                                int runtime_invisible_parameter_annotations_length,
522                                const u1* runtime_visible_type_annotations,
523                                int runtime_visible_type_annotations_length,
524                                const u1* runtime_invisible_type_annotations,
525                                int runtime_invisible_type_annotations_length,
526                                const u1* annotation_default,
527                                int annotation_default_length,
528                                TRAPS);
529 
530   // lays out fields in class and returns the total oopmap count
531   void layout_fields(ConstantPool* cp,
532                      const FieldAllocationCount* fac,
533                      const ClassAnnotationCollector* parsed_annotations,
534                      FieldLayoutInfo* info,
535                      TRAPS);
536 
537   void update_class_name(Symbol* new_name);
538 



539  public:
540   ClassFileParser(ClassFileStream* stream,
541                   Symbol* name,
542                   ClassLoaderData* loader_data,
543                   const ClassLoadInfo* cl_info,
544                   Publicity pub_level,
545                   TRAPS);
546 
547   ~ClassFileParser();
548 
549   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, const ClassInstanceInfo&amp; cl_inst_info, TRAPS);
550 
551   const ClassFileStream* clone_stream() const;
552 
553   void set_klass_to_deallocate(InstanceKlass* klass);
554 
555   int static_field_size() const;
556   int total_oop_map_count() const;
557   jint layout_size() const;
558 
559   int vtable_size() const { return _vtable_size; }
560   int itable_size() const { return _itable_size; }
561 
562   u2 this_class_index() const { return _this_class_index; }
563 
564   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
565   bool is_hidden() const { return _is_hidden; }
566   bool is_interface() const { return _access_flags.is_interface(); }










567 
568   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
569   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
570   ClassLoaderData* loader_data() const { return _loader_data; }
571   const Symbol* class_name() const { return _class_name; }
572   const InstanceKlass* super_klass() const { return _super_klass; }
573 
574   ReferenceType reference_type() const { return _rt; }
575   AccessFlags access_flags() const { return _access_flags; }
576 
577   bool is_internal() const { return INTERNAL == _pub_level; }
578 
579   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
580 
581 #ifdef ASSERT
582   static bool is_internal_format(Symbol* class_name);
583 #endif
584 
585 };
586 
</pre>
</td>
<td>
<hr />
<pre>
 58   unsigned int _max_nonstatic_oop_maps;
 59 
 60   OopMapBlocksBuilder(unsigned int  max_blocks);
 61   OopMapBlock* last_oop_map() const;
 62   void initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks);
 63   void add(int offset, int count);
 64   void copy(OopMapBlock* dst);
 65   void compact();
 66   void print_on(outputStream* st) const;
 67   void print_value_on(outputStream* st) const;
 68 };
 69 
 70 // Values needed for oopmap and InstanceKlass creation
 71 class FieldLayoutInfo : public ResourceObj {
 72  public:
 73   OopMapBlocksBuilder* oop_map_blocks;
 74   int _instance_size;
 75   int _nonstatic_field_size;
 76   int _static_field_size;
 77   bool  _has_nonstatic_fields;
<span class="line-added"> 78   bool  _is_naturally_atomic;</span>
 79 };
 80 
 81 // Parser for for .class files
 82 //
 83 // The bytes describing the class file structure is read from a Stream object
 84 
 85 class ClassFileParser {
 86   friend class FieldLayoutBuilder;
 87   friend class FieldLayout;
 88 
 89   class ClassAnnotationCollector;
 90   class FieldAllocationCount;
 91   class FieldAnnotationCollector;
 92 
 93  public:
 94   // The ClassFileParser has an associated &quot;publicity&quot; level
 95   // It is used to control which subsystems (if any)
 96   // will observe the parsing (logging, events, tracing).
 97   // Default level is &quot;BROADCAST&quot;, which is equivalent to
 98   // a &quot;public&quot; parsing attempt.
</pre>
<hr />
<pre>
117   const InstanceKlass* _unsafe_anonymous_host;
118   GrowableArray&lt;Handle&gt;* _cp_patches; // overrides for CP entries
119   const bool _is_hidden;
120   const bool _can_access_vm_annotations;
121   int _num_patched_klasses;
122   int _max_num_patched_klasses;
123   int _orig_cp_size;
124   int _first_patched_klass_resolved_index;
125 
126   // Metadata created before the instance klass is created.  Must be deallocated
127   // if not transferred to the InstanceKlass upon successful class loading
128   // in which case these pointers have been set to NULL.
129   const InstanceKlass* _super_klass;
130   ConstantPool* _cp;
131   Array&lt;u2&gt;* _fields;
132   Array&lt;Method*&gt;* _methods;
133   Array&lt;u2&gt;* _inner_classes;
134   Array&lt;u2&gt;* _nest_members;
135   u2 _nest_host;
136   Array&lt;RecordComponent*&gt;* _record_components;
<span class="line-added">137   GrowableArray&lt;InstanceKlass*&gt;* _temp_local_interfaces;</span>
138   Array&lt;InstanceKlass*&gt;* _local_interfaces;
139   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
140   Annotations* _combined_annotations;
141   AnnotationArray* _class_annotations;
142   AnnotationArray* _class_type_annotations;
143   Array&lt;AnnotationArray*&gt;* _fields_annotations;
144   Array&lt;AnnotationArray*&gt;* _fields_type_annotations;
145   InstanceKlass* _klass;  // InstanceKlass* once created.
146   InstanceKlass* _klass_to_deallocate; // an InstanceKlass* to be destroyed
147 
148   ClassAnnotationCollector* _parsed_annotations;
149   FieldAllocationCount* _fac;
150   FieldLayoutInfo* _field_info;
151   const intArray* _method_ordering;
152   GrowableArray&lt;Method*&gt;* _all_mirandas;
153 
154   enum { fixed_buffer_size = 128 };
155   u_char _linenumbertable_buffer[fixed_buffer_size];
156 
157   // Size of Java vtable (in words)
158   int _vtable_size;
159   int _itable_size;
160 
161   int _num_miranda_methods;
162 
<span class="line-added">163   int _alignment;</span>
<span class="line-added">164   int _first_field_offset;</span>
<span class="line-added">165   int _exact_size_in_bytes;</span>
<span class="line-added">166 </span>
167   ReferenceType _rt;
168   Handle _protection_domain;
169   AccessFlags _access_flags;
170 
171   // for tracing and notifications
172   Publicity _pub_level;
173 
174   // Used to keep track of whether a constant pool item 19 or 20 is found.  These
175   // correspond to CONSTANT_Module and CONSTANT_Package tags and are not allowed
176   // in regular class files.  For class file version &gt;= 53, a CFE cannot be thrown
177   // immediately when these are seen because a NCDFE must be thrown if the class&#39;s
178   // access_flags have ACC_MODULE set.  But, the access_flags haven&#39;t been looked
179   // at yet.  So, the bad constant pool item is cached here.  A value of zero
180   // means that no constant pool item 19 or 20 was found.
181   short _bad_constant_seen;
182 
183   // class attributes parsed before the instance klass is created:
184   bool _synthetic_flag;
185   int _sde_length;
186   const char* _sde_buffer;
187   u2 _sourcefile_index;
188   u2 _generic_signature_index;
189 
190   u2 _major_version;
191   u2 _minor_version;
192   u2 _this_class_index;
193   u2 _super_class_index;
194   u2 _itfs_len;
195   u2 _java_fields_count;
196 
197   bool _need_verify;
198   bool _relax_verify;
199 
200   bool _has_nonstatic_concrete_methods;
201   bool _declares_nonstatic_concrete_methods;
202   bool _has_final_method;
203   bool _has_contended_fields;
204 
<span class="line-added">205   bool _has_flattenable_fields;</span>
<span class="line-added">206   bool _has_nonstatic_fields;</span>
<span class="line-added">207   bool _is_empty_inline_type;</span>
<span class="line-added">208   bool _is_naturally_atomic;</span>
<span class="line-added">209   bool _is_declared_atomic;</span>
<span class="line-added">210   bool _invalid_inline_super;   // if true, invalid super type for an inline type.</span>
<span class="line-added">211   bool _invalid_identity_super; // if true, invalid super type for an identity type.</span>
<span class="line-added">212   bool _implements_identityObject;</span>
<span class="line-added">213   bool _has_injected_identityObject;</span>
<span class="line-added">214 </span>
215   // precomputed flags
216   bool _has_finalizer;
217   bool _has_empty_finalizer;
218   bool _has_vanilla_constructor;
219   int _max_bootstrap_specifier_index;  // detects BSS values
220 
221   void parse_stream(const ClassFileStream* const stream, TRAPS);
222 
223   void mangle_hidden_class_name(InstanceKlass* const ik);
224 
225   void post_process_parsed_stream(const ClassFileStream* const stream,
226                                   ConstantPool* cp,
227                                   TRAPS);
228 
229   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
230   void fix_unsafe_anonymous_class_name(TRAPS);
231 
232   void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH,
233                            const ClassInstanceInfo&amp; cl_inst_info, TRAPS);
234 
</pre>
<hr />
<pre>
244   void create_combined_annotations(TRAPS);
245   void apply_parsed_class_attributes(InstanceKlass* k);  // update k
246   void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);
247   void clear_class_metadata();
248 
249   // Constant pool parsing
250   void parse_constant_pool_entries(const ClassFileStream* const stream,
251                                    ConstantPool* cp,
252                                    const int length,
253                                    TRAPS);
254 
255   void parse_constant_pool(const ClassFileStream* const cfs,
256                            ConstantPool* const cp,
257                            const int length,
258                            TRAPS);
259 
260   // Interface parsing
261   void parse_interfaces(const ClassFileStream* const stream,
262                         const int itfs_len,
263                         ConstantPool* const cp,
<span class="line-added">264                         bool is_inline_type,</span>
265                         bool* has_nonstatic_concrete_methods,
<span class="line-added">266                         bool* is_declared_atomic,</span>
267                         TRAPS);
268 
269   const InstanceKlass* parse_super_class(ConstantPool* const cp,
270                                          const int super_class_index,
271                                          const bool need_verify,
272                                          TRAPS);
273 
274   // Field parsing
275   void parse_field_attributes(const ClassFileStream* const cfs,
276                               u2 attributes_count,
277                               bool is_static,
278                               u2 signature_index,
279                               u2* const constantvalue_index_addr,
280                               bool* const is_synthetic_addr,
281                               u2* const generic_signature_index_addr,
282                               FieldAnnotationCollector* parsed_annotations,
283                               TRAPS);
284 
285   void parse_fields(const ClassFileStream* const cfs,
286                     bool is_interface,
<span class="line-added">287                     bool is_inline_type,</span>
288                     FieldAllocationCount* const fac,
289                     ConstantPool* cp,
290                     const int cp_size,
291                     u2* const java_fields_count_ptr,
292                     TRAPS);
293 
294   // Method parsing
295   Method* parse_method(const ClassFileStream* const cfs,
296                        bool is_interface,
<span class="line-added">297                        bool is_inline_type,</span>
298                        const ConstantPool* cp,
299                        AccessFlags* const promoted_flags,
300                        TRAPS);
301 
302   void parse_methods(const ClassFileStream* const cfs,
303                      bool is_interface,
<span class="line-added">304                      bool is_inline_type,</span>
305                      AccessFlags* const promoted_flags,
306                      bool* const has_final_method,
307                      bool* const declares_nonstatic_concrete_methods,
308                      TRAPS);
309 
310   const unsafe_u2* parse_exception_table(const ClassFileStream* const stream,
311                                          u4 code_length,
312                                          u4 exception_table_length,
313                                          TRAPS);
314 
315   void parse_linenumber_table(u4 code_attribute_length,
316                               u4 code_length,
317                               CompressedLineNumberWriteStream**const write_stream,
318                               TRAPS);
319 
320   const unsafe_u2* parse_localvariable_table(const ClassFileStream* const cfs,
321                                              u4 code_length,
322                                              u2 max_locals,
323                                              u4 code_attribute_length,
324                                              u2* const localvariable_table_length,
</pre>
<hr />
<pre>
441   inline void guarantee_property(bool b,
442                                  const char* msg,
443                                  const char *name,
444                                  TRAPS) const {
445     if (!b) { classfile_parse_error(msg, name, CHECK); }
446   }
447 
448   inline void guarantee_property(bool b,
449                                  const char* msg,
450                                  int index,
451                                  const char *name,
452                                  TRAPS) const {
453     if (!b) { classfile_parse_error(msg, index, name, CHECK); }
454   }
455 
456   void throwIllegalSignature(const char* type,
457                              const Symbol* name,
458                              const Symbol* sig,
459                              TRAPS) const;
460 
<span class="line-added">461   void throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-added">462                                  const char* msg,</span>
<span class="line-added">463                                  const Symbol* name = NULL,</span>
<span class="line-added">464                                  const Symbol* sig  = NULL) const;</span>
<span class="line-added">465 </span>
466   void verify_constantvalue(const ConstantPool* const cp,
467                             int constantvalue_index,
468                             int signature_index,
469                             TRAPS) const;
470 
471   void verify_legal_utf8(const unsigned char* buffer, int length, TRAPS) const;
472   void verify_legal_class_name(const Symbol* name, TRAPS) const;
473   void verify_legal_field_name(const Symbol* name, TRAPS) const;
474   void verify_legal_method_name(const Symbol* name, TRAPS) const;
475 
476   void verify_legal_field_signature(const Symbol* fieldname,
477                                     const Symbol* signature,
478                                     TRAPS) const;
479   int  verify_legal_method_signature(const Symbol* methodname,
480                                      const Symbol* signature,
481                                      TRAPS) const;
482 
483   void verify_legal_class_modifiers(jint flags, TRAPS) const;
<span class="line-modified">484   void verify_legal_field_modifiers(jint flags,</span>
<span class="line-added">485                                     bool is_interface,</span>
<span class="line-added">486                                     bool is_inline_type,</span>
<span class="line-added">487                                     TRAPS) const;</span>
488   void verify_legal_method_modifiers(jint flags,
489                                      bool is_interface,
<span class="line-added">490                                      bool is_inline_type,</span>
491                                      const Symbol* name,
492                                      TRAPS) const;
493 
494   const char* skip_over_field_signature(const char* signature,
495                                         bool void_ok,
496                                         unsigned int length,
497                                         TRAPS) const;
498 
499   bool has_cp_patch_at(int index) const {
500     assert(index &gt;= 0, &quot;oob&quot;);
501     return (_cp_patches != NULL
502             &amp;&amp; index &lt; _cp_patches-&gt;length()
503             &amp;&amp; _cp_patches-&gt;adr_at(index)-&gt;not_null());
504   }
505 
506   Handle cp_patch_at(int index) const {
507     assert(has_cp_patch_at(index), &quot;oob&quot;);
508     return _cp_patches-&gt;at(index);
509   }
510 
</pre>
<hr />
<pre>
549                                int runtime_visible_parameter_annotations_length,
550                                const u1* runtime_invisible_parameter_annotations,
551                                int runtime_invisible_parameter_annotations_length,
552                                const u1* runtime_visible_type_annotations,
553                                int runtime_visible_type_annotations_length,
554                                const u1* runtime_invisible_type_annotations,
555                                int runtime_invisible_type_annotations_length,
556                                const u1* annotation_default,
557                                int annotation_default_length,
558                                TRAPS);
559 
560   // lays out fields in class and returns the total oopmap count
561   void layout_fields(ConstantPool* cp,
562                      const FieldAllocationCount* fac,
563                      const ClassAnnotationCollector* parsed_annotations,
564                      FieldLayoutInfo* info,
565                      TRAPS);
566 
567   void update_class_name(Symbol* new_name);
568 
<span class="line-added">569   // Check if the class file supports inline types</span>
<span class="line-added">570   bool supports_inline_types() const;</span>
<span class="line-added">571 </span>
572  public:
573   ClassFileParser(ClassFileStream* stream,
574                   Symbol* name,
575                   ClassLoaderData* loader_data,
576                   const ClassLoadInfo* cl_info,
577                   Publicity pub_level,
578                   TRAPS);
579 
580   ~ClassFileParser();
581 
582   InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, const ClassInstanceInfo&amp; cl_inst_info, TRAPS);
583 
584   const ClassFileStream* clone_stream() const;
585 
586   void set_klass_to_deallocate(InstanceKlass* klass);
587 
588   int static_field_size() const;
589   int total_oop_map_count() const;
590   jint layout_size() const;
591 
592   int vtable_size() const { return _vtable_size; }
593   int itable_size() const { return _itable_size; }
594 
595   u2 this_class_index() const { return _this_class_index; }
596 
597   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
598   bool is_hidden() const { return _is_hidden; }
599   bool is_interface() const { return _access_flags.is_interface(); }
<span class="line-added">600   bool is_inline_type() const { return _access_flags.is_inline_type(); }</span>
<span class="line-added">601   bool is_value_capable_class() const;</span>
<span class="line-added">602   bool has_flattenable_fields() const { return _has_flattenable_fields; }</span>
<span class="line-added">603   bool invalid_inline_super() const { return _invalid_inline_super; }</span>
<span class="line-added">604   void set_invalid_inline_super() { _invalid_inline_super = true; }</span>
<span class="line-added">605   bool invalid_identity_super() const { return _invalid_identity_super; }</span>
<span class="line-added">606   void set_invalid_identity_super() { _invalid_identity_super = true; }</span>
<span class="line-added">607   bool is_invalid_super_for_inline_type();</span>
<span class="line-added">608 </span>
<span class="line-added">609   u2 java_fields_count() const { return _java_fields_count; }</span>
610 
611   const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
612   const GrowableArray&lt;Handle&gt;* cp_patches() const { return _cp_patches; }
613   ClassLoaderData* loader_data() const { return _loader_data; }
614   const Symbol* class_name() const { return _class_name; }
615   const InstanceKlass* super_klass() const { return _super_klass; }
616 
617   ReferenceType reference_type() const { return _rt; }
618   AccessFlags access_flags() const { return _access_flags; }
619 
620   bool is_internal() const { return INTERNAL == _pub_level; }
621 
622   static bool verify_unqualified_name(const char* name, unsigned int length, int type);
623 
624 #ifdef ASSERT
625   static bool is_internal_format(Symbol* class_name);
626 #endif
627 
628 };
629 
</pre>
</td>
</tr>
</table>
<center><a href="classFileParser.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoader.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
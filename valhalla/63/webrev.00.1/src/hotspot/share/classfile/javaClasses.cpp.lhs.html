<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<a name="2" id="anc2"></a>

  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vm_version.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/preserveException.hpp&quot;
  72 #include &quot;utilities/utf8.hpp&quot;
  73 #if INCLUDE_JVMCI
  74 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  75 #endif
  76 
  77 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  78   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  79 
  80 #if INCLUDE_CDS
  81 #define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \
  82   f-&gt;do_u4((u4*)&amp;_##name##_offset);
  83 #endif
  84 
  85 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  86   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  87 
  88 InjectedField JavaClasses::_injected_fields[] = {
  89   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  90 };
  91 
  92 // Register native methods of Object
  93 void java_lang_Object::register_natives(TRAPS) {
  94   InstanceKlass* obj = SystemDictionary::Object_klass();
  95   Method::register_native(obj, vmSymbols::hashCode_name(),
  96                           vmSymbols::void_int_signature(), (address) &amp;JVM_IHashCode, CHECK);
  97   Method::register_native(obj, vmSymbols::wait_name(),
  98                           vmSymbols::long_void_signature(), (address) &amp;JVM_MonitorWait, CHECK);
  99   Method::register_native(obj, vmSymbols::notify_name(),
 100                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotify, CHECK);
 101   Method::register_native(obj, vmSymbols::notifyAll_name(),
 102                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotifyAll, CHECK);
 103   Method::register_native(obj, vmSymbols::clone_name(),
 104                           vmSymbols::void_object_signature(), (address) &amp;JVM_Clone, THREAD);
 105 }
 106 
 107 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
 108   return _injected_fields[id].compute_offset();
 109 }
 110 
 111 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
 112   *field_count = 0;
 113 
 114   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
 115   if (sid == vmSymbols::NO_SID) {
 116     // Only well known classes can inject fields
 117     return NULL;
 118   }
 119 
 120   int count = 0;
 121   int start = -1;
 122 
 123 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
 124   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
 125     count++;                                                       \
 126     if (start == -1) start = klass##_##name##_enum;                \
 127   }
 128   ALL_INJECTED_FIELDS(LOOKUP_INJECTED_FIELD);
 129 #undef LOOKUP_INJECTED_FIELD
 130 
 131   if (start != -1) {
 132     *field_count = count;
 133     return _injected_fields + start;
 134   }
 135   return NULL;
 136 }
 137 
 138 
 139 // Helpful routine for computing field offsets at run time rather than hardcoding them
 140 // Finds local fields only, including static fields.  Static field offsets are from the
 141 // beginning of the mirror.
 142 static void compute_offset(int &amp;dest_offset,
 143                            InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,
 144                            bool is_static = false) {
 145   fieldDescriptor fd;
 146   if (ik == NULL) {
 147     ResourceMark rm;
 148     log_error(class)(&quot;Mismatch JDK version for field: %s type: %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 149     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;);
 150   }
 151 
 152   if (!ik-&gt;find_local_field(name_symbol, signature_symbol, &amp;fd) || fd.is_static() != is_static) {
 153     ResourceMark rm;
 154     log_error(class)(&quot;Invalid layout of %s field: %s type: %s&quot;, ik-&gt;external_name(),
 155                      name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 156 #ifndef PRODUCT
 157     // Prints all fields and offsets
 158     Log(class) lt;
 159     LogStream ls(lt.error());
 160     ik-&gt;print_on(&amp;ls);
 161 #endif //PRODUCT
 162     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 163   }
 164   dest_offset = fd.offset();
 165 }
 166 
 167 // Overloading to pass name as a string.
 168 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 169                            const char* name_string, Symbol* signature_symbol,
 170                            bool is_static = false) {
 171   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 172   if (name == NULL) {
 173     ResourceMark rm;
 174     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 175     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 176   }
 177   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 178 }
 179 
 180 int java_lang_String::value_offset  = 0;
 181 int java_lang_String::hash_offset   = 0;
 182 int java_lang_String::hashIsZero_offset = 0;
 183 int java_lang_String::coder_offset  = 0;
 184 
 185 bool java_lang_String::initialized  = false;
 186 
 187 bool java_lang_String::is_instance(oop obj) {
 188   return is_instance_inlined(obj);
 189 }
 190 
 191 #if INCLUDE_CDS
 192 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 193   f-&gt;do_u4((u4*)&amp;offset)
 194 #endif
 195 
 196 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 197   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 198 
 199 #define STRING_FIELDS_DO(macro) \
 200   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
 201   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
 202   macro(hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \
 203   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);
 204 
 205 void java_lang_String::compute_offsets() {
 206   if (initialized) {
 207     return;
 208   }
 209 
 210   InstanceKlass* k = SystemDictionary::String_klass();
 211   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 212 
 213   initialized = true;
 214 }
 215 
 216 #if INCLUDE_CDS
 217 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 218   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 219   f-&gt;do_bool(&amp;initialized);
 220 }
 221 #endif
 222 
 223 class CompactStringsFixup : public FieldClosure {
 224 private:
 225   bool _value;
 226 
 227 public:
 228   CompactStringsFixup(bool value) : _value(value) {}
 229 
 230   void do_field(fieldDescriptor* fd) {
 231     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 232       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 233       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 234       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 235       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 236     }
 237   }
 238 };
 239 
 240 void java_lang_String::set_compact_strings(bool value) {
 241   CompactStringsFixup fix(value);
 242   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 243 }
 244 
 245 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 246   assert(initialized, &quot;Must be initialized&quot;);
 247   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 248 
 249   // Create the String object first, so there&#39;s a chance that the String
 250   // and the char array it points to end up in the same cache line.
 251   oop obj;
 252   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 253 
 254   // Create the char array.  The String object must be handlized here
 255   // because GC can happen as a result of the allocation attempt.
 256   Handle h_obj(THREAD, obj);
 257   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 258   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 259 
 260   // Point the String at the char array
 261   obj = h_obj();
 262   set_value(obj, buffer);
 263   // No need to zero the offset, allocation zero&#39;ed the entire String object
 264   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 265   return h_obj;
 266 }
 267 
 268 Handle java_lang_String::create_from_unicode(const jchar* unicode, int length, TRAPS) {
 269   bool is_latin1 = CompactStrings &amp;&amp; UNICODE::is_latin1(unicode, length);
 270   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 271   typeArrayOop buffer = value(h_obj());
 272   assert(TypeArrayKlass::cast(buffer-&gt;klass())-&gt;element_type() == T_BYTE, &quot;only byte[]&quot;);
 273   if (is_latin1) {
 274     for (int index = 0; index &lt; length; index++) {
 275       buffer-&gt;byte_at_put(index, (jbyte)unicode[index]);
 276     }
 277   } else {
 278     for (int index = 0; index &lt; length; index++) {
 279       buffer-&gt;char_at_put(index, unicode[index]);
 280     }
 281   }
 282 
 283 #ifdef ASSERT
 284   {
 285     ResourceMark rm;
 286     char* expected = UNICODE::as_utf8(unicode, length);
 287     char* actual = as_utf8_string(h_obj());
 288     if (strcmp(expected, actual) != 0) {
 289       tty-&gt;print_cr(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 290       ShouldNotReachHere();
 291     }
 292   }
 293 #endif
 294 
 295   return h_obj;
 296 }
 297 
 298 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
 299   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);
 300   return h_obj();
 301 }
 302 
 303 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 304   if (utf8_str == NULL) {
 305     return Handle();
 306   }
 307   bool has_multibyte, is_latin1;
 308   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 309   if (!CompactStrings) {
 310     has_multibyte = true;
 311     is_latin1 = false;
 312   }
 313 
 314   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 315   if (length &gt; 0) {
 316     if (!has_multibyte) {
 317       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 318       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 319     } else if (is_latin1) {
 320       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 321     } else {
 322       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 323     }
 324   }
 325 
 326 #ifdef ASSERT
 327   // This check is too strict because the input string is not necessarily valid UTF8.
 328   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 329   /*
 330   {
 331     ResourceMark rm;
 332     const char* expected = utf8_str;
 333     char* actual = as_utf8_string(h_obj());
 334     if (strcmp(expected, actual) != 0) {
 335       tty-&gt;print_cr(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 336       ShouldNotReachHere();
 337     }
 338   }
 339   */
 340 #endif
 341 
 342   return h_obj;
 343 }
 344 
 345 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 346   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);
 347   return h_obj();
 348 }
 349 
 350 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 351   const char* utf8_str = (char*)symbol-&gt;bytes();
 352   int utf8_len = symbol-&gt;utf8_length();
 353 
 354   bool has_multibyte, is_latin1;
 355   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 356   if (!CompactStrings) {
 357     has_multibyte = true;
 358     is_latin1 = false;
 359   }
 360 
 361   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 362   if (length &gt; 0) {
 363     if (!has_multibyte) {
 364       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 365       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 366     } else if (is_latin1) {
 367       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 368     } else {
 369       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 370     }
 371   }
 372 
 373 #ifdef ASSERT
 374   {
 375     ResourceMark rm;
 376     const char* expected = symbol-&gt;as_utf8();
 377     char* actual = as_utf8_string(h_obj());
 378     if (strncmp(expected, actual, utf8_len) != 0) {
 379       tty-&gt;print_cr(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);
 380       ShouldNotReachHere();
 381     }
 382   }
 383 #endif
 384 
 385   return h_obj;
 386 }
 387 
 388 // Converts a C string to a Java String based on current encoding
 389 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 390   assert(str != NULL, &quot;bad arguments&quot;);
 391 
 392   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);
 393   static to_java_string_fn_t _to_java_string_fn = NULL;
 394 
 395   if (_to_java_string_fn == NULL) {
 396     void *lib_handle = os::native_java_library();
 397     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));
 398 #if defined(_WIN32) &amp;&amp; !defined(_WIN64)
 399     if (_to_java_string_fn == NULL) {
 400       // On 32 bit Windows, also try __stdcall decorated name
 401       _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;_JNU_NewStringPlatform@8&quot;));
 402     }
 403 #endif
 404     if (_to_java_string_fn == NULL) {
 405       fatal(&quot;JNU_NewStringPlatform missing&quot;);
 406     }
 407   }
 408 
 409   jstring js = NULL;
 410   {
 411     assert(THREAD-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 412     JavaThread* thread = (JavaThread*)THREAD;
 413     HandleMark hm(thread);
 414     ThreadToNativeFromVM ttn(thread);
 415     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 416   }
 417 
 418   Handle native_platform_string(THREAD, JNIHandles::resolve(js));
 419   JNIHandles::destroy_local(js);  // destroy local JNIHandle.
 420   return native_platform_string;
 421 }
 422 
 423 // Converts a Java String to a native C string that can be used for
 424 // native OS calls.
 425 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 426   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 427   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 428 
 429   if (_to_platform_string_fn == NULL) {
 430     void *lib_handle = os::native_java_library();
 431     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, &quot;GetStringPlatformChars&quot;));
 432     if (_to_platform_string_fn == NULL) {
 433       fatal(&quot;GetStringPlatformChars missing&quot;);
 434     }
 435   }
 436 
 437   char *native_platform_string;
 438   { JavaThread* thread = (JavaThread*)THREAD;
 439     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 440     JNIEnv *env = thread-&gt;jni_environment();
 441     jstring js = (jstring) JNIHandles::make_local(env, java_string());
 442     bool is_copy;
 443     HandleMark hm(thread);
 444     ThreadToNativeFromVM ttn(thread);
 445     native_platform_string = (_to_platform_string_fn)(env, js, &amp;is_copy);
 446     assert(is_copy == JNI_TRUE, &quot;is_copy value changed&quot;);
 447     JNIHandles::destroy_local(js);
 448   }
 449   return native_platform_string;
 450 }
 451 
 452 Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {
 453   oop          obj    = java_string();
 454   // Typical usage is to convert all &#39;/&#39; to &#39;.&#39; in string.
 455   typeArrayOop value  = java_lang_String::value(obj);
 456   int          length = java_lang_String::length(obj, value);
 457   bool      is_latin1 = java_lang_String::is_latin1(obj);
 458 
 459   // First check if any from_char exist
 460   int index; // Declared outside, used later
 461   for (index = 0; index &lt; length; index++) {
 462     jchar c = !is_latin1 ? value-&gt;char_at(index) :
 463                   ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 464     if (c == from_char) {
 465       break;
 466     }
 467   }
 468   if (index == length) {
 469     // No from_char, so do not copy.
 470     return java_string;
 471   }
 472 
 473   // Check if result string will be latin1
 474   bool to_is_latin1 = false;
 475 
 476   // Replacement char must be latin1
 477   if (CompactStrings &amp;&amp; UNICODE::is_latin1(to_char)) {
 478     if (is_latin1) {
 479       // Source string is latin1 as well
 480       to_is_latin1 = true;
 481     } else if (!UNICODE::is_latin1(from_char)) {
 482       // We are replacing an UTF16 char. Scan string to
 483       // check if result can be latin1 encoded.
 484       to_is_latin1 = true;
 485       for (index = 0; index &lt; length; index++) {
 486         jchar c = value-&gt;char_at(index);
 487         if (c != from_char &amp;&amp; !UNICODE::is_latin1(c)) {
 488           to_is_latin1 = false;
 489           break;
 490         }
 491       }
 492     }
 493   }
 494 
 495   // Create new UNICODE (or byte) buffer. Must handlize value because GC
 496   // may happen during String and char array creation.
 497   typeArrayHandle h_value(THREAD, value);
 498   Handle string = basic_create(length, to_is_latin1, CHECK_NH);
 499   typeArrayOop from_buffer = h_value();
 500   typeArrayOop to_buffer = java_lang_String::value(string());
 501 
 502   // Copy contents
 503   for (index = 0; index &lt; length; index++) {
 504     jchar c = (!is_latin1) ? from_buffer-&gt;char_at(index) :
 505                     ((jchar) from_buffer-&gt;byte_at(index)) &amp; 0xff;
 506     if (c == from_char) {
 507       c = to_char;
 508     }
 509     if (!to_is_latin1) {
 510       to_buffer-&gt;char_at_put(index, c);
 511     } else {
 512       to_buffer-&gt;byte_at_put(index, (jbyte) c);
 513     }
 514   }
 515   return string;
 516 }
 517 
 518 jchar* java_lang_String::as_unicode_string(oop java_string, int&amp; length, TRAPS) {
 519   typeArrayOop value  = java_lang_String::value(java_string);
 520                length = java_lang_String::length(java_string, value);
 521   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 522 
 523   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 524   if (result != NULL) {
 525     if (!is_latin1) {
 526       for (int index = 0; index &lt; length; index++) {
 527         result[index] = value-&gt;char_at(index);
 528       }
 529     } else {
 530       for (int index = 0; index &lt; length; index++) {
 531         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 532       }
 533     }
 534   } else {
 535     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 536   }
 537   return result;
 538 }
 539 
 540 unsigned int java_lang_String::hash_code(oop java_string) {
 541   // The hash and hashIsZero fields are subject to a benign data race,
 542   // making it crucial to ensure that any observable result of the
 543   // calculation in this method stays correct under any possible read of
 544   // these fields. Necessary restrictions to allow this to be correct
 545   // without explicit memory fences or similar concurrency primitives is
 546   // that we can ever only write to one of these two fields for a given
 547   // String instance, and that the computation is idempotent and derived
 548   // from immutable state
 549   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 550   if (java_lang_String::hash_is_set(java_string)) {
 551     return java_string-&gt;int_field(hash_offset);
 552   }
 553 
 554   typeArrayOop value = java_lang_String::value(java_string);
 555   int         length = java_lang_String::length(java_string, value);
 556   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 557 
 558   unsigned int hash = 0;
 559   if (length &gt; 0) {
 560     if (is_latin1) {
 561       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 562     } else {
 563       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 564     }
 565   }
 566 
 567   if (hash != 0) {
 568     java_string-&gt;int_field_put(hash_offset, hash);
 569   } else {
 570     java_string-&gt;bool_field_put(hashIsZero_offset, true);
 571   }
 572   return hash;
 573 }
 574 
 575 char* java_lang_String::as_quoted_ascii(oop java_string) {
 576   typeArrayOop value  = java_lang_String::value(java_string);
 577   int          length = java_lang_String::length(java_string, value);
 578   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 579 
 580   if (length == 0) return NULL;
 581 
 582   char* result;
 583   int result_length;
 584   if (!is_latin1) {
 585     jchar* base = value-&gt;char_at_addr(0);
 586     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 587     result = NEW_RESOURCE_ARRAY(char, result_length);
 588     UNICODE::as_quoted_ascii(base, length, result, result_length);
 589   } else {
 590     jbyte* base = value-&gt;byte_at_addr(0);
 591     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 592     result = NEW_RESOURCE_ARRAY(char, result_length);
 593     UNICODE::as_quoted_ascii(base, length, result, result_length);
 594   }
 595   assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
 596   assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
 597   return result;
 598 }
 599 
 600 Symbol* java_lang_String::as_symbol(oop java_string) {
 601   typeArrayOop value  = java_lang_String::value(java_string);
 602   int          length = java_lang_String::length(java_string, value);
 603   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 604   if (!is_latin1) {
 605     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 606     Symbol* sym = SymbolTable::new_symbol(base, length);
 607     return sym;
 608   } else {
 609     ResourceMark rm;
 610     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 611     const char* base = UNICODE::as_utf8(position, length);
 612     Symbol* sym = SymbolTable::new_symbol(base, length);
 613     return sym;
 614   }
 615 }
 616 
 617 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 618   typeArrayOop value  = java_lang_String::value(java_string);
 619   int          length = java_lang_String::length(java_string, value);
 620   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 621   if (!is_latin1) {
 622     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 623     return SymbolTable::probe_unicode(base, length);
 624   } else {
 625     ResourceMark rm;
 626     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 627     const char* base = UNICODE::as_utf8(position, length);
 628     return SymbolTable::probe(base, length);
 629   }
 630 }
 631 
 632 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
 633   assert(value_equals(value, java_lang_String::value(java_string)),
 634          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 635   int length = java_lang_String::length(java_string, value);
 636   if (length == 0) {
 637     return 0;
 638   }
 639   if (!java_lang_String::is_latin1(java_string)) {
 640     return UNICODE::utf8_length(value-&gt;char_at_addr(0), length);
 641   } else {
 642     return UNICODE::utf8_length(value-&gt;byte_at_addr(0), length);
 643   }
 644 }
 645 
 646 int java_lang_String::utf8_length(oop java_string) {
 647   typeArrayOop value = java_lang_String::value(java_string);
 648   return utf8_length(java_string, value);
 649 }
 650 
 651 char* java_lang_String::as_utf8_string(oop java_string) {
 652   int length;
 653   return as_utf8_string(java_string, length);
 654 }
 655 
 656 char* java_lang_String::as_utf8_string(oop java_string, int&amp; length) {
 657   typeArrayOop value = java_lang_String::value(java_string);
 658   length             = java_lang_String::length(java_string, value);
 659   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 660   if (!is_latin1) {
 661     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 662     return UNICODE::as_utf8(position, length);
 663   } else {
 664     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 665     return UNICODE::as_utf8(position, length);
 666   }
 667 }
 668 
 669 // Uses a provided buffer if it&#39;s sufficiently large, otherwise allocates
 670 // a resource array to fit
 671 char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; utf8_len) {
 672   typeArrayOop value = java_lang_String::value(java_string);
 673   int            len = java_lang_String::length(java_string, value);
 674   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 675   if (!is_latin1) {
 676     jchar *position = (len == 0) ? NULL : value-&gt;char_at_addr(0);
 677     utf8_len = UNICODE::utf8_length(position, len);
 678     if (utf8_len &gt;= buflen) {
 679       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 680     }
 681     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 682   } else {
 683     jbyte *position = (len == 0) ? NULL : value-&gt;byte_at_addr(0);
 684     utf8_len = UNICODE::utf8_length(position, len);
 685     if (utf8_len &gt;= buflen) {
 686       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 687     }
 688     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 689   }
 690 }
 691 
 692 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
 693   assert(value_equals(value, java_lang_String::value(java_string)),
 694          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 695   int     length = java_lang_String::length(java_string, value);
 696   bool is_latin1 = java_lang_String::is_latin1(java_string);
 697   if (!is_latin1) {
 698     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 699     return UNICODE::as_utf8(position, length, buf, buflen);
 700   } else {
 701     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 702     return UNICODE::as_utf8(position, length, buf, buflen);
 703   }
 704 }
 705 
 706 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 707   typeArrayOop value = java_lang_String::value(java_string);
 708   return as_utf8_string(java_string, value, buf, buflen);
 709 }
 710 
 711 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
 712   typeArrayOop value  = java_lang_String::value(java_string);
 713   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 714   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 715   if (!is_latin1) {
 716     jchar* position = value-&gt;char_at_addr(start);
 717     return UNICODE::as_utf8(position, len);
 718   } else {
 719     jbyte* position = value-&gt;byte_at_addr(start);
 720     return UNICODE::as_utf8(position, len);
 721   }
 722 }
 723 
 724 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {
 725   assert(value_equals(value, java_lang_String::value(java_string)),
 726          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 727   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 728   bool is_latin1 = java_lang_String::is_latin1(java_string);
 729   if (!is_latin1) {
 730     jchar* position = value-&gt;char_at_addr(start);
 731     return UNICODE::as_utf8(position, len, buf, buflen);
 732   } else {
 733     jbyte* position = value-&gt;byte_at_addr(start);
 734     return UNICODE::as_utf8(position, len, buf, buflen);
 735   }
 736 }
 737 
 738 bool java_lang_String::equals(oop java_string, const jchar* chars, int len) {
 739   assert(java_string-&gt;klass() == SystemDictionary::String_klass(),
 740          &quot;must be java_string&quot;);
 741   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
 742   int length = java_lang_String::length(java_string, value);
 743   if (length != len) {
 744     return false;
 745   }
 746   bool is_latin1 = java_lang_String::is_latin1(java_string);
 747   if (!is_latin1) {
 748     for (int i = 0; i &lt; len; i++) {
 749       if (value-&gt;char_at(i) != chars[i]) {
 750         return false;
 751       }
 752     }
 753   } else {
 754     for (int i = 0; i &lt; len; i++) {
 755       if ((((jchar) value-&gt;byte_at(i)) &amp; 0xff) != chars[i]) {
 756         return false;
 757       }
 758     }
 759   }
 760   return true;
 761 }
 762 
 763 bool java_lang_String::equals(oop str1, oop str2) {
 764   assert(str1-&gt;klass() == SystemDictionary::String_klass(),
 765          &quot;must be java String&quot;);
 766   assert(str2-&gt;klass() == SystemDictionary::String_klass(),
 767          &quot;must be java String&quot;);
 768   typeArrayOop value1    = java_lang_String::value_no_keepalive(str1);
 769   bool         is_latin1 = java_lang_String::is_latin1(str1);
 770   typeArrayOop value2    = java_lang_String::value_no_keepalive(str2);
 771   bool         is_latin2 = java_lang_String::is_latin1(str2);
 772 
 773   if (is_latin1 != is_latin2) {
 774     // Strings with different coders are never equal.
 775     return false;
 776   }
 777   return value_equals(value1, value2);
 778 }
 779 
 780 void java_lang_String::print(oop java_string, outputStream* st) {
 781   assert(java_string-&gt;klass() == SystemDictionary::String_klass(), &quot;must be java_string&quot;);
 782   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 783 
 784   if (value == NULL) {
 785     // This can happen if, e.g., printing a String
 786     // object before its initializer has been called
 787     st-&gt;print(&quot;NULL&quot;);
 788     return;
 789   }
 790 
 791   int length = java_lang_String::length(java_string, value);
 792   bool is_latin1 = java_lang_String::is_latin1(java_string);
 793 
 794   st-&gt;print(&quot;\&quot;&quot;);
 795   for (int index = 0; index &lt; length; index++) {
 796     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 797                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 798   }
 799   st-&gt;print(&quot;\&quot;&quot;);
 800 }
 801 
 802 
 803 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 804   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 805   if (fd-&gt;has_initial_value()) {
 806     BasicType t = fd-&gt;field_type();
 807     switch (t) {
 808       case T_BYTE:
 809         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 810               break;
 811       case T_BOOLEAN:
 812         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 813               break;
 814       case T_CHAR:
 815         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 816               break;
 817       case T_SHORT:
 818         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 819               break;
 820       case T_INT:
 821         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 822         break;
 823       case T_FLOAT:
 824         mirror()-&gt;float_field_put(fd-&gt;offset(), fd-&gt;float_initial_value());
 825         break;
 826       case T_DOUBLE:
 827         mirror()-&gt;double_field_put(fd-&gt;offset(), fd-&gt;double_initial_value());
 828         break;
 829       case T_LONG:
 830         mirror()-&gt;long_field_put(fd-&gt;offset(), fd-&gt;long_initial_value());
 831         break;
 832       case T_OBJECT:
 833         {
 834           assert(fd-&gt;signature() == vmSymbols::string_signature(),
 835                  &quot;just checking&quot;);
 836           if (DumpSharedSpaces &amp;&amp; HeapShared::is_archived_object(mirror())) {
 837             // Archive the String field and update the pointer.
 838             oop s = mirror()-&gt;obj_field(fd-&gt;offset());
 839             oop archived_s = StringTable::create_archived_string(s, CHECK);
 840             mirror()-&gt;obj_field_put(fd-&gt;offset(), archived_s);
 841           } else {
 842             oop string = fd-&gt;string_initial_value(CHECK);
 843             mirror()-&gt;obj_field_put(fd-&gt;offset(), string);
 844           }
 845         }
 846         break;
 847       default:
 848         THROW_MSG(vmSymbols::java_lang_ClassFormatError(),
 849                   &quot;Illegal ConstantValue attribute in class file&quot;);
 850     }
 851   }
 852 }
 853 
 854 
 855 void java_lang_Class::fixup_mirror(Klass* k, TRAPS) {
 856   assert(InstanceMirrorKlass::offset_of_static_fields() != 0, &quot;must have been computed already&quot;);
 857 
 858   // If the offset was read from the shared archive, it was fixed up already
 859   if (!k-&gt;is_shared()) {
 860     if (k-&gt;is_instance_klass()) {
 861       // During bootstrap, java.lang.Class wasn&#39;t loaded so static field
 862       // offsets were computed without the size added it.  Go back and
 863       // update all the static field offsets to included the size.
 864       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 865         if (fs.access_flags().is_static()) {
 866           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 867           fs.set_offset(real_offset);
 868         }
 869       }
 870     }
 871   }
 872 
 873   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 874     if (HeapShared::open_archive_heap_region_mapped()) {
 875       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 876       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 877       return;
 878     } else {
 879       k-&gt;set_java_mirror_handle(NULL);
 880       k-&gt;clear_has_raw_archived_mirror();
 881     }
 882   }
 883   create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);
 884 }
 885 
 886 void java_lang_Class::initialize_mirror_fields(Klass* k,
 887                                                Handle mirror,
 888                                                Handle protection_domain,
 889                                                Handle classData,
 890                                                TRAPS) {
 891   // Allocate a simple java object for a lock.
 892   // This needs to be a java object because during class initialization
 893   // it can be held across a java call.
 894   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 895   set_init_lock(mirror(), r);
 896 
 897   // Set protection domain also
 898   set_protection_domain(mirror(), protection_domain());
 899 
 900   // Initialize static fields
 901   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 902 
 903  // Set classData
 904   set_class_data(mirror(), classData());
 905 }
 906 
 907 // Set the java.lang.Module module field in the java_lang_Class mirror
 908 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 909   if (module.is_null()) {
 910     // During startup, the module may be NULL only if java.base has not been defined yet.
 911     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 912     // for java.base is known. But note that since we captured the NULL module another
 913     // thread may have completed that initialization.
 914 
 915     bool javabase_was_defined = false;
 916     {
 917       MutexLocker m1(THREAD, Module_lock);
 918       // Keep list of classes needing java.base module fixup
 919       if (!ModuleEntryTable::javabase_defined()) {
 920         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 921         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 922         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 923         fixup_module_field_list()-&gt;push(k);
 924       } else {
 925         javabase_was_defined = true;
 926       }
 927     }
 928 
 929     // If java.base was already defined then patch this particular class with java.base.
 930     if (javabase_was_defined) {
 931       ModuleEntry *javabase_entry = ModuleEntryTable::javabase_moduleEntry();
 932       assert(javabase_entry != NULL &amp;&amp; javabase_entry-&gt;module() != NULL,
 933              &quot;Setting class module field, &quot; JAVA_BASE_NAME &quot; should be defined&quot;);
 934       Handle javabase_handle(THREAD, javabase_entry-&gt;module());
 935       set_module(mirror(), javabase_handle());
 936     }
 937   } else {
 938     assert(Universe::is_module_initialized() ||
 939            (ModuleEntryTable::javabase_defined() &amp;&amp;
 940             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),
 941            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 942     set_module(mirror(), module());
 943   }
 944 }
 945 
 946 // Statically allocate fixup lists because they always get created.
 947 void java_lang_Class::allocate_fixup_lists() {
 948   GrowableArray&lt;Klass*&gt;* mirror_list =
 949     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 950   set_fixup_mirror_list(mirror_list);
 951 
 952   GrowableArray&lt;Klass*&gt;* module_list =
 953     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, true);
 954   set_fixup_module_field_list(module_list);
 955 }
 956 
 957 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
 958                                     Handle module, Handle protection_domain,
 959                                     Handle classData, TRAPS) {
 960   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 961   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
 962 
 963   // Use this moment of initialization to cache modifier_flags also,
 964   // to support Class.getModifiers().  Instance classes recalculate
 965   // the cached flags after the class file is parsed, but before the
 966   // class is put into the system dictionary.
 967   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 968   k-&gt;set_modifier_flags(computed_modifiers);
 969   // Class_klass has to be loaded because it is used to allocate
 970   // the mirror.
 971   if (SystemDictionary::Class_klass_loaded()) {
 972     // Allocate mirror (java.lang.Class instance)
 973     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 974     Handle mirror(THREAD, mirror_oop);
 975     Handle comp_mirror;
 976 
 977     // Setup indirection from mirror-&gt;klass
 978     java_lang_Class::set_klass(mirror(), k);
 979 
 980     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 981     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 982 
 983     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 984 
 985     // It might also have a component mirror.  This mirror must already exist.
 986     if (k-&gt;is_array_klass()) {
<a name="3" id="anc3"></a><span class="line-modified"> 987       if (k-&gt;is_typeArray_klass()) {</span>





 988         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 989         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 990       } else {
 991         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 992         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 993         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
 994         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
 995       }
 996       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 997 
 998       // Two-way link between the array klass and its component mirror:
 999       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1000       set_component_mirror(mirror(), comp_mirror());
1001       // See below for ordering dependencies between field array_klass in component mirror
1002       // and java_mirror in this klass.
1003     } else {
1004       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1005 
1006       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1007       if (HAS_PENDING_EXCEPTION) {
1008         // If any of the fields throws an exception like OOM remove the klass field
1009         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
1010         // This mirror looks like a primitive type, which logically it is because it
1011         // it represents no class.
1012         java_lang_Class::set_klass(mirror(), NULL);
1013         return;
1014       }
1015     }
1016 
1017     // set the classLoader field in the java_lang_Class instance
1018     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1019     set_class_loader(mirror(), class_loader());
1020 
1021     // Setup indirection from klass-&gt;mirror
1022     // after any exceptions can happen during allocations.
1023     k-&gt;set_java_mirror(mirror);
1024 
1025     // Set the module field in the java_lang_Class instance.  This must be done
1026     // after the mirror is set.
1027     set_mirror_module_field(k, mirror, module, THREAD);
1028 
1029     if (comp_mirror() != NULL) {
1030       // Set after k-&gt;java_mirror() is published, because compiled code running
1031       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1032       release_set_array_klass(comp_mirror(), k);
1033     }
<a name="4" id="anc4"></a>
















1034   } else {
1035     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1036     fixup_mirror_list()-&gt;push(k);
1037   }
1038 }
1039 
1040 #if INCLUDE_CDS_JAVA_HEAP
1041 // Clears mirror fields. Static final fields with initial values are reloaded
1042 // from constant pool. The object identity hash is in the object header and is
1043 // not affected.
1044 class ResetMirrorField: public FieldClosure {
1045  private:
1046   Handle _m;
1047 
1048  public:
1049   ResetMirrorField(Handle mirror) : _m(mirror) {}
1050 
1051   void do_field(fieldDescriptor* fd) {
1052     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1053     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
1054 
1055     if (fd-&gt;is_static() &amp;&amp; fd-&gt;has_initial_value()) {
1056       initialize_static_field(fd, _m, Thread::current());
1057       return;
1058     }
1059 
1060     BasicType ft = fd-&gt;field_type();
1061     switch (ft) {
1062       case T_BYTE:
1063         _m()-&gt;byte_field_put(fd-&gt;offset(), 0);
1064         break;
1065       case T_CHAR:
1066         _m()-&gt;char_field_put(fd-&gt;offset(), 0);
1067         break;
1068       case T_DOUBLE:
1069         _m()-&gt;double_field_put(fd-&gt;offset(), 0);
1070         break;
1071       case T_FLOAT:
1072         _m()-&gt;float_field_put(fd-&gt;offset(), 0);
1073         break;
1074       case T_INT:
1075         _m()-&gt;int_field_put(fd-&gt;offset(), 0);
1076         break;
1077       case T_LONG:
1078         _m()-&gt;long_field_put(fd-&gt;offset(), 0);
1079         break;
1080       case T_SHORT:
1081         _m()-&gt;short_field_put(fd-&gt;offset(), 0);
1082         break;
1083       case T_BOOLEAN:
1084         _m()-&gt;bool_field_put(fd-&gt;offset(), false);
1085         break;
1086       case T_ARRAY:
1087       case T_OBJECT: {
1088         // It might be useful to cache the String field, but
1089         // for now just clear out any reference field
1090         oop o = _m()-&gt;obj_field(fd-&gt;offset());
1091         _m()-&gt;obj_field_put(fd-&gt;offset(), NULL);
1092         break;
1093       }
1094       default:
1095         ShouldNotReachHere();
1096         break;
1097      }
1098   }
1099 };
1100 
1101 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1102   assert(HeapShared::is_heap_object_archiving_allowed(),
1103          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1104 
1105   for (int t = 0; t &lt;= T_VOID; t++) {
1106     oop m = Universe::_mirrors[t];
1107     if (m != NULL) {
1108       // Update the field at _array_klass_offset to point to the relocated array klass.
1109       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
1110       assert(archived_m != NULL, &quot;sanity&quot;);
1111       Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
1112       assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
1113       if (ak != NULL) {
1114         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak, true);
1115         archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
1116       }
1117 
1118       // Clear the fields. Just to be safe
1119       Klass *k = m-&gt;klass();
1120       Handle archived_mirror_h(THREAD, archived_m);
1121       ResetMirrorField reset(archived_mirror_h);
1122       InstanceKlass::cast(k)-&gt;do_nonstatic_fields(&amp;reset);
1123 
1124       log_trace(cds, heap, mirror)(
1125         &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1126         type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));
1127 
1128       Universe::_mirrors[t] = archived_m;
1129     }
1130   }
1131 
1132   assert(Universe::_mirrors[T_INT] != NULL &amp;&amp;
1133          Universe::_mirrors[T_FLOAT] != NULL &amp;&amp;
1134          Universe::_mirrors[T_DOUBLE] != NULL &amp;&amp;
1135          Universe::_mirrors[T_BYTE] != NULL &amp;&amp;
1136          Universe::_mirrors[T_BOOLEAN] != NULL &amp;&amp;
1137          Universe::_mirrors[T_CHAR] != NULL &amp;&amp;
1138          Universe::_mirrors[T_LONG] != NULL &amp;&amp;
1139          Universe::_mirrors[T_SHORT] != NULL &amp;&amp;
1140          Universe::_mirrors[T_VOID] != NULL, &quot;sanity&quot;);
1141 
1142   Universe::set_int_mirror(Universe::_mirrors[T_INT]);
1143   Universe::set_float_mirror(Universe::_mirrors[T_FLOAT]);
1144   Universe::set_double_mirror(Universe::_mirrors[T_DOUBLE]);
1145   Universe::set_byte_mirror(Universe::_mirrors[T_BYTE]);
1146   Universe::set_bool_mirror(Universe::_mirrors[T_BOOLEAN]);
1147   Universe::set_char_mirror(Universe::_mirrors[T_CHAR]);
1148   Universe::set_long_mirror(Universe::_mirrors[T_LONG]);
1149   Universe::set_short_mirror(Universe::_mirrors[T_SHORT]);
1150   Universe::set_void_mirror(Universe::_mirrors[T_VOID]);
1151 }
1152 
1153 //
1154 // After the mirror object is successfully archived, the archived
1155 // klass is set with _has_archived_raw_mirror flag.
1156 //
1157 // The _has_archived_raw_mirror flag is cleared at runtime when the
1158 // archived mirror is restored. If archived java heap data cannot
1159 // be used at runtime, new mirror object is created for the shared
1160 // class. The _has_archived_raw_mirror is cleared also during the process.
1161 oop java_lang_Class::archive_mirror(Klass* k, TRAPS) {
1162   assert(HeapShared::is_heap_object_archiving_allowed(),
1163          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1164 
1165   // Mirror is already archived
1166   if (k-&gt;has_raw_archived_mirror()) {
1167     assert(k-&gt;archived_java_mirror_raw() != NULL, &quot;no archived mirror&quot;);
1168     return k-&gt;archived_java_mirror_raw();
1169   }
1170 
1171   // No mirror
1172   oop mirror = k-&gt;java_mirror();
1173   if (mirror == NULL) {
1174     return NULL;
1175   }
1176 
1177   if (k-&gt;is_instance_klass()) {
1178     InstanceKlass *ik = InstanceKlass::cast(k);
1179     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1180 
1181     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1182           ik-&gt;is_shared_app_class())) {
1183       // Archiving mirror for classes from non-builtin loaders is not
1184       // supported. Clear the _java_mirror within the archived class.
1185       k-&gt;set_java_mirror_handle(NULL);
1186       return NULL;
1187     }
1188   }
1189 
<a name="5" id="anc5"></a>





1190   // Now start archiving the mirror object
1191   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1192   if (archived_mirror == NULL) {
1193     return NULL;
1194   }
1195 
1196   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1197   if (archived_mirror == NULL) {
1198     return NULL;
1199   }
1200 
1201   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1202 
1203   k-&gt;set_has_raw_archived_mirror();
1204 
1205   ResourceMark rm;
1206   log_trace(cds, heap, mirror)(
1207     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1208     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1209 
1210   return archived_mirror;
1211 }
1212 
1213 // The process is based on create_mirror().
1214 oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,
1215                                              oop archived_mirror,
1216                                              Thread *THREAD) {
1217   // Clear nonstatic fields in archived mirror. Some of the fields will be set
1218   // to archived metadata and objects below.
1219   Klass *c = archived_mirror-&gt;klass();
1220   Handle archived_mirror_h(THREAD, archived_mirror);
1221   ResetMirrorField reset(archived_mirror_h);
1222   InstanceKlass::cast(c)-&gt;do_nonstatic_fields(&amp;reset);
1223 
1224   if (k-&gt;is_array_klass()) {
1225     oop archived_comp_mirror;
1226     if (k-&gt;is_typeArray_klass()) {
1227       // The primitive type mirrors are already archived. Get the archived mirror.
1228       oop comp_mirror = java_lang_Class::component_mirror(mirror);
1229       archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);
1230       assert(archived_comp_mirror != NULL, &quot;Must be&quot;);
1231     } else {
1232       assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1233       Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1234       assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1235       archived_comp_mirror = archive_mirror(element_klass, THREAD);
1236       if (archived_comp_mirror == NULL) {
1237         return NULL;
1238       }
1239     }
1240     java_lang_Class::set_component_mirror(archived_mirror, archived_comp_mirror);
1241   } else {
1242     assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1243 
1244     // Reset local static fields in the mirror
1245     InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;reset);
1246 
1247     java_lang_Class:set_init_lock(archived_mirror, NULL);
1248 
1249     set_protection_domain(archived_mirror, NULL);
1250   }
1251 
1252   // clear class loader and mirror_module_field
1253   set_class_loader(archived_mirror, NULL);
1254   set_module(archived_mirror, NULL);
1255 
1256   // The archived mirror&#39;s field at _klass_offset is still pointing to the original
1257   // klass. Updated the field in the archived mirror to point to the relocated
1258   // klass in the archive.
1259   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror), true);
1260   log_debug(cds, heap, mirror)(
1261     &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1262     p2i(as_Klass(mirror)), p2i(reloc_k));
1263   archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
1264 
1265   // The field at _array_klass_offset is pointing to the original one dimension
1266   // higher array klass if exists. Relocate the pointer.
1267   Klass *arr = array_klass_acquire(mirror);
1268   if (arr != NULL) {
1269     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr, true);
1270     log_debug(cds, heap, mirror)(
1271       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1272       p2i(arr), p2i(reloc_arr));
1273     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1274   }
1275   return archived_mirror;
1276 }
1277 
1278 void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {
1279   if (MetaspaceShared::relocation_delta() != 0) {
1280     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);
1281 
1282     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1283     if (ak != NULL) {
1284       archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1285           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1286     }
1287   }
1288 }
1289 
1290 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {
1291   assert(MetaspaceShared::relocation_delta() != 0, &quot;must be&quot;);
1292 
1293   Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));
1294   archived_mirror-&gt;metadata_field_put(_klass_offset,
1295       (Klass*)(address(k) + MetaspaceShared::relocation_delta()));
1296 
1297   Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1298   if (ak != NULL) {
1299     archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1300         (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1301   }
1302 }
1303 
1304 
1305 // Returns true if the mirror is updated, false if no archived mirror
1306 // data is present. After the archived mirror object is restored, the
1307 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1308 bool java_lang_Class::restore_archived_mirror(Klass *k,
1309                                               Handle class_loader, Handle module,
1310                                               Handle protection_domain, TRAPS) {
1311   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1312   // see more details in SystemDictionary::resolve_well_known_classes().
1313   if (!SystemDictionary::Class_klass_loaded()) {
1314     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1315     fixup_mirror_list()-&gt;push(k);
1316     return true;
1317   }
1318 
1319   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
1320   if (m == NULL) {
1321     return false;
1322   }
1323 
1324   // mirror is archived, restore
1325   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));
1326   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
1327   assert(as_Klass(m) == k, &quot;must be&quot;);
1328   Handle mirror(THREAD, m);
1329 
1330   if (!k-&gt;is_array_klass()) {
1331     // - local static final fields with initial values were initialized at dump time
1332 
1333     // create the init_lock
1334     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1335     set_init_lock(mirror(), r);
1336 
1337     if (protection_domain.not_null()) {
1338       set_protection_domain(mirror(), protection_domain());
1339     }
1340   }
1341 
1342   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1343   if (class_loader.not_null()) {
1344     set_class_loader(mirror(), class_loader());
1345   }
1346 
1347   k-&gt;set_java_mirror(mirror);
1348   k-&gt;clear_has_raw_archived_mirror();
1349 
1350   set_mirror_module_field(k, mirror, module, THREAD);
1351 
1352   if (log_is_enabled(Trace, cds, heap, mirror)) {
1353     ResourceMark rm(THREAD);
1354     log_trace(cds, heap, mirror)(
1355         &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));
1356   }
1357 
1358   return true;
1359 }
1360 #endif // INCLUDE_CDS_JAVA_HEAP
1361 
1362 void java_lang_Class::fixup_module_field(Klass* k, Handle module) {
1363   assert(_module_offset != 0, &quot;must have been computed already&quot;);
1364   java_lang_Class::set_module(k-&gt;java_mirror(), module());
1365 }
1366 
1367 int  java_lang_Class::oop_size(oop java_class) {
1368   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1369   int size = java_class-&gt;int_field(_oop_size_offset);
1370   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1371   return size;
1372 }
1373 
1374 
1375 void java_lang_Class::set_oop_size(HeapWord* java_class, int size) {
1376   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1377   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1378   *(int*)(((char*)java_class) + _oop_size_offset) = size;
1379 }
1380 
1381 int  java_lang_Class::static_oop_field_count(oop java_class) {
1382   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1383   return java_class-&gt;int_field(_static_oop_field_count_offset);
1384 }
1385 
1386 int  java_lang_Class::static_oop_field_count_raw(oop java_class) {
1387   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1388   return java_class-&gt;int_field_raw(_static_oop_field_count_offset);
1389 }
1390 
1391 void java_lang_Class::set_static_oop_field_count(oop java_class, int size) {
1392   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1393   java_class-&gt;int_field_put(_static_oop_field_count_offset, size);
1394 }
1395 
1396 oop java_lang_Class::protection_domain(oop java_class) {
1397   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1398   return java_class-&gt;obj_field(_protection_domain_offset);
1399 }
1400 void java_lang_Class::set_protection_domain(oop java_class, oop pd) {
1401   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1402   java_class-&gt;obj_field_put(_protection_domain_offset, pd);
1403 }
1404 
1405 void java_lang_Class::set_component_mirror(oop java_class, oop comp_mirror) {
1406   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1407     java_class-&gt;obj_field_put(_component_mirror_offset, comp_mirror);
1408   }
1409 oop java_lang_Class::component_mirror(oop java_class) {
1410   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1411   return java_class-&gt;obj_field(_component_mirror_offset);
1412 }
1413 
1414 oop java_lang_Class::init_lock(oop java_class) {
1415   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1416   return java_class-&gt;obj_field(_init_lock_offset);
1417 }
1418 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1419   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1420   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1421 }
1422 
1423 objArrayOop java_lang_Class::signers(oop java_class) {
1424   assert(_signers_offset != 0, &quot;must be set&quot;);
1425   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1426 }
1427 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1428   assert(_signers_offset != 0, &quot;must be set&quot;);
1429   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1430 }
1431 
1432 oop java_lang_Class::class_data(oop java_class) {
1433   assert(_classData_offset != 0, &quot;must be set&quot;);
1434   return java_class-&gt;obj_field(_classData_offset);
1435 }
1436 void java_lang_Class::set_class_data(oop java_class, oop class_data) {
1437   assert(_classData_offset != 0, &quot;must be set&quot;);
1438   java_class-&gt;obj_field_put(_classData_offset, class_data);
1439 }
1440 
1441 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
1442   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);
1443   java_class-&gt;obj_field_put(_class_loader_offset, loader);
1444 }
1445 
1446 oop java_lang_Class::class_loader(oop java_class) {
1447   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1448   return java_class-&gt;obj_field(_class_loader_offset);
1449 }
1450 
1451 oop java_lang_Class::module(oop java_class) {
1452   assert(_module_offset != 0, &quot;must be set&quot;);
1453   return java_class-&gt;obj_field(_module_offset);
1454 }
1455 
1456 void java_lang_Class::set_module(oop java_class, oop module) {
1457   assert(_module_offset != 0, &quot;must be set&quot;);
1458   java_class-&gt;obj_field_put(_module_offset, module);
1459 }
1460 
1461 oop java_lang_Class::name(Handle java_class, TRAPS) {
1462   assert(_name_offset != 0, &quot;must be set&quot;);
1463   oop o = java_class-&gt;obj_field(_name_offset);
1464   if (o == NULL) {
1465     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1466     java_class-&gt;obj_field_put(_name_offset, o);
1467   }
1468   return o;
1469 }
1470 
1471 oop java_lang_Class::source_file(oop java_class) {
1472   assert(_source_file_offset != 0, &quot;must be set&quot;);
1473   return java_class-&gt;obj_field(_source_file_offset);
1474 }
1475 
1476 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1477   assert(_source_file_offset != 0, &quot;must be set&quot;);
1478   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1479 }
1480 
<a name="6" id="anc6"></a>



















1481 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1482   // This should be improved by adding a field at the Java level or by
1483   // introducing a new VM klass (see comment in ClassFileParser)
1484   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1485   if (type != T_VOID) {
1486     Klass* aklass = Universe::typeArrayKlassObj(type);
1487     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1488     release_set_array_klass(java_class, aklass);
1489   }
1490 #ifdef ASSERT
1491   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1492   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1493 #endif
1494   return java_class;
1495 }
1496 
1497 
1498 Klass* java_lang_Class::as_Klass(oop java_class) {
1499   //%note memory_2
1500   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1501   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));
1502   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1503   return k;
1504 }
1505 
1506 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1507   //%note memory_2
1508   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1509   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1510   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1511   return k;
1512 }
1513 
1514 
1515 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1516   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1517   java_class-&gt;metadata_field_put(_klass_offset, klass);
1518 }
1519 
1520 
1521 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1522   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1523   Symbol* name = NULL;
1524   bool is_instance = false;
<a name="7" id="anc7"></a>
1525   if (is_primitive(java_class)) {
1526     name = vmSymbols::type_signature(primitive_type(java_class));
1527   } else {
1528     Klass* k = as_Klass(java_class);
1529     is_instance = k-&gt;is_instance_klass();
<a name="8" id="anc8"></a>
1530     name = k-&gt;name();
1531   }
1532   if (name == NULL) {
1533     st-&gt;print(&quot;&lt;null&gt;&quot;);
1534     return;
1535   }
<a name="9" id="anc9"></a><span class="line-modified">1536   if (is_instance)  st-&gt;print(&quot;L&quot;);</span>






1537   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1538   if (is_instance)  st-&gt;print(&quot;;&quot;);
1539 }
1540 
1541 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1542   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1543   Symbol* name;
1544   if (is_primitive(java_class)) {
1545     name = vmSymbols::type_signature(primitive_type(java_class));
1546     // Because this can create a new symbol, the caller has to decrement
1547     // the refcount, so make adjustment here and below for symbols returned
1548     // that are not created or incremented due to a successful lookup.
1549     name-&gt;increment_refcount();
1550   } else {
1551     Klass* k = as_Klass(java_class);
1552     if (!k-&gt;is_instance_klass()) {
1553       name = k-&gt;name();
1554       name-&gt;increment_refcount();
1555     } else {
1556       ResourceMark rm;
1557       const char* sigstr = k-&gt;signature_name();
<a name="10" id="anc10"></a><span class="line-modified">1558       int         siglen = (int) strlen(sigstr);</span>
1559       if (!intern_if_not_found) {
1560         name = SymbolTable::probe(sigstr, siglen);
1561       } else {
1562         name = SymbolTable::new_symbol(sigstr, siglen);
1563       }
1564     }
1565   }
1566   return name;
1567 }
1568 
1569 // Returns the Java name for this Java mirror (Resource allocated)
1570 // See Klass::external_name().
1571 // For primitive type Java mirrors, its type name is returned.
1572 const char* java_lang_Class::as_external_name(oop java_class) {
1573   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1574   const char* name = NULL;
1575   if (is_primitive(java_class)) {
1576     name = type2name(primitive_type(java_class));
1577   } else {
1578     name = as_Klass(java_class)-&gt;external_name();
1579   }
1580   if (name == NULL) {
1581     name = &quot;&lt;null&gt;&quot;;
1582   }
1583   return name;
1584 }
1585 
1586 Klass* java_lang_Class::array_klass_acquire(oop java_class) {
1587   Klass* k = ((Klass*)java_class-&gt;metadata_field_acquire(_array_klass_offset));
1588   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;is_array_klass(), &quot;should be array klass&quot;);
1589   return k;
1590 }
1591 
1592 
1593 void java_lang_Class::release_set_array_klass(oop java_class, Klass* klass) {
1594   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;is_array_klass(), &quot;should be array klass&quot;);
1595   java_class-&gt;release_metadata_field_put(_array_klass_offset, klass);
1596 }
1597 
1598 
1599 BasicType java_lang_Class::primitive_type(oop java_class) {
1600   assert(java_lang_Class::is_primitive(java_class), &quot;just checking&quot;);
1601   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
1602   BasicType type = T_VOID;
1603   if (ak != NULL) {
1604     // Note: create_basic_type_mirror above initializes ak to a non-null value.
1605     type = ArrayKlass::cast(ak)-&gt;element_type();
1606   } else {
1607     assert(java_class == Universe::void_mirror(), &quot;only valid non-array primitive&quot;);
1608   }
1609   assert(Universe::java_mirror(type) == java_class, &quot;must be consistent&quot;);
1610   return type;
1611 }
1612 
1613 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
1614   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1615   if (is_primitive(java_class)) {
1616     if (reference_klass != NULL)
1617       (*reference_klass) = NULL;
1618     return primitive_type(java_class);
1619   } else {
1620     if (reference_klass != NULL)
1621       (*reference_klass) = as_Klass(java_class);
1622     return T_OBJECT;
1623   }
1624 }
1625 
1626 
1627 oop java_lang_Class::primitive_mirror(BasicType t) {
1628   oop mirror = Universe::java_mirror(t);
1629   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1630   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1631   return mirror;
1632 }
1633 
1634 bool java_lang_Class::offsets_computed = false;
1635 int  java_lang_Class::classRedefinedCount_offset = -1;
1636 
1637 #define CLASS_FIELDS_DO(macro) \
1638   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1639   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1640   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1641   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1642   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
<a name="11" id="anc11"></a>

1643   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1644 
1645 void java_lang_Class::compute_offsets() {
1646   if (offsets_computed) {
1647     return;
1648   }
1649 
1650   offsets_computed = true;
1651 
1652   InstanceKlass* k = SystemDictionary::Class_klass();
1653   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1654 
1655   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1656   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1657   // GC treats them the same.
1658   _init_lock_offset = _component_mirror_offset;
1659 
1660   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1661 }
1662 
1663 #if INCLUDE_CDS
1664 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
1665   f-&gt;do_bool(&amp;offsets_computed);
1666   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1667 
1668   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1669 
1670   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1671 }
1672 #endif
1673 
1674 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
1675   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);
1676   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
1677 }
1678 
1679 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
1680   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);
1681   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
1682 }
1683 
1684 
1685 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1686 //       platform thread structure, and a eetop offset which was used for thread
1687 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1688 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1689 //       instead of the privateInfo_offset.
1690 //
1691 // Note: The stackSize field is only present starting in 1.4.
1692 
1693 int java_lang_Thread::_name_offset = 0;
1694 int java_lang_Thread::_group_offset = 0;
1695 int java_lang_Thread::_contextClassLoader_offset = 0;
1696 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
1697 int java_lang_Thread::_priority_offset = 0;
1698 int java_lang_Thread::_eetop_offset = 0;
1699 int java_lang_Thread::_interrupted_offset = 0;
1700 int java_lang_Thread::_daemon_offset = 0;
1701 int java_lang_Thread::_stillborn_offset = 0;
1702 int java_lang_Thread::_stackSize_offset = 0;
1703 int java_lang_Thread::_tid_offset = 0;
1704 int java_lang_Thread::_thread_status_offset = 0;
1705 int java_lang_Thread::_park_blocker_offset = 0;
1706 
1707 #define THREAD_FIELDS_DO(macro) \
1708   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1709   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1710   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1711   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1712   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1713   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1714   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1715   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1716   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1717   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1718   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1719   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
1720   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)
1721 
1722 void java_lang_Thread::compute_offsets() {
1723   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1724 
1725   InstanceKlass* k = SystemDictionary::Thread_klass();
1726   THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1727 }
1728 
1729 #if INCLUDE_CDS
1730 void java_lang_Thread::serialize_offsets(SerializeClosure* f) {
1731   THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1732 }
1733 #endif
1734 
1735 JavaThread* java_lang_Thread::thread(oop java_thread) {
1736   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
1737 }
1738 
1739 
1740 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
1741   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
1742 }
1743 
1744 bool java_lang_Thread::interrupted(oop java_thread) {
1745   // Make sure the caller can safely access oops.
1746   assert(Thread::current()-&gt;is_VM_thread() ||
1747          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1748           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1749          &quot;Unsafe access to oop&quot;);
1750   return java_thread-&gt;bool_field_volatile(_interrupted_offset);
1751 }
1752 
1753 void java_lang_Thread::set_interrupted(oop java_thread, bool val) {
1754   // Make sure the caller can safely access oops.
1755   assert(Thread::current()-&gt;is_VM_thread() ||
1756          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1757           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1758          &quot;Unsafe access to oop&quot;);
1759   java_thread-&gt;bool_field_put_volatile(_interrupted_offset, val);
1760 }
1761 
1762 
1763 oop java_lang_Thread::name(oop java_thread) {
1764   return java_thread-&gt;obj_field(_name_offset);
1765 }
1766 
1767 
1768 void java_lang_Thread::set_name(oop java_thread, oop name) {
1769   java_thread-&gt;obj_field_put(_name_offset, name);
1770 }
1771 
1772 
1773 ThreadPriority java_lang_Thread::priority(oop java_thread) {
1774   return (ThreadPriority)java_thread-&gt;int_field(_priority_offset);
1775 }
1776 
1777 
1778 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
1779   java_thread-&gt;int_field_put(_priority_offset, priority);
1780 }
1781 
1782 
1783 oop java_lang_Thread::threadGroup(oop java_thread) {
1784   return java_thread-&gt;obj_field(_group_offset);
1785 }
1786 
1787 
1788 bool java_lang_Thread::is_stillborn(oop java_thread) {
1789   return java_thread-&gt;bool_field(_stillborn_offset) != 0;
1790 }
1791 
1792 
1793 // We never have reason to turn the stillborn bit off
1794 void java_lang_Thread::set_stillborn(oop java_thread) {
1795   java_thread-&gt;bool_field_put(_stillborn_offset, true);
1796 }
1797 
1798 
1799 bool java_lang_Thread::is_alive(oop java_thread) {
1800   JavaThread* thr = java_lang_Thread::thread(java_thread);
1801   return (thr != NULL);
1802 }
1803 
1804 
1805 bool java_lang_Thread::is_daemon(oop java_thread) {
1806   return java_thread-&gt;bool_field(_daemon_offset) != 0;
1807 }
1808 
1809 
1810 void java_lang_Thread::set_daemon(oop java_thread) {
1811   java_thread-&gt;bool_field_put(_daemon_offset, true);
1812 }
1813 
1814 oop java_lang_Thread::context_class_loader(oop java_thread) {
1815   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1816 }
1817 
1818 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1819   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1820 }
1821 
1822 
1823 jlong java_lang_Thread::stackSize(oop java_thread) {
1824   return java_thread-&gt;long_field(_stackSize_offset);
1825 }
1826 
1827 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1828 void java_lang_Thread::set_thread_status(oop java_thread,
1829                                          java_lang_Thread::ThreadStatus status) {
1830   java_thread-&gt;int_field_put(_thread_status_offset, status);
1831 }
1832 
1833 // Read thread status value from threadStatus field in java.lang.Thread java class.
1834 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1835   // Make sure the caller is operating on behalf of the VM or is
1836   // running VM code (state == _thread_in_vm).
1837   assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
1838          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1839          &quot;Java Thread is not running in vm&quot;);
1840   return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1841 }
1842 
1843 
1844 jlong java_lang_Thread::thread_id(oop java_thread) {
1845   return java_thread-&gt;long_field(_tid_offset);
1846 }
1847 
1848 oop java_lang_Thread::park_blocker(oop java_thread) {
1849   return java_thread-&gt;obj_field(_park_blocker_offset);
1850 }
1851 
1852 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1853   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1854   switch (status) {
1855     case NEW                      : return &quot;NEW&quot;;
1856     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1857     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1858     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1859     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1860     case PARKED                   : return &quot;WAITING (parking)&quot;;
1861     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1862     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1863     case TERMINATED               : return &quot;TERMINATED&quot;;
1864     default                       : return &quot;UNKNOWN&quot;;
1865   };
1866 }
1867 int java_lang_ThreadGroup::_parent_offset = 0;
1868 int java_lang_ThreadGroup::_name_offset = 0;
1869 int java_lang_ThreadGroup::_threads_offset = 0;
1870 int java_lang_ThreadGroup::_groups_offset = 0;
1871 int java_lang_ThreadGroup::_maxPriority_offset = 0;
1872 int java_lang_ThreadGroup::_destroyed_offset = 0;
1873 int java_lang_ThreadGroup::_daemon_offset = 0;
1874 int java_lang_ThreadGroup::_nthreads_offset = 0;
1875 int java_lang_ThreadGroup::_ngroups_offset = 0;
1876 
1877 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1878   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1879   return java_thread_group-&gt;obj_field(_parent_offset);
1880 }
1881 
1882 // (&quot;name as oop&quot; accessor is not necessary)
1883 
1884 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1885   oop name = java_thread_group-&gt;obj_field(_name_offset);
1886   // ThreadGroup.name can be null
1887   if (name != NULL) {
1888     return java_lang_String::as_utf8_string(name);
1889   }
1890   return NULL;
1891 }
1892 
1893 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1894   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1895   return java_thread_group-&gt;int_field(_nthreads_offset);
1896 }
1897 
1898 objArrayOop java_lang_ThreadGroup::threads(oop java_thread_group) {
1899   oop threads = java_thread_group-&gt;obj_field(_threads_offset);
1900   assert(threads != NULL, &quot;threadgroups should have threads&quot;);
1901   assert(threads-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1902   return objArrayOop(threads);
1903 }
1904 
1905 int java_lang_ThreadGroup::ngroups(oop java_thread_group) {
1906   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1907   return java_thread_group-&gt;int_field(_ngroups_offset);
1908 }
1909 
1910 objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {
1911   oop groups = java_thread_group-&gt;obj_field(_groups_offset);
1912   assert(groups == NULL || groups-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1913   return objArrayOop(groups);
1914 }
1915 
1916 ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {
1917   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1918   return (ThreadPriority) java_thread_group-&gt;int_field(_maxPriority_offset);
1919 }
1920 
1921 bool java_lang_ThreadGroup::is_destroyed(oop java_thread_group) {
1922   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1923   return java_thread_group-&gt;bool_field(_destroyed_offset) != 0;
1924 }
1925 
1926 bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {
1927   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1928   return java_thread_group-&gt;bool_field(_daemon_offset) != 0;
1929 }
1930 
1931 #define THREADGROUP_FIELDS_DO(macro) \
1932   macro(_parent_offset,      k, vmSymbols::parent_name(),      threadgroup_signature,       false); \
1933   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature,            false); \
1934   macro(_threads_offset,     k, vmSymbols::threads_name(),     thread_array_signature,      false); \
1935   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
1936   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
1937   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
1938   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
1939   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
1940   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
1941 
1942 void java_lang_ThreadGroup::compute_offsets() {
1943   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
1944 
1945   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
1946   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1947 }
1948 
1949 #if INCLUDE_CDS
1950 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
1951   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1952 }
1953 #endif
1954 
1955 #define THROWABLE_FIELDS_DO(macro) \
1956   macro(backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \
1957   macro(detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \
1958   macro(stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \
1959   macro(depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \
1960   macro(static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)
1961 
1962 void java_lang_Throwable::compute_offsets() {
1963   InstanceKlass* k = SystemDictionary::Throwable_klass();
1964   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1965 }
1966 
1967 #if INCLUDE_CDS
1968 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
1969   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1970 }
1971 #endif
1972 
1973 oop java_lang_Throwable::unassigned_stacktrace() {
1974   InstanceKlass* ik = SystemDictionary::Throwable_klass();
1975   oop base = ik-&gt;static_field_base_raw();
1976   return base-&gt;obj_field(static_unassigned_stacktrace_offset);
1977 }
1978 
1979 oop java_lang_Throwable::backtrace(oop throwable) {
1980   return throwable-&gt;obj_field_acquire(backtrace_offset);
1981 }
1982 
1983 
1984 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
1985   throwable-&gt;release_obj_field_put(backtrace_offset, value);
1986 }
1987 
1988 int java_lang_Throwable::depth(oop throwable) {
1989   return throwable-&gt;int_field(depth_offset);
1990 }
1991 
1992 void java_lang_Throwable::set_depth(oop throwable, int value) {
1993   throwable-&gt;int_field_put(depth_offset, value);
1994 }
1995 
1996 oop java_lang_Throwable::message(oop throwable) {
1997   return throwable-&gt;obj_field(detailMessage_offset);
1998 }
1999 
2000 
2001 // Return Symbol for detailed_message or NULL
2002 Symbol* java_lang_Throwable::detail_message(oop throwable) {
2003   PRESERVE_EXCEPTION_MARK;  // Keep original exception
2004   oop detailed_message = java_lang_Throwable::message(throwable);
2005   if (detailed_message != NULL) {
2006     return java_lang_String::as_symbol(detailed_message);
2007   }
2008   return NULL;
2009 }
2010 
2011 void java_lang_Throwable::set_message(oop throwable, oop value) {
2012   throwable-&gt;obj_field_put(detailMessage_offset, value);
2013 }
2014 
2015 
2016 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
2017   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);
2018 }
2019 
2020 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2021   set_stacktrace(throwable, NULL);
2022 }
2023 
2024 
2025 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2026   ResourceMark rm;
2027   Klass* k = throwable-&gt;klass();
2028   assert(k != NULL, &quot;just checking&quot;);
2029   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2030   oop msg = message(throwable);
2031   if (msg != NULL) {
2032     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2033   }
2034 }
2035 
2036 // After this many redefines, the stack trace is unreliable.
2037 const int MAX_VERSION = USHRT_MAX;
2038 
2039 static inline bool version_matches(Method* method, int version) {
2040   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2041   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2042 }
2043 
2044 // This class provides a simple wrapper over the internal structure of
2045 // exception backtrace to insulate users of the backtrace from needing
2046 // to know what it looks like.
2047 // The code of this class is not GC safe. Allocations can only happen
2048 // in expand().
2049 class BacktraceBuilder: public StackObj {
2050  friend class BacktraceIterator;
2051  private:
2052   Handle          _backtrace;
2053   objArrayOop     _head;
2054   typeArrayOop    _methods;
2055   typeArrayOop    _bcis;
2056   objArrayOop     _mirrors;
2057   typeArrayOop    _names; // Needed to insulate method name against redefinition.
2058   // True if the top frame of the backtrace is omitted because it shall be hidden.
2059   bool            _has_hidden_top_frame;
2060   int             _index;
2061   NoSafepointVerifier _nsv;
2062 
2063   enum {
2064     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2065     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2066     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2067     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2068     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2069     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2070     trace_size           = java_lang_Throwable::trace_size,
2071     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2072   };
2073 
2074   // get info out of chunks
2075   static typeArrayOop get_methods(objArrayHandle chunk) {
2076     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2077     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2078     return methods;
2079   }
2080   static typeArrayOop get_bcis(objArrayHandle chunk) {
2081     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2082     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2083     return bcis;
2084   }
2085   static objArrayOop get_mirrors(objArrayHandle chunk) {
2086     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2087     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2088     return mirrors;
2089   }
2090   static typeArrayOop get_names(objArrayHandle chunk) {
2091     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2092     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2093     return names;
2094   }
2095   static bool has_hidden_top_frame(objArrayHandle chunk) {
2096     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
2097     return hidden != NULL;
2098   }
2099 
2100  public:
2101 
2102   // constructor for new backtrace
2103   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {
2104     expand(CHECK);
2105     _backtrace = Handle(THREAD, _head);
2106     _index = 0;
2107   }
2108 
2109   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2110     _methods = get_methods(backtrace);
2111     _bcis = get_bcis(backtrace);
2112     _mirrors = get_mirrors(backtrace);
2113     _names = get_names(backtrace);
2114     _has_hidden_top_frame = has_hidden_top_frame(backtrace);
2115     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2116            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2117            _mirrors-&gt;length() == _names-&gt;length(),
2118            &quot;method and source information arrays should match&quot;);
2119 
2120     // head is the preallocated backtrace
2121     _head = backtrace();
2122     _backtrace = Handle(thread, _head);
2123     _index = 0;
2124   }
2125 
2126   void expand(TRAPS) {
2127     objArrayHandle old_head(THREAD, _head);
2128     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2129 
2130     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2131     objArrayHandle new_head(THREAD, head);
2132 
2133     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2134     typeArrayHandle new_methods(THREAD, methods);
2135 
2136     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
2137     typeArrayHandle new_bcis(THREAD, bcis);
2138 
2139     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2140     objArrayHandle new_mirrors(THREAD, mirrors);
2141 
2142     typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);
2143     typeArrayHandle new_names(THREAD, names);
2144 
2145     if (!old_head.is_null()) {
2146       old_head-&gt;obj_at_put(trace_next_offset, new_head());
2147     }
2148     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
2149     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
2150     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
2151     new_head-&gt;obj_at_put(trace_names_offset, new_names());
2152     new_head-&gt;obj_at_put(trace_hidden_offset, NULL);
2153 
2154     _head    = new_head();
2155     _methods = new_methods();
2156     _bcis = new_bcis();
2157     _mirrors = new_mirrors();
2158     _names  = new_names();
2159     _index = 0;
2160   }
2161 
2162   oop backtrace() {
2163     return _backtrace();
2164   }
2165 
2166   inline void push(Method* method, int bci, TRAPS) {
2167     // Smear the -1 bci to 0 since the array only holds unsigned
2168     // shorts.  The later line number lookup would just smear the -1
2169     // to a 0 even if it could be recorded.
2170     if (bci == SynchronizationEntryBCI) bci = 0;
2171 
2172     if (_index &gt;= trace_chunk_size) {
2173       methodHandle mhandle(THREAD, method);
2174       expand(CHECK);
2175       method = mhandle();
2176     }
2177 
2178     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2179     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2180 
2181     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2182     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2183     Symbol* name = method-&gt;name();
2184     _names-&gt;symbol_at_put(_index, name);
2185 
2186     // We need to save the mirrors in the backtrace to keep the class
2187     // from being unloaded while we still have this stack trace.
2188     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2189     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2190     _index++;
2191   }
2192 
2193   void set_has_hidden_top_frame(TRAPS) {
2194     if (!_has_hidden_top_frame) {
2195       // It would be nice to add java/lang/Boolean::TRUE here
2196       // to indicate that this backtrace has a hidden top frame.
2197       // But this code is used before TRUE is allocated.
2198       // Therefore let&#39;s just use an arbitrary legal oop
2199       // available right here. _methods is a short[].
2200       assert(_methods != NULL, &quot;we need a legal oop&quot;);
2201       _has_hidden_top_frame = true;
2202       _head-&gt;obj_at_put(trace_hidden_offset, _methods);
2203     }
2204   }
2205 };
2206 
2207 struct BacktraceElement : public StackObj {
2208   int _method_id;
2209   int _bci;
2210   int _version;
2211   Symbol* _name;
2212   Handle _mirror;
2213   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2214                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2215 };
2216 
2217 class BacktraceIterator : public StackObj {
2218   int _index;
2219   objArrayHandle  _result;
2220   objArrayHandle  _mirrors;
2221   typeArrayHandle _methods;
2222   typeArrayHandle _bcis;
2223   typeArrayHandle _names;
2224 
2225   void init(objArrayHandle result, Thread* thread) {
2226     // Get method id, bci, version and mirror from chunk
2227     _result = result;
2228     if (_result.not_null()) {
2229       _methods = typeArrayHandle(thread, BacktraceBuilder::get_methods(_result));
2230       _bcis = typeArrayHandle(thread, BacktraceBuilder::get_bcis(_result));
2231       _mirrors = objArrayHandle(thread, BacktraceBuilder::get_mirrors(_result));
2232       _names = typeArrayHandle(thread, BacktraceBuilder::get_names(_result));
2233       _index = 0;
2234     }
2235   }
2236  public:
2237   BacktraceIterator(objArrayHandle result, Thread* thread) {
2238     init(result, thread);
2239     assert(_methods.is_null() || _methods-&gt;length() == java_lang_Throwable::trace_chunk_size, &quot;lengths don&#39;t match&quot;);
2240   }
2241 
2242   BacktraceElement next(Thread* thread) {
2243     BacktraceElement e (Handle(thread, _mirrors-&gt;obj_at(_index)),
2244                         _methods-&gt;ushort_at(_index),
2245                         Backtrace::version_at(_bcis-&gt;int_at(_index)),
2246                         Backtrace::bci_at(_bcis-&gt;int_at(_index)),
2247                         _names-&gt;symbol_at(_index));
2248     _index++;
2249 
2250     if (_index &gt;= java_lang_Throwable::trace_chunk_size) {
2251       int next_offset = java_lang_Throwable::trace_next_offset;
2252       // Get next chunk
2253       objArrayHandle result (thread, objArrayOop(_result-&gt;obj_at(next_offset)));
2254       init(result, thread);
2255     }
2256     return e;
2257   }
2258 
2259   bool repeat() {
2260     return _result.not_null() &amp;&amp; _mirrors-&gt;obj_at(_index) != NULL;
2261   }
2262 };
2263 
2264 
2265 // Print stack trace element to resource allocated buffer
2266 static void print_stack_element_to_stream(outputStream* st, Handle mirror, int method_id,
2267                                           int version, int bci, Symbol* name) {
2268   ResourceMark rm;
2269 
2270   // Get strings and string lengths
2271   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));
2272   const char* klass_name  = holder-&gt;external_name();
2273   int buf_len = (int)strlen(klass_name);
2274 
2275   char* method_name = name-&gt;as_C_string();
2276   buf_len += (int)strlen(method_name);
2277 
2278   char* source_file_name = NULL;
2279   Symbol* source = Backtrace::get_source_file_name(holder, version);
2280   if (source != NULL) {
2281     source_file_name = source-&gt;as_C_string();
2282     buf_len += (int)strlen(source_file_name);
2283   }
2284 
2285   char *module_name = NULL, *module_version = NULL;
2286   ModuleEntry* module = holder-&gt;module();
2287   if (module-&gt;is_named()) {
2288     module_name = module-&gt;name()-&gt;as_C_string();
2289     buf_len += (int)strlen(module_name);
2290     if (module-&gt;version() != NULL) {
2291       module_version = module-&gt;version()-&gt;as_C_string();
2292       buf_len += (int)strlen(module_version);
2293     }
2294   }
2295 
2296   // Allocate temporary buffer with extra space for formatting and line number
2297   char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);
2298 
2299   // Print stack trace line in buffer
2300   sprintf(buf, &quot;\tat %s.%s(&quot;, klass_name, method_name);
2301 
2302   // Print module information
2303   if (module_name != NULL) {
2304     if (module_version != NULL) {
2305       sprintf(buf + (int)strlen(buf), &quot;%s@%s/&quot;, module_name, module_version);
2306     } else {
2307       sprintf(buf + (int)strlen(buf), &quot;%s/&quot;, module_name);
2308     }
2309   }
2310 
2311   // The method can be NULL if the requested class version is gone
2312   Method* method = holder-&gt;method_with_orig_idnum(method_id, version);
2313   if (!version_matches(method, version)) {
2314     strcat(buf, &quot;Redefined)&quot;);
2315   } else {
2316     int line_number = Backtrace::get_line_number(method, bci);
2317     if (line_number == -2) {
2318       strcat(buf, &quot;Native Method)&quot;);
2319     } else {
2320       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
2321         // Sourcename and linenumber
2322         sprintf(buf + (int)strlen(buf), &quot;%s:%d)&quot;, source_file_name, line_number);
2323       } else if (source_file_name != NULL) {
2324         // Just sourcename
2325         sprintf(buf + (int)strlen(buf), &quot;%s)&quot;, source_file_name);
2326       } else {
2327         // Neither sourcename nor linenumber
2328         sprintf(buf + (int)strlen(buf), &quot;Unknown Source)&quot;);
2329       }
2330       CompiledMethod* nm = method-&gt;code();
2331       if (WizardMode &amp;&amp; nm != NULL) {
2332         sprintf(buf + (int)strlen(buf), &quot;(nmethod &quot; INTPTR_FORMAT &quot;)&quot;, (intptr_t)nm);
2333       }
2334     }
2335   }
2336 
2337   st-&gt;print_cr(&quot;%s&quot;, buf);
2338 }
2339 
2340 void java_lang_Throwable::print_stack_element(outputStream *st, Method* method, int bci) {
2341   Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
2342   int method_id = method-&gt;orig_method_idnum();
2343   int version = method-&gt;constants()-&gt;version();
2344   print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
2345 }
2346 
2347 /**
2348  * Print the throwable message and its stack trace plus all causes by walking the
2349  * cause chain.  The output looks the same as of Throwable.printStackTrace().
2350  */
2351 void java_lang_Throwable::print_stack_trace(Handle throwable, outputStream* st) {
2352   // First, print the message.
2353   print(throwable(), st);
2354   st-&gt;cr();
2355 
2356   // Now print the stack trace.
2357   Thread* THREAD = Thread::current();
2358   while (throwable.not_null()) {
2359     objArrayHandle result (THREAD, objArrayOop(backtrace(throwable())));
2360     if (result.is_null()) {
2361       st-&gt;print_raw_cr(&quot;\t&lt;&lt;no stack trace available&gt;&gt;&quot;);
2362       return;
2363     }
2364     BacktraceIterator iter(result, THREAD);
2365 
2366     while (iter.repeat()) {
2367       BacktraceElement bte = iter.next(THREAD);
2368       print_stack_element_to_stream(st, bte._mirror, bte._method_id, bte._version, bte._bci, bte._name);
2369     }
2370     {
2371       // Call getCause() which doesn&#39;t necessarily return the _cause field.
2372       EXCEPTION_MARK;
2373       JavaValue cause(T_OBJECT);
2374       JavaCalls::call_virtual(&amp;cause,
2375                               throwable,
2376                               throwable-&gt;klass(),
2377                               vmSymbols::getCause_name(),
2378                               vmSymbols::void_throwable_signature(),
2379                               THREAD);
2380       // Ignore any exceptions. we are in the middle of exception handling. Same as classic VM.
2381       if (HAS_PENDING_EXCEPTION) {
2382         CLEAR_PENDING_EXCEPTION;
2383         throwable = Handle();
2384       } else {
2385         throwable = Handle(THREAD, (oop) cause.get_jobject());
2386         if (throwable.not_null()) {
2387           st-&gt;print(&quot;Caused by: &quot;);
2388           print(throwable(), st);
2389           st-&gt;cr();
2390         }
2391       }
2392     }
2393   }
2394 }
2395 
2396 /**
2397  * Print the throwable stack trace by calling the Java method java.lang.Throwable.printStackTrace().
2398  */
2399 void java_lang_Throwable::java_printStackTrace(Handle throwable, TRAPS) {
2400   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;Throwable instance expected&quot;);
2401   JavaValue result(T_VOID);
2402   JavaCalls::call_virtual(&amp;result,
2403                           throwable,
2404                           SystemDictionary::Throwable_klass(),
2405                           vmSymbols::printStackTrace_name(),
2406                           vmSymbols::void_method_signature(),
2407                           THREAD);
2408 }
2409 
2410 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS) {
2411   if (!StackTraceInThrowable) return;
2412   ResourceMark rm(THREAD);
2413 
2414   // Start out by clearing the backtrace for this object, in case the VM
2415   // runs out of memory while allocating the stack trace
2416   set_backtrace(throwable(), NULL);
2417   // Clear lazily constructed Java level stacktrace if refilling occurs
2418   // This is unnecessary in 1.7+ but harmless
2419   clear_stacktrace(throwable());
2420 
2421   int max_depth = MaxJavaStackTraceDepth;
2422   JavaThread* thread = (JavaThread*)THREAD;
2423 
2424   BacktraceBuilder bt(CHECK);
2425 
2426   // If there is no Java frame just return the method that was being called
2427   // with bci 0
2428   if (!thread-&gt;has_last_Java_frame()) {
2429     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2430       bt.push(method(), 0, CHECK);
2431       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2432       set_depth(throwable(), 1);
2433       set_backtrace(throwable(), bt.backtrace());
2434     }
2435     return;
2436   }
2437 
2438   // Instead of using vframe directly, this version of fill_in_stack_trace
2439   // basically handles everything by hand. This significantly improved the
2440   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2441   // See bug 6333838 for  more details.
2442   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2443   // trace as utilizing vframe.
2444 #ifdef ASSERT
2445   vframeStream st(thread);
2446 #endif
2447   int total_count = 0;
2448   RegisterMap map(thread, false);
2449   int decode_offset = 0;
2450   CompiledMethod* nm = NULL;
2451   bool skip_fillInStackTrace_check = false;
2452   bool skip_throwableInit_check = false;
2453   bool skip_hidden = !ShowHiddenFrames;
2454 
2455   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2456     Method* method = NULL;
2457     int bci = 0;
2458 
2459     // Compiled java method case.
2460     if (decode_offset != 0) {
2461       DebugInfoReadStream stream(nm, decode_offset);
2462       decode_offset = stream.read_int();
2463       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2464       bci = stream.read_bci();
2465     } else {
2466       if (fr.is_first_frame()) break;
2467       address pc = fr.pc();
2468       if (fr.is_interpreted_frame()) {
2469         address bcp = fr.interpreter_frame_bcp();
2470         method = fr.interpreter_frame_method();
2471         bci =  method-&gt;bci_from(bcp);
2472         fr = fr.sender(&amp;map);
2473       } else {
2474         CodeBlob* cb = fr.cb();
2475         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2476         // but non nmethod
2477         fr = fr.sender(&amp;map);
2478         if (cb == NULL || !cb-&gt;is_compiled()) {
2479           continue;
2480         }
2481         nm = cb-&gt;as_compiled_method();
2482         if (nm-&gt;method()-&gt;is_native()) {
2483           method = nm-&gt;method();
2484           bci = 0;
2485         } else {
2486           PcDesc* pd = nm-&gt;pc_desc_at(pc);
2487           decode_offset = pd-&gt;scope_decode_offset();
2488           // if decode_offset is not equal to 0, it will execute the
2489           // &quot;compiled java method case&quot; at the beginning of the loop.
2490           continue;
2491         }
2492       }
2493     }
2494 #ifdef ASSERT
2495     assert(st.method() == method &amp;&amp; st.bci() == bci,
2496            &quot;Wrong stack trace&quot;);
2497     st.next();
2498 #endif
2499 
2500     // the format of the stacktrace will be:
2501     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2502     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2503     // - rest of the stack
2504 
2505     if (!skip_fillInStackTrace_check) {
2506       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2507           throwable-&gt;is_a(method-&gt;method_holder())) {
2508         continue;
2509       }
2510       else {
2511         skip_fillInStackTrace_check = true; // gone past them all
2512       }
2513     }
2514     if (!skip_throwableInit_check) {
2515       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2516 
2517       // skip &lt;init&gt; methods of the exception class and superclasses
<a name="12" id="anc12"></a><span class="line-modified">2518       // This is simlar to classic VM.</span>
<span class="line-modified">2519       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
2520           throwable-&gt;is_a(method-&gt;method_holder())) {
2521         continue;
2522       } else {
2523         // there are none or we&#39;ve seen them all - either way stop checking
2524         skip_throwableInit_check = true;
2525       }
2526     }
2527     if (method-&gt;is_hidden()) {
2528       if (skip_hidden) {
2529         if (total_count == 0) {
2530           // The top frame will be hidden from the stack trace.
2531           bt.set_has_hidden_top_frame(CHECK);
2532         }
2533         continue;
2534       }
2535     }
2536     bt.push(method, bci, CHECK);
2537     total_count++;
2538   }
2539 
2540   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), total_count);
2541 
2542   // Put completed stack trace into throwable object
2543   set_backtrace(throwable(), bt.backtrace());
2544   set_depth(throwable(), total_count);
2545 }
2546 
2547 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method) {
2548   // No-op if stack trace is disabled
2549   if (!StackTraceInThrowable) {
2550     return;
2551   }
2552 
2553   // Disable stack traces for some preallocated out of memory errors
2554   if (!Universe::should_fill_in_stack_trace(throwable)) {
2555     return;
2556   }
2557 
2558   PRESERVE_EXCEPTION_MARK;
2559 
2560   JavaThread* thread = JavaThread::active();
2561   fill_in_stack_trace(throwable, method, thread);
2562   // ignore exceptions thrown during stack trace filling
2563   CLEAR_PENDING_EXCEPTION;
2564 }
2565 
2566 void java_lang_Throwable::allocate_backtrace(Handle throwable, TRAPS) {
2567   // Allocate stack trace - backtrace is created but not filled in
2568 
2569   // No-op if stack trace is disabled
2570   if (!StackTraceInThrowable) return;
2571   BacktraceBuilder bt(CHECK);   // creates a backtrace
2572   set_backtrace(throwable(), bt.backtrace());
2573 }
2574 
2575 
2576 void java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(Handle throwable) {
2577   // Fill in stack trace into preallocated backtrace (no GC)
2578 
2579   // No-op if stack trace is disabled
2580   if (!StackTraceInThrowable) return;
2581 
2582   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;sanity check&quot;);
2583 
2584   JavaThread* THREAD = JavaThread::current();
2585 
2586   objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));
2587   assert(backtrace.not_null(), &quot;backtrace should have been preallocated&quot;);
2588 
2589   ResourceMark rm(THREAD);
2590   vframeStream st(THREAD);
2591 
2592   BacktraceBuilder bt(THREAD, backtrace);
2593 
2594   // Unlike fill_in_stack_trace we do not skip fillInStackTrace or throwable init
2595   // methods as preallocated errors aren&#39;t created by &quot;java&quot; code.
2596 
2597   // fill in as much stack trace as possible
2598   int chunk_count = 0;
2599   for (;!st.at_end(); st.next()) {
2600     bt.push(st.method(), st.bci(), CHECK);
2601     chunk_count++;
2602 
2603     // Bail-out for deep stacks
2604     if (chunk_count &gt;= trace_chunk_size) break;
2605   }
2606   set_depth(throwable(), chunk_count);
2607   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), chunk_count);
2608 
2609   // We support the Throwable immutability protocol defined for Java 7.
2610   java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());
2611   assert(java_lang_Throwable::unassigned_stacktrace() != NULL, &quot;not initialized&quot;);
2612 }
2613 
2614 void java_lang_Throwable::get_stack_trace_elements(Handle throwable,
2615                                                    objArrayHandle stack_trace_array_h, TRAPS) {
2616 
2617   if (throwable.is_null() || stack_trace_array_h.is_null()) {
2618     THROW(vmSymbols::java_lang_NullPointerException());
2619   }
2620 
2621   assert(stack_trace_array_h-&gt;is_objArray(), &quot;Stack trace array should be an array of StackTraceElenent&quot;);
2622 
2623   if (stack_trace_array_h-&gt;length() != depth(throwable())) {
2624     THROW(vmSymbols::java_lang_IndexOutOfBoundsException());
2625   }
2626 
2627   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable())));
2628   BacktraceIterator iter(result, THREAD);
2629 
2630   int index = 0;
2631   while (iter.repeat()) {
2632     BacktraceElement bte = iter.next(THREAD);
2633 
2634     Handle stack_trace_element(THREAD, stack_trace_array_h-&gt;obj_at(index++));
2635 
2636     if (stack_trace_element.is_null()) {
2637       THROW(vmSymbols::java_lang_NullPointerException());
2638     }
2639 
2640     InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2641     methodHandle method (THREAD, holder-&gt;method_with_orig_idnum(bte._method_id, bte._version));
2642 
2643     java_lang_StackTraceElement::fill_in(stack_trace_element, holder,
2644                                          method,
2645                                          bte._version,
2646                                          bte._bci,
2647                                          bte._name, CHECK);
2648   }
2649 }
2650 
2651 bool java_lang_Throwable::get_top_method_and_bci(oop throwable, Method** method, int* bci) {
2652   Thread* THREAD = Thread::current();
2653   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));
2654   BacktraceIterator iter(result, THREAD);
2655   // No backtrace available.
2656   if (!iter.repeat()) return false;
2657 
2658   // If the exception happened in a frame that has been hidden, i.e.,
2659   // omitted from the back trace, we can not compute the message.
2660   oop hidden = ((objArrayOop)backtrace(throwable))-&gt;obj_at(trace_hidden_offset);
2661   if (hidden != NULL) {
2662     return false;
2663   }
2664 
2665   // Get first backtrace element.
2666   BacktraceElement bte = iter.next(THREAD);
2667 
2668   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2669   assert(holder != NULL, &quot;first element should be non-null&quot;);
2670   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2671 
2672   // Original version is no longer available.
2673   if (m == NULL || !version_matches(m, bte._version)) {
2674     return false;
2675   }
2676 
2677   *method = m;
2678   *bci = bte._bci;
2679   return true;
2680 }
2681 
2682 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2683   // Allocate java.lang.StackTraceElement instance
2684   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2685   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2686   if (k-&gt;should_be_initialized()) {
2687     k-&gt;initialize(CHECK_NULL);
2688   }
2689 
2690   Handle element = k-&gt;allocate_instance_handle(CHECK_NULL);
2691 
2692   int version = method-&gt;constants()-&gt;version();
2693   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_NULL);
2694   return element();
2695 }
2696 
2697 void java_lang_StackTraceElement::fill_in(Handle element,
2698                                           InstanceKlass* holder, const methodHandle&amp; method,
2699                                           int version, int bci, Symbol* name, TRAPS) {
2700   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2701 
2702   ResourceMark rm(THREAD);
2703   HandleMark hm(THREAD);
2704 
2705   // Fill in class name
2706   Handle java_class(THREAD, holder-&gt;java_mirror());
2707   oop classname = java_lang_Class::name(java_class, CHECK);
2708   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2709   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2710 
2711   oop loader = holder-&gt;class_loader();
2712   if (loader != NULL) {
2713     oop loader_name = java_lang_ClassLoader::name(loader);
2714     if (loader_name != NULL)
2715       java_lang_StackTraceElement::set_classLoaderName(element(), loader_name);
2716   }
2717 
2718   // Fill in method name
2719   oop methodname = StringTable::intern(name, CHECK);
2720   java_lang_StackTraceElement::set_methodName(element(), methodname);
2721 
2722   // Fill in module name and version
2723   ModuleEntry* module = holder-&gt;module();
2724   if (module-&gt;is_named()) {
2725     oop module_name = StringTable::intern(module-&gt;name(), CHECK);
2726     java_lang_StackTraceElement::set_moduleName(element(), module_name);
2727     oop module_version;
2728     if (module-&gt;version() != NULL) {
2729       module_version = StringTable::intern(module-&gt;version(), CHECK);
2730     } else {
2731       module_version = NULL;
2732     }
2733     java_lang_StackTraceElement::set_moduleVersion(element(), module_version);
2734   }
2735 
2736   if (method() == NULL || !version_matches(method(), version)) {
2737     // The method was redefined, accurate line number information isn&#39;t available
2738     java_lang_StackTraceElement::set_fileName(element(), NULL);
2739     java_lang_StackTraceElement::set_lineNumber(element(), -1);
2740   } else {
2741     Symbol* source;
2742     oop source_file;
2743     int line_number;
2744     decode_file_and_line(java_class, holder, version, method, bci, source, source_file, line_number, CHECK);
2745 
2746     java_lang_StackTraceElement::set_fileName(element(), source_file);
2747     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
2748   }
2749 }
2750 
2751 void java_lang_StackTraceElement::decode_file_and_line(Handle java_class,
2752                                                        InstanceKlass* holder,
2753                                                        int version,
2754                                                        const methodHandle&amp; method,
2755                                                        int bci,
2756                                                        Symbol*&amp; source,
2757                                                        oop&amp; source_file,
2758                                                        int&amp; line_number, TRAPS) {
2759   // Fill in source file name and line number.
2760   source = Backtrace::get_source_file_name(holder, version);
2761   source_file = java_lang_Class::source_file(java_class());
2762   if (source != NULL) {
2763     // Class was not redefined. We can trust its cache if set,
2764     // else we have to initialize it.
2765     if (source_file == NULL) {
2766       source_file = StringTable::intern(source, CHECK);
2767       java_lang_Class::set_source_file(java_class(), source_file);
2768     }
2769   } else {
2770     // Class was redefined. Dump the cache if it was set.
2771     if (source_file != NULL) {
2772       source_file = NULL;
2773       java_lang_Class::set_source_file(java_class(), source_file);
2774     }
2775   }
2776   line_number = Backtrace::get_line_number(method(), bci);
2777 }
2778 
2779 #if INCLUDE_JVMCI
2780 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
2781                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
2782   ResourceMark rm(THREAD);
2783   HandleMark hm(THREAD);
2784 
2785   filename = NULL;
2786   line_number = -1;
2787 
2788   oop source_file;
2789   int version = method-&gt;constants()-&gt;version();
2790   InstanceKlass* holder = method-&gt;method_holder();
2791   Handle java_class(THREAD, holder-&gt;java_mirror());
2792   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
2793 }
2794 #endif // INCLUDE_JVMCI
2795 
2796 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2797   HandleMark hm(THREAD);
2798   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2799   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2800   // we should expand MemberName::name when Throwable uses StackTrace
2801   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2802   return method;
2803 }
2804 
2805 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2806   // set Method* or mid/cpref
2807   HandleMark hm(THREAD);
2808   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2809   InstanceKlass* ik = method-&gt;method_holder();
2810   CallInfo info(method(), ik, CHECK);
2811   MethodHandles::init_method_MemberName(mname, info);
2812   // set bci
2813   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2814   // method may be redefined; store the version
2815   int version = method-&gt;constants()-&gt;version();
2816   assert((jushort)version == version, &quot;version should be short&quot;);
2817   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2818 }
2819 
2820 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2821   ResourceMark rm(THREAD);
2822   HandleMark hm(THREAD);
2823   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2824   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2825   InstanceKlass* holder = InstanceKlass::cast(clazz);
2826   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2827 
2828   short version = stackFrame-&gt;short_field(_version_offset);
2829   int bci = stackFrame-&gt;int_field(_bci_offset);
2830   Symbol* name = method-&gt;name();
2831   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
2832                                        version, bci, name, CHECK);
2833 }
2834 
2835 #define STACKFRAMEINFO_FIELDS_DO(macro) \
2836   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
2837   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)
2838 
2839 void java_lang_StackFrameInfo::compute_offsets() {
2840   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
2841   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2842   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
2843 }
2844 
2845 #if INCLUDE_CDS
2846 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
2847   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2848   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
2849 }
2850 #endif
2851 
2852 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2853   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2854   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2855   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2856   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2857 
2858 void java_lang_LiveStackFrameInfo::compute_offsets() {
2859   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2860   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2861 }
2862 
2863 #if INCLUDE_CDS
2864 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2865   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2866 }
2867 #endif
2868 
2869 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
2870   macro(override_offset, k, &quot;override&quot;, bool_signature, false)
2871 
2872 void java_lang_reflect_AccessibleObject::compute_offsets() {
2873   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2874   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2875 }
2876 
2877 #if INCLUDE_CDS
2878 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
2879   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2880 }
2881 #endif
2882 
2883 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
2884   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2885   return (jboolean) reflect-&gt;bool_field(override_offset);
2886 }
2887 
2888 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
2889   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2890   reflect-&gt;bool_field_put(override_offset, (int) value);
2891 }
2892 
2893 #define METHOD_FIELDS_DO(macro) \
2894   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
2895   macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \
2896   macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \
2897   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
2898   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
2899   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
2900   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
2901   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
2902   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
2903   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \
2904   macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);
2905 
2906 void java_lang_reflect_Method::compute_offsets() {
2907   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
2908   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2909 }
2910 
2911 #if INCLUDE_CDS
2912 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
2913   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2914 }
2915 #endif
2916 
2917 Handle java_lang_reflect_Method::create(TRAPS) {
2918   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2919   Klass* klass = SystemDictionary::reflect_Method_klass();
2920   // This class is eagerly initialized during VM initialization, since we keep a refence
2921   // to one of the methods
2922   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
2923   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
2924 }
2925 
2926 oop java_lang_reflect_Method::clazz(oop reflect) {
2927   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2928   return reflect-&gt;obj_field(clazz_offset);
2929 }
2930 
2931 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
2932   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2933    reflect-&gt;obj_field_put(clazz_offset, value);
2934 }
2935 
2936 int java_lang_reflect_Method::slot(oop reflect) {
2937   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2938   return reflect-&gt;int_field(slot_offset);
2939 }
2940 
2941 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
2942   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2943   reflect-&gt;int_field_put(slot_offset, value);
2944 }
2945 
2946 void java_lang_reflect_Method::set_name(oop method, oop value) {
2947   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2948   method-&gt;obj_field_put(name_offset, value);
2949 }
2950 
2951 oop java_lang_reflect_Method::return_type(oop method) {
2952   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2953   return method-&gt;obj_field(returnType_offset);
2954 }
2955 
2956 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
2957   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2958   method-&gt;obj_field_put(returnType_offset, value);
2959 }
2960 
2961 oop java_lang_reflect_Method::parameter_types(oop method) {
2962   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2963   return method-&gt;obj_field(parameterTypes_offset);
2964 }
2965 
2966 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
2967   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2968   method-&gt;obj_field_put(parameterTypes_offset, value);
2969 }
2970 
2971 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
2972   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2973   method-&gt;obj_field_put(exceptionTypes_offset, value);
2974 }
2975 
2976 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
2977   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2978   method-&gt;int_field_put(modifiers_offset, value);
2979 }
2980 
2981 void java_lang_reflect_Method::set_signature(oop method, oop value) {
2982   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2983   method-&gt;obj_field_put(signature_offset, value);
2984 }
2985 
2986 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
2987   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2988   method-&gt;obj_field_put(annotations_offset, value);
2989 }
2990 
2991 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
2992   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2993   method-&gt;obj_field_put(parameter_annotations_offset, value);
2994 }
2995 
2996 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
2997   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2998   method-&gt;obj_field_put(annotation_default_offset, value);
2999 }
3000 
3001 #define CONSTRUCTOR_FIELDS_DO(macro) \
3002   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
3003   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
3004   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
3005   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
3006   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
3007   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
3008   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
3009   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);
3010 
3011 void java_lang_reflect_Constructor::compute_offsets() {
3012   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3013   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3014 }
3015 
3016 #if INCLUDE_CDS
3017 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3018   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3019 }
3020 #endif
3021 
3022 Handle java_lang_reflect_Constructor::create(TRAPS) {
3023   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3024   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3025   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3026   InstanceKlass* ik = InstanceKlass::cast(k);
3027   // Ensure it is initialized
3028   ik-&gt;initialize(CHECK_NH);
3029   return ik-&gt;allocate_instance_handle(THREAD);
3030 }
3031 
3032 oop java_lang_reflect_Constructor::clazz(oop reflect) {
3033   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3034   return reflect-&gt;obj_field(clazz_offset);
3035 }
3036 
3037 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
3038   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3039    reflect-&gt;obj_field_put(clazz_offset, value);
3040 }
3041 
3042 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
3043   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3044   return constructor-&gt;obj_field(parameterTypes_offset);
3045 }
3046 
3047 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
3048   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3049   constructor-&gt;obj_field_put(parameterTypes_offset, value);
3050 }
3051 
3052 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
3053   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3054   constructor-&gt;obj_field_put(exceptionTypes_offset, value);
3055 }
3056 
3057 int java_lang_reflect_Constructor::slot(oop reflect) {
3058   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3059   return reflect-&gt;int_field(slot_offset);
3060 }
3061 
3062 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
3063   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3064   reflect-&gt;int_field_put(slot_offset, value);
3065 }
3066 
3067 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
3068   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3069   constructor-&gt;int_field_put(modifiers_offset, value);
3070 }
3071 
3072 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
3073   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3074   constructor-&gt;obj_field_put(signature_offset, value);
3075 }
3076 
3077 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
3078   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3079   constructor-&gt;obj_field_put(annotations_offset, value);
3080 }
3081 
3082 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
3083   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3084   method-&gt;obj_field_put(parameter_annotations_offset, value);
3085 }
3086 
3087 #define FIELD_FIELDS_DO(macro) \
3088   macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \
3089   macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \
3090   macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \
3091   macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \
3092   macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \
3093   macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \
3094   macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);
3095 
3096 void java_lang_reflect_Field::compute_offsets() {
3097   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3098   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3099 }
3100 
3101 #if INCLUDE_CDS
3102 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3103   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3104 }
3105 #endif
3106 
3107 Handle java_lang_reflect_Field::create(TRAPS) {
3108   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3109   Symbol* name = vmSymbols::java_lang_reflect_Field();
3110   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3111   InstanceKlass* ik = InstanceKlass::cast(k);
3112   // Ensure it is initialized
3113   ik-&gt;initialize(CHECK_NH);
3114   return ik-&gt;allocate_instance_handle(THREAD);
3115 }
3116 
3117 oop java_lang_reflect_Field::clazz(oop reflect) {
3118   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3119   return reflect-&gt;obj_field(clazz_offset);
3120 }
3121 
3122 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
3123   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3124    reflect-&gt;obj_field_put(clazz_offset, value);
3125 }
3126 
3127 oop java_lang_reflect_Field::name(oop field) {
3128   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3129   return field-&gt;obj_field(name_offset);
3130 }
3131 
3132 void java_lang_reflect_Field::set_name(oop field, oop value) {
3133   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3134   field-&gt;obj_field_put(name_offset, value);
3135 }
3136 
3137 oop java_lang_reflect_Field::type(oop field) {
3138   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3139   return field-&gt;obj_field(type_offset);
3140 }
3141 
3142 void java_lang_reflect_Field::set_type(oop field, oop value) {
3143   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3144   field-&gt;obj_field_put(type_offset, value);
3145 }
3146 
3147 int java_lang_reflect_Field::slot(oop reflect) {
3148   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3149   return reflect-&gt;int_field(slot_offset);
3150 }
3151 
3152 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
3153   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3154   reflect-&gt;int_field_put(slot_offset, value);
3155 }
3156 
3157 int java_lang_reflect_Field::modifiers(oop field) {
3158   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3159   return field-&gt;int_field(modifiers_offset);
3160 }
3161 
3162 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
3163   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3164   field-&gt;int_field_put(modifiers_offset, value);
3165 }
3166 
3167 void java_lang_reflect_Field::set_signature(oop field, oop value) {
3168   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3169   field-&gt;obj_field_put(signature_offset, value);
3170 }
3171 
3172 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
3173   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3174   field-&gt;obj_field_put(annotations_offset, value);
3175 }
3176 
3177 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3178   // Allocate java.lang.reflect.RecordComponent instance
3179   HandleMark hm(THREAD);
3180   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3181   assert(ik != NULL, &quot;must be loaded&quot;);
3182   ik-&gt;initialize(CHECK_NULL);
3183 
3184   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3185 
3186   Handle decl_class(THREAD, holder-&gt;java_mirror());
3187   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3188 
3189   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3190   oop component_name = StringTable::intern(name, CHECK_NULL);
3191   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3192 
3193   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3194   Handle component_type_h =
3195     SystemDictionary::find_java_mirror_for_type(type, holder, SignatureStream::NCDFError, CHECK_NULL);
3196   java_lang_reflect_RecordComponent::set_type(element(), component_type_h());
3197 
3198   Method* accessor_method = NULL;
3199   {
3200     // Prepend &quot;()&quot; to type to create the full method signature.
3201     ResourceMark rm(THREAD);
3202     int sig_len = type-&gt;utf8_length() + 3; // &quot;()&quot; and null char
3203     char* sig = NEW_RESOURCE_ARRAY(char, sig_len);
3204     jio_snprintf(sig, sig_len, &quot;%c%c%s&quot;, JVM_SIGNATURE_FUNC, JVM_SIGNATURE_ENDFUNC, type-&gt;as_C_string());
3205     TempNewSymbol full_sig = SymbolTable::new_symbol(sig);
3206     accessor_method = holder-&gt;find_instance_method(name, full_sig, Klass::find_private);
3207   }
3208 
3209   if (accessor_method != NULL) {
3210     methodHandle method(THREAD, accessor_method);
3211     oop m = Reflection::new_method(method, false, CHECK_NULL);
3212     java_lang_reflect_RecordComponent::set_accessor(element(), m);
3213   } else {
3214     java_lang_reflect_RecordComponent::set_accessor(element(), NULL);
3215   }
3216 
3217   int sig_index = component-&gt;generic_signature_index();
3218   if (sig_index &gt; 0) {
3219     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3220     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3221     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3222   } else {
3223     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3224   }
3225 
3226   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3227   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3228 
3229   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3230   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3231 
3232   return element();
3233 }
3234 
3235 #define CONSTANTPOOL_FIELDS_DO(macro) \
3236   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3237 
3238 void reflect_ConstantPool::compute_offsets() {
3239   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3240   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3241   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3242 }
3243 
3244 #if INCLUDE_CDS
3245 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3246   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3247 }
3248 #endif
3249 
3250 #define PARAMETER_FIELDS_DO(macro) \
3251   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
3252   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
3253   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
3254   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
3255 
3256 void java_lang_reflect_Parameter::compute_offsets() {
3257   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3258   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3259 }
3260 
3261 #if INCLUDE_CDS
3262 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3263   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3264 }
3265 #endif
3266 
3267 Handle java_lang_reflect_Parameter::create(TRAPS) {
3268   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3269   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3270   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3271   InstanceKlass* ik = InstanceKlass::cast(k);
3272   // Ensure it is initialized
3273   ik-&gt;initialize(CHECK_NH);
3274   return ik-&gt;allocate_instance_handle(THREAD);
3275 }
3276 
3277 oop java_lang_reflect_Parameter::name(oop param) {
3278   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3279   return param-&gt;obj_field(name_offset);
3280 }
3281 
3282 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
3283   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3284   param-&gt;obj_field_put(name_offset, value);
3285 }
3286 
3287 int java_lang_reflect_Parameter::modifiers(oop param) {
3288   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3289   return param-&gt;int_field(modifiers_offset);
3290 }
3291 
3292 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
3293   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3294   param-&gt;int_field_put(modifiers_offset, value);
3295 }
3296 
3297 int java_lang_reflect_Parameter::index(oop param) {
3298   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3299   return param-&gt;int_field(index_offset);
3300 }
3301 
3302 void java_lang_reflect_Parameter::set_index(oop param, int value) {
3303   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3304   param-&gt;int_field_put(index_offset, value);
3305 }
3306 
3307 oop java_lang_reflect_Parameter::executable(oop param) {
3308   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3309   return param-&gt;obj_field(executable_offset);
3310 }
3311 
3312 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
3313   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3314   param-&gt;obj_field_put(executable_offset, value);
3315 }
3316 
3317 
3318 int java_lang_Module::loader_offset;
3319 int java_lang_Module::name_offset;
3320 int java_lang_Module::_module_entry_offset = -1;
3321 
3322 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3323   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3324   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3325                           vmSymbols::java_lang_module_init_signature(),
3326                           loader, module_name, CHECK_NH);
3327 }
3328 
3329 #define MODULE_FIELDS_DO(macro) \
3330   macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \
3331   macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)
3332 
3333 void java_lang_Module::compute_offsets() {
3334   InstanceKlass* k = SystemDictionary::Module_klass();
3335   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3336   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3337 }
3338 
3339 #if INCLUDE_CDS
3340 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3341   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3342   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3343 }
3344 #endif
3345 
3346 oop java_lang_Module::loader(oop module) {
3347   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3348   return module-&gt;obj_field(loader_offset);
3349 }
3350 
3351 void java_lang_Module::set_loader(oop module, oop value) {
3352   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3353   module-&gt;obj_field_put(loader_offset, value);
3354 }
3355 
3356 oop java_lang_Module::name(oop module) {
3357   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3358   return module-&gt;obj_field(name_offset);
3359 }
3360 
3361 void java_lang_Module::set_name(oop module, oop value) {
3362   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3363   module-&gt;obj_field_put(name_offset, value);
3364 }
3365 
3366 ModuleEntry* java_lang_Module::module_entry(oop module) {
3367   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3368   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3369   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3370 
3371   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3372   if (module_entry == NULL) {
3373     // If the inject field containing the ModuleEntry* is null then return the
3374     // class loader&#39;s unnamed module.
3375     oop loader = java_lang_Module::loader(module);
3376     Handle h_loader = Handle(Thread::current(), loader);
3377     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3378     return loader_cld-&gt;unnamed_module();
3379   }
3380   return module_entry;
3381 }
3382 
3383 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
3384   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3385   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3386   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3387   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3388 }
3389 
3390 Handle reflect_ConstantPool::create(TRAPS) {
3391   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3392   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3393   // Ensure it is initialized
3394   k-&gt;initialize(CHECK_NH);
3395   return k-&gt;allocate_instance_handle(THREAD);
3396 }
3397 
3398 
3399 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
3400   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3401   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3402   // Save the mirror to get back the constant pool.
3403   reflect-&gt;obj_field_put(_oop_offset, mirror);
3404 }
3405 
3406 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
3407   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3408 
3409   oop mirror = reflect-&gt;obj_field(_oop_offset);
3410   Klass* k = java_lang_Class::as_Klass(mirror);
3411   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3412 
3413   // Get the constant pool back from the klass.  Since class redefinition
3414   // merges the new constant pool into the old, this is essentially the
3415   // same constant pool as the original.  If constant pool merging is
3416   // no longer done in the future, this will have to change to save
3417   // the original.
3418   return InstanceKlass::cast(k)-&gt;constants();
3419 }
3420 
3421 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3422   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3423 
3424 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3425   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3426   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3427 }
3428 
3429 #if INCLUDE_CDS
3430 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3431   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3432 }
3433 #endif
3434 
3435 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3436   Klass* k = SystemDictionary::box_klass(type);
3437   if (k == NULL)  return NULL;
3438   InstanceKlass* ik = InstanceKlass::cast(k);
3439   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3440   return ik-&gt;allocate_instance(THREAD);
3441 }
3442 
3443 
3444 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3445   oop box = initialize_and_allocate(type, CHECK_NULL);
3446   if (box == NULL)  return NULL;
3447   switch (type) {
3448     case T_BOOLEAN:
3449       box-&gt;bool_field_put(value_offset, value-&gt;z);
3450       break;
3451     case T_CHAR:
3452       box-&gt;char_field_put(value_offset, value-&gt;c);
3453       break;
3454     case T_FLOAT:
3455       box-&gt;float_field_put(value_offset, value-&gt;f);
3456       break;
3457     case T_DOUBLE:
3458       box-&gt;double_field_put(long_value_offset, value-&gt;d);
3459       break;
3460     case T_BYTE:
3461       box-&gt;byte_field_put(value_offset, value-&gt;b);
3462       break;
3463     case T_SHORT:
3464       box-&gt;short_field_put(value_offset, value-&gt;s);
3465       break;
3466     case T_INT:
3467       box-&gt;int_field_put(value_offset, value-&gt;i);
3468       break;
3469     case T_LONG:
3470       box-&gt;long_field_put(long_value_offset, value-&gt;j);
3471       break;
3472     default:
3473       return NULL;
3474   }
3475   return box;
3476 }
3477 
3478 
3479 BasicType java_lang_boxing_object::basic_type(oop box) {
3480   if (box == NULL)  return T_ILLEGAL;
3481   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3482   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3483     return T_ILLEGAL;
3484   return type;
3485 }
3486 
3487 
3488 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3489   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3490   switch (type) {
3491   case T_BOOLEAN:
3492     value-&gt;z = box-&gt;bool_field(value_offset);
3493     break;
3494   case T_CHAR:
3495     value-&gt;c = box-&gt;char_field(value_offset);
3496     break;
3497   case T_FLOAT:
3498     value-&gt;f = box-&gt;float_field(value_offset);
3499     break;
3500   case T_DOUBLE:
3501     value-&gt;d = box-&gt;double_field(long_value_offset);
3502     break;
3503   case T_BYTE:
3504     value-&gt;b = box-&gt;byte_field(value_offset);
3505     break;
3506   case T_SHORT:
3507     value-&gt;s = box-&gt;short_field(value_offset);
3508     break;
3509   case T_INT:
3510     value-&gt;i = box-&gt;int_field(value_offset);
3511     break;
3512   case T_LONG:
3513     value-&gt;j = box-&gt;long_field(long_value_offset);
3514     break;
3515   default:
3516     return T_ILLEGAL;
3517   } // end switch
3518   return type;
3519 }
3520 
3521 
3522 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3523   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3524   switch (type) {
3525   case T_BOOLEAN:
3526     box-&gt;bool_field_put(value_offset, value-&gt;z);
3527     break;
3528   case T_CHAR:
3529     box-&gt;char_field_put(value_offset, value-&gt;c);
3530     break;
3531   case T_FLOAT:
3532     box-&gt;float_field_put(value_offset, value-&gt;f);
3533     break;
3534   case T_DOUBLE:
3535     box-&gt;double_field_put(long_value_offset, value-&gt;d);
3536     break;
3537   case T_BYTE:
3538     box-&gt;byte_field_put(value_offset, value-&gt;b);
3539     break;
3540   case T_SHORT:
3541     box-&gt;short_field_put(value_offset, value-&gt;s);
3542     break;
3543   case T_INT:
3544     box-&gt;int_field_put(value_offset, value-&gt;i);
3545     break;
3546   case T_LONG:
3547     box-&gt;long_field_put(long_value_offset, value-&gt;j);
3548     break;
3549   default:
3550     return T_ILLEGAL;
3551   } // end switch
3552   return type;
3553 }
3554 
3555 
3556 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3557   switch (type) {
3558   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3559   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3560   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3561   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3562   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3563   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3564   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3565   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3566   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3567   }
3568 }
3569 
3570 // Support for java_lang_ref_Reference
3571 
3572 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
3573   assert(obj != NULL, &quot;sanity&quot;);
3574   if (offset != java_lang_ref_Reference::referent_offset) {
3575     return false;
3576   }
3577 
3578   Klass* k = obj-&gt;klass();
3579   if (!k-&gt;is_instance_klass()) {
3580     return false;
3581   }
3582 
3583   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
3584   bool is_reference = ik-&gt;reference_type() != REF_NONE;
3585   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);
3586   return is_reference;
3587 }
3588 
3589 // Support for java_lang_ref_SoftReference
3590 //
3591 
3592 #define SOFTREFERENCE_FIELDS_DO(macro) \
3593   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \
3594   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)
3595 
3596 void java_lang_ref_SoftReference::compute_offsets() {
3597   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3598   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3599 }
3600 
3601 #if INCLUDE_CDS
3602 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3603   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3604 }
3605 #endif
3606 
3607 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
3608   return ref-&gt;long_field(timestamp_offset);
3609 }
3610 
3611 jlong java_lang_ref_SoftReference::clock() {
3612   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3613   oop base = ik-&gt;static_field_base_raw();
3614   return base-&gt;long_field(static_clock_offset);
3615 }
3616 
3617 void java_lang_ref_SoftReference::set_clock(jlong value) {
3618   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3619   oop base = ik-&gt;static_field_base_raw();
3620   base-&gt;long_field_put(static_clock_offset, value);
3621 }
3622 
3623 // Support for java_lang_invoke_DirectMethodHandle
3624 
3625 int java_lang_invoke_DirectMethodHandle::_member_offset;
3626 
3627 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3628   oop member_name = NULL;
3629   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3630          &quot;a DirectMethodHandle oop is expected&quot;);
3631   return dmh-&gt;obj_field(member_offset_in_bytes());
3632 }
3633 
3634 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3635   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3636 
3637 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3638   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3639   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3640 }
3641 
3642 #if INCLUDE_CDS
3643 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3644   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3645 }
3646 #endif
3647 
3648 // Support for java_lang_invoke_MethodHandle
3649 
3650 int java_lang_invoke_MethodHandle::_type_offset;
3651 int java_lang_invoke_MethodHandle::_form_offset;
3652 
3653 int java_lang_invoke_MemberName::_clazz_offset;
3654 int java_lang_invoke_MemberName::_name_offset;
3655 int java_lang_invoke_MemberName::_type_offset;
3656 int java_lang_invoke_MemberName::_flags_offset;
3657 int java_lang_invoke_MemberName::_method_offset;
3658 int java_lang_invoke_MemberName::_vmindex_offset;
3659 
3660 int java_lang_invoke_ResolvedMethodName::_vmtarget_offset;
3661 int java_lang_invoke_ResolvedMethodName::_vmholder_offset;
3662 
3663 int java_lang_invoke_LambdaForm::_vmentry_offset;
3664 
3665 #define METHODHANDLE_FIELDS_DO(macro) \
3666   macro(_type_offset, k, vmSymbols::type_name(), java_lang_invoke_MethodType_signature, false); \
3667   macro(_form_offset, k, &quot;form&quot;,                 java_lang_invoke_LambdaForm_signature, false)
3668 
3669 void java_lang_invoke_MethodHandle::compute_offsets() {
3670   InstanceKlass* k = SystemDictionary::MethodHandle_klass();
3671   METHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3672 }
3673 
3674 #if INCLUDE_CDS
3675 void java_lang_invoke_MethodHandle::serialize_offsets(SerializeClosure* f) {
3676   METHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3677 }
3678 #endif
3679 
3680 #define MEMBERNAME_FIELDS_DO(macro) \
3681   macro(_clazz_offset,   k, vmSymbols::clazz_name(),   class_signature,  false); \
3682   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature, false); \
3683   macro(_type_offset,    k, vmSymbols::type_name(),    object_signature, false); \
3684   macro(_flags_offset,   k, vmSymbols::flags_name(),   int_signature,    false); \
3685   macro(_method_offset,  k, vmSymbols::method_name(),  java_lang_invoke_ResolvedMethodName_signature, false)
3686 
3687 void java_lang_invoke_MemberName::compute_offsets() {
3688   InstanceKlass* k = SystemDictionary::MemberName_klass();
3689   MEMBERNAME_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3690   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3691 }
3692 
3693 #if INCLUDE_CDS
3694 void java_lang_invoke_MemberName::serialize_offsets(SerializeClosure* f) {
3695   MEMBERNAME_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3696   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3697 }
3698 #endif
3699 
3700 void java_lang_invoke_ResolvedMethodName::compute_offsets() {
3701   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3702   assert(k != NULL, &quot;jdk mismatch&quot;);
3703   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3704 }
3705 
3706 #if INCLUDE_CDS
3707 void java_lang_invoke_ResolvedMethodName::serialize_offsets(SerializeClosure* f) {
3708   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3709 }
3710 #endif
3711 
3712 #define LAMBDAFORM_FIELDS_DO(macro) \
3713   macro(_vmentry_offset, k, &quot;vmentry&quot;, java_lang_invoke_MemberName_signature, false)
3714 
3715 void java_lang_invoke_LambdaForm::compute_offsets() {
3716   InstanceKlass* k = SystemDictionary::LambdaForm_klass();
3717   assert (k != NULL, &quot;jdk mismatch&quot;);
3718   LAMBDAFORM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3719 }
3720 
3721 #if INCLUDE_CDS
3722 void java_lang_invoke_LambdaForm::serialize_offsets(SerializeClosure* f) {
3723   LAMBDAFORM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3724 }
3725 #endif
3726 
3727 bool java_lang_invoke_LambdaForm::is_instance(oop obj) {
3728   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3729 }
3730 
3731 
3732 oop java_lang_invoke_MethodHandle::type(oop mh) {
3733   return mh-&gt;obj_field(_type_offset);
3734 }
3735 
3736 void java_lang_invoke_MethodHandle::set_type(oop mh, oop mtype) {
3737   mh-&gt;obj_field_put(_type_offset, mtype);
3738 }
3739 
3740 oop java_lang_invoke_MethodHandle::form(oop mh) {
3741   assert(_form_offset != 0, &quot;&quot;);
3742   return mh-&gt;obj_field(_form_offset);
3743 }
3744 
3745 void java_lang_invoke_MethodHandle::set_form(oop mh, oop lform) {
3746   assert(_form_offset != 0, &quot;&quot;);
3747   mh-&gt;obj_field_put(_form_offset, lform);
3748 }
3749 
3750 /// MemberName accessors
3751 
3752 oop java_lang_invoke_MemberName::clazz(oop mname) {
3753   assert(is_instance(mname), &quot;wrong type&quot;);
3754   return mname-&gt;obj_field(_clazz_offset);
3755 }
3756 
3757 void java_lang_invoke_MemberName::set_clazz(oop mname, oop clazz) {
3758   assert(is_instance(mname), &quot;wrong type&quot;);
3759   mname-&gt;obj_field_put(_clazz_offset, clazz);
3760 }
3761 
3762 oop java_lang_invoke_MemberName::name(oop mname) {
3763   assert(is_instance(mname), &quot;wrong type&quot;);
3764   return mname-&gt;obj_field(_name_offset);
3765 }
3766 
3767 void java_lang_invoke_MemberName::set_name(oop mname, oop name) {
3768   assert(is_instance(mname), &quot;wrong type&quot;);
3769   mname-&gt;obj_field_put(_name_offset, name);
3770 }
3771 
3772 oop java_lang_invoke_MemberName::type(oop mname) {
3773   assert(is_instance(mname), &quot;wrong type&quot;);
3774   return mname-&gt;obj_field(_type_offset);
3775 }
3776 
3777 void java_lang_invoke_MemberName::set_type(oop mname, oop type) {
3778   assert(is_instance(mname), &quot;wrong type&quot;);
3779   mname-&gt;obj_field_put(_type_offset, type);
3780 }
3781 
3782 int java_lang_invoke_MemberName::flags(oop mname) {
3783   assert(is_instance(mname), &quot;wrong type&quot;);
3784   return mname-&gt;int_field(_flags_offset);
3785 }
3786 
3787 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3788   assert(is_instance(mname), &quot;wrong type&quot;);
3789   mname-&gt;int_field_put(_flags_offset, flags);
3790 }
3791 
3792 
3793 // Return vmtarget from ResolvedMethodName method field through indirection
3794 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3795   assert(is_instance(mname), &quot;wrong type&quot;);
3796   oop method = mname-&gt;obj_field(_method_offset);
3797   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3798 }
3799 
3800 bool java_lang_invoke_MemberName::is_method(oop mname) {
3801   assert(is_instance(mname), &quot;must be MemberName&quot;);
<a name="13" id="anc13"></a><span class="line-modified">3802   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;</span>
3803 }
3804 
3805 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3806   assert(is_instance(mname), &quot;wrong type&quot;);
3807   mname-&gt;obj_field_put(_method_offset, resolved_method);
3808 }
3809 
3810 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3811   assert(is_instance(mname), &quot;wrong type&quot;);
3812   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3813 }
3814 
3815 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3816   assert(is_instance(mname), &quot;wrong type&quot;);
3817   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3818 }
3819 
3820 
3821 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3822   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3823   Method* m = (Method*)resolved_method-&gt;address_field(_vmtarget_offset);
3824   assert(m-&gt;is_method(), &quot;must be&quot;);
3825   return m;
3826 }
3827 
3828 // Used by redefinition to change Method* to new Method* with same hash (name, signature)
3829 void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
3830   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3831   resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
3832 }
3833 
3834 void java_lang_invoke_ResolvedMethodName::set_vmholder(oop resolved_method, oop holder) {
3835   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3836   resolved_method-&gt;obj_field_put(_vmholder_offset, holder);
3837 }
3838 
3839 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
3840   const Method* method = m();
3841 
3842   // lookup ResolvedMethod oop in the table, or create a new one and intern it
3843   oop resolved_method = ResolvedMethodTable::find_method(method);
3844   if (resolved_method != NULL) {
3845     return resolved_method;
3846   }
3847 
3848   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3849   if (!k-&gt;is_initialized()) {
3850     k-&gt;initialize(CHECK_NULL);
3851   }
3852 
3853   oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);
3854 
3855   NoSafepointVerifier nsv;
3856 
3857   if (method-&gt;is_old()) {
3858     method = (method-&gt;is_deleted()) ? Universe::throw_no_such_method_error() :
3859                                       method-&gt;get_new_method();
3860   }
3861 
3862   InstanceKlass* holder = method-&gt;method_holder();
3863 
3864   set_vmtarget(new_resolved_method, const_cast&lt;Method*&gt;(method));
3865   // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have
3866   // distinct loaders) to ensure the metadata is kept alive.
3867   // This mirror may be different than the one in clazz field.
3868   set_vmholder(new_resolved_method, holder-&gt;java_mirror());
3869 
3870   // Set flag in class to indicate this InstanceKlass has entries in the table
3871   // to avoid walking table during redefinition if none of the redefined classes
3872   // have any membernames in the table.
3873   holder-&gt;set_has_resolved_methods();
3874 
3875   return ResolvedMethodTable::add_method(method, Handle(THREAD, new_resolved_method));
3876 }
3877 
3878 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
3879   assert(is_instance(lform), &quot;wrong type&quot;);
3880   return lform-&gt;obj_field(_vmentry_offset);
3881 }
3882 
3883 
3884 // Support for java_lang_invoke_MethodType
3885 
3886 int java_lang_invoke_MethodType::_rtype_offset;
3887 int java_lang_invoke_MethodType::_ptypes_offset;
3888 
3889 #define METHODTYPE_FIELDS_DO(macro) \
3890   macro(_rtype_offset,  k, &quot;rtype&quot;,  class_signature,       false); \
3891   macro(_ptypes_offset, k, &quot;ptypes&quot;, class_array_signature, false)
3892 
3893 void java_lang_invoke_MethodType::compute_offsets() {
3894   InstanceKlass* k = SystemDictionary::MethodType_klass();
3895   METHODTYPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3896 }
3897 
3898 #if INCLUDE_CDS
3899 void java_lang_invoke_MethodType::serialize_offsets(SerializeClosure* f) {
3900   METHODTYPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3901 }
3902 #endif
3903 
3904 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
3905   st-&gt;print(&quot;(&quot;);
3906   objArrayOop pts = ptypes(mt);
3907   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
3908     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
3909   }
3910   st-&gt;print(&quot;)&quot;);
3911   java_lang_Class::print_signature(rtype(mt), st);
3912 }
3913 
3914 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found) {
3915   ResourceMark rm;
3916   stringStream buffer(128);
3917   print_signature(mt, &amp;buffer);
3918   const char* sigstr =       buffer.base();
3919   int         siglen = (int) buffer.size();
3920   Symbol *name;
3921   if (!intern_if_not_found) {
3922     name = SymbolTable::probe(sigstr, siglen);
3923   } else {
3924     name = SymbolTable::new_symbol(sigstr, siglen);
3925   }
3926   return name;
3927 }
3928 
3929 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
3930   if (mt1 == mt2)
3931     return true;
3932   if (rtype(mt1) != rtype(mt2))
3933     return false;
3934   if (ptype_count(mt1) != ptype_count(mt2))
3935     return false;
3936   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
3937     if (ptype(mt1, i) != ptype(mt2, i))
3938       return false;
3939   }
3940   return true;
3941 }
3942 
3943 oop java_lang_invoke_MethodType::rtype(oop mt) {
3944   assert(is_instance(mt), &quot;must be a MethodType&quot;);
3945   return mt-&gt;obj_field(_rtype_offset);
3946 }
3947 
3948 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
3949   assert(is_instance(mt), &quot;must be a MethodType&quot;);
3950   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
3951 }
3952 
3953 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
3954   return ptypes(mt)-&gt;obj_at(idx);
3955 }
3956 
3957 int java_lang_invoke_MethodType::ptype_count(oop mt) {
3958   return ptypes(mt)-&gt;length();
3959 }
3960 
3961 int java_lang_invoke_MethodType::ptype_slot_count(oop mt) {
3962   objArrayOop pts = ptypes(mt);
3963   int count = pts-&gt;length();
3964   int slots = 0;
3965   for (int i = 0; i &lt; count; i++) {
3966     BasicType bt = java_lang_Class::as_BasicType(pts-&gt;obj_at(i));
3967     slots += type2size[bt];
3968   }
3969   return slots;
3970 }
3971 
3972 int java_lang_invoke_MethodType::rtype_slot_count(oop mt) {
3973   BasicType bt = java_lang_Class::as_BasicType(rtype(mt));
3974   return type2size[bt];
3975 }
3976 
3977 
3978 // Support for java_lang_invoke_CallSite
3979 
3980 int java_lang_invoke_CallSite::_target_offset;
3981 int java_lang_invoke_CallSite::_context_offset;
3982 
3983 #define CALLSITE_FIELDS_DO(macro) \
3984   macro(_target_offset,  k, &quot;target&quot;, java_lang_invoke_MethodHandle_signature, false); \
3985   macro(_context_offset, k, &quot;context&quot;, java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)
3986 
3987 void java_lang_invoke_CallSite::compute_offsets() {
3988   InstanceKlass* k = SystemDictionary::CallSite_klass();
3989   CALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3990 }
3991 
3992 #if INCLUDE_CDS
3993 void java_lang_invoke_CallSite::serialize_offsets(SerializeClosure* f) {
3994   CALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3995 }
3996 #endif
3997 
3998 oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {
3999   assert(java_lang_invoke_CallSite::is_instance(call_site), &quot;&quot;);
4000 
4001   oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
4002   return dep_oop;
4003 }
4004 
4005 // Support for java_lang_invoke_ConstantCallSite
4006 
4007 int java_lang_invoke_ConstantCallSite::_is_frozen_offset;
4008 
4009 #define CONSTANTCALLSITE_FIELDS_DO(macro) \
4010   macro(_is_frozen_offset, k, &quot;isFrozen&quot;, bool_signature, false)
4011 
4012 void java_lang_invoke_ConstantCallSite::compute_offsets() {
4013   InstanceKlass* k = SystemDictionary::ConstantCallSite_klass();
4014   CONSTANTCALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4015 }
4016 
4017 #if INCLUDE_CDS
4018 void java_lang_invoke_ConstantCallSite::serialize_offsets(SerializeClosure* f) {
4019   CONSTANTCALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4020 }
4021 #endif
4022 
4023 // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
4024 
4025 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
4026 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
4027 
4028 void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {
4029   InstanceKlass* k = SystemDictionary::Context_klass();
4030   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4031 }
4032 
4033 #if INCLUDE_CDS
4034 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4035   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4036 }
4037 #endif
4038 
4039 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4040   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4041   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4042   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4043   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4044   return dep_ctx;
4045 }
4046 
4047 // Support for java_security_AccessControlContext
4048 
4049 int java_security_AccessControlContext::_context_offset = 0;
4050 int java_security_AccessControlContext::_privilegedContext_offset = 0;
4051 int java_security_AccessControlContext::_isPrivileged_offset = 0;
4052 int java_security_AccessControlContext::_isAuthorized_offset = -1;
4053 
4054 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4055   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4056   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4057   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4058   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4059 
4060 void java_security_AccessControlContext::compute_offsets() {
4061   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4062   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4063   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4064 }
4065 
4066 #if INCLUDE_CDS
4067 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4068   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4069 }
4070 #endif
4071 
4072 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4073   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4074   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);
4075   // Ensure klass is initialized
4076   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4077   // Allocate result
4078   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4079   // Fill in values
4080   result-&gt;obj_field_put(_context_offset, context());
4081   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4082   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4083   // whitelist AccessControlContexts created by the JVM
4084   result-&gt;bool_field_put(_isAuthorized_offset, true);
4085   return result;
4086 }
4087 
4088 
4089 // Support for java_lang_ClassLoader
4090 
4091 bool java_lang_ClassLoader::offsets_computed = false;
4092 int  java_lang_ClassLoader::_loader_data_offset = -1;
4093 int  java_lang_ClassLoader::parallelCapable_offset = -1;
4094 int  java_lang_ClassLoader::name_offset = -1;
4095 int  java_lang_ClassLoader::nameAndId_offset = -1;
4096 int  java_lang_ClassLoader::unnamedModule_offset = -1;
4097 
4098 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4099   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4100   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4101   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4102 }
4103 
4104 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4105   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4106   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4107   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4108 }
4109 
4110 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4111   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4112   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4113   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4114 }
4115 
4116 #define CLASSLOADER_FIELDS_DO(macro) \
4117   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
4118   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
4119   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \
4120   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \
4121   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)
4122 
4123 void java_lang_ClassLoader::compute_offsets() {
4124   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);
4125   offsets_computed = true;
4126 
4127   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4128   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4129 
4130   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4131 }
4132 
4133 #if INCLUDE_CDS
4134 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4135   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4136   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4137 }
4138 #endif
4139 
4140 oop java_lang_ClassLoader::parent(oop loader) {
4141   assert(is_instance(loader), &quot;loader must be oop&quot;);
4142   return loader-&gt;obj_field(parent_offset);
4143 }
4144 
4145 // Returns the name field of this class loader.  If the name field has not
4146 // been set, null will be returned.
4147 oop java_lang_ClassLoader::name(oop loader) {
4148   assert(is_instance(loader), &quot;loader must be oop&quot;);
4149   return loader-&gt;obj_field(name_offset);
4150 }
4151 
4152 // Returns the nameAndId field of this class loader. The format is
4153 // as follows:
4154 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4155 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4156 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4157 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4158 oop java_lang_ClassLoader::nameAndId(oop loader) {
4159   assert(is_instance(loader), &quot;loader must be oop&quot;);
4160   return loader-&gt;obj_field(nameAndId_offset);
4161 }
4162 
4163 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4164   assert(is_instance(loader), &quot;loader must be oop&quot;);
4165   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4166   oop acl = loader;
4167   debug_only(jint loop_count = 0);
4168   // This loop taken verbatim from ClassLoader.java:
4169   do {
4170     acl = parent(acl);
4171     if (cl == acl) {
4172       return true;
4173     }
4174     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4175   } while (acl != NULL);
4176   return false;
4177 }
4178 
4179 bool java_lang_ClassLoader::is_instance(oop obj) {
4180   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4181 }
4182 
4183 
4184 // For class loader classes, parallelCapable defined
4185 // based on non-null field
4186 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4187 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
4188   assert(parallelCapable_offset != -1, &quot;offsets should have been initialized&quot;);
4189   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
4190 }
4191 
4192 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4193   // Fix for 4474172; see evaluation for more details
4194   loader = non_reflection_class_loader(loader);
4195 
4196   oop cl = SystemDictionary::java_system_loader();
4197   while(cl != NULL) {
4198     if (cl == loader) return true;
4199     cl = parent(cl);
4200   }
4201   return false;
4202 }
4203 
4204 // Return true if this is one of the class loaders associated with
4205 // the generated bytecodes for reflection.
4206 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4207   if (loader != NULL) {
4208     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4209     // This might be null in non-1.4 JDKs
4210     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4211   }
4212   return false;
4213 }
4214 
4215 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4216   // See whether this is one of the class loaders associated with
4217   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4218   // delegate to its parent to prevent class loading from occurring
4219   // in places where applications using reflection didn&#39;t expect it.
4220   if (is_reflection_class_loader(loader)) {
4221     return parent(loader);
4222   }
4223   return loader;
4224 }
4225 
4226 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4227   assert(is_instance(loader), &quot;loader must be oop&quot;);
4228   return loader-&gt;obj_field(unnamedModule_offset);
4229 }
4230 
4231 // Support for java_lang_System
4232 //
4233 #define SYSTEM_FIELDS_DO(macro) \
4234   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \
4235   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \
4236   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \
4237   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)
4238 
4239 void java_lang_System::compute_offsets() {
4240   InstanceKlass* k = SystemDictionary::System_klass();
4241   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4242 }
4243 
4244 #if INCLUDE_CDS
4245 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4246    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4247 }
4248 #endif
4249 
4250 int java_lang_System::in_offset_in_bytes() { return static_in_offset; }
4251 int java_lang_System::out_offset_in_bytes() { return static_out_offset; }
4252 int java_lang_System::err_offset_in_bytes() { return static_err_offset; }
4253 
4254 // Support for jdk_internal_misc_UnsafeConstants
4255 //
4256 class UnsafeConstantsFixup : public FieldClosure {
4257 private:
4258   int _address_size;
4259   int _page_size;
4260   bool _big_endian;
4261   bool _use_unaligned_access;
4262   int _data_cache_line_flush_size;
4263 public:
4264   UnsafeConstantsFixup() {
4265     // round up values for all static final fields
4266     _address_size = sizeof(void*);
4267     _page_size = os::vm_page_size();
4268     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4269     _use_unaligned_access = UseUnalignedAccesses;
4270     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4271   }
4272 
4273   void do_field(fieldDescriptor* fd) {
4274     oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
4275     assert(mirror != NULL, &quot;UnsafeConstants must have mirror already&quot;);
4276     assert(fd-&gt;field_holder() == SystemDictionary::UnsafeConstants_klass(), &quot;Should be UnsafeConstants&quot;);
4277     assert(fd-&gt;is_final(), &quot;fields of UnsafeConstants must be final&quot;);
4278     assert(fd-&gt;is_static(), &quot;fields of UnsafeConstants must be static&quot;);
4279     if (fd-&gt;name() == vmSymbols::address_size_name()) {
4280       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4281     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4282       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4283     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4284       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4285     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4286       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4287     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4288       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4289     } else {
4290       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4291     }
4292   }
4293 };
4294 
4295 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4296   UnsafeConstantsFixup fixup;
4297   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4298 }
4299 
4300 int java_lang_Class::_klass_offset;
4301 int java_lang_Class::_array_klass_offset;
4302 int java_lang_Class::_oop_size_offset;
4303 int java_lang_Class::_static_oop_field_count_offset;
4304 int java_lang_Class::_class_loader_offset;
4305 int java_lang_Class::_module_offset;
4306 int java_lang_Class::_protection_domain_offset;
4307 int java_lang_Class::_component_mirror_offset;
<a name="14" id="anc14"></a>

4308 int java_lang_Class::_init_lock_offset;
4309 int java_lang_Class::_signers_offset;
4310 int java_lang_Class::_name_offset;
4311 int java_lang_Class::_source_file_offset;
4312 int java_lang_Class::_classData_offset;
4313 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4314 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4315 int java_lang_Throwable::backtrace_offset;
4316 int java_lang_Throwable::detailMessage_offset;
4317 int java_lang_Throwable::stackTrace_offset;
4318 int java_lang_Throwable::depth_offset;
4319 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4320 int java_lang_reflect_AccessibleObject::override_offset;
4321 int java_lang_reflect_Method::clazz_offset;
4322 int java_lang_reflect_Method::name_offset;
4323 int java_lang_reflect_Method::returnType_offset;
4324 int java_lang_reflect_Method::parameterTypes_offset;
4325 int java_lang_reflect_Method::exceptionTypes_offset;
4326 int java_lang_reflect_Method::slot_offset;
4327 int java_lang_reflect_Method::modifiers_offset;
4328 int java_lang_reflect_Method::signature_offset;
4329 int java_lang_reflect_Method::annotations_offset;
4330 int java_lang_reflect_Method::parameter_annotations_offset;
4331 int java_lang_reflect_Method::annotation_default_offset;
4332 int java_lang_reflect_Constructor::clazz_offset;
4333 int java_lang_reflect_Constructor::parameterTypes_offset;
4334 int java_lang_reflect_Constructor::exceptionTypes_offset;
4335 int java_lang_reflect_Constructor::slot_offset;
4336 int java_lang_reflect_Constructor::modifiers_offset;
4337 int java_lang_reflect_Constructor::signature_offset;
4338 int java_lang_reflect_Constructor::annotations_offset;
4339 int java_lang_reflect_Constructor::parameter_annotations_offset;
4340 int java_lang_reflect_Field::clazz_offset;
4341 int java_lang_reflect_Field::name_offset;
4342 int java_lang_reflect_Field::type_offset;
4343 int java_lang_reflect_Field::slot_offset;
4344 int java_lang_reflect_Field::modifiers_offset;
4345 int java_lang_reflect_Field::signature_offset;
4346 int java_lang_reflect_Field::annotations_offset;
4347 int java_lang_reflect_Parameter::name_offset;
4348 int java_lang_reflect_Parameter::modifiers_offset;
4349 int java_lang_reflect_Parameter::index_offset;
4350 int java_lang_reflect_Parameter::executable_offset;
4351 int java_lang_boxing_object::value_offset;
4352 int java_lang_boxing_object::long_value_offset;
4353 int java_lang_ref_Reference::referent_offset;
4354 int java_lang_ref_Reference::queue_offset;
4355 int java_lang_ref_Reference::next_offset;
4356 int java_lang_ref_Reference::discovered_offset;
4357 int java_lang_ref_SoftReference::timestamp_offset;
4358 int java_lang_ref_SoftReference::static_clock_offset;
4359 int java_lang_ClassLoader::parent_offset;
4360 int java_lang_System::static_in_offset;
4361 int java_lang_System::static_out_offset;
4362 int java_lang_System::static_err_offset;
4363 int java_lang_System::static_security_offset;
4364 int java_lang_StackTraceElement::methodName_offset;
4365 int java_lang_StackTraceElement::fileName_offset;
4366 int java_lang_StackTraceElement::lineNumber_offset;
4367 int java_lang_StackTraceElement::moduleName_offset;
4368 int java_lang_StackTraceElement::moduleVersion_offset;
4369 int java_lang_StackTraceElement::classLoaderName_offset;
4370 int java_lang_StackTraceElement::declaringClass_offset;
4371 int java_lang_StackTraceElement::declaringClassObject_offset;
4372 int java_lang_StackFrameInfo::_memberName_offset;
4373 int java_lang_StackFrameInfo::_bci_offset;
4374 int java_lang_StackFrameInfo::_version_offset;
4375 int java_lang_LiveStackFrameInfo::_monitors_offset;
4376 int java_lang_LiveStackFrameInfo::_locals_offset;
4377 int java_lang_LiveStackFrameInfo::_operands_offset;
4378 int java_lang_LiveStackFrameInfo::_mode_offset;
4379 int java_lang_AssertionStatusDirectives::classes_offset;
4380 int java_lang_AssertionStatusDirectives::classEnabled_offset;
4381 int java_lang_AssertionStatusDirectives::packages_offset;
4382 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4383 int java_lang_AssertionStatusDirectives::deflt_offset;
4384 int java_nio_Buffer::_limit_offset;
4385 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4386 int reflect_ConstantPool::_oop_offset;
4387 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4388 int java_lang_Integer_IntegerCache::_static_cache_offset;
4389 int java_lang_Long_LongCache::_static_cache_offset;
4390 int java_lang_Character_CharacterCache::_static_cache_offset;
4391 int java_lang_Short_ShortCache::_static_cache_offset;
4392 int java_lang_Byte_ByteCache::_static_cache_offset;
4393 int java_lang_Boolean::_static_TRUE_offset;
4394 int java_lang_Boolean::_static_FALSE_offset;
4395 int java_lang_reflect_RecordComponent::clazz_offset;
4396 int java_lang_reflect_RecordComponent::name_offset;
4397 int java_lang_reflect_RecordComponent::type_offset;
4398 int java_lang_reflect_RecordComponent::accessor_offset;
4399 int java_lang_reflect_RecordComponent::signature_offset;
4400 int java_lang_reflect_RecordComponent::annotations_offset;
4401 int java_lang_reflect_RecordComponent::typeAnnotations_offset;
<a name="15" id="anc15"></a>




4402 
4403 
4404 
4405 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4406   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4407   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4408   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4409   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4410   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4411   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4412   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4413   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4414 
4415 // Support for java_lang_StackTraceElement
4416 void java_lang_StackTraceElement::compute_offsets() {
4417   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4418   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4419 }
4420 
4421 #if INCLUDE_CDS
4422 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4423   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4424 }
4425 #endif
4426 
4427 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
4428   element-&gt;obj_field_put(fileName_offset, value);
4429 }
4430 
4431 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
4432   element-&gt;obj_field_put(declaringClass_offset, value);
4433 }
4434 
4435 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
4436   element-&gt;obj_field_put(methodName_offset, value);
4437 }
4438 
4439 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
4440   element-&gt;int_field_put(lineNumber_offset, value);
4441 }
4442 
4443 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
4444   element-&gt;obj_field_put(moduleName_offset, value);
4445 }
4446 
4447 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
4448   element-&gt;obj_field_put(moduleVersion_offset, value);
4449 }
4450 
4451 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
4452   element-&gt;obj_field_put(classLoaderName_offset, value);
4453 }
4454 
4455 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
4456   element-&gt;obj_field_put(declaringClassObject_offset, value);
4457 }
4458 
4459 void java_lang_StackFrameInfo::set_version(oop element, short value) {
4460   element-&gt;short_field_put(_version_offset, value);
4461 }
4462 
4463 void java_lang_StackFrameInfo::set_bci(oop element, int value) {
4464   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);
4465   element-&gt;int_field_put(_bci_offset, value);
4466 }
4467 
4468 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
4469   element-&gt;obj_field_put(_monitors_offset, value);
4470 }
4471 
4472 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
4473   element-&gt;obj_field_put(_locals_offset, value);
4474 }
4475 
4476 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
4477   element-&gt;obj_field_put(_operands_offset, value);
4478 }
4479 
4480 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
4481   element-&gt;int_field_put(_mode_offset, value);
4482 }
4483 
4484 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4485 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
4486   macro(classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \
4487   macro(classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \
4488   macro(packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \
4489   macro(packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \
4490   macro(deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)
4491 
4492 void java_lang_AssertionStatusDirectives::compute_offsets() {
4493   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4494   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4495 }
4496 
4497 #if INCLUDE_CDS
4498 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4499   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4500 }
4501 #endif
4502 
4503 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
4504   o-&gt;obj_field_put(classes_offset, val);
4505 }
4506 
4507 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
4508   o-&gt;obj_field_put(classEnabled_offset, val);
4509 }
4510 
4511 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
4512   o-&gt;obj_field_put(packages_offset, val);
4513 }
4514 
4515 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
4516   o-&gt;obj_field_put(packageEnabled_offset, val);
4517 }
4518 
4519 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
4520   o-&gt;bool_field_put(deflt_offset, val);
4521 }
4522 
4523 
4524 // Support for intrinsification of java.nio.Buffer.checkIndex
4525 int java_nio_Buffer::limit_offset() {
4526   return _limit_offset;
4527 }
4528 
4529 #define BUFFER_FIELDS_DO(macro) \
4530   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4531 
4532 void java_nio_Buffer::compute_offsets() {
4533   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4534   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4535   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4536 }
4537 
4538 #if INCLUDE_CDS
4539 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4540   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4541 }
4542 #endif
4543 
4544 #define AOS_FIELDS_DO(macro) \
4545   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4546 
4547 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4548   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4549   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4550 }
4551 
4552 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4553   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4554   return obj-&gt;obj_field(_owner_offset);
4555 }
4556 
4557 #if INCLUDE_CDS
4558 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4559   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4560 }
4561 #endif
4562 
4563 #define INTEGER_CACHE_FIELDS_DO(macro) \
4564   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4565 
4566 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4567   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4568   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4569 }
4570 
4571 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4572   oop base = ik-&gt;static_field_base_raw();
4573   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4574 }
4575 
4576 Symbol* java_lang_Integer_IntegerCache::symbol() {
4577   return vmSymbols::java_lang_Integer_IntegerCache();
4578 }
4579 
4580 #if INCLUDE_CDS
4581 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4582   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4583 }
4584 #endif
4585 #undef INTEGER_CACHE_FIELDS_DO
4586 
4587 jint java_lang_Integer::value(oop obj) {
4588    jvalue v;
4589    java_lang_boxing_object::get_value(obj, &amp;v);
4590    return v.i;
4591 }
4592 
4593 #define LONG_CACHE_FIELDS_DO(macro) \
4594   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Long_array_signature, true)
4595 
4596 void java_lang_Long_LongCache::compute_offsets(InstanceKlass *k) {
4597   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4598   LONG_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4599 }
4600 
4601 objArrayOop java_lang_Long_LongCache::cache(InstanceKlass *ik) {
4602   oop base = ik-&gt;static_field_base_raw();
4603   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4604 }
4605 
4606 Symbol* java_lang_Long_LongCache::symbol() {
4607   return vmSymbols::java_lang_Long_LongCache();
4608 }
4609 
4610 #if INCLUDE_CDS
4611 void java_lang_Long_LongCache::serialize_offsets(SerializeClosure* f) {
4612   LONG_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4613 }
4614 #endif
4615 #undef LONG_CACHE_FIELDS_DO
4616 
4617 jlong java_lang_Long::value(oop obj) {
4618    jvalue v;
4619    java_lang_boxing_object::get_value(obj, &amp;v);
4620    return v.j;
4621 }
4622 
4623 #define CHARACTER_CACHE_FIELDS_DO(macro) \
4624   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Character_array_signature, true)
4625 
4626 void java_lang_Character_CharacterCache::compute_offsets(InstanceKlass *k) {
4627   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4628   CHARACTER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4629 }
4630 
4631 objArrayOop java_lang_Character_CharacterCache::cache(InstanceKlass *ik) {
4632   oop base = ik-&gt;static_field_base_raw();
4633   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4634 }
4635 
4636 Symbol* java_lang_Character_CharacterCache::symbol() {
4637   return vmSymbols::java_lang_Character_CharacterCache();
4638 }
4639 
4640 #if INCLUDE_CDS
4641 void java_lang_Character_CharacterCache::serialize_offsets(SerializeClosure* f) {
4642   CHARACTER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4643 }
4644 #endif
4645 #undef CHARACTER_CACHE_FIELDS_DO
4646 
4647 jchar java_lang_Character::value(oop obj) {
4648    jvalue v;
4649    java_lang_boxing_object::get_value(obj, &amp;v);
4650    return v.c;
4651 }
4652 
4653 #define SHORT_CACHE_FIELDS_DO(macro) \
4654   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Short_array_signature, true)
4655 
4656 void java_lang_Short_ShortCache::compute_offsets(InstanceKlass *k) {
4657   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4658   SHORT_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4659 }
4660 
4661 objArrayOop java_lang_Short_ShortCache::cache(InstanceKlass *ik) {
4662   oop base = ik-&gt;static_field_base_raw();
4663   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4664 }
4665 
4666 Symbol* java_lang_Short_ShortCache::symbol() {
4667   return vmSymbols::java_lang_Short_ShortCache();
4668 }
4669 
4670 #if INCLUDE_CDS
4671 void java_lang_Short_ShortCache::serialize_offsets(SerializeClosure* f) {
4672   SHORT_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4673 }
4674 #endif
4675 #undef SHORT_CACHE_FIELDS_DO
4676 
4677 jshort java_lang_Short::value(oop obj) {
4678    jvalue v;
4679    java_lang_boxing_object::get_value(obj, &amp;v);
4680    return v.s;
4681 }
4682 
4683 #define BYTE_CACHE_FIELDS_DO(macro) \
4684   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Byte_array_signature, true)
4685 
4686 void java_lang_Byte_ByteCache::compute_offsets(InstanceKlass *k) {
4687   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4688   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4689 }
4690 
4691 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4692   oop base = ik-&gt;static_field_base_raw();
4693   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4694 }
4695 
4696 Symbol* java_lang_Byte_ByteCache::symbol() {
4697   return vmSymbols::java_lang_Byte_ByteCache();
4698 }
4699 
4700 #if INCLUDE_CDS
4701 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4702   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4703 }
4704 #endif
4705 #undef BYTE_CACHE_FIELDS_DO
4706 
<a name="16" id="anc16"></a>






























































4707 jbyte java_lang_Byte::value(oop obj) {
4708    jvalue v;
4709    java_lang_boxing_object::get_value(obj, &amp;v);
4710    return v.b;
4711 }
4712 #define BOOLEAN_FIELDS_DO(macro) \
4713   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4714   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4715 
4716 
4717 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4718   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4719   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4720 }
4721 
4722 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4723   oop base = ik-&gt;static_field_base_raw();
4724   return base-&gt;obj_field(_static_TRUE_offset);
4725 }
4726 
4727 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
4728   oop base = ik-&gt;static_field_base_raw();
4729   return base-&gt;obj_field(_static_FALSE_offset);
4730 }
4731 
4732 Symbol* java_lang_Boolean::symbol() {
4733   return vmSymbols::java_lang_Boolean();
4734 }
4735 
4736 #if INCLUDE_CDS
4737 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4738   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4739 }
4740 #endif
4741 #undef BOOLEAN_CACHE_FIELDS_DO
4742 
4743 jboolean java_lang_Boolean::value(oop obj) {
4744    jvalue v;
4745    java_lang_boxing_object::get_value(obj, &amp;v);
4746    return v.z;
4747 }
4748 
4749 static int member_offset(int hardcoded_offset) {
4750   return (hardcoded_offset * heapOopSize) + instanceOopDesc::base_offset_in_bytes();
4751 }
4752 
4753 #define RECORDCOMPONENT_FIELDS_DO(macro) \
4754   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
4755   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \
4756   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \
4757   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
4758   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
4759   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
4760   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
4761 
4762 // Support for java_lang_reflect_RecordComponent
4763 void java_lang_reflect_RecordComponent::compute_offsets() {
4764   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4765   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4766 }
4767 
4768 #if INCLUDE_CDS
4769 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4770   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4771 }
4772 #endif
4773 
4774 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
4775   element-&gt;obj_field_put(clazz_offset, value);
4776 }
4777 
4778 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
4779   element-&gt;obj_field_put(name_offset, value);
4780 }
4781 
4782 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
4783   element-&gt;obj_field_put(type_offset, value);
4784 }
4785 
4786 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
4787   element-&gt;obj_field_put(accessor_offset, value);
4788 }
4789 
4790 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
4791   element-&gt;obj_field_put(signature_offset, value);
4792 }
4793 
4794 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
4795   element-&gt;obj_field_put(annotations_offset, value);
4796 }
4797 
4798 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
4799   element-&gt;obj_field_put(typeAnnotations_offset, value);
4800 }
4801 
4802 // Compute hard-coded offsets
4803 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4804 // are not available to determine the offset_of_static_fields.
4805 void JavaClasses::compute_hard_coded_offsets() {
4806 
4807   // java_lang_boxing_object
4808   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);
4809   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);
4810 
4811   // java_lang_ref_Reference
4812   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);
4813   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);
4814   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);
4815   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);
4816 }
4817 
4818 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4819 
4820 // Compute non-hard-coded field offsets of all the classes in this file
4821 void JavaClasses::compute_offsets() {
4822   if (UseSharedSpaces) {
4823     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4824                                                          JvmtiExport::has_early_class_hook_env()),
4825                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4826     // None of the classes used by the rest of this function can be replaced by
4827     // JMVTI ClassFileLoadHook.
4828     // We are safe to use the archived offsets, which have already been restored
4829     // by JavaClasses::serialize_offsets, without computing the offsets again.
4830     return;
4831   }
4832 
4833   // We have already called the compute_offsets() of the
4834   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4835   // earlier inside SystemDictionary::resolve_well_known_classes()
4836   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4837 }
4838 
4839 #if INCLUDE_CDS
4840 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4841 
4842 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4843   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4844 }
4845 #endif
4846 
4847 #if INCLUDE_CDS_JAVA_HEAP
4848 bool JavaClasses::is_supported_for_archiving(oop obj) {
4849   Klass* klass = obj-&gt;klass();
4850 
4851   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.
4852       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4853       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4854       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4855       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
4856       // So for now we cannot not support these classes for archiving.
4857       //
4858       // These objects typically are not referenced by static fields, but rather by resolved
4859       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
4860       klass == SystemDictionary::ResolvedMethodName_klass() ||
4861       klass == SystemDictionary::MemberName_klass() ||
4862       klass == SystemDictionary::Context_klass()) {
4863     return false;
4864   }
4865 
4866   return true;
4867 }
4868 #endif
4869 
4870 #ifndef PRODUCT
4871 
4872 // These functions exist to assert the validity of hard-coded field offsets to guard
4873 // against changes in the class files
4874 
4875 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
4876   EXCEPTION_MARK;
4877   fieldDescriptor fd;
4878   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
4879   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
4880   InstanceKlass* ik = InstanceKlass::cast(k);
4881   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
4882   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
4883   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
4884     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
4885     return false;
4886   }
4887   if (fd.is_static()) {
4888     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
4889     return false;
4890   }
4891   if (fd.offset() == hardcoded_offset ) {
4892     return true;
4893   } else {
4894     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,
4895                   klass_name, field_name, hardcoded_offset, fd.offset());
4896     return false;
4897   }
4898 }
4899 
4900 // Check the hard-coded field offsets of all the classes in this file
4901 
4902 void JavaClasses::check_offsets() {
4903   bool valid = true;
4904 
4905 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
4906   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)
4907 
4908 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
4909   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)
4910 
4911   // Boxed primitive objects (java_lang_boxing_object)
4912 
4913   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
4914   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
4915   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
4916   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
4917   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
4918   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
4919   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
4920   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
4921 
4922   // java.lang.ref.Reference
4923 
4924   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, referent, &quot;Ljava/lang/Object;&quot;);
4925   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, queue, &quot;Ljava/lang/ref/ReferenceQueue;&quot;);
4926   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, next, &quot;Ljava/lang/ref/Reference;&quot;);
4927   // Fake field
4928   //CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, discovered, &quot;Ljava/lang/ref/Reference;&quot;);
4929 
4930   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);
4931 }
4932 
4933 #endif // PRODUCT
4934 
4935 int InjectedField::compute_offset() {
4936   InstanceKlass* ik = InstanceKlass::cast(klass());
4937   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
4938     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
4939       // Only look at injected fields
4940       continue;
4941     }
4942     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
4943       return fs.offset();
4944     }
4945   }
4946   ResourceMark rm;
4947   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
4948 #ifndef PRODUCT
4949   ik-&gt;print();
4950   tty-&gt;print_cr(&quot;all fields:&quot;);
4951   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
4952     tty-&gt;print_cr(&quot;  name: %s, sig: %s, flags: %08x&quot;, fs.name()-&gt;as_C_string(), fs.signature()-&gt;as_C_string(), fs.access_flags().as_int());
4953   }
4954 #endif //PRODUCT
4955   vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
4956   return -1;
4957 }
4958 
4959 void javaClasses_init() {
4960   JavaClasses::compute_offsets();
4961   JavaClasses::check_offsets();
4962   FilteredFieldsMap::initialize();  // must be done after computing offsets.
4963 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
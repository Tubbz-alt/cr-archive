<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../ci/ciInstanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */

  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/packageEntry.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/verificationType.hpp&quot;
  40 #include &quot;classfile/verifier.hpp&quot;
  41 #include &quot;classfile/vmSymbols.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/annotations.hpp&quot;
  50 #include &quot;oops/constantPool.inline.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  54 #include &quot;oops/klass.inline.hpp&quot;
  55 #include &quot;oops/klassVtable.hpp&quot;
  56 #include &quot;oops/metadata.hpp&quot;
  57 #include &quot;oops/method.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/recordComponent.hpp&quot;
  60 #include &quot;oops/symbol.hpp&quot;

  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/os.hpp&quot;
  68 #include &quot;runtime/perfData.hpp&quot;
  69 #include &quot;runtime/reflection.hpp&quot;
  70 #include &quot;runtime/safepointVerifiers.hpp&quot;
  71 #include &quot;runtime/signature.hpp&quot;
  72 #include &quot;runtime/timer.hpp&quot;
  73 #include &quot;services/classLoadingService.hpp&quot;
  74 #include &quot;services/threadService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/bitMap.inline.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/exceptions.hpp&quot;
  79 #include &quot;utilities/globalDefinitions.hpp&quot;
  80 #include &quot;utilities/growableArray.hpp&quot;
  81 #include &quot;utilities/macros.hpp&quot;
  82 #include &quot;utilities/ostream.hpp&quot;
  83 #include &quot;utilities/resourceHash.hpp&quot;

  84 #include &quot;utilities/utf8.hpp&quot;
  85 
  86 #if INCLUDE_CDS
  87 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  88 #endif
  89 #if INCLUDE_JFR
  90 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  91 #endif
  92 
  93 // We generally try to create the oops directly when parsing, rather than
  94 // allocating temporary data structures and copying the bytes twice. A
  95 // temporary area is only needed when parsing utf8 entries in the constant
  96 // pool and when parsing line number tables.
  97 
  98 // We add assert in debug mode when class format is not checked.
  99 
 100 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 101 #define JAVA_MIN_SUPPORTED_VERSION        45
 102 #define JAVA_PREVIEW_MINOR_VERSION        65535
 103 
</pre>
<hr />
<pre>
 115 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 116 #define JAVA_7_VERSION                    51
 117 
 118 // Extension method support.
 119 #define JAVA_8_VERSION                    52
 120 
 121 #define JAVA_9_VERSION                    53
 122 
 123 #define JAVA_10_VERSION                   54
 124 
 125 #define JAVA_11_VERSION                   55
 126 
 127 #define JAVA_12_VERSION                   56
 128 
 129 #define JAVA_13_VERSION                   57
 130 
 131 #define JAVA_14_VERSION                   58
 132 
 133 #define JAVA_15_VERSION                   59
 134 


 135 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 136   assert((bad_constant == JVM_CONSTANT_Module ||
 137           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 138          &quot;Unexpected bad constant pool entry&quot;);
 139   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 140 }
 141 
 142 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 143                                                   ConstantPool* cp,
 144                                                   const int length,
 145                                                   TRAPS) {
 146   assert(stream != NULL, &quot;invariant&quot;);
 147   assert(cp != NULL, &quot;invariant&quot;);
 148 
 149   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 150   // this function (_current can be allocated in a register, with scalar
 151   // replacement of aggregates). The _current pointer is copied back to
 152   // stream() when this function returns. DON&#39;T call another method within
 153   // this method that uses stream().
 154   const ClassFileStream cfs1 = *stream;
 155   const ClassFileStream* const cfs = &amp;cfs1;
 156 
 157   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 158   debug_only(const u1* const old_current = stream-&gt;current();)
 159 
 160   // Used for batching symbol allocations.
 161   const char* names[SymbolTable::symbol_alloc_batch_size];
 162   int lengths[SymbolTable::symbol_alloc_batch_size];
 163   int indices[SymbolTable::symbol_alloc_batch_size];
 164   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 165   int names_count = 0;
 166 
 167   // parsing  Index 0 is unused
 168   for (int index = 1; index &lt; length; index++) {
 169     // Each of the following case guarantees one more byte in the stream
 170     // for the following tag or the access_flags following constant pool,
 171     // so we don&#39;t need bounds-check for reading tag.
 172     const u1 tag = cfs-&gt;get_u1_fast();
 173     switch (tag) {
<span class="line-modified"> 174       case JVM_CONSTANT_Class : {</span>
 175         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 176         const u2 name_index = cfs-&gt;get_u2_fast();
 177         cp-&gt;klass_index_at_put(index, name_index);
 178         break;
 179       }
 180       case JVM_CONSTANT_Fieldref: {
 181         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 182         const u2 class_index = cfs-&gt;get_u2_fast();
 183         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 184         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 185         break;
 186       }
 187       case JVM_CONSTANT_Methodref: {
 188         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 189         const u2 class_index = cfs-&gt;get_u2_fast();
 190         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 191         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 192         break;
 193       }
 194       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 484         check_property(valid_symbol_at(name_ref_index),
 485           &quot;Invalid constant pool index %u in class file %s&quot;,
 486           name_ref_index, CHECK);
 487         check_property(valid_symbol_at(signature_ref_index),
 488           &quot;Invalid constant pool index %u in class file %s&quot;,
 489           signature_ref_index, CHECK);
 490         break;
 491       }
 492       case JVM_CONSTANT_Utf8:
 493         break;
 494       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 495       case JVM_CONSTANT_UnresolvedClassInError: {
 496         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 497         break;
 498       }
 499       case JVM_CONSTANT_ClassIndex: {
 500         const int class_index = cp-&gt;klass_index_at(index);
 501         check_property(valid_symbol_at(class_index),
 502           &quot;Invalid constant pool index %u in class file %s&quot;,
 503           class_index, CHECK);
<span class="line-modified"> 504         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>







 505         break;
 506       }
 507       case JVM_CONSTANT_StringIndex: {
 508         const int string_index = cp-&gt;string_index_at(index);
 509         check_property(valid_symbol_at(string_index),
 510           &quot;Invalid constant pool index %u in class file %s&quot;,
 511           string_index, CHECK);
 512         Symbol* const sym = cp-&gt;symbol_at(string_index);
 513         cp-&gt;unresolved_string_at_put(index, sym);
 514         break;
 515       }
 516       case JVM_CONSTANT_MethodHandle: {
 517         const int ref_index = cp-&gt;method_handle_index_at(index);
 518         check_property(valid_cp_range(ref_index, length),
 519           &quot;Invalid constant pool index %u in class file %s&quot;,
 520           ref_index, CHECK);
 521         const constantTag tag = cp-&gt;tag_at(ref_index);
 522         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 523 
 524         switch (ref_kind) {
</pre>
<hr />
<pre>
 738             classfile_parse_error(
 739               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 740               name_ref_index, CHECK);
 741           }
 742         }
 743         break;
 744       }
 745       case JVM_CONSTANT_MethodHandle: {
 746         const int ref_index = cp-&gt;method_handle_index_at(index);
 747         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 748         switch (ref_kind) {
 749           case JVM_REF_invokeVirtual:
 750           case JVM_REF_invokeStatic:
 751           case JVM_REF_invokeSpecial:
 752           case JVM_REF_newInvokeSpecial: {
 753             const int name_and_type_ref_index =
 754               cp-&gt;name_and_type_ref_index_at(ref_index);
 755             const int name_ref_index =
 756               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 757             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 758             if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-modified"> 759               if (name != vmSymbols::object_initializer_name()) {</span>
 760                 classfile_parse_error(
 761                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 762                     name_ref_index, CHECK);
 763               }
 764             } else {
<span class="line-modified"> 765               if (name == vmSymbols::object_initializer_name()) {</span>











 766                 classfile_parse_error(
 767                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 768                   name_ref_index, CHECK);
 769               }
 770             }
 771             break;
 772           }
 773           // Other ref_kinds are already fully checked in previous pass.
 774         } // switch(ref_kind)
 775         break;
 776       }
 777       case JVM_CONSTANT_MethodType: {
 778         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 779         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 780         verify_legal_method_signature(no_name, signature, CHECK);
 781         break;
 782       }
 783       case JVM_CONSTANT_Utf8: {
 784         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 785       }
</pre>
<hr />
<pre>
 904   while (entry != NULL) {
 905     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 906       return false;
 907     }
 908     entry = entry-&gt;_next;
 909   }
 910 
 911   // No duplicate is found, allocate a new entry and fill it.
 912   entry = new NameSigHash();
 913   entry-&gt;_name = name;
 914   entry-&gt;_sig = sig;
 915 
 916   // Insert into hash table
 917   entry-&gt;_next = table[index];
 918   table[index] = entry;
 919 
 920   return true;
 921 }
 922 
 923 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 924 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,</span>
<span class="line-modified"> 925                                        const int itfs_len,</span>
<span class="line-modified"> 926                                        ConstantPool* const cp,</span>

 927                                        bool* const has_nonstatic_concrete_methods,







 928                                        TRAPS) {
 929   assert(stream != NULL, &quot;invariant&quot;);
 930   assert(cp != NULL, &quot;invariant&quot;);
 931   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 932 
 933   if (itfs_len == 0) {
<span class="line-modified"> 934     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
 935   } else {
 936     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 937     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-modified"> 938 </span>
<span class="line-removed"> 939     int index;</span>
 940     for (index = 0; index &lt; itfs_len; index++) {
 941       const u2 interface_index = stream-&gt;get_u2(CHECK);
 942       Klass* interf;
 943       check_property(
 944         valid_klass_reference_at(interface_index),
 945         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 946         interface_index, CHECK);
 947       if (cp-&gt;tag_at(interface_index).is_klass()) {
 948         interf = cp-&gt;resolved_klass_at(interface_index);
 949       } else {
 950         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 951 
 952         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 953         // But need to make sure it&#39;s not an array type.
 954         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 955                            &quot;Bad interface name in class file %s&quot;, CHECK);
 956 
<span class="line-modified"> 957         // Call resolve_super so classcircularity is checked</span>
 958         interf = SystemDictionary::resolve_super_or_fail(
 959                                                   _class_name,
 960                                                   unresolved_klass,
 961                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 962                                                   _protection_domain,
 963                                                   false,
 964                                                   CHECK);
 965       }
 966 
 967       if (!interf-&gt;is_interface()) {
 968         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 969                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 970                           _class_name-&gt;as_klass_external_name(),
 971                           interf-&gt;external_name(),
 972                           interf-&gt;class_in_module_of_loader()));
 973       }
 974 
<span class="line-modified"> 975       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {</span>













 976         *has_nonstatic_concrete_methods = true;
 977       }
<span class="line-modified"> 978       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));</span>






 979     }
 980 
 981     if (!_need_verify || itfs_len &lt;= 1) {
 982       return;
 983     }
 984 
 985     // Check if there&#39;s any duplicates in interfaces
 986     ResourceMark rm(THREAD);
 987     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
 988                                                                  NameSigHash*,
 989                                                                  HASH_ROW_SIZE);
 990     initialize_hashtable(interface_names);
 991     bool dup = false;
 992     const Symbol* name = NULL;
 993     {
 994       debug_only(NoSafepointVerifier nsv;)
 995       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified"> 996         const InstanceKlass* const k = _local_interfaces-&gt;at(index);</span>
 997         name = k-&gt;name();
 998         // If no duplicates, add (name, NULL) in hashtable interface_names.
 999         if (!put_after_lookup(name, NULL, interface_names)) {
1000           dup = true;
1001           break;
1002         }
1003       }
1004     }
1005     if (dup) {
1006       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1007                              name-&gt;as_C_string(), CHECK);
1008     }
1009   }
1010 }
1011 
1012 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1013                                            int constantvalue_index,
1014                                            int signature_index,
1015                                            TRAPS) const {
1016   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1452                                             CHECK);
1453   parsed_annotations-&gt;set_field_annotations(a);
1454   a = assemble_annotations(runtime_visible_type_annotations,
1455                            runtime_visible_type_annotations_length,
1456                            runtime_invisible_type_annotations,
1457                            runtime_invisible_type_annotations_length,
1458                            CHECK);
1459   parsed_annotations-&gt;set_field_type_annotations(a);
1460   return;
1461 }
1462 
1463 
1464 // Field allocation types. Used for computing field offsets.
1465 
1466 enum FieldAllocationType {
1467   STATIC_OOP,           // Oops
1468   STATIC_BYTE,          // Boolean, Byte, char
1469   STATIC_SHORT,         // shorts
1470   STATIC_WORD,          // ints
1471   STATIC_DOUBLE,        // aligned long or double

1472   NONSTATIC_OOP,
1473   NONSTATIC_BYTE,
1474   NONSTATIC_SHORT,
1475   NONSTATIC_WORD,
1476   NONSTATIC_DOUBLE,

1477   MAX_FIELD_ALLOCATION_TYPE,
1478   BAD_ALLOCATION_TYPE = -1
1479 };
1480 
1481 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1482   BAD_ALLOCATION_TYPE, // 0
1483   BAD_ALLOCATION_TYPE, // 1
1484   BAD_ALLOCATION_TYPE, // 2
1485   BAD_ALLOCATION_TYPE, // 3
1486   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1487   NONSTATIC_SHORT,     // T_CHAR        =  5,
1488   NONSTATIC_WORD,      // T_FLOAT       =  6,
1489   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1490   NONSTATIC_BYTE,      // T_BYTE        =  8,
1491   NONSTATIC_SHORT,     // T_SHORT       =  9,
1492   NONSTATIC_WORD,      // T_INT         = 10,
1493   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1494   NONSTATIC_OOP,       // T_OBJECT      = 12,
1495   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1496   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1497   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1498   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1499   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1500   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1501   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1502   BAD_ALLOCATION_TYPE, // 0
1503   BAD_ALLOCATION_TYPE, // 1
1504   BAD_ALLOCATION_TYPE, // 2
1505   BAD_ALLOCATION_TYPE, // 3
1506   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1507   STATIC_SHORT,        // T_CHAR        =  5,
1508   STATIC_WORD,         // T_FLOAT       =  6,
1509   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1510   STATIC_BYTE,         // T_BYTE        =  8,
1511   STATIC_SHORT,        // T_SHORT       =  9,
1512   STATIC_WORD,         // T_INT         = 10,
1513   STATIC_DOUBLE,       // T_LONG        = 11,
1514   STATIC_OOP,          // T_OBJECT      = 12,
1515   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1516   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1517   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1518   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1519   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1520   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1521   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1522 };
1523 
<span class="line-modified">1524 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {</span>
1525   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1526   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1527   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);



1528   return result;
1529 }
1530 
1531 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1532  public:
1533   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1534 
1535   FieldAllocationCount() {
1536     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1537       count[i] = 0;
1538     }
1539   }
1540 
<span class="line-modified">1541   FieldAllocationType update(bool is_static, BasicType type) {</span>
<span class="line-modified">1542     FieldAllocationType atype = basic_type_to_atype(is_static, type);</span>
1543     if (atype != BAD_ALLOCATION_TYPE) {
1544       // Make sure there is no overflow with injected fields.
1545       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1546       count[atype]++;
1547     }
1548     return atype;
1549   }
1550 };
1551 
1552 // Side-effects: populates the _fields, _fields_annotations,
1553 // _fields_type_annotations fields
1554 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1555                                    bool is_interface,

1556                                    FieldAllocationCount* const fac,
1557                                    ConstantPool* cp,
1558                                    const int cp_size,
1559                                    u2* const java_fields_count_ptr,
1560                                    TRAPS) {
1561 
1562   assert(cfs != NULL, &quot;invariant&quot;);
1563   assert(fac != NULL, &quot;invariant&quot;);
1564   assert(cp != NULL, &quot;invariant&quot;);
1565   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1566 
1567   assert(NULL == _fields, &quot;invariant&quot;);
1568   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1569   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1570 
1571   cfs-&gt;guarantee_more(2, CHECK);  // length
1572   const u2 length = cfs-&gt;get_u2_fast();
1573   *java_fields_count_ptr = length;
1574 
1575   int num_injected = 0;
1576   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1577                                                                   &amp;num_injected);
<span class="line-modified">1578   const int total_fields = length + num_injected;</span>




1579 
1580   // The field array starts with tuples of shorts
1581   // [access, name index, sig index, initial value index, byte offset].
1582   // A generic signature slot only exists for field with generic
1583   // signature attribute. And the access flag is set with
1584   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1585   // signature slots are at the end of the field array and after all
1586   // other fields data.
1587   //
1588   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1589   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1590   //       ...
1591   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1592   //       [generic signature index]
1593   //       [generic signature index]
1594   //       ...
1595   //
1596   // Allocate a temporary resource array for field data. For each field,
1597   // a slot is reserved in the temporary array for the generic signature
1598   // index. After parsing all fields, the data are copied to a permanent
1599   // array and any unused slots will be discarded.
1600   ResourceMark rm(THREAD);
1601   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1602                                               u2,
1603                                               total_fields * (FieldInfo::field_slots + 1));
1604 
1605   // The generic signature slots start after all other fields&#39; data.
1606   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1607   int num_generic_signature = 0;

1608   for (int n = 0; n &lt; length; n++) {
1609     // access_flags, name_index, descriptor_index, attributes_count
1610     cfs-&gt;guarantee_more(8, CHECK);
1611 




1612     AccessFlags access_flags;
<span class="line-removed">1613     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-removed">1614     verify_legal_field_modifiers(flags, is_interface, CHECK);</span>
1615     access_flags.set_flags(flags);
1616 
1617     const u2 name_index = cfs-&gt;get_u2_fast();
1618     check_property(valid_symbol_at(name_index),
1619       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1620       name_index, CHECK);
1621     const Symbol* const name = cp-&gt;symbol_at(name_index);
1622     verify_legal_field_name(name, CHECK);
1623 
1624     const u2 signature_index = cfs-&gt;get_u2_fast();
1625     check_property(valid_symbol_at(signature_index),
1626       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1627       signature_index, CHECK);
1628     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1629     verify_legal_field_signature(name, sig, CHECK);

















1630 
1631     u2 constantvalue_index = 0;
1632     bool is_synthetic = false;
1633     u2 generic_signature_index = 0;
1634     const bool is_static = access_flags.is_static();
1635     FieldAnnotationCollector parsed_annotations(_loader_data);
1636 
1637     const u2 attributes_count = cfs-&gt;get_u2_fast();
1638     if (attributes_count &gt; 0) {
1639       parse_field_attributes(cfs,
1640                              attributes_count,
1641                              is_static,
1642                              signature_index,
1643                              &amp;constantvalue_index,
1644                              &amp;is_synthetic,
1645                              &amp;generic_signature_index,
1646                              &amp;parsed_annotations,
1647                              CHECK);
1648 
1649       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1669 
1670       if (is_synthetic) {
1671         access_flags.set_is_synthetic();
1672       }
1673       if (generic_signature_index != 0) {
1674         access_flags.set_field_has_generic_signature();
1675         fa[generic_signature_slot] = generic_signature_index;
1676         generic_signature_slot ++;
1677         num_generic_signature ++;
1678       }
1679     }
1680 
1681     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1682     field-&gt;initialize(access_flags.as_short(),
1683                       name_index,
1684                       signature_index,
1685                       constantvalue_index);
1686     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1687 
1688     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1689     const FieldAllocationType atype = fac-&gt;update(is_static, type);</span>
1690     field-&gt;set_allocation_type(atype);
1691 
1692     // After field is initialized with type, we can augment it with aux info
1693     if (parsed_annotations.has_any_annotations()) {
1694       parsed_annotations.apply_to(field);
1695       if (field-&gt;is_contended()) {
1696         _has_contended_fields = true;
1697       }
1698     }
1699   }
1700 
1701   int index = length;
1702   if (num_injected != 0) {
1703     for (int n = 0; n &lt; num_injected; n++) {
1704       // Check for duplicates
1705       if (injected[n].may_be_java) {
1706         const Symbol* const name      = injected[n].name();
1707         const Symbol* const signature = injected[n].signature();
1708         bool duplicate = false;
1709         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1714             duplicate = true;
1715             break;
1716           }
1717         }
1718         if (duplicate) {
1719           // These will be removed from the field array at the end
1720           continue;
1721         }
1722       }
1723 
1724       // Injected field
1725       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1726       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1727                         injected[n].name_index,
1728                         injected[n].signature_index,
1729                         0);
1730 
1731       const BasicType type = Signature::basic_type(injected[n].signature());
1732 
1733       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1734       const FieldAllocationType atype = fac-&gt;update(false, type);</span>
1735       field-&gt;set_allocation_type(atype);
1736       index++;
1737     }
1738   }
1739 





























1740   assert(NULL == _fields, &quot;invariant&quot;);
1741 
1742   _fields =
1743     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1744                                    index * FieldInfo::field_slots + num_generic_signature,
1745                                    CHECK);
1746   // Sometimes injected fields already exist in the Java source so
1747   // the fields array could be too long.  In that case the
1748   // fields array is trimed. Also unused slots that were reserved
1749   // for generic signature indexes are discarded.
1750   {
1751     int i = 0;
1752     for (; i &lt; index * FieldInfo::field_slots; i++) {
1753       _fields-&gt;at_put(i, fa[i]);
1754     }
1755     for (int j = total_fields * FieldInfo::field_slots;
1756          j &lt; generic_signature_slot; j++) {
1757       _fields-&gt;at_put(i++, fa[j]);
1758     }
1759     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2035         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2036         checked_exception, CHECK_NULL);
2037     }
2038   }
2039   // check exceptions attribute length
2040   if (_need_verify) {
2041     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2042                                                    sizeof(u2) * size),
2043                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2044   }
2045   return checked_exceptions_start;
2046 }
2047 
2048 void ClassFileParser::throwIllegalSignature(const char* type,
2049                                             const Symbol* name,
2050                                             const Symbol* sig,
2051                                             TRAPS) const {
2052   assert(name != NULL, &quot;invariant&quot;);
2053   assert(sig != NULL, &quot;invariant&quot;);
2054 





2055   ResourceMark rm(THREAD);
2056   Exceptions::fthrow(THREAD_AND_LOCATION,
2057       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2058       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2059       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());</span>
2060 }
2061 
2062 AnnotationCollector::ID
2063 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2064                                       const Symbol* name,
2065                                       const bool can_access_vm_annotations) {
2066   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2067   // Privileged code can use all annotations.  Other code silently drops some.
2068   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2069                           loader_data-&gt;is_platform_class_loader_data() ||
2070                           can_access_vm_annotations;
2071   switch (sid) {
2072     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2073       if (_location != _in_method)  break;  // only allow for methods
2074       if (!privileged)              break;  // only allow in privileged code
2075       return _method_CallerSensitive;
2076     }
2077     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2078       if (_location != _in_method)  break;  // only allow for methods
2079       if (!privileged)              break;  // only allow in privileged code
</pre>
<hr />
<pre>
2304                              runtime_visible_type_annotations_length,
2305                              runtime_invisible_type_annotations,
2306                              runtime_invisible_type_annotations_length,
2307                              CHECK);
2308     cm-&gt;set_type_annotations(a);
2309   }
2310 }
2311 
2312 
2313 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2314 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2315 // Method* to save footprint, so we only know the size of the resulting Method* when the
2316 // entire method attribute is parsed.
2317 //
2318 // The promoted_flags parameter is used to pass relevant access_flags
2319 // from the method back up to the containing klass. These flag values
2320 // are added to klass&#39;s access_flags.
2321 
2322 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2323                                       bool is_interface,

2324                                       const ConstantPool* cp,
2325                                       AccessFlags* const promoted_flags,
2326                                       TRAPS) {
2327   assert(cfs != NULL, &quot;invariant&quot;);
2328   assert(cp != NULL, &quot;invariant&quot;);
2329   assert(promoted_flags != NULL, &quot;invariant&quot;);
2330 
2331   ResourceMark rm(THREAD);
2332   // Parse fixed parts:
2333   // access_flags, name_index, descriptor_index, attributes_count
2334   cfs-&gt;guarantee_more(8, CHECK_NULL);
2335 
2336   int flags = cfs-&gt;get_u2_fast();
2337   const u2 name_index = cfs-&gt;get_u2_fast();
2338   const int cp_size = cp-&gt;length();
2339   check_property(
2340     valid_symbol_at(name_index),
2341     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2342     name_index, CHECK_NULL);
2343   const Symbol* const name = cp-&gt;symbol_at(name_index);
2344   verify_legal_method_name(name, CHECK_NULL);
2345 
2346   const u2 signature_index = cfs-&gt;get_u2_fast();
2347   guarantee_property(
2348     valid_symbol_at(signature_index),
2349     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2350     signature_index, CHECK_NULL);
2351   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2352 
2353   if (name == vmSymbols::class_initializer_name()) {
2354     // We ignore the other access flags for a valid class initializer.
2355     // (JVM Spec 2nd ed., chapter 4.6)
2356     if (_major_version &lt; 51) { // backward compatibility
2357       flags = JVM_ACC_STATIC;
2358     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2359       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2360     } else {
2361       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2362     }
2363   } else {
<span class="line-modified">2364     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);</span>
<span class="line-modified">2365   }</span>
<span class="line-modified">2366 </span>
<span class="line-modified">2367   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {</span>
<span class="line-modified">2368     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>










































2369   }
2370 
2371   int args_size = -1;  // only used when _need_verify is true
2372   if (_need_verify) {
2373     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2374                  verify_legal_method_signature(name, signature, CHECK_NULL);
2375     if (args_size &gt; MAX_ARGS_SIZE) {
2376       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2377     }
2378   }
2379 
2380   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2381 
2382   // Default values for code and exceptions attribute elements
2383   u2 max_stack = 0;
2384   u2 max_locals = 0;
2385   u4 code_length = 0;
2386   const u1* code_start = 0;
2387   u2 exception_table_length = 0;
2388   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
2899       _has_finalizer = true;
2900     }
2901   }
2902   if (name == vmSymbols::object_initializer_name() &amp;&amp;
2903       signature == vmSymbols::void_method_signature() &amp;&amp;
2904       m-&gt;is_vanilla_constructor()) {
2905     _has_vanilla_constructor = true;
2906   }
2907 
2908   NOT_PRODUCT(m-&gt;verify());
2909   return m;
2910 }
2911 
2912 
2913 // The promoted_flags parameter is used to pass relevant access_flags
2914 // from the methods back up to the containing klass. These flag values
2915 // are added to klass&#39;s access_flags.
2916 // Side-effects: populates the _methods field in the parser
2917 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
2918                                     bool is_interface,

2919                                     AccessFlags* promoted_flags,
2920                                     bool* has_final_method,
2921                                     bool* declares_nonstatic_concrete_methods,
2922                                     TRAPS) {
2923   assert(cfs != NULL, &quot;invariant&quot;);
2924   assert(promoted_flags != NULL, &quot;invariant&quot;);
2925   assert(has_final_method != NULL, &quot;invariant&quot;);
2926   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
2927 
2928   assert(NULL == _methods, &quot;invariant&quot;);
2929 
2930   cfs-&gt;guarantee_more(2, CHECK);  // length
2931   const u2 length = cfs-&gt;get_u2_fast();
2932   if (length == 0) {
2933     _methods = Universe::the_empty_method_array();
2934   } else {
2935     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
2936                                                    length,
2937                                                    NULL,
2938                                                    CHECK);
2939 
2940     for (int index = 0; index &lt; length; index++) {
2941       Method* method = parse_method(cfs,
2942                                     is_interface,

2943                                     _cp,
2944                                     promoted_flags,
2945                                     CHECK);
2946 
2947       if (method-&gt;is_final()) {
2948         *has_final_method = true;
2949       }
2950       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
2951       // used for interface initialization, and default method inheritance analysis
2952       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
2953         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
2954         *declares_nonstatic_concrete_methods = true;
2955       }
2956       _methods-&gt;at_put(index, method);
2957     }
2958 
2959     if (_need_verify &amp;&amp; length &gt; 1) {
2960       // Check duplicated methods
2961       ResourceMark rm(THREAD);
2962       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3115       valid_klass_reference_at(inner_class_info_index),
3116       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3117       inner_class_info_index, CHECK_0);
3118     // Outer class index
3119     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3120     check_property(
3121       outer_class_info_index == 0 ||
3122         valid_klass_reference_at(outer_class_info_index),
3123       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3124       outer_class_info_index, CHECK_0);
3125     // Inner class name
3126     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3127     check_property(
3128       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3129       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3130       inner_name_index, CHECK_0);
3131     if (_need_verify) {
3132       guarantee_property(inner_class_info_index != outer_class_info_index,
3133                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3134     }
<span class="line-modified">3135     // Access flags</span>
<span class="line-modified">3136     jint flags;</span>
3137     // JVM_ACC_MODULE is defined in JDK-9 and later.
3138     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3139       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-removed">3140     } else {</span>
<span class="line-removed">3141       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;</span>
3142     }








3143     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3144       // Set abstract bit for old class files for backward compatibility
3145       flags |= JVM_ACC_ABSTRACT;
3146     }
3147     verify_legal_class_modifiers(flags, CHECK_0);
3148     AccessFlags inner_access_flags(flags);
3149 
3150     inner_classes-&gt;at_put(index++, inner_class_info_index);
3151     inner_classes-&gt;at_put(index++, outer_class_info_index);
3152     inner_classes-&gt;at_put(index++, inner_name_index);
3153     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3154   }
3155 
3156   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3157   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3158     for(int i = 0; i &lt; length * 4; i += 4) {
3159       for(int j = i + 4; j &lt; length * 4; j += 4) {
3160         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3161                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3162                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
3903       }
3904     }
3905     if (runtime_invisible_annotations != NULL) {
3906       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
3907         int append = runtime_visible_annotations_length+i;
3908         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
3909       }
3910     }
3911   }
3912   return annotations;
3913 }
3914 
3915 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
3916                                                         const int super_class_index,
3917                                                         const bool need_verify,
3918                                                         TRAPS) {
3919   assert(cp != NULL, &quot;invariant&quot;);
3920   const InstanceKlass* super_klass = NULL;
3921 
3922   if (super_class_index == 0) {
<span class="line-modified">3923     check_property(_class_name == vmSymbols::java_lang_Object(),</span>

3924                    &quot;Invalid superclass index %u in class file %s&quot;,
3925                    super_class_index,
3926                    CHECK_NULL);
3927   } else {
3928     check_property(valid_klass_reference_at(super_class_index),
3929                    &quot;Invalid superclass index %u in class file %s&quot;,
3930                    super_class_index,
3931                    CHECK_NULL);
3932     // The class name should be legal because it is checked when parsing constant pool.
3933     // However, make sure it is not an array type.
3934     bool is_array = false;
3935     if (cp-&gt;tag_at(super_class_index).is_klass()) {
3936       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
3937       if (need_verify)
3938         is_array = super_klass-&gt;is_array_klass();
3939     } else if (need_verify) {
3940       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
3941     }
3942     if (need_verify) {
3943       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4083 }
4084 
4085 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4086   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4087   if (_nonstatic_oop_map_count &gt; 0) {
4088     OopMapBlock* map = _nonstatic_oop_maps;
4089     OopMapBlock* last_map = last_oop_map();
4090     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4091     while (map &lt;= last_map) {
4092       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4093                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4094       map++;
4095     }
4096   }
4097 }
4098 
4099 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4100   print_on(st);
4101 }
4102 



















4103 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4104 void ClassFileParser::layout_fields(ConstantPool* cp,
4105                                     const FieldAllocationCount* fac,
4106                                     const ClassAnnotationCollector* parsed_annotations,
4107                                     FieldLayoutInfo* info,
4108                                     TRAPS) {
4109 
4110   assert(cp != NULL, &quot;invariant&quot;);
4111 
4112   // Field size and offset computation
4113   int nonstatic_field_size = _super_klass == NULL ? 0 :
4114                                _super_klass-&gt;nonstatic_field_size();






4115 
4116   // Count the contended fields by type.
4117   //
4118   // We ignore static fields, because @Contended is not supported for them.
4119   // The layout code below will also ignore the static fields.
4120   int nonstatic_contended_count = 0;
4121   FieldAllocationCount fac_contended;
4122   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4123     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4124     if (fs.is_contended()) {
4125       fac_contended.count[atype]++;
4126       if (!fs.access_flags().is_static()) {
4127         nonstatic_contended_count++;
4128       }
4129     }
4130   }
4131 
4132 
4133   // Calculate the starting byte offsets
4134   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();

4135   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4136                                       ((fac-&gt;count[STATIC_OOP]) * heapOopSize);</span>
4137   if (fac-&gt;count[STATIC_DOUBLE]) {
4138     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4139   }
4140 
4141   int next_static_word_offset   = next_static_double_offset +
4142                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4143   int next_static_short_offset  = next_static_word_offset +
4144                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4145   int next_static_byte_offset   = next_static_short_offset +
4146                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4147 
4148   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4149                                 nonstatic_field_size * heapOopSize;
4150 










4151   int next_nonstatic_field_offset = nonstatic_fields_start;
4152 
4153   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4154 
4155   // Class is contended, pad before all the fields
4156   if (is_contended_class) {
4157     next_nonstatic_field_offset += ContendedPaddingWidth;
4158   }
4159 








4160   // Compute the non-contended fields count.
4161   // The packing code below relies on these counts to determine if some field
4162   // can be squeezed into the alignment gap. Contended fields are obviously
4163   // exempt from that.
4164   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4165   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4166   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4167   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4168   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4169 









































































4170   // Total non-static fields count, including every contended field
4171   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4172                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4173                                         fac-&gt;count[NONSTATIC_OOP];</span>
4174 
4175   const bool super_has_nonstatic_fields =
4176           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4177   const bool has_nonstatic_fields =
4178     super_has_nonstatic_fields || (nonstatic_fields_count != 0);

4179 





4180 
4181   // Prepare list of oops for oop map generation.
4182   //
4183   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4184   // regions. offset[i] is the start of the i-th region, which then has
4185   // count[i] oops following. Before we know how many regions are required,
4186   // we pessimistically allocate the maps to fit all the oops into the
4187   // distinct regions.
<span class="line-modified">4188 </span>
4189   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">4190   int max_oop_map_count = super_oop_map_count + fac-&gt;count[NONSTATIC_OOP];</span>




4191 
4192   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4193   if (super_oop_map_count &gt; 0) {
4194     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4195                                                     _super_klass-&gt;nonstatic_oop_map_count());
4196   }
4197 
4198   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4199 
4200   bool compact_fields  = true;
4201   bool allocate_oops_first = false;
4202 
4203   // The next classes have predefined hard-coded fields offsets
4204   // (see in JavaClasses::compute_hard_coded_offsets()).
4205   // Use default fields allocation order for them.
4206   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;
4207       (_class_name == vmSymbols::java_lang_ref_Reference() ||
4208        _class_name == vmSymbols::java_lang_Boolean() ||
4209        _class_name == vmSymbols::java_lang_Character() ||
4210        _class_name == vmSymbols::java_lang_Float() ||
</pre>
<hr />
<pre>
4282   }
4283 
4284   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4285                                      (nonstatic_double_count * BytesPerLong);
4286   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4287                                       (nonstatic_word_count * BytesPerInt);
4288   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4289                                      (nonstatic_short_count * BytesPerShort);
4290   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4291                                        nonstatic_byte_count;
4292 
4293   // let oops jump before padding with this allocation style
4294   if (!allocate_oops_first) {
4295     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4296     if( nonstatic_oop_count &gt; 0 ) {
4297       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4298     }
4299     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4300   }
4301 










4302   // Iterate over fields again and compute correct offsets.
4303   // The field allocation type was temporarily stored in the offset slot.
4304   // oop fields are located before non-oop fields (static and non-static).
4305   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4306 
4307     // skip already laid out fields
4308     if (fs.is_offset_set()) continue;
4309 
4310     // contended instance fields are handled below
4311     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4312 
4313     int real_offset = 0;
4314     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4315 
4316     // pack the rest of the fields
4317     switch (atype) {


4318       case STATIC_OOP:
4319         real_offset = next_static_oop_offset;
4320         next_static_oop_offset += heapOopSize;
4321         break;
4322       case STATIC_BYTE:
4323         real_offset = next_static_byte_offset;
4324         next_static_byte_offset += 1;
4325         break;
4326       case STATIC_SHORT:
4327         real_offset = next_static_short_offset;
4328         next_static_short_offset += BytesPerShort;
4329         break;
4330       case STATIC_WORD:
4331         real_offset = next_static_word_offset;
4332         next_static_word_offset += BytesPerInt;
4333         break;
4334       case STATIC_DOUBLE:
4335         real_offset = next_static_double_offset;
4336         next_static_double_offset += BytesPerLong;
4337         break;

























4338       case NONSTATIC_OOP:
4339         if( nonstatic_oop_space_count &gt; 0 ) {
4340           real_offset = nonstatic_oop_space_offset;
4341           nonstatic_oop_space_offset += heapOopSize;
4342           nonstatic_oop_space_count  -= 1;
4343         } else {
4344           real_offset = next_nonstatic_oop_offset;
4345           next_nonstatic_oop_offset += heapOopSize;
4346         }
4347         nonstatic_oop_maps-&gt;add(real_offset, 1);
4348         break;
4349       case NONSTATIC_BYTE:
4350         if( nonstatic_byte_space_count &gt; 0 ) {
4351           real_offset = nonstatic_byte_space_offset;
4352           nonstatic_byte_space_offset += 1;
4353           nonstatic_byte_space_count  -= 1;
4354         } else {
4355           real_offset = next_nonstatic_byte_offset;
4356           next_nonstatic_byte_offset += 1;
4357         }
</pre>
<hr />
<pre>
4436             break;
4437 
4438           case NONSTATIC_SHORT:
4439             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4440             real_offset = next_nonstatic_padded_offset;
4441             next_nonstatic_padded_offset += BytesPerShort;
4442             break;
4443 
4444           case NONSTATIC_WORD:
4445             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4446             real_offset = next_nonstatic_padded_offset;
4447             next_nonstatic_padded_offset += BytesPerInt;
4448             break;
4449 
4450           case NONSTATIC_DOUBLE:
4451             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4452             real_offset = next_nonstatic_padded_offset;
4453             next_nonstatic_padded_offset += BytesPerLong;
4454             break;
4455 






4456           case NONSTATIC_OOP:
4457             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4458             real_offset = next_nonstatic_padded_offset;
4459             next_nonstatic_padded_offset += heapOopSize;
4460             nonstatic_oop_maps-&gt;add(real_offset, 1);
4461             break;
4462 
4463           default:
4464             ShouldNotReachHere();
4465         }
4466 
4467         if (fs.contended_group() == 0) {
4468           // Contended group defines the equivalence class over the fields:
4469           // the fields within the same contended group are not inter-padded.
4470           // The only exception is default group, which does not incur the
4471           // equivalence, and so requires intra-padding.
4472           next_nonstatic_padded_offset += ContendedPaddingWidth;
4473         }
4474 
4475         fs.set_offset(real_offset);
4476       } // for
4477 
4478       // Start laying out the next group.
4479       // Note that this will effectively pad the last group in the back;
4480       // this is expected to alleviate memory contention effects for
4481       // subclass fields and/or adjacent object.
4482       // If this was the default group, the padding is already in place.
4483       if (current_group != 0) {
4484         next_nonstatic_padded_offset += ContendedPaddingWidth;
4485       }
4486     }
4487 
4488     // handle static fields
4489   }
4490 
4491   // Entire class is contended, pad in the back.
4492   // This helps to alleviate memory contention effects for subclass fields
4493   // and/or adjacent object.
4494   if (is_contended_class) {

4495     next_nonstatic_padded_offset += ContendedPaddingWidth;
4496   }
4497 
<span class="line-modified">4498   int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>





4499 
<span class="line-modified">4500   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);</span>






4501   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4502   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4503 
4504   int static_field_size         = (static_fields_end -
4505                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4506   nonstatic_field_size          = nonstatic_field_size +
4507                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4508 
4509   int instance_size             = align_object_size(instance_end / wordSize);
4510 
4511   assert(instance_size == align_object_size(align_up(
<span class="line-modified">4512          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),</span>
<span class="line-modified">4513           wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>

4514 
4515   // Invariant: nonstatic_field end/start should only change if there are
4516   // nonstatic fields in the class, or if the class is contended. We compare
4517   // against the non-aligned value, so that end alignment will not fail the
4518   // assert without actually having the fields.
4519   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4520          is_contended_class ||
4521          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4522 
4523   // Number of non-static oop map blocks allocated at end of klass.
4524   nonstatic_oop_maps-&gt;compact();
4525 
4526 #ifndef PRODUCT
<span class="line-modified">4527   if (PrintFieldLayout) {</span>

4528     print_field_layout(_class_name,
4529           _fields,
4530           cp,
4531           instance_size,
4532           nonstatic_fields_start,
4533           nonstatic_fields_end,
4534           static_fields_end);







4535   }
4536 
4537 #endif
4538   // Pass back information needed for InstanceKlass creation
4539   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4540   info-&gt;_instance_size = instance_size;
4541   info-&gt;_static_field_size = static_field_size;
4542   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4543   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;













4544 }
4545 
4546 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4547   assert(ik != NULL, &quot;invariant&quot;);
4548 
4549   const Klass* const super = ik-&gt;super();
4550 
4551   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4552   // in which case we don&#39;t have to register objects as finalizable
4553   if (!_has_empty_finalizer) {
4554     if (_has_finalizer ||
4555         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4556       ik-&gt;set_has_finalizer();
4557     }
4558   }
4559 
4560 #ifdef ASSERT
4561   bool f = false;
4562   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4563                                            vmSymbols::void_method_signature());
4564   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4565       f = true;
4566   }
4567 
4568   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4569   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4570   // will not work as expected we shouldn&#39;t abort vm in this case
4571   if (!ik-&gt;has_redefined_this_or_super()) {
4572     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4573   }
4574 #endif
4575 
4576   // Check if this klass supports the java.lang.Cloneable interface
4577   if (SystemDictionary::Cloneable_klass_loaded()) {
4578     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {





4579       ik-&gt;set_is_cloneable();
4580     }
4581   }
4582 
4583   // Check if this klass has a vanilla default constructor
4584   if (super == NULL) {
4585     // java.lang.Object has empty default constructor
4586     ik-&gt;set_has_vanilla_constructor();
4587   } else {
4588     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4589         _has_vanilla_constructor) {
4590       ik-&gt;set_has_vanilla_constructor();
4591     }
4592 #ifdef ASSERT
4593     bool v = false;
4594     if (super-&gt;has_vanilla_constructor()) {
4595       const Method* const constructor =
4596         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4597                        vmSymbols::void_method_signature());
4598       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4599         v = true;
4600       }
4601     }
4602     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4603 #endif
4604   }
4605 
4606   // If it cannot be fast-path allocated, set a bit in the layout helper.
4607   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4608   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4609   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4610       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4611       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4612       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4613     // Forbid fast-path allocation.
4614     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4615     ik-&gt;set_layout_helper(lh);
4616   }
4617 }
4618 





4619 // utility methods for appending an array with check for duplicates
4620 
4621 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4622                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4623   // iterate over new interfaces
4624   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4625     InstanceKlass* const e = ifs-&gt;at(i);
4626     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4627     // add new interface
4628     result-&gt;append_if_missing(e);
4629   }
4630 }
4631 
4632 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4633                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4634                                                             ClassLoaderData* loader_data,
4635                                                             TRAPS) {
4636   assert(local_ifs != NULL, &quot;invariant&quot;);
4637   assert(loader_data != NULL, &quot;invariant&quot;);
4638 
</pre>
<hr />
<pre>
4642   // Add superclass transitive interfaces size
4643   if (super != NULL) {
4644     super_size = super-&gt;transitive_interfaces()-&gt;length();
4645     max_transitive_size += super_size;
4646   }
4647   // Add local interfaces&#39; super interfaces
4648   const int local_size = local_ifs-&gt;length();
4649   for (int i = 0; i &lt; local_size; i++) {
4650     InstanceKlass* const l = local_ifs-&gt;at(i);
4651     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4652   }
4653   // Finally add local interfaces
4654   max_transitive_size += local_size;
4655   // Construct array
4656   if (max_transitive_size == 0) {
4657     // no interfaces, use canonicalized array
4658     return Universe::the_empty_instance_klass_array();
4659   } else if (max_transitive_size == super_size) {
4660     // no new local interfaces added, share superklass&#39; transitive interface array
4661     return super-&gt;transitive_interfaces();
<span class="line-modified">4662   } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">4663     // only local interfaces added, share local interface array</span>
<span class="line-modified">4664     return local_ifs;</span>

4665   } else {
4666     ResourceMark rm;
4667     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4668 
4669     // Copy down from superclass
4670     if (super != NULL) {
4671       append_interfaces(result, super-&gt;transitive_interfaces());
4672     }
4673 
4674     // Copy down from local interfaces&#39; superinterfaces
4675     for (int i = 0; i &lt; local_size; i++) {
4676       InstanceKlass* const l = local_ifs-&gt;at(i);
4677       append_interfaces(result, l-&gt;transitive_interfaces());
4678     }
4679     // Finally add local interfaces
4680     append_interfaces(result, local_ifs);
4681 
4682     // length will be less than the max_transitive_size if duplicates were removed
4683     const int length = result-&gt;length();
4684     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);





4685     Array&lt;InstanceKlass*&gt;* const new_result =
4686       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4687     for (int i = 0; i &lt; length; i++) {
4688       InstanceKlass* const e = result-&gt;at(i);
4689       assert(e != NULL, &quot;just checking&quot;);
4690       new_result-&gt;at_put(i, e);
4691     }
4692     return new_result;
4693   }
4694 }
4695 
4696 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4697   assert(this_klass != NULL, &quot;invariant&quot;);
4698   const Klass* const super = this_klass-&gt;super();
4699 
4700   if (super != NULL) {
4701 
4702     // If the loader is not the boot loader then throw an exception if its
4703     // superclass is in package jdk.internal.reflect and its loader is not a
4704     // special reflection class loader
</pre>
<hr />
<pre>
4862     const Method* const m = methods-&gt;at(index);
4863     // if m is static and not the init method, throw a verify error
4864     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4865       ResourceMark rm(THREAD);
4866       Exceptions::fthrow(
4867         THREAD_AND_LOCATION,
4868         vmSymbols::java_lang_VerifyError(),
4869         &quot;Illegal static method %s in interface %s&quot;,
4870         m-&gt;name()-&gt;as_C_string(),
4871         this_klass-&gt;external_name()
4872       );
4873       return;
4874     }
4875   }
4876 }
4877 
4878 // utility methods for format checking
4879 
4880 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4881   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;

4882   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);

4883   if (is_module) {
4884     ResourceMark rm(THREAD);
4885     Exceptions::fthrow(
4886       THREAD_AND_LOCATION,
4887       vmSymbols::java_lang_NoClassDefFoundError(),
4888       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4889       _class_name-&gt;as_C_string());
4890     return;
4891   }
4892 










4893   if (!_need_verify) { return; }
4894 
4895   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4896   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4897   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4898   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4899   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4900   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
4901   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4902   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
4903 
4904   if ((is_abstract &amp;&amp; is_final) ||
4905       (is_interface &amp;&amp; !is_abstract) ||
4906       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">4907       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {</span>

4908     ResourceMark rm(THREAD);


4909     Exceptions::fthrow(
4910       THREAD_AND_LOCATION,
4911       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">4912       &quot;Illegal class modifiers in class %s: 0x%X&quot;,</span>
<span class="line-modified">4913       _class_name-&gt;as_C_string(), flags</span>
4914     );
4915     return;
4916   }
4917 }
4918 
4919 static bool has_illegal_visibility(jint flags) {
4920   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4921   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4922   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4923 
4924   return ((is_public &amp;&amp; is_protected) ||
4925           (is_public &amp;&amp; is_private) ||
4926           (is_protected &amp;&amp; is_private));
4927 }
4928 
4929 // A legal major_version.minor_version must be one of the following:
4930 //
4931 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
4932 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
4933 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
4972     if (!Arguments::enable_preview()) {
4973       Exceptions::fthrow(
4974         THREAD_AND_LOCATION,
4975         vmSymbols::java_lang_UnsupportedClassVersionError(),
4976         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
4977         class_name-&gt;as_C_string(), major, minor);
4978       return;
4979     }
4980 
4981   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
4982     Exceptions::fthrow(
4983         THREAD_AND_LOCATION,
4984         vmSymbols::java_lang_UnsupportedClassVersionError(),
4985         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
4986         class_name-&gt;as_C_string(), major, minor);
4987   }
4988 }
4989 
4990 void ClassFileParser::verify_legal_field_modifiers(jint flags,
4991                                                    bool is_interface,

4992                                                    TRAPS) const {
4993   if (!_need_verify) { return; }
4994 
4995   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
4996   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
4997   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
4998   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
4999   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5000   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5001   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5002   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5003   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5004 
5005   bool is_illegal = false;
5006 
5007   if (is_interface) {
5008     if (!is_public || !is_static || !is_final || is_private ||
5009         is_protected || is_volatile || is_transient ||
5010         (major_gte_1_5 &amp;&amp; is_enum)) {
5011       is_illegal = true;
5012     }
5013   } else { // not interface
5014     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5015       is_illegal = true;




5016     }
5017   }
5018 
5019   if (is_illegal) {
5020     ResourceMark rm(THREAD);
5021     Exceptions::fthrow(
5022       THREAD_AND_LOCATION,
5023       vmSymbols::java_lang_ClassFormatError(),
5024       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5025       _class_name-&gt;as_C_string(), flags);
5026     return;
5027   }
5028 }
5029 
5030 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5031                                                     bool is_interface,

5032                                                     const Symbol* name,
5033                                                     TRAPS) const {
5034   if (!_need_verify) { return; }
5035 
5036   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5037   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5038   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5039   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5040   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5041   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5042   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5043   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5044   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5045   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5046   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5047   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5048   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5049 
5050   bool is_illegal = false;
5051 


5052   if (is_interface) {
5053     if (major_gte_8) {
5054       // Class file version is JAVA_8_VERSION or later Methods of
5055       // interfaces may set any of the flags except ACC_PROTECTED,
5056       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5057       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5058       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5059           (is_native || is_protected || is_final || is_synchronized) ||
5060           // If a specific method of a class or interface has its
5061           // ACC_ABSTRACT flag set, it must not have any of its
5062           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5063           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5064           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5065           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5066           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5067         is_illegal = true;
5068       }
5069     } else if (major_gte_1_5) {
5070       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5071       if (!is_public || is_private || is_protected || is_static || is_final ||
5072           is_synchronized || is_native || !is_abstract || is_strict) {
5073         is_illegal = true;
5074       }
5075     } else {
5076       // Class file version is pre-JAVA_1_5_VERSION
5077       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5078         is_illegal = true;
5079       }
5080     }
5081   } else { // not interface
5082     if (has_illegal_visibility(flags)) {
5083       is_illegal = true;
5084     } else {
5085       if (is_initializer) {
<span class="line-modified">5086         if (is_static || is_final || is_synchronized || is_native ||</span>
5087             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5088           is_illegal = true;
5089         }









5090       } else { // not initializer
<span class="line-modified">5091         if (is_abstract) {</span>
<span class="line-modified">5092           if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-modified">5093               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-modified">5094             is_illegal = true;</span>





5095           }
5096         }
5097       }
5098     }
5099   }
5100 
5101   if (is_illegal) {
5102     ResourceMark rm(THREAD);
5103     Exceptions::fthrow(
5104       THREAD_AND_LOCATION,
5105       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5106       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5107       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);</span>
5108     return;
5109   }
5110 }
5111 
5112 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5113                                         int length,
5114                                         TRAPS) const {
5115   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5116   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5117     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5118   }
5119 }
5120 
5121 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5122 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5123 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5124 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5125 // method.  Because these names have been checked as special cases before
5126 // calling this method in verify_legal_method_name.
5127 //
</pre>
<hr />
<pre>
5245 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5246 // Return a pointer to just past the signature.
5247 // Return NULL if no legal signature is found.
5248 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5249                                                        bool void_ok,
5250                                                        unsigned int length,
5251                                                        TRAPS) const {
5252   unsigned int array_dim = 0;
5253   while (length &gt; 0) {
5254     switch (signature[0]) {
5255     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5256     case JVM_SIGNATURE_BOOLEAN:
5257     case JVM_SIGNATURE_BYTE:
5258     case JVM_SIGNATURE_CHAR:
5259     case JVM_SIGNATURE_SHORT:
5260     case JVM_SIGNATURE_INT:
5261     case JVM_SIGNATURE_FLOAT:
5262     case JVM_SIGNATURE_LONG:
5263     case JVM_SIGNATURE_DOUBLE:
5264       return signature + 1;
<span class="line-modified">5265     case JVM_SIGNATURE_CLASS: {</span>









5266       if (_major_version &lt; JAVA_1_5_VERSION) {
5267         // Skip over the class name if one is there
5268         const char* const p = skip_over_field_name(signature + 1, true, --length);
5269 
5270         // The next character better be a semicolon
5271         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5272           return p + 1;
5273         }
5274       }
5275       else {
<span class="line-modified">5276         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;</span>
5277         signature++;
5278         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5279         // Format check signature
5280         if (c != NULL) {
5281           int newlen = c - (char*) signature;
5282           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5283           if (!legal) {
5284             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5285                                   &quot;in descriptor in class file %s&quot;,
5286                                   CHECK_NULL);
5287             return NULL;
5288           }
5289           return signature + newlen + 1;
5290         }
5291       }
5292       return NULL;
5293     }
5294     case JVM_SIGNATURE_ARRAY:
5295       array_dim++;
5296       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5311 
5312 // Checks if name is a legal class name.
5313 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5314   if (!_need_verify || _relax_verify) { return; }
5315 
5316   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5317   char* bytes = (char*)name-&gt;bytes();
5318   unsigned int length = name-&gt;utf8_length();
5319   bool legal = false;
5320 
5321   if (length &gt; 0) {
5322     const char* p;
5323     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5324       p = skip_over_field_signature(bytes, false, length, CHECK);
5325       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5326     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5327       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5328         p = skip_over_field_name(bytes, true, length);
5329         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5330       }



5331     } else {
5332       // 4900761: relax the constraints based on JSR202 spec
5333       // Class names may be drawn from the entire Unicode character set.
5334       // Identifiers between &#39;/&#39; must be unqualified names.
5335       // The utf8 string has been verified when parsing cpool entries.
5336       legal = verify_unqualified_name(bytes, length, LegalClass);
5337     }
5338   }
5339   if (!legal) {
5340     ResourceMark rm(THREAD);
5341     assert(_class_name != NULL, &quot;invariant&quot;);
5342     Exceptions::fthrow(
5343       THREAD_AND_LOCATION,
5344       vmSymbols::java_lang_ClassFormatError(),
5345       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5346       _class_name-&gt;as_C_string()
5347     );
5348     return;
5349   }
5350 }
</pre>
<hr />
<pre>
5460   const char* nextp;
5461 
5462   // The first character must be a &#39;(&#39;
5463   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5464     length--;
5465     // Skip over legal field signatures
5466     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5467     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5468       args_size++;
5469       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5470         args_size++;
5471       }
5472       length -= nextp - p;
5473       p = nextp;
5474       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5475     }
5476     // The first non-signature thing better be a &#39;)&#39;
5477     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5478       length--;
5479       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">5480         // All internal methods must return void</span>
5481         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5482           return args_size;
5483         }
















5484       } else {
5485         // Now we better just have a return value
5486         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5487         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5488           return args_size;
5489         }
5490       }
5491     }
5492   }
5493   // Report error
5494   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5495   return 0;
5496 }
5497 
5498 int ClassFileParser::static_field_size() const {
5499   assert(_field_info != NULL, &quot;invariant&quot;);
5500   return _field_info-&gt;_static_field_size;
5501 }
5502 
5503 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
5621 
5622 
5623   if (ik-&gt;should_store_fingerprint()) {
5624     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5625   }
5626 
5627   ik-&gt;set_has_passed_fingerprint_check(false);
5628   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5629     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5630     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5631     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5632       // This class matches with a class saved in an AOT library
5633       ik-&gt;set_has_passed_fingerprint_check(true);
5634     } else {
5635       ResourceMark rm;
5636       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5637                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5638     }
5639   }
5640 






5641   return ik;
5642 }
5643 


































5644 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
5645                                           bool changed_by_loadhook,
5646                                           const ClassInstanceInfo&amp; cl_inst_info,
5647                                           TRAPS) {
5648   assert(ik != NULL, &quot;invariant&quot;);
5649 
5650   // Set name and CLD before adding to CLD
5651   ik-&gt;set_class_loader_data(_loader_data);
5652   ik-&gt;set_name(_class_name);
5653 
5654   // Add all classes to our internal class loader list here,
5655   // including classes in the bootstrap (NULL) class loader.
5656   const bool publicize = !is_internal();
5657 
5658   _loader_data-&gt;add_class(ik, publicize);
5659 
5660   set_klass_to_deallocate(ik);
5661 
5662   assert(_field_info != NULL, &quot;invariant&quot;);
5663   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
5664   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
5665          &quot;sanity&quot;);
5666 
5667   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5668   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
5669 
5670   // Fill in information already parsed
5671   ik-&gt;set_should_verify_class(_need_verify);
5672 
5673   // Not yet: supers are done below to support the new subtype-checking fields
5674   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
5675   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);















5676   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">5677   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);</span>
5678 
5679   // this transfers ownership of a lot of arrays from
5680   // the parser onto the InstanceKlass*
5681   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5682 
5683   // can only set dynamic nest-host after static nest information is set
5684   if (cl_inst_info.dynamic_nest_host() != NULL) {
5685     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
5686   }
5687 
5688   // note that is not safe to use the fields in the parser from this point on
5689   assert(NULL == _cp, &quot;invariant&quot;);
5690   assert(NULL == _fields, &quot;invariant&quot;);
5691   assert(NULL == _methods, &quot;invariant&quot;);
5692   assert(NULL == _inner_classes, &quot;invariant&quot;);
5693   assert(NULL == _nest_members, &quot;invariant&quot;);
5694   assert(NULL == _local_interfaces, &quot;invariant&quot;);
5695   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5696   assert(NULL == _record_components, &quot;invariant&quot;);
5697 
</pre>
<hr />
<pre>
5707   // has to be changed accordingly.
5708   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5709 
5710   ik-&gt;set_this_class_index(_this_class_index);
5711 
5712   if (_is_hidden || is_unsafe_anonymous()) {
5713     // _this_class_index is a CONSTANT_Class entry that refers to this
5714     // hidden or anonymous class itself. If this class needs to refer to its own
5715     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
5716     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
5717     // not stored in SystemDictionary), _this_class_index cannot be resolved
5718     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5719     // Therefore, we must eagerly resolve _this_class_index now.
5720     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5721   }
5722 
5723   ik-&gt;set_minor_version(_minor_version);
5724   ik-&gt;set_major_version(_major_version);
5725   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5726   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);



5727 
5728   if (_unsafe_anonymous_host != NULL) {
5729     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5730     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5731   }
5732   if (_is_hidden) {
5733     ik-&gt;set_is_hidden();
5734   }
5735 
5736   // Set PackageEntry for this_klass
5737   oop cl = ik-&gt;class_loader();
5738   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5739   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5740   ik-&gt;set_package(cld, NULL, CHECK);
5741 
5742   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5743   assert(methods != NULL, &quot;invariant&quot;);
5744   const int methods_len = methods-&gt;length();
5745 
5746   check_methods_for_intrinsics(ik, methods);
</pre>
<hr />
<pre>
5816 
5817   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5818 
5819   // Generate any default methods - default methods are public interface methods
5820   // that have a default implementation.  This is new with Java 8.
5821   if (_has_nonstatic_concrete_methods) {
5822     DefaultMethods::generate_default_methods(ik,
5823                                              _all_mirandas,
5824                                              CHECK);
5825   }
5826 
5827   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5828   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5829       !module_entry-&gt;has_default_read_edges()) {
5830     if (!module_entry-&gt;set_has_default_read_edges()) {
5831       // We won a potential race
5832       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5833     }
5834   }
5835 


































5836   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5837 
5838   if (!is_internal()) {
5839     if (log_is_enabled(Info, class, load)) {
5840       ResourceMark rm;
5841       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5842       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5843     }
5844 
5845     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5846         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5847         log_is_enabled(Info, class, preview)) {
5848       ResourceMark rm;
5849       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5850                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5851     }
5852 
5853     if (log_is_enabled(Debug, class, resolve))  {
5854       ResourceMark rm;
5855       // print out the superclass.
</pre>
<hr />
<pre>
5865         const int length = local_interfaces-&gt;length();
5866         for (int i = 0; i &lt; length; i++) {
5867           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5868           const char * to = k-&gt;external_name();
5869           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5870         }
5871       }
5872     }
5873   }
5874 
5875   JFR_ONLY(INIT_ID(ik);)
5876 
5877   // If we reach here, all is well.
5878   // Now remove the InstanceKlass* from the _klass_to_deallocate field
5879   // in order for it to not be destroyed in the ClassFileParser destructor.
5880   set_klass_to_deallocate(NULL);
5881 
5882   // it&#39;s official
5883   set_klass(ik);
5884 




5885   debug_only(ik-&gt;verify();)
5886 }
5887 
5888 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5889   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5890   _class_name-&gt;decrement_refcount();
5891 
5892   _class_name = new_class_name;
5893   // Increment the refcount of the new name.
5894   // Now the ClassFileParser owns this name and will decrement in
5895   // the destructor.
5896   _class_name-&gt;increment_refcount();
5897 }
5898 
5899 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5900 // package by prepending its host class&#39;s package name to its class name and setting
5901 // its _class_name field.
5902 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
5903   ResourceMark rm(THREAD);
5904   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
</pre>
<hr />
<pre>
5966                                  TRAPS) :
5967   _stream(stream),
5968   _class_name(NULL),
5969   _loader_data(loader_data),
5970   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
5971   _cp_patches(cl_info-&gt;cp_patches()),
5972   _is_hidden(cl_info-&gt;is_hidden()),
5973   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
5974   _num_patched_klasses(0),
5975   _max_num_patched_klasses(0),
5976   _orig_cp_size(0),
5977   _first_patched_klass_resolved_index(0),
5978   _super_klass(),
5979   _cp(NULL),
5980   _fields(NULL),
5981   _methods(NULL),
5982   _inner_classes(NULL),
5983   _nest_members(NULL),
5984   _nest_host(0),
5985   _record_components(NULL),

5986   _local_interfaces(NULL),
5987   _transitive_interfaces(NULL),
5988   _combined_annotations(NULL),
5989   _class_annotations(NULL),
5990   _class_type_annotations(NULL),
5991   _fields_annotations(NULL),
5992   _fields_type_annotations(NULL),
5993   _klass(NULL),
5994   _klass_to_deallocate(NULL),
5995   _parsed_annotations(NULL),
5996   _fac(NULL),
5997   _field_info(NULL),
5998   _method_ordering(NULL),
5999   _all_mirandas(NULL),
6000   _vtable_size(0),
6001   _itable_size(0),
6002   _num_miranda_methods(0),
6003   _rt(REF_NONE),
6004   _protection_domain(cl_info-&gt;protection_domain()),
6005   _access_flags(),
6006   _pub_level(pub_level),
6007   _bad_constant_seen(0),
6008   _synthetic_flag(false),
6009   _sde_length(false),
6010   _sde_buffer(NULL),
6011   _sourcefile_index(0),
6012   _generic_signature_index(0),
6013   _major_version(0),
6014   _minor_version(0),
6015   _this_class_index(0),
6016   _super_class_index(0),
6017   _itfs_len(0),
6018   _java_fields_count(0),
6019   _need_verify(false),
6020   _relax_verify(false),
6021   _has_nonstatic_concrete_methods(false),
6022   _declares_nonstatic_concrete_methods(false),
6023   _has_final_method(false),
6024   _has_contended_fields(false),









6025   _has_finalizer(false),
6026   _has_empty_finalizer(false),
6027   _has_vanilla_constructor(false),
6028   _max_bootstrap_specifier_index(-1) {
6029 
6030   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6031   _class_name-&gt;increment_refcount();
6032 
6033   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6034   assert(_loader_data != NULL, &quot;invariant&quot;);
6035   assert(stream != NULL, &quot;invariant&quot;);
6036   assert(_stream != NULL, &quot;invariant&quot;);
6037   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6038   assert(_class_name != NULL, &quot;invariant&quot;);
6039   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6040 
6041   // Figure out whether we can skip format checking (matching classic VM behavior)
6042   if (DumpSharedSpaces) {
6043     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6044     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6210   } else {
6211     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6212       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6213     }
6214     cp_size += _max_num_patched_klasses;
6215   }
6216 
6217   _cp = ConstantPool::allocate(_loader_data,
6218                                cp_size,
6219                                CHECK);
6220 
6221   ConstantPool* const cp = _cp;
6222 
6223   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6224 
6225   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6226 
6227   // ACCESS FLAGS
6228   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6229 
<span class="line-modified">6230   // Access flags</span>
<span class="line-removed">6231   jint flags;</span>
6232   // JVM_ACC_MODULE is defined in JDK-9 and later.
6233   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6234     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">6235   } else {</span>
<span class="line-modified">6236     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;</span>


6237   }
6238 



6239   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6240     // Set abstract bit for old class files for backward compatibility
6241     flags |= JVM_ACC_ABSTRACT;
6242   }
6243 
6244   verify_legal_class_modifiers(flags, CHECK);
6245 
6246   short bad_constant = class_bad_constant_seen();
6247   if (bad_constant != 0) {
6248     // Do not throw CFE until after the access_flags are checked because if
6249     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6250     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6251   }
6252 
6253   _access_flags.set_flags(flags);
6254 
6255   // This class and superclass
6256   _this_class_index = stream-&gt;get_u2_fast();
6257   check_property(
6258     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
6376           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6377           classlist_file-&gt;flush();
6378         }
6379       }
6380     }
6381 #endif
6382   }
6383 
6384   // SUPERKLASS
6385   _super_class_index = stream-&gt;get_u2_fast();
6386   _super_klass = parse_super_class(cp,
6387                                    _super_class_index,
6388                                    _need_verify,
6389                                    CHECK);
6390 
6391   // Interfaces
6392   _itfs_len = stream-&gt;get_u2_fast();
6393   parse_interfaces(stream,
6394                    _itfs_len,
6395                    cp,

6396                    &amp;_has_nonstatic_concrete_methods,

6397                    CHECK);
6398 
<span class="line-modified">6399   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
6400 
6401   // Fields (offsets are filled in later)
6402   _fac = new FieldAllocationCount();
6403   parse_fields(stream,
<span class="line-modified">6404                _access_flags.is_interface(),</span>

6405                _fac,
6406                cp,
6407                cp_size,
6408                &amp;_java_fields_count,
6409                CHECK);
6410 
6411   assert(_fields != NULL, &quot;invariant&quot;);
6412 
6413   // Methods
6414   AccessFlags promoted_flags;
6415   parse_methods(stream,
<span class="line-modified">6416                 _access_flags.is_interface(),</span>

6417                 &amp;promoted_flags,
6418                 &amp;_has_final_method,
6419                 &amp;_declares_nonstatic_concrete_methods,
6420                 CHECK);
6421 
6422   assert(_methods != NULL, &quot;invariant&quot;);
6423 
6424   // promote flags from parse_methods() to the klass&#39; flags
6425   _access_flags.add_promoted_flags(promoted_flags.as_int());
6426 
6427   if (_declares_nonstatic_concrete_methods) {
6428     _has_nonstatic_concrete_methods = true;
6429   }
6430 
6431   // Additional attributes/annotations
6432   _parsed_annotations = new ClassAnnotationCollector();
6433   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6434 
6435   assert(_inner_classes != NULL, &quot;invariant&quot;);
6436 
</pre>
<hr />
<pre>
6467 
6468   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
6469   // We have to update the resolved_klass_index and the name_index together
6470   // so extract the existing resolved_klass_index first.
6471   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
6472   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
6473   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
6474   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
6475          &quot;Bad name_index&quot;);
6476 }
6477 
6478 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6479                                                  ConstantPool* cp,
6480                                                  TRAPS) {
6481   assert(stream != NULL, &quot;invariant&quot;);
6482   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6483   assert(cp != NULL, &quot;invariant&quot;);
6484   assert(_loader_data != NULL, &quot;invariant&quot;);
6485 
6486   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">6487     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),</span>
<span class="line-modified">6488                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6489                    CHECK);</span>
6490   }
6491   // We check super class after class file is parsed and format is checked
6492   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6493     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">6494     if (_access_flags.is_interface()) {</span>
6495       // Before attempting to resolve the superclass, check for class format
6496       // errors not checked yet.
6497       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6498         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6499         CHECK);
6500     }
6501     Handle loader(THREAD, _loader_data-&gt;class_loader());
6502     _super_klass = (const InstanceKlass*)
6503                        SystemDictionary::resolve_super_or_fail(_class_name,
6504                                                                super_class_name,
6505                                                                loader,
6506                                                                _protection_domain,
6507                                                                true,
6508                                                                CHECK);
6509   }
6510 
6511   if (_super_klass != NULL) {
6512     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6513       _has_nonstatic_concrete_methods = true;
6514     }



6515 
6516     if (_super_klass-&gt;is_interface()) {
6517       ResourceMark rm(THREAD);
6518       Exceptions::fthrow(
6519         THREAD_AND_LOCATION,
6520         vmSymbols::java_lang_IncompatibleClassChangeError(),
6521         &quot;class %s has interface %s as super class&quot;,
6522         _class_name-&gt;as_klass_external_name(),
6523         _super_klass-&gt;external_name()
6524       );
6525       return;
6526     }

6527     // Make sure super class is not final
6528     if (_super_klass-&gt;is_final()) {
6529       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
6530     }






















































6531   }


6532 
6533   // Compute the transitive list of all unique interfaces implemented by this class
6534   _transitive_interfaces =
6535     compute_transitive_interfaces(_super_klass,
6536                                   _local_interfaces,
6537                                   _loader_data,
6538                                   CHECK);
6539 
6540   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6541 
6542   // sort methods
6543   _method_ordering = sort_methods(_methods);
6544 
6545   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6546 
6547   Handle loader(THREAD, _loader_data-&gt;class_loader());
6548   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6549                                                     &amp;_num_miranda_methods,
6550                                                     _all_mirandas,
6551                                                     _super_klass,
6552                                                     _methods,
6553                                                     _access_flags,
6554                                                     _major_version,
6555                                                     loader,
6556                                                     _class_name,
6557                                                     _local_interfaces,
6558                                                     CHECK);
6559 
6560   // Size of Java itable (in words)
<span class="line-modified">6561   _itable_size = _access_flags.is_interface() ? 0 :</span>
6562     klassItable::compute_itable_size(_transitive_interfaces);
6563 
6564   assert(_fac != NULL, &quot;invariant&quot;);
6565   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6566 













6567   _field_info = new FieldLayoutInfo();
6568   if (UseNewFieldLayout) {
6569     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">6570                           _parsed_annotations-&gt;is_contended(), _field_info);</span>
<span class="line-modified">6571     lb.build_layout();</span>






6572   } else {
6573     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
6574   }
6575 
<span class="line-modified">6576   // Compute reference typ</span>
6577   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
<span class="line-removed">6578 </span>
6579 }
6580 
6581 void ClassFileParser::set_klass(InstanceKlass* klass) {
6582 
6583 #ifdef ASSERT
6584   if (klass != NULL) {
6585     assert(NULL == _klass, &quot;leaking?&quot;);
6586   }
6587 #endif
6588 
6589   _klass = klass;
6590 }
6591 
6592 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6593 
6594 #ifdef ASSERT
6595   if (klass != NULL) {
6596     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6597   }
6598 #endif
6599 
6600   _klass_to_deallocate = klass;
6601 }
6602 
6603 // Caller responsible for ResourceMark
6604 // clone stream with rewound position
6605 const ClassFileStream* ClassFileParser::clone_stream() const {
6606   assert(_stream != NULL, &quot;invariant&quot;);
6607 
6608   return _stream-&gt;clone();
6609 }

6610 // ----------------------------------------------------------------------------
6611 // debugging
6612 
6613 #ifdef ASSERT
6614 
6615 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6616 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6617   if (class_name != NULL) {
6618     ResourceMark rm;
6619     char* name = class_name-&gt;as_C_string();
6620     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6621   } else {
6622     return true;
6623   }
6624 }
6625 
6626 #endif
</pre>
</td>
<td>
<hr />
<pre>
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
<span class="line-added">  24 </span>
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/defaultMethods.hpp&quot;
  33 #include &quot;classfile/dictionary.hpp&quot;
  34 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/moduleEntry.hpp&quot;
  37 #include &quot;classfile/packageEntry.hpp&quot;
  38 #include &quot;classfile/symbolTable.hpp&quot;
  39 #include &quot;classfile/systemDictionary.hpp&quot;
  40 #include &quot;classfile/verificationType.hpp&quot;
  41 #include &quot;classfile/verifier.hpp&quot;
  42 #include &quot;classfile/vmSymbols.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
  44 #include &quot;logging/logStream.hpp&quot;
  45 #include &quot;memory/allocation.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/annotations.hpp&quot;
  51 #include &quot;oops/constantPool.inline.hpp&quot;
  52 #include &quot;oops/fieldStreams.inline.hpp&quot;
  53 #include &quot;oops/instanceKlass.hpp&quot;
  54 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  55 #include &quot;oops/klass.inline.hpp&quot;
  56 #include &quot;oops/klassVtable.hpp&quot;
  57 #include &quot;oops/metadata.hpp&quot;
  58 #include &quot;oops/method.inline.hpp&quot;
  59 #include &quot;oops/oop.inline.hpp&quot;
  60 #include &quot;oops/recordComponent.hpp&quot;
  61 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  62 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  63 #include &quot;prims/jvmtiExport.hpp&quot;
  64 #include &quot;prims/jvmtiThreadState.hpp&quot;
  65 #include &quot;runtime/arguments.hpp&quot;
  66 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/os.hpp&quot;
  70 #include &quot;runtime/perfData.hpp&quot;
  71 #include &quot;runtime/reflection.hpp&quot;
  72 #include &quot;runtime/safepointVerifiers.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/timer.hpp&quot;
  75 #include &quot;services/classLoadingService.hpp&quot;
  76 #include &quot;services/threadService.hpp&quot;
  77 #include &quot;utilities/align.hpp&quot;
  78 #include &quot;utilities/bitMap.inline.hpp&quot;
  79 #include &quot;utilities/copy.hpp&quot;
  80 #include &quot;utilities/exceptions.hpp&quot;
  81 #include &quot;utilities/globalDefinitions.hpp&quot;
  82 #include &quot;utilities/growableArray.hpp&quot;
  83 #include &quot;utilities/macros.hpp&quot;
  84 #include &quot;utilities/ostream.hpp&quot;
  85 #include &quot;utilities/resourceHash.hpp&quot;
<span class="line-added">  86 #include &quot;utilities/stringUtils.hpp&quot;</span>
  87 #include &quot;utilities/utf8.hpp&quot;
  88 
  89 #if INCLUDE_CDS
  90 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  91 #endif
  92 #if INCLUDE_JFR
  93 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  94 #endif
  95 
  96 // We generally try to create the oops directly when parsing, rather than
  97 // allocating temporary data structures and copying the bytes twice. A
  98 // temporary area is only needed when parsing utf8 entries in the constant
  99 // pool and when parsing line number tables.
 100 
 101 // We add assert in debug mode when class format is not checked.
 102 
 103 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 104 #define JAVA_MIN_SUPPORTED_VERSION        45
 105 #define JAVA_PREVIEW_MINOR_VERSION        65535
 106 
</pre>
<hr />
<pre>
 118 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 119 #define JAVA_7_VERSION                    51
 120 
 121 // Extension method support.
 122 #define JAVA_8_VERSION                    52
 123 
 124 #define JAVA_9_VERSION                    53
 125 
 126 #define JAVA_10_VERSION                   54
 127 
 128 #define JAVA_11_VERSION                   55
 129 
 130 #define JAVA_12_VERSION                   56
 131 
 132 #define JAVA_13_VERSION                   57
 133 
 134 #define JAVA_14_VERSION                   58
 135 
 136 #define JAVA_15_VERSION                   59
 137 
<span class="line-added"> 138 #define CONSTANT_CLASS_DESCRIPTORS        59</span>
<span class="line-added"> 139 </span>
 140 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 141   assert((bad_constant == JVM_CONSTANT_Module ||
 142           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 143          &quot;Unexpected bad constant pool entry&quot;);
 144   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 145 }
 146 
 147 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 148                                                   ConstantPool* cp,
 149                                                   const int length,
 150                                                   TRAPS) {
 151   assert(stream != NULL, &quot;invariant&quot;);
 152   assert(cp != NULL, &quot;invariant&quot;);
 153 
 154   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 155   // this function (_current can be allocated in a register, with scalar
 156   // replacement of aggregates). The _current pointer is copied back to
 157   // stream() when this function returns. DON&#39;T call another method within
 158   // this method that uses stream().
 159   const ClassFileStream cfs1 = *stream;
 160   const ClassFileStream* const cfs = &amp;cfs1;
 161 
 162   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 163   debug_only(const u1* const old_current = stream-&gt;current();)
 164 
 165   // Used for batching symbol allocations.
 166   const char* names[SymbolTable::symbol_alloc_batch_size];
 167   int lengths[SymbolTable::symbol_alloc_batch_size];
 168   int indices[SymbolTable::symbol_alloc_batch_size];
 169   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 170   int names_count = 0;
 171 
 172   // parsing  Index 0 is unused
 173   for (int index = 1; index &lt; length; index++) {
 174     // Each of the following case guarantees one more byte in the stream
 175     // for the following tag or the access_flags following constant pool,
 176     // so we don&#39;t need bounds-check for reading tag.
 177     const u1 tag = cfs-&gt;get_u1_fast();
 178     switch (tag) {
<span class="line-modified"> 179       case JVM_CONSTANT_Class: {</span>
 180         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 181         const u2 name_index = cfs-&gt;get_u2_fast();
 182         cp-&gt;klass_index_at_put(index, name_index);
 183         break;
 184       }
 185       case JVM_CONSTANT_Fieldref: {
 186         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 187         const u2 class_index = cfs-&gt;get_u2_fast();
 188         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 189         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 190         break;
 191       }
 192       case JVM_CONSTANT_Methodref: {
 193         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 194         const u2 class_index = cfs-&gt;get_u2_fast();
 195         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 196         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 197         break;
 198       }
 199       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
<hr />
<pre>
 489         check_property(valid_symbol_at(name_ref_index),
 490           &quot;Invalid constant pool index %u in class file %s&quot;,
 491           name_ref_index, CHECK);
 492         check_property(valid_symbol_at(signature_ref_index),
 493           &quot;Invalid constant pool index %u in class file %s&quot;,
 494           signature_ref_index, CHECK);
 495         break;
 496       }
 497       case JVM_CONSTANT_Utf8:
 498         break;
 499       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 500       case JVM_CONSTANT_UnresolvedClassInError: {
 501         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 502         break;
 503       }
 504       case JVM_CONSTANT_ClassIndex: {
 505         const int class_index = cp-&gt;klass_index_at(index);
 506         check_property(valid_symbol_at(class_index),
 507           &quot;Invalid constant pool index %u in class file %s&quot;,
 508           class_index, CHECK);
<span class="line-modified"> 509 </span>
<span class="line-added"> 510         Symbol* const name = cp-&gt;symbol_at(class_index);</span>
<span class="line-added"> 511         const unsigned int name_len = name-&gt;utf8_length();</span>
<span class="line-added"> 512         if (name-&gt;is_Q_signature()) {</span>
<span class="line-added"> 513           cp-&gt;unresolved_qdescriptor_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 514         } else {</span>
<span class="line-added"> 515           cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>
<span class="line-added"> 516         }</span>
 517         break;
 518       }
 519       case JVM_CONSTANT_StringIndex: {
 520         const int string_index = cp-&gt;string_index_at(index);
 521         check_property(valid_symbol_at(string_index),
 522           &quot;Invalid constant pool index %u in class file %s&quot;,
 523           string_index, CHECK);
 524         Symbol* const sym = cp-&gt;symbol_at(string_index);
 525         cp-&gt;unresolved_string_at_put(index, sym);
 526         break;
 527       }
 528       case JVM_CONSTANT_MethodHandle: {
 529         const int ref_index = cp-&gt;method_handle_index_at(index);
 530         check_property(valid_cp_range(ref_index, length),
 531           &quot;Invalid constant pool index %u in class file %s&quot;,
 532           ref_index, CHECK);
 533         const constantTag tag = cp-&gt;tag_at(ref_index);
 534         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 535 
 536         switch (ref_kind) {
</pre>
<hr />
<pre>
 750             classfile_parse_error(
 751               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 752               name_ref_index, CHECK);
 753           }
 754         }
 755         break;
 756       }
 757       case JVM_CONSTANT_MethodHandle: {
 758         const int ref_index = cp-&gt;method_handle_index_at(index);
 759         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 760         switch (ref_kind) {
 761           case JVM_REF_invokeVirtual:
 762           case JVM_REF_invokeStatic:
 763           case JVM_REF_invokeSpecial:
 764           case JVM_REF_newInvokeSpecial: {
 765             const int name_and_type_ref_index =
 766               cp-&gt;name_and_type_ref_index_at(ref_index);
 767             const int name_ref_index =
 768               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 769             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<span class="line-modified"> 770             if (name != vmSymbols::object_initializer_name()) {</span>
<span class="line-modified"> 771               if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
 772                 classfile_parse_error(
 773                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 774                     name_ref_index, CHECK);
 775               }
 776             } else {
<span class="line-modified"> 777               // The allowed invocation mode of &lt;init&gt; depends on its signature.</span>
<span class="line-added"> 778               // This test corresponds to verify_invoke_instructions in the verifier.</span>
<span class="line-added"> 779               const int signature_ref_index =</span>
<span class="line-added"> 780                 cp-&gt;signature_ref_index_at(name_and_type_ref_index);</span>
<span class="line-added"> 781               const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);</span>
<span class="line-added"> 782               if (signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 783                   &amp;&amp; ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-added"> 784                 // OK, could be a constructor call</span>
<span class="line-added"> 785               } else if (!signature-&gt;is_void_method_signature()</span>
<span class="line-added"> 786                          &amp;&amp; ref_kind == JVM_REF_invokeStatic) {</span>
<span class="line-added"> 787                 // also OK, could be a static factory call</span>
<span class="line-added"> 788               } else {</span>
 789                 classfile_parse_error(
 790                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 791                   name_ref_index, CHECK);
 792               }
 793             }
 794             break;
 795           }
 796           // Other ref_kinds are already fully checked in previous pass.
 797         } // switch(ref_kind)
 798         break;
 799       }
 800       case JVM_CONSTANT_MethodType: {
 801         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 802         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 803         verify_legal_method_signature(no_name, signature, CHECK);
 804         break;
 805       }
 806       case JVM_CONSTANT_Utf8: {
 807         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 808       }
</pre>
<hr />
<pre>
 927   while (entry != NULL) {
 928     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 929       return false;
 930     }
 931     entry = entry-&gt;_next;
 932   }
 933 
 934   // No duplicate is found, allocate a new entry and fill it.
 935   entry = new NameSigHash();
 936   entry-&gt;_name = name;
 937   entry-&gt;_sig = sig;
 938 
 939   // Insert into hash table
 940   entry-&gt;_next = table[index];
 941   table[index] = entry;
 942 
 943   return true;
 944 }
 945 
 946 // Side-effects: populates the _local_interfaces field
<span class="line-modified"> 947 void ClassFileParser::parse_interfaces(const ClassFileStream* stream,</span>
<span class="line-modified"> 948                                        int itfs_len,</span>
<span class="line-modified"> 949                                        ConstantPool* cp,</span>
<span class="line-added"> 950                                        bool is_inline_type,</span>
 951                                        bool* const has_nonstatic_concrete_methods,
<span class="line-added"> 952                                        // FIXME: lots of these functions</span>
<span class="line-added"> 953                                        // declare their parameters as const,</span>
<span class="line-added"> 954                                        // which adds only noise to the code.</span>
<span class="line-added"> 955                                        // Remove the spurious const modifiers.</span>
<span class="line-added"> 956                                        // Many are of the form &quot;const int x&quot;</span>
<span class="line-added"> 957                                        // or &quot;T* const x&quot;.</span>
<span class="line-added"> 958                                        bool* const is_declared_atomic,</span>
 959                                        TRAPS) {
 960   assert(stream != NULL, &quot;invariant&quot;);
 961   assert(cp != NULL, &quot;invariant&quot;);
 962   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 963 
 964   if (itfs_len == 0) {
<span class="line-modified"> 965     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(0);</span>
 966   } else {
 967     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<span class="line-modified"> 968     _temp_local_interfaces = new GrowableArray&lt;InstanceKlass*&gt;(itfs_len);</span>
<span class="line-modified"> 969     int index = 0;</span>

 970     for (index = 0; index &lt; itfs_len; index++) {
 971       const u2 interface_index = stream-&gt;get_u2(CHECK);
 972       Klass* interf;
 973       check_property(
 974         valid_klass_reference_at(interface_index),
 975         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 976         interface_index, CHECK);
 977       if (cp-&gt;tag_at(interface_index).is_klass()) {
 978         interf = cp-&gt;resolved_klass_at(interface_index);
 979       } else {
 980         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 981 
 982         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 983         // But need to make sure it&#39;s not an array type.
 984         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 985                            &quot;Bad interface name in class file %s&quot;, CHECK);
 986 
<span class="line-modified"> 987         // Call resolve_super so class circularity is checked</span>
 988         interf = SystemDictionary::resolve_super_or_fail(
 989                                                   _class_name,
 990                                                   unresolved_klass,
 991                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 992                                                   _protection_domain,
 993                                                   false,
 994                                                   CHECK);
 995       }
 996 
 997       if (!interf-&gt;is_interface()) {
 998         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 999                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
1000                           _class_name-&gt;as_klass_external_name(),
1001                           interf-&gt;external_name(),
1002                           interf-&gt;class_in_module_of_loader()));
1003       }
1004 
<span class="line-modified">1005       InstanceKlass* ik = InstanceKlass::cast(interf);</span>
<span class="line-added">1006       if (is_inline_type &amp;&amp; ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">1007         ResourceMark rm(THREAD);</span>
<span class="line-added">1008         Exceptions::fthrow(</span>
<span class="line-added">1009           THREAD_AND_LOCATION,</span>
<span class="line-added">1010           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">1011           &quot;Inline type %s attempts to implement interface java.lang.IdentityObject&quot;,</span>
<span class="line-added">1012           _class_name-&gt;as_klass_external_name());</span>
<span class="line-added">1013         return;</span>
<span class="line-added">1014       }</span>
<span class="line-added">1015       if (ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">1016         set_invalid_inline_super();</span>
<span class="line-added">1017       }</span>
<span class="line-added">1018       if (ik-&gt;has_nonstatic_concrete_methods()) {</span>
1019         *has_nonstatic_concrete_methods = true;
1020       }
<span class="line-modified">1021       if (ik-&gt;is_declared_atomic()) {</span>
<span class="line-added">1022         *is_declared_atomic = true;</span>
<span class="line-added">1023       }</span>
<span class="line-added">1024       if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">1025         _implements_identityObject = true;</span>
<span class="line-added">1026       }</span>
<span class="line-added">1027       _temp_local_interfaces-&gt;append(ik);</span>
1028     }
1029 
1030     if (!_need_verify || itfs_len &lt;= 1) {
1031       return;
1032     }
1033 
1034     // Check if there&#39;s any duplicates in interfaces
1035     ResourceMark rm(THREAD);
1036     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1037                                                                  NameSigHash*,
1038                                                                  HASH_ROW_SIZE);
1039     initialize_hashtable(interface_names);
1040     bool dup = false;
1041     const Symbol* name = NULL;
1042     {
1043       debug_only(NoSafepointVerifier nsv;)
1044       for (index = 0; index &lt; itfs_len; index++) {
<span class="line-modified">1045         const InstanceKlass* const k = _temp_local_interfaces-&gt;at(index);</span>
1046         name = k-&gt;name();
1047         // If no duplicates, add (name, NULL) in hashtable interface_names.
1048         if (!put_after_lookup(name, NULL, interface_names)) {
1049           dup = true;
1050           break;
1051         }
1052       }
1053     }
1054     if (dup) {
1055       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1056                              name-&gt;as_C_string(), CHECK);
1057     }
1058   }
1059 }
1060 
1061 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1062                                            int constantvalue_index,
1063                                            int signature_index,
1064                                            TRAPS) const {
1065   // Make sure the constant pool entry is of a type appropriate to this field
</pre>
<hr />
<pre>
1501                                             CHECK);
1502   parsed_annotations-&gt;set_field_annotations(a);
1503   a = assemble_annotations(runtime_visible_type_annotations,
1504                            runtime_visible_type_annotations_length,
1505                            runtime_invisible_type_annotations,
1506                            runtime_invisible_type_annotations_length,
1507                            CHECK);
1508   parsed_annotations-&gt;set_field_type_annotations(a);
1509   return;
1510 }
1511 
1512 
1513 // Field allocation types. Used for computing field offsets.
1514 
1515 enum FieldAllocationType {
1516   STATIC_OOP,           // Oops
1517   STATIC_BYTE,          // Boolean, Byte, char
1518   STATIC_SHORT,         // shorts
1519   STATIC_WORD,          // ints
1520   STATIC_DOUBLE,        // aligned long or double
<span class="line-added">1521   STATIC_FLATTENABLE,   // flattenable field</span>
1522   NONSTATIC_OOP,
1523   NONSTATIC_BYTE,
1524   NONSTATIC_SHORT,
1525   NONSTATIC_WORD,
1526   NONSTATIC_DOUBLE,
<span class="line-added">1527   NONSTATIC_FLATTENABLE,</span>
1528   MAX_FIELD_ALLOCATION_TYPE,
1529   BAD_ALLOCATION_TYPE = -1
1530 };
1531 
1532 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1533   BAD_ALLOCATION_TYPE, // 0
1534   BAD_ALLOCATION_TYPE, // 1
1535   BAD_ALLOCATION_TYPE, // 2
1536   BAD_ALLOCATION_TYPE, // 3
1537   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1538   NONSTATIC_SHORT,     // T_CHAR        =  5,
1539   NONSTATIC_WORD,      // T_FLOAT       =  6,
1540   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1541   NONSTATIC_BYTE,      // T_BYTE        =  8,
1542   NONSTATIC_SHORT,     // T_SHORT       =  9,
1543   NONSTATIC_WORD,      // T_INT         = 10,
1544   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1545   NONSTATIC_OOP,       // T_OBJECT      = 12,
1546   NONSTATIC_OOP,       // T_ARRAY       = 13,
<span class="line-modified">1547   NONSTATIC_OOP,       // T_VALUETYPE   = 14,</span>
<span class="line-modified">1548   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1549   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1550   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1551   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1552   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1553   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20,</span>
1554   BAD_ALLOCATION_TYPE, // 0
1555   BAD_ALLOCATION_TYPE, // 1
1556   BAD_ALLOCATION_TYPE, // 2
1557   BAD_ALLOCATION_TYPE, // 3
1558   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1559   STATIC_SHORT,        // T_CHAR        =  5,
1560   STATIC_WORD,         // T_FLOAT       =  6,
1561   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1562   STATIC_BYTE,         // T_BYTE        =  8,
1563   STATIC_SHORT,        // T_SHORT       =  9,
1564   STATIC_WORD,         // T_INT         = 10,
1565   STATIC_DOUBLE,       // T_LONG        = 11,
1566   STATIC_OOP,          // T_OBJECT      = 12,
1567   STATIC_OOP,          // T_ARRAY       = 13,
<span class="line-modified">1568   STATIC_OOP,          // T_VALUETYPE   = 14,</span>
<span class="line-modified">1569   BAD_ALLOCATION_TYPE, // T_VOID        = 15,</span>
<span class="line-modified">1570   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 16,</span>
<span class="line-modified">1571   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 17,</span>
<span class="line-modified">1572   BAD_ALLOCATION_TYPE, // T_METADATA    = 18,</span>
<span class="line-modified">1573   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 19,</span>
<span class="line-added">1574   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 20</span>
1575 };
1576 
<span class="line-modified">1577 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type, bool is_flattenable) {</span>
1578   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1579   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1580   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<span class="line-added">1581   if (is_flattenable) {</span>
<span class="line-added">1582     result = is_static ? STATIC_FLATTENABLE : NONSTATIC_FLATTENABLE;</span>
<span class="line-added">1583   }</span>
1584   return result;
1585 }
1586 
1587 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1588  public:
1589   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1590 
1591   FieldAllocationCount() {
1592     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1593       count[i] = 0;
1594     }
1595   }
1596 
<span class="line-modified">1597   FieldAllocationType update(bool is_static, BasicType type, bool is_flattenable) {</span>
<span class="line-modified">1598     FieldAllocationType atype = basic_type_to_atype(is_static, type, is_flattenable);</span>
1599     if (atype != BAD_ALLOCATION_TYPE) {
1600       // Make sure there is no overflow with injected fields.
1601       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1602       count[atype]++;
1603     }
1604     return atype;
1605   }
1606 };
1607 
1608 // Side-effects: populates the _fields, _fields_annotations,
1609 // _fields_type_annotations fields
1610 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1611                                    bool is_interface,
<span class="line-added">1612                                    bool is_inline_type,</span>
1613                                    FieldAllocationCount* const fac,
1614                                    ConstantPool* cp,
1615                                    const int cp_size,
1616                                    u2* const java_fields_count_ptr,
1617                                    TRAPS) {
1618 
1619   assert(cfs != NULL, &quot;invariant&quot;);
1620   assert(fac != NULL, &quot;invariant&quot;);
1621   assert(cp != NULL, &quot;invariant&quot;);
1622   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1623 
1624   assert(NULL == _fields, &quot;invariant&quot;);
1625   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1626   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1627 
1628   cfs-&gt;guarantee_more(2, CHECK);  // length
1629   const u2 length = cfs-&gt;get_u2_fast();
1630   *java_fields_count_ptr = length;
1631 
1632   int num_injected = 0;
1633   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1634                                                                   &amp;num_injected);
<span class="line-modified">1635 </span>
<span class="line-added">1636   // two more slots are required for inline classes:</span>
<span class="line-added">1637   // one for the static field with a reference to the pre-allocated default value</span>
<span class="line-added">1638   // one for the field the JVM injects when detecting an empty inline class</span>
<span class="line-added">1639   const int total_fields = length + num_injected + (is_inline_type ? 2 : 0);</span>
1640 
1641   // The field array starts with tuples of shorts
1642   // [access, name index, sig index, initial value index, byte offset].
1643   // A generic signature slot only exists for field with generic
1644   // signature attribute. And the access flag is set with
1645   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1646   // signature slots are at the end of the field array and after all
1647   // other fields data.
1648   //
1649   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1650   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1651   //       ...
1652   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1653   //       [generic signature index]
1654   //       [generic signature index]
1655   //       ...
1656   //
1657   // Allocate a temporary resource array for field data. For each field,
1658   // a slot is reserved in the temporary array for the generic signature
1659   // index. After parsing all fields, the data are copied to a permanent
1660   // array and any unused slots will be discarded.
1661   ResourceMark rm(THREAD);
1662   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1663                                               u2,
1664                                               total_fields * (FieldInfo::field_slots + 1));
1665 
1666   // The generic signature slots start after all other fields&#39; data.
1667   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1668   int num_generic_signature = 0;
<span class="line-added">1669   int instance_fields_count = 0;</span>
1670   for (int n = 0; n &lt; length; n++) {
1671     // access_flags, name_index, descriptor_index, attributes_count
1672     cfs-&gt;guarantee_more(8, CHECK);
1673 
<span class="line-added">1674     jint recognized_modifiers = JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-added">1675 </span>
<span class="line-added">1676     const jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">1677     verify_legal_field_modifiers(flags, is_interface, is_inline_type, CHECK);</span>
1678     AccessFlags access_flags;


1679     access_flags.set_flags(flags);
1680 
1681     const u2 name_index = cfs-&gt;get_u2_fast();
1682     check_property(valid_symbol_at(name_index),
1683       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1684       name_index, CHECK);
1685     const Symbol* const name = cp-&gt;symbol_at(name_index);
1686     verify_legal_field_name(name, CHECK);
1687 
1688     const u2 signature_index = cfs-&gt;get_u2_fast();
1689     check_property(valid_symbol_at(signature_index),
1690       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1691       signature_index, CHECK);
1692     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1693     verify_legal_field_signature(name, sig, CHECK);
<span class="line-added">1694     assert(!access_flags.is_flattenable(), &quot;ACC_FLATTENABLE should have been filtered out&quot;);</span>
<span class="line-added">1695     if (sig-&gt;is_Q_signature()) {</span>
<span class="line-added">1696       // assert(_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS, &quot;Q-descriptors are only supported in recent classfiles&quot;);</span>
<span class="line-added">1697       access_flags.set_is_flattenable();</span>
<span class="line-added">1698     }</span>
<span class="line-added">1699     if (access_flags.is_flattenable()) {</span>
<span class="line-added">1700       // Array flattenability cannot be specified.  Arrays of value classes are</span>
<span class="line-added">1701       // are always flattenable.  Arrays of other classes are not flattenable.</span>
<span class="line-added">1702       if (sig-&gt;utf8_length() &gt; 1 &amp;&amp; sig-&gt;char_at(0) == &#39;[&#39;) {</span>
<span class="line-added">1703         classfile_parse_error(</span>
<span class="line-added">1704             &quot;Field \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s is invalid.&quot;</span>
<span class="line-added">1705             &quot; ACC_FLATTENABLE cannot be specified for an array&quot;,</span>
<span class="line-added">1706             name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);</span>
<span class="line-added">1707       }</span>
<span class="line-added">1708       _has_flattenable_fields = true;</span>
<span class="line-added">1709     }</span>
<span class="line-added">1710     if (!access_flags.is_static()) instance_fields_count++;</span>
1711 
1712     u2 constantvalue_index = 0;
1713     bool is_synthetic = false;
1714     u2 generic_signature_index = 0;
1715     const bool is_static = access_flags.is_static();
1716     FieldAnnotationCollector parsed_annotations(_loader_data);
1717 
1718     const u2 attributes_count = cfs-&gt;get_u2_fast();
1719     if (attributes_count &gt; 0) {
1720       parse_field_attributes(cfs,
1721                              attributes_count,
1722                              is_static,
1723                              signature_index,
1724                              &amp;constantvalue_index,
1725                              &amp;is_synthetic,
1726                              &amp;generic_signature_index,
1727                              &amp;parsed_annotations,
1728                              CHECK);
1729 
1730       if (parsed_annotations.field_annotations() != NULL) {
</pre>
<hr />
<pre>
1750 
1751       if (is_synthetic) {
1752         access_flags.set_is_synthetic();
1753       }
1754       if (generic_signature_index != 0) {
1755         access_flags.set_field_has_generic_signature();
1756         fa[generic_signature_slot] = generic_signature_index;
1757         generic_signature_slot ++;
1758         num_generic_signature ++;
1759       }
1760     }
1761 
1762     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1763     field-&gt;initialize(access_flags.as_short(),
1764                       name_index,
1765                       signature_index,
1766                       constantvalue_index);
1767     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1768 
1769     // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1770     const FieldAllocationType atype = fac-&gt;update(is_static, type, access_flags.is_flattenable());</span>
1771     field-&gt;set_allocation_type(atype);
1772 
1773     // After field is initialized with type, we can augment it with aux info
1774     if (parsed_annotations.has_any_annotations()) {
1775       parsed_annotations.apply_to(field);
1776       if (field-&gt;is_contended()) {
1777         _has_contended_fields = true;
1778       }
1779     }
1780   }
1781 
1782   int index = length;
1783   if (num_injected != 0) {
1784     for (int n = 0; n &lt; num_injected; n++) {
1785       // Check for duplicates
1786       if (injected[n].may_be_java) {
1787         const Symbol* const name      = injected[n].name();
1788         const Symbol* const signature = injected[n].signature();
1789         bool duplicate = false;
1790         for (int i = 0; i &lt; length; i++) {
</pre>
<hr />
<pre>
1795             duplicate = true;
1796             break;
1797           }
1798         }
1799         if (duplicate) {
1800           // These will be removed from the field array at the end
1801           continue;
1802         }
1803       }
1804 
1805       // Injected field
1806       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1807       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1808                         injected[n].name_index,
1809                         injected[n].signature_index,
1810                         0);
1811 
1812       const BasicType type = Signature::basic_type(injected[n].signature());
1813 
1814       // Remember how many oops we encountered and compute allocation type
<span class="line-modified">1815       const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
1816       field-&gt;set_allocation_type(atype);
1817       index++;
1818     }
1819   }
1820 
<span class="line-added">1821   if (is_inline_type) {</span>
<span class="line-added">1822     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1823     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL | JVM_ACC_STATIC,</span>
<span class="line-added">1824                       vmSymbols::default_value_name_enum,</span>
<span class="line-added">1825                       vmSymbols::object_signature_enum,</span>
<span class="line-added">1826                       0);</span>
<span class="line-added">1827     const BasicType type = Signature::basic_type(vmSymbols::object_signature());</span>
<span class="line-added">1828     const FieldAllocationType atype = fac-&gt;update(true, type, false);</span>
<span class="line-added">1829     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1830     index++;</span>
<span class="line-added">1831   }</span>
<span class="line-added">1832 </span>
<span class="line-added">1833   if (is_inline_type &amp;&amp; instance_fields_count == 0) {</span>
<span class="line-added">1834     _is_empty_inline_type = true;</span>
<span class="line-added">1835     FieldInfo* const field = FieldInfo::from_field_array(fa, index);</span>
<span class="line-added">1836     field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,</span>
<span class="line-added">1837         vmSymbols::empty_marker_name_enum,</span>
<span class="line-added">1838         vmSymbols::byte_signature_enum,</span>
<span class="line-added">1839         0);</span>
<span class="line-added">1840     const BasicType type = Signature::basic_type(vmSymbols::byte_signature());</span>
<span class="line-added">1841     const FieldAllocationType atype = fac-&gt;update(false, type, false);</span>
<span class="line-added">1842     field-&gt;set_allocation_type(atype);</span>
<span class="line-added">1843     index++;</span>
<span class="line-added">1844   }</span>
<span class="line-added">1845 </span>
<span class="line-added">1846   if (instance_fields_count &gt; 0) {</span>
<span class="line-added">1847     _has_nonstatic_fields = true;</span>
<span class="line-added">1848   }</span>
<span class="line-added">1849 </span>
1850   assert(NULL == _fields, &quot;invariant&quot;);
1851 
1852   _fields =
1853     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1854                                    index * FieldInfo::field_slots + num_generic_signature,
1855                                    CHECK);
1856   // Sometimes injected fields already exist in the Java source so
1857   // the fields array could be too long.  In that case the
1858   // fields array is trimed. Also unused slots that were reserved
1859   // for generic signature indexes are discarded.
1860   {
1861     int i = 0;
1862     for (; i &lt; index * FieldInfo::field_slots; i++) {
1863       _fields-&gt;at_put(i, fa[i]);
1864     }
1865     for (int j = total_fields * FieldInfo::field_slots;
1866          j &lt; generic_signature_slot; j++) {
1867       _fields-&gt;at_put(i++, fa[j]);
1868     }
1869     assert(_fields-&gt;length() == i, &quot;&quot;);
</pre>
<hr />
<pre>
2145         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2146         checked_exception, CHECK_NULL);
2147     }
2148   }
2149   // check exceptions attribute length
2150   if (_need_verify) {
2151     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2152                                                    sizeof(u2) * size),
2153                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2154   }
2155   return checked_exceptions_start;
2156 }
2157 
2158 void ClassFileParser::throwIllegalSignature(const char* type,
2159                                             const Symbol* name,
2160                                             const Symbol* sig,
2161                                             TRAPS) const {
2162   assert(name != NULL, &quot;invariant&quot;);
2163   assert(sig != NULL, &quot;invariant&quot;);
2164 
<span class="line-added">2165   const char* class_note = &quot;&quot;;</span>
<span class="line-added">2166   if (is_inline_type() &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">2167     class_note = &quot; (an inline class)&quot;;</span>
<span class="line-added">2168   }</span>
<span class="line-added">2169 </span>
2170   ResourceMark rm(THREAD);
2171   Exceptions::fthrow(THREAD_AND_LOCATION,
2172       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">2173       &quot;%s \&quot;%s\&quot; in class %s%s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2174       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, sig-&gt;as_C_string());</span>
2175 }
2176 
2177 AnnotationCollector::ID
2178 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2179                                       const Symbol* name,
2180                                       const bool can_access_vm_annotations) {
2181   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2182   // Privileged code can use all annotations.  Other code silently drops some.
2183   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2184                           loader_data-&gt;is_platform_class_loader_data() ||
2185                           can_access_vm_annotations;
2186   switch (sid) {
2187     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2188       if (_location != _in_method)  break;  // only allow for methods
2189       if (!privileged)              break;  // only allow in privileged code
2190       return _method_CallerSensitive;
2191     }
2192     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2193       if (_location != _in_method)  break;  // only allow for methods
2194       if (!privileged)              break;  // only allow in privileged code
</pre>
<hr />
<pre>
2419                              runtime_visible_type_annotations_length,
2420                              runtime_invisible_type_annotations,
2421                              runtime_invisible_type_annotations_length,
2422                              CHECK);
2423     cm-&gt;set_type_annotations(a);
2424   }
2425 }
2426 
2427 
2428 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2429 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2430 // Method* to save footprint, so we only know the size of the resulting Method* when the
2431 // entire method attribute is parsed.
2432 //
2433 // The promoted_flags parameter is used to pass relevant access_flags
2434 // from the method back up to the containing klass. These flag values
2435 // are added to klass&#39;s access_flags.
2436 
2437 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2438                                       bool is_interface,
<span class="line-added">2439                                       bool is_inline_type,</span>
2440                                       const ConstantPool* cp,
2441                                       AccessFlags* const promoted_flags,
2442                                       TRAPS) {
2443   assert(cfs != NULL, &quot;invariant&quot;);
2444   assert(cp != NULL, &quot;invariant&quot;);
2445   assert(promoted_flags != NULL, &quot;invariant&quot;);
2446 
2447   ResourceMark rm(THREAD);
2448   // Parse fixed parts:
2449   // access_flags, name_index, descriptor_index, attributes_count
2450   cfs-&gt;guarantee_more(8, CHECK_NULL);
2451 
2452   int flags = cfs-&gt;get_u2_fast();
2453   const u2 name_index = cfs-&gt;get_u2_fast();
2454   const int cp_size = cp-&gt;length();
2455   check_property(
2456     valid_symbol_at(name_index),
2457     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2458     name_index, CHECK_NULL);
2459   const Symbol* const name = cp-&gt;symbol_at(name_index);
2460   verify_legal_method_name(name, CHECK_NULL);
2461 
2462   const u2 signature_index = cfs-&gt;get_u2_fast();
2463   guarantee_property(
2464     valid_symbol_at(signature_index),
2465     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2466     signature_index, CHECK_NULL);
2467   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2468 
2469   if (name == vmSymbols::class_initializer_name()) {
2470     // We ignore the other access flags for a valid class initializer.
2471     // (JVM Spec 2nd ed., chapter 4.6)
2472     if (_major_version &lt; 51) { // backward compatibility
2473       flags = JVM_ACC_STATIC;
2474     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2475       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2476     } else {
2477       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2478     }
2479   } else {
<span class="line-modified">2480     verify_legal_method_modifiers(flags, is_interface, is_inline_type, name, CHECK_NULL);</span>
<span class="line-modified">2481   }</span>
<span class="line-modified">2482 </span>
<span class="line-modified">2483   if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-modified">2484     if (is_interface) {</span>
<span class="line-added">2485       classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>
<span class="line-added">2486     } else if (!is_inline_type &amp;&amp; signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2487       // OK, a constructor</span>
<span class="line-added">2488     } else if (is_inline_type &amp;&amp; !signature-&gt;is_void_method_signature()) {</span>
<span class="line-added">2489       // also OK, a static factory, as long as the return value is good</span>
<span class="line-added">2490       bool ok = false;</span>
<span class="line-added">2491       SignatureStream ss((Symbol*) signature, true);</span>
<span class="line-added">2492       while (!ss.at_return_type())  ss.next();</span>
<span class="line-added">2493       if (ss.is_reference()) {</span>
<span class="line-added">2494         Symbol* ret = ss.as_symbol();</span>
<span class="line-added">2495         const Symbol* required = class_name();</span>
<span class="line-added">2496         if (is_unsafe_anonymous()) {</span>
<span class="line-added">2497           // The original class name in the UAC byte stream gets changed.  So</span>
<span class="line-added">2498           // using the original name in the return type is no longer valid.</span>
<span class="line-added">2499           required = vmSymbols::java_lang_Object();</span>
<span class="line-added">2500         }</span>
<span class="line-added">2501         ok = (ret == required);</span>
<span class="line-added">2502       }</span>
<span class="line-added">2503       if (!ok) {</span>
<span class="line-added">2504         throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2505       }</span>
<span class="line-added">2506     } else {</span>
<span class="line-added">2507       // not OK, so throw the same error as in verify_legal_method_signature.</span>
<span class="line-added">2508       throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);</span>
<span class="line-added">2509     }</span>
<span class="line-added">2510     // A declared &lt;init&gt; method must always be either a non-static</span>
<span class="line-added">2511     // object constructor, with a void return, or else it must be a</span>
<span class="line-added">2512     // static factory method, with a non-void return.  No other</span>
<span class="line-added">2513     // definition of &lt;init&gt; is possible.</span>
<span class="line-added">2514     //</span>
<span class="line-added">2515     // The verifier (in verify_invoke_instructions) will inspect the</span>
<span class="line-added">2516     // signature of any attempt to invoke &lt;init&gt;, and ensures that it</span>
<span class="line-added">2517     // returns non-void if and only if it is being invoked by</span>
<span class="line-added">2518     // invokestatic, and void if and only if it is being invoked by</span>
<span class="line-added">2519     // invokespecial.</span>
<span class="line-added">2520     //</span>
<span class="line-added">2521     // When a symbolic reference to &lt;init&gt; is resolved for a</span>
<span class="line-added">2522     // particular invocation mode (special or static), the mode is</span>
<span class="line-added">2523     // matched to the JVM_ACC_STATIC modifier of the &lt;init&gt; method.</span>
<span class="line-added">2524     // Thus, it is impossible to statically invoke a constructor, and</span>
<span class="line-added">2525     // impossible to &quot;new + invokespecial&quot; a static factory, either</span>
<span class="line-added">2526     // through bytecode or through reflection.</span>
2527   }
2528 
2529   int args_size = -1;  // only used when _need_verify is true
2530   if (_need_verify) {
2531     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2532                  verify_legal_method_signature(name, signature, CHECK_NULL);
2533     if (args_size &gt; MAX_ARGS_SIZE) {
2534       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2535     }
2536   }
2537 
2538   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2539 
2540   // Default values for code and exceptions attribute elements
2541   u2 max_stack = 0;
2542   u2 max_locals = 0;
2543   u4 code_length = 0;
2544   const u1* code_start = 0;
2545   u2 exception_table_length = 0;
2546   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
</pre>
<hr />
<pre>
3057       _has_finalizer = true;
3058     }
3059   }
3060   if (name == vmSymbols::object_initializer_name() &amp;&amp;
3061       signature == vmSymbols::void_method_signature() &amp;&amp;
3062       m-&gt;is_vanilla_constructor()) {
3063     _has_vanilla_constructor = true;
3064   }
3065 
3066   NOT_PRODUCT(m-&gt;verify());
3067   return m;
3068 }
3069 
3070 
3071 // The promoted_flags parameter is used to pass relevant access_flags
3072 // from the methods back up to the containing klass. These flag values
3073 // are added to klass&#39;s access_flags.
3074 // Side-effects: populates the _methods field in the parser
3075 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
3076                                     bool is_interface,
<span class="line-added">3077                                     bool is_inline_type,</span>
3078                                     AccessFlags* promoted_flags,
3079                                     bool* has_final_method,
3080                                     bool* declares_nonstatic_concrete_methods,
3081                                     TRAPS) {
3082   assert(cfs != NULL, &quot;invariant&quot;);
3083   assert(promoted_flags != NULL, &quot;invariant&quot;);
3084   assert(has_final_method != NULL, &quot;invariant&quot;);
3085   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
3086 
3087   assert(NULL == _methods, &quot;invariant&quot;);
3088 
3089   cfs-&gt;guarantee_more(2, CHECK);  // length
3090   const u2 length = cfs-&gt;get_u2_fast();
3091   if (length == 0) {
3092     _methods = Universe::the_empty_method_array();
3093   } else {
3094     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
3095                                                    length,
3096                                                    NULL,
3097                                                    CHECK);
3098 
3099     for (int index = 0; index &lt; length; index++) {
3100       Method* method = parse_method(cfs,
3101                                     is_interface,
<span class="line-added">3102                                     is_inline_type,</span>
3103                                     _cp,
3104                                     promoted_flags,
3105                                     CHECK);
3106 
3107       if (method-&gt;is_final()) {
3108         *has_final_method = true;
3109       }
3110       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
3111       // used for interface initialization, and default method inheritance analysis
3112       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
3113         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
3114         *declares_nonstatic_concrete_methods = true;
3115       }
3116       _methods-&gt;at_put(index, method);
3117     }
3118 
3119     if (_need_verify &amp;&amp; length &gt; 1) {
3120       // Check duplicated methods
3121       ResourceMark rm(THREAD);
3122       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
</pre>
<hr />
<pre>
3275       valid_klass_reference_at(inner_class_info_index),
3276       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3277       inner_class_info_index, CHECK_0);
3278     // Outer class index
3279     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3280     check_property(
3281       outer_class_info_index == 0 ||
3282         valid_klass_reference_at(outer_class_info_index),
3283       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3284       outer_class_info_index, CHECK_0);
3285     // Inner class name
3286     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3287     check_property(
3288       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3289       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3290       inner_name_index, CHECK_0);
3291     if (_need_verify) {
3292       guarantee_property(inner_class_info_index != outer_class_info_index,
3293                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3294     }
<span class="line-modified">3295 </span>
<span class="line-modified">3296     jint recognized_modifiers = RECOGNIZED_INNER_CLASS_MODIFIERS;</span>
3297     // JVM_ACC_MODULE is defined in JDK-9 and later.
3298     if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">3299       recognized_modifiers |= JVM_ACC_MODULE;</span>


3300     }
<span class="line-added">3301     // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">3302     if (supports_inline_types()) {</span>
<span class="line-added">3303       recognized_modifiers |= JVM_ACC_VALUE;</span>
<span class="line-added">3304     }</span>
<span class="line-added">3305 </span>
<span class="line-added">3306     // Access flags</span>
<span class="line-added">3307     jint flags = cfs-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">3308 </span>
3309     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3310       // Set abstract bit for old class files for backward compatibility
3311       flags |= JVM_ACC_ABSTRACT;
3312     }
3313     verify_legal_class_modifiers(flags, CHECK_0);
3314     AccessFlags inner_access_flags(flags);
3315 
3316     inner_classes-&gt;at_put(index++, inner_class_info_index);
3317     inner_classes-&gt;at_put(index++, outer_class_info_index);
3318     inner_classes-&gt;at_put(index++, inner_name_index);
3319     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3320   }
3321 
3322   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3323   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3324     for(int i = 0; i &lt; length * 4; i += 4) {
3325       for(int j = i + 4; j &lt; length * 4; j += 4) {
3326         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3327                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3328                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
</pre>
<hr />
<pre>
4069       }
4070     }
4071     if (runtime_invisible_annotations != NULL) {
4072       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
4073         int append = runtime_visible_annotations_length+i;
4074         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
4075       }
4076     }
4077   }
4078   return annotations;
4079 }
4080 
4081 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
4082                                                         const int super_class_index,
4083                                                         const bool need_verify,
4084                                                         TRAPS) {
4085   assert(cp != NULL, &quot;invariant&quot;);
4086   const InstanceKlass* super_klass = NULL;
4087 
4088   if (super_class_index == 0) {
<span class="line-modified">4089     check_property(_class_name == vmSymbols::java_lang_Object()</span>
<span class="line-added">4090                    || (_access_flags.get_flags() &amp; JVM_ACC_VALUE),</span>
4091                    &quot;Invalid superclass index %u in class file %s&quot;,
4092                    super_class_index,
4093                    CHECK_NULL);
4094   } else {
4095     check_property(valid_klass_reference_at(super_class_index),
4096                    &quot;Invalid superclass index %u in class file %s&quot;,
4097                    super_class_index,
4098                    CHECK_NULL);
4099     // The class name should be legal because it is checked when parsing constant pool.
4100     // However, make sure it is not an array type.
4101     bool is_array = false;
4102     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4103       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4104       if (need_verify)
4105         is_array = super_klass-&gt;is_array_klass();
4106     } else if (need_verify) {
4107       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4108     }
4109     if (need_verify) {
4110       guarantee_property(!is_array,
</pre>
<hr />
<pre>
4250 }
4251 
4252 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4253   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4254   if (_nonstatic_oop_map_count &gt; 0) {
4255     OopMapBlock* map = _nonstatic_oop_maps;
4256     OopMapBlock* last_map = last_oop_map();
4257     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4258     while (map &lt;= last_map) {
4259       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4260                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4261       map++;
4262     }
4263   }
4264 }
4265 
4266 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4267   print_on(st);
4268 }
4269 
<span class="line-added">4270 void ClassFileParser::throwInlineTypeLimitation(THREAD_AND_LOCATION_DECL,</span>
<span class="line-added">4271                                                 const char* msg,</span>
<span class="line-added">4272                                                 const Symbol* name,</span>
<span class="line-added">4273                                                 const Symbol* sig) const {</span>
<span class="line-added">4274 </span>
<span class="line-added">4275   ResourceMark rm(THREAD);</span>
<span class="line-added">4276   if (name == NULL || sig == NULL) {</span>
<span class="line-added">4277     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4278         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4279         &quot;class: %s - %s&quot;, _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4280   }</span>
<span class="line-added">4281   else {</span>
<span class="line-added">4282     Exceptions::fthrow(THREAD_AND_LOCATION_ARGS,</span>
<span class="line-added">4283         vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">4284         &quot;\&quot;%s\&quot; sig: \&quot;%s\&quot; class: %s - %s&quot;, name-&gt;as_C_string(), sig-&gt;as_C_string(),</span>
<span class="line-added">4285         _class_name-&gt;as_C_string(), msg);</span>
<span class="line-added">4286   }</span>
<span class="line-added">4287 }</span>
<span class="line-added">4288 </span>
4289 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4290 void ClassFileParser::layout_fields(ConstantPool* cp,
4291                                     const FieldAllocationCount* fac,
4292                                     const ClassAnnotationCollector* parsed_annotations,
4293                                     FieldLayoutInfo* info,
4294                                     TRAPS) {
4295 
4296   assert(cp != NULL, &quot;invariant&quot;);
4297 
4298   // Field size and offset computation
4299   int nonstatic_field_size = _super_klass == NULL ? 0 :
4300                                _super_klass-&gt;nonstatic_field_size();
<span class="line-added">4301   int next_nonstatic_inline_type_offset = 0;</span>
<span class="line-added">4302   int first_nonstatic_inline_type_offset = 0;</span>
<span class="line-added">4303 </span>
<span class="line-added">4304   // Fields that are inline types are handled differently depending if they are static or not:</span>
<span class="line-added">4305   // - static fields are oops</span>
<span class="line-added">4306   // - non-static fields are embedded</span>
4307 
4308   // Count the contended fields by type.
4309   //
4310   // We ignore static fields, because @Contended is not supported for them.
4311   // The layout code below will also ignore the static fields.
4312   int nonstatic_contended_count = 0;
4313   FieldAllocationCount fac_contended;
4314   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4315     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4316     if (fs.is_contended()) {
4317       fac_contended.count[atype]++;
4318       if (!fs.access_flags().is_static()) {
4319         nonstatic_contended_count++;
4320       }
4321     }
4322   }
4323 
4324 
4325   // Calculate the starting byte offsets
4326   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<span class="line-added">4327   // Inline types in static fields are not embedded, they are handled with oops</span>
4328   int next_static_double_offset = next_static_oop_offset +
<span class="line-modified">4329                                   ((fac-&gt;count[STATIC_OOP] + fac-&gt;count[STATIC_FLATTENABLE]) * heapOopSize);</span>
4330   if (fac-&gt;count[STATIC_DOUBLE]) {
4331     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4332   }
4333 
4334   int next_static_word_offset   = next_static_double_offset +
4335                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4336   int next_static_short_offset  = next_static_word_offset +
4337                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4338   int next_static_byte_offset   = next_static_short_offset +
4339                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4340 
4341   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4342                                 nonstatic_field_size * heapOopSize;
4343 
<span class="line-added">4344   // First field of inline types is aligned on a long boundary in order to ease</span>
<span class="line-added">4345   // in-lining of inline types (with header removal) in packed arrays and</span>
<span class="line-added">4346   // flatten inline types</span>
<span class="line-added">4347   int initial_inline_type_padding = 0;</span>
<span class="line-added">4348   if (is_inline_type()) {</span>
<span class="line-added">4349     int old = nonstatic_fields_start;</span>
<span class="line-added">4350     nonstatic_fields_start = align_up(nonstatic_fields_start, BytesPerLong);</span>
<span class="line-added">4351     initial_inline_type_padding = nonstatic_fields_start - old;</span>
<span class="line-added">4352   }</span>
<span class="line-added">4353 </span>
4354   int next_nonstatic_field_offset = nonstatic_fields_start;
4355 
4356   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4357 
4358   // Class is contended, pad before all the fields
4359   if (is_contended_class) {
4360     next_nonstatic_field_offset += ContendedPaddingWidth;
4361   }
4362 
<span class="line-added">4363   // Temporary inline types restrictions</span>
<span class="line-added">4364   if (is_inline_type()) {</span>
<span class="line-added">4365     if (is_contended_class) {</span>
<span class="line-added">4366       throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support @Contended annotation yet&quot;);</span>
<span class="line-added">4367       return;</span>
<span class="line-added">4368     }</span>
<span class="line-added">4369   }</span>
<span class="line-added">4370 </span>
4371   // Compute the non-contended fields count.
4372   // The packing code below relies on these counts to determine if some field
4373   // can be squeezed into the alignment gap. Contended fields are obviously
4374   // exempt from that.
4375   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4376   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4377   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4378   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4379   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4380 
<span class="line-added">4381   int static_inline_type_count = 0;</span>
<span class="line-added">4382   int nonstatic_inline_type_count = 0;</span>
<span class="line-added">4383   int* nonstatic_inline_type_indexes = NULL;</span>
<span class="line-added">4384   Klass** nonstatic_inline_type_klasses = NULL;</span>
<span class="line-added">4385   unsigned int inline_type_oop_map_count = 0;</span>
<span class="line-added">4386   int not_flattened_inline_types = 0;</span>
<span class="line-added">4387   int not_atomic_inline_types = 0;</span>
<span class="line-added">4388 </span>
<span class="line-added">4389   int max_nonstatic_inline_type = fac-&gt;count[NONSTATIC_FLATTENABLE] + 1;</span>
<span class="line-added">4390 </span>
<span class="line-added">4391   nonstatic_inline_type_indexes = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, int,</span>
<span class="line-added">4392                                                                max_nonstatic_inline_type);</span>
<span class="line-added">4393   for (int i = 0; i &lt; max_nonstatic_inline_type; i++) {</span>
<span class="line-added">4394     nonstatic_inline_type_indexes[i] = -1;</span>
<span class="line-added">4395   }</span>
<span class="line-added">4396   nonstatic_inline_type_klasses = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, Klass*,</span>
<span class="line-added">4397                                                                max_nonstatic_inline_type);</span>
<span class="line-added">4398 </span>
<span class="line-added">4399   for (AllFieldStream fs(_fields, _cp); !fs.done(); fs.next()) {</span>
<span class="line-added">4400     if (fs.allocation_type() == STATIC_FLATTENABLE) {</span>
<span class="line-added">4401       ResourceMark rm;</span>
<span class="line-added">4402       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">4403         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">4404       }</span>
<span class="line-added">4405       static_inline_type_count++;</span>
<span class="line-added">4406     } else if (fs.allocation_type() == NONSTATIC_FLATTENABLE) {</span>
<span class="line-added">4407       // Pre-resolve the flattenable field and check for inline type circularity issues.</span>
<span class="line-added">4408       ResourceMark rm;</span>
<span class="line-added">4409       if (!fs.signature()-&gt;is_Q_signature()) {</span>
<span class="line-added">4410         THROW(vmSymbols::java_lang_ClassFormatError());</span>
<span class="line-added">4411       }</span>
<span class="line-added">4412       Klass* klass =</span>
<span class="line-added">4413         SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">4414                                                             Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">4415                                                             _protection_domain, true, CHECK);</span>
<span class="line-added">4416       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">4417       if (!klass-&gt;access_flags().is_inline_type()) {</span>
<span class="line-added">4418         THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">4419       }</span>
<span class="line-added">4420       ValueKlass* vk = ValueKlass::cast(klass);</span>
<span class="line-added">4421       // Conditions to apply flattening or not should be defined in a single place</span>
<span class="line-added">4422       bool too_big_to_flatten = (ValueFieldMaxFlatSize &gt;= 0 &amp;&amp;</span>
<span class="line-added">4423                                  (vk-&gt;size_helper() * HeapWordSize) &gt; ValueFieldMaxFlatSize);</span>
<span class="line-added">4424       bool too_atomic_to_flatten = vk-&gt;is_declared_atomic();</span>
<span class="line-added">4425       bool too_volatile_to_flatten = fs.access_flags().is_volatile();</span>
<span class="line-added">4426       if (vk-&gt;is_naturally_atomic()) {</span>
<span class="line-added">4427         too_atomic_to_flatten = false;</span>
<span class="line-added">4428         //too_volatile_to_flatten = false; //FIXME</span>
<span class="line-added">4429         // volatile fields are currently never flattened, this could change in the future</span>
<span class="line-added">4430       }</span>
<span class="line-added">4431       if (!(too_big_to_flatten | too_atomic_to_flatten | too_volatile_to_flatten)) {</span>
<span class="line-added">4432         nonstatic_inline_type_indexes[nonstatic_inline_type_count] = fs.index();</span>
<span class="line-added">4433         nonstatic_inline_type_klasses[nonstatic_inline_type_count] = klass;</span>
<span class="line-added">4434         nonstatic_inline_type_count++;</span>
<span class="line-added">4435 </span>
<span class="line-added">4436         ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">4437         if (vklass-&gt;contains_oops()) {</span>
<span class="line-added">4438           inline_type_oop_map_count += vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">4439         }</span>
<span class="line-added">4440         fs.set_flattened(true);</span>
<span class="line-added">4441         if (!vk-&gt;is_atomic()) {  // flat and non-atomic: take note</span>
<span class="line-added">4442           not_atomic_inline_types++;</span>
<span class="line-added">4443         }</span>
<span class="line-added">4444       } else {</span>
<span class="line-added">4445         not_flattened_inline_types++;</span>
<span class="line-added">4446         fs.set_flattened(false);</span>
<span class="line-added">4447       }</span>
<span class="line-added">4448     }</span>
<span class="line-added">4449   }</span>
<span class="line-added">4450 </span>
<span class="line-added">4451   // Adjusting non_static_oop_count to take into account not flattened inline types;</span>
<span class="line-added">4452   nonstatic_oop_count += not_flattened_inline_types;</span>
<span class="line-added">4453 </span>
4454   // Total non-static fields count, including every contended field
4455   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4456                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<span class="line-modified">4457                                         fac-&gt;count[NONSTATIC_OOP] + fac-&gt;count[NONSTATIC_FLATTENABLE];</span>
4458 
4459   const bool super_has_nonstatic_fields =
4460           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4461   const bool has_nonstatic_fields =
4462     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<span class="line-added">4463   const bool has_nonstatic_value_fields = nonstatic_inline_type_count &gt; 0;</span>
4464 
<span class="line-added">4465   if (is_inline_type() &amp;&amp; (!has_nonstatic_fields)) {</span>
<span class="line-added">4466     // There are a number of fixes required throughout the type system and JIT</span>
<span class="line-added">4467     throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support zero instance size yet&quot;);</span>
<span class="line-added">4468     return;</span>
<span class="line-added">4469   }</span>
4470 
4471   // Prepare list of oops for oop map generation.
4472   //
4473   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4474   // regions. offset[i] is the start of the i-th region, which then has
4475   // count[i] oops following. Before we know how many regions are required,
4476   // we pessimistically allocate the maps to fit all the oops into the
4477   // distinct regions.
<span class="line-modified">4478   //</span>
4479   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<span class="line-modified">4480   int max_oop_map_count =</span>
<span class="line-added">4481       super_oop_map_count +</span>
<span class="line-added">4482       fac-&gt;count[NONSTATIC_OOP] +</span>
<span class="line-added">4483       inline_type_oop_map_count +</span>
<span class="line-added">4484       not_flattened_inline_types;</span>
4485 
4486   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4487   if (super_oop_map_count &gt; 0) {
4488     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4489                                                     _super_klass-&gt;nonstatic_oop_map_count());
4490   }
4491 
4492   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4493 
4494   bool compact_fields  = true;
4495   bool allocate_oops_first = false;
4496 
4497   // The next classes have predefined hard-coded fields offsets
4498   // (see in JavaClasses::compute_hard_coded_offsets()).
4499   // Use default fields allocation order for them.
4500   if (_loader_data-&gt;class_loader() == NULL &amp;&amp;
4501       (_class_name == vmSymbols::java_lang_ref_Reference() ||
4502        _class_name == vmSymbols::java_lang_Boolean() ||
4503        _class_name == vmSymbols::java_lang_Character() ||
4504        _class_name == vmSymbols::java_lang_Float() ||
</pre>
<hr />
<pre>
4576   }
4577 
4578   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4579                                      (nonstatic_double_count * BytesPerLong);
4580   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4581                                       (nonstatic_word_count * BytesPerInt);
4582   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4583                                      (nonstatic_short_count * BytesPerShort);
4584   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4585                                        nonstatic_byte_count;
4586 
4587   // let oops jump before padding with this allocation style
4588   if (!allocate_oops_first) {
4589     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4590     if( nonstatic_oop_count &gt; 0 ) {
4591       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4592     }
4593     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4594   }
4595 
<span class="line-added">4596   // Aligning embedded inline types</span>
<span class="line-added">4597   // bug below, the current algorithm to layout embedded inline types always put them at the</span>
<span class="line-added">4598   // end of the layout, which doesn&#39;t match the different allocation policies the VM is</span>
<span class="line-added">4599   // supposed to provide =&gt; FixMe</span>
<span class="line-added">4600   // Note also that the current alignment policy is to make each inline type starting on a</span>
<span class="line-added">4601   // 64 bits boundary. This could be optimized later. For instance, it could be nice to</span>
<span class="line-added">4602   // align inline types according to their most constrained internal type.</span>
<span class="line-added">4603   next_nonstatic_inline_type_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);</span>
<span class="line-added">4604   int next_inline_type_index = 0;</span>
<span class="line-added">4605 </span>
4606   // Iterate over fields again and compute correct offsets.
4607   // The field allocation type was temporarily stored in the offset slot.
4608   // oop fields are located before non-oop fields (static and non-static).
4609   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4610 
4611     // skip already laid out fields
4612     if (fs.is_offset_set()) continue;
4613 
4614     // contended instance fields are handled below
4615     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4616 
4617     int real_offset = 0;
4618     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4619 
4620     // pack the rest of the fields
4621     switch (atype) {
<span class="line-added">4622       // Inline types in static fields are handled with oops</span>
<span class="line-added">4623       case STATIC_FLATTENABLE:   // Fallthrough</span>
4624       case STATIC_OOP:
4625         real_offset = next_static_oop_offset;
4626         next_static_oop_offset += heapOopSize;
4627         break;
4628       case STATIC_BYTE:
4629         real_offset = next_static_byte_offset;
4630         next_static_byte_offset += 1;
4631         break;
4632       case STATIC_SHORT:
4633         real_offset = next_static_short_offset;
4634         next_static_short_offset += BytesPerShort;
4635         break;
4636       case STATIC_WORD:
4637         real_offset = next_static_word_offset;
4638         next_static_word_offset += BytesPerInt;
4639         break;
4640       case STATIC_DOUBLE:
4641         real_offset = next_static_double_offset;
4642         next_static_double_offset += BytesPerLong;
4643         break;
<span class="line-added">4644       case NONSTATIC_FLATTENABLE:</span>
<span class="line-added">4645         if (fs.is_flattened()) {</span>
<span class="line-added">4646           Klass* klass = nonstatic_inline_type_klasses[next_inline_type_index];</span>
<span class="line-added">4647           assert(klass != NULL, &quot;Klass should have been loaded and resolved earlier&quot;);</span>
<span class="line-added">4648           assert(klass-&gt;access_flags().is_inline_type(),&quot;Must be an inline type&quot;);</span>
<span class="line-added">4649           ValueKlass* vklass = ValueKlass::cast(klass);</span>
<span class="line-added">4650           real_offset = next_nonstatic_inline_type_offset;</span>
<span class="line-added">4651           next_nonstatic_inline_type_offset += (vklass-&gt;size_helper()) * wordSize - vklass-&gt;first_field_offset();</span>
<span class="line-added">4652           // aligning next inline type on a 64 bits boundary</span>
<span class="line-added">4653           next_nonstatic_inline_type_offset = align_up(next_nonstatic_inline_type_offset, BytesPerLong);</span>
<span class="line-added">4654           next_inline_type_index += 1;</span>
<span class="line-added">4655 </span>
<span class="line-added">4656           if (vklass-&gt;contains_oops()) { // add flatten oop maps</span>
<span class="line-added">4657             int diff = real_offset - vklass-&gt;first_field_offset();</span>
<span class="line-added">4658             const OopMapBlock* map = vklass-&gt;start_of_nonstatic_oop_maps();</span>
<span class="line-added">4659             const OopMapBlock* const last_map = map + vklass-&gt;nonstatic_oop_map_count();</span>
<span class="line-added">4660             while (map &lt; last_map) {</span>
<span class="line-added">4661               nonstatic_oop_maps-&gt;add(map-&gt;offset() + diff, map-&gt;count());</span>
<span class="line-added">4662               map++;</span>
<span class="line-added">4663             }</span>
<span class="line-added">4664           }</span>
<span class="line-added">4665           break;</span>
<span class="line-added">4666         } else {</span>
<span class="line-added">4667           // Fall through</span>
<span class="line-added">4668         }</span>
4669       case NONSTATIC_OOP:
4670         if( nonstatic_oop_space_count &gt; 0 ) {
4671           real_offset = nonstatic_oop_space_offset;
4672           nonstatic_oop_space_offset += heapOopSize;
4673           nonstatic_oop_space_count  -= 1;
4674         } else {
4675           real_offset = next_nonstatic_oop_offset;
4676           next_nonstatic_oop_offset += heapOopSize;
4677         }
4678         nonstatic_oop_maps-&gt;add(real_offset, 1);
4679         break;
4680       case NONSTATIC_BYTE:
4681         if( nonstatic_byte_space_count &gt; 0 ) {
4682           real_offset = nonstatic_byte_space_offset;
4683           nonstatic_byte_space_offset += 1;
4684           nonstatic_byte_space_count  -= 1;
4685         } else {
4686           real_offset = next_nonstatic_byte_offset;
4687           next_nonstatic_byte_offset += 1;
4688         }
</pre>
<hr />
<pre>
4767             break;
4768 
4769           case NONSTATIC_SHORT:
4770             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4771             real_offset = next_nonstatic_padded_offset;
4772             next_nonstatic_padded_offset += BytesPerShort;
4773             break;
4774 
4775           case NONSTATIC_WORD:
4776             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4777             real_offset = next_nonstatic_padded_offset;
4778             next_nonstatic_padded_offset += BytesPerInt;
4779             break;
4780 
4781           case NONSTATIC_DOUBLE:
4782             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4783             real_offset = next_nonstatic_padded_offset;
4784             next_nonstatic_padded_offset += BytesPerLong;
4785             break;
4786 
<span class="line-added">4787             // Inline types in static fields are handled with oops</span>
<span class="line-added">4788           case NONSTATIC_FLATTENABLE:</span>
<span class="line-added">4789             throwInlineTypeLimitation(THREAD_AND_LOCATION,</span>
<span class="line-added">4790                                       &quot;@Contended annotation not supported for inline types yet&quot;, fs.name(), fs.signature());</span>
<span class="line-added">4791             return;</span>
<span class="line-added">4792 </span>
4793           case NONSTATIC_OOP:
4794             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4795             real_offset = next_nonstatic_padded_offset;
4796             next_nonstatic_padded_offset += heapOopSize;
4797             nonstatic_oop_maps-&gt;add(real_offset, 1);
4798             break;
4799 
4800           default:
4801             ShouldNotReachHere();
4802         }
4803 
4804         if (fs.contended_group() == 0) {
4805           // Contended group defines the equivalence class over the fields:
4806           // the fields within the same contended group are not inter-padded.
4807           // The only exception is default group, which does not incur the
4808           // equivalence, and so requires intra-padding.
4809           next_nonstatic_padded_offset += ContendedPaddingWidth;
4810         }
4811 
4812         fs.set_offset(real_offset);
4813       } // for
4814 
4815       // Start laying out the next group.
4816       // Note that this will effectively pad the last group in the back;
4817       // this is expected to alleviate memory contention effects for
4818       // subclass fields and/or adjacent object.
4819       // If this was the default group, the padding is already in place.
4820       if (current_group != 0) {
4821         next_nonstatic_padded_offset += ContendedPaddingWidth;
4822       }
4823     }
4824 
4825     // handle static fields
4826   }
4827 
4828   // Entire class is contended, pad in the back.
4829   // This helps to alleviate memory contention effects for subclass fields
4830   // and/or adjacent object.
4831   if (is_contended_class) {
<span class="line-added">4832     assert(!is_inline_type(), &quot;@Contended not supported for inline types yet&quot;);</span>
4833     next_nonstatic_padded_offset += ContendedPaddingWidth;
4834   }
4835 
<span class="line-modified">4836   int notaligned_nonstatic_fields_end;</span>
<span class="line-added">4837   if (nonstatic_inline_type_count != 0) {</span>
<span class="line-added">4838     notaligned_nonstatic_fields_end = next_nonstatic_inline_type_offset;</span>
<span class="line-added">4839   } else {</span>
<span class="line-added">4840     notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>
<span class="line-added">4841   }</span>
4842 
<span class="line-modified">4843   int nonstatic_field_sz_align = heapOopSize;</span>
<span class="line-added">4844   if (is_inline_type()) {</span>
<span class="line-added">4845     if ((notaligned_nonstatic_fields_end - nonstatic_fields_start) &gt; heapOopSize) {</span>
<span class="line-added">4846       nonstatic_field_sz_align = BytesPerLong; // value copy of fields only uses jlong copy</span>
<span class="line-added">4847     }</span>
<span class="line-added">4848   }</span>
<span class="line-added">4849   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, nonstatic_field_sz_align);</span>
4850   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4851   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4852 
4853   int static_field_size         = (static_fields_end -
4854                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4855   nonstatic_field_size          = nonstatic_field_size +
4856                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4857 
4858   int instance_size             = align_object_size(instance_end / wordSize);
4859 
4860   assert(instance_size == align_object_size(align_up(
<span class="line-modified">4861          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize)</span>
<span class="line-modified">4862          + initial_inline_type_padding, wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>
<span class="line-added">4863 </span>
4864 
4865   // Invariant: nonstatic_field end/start should only change if there are
4866   // nonstatic fields in the class, or if the class is contended. We compare
4867   // against the non-aligned value, so that end alignment will not fail the
4868   // assert without actually having the fields.
4869   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4870          is_contended_class ||
4871          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4872 
4873   // Number of non-static oop map blocks allocated at end of klass.
4874   nonstatic_oop_maps-&gt;compact();
4875 
4876 #ifndef PRODUCT
<span class="line-modified">4877   if ((PrintFieldLayout &amp;&amp; !is_inline_type()) ||</span>
<span class="line-added">4878       (PrintValueLayout &amp;&amp; (is_inline_type() || has_nonstatic_value_fields))) {</span>
4879     print_field_layout(_class_name,
4880           _fields,
4881           cp,
4882           instance_size,
4883           nonstatic_fields_start,
4884           nonstatic_fields_end,
4885           static_fields_end);
<span class="line-added">4886     nonstatic_oop_maps-&gt;print_on(tty);</span>
<span class="line-added">4887     tty-&gt;print(&quot;\n&quot;);</span>
<span class="line-added">4888     tty-&gt;print_cr(&quot;Instance size = %d&quot;, instance_size);</span>
<span class="line-added">4889     tty-&gt;print_cr(&quot;Nonstatic_field_size = %d&quot;, nonstatic_field_size);</span>
<span class="line-added">4890     tty-&gt;print_cr(&quot;Static_field_size = %d&quot;, static_field_size);</span>
<span class="line-added">4891     tty-&gt;print_cr(&quot;Has nonstatic fields = %d&quot;, has_nonstatic_fields);</span>
<span class="line-added">4892     tty-&gt;print_cr(&quot;---&quot;);</span>
4893   }
4894 
4895 #endif
4896   // Pass back information needed for InstanceKlass creation
4897   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4898   info-&gt;_instance_size = instance_size;
4899   info-&gt;_static_field_size = static_field_size;
4900   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4901   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<span class="line-added">4902 </span>
<span class="line-added">4903   // An inline type is naturally atomic if it has just one field, and</span>
<span class="line-added">4904   // that field is simple enough.</span>
<span class="line-added">4905   info-&gt;_is_naturally_atomic = (is_inline_type() &amp;&amp;</span>
<span class="line-added">4906                                 !super_has_nonstatic_fields &amp;&amp;</span>
<span class="line-added">4907                                 (nonstatic_fields_count &lt;= 1) &amp;&amp;</span>
<span class="line-added">4908                                 (not_atomic_inline_types == 0) &amp;&amp;</span>
<span class="line-added">4909                                 (nonstatic_contended_count == 0));</span>
<span class="line-added">4910   // This may be too restrictive, since if all the fields fit in 64</span>
<span class="line-added">4911   // bits we could make the decision to align instances of this class</span>
<span class="line-added">4912   // to 64-bit boundaries, and load and store them as single words.</span>
<span class="line-added">4913   // And on machines which supported larger atomics we could similarly</span>
<span class="line-added">4914   // allow larger values to be atomic, if properly aligned.</span>
4915 }
4916 
4917 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4918   assert(ik != NULL, &quot;invariant&quot;);
4919 
4920   const Klass* const super = ik-&gt;super();
4921 
4922   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4923   // in which case we don&#39;t have to register objects as finalizable
4924   if (!_has_empty_finalizer) {
4925     if (_has_finalizer ||
4926         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4927       ik-&gt;set_has_finalizer();
4928     }
4929   }
4930 
4931 #ifdef ASSERT
4932   bool f = false;
4933   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4934                                            vmSymbols::void_method_signature());
4935   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4936       f = true;
4937   }
4938 
4939   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4940   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4941   // will not work as expected we shouldn&#39;t abort vm in this case
4942   if (!ik-&gt;has_redefined_this_or_super()) {
4943     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4944   }
4945 #endif
4946 
4947   // Check if this klass supports the java.lang.Cloneable interface
4948   if (SystemDictionary::Cloneable_klass_loaded()) {
4949     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
<span class="line-added">4950       if (ik-&gt;is_value()) {</span>
<span class="line-added">4951         Thread *THREAD = Thread::current();</span>
<span class="line-added">4952         throwInlineTypeLimitation(THREAD_AND_LOCATION, &quot;Inline Types do not support Cloneable&quot;);</span>
<span class="line-added">4953         return;</span>
<span class="line-added">4954       }</span>
4955       ik-&gt;set_is_cloneable();
4956     }
4957   }
4958 
4959   // Check if this klass has a vanilla default constructor
4960   if (super == NULL) {
4961     // java.lang.Object has empty default constructor
4962     ik-&gt;set_has_vanilla_constructor();
4963   } else {
4964     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4965         _has_vanilla_constructor) {
4966       ik-&gt;set_has_vanilla_constructor();
4967     }
4968 #ifdef ASSERT
4969     bool v = false;
4970     if (super-&gt;has_vanilla_constructor()) {
4971       const Method* const constructor =
4972         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4973                        vmSymbols::void_method_signature());
4974       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4975         v = true;
4976       }
4977     }
4978     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4979 #endif
4980   }
4981 
4982   // If it cannot be fast-path allocated, set a bit in the layout helper.
4983   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4984   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4985   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4986       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4987       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4988       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4989     // Forbid fast-path allocation.
4990     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4991     ik-&gt;set_layout_helper(lh);
4992   }
4993 }
4994 
<span class="line-added">4995 bool ClassFileParser::supports_inline_types() const {</span>
<span class="line-added">4996   // Inline types are only supported by class file version 55 and later</span>
<span class="line-added">4997   return _major_version &gt;= JAVA_11_VERSION;</span>
<span class="line-added">4998 }</span>
<span class="line-added">4999 </span>
5000 // utility methods for appending an array with check for duplicates
5001 
5002 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
5003                               const Array&lt;InstanceKlass*&gt;* const ifs) {
5004   // iterate over new interfaces
5005   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
5006     InstanceKlass* const e = ifs-&gt;at(i);
5007     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
5008     // add new interface
5009     result-&gt;append_if_missing(e);
5010   }
5011 }
5012 
5013 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
5014                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
5015                                                             ClassLoaderData* loader_data,
5016                                                             TRAPS) {
5017   assert(local_ifs != NULL, &quot;invariant&quot;);
5018   assert(loader_data != NULL, &quot;invariant&quot;);
5019 
</pre>
<hr />
<pre>
5023   // Add superclass transitive interfaces size
5024   if (super != NULL) {
5025     super_size = super-&gt;transitive_interfaces()-&gt;length();
5026     max_transitive_size += super_size;
5027   }
5028   // Add local interfaces&#39; super interfaces
5029   const int local_size = local_ifs-&gt;length();
5030   for (int i = 0; i &lt; local_size; i++) {
5031     InstanceKlass* const l = local_ifs-&gt;at(i);
5032     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
5033   }
5034   // Finally add local interfaces
5035   max_transitive_size += local_size;
5036   // Construct array
5037   if (max_transitive_size == 0) {
5038     // no interfaces, use canonicalized array
5039     return Universe::the_empty_instance_klass_array();
5040   } else if (max_transitive_size == super_size) {
5041     // no new local interfaces added, share superklass&#39; transitive interface array
5042     return super-&gt;transitive_interfaces();
<span class="line-modified">5043     // The three lines below are commented to work around bug JDK-8245487</span>
<span class="line-modified">5044 //  } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">5045 //    // only local interfaces added, share local interface array</span>
<span class="line-added">5046 //    return local_ifs;</span>
5047   } else {
5048     ResourceMark rm;
5049     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
5050 
5051     // Copy down from superclass
5052     if (super != NULL) {
5053       append_interfaces(result, super-&gt;transitive_interfaces());
5054     }
5055 
5056     // Copy down from local interfaces&#39; superinterfaces
5057     for (int i = 0; i &lt; local_size; i++) {
5058       InstanceKlass* const l = local_ifs-&gt;at(i);
5059       append_interfaces(result, l-&gt;transitive_interfaces());
5060     }
5061     // Finally add local interfaces
5062     append_interfaces(result, local_ifs);
5063 
5064     // length will be less than the max_transitive_size if duplicates were removed
5065     const int length = result-&gt;length();
5066     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
<span class="line-added">5067 </span>
<span class="line-added">5068     if (length == 1 &amp;&amp; result-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">5069       return Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">5070     }</span>
<span class="line-added">5071 </span>
5072     Array&lt;InstanceKlass*&gt;* const new_result =
5073       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
5074     for (int i = 0; i &lt; length; i++) {
5075       InstanceKlass* const e = result-&gt;at(i);
5076       assert(e != NULL, &quot;just checking&quot;);
5077       new_result-&gt;at_put(i, e);
5078     }
5079     return new_result;
5080   }
5081 }
5082 
5083 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
5084   assert(this_klass != NULL, &quot;invariant&quot;);
5085   const Klass* const super = this_klass-&gt;super();
5086 
5087   if (super != NULL) {
5088 
5089     // If the loader is not the boot loader then throw an exception if its
5090     // superclass is in package jdk.internal.reflect and its loader is not a
5091     // special reflection class loader
</pre>
<hr />
<pre>
5249     const Method* const m = methods-&gt;at(index);
5250     // if m is static and not the init method, throw a verify error
5251     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
5252       ResourceMark rm(THREAD);
5253       Exceptions::fthrow(
5254         THREAD_AND_LOCATION,
5255         vmSymbols::java_lang_VerifyError(),
5256         &quot;Illegal static method %s in interface %s&quot;,
5257         m-&gt;name()-&gt;as_C_string(),
5258         this_klass-&gt;external_name()
5259       );
5260       return;
5261     }
5262   }
5263 }
5264 
5265 // utility methods for format checking
5266 
5267 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
5268   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<span class="line-added">5269   const bool is_inline_type = (flags &amp; JVM_ACC_VALUE) != 0;</span>
5270   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<span class="line-added">5271   assert(supports_inline_types() || !is_inline_type, &quot;JVM_ACC_VALUE should not be set&quot;);</span>
5272   if (is_module) {
5273     ResourceMark rm(THREAD);
5274     Exceptions::fthrow(
5275       THREAD_AND_LOCATION,
5276       vmSymbols::java_lang_NoClassDefFoundError(),
5277       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
5278       _class_name-&gt;as_C_string());
5279     return;
5280   }
5281 
<span class="line-added">5282   if (is_inline_type &amp;&amp; !EnableValhalla) {</span>
<span class="line-added">5283     ResourceMark rm(THREAD);</span>
<span class="line-added">5284     Exceptions::fthrow(</span>
<span class="line-added">5285       THREAD_AND_LOCATION,</span>
<span class="line-added">5286       vmSymbols::java_lang_ClassFormatError(),</span>
<span class="line-added">5287       &quot;Class modifier ACC_VALUE in class %s requires option -XX:+EnableValhalla&quot;,</span>
<span class="line-added">5288       _class_name-&gt;as_C_string()</span>
<span class="line-added">5289     );</span>
<span class="line-added">5290   }</span>
<span class="line-added">5291 </span>
5292   if (!_need_verify) { return; }
5293 
5294   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
5295   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
5296   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
5297   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
5298   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
5299   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
5300   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5301   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5302 
5303   if ((is_abstract &amp;&amp; is_final) ||
5304       (is_interface &amp;&amp; !is_abstract) ||
5305       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<span class="line-modified">5306       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation) ||</span>
<span class="line-added">5307       (is_inline_type &amp;&amp; (is_interface || is_abstract || is_enum || !is_final))) {</span>
5308     ResourceMark rm(THREAD);
<span class="line-added">5309     const char* class_note = &quot;&quot;;</span>
<span class="line-added">5310     if (is_inline_type)  class_note = &quot; (an inline class)&quot;;</span>
5311     Exceptions::fthrow(
5312       THREAD_AND_LOCATION,
5313       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5314       &quot;Illegal class modifiers in class %s%s: 0x%X&quot;,</span>
<span class="line-modified">5315       _class_name-&gt;as_C_string(), class_note, flags</span>
5316     );
5317     return;
5318   }
5319 }
5320 
5321 static bool has_illegal_visibility(jint flags) {
5322   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5323   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5324   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5325 
5326   return ((is_public &amp;&amp; is_protected) ||
5327           (is_public &amp;&amp; is_private) ||
5328           (is_protected &amp;&amp; is_private));
5329 }
5330 
5331 // A legal major_version.minor_version must be one of the following:
5332 //
5333 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5334 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5335 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
</pre>
<hr />
<pre>
5374     if (!Arguments::enable_preview()) {
5375       Exceptions::fthrow(
5376         THREAD_AND_LOCATION,
5377         vmSymbols::java_lang_UnsupportedClassVersionError(),
5378         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5379         class_name-&gt;as_C_string(), major, minor);
5380       return;
5381     }
5382 
5383   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5384     Exceptions::fthrow(
5385         THREAD_AND_LOCATION,
5386         vmSymbols::java_lang_UnsupportedClassVersionError(),
5387         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5388         class_name-&gt;as_C_string(), major, minor);
5389   }
5390 }
5391 
5392 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5393                                                    bool is_interface,
<span class="line-added">5394                                                    bool is_inline_type,</span>
5395                                                    TRAPS) const {
5396   if (!_need_verify) { return; }
5397 
5398   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5399   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5400   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5401   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5402   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5403   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5404   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5405   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5406   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5407 
5408   bool is_illegal = false;
5409 
5410   if (is_interface) {
5411     if (!is_public || !is_static || !is_final || is_private ||
5412         is_protected || is_volatile || is_transient ||
5413         (major_gte_1_5 &amp;&amp; is_enum)) {
5414       is_illegal = true;
5415     }
5416   } else { // not interface
5417     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5418       is_illegal = true;
<span class="line-added">5419     } else {</span>
<span class="line-added">5420       if (is_inline_type &amp;&amp; !is_static &amp;&amp; !is_final) {</span>
<span class="line-added">5421         is_illegal = true;</span>
<span class="line-added">5422       }</span>
5423     }
5424   }
5425 
5426   if (is_illegal) {
5427     ResourceMark rm(THREAD);
5428     Exceptions::fthrow(
5429       THREAD_AND_LOCATION,
5430       vmSymbols::java_lang_ClassFormatError(),
5431       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5432       _class_name-&gt;as_C_string(), flags);
5433     return;
5434   }
5435 }
5436 
5437 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5438                                                     bool is_interface,
<span class="line-added">5439                                                     bool is_inline_type,</span>
5440                                                     const Symbol* name,
5441                                                     TRAPS) const {
5442   if (!_need_verify) { return; }
5443 
5444   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5445   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5446   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5447   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5448   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5449   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5450   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5451   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5452   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5453   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5454   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5455   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5456   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5457 
5458   bool is_illegal = false;
5459 
<span class="line-added">5460   const char* class_note = &quot;&quot;;</span>
<span class="line-added">5461 </span>
5462   if (is_interface) {
5463     if (major_gte_8) {
5464       // Class file version is JAVA_8_VERSION or later Methods of
5465       // interfaces may set any of the flags except ACC_PROTECTED,
5466       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5467       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5468       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5469           (is_native || is_protected || is_final || is_synchronized) ||
5470           // If a specific method of a class or interface has its
5471           // ACC_ABSTRACT flag set, it must not have any of its
5472           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5473           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5474           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5475           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5476           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5477         is_illegal = true;
5478       }
5479     } else if (major_gte_1_5) {
5480       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5481       if (!is_public || is_private || is_protected || is_static || is_final ||
5482           is_synchronized || is_native || !is_abstract || is_strict) {
5483         is_illegal = true;
5484       }
5485     } else {
5486       // Class file version is pre-JAVA_1_5_VERSION
5487       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5488         is_illegal = true;
5489       }
5490     }
5491   } else { // not interface
5492     if (has_illegal_visibility(flags)) {
5493       is_illegal = true;
5494     } else {
5495       if (is_initializer) {
<span class="line-modified">5496         if (is_final || is_synchronized || is_native ||</span>
5497             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5498           is_illegal = true;
5499         }
<span class="line-added">5500         if (!is_static &amp;&amp; !is_inline_type) {</span>
<span class="line-added">5501           // OK, an object constructor in a regular class</span>
<span class="line-added">5502         } else if (is_static &amp;&amp; is_inline_type) {</span>
<span class="line-added">5503           // OK, a static init factory in an inline class</span>
<span class="line-added">5504         } else {</span>
<span class="line-added">5505           // but no other combinations are allowed</span>
<span class="line-added">5506           is_illegal = true;</span>
<span class="line-added">5507           class_note = (is_inline_type ? &quot; (an inline class)&quot; : &quot; (not an inline class)&quot;);</span>
<span class="line-added">5508         }</span>
5509       } else { // not initializer
<span class="line-modified">5510         if (is_inline_type &amp;&amp; is_synchronized &amp;&amp; !is_static) {</span>
<span class="line-modified">5511           is_illegal = true;</span>
<span class="line-modified">5512           class_note = &quot; (an inline class)&quot;;</span>
<span class="line-modified">5513         } else {</span>
<span class="line-added">5514           if (is_abstract) {</span>
<span class="line-added">5515             if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-added">5516                 (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-added">5517               is_illegal = true;</span>
<span class="line-added">5518             }</span>
5519           }
5520         }
5521       }
5522     }
5523   }
5524 
5525   if (is_illegal) {
5526     ResourceMark rm(THREAD);
5527     Exceptions::fthrow(
5528       THREAD_AND_LOCATION,
5529       vmSymbols::java_lang_ClassFormatError(),
<span class="line-modified">5530       &quot;Method %s in class %s%s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5531       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), class_note, flags);</span>
5532     return;
5533   }
5534 }
5535 
5536 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5537                                         int length,
5538                                         TRAPS) const {
5539   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5540   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5541     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5542   }
5543 }
5544 
5545 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5546 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5547 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5548 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5549 // method.  Because these names have been checked as special cases before
5550 // calling this method in verify_legal_method_name.
5551 //
</pre>
<hr />
<pre>
5669 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5670 // Return a pointer to just past the signature.
5671 // Return NULL if no legal signature is found.
5672 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5673                                                        bool void_ok,
5674                                                        unsigned int length,
5675                                                        TRAPS) const {
5676   unsigned int array_dim = 0;
5677   while (length &gt; 0) {
5678     switch (signature[0]) {
5679     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5680     case JVM_SIGNATURE_BOOLEAN:
5681     case JVM_SIGNATURE_BYTE:
5682     case JVM_SIGNATURE_CHAR:
5683     case JVM_SIGNATURE_SHORT:
5684     case JVM_SIGNATURE_INT:
5685     case JVM_SIGNATURE_FLOAT:
5686     case JVM_SIGNATURE_LONG:
5687     case JVM_SIGNATURE_DOUBLE:
5688       return signature + 1;
<span class="line-modified">5689     case JVM_SIGNATURE_VALUETYPE:</span>
<span class="line-added">5690       // Can&#39;t enable this check until JDK upgrades the bytecode generators</span>
<span class="line-added">5691       // if (_major_version &lt; CONSTANT_CLASS_DESCRIPTORS ) {</span>
<span class="line-added">5692       //   classfile_parse_error(&quot;Class name contains illegal Q-signature &quot;</span>
<span class="line-added">5693       //                                    &quot;in descriptor in class file %s&quot;,</span>
<span class="line-added">5694       //                                    CHECK_0);</span>
<span class="line-added">5695       // }</span>
<span class="line-added">5696       // fall through</span>
<span class="line-added">5697     case JVM_SIGNATURE_CLASS:</span>
<span class="line-added">5698     {</span>
5699       if (_major_version &lt; JAVA_1_5_VERSION) {
5700         // Skip over the class name if one is there
5701         const char* const p = skip_over_field_name(signature + 1, true, --length);
5702 
5703         // The next character better be a semicolon
5704         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5705           return p + 1;
5706         }
5707       }
5708       else {
<span class="line-modified">5709         // Skip leading &#39;L&#39; or &#39;Q&#39; and ignore first appearance of &#39;;&#39;</span>
5710         signature++;
5711         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5712         // Format check signature
5713         if (c != NULL) {
5714           int newlen = c - (char*) signature;
5715           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5716           if (!legal) {
5717             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5718                                   &quot;in descriptor in class file %s&quot;,
5719                                   CHECK_NULL);
5720             return NULL;
5721           }
5722           return signature + newlen + 1;
5723         }
5724       }
5725       return NULL;
5726     }
5727     case JVM_SIGNATURE_ARRAY:
5728       array_dim++;
5729       if (array_dim &gt; 255) {
</pre>
<hr />
<pre>
5744 
5745 // Checks if name is a legal class name.
5746 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5747   if (!_need_verify || _relax_verify) { return; }
5748 
5749   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5750   char* bytes = (char*)name-&gt;bytes();
5751   unsigned int length = name-&gt;utf8_length();
5752   bool legal = false;
5753 
5754   if (length &gt; 0) {
5755     const char* p;
5756     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5757       p = skip_over_field_signature(bytes, false, length, CHECK);
5758       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5759     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5760       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5761         p = skip_over_field_name(bytes, true, length);
5762         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5763       }
<span class="line-added">5764     } else if (_major_version &gt;= CONSTANT_CLASS_DESCRIPTORS &amp;&amp; bytes[length - 1] == &#39;;&#39; ) {</span>
<span class="line-added">5765       // Support for L...; and Q...; descriptors</span>
<span class="line-added">5766       legal = verify_unqualified_name(bytes + 1, length - 2, LegalClass);</span>
5767     } else {
5768       // 4900761: relax the constraints based on JSR202 spec
5769       // Class names may be drawn from the entire Unicode character set.
5770       // Identifiers between &#39;/&#39; must be unqualified names.
5771       // The utf8 string has been verified when parsing cpool entries.
5772       legal = verify_unqualified_name(bytes, length, LegalClass);
5773     }
5774   }
5775   if (!legal) {
5776     ResourceMark rm(THREAD);
5777     assert(_class_name != NULL, &quot;invariant&quot;);
5778     Exceptions::fthrow(
5779       THREAD_AND_LOCATION,
5780       vmSymbols::java_lang_ClassFormatError(),
5781       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5782       _class_name-&gt;as_C_string()
5783     );
5784     return;
5785   }
5786 }
</pre>
<hr />
<pre>
5896   const char* nextp;
5897 
5898   // The first character must be a &#39;(&#39;
5899   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5900     length--;
5901     // Skip over legal field signatures
5902     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5903     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5904       args_size++;
5905       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5906         args_size++;
5907       }
5908       length -= nextp - p;
5909       p = nextp;
5910       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5911     }
5912     // The first non-signature thing better be a &#39;)&#39;
5913     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5914       length--;
5915       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">5916         // All constructor methods must return void</span>
5917         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5918           return args_size;
5919         }
<span class="line-added">5920         // All static init methods must return the current class</span>
<span class="line-added">5921         if ((length &gt;= 3) &amp;&amp; (p[length-1] == JVM_SIGNATURE_ENDCLASS)</span>
<span class="line-added">5922             &amp;&amp; name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">5923           nextp = skip_over_field_signature(p, true, length, CHECK_0);</span>
<span class="line-added">5924           if (nextp &amp;&amp; ((int)length == (nextp - p))) {</span>
<span class="line-added">5925             // The actual class will be checked against current class</span>
<span class="line-added">5926             // when the method is defined (see parse_method).</span>
<span class="line-added">5927             // A reference to a static init with a bad return type</span>
<span class="line-added">5928             // will load and verify OK, but will fail to link.</span>
<span class="line-added">5929             return args_size;</span>
<span class="line-added">5930           }</span>
<span class="line-added">5931         }</span>
<span class="line-added">5932         // The distinction between static factory methods and</span>
<span class="line-added">5933         // constructors depends on the JVM_ACC_STATIC modifier.</span>
<span class="line-added">5934         // This distinction must be reflected in a void or non-void</span>
<span class="line-added">5935         // return. For declared methods, the check is in parse_method.</span>
5936       } else {
5937         // Now we better just have a return value
5938         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5939         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5940           return args_size;
5941         }
5942       }
5943     }
5944   }
5945   // Report error
5946   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5947   return 0;
5948 }
5949 
5950 int ClassFileParser::static_field_size() const {
5951   assert(_field_info != NULL, &quot;invariant&quot;);
5952   return _field_info-&gt;_static_field_size;
5953 }
5954 
5955 int ClassFileParser::total_oop_map_count() const {
</pre>
<hr />
<pre>
6073 
6074 
6075   if (ik-&gt;should_store_fingerprint()) {
6076     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
6077   }
6078 
6079   ik-&gt;set_has_passed_fingerprint_check(false);
6080   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
6081     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
6082     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
6083     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
6084       // This class matches with a class saved in an AOT library
6085       ik-&gt;set_has_passed_fingerprint_check(true);
6086     } else {
6087       ResourceMark rm;
6088       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
6089                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
6090     }
6091   }
6092 
<span class="line-added">6093   if (ik-&gt;is_value()) {</span>
<span class="line-added">6094     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">6095     oop val = ik-&gt;allocate_instance(CHECK_NULL);</span>
<span class="line-added">6096     vk-&gt;set_default_value(val);</span>
<span class="line-added">6097   }</span>
<span class="line-added">6098 </span>
6099   return ik;
6100 }
6101 
<span class="line-added">6102 // Return true if the specified class is not a valid super class for an inline type.</span>
<span class="line-added">6103 // A valid super class for an inline type is abstract, has no instance fields,</span>
<span class="line-added">6104 // does not implement interface java.lang.IdentityObject (checked elsewhere), has</span>
<span class="line-added">6105 // an empty body-less no-arg constructor, and no synchronized instance methods.</span>
<span class="line-added">6106 // This function doesn&#39;t check if the class&#39;s super types are invalid.  Those checks</span>
<span class="line-added">6107 // are done elsewhere.  The final determination of whether or not a class is an</span>
<span class="line-added">6108 // invalid super type for an inline class is done in fill_instance_klass().</span>
<span class="line-added">6109 bool ClassFileParser::is_invalid_super_for_inline_type() {</span>
<span class="line-added">6110   if (class_name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">6111     return true;</span>
<span class="line-added">6112   }</span>
<span class="line-added">6113   if (is_interface() || class_name() == vmSymbols::java_lang_Object()) {</span>
<span class="line-added">6114     return false;</span>
<span class="line-added">6115   }</span>
<span class="line-added">6116   if (!access_flags().is_abstract() || _has_nonstatic_fields) {</span>
<span class="line-added">6117     return true;</span>
<span class="line-added">6118   } else {</span>
<span class="line-added">6119     // Look at each method</span>
<span class="line-added">6120     for (int x = 0; x &lt; _methods-&gt;length(); x++) {</span>
<span class="line-added">6121       const Method* const method = _methods-&gt;at(x);</span>
<span class="line-added">6122       if (method-&gt;is_synchronized() &amp;&amp; !method-&gt;is_static()) {</span>
<span class="line-added">6123         return true;</span>
<span class="line-added">6124 </span>
<span class="line-added">6125       } else if (method-&gt;name() == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">6126         if (method-&gt;signature() != vmSymbols::void_method_signature() ||</span>
<span class="line-added">6127             !method-&gt;is_vanilla_constructor()) {</span>
<span class="line-added">6128           return true;</span>
<span class="line-added">6129         }</span>
<span class="line-added">6130       }</span>
<span class="line-added">6131     }</span>
<span class="line-added">6132   }</span>
<span class="line-added">6133   return false;</span>
<span class="line-added">6134 }</span>
<span class="line-added">6135 </span>
6136 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
6137                                           bool changed_by_loadhook,
6138                                           const ClassInstanceInfo&amp; cl_inst_info,
6139                                           TRAPS) {
6140   assert(ik != NULL, &quot;invariant&quot;);
6141 
6142   // Set name and CLD before adding to CLD
6143   ik-&gt;set_class_loader_data(_loader_data);
6144   ik-&gt;set_name(_class_name);
6145 
6146   // Add all classes to our internal class loader list here,
6147   // including classes in the bootstrap (NULL) class loader.
6148   const bool publicize = !is_internal();
6149 
6150   _loader_data-&gt;add_class(ik, publicize);
6151 
6152   set_klass_to_deallocate(ik);
6153 
6154   assert(_field_info != NULL, &quot;invariant&quot;);
6155   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
6156   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
6157          &quot;sanity&quot;);
6158 
6159   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
6160   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
6161 
6162   // Fill in information already parsed
6163   ik-&gt;set_should_verify_class(_need_verify);
6164 
6165   // Not yet: supers are done below to support the new subtype-checking fields
6166   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
6167   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
<span class="line-added">6168   if (_field_info-&gt;_is_naturally_atomic &amp;&amp; ik-&gt;is_value()) {</span>
<span class="line-added">6169     ik-&gt;set_is_naturally_atomic();</span>
<span class="line-added">6170   }</span>
<span class="line-added">6171   if (_is_empty_inline_type) {</span>
<span class="line-added">6172     ik-&gt;set_is_empty_inline_type();</span>
<span class="line-added">6173   }</span>
<span class="line-added">6174 </span>
<span class="line-added">6175   if (this-&gt;_invalid_inline_super) {</span>
<span class="line-added">6176     ik-&gt;set_invalid_inline_super();</span>
<span class="line-added">6177   }</span>
<span class="line-added">6178 </span>
<span class="line-added">6179   if (_has_injected_identityObject) {</span>
<span class="line-added">6180     ik-&gt;set_has_injected_identityObject();</span>
<span class="line-added">6181   }</span>
<span class="line-added">6182 </span>
6183   assert(_fac != NULL, &quot;invariant&quot;);
<span class="line-modified">6184   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);</span>
6185 
6186   // this transfers ownership of a lot of arrays from
6187   // the parser onto the InstanceKlass*
6188   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6189 
6190   // can only set dynamic nest-host after static nest information is set
6191   if (cl_inst_info.dynamic_nest_host() != NULL) {
6192     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6193   }
6194 
6195   // note that is not safe to use the fields in the parser from this point on
6196   assert(NULL == _cp, &quot;invariant&quot;);
6197   assert(NULL == _fields, &quot;invariant&quot;);
6198   assert(NULL == _methods, &quot;invariant&quot;);
6199   assert(NULL == _inner_classes, &quot;invariant&quot;);
6200   assert(NULL == _nest_members, &quot;invariant&quot;);
6201   assert(NULL == _local_interfaces, &quot;invariant&quot;);
6202   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6203   assert(NULL == _record_components, &quot;invariant&quot;);
6204 
</pre>
<hr />
<pre>
6214   // has to be changed accordingly.
6215   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6216 
6217   ik-&gt;set_this_class_index(_this_class_index);
6218 
6219   if (_is_hidden || is_unsafe_anonymous()) {
6220     // _this_class_index is a CONSTANT_Class entry that refers to this
6221     // hidden or anonymous class itself. If this class needs to refer to its own
6222     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
6223     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
6224     // not stored in SystemDictionary), _this_class_index cannot be resolved
6225     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
6226     // Therefore, we must eagerly resolve _this_class_index now.
6227     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
6228   }
6229 
6230   ik-&gt;set_minor_version(_minor_version);
6231   ik-&gt;set_major_version(_major_version);
6232   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
6233   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
<span class="line-added">6234   if (_is_declared_atomic) {</span>
<span class="line-added">6235     ik-&gt;set_is_declared_atomic();</span>
<span class="line-added">6236   }</span>
6237 
6238   if (_unsafe_anonymous_host != NULL) {
6239     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
6240     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
6241   }
6242   if (_is_hidden) {
6243     ik-&gt;set_is_hidden();
6244   }
6245 
6246   // Set PackageEntry for this_klass
6247   oop cl = ik-&gt;class_loader();
6248   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
6249   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
6250   ik-&gt;set_package(cld, NULL, CHECK);
6251 
6252   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
6253   assert(methods != NULL, &quot;invariant&quot;);
6254   const int methods_len = methods-&gt;length();
6255 
6256   check_methods_for_intrinsics(ik, methods);
</pre>
<hr />
<pre>
6326 
6327   assert(_all_mirandas != NULL, &quot;invariant&quot;);
6328 
6329   // Generate any default methods - default methods are public interface methods
6330   // that have a default implementation.  This is new with Java 8.
6331   if (_has_nonstatic_concrete_methods) {
6332     DefaultMethods::generate_default_methods(ik,
6333                                              _all_mirandas,
6334                                              CHECK);
6335   }
6336 
6337   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
6338   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
6339       !module_entry-&gt;has_default_read_edges()) {
6340     if (!module_entry-&gt;set_has_default_read_edges()) {
6341       // We won a potential race
6342       JvmtiExport::add_default_read_edges(module_handle, THREAD);
6343     }
6344   }
6345 
<span class="line-added">6346   int nfields = ik-&gt;java_fields_count();</span>
<span class="line-added">6347   if (ik-&gt;is_value()) nfields++;</span>
<span class="line-added">6348   for (int i = 0; i &lt; nfields; i++) {</span>
<span class="line-added">6349     if (ik-&gt;field_is_flattenable(i)) {</span>
<span class="line-added">6350       Symbol* klass_name = ik-&gt;field_signature(i)-&gt;fundamental_name(CHECK);</span>
<span class="line-added">6351       // Inline classes for instance fields must have been pre-loaded</span>
<span class="line-added">6352       // Inline classes for static fields might not have been loaded yet</span>
<span class="line-added">6353       Klass* klass = SystemDictionary::find(klass_name,</span>
<span class="line-added">6354           Handle(THREAD, ik-&gt;class_loader()),</span>
<span class="line-added">6355           Handle(THREAD, ik-&gt;protection_domain()), CHECK);</span>
<span class="line-added">6356       if (klass != NULL) {</span>
<span class="line-added">6357         assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-added">6358         ik-&gt;set_value_field_klass(i, klass);</span>
<span class="line-added">6359       }</span>
<span class="line-added">6360       klass_name-&gt;decrement_refcount();</span>
<span class="line-added">6361     } else</span>
<span class="line-added">6362       if (is_inline_type() &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_FIELD_INTERNAL) != 0)</span>
<span class="line-added">6363         &amp;&amp; ((ik-&gt;field_access_flags(i) &amp; JVM_ACC_STATIC) != 0)) {</span>
<span class="line-added">6364       ValueKlass::cast(ik)-&gt;set_default_value_offset(ik-&gt;field_offset(i));</span>
<span class="line-added">6365     }</span>
<span class="line-added">6366   }</span>
<span class="line-added">6367 </span>
<span class="line-added">6368   if (is_inline_type()) {</span>
<span class="line-added">6369     ValueKlass* vk = ValueKlass::cast(ik);</span>
<span class="line-added">6370     if (UseNewFieldLayout) {</span>
<span class="line-added">6371       vk-&gt;set_alignment(_alignment);</span>
<span class="line-added">6372       vk-&gt;set_first_field_offset(_first_field_offset);</span>
<span class="line-added">6373       vk-&gt;set_exact_size_in_bytes(_exact_size_in_bytes);</span>
<span class="line-added">6374     } else {</span>
<span class="line-added">6375       vk-&gt;set_first_field_offset(vk-&gt;first_field_offset_old());</span>
<span class="line-added">6376     }</span>
<span class="line-added">6377     ValueKlass::cast(ik)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">6378   }</span>
<span class="line-added">6379 </span>
6380   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
6381 
6382   if (!is_internal()) {
6383     if (log_is_enabled(Info, class, load)) {
6384       ResourceMark rm;
6385       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
6386       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
6387     }
6388 
6389     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
6390         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
6391         log_is_enabled(Info, class, preview)) {
6392       ResourceMark rm;
6393       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
6394                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
6395     }
6396 
6397     if (log_is_enabled(Debug, class, resolve))  {
6398       ResourceMark rm;
6399       // print out the superclass.
</pre>
<hr />
<pre>
6409         const int length = local_interfaces-&gt;length();
6410         for (int i = 0; i &lt; length; i++) {
6411           const InstanceKlass* const k = local_interfaces-&gt;at(i);
6412           const char * to = k-&gt;external_name();
6413           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
6414         }
6415       }
6416     }
6417   }
6418 
6419   JFR_ONLY(INIT_ID(ik);)
6420 
6421   // If we reach here, all is well.
6422   // Now remove the InstanceKlass* from the _klass_to_deallocate field
6423   // in order for it to not be destroyed in the ClassFileParser destructor.
6424   set_klass_to_deallocate(NULL);
6425 
6426   // it&#39;s official
6427   set_klass(ik);
6428 
<span class="line-added">6429   if (ik-&gt;name() == vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">6430     Universe::initialize_the_single_IdentityObject_klass_array(ik, CHECK);</span>
<span class="line-added">6431   }</span>
<span class="line-added">6432 </span>
6433   debug_only(ik-&gt;verify();)
6434 }
6435 
6436 void ClassFileParser::update_class_name(Symbol* new_class_name) {
6437   // Decrement the refcount in the old name, since we&#39;re clobbering it.
6438   _class_name-&gt;decrement_refcount();
6439 
6440   _class_name = new_class_name;
6441   // Increment the refcount of the new name.
6442   // Now the ClassFileParser owns this name and will decrement in
6443   // the destructor.
6444   _class_name-&gt;increment_refcount();
6445 }
6446 
6447 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
6448 // package by prepending its host class&#39;s package name to its class name and setting
6449 // its _class_name field.
6450 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6451   ResourceMark rm(THREAD);
6452   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
</pre>
<hr />
<pre>
6514                                  TRAPS) :
6515   _stream(stream),
6516   _class_name(NULL),
6517   _loader_data(loader_data),
6518   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6519   _cp_patches(cl_info-&gt;cp_patches()),
6520   _is_hidden(cl_info-&gt;is_hidden()),
6521   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6522   _num_patched_klasses(0),
6523   _max_num_patched_klasses(0),
6524   _orig_cp_size(0),
6525   _first_patched_klass_resolved_index(0),
6526   _super_klass(),
6527   _cp(NULL),
6528   _fields(NULL),
6529   _methods(NULL),
6530   _inner_classes(NULL),
6531   _nest_members(NULL),
6532   _nest_host(0),
6533   _record_components(NULL),
<span class="line-added">6534   _temp_local_interfaces(NULL),</span>
6535   _local_interfaces(NULL),
6536   _transitive_interfaces(NULL),
6537   _combined_annotations(NULL),
6538   _class_annotations(NULL),
6539   _class_type_annotations(NULL),
6540   _fields_annotations(NULL),
6541   _fields_type_annotations(NULL),
6542   _klass(NULL),
6543   _klass_to_deallocate(NULL),
6544   _parsed_annotations(NULL),
6545   _fac(NULL),
6546   _field_info(NULL),
6547   _method_ordering(NULL),
6548   _all_mirandas(NULL),
6549   _vtable_size(0),
6550   _itable_size(0),
6551   _num_miranda_methods(0),
6552   _rt(REF_NONE),
6553   _protection_domain(cl_info-&gt;protection_domain()),
6554   _access_flags(),
6555   _pub_level(pub_level),
6556   _bad_constant_seen(0),
6557   _synthetic_flag(false),
6558   _sde_length(false),
6559   _sde_buffer(NULL),
6560   _sourcefile_index(0),
6561   _generic_signature_index(0),
6562   _major_version(0),
6563   _minor_version(0),
6564   _this_class_index(0),
6565   _super_class_index(0),
6566   _itfs_len(0),
6567   _java_fields_count(0),
6568   _need_verify(false),
6569   _relax_verify(false),
6570   _has_nonstatic_concrete_methods(false),
6571   _declares_nonstatic_concrete_methods(false),
6572   _has_final_method(false),
6573   _has_contended_fields(false),
<span class="line-added">6574   _has_flattenable_fields(false),</span>
<span class="line-added">6575   _has_nonstatic_fields(false),</span>
<span class="line-added">6576   _is_empty_inline_type(false),</span>
<span class="line-added">6577   _is_naturally_atomic(false),</span>
<span class="line-added">6578   _is_declared_atomic(false),</span>
<span class="line-added">6579   _invalid_inline_super(false),</span>
<span class="line-added">6580   _invalid_identity_super(false),</span>
<span class="line-added">6581   _implements_identityObject(false),</span>
<span class="line-added">6582   _has_injected_identityObject(false),</span>
6583   _has_finalizer(false),
6584   _has_empty_finalizer(false),
6585   _has_vanilla_constructor(false),
6586   _max_bootstrap_specifier_index(-1) {
6587 
6588   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6589   _class_name-&gt;increment_refcount();
6590 
6591   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6592   assert(_loader_data != NULL, &quot;invariant&quot;);
6593   assert(stream != NULL, &quot;invariant&quot;);
6594   assert(_stream != NULL, &quot;invariant&quot;);
6595   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6596   assert(_class_name != NULL, &quot;invariant&quot;);
6597   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6598 
6599   // Figure out whether we can skip format checking (matching classic VM behavior)
6600   if (DumpSharedSpaces) {
6601     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6602     // Verification decision is based on BytecodeVerificationRemote flag
</pre>
<hr />
<pre>
6768   } else {
6769     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6770       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6771     }
6772     cp_size += _max_num_patched_klasses;
6773   }
6774 
6775   _cp = ConstantPool::allocate(_loader_data,
6776                                cp_size,
6777                                CHECK);
6778 
6779   ConstantPool* const cp = _cp;
6780 
6781   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6782 
6783   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6784 
6785   // ACCESS FLAGS
6786   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6787 
<span class="line-modified">6788   jint recognized_modifiers = JVM_RECOGNIZED_CLASS_MODIFIERS;</span>

6789   // JVM_ACC_MODULE is defined in JDK-9 and later.
6790   if (_major_version &gt;= JAVA_9_VERSION) {
<span class="line-modified">6791     recognized_modifiers |= JVM_ACC_MODULE;</span>
<span class="line-modified">6792   }</span>
<span class="line-modified">6793   // JVM_ACC_VALUE is defined for class file version 55 and later</span>
<span class="line-added">6794   if (supports_inline_types()) {</span>
<span class="line-added">6795     recognized_modifiers |= JVM_ACC_VALUE;</span>
6796   }
6797 
<span class="line-added">6798   // Access flags</span>
<span class="line-added">6799   jint flags = stream-&gt;get_u2_fast() &amp; recognized_modifiers;</span>
<span class="line-added">6800 </span>
6801   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6802     // Set abstract bit for old class files for backward compatibility
6803     flags |= JVM_ACC_ABSTRACT;
6804   }
6805 
6806   verify_legal_class_modifiers(flags, CHECK);
6807 
6808   short bad_constant = class_bad_constant_seen();
6809   if (bad_constant != 0) {
6810     // Do not throw CFE until after the access_flags are checked because if
6811     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6812     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6813   }
6814 
6815   _access_flags.set_flags(flags);
6816 
6817   // This class and superclass
6818   _this_class_index = stream-&gt;get_u2_fast();
6819   check_property(
6820     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
</pre>
<hr />
<pre>
6938           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6939           classlist_file-&gt;flush();
6940         }
6941       }
6942     }
6943 #endif
6944   }
6945 
6946   // SUPERKLASS
6947   _super_class_index = stream-&gt;get_u2_fast();
6948   _super_klass = parse_super_class(cp,
6949                                    _super_class_index,
6950                                    _need_verify,
6951                                    CHECK);
6952 
6953   // Interfaces
6954   _itfs_len = stream-&gt;get_u2_fast();
6955   parse_interfaces(stream,
6956                    _itfs_len,
6957                    cp,
<span class="line-added">6958                    is_inline_type(),</span>
6959                    &amp;_has_nonstatic_concrete_methods,
<span class="line-added">6960                    &amp;_is_declared_atomic,</span>
6961                    CHECK);
6962 
<span class="line-modified">6963   assert(_temp_local_interfaces != NULL, &quot;invariant&quot;);</span>
6964 
6965   // Fields (offsets are filled in later)
6966   _fac = new FieldAllocationCount();
6967   parse_fields(stream,
<span class="line-modified">6968                is_interface(),</span>
<span class="line-added">6969                is_inline_type(),</span>
6970                _fac,
6971                cp,
6972                cp_size,
6973                &amp;_java_fields_count,
6974                CHECK);
6975 
6976   assert(_fields != NULL, &quot;invariant&quot;);
6977 
6978   // Methods
6979   AccessFlags promoted_flags;
6980   parse_methods(stream,
<span class="line-modified">6981                 is_interface(),</span>
<span class="line-added">6982                 is_inline_type(),</span>
6983                 &amp;promoted_flags,
6984                 &amp;_has_final_method,
6985                 &amp;_declares_nonstatic_concrete_methods,
6986                 CHECK);
6987 
6988   assert(_methods != NULL, &quot;invariant&quot;);
6989 
6990   // promote flags from parse_methods() to the klass&#39; flags
6991   _access_flags.add_promoted_flags(promoted_flags.as_int());
6992 
6993   if (_declares_nonstatic_concrete_methods) {
6994     _has_nonstatic_concrete_methods = true;
6995   }
6996 
6997   // Additional attributes/annotations
6998   _parsed_annotations = new ClassAnnotationCollector();
6999   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
7000 
7001   assert(_inner_classes != NULL, &quot;invariant&quot;);
7002 
</pre>
<hr />
<pre>
7033 
7034   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
7035   // We have to update the resolved_klass_index and the name_index together
7036   // so extract the existing resolved_klass_index first.
7037   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
7038   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
7039   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
7040   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
7041          &quot;Bad name_index&quot;);
7042 }
7043 
7044 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
7045                                                  ConstantPool* cp,
7046                                                  TRAPS) {
7047   assert(stream != NULL, &quot;invariant&quot;);
7048   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
7049   assert(cp != NULL, &quot;invariant&quot;);
7050   assert(_loader_data != NULL, &quot;invariant&quot;);
7051 
7052   if (_class_name == vmSymbols::java_lang_Object()) {
<span class="line-modified">7053     check_property(_temp_local_interfaces-&gt;length() == 0,</span>
<span class="line-modified">7054         &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">7055         CHECK);</span>
7056   }
7057   // We check super class after class file is parsed and format is checked
7058   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
7059     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<span class="line-modified">7060     if (is_interface()) {</span>
7061       // Before attempting to resolve the superclass, check for class format
7062       // errors not checked yet.
7063       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
7064         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
7065         CHECK);
7066     }
7067     Handle loader(THREAD, _loader_data-&gt;class_loader());
7068     _super_klass = (const InstanceKlass*)
7069                        SystemDictionary::resolve_super_or_fail(_class_name,
7070                                                                super_class_name,
7071                                                                loader,
7072                                                                _protection_domain,
7073                                                                true,
7074                                                                CHECK);
7075   }
7076 
7077   if (_super_klass != NULL) {
7078     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
7079       _has_nonstatic_concrete_methods = true;
7080     }
<span class="line-added">7081     if (_super_klass-&gt;is_declared_atomic()) {</span>
<span class="line-added">7082       _is_declared_atomic = true;</span>
<span class="line-added">7083     }</span>
7084 
7085     if (_super_klass-&gt;is_interface()) {
7086       ResourceMark rm(THREAD);
7087       Exceptions::fthrow(
7088         THREAD_AND_LOCATION,
7089         vmSymbols::java_lang_IncompatibleClassChangeError(),
7090         &quot;class %s has interface %s as super class&quot;,
7091         _class_name-&gt;as_klass_external_name(),
7092         _super_klass-&gt;external_name()
7093       );
7094       return;
7095     }
<span class="line-added">7096 </span>
7097     // Make sure super class is not final
7098     if (_super_klass-&gt;is_final()) {
7099       THROW_MSG(vmSymbols::java_lang_VerifyError(), &quot;Cannot inherit from final class&quot;);
7100     }
<span class="line-added">7101 </span>
<span class="line-added">7102     // For an inline class, only java/lang/Object or special abstract classes</span>
<span class="line-added">7103     // are acceptable super classes.</span>
<span class="line-added">7104     if (is_inline_type()) {</span>
<span class="line-added">7105       const InstanceKlass* super_ik = _super_klass;</span>
<span class="line-added">7106       if (super_ik-&gt;invalid_inline_super()) {</span>
<span class="line-added">7107         ResourceMark rm(THREAD);</span>
<span class="line-added">7108         Exceptions::fthrow(</span>
<span class="line-added">7109           THREAD_AND_LOCATION,</span>
<span class="line-added">7110           vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">7111           &quot;inline class %s has an invalid super class %s&quot;,</span>
<span class="line-added">7112           _class_name-&gt;as_klass_external_name(),</span>
<span class="line-added">7113           _super_klass-&gt;external_name());</span>
<span class="line-added">7114         return;</span>
<span class="line-added">7115       }</span>
<span class="line-added">7116     }</span>
<span class="line-added">7117   }</span>
<span class="line-added">7118 </span>
<span class="line-added">7119   if (_class_name == vmSymbols::java_lang_NonTearable() &amp;&amp; _loader_data-&gt;class_loader() == NULL) {</span>
<span class="line-added">7120     // This is the original source of this condition.</span>
<span class="line-added">7121     // It propagates by inheritance, as if testing &quot;instanceof NonTearable&quot;.</span>
<span class="line-added">7122     _is_declared_atomic = true;</span>
<span class="line-added">7123   } else if (*ForceNonTearable != &#39;\0&#39;) {</span>
<span class="line-added">7124     // Allow a command line switch to force the same atomicity property:</span>
<span class="line-added">7125     const char* class_name_str = _class_name-&gt;as_C_string();</span>
<span class="line-added">7126     if (StringUtils::class_list_match(ForceNonTearable, class_name_str)) {</span>
<span class="line-added">7127       _is_declared_atomic = true;</span>
<span class="line-added">7128     }</span>
<span class="line-added">7129   }</span>
<span class="line-added">7130 </span>
<span class="line-added">7131   // Set ik-&gt;invalid_inline_super field to TRUE if already marked as invalid,</span>
<span class="line-added">7132   // if super is marked invalid, or if is_invalid_super_for_inline_type()</span>
<span class="line-added">7133   // returns true</span>
<span class="line-added">7134   if (invalid_inline_super() ||</span>
<span class="line-added">7135       (_super_klass != NULL &amp;&amp; _super_klass-&gt;invalid_inline_super()) ||</span>
<span class="line-added">7136       is_invalid_super_for_inline_type()) {</span>
<span class="line-added">7137     set_invalid_inline_super();</span>
<span class="line-added">7138   }</span>
<span class="line-added">7139 </span>
<span class="line-added">7140   if (!is_inline_type() &amp;&amp; invalid_inline_super() &amp;&amp; (_super_klass == NULL || !_super_klass-&gt;invalid_inline_super())</span>
<span class="line-added">7141       &amp;&amp; !_implements_identityObject &amp;&amp; class_name() != vmSymbols::java_lang_IdentityObject()) {</span>
<span class="line-added">7142     _temp_local_interfaces-&gt;append(SystemDictionary::IdentityObject_klass());</span>
<span class="line-added">7143     _has_injected_identityObject = true;</span>
<span class="line-added">7144   }</span>
<span class="line-added">7145   int itfs_len = _temp_local_interfaces-&gt;length();</span>
<span class="line-added">7146   if (itfs_len == 0) {</span>
<span class="line-added">7147     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
<span class="line-added">7148   } else if (itfs_len == 1 &amp;&amp; _temp_local_interfaces-&gt;at(0) == SystemDictionary::IdentityObject_klass()) {</span>
<span class="line-added">7149     _local_interfaces = Universe::the_single_IdentityObject_klass_array();</span>
<span class="line-added">7150   } else {</span>
<span class="line-added">7151     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-added">7152     for (int i = 0; i &lt; itfs_len; i++) {</span>
<span class="line-added">7153       _local_interfaces-&gt;at_put(i, _temp_local_interfaces-&gt;at(i));</span>
<span class="line-added">7154     }</span>
7155   }
<span class="line-added">7156   _temp_local_interfaces = NULL;</span>
<span class="line-added">7157   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
7158 
7159   // Compute the transitive list of all unique interfaces implemented by this class
7160   _transitive_interfaces =
7161     compute_transitive_interfaces(_super_klass,
7162                                   _local_interfaces,
7163                                   _loader_data,
7164                                   CHECK);
7165 
7166   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
7167 
7168   // sort methods
7169   _method_ordering = sort_methods(_methods);
7170 
7171   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
7172 
7173   Handle loader(THREAD, _loader_data-&gt;class_loader());
7174   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
7175                                                     &amp;_num_miranda_methods,
7176                                                     _all_mirandas,
7177                                                     _super_klass,
7178                                                     _methods,
7179                                                     _access_flags,
7180                                                     _major_version,
7181                                                     loader,
7182                                                     _class_name,
7183                                                     _local_interfaces,
7184                                                     CHECK);
7185 
7186   // Size of Java itable (in words)
<span class="line-modified">7187   _itable_size = is_interface() ? 0 :</span>
7188     klassItable::compute_itable_size(_transitive_interfaces);
7189 
7190   assert(_fac != NULL, &quot;invariant&quot;);
7191   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
7192 
<span class="line-added">7193 </span>
<span class="line-added">7194   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {</span>
<span class="line-added">7195     if (fs.is_flattenable() &amp;&amp; !fs.access_flags().is_static()) {</span>
<span class="line-added">7196       // Pre-load value class</span>
<span class="line-added">7197       Klass* klass = SystemDictionary::resolve_flattenable_field_or_fail(&amp;fs,</span>
<span class="line-added">7198           Handle(THREAD, _loader_data-&gt;class_loader()),</span>
<span class="line-added">7199           _protection_domain, true, CHECK);</span>
<span class="line-added">7200       assert(klass != NULL, &quot;Sanity check&quot;);</span>
<span class="line-added">7201       assert(klass-&gt;access_flags().is_inline_type(), &quot;Inline type expected&quot;);</span>
<span class="line-added">7202       _has_flattenable_fields = true;</span>
<span class="line-added">7203     }</span>
<span class="line-added">7204   }</span>
<span class="line-added">7205 </span>
7206   _field_info = new FieldLayoutInfo();
7207   if (UseNewFieldLayout) {
7208     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<span class="line-modified">7209         _parsed_annotations-&gt;is_contended(), is_inline_type(),</span>
<span class="line-modified">7210         loader_data(), _protection_domain, _field_info);</span>
<span class="line-added">7211     lb.build_layout(CHECK);</span>
<span class="line-added">7212     if (is_inline_type()) {</span>
<span class="line-added">7213       _alignment = lb.get_alignment();</span>
<span class="line-added">7214       _first_field_offset = lb.get_first_field_offset();</span>
<span class="line-added">7215       _exact_size_in_bytes = lb.get_exact_size_in_byte();</span>
<span class="line-added">7216     }</span>
7217   } else {
7218     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
7219   }
7220 
<span class="line-modified">7221   // Compute reference type</span>
7222   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();

7223 }
7224 
7225 void ClassFileParser::set_klass(InstanceKlass* klass) {
7226 
7227 #ifdef ASSERT
7228   if (klass != NULL) {
7229     assert(NULL == _klass, &quot;leaking?&quot;);
7230   }
7231 #endif
7232 
7233   _klass = klass;
7234 }
7235 
7236 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
7237 
7238 #ifdef ASSERT
7239   if (klass != NULL) {
7240     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
7241   }
7242 #endif
7243 
7244   _klass_to_deallocate = klass;
7245 }
7246 
7247 // Caller responsible for ResourceMark
7248 // clone stream with rewound position
7249 const ClassFileStream* ClassFileParser::clone_stream() const {
7250   assert(_stream != NULL, &quot;invariant&quot;);
7251 
7252   return _stream-&gt;clone();
7253 }
<span class="line-added">7254 </span>
7255 // ----------------------------------------------------------------------------
7256 // debugging
7257 
7258 #ifdef ASSERT
7259 
7260 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
7261 bool ClassFileParser::is_internal_format(Symbol* class_name) {
7262   if (class_name != NULL) {
7263     ResourceMark rm;
7264     char* name = class_name-&gt;as_C_string();
7265     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
7266   } else {
7267     return true;
7268   }
7269 }
7270 
7271 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../ci/ciInstanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classFileParser.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
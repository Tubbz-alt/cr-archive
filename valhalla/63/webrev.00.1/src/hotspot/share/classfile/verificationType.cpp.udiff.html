<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/classfile/verificationType.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verificationType.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -58,19 +58,22 @@</span>
      if (log_is_enabled(Debug, class, resolve)) {
        Verifier::trace_class_resolution(this_class, klass);
      }
    }
  
<span class="udiff-line-added">+   if (this_class-&gt;access_flags().is_inline_type()) return false;</span>
    if (this_class-&gt;is_interface() &amp;&amp; (!from_field_is_protected ||
        from_name != vmSymbols::java_lang_Object())) {
      // If we are not trying to access a protected field or method in
      // java.lang.Object then, for arrays, we only allow assignability
<span class="udiff-line-modified-removed">-     // to interfaces java.lang.Cloneable and java.io.Serializable.</span>
<span class="udiff-line-modified-added">+     // to interfaces java.lang.Cloneable, java.io.Serializable,</span>
<span class="udiff-line-added">+     // and java.lang.IdentityObject.</span>
      // Otherwise, we treat interfaces as java.lang.Object.
      return !from_is_array ||
        this_class == SystemDictionary::Cloneable_klass() ||
<span class="udiff-line-modified-removed">-       this_class == SystemDictionary::Serializable_klass();</span>
<span class="udiff-line-modified-added">+       this_class == SystemDictionary::Serializable_klass() ||</span>
<span class="udiff-line-added">+       this_class == SystemDictionary::IdentityObject_klass();</span>
    } else if (from_is_object) {
      Klass* from_class;
      if (klass-&gt;is_hidden() &amp;&amp; klass-&gt;name() == from_name) {
        from_class = klass;
      } else {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -118,18 +121,86 @@</span>
      return resolve_and_check_assignability(klass, name(), from.name(),
            from_field_is_protected, from.is_array(), from.is_object(), THREAD);
    } else if (is_array() &amp;&amp; from.is_array()) {
      VerificationType comp_this = get_component(context, CHECK_false);
      VerificationType comp_from = from.get_component(context, CHECK_false);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /*</span>
<span class="udiff-line-added">+     // This code implements non-covariance between value type arrays and both</span>
<span class="udiff-line-added">+     // arrays of objects and arrays of interface types.  If covariance is</span>
<span class="udiff-line-added">+     // supported for value type arrays then this code should be removed.</span>
<span class="udiff-line-added">+     if (comp_from.is_valuetype() &amp;&amp; !comp_this.is_null() &amp;&amp; comp_this.is_reference()) {</span>
<span class="udiff-line-added">+       // An array of value types is not assignable to an array of java.lang.Objects.</span>
<span class="udiff-line-added">+       if (comp_this.name() == vmSymbols::java_lang_Object()) {</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       // Need to load &#39;comp_this&#39; to see if it is an interface.</span>
<span class="udiff-line-added">+       InstanceKlass* klass = context-&gt;current_class();</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         HandleMark hm(THREAD);</span>
<span class="udiff-line-added">+         Klass* comp_this_class = SystemDictionary::resolve_or_fail(</span>
<span class="udiff-line-added">+             comp_this.name(), Handle(THREAD, klass-&gt;class_loader()),</span>
<span class="udiff-line-added">+             Handle(THREAD, klass-&gt;protection_domain()), true, CHECK_false);</span>
<span class="udiff-line-added">+         klass-&gt;class_loader_data()-&gt;record_dependency(comp_this_class);</span>
<span class="udiff-line-added">+         if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="udiff-line-added">+           Verifier::trace_class_resolution(comp_this_class, klass);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         // An array of value types is not assignable to an array of interface types.</span>
<span class="udiff-line-added">+         if (comp_this_class-&gt;is_interface()) {</span>
<span class="udiff-line-added">+           return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ */</span>
      if (!comp_this.is_bogus() &amp;&amp; !comp_from.is_bogus()) {
        return comp_this.is_component_assignable_from(comp_from, context,
                                                      from_field_is_protected, THREAD);
      }
    }
    return false;
  }
  
<span class="udiff-line-added">+ bool VerificationType::is_valuetype_assignable_from(const VerificationType&amp; from) const {</span>
<span class="udiff-line-added">+   // Check that &#39;from&#39; is not null, is a value type, and is the same value type.</span>
<span class="udiff-line-added">+   assert(is_valuetype(), &quot;called with a non-valuetype type&quot;);</span>
<span class="udiff-line-added">+   assert(!is_null(), &quot;valuetype is not null&quot;);</span>
<span class="udiff-line-added">+   return (!from.is_null() &amp;&amp; from.is_valuetype() &amp;&amp; name() == from.name());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool VerificationType::is_ref_assignable_from_value_type(const VerificationType&amp; from, ClassVerifier* context, TRAPS) const {</span>
<span class="udiff-line-added">+   assert(!from.is_null(), &quot;Value type should not be null&quot;);</span>
<span class="udiff-line-added">+   if (!is_null() &amp;&amp; (name()-&gt;is_same_fundamental_type(from.name()) ||</span>
<span class="udiff-line-added">+       name() == vmSymbols::java_lang_Object())) {</span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Need to load &#39;this&#39; to see if it is an interface or supertype.</span>
<span class="udiff-line-added">+   InstanceKlass* klass = context-&gt;current_class();</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     HandleMark hm(THREAD);</span>
<span class="udiff-line-added">+     Klass* this_class = SystemDictionary::resolve_or_fail(</span>
<span class="udiff-line-added">+         name(), Handle(THREAD, klass-&gt;class_loader()),</span>
<span class="udiff-line-added">+         Handle(THREAD, klass-&gt;protection_domain()), true, CHECK_false);</span>
<span class="udiff-line-added">+     klass-&gt;class_loader_data()-&gt;record_dependency(this_class);</span>
<span class="udiff-line-added">+     if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="udiff-line-added">+       Verifier::trace_class_resolution(this_class, klass);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (this_class-&gt;is_interface()) {</span>
<span class="udiff-line-added">+       return true;</span>
<span class="udiff-line-added">+     } else {</span>
<span class="udiff-line-added">+       Klass* from_class = SystemDictionary::resolve_or_fail(</span>
<span class="udiff-line-added">+         from.name(), Handle(THREAD, klass-&gt;class_loader()),</span>
<span class="udiff-line-added">+         Handle(THREAD, klass-&gt;protection_domain()), true, CHECK_false);</span>
<span class="udiff-line-added">+       if (log_is_enabled(Debug, class, resolve)) {</span>
<span class="udiff-line-added">+         Verifier::trace_class_resolution(from_class, klass);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       return from_class-&gt;is_subclass_of(this_class);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  VerificationType VerificationType::get_component(ClassVerifier *context, TRAPS) const {
    assert(is_array() &amp;&amp; name()-&gt;utf8_length() &gt;= 2, &quot;Must be a valid array&quot;);
    SignatureStream ss(name(), false);
    ss.skip_array_prefix(1);
    switch (ss.type()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -140,17 +211,20 @@</span>
      case T_INT:     return VerificationType(Integer);
      case T_LONG:    return VerificationType(Long);
      case T_FLOAT:   return VerificationType(Float);
      case T_DOUBLE:  return VerificationType(Double);
      case T_ARRAY:
<span class="udiff-line-modified-removed">-     case T_OBJECT: {</span>
<span class="udiff-line-modified-added">+     case T_OBJECT:</span>
<span class="udiff-line-added">+     case T_VALUETYPE: {</span>
        guarantee(ss.is_reference(), &quot;unchecked verifier input?&quot;);
        Symbol* component = ss.as_symbol();
        // Create another symbol to save as signature stream unreferences this symbol.
        Symbol* component_copy = context-&gt;create_temporary_symbol(component);
        assert(component_copy == component, &quot;symbols don&#39;t match&quot;);
<span class="udiff-line-modified-removed">-       return VerificationType::reference_type(component_copy);</span>
<span class="udiff-line-modified-added">+       return (ss.type() == T_VALUETYPE) ?</span>
<span class="udiff-line-added">+         VerificationType::valuetype_type(component_copy) :</span>
<span class="udiff-line-added">+         VerificationType::reference_type(component_copy);</span>
     }
     default:
       // Met an invalid type signature, e.g. [X
       return VerificationType::bogus_type();
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -172,18 +246,22 @@</span>
      case Double:           st-&gt;print(&quot;double&quot;); break;
      case Long_2nd:         st-&gt;print(&quot;long_2nd&quot;); break;
      case Double_2nd:       st-&gt;print(&quot;double_2nd&quot;); break;
      case Null:             st-&gt;print(&quot;null&quot;); break;
      case ReferenceQuery:   st-&gt;print(&quot;reference type&quot;); break;
<span class="udiff-line-added">+     case ValueTypeQuery:   st-&gt;print(&quot;inline type&quot;); break;</span>
<span class="udiff-line-added">+     case NonScalarQuery:   st-&gt;print(&quot;reference or inline type&quot;); break;</span>
      case Category1Query:   st-&gt;print(&quot;category1 type&quot;); break;
      case Category2Query:   st-&gt;print(&quot;category2 type&quot;); break;
      case Category2_2ndQuery: st-&gt;print(&quot;category2_2nd type&quot;); break;
      default:
        if (is_uninitialized_this()) {
          st-&gt;print(&quot;uninitializedThis&quot;);
        } else if (is_uninitialized()) {
          st-&gt;print(&quot;uninitialized %d&quot;, bci());
<span class="udiff-line-added">+       } else if (is_valuetype()) {</span>
<span class="udiff-line-added">+         name()-&gt;print_Qvalue_on(st);</span>
        } else {
          if (name() != NULL) {
            name()-&gt;print_value_on(st);
          } else {
            st-&gt;print_cr(&quot;NULL&quot;);
</pre>
<center><a href="systemDictionary.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="verifier.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
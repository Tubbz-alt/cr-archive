<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/verifier.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verificationType.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;oops/typeArrayOop.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;
  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/thread.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/bytes.hpp&quot;
  59 
  60 #define NOFAILOVER_MAJOR_VERSION                       51
  61 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  62 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52

  63 #define MAX_ARRAY_DIMENSIONS 255
  64 
  65 // Access to external entry for VerifyClassForMajorVersion - old byte code verifier
  66 
  67 extern &quot;C&quot; {
  68   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);
  69 }
  70 
  71 static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;
  72 
  73 static verify_byte_codes_fn_t verify_byte_codes_fn() {
  74 
  75   if (_verify_byte_codes_fn != NULL)
  76     return _verify_byte_codes_fn;
  77 
  78   MutexLocker locker(Verify_lock);
  79 
  80   if (_verify_byte_codes_fn != NULL)
  81     return _verify_byte_codes_fn;
  82 
</pre>
<hr />
<pre>
 247       }
 248       kls = kls-&gt;super();
 249     }
 250     if (message_buffer != NULL) {
 251       message_buffer[message_buffer_len - 1] = &#39;\0&#39;; // just to be sure
 252     }
 253     assert(exception_message != NULL, &quot;&quot;);
 254     THROW_MSG_(exception_name, exception_message, false);
 255   }
 256 }
 257 
 258 bool Verifier::is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class) {
 259   Symbol* name = klass-&gt;name();
 260   Klass* refl_magic_klass = SystemDictionary::reflect_MagicAccessorImpl_klass();
 261 
 262   bool is_reflect = refl_magic_klass != NULL &amp;&amp; klass-&gt;is_subtype_of(refl_magic_klass);
 263 
 264   return (should_verify_for(klass-&gt;class_loader(), should_verify_class) &amp;&amp;
 265     // return if the class is a bootstrapping class
 266     // or defineClass specified not to verify by default (flags override passed arg)
<span class="line-modified"> 267     // We need to skip the following four for bootstraping</span>
 268     name != vmSymbols::java_lang_Object() &amp;&amp;
 269     name != vmSymbols::java_lang_Class() &amp;&amp;
 270     name != vmSymbols::java_lang_String() &amp;&amp;
 271     name != vmSymbols::java_lang_Throwable() &amp;&amp;
 272 
 273     // Can not verify the bytecodes for shared classes because they have
 274     // already been rewritten to contain constant pool cache indices,
 275     // which the verifier can&#39;t understand.
 276     // Shared classes shouldn&#39;t have stackmaps either.
 277     !klass-&gt;is_shared() &amp;&amp;
 278 
 279     // As of the fix for 4486457 we disable verification for all of the
 280     // dynamically-generated bytecodes associated with the 1.4
 281     // reflection implementation, not just those associated with
 282     // jdk/internal/reflect/SerializationConstructorAccessor.
 283     // NOTE: this is called too early in the bootstrapping process to be
 284     // guarded by Universe::is_gte_jdk14x_version().
 285     // Also for lambda generated code, gte jdk8
 286     (!is_reflect));
 287 }
</pre>
<hr />
<pre>
 469       ss-&gt;print(&quot;Local index %d is invalid&quot;, _type.index());
 470       break;
 471     case LOCALS_SIZE_MISMATCH:
 472       ss-&gt;print(&quot;Current frame&#39;s local size doesn&#39;t match stackmap.&quot;);
 473       break;
 474     case STACK_SIZE_MISMATCH:
 475       ss-&gt;print(&quot;Current frame&#39;s stack size doesn&#39;t match stackmap.&quot;);
 476       break;
 477     case STACK_OVERFLOW:
 478       ss-&gt;print(&quot;Exceeded max stack size.&quot;);
 479       break;
 480     case STACK_UNDERFLOW:
 481       ss-&gt;print(&quot;Attempt to pop empty stack.&quot;);
 482       break;
 483     case MISSING_STACKMAP:
 484       ss-&gt;print(&quot;Expected stackmap frame at this location.&quot;);
 485       break;
 486     case BAD_STACKMAP:
 487       ss-&gt;print(&quot;Invalid stackmap specification.&quot;);
 488       break;







 489     case UNKNOWN:
 490     default:
 491       ShouldNotReachHere();
 492       ss-&gt;print_cr(&quot;Unknown&quot;);
 493   }
 494   ss-&gt;cr();
 495 }
 496 
 497 void ErrorContext::location_details(outputStream* ss, const Method* method) const {
 498   if (_bci != -1 &amp;&amp; method != NULL) {
 499     streamIndentor si(ss);
 500     const char* bytecode_name = &quot;&lt;invalid&gt;&quot;;
 501     if (method-&gt;validate_bci(_bci) != -1) {
 502       Bytecodes::Code code = Bytecodes::code_or_bp_at(method-&gt;bcp_from(_bci));
 503       if (Bytecodes::is_defined(code)) {
 504           bytecode_name = Bytecodes::name(code);
 505       } else {
 506           bytecode_name = &quot;&lt;illegal&gt;&quot;;
 507       }
 508     }
</pre>
<hr />
<pre>
 563     stack_map_frame* sm_frame = sm_table-&gt;entries();
 564     streamIndentor si2(ss);
 565     int current_offset = -1;
 566     address end_of_sm_table = (address)sm_table + method-&gt;stackmap_data()-&gt;length();
 567     for (u2 i = 0; i &lt; sm_table-&gt;number_of_entries(); ++i) {
 568       ss-&gt;indent();
 569       if (!sm_frame-&gt;verify((address)sm_frame, end_of_sm_table)) {
 570         sm_frame-&gt;print_truncated(ss, current_offset);
 571         return;
 572       }
 573       sm_frame-&gt;print_on(ss, current_offset);
 574       ss-&gt;cr();
 575       current_offset += sm_frame-&gt;offset_delta();
 576       sm_frame = sm_frame-&gt;next();
 577     }
 578   }
 579 }
 580 
 581 // Methods in ClassVerifier
 582 








 583 ClassVerifier::ClassVerifier(
 584     InstanceKlass* klass, TRAPS)
 585     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
 586       _message(NULL), _method_signatures_table(NULL), _klass(klass) {
<span class="line-modified"> 587   _this_type = VerificationType::reference_type(klass-&gt;name());</span>
 588 }
 589 
 590 ClassVerifier::~ClassVerifier() {
 591   // Decrement the reference count for any symbols created.
 592   if (_symbols != NULL) {
 593     for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
 594       Symbol* s = _symbols-&gt;at(i);
 595       s-&gt;decrement_refcount();
 596     }
 597   }
 598 }
 599 
 600 VerificationType ClassVerifier::object_type() const {
 601   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 602 }
 603 
 604 TypeOrigin ClassVerifier::ref_ctx(const char* sig) {
 605   VerificationType vt = VerificationType::reference_type(
 606                          create_temporary_symbol(sig, (int)strlen(sig)));
 607   return TypeOrigin::implicit(vt);
</pre>
<hr />
<pre>
1012         case Bytecodes::_daload :
1013           type = current_frame.pop_stack(
1014             VerificationType::integer_type(), CHECK_VERIFY(this));
1015           atype = current_frame.pop_stack(
1016             VerificationType::reference_check(), CHECK_VERIFY(this));
1017           if (!atype.is_double_array()) {
1018             verify_error(ErrorContext::bad_type(bci,
1019                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),
1020                 bad_type_msg, &quot;daload&quot;);
1021             return;
1022           }
1023           current_frame.push_stack_2(
1024             VerificationType::double_type(),
1025             VerificationType::double2_type(), CHECK_VERIFY(this));
1026           no_control_flow = false; break;
1027         case Bytecodes::_aaload : {
1028           type = current_frame.pop_stack(
1029             VerificationType::integer_type(), CHECK_VERIFY(this));
1030           atype = current_frame.pop_stack(
1031             VerificationType::reference_check(), CHECK_VERIFY(this));
<span class="line-modified">1032           if (!atype.is_reference_array()) {</span>
1033             verify_error(ErrorContext::bad_type(bci,
1034                 current_frame.stack_top_ctx(),
1035                 TypeOrigin::implicit(VerificationType::reference_check())),
1036                 bad_type_msg, &quot;aaload&quot;);
1037             return;
1038           }
1039           if (atype.is_null()) {
1040             current_frame.push_stack(
1041               VerificationType::null_type(), CHECK_VERIFY(this));
1042           } else {
1043             VerificationType component =
1044               atype.get_component(this, CHECK_VERIFY(this));
1045             current_frame.push_stack(component, CHECK_VERIFY(this));
1046           }
1047           no_control_flow = false; break;
1048         }
1049         case Bytecodes::_istore :
1050           verify_istore(bcs.get_index(), &amp;current_frame, CHECK_VERIFY(this));
1051           no_control_flow = false; break;
1052         case Bytecodes::_istore_0 :
</pre>
<hr />
<pre>
1186             VerificationType::double2_type(),
1187             VerificationType::double_type(), CHECK_VERIFY(this));
1188           current_frame.pop_stack(
1189             VerificationType::integer_type(), CHECK_VERIFY(this));
1190           atype = current_frame.pop_stack(
1191             VerificationType::reference_check(), CHECK_VERIFY(this));
1192           if (!atype.is_double_array()) {
1193             verify_error(ErrorContext::bad_type(bci,
1194                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),
1195                 bad_type_msg, &quot;dastore&quot;);
1196             return;
1197           }
1198           no_control_flow = false; break;
1199         case Bytecodes::_aastore :
1200           type = current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1201           type2 = current_frame.pop_stack(
1202             VerificationType::integer_type(), CHECK_VERIFY(this));
1203           atype = current_frame.pop_stack(
1204             VerificationType::reference_check(), CHECK_VERIFY(this));
1205           // more type-checking is done at runtime
<span class="line-modified">1206           if (!atype.is_reference_array()) {</span>
1207             verify_error(ErrorContext::bad_type(bci,
1208                 current_frame.stack_top_ctx(),
1209                 TypeOrigin::implicit(VerificationType::reference_check())),
1210                 bad_type_msg, &quot;aastore&quot;);
1211             return;
1212           }
1213           // 4938384: relaxed constraint in JVMS 3nd edition.
1214           no_control_flow = false; break;
1215         case Bytecodes::_pop :
1216           current_frame.pop_stack(
1217             VerificationType::category1_check(), CHECK_VERIFY(this));
1218           no_control_flow = false; break;
1219         case Bytecodes::_pop2 :
1220           type = current_frame.pop_stack(CHECK_VERIFY(this));
1221           if (type.is_category1()) {
1222             current_frame.pop_stack(
1223               VerificationType::category1_check(), CHECK_VERIFY(this));
1224           } else if (type.is_category2_2nd()) {
1225             current_frame.pop_stack(
1226               VerificationType::category2_check(), CHECK_VERIFY(this));
</pre>
<hr />
<pre>
1586         case Bytecodes::_if_icmpgt:
1587         case Bytecodes::_if_icmple:
1588           current_frame.pop_stack(
1589             VerificationType::integer_type(), CHECK_VERIFY(this));
1590           // fall through
1591         case Bytecodes::_ifeq:
1592         case Bytecodes::_ifne:
1593         case Bytecodes::_iflt:
1594         case Bytecodes::_ifge:
1595         case Bytecodes::_ifgt:
1596         case Bytecodes::_ifle:
1597           current_frame.pop_stack(
1598             VerificationType::integer_type(), CHECK_VERIFY(this));
1599           target = bcs.dest();
1600           stackmap_table.check_jump_target(
1601             &amp;current_frame, target, CHECK_VERIFY(this));
1602           no_control_flow = false; break;
1603         case Bytecodes::_if_acmpeq :
1604         case Bytecodes::_if_acmpne :
1605           current_frame.pop_stack(
<span class="line-modified">1606             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
1607           // fall through
1608         case Bytecodes::_ifnull :
1609         case Bytecodes::_ifnonnull :
1610           current_frame.pop_stack(
<span class="line-modified">1611             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
1612           target = bcs.dest();
1613           stackmap_table.check_jump_target
1614             (&amp;current_frame, target, CHECK_VERIFY(this));
1615           no_control_flow = false; break;
1616         case Bytecodes::_goto :
1617           target = bcs.dest();
1618           stackmap_table.check_jump_target(
1619             &amp;current_frame, target, CHECK_VERIFY(this));
1620           no_control_flow = true; break;
1621         case Bytecodes::_goto_w :
1622           target = bcs.dest_w();
1623           stackmap_table.check_jump_target(
1624             &amp;current_frame, target, CHECK_VERIFY(this));
1625           no_control_flow = true; break;
1626         case Bytecodes::_tableswitch :
1627         case Bytecodes::_lookupswitch :
1628           verify_switch(
1629             &amp;bcs, code_length, code_data, &amp;current_frame,
1630             &amp;stackmap_table, CHECK_VERIFY(this));
1631           no_control_flow = true; break;
</pre>
<hr />
<pre>
1642             VerificationType::long_type(), CHECK_VERIFY(this));
1643           verify_return_value(return_type, type, bci,
1644                               &amp;current_frame, CHECK_VERIFY(this));
1645           no_control_flow = true; break;
1646         case Bytecodes::_freturn :
1647           type = current_frame.pop_stack(
1648             VerificationType::float_type(), CHECK_VERIFY(this));
1649           verify_return_value(return_type, type, bci,
1650                               &amp;current_frame, CHECK_VERIFY(this));
1651           no_control_flow = true; break;
1652         case Bytecodes::_dreturn :
1653           type2 = current_frame.pop_stack(
1654             VerificationType::double2_type(),  CHECK_VERIFY(this));
1655           type = current_frame.pop_stack(
1656             VerificationType::double_type(), CHECK_VERIFY(this));
1657           verify_return_value(return_type, type, bci,
1658                               &amp;current_frame, CHECK_VERIFY(this));
1659           no_control_flow = true; break;
1660         case Bytecodes::_areturn :
1661           type = current_frame.pop_stack(
<span class="line-modified">1662             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
1663           verify_return_value(return_type, type, bci,
1664                               &amp;current_frame, CHECK_VERIFY(this));
1665           no_control_flow = true; break;
1666         case Bytecodes::_return :
1667           if (return_type != VerificationType::bogus_type()) {
1668             verify_error(ErrorContext::bad_code(bci),
1669                          &quot;Method expects a return value&quot;);
1670             return;
1671           }
1672           // Make sure &quot;this&quot; has been initialized if current method is an
1673           // &lt;init&gt;.
<span class="line-modified">1674           if (_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
1675               current_frame.flag_this_uninit()) {
1676             verify_error(ErrorContext::bad_code(bci),
1677                          &quot;Constructor must call super() or this() &quot;
1678                          &quot;before return&quot;);
1679             return;
1680           }
1681           no_control_flow = true; break;
1682         case Bytecodes::_getstatic :
1683         case Bytecodes::_putstatic :
1684           // pass TRUE, operand can be an array type for getstatic/putstatic.
1685           verify_field_instructions(
1686             &amp;bcs, &amp;current_frame, cp, true, CHECK_VERIFY(this));
1687           no_control_flow = false; break;
1688         case Bytecodes::_getfield :
1689         case Bytecodes::_putfield :
1690           // pass FALSE, operand can&#39;t be an array type for getfield/putfield.
1691           verify_field_instructions(
1692             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1693           no_control_flow = false; break;











1694         case Bytecodes::_invokevirtual :
1695         case Bytecodes::_invokespecial :
1696         case Bytecodes::_invokestatic :
<span class="line-removed">1697           verify_invoke_instructions(</span>
<span class="line-removed">1698             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),</span>
<span class="line-removed">1699             &amp;this_uninit, return_type, cp, &amp;stackmap_table, CHECK_VERIFY(this));</span>
<span class="line-removed">1700           no_control_flow = false; break;</span>
1701         case Bytecodes::_invokeinterface :
1702         case Bytecodes::_invokedynamic :
1703           verify_invoke_instructions(
1704             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),
<span class="line-modified">1705             &amp;this_uninit, return_type, cp, &amp;stackmap_table, CHECK_VERIFY(this));</span>
1706           no_control_flow = false; break;
1707         case Bytecodes::_new :
1708         {
1709           index = bcs.get_index_u2();
1710           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1711           VerificationType new_class_type =
1712             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1713           if (!new_class_type.is_object()) {
1714             verify_error(ErrorContext::bad_type(bci,
1715                 TypeOrigin::cp(index, new_class_type)),
1716                 &quot;Illegal new instruction&quot;);
1717             return;
1718           }
1719           type = VerificationType::uninitialized_type(bci);
1720           current_frame.push_stack(type, CHECK_VERIFY(this));
1721           no_control_flow = false; break;
1722         }






















1723         case Bytecodes::_newarray :
1724           type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
1725           current_frame.pop_stack(
1726             VerificationType::integer_type(),  CHECK_VERIFY(this));
1727           current_frame.push_stack(type, CHECK_VERIFY(this));
1728           no_control_flow = false; break;
1729         case Bytecodes::_anewarray :
1730           verify_anewarray(
1731             bci, bcs.get_index_u2(), cp, &amp;current_frame, CHECK_VERIFY(this));
1732           no_control_flow = false; break;
1733         case Bytecodes::_arraylength :
1734           type = current_frame.pop_stack(
1735             VerificationType::reference_check(), CHECK_VERIFY(this));
1736           if (!(type.is_null() || type.is_array())) {
1737             verify_error(ErrorContext::bad_type(
1738                 bci, current_frame.stack_top_ctx()),
1739                 bad_type_msg, &quot;arraylength&quot;);
1740           }
1741           current_frame.push_stack(
1742             VerificationType::integer_type(), CHECK_VERIFY(this));
1743           no_control_flow = false; break;
1744         case Bytecodes::_checkcast :
1745         {
1746           index = bcs.get_index_u2();
1747           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1748           current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1749           VerificationType klass_type = cp_index_to_type(
1750             index, cp, CHECK_VERIFY(this));
1751           current_frame.push_stack(klass_type, CHECK_VERIFY(this));
1752           no_control_flow = false; break;
1753         }
1754         case Bytecodes::_instanceof : {
1755           index = bcs.get_index_u2();
1756           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1757           current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1758           current_frame.push_stack(
1759             VerificationType::integer_type(), CHECK_VERIFY(this));
1760           no_control_flow = false; break;
1761         }
1762         case Bytecodes::_monitorenter :
<span class="line-modified">1763         case Bytecodes::_monitorexit :</span>
<span class="line-modified">1764           current_frame.pop_stack(</span>
<span class="line-modified">1765             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
1766           no_control_flow = false; break;

1767         case Bytecodes::_multianewarray :
1768         {
1769           index = bcs.get_index_u2();
1770           u2 dim = *(bcs.bcp()+3);
1771           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1772           VerificationType new_array_type =
1773             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1774           if (!new_array_type.is_array()) {
1775             verify_error(ErrorContext::bad_type(bci,
1776                 TypeOrigin::cp(index, new_array_type)),
1777                 &quot;Illegal constant pool index in multianewarray instruction&quot;);
1778             return;
1779           }
1780           if (dim &lt; 1 || new_array_type.dimensions() &lt; dim) {
1781             verify_error(ErrorContext::bad_code(bci),
1782                 &quot;Illegal dimension in multianewarray instruction: %d&quot;, dim);
1783             return;
1784           }
1785           for (int i = 0; i &lt; dim; i++) {
1786             current_frame.pop_stack(
</pre>
<hr />
<pre>
2005   int nconstants = cp-&gt;length();
2006   if ((index &lt;= 0) || (index &gt;= nconstants)) {
2007     verify_error(ErrorContext::bad_cp_index(bci, index),
2008         &quot;Illegal constant pool index %d in class %s&quot;,
2009         index, cp-&gt;pool_holder()-&gt;external_name());
2010     return;
2011   }
2012 }
2013 
2014 void ClassVerifier::verify_cp_type(
2015     u2 bci, int index, const constantPoolHandle&amp; cp, unsigned int types, TRAPS) {
2016 
2017   // In some situations, bytecode rewriting may occur while we&#39;re verifying.
2018   // In this case, a constant pool cache exists and some indices refer to that
2019   // instead.  Be sure we don&#39;t pick up such indices by accident.
2020   // We must check was_recursively_verified() before we get here.
2021   guarantee(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
2022 
2023   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2024   unsigned int tag = cp-&gt;tag_at(index).value();

2025   if ((types &amp; (1 &lt;&lt; tag)) == 0) {
2026     verify_error(ErrorContext::bad_cp_index(bci, index),
2027       &quot;Illegal type at constant pool entry %d in class %s&quot;,
2028       index, cp-&gt;pool_holder()-&gt;external_name());
2029     return;
2030   }
2031 }
2032 
2033 void ClassVerifier::verify_cp_class_type(
2034     u2 bci, int index, const constantPoolHandle&amp; cp, TRAPS) {
2035   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2036   constantTag tag = cp-&gt;tag_at(index);
2037   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2038     verify_error(ErrorContext::bad_cp_index(bci, index),
2039         &quot;Illegal type at constant pool entry %d in class %s&quot;,
2040         index, cp-&gt;pool_holder()-&gt;external_name());
2041     return;
2042   }
2043 }
2044 
</pre>
<hr />
<pre>
2119   } else {
2120     Klass* member_klass = target_instance-&gt;find_field(field_name, field_sig, &amp;fd);
2121     if (member_klass != NULL &amp;&amp; fd.is_protected()) {
2122       if (!this_class-&gt;is_same_class_package(member_klass)) {
2123         return true;
2124       }
2125     }
2126   }
2127   return false;
2128 }
2129 
2130 void ClassVerifier::verify_ldc(
2131     int opcode, u2 index, StackMapFrame* current_frame,
2132     const constantPoolHandle&amp; cp, u2 bci, TRAPS) {
2133   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2134   constantTag tag = cp-&gt;tag_at(index);
2135   unsigned int types = 0;
2136   if (opcode == Bytecodes::_ldc || opcode == Bytecodes::_ldc_w) {
2137     if (!tag.is_unresolved_klass()) {
2138       types = (1 &lt;&lt; JVM_CONSTANT_Integer) | (1 &lt;&lt; JVM_CONSTANT_Float)
<span class="line-modified">2139             | (1 &lt;&lt; JVM_CONSTANT_String)  | (1 &lt;&lt; JVM_CONSTANT_Class)</span>
2140             | (1 &lt;&lt; JVM_CONSTANT_MethodHandle) | (1 &lt;&lt; JVM_CONSTANT_MethodType)
2141             | (1 &lt;&lt; JVM_CONSTANT_Dynamic);
2142       // Note:  The class file parser already verified the legality of
2143       // MethodHandle and MethodType constants.
2144       verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
2145     }
2146   } else {
2147     assert(opcode == Bytecodes::_ldc2_w, &quot;must be ldc2_w&quot;);
2148     types = (1 &lt;&lt; JVM_CONSTANT_Double) | (1 &lt;&lt; JVM_CONSTANT_Long)
2149           | (1 &lt;&lt; JVM_CONSTANT_Dynamic);
2150     verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
2151   }
2152   if (tag.is_string() &amp;&amp; cp-&gt;is_pseudo_string_at(index)) {
2153     current_frame-&gt;push_stack(object_type(), CHECK_VERIFY(this));
2154   } else if (tag.is_string()) {
2155     current_frame-&gt;push_stack(
2156       VerificationType::reference_type(
2157         vmSymbols::java_lang_String()), CHECK_VERIFY(this));
2158   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
2159     current_frame-&gt;push_stack(
</pre>
<hr />
<pre>
2295                                               StackMapFrame* current_frame,
2296                                               const constantPoolHandle&amp; cp,
2297                                               bool allow_arrays,
2298                                               TRAPS) {
2299   u2 index = bcs-&gt;get_index_u2();
2300   verify_cp_type(bcs-&gt;bci(), index, cp,
2301       1 &lt;&lt; JVM_CONSTANT_Fieldref, CHECK_VERIFY(this));
2302 
2303   // Get field name and signature
2304   Symbol* field_name = cp-&gt;name_ref_at(index);
2305   Symbol* field_sig = cp-&gt;signature_ref_at(index);
2306 
2307   // Field signature was checked in ClassFileParser.
2308   assert(SignatureVerifier::is_valid_type_signature(field_sig),
2309          &quot;Invalid field signature&quot;);
2310 
2311   // Get referenced class type
2312   VerificationType ref_class_type = cp_ref_index_to_type(
2313     index, cp, CHECK_VERIFY(this));
2314   if (!ref_class_type.is_object() &amp;&amp;
<span class="line-modified">2315     (!allow_arrays || !ref_class_type.is_array())) {</span>
2316     verify_error(ErrorContext::bad_type(bcs-&gt;bci(),
2317         TypeOrigin::cp(index, ref_class_type)),
2318         &quot;Expecting reference to class in class %s at constant pool index %d&quot;,
2319         _klass-&gt;external_name(), index);
2320     return;
2321   }

2322   VerificationType target_class_type = ref_class_type;
2323 
2324   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2325         &quot;buffer type must match VerificationType size&quot;);
2326   uintptr_t field_type_buffer[2];
2327   VerificationType* field_type = (VerificationType*)field_type_buffer;
2328   // If we make a VerificationType[2] array directly, the compiler calls
2329   // to the c-runtime library to do the allocation instead of just
2330   // stack allocating it.  Plus it would run constructors.  This shows up
2331   // in performance profiles.
2332 
2333   SignatureStream sig_stream(field_sig, false);
2334   VerificationType stack_object_type;
2335   int n = change_sig_to_verificationType(&amp;sig_stream, field_type);
2336   u2 bci = bcs-&gt;bci();
2337   bool is_assignable;
2338   switch (bcs-&gt;raw_code()) {
2339     case Bytecodes::_getstatic: {
2340       for (int i = 0; i &lt; n; i++) {
2341         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2342       }
2343       break;
2344     }
2345     case Bytecodes::_putstatic: {
2346       for (int i = n - 1; i &gt;= 0; i--) {
2347         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2348       }
2349       break;
2350     }



















2351     case Bytecodes::_getfield: {
2352       stack_object_type = current_frame-&gt;pop_stack(
2353         target_class_type, CHECK_VERIFY(this));
2354       for (int i = 0; i &lt; n; i++) {
2355         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2356       }
2357       goto check_protected;
2358     }
2359     case Bytecodes::_putfield: {
2360       for (int i = n - 1; i &gt;= 0; i--) {
2361         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2362       }
2363       stack_object_type = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2364 
2365       // The JVMS 2nd edition allows field initialization before the superclass
2366       // initializer, if the field is defined within the current class.
2367       fieldDescriptor fd;
2368       if (stack_object_type == VerificationType::uninitialized_this_type() &amp;&amp;
2369           target_class_type.equals(current_type()) &amp;&amp;
2370           _klass-&gt;find_local_field(field_name, field_sig, &amp;fd)) {
</pre>
<hr />
<pre>
2739 bool ClassVerifier::is_same_or_direct_interface(
2740     InstanceKlass* klass,
2741     VerificationType klass_type,
2742     VerificationType ref_class_type) {
2743   if (ref_class_type.equals(klass_type)) return true;
2744   Array&lt;InstanceKlass*&gt;* local_interfaces = klass-&gt;local_interfaces();
2745   if (local_interfaces != NULL) {
2746     for (int x = 0; x &lt; local_interfaces-&gt;length(); x++) {
2747       InstanceKlass* k = local_interfaces-&gt;at(x);
2748       assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
2749       if (ref_class_type.equals(VerificationType::reference_type(k-&gt;name()))) {
2750         return true;
2751       }
2752     }
2753   }
2754   return false;
2755 }
2756 
2757 void ClassVerifier::verify_invoke_instructions(
2758     RawBytecodeStream* bcs, u4 code_length, StackMapFrame* current_frame,
<span class="line-modified">2759     bool in_try_block, bool *this_uninit, VerificationType return_type,</span>
2760     const constantPoolHandle&amp; cp, StackMapTable* stackmap_table, TRAPS) {
2761   // Make sure the constant pool item is the right type
2762   u2 index = bcs-&gt;get_index_u2();
2763   Bytecodes::Code opcode = bcs-&gt;raw_code();
2764   unsigned int types = 0;
2765   switch (opcode) {
2766     case Bytecodes::_invokeinterface:
2767       types = 1 &lt;&lt; JVM_CONSTANT_InterfaceMethodref;
2768       break;
2769     case Bytecodes::_invokedynamic:
2770       types = 1 &lt;&lt; JVM_CONSTANT_InvokeDynamic;
2771       break;
2772     case Bytecodes::_invokespecial:
2773     case Bytecodes::_invokestatic:
2774       types = (_klass-&gt;major_version() &lt; STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION) ?
2775         (1 &lt;&lt; JVM_CONSTANT_Methodref) :
2776         ((1 &lt;&lt; JVM_CONSTANT_InterfaceMethodref) | (1 &lt;&lt; JVM_CONSTANT_Methodref));
2777       break;
2778     default:
2779       types = 1 &lt;&lt; JVM_CONSTANT_Methodref;
2780   }
2781   verify_cp_type(bcs-&gt;bci(), index, cp, types, CHECK_VERIFY(this));
2782 
2783   // Get method name and signature
2784   Symbol* method_name = cp-&gt;name_ref_at(index);
2785   Symbol* method_sig = cp-&gt;signature_ref_at(index);
2786 
2787   // Method signature was checked in ClassFileParser.
2788   assert(SignatureVerifier::is_valid_method_signature(method_sig),
2789          &quot;Invalid method signature&quot;);
2790 
<span class="line-modified">2791   // Get referenced class type</span>
2792   VerificationType ref_class_type;
2793   if (opcode == Bytecodes::_invokedynamic) {
2794     if (_klass-&gt;major_version() &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
2795       class_format_error(
2796         &quot;invokedynamic instructions not supported by this class file version (%d), class %s&quot;,
2797         _klass-&gt;major_version(), _klass-&gt;external_name());
2798       return;
2799     }
2800   } else {
2801     ref_class_type = cp_ref_index_to_type(index, cp, CHECK_VERIFY(this));
2802   }
2803 
2804   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2805         &quot;buffer type must match VerificationType size&quot;);
2806 
2807   // Get the UTF8 index for this signature.
2808   int sig_index = cp-&gt;signature_ref_index_at(cp-&gt;name_and_type_ref_index_at(index));
2809 
2810   // Get the signature&#39;s verification types.
2811   sig_as_verification_types* mth_sig_verif_types;
</pre>
<hr />
<pre>
2837           &quot;Inconsistent args count operand in invokeinterface&quot;);
2838       return;
2839     }
2840     if (*(bcp+4) != 0) {
2841       verify_error(ErrorContext::bad_code(bci),
2842           &quot;Fourth operand byte of invokeinterface must be zero&quot;);
2843       return;
2844     }
2845   }
2846 
2847   if (opcode == Bytecodes::_invokedynamic) {
2848     address bcp = bcs-&gt;bcp();
2849     if (*(bcp+3) != 0 || *(bcp+4) != 0) {
2850       verify_error(ErrorContext::bad_code(bci),
2851           &quot;Third and fourth operand bytes of invokedynamic must be zero&quot;);
2852       return;
2853     }
2854   }
2855 
2856   if (method_name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">2857     // Make sure &lt;init&gt; can only be invoked by invokespecial</span>
<span class="line-modified">2858     if (opcode != Bytecodes::_invokespecial ||</span>


2859         method_name != vmSymbols::object_initializer_name()) {
2860       verify_error(ErrorContext::bad_code(bci),
2861           &quot;Illegal call to internal method&quot;);
2862       return;
2863     }
2864   } else if (opcode == Bytecodes::_invokespecial
2865              &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
2866              &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
<span class="line-modified">2867                   current_class()-&gt;super()-&gt;name()))) {</span>
2868     bool subtype = false;
2869     bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
2870     if (!current_class()-&gt;is_unsafe_anonymous()) {
2871       subtype = ref_class_type.is_assignable_from(
2872                  current_type(), this, false, CHECK_VERIFY(this));
2873     } else {
<span class="line-modified">2874       VerificationType unsafe_anonymous_host_type =</span>
<span class="line-modified">2875                         VerificationType::reference_type(current_class()-&gt;unsafe_anonymous_host()-&gt;name());</span>
2876       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
2877 
2878       // If invokespecial of IMR, need to recheck for same or
2879       // direct interface relative to the host class
2880       have_imr_indirect = (have_imr_indirect &amp;&amp;
2881                            !is_same_or_direct_interface(
<span class="line-modified">2882                              current_class()-&gt;unsafe_anonymous_host(),</span>
2883                              unsafe_anonymous_host_type, ref_class_type));
2884     }
2885     if (!subtype) {
2886       verify_error(ErrorContext::bad_code(bci),
2887           &quot;Bad invokespecial instruction: &quot;
2888           &quot;current class isn&#39;t assignable to reference class.&quot;);
2889        return;
2890     } else if (have_imr_indirect) {
2891       verify_error(ErrorContext::bad_code(bci),
2892           &quot;Bad invokespecial instruction: &quot;
2893           &quot;interface method reference is in an indirect superinterface.&quot;);
2894       return;
2895     }
2896 
2897   }
2898 
2899   // Get the verification types for the method&#39;s arguments.
2900   GrowableArray&lt;VerificationType&gt;* sig_verif_types = mth_sig_verif_types-&gt;sig_verif_types();
2901   assert(sig_verif_types != NULL, &quot;Missing signature&#39;s array of verification types&quot;);
2902   // Match method descriptor with operand stack
2903   // The arguments are on the stack in descending order.
2904   for (int i = nargs - 1; i &gt;= 0; i--) { // Run backwards
2905     current_frame-&gt;pop_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));
2906   }
2907 
2908   // Check objectref on operand stack
2909   if (opcode != Bytecodes::_invokestatic &amp;&amp;
2910       opcode != Bytecodes::_invokedynamic) {
2911     if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method

2912       verify_invoke_init(bcs, index, ref_class_type, current_frame,
2913         code_length, in_try_block, this_uninit, cp, stackmap_table,
2914         CHECK_VERIFY(this));
2915       if (was_recursively_verified()) return;
2916     } else {   // other methods
2917       // Ensures that target class is assignable to method class.
2918       if (opcode == Bytecodes::_invokespecial) {
2919         if (!current_class()-&gt;is_unsafe_anonymous()) {
2920           current_frame-&gt;pop_stack(current_type(), CHECK_VERIFY(this));
2921         } else {
2922           // anonymous class invokespecial calls: check if the
2923           // objectref is a subtype of the unsafe_anonymous_host of the current class
2924           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
2925           VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
<span class="line-modified">2926           VerificationType hosttype =</span>
<span class="line-modified">2927             VerificationType::reference_type(current_class()-&gt;unsafe_anonymous_host()-&gt;name());</span>
<span class="line-modified">2928           bool subtype = hosttype.is_assignable_from(top, this, false, CHECK_VERIFY(this));</span>

2929           if (!subtype) {
2930             verify_error( ErrorContext::bad_type(current_frame-&gt;offset(),
2931               current_frame-&gt;stack_top_ctx(),
2932               TypeOrigin::implicit(top)),
2933               &quot;Bad type on operand stack&quot;);
2934             return;
2935           }
2936         }
2937       } else if (opcode == Bytecodes::_invokevirtual) {
2938         VerificationType stack_object_type =
2939           current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
2940         if (current_type() != stack_object_type) {
2941           if (was_recursively_verified()) return;
2942           assert(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
2943           Symbol* ref_class_name =
2944             cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(index));
2945           // See the comments in verify_field_instructions() for
2946           // the rationale behind this.
2947           if (name_in_supers(ref_class_name, current_class())) {
2948             Klass* ref_class = load_class(ref_class_name, CHECK);
</pre>
<hr />
<pre>
2961                 } else {
2962                   verify_error(ErrorContext::bad_type(bci,
2963                       current_frame-&gt;stack_top_ctx(),
2964                       TypeOrigin::implicit(current_type())),
2965                       &quot;Bad access to protected data in invokevirtual&quot;);
2966                   return;
2967                 }
2968               }
2969             }
2970           }
2971         }
2972       } else {
2973         assert(opcode == Bytecodes::_invokeinterface, &quot;Unexpected opcode encountered&quot;);
2974         current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
2975       }
2976     }
2977   }
2978   // Push the result type.
2979   int sig_verif_types_len = sig_verif_types-&gt;length();
2980   if (sig_verif_types_len &gt; nargs) {  // There&#39;s a return type
<span class="line-modified">2981     if (method_name == vmSymbols::object_initializer_name()) {</span>
<span class="line-modified">2982       // &lt;init&gt; method must have a void return type</span>
<span class="line-modified">2983       /* Unreachable?  Class file parser verifies that methods with &#39;&lt;&#39; have</span>
<span class="line-removed">2984        * void return */</span>
2985       verify_error(ErrorContext::bad_code(bci),
2986           &quot;Return type must be void in &lt;init&gt; method&quot;);
2987       return;
2988     }
2989 
2990     assert(sig_verif_types_len &lt;= nargs + 2,
2991            &quot;Signature verification types array return type is bogus&quot;);
2992     for (int i = nargs; i &lt; sig_verif_types_len; i++) {
2993       assert(i == nargs || sig_verif_types-&gt;at(i).is_long2() ||
2994              sig_verif_types-&gt;at(i).is_double2(), &quot;Unexpected return verificationType&quot;);
2995       current_frame-&gt;push_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));
2996     }








2997   }
2998 }
2999 
3000 VerificationType ClassVerifier::get_newarray_type(
3001     u2 index, u2 bci, TRAPS) {
3002   const char* from_bt[] = {
3003     NULL, NULL, NULL, NULL, &quot;[Z&quot;, &quot;[C&quot;, &quot;[F&quot;, &quot;[D&quot;, &quot;[B&quot;, &quot;[S&quot;, &quot;[I&quot;, &quot;[J&quot;,
3004   };
3005   if (index &lt; T_BOOLEAN || index &gt; T_LONG) {
3006     verify_error(ErrorContext::bad_code(bci), &quot;Illegal newarray instruction&quot;);
3007     return VerificationType::bogus_type();
3008   }
3009 
3010   // from_bt[index] contains the array signature which has a length of 2
3011   Symbol* sig = create_temporary_symbol(from_bt[index], 2);
3012   return VerificationType::reference_type(sig);
3013 }
3014 
3015 void ClassVerifier::verify_anewarray(
3016     u2 bci, u2 index, const constantPoolHandle&amp; cp,
</pre>
<hr />
<pre>
3024     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3025   int length;
3026   char* arr_sig_str;
3027   if (component_type.is_array()) {     // it&#39;s an array
3028     const char* component_name = component_type.name()-&gt;as_utf8();
3029     // Check for more than MAX_ARRAY_DIMENSIONS
3030     length = (int)strlen(component_name);
3031     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
3032         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
3033       verify_error(ErrorContext::bad_code(bci),
3034         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3035     }
3036     // add one dimension to component
3037     length++;
3038     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3039     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
3040                          JVM_SIGNATURE_ARRAY, component_name);
3041     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3042   } else {         // it&#39;s an object or interface
3043     const char* component_name = component_type.name()-&gt;as_utf8();
<span class="line-modified">3044     // add one dimension to component with &#39;L&#39; prepended and &#39;;&#39; postpended.</span>

3045     length = (int)strlen(component_name) + 3;
3046     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3047     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
<span class="line-modified">3048                          JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);</span>
3049     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3050   }
3051   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
3052   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3053   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3054 }
3055 
3056 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3057   current_frame-&gt;get_local(
3058     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3059   current_frame-&gt;push_stack(
3060     VerificationType::integer_type(), CHECK_VERIFY(this));
3061 }
3062 
3063 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
3064   current_frame-&gt;get_local_2(
3065     index, VerificationType::long_type(),
3066     VerificationType::long2_type(), CHECK_VERIFY(this));
3067   current_frame-&gt;push_stack_2(
3068     VerificationType::long_type(),
</pre>
<hr />
<pre>
3070 }
3071 
3072 void ClassVerifier::verify_fload(u2 index, StackMapFrame* current_frame, TRAPS) {
3073   current_frame-&gt;get_local(
3074     index, VerificationType::float_type(), CHECK_VERIFY(this));
3075   current_frame-&gt;push_stack(
3076     VerificationType::float_type(), CHECK_VERIFY(this));
3077 }
3078 
3079 void ClassVerifier::verify_dload(u2 index, StackMapFrame* current_frame, TRAPS) {
3080   current_frame-&gt;get_local_2(
3081     index, VerificationType::double_type(),
3082     VerificationType::double2_type(), CHECK_VERIFY(this));
3083   current_frame-&gt;push_stack_2(
3084     VerificationType::double_type(),
3085     VerificationType::double2_type(), CHECK_VERIFY(this));
3086 }
3087 
3088 void ClassVerifier::verify_aload(u2 index, StackMapFrame* current_frame, TRAPS) {
3089   VerificationType type = current_frame-&gt;get_local(
<span class="line-modified">3090     index, VerificationType::reference_check(), CHECK_VERIFY(this));</span>
3091   current_frame-&gt;push_stack(type, CHECK_VERIFY(this));
3092 }
3093 
3094 void ClassVerifier::verify_istore(u2 index, StackMapFrame* current_frame, TRAPS) {
3095   current_frame-&gt;pop_stack(
3096     VerificationType::integer_type(), CHECK_VERIFY(this));
3097   current_frame-&gt;set_local(
3098     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3099 }
3100 
3101 void ClassVerifier::verify_lstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3102   current_frame-&gt;pop_stack_2(
3103     VerificationType::long2_type(),
3104     VerificationType::long_type(), CHECK_VERIFY(this));
3105   current_frame-&gt;set_local_2(
3106     index, VerificationType::long_type(),
3107     VerificationType::long2_type(), CHECK_VERIFY(this));
3108 }
3109 
3110 void ClassVerifier::verify_fstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3111   current_frame-&gt;pop_stack(VerificationType::float_type(), CHECK_VERIFY(this));
3112   current_frame-&gt;set_local(
3113     index, VerificationType::float_type(), CHECK_VERIFY(this));
3114 }
3115 
3116 void ClassVerifier::verify_dstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3117   current_frame-&gt;pop_stack_2(
3118     VerificationType::double2_type(),
3119     VerificationType::double_type(), CHECK_VERIFY(this));
3120   current_frame-&gt;set_local_2(
3121     index, VerificationType::double_type(),
3122     VerificationType::double2_type(), CHECK_VERIFY(this));
3123 }
3124 
3125 void ClassVerifier::verify_astore(u2 index, StackMapFrame* current_frame, TRAPS) {
3126   VerificationType type = current_frame-&gt;pop_stack(
<span class="line-modified">3127     VerificationType::reference_check(), CHECK_VERIFY(this));</span>
3128   current_frame-&gt;set_local(index, type, CHECK_VERIFY(this));
3129 }
3130 
3131 void ClassVerifier::verify_iinc(u2 index, StackMapFrame* current_frame, TRAPS) {
3132   VerificationType type = current_frame-&gt;get_local(
3133     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3134   current_frame-&gt;set_local(index, type, CHECK_VERIFY(this));
3135 }
3136 
3137 void ClassVerifier::verify_return_value(
3138     VerificationType return_type, VerificationType type, u2 bci,
3139     StackMapFrame* current_frame, TRAPS) {
3140   if (return_type == VerificationType::bogus_type()) {
3141     verify_error(ErrorContext::bad_type(bci,
3142         current_frame-&gt;stack_top_ctx(), TypeOrigin::signature(return_type)),
3143         &quot;Method expects a return value&quot;);
3144     return;
3145   }
3146   bool match = return_type.is_assignable_from(type, this, false, CHECK_VERIFY(this));
3147   if (!match) {
</pre>
</td>
<td>
<hr />
<pre>
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/instanceKlass.hpp&quot;
  46 #include &quot;oops/oop.inline.hpp&quot;
  47 #include &quot;oops/typeArrayOop.hpp&quot;
  48 #include &quot;runtime/fieldDescriptor.hpp&quot;
  49 #include &quot;runtime/handles.inline.hpp&quot;
  50 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  51 #include &quot;runtime/javaCalls.hpp&quot;
  52 #include &quot;runtime/jniHandles.inline.hpp&quot;
  53 #include &quot;runtime/os.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/thread.hpp&quot;
  56 #include &quot;services/threadService.hpp&quot;
  57 #include &quot;utilities/align.hpp&quot;
  58 #include &quot;utilities/bytes.hpp&quot;
  59 
  60 #define NOFAILOVER_MAJOR_VERSION                       51
  61 #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  62 #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
<span class="line-added">  63 #define VALUETYPE_MAJOR_VERSION                        56</span>
  64 #define MAX_ARRAY_DIMENSIONS 255
  65 
  66 // Access to external entry for VerifyClassForMajorVersion - old byte code verifier
  67 
  68 extern &quot;C&quot; {
  69   typedef jboolean (*verify_byte_codes_fn_t)(JNIEnv *, jclass, char *, jint, jint);
  70 }
  71 
  72 static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;
  73 
  74 static verify_byte_codes_fn_t verify_byte_codes_fn() {
  75 
  76   if (_verify_byte_codes_fn != NULL)
  77     return _verify_byte_codes_fn;
  78 
  79   MutexLocker locker(Verify_lock);
  80 
  81   if (_verify_byte_codes_fn != NULL)
  82     return _verify_byte_codes_fn;
  83 
</pre>
<hr />
<pre>
 248       }
 249       kls = kls-&gt;super();
 250     }
 251     if (message_buffer != NULL) {
 252       message_buffer[message_buffer_len - 1] = &#39;\0&#39;; // just to be sure
 253     }
 254     assert(exception_message != NULL, &quot;&quot;);
 255     THROW_MSG_(exception_name, exception_message, false);
 256   }
 257 }
 258 
 259 bool Verifier::is_eligible_for_verification(InstanceKlass* klass, bool should_verify_class) {
 260   Symbol* name = klass-&gt;name();
 261   Klass* refl_magic_klass = SystemDictionary::reflect_MagicAccessorImpl_klass();
 262 
 263   bool is_reflect = refl_magic_klass != NULL &amp;&amp; klass-&gt;is_subtype_of(refl_magic_klass);
 264 
 265   return (should_verify_for(klass-&gt;class_loader(), should_verify_class) &amp;&amp;
 266     // return if the class is a bootstrapping class
 267     // or defineClass specified not to verify by default (flags override passed arg)
<span class="line-modified"> 268     // We need to skip the following four for bootstrapping</span>
 269     name != vmSymbols::java_lang_Object() &amp;&amp;
 270     name != vmSymbols::java_lang_Class() &amp;&amp;
 271     name != vmSymbols::java_lang_String() &amp;&amp;
 272     name != vmSymbols::java_lang_Throwable() &amp;&amp;
 273 
 274     // Can not verify the bytecodes for shared classes because they have
 275     // already been rewritten to contain constant pool cache indices,
 276     // which the verifier can&#39;t understand.
 277     // Shared classes shouldn&#39;t have stackmaps either.
 278     !klass-&gt;is_shared() &amp;&amp;
 279 
 280     // As of the fix for 4486457 we disable verification for all of the
 281     // dynamically-generated bytecodes associated with the 1.4
 282     // reflection implementation, not just those associated with
 283     // jdk/internal/reflect/SerializationConstructorAccessor.
 284     // NOTE: this is called too early in the bootstrapping process to be
 285     // guarded by Universe::is_gte_jdk14x_version().
 286     // Also for lambda generated code, gte jdk8
 287     (!is_reflect));
 288 }
</pre>
<hr />
<pre>
 470       ss-&gt;print(&quot;Local index %d is invalid&quot;, _type.index());
 471       break;
 472     case LOCALS_SIZE_MISMATCH:
 473       ss-&gt;print(&quot;Current frame&#39;s local size doesn&#39;t match stackmap.&quot;);
 474       break;
 475     case STACK_SIZE_MISMATCH:
 476       ss-&gt;print(&quot;Current frame&#39;s stack size doesn&#39;t match stackmap.&quot;);
 477       break;
 478     case STACK_OVERFLOW:
 479       ss-&gt;print(&quot;Exceeded max stack size.&quot;);
 480       break;
 481     case STACK_UNDERFLOW:
 482       ss-&gt;print(&quot;Attempt to pop empty stack.&quot;);
 483       break;
 484     case MISSING_STACKMAP:
 485       ss-&gt;print(&quot;Expected stackmap frame at this location.&quot;);
 486       break;
 487     case BAD_STACKMAP:
 488       ss-&gt;print(&quot;Invalid stackmap specification.&quot;);
 489       break;
<span class="line-added"> 490     case WRONG_VALUE_TYPE:</span>
<span class="line-added"> 491       ss-&gt;print(&quot;Type &quot;);</span>
<span class="line-added"> 492       _type.details(ss);</span>
<span class="line-added"> 493       ss-&gt;print(&quot; and type &quot;);</span>
<span class="line-added"> 494       _expected.details(ss);</span>
<span class="line-added"> 495       ss-&gt;print(&quot; must be identical inline types.&quot;);</span>
<span class="line-added"> 496       break;</span>
 497     case UNKNOWN:
 498     default:
 499       ShouldNotReachHere();
 500       ss-&gt;print_cr(&quot;Unknown&quot;);
 501   }
 502   ss-&gt;cr();
 503 }
 504 
 505 void ErrorContext::location_details(outputStream* ss, const Method* method) const {
 506   if (_bci != -1 &amp;&amp; method != NULL) {
 507     streamIndentor si(ss);
 508     const char* bytecode_name = &quot;&lt;invalid&gt;&quot;;
 509     if (method-&gt;validate_bci(_bci) != -1) {
 510       Bytecodes::Code code = Bytecodes::code_or_bp_at(method-&gt;bcp_from(_bci));
 511       if (Bytecodes::is_defined(code)) {
 512           bytecode_name = Bytecodes::name(code);
 513       } else {
 514           bytecode_name = &quot;&lt;illegal&gt;&quot;;
 515       }
 516     }
</pre>
<hr />
<pre>
 571     stack_map_frame* sm_frame = sm_table-&gt;entries();
 572     streamIndentor si2(ss);
 573     int current_offset = -1;
 574     address end_of_sm_table = (address)sm_table + method-&gt;stackmap_data()-&gt;length();
 575     for (u2 i = 0; i &lt; sm_table-&gt;number_of_entries(); ++i) {
 576       ss-&gt;indent();
 577       if (!sm_frame-&gt;verify((address)sm_frame, end_of_sm_table)) {
 578         sm_frame-&gt;print_truncated(ss, current_offset);
 579         return;
 580       }
 581       sm_frame-&gt;print_on(ss, current_offset);
 582       ss-&gt;cr();
 583       current_offset += sm_frame-&gt;offset_delta();
 584       sm_frame = sm_frame-&gt;next();
 585     }
 586   }
 587 }
 588 
 589 // Methods in ClassVerifier
 590 
<span class="line-added"> 591 VerificationType reference_or_valuetype(InstanceKlass* klass) {</span>
<span class="line-added"> 592   if (klass-&gt;is_value()) {</span>
<span class="line-added"> 593     return VerificationType::valuetype_type(klass-&gt;name());</span>
<span class="line-added"> 594   } else {</span>
<span class="line-added"> 595     return VerificationType::reference_type(klass-&gt;name());</span>
<span class="line-added"> 596   }</span>
<span class="line-added"> 597 }</span>
<span class="line-added"> 598 </span>
 599 ClassVerifier::ClassVerifier(
 600     InstanceKlass* klass, TRAPS)
 601     : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
 602       _message(NULL), _method_signatures_table(NULL), _klass(klass) {
<span class="line-modified"> 603   _this_type = reference_or_valuetype(klass);</span>
 604 }
 605 
 606 ClassVerifier::~ClassVerifier() {
 607   // Decrement the reference count for any symbols created.
 608   if (_symbols != NULL) {
 609     for (int i = 0; i &lt; _symbols-&gt;length(); i++) {
 610       Symbol* s = _symbols-&gt;at(i);
 611       s-&gt;decrement_refcount();
 612     }
 613   }
 614 }
 615 
 616 VerificationType ClassVerifier::object_type() const {
 617   return VerificationType::reference_type(vmSymbols::java_lang_Object());
 618 }
 619 
 620 TypeOrigin ClassVerifier::ref_ctx(const char* sig) {
 621   VerificationType vt = VerificationType::reference_type(
 622                          create_temporary_symbol(sig, (int)strlen(sig)));
 623   return TypeOrigin::implicit(vt);
</pre>
<hr />
<pre>
1028         case Bytecodes::_daload :
1029           type = current_frame.pop_stack(
1030             VerificationType::integer_type(), CHECK_VERIFY(this));
1031           atype = current_frame.pop_stack(
1032             VerificationType::reference_check(), CHECK_VERIFY(this));
1033           if (!atype.is_double_array()) {
1034             verify_error(ErrorContext::bad_type(bci,
1035                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),
1036                 bad_type_msg, &quot;daload&quot;);
1037             return;
1038           }
1039           current_frame.push_stack_2(
1040             VerificationType::double_type(),
1041             VerificationType::double2_type(), CHECK_VERIFY(this));
1042           no_control_flow = false; break;
1043         case Bytecodes::_aaload : {
1044           type = current_frame.pop_stack(
1045             VerificationType::integer_type(), CHECK_VERIFY(this));
1046           atype = current_frame.pop_stack(
1047             VerificationType::reference_check(), CHECK_VERIFY(this));
<span class="line-modified">1048           if (!atype.is_nonscalar_array()) {</span>
1049             verify_error(ErrorContext::bad_type(bci,
1050                 current_frame.stack_top_ctx(),
1051                 TypeOrigin::implicit(VerificationType::reference_check())),
1052                 bad_type_msg, &quot;aaload&quot;);
1053             return;
1054           }
1055           if (atype.is_null()) {
1056             current_frame.push_stack(
1057               VerificationType::null_type(), CHECK_VERIFY(this));
1058           } else {
1059             VerificationType component =
1060               atype.get_component(this, CHECK_VERIFY(this));
1061             current_frame.push_stack(component, CHECK_VERIFY(this));
1062           }
1063           no_control_flow = false; break;
1064         }
1065         case Bytecodes::_istore :
1066           verify_istore(bcs.get_index(), &amp;current_frame, CHECK_VERIFY(this));
1067           no_control_flow = false; break;
1068         case Bytecodes::_istore_0 :
</pre>
<hr />
<pre>
1202             VerificationType::double2_type(),
1203             VerificationType::double_type(), CHECK_VERIFY(this));
1204           current_frame.pop_stack(
1205             VerificationType::integer_type(), CHECK_VERIFY(this));
1206           atype = current_frame.pop_stack(
1207             VerificationType::reference_check(), CHECK_VERIFY(this));
1208           if (!atype.is_double_array()) {
1209             verify_error(ErrorContext::bad_type(bci,
1210                 current_frame.stack_top_ctx(), ref_ctx(&quot;[D&quot;)),
1211                 bad_type_msg, &quot;dastore&quot;);
1212             return;
1213           }
1214           no_control_flow = false; break;
1215         case Bytecodes::_aastore :
1216           type = current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1217           type2 = current_frame.pop_stack(
1218             VerificationType::integer_type(), CHECK_VERIFY(this));
1219           atype = current_frame.pop_stack(
1220             VerificationType::reference_check(), CHECK_VERIFY(this));
1221           // more type-checking is done at runtime
<span class="line-modified">1222           if (!atype.is_nonscalar_array()) {</span>
1223             verify_error(ErrorContext::bad_type(bci,
1224                 current_frame.stack_top_ctx(),
1225                 TypeOrigin::implicit(VerificationType::reference_check())),
1226                 bad_type_msg, &quot;aastore&quot;);
1227             return;
1228           }
1229           // 4938384: relaxed constraint in JVMS 3nd edition.
1230           no_control_flow = false; break;
1231         case Bytecodes::_pop :
1232           current_frame.pop_stack(
1233             VerificationType::category1_check(), CHECK_VERIFY(this));
1234           no_control_flow = false; break;
1235         case Bytecodes::_pop2 :
1236           type = current_frame.pop_stack(CHECK_VERIFY(this));
1237           if (type.is_category1()) {
1238             current_frame.pop_stack(
1239               VerificationType::category1_check(), CHECK_VERIFY(this));
1240           } else if (type.is_category2_2nd()) {
1241             current_frame.pop_stack(
1242               VerificationType::category2_check(), CHECK_VERIFY(this));
</pre>
<hr />
<pre>
1602         case Bytecodes::_if_icmpgt:
1603         case Bytecodes::_if_icmple:
1604           current_frame.pop_stack(
1605             VerificationType::integer_type(), CHECK_VERIFY(this));
1606           // fall through
1607         case Bytecodes::_ifeq:
1608         case Bytecodes::_ifne:
1609         case Bytecodes::_iflt:
1610         case Bytecodes::_ifge:
1611         case Bytecodes::_ifgt:
1612         case Bytecodes::_ifle:
1613           current_frame.pop_stack(
1614             VerificationType::integer_type(), CHECK_VERIFY(this));
1615           target = bcs.dest();
1616           stackmap_table.check_jump_target(
1617             &amp;current_frame, target, CHECK_VERIFY(this));
1618           no_control_flow = false; break;
1619         case Bytecodes::_if_acmpeq :
1620         case Bytecodes::_if_acmpne :
1621           current_frame.pop_stack(
<span class="line-modified">1622             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
1623           // fall through
1624         case Bytecodes::_ifnull :
1625         case Bytecodes::_ifnonnull :
1626           current_frame.pop_stack(
<span class="line-modified">1627             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
1628           target = bcs.dest();
1629           stackmap_table.check_jump_target
1630             (&amp;current_frame, target, CHECK_VERIFY(this));
1631           no_control_flow = false; break;
1632         case Bytecodes::_goto :
1633           target = bcs.dest();
1634           stackmap_table.check_jump_target(
1635             &amp;current_frame, target, CHECK_VERIFY(this));
1636           no_control_flow = true; break;
1637         case Bytecodes::_goto_w :
1638           target = bcs.dest_w();
1639           stackmap_table.check_jump_target(
1640             &amp;current_frame, target, CHECK_VERIFY(this));
1641           no_control_flow = true; break;
1642         case Bytecodes::_tableswitch :
1643         case Bytecodes::_lookupswitch :
1644           verify_switch(
1645             &amp;bcs, code_length, code_data, &amp;current_frame,
1646             &amp;stackmap_table, CHECK_VERIFY(this));
1647           no_control_flow = true; break;
</pre>
<hr />
<pre>
1658             VerificationType::long_type(), CHECK_VERIFY(this));
1659           verify_return_value(return_type, type, bci,
1660                               &amp;current_frame, CHECK_VERIFY(this));
1661           no_control_flow = true; break;
1662         case Bytecodes::_freturn :
1663           type = current_frame.pop_stack(
1664             VerificationType::float_type(), CHECK_VERIFY(this));
1665           verify_return_value(return_type, type, bci,
1666                               &amp;current_frame, CHECK_VERIFY(this));
1667           no_control_flow = true; break;
1668         case Bytecodes::_dreturn :
1669           type2 = current_frame.pop_stack(
1670             VerificationType::double2_type(),  CHECK_VERIFY(this));
1671           type = current_frame.pop_stack(
1672             VerificationType::double_type(), CHECK_VERIFY(this));
1673           verify_return_value(return_type, type, bci,
1674                               &amp;current_frame, CHECK_VERIFY(this));
1675           no_control_flow = true; break;
1676         case Bytecodes::_areturn :
1677           type = current_frame.pop_stack(
<span class="line-modified">1678             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
1679           verify_return_value(return_type, type, bci,
1680                               &amp;current_frame, CHECK_VERIFY(this));
1681           no_control_flow = true; break;
1682         case Bytecodes::_return :
1683           if (return_type != VerificationType::bogus_type()) {
1684             verify_error(ErrorContext::bad_code(bci),
1685                          &quot;Method expects a return value&quot;);
1686             return;
1687           }
1688           // Make sure &quot;this&quot; has been initialized if current method is an
1689           // &lt;init&gt;.
<span class="line-modified">1690           if (_method-&gt;is_object_constructor() &amp;&amp;</span>
1691               current_frame.flag_this_uninit()) {
1692             verify_error(ErrorContext::bad_code(bci),
1693                          &quot;Constructor must call super() or this() &quot;
1694                          &quot;before return&quot;);
1695             return;
1696           }
1697           no_control_flow = true; break;
1698         case Bytecodes::_getstatic :
1699         case Bytecodes::_putstatic :
1700           // pass TRUE, operand can be an array type for getstatic/putstatic.
1701           verify_field_instructions(
1702             &amp;bcs, &amp;current_frame, cp, true, CHECK_VERIFY(this));
1703           no_control_flow = false; break;
1704         case Bytecodes::_getfield :
1705         case Bytecodes::_putfield :
1706           // pass FALSE, operand can&#39;t be an array type for getfield/putfield.
1707           verify_field_instructions(
1708             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
1709           no_control_flow = false; break;
<span class="line-added">1710         case Bytecodes::_withfield :</span>
<span class="line-added">1711           if (_klass-&gt;major_version() &lt; VALUETYPE_MAJOR_VERSION) {</span>
<span class="line-added">1712             class_format_error(</span>
<span class="line-added">1713               &quot;withfield not supported by this class file version (%d.%d), class %s&quot;,</span>
<span class="line-added">1714               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());</span>
<span class="line-added">1715             return;</span>
<span class="line-added">1716           }</span>
<span class="line-added">1717           // pass FALSE, operand can&#39;t be an array type for withfield.</span>
<span class="line-added">1718           verify_field_instructions(</span>
<span class="line-added">1719             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));</span>
<span class="line-added">1720           no_control_flow = false; break;</span>
1721         case Bytecodes::_invokevirtual :
1722         case Bytecodes::_invokespecial :
1723         case Bytecodes::_invokestatic :




1724         case Bytecodes::_invokeinterface :
1725         case Bytecodes::_invokedynamic :
1726           verify_invoke_instructions(
1727             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),
<span class="line-modified">1728             &amp;this_uninit, cp, &amp;stackmap_table, CHECK_VERIFY(this));</span>
1729           no_control_flow = false; break;
1730         case Bytecodes::_new :
1731         {
1732           index = bcs.get_index_u2();
1733           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1734           VerificationType new_class_type =
1735             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1736           if (!new_class_type.is_object()) {
1737             verify_error(ErrorContext::bad_type(bci,
1738                 TypeOrigin::cp(index, new_class_type)),
1739                 &quot;Illegal new instruction&quot;);
1740             return;
1741           }
1742           type = VerificationType::uninitialized_type(bci);
1743           current_frame.push_stack(type, CHECK_VERIFY(this));
1744           no_control_flow = false; break;
1745         }
<span class="line-added">1746         case Bytecodes::_defaultvalue :</span>
<span class="line-added">1747         {</span>
<span class="line-added">1748           if (_klass-&gt;major_version() &lt; VALUETYPE_MAJOR_VERSION) {</span>
<span class="line-added">1749             class_format_error(</span>
<span class="line-added">1750               &quot;defaultvalue not supported by this class file version (%d.%d), class %s&quot;,</span>
<span class="line-added">1751               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());</span>
<span class="line-added">1752             return;</span>
<span class="line-added">1753           }</span>
<span class="line-added">1754           index = bcs.get_index_u2();</span>
<span class="line-added">1755           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));</span>
<span class="line-added">1756           VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));</span>
<span class="line-added">1757           if (!ref_type.is_object()) {</span>
<span class="line-added">1758             verify_error(ErrorContext::bad_type(bci,</span>
<span class="line-added">1759                 TypeOrigin::cp(index, ref_type)),</span>
<span class="line-added">1760                 &quot;Illegal defaultvalue instruction&quot;);</span>
<span class="line-added">1761             return;</span>
<span class="line-added">1762           }</span>
<span class="line-added">1763           VerificationType value_type =</span>
<span class="line-added">1764             VerificationType::change_ref_to_valuetype(ref_type);</span>
<span class="line-added">1765           current_frame.push_stack(value_type, CHECK_VERIFY(this));</span>
<span class="line-added">1766           no_control_flow = false; break;</span>
<span class="line-added">1767         }</span>
1768         case Bytecodes::_newarray :
1769           type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
1770           current_frame.pop_stack(
1771             VerificationType::integer_type(),  CHECK_VERIFY(this));
1772           current_frame.push_stack(type, CHECK_VERIFY(this));
1773           no_control_flow = false; break;
1774         case Bytecodes::_anewarray :
1775           verify_anewarray(
1776             bci, bcs.get_index_u2(), cp, &amp;current_frame, CHECK_VERIFY(this));
1777           no_control_flow = false; break;
1778         case Bytecodes::_arraylength :
1779           type = current_frame.pop_stack(
1780             VerificationType::reference_check(), CHECK_VERIFY(this));
1781           if (!(type.is_null() || type.is_array())) {
1782             verify_error(ErrorContext::bad_type(
1783                 bci, current_frame.stack_top_ctx()),
1784                 bad_type_msg, &quot;arraylength&quot;);
1785           }
1786           current_frame.push_stack(
1787             VerificationType::integer_type(), CHECK_VERIFY(this));
1788           no_control_flow = false; break;
1789         case Bytecodes::_checkcast :
1790         {
1791           index = bcs.get_index_u2();
1792           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1793           current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1794           VerificationType klass_type = cp_index_to_type(
1795             index, cp, CHECK_VERIFY(this));
1796           current_frame.push_stack(klass_type, CHECK_VERIFY(this));
1797           no_control_flow = false; break;
1798         }
1799         case Bytecodes::_instanceof : {
1800           index = bcs.get_index_u2();
1801           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1802           current_frame.pop_stack(object_type(), CHECK_VERIFY(this));
1803           current_frame.push_stack(
1804             VerificationType::integer_type(), CHECK_VERIFY(this));
1805           no_control_flow = false; break;
1806         }
1807         case Bytecodes::_monitorenter :
<span class="line-modified">1808         case Bytecodes::_monitorexit : {</span>
<span class="line-modified">1809           VerificationType ref = current_frame.pop_stack(</span>
<span class="line-modified">1810             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
1811           no_control_flow = false; break;
<span class="line-added">1812         }</span>
1813         case Bytecodes::_multianewarray :
1814         {
1815           index = bcs.get_index_u2();
1816           u2 dim = *(bcs.bcp()+3);
1817           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
1818           VerificationType new_array_type =
1819             cp_index_to_type(index, cp, CHECK_VERIFY(this));
1820           if (!new_array_type.is_array()) {
1821             verify_error(ErrorContext::bad_type(bci,
1822                 TypeOrigin::cp(index, new_array_type)),
1823                 &quot;Illegal constant pool index in multianewarray instruction&quot;);
1824             return;
1825           }
1826           if (dim &lt; 1 || new_array_type.dimensions() &lt; dim) {
1827             verify_error(ErrorContext::bad_code(bci),
1828                 &quot;Illegal dimension in multianewarray instruction: %d&quot;, dim);
1829             return;
1830           }
1831           for (int i = 0; i &lt; dim; i++) {
1832             current_frame.pop_stack(
</pre>
<hr />
<pre>
2051   int nconstants = cp-&gt;length();
2052   if ((index &lt;= 0) || (index &gt;= nconstants)) {
2053     verify_error(ErrorContext::bad_cp_index(bci, index),
2054         &quot;Illegal constant pool index %d in class %s&quot;,
2055         index, cp-&gt;pool_holder()-&gt;external_name());
2056     return;
2057   }
2058 }
2059 
2060 void ClassVerifier::verify_cp_type(
2061     u2 bci, int index, const constantPoolHandle&amp; cp, unsigned int types, TRAPS) {
2062 
2063   // In some situations, bytecode rewriting may occur while we&#39;re verifying.
2064   // In this case, a constant pool cache exists and some indices refer to that
2065   // instead.  Be sure we don&#39;t pick up such indices by accident.
2066   // We must check was_recursively_verified() before we get here.
2067   guarantee(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
2068 
2069   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2070   unsigned int tag = cp-&gt;tag_at(index).value();
<span class="line-added">2071 </span>
2072   if ((types &amp; (1 &lt;&lt; tag)) == 0) {
2073     verify_error(ErrorContext::bad_cp_index(bci, index),
2074       &quot;Illegal type at constant pool entry %d in class %s&quot;,
2075       index, cp-&gt;pool_holder()-&gt;external_name());
2076     return;
2077   }
2078 }
2079 
2080 void ClassVerifier::verify_cp_class_type(
2081     u2 bci, int index, const constantPoolHandle&amp; cp, TRAPS) {
2082   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2083   constantTag tag = cp-&gt;tag_at(index);
2084   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2085     verify_error(ErrorContext::bad_cp_index(bci, index),
2086         &quot;Illegal type at constant pool entry %d in class %s&quot;,
2087         index, cp-&gt;pool_holder()-&gt;external_name());
2088     return;
2089   }
2090 }
2091 
</pre>
<hr />
<pre>
2166   } else {
2167     Klass* member_klass = target_instance-&gt;find_field(field_name, field_sig, &amp;fd);
2168     if (member_klass != NULL &amp;&amp; fd.is_protected()) {
2169       if (!this_class-&gt;is_same_class_package(member_klass)) {
2170         return true;
2171       }
2172     }
2173   }
2174   return false;
2175 }
2176 
2177 void ClassVerifier::verify_ldc(
2178     int opcode, u2 index, StackMapFrame* current_frame,
2179     const constantPoolHandle&amp; cp, u2 bci, TRAPS) {
2180   verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
2181   constantTag tag = cp-&gt;tag_at(index);
2182   unsigned int types = 0;
2183   if (opcode == Bytecodes::_ldc || opcode == Bytecodes::_ldc_w) {
2184     if (!tag.is_unresolved_klass()) {
2185       types = (1 &lt;&lt; JVM_CONSTANT_Integer) | (1 &lt;&lt; JVM_CONSTANT_Float)
<span class="line-modified">2186             | (1 &lt;&lt; JVM_CONSTANT_String) | (1 &lt;&lt; JVM_CONSTANT_Class)</span>
2187             | (1 &lt;&lt; JVM_CONSTANT_MethodHandle) | (1 &lt;&lt; JVM_CONSTANT_MethodType)
2188             | (1 &lt;&lt; JVM_CONSTANT_Dynamic);
2189       // Note:  The class file parser already verified the legality of
2190       // MethodHandle and MethodType constants.
2191       verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
2192     }
2193   } else {
2194     assert(opcode == Bytecodes::_ldc2_w, &quot;must be ldc2_w&quot;);
2195     types = (1 &lt;&lt; JVM_CONSTANT_Double) | (1 &lt;&lt; JVM_CONSTANT_Long)
2196           | (1 &lt;&lt; JVM_CONSTANT_Dynamic);
2197     verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
2198   }
2199   if (tag.is_string() &amp;&amp; cp-&gt;is_pseudo_string_at(index)) {
2200     current_frame-&gt;push_stack(object_type(), CHECK_VERIFY(this));
2201   } else if (tag.is_string()) {
2202     current_frame-&gt;push_stack(
2203       VerificationType::reference_type(
2204         vmSymbols::java_lang_String()), CHECK_VERIFY(this));
2205   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
2206     current_frame-&gt;push_stack(
</pre>
<hr />
<pre>
2342                                               StackMapFrame* current_frame,
2343                                               const constantPoolHandle&amp; cp,
2344                                               bool allow_arrays,
2345                                               TRAPS) {
2346   u2 index = bcs-&gt;get_index_u2();
2347   verify_cp_type(bcs-&gt;bci(), index, cp,
2348       1 &lt;&lt; JVM_CONSTANT_Fieldref, CHECK_VERIFY(this));
2349 
2350   // Get field name and signature
2351   Symbol* field_name = cp-&gt;name_ref_at(index);
2352   Symbol* field_sig = cp-&gt;signature_ref_at(index);
2353 
2354   // Field signature was checked in ClassFileParser.
2355   assert(SignatureVerifier::is_valid_type_signature(field_sig),
2356          &quot;Invalid field signature&quot;);
2357 
2358   // Get referenced class type
2359   VerificationType ref_class_type = cp_ref_index_to_type(
2360     index, cp, CHECK_VERIFY(this));
2361   if (!ref_class_type.is_object() &amp;&amp;
<span class="line-modified">2362       (!allow_arrays || !ref_class_type.is_array())) {</span>
2363     verify_error(ErrorContext::bad_type(bcs-&gt;bci(),
2364         TypeOrigin::cp(index, ref_class_type)),
2365         &quot;Expecting reference to class in class %s at constant pool index %d&quot;,
2366         _klass-&gt;external_name(), index);
2367     return;
2368   }
<span class="line-added">2369 </span>
2370   VerificationType target_class_type = ref_class_type;
2371 
2372   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2373         &quot;buffer type must match VerificationType size&quot;);
2374   uintptr_t field_type_buffer[2];
2375   VerificationType* field_type = (VerificationType*)field_type_buffer;
2376   // If we make a VerificationType[2] array directly, the compiler calls
2377   // to the c-runtime library to do the allocation instead of just
2378   // stack allocating it.  Plus it would run constructors.  This shows up
2379   // in performance profiles.
2380 
2381   SignatureStream sig_stream(field_sig, false);
2382   VerificationType stack_object_type;
2383   int n = change_sig_to_verificationType(&amp;sig_stream, field_type);
2384   u2 bci = bcs-&gt;bci();
2385   bool is_assignable;
2386   switch (bcs-&gt;raw_code()) {
2387     case Bytecodes::_getstatic: {
2388       for (int i = 0; i &lt; n; i++) {
2389         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2390       }
2391       break;
2392     }
2393     case Bytecodes::_putstatic: {
2394       for (int i = n - 1; i &gt;= 0; i--) {
2395         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2396       }
2397       break;
2398     }
<span class="line-added">2399     case Bytecodes::_withfield: {</span>
<span class="line-added">2400       for (int i = n - 1; i &gt;= 0; i--) {</span>
<span class="line-added">2401         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));</span>
<span class="line-added">2402       }</span>
<span class="line-added">2403       // stack_object_type and target_class_type must be the same value type.</span>
<span class="line-added">2404       stack_object_type =</span>
<span class="line-added">2405         current_frame-&gt;pop_stack(VerificationType::valuetype_check(), CHECK_VERIFY(this));</span>
<span class="line-added">2406       VerificationType target_value_type =</span>
<span class="line-added">2407         VerificationType::change_ref_to_valuetype(target_class_type);</span>
<span class="line-added">2408       if (!stack_object_type.equals(target_value_type)) {</span>
<span class="line-added">2409         verify_error(ErrorContext::bad_value_type(bci,</span>
<span class="line-added">2410             current_frame-&gt;stack_top_ctx(),</span>
<span class="line-added">2411             TypeOrigin::cp(index, target_class_type)),</span>
<span class="line-added">2412             &quot;Invalid type on operand stack in withfield instruction&quot;);</span>
<span class="line-added">2413         return;</span>
<span class="line-added">2414       }</span>
<span class="line-added">2415       current_frame-&gt;push_stack(target_value_type, CHECK_VERIFY(this));</span>
<span class="line-added">2416       break;</span>
<span class="line-added">2417     }</span>
2418     case Bytecodes::_getfield: {
2419       stack_object_type = current_frame-&gt;pop_stack(
2420         target_class_type, CHECK_VERIFY(this));
2421       for (int i = 0; i &lt; n; i++) {
2422         current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
2423       }
2424       goto check_protected;
2425     }
2426     case Bytecodes::_putfield: {
2427       for (int i = n - 1; i &gt;= 0; i--) {
2428         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
2429       }
2430       stack_object_type = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
2431 
2432       // The JVMS 2nd edition allows field initialization before the superclass
2433       // initializer, if the field is defined within the current class.
2434       fieldDescriptor fd;
2435       if (stack_object_type == VerificationType::uninitialized_this_type() &amp;&amp;
2436           target_class_type.equals(current_type()) &amp;&amp;
2437           _klass-&gt;find_local_field(field_name, field_sig, &amp;fd)) {
</pre>
<hr />
<pre>
2806 bool ClassVerifier::is_same_or_direct_interface(
2807     InstanceKlass* klass,
2808     VerificationType klass_type,
2809     VerificationType ref_class_type) {
2810   if (ref_class_type.equals(klass_type)) return true;
2811   Array&lt;InstanceKlass*&gt;* local_interfaces = klass-&gt;local_interfaces();
2812   if (local_interfaces != NULL) {
2813     for (int x = 0; x &lt; local_interfaces-&gt;length(); x++) {
2814       InstanceKlass* k = local_interfaces-&gt;at(x);
2815       assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
2816       if (ref_class_type.equals(VerificationType::reference_type(k-&gt;name()))) {
2817         return true;
2818       }
2819     }
2820   }
2821   return false;
2822 }
2823 
2824 void ClassVerifier::verify_invoke_instructions(
2825     RawBytecodeStream* bcs, u4 code_length, StackMapFrame* current_frame,
<span class="line-modified">2826     bool in_try_block, bool *this_uninit,</span>
2827     const constantPoolHandle&amp; cp, StackMapTable* stackmap_table, TRAPS) {
2828   // Make sure the constant pool item is the right type
2829   u2 index = bcs-&gt;get_index_u2();
2830   Bytecodes::Code opcode = bcs-&gt;raw_code();
2831   unsigned int types = 0;
2832   switch (opcode) {
2833     case Bytecodes::_invokeinterface:
2834       types = 1 &lt;&lt; JVM_CONSTANT_InterfaceMethodref;
2835       break;
2836     case Bytecodes::_invokedynamic:
2837       types = 1 &lt;&lt; JVM_CONSTANT_InvokeDynamic;
2838       break;
2839     case Bytecodes::_invokespecial:
2840     case Bytecodes::_invokestatic:
2841       types = (_klass-&gt;major_version() &lt; STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION) ?
2842         (1 &lt;&lt; JVM_CONSTANT_Methodref) :
2843         ((1 &lt;&lt; JVM_CONSTANT_InterfaceMethodref) | (1 &lt;&lt; JVM_CONSTANT_Methodref));
2844       break;
2845     default:
2846       types = 1 &lt;&lt; JVM_CONSTANT_Methodref;
2847   }
2848   verify_cp_type(bcs-&gt;bci(), index, cp, types, CHECK_VERIFY(this));
2849 
2850   // Get method name and signature
2851   Symbol* method_name = cp-&gt;name_ref_at(index);
2852   Symbol* method_sig = cp-&gt;signature_ref_at(index);
2853 
2854   // Method signature was checked in ClassFileParser.
2855   assert(SignatureVerifier::is_valid_method_signature(method_sig),
2856          &quot;Invalid method signature&quot;);
2857 
<span class="line-modified">2858   // Get referenced class</span>
2859   VerificationType ref_class_type;
2860   if (opcode == Bytecodes::_invokedynamic) {
2861     if (_klass-&gt;major_version() &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
2862       class_format_error(
2863         &quot;invokedynamic instructions not supported by this class file version (%d), class %s&quot;,
2864         _klass-&gt;major_version(), _klass-&gt;external_name());
2865       return;
2866     }
2867   } else {
2868     ref_class_type = cp_ref_index_to_type(index, cp, CHECK_VERIFY(this));
2869   }
2870 
2871   assert(sizeof(VerificationType) == sizeof(uintptr_t),
2872         &quot;buffer type must match VerificationType size&quot;);
2873 
2874   // Get the UTF8 index for this signature.
2875   int sig_index = cp-&gt;signature_ref_index_at(cp-&gt;name_and_type_ref_index_at(index));
2876 
2877   // Get the signature&#39;s verification types.
2878   sig_as_verification_types* mth_sig_verif_types;
</pre>
<hr />
<pre>
2904           &quot;Inconsistent args count operand in invokeinterface&quot;);
2905       return;
2906     }
2907     if (*(bcp+4) != 0) {
2908       verify_error(ErrorContext::bad_code(bci),
2909           &quot;Fourth operand byte of invokeinterface must be zero&quot;);
2910       return;
2911     }
2912   }
2913 
2914   if (opcode == Bytecodes::_invokedynamic) {
2915     address bcp = bcs-&gt;bcp();
2916     if (*(bcp+3) != 0 || *(bcp+4) != 0) {
2917       verify_error(ErrorContext::bad_code(bci),
2918           &quot;Third and fourth operand bytes of invokedynamic must be zero&quot;);
2919       return;
2920     }
2921   }
2922 
2923   if (method_name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="line-modified">2924     // Make sure &lt;init&gt; can only be invoked by invokespecial or invokestatic.</span>
<span class="line-modified">2925     // The allowed invocation mode of &lt;init&gt; depends on its signature.</span>
<span class="line-added">2926     if ((opcode != Bytecodes::_invokespecial &amp;&amp;</span>
<span class="line-added">2927          opcode != Bytecodes::_invokestatic) ||</span>
2928         method_name != vmSymbols::object_initializer_name()) {
2929       verify_error(ErrorContext::bad_code(bci),
2930           &quot;Illegal call to internal method&quot;);
2931       return;
2932     }
2933   } else if (opcode == Bytecodes::_invokespecial
2934              &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
2935              &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
<span class="line-modified">2936                   current_class()-&gt;super()-&gt;name()))) { // super() can never be a value_type.</span>
2937     bool subtype = false;
2938     bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
2939     if (!current_class()-&gt;is_unsafe_anonymous()) {
2940       subtype = ref_class_type.is_assignable_from(
2941                  current_type(), this, false, CHECK_VERIFY(this));
2942     } else {
<span class="line-modified">2943       InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();</span>
<span class="line-modified">2944       VerificationType unsafe_anonymous_host_type = reference_or_valuetype(unsafe_host);</span>
2945       subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
2946 
2947       // If invokespecial of IMR, need to recheck for same or
2948       // direct interface relative to the host class
2949       have_imr_indirect = (have_imr_indirect &amp;&amp;
2950                            !is_same_or_direct_interface(
<span class="line-modified">2951                              unsafe_host,</span>
2952                              unsafe_anonymous_host_type, ref_class_type));
2953     }
2954     if (!subtype) {
2955       verify_error(ErrorContext::bad_code(bci),
2956           &quot;Bad invokespecial instruction: &quot;
2957           &quot;current class isn&#39;t assignable to reference class.&quot;);
2958        return;
2959     } else if (have_imr_indirect) {
2960       verify_error(ErrorContext::bad_code(bci),
2961           &quot;Bad invokespecial instruction: &quot;
2962           &quot;interface method reference is in an indirect superinterface.&quot;);
2963       return;
2964     }
2965 
2966   }
2967 
2968   // Get the verification types for the method&#39;s arguments.
2969   GrowableArray&lt;VerificationType&gt;* sig_verif_types = mth_sig_verif_types-&gt;sig_verif_types();
2970   assert(sig_verif_types != NULL, &quot;Missing signature&#39;s array of verification types&quot;);
2971   // Match method descriptor with operand stack
2972   // The arguments are on the stack in descending order.
2973   for (int i = nargs - 1; i &gt;= 0; i--) { // Run backwards
2974     current_frame-&gt;pop_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));
2975   }
2976 
2977   // Check objectref on operand stack
2978   if (opcode != Bytecodes::_invokestatic &amp;&amp;
2979       opcode != Bytecodes::_invokedynamic) {
2980     if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
<span class="line-added">2981       // (use of &lt;init&gt; as a static factory is handled under invokestatic)</span>
2982       verify_invoke_init(bcs, index, ref_class_type, current_frame,
2983         code_length, in_try_block, this_uninit, cp, stackmap_table,
2984         CHECK_VERIFY(this));
2985       if (was_recursively_verified()) return;
2986     } else {   // other methods
2987       // Ensures that target class is assignable to method class.
2988       if (opcode == Bytecodes::_invokespecial) {
2989         if (!current_class()-&gt;is_unsafe_anonymous()) {
2990           current_frame-&gt;pop_stack(current_type(), CHECK_VERIFY(this));
2991         } else {
2992           // anonymous class invokespecial calls: check if the
2993           // objectref is a subtype of the unsafe_anonymous_host of the current class
2994           // to allow an anonymous class to reference methods in the unsafe_anonymous_host
2995           VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
<span class="line-modified">2996 </span>
<span class="line-modified">2997           InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();</span>
<span class="line-modified">2998           VerificationType host_type = reference_or_valuetype(unsafe_host);</span>
<span class="line-added">2999           bool subtype = host_type.is_assignable_from(top, this, false, CHECK_VERIFY(this));</span>
3000           if (!subtype) {
3001             verify_error( ErrorContext::bad_type(current_frame-&gt;offset(),
3002               current_frame-&gt;stack_top_ctx(),
3003               TypeOrigin::implicit(top)),
3004               &quot;Bad type on operand stack&quot;);
3005             return;
3006           }
3007         }
3008       } else if (opcode == Bytecodes::_invokevirtual) {
3009         VerificationType stack_object_type =
3010           current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
3011         if (current_type() != stack_object_type) {
3012           if (was_recursively_verified()) return;
3013           assert(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
3014           Symbol* ref_class_name =
3015             cp-&gt;klass_name_at(cp-&gt;klass_ref_index_at(index));
3016           // See the comments in verify_field_instructions() for
3017           // the rationale behind this.
3018           if (name_in_supers(ref_class_name, current_class())) {
3019             Klass* ref_class = load_class(ref_class_name, CHECK);
</pre>
<hr />
<pre>
3032                 } else {
3033                   verify_error(ErrorContext::bad_type(bci,
3034                       current_frame-&gt;stack_top_ctx(),
3035                       TypeOrigin::implicit(current_type())),
3036                       &quot;Bad access to protected data in invokevirtual&quot;);
3037                   return;
3038                 }
3039               }
3040             }
3041           }
3042         }
3043       } else {
3044         assert(opcode == Bytecodes::_invokeinterface, &quot;Unexpected opcode encountered&quot;);
3045         current_frame-&gt;pop_stack(ref_class_type, CHECK_VERIFY(this));
3046       }
3047     }
3048   }
3049   // Push the result type.
3050   int sig_verif_types_len = sig_verif_types-&gt;length();
3051   if (sig_verif_types_len &gt; nargs) {  // There&#39;s a return type
<span class="line-modified">3052     if (method_name == vmSymbols::object_initializer_name() &amp;&amp;</span>
<span class="line-modified">3053         opcode != Bytecodes::_invokestatic) {</span>
<span class="line-modified">3054       // an &lt;init&gt; method must have a void return type, unless it&#39;s a static factory</span>

3055       verify_error(ErrorContext::bad_code(bci),
3056           &quot;Return type must be void in &lt;init&gt; method&quot;);
3057       return;
3058     }
3059 
3060     assert(sig_verif_types_len &lt;= nargs + 2,
3061            &quot;Signature verification types array return type is bogus&quot;);
3062     for (int i = nargs; i &lt; sig_verif_types_len; i++) {
3063       assert(i == nargs || sig_verif_types-&gt;at(i).is_long2() ||
3064              sig_verif_types-&gt;at(i).is_double2(), &quot;Unexpected return verificationType&quot;);
3065       current_frame-&gt;push_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));
3066     }
<span class="line-added">3067   } else {</span>
<span class="line-added">3068     // an &lt;init&gt; method may not have a void return type, if it&#39;s a static factory</span>
<span class="line-added">3069     if (method_name == vmSymbols::object_initializer_name() &amp;&amp;</span>
<span class="line-added">3070         opcode != Bytecodes::_invokespecial) {</span>
<span class="line-added">3071       verify_error(ErrorContext::bad_code(bci),</span>
<span class="line-added">3072           &quot;Return type must be non-void in &lt;init&gt; static factory method&quot;);</span>
<span class="line-added">3073       return;</span>
<span class="line-added">3074     }</span>
3075   }
3076 }
3077 
3078 VerificationType ClassVerifier::get_newarray_type(
3079     u2 index, u2 bci, TRAPS) {
3080   const char* from_bt[] = {
3081     NULL, NULL, NULL, NULL, &quot;[Z&quot;, &quot;[C&quot;, &quot;[F&quot;, &quot;[D&quot;, &quot;[B&quot;, &quot;[S&quot;, &quot;[I&quot;, &quot;[J&quot;,
3082   };
3083   if (index &lt; T_BOOLEAN || index &gt; T_LONG) {
3084     verify_error(ErrorContext::bad_code(bci), &quot;Illegal newarray instruction&quot;);
3085     return VerificationType::bogus_type();
3086   }
3087 
3088   // from_bt[index] contains the array signature which has a length of 2
3089   Symbol* sig = create_temporary_symbol(from_bt[index], 2);
3090   return VerificationType::reference_type(sig);
3091 }
3092 
3093 void ClassVerifier::verify_anewarray(
3094     u2 bci, u2 index, const constantPoolHandle&amp; cp,
</pre>
<hr />
<pre>
3102     cp_index_to_type(index, cp, CHECK_VERIFY(this));
3103   int length;
3104   char* arr_sig_str;
3105   if (component_type.is_array()) {     // it&#39;s an array
3106     const char* component_name = component_type.name()-&gt;as_utf8();
3107     // Check for more than MAX_ARRAY_DIMENSIONS
3108     length = (int)strlen(component_name);
3109     if (length &gt; MAX_ARRAY_DIMENSIONS &amp;&amp;
3110         component_name[MAX_ARRAY_DIMENSIONS - 1] == JVM_SIGNATURE_ARRAY) {
3111       verify_error(ErrorContext::bad_code(bci),
3112         &quot;Illegal anewarray instruction, array has more than 255 dimensions&quot;);
3113     }
3114     // add one dimension to component
3115     length++;
3116     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3117     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
3118                          JVM_SIGNATURE_ARRAY, component_name);
3119     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3120   } else {         // it&#39;s an object or interface
3121     const char* component_name = component_type.name()-&gt;as_utf8();
<span class="line-modified">3122     char Q_or_L = component_type.is_valuetype() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;</span>
<span class="line-added">3123     // add one dimension to component with &#39;L&#39; or &#39;Q&#39; prepended and &#39;;&#39; appended.</span>
3124     length = (int)strlen(component_name) + 3;
3125     arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
3126     int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
<span class="line-modified">3127                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);</span>
3128     assert(n == length, &quot;Unexpected number of characters in string&quot;);
3129   }
3130   Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
3131   VerificationType new_array_type = VerificationType::reference_type(arr_sig);
3132   current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
3133 }
3134 
3135 void ClassVerifier::verify_iload(u2 index, StackMapFrame* current_frame, TRAPS) {
3136   current_frame-&gt;get_local(
3137     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3138   current_frame-&gt;push_stack(
3139     VerificationType::integer_type(), CHECK_VERIFY(this));
3140 }
3141 
3142 void ClassVerifier::verify_lload(u2 index, StackMapFrame* current_frame, TRAPS) {
3143   current_frame-&gt;get_local_2(
3144     index, VerificationType::long_type(),
3145     VerificationType::long2_type(), CHECK_VERIFY(this));
3146   current_frame-&gt;push_stack_2(
3147     VerificationType::long_type(),
</pre>
<hr />
<pre>
3149 }
3150 
3151 void ClassVerifier::verify_fload(u2 index, StackMapFrame* current_frame, TRAPS) {
3152   current_frame-&gt;get_local(
3153     index, VerificationType::float_type(), CHECK_VERIFY(this));
3154   current_frame-&gt;push_stack(
3155     VerificationType::float_type(), CHECK_VERIFY(this));
3156 }
3157 
3158 void ClassVerifier::verify_dload(u2 index, StackMapFrame* current_frame, TRAPS) {
3159   current_frame-&gt;get_local_2(
3160     index, VerificationType::double_type(),
3161     VerificationType::double2_type(), CHECK_VERIFY(this));
3162   current_frame-&gt;push_stack_2(
3163     VerificationType::double_type(),
3164     VerificationType::double2_type(), CHECK_VERIFY(this));
3165 }
3166 
3167 void ClassVerifier::verify_aload(u2 index, StackMapFrame* current_frame, TRAPS) {
3168   VerificationType type = current_frame-&gt;get_local(
<span class="line-modified">3169     index, VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
3170   current_frame-&gt;push_stack(type, CHECK_VERIFY(this));
3171 }
3172 
3173 void ClassVerifier::verify_istore(u2 index, StackMapFrame* current_frame, TRAPS) {
3174   current_frame-&gt;pop_stack(
3175     VerificationType::integer_type(), CHECK_VERIFY(this));
3176   current_frame-&gt;set_local(
3177     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3178 }
3179 
3180 void ClassVerifier::verify_lstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3181   current_frame-&gt;pop_stack_2(
3182     VerificationType::long2_type(),
3183     VerificationType::long_type(), CHECK_VERIFY(this));
3184   current_frame-&gt;set_local_2(
3185     index, VerificationType::long_type(),
3186     VerificationType::long2_type(), CHECK_VERIFY(this));
3187 }
3188 
3189 void ClassVerifier::verify_fstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3190   current_frame-&gt;pop_stack(VerificationType::float_type(), CHECK_VERIFY(this));
3191   current_frame-&gt;set_local(
3192     index, VerificationType::float_type(), CHECK_VERIFY(this));
3193 }
3194 
3195 void ClassVerifier::verify_dstore(u2 index, StackMapFrame* current_frame, TRAPS) {
3196   current_frame-&gt;pop_stack_2(
3197     VerificationType::double2_type(),
3198     VerificationType::double_type(), CHECK_VERIFY(this));
3199   current_frame-&gt;set_local_2(
3200     index, VerificationType::double_type(),
3201     VerificationType::double2_type(), CHECK_VERIFY(this));
3202 }
3203 
3204 void ClassVerifier::verify_astore(u2 index, StackMapFrame* current_frame, TRAPS) {
3205   VerificationType type = current_frame-&gt;pop_stack(
<span class="line-modified">3206     VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
3207   current_frame-&gt;set_local(index, type, CHECK_VERIFY(this));
3208 }
3209 
3210 void ClassVerifier::verify_iinc(u2 index, StackMapFrame* current_frame, TRAPS) {
3211   VerificationType type = current_frame-&gt;get_local(
3212     index, VerificationType::integer_type(), CHECK_VERIFY(this));
3213   current_frame-&gt;set_local(index, type, CHECK_VERIFY(this));
3214 }
3215 
3216 void ClassVerifier::verify_return_value(
3217     VerificationType return_type, VerificationType type, u2 bci,
3218     StackMapFrame* current_frame, TRAPS) {
3219   if (return_type == VerificationType::bogus_type()) {
3220     verify_error(ErrorContext::bad_type(bci,
3221         current_frame-&gt;stack_top_ctx(), TypeOrigin::signature(return_type)),
3222         &quot;Method expects a return value&quot;);
3223     return;
3224   }
3225   bool match = return_type.is_assignable_from(type, this, false, CHECK_VERIFY(this));
3226   if (!match) {
</pre>
</td>
</tr>
</table>
<center><a href="verificationType.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
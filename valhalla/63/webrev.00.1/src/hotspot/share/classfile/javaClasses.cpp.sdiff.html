<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;


  55 #include &quot;prims/jvmtiExport.hpp&quot;
  56 #include &quot;prims/resolvedMethodTable.hpp&quot;
  57 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  58 #include &quot;runtime/frame.inline.hpp&quot;
  59 #include &quot;runtime/handles.inline.hpp&quot;
  60 #include &quot;runtime/init.hpp&quot;
  61 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  62 #include &quot;runtime/java.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepoint.hpp&quot;
  66 #include &quot;runtime/safepointVerifiers.hpp&quot;
  67 #include &quot;runtime/thread.inline.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vm_version.hpp&quot;
  70 #include &quot;utilities/align.hpp&quot;
  71 #include &quot;utilities/preserveException.hpp&quot;
  72 #include &quot;utilities/utf8.hpp&quot;
  73 #if INCLUDE_JVMCI
  74 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
</pre>
<hr />
<pre>
 967   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 968   k-&gt;set_modifier_flags(computed_modifiers);
 969   // Class_klass has to be loaded because it is used to allocate
 970   // the mirror.
 971   if (SystemDictionary::Class_klass_loaded()) {
 972     // Allocate mirror (java.lang.Class instance)
 973     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 974     Handle mirror(THREAD, mirror_oop);
 975     Handle comp_mirror;
 976 
 977     // Setup indirection from mirror-&gt;klass
 978     java_lang_Class::set_klass(mirror(), k);
 979 
 980     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 981     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 982 
 983     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 984 
 985     // It might also have a component mirror.  This mirror must already exist.
 986     if (k-&gt;is_array_klass()) {
<span class="line-modified"> 987       if (k-&gt;is_typeArray_klass()) {</span>





 988         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 989         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 990       } else {
 991         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 992         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
 993         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
 994         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
 995       }
 996       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
 997 
 998       // Two-way link between the array klass and its component mirror:
 999       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1000       set_component_mirror(mirror(), comp_mirror());
1001       // See below for ordering dependencies between field array_klass in component mirror
1002       // and java_mirror in this klass.
1003     } else {
1004       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1005 
1006       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1007       if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
1014       }
1015     }
1016 
1017     // set the classLoader field in the java_lang_Class instance
1018     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1019     set_class_loader(mirror(), class_loader());
1020 
1021     // Setup indirection from klass-&gt;mirror
1022     // after any exceptions can happen during allocations.
1023     k-&gt;set_java_mirror(mirror);
1024 
1025     // Set the module field in the java_lang_Class instance.  This must be done
1026     // after the mirror is set.
1027     set_mirror_module_field(k, mirror, module, THREAD);
1028 
1029     if (comp_mirror() != NULL) {
1030       // Set after k-&gt;java_mirror() is published, because compiled code running
1031       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1032       release_set_array_klass(comp_mirror(), k);
1033     }

















1034   } else {
1035     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1036     fixup_mirror_list()-&gt;push(k);
1037   }
1038 }
1039 
1040 #if INCLUDE_CDS_JAVA_HEAP
1041 // Clears mirror fields. Static final fields with initial values are reloaded
1042 // from constant pool. The object identity hash is in the object header and is
1043 // not affected.
1044 class ResetMirrorField: public FieldClosure {
1045  private:
1046   Handle _m;
1047 
1048  public:
1049   ResetMirrorField(Handle mirror) : _m(mirror) {}
1050 
1051   void do_field(fieldDescriptor* fd) {
1052     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1053     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
</pre>
<hr />
<pre>
1170 
1171   // No mirror
1172   oop mirror = k-&gt;java_mirror();
1173   if (mirror == NULL) {
1174     return NULL;
1175   }
1176 
1177   if (k-&gt;is_instance_klass()) {
1178     InstanceKlass *ik = InstanceKlass::cast(k);
1179     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1180 
1181     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1182           ik-&gt;is_shared_app_class())) {
1183       // Archiving mirror for classes from non-builtin loaders is not
1184       // supported. Clear the _java_mirror within the archived class.
1185       k-&gt;set_java_mirror_handle(NULL);
1186       return NULL;
1187     }
1188   }
1189 






1190   // Now start archiving the mirror object
1191   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1192   if (archived_mirror == NULL) {
1193     return NULL;
1194   }
1195 
1196   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1197   if (archived_mirror == NULL) {
1198     return NULL;
1199   }
1200 
1201   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1202 
1203   k-&gt;set_has_raw_archived_mirror();
1204 
1205   ResourceMark rm;
1206   log_trace(cds, heap, mirror)(
1207     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1208     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1209 
</pre>
<hr />
<pre>
1461 oop java_lang_Class::name(Handle java_class, TRAPS) {
1462   assert(_name_offset != 0, &quot;must be set&quot;);
1463   oop o = java_class-&gt;obj_field(_name_offset);
1464   if (o == NULL) {
1465     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1466     java_class-&gt;obj_field_put(_name_offset, o);
1467   }
1468   return o;
1469 }
1470 
1471 oop java_lang_Class::source_file(oop java_class) {
1472   assert(_source_file_offset != 0, &quot;must be set&quot;);
1473   return java_class-&gt;obj_field(_source_file_offset);
1474 }
1475 
1476 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1477   assert(_source_file_offset != 0, &quot;must be set&quot;);
1478   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1479 }
1480 




















1481 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1482   // This should be improved by adding a field at the Java level or by
1483   // introducing a new VM klass (see comment in ClassFileParser)
1484   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1485   if (type != T_VOID) {
1486     Klass* aklass = Universe::typeArrayKlassObj(type);
1487     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1488     release_set_array_klass(java_class, aklass);
1489   }
1490 #ifdef ASSERT
1491   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1492   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1493 #endif
1494   return java_class;
1495 }
1496 
1497 
1498 Klass* java_lang_Class::as_Klass(oop java_class) {
1499   //%note memory_2
1500   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
</pre>
<hr />
<pre>
1505 
1506 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1507   //%note memory_2
1508   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1509   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1510   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1511   return k;
1512 }
1513 
1514 
1515 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1516   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1517   java_class-&gt;metadata_field_put(_klass_offset, klass);
1518 }
1519 
1520 
1521 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1522   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1523   Symbol* name = NULL;
1524   bool is_instance = false;

1525   if (is_primitive(java_class)) {
1526     name = vmSymbols::type_signature(primitive_type(java_class));
1527   } else {
1528     Klass* k = as_Klass(java_class);
1529     is_instance = k-&gt;is_instance_klass();

1530     name = k-&gt;name();
1531   }
1532   if (name == NULL) {
1533     st-&gt;print(&quot;&lt;null&gt;&quot;);
1534     return;
1535   }
<span class="line-modified">1536   if (is_instance)  st-&gt;print(&quot;L&quot;);</span>






1537   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1538   if (is_instance)  st-&gt;print(&quot;;&quot;);
1539 }
1540 
1541 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1542   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1543   Symbol* name;
1544   if (is_primitive(java_class)) {
1545     name = vmSymbols::type_signature(primitive_type(java_class));
1546     // Because this can create a new symbol, the caller has to decrement
1547     // the refcount, so make adjustment here and below for symbols returned
1548     // that are not created or incremented due to a successful lookup.
1549     name-&gt;increment_refcount();
1550   } else {
1551     Klass* k = as_Klass(java_class);
1552     if (!k-&gt;is_instance_klass()) {
1553       name = k-&gt;name();
1554       name-&gt;increment_refcount();
1555     } else {
1556       ResourceMark rm;
1557       const char* sigstr = k-&gt;signature_name();
<span class="line-modified">1558       int         siglen = (int) strlen(sigstr);</span>
1559       if (!intern_if_not_found) {
1560         name = SymbolTable::probe(sigstr, siglen);
1561       } else {
1562         name = SymbolTable::new_symbol(sigstr, siglen);
1563       }
1564     }
1565   }
1566   return name;
1567 }
1568 
1569 // Returns the Java name for this Java mirror (Resource allocated)
1570 // See Klass::external_name().
1571 // For primitive type Java mirrors, its type name is returned.
1572 const char* java_lang_Class::as_external_name(oop java_class) {
1573   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1574   const char* name = NULL;
1575   if (is_primitive(java_class)) {
1576     name = type2name(primitive_type(java_class));
1577   } else {
1578     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1623   }
1624 }
1625 
1626 
1627 oop java_lang_Class::primitive_mirror(BasicType t) {
1628   oop mirror = Universe::java_mirror(t);
1629   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1630   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1631   return mirror;
1632 }
1633 
1634 bool java_lang_Class::offsets_computed = false;
1635 int  java_lang_Class::classRedefinedCount_offset = -1;
1636 
1637 #define CLASS_FIELDS_DO(macro) \
1638   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1639   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1640   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1641   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1642   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \


1643   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1644 
1645 void java_lang_Class::compute_offsets() {
1646   if (offsets_computed) {
1647     return;
1648   }
1649 
1650   offsets_computed = true;
1651 
1652   InstanceKlass* k = SystemDictionary::Class_klass();
1653   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1654 
1655   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1656   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1657   // GC treats them the same.
1658   _init_lock_offset = _component_mirror_offset;
1659 
1660   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1661 }
1662 
</pre>
<hr />
<pre>
2498 #endif
2499 
2500     // the format of the stacktrace will be:
2501     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2502     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2503     // - rest of the stack
2504 
2505     if (!skip_fillInStackTrace_check) {
2506       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2507           throwable-&gt;is_a(method-&gt;method_holder())) {
2508         continue;
2509       }
2510       else {
2511         skip_fillInStackTrace_check = true; // gone past them all
2512       }
2513     }
2514     if (!skip_throwableInit_check) {
2515       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2516 
2517       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2518       // This is simlar to classic VM.</span>
<span class="line-modified">2519       if (method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
2520           throwable-&gt;is_a(method-&gt;method_holder())) {
2521         continue;
2522       } else {
2523         // there are none or we&#39;ve seen them all - either way stop checking
2524         skip_throwableInit_check = true;
2525       }
2526     }
2527     if (method-&gt;is_hidden()) {
2528       if (skip_hidden) {
2529         if (total_count == 0) {
2530           // The top frame will be hidden from the stack trace.
2531           bt.set_has_hidden_top_frame(CHECK);
2532         }
2533         continue;
2534       }
2535     }
2536     bt.push(method, bci, CHECK);
2537     total_count++;
2538   }
2539 
</pre>
<hr />
<pre>
3782 int java_lang_invoke_MemberName::flags(oop mname) {
3783   assert(is_instance(mname), &quot;wrong type&quot;);
3784   return mname-&gt;int_field(_flags_offset);
3785 }
3786 
3787 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3788   assert(is_instance(mname), &quot;wrong type&quot;);
3789   mname-&gt;int_field_put(_flags_offset, flags);
3790 }
3791 
3792 
3793 // Return vmtarget from ResolvedMethodName method field through indirection
3794 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3795   assert(is_instance(mname), &quot;wrong type&quot;);
3796   oop method = mname-&gt;obj_field(_method_offset);
3797   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3798 }
3799 
3800 bool java_lang_invoke_MemberName::is_method(oop mname) {
3801   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3802   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) &gt; 0;</span>
3803 }
3804 
3805 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3806   assert(is_instance(mname), &quot;wrong type&quot;);
3807   mname-&gt;obj_field_put(_method_offset, resolved_method);
3808 }
3809 
3810 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3811   assert(is_instance(mname), &quot;wrong type&quot;);
3812   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3813 }
3814 
3815 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3816   assert(is_instance(mname), &quot;wrong type&quot;);
3817   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3818 }
3819 
3820 
3821 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3822   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4288       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4289     } else {
4290       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4291     }
4292   }
4293 };
4294 
4295 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4296   UnsafeConstantsFixup fixup;
4297   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4298 }
4299 
4300 int java_lang_Class::_klass_offset;
4301 int java_lang_Class::_array_klass_offset;
4302 int java_lang_Class::_oop_size_offset;
4303 int java_lang_Class::_static_oop_field_count_offset;
4304 int java_lang_Class::_class_loader_offset;
4305 int java_lang_Class::_module_offset;
4306 int java_lang_Class::_protection_domain_offset;
4307 int java_lang_Class::_component_mirror_offset;


4308 int java_lang_Class::_init_lock_offset;
4309 int java_lang_Class::_signers_offset;
4310 int java_lang_Class::_name_offset;
4311 int java_lang_Class::_source_file_offset;
4312 int java_lang_Class::_classData_offset;
4313 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4314 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4315 int java_lang_Throwable::backtrace_offset;
4316 int java_lang_Throwable::detailMessage_offset;
4317 int java_lang_Throwable::stackTrace_offset;
4318 int java_lang_Throwable::depth_offset;
4319 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4320 int java_lang_reflect_AccessibleObject::override_offset;
4321 int java_lang_reflect_Method::clazz_offset;
4322 int java_lang_reflect_Method::name_offset;
4323 int java_lang_reflect_Method::returnType_offset;
4324 int java_lang_reflect_Method::parameterTypes_offset;
4325 int java_lang_reflect_Method::exceptionTypes_offset;
4326 int java_lang_reflect_Method::slot_offset;
4327 int java_lang_reflect_Method::modifiers_offset;
</pre>
<hr />
<pre>
4382 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4383 int java_lang_AssertionStatusDirectives::deflt_offset;
4384 int java_nio_Buffer::_limit_offset;
4385 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4386 int reflect_ConstantPool::_oop_offset;
4387 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4388 int java_lang_Integer_IntegerCache::_static_cache_offset;
4389 int java_lang_Long_LongCache::_static_cache_offset;
4390 int java_lang_Character_CharacterCache::_static_cache_offset;
4391 int java_lang_Short_ShortCache::_static_cache_offset;
4392 int java_lang_Byte_ByteCache::_static_cache_offset;
4393 int java_lang_Boolean::_static_TRUE_offset;
4394 int java_lang_Boolean::_static_FALSE_offset;
4395 int java_lang_reflect_RecordComponent::clazz_offset;
4396 int java_lang_reflect_RecordComponent::name_offset;
4397 int java_lang_reflect_RecordComponent::type_offset;
4398 int java_lang_reflect_RecordComponent::accessor_offset;
4399 int java_lang_reflect_RecordComponent::signature_offset;
4400 int java_lang_reflect_RecordComponent::annotations_offset;
4401 int java_lang_reflect_RecordComponent::typeAnnotations_offset;





4402 
4403 
4404 
4405 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4406   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4407   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4408   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4409   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4410   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4411   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4412   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4413   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4414 
4415 // Support for java_lang_StackTraceElement
4416 void java_lang_StackTraceElement::compute_offsets() {
4417   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4418   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4419 }
4420 
4421 #if INCLUDE_CDS
</pre>
<hr />
<pre>
4687   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4688   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4689 }
4690 
4691 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4692   oop base = ik-&gt;static_field_base_raw();
4693   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4694 }
4695 
4696 Symbol* java_lang_Byte_ByteCache::symbol() {
4697   return vmSymbols::java_lang_Byte_ByteCache();
4698 }
4699 
4700 #if INCLUDE_CDS
4701 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4702   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4703 }
4704 #endif
4705 #undef BYTE_CACHE_FIELDS_DO
4706 































































4707 jbyte java_lang_Byte::value(oop obj) {
4708    jvalue v;
4709    java_lang_boxing_object::get_value(obj, &amp;v);
4710    return v.b;
4711 }
4712 #define BOOLEAN_FIELDS_DO(macro) \
4713   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4714   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4715 
4716 
4717 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4718   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4719   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4720 }
4721 
4722 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4723   oop base = ik-&gt;static_field_base_raw();
4724   return base-&gt;obj_field(_static_TRUE_offset);
4725 }
4726 
</pre>
</td>
<td>
<hr />
<pre>
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  55 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  56 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/resolvedMethodTable.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/jniHandles.inline.hpp&quot;
  67 #include &quot;runtime/safepoint.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/vframe.inline.hpp&quot;
  71 #include &quot;runtime/vm_version.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/preserveException.hpp&quot;
  74 #include &quot;utilities/utf8.hpp&quot;
  75 #if INCLUDE_JVMCI
  76 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
</pre>
<hr />
<pre>
 969   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 970   k-&gt;set_modifier_flags(computed_modifiers);
 971   // Class_klass has to be loaded because it is used to allocate
 972   // the mirror.
 973   if (SystemDictionary::Class_klass_loaded()) {
 974     // Allocate mirror (java.lang.Class instance)
 975     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 976     Handle mirror(THREAD, mirror_oop);
 977     Handle comp_mirror;
 978 
 979     // Setup indirection from mirror-&gt;klass
 980     java_lang_Class::set_klass(mirror(), k);
 981 
 982     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 983     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 984 
 985     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 986 
 987     // It might also have a component mirror.  This mirror must already exist.
 988     if (k-&gt;is_array_klass()) {
<span class="line-modified"> 989       if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 990         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added"> 991         assert(element_klass-&gt;is_value(), &quot;Must be value type component&quot;);</span>
<span class="line-added"> 992         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));</span>
<span class="line-added"> 993         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());</span>
<span class="line-added"> 994       } else if (k-&gt;is_typeArray_klass()) {</span>
 995         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 996         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 997       } else {
 998         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 999         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1000         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1001         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1002       }
1003       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1004 
1005       // Two-way link between the array klass and its component mirror:
1006       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1007       set_component_mirror(mirror(), comp_mirror());
1008       // See below for ordering dependencies between field array_klass in component mirror
1009       // and java_mirror in this klass.
1010     } else {
1011       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1012 
1013       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1014       if (HAS_PENDING_EXCEPTION) {
</pre>
<hr />
<pre>
1021       }
1022     }
1023 
1024     // set the classLoader field in the java_lang_Class instance
1025     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1026     set_class_loader(mirror(), class_loader());
1027 
1028     // Setup indirection from klass-&gt;mirror
1029     // after any exceptions can happen during allocations.
1030     k-&gt;set_java_mirror(mirror);
1031 
1032     // Set the module field in the java_lang_Class instance.  This must be done
1033     // after the mirror is set.
1034     set_mirror_module_field(k, mirror, module, THREAD);
1035 
1036     if (comp_mirror() != NULL) {
1037       // Set after k-&gt;java_mirror() is published, because compiled code running
1038       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1039       release_set_array_klass(comp_mirror(), k);
1040     }
<span class="line-added">1041 </span>
<span class="line-added">1042     if (k-&gt;is_value()) {</span>
<span class="line-added">1043       InstanceKlass* super = k-&gt;java_super();</span>
<span class="line-added">1044       set_val_type_mirror(mirror(), mirror());</span>
<span class="line-added">1045 </span>
<span class="line-added">1046       // if the supertype is a restricted abstract class</span>
<span class="line-added">1047       if (super != SystemDictionary::Object_klass()) {</span>
<span class="line-added">1048         assert(super-&gt;access_flags().is_abstract(), &quot;must be an abstract class&quot;);</span>
<span class="line-added">1049         oop ref_type_oop = super-&gt;java_mirror();</span>
<span class="line-added">1050         // set the reference projection type</span>
<span class="line-added">1051         set_ref_type_mirror(mirror(), ref_type_oop);</span>
<span class="line-added">1052 </span>
<span class="line-added">1053         // set the value and reference projection types</span>
<span class="line-added">1054         set_val_type_mirror(ref_type_oop, mirror());</span>
<span class="line-added">1055         set_ref_type_mirror(ref_type_oop, ref_type_oop);</span>
<span class="line-added">1056       }</span>
<span class="line-added">1057     }</span>
1058   } else {
1059     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1060     fixup_mirror_list()-&gt;push(k);
1061   }
1062 }
1063 
1064 #if INCLUDE_CDS_JAVA_HEAP
1065 // Clears mirror fields. Static final fields with initial values are reloaded
1066 // from constant pool. The object identity hash is in the object header and is
1067 // not affected.
1068 class ResetMirrorField: public FieldClosure {
1069  private:
1070   Handle _m;
1071 
1072  public:
1073   ResetMirrorField(Handle mirror) : _m(mirror) {}
1074 
1075   void do_field(fieldDescriptor* fd) {
1076     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1077     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
</pre>
<hr />
<pre>
1194 
1195   // No mirror
1196   oop mirror = k-&gt;java_mirror();
1197   if (mirror == NULL) {
1198     return NULL;
1199   }
1200 
1201   if (k-&gt;is_instance_klass()) {
1202     InstanceKlass *ik = InstanceKlass::cast(k);
1203     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1204 
1205     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1206           ik-&gt;is_shared_app_class())) {
1207       // Archiving mirror for classes from non-builtin loaders is not
1208       // supported. Clear the _java_mirror within the archived class.
1209       k-&gt;set_java_mirror_handle(NULL);
1210       return NULL;
1211     }
1212   }
1213 
<span class="line-added">1214   if (k-&gt;is_value()) {</span>
<span class="line-added">1215     // Values have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS</span>
<span class="line-added">1216     k-&gt;set_java_mirror_handle(NULL);</span>
<span class="line-added">1217     return NULL;</span>
<span class="line-added">1218   }</span>
<span class="line-added">1219 </span>
1220   // Now start archiving the mirror object
1221   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1222   if (archived_mirror == NULL) {
1223     return NULL;
1224   }
1225 
1226   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1227   if (archived_mirror == NULL) {
1228     return NULL;
1229   }
1230 
1231   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1232 
1233   k-&gt;set_has_raw_archived_mirror();
1234 
1235   ResourceMark rm;
1236   log_trace(cds, heap, mirror)(
1237     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1238     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1239 
</pre>
<hr />
<pre>
1491 oop java_lang_Class::name(Handle java_class, TRAPS) {
1492   assert(_name_offset != 0, &quot;must be set&quot;);
1493   oop o = java_class-&gt;obj_field(_name_offset);
1494   if (o == NULL) {
1495     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1496     java_class-&gt;obj_field_put(_name_offset, o);
1497   }
1498   return o;
1499 }
1500 
1501 oop java_lang_Class::source_file(oop java_class) {
1502   assert(_source_file_offset != 0, &quot;must be set&quot;);
1503   return java_class-&gt;obj_field(_source_file_offset);
1504 }
1505 
1506 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1507   assert(_source_file_offset != 0, &quot;must be set&quot;);
1508   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1509 }
1510 
<span class="line-added">1511 oop java_lang_Class::val_type_mirror(oop java_class) {</span>
<span class="line-added">1512   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1513   return java_class-&gt;obj_field(_val_type_mirror_offset);</span>
<span class="line-added">1514 }</span>
<span class="line-added">1515 </span>
<span class="line-added">1516 void java_lang_Class::set_val_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1517   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1518   java_class-&gt;obj_field_put(_val_type_mirror_offset, mirror);</span>
<span class="line-added">1519 }</span>
<span class="line-added">1520 </span>
<span class="line-added">1521 oop java_lang_Class::ref_type_mirror(oop java_class) {</span>
<span class="line-added">1522   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1523   return java_class-&gt;obj_field(_ref_type_mirror_offset);</span>
<span class="line-added">1524 }</span>
<span class="line-added">1525 </span>
<span class="line-added">1526 void java_lang_Class::set_ref_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1527   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1528   java_class-&gt;obj_field_put(_ref_type_mirror_offset, mirror);</span>
<span class="line-added">1529 }</span>
<span class="line-added">1530 </span>
1531 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1532   // This should be improved by adding a field at the Java level or by
1533   // introducing a new VM klass (see comment in ClassFileParser)
1534   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1535   if (type != T_VOID) {
1536     Klass* aklass = Universe::typeArrayKlassObj(type);
1537     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1538     release_set_array_klass(java_class, aklass);
1539   }
1540 #ifdef ASSERT
1541   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1542   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1543 #endif
1544   return java_class;
1545 }
1546 
1547 
1548 Klass* java_lang_Class::as_Klass(oop java_class) {
1549   //%note memory_2
1550   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
</pre>
<hr />
<pre>
1555 
1556 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1557   //%note memory_2
1558   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1559   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1560   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1561   return k;
1562 }
1563 
1564 
1565 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1566   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1567   java_class-&gt;metadata_field_put(_klass_offset, klass);
1568 }
1569 
1570 
1571 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1572   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1573   Symbol* name = NULL;
1574   bool is_instance = false;
<span class="line-added">1575   bool is_value = false;</span>
1576   if (is_primitive(java_class)) {
1577     name = vmSymbols::type_signature(primitive_type(java_class));
1578   } else {
1579     Klass* k = as_Klass(java_class);
1580     is_instance = k-&gt;is_instance_klass();
<span class="line-added">1581     is_value = k-&gt;is_value();</span>
1582     name = k-&gt;name();
1583   }
1584   if (name == NULL) {
1585     st-&gt;print(&quot;&lt;null&gt;&quot;);
1586     return;
1587   }
<span class="line-modified">1588   if (is_instance)  {</span>
<span class="line-added">1589     if (is_value) {</span>
<span class="line-added">1590       st-&gt;print(&quot;Q&quot;);</span>
<span class="line-added">1591     } else {</span>
<span class="line-added">1592       st-&gt;print(&quot;L&quot;);</span>
<span class="line-added">1593     }</span>
<span class="line-added">1594   }</span>
1595   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1596   if (is_instance)  st-&gt;print(&quot;;&quot;);
1597 }
1598 
1599 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1600   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1601   Symbol* name;
1602   if (is_primitive(java_class)) {
1603     name = vmSymbols::type_signature(primitive_type(java_class));
1604     // Because this can create a new symbol, the caller has to decrement
1605     // the refcount, so make adjustment here and below for symbols returned
1606     // that are not created or incremented due to a successful lookup.
1607     name-&gt;increment_refcount();
1608   } else {
1609     Klass* k = as_Klass(java_class);
1610     if (!k-&gt;is_instance_klass()) {
1611       name = k-&gt;name();
1612       name-&gt;increment_refcount();
1613     } else {
1614       ResourceMark rm;
1615       const char* sigstr = k-&gt;signature_name();
<span class="line-modified">1616       int siglen = (int) strlen(sigstr);</span>
1617       if (!intern_if_not_found) {
1618         name = SymbolTable::probe(sigstr, siglen);
1619       } else {
1620         name = SymbolTable::new_symbol(sigstr, siglen);
1621       }
1622     }
1623   }
1624   return name;
1625 }
1626 
1627 // Returns the Java name for this Java mirror (Resource allocated)
1628 // See Klass::external_name().
1629 // For primitive type Java mirrors, its type name is returned.
1630 const char* java_lang_Class::as_external_name(oop java_class) {
1631   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1632   const char* name = NULL;
1633   if (is_primitive(java_class)) {
1634     name = type2name(primitive_type(java_class));
1635   } else {
1636     name = as_Klass(java_class)-&gt;external_name();
</pre>
<hr />
<pre>
1681   }
1682 }
1683 
1684 
1685 oop java_lang_Class::primitive_mirror(BasicType t) {
1686   oop mirror = Universe::java_mirror(t);
1687   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1688   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1689   return mirror;
1690 }
1691 
1692 bool java_lang_Class::offsets_computed = false;
1693 int  java_lang_Class::classRedefinedCount_offset = -1;
1694 
1695 #define CLASS_FIELDS_DO(macro) \
1696   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1697   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1698   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1699   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1700   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
<span class="line-added">1701   macro(_val_type_mirror_offset,    k, &quot;valType&quot;,             class_signature,       false); \</span>
<span class="line-added">1702   macro(_ref_type_mirror_offset,    k, &quot;refType&quot;,             class_signature,       false); \</span>
1703   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1704 
1705 void java_lang_Class::compute_offsets() {
1706   if (offsets_computed) {
1707     return;
1708   }
1709 
1710   offsets_computed = true;
1711 
1712   InstanceKlass* k = SystemDictionary::Class_klass();
1713   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1714 
1715   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1716   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1717   // GC treats them the same.
1718   _init_lock_offset = _component_mirror_offset;
1719 
1720   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1721 }
1722 
</pre>
<hr />
<pre>
2558 #endif
2559 
2560     // the format of the stacktrace will be:
2561     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2562     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2563     // - rest of the stack
2564 
2565     if (!skip_fillInStackTrace_check) {
2566       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2567           throwable-&gt;is_a(method-&gt;method_holder())) {
2568         continue;
2569       }
2570       else {
2571         skip_fillInStackTrace_check = true; // gone past them all
2572       }
2573     }
2574     if (!skip_throwableInit_check) {
2575       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2576 
2577       // skip &lt;init&gt; methods of the exception class and superclasses
<span class="line-modified">2578       // This is similar to classic VM (before HotSpot).</span>
<span class="line-modified">2579       if (method-&gt;is_object_constructor() &amp;&amp;</span>
2580           throwable-&gt;is_a(method-&gt;method_holder())) {
2581         continue;
2582       } else {
2583         // there are none or we&#39;ve seen them all - either way stop checking
2584         skip_throwableInit_check = true;
2585       }
2586     }
2587     if (method-&gt;is_hidden()) {
2588       if (skip_hidden) {
2589         if (total_count == 0) {
2590           // The top frame will be hidden from the stack trace.
2591           bt.set_has_hidden_top_frame(CHECK);
2592         }
2593         continue;
2594       }
2595     }
2596     bt.push(method, bci, CHECK);
2597     total_count++;
2598   }
2599 
</pre>
<hr />
<pre>
3842 int java_lang_invoke_MemberName::flags(oop mname) {
3843   assert(is_instance(mname), &quot;wrong type&quot;);
3844   return mname-&gt;int_field(_flags_offset);
3845 }
3846 
3847 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3848   assert(is_instance(mname), &quot;wrong type&quot;);
3849   mname-&gt;int_field_put(_flags_offset, flags);
3850 }
3851 
3852 
3853 // Return vmtarget from ResolvedMethodName method field through indirection
3854 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3855   assert(is_instance(mname), &quot;wrong type&quot;);
3856   oop method = mname-&gt;obj_field(_method_offset);
3857   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3858 }
3859 
3860 bool java_lang_invoke_MemberName::is_method(oop mname) {
3861   assert(is_instance(mname), &quot;must be MemberName&quot;);
<span class="line-modified">3862   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) &gt; 0;</span>
3863 }
3864 
3865 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3866   assert(is_instance(mname), &quot;wrong type&quot;);
3867   mname-&gt;obj_field_put(_method_offset, resolved_method);
3868 }
3869 
3870 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3871   assert(is_instance(mname), &quot;wrong type&quot;);
3872   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3873 }
3874 
3875 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3876   assert(is_instance(mname), &quot;wrong type&quot;);
3877   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3878 }
3879 
3880 
3881 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3882   assert(is_instance(resolved_method), &quot;wrong type&quot;);
</pre>
<hr />
<pre>
4348       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4349     } else {
4350       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4351     }
4352   }
4353 };
4354 
4355 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4356   UnsafeConstantsFixup fixup;
4357   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4358 }
4359 
4360 int java_lang_Class::_klass_offset;
4361 int java_lang_Class::_array_klass_offset;
4362 int java_lang_Class::_oop_size_offset;
4363 int java_lang_Class::_static_oop_field_count_offset;
4364 int java_lang_Class::_class_loader_offset;
4365 int java_lang_Class::_module_offset;
4366 int java_lang_Class::_protection_domain_offset;
4367 int java_lang_Class::_component_mirror_offset;
<span class="line-added">4368 int java_lang_Class::_val_type_mirror_offset;</span>
<span class="line-added">4369 int java_lang_Class::_ref_type_mirror_offset;</span>
4370 int java_lang_Class::_init_lock_offset;
4371 int java_lang_Class::_signers_offset;
4372 int java_lang_Class::_name_offset;
4373 int java_lang_Class::_source_file_offset;
4374 int java_lang_Class::_classData_offset;
4375 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4376 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4377 int java_lang_Throwable::backtrace_offset;
4378 int java_lang_Throwable::detailMessage_offset;
4379 int java_lang_Throwable::stackTrace_offset;
4380 int java_lang_Throwable::depth_offset;
4381 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4382 int java_lang_reflect_AccessibleObject::override_offset;
4383 int java_lang_reflect_Method::clazz_offset;
4384 int java_lang_reflect_Method::name_offset;
4385 int java_lang_reflect_Method::returnType_offset;
4386 int java_lang_reflect_Method::parameterTypes_offset;
4387 int java_lang_reflect_Method::exceptionTypes_offset;
4388 int java_lang_reflect_Method::slot_offset;
4389 int java_lang_reflect_Method::modifiers_offset;
</pre>
<hr />
<pre>
4444 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4445 int java_lang_AssertionStatusDirectives::deflt_offset;
4446 int java_nio_Buffer::_limit_offset;
4447 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4448 int reflect_ConstantPool::_oop_offset;
4449 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4450 int java_lang_Integer_IntegerCache::_static_cache_offset;
4451 int java_lang_Long_LongCache::_static_cache_offset;
4452 int java_lang_Character_CharacterCache::_static_cache_offset;
4453 int java_lang_Short_ShortCache::_static_cache_offset;
4454 int java_lang_Byte_ByteCache::_static_cache_offset;
4455 int java_lang_Boolean::_static_TRUE_offset;
4456 int java_lang_Boolean::_static_FALSE_offset;
4457 int java_lang_reflect_RecordComponent::clazz_offset;
4458 int java_lang_reflect_RecordComponent::name_offset;
4459 int java_lang_reflect_RecordComponent::type_offset;
4460 int java_lang_reflect_RecordComponent::accessor_offset;
4461 int java_lang_reflect_RecordComponent::signature_offset;
4462 int java_lang_reflect_RecordComponent::annotations_offset;
4463 int java_lang_reflect_RecordComponent::typeAnnotations_offset;
<span class="line-added">4464 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-added">4465 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-added">4466 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-added">4467 int jdk_internal_vm_jni_SubElementSelector::_isFlattened_offset;</span>
<span class="line-added">4468 int jdk_internal_vm_jni_SubElementSelector::_isFlattenable_offset;</span>
4469 
4470 
4471 
4472 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4473   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4474   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4475   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4476   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4477   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4478   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4479   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4480   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4481 
4482 // Support for java_lang_StackTraceElement
4483 void java_lang_StackTraceElement::compute_offsets() {
4484   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4485   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4486 }
4487 
4488 #if INCLUDE_CDS
</pre>
<hr />
<pre>
4754   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4755   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4756 }
4757 
4758 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4759   oop base = ik-&gt;static_field_base_raw();
4760   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4761 }
4762 
4763 Symbol* java_lang_Byte_ByteCache::symbol() {
4764   return vmSymbols::java_lang_Byte_ByteCache();
4765 }
4766 
4767 #if INCLUDE_CDS
4768 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4769   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4770 }
4771 #endif
4772 #undef BYTE_CACHE_FIELDS_DO
4773 
<span class="line-added">4774 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \</span>
<span class="line-added">4775   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \</span>
<span class="line-added">4776   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \</span>
<span class="line-added">4777   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \</span>
<span class="line-added">4778   macro(_isFlattened_offset,       k, &quot;isFlattened&quot;,      bool_signature,  false); \</span>
<span class="line-added">4779   macro(_isFlattenable_offset,     k, &quot;isFlattenable&quot;,    bool_signature,  false);</span>
<span class="line-added">4780 </span>
<span class="line-added">4781 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {</span>
<span class="line-added">4782   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();</span>
<span class="line-added">4783   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4784 }</span>
<span class="line-added">4785 </span>
<span class="line-added">4786 #if INCLUDE_CDS</span>
<span class="line-added">4787 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4788   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4789 }</span>
<span class="line-added">4790 #endif</span>
<span class="line-added">4791 #undef SUBELEMENT_SELECTOR_FIELDS_DO</span>
<span class="line-added">4792 </span>
<span class="line-added">4793 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {</span>
<span class="line-added">4794   return vmSymbols::jdk_internal_vm_jni_SubElementSelector();</span>
<span class="line-added">4795 }</span>
<span class="line-added">4796 </span>
<span class="line-added">4797 oop jdk_internal_vm_jni_SubElementSelector::getArrayElementType(oop obj) {</span>
<span class="line-added">4798   return obj-&gt;obj_field(_arrayElementType_offset);</span>
<span class="line-added">4799 }</span>
<span class="line-added">4800 </span>
<span class="line-added">4801 void jdk_internal_vm_jni_SubElementSelector::setArrayElementType(oop obj, oop type) {</span>
<span class="line-added">4802   obj-&gt;obj_field_put(_arrayElementType_offset, type);</span>
<span class="line-added">4803 }</span>
<span class="line-added">4804 </span>
<span class="line-added">4805 oop jdk_internal_vm_jni_SubElementSelector::getSubElementType(oop obj) {</span>
<span class="line-added">4806   return obj-&gt;obj_field(_subElementType_offset);</span>
<span class="line-added">4807 }</span>
<span class="line-added">4808 </span>
<span class="line-added">4809 void jdk_internal_vm_jni_SubElementSelector::setSubElementType(oop obj, oop type) {</span>
<span class="line-added">4810   obj-&gt;obj_field_put(_subElementType_offset, type);</span>
<span class="line-added">4811 }</span>
<span class="line-added">4812 </span>
<span class="line-added">4813 int jdk_internal_vm_jni_SubElementSelector::getOffset(oop obj) {</span>
<span class="line-added">4814   return obj-&gt;int_field(_offset_offset);</span>
<span class="line-added">4815 }</span>
<span class="line-added">4816 </span>
<span class="line-added">4817 void jdk_internal_vm_jni_SubElementSelector::setOffset(oop obj, int offset) {</span>
<span class="line-added">4818   obj-&gt;int_field_put(_offset_offset, offset);</span>
<span class="line-added">4819 }</span>
<span class="line-added">4820 </span>
<span class="line-added">4821 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattened(oop obj) {</span>
<span class="line-added">4822   return obj-&gt;bool_field(_isFlattened_offset);</span>
<span class="line-added">4823 }</span>
<span class="line-added">4824 </span>
<span class="line-added">4825 void jdk_internal_vm_jni_SubElementSelector::setIsFlattened(oop obj, bool b) {</span>
<span class="line-added">4826   obj-&gt;bool_field_put(_isFlattened_offset, b);</span>
<span class="line-added">4827 }</span>
<span class="line-added">4828 </span>
<span class="line-added">4829 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(oop obj) {</span>
<span class="line-added">4830   return obj-&gt;bool_field(_isFlattenable_offset);</span>
<span class="line-added">4831 }</span>
<span class="line-added">4832 </span>
<span class="line-added">4833 void jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(oop obj, bool b) {</span>
<span class="line-added">4834   obj-&gt;bool_field_put(_isFlattenable_offset, b);</span>
<span class="line-added">4835 }</span>
<span class="line-added">4836 </span>
4837 jbyte java_lang_Byte::value(oop obj) {
4838    jvalue v;
4839    java_lang_boxing_object::get_value(obj, &amp;v);
4840    return v.b;
4841 }
4842 #define BOOLEAN_FIELDS_DO(macro) \
4843   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4844   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4845 
4846 
4847 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4848   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4849   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4850 }
4851 
4852 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4853   oop base = ik-&gt;static_field_base_raw();
4854   return base-&gt;obj_field(_static_TRUE_offset);
4855 }
4856 
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="javaClasses.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
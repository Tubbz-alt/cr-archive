<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/classfile/verifier.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="verificationType.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/verifier.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -58,10 +58,11 @@</span>
  #include &quot;utilities/bytes.hpp&quot;
  
  #define NOFAILOVER_MAJOR_VERSION                       51
  #define NONZERO_PADDING_BYTES_IN_SWITCH_MAJOR_VERSION  51
  #define STATIC_METHOD_IN_INTERFACE_MAJOR_VERSION       52
<span class="udiff-line-added">+ #define VALUETYPE_MAJOR_VERSION                        56</span>
  #define MAX_ARRAY_DIMENSIONS 255
  
  // Access to external entry for VerifyClassForMajorVersion - old byte code verifier
  
  extern &quot;C&quot; {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -262,11 +263,11 @@</span>
    bool is_reflect = refl_magic_klass != NULL &amp;&amp; klass-&gt;is_subtype_of(refl_magic_klass);
  
    return (should_verify_for(klass-&gt;class_loader(), should_verify_class) &amp;&amp;
      // return if the class is a bootstrapping class
      // or defineClass specified not to verify by default (flags override passed arg)
<span class="udiff-line-modified-removed">-     // We need to skip the following four for bootstraping</span>
<span class="udiff-line-modified-added">+     // We need to skip the following four for bootstrapping</span>
      name != vmSymbols::java_lang_Object() &amp;&amp;
      name != vmSymbols::java_lang_Class() &amp;&amp;
      name != vmSymbols::java_lang_String() &amp;&amp;
      name != vmSymbols::java_lang_Throwable() &amp;&amp;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -484,10 +485,17 @@</span>
        ss-&gt;print(&quot;Expected stackmap frame at this location.&quot;);
        break;
      case BAD_STACKMAP:
        ss-&gt;print(&quot;Invalid stackmap specification.&quot;);
        break;
<span class="udiff-line-added">+     case WRONG_VALUE_TYPE:</span>
<span class="udiff-line-added">+       ss-&gt;print(&quot;Type &quot;);</span>
<span class="udiff-line-added">+       _type.details(ss);</span>
<span class="udiff-line-added">+       ss-&gt;print(&quot; and type &quot;);</span>
<span class="udiff-line-added">+       _expected.details(ss);</span>
<span class="udiff-line-added">+       ss-&gt;print(&quot; must be identical inline types.&quot;);</span>
<span class="udiff-line-added">+       break;</span>
      case UNKNOWN:
      default:
        ShouldNotReachHere();
        ss-&gt;print_cr(&quot;Unknown&quot;);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -578,15 +586,23 @@</span>
    }
  }
  
  // Methods in ClassVerifier
  
<span class="udiff-line-added">+ VerificationType reference_or_valuetype(InstanceKlass* klass) {</span>
<span class="udiff-line-added">+   if (klass-&gt;is_value()) {</span>
<span class="udiff-line-added">+     return VerificationType::valuetype_type(klass-&gt;name());</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     return VerificationType::reference_type(klass-&gt;name());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  ClassVerifier::ClassVerifier(
      InstanceKlass* klass, TRAPS)
      : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),
        _message(NULL), _method_signatures_table(NULL), _klass(klass) {
<span class="udiff-line-modified-removed">-   _this_type = VerificationType::reference_type(klass-&gt;name());</span>
<span class="udiff-line-modified-added">+   _this_type = reference_or_valuetype(klass);</span>
  }
  
  ClassVerifier::~ClassVerifier() {
    // Decrement the reference count for any symbols created.
    if (_symbols != NULL) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1027,11 +1043,11 @@</span>
          case Bytecodes::_aaload : {
            type = current_frame.pop_stack(
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
<span class="udiff-line-modified-removed">-           if (!atype.is_reference_array()) {</span>
<span class="udiff-line-modified-added">+           if (!atype.is_nonscalar_array()) {</span>
              verify_error(ErrorContext::bad_type(bci,
                  current_frame.stack_top_ctx(),
                  TypeOrigin::implicit(VerificationType::reference_check())),
                  bad_type_msg, &quot;aaload&quot;);
              return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1201,11 +1217,11 @@</span>
            type2 = current_frame.pop_stack(
              VerificationType::integer_type(), CHECK_VERIFY(this));
            atype = current_frame.pop_stack(
              VerificationType::reference_check(), CHECK_VERIFY(this));
            // more type-checking is done at runtime
<span class="udiff-line-modified-removed">-           if (!atype.is_reference_array()) {</span>
<span class="udiff-line-modified-added">+           if (!atype.is_nonscalar_array()) {</span>
              verify_error(ErrorContext::bad_type(bci,
                  current_frame.stack_top_ctx(),
                  TypeOrigin::implicit(VerificationType::reference_check())),
                  bad_type_msg, &quot;aastore&quot;);
              return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1601,16 +1617,16 @@</span>
              &amp;current_frame, target, CHECK_VERIFY(this));
            no_control_flow = false; break;
          case Bytecodes::_if_acmpeq :
          case Bytecodes::_if_acmpne :
            current_frame.pop_stack(
<span class="udiff-line-modified-removed">-             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
<span class="udiff-line-modified-added">+             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
            // fall through
          case Bytecodes::_ifnull :
          case Bytecodes::_ifnonnull :
            current_frame.pop_stack(
<span class="udiff-line-modified-removed">-             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
<span class="udiff-line-modified-added">+             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
            target = bcs.dest();
            stackmap_table.check_jump_target
              (&amp;current_frame, target, CHECK_VERIFY(this));
            no_control_flow = false; break;
          case Bytecodes::_goto :
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1657,11 +1673,11 @@</span>
            verify_return_value(return_type, type, bci,
                                &amp;current_frame, CHECK_VERIFY(this));
            no_control_flow = true; break;
          case Bytecodes::_areturn :
            type = current_frame.pop_stack(
<span class="udiff-line-modified-removed">-             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
<span class="udiff-line-modified-added">+             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
            verify_return_value(return_type, type, bci,
                                &amp;current_frame, CHECK_VERIFY(this));
            no_control_flow = true; break;
          case Bytecodes::_return :
            if (return_type != VerificationType::bogus_type()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1669,11 +1685,11 @@</span>
                           &quot;Method expects a return value&quot;);
              return;
            }
            // Make sure &quot;this&quot; has been initialized if current method is an
            // &lt;init&gt;.
<span class="udiff-line-modified-removed">-           if (_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;</span>
<span class="udiff-line-modified-added">+           if (_method-&gt;is_object_constructor() &amp;&amp;</span>
                current_frame.flag_this_uninit()) {
              verify_error(ErrorContext::bad_code(bci),
                           &quot;Constructor must call super() or this() &quot;
                           &quot;before return&quot;);
              return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1689,22 +1705,29 @@</span>
          case Bytecodes::_putfield :
            // pass FALSE, operand can&#39;t be an array type for getfield/putfield.
            verify_field_instructions(
              &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));
            no_control_flow = false; break;
<span class="udiff-line-added">+         case Bytecodes::_withfield :</span>
<span class="udiff-line-added">+           if (_klass-&gt;major_version() &lt; VALUETYPE_MAJOR_VERSION) {</span>
<span class="udiff-line-added">+             class_format_error(</span>
<span class="udiff-line-added">+               &quot;withfield not supported by this class file version (%d.%d), class %s&quot;,</span>
<span class="udiff-line-added">+               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           // pass FALSE, operand can&#39;t be an array type for withfield.</span>
<span class="udiff-line-added">+           verify_field_instructions(</span>
<span class="udiff-line-added">+             &amp;bcs, &amp;current_frame, cp, false, CHECK_VERIFY(this));</span>
<span class="udiff-line-added">+           no_control_flow = false; break;</span>
          case Bytecodes::_invokevirtual :
          case Bytecodes::_invokespecial :
          case Bytecodes::_invokestatic :
<span class="udiff-line-removed">-           verify_invoke_instructions(</span>
<span class="udiff-line-removed">-             &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),</span>
<span class="udiff-line-removed">-             &amp;this_uninit, return_type, cp, &amp;stackmap_table, CHECK_VERIFY(this));</span>
<span class="udiff-line-removed">-           no_control_flow = false; break;</span>
          case Bytecodes::_invokeinterface :
          case Bytecodes::_invokedynamic :
            verify_invoke_instructions(
              &amp;bcs, code_length, &amp;current_frame, (bci &gt;= ex_min &amp;&amp; bci &lt; ex_max),
<span class="udiff-line-modified-removed">-             &amp;this_uninit, return_type, cp, &amp;stackmap_table, CHECK_VERIFY(this));</span>
<span class="udiff-line-modified-added">+             &amp;this_uninit, cp, &amp;stackmap_table, CHECK_VERIFY(this));</span>
            no_control_flow = false; break;
          case Bytecodes::_new :
          {
            index = bcs.get_index_u2();
            verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1718,10 +1741,32 @@</span>
            }
            type = VerificationType::uninitialized_type(bci);
            current_frame.push_stack(type, CHECK_VERIFY(this));
            no_control_flow = false; break;
          }
<span class="udiff-line-added">+         case Bytecodes::_defaultvalue :</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           if (_klass-&gt;major_version() &lt; VALUETYPE_MAJOR_VERSION) {</span>
<span class="udiff-line-added">+             class_format_error(</span>
<span class="udiff-line-added">+               &quot;defaultvalue not supported by this class file version (%d.%d), class %s&quot;,</span>
<span class="udiff-line-added">+               _klass-&gt;major_version(), _klass-&gt;minor_version(), _klass-&gt;external_name());</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           index = bcs.get_index_u2();</span>
<span class="udiff-line-added">+           verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));</span>
<span class="udiff-line-added">+           VerificationType ref_type = cp_index_to_type(index, cp, CHECK_VERIFY(this));</span>
<span class="udiff-line-added">+           if (!ref_type.is_object()) {</span>
<span class="udiff-line-added">+             verify_error(ErrorContext::bad_type(bci,</span>
<span class="udiff-line-added">+                 TypeOrigin::cp(index, ref_type)),</span>
<span class="udiff-line-added">+                 &quot;Illegal defaultvalue instruction&quot;);</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+           VerificationType value_type =</span>
<span class="udiff-line-added">+             VerificationType::change_ref_to_valuetype(ref_type);</span>
<span class="udiff-line-added">+           current_frame.push_stack(value_type, CHECK_VERIFY(this));</span>
<span class="udiff-line-added">+           no_control_flow = false; break;</span>
<span class="udiff-line-added">+         }</span>
          case Bytecodes::_newarray :
            type = get_newarray_type(bcs.get_index(), bci, CHECK_VERIFY(this));
            current_frame.pop_stack(
              VerificationType::integer_type(),  CHECK_VERIFY(this));
            current_frame.push_stack(type, CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1758,14 +1803,15 @@</span>
            current_frame.push_stack(
              VerificationType::integer_type(), CHECK_VERIFY(this));
            no_control_flow = false; break;
          }
          case Bytecodes::_monitorenter :
<span class="udiff-line-modified-removed">-         case Bytecodes::_monitorexit :</span>
<span class="udiff-line-modified-removed">-           current_frame.pop_stack(</span>
<span class="udiff-line-modified-removed">-             VerificationType::reference_check(), CHECK_VERIFY(this));</span>
<span class="udiff-line-modified-added">+         case Bytecodes::_monitorexit : {</span>
<span class="udiff-line-modified-added">+           VerificationType ref = current_frame.pop_stack(</span>
<span class="udiff-line-modified-added">+             VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
            no_control_flow = false; break;
<span class="udiff-line-added">+         }</span>
          case Bytecodes::_multianewarray :
          {
            index = bcs.get_index_u2();
            u2 dim = *(bcs.bcp()+3);
            verify_cp_class_type(bci, index, cp, CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2020,10 +2066,11 @@</span>
    // We must check was_recursively_verified() before we get here.
    guarantee(cp-&gt;cache() == NULL, &quot;not rewritten yet&quot;);
  
    verify_cp_index(bci, cp, index, CHECK_VERIFY(this));
    unsigned int tag = cp-&gt;tag_at(index).value();
<span class="udiff-line-added">+ </span>
    if ((types &amp; (1 &lt;&lt; tag)) == 0) {
      verify_error(ErrorContext::bad_cp_index(bci, index),
        &quot;Illegal type at constant pool entry %d in class %s&quot;,
        index, cp-&gt;pool_holder()-&gt;external_name());
      return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2134,11 +2181,11 @@</span>
    constantTag tag = cp-&gt;tag_at(index);
    unsigned int types = 0;
    if (opcode == Bytecodes::_ldc || opcode == Bytecodes::_ldc_w) {
      if (!tag.is_unresolved_klass()) {
        types = (1 &lt;&lt; JVM_CONSTANT_Integer) | (1 &lt;&lt; JVM_CONSTANT_Float)
<span class="udiff-line-modified-removed">-             | (1 &lt;&lt; JVM_CONSTANT_String)  | (1 &lt;&lt; JVM_CONSTANT_Class)</span>
<span class="udiff-line-modified-added">+             | (1 &lt;&lt; JVM_CONSTANT_String) | (1 &lt;&lt; JVM_CONSTANT_Class)</span>
              | (1 &lt;&lt; JVM_CONSTANT_MethodHandle) | (1 &lt;&lt; JVM_CONSTANT_MethodType)
              | (1 &lt;&lt; JVM_CONSTANT_Dynamic);
        // Note:  The class file parser already verified the legality of
        // MethodHandle and MethodType constants.
        verify_cp_type(bci, index, cp, types, CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2310,17 +2357,18 @@</span>
  
    // Get referenced class type
    VerificationType ref_class_type = cp_ref_index_to_type(
      index, cp, CHECK_VERIFY(this));
    if (!ref_class_type.is_object() &amp;&amp;
<span class="udiff-line-modified-removed">-     (!allow_arrays || !ref_class_type.is_array())) {</span>
<span class="udiff-line-modified-added">+       (!allow_arrays || !ref_class_type.is_array())) {</span>
      verify_error(ErrorContext::bad_type(bcs-&gt;bci(),
          TypeOrigin::cp(index, ref_class_type)),
          &quot;Expecting reference to class in class %s at constant pool index %d&quot;,
          _klass-&gt;external_name(), index);
      return;
    }
<span class="udiff-line-added">+ </span>
    VerificationType target_class_type = ref_class_type;
  
    assert(sizeof(VerificationType) == sizeof(uintptr_t),
          &quot;buffer type must match VerificationType size&quot;);
    uintptr_t field_type_buffer[2];
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2346,10 +2394,29 @@</span>
        for (int i = n - 1; i &gt;= 0; i--) {
          current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));
        }
        break;
      }
<span class="udiff-line-added">+     case Bytecodes::_withfield: {</span>
<span class="udiff-line-added">+       for (int i = n - 1; i &gt;= 0; i--) {</span>
<span class="udiff-line-added">+         current_frame-&gt;pop_stack(field_type[i], CHECK_VERIFY(this));</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       // stack_object_type and target_class_type must be the same value type.</span>
<span class="udiff-line-added">+       stack_object_type =</span>
<span class="udiff-line-added">+         current_frame-&gt;pop_stack(VerificationType::valuetype_check(), CHECK_VERIFY(this));</span>
<span class="udiff-line-added">+       VerificationType target_value_type =</span>
<span class="udiff-line-added">+         VerificationType::change_ref_to_valuetype(target_class_type);</span>
<span class="udiff-line-added">+       if (!stack_object_type.equals(target_value_type)) {</span>
<span class="udiff-line-added">+         verify_error(ErrorContext::bad_value_type(bci,</span>
<span class="udiff-line-added">+             current_frame-&gt;stack_top_ctx(),</span>
<span class="udiff-line-added">+             TypeOrigin::cp(index, target_class_type)),</span>
<span class="udiff-line-added">+             &quot;Invalid type on operand stack in withfield instruction&quot;);</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       current_frame-&gt;push_stack(target_value_type, CHECK_VERIFY(this));</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
      case Bytecodes::_getfield: {
        stack_object_type = current_frame-&gt;pop_stack(
          target_class_type, CHECK_VERIFY(this));
        for (int i = 0; i &lt; n; i++) {
          current_frame-&gt;push_stack(field_type[i], CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2754,11 +2821,11 @@</span>
    return false;
  }
  
  void ClassVerifier::verify_invoke_instructions(
      RawBytecodeStream* bcs, u4 code_length, StackMapFrame* current_frame,
<span class="udiff-line-modified-removed">-     bool in_try_block, bool *this_uninit, VerificationType return_type,</span>
<span class="udiff-line-modified-added">+     bool in_try_block, bool *this_uninit,</span>
      const constantPoolHandle&amp; cp, StackMapTable* stackmap_table, TRAPS) {
    // Make sure the constant pool item is the right type
    u2 index = bcs-&gt;get_index_u2();
    Bytecodes::Code opcode = bcs-&gt;raw_code();
    unsigned int types = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2786,11 +2853,11 @@</span>
  
    // Method signature was checked in ClassFileParser.
    assert(SignatureVerifier::is_valid_method_signature(method_sig),
           &quot;Invalid method signature&quot;);
  
<span class="udiff-line-modified-removed">-   // Get referenced class type</span>
<span class="udiff-line-modified-added">+   // Get referenced class</span>
    VerificationType ref_class_type;
    if (opcode == Bytecodes::_invokedynamic) {
      if (_klass-&gt;major_version() &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
        class_format_error(
          &quot;invokedynamic instructions not supported by this class file version (%d), class %s&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2852,36 +2919,38 @@</span>
        return;
      }
    }
  
    if (method_name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<span class="udiff-line-modified-removed">-     // Make sure &lt;init&gt; can only be invoked by invokespecial</span>
<span class="udiff-line-modified-removed">-     if (opcode != Bytecodes::_invokespecial ||</span>
<span class="udiff-line-modified-added">+     // Make sure &lt;init&gt; can only be invoked by invokespecial or invokestatic.</span>
<span class="udiff-line-modified-added">+     // The allowed invocation mode of &lt;init&gt; depends on its signature.</span>
<span class="udiff-line-added">+     if ((opcode != Bytecodes::_invokespecial &amp;&amp;</span>
<span class="udiff-line-added">+          opcode != Bytecodes::_invokestatic) ||</span>
          method_name != vmSymbols::object_initializer_name()) {
        verify_error(ErrorContext::bad_code(bci),
            &quot;Illegal call to internal method&quot;);
        return;
      }
    } else if (opcode == Bytecodes::_invokespecial
               &amp;&amp; !is_same_or_direct_interface(current_class(), current_type(), ref_class_type)
               &amp;&amp; !ref_class_type.equals(VerificationType::reference_type(
<span class="udiff-line-modified-removed">-                   current_class()-&gt;super()-&gt;name()))) {</span>
<span class="udiff-line-modified-added">+                   current_class()-&gt;super()-&gt;name()))) { // super() can never be a value_type.</span>
      bool subtype = false;
      bool have_imr_indirect = cp-&gt;tag_at(index).value() == JVM_CONSTANT_InterfaceMethodref;
      if (!current_class()-&gt;is_unsafe_anonymous()) {
        subtype = ref_class_type.is_assignable_from(
                   current_type(), this, false, CHECK_VERIFY(this));
      } else {
<span class="udiff-line-modified-removed">-       VerificationType unsafe_anonymous_host_type =</span>
<span class="udiff-line-modified-removed">-                         VerificationType::reference_type(current_class()-&gt;unsafe_anonymous_host()-&gt;name());</span>
<span class="udiff-line-modified-added">+       InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();</span>
<span class="udiff-line-modified-added">+       VerificationType unsafe_anonymous_host_type = reference_or_valuetype(unsafe_host);</span>
        subtype = ref_class_type.is_assignable_from(unsafe_anonymous_host_type, this, false, CHECK_VERIFY(this));
  
        // If invokespecial of IMR, need to recheck for same or
        // direct interface relative to the host class
        have_imr_indirect = (have_imr_indirect &amp;&amp;
                             !is_same_or_direct_interface(
<span class="udiff-line-modified-removed">-                              current_class()-&gt;unsafe_anonymous_host(),</span>
<span class="udiff-line-modified-added">+                              unsafe_host,</span>
                               unsafe_anonymous_host_type, ref_class_type));
      }
      if (!subtype) {
        verify_error(ErrorContext::bad_code(bci),
            &quot;Bad invokespecial instruction: &quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2907,10 +2976,11 @@</span>
  
    // Check objectref on operand stack
    if (opcode != Bytecodes::_invokestatic &amp;&amp;
        opcode != Bytecodes::_invokedynamic) {
      if (method_name == vmSymbols::object_initializer_name()) {  // &lt;init&gt; method
<span class="udiff-line-added">+       // (use of &lt;init&gt; as a static factory is handled under invokestatic)</span>
        verify_invoke_init(bcs, index, ref_class_type, current_frame,
          code_length, in_try_block, this_uninit, cp, stackmap_table,
          CHECK_VERIFY(this));
        if (was_recursively_verified()) return;
      } else {   // other methods
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2921,13 +2991,14 @@</span>
          } else {
            // anonymous class invokespecial calls: check if the
            // objectref is a subtype of the unsafe_anonymous_host of the current class
            // to allow an anonymous class to reference methods in the unsafe_anonymous_host
            VerificationType top = current_frame-&gt;pop_stack(CHECK_VERIFY(this));
<span class="udiff-line-modified-removed">-           VerificationType hosttype =</span>
<span class="udiff-line-modified-removed">-             VerificationType::reference_type(current_class()-&gt;unsafe_anonymous_host()-&gt;name());</span>
<span class="udiff-line-modified-removed">-           bool subtype = hosttype.is_assignable_from(top, this, false, CHECK_VERIFY(this));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+           InstanceKlass* unsafe_host = current_class()-&gt;unsafe_anonymous_host();</span>
<span class="udiff-line-modified-added">+           VerificationType host_type = reference_or_valuetype(unsafe_host);</span>
<span class="udiff-line-added">+           bool subtype = host_type.is_assignable_from(top, this, false, CHECK_VERIFY(this));</span>
            if (!subtype) {
              verify_error( ErrorContext::bad_type(current_frame-&gt;offset(),
                current_frame-&gt;stack_top_ctx(),
                TypeOrigin::implicit(top)),
                &quot;Bad type on operand stack&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2976,14 +3047,13 @@</span>
      }
    }
    // Push the result type.
    int sig_verif_types_len = sig_verif_types-&gt;length();
    if (sig_verif_types_len &gt; nargs) {  // There&#39;s a return type
<span class="udiff-line-modified-removed">-     if (method_name == vmSymbols::object_initializer_name()) {</span>
<span class="udiff-line-modified-removed">-       // &lt;init&gt; method must have a void return type</span>
<span class="udiff-line-modified-removed">-       /* Unreachable?  Class file parser verifies that methods with &#39;&lt;&#39; have</span>
<span class="udiff-line-removed">-        * void return */</span>
<span class="udiff-line-modified-added">+     if (method_name == vmSymbols::object_initializer_name() &amp;&amp;</span>
<span class="udiff-line-modified-added">+         opcode != Bytecodes::_invokestatic) {</span>
<span class="udiff-line-modified-added">+       // an &lt;init&gt; method must have a void return type, unless it&#39;s a static factory</span>
        verify_error(ErrorContext::bad_code(bci),
            &quot;Return type must be void in &lt;init&gt; method&quot;);
        return;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2992,10 +3062,18 @@</span>
      for (int i = nargs; i &lt; sig_verif_types_len; i++) {
        assert(i == nargs || sig_verif_types-&gt;at(i).is_long2() ||
               sig_verif_types-&gt;at(i).is_double2(), &quot;Unexpected return verificationType&quot;);
        current_frame-&gt;push_stack(sig_verif_types-&gt;at(i), CHECK_VERIFY(this));
      }
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     // an &lt;init&gt; method may not have a void return type, if it&#39;s a static factory</span>
<span class="udiff-line-added">+     if (method_name == vmSymbols::object_initializer_name() &amp;&amp;</span>
<span class="udiff-line-added">+         opcode != Bytecodes::_invokespecial) {</span>
<span class="udiff-line-added">+       verify_error(ErrorContext::bad_code(bci),</span>
<span class="udiff-line-added">+           &quot;Return type must be non-void in &lt;init&gt; static factory method&quot;);</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
    }
  }
  
  VerificationType ClassVerifier::get_newarray_type(
      u2 index, u2 bci, TRAPS) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3039,15 +3117,16 @@</span>
      int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%s&quot;,
                           JVM_SIGNATURE_ARRAY, component_name);
      assert(n == length, &quot;Unexpected number of characters in string&quot;);
    } else {         // it&#39;s an object or interface
      const char* component_name = component_type.name()-&gt;as_utf8();
<span class="udiff-line-modified-removed">-     // add one dimension to component with &#39;L&#39; prepended and &#39;;&#39; postpended.</span>
<span class="udiff-line-modified-added">+     char Q_or_L = component_type.is_valuetype() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;</span>
<span class="udiff-line-added">+     // add one dimension to component with &#39;L&#39; or &#39;Q&#39; prepended and &#39;;&#39; appended.</span>
      length = (int)strlen(component_name) + 3;
      arr_sig_str = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, length + 1);
      int n = os::snprintf(arr_sig_str, length + 1, &quot;%c%c%s;&quot;,
<span class="udiff-line-modified-removed">-                          JVM_SIGNATURE_ARRAY, JVM_SIGNATURE_CLASS, component_name);</span>
<span class="udiff-line-modified-added">+                          JVM_SIGNATURE_ARRAY, Q_or_L, component_name);</span>
      assert(n == length, &quot;Unexpected number of characters in string&quot;);
    }
    Symbol* arr_sig = create_temporary_symbol(arr_sig_str, length);
    VerificationType new_array_type = VerificationType::reference_type(arr_sig);
    current_frame-&gt;push_stack(new_array_type, CHECK_VERIFY(this));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3085,11 +3164,11 @@</span>
      VerificationType::double2_type(), CHECK_VERIFY(this));
  }
  
  void ClassVerifier::verify_aload(u2 index, StackMapFrame* current_frame, TRAPS) {
    VerificationType type = current_frame-&gt;get_local(
<span class="udiff-line-modified-removed">-     index, VerificationType::reference_check(), CHECK_VERIFY(this));</span>
<span class="udiff-line-modified-added">+     index, VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
    current_frame-&gt;push_stack(type, CHECK_VERIFY(this));
  }
  
  void ClassVerifier::verify_istore(u2 index, StackMapFrame* current_frame, TRAPS) {
    current_frame-&gt;pop_stack(
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3122,11 +3201,11 @@</span>
      VerificationType::double2_type(), CHECK_VERIFY(this));
  }
  
  void ClassVerifier::verify_astore(u2 index, StackMapFrame* current_frame, TRAPS) {
    VerificationType type = current_frame-&gt;pop_stack(
<span class="udiff-line-modified-removed">-     VerificationType::reference_check(), CHECK_VERIFY(this));</span>
<span class="udiff-line-modified-added">+     VerificationType::nonscalar_check(), CHECK_VERIFY(this));</span>
    current_frame-&gt;set_local(index, type, CHECK_VERIFY(this));
  }
  
  void ClassVerifier::verify_iinc(u2 index, StackMapFrame* current_frame, TRAPS) {
    VerificationType type = current_frame-&gt;get_local(
</pre>
<center><a href="verificationType.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmSymbols.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
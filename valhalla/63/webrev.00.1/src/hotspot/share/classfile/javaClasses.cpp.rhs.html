<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/altHashing.hpp&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/moduleEntry.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/symbolTable.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;code/debugInfo.hpp&quot;
  34 #include &quot;code/dependencyContext.hpp&quot;
  35 #include &quot;code/pcDesc.hpp&quot;
  36 #include &quot;interpreter/interpreter.hpp&quot;
  37 #include &quot;interpreter/linkResolver.hpp&quot;
  38 #include &quot;logging/log.hpp&quot;
  39 #include &quot;logging/logStream.hpp&quot;
  40 #include &quot;memory/heapShared.inline.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/fieldStreams.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
<a name="1" id="anc1"></a><span class="line-modified">  47 #include &quot;oops/instanceMirrorKlass.inline.hpp&quot;</span>
  48 #include &quot;oops/klass.hpp&quot;
  49 #include &quot;oops/method.inline.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/symbol.hpp&quot;
  53 #include &quot;oops/recordComponent.hpp&quot;
  54 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  55 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  56 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
  57 #include &quot;prims/jvmtiExport.hpp&quot;
  58 #include &quot;prims/resolvedMethodTable.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/init.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/java.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/jniHandles.inline.hpp&quot;
  67 #include &quot;runtime/safepoint.hpp&quot;
  68 #include &quot;runtime/safepointVerifiers.hpp&quot;
  69 #include &quot;runtime/thread.inline.hpp&quot;
  70 #include &quot;runtime/vframe.inline.hpp&quot;
  71 #include &quot;runtime/vm_version.hpp&quot;
  72 #include &quot;utilities/align.hpp&quot;
  73 #include &quot;utilities/preserveException.hpp&quot;
  74 #include &quot;utilities/utf8.hpp&quot;
  75 #if INCLUDE_JVMCI
  76 #include &quot;jvmci/jvmciJavaClasses.hpp&quot;
  77 #endif
  78 
  79 #define INJECTED_FIELD_COMPUTE_OFFSET(klass, name, signature, may_be_java)    \
  80   klass::_##name##_offset = JavaClasses::compute_injected_offset(JavaClasses::klass##_##name##_enum);
  81 
  82 #if INCLUDE_CDS
  83 #define INJECTED_FIELD_SERIALIZE_OFFSET(klass, name, signature, may_be_java) \
  84   f-&gt;do_u4((u4*)&amp;_##name##_offset);
  85 #endif
  86 
  87 #define DECLARE_INJECTED_FIELD(klass, name, signature, may_be_java)           \
  88   { SystemDictionary::WK_KLASS_ENUM_NAME(klass), vmSymbols::VM_SYMBOL_ENUM_NAME(name##_name), vmSymbols::VM_SYMBOL_ENUM_NAME(signature), may_be_java },
  89 
  90 InjectedField JavaClasses::_injected_fields[] = {
  91   ALL_INJECTED_FIELDS(DECLARE_INJECTED_FIELD)
  92 };
  93 
  94 // Register native methods of Object
  95 void java_lang_Object::register_natives(TRAPS) {
  96   InstanceKlass* obj = SystemDictionary::Object_klass();
  97   Method::register_native(obj, vmSymbols::hashCode_name(),
  98                           vmSymbols::void_int_signature(), (address) &amp;JVM_IHashCode, CHECK);
  99   Method::register_native(obj, vmSymbols::wait_name(),
 100                           vmSymbols::long_void_signature(), (address) &amp;JVM_MonitorWait, CHECK);
 101   Method::register_native(obj, vmSymbols::notify_name(),
 102                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotify, CHECK);
 103   Method::register_native(obj, vmSymbols::notifyAll_name(),
 104                           vmSymbols::void_method_signature(), (address) &amp;JVM_MonitorNotifyAll, CHECK);
 105   Method::register_native(obj, vmSymbols::clone_name(),
 106                           vmSymbols::void_object_signature(), (address) &amp;JVM_Clone, THREAD);
 107 }
 108 
 109 int JavaClasses::compute_injected_offset(InjectedFieldID id) {
 110   return _injected_fields[id].compute_offset();
 111 }
 112 
 113 InjectedField* JavaClasses::get_injected(Symbol* class_name, int* field_count) {
 114   *field_count = 0;
 115 
 116   vmSymbols::SID sid = vmSymbols::find_sid(class_name);
 117   if (sid == vmSymbols::NO_SID) {
 118     // Only well known classes can inject fields
 119     return NULL;
 120   }
 121 
 122   int count = 0;
 123   int start = -1;
 124 
 125 #define LOOKUP_INJECTED_FIELD(klass, name, signature, may_be_java) \
 126   if (sid == vmSymbols::VM_SYMBOL_ENUM_NAME(klass)) {              \
 127     count++;                                                       \
 128     if (start == -1) start = klass##_##name##_enum;                \
 129   }
 130   ALL_INJECTED_FIELDS(LOOKUP_INJECTED_FIELD);
 131 #undef LOOKUP_INJECTED_FIELD
 132 
 133   if (start != -1) {
 134     *field_count = count;
 135     return _injected_fields + start;
 136   }
 137   return NULL;
 138 }
 139 
 140 
 141 // Helpful routine for computing field offsets at run time rather than hardcoding them
 142 // Finds local fields only, including static fields.  Static field offsets are from the
 143 // beginning of the mirror.
 144 static void compute_offset(int &amp;dest_offset,
 145                            InstanceKlass* ik, Symbol* name_symbol, Symbol* signature_symbol,
 146                            bool is_static = false) {
 147   fieldDescriptor fd;
 148   if (ik == NULL) {
 149     ResourceMark rm;
 150     log_error(class)(&quot;Mismatch JDK version for field: %s type: %s&quot;, name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 151     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;);
 152   }
 153 
 154   if (!ik-&gt;find_local_field(name_symbol, signature_symbol, &amp;fd) || fd.is_static() != is_static) {
 155     ResourceMark rm;
 156     log_error(class)(&quot;Invalid layout of %s field: %s type: %s&quot;, ik-&gt;external_name(),
 157                      name_symbol-&gt;as_C_string(), signature_symbol-&gt;as_C_string());
 158 #ifndef PRODUCT
 159     // Prints all fields and offsets
 160     Log(class) lt;
 161     LogStream ls(lt.error());
 162     ik-&gt;print_on(&amp;ls);
 163 #endif //PRODUCT
 164     vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
 165   }
 166   dest_offset = fd.offset();
 167 }
 168 
 169 // Overloading to pass name as a string.
 170 static void compute_offset(int&amp; dest_offset, InstanceKlass* ik,
 171                            const char* name_string, Symbol* signature_symbol,
 172                            bool is_static = false) {
 173   TempNewSymbol name = SymbolTable::probe(name_string, (int)strlen(name_string));
 174   if (name == NULL) {
 175     ResourceMark rm;
 176     log_error(class)(&quot;Name %s should be in the SymbolTable since its class is loaded&quot;, name_string);
 177     vm_exit_during_initialization(&quot;Invalid layout of well-known class&quot;, ik-&gt;external_name());
 178   }
 179   compute_offset(dest_offset, ik, name, signature_symbol, is_static);
 180 }
 181 
 182 int java_lang_String::value_offset  = 0;
 183 int java_lang_String::hash_offset   = 0;
 184 int java_lang_String::hashIsZero_offset = 0;
 185 int java_lang_String::coder_offset  = 0;
 186 
 187 bool java_lang_String::initialized  = false;
 188 
 189 bool java_lang_String::is_instance(oop obj) {
 190   return is_instance_inlined(obj);
 191 }
 192 
 193 #if INCLUDE_CDS
 194 #define FIELD_SERIALIZE_OFFSET(offset, klass, name, signature, is_static) \
 195   f-&gt;do_u4((u4*)&amp;offset)
 196 #endif
 197 
 198 #define FIELD_COMPUTE_OFFSET(offset, klass, name, signature, is_static) \
 199   compute_offset(offset, klass, name, vmSymbols::signature(), is_static)
 200 
 201 #define STRING_FIELDS_DO(macro) \
 202   macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \
 203   macro(hash_offset,  k, &quot;hash&quot;,                  int_signature,        false); \
 204   macro(hashIsZero_offset, k, &quot;hashIsZero&quot;,       bool_signature,       false); \
 205   macro(coder_offset, k, &quot;coder&quot;,                 byte_signature,       false);
 206 
 207 void java_lang_String::compute_offsets() {
 208   if (initialized) {
 209     return;
 210   }
 211 
 212   InstanceKlass* k = SystemDictionary::String_klass();
 213   STRING_FIELDS_DO(FIELD_COMPUTE_OFFSET);
 214 
 215   initialized = true;
 216 }
 217 
 218 #if INCLUDE_CDS
 219 void java_lang_String::serialize_offsets(SerializeClosure* f) {
 220   STRING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
 221   f-&gt;do_bool(&amp;initialized);
 222 }
 223 #endif
 224 
 225 class CompactStringsFixup : public FieldClosure {
 226 private:
 227   bool _value;
 228 
 229 public:
 230   CompactStringsFixup(bool value) : _value(value) {}
 231 
 232   void do_field(fieldDescriptor* fd) {
 233     if (fd-&gt;name() == vmSymbols::compact_strings_name()) {
 234       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
 235       assert(fd-&gt;field_holder() == SystemDictionary::String_klass(), &quot;Should be String&quot;);
 236       assert(mirror != NULL, &quot;String must have mirror already&quot;);
 237       mirror-&gt;bool_field_put(fd-&gt;offset(), _value);
 238     }
 239   }
 240 };
 241 
 242 void java_lang_String::set_compact_strings(bool value) {
 243   CompactStringsFixup fix(value);
 244   SystemDictionary::String_klass()-&gt;do_local_static_fields(&amp;fix);
 245 }
 246 
 247 Handle java_lang_String::basic_create(int length, bool is_latin1, TRAPS) {
 248   assert(initialized, &quot;Must be initialized&quot;);
 249   assert(CompactStrings || !is_latin1, &quot;Must be UTF16 without CompactStrings&quot;);
 250 
 251   // Create the String object first, so there&#39;s a chance that the String
 252   // and the char array it points to end up in the same cache line.
 253   oop obj;
 254   obj = SystemDictionary::String_klass()-&gt;allocate_instance(CHECK_NH);
 255 
 256   // Create the char array.  The String object must be handlized here
 257   // because GC can happen as a result of the allocation attempt.
 258   Handle h_obj(THREAD, obj);
 259   int arr_length = is_latin1 ? length : length &lt;&lt; 1; // 2 bytes per UTF16.
 260   typeArrayOop buffer = oopFactory::new_byteArray(arr_length, CHECK_NH);;
 261 
 262   // Point the String at the char array
 263   obj = h_obj();
 264   set_value(obj, buffer);
 265   // No need to zero the offset, allocation zero&#39;ed the entire String object
 266   set_coder(obj, is_latin1 ? CODER_LATIN1 : CODER_UTF16);
 267   return h_obj;
 268 }
 269 
 270 Handle java_lang_String::create_from_unicode(const jchar* unicode, int length, TRAPS) {
 271   bool is_latin1 = CompactStrings &amp;&amp; UNICODE::is_latin1(unicode, length);
 272   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 273   typeArrayOop buffer = value(h_obj());
 274   assert(TypeArrayKlass::cast(buffer-&gt;klass())-&gt;element_type() == T_BYTE, &quot;only byte[]&quot;);
 275   if (is_latin1) {
 276     for (int index = 0; index &lt; length; index++) {
 277       buffer-&gt;byte_at_put(index, (jbyte)unicode[index]);
 278     }
 279   } else {
 280     for (int index = 0; index &lt; length; index++) {
 281       buffer-&gt;char_at_put(index, unicode[index]);
 282     }
 283   }
 284 
 285 #ifdef ASSERT
 286   {
 287     ResourceMark rm;
 288     char* expected = UNICODE::as_utf8(unicode, length);
 289     char* actual = as_utf8_string(h_obj());
 290     if (strcmp(expected, actual) != 0) {
 291       tty-&gt;print_cr(&quot;Unicode conversion failure: %s --&gt; %s&quot;, expected, actual);
 292       ShouldNotReachHere();
 293     }
 294   }
 295 #endif
 296 
 297   return h_obj;
 298 }
 299 
 300 oop java_lang_String::create_oop_from_unicode(const jchar* unicode, int length, TRAPS) {
 301   Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);
 302   return h_obj();
 303 }
 304 
 305 Handle java_lang_String::create_from_str(const char* utf8_str, TRAPS) {
 306   if (utf8_str == NULL) {
 307     return Handle();
 308   }
 309   bool has_multibyte, is_latin1;
 310   int length = UTF8::unicode_length(utf8_str, is_latin1, has_multibyte);
 311   if (!CompactStrings) {
 312     has_multibyte = true;
 313     is_latin1 = false;
 314   }
 315 
 316   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 317   if (length &gt; 0) {
 318     if (!has_multibyte) {
 319       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 320       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 321     } else if (is_latin1) {
 322       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 323     } else {
 324       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 325     }
 326   }
 327 
 328 #ifdef ASSERT
 329   // This check is too strict because the input string is not necessarily valid UTF8.
 330   // For example, it may be created with arbitrary content via jni_NewStringUTF.
 331   /*
 332   {
 333     ResourceMark rm;
 334     const char* expected = utf8_str;
 335     char* actual = as_utf8_string(h_obj());
 336     if (strcmp(expected, actual) != 0) {
 337       tty-&gt;print_cr(&quot;String conversion failure: %s --&gt; %s&quot;, expected, actual);
 338       ShouldNotReachHere();
 339     }
 340   }
 341   */
 342 #endif
 343 
 344   return h_obj;
 345 }
 346 
 347 oop java_lang_String::create_oop_from_str(const char* utf8_str, TRAPS) {
 348   Handle h_obj = create_from_str(utf8_str, CHECK_NULL);
 349   return h_obj();
 350 }
 351 
 352 Handle java_lang_String::create_from_symbol(Symbol* symbol, TRAPS) {
 353   const char* utf8_str = (char*)symbol-&gt;bytes();
 354   int utf8_len = symbol-&gt;utf8_length();
 355 
 356   bool has_multibyte, is_latin1;
 357   int length = UTF8::unicode_length(utf8_str, utf8_len, is_latin1, has_multibyte);
 358   if (!CompactStrings) {
 359     has_multibyte = true;
 360     is_latin1 = false;
 361   }
 362 
 363   Handle h_obj = basic_create(length, is_latin1, CHECK_NH);
 364   if (length &gt; 0) {
 365     if (!has_multibyte) {
 366       const jbyte* src = reinterpret_cast&lt;const jbyte*&gt;(utf8_str);
 367       ArrayAccess&lt;&gt;::arraycopy_from_native(src, value(h_obj()), typeArrayOopDesc::element_offset&lt;jbyte&gt;(0), length);
 368     } else if (is_latin1) {
 369       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;byte_at_addr(0), length);
 370     } else {
 371       UTF8::convert_to_unicode(utf8_str, value(h_obj())-&gt;char_at_addr(0), length);
 372     }
 373   }
 374 
 375 #ifdef ASSERT
 376   {
 377     ResourceMark rm;
 378     const char* expected = symbol-&gt;as_utf8();
 379     char* actual = as_utf8_string(h_obj());
 380     if (strncmp(expected, actual, utf8_len) != 0) {
 381       tty-&gt;print_cr(&quot;Symbol conversion failure: %s --&gt; %s&quot;, expected, actual);
 382       ShouldNotReachHere();
 383     }
 384   }
 385 #endif
 386 
 387   return h_obj;
 388 }
 389 
 390 // Converts a C string to a Java String based on current encoding
 391 Handle java_lang_String::create_from_platform_dependent_str(const char* str, TRAPS) {
 392   assert(str != NULL, &quot;bad arguments&quot;);
 393 
 394   typedef jstring (JNICALL *to_java_string_fn_t)(JNIEnv*, const char *);
 395   static to_java_string_fn_t _to_java_string_fn = NULL;
 396 
 397   if (_to_java_string_fn == NULL) {
 398     void *lib_handle = os::native_java_library();
 399     _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;JNU_NewStringPlatform&quot;));
 400 #if defined(_WIN32) &amp;&amp; !defined(_WIN64)
 401     if (_to_java_string_fn == NULL) {
 402       // On 32 bit Windows, also try __stdcall decorated name
 403       _to_java_string_fn = CAST_TO_FN_PTR(to_java_string_fn_t, os::dll_lookup(lib_handle, &quot;_JNU_NewStringPlatform@8&quot;));
 404     }
 405 #endif
 406     if (_to_java_string_fn == NULL) {
 407       fatal(&quot;JNU_NewStringPlatform missing&quot;);
 408     }
 409   }
 410 
 411   jstring js = NULL;
 412   {
 413     assert(THREAD-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 414     JavaThread* thread = (JavaThread*)THREAD;
 415     HandleMark hm(thread);
 416     ThreadToNativeFromVM ttn(thread);
 417     js = (_to_java_string_fn)(thread-&gt;jni_environment(), str);
 418   }
 419 
 420   Handle native_platform_string(THREAD, JNIHandles::resolve(js));
 421   JNIHandles::destroy_local(js);  // destroy local JNIHandle.
 422   return native_platform_string;
 423 }
 424 
 425 // Converts a Java String to a native C string that can be used for
 426 // native OS calls.
 427 char* java_lang_String::as_platform_dependent_str(Handle java_string, TRAPS) {
 428   typedef char* (*to_platform_string_fn_t)(JNIEnv*, jstring, bool*);
 429   static to_platform_string_fn_t _to_platform_string_fn = NULL;
 430 
 431   if (_to_platform_string_fn == NULL) {
 432     void *lib_handle = os::native_java_library();
 433     _to_platform_string_fn = CAST_TO_FN_PTR(to_platform_string_fn_t, os::dll_lookup(lib_handle, &quot;GetStringPlatformChars&quot;));
 434     if (_to_platform_string_fn == NULL) {
 435       fatal(&quot;GetStringPlatformChars missing&quot;);
 436     }
 437   }
 438 
 439   char *native_platform_string;
 440   { JavaThread* thread = (JavaThread*)THREAD;
 441     assert(thread-&gt;is_Java_thread(), &quot;must be java thread&quot;);
 442     JNIEnv *env = thread-&gt;jni_environment();
 443     jstring js = (jstring) JNIHandles::make_local(env, java_string());
 444     bool is_copy;
 445     HandleMark hm(thread);
 446     ThreadToNativeFromVM ttn(thread);
 447     native_platform_string = (_to_platform_string_fn)(env, js, &amp;is_copy);
 448     assert(is_copy == JNI_TRUE, &quot;is_copy value changed&quot;);
 449     JNIHandles::destroy_local(js);
 450   }
 451   return native_platform_string;
 452 }
 453 
 454 Handle java_lang_String::char_converter(Handle java_string, jchar from_char, jchar to_char, TRAPS) {
 455   oop          obj    = java_string();
 456   // Typical usage is to convert all &#39;/&#39; to &#39;.&#39; in string.
 457   typeArrayOop value  = java_lang_String::value(obj);
 458   int          length = java_lang_String::length(obj, value);
 459   bool      is_latin1 = java_lang_String::is_latin1(obj);
 460 
 461   // First check if any from_char exist
 462   int index; // Declared outside, used later
 463   for (index = 0; index &lt; length; index++) {
 464     jchar c = !is_latin1 ? value-&gt;char_at(index) :
 465                   ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 466     if (c == from_char) {
 467       break;
 468     }
 469   }
 470   if (index == length) {
 471     // No from_char, so do not copy.
 472     return java_string;
 473   }
 474 
 475   // Check if result string will be latin1
 476   bool to_is_latin1 = false;
 477 
 478   // Replacement char must be latin1
 479   if (CompactStrings &amp;&amp; UNICODE::is_latin1(to_char)) {
 480     if (is_latin1) {
 481       // Source string is latin1 as well
 482       to_is_latin1 = true;
 483     } else if (!UNICODE::is_latin1(from_char)) {
 484       // We are replacing an UTF16 char. Scan string to
 485       // check if result can be latin1 encoded.
 486       to_is_latin1 = true;
 487       for (index = 0; index &lt; length; index++) {
 488         jchar c = value-&gt;char_at(index);
 489         if (c != from_char &amp;&amp; !UNICODE::is_latin1(c)) {
 490           to_is_latin1 = false;
 491           break;
 492         }
 493       }
 494     }
 495   }
 496 
 497   // Create new UNICODE (or byte) buffer. Must handlize value because GC
 498   // may happen during String and char array creation.
 499   typeArrayHandle h_value(THREAD, value);
 500   Handle string = basic_create(length, to_is_latin1, CHECK_NH);
 501   typeArrayOop from_buffer = h_value();
 502   typeArrayOop to_buffer = java_lang_String::value(string());
 503 
 504   // Copy contents
 505   for (index = 0; index &lt; length; index++) {
 506     jchar c = (!is_latin1) ? from_buffer-&gt;char_at(index) :
 507                     ((jchar) from_buffer-&gt;byte_at(index)) &amp; 0xff;
 508     if (c == from_char) {
 509       c = to_char;
 510     }
 511     if (!to_is_latin1) {
 512       to_buffer-&gt;char_at_put(index, c);
 513     } else {
 514       to_buffer-&gt;byte_at_put(index, (jbyte) c);
 515     }
 516   }
 517   return string;
 518 }
 519 
 520 jchar* java_lang_String::as_unicode_string(oop java_string, int&amp; length, TRAPS) {
 521   typeArrayOop value  = java_lang_String::value(java_string);
 522                length = java_lang_String::length(java_string, value);
 523   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 524 
 525   jchar* result = NEW_RESOURCE_ARRAY_RETURN_NULL(jchar, length);
 526   if (result != NULL) {
 527     if (!is_latin1) {
 528       for (int index = 0; index &lt; length; index++) {
 529         result[index] = value-&gt;char_at(index);
 530       }
 531     } else {
 532       for (int index = 0; index &lt; length; index++) {
 533         result[index] = ((jchar) value-&gt;byte_at(index)) &amp; 0xff;
 534       }
 535     }
 536   } else {
 537     THROW_MSG_0(vmSymbols::java_lang_OutOfMemoryError(), &quot;could not allocate Unicode string&quot;);
 538   }
 539   return result;
 540 }
 541 
 542 unsigned int java_lang_String::hash_code(oop java_string) {
 543   // The hash and hashIsZero fields are subject to a benign data race,
 544   // making it crucial to ensure that any observable result of the
 545   // calculation in this method stays correct under any possible read of
 546   // these fields. Necessary restrictions to allow this to be correct
 547   // without explicit memory fences or similar concurrency primitives is
 548   // that we can ever only write to one of these two fields for a given
 549   // String instance, and that the computation is idempotent and derived
 550   // from immutable state
 551   assert(initialized &amp;&amp; (hash_offset &gt; 0) &amp;&amp; (hashIsZero_offset &gt; 0), &quot;Must be initialized&quot;);
 552   if (java_lang_String::hash_is_set(java_string)) {
 553     return java_string-&gt;int_field(hash_offset);
 554   }
 555 
 556   typeArrayOop value = java_lang_String::value(java_string);
 557   int         length = java_lang_String::length(java_string, value);
 558   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 559 
 560   unsigned int hash = 0;
 561   if (length &gt; 0) {
 562     if (is_latin1) {
 563       hash = java_lang_String::hash_code(value-&gt;byte_at_addr(0), length);
 564     } else {
 565       hash = java_lang_String::hash_code(value-&gt;char_at_addr(0), length);
 566     }
 567   }
 568 
 569   if (hash != 0) {
 570     java_string-&gt;int_field_put(hash_offset, hash);
 571   } else {
 572     java_string-&gt;bool_field_put(hashIsZero_offset, true);
 573   }
 574   return hash;
 575 }
 576 
 577 char* java_lang_String::as_quoted_ascii(oop java_string) {
 578   typeArrayOop value  = java_lang_String::value(java_string);
 579   int          length = java_lang_String::length(java_string, value);
 580   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 581 
 582   if (length == 0) return NULL;
 583 
 584   char* result;
 585   int result_length;
 586   if (!is_latin1) {
 587     jchar* base = value-&gt;char_at_addr(0);
 588     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 589     result = NEW_RESOURCE_ARRAY(char, result_length);
 590     UNICODE::as_quoted_ascii(base, length, result, result_length);
 591   } else {
 592     jbyte* base = value-&gt;byte_at_addr(0);
 593     result_length = UNICODE::quoted_ascii_length(base, length) + 1;
 594     result = NEW_RESOURCE_ARRAY(char, result_length);
 595     UNICODE::as_quoted_ascii(base, length, result, result_length);
 596   }
 597   assert(result_length &gt;= length + 1, &quot;must not be shorter&quot;);
 598   assert(result_length == (int)strlen(result) + 1, &quot;must match&quot;);
 599   return result;
 600 }
 601 
 602 Symbol* java_lang_String::as_symbol(oop java_string) {
 603   typeArrayOop value  = java_lang_String::value(java_string);
 604   int          length = java_lang_String::length(java_string, value);
 605   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 606   if (!is_latin1) {
 607     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 608     Symbol* sym = SymbolTable::new_symbol(base, length);
 609     return sym;
 610   } else {
 611     ResourceMark rm;
 612     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 613     const char* base = UNICODE::as_utf8(position, length);
 614     Symbol* sym = SymbolTable::new_symbol(base, length);
 615     return sym;
 616   }
 617 }
 618 
 619 Symbol* java_lang_String::as_symbol_or_null(oop java_string) {
 620   typeArrayOop value  = java_lang_String::value(java_string);
 621   int          length = java_lang_String::length(java_string, value);
 622   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 623   if (!is_latin1) {
 624     jchar* base = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 625     return SymbolTable::probe_unicode(base, length);
 626   } else {
 627     ResourceMark rm;
 628     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 629     const char* base = UNICODE::as_utf8(position, length);
 630     return SymbolTable::probe(base, length);
 631   }
 632 }
 633 
 634 int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {
 635   assert(value_equals(value, java_lang_String::value(java_string)),
 636          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 637   int length = java_lang_String::length(java_string, value);
 638   if (length == 0) {
 639     return 0;
 640   }
 641   if (!java_lang_String::is_latin1(java_string)) {
 642     return UNICODE::utf8_length(value-&gt;char_at_addr(0), length);
 643   } else {
 644     return UNICODE::utf8_length(value-&gt;byte_at_addr(0), length);
 645   }
 646 }
 647 
 648 int java_lang_String::utf8_length(oop java_string) {
 649   typeArrayOop value = java_lang_String::value(java_string);
 650   return utf8_length(java_string, value);
 651 }
 652 
 653 char* java_lang_String::as_utf8_string(oop java_string) {
 654   int length;
 655   return as_utf8_string(java_string, length);
 656 }
 657 
 658 char* java_lang_String::as_utf8_string(oop java_string, int&amp; length) {
 659   typeArrayOop value = java_lang_String::value(java_string);
 660   length             = java_lang_String::length(java_string, value);
 661   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 662   if (!is_latin1) {
 663     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 664     return UNICODE::as_utf8(position, length);
 665   } else {
 666     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 667     return UNICODE::as_utf8(position, length);
 668   }
 669 }
 670 
 671 // Uses a provided buffer if it&#39;s sufficiently large, otherwise allocates
 672 // a resource array to fit
 673 char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int&amp; utf8_len) {
 674   typeArrayOop value = java_lang_String::value(java_string);
 675   int            len = java_lang_String::length(java_string, value);
 676   bool     is_latin1 = java_lang_String::is_latin1(java_string);
 677   if (!is_latin1) {
 678     jchar *position = (len == 0) ? NULL : value-&gt;char_at_addr(0);
 679     utf8_len = UNICODE::utf8_length(position, len);
 680     if (utf8_len &gt;= buflen) {
 681       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 682     }
 683     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 684   } else {
 685     jbyte *position = (len == 0) ? NULL : value-&gt;byte_at_addr(0);
 686     utf8_len = UNICODE::utf8_length(position, len);
 687     if (utf8_len &gt;= buflen) {
 688       buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
 689     }
 690     return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
 691   }
 692 }
 693 
 694 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
 695   assert(value_equals(value, java_lang_String::value(java_string)),
 696          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 697   int     length = java_lang_String::length(java_string, value);
 698   bool is_latin1 = java_lang_String::is_latin1(java_string);
 699   if (!is_latin1) {
 700     jchar* position = (length == 0) ? NULL : value-&gt;char_at_addr(0);
 701     return UNICODE::as_utf8(position, length, buf, buflen);
 702   } else {
 703     jbyte* position = (length == 0) ? NULL : value-&gt;byte_at_addr(0);
 704     return UNICODE::as_utf8(position, length, buf, buflen);
 705   }
 706 }
 707 
 708 char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {
 709   typeArrayOop value = java_lang_String::value(java_string);
 710   return as_utf8_string(java_string, value, buf, buflen);
 711 }
 712 
 713 char* java_lang_String::as_utf8_string(oop java_string, int start, int len) {
 714   typeArrayOop value  = java_lang_String::value(java_string);
 715   bool      is_latin1 = java_lang_String::is_latin1(java_string);
 716   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 717   if (!is_latin1) {
 718     jchar* position = value-&gt;char_at_addr(start);
 719     return UNICODE::as_utf8(position, len);
 720   } else {
 721     jbyte* position = value-&gt;byte_at_addr(start);
 722     return UNICODE::as_utf8(position, len);
 723   }
 724 }
 725 
 726 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {
 727   assert(value_equals(value, java_lang_String::value(java_string)),
 728          &quot;value must be same as java_lang_String::value(java_string)&quot;);
 729   assert(start + len &lt;= java_lang_String::length(java_string), &quot;just checking&quot;);
 730   bool is_latin1 = java_lang_String::is_latin1(java_string);
 731   if (!is_latin1) {
 732     jchar* position = value-&gt;char_at_addr(start);
 733     return UNICODE::as_utf8(position, len, buf, buflen);
 734   } else {
 735     jbyte* position = value-&gt;byte_at_addr(start);
 736     return UNICODE::as_utf8(position, len, buf, buflen);
 737   }
 738 }
 739 
 740 bool java_lang_String::equals(oop java_string, const jchar* chars, int len) {
 741   assert(java_string-&gt;klass() == SystemDictionary::String_klass(),
 742          &quot;must be java_string&quot;);
 743   typeArrayOop value = java_lang_String::value_no_keepalive(java_string);
 744   int length = java_lang_String::length(java_string, value);
 745   if (length != len) {
 746     return false;
 747   }
 748   bool is_latin1 = java_lang_String::is_latin1(java_string);
 749   if (!is_latin1) {
 750     for (int i = 0; i &lt; len; i++) {
 751       if (value-&gt;char_at(i) != chars[i]) {
 752         return false;
 753       }
 754     }
 755   } else {
 756     for (int i = 0; i &lt; len; i++) {
 757       if ((((jchar) value-&gt;byte_at(i)) &amp; 0xff) != chars[i]) {
 758         return false;
 759       }
 760     }
 761   }
 762   return true;
 763 }
 764 
 765 bool java_lang_String::equals(oop str1, oop str2) {
 766   assert(str1-&gt;klass() == SystemDictionary::String_klass(),
 767          &quot;must be java String&quot;);
 768   assert(str2-&gt;klass() == SystemDictionary::String_klass(),
 769          &quot;must be java String&quot;);
 770   typeArrayOop value1    = java_lang_String::value_no_keepalive(str1);
 771   bool         is_latin1 = java_lang_String::is_latin1(str1);
 772   typeArrayOop value2    = java_lang_String::value_no_keepalive(str2);
 773   bool         is_latin2 = java_lang_String::is_latin1(str2);
 774 
 775   if (is_latin1 != is_latin2) {
 776     // Strings with different coders are never equal.
 777     return false;
 778   }
 779   return value_equals(value1, value2);
 780 }
 781 
 782 void java_lang_String::print(oop java_string, outputStream* st) {
 783   assert(java_string-&gt;klass() == SystemDictionary::String_klass(), &quot;must be java_string&quot;);
 784   typeArrayOop value  = java_lang_String::value_no_keepalive(java_string);
 785 
 786   if (value == NULL) {
 787     // This can happen if, e.g., printing a String
 788     // object before its initializer has been called
 789     st-&gt;print(&quot;NULL&quot;);
 790     return;
 791   }
 792 
 793   int length = java_lang_String::length(java_string, value);
 794   bool is_latin1 = java_lang_String::is_latin1(java_string);
 795 
 796   st-&gt;print(&quot;\&quot;&quot;);
 797   for (int index = 0; index &lt; length; index++) {
 798     st-&gt;print(&quot;%c&quot;, (!is_latin1) ?  value-&gt;char_at(index) :
 799                            ((jchar) value-&gt;byte_at(index)) &amp; 0xff );
 800   }
 801   st-&gt;print(&quot;\&quot;&quot;);
 802 }
 803 
 804 
 805 static void initialize_static_field(fieldDescriptor* fd, Handle mirror, TRAPS) {
 806   assert(mirror.not_null() &amp;&amp; fd-&gt;is_static(), &quot;just checking&quot;);
 807   if (fd-&gt;has_initial_value()) {
 808     BasicType t = fd-&gt;field_type();
 809     switch (t) {
 810       case T_BYTE:
 811         mirror()-&gt;byte_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 812               break;
 813       case T_BOOLEAN:
 814         mirror()-&gt;bool_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 815               break;
 816       case T_CHAR:
 817         mirror()-&gt;char_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 818               break;
 819       case T_SHORT:
 820         mirror()-&gt;short_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 821               break;
 822       case T_INT:
 823         mirror()-&gt;int_field_put(fd-&gt;offset(), fd-&gt;int_initial_value());
 824         break;
 825       case T_FLOAT:
 826         mirror()-&gt;float_field_put(fd-&gt;offset(), fd-&gt;float_initial_value());
 827         break;
 828       case T_DOUBLE:
 829         mirror()-&gt;double_field_put(fd-&gt;offset(), fd-&gt;double_initial_value());
 830         break;
 831       case T_LONG:
 832         mirror()-&gt;long_field_put(fd-&gt;offset(), fd-&gt;long_initial_value());
 833         break;
 834       case T_OBJECT:
 835         {
 836           assert(fd-&gt;signature() == vmSymbols::string_signature(),
 837                  &quot;just checking&quot;);
 838           if (DumpSharedSpaces &amp;&amp; HeapShared::is_archived_object(mirror())) {
 839             // Archive the String field and update the pointer.
 840             oop s = mirror()-&gt;obj_field(fd-&gt;offset());
 841             oop archived_s = StringTable::create_archived_string(s, CHECK);
 842             mirror()-&gt;obj_field_put(fd-&gt;offset(), archived_s);
 843           } else {
 844             oop string = fd-&gt;string_initial_value(CHECK);
 845             mirror()-&gt;obj_field_put(fd-&gt;offset(), string);
 846           }
 847         }
 848         break;
 849       default:
 850         THROW_MSG(vmSymbols::java_lang_ClassFormatError(),
 851                   &quot;Illegal ConstantValue attribute in class file&quot;);
 852     }
 853   }
 854 }
 855 
 856 
 857 void java_lang_Class::fixup_mirror(Klass* k, TRAPS) {
 858   assert(InstanceMirrorKlass::offset_of_static_fields() != 0, &quot;must have been computed already&quot;);
 859 
 860   // If the offset was read from the shared archive, it was fixed up already
 861   if (!k-&gt;is_shared()) {
 862     if (k-&gt;is_instance_klass()) {
 863       // During bootstrap, java.lang.Class wasn&#39;t loaded so static field
 864       // offsets were computed without the size added it.  Go back and
 865       // update all the static field offsets to included the size.
 866       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 867         if (fs.access_flags().is_static()) {
 868           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 869           fs.set_offset(real_offset);
 870         }
 871       }
 872     }
 873   }
 874 
 875   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 876     if (HeapShared::open_archive_heap_region_mapped()) {
 877       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 878       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 879       return;
 880     } else {
 881       k-&gt;set_java_mirror_handle(NULL);
 882       k-&gt;clear_has_raw_archived_mirror();
 883     }
 884   }
 885   create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);
 886 }
 887 
 888 void java_lang_Class::initialize_mirror_fields(Klass* k,
 889                                                Handle mirror,
 890                                                Handle protection_domain,
 891                                                Handle classData,
 892                                                TRAPS) {
 893   // Allocate a simple java object for a lock.
 894   // This needs to be a java object because during class initialization
 895   // it can be held across a java call.
 896   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 897   set_init_lock(mirror(), r);
 898 
 899   // Set protection domain also
 900   set_protection_domain(mirror(), protection_domain());
 901 
 902   // Initialize static fields
 903   InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;initialize_static_field, mirror, CHECK);
 904 
 905  // Set classData
 906   set_class_data(mirror(), classData());
 907 }
 908 
 909 // Set the java.lang.Module module field in the java_lang_Class mirror
 910 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
 911   if (module.is_null()) {
 912     // During startup, the module may be NULL only if java.base has not been defined yet.
 913     // Put the class on the fixup_module_list to patch later when the java.lang.Module
 914     // for java.base is known. But note that since we captured the NULL module another
 915     // thread may have completed that initialization.
 916 
 917     bool javabase_was_defined = false;
 918     {
 919       MutexLocker m1(THREAD, Module_lock);
 920       // Keep list of classes needing java.base module fixup
 921       if (!ModuleEntryTable::javabase_defined()) {
 922         assert(k-&gt;java_mirror() != NULL, &quot;Class&#39;s mirror is null&quot;);
 923         k-&gt;class_loader_data()-&gt;inc_keep_alive();
 924         assert(fixup_module_field_list() != NULL, &quot;fixup_module_field_list not initialized&quot;);
 925         fixup_module_field_list()-&gt;push(k);
 926       } else {
 927         javabase_was_defined = true;
 928       }
 929     }
 930 
 931     // If java.base was already defined then patch this particular class with java.base.
 932     if (javabase_was_defined) {
 933       ModuleEntry *javabase_entry = ModuleEntryTable::javabase_moduleEntry();
 934       assert(javabase_entry != NULL &amp;&amp; javabase_entry-&gt;module() != NULL,
 935              &quot;Setting class module field, &quot; JAVA_BASE_NAME &quot; should be defined&quot;);
 936       Handle javabase_handle(THREAD, javabase_entry-&gt;module());
 937       set_module(mirror(), javabase_handle());
 938     }
 939   } else {
 940     assert(Universe::is_module_initialized() ||
 941            (ModuleEntryTable::javabase_defined() &amp;&amp;
 942             (module() == ModuleEntryTable::javabase_moduleEntry()-&gt;module())),
 943            &quot;Incorrect java.lang.Module specification while creating mirror&quot;);
 944     set_module(mirror(), module());
 945   }
 946 }
 947 
 948 // Statically allocate fixup lists because they always get created.
 949 void java_lang_Class::allocate_fixup_lists() {
 950   GrowableArray&lt;Klass*&gt;* mirror_list =
 951     new (ResourceObj::C_HEAP, mtClass) GrowableArray&lt;Klass*&gt;(40, true);
 952   set_fixup_mirror_list(mirror_list);
 953 
 954   GrowableArray&lt;Klass*&gt;* module_list =
 955     new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;Klass*&gt;(500, true);
 956   set_fixup_module_field_list(module_list);
 957 }
 958 
 959 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
 960                                     Handle module, Handle protection_domain,
 961                                     Handle classData, TRAPS) {
 962   assert(k != NULL, &quot;Use create_basic_type_mirror for primitive types&quot;);
 963   assert(k-&gt;java_mirror() == NULL, &quot;should only assign mirror once&quot;);
 964 
 965   // Use this moment of initialization to cache modifier_flags also,
 966   // to support Class.getModifiers().  Instance classes recalculate
 967   // the cached flags after the class file is parsed, but before the
 968   // class is put into the system dictionary.
 969   int computed_modifiers = k-&gt;compute_modifier_flags(CHECK);
 970   k-&gt;set_modifier_flags(computed_modifiers);
 971   // Class_klass has to be loaded because it is used to allocate
 972   // the mirror.
 973   if (SystemDictionary::Class_klass_loaded()) {
 974     // Allocate mirror (java.lang.Class instance)
 975     oop mirror_oop = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(k, CHECK);
 976     Handle mirror(THREAD, mirror_oop);
 977     Handle comp_mirror;
 978 
 979     // Setup indirection from mirror-&gt;klass
 980     java_lang_Class::set_klass(mirror(), k);
 981 
 982     InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(mirror-&gt;klass());
 983     assert(oop_size(mirror()) == mk-&gt;instance_size(k), &quot;should have been set&quot;);
 984 
 985     java_lang_Class::set_static_oop_field_count(mirror(), mk-&gt;compute_static_oop_field_count(mirror()));
 986 
 987     // It might also have a component mirror.  This mirror must already exist.
 988     if (k-&gt;is_array_klass()) {
<a name="3" id="anc3"></a><span class="line-modified"> 989       if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 990         Klass* element_klass = (Klass*) ValueArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added"> 991         assert(element_klass-&gt;is_value(), &quot;Must be value type component&quot;);</span>
<span class="line-added"> 992         ValueKlass* vk = ValueKlass::cast(InstanceKlass::cast(element_klass));</span>
<span class="line-added"> 993         comp_mirror = Handle(THREAD, vk-&gt;java_mirror());</span>
<span class="line-added"> 994       } else if (k-&gt;is_typeArray_klass()) {</span>
 995         BasicType type = TypeArrayKlass::cast(k)-&gt;element_type();
 996         comp_mirror = Handle(THREAD, Universe::java_mirror(type));
 997       } else {
 998         assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
 999         Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1000         assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1001         comp_mirror = Handle(THREAD, element_klass-&gt;java_mirror());
1002       }
1003       assert(comp_mirror() != NULL, &quot;must have a mirror&quot;);
1004 
1005       // Two-way link between the array klass and its component mirror:
1006       // (array_klass) k -&gt; mirror -&gt; component_mirror -&gt; array_klass -&gt; k
1007       set_component_mirror(mirror(), comp_mirror());
1008       // See below for ordering dependencies between field array_klass in component mirror
1009       // and java_mirror in this klass.
1010     } else {
1011       assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1012 
1013       initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
1014       if (HAS_PENDING_EXCEPTION) {
1015         // If any of the fields throws an exception like OOM remove the klass field
1016         // from the mirror so GC doesn&#39;t follow it after the klass has been deallocated.
1017         // This mirror looks like a primitive type, which logically it is because it
1018         // it represents no class.
1019         java_lang_Class::set_klass(mirror(), NULL);
1020         return;
1021       }
1022     }
1023 
1024     // set the classLoader field in the java_lang_Class instance
1025     assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1026     set_class_loader(mirror(), class_loader());
1027 
1028     // Setup indirection from klass-&gt;mirror
1029     // after any exceptions can happen during allocations.
1030     k-&gt;set_java_mirror(mirror);
1031 
1032     // Set the module field in the java_lang_Class instance.  This must be done
1033     // after the mirror is set.
1034     set_mirror_module_field(k, mirror, module, THREAD);
1035 
1036     if (comp_mirror() != NULL) {
1037       // Set after k-&gt;java_mirror() is published, because compiled code running
1038       // concurrently doesn&#39;t expect a k to have a null java_mirror.
1039       release_set_array_klass(comp_mirror(), k);
1040     }
<a name="4" id="anc4"></a><span class="line-added">1041 </span>
<span class="line-added">1042     if (k-&gt;is_value()) {</span>
<span class="line-added">1043       InstanceKlass* super = k-&gt;java_super();</span>
<span class="line-added">1044       set_val_type_mirror(mirror(), mirror());</span>
<span class="line-added">1045 </span>
<span class="line-added">1046       // if the supertype is a restricted abstract class</span>
<span class="line-added">1047       if (super != SystemDictionary::Object_klass()) {</span>
<span class="line-added">1048         assert(super-&gt;access_flags().is_abstract(), &quot;must be an abstract class&quot;);</span>
<span class="line-added">1049         oop ref_type_oop = super-&gt;java_mirror();</span>
<span class="line-added">1050         // set the reference projection type</span>
<span class="line-added">1051         set_ref_type_mirror(mirror(), ref_type_oop);</span>
<span class="line-added">1052 </span>
<span class="line-added">1053         // set the value and reference projection types</span>
<span class="line-added">1054         set_val_type_mirror(ref_type_oop, mirror());</span>
<span class="line-added">1055         set_ref_type_mirror(ref_type_oop, ref_type_oop);</span>
<span class="line-added">1056       }</span>
<span class="line-added">1057     }</span>
1058   } else {
1059     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1060     fixup_mirror_list()-&gt;push(k);
1061   }
1062 }
1063 
1064 #if INCLUDE_CDS_JAVA_HEAP
1065 // Clears mirror fields. Static final fields with initial values are reloaded
1066 // from constant pool. The object identity hash is in the object header and is
1067 // not affected.
1068 class ResetMirrorField: public FieldClosure {
1069  private:
1070   Handle _m;
1071 
1072  public:
1073   ResetMirrorField(Handle mirror) : _m(mirror) {}
1074 
1075   void do_field(fieldDescriptor* fd) {
1076     assert(DumpSharedSpaces, &quot;dump time only&quot;);
1077     assert(_m.not_null(), &quot;Mirror cannot be NULL&quot;);
1078 
1079     if (fd-&gt;is_static() &amp;&amp; fd-&gt;has_initial_value()) {
1080       initialize_static_field(fd, _m, Thread::current());
1081       return;
1082     }
1083 
1084     BasicType ft = fd-&gt;field_type();
1085     switch (ft) {
1086       case T_BYTE:
1087         _m()-&gt;byte_field_put(fd-&gt;offset(), 0);
1088         break;
1089       case T_CHAR:
1090         _m()-&gt;char_field_put(fd-&gt;offset(), 0);
1091         break;
1092       case T_DOUBLE:
1093         _m()-&gt;double_field_put(fd-&gt;offset(), 0);
1094         break;
1095       case T_FLOAT:
1096         _m()-&gt;float_field_put(fd-&gt;offset(), 0);
1097         break;
1098       case T_INT:
1099         _m()-&gt;int_field_put(fd-&gt;offset(), 0);
1100         break;
1101       case T_LONG:
1102         _m()-&gt;long_field_put(fd-&gt;offset(), 0);
1103         break;
1104       case T_SHORT:
1105         _m()-&gt;short_field_put(fd-&gt;offset(), 0);
1106         break;
1107       case T_BOOLEAN:
1108         _m()-&gt;bool_field_put(fd-&gt;offset(), false);
1109         break;
1110       case T_ARRAY:
1111       case T_OBJECT: {
1112         // It might be useful to cache the String field, but
1113         // for now just clear out any reference field
1114         oop o = _m()-&gt;obj_field(fd-&gt;offset());
1115         _m()-&gt;obj_field_put(fd-&gt;offset(), NULL);
1116         break;
1117       }
1118       default:
1119         ShouldNotReachHere();
1120         break;
1121      }
1122   }
1123 };
1124 
1125 void java_lang_Class::archive_basic_type_mirrors(TRAPS) {
1126   assert(HeapShared::is_heap_object_archiving_allowed(),
1127          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1128 
1129   for (int t = 0; t &lt;= T_VOID; t++) {
1130     oop m = Universe::_mirrors[t];
1131     if (m != NULL) {
1132       // Update the field at _array_klass_offset to point to the relocated array klass.
1133       oop archived_m = HeapShared::archive_heap_object(m, THREAD);
1134       assert(archived_m != NULL, &quot;sanity&quot;);
1135       Klass *ak = (Klass*)(archived_m-&gt;metadata_field(_array_klass_offset));
1136       assert(ak != NULL || t == T_VOID, &quot;should not be NULL&quot;);
1137       if (ak != NULL) {
1138         Klass *reloc_ak = MetaspaceShared::get_relocated_klass(ak, true);
1139         archived_m-&gt;metadata_field_put(_array_klass_offset, reloc_ak);
1140       }
1141 
1142       // Clear the fields. Just to be safe
1143       Klass *k = m-&gt;klass();
1144       Handle archived_mirror_h(THREAD, archived_m);
1145       ResetMirrorField reset(archived_mirror_h);
1146       InstanceKlass::cast(k)-&gt;do_nonstatic_fields(&amp;reset);
1147 
1148       log_trace(cds, heap, mirror)(
1149         &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1150         type2name((BasicType)t), p2i(Universe::_mirrors[t]), p2i(archived_m));
1151 
1152       Universe::_mirrors[t] = archived_m;
1153     }
1154   }
1155 
1156   assert(Universe::_mirrors[T_INT] != NULL &amp;&amp;
1157          Universe::_mirrors[T_FLOAT] != NULL &amp;&amp;
1158          Universe::_mirrors[T_DOUBLE] != NULL &amp;&amp;
1159          Universe::_mirrors[T_BYTE] != NULL &amp;&amp;
1160          Universe::_mirrors[T_BOOLEAN] != NULL &amp;&amp;
1161          Universe::_mirrors[T_CHAR] != NULL &amp;&amp;
1162          Universe::_mirrors[T_LONG] != NULL &amp;&amp;
1163          Universe::_mirrors[T_SHORT] != NULL &amp;&amp;
1164          Universe::_mirrors[T_VOID] != NULL, &quot;sanity&quot;);
1165 
1166   Universe::set_int_mirror(Universe::_mirrors[T_INT]);
1167   Universe::set_float_mirror(Universe::_mirrors[T_FLOAT]);
1168   Universe::set_double_mirror(Universe::_mirrors[T_DOUBLE]);
1169   Universe::set_byte_mirror(Universe::_mirrors[T_BYTE]);
1170   Universe::set_bool_mirror(Universe::_mirrors[T_BOOLEAN]);
1171   Universe::set_char_mirror(Universe::_mirrors[T_CHAR]);
1172   Universe::set_long_mirror(Universe::_mirrors[T_LONG]);
1173   Universe::set_short_mirror(Universe::_mirrors[T_SHORT]);
1174   Universe::set_void_mirror(Universe::_mirrors[T_VOID]);
1175 }
1176 
1177 //
1178 // After the mirror object is successfully archived, the archived
1179 // klass is set with _has_archived_raw_mirror flag.
1180 //
1181 // The _has_archived_raw_mirror flag is cleared at runtime when the
1182 // archived mirror is restored. If archived java heap data cannot
1183 // be used at runtime, new mirror object is created for the shared
1184 // class. The _has_archived_raw_mirror is cleared also during the process.
1185 oop java_lang_Class::archive_mirror(Klass* k, TRAPS) {
1186   assert(HeapShared::is_heap_object_archiving_allowed(),
1187          &quot;HeapShared::is_heap_object_archiving_allowed() must be true&quot;);
1188 
1189   // Mirror is already archived
1190   if (k-&gt;has_raw_archived_mirror()) {
1191     assert(k-&gt;archived_java_mirror_raw() != NULL, &quot;no archived mirror&quot;);
1192     return k-&gt;archived_java_mirror_raw();
1193   }
1194 
1195   // No mirror
1196   oop mirror = k-&gt;java_mirror();
1197   if (mirror == NULL) {
1198     return NULL;
1199   }
1200 
1201   if (k-&gt;is_instance_klass()) {
1202     InstanceKlass *ik = InstanceKlass::cast(k);
1203     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1204 
1205     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1206           ik-&gt;is_shared_app_class())) {
1207       // Archiving mirror for classes from non-builtin loaders is not
1208       // supported. Clear the _java_mirror within the archived class.
1209       k-&gt;set_java_mirror_handle(NULL);
1210       return NULL;
1211     }
1212   }
1213 
<a name="5" id="anc5"></a><span class="line-added">1214   if (k-&gt;is_value()) {</span>
<span class="line-added">1215     // Values have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS</span>
<span class="line-added">1216     k-&gt;set_java_mirror_handle(NULL);</span>
<span class="line-added">1217     return NULL;</span>
<span class="line-added">1218   }</span>
<span class="line-added">1219 </span>
1220   // Now start archiving the mirror object
1221   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1222   if (archived_mirror == NULL) {
1223     return NULL;
1224   }
1225 
1226   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1227   if (archived_mirror == NULL) {
1228     return NULL;
1229   }
1230 
1231   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1232 
1233   k-&gt;set_has_raw_archived_mirror();
1234 
1235   ResourceMark rm;
1236   log_trace(cds, heap, mirror)(
1237     &quot;Archived %s mirror object from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1238     k-&gt;external_name(), p2i(mirror), p2i(archived_mirror));
1239 
1240   return archived_mirror;
1241 }
1242 
1243 // The process is based on create_mirror().
1244 oop java_lang_Class::process_archived_mirror(Klass* k, oop mirror,
1245                                              oop archived_mirror,
1246                                              Thread *THREAD) {
1247   // Clear nonstatic fields in archived mirror. Some of the fields will be set
1248   // to archived metadata and objects below.
1249   Klass *c = archived_mirror-&gt;klass();
1250   Handle archived_mirror_h(THREAD, archived_mirror);
1251   ResetMirrorField reset(archived_mirror_h);
1252   InstanceKlass::cast(c)-&gt;do_nonstatic_fields(&amp;reset);
1253 
1254   if (k-&gt;is_array_klass()) {
1255     oop archived_comp_mirror;
1256     if (k-&gt;is_typeArray_klass()) {
1257       // The primitive type mirrors are already archived. Get the archived mirror.
1258       oop comp_mirror = java_lang_Class::component_mirror(mirror);
1259       archived_comp_mirror = HeapShared::find_archived_heap_object(comp_mirror);
1260       assert(archived_comp_mirror != NULL, &quot;Must be&quot;);
1261     } else {
1262       assert(k-&gt;is_objArray_klass(), &quot;Must be&quot;);
1263       Klass* element_klass = ObjArrayKlass::cast(k)-&gt;element_klass();
1264       assert(element_klass != NULL, &quot;Must have an element klass&quot;);
1265       archived_comp_mirror = archive_mirror(element_klass, THREAD);
1266       if (archived_comp_mirror == NULL) {
1267         return NULL;
1268       }
1269     }
1270     java_lang_Class::set_component_mirror(archived_mirror, archived_comp_mirror);
1271   } else {
1272     assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
1273 
1274     // Reset local static fields in the mirror
1275     InstanceKlass::cast(k)-&gt;do_local_static_fields(&amp;reset);
1276 
1277     java_lang_Class:set_init_lock(archived_mirror, NULL);
1278 
1279     set_protection_domain(archived_mirror, NULL);
1280   }
1281 
1282   // clear class loader and mirror_module_field
1283   set_class_loader(archived_mirror, NULL);
1284   set_module(archived_mirror, NULL);
1285 
1286   // The archived mirror&#39;s field at _klass_offset is still pointing to the original
1287   // klass. Updated the field in the archived mirror to point to the relocated
1288   // klass in the archive.
1289   Klass *reloc_k = MetaspaceShared::get_relocated_klass(as_Klass(mirror), true);
1290   log_debug(cds, heap, mirror)(
1291     &quot;Relocate mirror metadata field at _klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1292     p2i(as_Klass(mirror)), p2i(reloc_k));
1293   archived_mirror-&gt;metadata_field_put(_klass_offset, reloc_k);
1294 
1295   // The field at _array_klass_offset is pointing to the original one dimension
1296   // higher array klass if exists. Relocate the pointer.
1297   Klass *arr = array_klass_acquire(mirror);
1298   if (arr != NULL) {
1299     Klass *reloc_arr = MetaspaceShared::get_relocated_klass(arr, true);
1300     log_debug(cds, heap, mirror)(
1301       &quot;Relocate mirror metadata field at _array_klass_offset from &quot; PTR_FORMAT &quot; ==&gt; &quot; PTR_FORMAT,
1302       p2i(arr), p2i(reloc_arr));
1303     archived_mirror-&gt;metadata_field_put(_array_klass_offset, reloc_arr);
1304   }
1305   return archived_mirror;
1306 }
1307 
1308 void java_lang_Class::update_archived_primitive_mirror_native_pointers(oop archived_mirror) {
1309   if (MetaspaceShared::relocation_delta() != 0) {
1310     assert(archived_mirror-&gt;metadata_field(_klass_offset) == NULL, &quot;must be for primitive class&quot;);
1311 
1312     Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1313     if (ak != NULL) {
1314       archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1315           (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1316     }
1317   }
1318 }
1319 
1320 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {
1321   assert(MetaspaceShared::relocation_delta() != 0, &quot;must be&quot;);
1322 
1323   Klass* k = ((Klass*)archived_mirror-&gt;metadata_field(_klass_offset));
1324   archived_mirror-&gt;metadata_field_put(_klass_offset,
1325       (Klass*)(address(k) + MetaspaceShared::relocation_delta()));
1326 
1327   Klass* ak = ((Klass*)archived_mirror-&gt;metadata_field(_array_klass_offset));
1328   if (ak != NULL) {
1329     archived_mirror-&gt;metadata_field_put(_array_klass_offset,
1330         (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
1331   }
1332 }
1333 
1334 
1335 // Returns true if the mirror is updated, false if no archived mirror
1336 // data is present. After the archived mirror object is restored, the
1337 // shared klass&#39; _has_raw_archived_mirror flag is cleared.
1338 bool java_lang_Class::restore_archived_mirror(Klass *k,
1339                                               Handle class_loader, Handle module,
1340                                               Handle protection_domain, TRAPS) {
1341   // Postpone restoring archived mirror until java.lang.Class is loaded. Please
1342   // see more details in SystemDictionary::resolve_well_known_classes().
1343   if (!SystemDictionary::Class_klass_loaded()) {
1344     assert(fixup_mirror_list() != NULL, &quot;fixup_mirror_list not initialized&quot;);
1345     fixup_mirror_list()-&gt;push(k);
1346     return true;
1347   }
1348 
1349   oop m = HeapShared::materialize_archived_object(k-&gt;archived_java_mirror_raw_narrow());
1350   if (m == NULL) {
1351     return false;
1352   }
1353 
1354   // mirror is archived, restore
1355   log_debug(cds, mirror)(&quot;Archived mirror is: &quot; PTR_FORMAT, p2i(m));
1356   assert(HeapShared::is_archived_object(m), &quot;must be archived mirror object&quot;);
1357   assert(as_Klass(m) == k, &quot;must be&quot;);
1358   Handle mirror(THREAD, m);
1359 
1360   if (!k-&gt;is_array_klass()) {
1361     // - local static final fields with initial values were initialized at dump time
1362 
1363     // create the init_lock
1364     typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));
1365     set_init_lock(mirror(), r);
1366 
1367     if (protection_domain.not_null()) {
1368       set_protection_domain(mirror(), protection_domain());
1369     }
1370   }
1371 
1372   assert(class_loader() == k-&gt;class_loader(), &quot;should be same&quot;);
1373   if (class_loader.not_null()) {
1374     set_class_loader(mirror(), class_loader());
1375   }
1376 
1377   k-&gt;set_java_mirror(mirror);
1378   k-&gt;clear_has_raw_archived_mirror();
1379 
1380   set_mirror_module_field(k, mirror, module, THREAD);
1381 
1382   if (log_is_enabled(Trace, cds, heap, mirror)) {
1383     ResourceMark rm(THREAD);
1384     log_trace(cds, heap, mirror)(
1385         &quot;Restored %s archived mirror &quot; PTR_FORMAT, k-&gt;external_name(), p2i(mirror()));
1386   }
1387 
1388   return true;
1389 }
1390 #endif // INCLUDE_CDS_JAVA_HEAP
1391 
1392 void java_lang_Class::fixup_module_field(Klass* k, Handle module) {
1393   assert(_module_offset != 0, &quot;must have been computed already&quot;);
1394   java_lang_Class::set_module(k-&gt;java_mirror(), module());
1395 }
1396 
1397 int  java_lang_Class::oop_size(oop java_class) {
1398   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1399   int size = java_class-&gt;int_field(_oop_size_offset);
1400   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1401   return size;
1402 }
1403 
1404 
1405 void java_lang_Class::set_oop_size(HeapWord* java_class, int size) {
1406   assert(_oop_size_offset != 0, &quot;must be set&quot;);
1407   assert(size &gt; 0, &quot;Oop size must be greater than zero, not %d&quot;, size);
1408   *(int*)(((char*)java_class) + _oop_size_offset) = size;
1409 }
1410 
1411 int  java_lang_Class::static_oop_field_count(oop java_class) {
1412   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1413   return java_class-&gt;int_field(_static_oop_field_count_offset);
1414 }
1415 
1416 int  java_lang_Class::static_oop_field_count_raw(oop java_class) {
1417   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1418   return java_class-&gt;int_field_raw(_static_oop_field_count_offset);
1419 }
1420 
1421 void java_lang_Class::set_static_oop_field_count(oop java_class, int size) {
1422   assert(_static_oop_field_count_offset != 0, &quot;must be set&quot;);
1423   java_class-&gt;int_field_put(_static_oop_field_count_offset, size);
1424 }
1425 
1426 oop java_lang_Class::protection_domain(oop java_class) {
1427   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1428   return java_class-&gt;obj_field(_protection_domain_offset);
1429 }
1430 void java_lang_Class::set_protection_domain(oop java_class, oop pd) {
1431   assert(_protection_domain_offset != 0, &quot;must be set&quot;);
1432   java_class-&gt;obj_field_put(_protection_domain_offset, pd);
1433 }
1434 
1435 void java_lang_Class::set_component_mirror(oop java_class, oop comp_mirror) {
1436   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1437     java_class-&gt;obj_field_put(_component_mirror_offset, comp_mirror);
1438   }
1439 oop java_lang_Class::component_mirror(oop java_class) {
1440   assert(_component_mirror_offset != 0, &quot;must be set&quot;);
1441   return java_class-&gt;obj_field(_component_mirror_offset);
1442 }
1443 
1444 oop java_lang_Class::init_lock(oop java_class) {
1445   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1446   return java_class-&gt;obj_field(_init_lock_offset);
1447 }
1448 void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {
1449   assert(_init_lock_offset != 0, &quot;must be set&quot;);
1450   java_class-&gt;obj_field_put(_init_lock_offset, init_lock);
1451 }
1452 
1453 objArrayOop java_lang_Class::signers(oop java_class) {
1454   assert(_signers_offset != 0, &quot;must be set&quot;);
1455   return (objArrayOop)java_class-&gt;obj_field(_signers_offset);
1456 }
1457 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
1458   assert(_signers_offset != 0, &quot;must be set&quot;);
1459   java_class-&gt;obj_field_put(_signers_offset, (oop)signers);
1460 }
1461 
1462 oop java_lang_Class::class_data(oop java_class) {
1463   assert(_classData_offset != 0, &quot;must be set&quot;);
1464   return java_class-&gt;obj_field(_classData_offset);
1465 }
1466 void java_lang_Class::set_class_data(oop java_class, oop class_data) {
1467   assert(_classData_offset != 0, &quot;must be set&quot;);
1468   java_class-&gt;obj_field_put(_classData_offset, class_data);
1469 }
1470 
1471 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
1472   assert(_class_loader_offset != 0, &quot;offsets should have been initialized&quot;);
1473   java_class-&gt;obj_field_put(_class_loader_offset, loader);
1474 }
1475 
1476 oop java_lang_Class::class_loader(oop java_class) {
1477   assert(_class_loader_offset != 0, &quot;must be set&quot;);
1478   return java_class-&gt;obj_field(_class_loader_offset);
1479 }
1480 
1481 oop java_lang_Class::module(oop java_class) {
1482   assert(_module_offset != 0, &quot;must be set&quot;);
1483   return java_class-&gt;obj_field(_module_offset);
1484 }
1485 
1486 void java_lang_Class::set_module(oop java_class, oop module) {
1487   assert(_module_offset != 0, &quot;must be set&quot;);
1488   java_class-&gt;obj_field_put(_module_offset, module);
1489 }
1490 
1491 oop java_lang_Class::name(Handle java_class, TRAPS) {
1492   assert(_name_offset != 0, &quot;must be set&quot;);
1493   oop o = java_class-&gt;obj_field(_name_offset);
1494   if (o == NULL) {
1495     o = StringTable::intern(java_lang_Class::as_external_name(java_class()), THREAD);
1496     java_class-&gt;obj_field_put(_name_offset, o);
1497   }
1498   return o;
1499 }
1500 
1501 oop java_lang_Class::source_file(oop java_class) {
1502   assert(_source_file_offset != 0, &quot;must be set&quot;);
1503   return java_class-&gt;obj_field(_source_file_offset);
1504 }
1505 
1506 void java_lang_Class::set_source_file(oop java_class, oop source_file) {
1507   assert(_source_file_offset != 0, &quot;must be set&quot;);
1508   java_class-&gt;obj_field_put(_source_file_offset, source_file);
1509 }
1510 
<a name="6" id="anc6"></a><span class="line-added">1511 oop java_lang_Class::val_type_mirror(oop java_class) {</span>
<span class="line-added">1512   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1513   return java_class-&gt;obj_field(_val_type_mirror_offset);</span>
<span class="line-added">1514 }</span>
<span class="line-added">1515 </span>
<span class="line-added">1516 void java_lang_Class::set_val_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1517   assert(_val_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1518   java_class-&gt;obj_field_put(_val_type_mirror_offset, mirror);</span>
<span class="line-added">1519 }</span>
<span class="line-added">1520 </span>
<span class="line-added">1521 oop java_lang_Class::ref_type_mirror(oop java_class) {</span>
<span class="line-added">1522   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1523   return java_class-&gt;obj_field(_ref_type_mirror_offset);</span>
<span class="line-added">1524 }</span>
<span class="line-added">1525 </span>
<span class="line-added">1526 void java_lang_Class::set_ref_type_mirror(oop java_class, oop mirror) {</span>
<span class="line-added">1527   assert(_ref_type_mirror_offset != 0, &quot;must be set&quot;);</span>
<span class="line-added">1528   java_class-&gt;obj_field_put(_ref_type_mirror_offset, mirror);</span>
<span class="line-added">1529 }</span>
<span class="line-added">1530 </span>
1531 oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
1532   // This should be improved by adding a field at the Java level or by
1533   // introducing a new VM klass (see comment in ClassFileParser)
1534   oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&gt;allocate_instance(NULL, CHECK_NULL);
1535   if (type != T_VOID) {
1536     Klass* aklass = Universe::typeArrayKlassObj(type);
1537     assert(aklass != NULL, &quot;correct bootstrap&quot;);
1538     release_set_array_klass(java_class, aklass);
1539   }
1540 #ifdef ASSERT
1541   InstanceMirrorKlass* mk = InstanceMirrorKlass::cast(SystemDictionary::Class_klass());
1542   assert(java_lang_Class::static_oop_field_count(java_class) == 0, &quot;should have been zeroed by allocation&quot;);
1543 #endif
1544   return java_class;
1545 }
1546 
1547 
1548 Klass* java_lang_Class::as_Klass(oop java_class) {
1549   //%note memory_2
1550   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1551   Klass* k = ((Klass*)java_class-&gt;metadata_field(_klass_offset));
1552   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1553   return k;
1554 }
1555 
1556 Klass* java_lang_Class::as_Klass_raw(oop java_class) {
1557   //%note memory_2
1558   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1559   Klass* k = ((Klass*)java_class-&gt;metadata_field_raw(_klass_offset));
1560   assert(k == NULL || k-&gt;is_klass(), &quot;type check&quot;);
1561   return k;
1562 }
1563 
1564 
1565 void java_lang_Class::set_klass(oop java_class, Klass* klass) {
1566   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1567   java_class-&gt;metadata_field_put(_klass_offset, klass);
1568 }
1569 
1570 
1571 void java_lang_Class::print_signature(oop java_class, outputStream* st) {
1572   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1573   Symbol* name = NULL;
1574   bool is_instance = false;
<a name="7" id="anc7"></a><span class="line-added">1575   bool is_value = false;</span>
1576   if (is_primitive(java_class)) {
1577     name = vmSymbols::type_signature(primitive_type(java_class));
1578   } else {
1579     Klass* k = as_Klass(java_class);
1580     is_instance = k-&gt;is_instance_klass();
<a name="8" id="anc8"></a><span class="line-added">1581     is_value = k-&gt;is_value();</span>
1582     name = k-&gt;name();
1583   }
1584   if (name == NULL) {
1585     st-&gt;print(&quot;&lt;null&gt;&quot;);
1586     return;
1587   }
<a name="9" id="anc9"></a><span class="line-modified">1588   if (is_instance)  {</span>
<span class="line-added">1589     if (is_value) {</span>
<span class="line-added">1590       st-&gt;print(&quot;Q&quot;);</span>
<span class="line-added">1591     } else {</span>
<span class="line-added">1592       st-&gt;print(&quot;L&quot;);</span>
<span class="line-added">1593     }</span>
<span class="line-added">1594   }</span>
1595   st-&gt;write((char*) name-&gt;base(), (int) name-&gt;utf8_length());
1596   if (is_instance)  st-&gt;print(&quot;;&quot;);
1597 }
1598 
1599 Symbol* java_lang_Class::as_signature(oop java_class, bool intern_if_not_found) {
1600   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1601   Symbol* name;
1602   if (is_primitive(java_class)) {
1603     name = vmSymbols::type_signature(primitive_type(java_class));
1604     // Because this can create a new symbol, the caller has to decrement
1605     // the refcount, so make adjustment here and below for symbols returned
1606     // that are not created or incremented due to a successful lookup.
1607     name-&gt;increment_refcount();
1608   } else {
1609     Klass* k = as_Klass(java_class);
1610     if (!k-&gt;is_instance_klass()) {
1611       name = k-&gt;name();
1612       name-&gt;increment_refcount();
1613     } else {
1614       ResourceMark rm;
1615       const char* sigstr = k-&gt;signature_name();
<a name="10" id="anc10"></a><span class="line-modified">1616       int siglen = (int) strlen(sigstr);</span>
1617       if (!intern_if_not_found) {
1618         name = SymbolTable::probe(sigstr, siglen);
1619       } else {
1620         name = SymbolTable::new_symbol(sigstr, siglen);
1621       }
1622     }
1623   }
1624   return name;
1625 }
1626 
1627 // Returns the Java name for this Java mirror (Resource allocated)
1628 // See Klass::external_name().
1629 // For primitive type Java mirrors, its type name is returned.
1630 const char* java_lang_Class::as_external_name(oop java_class) {
1631   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1632   const char* name = NULL;
1633   if (is_primitive(java_class)) {
1634     name = type2name(primitive_type(java_class));
1635   } else {
1636     name = as_Klass(java_class)-&gt;external_name();
1637   }
1638   if (name == NULL) {
1639     name = &quot;&lt;null&gt;&quot;;
1640   }
1641   return name;
1642 }
1643 
1644 Klass* java_lang_Class::array_klass_acquire(oop java_class) {
1645   Klass* k = ((Klass*)java_class-&gt;metadata_field_acquire(_array_klass_offset));
1646   assert(k == NULL || k-&gt;is_klass() &amp;&amp; k-&gt;is_array_klass(), &quot;should be array klass&quot;);
1647   return k;
1648 }
1649 
1650 
1651 void java_lang_Class::release_set_array_klass(oop java_class, Klass* klass) {
1652   assert(klass-&gt;is_klass() &amp;&amp; klass-&gt;is_array_klass(), &quot;should be array klass&quot;);
1653   java_class-&gt;release_metadata_field_put(_array_klass_offset, klass);
1654 }
1655 
1656 
1657 BasicType java_lang_Class::primitive_type(oop java_class) {
1658   assert(java_lang_Class::is_primitive(java_class), &quot;just checking&quot;);
1659   Klass* ak = ((Klass*)java_class-&gt;metadata_field(_array_klass_offset));
1660   BasicType type = T_VOID;
1661   if (ak != NULL) {
1662     // Note: create_basic_type_mirror above initializes ak to a non-null value.
1663     type = ArrayKlass::cast(ak)-&gt;element_type();
1664   } else {
1665     assert(java_class == Universe::void_mirror(), &quot;only valid non-array primitive&quot;);
1666   }
1667   assert(Universe::java_mirror(type) == java_class, &quot;must be consistent&quot;);
1668   return type;
1669 }
1670 
1671 BasicType java_lang_Class::as_BasicType(oop java_class, Klass** reference_klass) {
1672   assert(java_lang_Class::is_instance(java_class), &quot;must be a Class object&quot;);
1673   if (is_primitive(java_class)) {
1674     if (reference_klass != NULL)
1675       (*reference_klass) = NULL;
1676     return primitive_type(java_class);
1677   } else {
1678     if (reference_klass != NULL)
1679       (*reference_klass) = as_Klass(java_class);
1680     return T_OBJECT;
1681   }
1682 }
1683 
1684 
1685 oop java_lang_Class::primitive_mirror(BasicType t) {
1686   oop mirror = Universe::java_mirror(t);
1687   assert(mirror != NULL &amp;&amp; mirror-&gt;is_a(SystemDictionary::Class_klass()), &quot;must be a Class&quot;);
1688   assert(java_lang_Class::is_primitive(mirror), &quot;must be primitive&quot;);
1689   return mirror;
1690 }
1691 
1692 bool java_lang_Class::offsets_computed = false;
1693 int  java_lang_Class::classRedefinedCount_offset = -1;
1694 
1695 #define CLASS_FIELDS_DO(macro) \
1696   macro(classRedefinedCount_offset, k, &quot;classRedefinedCount&quot;, int_signature,         false); \
1697   macro(_class_loader_offset,       k, &quot;classLoader&quot;,         classloader_signature, false); \
1698   macro(_component_mirror_offset,   k, &quot;componentType&quot;,       class_signature,       false); \
1699   macro(_module_offset,             k, &quot;module&quot;,              module_signature,      false); \
1700   macro(_name_offset,               k, &quot;name&quot;,                string_signature,      false); \
<a name="11" id="anc11"></a><span class="line-added">1701   macro(_val_type_mirror_offset,    k, &quot;valType&quot;,             class_signature,       false); \</span>
<span class="line-added">1702   macro(_ref_type_mirror_offset,    k, &quot;refType&quot;,             class_signature,       false); \</span>
1703   macro(_classData_offset,          k, &quot;classData&quot;,           object_signature,      false);
1704 
1705 void java_lang_Class::compute_offsets() {
1706   if (offsets_computed) {
1707     return;
1708   }
1709 
1710   offsets_computed = true;
1711 
1712   InstanceKlass* k = SystemDictionary::Class_klass();
1713   CLASS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1714 
1715   // Init lock is a C union with component_mirror.  Only instanceKlass mirrors have
1716   // init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops
1717   // GC treats them the same.
1718   _init_lock_offset = _component_mirror_offset;
1719 
1720   CLASS_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
1721 }
1722 
1723 #if INCLUDE_CDS
1724 void java_lang_Class::serialize_offsets(SerializeClosure* f) {
1725   f-&gt;do_bool(&amp;offsets_computed);
1726   f-&gt;do_u4((u4*)&amp;_init_lock_offset);
1727 
1728   CLASS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1729 
1730   CLASS_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
1731 }
1732 #endif
1733 
1734 int java_lang_Class::classRedefinedCount(oop the_class_mirror) {
1735   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);
1736   return the_class_mirror-&gt;int_field(classRedefinedCount_offset);
1737 }
1738 
1739 void java_lang_Class::set_classRedefinedCount(oop the_class_mirror, int value) {
1740   assert(classRedefinedCount_offset != -1, &quot;offsets should have been initialized&quot;);
1741   the_class_mirror-&gt;int_field_put(classRedefinedCount_offset, value);
1742 }
1743 
1744 
1745 // Note: JDK1.1 and before had a privateInfo_offset field which was used for the
1746 //       platform thread structure, and a eetop offset which was used for thread
1747 //       local storage (and unused by the HotSpot VM). In JDK1.2 the two structures
1748 //       merged, so in the HotSpot VM we just use the eetop field for the thread
1749 //       instead of the privateInfo_offset.
1750 //
1751 // Note: The stackSize field is only present starting in 1.4.
1752 
1753 int java_lang_Thread::_name_offset = 0;
1754 int java_lang_Thread::_group_offset = 0;
1755 int java_lang_Thread::_contextClassLoader_offset = 0;
1756 int java_lang_Thread::_inheritedAccessControlContext_offset = 0;
1757 int java_lang_Thread::_priority_offset = 0;
1758 int java_lang_Thread::_eetop_offset = 0;
1759 int java_lang_Thread::_interrupted_offset = 0;
1760 int java_lang_Thread::_daemon_offset = 0;
1761 int java_lang_Thread::_stillborn_offset = 0;
1762 int java_lang_Thread::_stackSize_offset = 0;
1763 int java_lang_Thread::_tid_offset = 0;
1764 int java_lang_Thread::_thread_status_offset = 0;
1765 int java_lang_Thread::_park_blocker_offset = 0;
1766 
1767 #define THREAD_FIELDS_DO(macro) \
1768   macro(_name_offset,          k, vmSymbols::name_name(), string_signature, false); \
1769   macro(_group_offset,         k, vmSymbols::group_name(), threadgroup_signature, false); \
1770   macro(_contextClassLoader_offset, k, vmSymbols::contextClassLoader_name(), classloader_signature, false); \
1771   macro(_inheritedAccessControlContext_offset, k, vmSymbols::inheritedAccessControlContext_name(), accesscontrolcontext_signature, false); \
1772   macro(_priority_offset,      k, vmSymbols::priority_name(), int_signature, false); \
1773   macro(_daemon_offset,        k, vmSymbols::daemon_name(), bool_signature, false); \
1774   macro(_eetop_offset,         k, &quot;eetop&quot;, long_signature, false); \
1775   macro(_interrupted_offset,   k, &quot;interrupted&quot;, bool_signature, false); \
1776   macro(_stillborn_offset,     k, &quot;stillborn&quot;, bool_signature, false); \
1777   macro(_stackSize_offset,     k, &quot;stackSize&quot;, long_signature, false); \
1778   macro(_tid_offset,           k, &quot;tid&quot;, long_signature, false); \
1779   macro(_thread_status_offset, k, &quot;threadStatus&quot;, int_signature, false); \
1780   macro(_park_blocker_offset,  k, &quot;parkBlocker&quot;, object_signature, false)
1781 
1782 void java_lang_Thread::compute_offsets() {
1783   assert(_group_offset == 0, &quot;offsets should be initialized only once&quot;);
1784 
1785   InstanceKlass* k = SystemDictionary::Thread_klass();
1786   THREAD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
1787 }
1788 
1789 #if INCLUDE_CDS
1790 void java_lang_Thread::serialize_offsets(SerializeClosure* f) {
1791   THREAD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
1792 }
1793 #endif
1794 
1795 JavaThread* java_lang_Thread::thread(oop java_thread) {
1796   return (JavaThread*)java_thread-&gt;address_field(_eetop_offset);
1797 }
1798 
1799 
1800 void java_lang_Thread::set_thread(oop java_thread, JavaThread* thread) {
1801   java_thread-&gt;address_field_put(_eetop_offset, (address)thread);
1802 }
1803 
1804 bool java_lang_Thread::interrupted(oop java_thread) {
1805   // Make sure the caller can safely access oops.
1806   assert(Thread::current()-&gt;is_VM_thread() ||
1807          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1808           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1809          &quot;Unsafe access to oop&quot;);
1810   return java_thread-&gt;bool_field_volatile(_interrupted_offset);
1811 }
1812 
1813 void java_lang_Thread::set_interrupted(oop java_thread, bool val) {
1814   // Make sure the caller can safely access oops.
1815   assert(Thread::current()-&gt;is_VM_thread() ||
1816          (JavaThread::current()-&gt;thread_state() != _thread_blocked &amp;&amp;
1817           JavaThread::current()-&gt;thread_state() != _thread_in_native),
1818          &quot;Unsafe access to oop&quot;);
1819   java_thread-&gt;bool_field_put_volatile(_interrupted_offset, val);
1820 }
1821 
1822 
1823 oop java_lang_Thread::name(oop java_thread) {
1824   return java_thread-&gt;obj_field(_name_offset);
1825 }
1826 
1827 
1828 void java_lang_Thread::set_name(oop java_thread, oop name) {
1829   java_thread-&gt;obj_field_put(_name_offset, name);
1830 }
1831 
1832 
1833 ThreadPriority java_lang_Thread::priority(oop java_thread) {
1834   return (ThreadPriority)java_thread-&gt;int_field(_priority_offset);
1835 }
1836 
1837 
1838 void java_lang_Thread::set_priority(oop java_thread, ThreadPriority priority) {
1839   java_thread-&gt;int_field_put(_priority_offset, priority);
1840 }
1841 
1842 
1843 oop java_lang_Thread::threadGroup(oop java_thread) {
1844   return java_thread-&gt;obj_field(_group_offset);
1845 }
1846 
1847 
1848 bool java_lang_Thread::is_stillborn(oop java_thread) {
1849   return java_thread-&gt;bool_field(_stillborn_offset) != 0;
1850 }
1851 
1852 
1853 // We never have reason to turn the stillborn bit off
1854 void java_lang_Thread::set_stillborn(oop java_thread) {
1855   java_thread-&gt;bool_field_put(_stillborn_offset, true);
1856 }
1857 
1858 
1859 bool java_lang_Thread::is_alive(oop java_thread) {
1860   JavaThread* thr = java_lang_Thread::thread(java_thread);
1861   return (thr != NULL);
1862 }
1863 
1864 
1865 bool java_lang_Thread::is_daemon(oop java_thread) {
1866   return java_thread-&gt;bool_field(_daemon_offset) != 0;
1867 }
1868 
1869 
1870 void java_lang_Thread::set_daemon(oop java_thread) {
1871   java_thread-&gt;bool_field_put(_daemon_offset, true);
1872 }
1873 
1874 oop java_lang_Thread::context_class_loader(oop java_thread) {
1875   return java_thread-&gt;obj_field(_contextClassLoader_offset);
1876 }
1877 
1878 oop java_lang_Thread::inherited_access_control_context(oop java_thread) {
1879   return java_thread-&gt;obj_field(_inheritedAccessControlContext_offset);
1880 }
1881 
1882 
1883 jlong java_lang_Thread::stackSize(oop java_thread) {
1884   return java_thread-&gt;long_field(_stackSize_offset);
1885 }
1886 
1887 // Write the thread status value to threadStatus field in java.lang.Thread java class.
1888 void java_lang_Thread::set_thread_status(oop java_thread,
1889                                          java_lang_Thread::ThreadStatus status) {
1890   java_thread-&gt;int_field_put(_thread_status_offset, status);
1891 }
1892 
1893 // Read thread status value from threadStatus field in java.lang.Thread java class.
1894 java_lang_Thread::ThreadStatus java_lang_Thread::get_thread_status(oop java_thread) {
1895   // Make sure the caller is operating on behalf of the VM or is
1896   // running VM code (state == _thread_in_vm).
1897   assert(Threads_lock-&gt;owned_by_self() || Thread::current()-&gt;is_VM_thread() ||
1898          JavaThread::current()-&gt;thread_state() == _thread_in_vm,
1899          &quot;Java Thread is not running in vm&quot;);
1900   return (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1901 }
1902 
1903 
1904 jlong java_lang_Thread::thread_id(oop java_thread) {
1905   return java_thread-&gt;long_field(_tid_offset);
1906 }
1907 
1908 oop java_lang_Thread::park_blocker(oop java_thread) {
1909   return java_thread-&gt;obj_field(_park_blocker_offset);
1910 }
1911 
1912 const char* java_lang_Thread::thread_status_name(oop java_thread) {
1913   ThreadStatus status = (java_lang_Thread::ThreadStatus)java_thread-&gt;int_field(_thread_status_offset);
1914   switch (status) {
1915     case NEW                      : return &quot;NEW&quot;;
1916     case RUNNABLE                 : return &quot;RUNNABLE&quot;;
1917     case SLEEPING                 : return &quot;TIMED_WAITING (sleeping)&quot;;
1918     case IN_OBJECT_WAIT           : return &quot;WAITING (on object monitor)&quot;;
1919     case IN_OBJECT_WAIT_TIMED     : return &quot;TIMED_WAITING (on object monitor)&quot;;
1920     case PARKED                   : return &quot;WAITING (parking)&quot;;
1921     case PARKED_TIMED             : return &quot;TIMED_WAITING (parking)&quot;;
1922     case BLOCKED_ON_MONITOR_ENTER : return &quot;BLOCKED (on object monitor)&quot;;
1923     case TERMINATED               : return &quot;TERMINATED&quot;;
1924     default                       : return &quot;UNKNOWN&quot;;
1925   };
1926 }
1927 int java_lang_ThreadGroup::_parent_offset = 0;
1928 int java_lang_ThreadGroup::_name_offset = 0;
1929 int java_lang_ThreadGroup::_threads_offset = 0;
1930 int java_lang_ThreadGroup::_groups_offset = 0;
1931 int java_lang_ThreadGroup::_maxPriority_offset = 0;
1932 int java_lang_ThreadGroup::_destroyed_offset = 0;
1933 int java_lang_ThreadGroup::_daemon_offset = 0;
1934 int java_lang_ThreadGroup::_nthreads_offset = 0;
1935 int java_lang_ThreadGroup::_ngroups_offset = 0;
1936 
1937 oop  java_lang_ThreadGroup::parent(oop java_thread_group) {
1938   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1939   return java_thread_group-&gt;obj_field(_parent_offset);
1940 }
1941 
1942 // (&quot;name as oop&quot; accessor is not necessary)
1943 
1944 const char* java_lang_ThreadGroup::name(oop java_thread_group) {
1945   oop name = java_thread_group-&gt;obj_field(_name_offset);
1946   // ThreadGroup.name can be null
1947   if (name != NULL) {
1948     return java_lang_String::as_utf8_string(name);
1949   }
1950   return NULL;
1951 }
1952 
1953 int java_lang_ThreadGroup::nthreads(oop java_thread_group) {
1954   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1955   return java_thread_group-&gt;int_field(_nthreads_offset);
1956 }
1957 
1958 objArrayOop java_lang_ThreadGroup::threads(oop java_thread_group) {
1959   oop threads = java_thread_group-&gt;obj_field(_threads_offset);
1960   assert(threads != NULL, &quot;threadgroups should have threads&quot;);
1961   assert(threads-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1962   return objArrayOop(threads);
1963 }
1964 
1965 int java_lang_ThreadGroup::ngroups(oop java_thread_group) {
1966   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1967   return java_thread_group-&gt;int_field(_ngroups_offset);
1968 }
1969 
1970 objArrayOop java_lang_ThreadGroup::groups(oop java_thread_group) {
1971   oop groups = java_thread_group-&gt;obj_field(_groups_offset);
1972   assert(groups == NULL || groups-&gt;is_objArray(), &quot;just checking&quot;); // Todo: Add better type checking code
1973   return objArrayOop(groups);
1974 }
1975 
1976 ThreadPriority java_lang_ThreadGroup::maxPriority(oop java_thread_group) {
1977   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1978   return (ThreadPriority) java_thread_group-&gt;int_field(_maxPriority_offset);
1979 }
1980 
1981 bool java_lang_ThreadGroup::is_destroyed(oop java_thread_group) {
1982   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1983   return java_thread_group-&gt;bool_field(_destroyed_offset) != 0;
1984 }
1985 
1986 bool java_lang_ThreadGroup::is_daemon(oop java_thread_group) {
1987   assert(oopDesc::is_oop(java_thread_group), &quot;thread group must be oop&quot;);
1988   return java_thread_group-&gt;bool_field(_daemon_offset) != 0;
1989 }
1990 
1991 #define THREADGROUP_FIELDS_DO(macro) \
1992   macro(_parent_offset,      k, vmSymbols::parent_name(),      threadgroup_signature,       false); \
1993   macro(_name_offset,        k, vmSymbols::name_name(),        string_signature,            false); \
1994   macro(_threads_offset,     k, vmSymbols::threads_name(),     thread_array_signature,      false); \
1995   macro(_groups_offset,      k, vmSymbols::groups_name(),      threadgroup_array_signature, false); \
1996   macro(_maxPriority_offset, k, vmSymbols::maxPriority_name(), int_signature,               false); \
1997   macro(_destroyed_offset,   k, vmSymbols::destroyed_name(),   bool_signature,              false); \
1998   macro(_daemon_offset,      k, vmSymbols::daemon_name(),      bool_signature,              false); \
1999   macro(_nthreads_offset,    k, vmSymbols::nthreads_name(),    int_signature,               false); \
2000   macro(_ngroups_offset,     k, vmSymbols::ngroups_name(),     int_signature,               false)
2001 
2002 void java_lang_ThreadGroup::compute_offsets() {
2003   assert(_parent_offset == 0, &quot;offsets should be initialized only once&quot;);
2004 
2005   InstanceKlass* k = SystemDictionary::ThreadGroup_klass();
2006   THREADGROUP_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2007 }
2008 
2009 #if INCLUDE_CDS
2010 void java_lang_ThreadGroup::serialize_offsets(SerializeClosure* f) {
2011   THREADGROUP_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2012 }
2013 #endif
2014 
2015 #define THROWABLE_FIELDS_DO(macro) \
2016   macro(backtrace_offset,     k, &quot;backtrace&quot;,     object_signature,                  false); \
2017   macro(detailMessage_offset, k, &quot;detailMessage&quot;, string_signature,                  false); \
2018   macro(stackTrace_offset,    k, &quot;stackTrace&quot;,    java_lang_StackTraceElement_array, false); \
2019   macro(depth_offset,         k, &quot;depth&quot;,         int_signature,                     false); \
2020   macro(static_unassigned_stacktrace_offset, k, &quot;UNASSIGNED_STACK&quot;, java_lang_StackTraceElement_array, true)
2021 
2022 void java_lang_Throwable::compute_offsets() {
2023   InstanceKlass* k = SystemDictionary::Throwable_klass();
2024   THROWABLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2025 }
2026 
2027 #if INCLUDE_CDS
2028 void java_lang_Throwable::serialize_offsets(SerializeClosure* f) {
2029   THROWABLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2030 }
2031 #endif
2032 
2033 oop java_lang_Throwable::unassigned_stacktrace() {
2034   InstanceKlass* ik = SystemDictionary::Throwable_klass();
2035   oop base = ik-&gt;static_field_base_raw();
2036   return base-&gt;obj_field(static_unassigned_stacktrace_offset);
2037 }
2038 
2039 oop java_lang_Throwable::backtrace(oop throwable) {
2040   return throwable-&gt;obj_field_acquire(backtrace_offset);
2041 }
2042 
2043 
2044 void java_lang_Throwable::set_backtrace(oop throwable, oop value) {
2045   throwable-&gt;release_obj_field_put(backtrace_offset, value);
2046 }
2047 
2048 int java_lang_Throwable::depth(oop throwable) {
2049   return throwable-&gt;int_field(depth_offset);
2050 }
2051 
2052 void java_lang_Throwable::set_depth(oop throwable, int value) {
2053   throwable-&gt;int_field_put(depth_offset, value);
2054 }
2055 
2056 oop java_lang_Throwable::message(oop throwable) {
2057   return throwable-&gt;obj_field(detailMessage_offset);
2058 }
2059 
2060 
2061 // Return Symbol for detailed_message or NULL
2062 Symbol* java_lang_Throwable::detail_message(oop throwable) {
2063   PRESERVE_EXCEPTION_MARK;  // Keep original exception
2064   oop detailed_message = java_lang_Throwable::message(throwable);
2065   if (detailed_message != NULL) {
2066     return java_lang_String::as_symbol(detailed_message);
2067   }
2068   return NULL;
2069 }
2070 
2071 void java_lang_Throwable::set_message(oop throwable, oop value) {
2072   throwable-&gt;obj_field_put(detailMessage_offset, value);
2073 }
2074 
2075 
2076 void java_lang_Throwable::set_stacktrace(oop throwable, oop st_element_array) {
2077   throwable-&gt;obj_field_put(stackTrace_offset, st_element_array);
2078 }
2079 
2080 void java_lang_Throwable::clear_stacktrace(oop throwable) {
2081   set_stacktrace(throwable, NULL);
2082 }
2083 
2084 
2085 void java_lang_Throwable::print(oop throwable, outputStream* st) {
2086   ResourceMark rm;
2087   Klass* k = throwable-&gt;klass();
2088   assert(k != NULL, &quot;just checking&quot;);
2089   st-&gt;print(&quot;%s&quot;, k-&gt;external_name());
2090   oop msg = message(throwable);
2091   if (msg != NULL) {
2092     st-&gt;print(&quot;: %s&quot;, java_lang_String::as_utf8_string(msg));
2093   }
2094 }
2095 
2096 // After this many redefines, the stack trace is unreliable.
2097 const int MAX_VERSION = USHRT_MAX;
2098 
2099 static inline bool version_matches(Method* method, int version) {
2100   assert(version &lt; MAX_VERSION, &quot;version is too big&quot;);
2101   return method != NULL &amp;&amp; (method-&gt;constants()-&gt;version() == version);
2102 }
2103 
2104 // This class provides a simple wrapper over the internal structure of
2105 // exception backtrace to insulate users of the backtrace from needing
2106 // to know what it looks like.
2107 // The code of this class is not GC safe. Allocations can only happen
2108 // in expand().
2109 class BacktraceBuilder: public StackObj {
2110  friend class BacktraceIterator;
2111  private:
2112   Handle          _backtrace;
2113   objArrayOop     _head;
2114   typeArrayOop    _methods;
2115   typeArrayOop    _bcis;
2116   objArrayOop     _mirrors;
2117   typeArrayOop    _names; // Needed to insulate method name against redefinition.
2118   // True if the top frame of the backtrace is omitted because it shall be hidden.
2119   bool            _has_hidden_top_frame;
2120   int             _index;
2121   NoSafepointVerifier _nsv;
2122 
2123   enum {
2124     trace_methods_offset = java_lang_Throwable::trace_methods_offset,
2125     trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,
2126     trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,
2127     trace_names_offset   = java_lang_Throwable::trace_names_offset,
2128     trace_next_offset    = java_lang_Throwable::trace_next_offset,
2129     trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,
2130     trace_size           = java_lang_Throwable::trace_size,
2131     trace_chunk_size     = java_lang_Throwable::trace_chunk_size
2132   };
2133 
2134   // get info out of chunks
2135   static typeArrayOop get_methods(objArrayHandle chunk) {
2136     typeArrayOop methods = typeArrayOop(chunk-&gt;obj_at(trace_methods_offset));
2137     assert(methods != NULL, &quot;method array should be initialized in backtrace&quot;);
2138     return methods;
2139   }
2140   static typeArrayOop get_bcis(objArrayHandle chunk) {
2141     typeArrayOop bcis = typeArrayOop(chunk-&gt;obj_at(trace_bcis_offset));
2142     assert(bcis != NULL, &quot;bci array should be initialized in backtrace&quot;);
2143     return bcis;
2144   }
2145   static objArrayOop get_mirrors(objArrayHandle chunk) {
2146     objArrayOop mirrors = objArrayOop(chunk-&gt;obj_at(trace_mirrors_offset));
2147     assert(mirrors != NULL, &quot;mirror array should be initialized in backtrace&quot;);
2148     return mirrors;
2149   }
2150   static typeArrayOop get_names(objArrayHandle chunk) {
2151     typeArrayOop names = typeArrayOop(chunk-&gt;obj_at(trace_names_offset));
2152     assert(names != NULL, &quot;names array should be initialized in backtrace&quot;);
2153     return names;
2154   }
2155   static bool has_hidden_top_frame(objArrayHandle chunk) {
2156     oop hidden = chunk-&gt;obj_at(trace_hidden_offset);
2157     return hidden != NULL;
2158   }
2159 
2160  public:
2161 
2162   // constructor for new backtrace
2163   BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {
2164     expand(CHECK);
2165     _backtrace = Handle(THREAD, _head);
2166     _index = 0;
2167   }
2168 
2169   BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {
2170     _methods = get_methods(backtrace);
2171     _bcis = get_bcis(backtrace);
2172     _mirrors = get_mirrors(backtrace);
2173     _names = get_names(backtrace);
2174     _has_hidden_top_frame = has_hidden_top_frame(backtrace);
2175     assert(_methods-&gt;length() == _bcis-&gt;length() &amp;&amp;
2176            _methods-&gt;length() == _mirrors-&gt;length() &amp;&amp;
2177            _mirrors-&gt;length() == _names-&gt;length(),
2178            &quot;method and source information arrays should match&quot;);
2179 
2180     // head is the preallocated backtrace
2181     _head = backtrace();
2182     _backtrace = Handle(thread, _head);
2183     _index = 0;
2184   }
2185 
2186   void expand(TRAPS) {
2187     objArrayHandle old_head(THREAD, _head);
2188     PauseNoSafepointVerifier pnsv(&amp;_nsv);
2189 
2190     objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);
2191     objArrayHandle new_head(THREAD, head);
2192 
2193     typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);
2194     typeArrayHandle new_methods(THREAD, methods);
2195 
2196     typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);
2197     typeArrayHandle new_bcis(THREAD, bcis);
2198 
2199     objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);
2200     objArrayHandle new_mirrors(THREAD, mirrors);
2201 
2202     typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);
2203     typeArrayHandle new_names(THREAD, names);
2204 
2205     if (!old_head.is_null()) {
2206       old_head-&gt;obj_at_put(trace_next_offset, new_head());
2207     }
2208     new_head-&gt;obj_at_put(trace_methods_offset, new_methods());
2209     new_head-&gt;obj_at_put(trace_bcis_offset, new_bcis());
2210     new_head-&gt;obj_at_put(trace_mirrors_offset, new_mirrors());
2211     new_head-&gt;obj_at_put(trace_names_offset, new_names());
2212     new_head-&gt;obj_at_put(trace_hidden_offset, NULL);
2213 
2214     _head    = new_head();
2215     _methods = new_methods();
2216     _bcis = new_bcis();
2217     _mirrors = new_mirrors();
2218     _names  = new_names();
2219     _index = 0;
2220   }
2221 
2222   oop backtrace() {
2223     return _backtrace();
2224   }
2225 
2226   inline void push(Method* method, int bci, TRAPS) {
2227     // Smear the -1 bci to 0 since the array only holds unsigned
2228     // shorts.  The later line number lookup would just smear the -1
2229     // to a 0 even if it could be recorded.
2230     if (bci == SynchronizationEntryBCI) bci = 0;
2231 
2232     if (_index &gt;= trace_chunk_size) {
2233       methodHandle mhandle(THREAD, method);
2234       expand(CHECK);
2235       method = mhandle();
2236     }
2237 
2238     _methods-&gt;ushort_at_put(_index, method-&gt;orig_method_idnum());
2239     _bcis-&gt;int_at_put(_index, Backtrace::merge_bci_and_version(bci, method-&gt;constants()-&gt;version()));
2240 
2241     // Note:this doesn&#39;t leak symbols because the mirror in the backtrace keeps the
2242     // klass owning the symbols alive so their refcounts aren&#39;t decremented.
2243     Symbol* name = method-&gt;name();
2244     _names-&gt;symbol_at_put(_index, name);
2245 
2246     // We need to save the mirrors in the backtrace to keep the class
2247     // from being unloaded while we still have this stack trace.
2248     assert(method-&gt;method_holder()-&gt;java_mirror() != NULL, &quot;never push null for mirror&quot;);
2249     _mirrors-&gt;obj_at_put(_index, method-&gt;method_holder()-&gt;java_mirror());
2250     _index++;
2251   }
2252 
2253   void set_has_hidden_top_frame(TRAPS) {
2254     if (!_has_hidden_top_frame) {
2255       // It would be nice to add java/lang/Boolean::TRUE here
2256       // to indicate that this backtrace has a hidden top frame.
2257       // But this code is used before TRUE is allocated.
2258       // Therefore let&#39;s just use an arbitrary legal oop
2259       // available right here. _methods is a short[].
2260       assert(_methods != NULL, &quot;we need a legal oop&quot;);
2261       _has_hidden_top_frame = true;
2262       _head-&gt;obj_at_put(trace_hidden_offset, _methods);
2263     }
2264   }
2265 };
2266 
2267 struct BacktraceElement : public StackObj {
2268   int _method_id;
2269   int _bci;
2270   int _version;
2271   Symbol* _name;
2272   Handle _mirror;
2273   BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :
2274                    _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}
2275 };
2276 
2277 class BacktraceIterator : public StackObj {
2278   int _index;
2279   objArrayHandle  _result;
2280   objArrayHandle  _mirrors;
2281   typeArrayHandle _methods;
2282   typeArrayHandle _bcis;
2283   typeArrayHandle _names;
2284 
2285   void init(objArrayHandle result, Thread* thread) {
2286     // Get method id, bci, version and mirror from chunk
2287     _result = result;
2288     if (_result.not_null()) {
2289       _methods = typeArrayHandle(thread, BacktraceBuilder::get_methods(_result));
2290       _bcis = typeArrayHandle(thread, BacktraceBuilder::get_bcis(_result));
2291       _mirrors = objArrayHandle(thread, BacktraceBuilder::get_mirrors(_result));
2292       _names = typeArrayHandle(thread, BacktraceBuilder::get_names(_result));
2293       _index = 0;
2294     }
2295   }
2296  public:
2297   BacktraceIterator(objArrayHandle result, Thread* thread) {
2298     init(result, thread);
2299     assert(_methods.is_null() || _methods-&gt;length() == java_lang_Throwable::trace_chunk_size, &quot;lengths don&#39;t match&quot;);
2300   }
2301 
2302   BacktraceElement next(Thread* thread) {
2303     BacktraceElement e (Handle(thread, _mirrors-&gt;obj_at(_index)),
2304                         _methods-&gt;ushort_at(_index),
2305                         Backtrace::version_at(_bcis-&gt;int_at(_index)),
2306                         Backtrace::bci_at(_bcis-&gt;int_at(_index)),
2307                         _names-&gt;symbol_at(_index));
2308     _index++;
2309 
2310     if (_index &gt;= java_lang_Throwable::trace_chunk_size) {
2311       int next_offset = java_lang_Throwable::trace_next_offset;
2312       // Get next chunk
2313       objArrayHandle result (thread, objArrayOop(_result-&gt;obj_at(next_offset)));
2314       init(result, thread);
2315     }
2316     return e;
2317   }
2318 
2319   bool repeat() {
2320     return _result.not_null() &amp;&amp; _mirrors-&gt;obj_at(_index) != NULL;
2321   }
2322 };
2323 
2324 
2325 // Print stack trace element to resource allocated buffer
2326 static void print_stack_element_to_stream(outputStream* st, Handle mirror, int method_id,
2327                                           int version, int bci, Symbol* name) {
2328   ResourceMark rm;
2329 
2330   // Get strings and string lengths
2331   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(mirror()));
2332   const char* klass_name  = holder-&gt;external_name();
2333   int buf_len = (int)strlen(klass_name);
2334 
2335   char* method_name = name-&gt;as_C_string();
2336   buf_len += (int)strlen(method_name);
2337 
2338   char* source_file_name = NULL;
2339   Symbol* source = Backtrace::get_source_file_name(holder, version);
2340   if (source != NULL) {
2341     source_file_name = source-&gt;as_C_string();
2342     buf_len += (int)strlen(source_file_name);
2343   }
2344 
2345   char *module_name = NULL, *module_version = NULL;
2346   ModuleEntry* module = holder-&gt;module();
2347   if (module-&gt;is_named()) {
2348     module_name = module-&gt;name()-&gt;as_C_string();
2349     buf_len += (int)strlen(module_name);
2350     if (module-&gt;version() != NULL) {
2351       module_version = module-&gt;version()-&gt;as_C_string();
2352       buf_len += (int)strlen(module_version);
2353     }
2354   }
2355 
2356   // Allocate temporary buffer with extra space for formatting and line number
2357   char* buf = NEW_RESOURCE_ARRAY(char, buf_len + 64);
2358 
2359   // Print stack trace line in buffer
2360   sprintf(buf, &quot;\tat %s.%s(&quot;, klass_name, method_name);
2361 
2362   // Print module information
2363   if (module_name != NULL) {
2364     if (module_version != NULL) {
2365       sprintf(buf + (int)strlen(buf), &quot;%s@%s/&quot;, module_name, module_version);
2366     } else {
2367       sprintf(buf + (int)strlen(buf), &quot;%s/&quot;, module_name);
2368     }
2369   }
2370 
2371   // The method can be NULL if the requested class version is gone
2372   Method* method = holder-&gt;method_with_orig_idnum(method_id, version);
2373   if (!version_matches(method, version)) {
2374     strcat(buf, &quot;Redefined)&quot;);
2375   } else {
2376     int line_number = Backtrace::get_line_number(method, bci);
2377     if (line_number == -2) {
2378       strcat(buf, &quot;Native Method)&quot;);
2379     } else {
2380       if (source_file_name != NULL &amp;&amp; (line_number != -1)) {
2381         // Sourcename and linenumber
2382         sprintf(buf + (int)strlen(buf), &quot;%s:%d)&quot;, source_file_name, line_number);
2383       } else if (source_file_name != NULL) {
2384         // Just sourcename
2385         sprintf(buf + (int)strlen(buf), &quot;%s)&quot;, source_file_name);
2386       } else {
2387         // Neither sourcename nor linenumber
2388         sprintf(buf + (int)strlen(buf), &quot;Unknown Source)&quot;);
2389       }
2390       CompiledMethod* nm = method-&gt;code();
2391       if (WizardMode &amp;&amp; nm != NULL) {
2392         sprintf(buf + (int)strlen(buf), &quot;(nmethod &quot; INTPTR_FORMAT &quot;)&quot;, (intptr_t)nm);
2393       }
2394     }
2395   }
2396 
2397   st-&gt;print_cr(&quot;%s&quot;, buf);
2398 }
2399 
2400 void java_lang_Throwable::print_stack_element(outputStream *st, Method* method, int bci) {
2401   Handle mirror (Thread::current(),  method-&gt;method_holder()-&gt;java_mirror());
2402   int method_id = method-&gt;orig_method_idnum();
2403   int version = method-&gt;constants()-&gt;version();
2404   print_stack_element_to_stream(st, mirror, method_id, version, bci, method-&gt;name());
2405 }
2406 
2407 /**
2408  * Print the throwable message and its stack trace plus all causes by walking the
2409  * cause chain.  The output looks the same as of Throwable.printStackTrace().
2410  */
2411 void java_lang_Throwable::print_stack_trace(Handle throwable, outputStream* st) {
2412   // First, print the message.
2413   print(throwable(), st);
2414   st-&gt;cr();
2415 
2416   // Now print the stack trace.
2417   Thread* THREAD = Thread::current();
2418   while (throwable.not_null()) {
2419     objArrayHandle result (THREAD, objArrayOop(backtrace(throwable())));
2420     if (result.is_null()) {
2421       st-&gt;print_raw_cr(&quot;\t&lt;&lt;no stack trace available&gt;&gt;&quot;);
2422       return;
2423     }
2424     BacktraceIterator iter(result, THREAD);
2425 
2426     while (iter.repeat()) {
2427       BacktraceElement bte = iter.next(THREAD);
2428       print_stack_element_to_stream(st, bte._mirror, bte._method_id, bte._version, bte._bci, bte._name);
2429     }
2430     {
2431       // Call getCause() which doesn&#39;t necessarily return the _cause field.
2432       EXCEPTION_MARK;
2433       JavaValue cause(T_OBJECT);
2434       JavaCalls::call_virtual(&amp;cause,
2435                               throwable,
2436                               throwable-&gt;klass(),
2437                               vmSymbols::getCause_name(),
2438                               vmSymbols::void_throwable_signature(),
2439                               THREAD);
2440       // Ignore any exceptions. we are in the middle of exception handling. Same as classic VM.
2441       if (HAS_PENDING_EXCEPTION) {
2442         CLEAR_PENDING_EXCEPTION;
2443         throwable = Handle();
2444       } else {
2445         throwable = Handle(THREAD, (oop) cause.get_jobject());
2446         if (throwable.not_null()) {
2447           st-&gt;print(&quot;Caused by: &quot;);
2448           print(throwable(), st);
2449           st-&gt;cr();
2450         }
2451       }
2452     }
2453   }
2454 }
2455 
2456 /**
2457  * Print the throwable stack trace by calling the Java method java.lang.Throwable.printStackTrace().
2458  */
2459 void java_lang_Throwable::java_printStackTrace(Handle throwable, TRAPS) {
2460   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;Throwable instance expected&quot;);
2461   JavaValue result(T_VOID);
2462   JavaCalls::call_virtual(&amp;result,
2463                           throwable,
2464                           SystemDictionary::Throwable_klass(),
2465                           vmSymbols::printStackTrace_name(),
2466                           vmSymbols::void_method_signature(),
2467                           THREAD);
2468 }
2469 
2470 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method, TRAPS) {
2471   if (!StackTraceInThrowable) return;
2472   ResourceMark rm(THREAD);
2473 
2474   // Start out by clearing the backtrace for this object, in case the VM
2475   // runs out of memory while allocating the stack trace
2476   set_backtrace(throwable(), NULL);
2477   // Clear lazily constructed Java level stacktrace if refilling occurs
2478   // This is unnecessary in 1.7+ but harmless
2479   clear_stacktrace(throwable());
2480 
2481   int max_depth = MaxJavaStackTraceDepth;
2482   JavaThread* thread = (JavaThread*)THREAD;
2483 
2484   BacktraceBuilder bt(CHECK);
2485 
2486   // If there is no Java frame just return the method that was being called
2487   // with bci 0
2488   if (!thread-&gt;has_last_Java_frame()) {
2489     if (max_depth &gt;= 1 &amp;&amp; method() != NULL) {
2490       bt.push(method(), 0, CHECK);
2491       log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), 1);
2492       set_depth(throwable(), 1);
2493       set_backtrace(throwable(), bt.backtrace());
2494     }
2495     return;
2496   }
2497 
2498   // Instead of using vframe directly, this version of fill_in_stack_trace
2499   // basically handles everything by hand. This significantly improved the
2500   // speed of this method call up to 28.5% on Solaris sparc. 27.1% on Windows.
2501   // See bug 6333838 for  more details.
2502   // The &quot;ASSERT&quot; here is to verify this method generates the exactly same stack
2503   // trace as utilizing vframe.
2504 #ifdef ASSERT
2505   vframeStream st(thread);
2506 #endif
2507   int total_count = 0;
2508   RegisterMap map(thread, false);
2509   int decode_offset = 0;
2510   CompiledMethod* nm = NULL;
2511   bool skip_fillInStackTrace_check = false;
2512   bool skip_throwableInit_check = false;
2513   bool skip_hidden = !ShowHiddenFrames;
2514 
2515   for (frame fr = thread-&gt;last_frame(); max_depth == 0 || max_depth != total_count;) {
2516     Method* method = NULL;
2517     int bci = 0;
2518 
2519     // Compiled java method case.
2520     if (decode_offset != 0) {
2521       DebugInfoReadStream stream(nm, decode_offset);
2522       decode_offset = stream.read_int();
2523       method = (Method*)nm-&gt;metadata_at(stream.read_int());
2524       bci = stream.read_bci();
2525     } else {
2526       if (fr.is_first_frame()) break;
2527       address pc = fr.pc();
2528       if (fr.is_interpreted_frame()) {
2529         address bcp = fr.interpreter_frame_bcp();
2530         method = fr.interpreter_frame_method();
2531         bci =  method-&gt;bci_from(bcp);
2532         fr = fr.sender(&amp;map);
2533       } else {
2534         CodeBlob* cb = fr.cb();
2535         // HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL
2536         // but non nmethod
2537         fr = fr.sender(&amp;map);
2538         if (cb == NULL || !cb-&gt;is_compiled()) {
2539           continue;
2540         }
2541         nm = cb-&gt;as_compiled_method();
2542         if (nm-&gt;method()-&gt;is_native()) {
2543           method = nm-&gt;method();
2544           bci = 0;
2545         } else {
2546           PcDesc* pd = nm-&gt;pc_desc_at(pc);
2547           decode_offset = pd-&gt;scope_decode_offset();
2548           // if decode_offset is not equal to 0, it will execute the
2549           // &quot;compiled java method case&quot; at the beginning of the loop.
2550           continue;
2551         }
2552       }
2553     }
2554 #ifdef ASSERT
2555     assert(st.method() == method &amp;&amp; st.bci() == bci,
2556            &quot;Wrong stack trace&quot;);
2557     st.next();
2558 #endif
2559 
2560     // the format of the stacktrace will be:
2561     // - 1 or more fillInStackTrace frames for the exception class (skipped)
2562     // - 0 or more &lt;init&gt; methods for the exception class (skipped)
2563     // - rest of the stack
2564 
2565     if (!skip_fillInStackTrace_check) {
2566       if (method-&gt;name() == vmSymbols::fillInStackTrace_name() &amp;&amp;
2567           throwable-&gt;is_a(method-&gt;method_holder())) {
2568         continue;
2569       }
2570       else {
2571         skip_fillInStackTrace_check = true; // gone past them all
2572       }
2573     }
2574     if (!skip_throwableInit_check) {
2575       assert(skip_fillInStackTrace_check, &quot;logic error in backtrace filtering&quot;);
2576 
2577       // skip &lt;init&gt; methods of the exception class and superclasses
<a name="12" id="anc12"></a><span class="line-modified">2578       // This is similar to classic VM (before HotSpot).</span>
<span class="line-modified">2579       if (method-&gt;is_object_constructor() &amp;&amp;</span>
2580           throwable-&gt;is_a(method-&gt;method_holder())) {
2581         continue;
2582       } else {
2583         // there are none or we&#39;ve seen them all - either way stop checking
2584         skip_throwableInit_check = true;
2585       }
2586     }
2587     if (method-&gt;is_hidden()) {
2588       if (skip_hidden) {
2589         if (total_count == 0) {
2590           // The top frame will be hidden from the stack trace.
2591           bt.set_has_hidden_top_frame(CHECK);
2592         }
2593         continue;
2594       }
2595     }
2596     bt.push(method, bci, CHECK);
2597     total_count++;
2598   }
2599 
2600   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), total_count);
2601 
2602   // Put completed stack trace into throwable object
2603   set_backtrace(throwable(), bt.backtrace());
2604   set_depth(throwable(), total_count);
2605 }
2606 
2607 void java_lang_Throwable::fill_in_stack_trace(Handle throwable, const methodHandle&amp; method) {
2608   // No-op if stack trace is disabled
2609   if (!StackTraceInThrowable) {
2610     return;
2611   }
2612 
2613   // Disable stack traces for some preallocated out of memory errors
2614   if (!Universe::should_fill_in_stack_trace(throwable)) {
2615     return;
2616   }
2617 
2618   PRESERVE_EXCEPTION_MARK;
2619 
2620   JavaThread* thread = JavaThread::active();
2621   fill_in_stack_trace(throwable, method, thread);
2622   // ignore exceptions thrown during stack trace filling
2623   CLEAR_PENDING_EXCEPTION;
2624 }
2625 
2626 void java_lang_Throwable::allocate_backtrace(Handle throwable, TRAPS) {
2627   // Allocate stack trace - backtrace is created but not filled in
2628 
2629   // No-op if stack trace is disabled
2630   if (!StackTraceInThrowable) return;
2631   BacktraceBuilder bt(CHECK);   // creates a backtrace
2632   set_backtrace(throwable(), bt.backtrace());
2633 }
2634 
2635 
2636 void java_lang_Throwable::fill_in_stack_trace_of_preallocated_backtrace(Handle throwable) {
2637   // Fill in stack trace into preallocated backtrace (no GC)
2638 
2639   // No-op if stack trace is disabled
2640   if (!StackTraceInThrowable) return;
2641 
2642   assert(throwable-&gt;is_a(SystemDictionary::Throwable_klass()), &quot;sanity check&quot;);
2643 
2644   JavaThread* THREAD = JavaThread::current();
2645 
2646   objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));
2647   assert(backtrace.not_null(), &quot;backtrace should have been preallocated&quot;);
2648 
2649   ResourceMark rm(THREAD);
2650   vframeStream st(THREAD);
2651 
2652   BacktraceBuilder bt(THREAD, backtrace);
2653 
2654   // Unlike fill_in_stack_trace we do not skip fillInStackTrace or throwable init
2655   // methods as preallocated errors aren&#39;t created by &quot;java&quot; code.
2656 
2657   // fill in as much stack trace as possible
2658   int chunk_count = 0;
2659   for (;!st.at_end(); st.next()) {
2660     bt.push(st.method(), st.bci(), CHECK);
2661     chunk_count++;
2662 
2663     // Bail-out for deep stacks
2664     if (chunk_count &gt;= trace_chunk_size) break;
2665   }
2666   set_depth(throwable(), chunk_count);
2667   log_info(stacktrace)(&quot;%s, %d&quot;, throwable-&gt;klass()-&gt;external_name(), chunk_count);
2668 
2669   // We support the Throwable immutability protocol defined for Java 7.
2670   java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());
2671   assert(java_lang_Throwable::unassigned_stacktrace() != NULL, &quot;not initialized&quot;);
2672 }
2673 
2674 void java_lang_Throwable::get_stack_trace_elements(Handle throwable,
2675                                                    objArrayHandle stack_trace_array_h, TRAPS) {
2676 
2677   if (throwable.is_null() || stack_trace_array_h.is_null()) {
2678     THROW(vmSymbols::java_lang_NullPointerException());
2679   }
2680 
2681   assert(stack_trace_array_h-&gt;is_objArray(), &quot;Stack trace array should be an array of StackTraceElenent&quot;);
2682 
2683   if (stack_trace_array_h-&gt;length() != depth(throwable())) {
2684     THROW(vmSymbols::java_lang_IndexOutOfBoundsException());
2685   }
2686 
2687   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable())));
2688   BacktraceIterator iter(result, THREAD);
2689 
2690   int index = 0;
2691   while (iter.repeat()) {
2692     BacktraceElement bte = iter.next(THREAD);
2693 
2694     Handle stack_trace_element(THREAD, stack_trace_array_h-&gt;obj_at(index++));
2695 
2696     if (stack_trace_element.is_null()) {
2697       THROW(vmSymbols::java_lang_NullPointerException());
2698     }
2699 
2700     InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2701     methodHandle method (THREAD, holder-&gt;method_with_orig_idnum(bte._method_id, bte._version));
2702 
2703     java_lang_StackTraceElement::fill_in(stack_trace_element, holder,
2704                                          method,
2705                                          bte._version,
2706                                          bte._bci,
2707                                          bte._name, CHECK);
2708   }
2709 }
2710 
2711 bool java_lang_Throwable::get_top_method_and_bci(oop throwable, Method** method, int* bci) {
2712   Thread* THREAD = Thread::current();
2713   objArrayHandle result(THREAD, objArrayOop(backtrace(throwable)));
2714   BacktraceIterator iter(result, THREAD);
2715   // No backtrace available.
2716   if (!iter.repeat()) return false;
2717 
2718   // If the exception happened in a frame that has been hidden, i.e.,
2719   // omitted from the back trace, we can not compute the message.
2720   oop hidden = ((objArrayOop)backtrace(throwable))-&gt;obj_at(trace_hidden_offset);
2721   if (hidden != NULL) {
2722     return false;
2723   }
2724 
2725   // Get first backtrace element.
2726   BacktraceElement bte = iter.next(THREAD);
2727 
2728   InstanceKlass* holder = InstanceKlass::cast(java_lang_Class::as_Klass(bte._mirror()));
2729   assert(holder != NULL, &quot;first element should be non-null&quot;);
2730   Method* m = holder-&gt;method_with_orig_idnum(bte._method_id, bte._version);
2731 
2732   // Original version is no longer available.
2733   if (m == NULL || !version_matches(m, bte._version)) {
2734     return false;
2735   }
2736 
2737   *method = m;
2738   *bci = bte._bci;
2739   return true;
2740 }
2741 
2742 oop java_lang_StackTraceElement::create(const methodHandle&amp; method, int bci, TRAPS) {
2743   // Allocate java.lang.StackTraceElement instance
2744   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
2745   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
2746   if (k-&gt;should_be_initialized()) {
2747     k-&gt;initialize(CHECK_NULL);
2748   }
2749 
2750   Handle element = k-&gt;allocate_instance_handle(CHECK_NULL);
2751 
2752   int version = method-&gt;constants()-&gt;version();
2753   fill_in(element, method-&gt;method_holder(), method, version, bci, method-&gt;name(), CHECK_NULL);
2754   return element();
2755 }
2756 
2757 void java_lang_StackTraceElement::fill_in(Handle element,
2758                                           InstanceKlass* holder, const methodHandle&amp; method,
2759                                           int version, int bci, Symbol* name, TRAPS) {
2760   assert(element-&gt;is_a(SystemDictionary::StackTraceElement_klass()), &quot;sanity check&quot;);
2761 
2762   ResourceMark rm(THREAD);
2763   HandleMark hm(THREAD);
2764 
2765   // Fill in class name
2766   Handle java_class(THREAD, holder-&gt;java_mirror());
2767   oop classname = java_lang_Class::name(java_class, CHECK);
2768   java_lang_StackTraceElement::set_declaringClass(element(), classname);
2769   java_lang_StackTraceElement::set_declaringClassObject(element(), java_class());
2770 
2771   oop loader = holder-&gt;class_loader();
2772   if (loader != NULL) {
2773     oop loader_name = java_lang_ClassLoader::name(loader);
2774     if (loader_name != NULL)
2775       java_lang_StackTraceElement::set_classLoaderName(element(), loader_name);
2776   }
2777 
2778   // Fill in method name
2779   oop methodname = StringTable::intern(name, CHECK);
2780   java_lang_StackTraceElement::set_methodName(element(), methodname);
2781 
2782   // Fill in module name and version
2783   ModuleEntry* module = holder-&gt;module();
2784   if (module-&gt;is_named()) {
2785     oop module_name = StringTable::intern(module-&gt;name(), CHECK);
2786     java_lang_StackTraceElement::set_moduleName(element(), module_name);
2787     oop module_version;
2788     if (module-&gt;version() != NULL) {
2789       module_version = StringTable::intern(module-&gt;version(), CHECK);
2790     } else {
2791       module_version = NULL;
2792     }
2793     java_lang_StackTraceElement::set_moduleVersion(element(), module_version);
2794   }
2795 
2796   if (method() == NULL || !version_matches(method(), version)) {
2797     // The method was redefined, accurate line number information isn&#39;t available
2798     java_lang_StackTraceElement::set_fileName(element(), NULL);
2799     java_lang_StackTraceElement::set_lineNumber(element(), -1);
2800   } else {
2801     Symbol* source;
2802     oop source_file;
2803     int line_number;
2804     decode_file_and_line(java_class, holder, version, method, bci, source, source_file, line_number, CHECK);
2805 
2806     java_lang_StackTraceElement::set_fileName(element(), source_file);
2807     java_lang_StackTraceElement::set_lineNumber(element(), line_number);
2808   }
2809 }
2810 
2811 void java_lang_StackTraceElement::decode_file_and_line(Handle java_class,
2812                                                        InstanceKlass* holder,
2813                                                        int version,
2814                                                        const methodHandle&amp; method,
2815                                                        int bci,
2816                                                        Symbol*&amp; source,
2817                                                        oop&amp; source_file,
2818                                                        int&amp; line_number, TRAPS) {
2819   // Fill in source file name and line number.
2820   source = Backtrace::get_source_file_name(holder, version);
2821   source_file = java_lang_Class::source_file(java_class());
2822   if (source != NULL) {
2823     // Class was not redefined. We can trust its cache if set,
2824     // else we have to initialize it.
2825     if (source_file == NULL) {
2826       source_file = StringTable::intern(source, CHECK);
2827       java_lang_Class::set_source_file(java_class(), source_file);
2828     }
2829   } else {
2830     // Class was redefined. Dump the cache if it was set.
2831     if (source_file != NULL) {
2832       source_file = NULL;
2833       java_lang_Class::set_source_file(java_class(), source_file);
2834     }
2835   }
2836   line_number = Backtrace::get_line_number(method(), bci);
2837 }
2838 
2839 #if INCLUDE_JVMCI
2840 void java_lang_StackTraceElement::decode(const methodHandle&amp; method, int bci,
2841                                          Symbol*&amp; filename, int&amp; line_number, TRAPS) {
2842   ResourceMark rm(THREAD);
2843   HandleMark hm(THREAD);
2844 
2845   filename = NULL;
2846   line_number = -1;
2847 
2848   oop source_file;
2849   int version = method-&gt;constants()-&gt;version();
2850   InstanceKlass* holder = method-&gt;method_holder();
2851   Handle java_class(THREAD, holder-&gt;java_mirror());
2852   decode_file_and_line(java_class, holder, version, method, bci, filename, source_file, line_number, CHECK);
2853 }
2854 #endif // INCLUDE_JVMCI
2855 
2856 Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {
2857   HandleMark hm(THREAD);
2858   Handle mname(THREAD, stackFrame-&gt;obj_field(_memberName_offset));
2859   Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());
2860   // we should expand MemberName::name when Throwable uses StackTrace
2861   // MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);
2862   return method;
2863 }
2864 
2865 void java_lang_StackFrameInfo::set_method_and_bci(Handle stackFrame, const methodHandle&amp; method, int bci, TRAPS) {
2866   // set Method* or mid/cpref
2867   HandleMark hm(THREAD);
2868   Handle mname(Thread::current(), stackFrame-&gt;obj_field(_memberName_offset));
2869   InstanceKlass* ik = method-&gt;method_holder();
2870   CallInfo info(method(), ik, CHECK);
2871   MethodHandles::init_method_MemberName(mname, info);
2872   // set bci
2873   java_lang_StackFrameInfo::set_bci(stackFrame(), bci);
2874   // method may be redefined; store the version
2875   int version = method-&gt;constants()-&gt;version();
2876   assert((jushort)version == version, &quot;version should be short&quot;);
2877   java_lang_StackFrameInfo::set_version(stackFrame(), (short)version);
2878 }
2879 
2880 void java_lang_StackFrameInfo::to_stack_trace_element(Handle stackFrame, Handle stack_trace_element, TRAPS) {
2881   ResourceMark rm(THREAD);
2882   HandleMark hm(THREAD);
2883   Handle mname(THREAD, stackFrame-&gt;obj_field(java_lang_StackFrameInfo::_memberName_offset));
2884   Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));
2885   InstanceKlass* holder = InstanceKlass::cast(clazz);
2886   Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);
2887 
2888   short version = stackFrame-&gt;short_field(_version_offset);
2889   int bci = stackFrame-&gt;int_field(_bci_offset);
2890   Symbol* name = method-&gt;name();
2891   java_lang_StackTraceElement::fill_in(stack_trace_element, holder, methodHandle(THREAD, method),
2892                                        version, bci, name, CHECK);
2893 }
2894 
2895 #define STACKFRAMEINFO_FIELDS_DO(macro) \
2896   macro(_memberName_offset,     k, &quot;memberName&quot;,  object_signature, false); \
2897   macro(_bci_offset,            k, &quot;bci&quot;,         int_signature,    false)
2898 
2899 void java_lang_StackFrameInfo::compute_offsets() {
2900   InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();
2901   STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2902   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
2903 }
2904 
2905 #if INCLUDE_CDS
2906 void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {
2907   STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2908   STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
2909 }
2910 #endif
2911 
2912 #define LIVESTACKFRAMEINFO_FIELDS_DO(macro) \
2913   macro(_monitors_offset,   k, &quot;monitors&quot;,    object_array_signature, false); \
2914   macro(_locals_offset,     k, &quot;locals&quot;,      object_array_signature, false); \
2915   macro(_operands_offset,   k, &quot;operands&quot;,    object_array_signature, false); \
2916   macro(_mode_offset,       k, &quot;mode&quot;,        int_signature,          false)
2917 
2918 void java_lang_LiveStackFrameInfo::compute_offsets() {
2919   InstanceKlass* k = SystemDictionary::LiveStackFrameInfo_klass();
2920   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2921 }
2922 
2923 #if INCLUDE_CDS
2924 void java_lang_LiveStackFrameInfo::serialize_offsets(SerializeClosure* f) {
2925   LIVESTACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2926 }
2927 #endif
2928 
2929 #define ACCESSIBLEOBJECT_FIELDS_DO(macro) \
2930   macro(override_offset, k, &quot;override&quot;, bool_signature, false)
2931 
2932 void java_lang_reflect_AccessibleObject::compute_offsets() {
2933   InstanceKlass* k = SystemDictionary::reflect_AccessibleObject_klass();
2934   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2935 }
2936 
2937 #if INCLUDE_CDS
2938 void java_lang_reflect_AccessibleObject::serialize_offsets(SerializeClosure* f) {
2939   ACCESSIBLEOBJECT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2940 }
2941 #endif
2942 
2943 jboolean java_lang_reflect_AccessibleObject::override(oop reflect) {
2944   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2945   return (jboolean) reflect-&gt;bool_field(override_offset);
2946 }
2947 
2948 void java_lang_reflect_AccessibleObject::set_override(oop reflect, jboolean value) {
2949   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2950   reflect-&gt;bool_field_put(override_offset, (int) value);
2951 }
2952 
2953 #define METHOD_FIELDS_DO(macro) \
2954   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
2955   macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \
2956   macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \
2957   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
2958   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
2959   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
2960   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
2961   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
2962   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
2963   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \
2964   macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);
2965 
2966 void java_lang_reflect_Method::compute_offsets() {
2967   InstanceKlass* k = SystemDictionary::reflect_Method_klass();
2968   METHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
2969 }
2970 
2971 #if INCLUDE_CDS
2972 void java_lang_reflect_Method::serialize_offsets(SerializeClosure* f) {
2973   METHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
2974 }
2975 #endif
2976 
2977 Handle java_lang_reflect_Method::create(TRAPS) {
2978   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2979   Klass* klass = SystemDictionary::reflect_Method_klass();
2980   // This class is eagerly initialized during VM initialization, since we keep a refence
2981   // to one of the methods
2982   assert(InstanceKlass::cast(klass)-&gt;is_initialized(), &quot;must be initialized&quot;);
2983   return InstanceKlass::cast(klass)-&gt;allocate_instance_handle(THREAD);
2984 }
2985 
2986 oop java_lang_reflect_Method::clazz(oop reflect) {
2987   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2988   return reflect-&gt;obj_field(clazz_offset);
2989 }
2990 
2991 void java_lang_reflect_Method::set_clazz(oop reflect, oop value) {
2992   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2993    reflect-&gt;obj_field_put(clazz_offset, value);
2994 }
2995 
2996 int java_lang_reflect_Method::slot(oop reflect) {
2997   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
2998   return reflect-&gt;int_field(slot_offset);
2999 }
3000 
3001 void java_lang_reflect_Method::set_slot(oop reflect, int value) {
3002   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3003   reflect-&gt;int_field_put(slot_offset, value);
3004 }
3005 
3006 void java_lang_reflect_Method::set_name(oop method, oop value) {
3007   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3008   method-&gt;obj_field_put(name_offset, value);
3009 }
3010 
3011 oop java_lang_reflect_Method::return_type(oop method) {
3012   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3013   return method-&gt;obj_field(returnType_offset);
3014 }
3015 
3016 void java_lang_reflect_Method::set_return_type(oop method, oop value) {
3017   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3018   method-&gt;obj_field_put(returnType_offset, value);
3019 }
3020 
3021 oop java_lang_reflect_Method::parameter_types(oop method) {
3022   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3023   return method-&gt;obj_field(parameterTypes_offset);
3024 }
3025 
3026 void java_lang_reflect_Method::set_parameter_types(oop method, oop value) {
3027   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3028   method-&gt;obj_field_put(parameterTypes_offset, value);
3029 }
3030 
3031 void java_lang_reflect_Method::set_exception_types(oop method, oop value) {
3032   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3033   method-&gt;obj_field_put(exceptionTypes_offset, value);
3034 }
3035 
3036 void java_lang_reflect_Method::set_modifiers(oop method, int value) {
3037   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3038   method-&gt;int_field_put(modifiers_offset, value);
3039 }
3040 
3041 void java_lang_reflect_Method::set_signature(oop method, oop value) {
3042   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3043   method-&gt;obj_field_put(signature_offset, value);
3044 }
3045 
3046 void java_lang_reflect_Method::set_annotations(oop method, oop value) {
3047   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3048   method-&gt;obj_field_put(annotations_offset, value);
3049 }
3050 
3051 void java_lang_reflect_Method::set_parameter_annotations(oop method, oop value) {
3052   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3053   method-&gt;obj_field_put(parameter_annotations_offset, value);
3054 }
3055 
3056 void java_lang_reflect_Method::set_annotation_default(oop method, oop value) {
3057   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3058   method-&gt;obj_field_put(annotation_default_offset, value);
3059 }
3060 
3061 #define CONSTRUCTOR_FIELDS_DO(macro) \
3062   macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \
3063   macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \
3064   macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \
3065   macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \
3066   macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \
3067   macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \
3068   macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \
3069   macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);
3070 
3071 void java_lang_reflect_Constructor::compute_offsets() {
3072   InstanceKlass* k = SystemDictionary::reflect_Constructor_klass();
3073   CONSTRUCTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3074 }
3075 
3076 #if INCLUDE_CDS
3077 void java_lang_reflect_Constructor::serialize_offsets(SerializeClosure* f) {
3078   CONSTRUCTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3079 }
3080 #endif
3081 
3082 Handle java_lang_reflect_Constructor::create(TRAPS) {
3083   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3084   Symbol* name = vmSymbols::java_lang_reflect_Constructor();
3085   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3086   InstanceKlass* ik = InstanceKlass::cast(k);
3087   // Ensure it is initialized
3088   ik-&gt;initialize(CHECK_NH);
3089   return ik-&gt;allocate_instance_handle(THREAD);
3090 }
3091 
3092 oop java_lang_reflect_Constructor::clazz(oop reflect) {
3093   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3094   return reflect-&gt;obj_field(clazz_offset);
3095 }
3096 
3097 void java_lang_reflect_Constructor::set_clazz(oop reflect, oop value) {
3098   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3099    reflect-&gt;obj_field_put(clazz_offset, value);
3100 }
3101 
3102 oop java_lang_reflect_Constructor::parameter_types(oop constructor) {
3103   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3104   return constructor-&gt;obj_field(parameterTypes_offset);
3105 }
3106 
3107 void java_lang_reflect_Constructor::set_parameter_types(oop constructor, oop value) {
3108   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3109   constructor-&gt;obj_field_put(parameterTypes_offset, value);
3110 }
3111 
3112 void java_lang_reflect_Constructor::set_exception_types(oop constructor, oop value) {
3113   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3114   constructor-&gt;obj_field_put(exceptionTypes_offset, value);
3115 }
3116 
3117 int java_lang_reflect_Constructor::slot(oop reflect) {
3118   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3119   return reflect-&gt;int_field(slot_offset);
3120 }
3121 
3122 void java_lang_reflect_Constructor::set_slot(oop reflect, int value) {
3123   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3124   reflect-&gt;int_field_put(slot_offset, value);
3125 }
3126 
3127 void java_lang_reflect_Constructor::set_modifiers(oop constructor, int value) {
3128   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3129   constructor-&gt;int_field_put(modifiers_offset, value);
3130 }
3131 
3132 void java_lang_reflect_Constructor::set_signature(oop constructor, oop value) {
3133   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3134   constructor-&gt;obj_field_put(signature_offset, value);
3135 }
3136 
3137 void java_lang_reflect_Constructor::set_annotations(oop constructor, oop value) {
3138   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3139   constructor-&gt;obj_field_put(annotations_offset, value);
3140 }
3141 
3142 void java_lang_reflect_Constructor::set_parameter_annotations(oop method, oop value) {
3143   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3144   method-&gt;obj_field_put(parameter_annotations_offset, value);
3145 }
3146 
3147 #define FIELD_FIELDS_DO(macro) \
3148   macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \
3149   macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \
3150   macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \
3151   macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \
3152   macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \
3153   macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \
3154   macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);
3155 
3156 void java_lang_reflect_Field::compute_offsets() {
3157   InstanceKlass* k = SystemDictionary::reflect_Field_klass();
3158   FIELD_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3159 }
3160 
3161 #if INCLUDE_CDS
3162 void java_lang_reflect_Field::serialize_offsets(SerializeClosure* f) {
3163   FIELD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3164 }
3165 #endif
3166 
3167 Handle java_lang_reflect_Field::create(TRAPS) {
3168   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3169   Symbol* name = vmSymbols::java_lang_reflect_Field();
3170   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3171   InstanceKlass* ik = InstanceKlass::cast(k);
3172   // Ensure it is initialized
3173   ik-&gt;initialize(CHECK_NH);
3174   return ik-&gt;allocate_instance_handle(THREAD);
3175 }
3176 
3177 oop java_lang_reflect_Field::clazz(oop reflect) {
3178   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3179   return reflect-&gt;obj_field(clazz_offset);
3180 }
3181 
3182 void java_lang_reflect_Field::set_clazz(oop reflect, oop value) {
3183   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3184    reflect-&gt;obj_field_put(clazz_offset, value);
3185 }
3186 
3187 oop java_lang_reflect_Field::name(oop field) {
3188   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3189   return field-&gt;obj_field(name_offset);
3190 }
3191 
3192 void java_lang_reflect_Field::set_name(oop field, oop value) {
3193   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3194   field-&gt;obj_field_put(name_offset, value);
3195 }
3196 
3197 oop java_lang_reflect_Field::type(oop field) {
3198   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3199   return field-&gt;obj_field(type_offset);
3200 }
3201 
3202 void java_lang_reflect_Field::set_type(oop field, oop value) {
3203   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3204   field-&gt;obj_field_put(type_offset, value);
3205 }
3206 
3207 int java_lang_reflect_Field::slot(oop reflect) {
3208   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3209   return reflect-&gt;int_field(slot_offset);
3210 }
3211 
3212 void java_lang_reflect_Field::set_slot(oop reflect, int value) {
3213   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3214   reflect-&gt;int_field_put(slot_offset, value);
3215 }
3216 
3217 int java_lang_reflect_Field::modifiers(oop field) {
3218   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3219   return field-&gt;int_field(modifiers_offset);
3220 }
3221 
3222 void java_lang_reflect_Field::set_modifiers(oop field, int value) {
3223   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3224   field-&gt;int_field_put(modifiers_offset, value);
3225 }
3226 
3227 void java_lang_reflect_Field::set_signature(oop field, oop value) {
3228   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3229   field-&gt;obj_field_put(signature_offset, value);
3230 }
3231 
3232 void java_lang_reflect_Field::set_annotations(oop field, oop value) {
3233   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3234   field-&gt;obj_field_put(annotations_offset, value);
3235 }
3236 
3237 oop java_lang_reflect_RecordComponent::create(InstanceKlass* holder, RecordComponent* component, TRAPS) {
3238   // Allocate java.lang.reflect.RecordComponent instance
3239   HandleMark hm(THREAD);
3240   InstanceKlass* ik = SystemDictionary::RecordComponent_klass();
3241   assert(ik != NULL, &quot;must be loaded&quot;);
3242   ik-&gt;initialize(CHECK_NULL);
3243 
3244   Handle element = ik-&gt;allocate_instance_handle(CHECK_NULL);
3245 
3246   Handle decl_class(THREAD, holder-&gt;java_mirror());
3247   java_lang_reflect_RecordComponent::set_clazz(element(), decl_class());
3248 
3249   Symbol* name = holder-&gt;constants()-&gt;symbol_at(component-&gt;name_index()); // name_index is a utf8
3250   oop component_name = StringTable::intern(name, CHECK_NULL);
3251   java_lang_reflect_RecordComponent::set_name(element(), component_name);
3252 
3253   Symbol* type = holder-&gt;constants()-&gt;symbol_at(component-&gt;descriptor_index());
3254   Handle component_type_h =
3255     SystemDictionary::find_java_mirror_for_type(type, holder, SignatureStream::NCDFError, CHECK_NULL);
3256   java_lang_reflect_RecordComponent::set_type(element(), component_type_h());
3257 
3258   Method* accessor_method = NULL;
3259   {
3260     // Prepend &quot;()&quot; to type to create the full method signature.
3261     ResourceMark rm(THREAD);
3262     int sig_len = type-&gt;utf8_length() + 3; // &quot;()&quot; and null char
3263     char* sig = NEW_RESOURCE_ARRAY(char, sig_len);
3264     jio_snprintf(sig, sig_len, &quot;%c%c%s&quot;, JVM_SIGNATURE_FUNC, JVM_SIGNATURE_ENDFUNC, type-&gt;as_C_string());
3265     TempNewSymbol full_sig = SymbolTable::new_symbol(sig);
3266     accessor_method = holder-&gt;find_instance_method(name, full_sig, Klass::find_private);
3267   }
3268 
3269   if (accessor_method != NULL) {
3270     methodHandle method(THREAD, accessor_method);
3271     oop m = Reflection::new_method(method, false, CHECK_NULL);
3272     java_lang_reflect_RecordComponent::set_accessor(element(), m);
3273   } else {
3274     java_lang_reflect_RecordComponent::set_accessor(element(), NULL);
3275   }
3276 
3277   int sig_index = component-&gt;generic_signature_index();
3278   if (sig_index &gt; 0) {
3279     Symbol* sig = holder-&gt;constants()-&gt;symbol_at(sig_index); // sig_index is a utf8
3280     oop component_sig = StringTable::intern(sig, CHECK_NULL);
3281     java_lang_reflect_RecordComponent::set_signature(element(), component_sig);
3282   } else {
3283     java_lang_reflect_RecordComponent::set_signature(element(), NULL);
3284   }
3285 
3286   typeArrayOop annotation_oop = Annotations::make_java_array(component-&gt;annotations(), CHECK_NULL);
3287   java_lang_reflect_RecordComponent::set_annotations(element(), annotation_oop);
3288 
3289   typeArrayOop type_annotation_oop = Annotations::make_java_array(component-&gt;type_annotations(), CHECK_NULL);
3290   java_lang_reflect_RecordComponent::set_typeAnnotations(element(), type_annotation_oop);
3291 
3292   return element();
3293 }
3294 
3295 #define CONSTANTPOOL_FIELDS_DO(macro) \
3296   macro(_oop_offset, k, &quot;constantPoolOop&quot;, object_signature, false)
3297 
3298 void reflect_ConstantPool::compute_offsets() {
3299   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3300   // The field is called ConstantPool* in the sun.reflect.ConstantPool class.
3301   CONSTANTPOOL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3302 }
3303 
3304 #if INCLUDE_CDS
3305 void reflect_ConstantPool::serialize_offsets(SerializeClosure* f) {
3306   CONSTANTPOOL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3307 }
3308 #endif
3309 
3310 #define PARAMETER_FIELDS_DO(macro) \
3311   macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \
3312   macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \
3313   macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \
3314   macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)
3315 
3316 void java_lang_reflect_Parameter::compute_offsets() {
3317   InstanceKlass* k = SystemDictionary::reflect_Parameter_klass();
3318   PARAMETER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3319 }
3320 
3321 #if INCLUDE_CDS
3322 void java_lang_reflect_Parameter::serialize_offsets(SerializeClosure* f) {
3323   PARAMETER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3324 }
3325 #endif
3326 
3327 Handle java_lang_reflect_Parameter::create(TRAPS) {
3328   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3329   Symbol* name = vmSymbols::java_lang_reflect_Parameter();
3330   Klass* k = SystemDictionary::resolve_or_fail(name, true, CHECK_NH);
3331   InstanceKlass* ik = InstanceKlass::cast(k);
3332   // Ensure it is initialized
3333   ik-&gt;initialize(CHECK_NH);
3334   return ik-&gt;allocate_instance_handle(THREAD);
3335 }
3336 
3337 oop java_lang_reflect_Parameter::name(oop param) {
3338   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3339   return param-&gt;obj_field(name_offset);
3340 }
3341 
3342 void java_lang_reflect_Parameter::set_name(oop param, oop value) {
3343   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3344   param-&gt;obj_field_put(name_offset, value);
3345 }
3346 
3347 int java_lang_reflect_Parameter::modifiers(oop param) {
3348   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3349   return param-&gt;int_field(modifiers_offset);
3350 }
3351 
3352 void java_lang_reflect_Parameter::set_modifiers(oop param, int value) {
3353   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3354   param-&gt;int_field_put(modifiers_offset, value);
3355 }
3356 
3357 int java_lang_reflect_Parameter::index(oop param) {
3358   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3359   return param-&gt;int_field(index_offset);
3360 }
3361 
3362 void java_lang_reflect_Parameter::set_index(oop param, int value) {
3363   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3364   param-&gt;int_field_put(index_offset, value);
3365 }
3366 
3367 oop java_lang_reflect_Parameter::executable(oop param) {
3368   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3369   return param-&gt;obj_field(executable_offset);
3370 }
3371 
3372 void java_lang_reflect_Parameter::set_executable(oop param, oop value) {
3373   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3374   param-&gt;obj_field_put(executable_offset, value);
3375 }
3376 
3377 
3378 int java_lang_Module::loader_offset;
3379 int java_lang_Module::name_offset;
3380 int java_lang_Module::_module_entry_offset = -1;
3381 
3382 Handle java_lang_Module::create(Handle loader, Handle module_name, TRAPS) {
3383   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3384   return JavaCalls::construct_new_instance(SystemDictionary::Module_klass(),
3385                           vmSymbols::java_lang_module_init_signature(),
3386                           loader, module_name, CHECK_NH);
3387 }
3388 
3389 #define MODULE_FIELDS_DO(macro) \
3390   macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \
3391   macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)
3392 
3393 void java_lang_Module::compute_offsets() {
3394   InstanceKlass* k = SystemDictionary::Module_klass();
3395   MODULE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3396   MODULE_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3397 }
3398 
3399 #if INCLUDE_CDS
3400 void java_lang_Module::serialize_offsets(SerializeClosure* f) {
3401   MODULE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3402   MODULE_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3403 }
3404 #endif
3405 
3406 oop java_lang_Module::loader(oop module) {
3407   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3408   return module-&gt;obj_field(loader_offset);
3409 }
3410 
3411 void java_lang_Module::set_loader(oop module, oop value) {
3412   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3413   module-&gt;obj_field_put(loader_offset, value);
3414 }
3415 
3416 oop java_lang_Module::name(oop module) {
3417   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3418   return module-&gt;obj_field(name_offset);
3419 }
3420 
3421 void java_lang_Module::set_name(oop module, oop value) {
3422   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3423   module-&gt;obj_field_put(name_offset, value);
3424 }
3425 
3426 ModuleEntry* java_lang_Module::module_entry(oop module) {
3427   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3428   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3429   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3430 
3431   ModuleEntry* module_entry = (ModuleEntry*)module-&gt;address_field(_module_entry_offset);
3432   if (module_entry == NULL) {
3433     // If the inject field containing the ModuleEntry* is null then return the
3434     // class loader&#39;s unnamed module.
3435     oop loader = java_lang_Module::loader(module);
3436     Handle h_loader = Handle(Thread::current(), loader);
3437     ClassLoaderData* loader_cld = SystemDictionary::register_loader(h_loader);
3438     return loader_cld-&gt;unnamed_module();
3439   }
3440   return module_entry;
3441 }
3442 
3443 void java_lang_Module::set_module_entry(oop module, ModuleEntry* module_entry) {
3444   assert(_module_entry_offset != -1, &quot;Uninitialized module_entry_offset&quot;);
3445   assert(module != NULL, &quot;module can&#39;t be null&quot;);
3446   assert(oopDesc::is_oop(module), &quot;module must be oop&quot;);
3447   module-&gt;address_field_put(_module_entry_offset, (address)module_entry);
3448 }
3449 
3450 Handle reflect_ConstantPool::create(TRAPS) {
3451   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3452   InstanceKlass* k = SystemDictionary::reflect_ConstantPool_klass();
3453   // Ensure it is initialized
3454   k-&gt;initialize(CHECK_NH);
3455   return k-&gt;allocate_instance_handle(THREAD);
3456 }
3457 
3458 
3459 void reflect_ConstantPool::set_cp(oop reflect, ConstantPool* value) {
3460   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3461   oop mirror = value-&gt;pool_holder()-&gt;java_mirror();
3462   // Save the mirror to get back the constant pool.
3463   reflect-&gt;obj_field_put(_oop_offset, mirror);
3464 }
3465 
3466 ConstantPool* reflect_ConstantPool::get_cp(oop reflect) {
3467   assert(Universe::is_fully_initialized(), &quot;Need to find another solution to the reflection problem&quot;);
3468 
3469   oop mirror = reflect-&gt;obj_field(_oop_offset);
3470   Klass* k = java_lang_Class::as_Klass(mirror);
3471   assert(k-&gt;is_instance_klass(), &quot;Must be&quot;);
3472 
3473   // Get the constant pool back from the klass.  Since class redefinition
3474   // merges the new constant pool into the old, this is essentially the
3475   // same constant pool as the original.  If constant pool merging is
3476   // no longer done in the future, this will have to change to save
3477   // the original.
3478   return InstanceKlass::cast(k)-&gt;constants();
3479 }
3480 
3481 #define UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(macro) \
3482   macro(_base_offset, k, &quot;base&quot;, object_signature, false)
3483 
3484 void reflect_UnsafeStaticFieldAccessorImpl::compute_offsets() {
3485   InstanceKlass* k = SystemDictionary::reflect_UnsafeStaticFieldAccessorImpl_klass();
3486   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3487 }
3488 
3489 #if INCLUDE_CDS
3490 void reflect_UnsafeStaticFieldAccessorImpl::serialize_offsets(SerializeClosure* f) {
3491   UNSAFESTATICFIELDACCESSORIMPL_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3492 }
3493 #endif
3494 
3495 oop java_lang_boxing_object::initialize_and_allocate(BasicType type, TRAPS) {
3496   Klass* k = SystemDictionary::box_klass(type);
3497   if (k == NULL)  return NULL;
3498   InstanceKlass* ik = InstanceKlass::cast(k);
3499   if (!ik-&gt;is_initialized())  ik-&gt;initialize(CHECK_NULL);
3500   return ik-&gt;allocate_instance(THREAD);
3501 }
3502 
3503 
3504 oop java_lang_boxing_object::create(BasicType type, jvalue* value, TRAPS) {
3505   oop box = initialize_and_allocate(type, CHECK_NULL);
3506   if (box == NULL)  return NULL;
3507   switch (type) {
3508     case T_BOOLEAN:
3509       box-&gt;bool_field_put(value_offset, value-&gt;z);
3510       break;
3511     case T_CHAR:
3512       box-&gt;char_field_put(value_offset, value-&gt;c);
3513       break;
3514     case T_FLOAT:
3515       box-&gt;float_field_put(value_offset, value-&gt;f);
3516       break;
3517     case T_DOUBLE:
3518       box-&gt;double_field_put(long_value_offset, value-&gt;d);
3519       break;
3520     case T_BYTE:
3521       box-&gt;byte_field_put(value_offset, value-&gt;b);
3522       break;
3523     case T_SHORT:
3524       box-&gt;short_field_put(value_offset, value-&gt;s);
3525       break;
3526     case T_INT:
3527       box-&gt;int_field_put(value_offset, value-&gt;i);
3528       break;
3529     case T_LONG:
3530       box-&gt;long_field_put(long_value_offset, value-&gt;j);
3531       break;
3532     default:
3533       return NULL;
3534   }
3535   return box;
3536 }
3537 
3538 
3539 BasicType java_lang_boxing_object::basic_type(oop box) {
3540   if (box == NULL)  return T_ILLEGAL;
3541   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3542   if (type == T_OBJECT)         // &#39;unknown&#39; value returned by SD::bkt
3543     return T_ILLEGAL;
3544   return type;
3545 }
3546 
3547 
3548 BasicType java_lang_boxing_object::get_value(oop box, jvalue* value) {
3549   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3550   switch (type) {
3551   case T_BOOLEAN:
3552     value-&gt;z = box-&gt;bool_field(value_offset);
3553     break;
3554   case T_CHAR:
3555     value-&gt;c = box-&gt;char_field(value_offset);
3556     break;
3557   case T_FLOAT:
3558     value-&gt;f = box-&gt;float_field(value_offset);
3559     break;
3560   case T_DOUBLE:
3561     value-&gt;d = box-&gt;double_field(long_value_offset);
3562     break;
3563   case T_BYTE:
3564     value-&gt;b = box-&gt;byte_field(value_offset);
3565     break;
3566   case T_SHORT:
3567     value-&gt;s = box-&gt;short_field(value_offset);
3568     break;
3569   case T_INT:
3570     value-&gt;i = box-&gt;int_field(value_offset);
3571     break;
3572   case T_LONG:
3573     value-&gt;j = box-&gt;long_field(long_value_offset);
3574     break;
3575   default:
3576     return T_ILLEGAL;
3577   } // end switch
3578   return type;
3579 }
3580 
3581 
3582 BasicType java_lang_boxing_object::set_value(oop box, jvalue* value) {
3583   BasicType type = SystemDictionary::box_klass_type(box-&gt;klass());
3584   switch (type) {
3585   case T_BOOLEAN:
3586     box-&gt;bool_field_put(value_offset, value-&gt;z);
3587     break;
3588   case T_CHAR:
3589     box-&gt;char_field_put(value_offset, value-&gt;c);
3590     break;
3591   case T_FLOAT:
3592     box-&gt;float_field_put(value_offset, value-&gt;f);
3593     break;
3594   case T_DOUBLE:
3595     box-&gt;double_field_put(long_value_offset, value-&gt;d);
3596     break;
3597   case T_BYTE:
3598     box-&gt;byte_field_put(value_offset, value-&gt;b);
3599     break;
3600   case T_SHORT:
3601     box-&gt;short_field_put(value_offset, value-&gt;s);
3602     break;
3603   case T_INT:
3604     box-&gt;int_field_put(value_offset, value-&gt;i);
3605     break;
3606   case T_LONG:
3607     box-&gt;long_field_put(long_value_offset, value-&gt;j);
3608     break;
3609   default:
3610     return T_ILLEGAL;
3611   } // end switch
3612   return type;
3613 }
3614 
3615 
3616 void java_lang_boxing_object::print(BasicType type, jvalue* value, outputStream* st) {
3617   switch (type) {
3618   case T_BOOLEAN:   st-&gt;print(&quot;%s&quot;, value-&gt;z ? &quot;true&quot; : &quot;false&quot;);   break;
3619   case T_CHAR:      st-&gt;print(&quot;%d&quot;, value-&gt;c);                      break;
3620   case T_BYTE:      st-&gt;print(&quot;%d&quot;, value-&gt;b);                      break;
3621   case T_SHORT:     st-&gt;print(&quot;%d&quot;, value-&gt;s);                      break;
3622   case T_INT:       st-&gt;print(&quot;%d&quot;, value-&gt;i);                      break;
3623   case T_LONG:      st-&gt;print(JLONG_FORMAT, value-&gt;j);              break;
3624   case T_FLOAT:     st-&gt;print(&quot;%f&quot;, value-&gt;f);                      break;
3625   case T_DOUBLE:    st-&gt;print(&quot;%lf&quot;, value-&gt;d);                     break;
3626   default:          st-&gt;print(&quot;type %d?&quot;, type);                    break;
3627   }
3628 }
3629 
3630 // Support for java_lang_ref_Reference
3631 
3632 bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {
3633   assert(obj != NULL, &quot;sanity&quot;);
3634   if (offset != java_lang_ref_Reference::referent_offset) {
3635     return false;
3636   }
3637 
3638   Klass* k = obj-&gt;klass();
3639   if (!k-&gt;is_instance_klass()) {
3640     return false;
3641   }
3642 
3643   InstanceKlass* ik = InstanceKlass::cast(obj-&gt;klass());
3644   bool is_reference = ik-&gt;reference_type() != REF_NONE;
3645   assert(!is_reference || ik-&gt;is_subclass_of(SystemDictionary::Reference_klass()), &quot;sanity&quot;);
3646   return is_reference;
3647 }
3648 
3649 // Support for java_lang_ref_SoftReference
3650 //
3651 
3652 #define SOFTREFERENCE_FIELDS_DO(macro) \
3653   macro(timestamp_offset,    k, &quot;timestamp&quot;, long_signature, false); \
3654   macro(static_clock_offset, k, &quot;clock&quot;,     long_signature, true)
3655 
3656 void java_lang_ref_SoftReference::compute_offsets() {
3657   InstanceKlass* k = SystemDictionary::SoftReference_klass();
3658   SOFTREFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3659 }
3660 
3661 #if INCLUDE_CDS
3662 void java_lang_ref_SoftReference::serialize_offsets(SerializeClosure* f) {
3663   SOFTREFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3664 }
3665 #endif
3666 
3667 jlong java_lang_ref_SoftReference::timestamp(oop ref) {
3668   return ref-&gt;long_field(timestamp_offset);
3669 }
3670 
3671 jlong java_lang_ref_SoftReference::clock() {
3672   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3673   oop base = ik-&gt;static_field_base_raw();
3674   return base-&gt;long_field(static_clock_offset);
3675 }
3676 
3677 void java_lang_ref_SoftReference::set_clock(jlong value) {
3678   InstanceKlass* ik = SystemDictionary::SoftReference_klass();
3679   oop base = ik-&gt;static_field_base_raw();
3680   base-&gt;long_field_put(static_clock_offset, value);
3681 }
3682 
3683 // Support for java_lang_invoke_DirectMethodHandle
3684 
3685 int java_lang_invoke_DirectMethodHandle::_member_offset;
3686 
3687 oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
3688   oop member_name = NULL;
3689   assert(oopDesc::is_oop(dmh) &amp;&amp; java_lang_invoke_DirectMethodHandle::is_instance(dmh),
3690          &quot;a DirectMethodHandle oop is expected&quot;);
3691   return dmh-&gt;obj_field(member_offset_in_bytes());
3692 }
3693 
3694 #define DIRECTMETHODHANDLE_FIELDS_DO(macro) \
3695   macro(_member_offset, k, &quot;member&quot;, java_lang_invoke_MemberName_signature, false)
3696 
3697 void java_lang_invoke_DirectMethodHandle::compute_offsets() {
3698   InstanceKlass* k = SystemDictionary::DirectMethodHandle_klass();
3699   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3700 }
3701 
3702 #if INCLUDE_CDS
3703 void java_lang_invoke_DirectMethodHandle::serialize_offsets(SerializeClosure* f) {
3704   DIRECTMETHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3705 }
3706 #endif
3707 
3708 // Support for java_lang_invoke_MethodHandle
3709 
3710 int java_lang_invoke_MethodHandle::_type_offset;
3711 int java_lang_invoke_MethodHandle::_form_offset;
3712 
3713 int java_lang_invoke_MemberName::_clazz_offset;
3714 int java_lang_invoke_MemberName::_name_offset;
3715 int java_lang_invoke_MemberName::_type_offset;
3716 int java_lang_invoke_MemberName::_flags_offset;
3717 int java_lang_invoke_MemberName::_method_offset;
3718 int java_lang_invoke_MemberName::_vmindex_offset;
3719 
3720 int java_lang_invoke_ResolvedMethodName::_vmtarget_offset;
3721 int java_lang_invoke_ResolvedMethodName::_vmholder_offset;
3722 
3723 int java_lang_invoke_LambdaForm::_vmentry_offset;
3724 
3725 #define METHODHANDLE_FIELDS_DO(macro) \
3726   macro(_type_offset, k, vmSymbols::type_name(), java_lang_invoke_MethodType_signature, false); \
3727   macro(_form_offset, k, &quot;form&quot;,                 java_lang_invoke_LambdaForm_signature, false)
3728 
3729 void java_lang_invoke_MethodHandle::compute_offsets() {
3730   InstanceKlass* k = SystemDictionary::MethodHandle_klass();
3731   METHODHANDLE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3732 }
3733 
3734 #if INCLUDE_CDS
3735 void java_lang_invoke_MethodHandle::serialize_offsets(SerializeClosure* f) {
3736   METHODHANDLE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3737 }
3738 #endif
3739 
3740 #define MEMBERNAME_FIELDS_DO(macro) \
3741   macro(_clazz_offset,   k, vmSymbols::clazz_name(),   class_signature,  false); \
3742   macro(_name_offset,    k, vmSymbols::name_name(),    string_signature, false); \
3743   macro(_type_offset,    k, vmSymbols::type_name(),    object_signature, false); \
3744   macro(_flags_offset,   k, vmSymbols::flags_name(),   int_signature,    false); \
3745   macro(_method_offset,  k, vmSymbols::method_name(),  java_lang_invoke_ResolvedMethodName_signature, false)
3746 
3747 void java_lang_invoke_MemberName::compute_offsets() {
3748   InstanceKlass* k = SystemDictionary::MemberName_klass();
3749   MEMBERNAME_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3750   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3751 }
3752 
3753 #if INCLUDE_CDS
3754 void java_lang_invoke_MemberName::serialize_offsets(SerializeClosure* f) {
3755   MEMBERNAME_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3756   MEMBERNAME_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3757 }
3758 #endif
3759 
3760 void java_lang_invoke_ResolvedMethodName::compute_offsets() {
3761   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3762   assert(k != NULL, &quot;jdk mismatch&quot;);
3763   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
3764 }
3765 
3766 #if INCLUDE_CDS
3767 void java_lang_invoke_ResolvedMethodName::serialize_offsets(SerializeClosure* f) {
3768   RESOLVEDMETHOD_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
3769 }
3770 #endif
3771 
3772 #define LAMBDAFORM_FIELDS_DO(macro) \
3773   macro(_vmentry_offset, k, &quot;vmentry&quot;, java_lang_invoke_MemberName_signature, false)
3774 
3775 void java_lang_invoke_LambdaForm::compute_offsets() {
3776   InstanceKlass* k = SystemDictionary::LambdaForm_klass();
3777   assert (k != NULL, &quot;jdk mismatch&quot;);
3778   LAMBDAFORM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3779 }
3780 
3781 #if INCLUDE_CDS
3782 void java_lang_invoke_LambdaForm::serialize_offsets(SerializeClosure* f) {
3783   LAMBDAFORM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3784 }
3785 #endif
3786 
3787 bool java_lang_invoke_LambdaForm::is_instance(oop obj) {
3788   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
3789 }
3790 
3791 
3792 oop java_lang_invoke_MethodHandle::type(oop mh) {
3793   return mh-&gt;obj_field(_type_offset);
3794 }
3795 
3796 void java_lang_invoke_MethodHandle::set_type(oop mh, oop mtype) {
3797   mh-&gt;obj_field_put(_type_offset, mtype);
3798 }
3799 
3800 oop java_lang_invoke_MethodHandle::form(oop mh) {
3801   assert(_form_offset != 0, &quot;&quot;);
3802   return mh-&gt;obj_field(_form_offset);
3803 }
3804 
3805 void java_lang_invoke_MethodHandle::set_form(oop mh, oop lform) {
3806   assert(_form_offset != 0, &quot;&quot;);
3807   mh-&gt;obj_field_put(_form_offset, lform);
3808 }
3809 
3810 /// MemberName accessors
3811 
3812 oop java_lang_invoke_MemberName::clazz(oop mname) {
3813   assert(is_instance(mname), &quot;wrong type&quot;);
3814   return mname-&gt;obj_field(_clazz_offset);
3815 }
3816 
3817 void java_lang_invoke_MemberName::set_clazz(oop mname, oop clazz) {
3818   assert(is_instance(mname), &quot;wrong type&quot;);
3819   mname-&gt;obj_field_put(_clazz_offset, clazz);
3820 }
3821 
3822 oop java_lang_invoke_MemberName::name(oop mname) {
3823   assert(is_instance(mname), &quot;wrong type&quot;);
3824   return mname-&gt;obj_field(_name_offset);
3825 }
3826 
3827 void java_lang_invoke_MemberName::set_name(oop mname, oop name) {
3828   assert(is_instance(mname), &quot;wrong type&quot;);
3829   mname-&gt;obj_field_put(_name_offset, name);
3830 }
3831 
3832 oop java_lang_invoke_MemberName::type(oop mname) {
3833   assert(is_instance(mname), &quot;wrong type&quot;);
3834   return mname-&gt;obj_field(_type_offset);
3835 }
3836 
3837 void java_lang_invoke_MemberName::set_type(oop mname, oop type) {
3838   assert(is_instance(mname), &quot;wrong type&quot;);
3839   mname-&gt;obj_field_put(_type_offset, type);
3840 }
3841 
3842 int java_lang_invoke_MemberName::flags(oop mname) {
3843   assert(is_instance(mname), &quot;wrong type&quot;);
3844   return mname-&gt;int_field(_flags_offset);
3845 }
3846 
3847 void java_lang_invoke_MemberName::set_flags(oop mname, int flags) {
3848   assert(is_instance(mname), &quot;wrong type&quot;);
3849   mname-&gt;int_field_put(_flags_offset, flags);
3850 }
3851 
3852 
3853 // Return vmtarget from ResolvedMethodName method field through indirection
3854 Method* java_lang_invoke_MemberName::vmtarget(oop mname) {
3855   assert(is_instance(mname), &quot;wrong type&quot;);
3856   oop method = mname-&gt;obj_field(_method_offset);
3857   return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);
3858 }
3859 
3860 bool java_lang_invoke_MemberName::is_method(oop mname) {
3861   assert(is_instance(mname), &quot;must be MemberName&quot;);
<a name="13" id="anc13"></a><span class="line-modified">3862   return (flags(mname) &amp; (MN_IS_METHOD | MN_IS_OBJECT_CONSTRUCTOR)) &gt; 0;</span>
3863 }
3864 
3865 void java_lang_invoke_MemberName::set_method(oop mname, oop resolved_method) {
3866   assert(is_instance(mname), &quot;wrong type&quot;);
3867   mname-&gt;obj_field_put(_method_offset, resolved_method);
3868 }
3869 
3870 intptr_t java_lang_invoke_MemberName::vmindex(oop mname) {
3871   assert(is_instance(mname), &quot;wrong type&quot;);
3872   return (intptr_t) mname-&gt;address_field(_vmindex_offset);
3873 }
3874 
3875 void java_lang_invoke_MemberName::set_vmindex(oop mname, intptr_t index) {
3876   assert(is_instance(mname), &quot;wrong type&quot;);
3877   mname-&gt;address_field_put(_vmindex_offset, (address) index);
3878 }
3879 
3880 
3881 Method* java_lang_invoke_ResolvedMethodName::vmtarget(oop resolved_method) {
3882   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3883   Method* m = (Method*)resolved_method-&gt;address_field(_vmtarget_offset);
3884   assert(m-&gt;is_method(), &quot;must be&quot;);
3885   return m;
3886 }
3887 
3888 // Used by redefinition to change Method* to new Method* with same hash (name, signature)
3889 void java_lang_invoke_ResolvedMethodName::set_vmtarget(oop resolved_method, Method* m) {
3890   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3891   resolved_method-&gt;address_field_put(_vmtarget_offset, (address)m);
3892 }
3893 
3894 void java_lang_invoke_ResolvedMethodName::set_vmholder(oop resolved_method, oop holder) {
3895   assert(is_instance(resolved_method), &quot;wrong type&quot;);
3896   resolved_method-&gt;obj_field_put(_vmholder_offset, holder);
3897 }
3898 
3899 oop java_lang_invoke_ResolvedMethodName::find_resolved_method(const methodHandle&amp; m, TRAPS) {
3900   const Method* method = m();
3901 
3902   // lookup ResolvedMethod oop in the table, or create a new one and intern it
3903   oop resolved_method = ResolvedMethodTable::find_method(method);
3904   if (resolved_method != NULL) {
3905     return resolved_method;
3906   }
3907 
3908   InstanceKlass* k = SystemDictionary::ResolvedMethodName_klass();
3909   if (!k-&gt;is_initialized()) {
3910     k-&gt;initialize(CHECK_NULL);
3911   }
3912 
3913   oop new_resolved_method = k-&gt;allocate_instance(CHECK_NULL);
3914 
3915   NoSafepointVerifier nsv;
3916 
3917   if (method-&gt;is_old()) {
3918     method = (method-&gt;is_deleted()) ? Universe::throw_no_such_method_error() :
3919                                       method-&gt;get_new_method();
3920   }
3921 
3922   InstanceKlass* holder = method-&gt;method_holder();
3923 
3924   set_vmtarget(new_resolved_method, const_cast&lt;Method*&gt;(method));
3925   // Add a reference to the loader (actually mirror because unsafe anonymous classes will not have
3926   // distinct loaders) to ensure the metadata is kept alive.
3927   // This mirror may be different than the one in clazz field.
3928   set_vmholder(new_resolved_method, holder-&gt;java_mirror());
3929 
3930   // Set flag in class to indicate this InstanceKlass has entries in the table
3931   // to avoid walking table during redefinition if none of the redefined classes
3932   // have any membernames in the table.
3933   holder-&gt;set_has_resolved_methods();
3934 
3935   return ResolvedMethodTable::add_method(method, Handle(THREAD, new_resolved_method));
3936 }
3937 
3938 oop java_lang_invoke_LambdaForm::vmentry(oop lform) {
3939   assert(is_instance(lform), &quot;wrong type&quot;);
3940   return lform-&gt;obj_field(_vmentry_offset);
3941 }
3942 
3943 
3944 // Support for java_lang_invoke_MethodType
3945 
3946 int java_lang_invoke_MethodType::_rtype_offset;
3947 int java_lang_invoke_MethodType::_ptypes_offset;
3948 
3949 #define METHODTYPE_FIELDS_DO(macro) \
3950   macro(_rtype_offset,  k, &quot;rtype&quot;,  class_signature,       false); \
3951   macro(_ptypes_offset, k, &quot;ptypes&quot;, class_array_signature, false)
3952 
3953 void java_lang_invoke_MethodType::compute_offsets() {
3954   InstanceKlass* k = SystemDictionary::MethodType_klass();
3955   METHODTYPE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
3956 }
3957 
3958 #if INCLUDE_CDS
3959 void java_lang_invoke_MethodType::serialize_offsets(SerializeClosure* f) {
3960   METHODTYPE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
3961 }
3962 #endif
3963 
3964 void java_lang_invoke_MethodType::print_signature(oop mt, outputStream* st) {
3965   st-&gt;print(&quot;(&quot;);
3966   objArrayOop pts = ptypes(mt);
3967   for (int i = 0, limit = pts-&gt;length(); i &lt; limit; i++) {
3968     java_lang_Class::print_signature(pts-&gt;obj_at(i), st);
3969   }
3970   st-&gt;print(&quot;)&quot;);
3971   java_lang_Class::print_signature(rtype(mt), st);
3972 }
3973 
3974 Symbol* java_lang_invoke_MethodType::as_signature(oop mt, bool intern_if_not_found) {
3975   ResourceMark rm;
3976   stringStream buffer(128);
3977   print_signature(mt, &amp;buffer);
3978   const char* sigstr =       buffer.base();
3979   int         siglen = (int) buffer.size();
3980   Symbol *name;
3981   if (!intern_if_not_found) {
3982     name = SymbolTable::probe(sigstr, siglen);
3983   } else {
3984     name = SymbolTable::new_symbol(sigstr, siglen);
3985   }
3986   return name;
3987 }
3988 
3989 bool java_lang_invoke_MethodType::equals(oop mt1, oop mt2) {
3990   if (mt1 == mt2)
3991     return true;
3992   if (rtype(mt1) != rtype(mt2))
3993     return false;
3994   if (ptype_count(mt1) != ptype_count(mt2))
3995     return false;
3996   for (int i = ptype_count(mt1) - 1; i &gt;= 0; i--) {
3997     if (ptype(mt1, i) != ptype(mt2, i))
3998       return false;
3999   }
4000   return true;
4001 }
4002 
4003 oop java_lang_invoke_MethodType::rtype(oop mt) {
4004   assert(is_instance(mt), &quot;must be a MethodType&quot;);
4005   return mt-&gt;obj_field(_rtype_offset);
4006 }
4007 
4008 objArrayOop java_lang_invoke_MethodType::ptypes(oop mt) {
4009   assert(is_instance(mt), &quot;must be a MethodType&quot;);
4010   return (objArrayOop) mt-&gt;obj_field(_ptypes_offset);
4011 }
4012 
4013 oop java_lang_invoke_MethodType::ptype(oop mt, int idx) {
4014   return ptypes(mt)-&gt;obj_at(idx);
4015 }
4016 
4017 int java_lang_invoke_MethodType::ptype_count(oop mt) {
4018   return ptypes(mt)-&gt;length();
4019 }
4020 
4021 int java_lang_invoke_MethodType::ptype_slot_count(oop mt) {
4022   objArrayOop pts = ptypes(mt);
4023   int count = pts-&gt;length();
4024   int slots = 0;
4025   for (int i = 0; i &lt; count; i++) {
4026     BasicType bt = java_lang_Class::as_BasicType(pts-&gt;obj_at(i));
4027     slots += type2size[bt];
4028   }
4029   return slots;
4030 }
4031 
4032 int java_lang_invoke_MethodType::rtype_slot_count(oop mt) {
4033   BasicType bt = java_lang_Class::as_BasicType(rtype(mt));
4034   return type2size[bt];
4035 }
4036 
4037 
4038 // Support for java_lang_invoke_CallSite
4039 
4040 int java_lang_invoke_CallSite::_target_offset;
4041 int java_lang_invoke_CallSite::_context_offset;
4042 
4043 #define CALLSITE_FIELDS_DO(macro) \
4044   macro(_target_offset,  k, &quot;target&quot;, java_lang_invoke_MethodHandle_signature, false); \
4045   macro(_context_offset, k, &quot;context&quot;, java_lang_invoke_MethodHandleNatives_CallSiteContext_signature, false)
4046 
4047 void java_lang_invoke_CallSite::compute_offsets() {
4048   InstanceKlass* k = SystemDictionary::CallSite_klass();
4049   CALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4050 }
4051 
4052 #if INCLUDE_CDS
4053 void java_lang_invoke_CallSite::serialize_offsets(SerializeClosure* f) {
4054   CALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4055 }
4056 #endif
4057 
4058 oop java_lang_invoke_CallSite::context_no_keepalive(oop call_site) {
4059   assert(java_lang_invoke_CallSite::is_instance(call_site), &quot;&quot;);
4060 
4061   oop dep_oop = call_site-&gt;obj_field_access&lt;AS_NO_KEEPALIVE&gt;(_context_offset);
4062   return dep_oop;
4063 }
4064 
4065 // Support for java_lang_invoke_ConstantCallSite
4066 
4067 int java_lang_invoke_ConstantCallSite::_is_frozen_offset;
4068 
4069 #define CONSTANTCALLSITE_FIELDS_DO(macro) \
4070   macro(_is_frozen_offset, k, &quot;isFrozen&quot;, bool_signature, false)
4071 
4072 void java_lang_invoke_ConstantCallSite::compute_offsets() {
4073   InstanceKlass* k = SystemDictionary::ConstantCallSite_klass();
4074   CONSTANTCALLSITE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4075 }
4076 
4077 #if INCLUDE_CDS
4078 void java_lang_invoke_ConstantCallSite::serialize_offsets(SerializeClosure* f) {
4079   CONSTANTCALLSITE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4080 }
4081 #endif
4082 
4083 // Support for java_lang_invoke_MethodHandleNatives_CallSiteContext
4084 
4085 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_vmdependencies_offset;
4086 int java_lang_invoke_MethodHandleNatives_CallSiteContext::_last_cleanup_offset;
4087 
4088 void java_lang_invoke_MethodHandleNatives_CallSiteContext::compute_offsets() {
4089   InstanceKlass* k = SystemDictionary::Context_klass();
4090   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4091 }
4092 
4093 #if INCLUDE_CDS
4094 void java_lang_invoke_MethodHandleNatives_CallSiteContext::serialize_offsets(SerializeClosure* f) {
4095   CALLSITECONTEXT_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4096 }
4097 #endif
4098 
4099 DependencyContext java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(oop call_site) {
4100   assert(java_lang_invoke_MethodHandleNatives_CallSiteContext::is_instance(call_site), &quot;&quot;);
4101   nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site-&gt;field_addr(_vmdependencies_offset);
4102   volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site-&gt;field_addr(_last_cleanup_offset);
4103   DependencyContext dep_ctx(vmdeps_addr, last_cleanup_addr);
4104   return dep_ctx;
4105 }
4106 
4107 // Support for java_security_AccessControlContext
4108 
4109 int java_security_AccessControlContext::_context_offset = 0;
4110 int java_security_AccessControlContext::_privilegedContext_offset = 0;
4111 int java_security_AccessControlContext::_isPrivileged_offset = 0;
4112 int java_security_AccessControlContext::_isAuthorized_offset = -1;
4113 
4114 #define ACCESSCONTROLCONTEXT_FIELDS_DO(macro) \
4115   macro(_context_offset,           k, &quot;context&quot;,      protectiondomain_signature, false); \
4116   macro(_privilegedContext_offset, k, &quot;privilegedContext&quot;, accesscontrolcontext_signature, false); \
4117   macro(_isPrivileged_offset,      k, &quot;isPrivileged&quot;, bool_signature, false); \
4118   macro(_isAuthorized_offset,      k, &quot;isAuthorized&quot;, bool_signature, false)
4119 
4120 void java_security_AccessControlContext::compute_offsets() {
4121   assert(_isPrivileged_offset == 0, &quot;offsets should be initialized only once&quot;);
4122   InstanceKlass* k = SystemDictionary::AccessControlContext_klass();
4123   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4124 }
4125 
4126 #if INCLUDE_CDS
4127 void java_security_AccessControlContext::serialize_offsets(SerializeClosure* f) {
4128   ACCESSCONTROLCONTEXT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4129 }
4130 #endif
4131 
4132 oop java_security_AccessControlContext::create(objArrayHandle context, bool isPrivileged, Handle privileged_context, TRAPS) {
4133   assert(_isPrivileged_offset != 0, &quot;offsets should have been initialized&quot;);
4134   assert(_isAuthorized_offset != -1, &quot;offsets should have been initialized&quot;);
4135   // Ensure klass is initialized
4136   SystemDictionary::AccessControlContext_klass()-&gt;initialize(CHECK_NULL);
4137   // Allocate result
4138   oop result = SystemDictionary::AccessControlContext_klass()-&gt;allocate_instance(CHECK_NULL);
4139   // Fill in values
4140   result-&gt;obj_field_put(_context_offset, context());
4141   result-&gt;obj_field_put(_privilegedContext_offset, privileged_context());
4142   result-&gt;bool_field_put(_isPrivileged_offset, isPrivileged);
4143   // whitelist AccessControlContexts created by the JVM
4144   result-&gt;bool_field_put(_isAuthorized_offset, true);
4145   return result;
4146 }
4147 
4148 
4149 // Support for java_lang_ClassLoader
4150 
4151 bool java_lang_ClassLoader::offsets_computed = false;
4152 int  java_lang_ClassLoader::_loader_data_offset = -1;
4153 int  java_lang_ClassLoader::parallelCapable_offset = -1;
4154 int  java_lang_ClassLoader::name_offset = -1;
4155 int  java_lang_ClassLoader::nameAndId_offset = -1;
4156 int  java_lang_ClassLoader::unnamedModule_offset = -1;
4157 
4158 ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {
4159   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4160   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4161   return HeapAccess&lt;MO_ACQUIRE&gt;::load_at(loader, _loader_data_offset);
4162 }
4163 
4164 ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {
4165   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4166   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4167   return RawAccess&lt;&gt;::load_at(loader, _loader_data_offset);
4168 }
4169 
4170 void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {
4171   assert(loader != NULL, &quot;loader must not be NULL&quot;);
4172   assert(oopDesc::is_oop(loader), &quot;loader must be oop&quot;);
4173   HeapAccess&lt;MO_RELEASE&gt;::store_at(loader, _loader_data_offset, new_data);
4174 }
4175 
4176 #define CLASSLOADER_FIELDS_DO(macro) \
4177   macro(parallelCapable_offset, k1, &quot;parallelLockMap&quot;,      concurrenthashmap_signature, false); \
4178   macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \
4179   macro(nameAndId_offset,       k1, &quot;nameAndId&quot;,            string_signature, false); \
4180   macro(unnamedModule_offset,   k1, &quot;unnamedModule&quot;,        module_signature, false); \
4181   macro(parent_offset,          k1, &quot;parent&quot;,               classloader_signature, false)
4182 
4183 void java_lang_ClassLoader::compute_offsets() {
4184   assert(!offsets_computed, &quot;offsets should be initialized only once&quot;);
4185   offsets_computed = true;
4186 
4187   InstanceKlass* k1 = SystemDictionary::ClassLoader_klass();
4188   CLASSLOADER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4189 
4190   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);
4191 }
4192 
4193 #if INCLUDE_CDS
4194 void java_lang_ClassLoader::serialize_offsets(SerializeClosure* f) {
4195   CLASSLOADER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4196   CLASSLOADER_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);
4197 }
4198 #endif
4199 
4200 oop java_lang_ClassLoader::parent(oop loader) {
4201   assert(is_instance(loader), &quot;loader must be oop&quot;);
4202   return loader-&gt;obj_field(parent_offset);
4203 }
4204 
4205 // Returns the name field of this class loader.  If the name field has not
4206 // been set, null will be returned.
4207 oop java_lang_ClassLoader::name(oop loader) {
4208   assert(is_instance(loader), &quot;loader must be oop&quot;);
4209   return loader-&gt;obj_field(name_offset);
4210 }
4211 
4212 // Returns the nameAndId field of this class loader. The format is
4213 // as follows:
4214 //   If the defining loader has a name explicitly set then &#39;&lt;loader-name&gt;&#39; @&lt;id&gt;
4215 //   If the defining loader has no name then &lt;qualified-class-name&gt; @&lt;id&gt;
4216 //   If built-in loader, then omit &#39;@&lt;id&gt;&#39; as there is only one instance.
4217 // Use ClassLoader::loader_name_id() to obtain this String as a char*.
4218 oop java_lang_ClassLoader::nameAndId(oop loader) {
4219   assert(is_instance(loader), &quot;loader must be oop&quot;);
4220   return loader-&gt;obj_field(nameAndId_offset);
4221 }
4222 
4223 bool java_lang_ClassLoader::isAncestor(oop loader, oop cl) {
4224   assert(is_instance(loader), &quot;loader must be oop&quot;);
4225   assert(cl == NULL || is_instance(cl), &quot;cl argument must be oop&quot;);
4226   oop acl = loader;
4227   debug_only(jint loop_count = 0);
4228   // This loop taken verbatim from ClassLoader.java:
4229   do {
4230     acl = parent(acl);
4231     if (cl == acl) {
4232       return true;
4233     }
4234     assert(++loop_count &gt; 0, &quot;loop_count overflow&quot;);
4235   } while (acl != NULL);
4236   return false;
4237 }
4238 
4239 bool java_lang_ClassLoader::is_instance(oop obj) {
4240   return obj != NULL &amp;&amp; is_subclass(obj-&gt;klass());
4241 }
4242 
4243 
4244 // For class loader classes, parallelCapable defined
4245 // based on non-null field
4246 // Written to by java.lang.ClassLoader, vm only reads this field, doesn&#39;t set it
4247 bool java_lang_ClassLoader::parallelCapable(oop class_loader) {
4248   assert(parallelCapable_offset != -1, &quot;offsets should have been initialized&quot;);
4249   return (class_loader-&gt;obj_field(parallelCapable_offset) != NULL);
4250 }
4251 
4252 bool java_lang_ClassLoader::is_trusted_loader(oop loader) {
4253   // Fix for 4474172; see evaluation for more details
4254   loader = non_reflection_class_loader(loader);
4255 
4256   oop cl = SystemDictionary::java_system_loader();
4257   while(cl != NULL) {
4258     if (cl == loader) return true;
4259     cl = parent(cl);
4260   }
4261   return false;
4262 }
4263 
4264 // Return true if this is one of the class loaders associated with
4265 // the generated bytecodes for reflection.
4266 bool java_lang_ClassLoader::is_reflection_class_loader(oop loader) {
4267   if (loader != NULL) {
4268     Klass* delegating_cl_class = SystemDictionary::reflect_DelegatingClassLoader_klass();
4269     // This might be null in non-1.4 JDKs
4270     return (delegating_cl_class != NULL &amp;&amp; loader-&gt;is_a(delegating_cl_class));
4271   }
4272   return false;
4273 }
4274 
4275 oop java_lang_ClassLoader::non_reflection_class_loader(oop loader) {
4276   // See whether this is one of the class loaders associated with
4277   // the generated bytecodes for reflection, and if so, &quot;magically&quot;
4278   // delegate to its parent to prevent class loading from occurring
4279   // in places where applications using reflection didn&#39;t expect it.
4280   if (is_reflection_class_loader(loader)) {
4281     return parent(loader);
4282   }
4283   return loader;
4284 }
4285 
4286 oop java_lang_ClassLoader::unnamedModule(oop loader) {
4287   assert(is_instance(loader), &quot;loader must be oop&quot;);
4288   return loader-&gt;obj_field(unnamedModule_offset);
4289 }
4290 
4291 // Support for java_lang_System
4292 //
4293 #define SYSTEM_FIELDS_DO(macro) \
4294   macro(static_in_offset,  k, &quot;in&quot;,  input_stream_signature, true); \
4295   macro(static_out_offset, k, &quot;out&quot;, print_stream_signature, true); \
4296   macro(static_err_offset, k, &quot;err&quot;, print_stream_signature, true); \
4297   macro(static_security_offset, k, &quot;security&quot;, security_manager_signature, true)
4298 
4299 void java_lang_System::compute_offsets() {
4300   InstanceKlass* k = SystemDictionary::System_klass();
4301   SYSTEM_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4302 }
4303 
4304 #if INCLUDE_CDS
4305 void java_lang_System::serialize_offsets(SerializeClosure* f) {
4306    SYSTEM_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4307 }
4308 #endif
4309 
4310 int java_lang_System::in_offset_in_bytes() { return static_in_offset; }
4311 int java_lang_System::out_offset_in_bytes() { return static_out_offset; }
4312 int java_lang_System::err_offset_in_bytes() { return static_err_offset; }
4313 
4314 // Support for jdk_internal_misc_UnsafeConstants
4315 //
4316 class UnsafeConstantsFixup : public FieldClosure {
4317 private:
4318   int _address_size;
4319   int _page_size;
4320   bool _big_endian;
4321   bool _use_unaligned_access;
4322   int _data_cache_line_flush_size;
4323 public:
4324   UnsafeConstantsFixup() {
4325     // round up values for all static final fields
4326     _address_size = sizeof(void*);
4327     _page_size = os::vm_page_size();
4328     _big_endian = LITTLE_ENDIAN_ONLY(false) BIG_ENDIAN_ONLY(true);
4329     _use_unaligned_access = UseUnalignedAccesses;
4330     _data_cache_line_flush_size = (int)VM_Version::data_cache_line_flush_size();
4331   }
4332 
4333   void do_field(fieldDescriptor* fd) {
4334     oop mirror = fd-&gt;field_holder()-&gt;java_mirror();
4335     assert(mirror != NULL, &quot;UnsafeConstants must have mirror already&quot;);
4336     assert(fd-&gt;field_holder() == SystemDictionary::UnsafeConstants_klass(), &quot;Should be UnsafeConstants&quot;);
4337     assert(fd-&gt;is_final(), &quot;fields of UnsafeConstants must be final&quot;);
4338     assert(fd-&gt;is_static(), &quot;fields of UnsafeConstants must be static&quot;);
4339     if (fd-&gt;name() == vmSymbols::address_size_name()) {
4340       mirror-&gt;int_field_put(fd-&gt;offset(), _address_size);
4341     } else if (fd-&gt;name() == vmSymbols::page_size_name()) {
4342       mirror-&gt;int_field_put(fd-&gt;offset(), _page_size);
4343     } else if (fd-&gt;name() == vmSymbols::big_endian_name()) {
4344       mirror-&gt;bool_field_put(fd-&gt;offset(), _big_endian);
4345     } else if (fd-&gt;name() == vmSymbols::use_unaligned_access_name()) {
4346       mirror-&gt;bool_field_put(fd-&gt;offset(), _use_unaligned_access);
4347     } else if (fd-&gt;name() == vmSymbols::data_cache_line_flush_size_name()) {
4348       mirror-&gt;int_field_put(fd-&gt;offset(), _data_cache_line_flush_size);
4349     } else {
4350       assert(false, &quot;unexpected UnsafeConstants field&quot;);
4351     }
4352   }
4353 };
4354 
4355 void jdk_internal_misc_UnsafeConstants::set_unsafe_constants() {
4356   UnsafeConstantsFixup fixup;
4357   SystemDictionary::UnsafeConstants_klass()-&gt;do_local_static_fields(&amp;fixup);
4358 }
4359 
4360 int java_lang_Class::_klass_offset;
4361 int java_lang_Class::_array_klass_offset;
4362 int java_lang_Class::_oop_size_offset;
4363 int java_lang_Class::_static_oop_field_count_offset;
4364 int java_lang_Class::_class_loader_offset;
4365 int java_lang_Class::_module_offset;
4366 int java_lang_Class::_protection_domain_offset;
4367 int java_lang_Class::_component_mirror_offset;
<a name="14" id="anc14"></a><span class="line-added">4368 int java_lang_Class::_val_type_mirror_offset;</span>
<span class="line-added">4369 int java_lang_Class::_ref_type_mirror_offset;</span>
4370 int java_lang_Class::_init_lock_offset;
4371 int java_lang_Class::_signers_offset;
4372 int java_lang_Class::_name_offset;
4373 int java_lang_Class::_source_file_offset;
4374 int java_lang_Class::_classData_offset;
4375 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_mirror_list = NULL;
4376 GrowableArray&lt;Klass*&gt;* java_lang_Class::_fixup_module_field_list = NULL;
4377 int java_lang_Throwable::backtrace_offset;
4378 int java_lang_Throwable::detailMessage_offset;
4379 int java_lang_Throwable::stackTrace_offset;
4380 int java_lang_Throwable::depth_offset;
4381 int java_lang_Throwable::static_unassigned_stacktrace_offset;
4382 int java_lang_reflect_AccessibleObject::override_offset;
4383 int java_lang_reflect_Method::clazz_offset;
4384 int java_lang_reflect_Method::name_offset;
4385 int java_lang_reflect_Method::returnType_offset;
4386 int java_lang_reflect_Method::parameterTypes_offset;
4387 int java_lang_reflect_Method::exceptionTypes_offset;
4388 int java_lang_reflect_Method::slot_offset;
4389 int java_lang_reflect_Method::modifiers_offset;
4390 int java_lang_reflect_Method::signature_offset;
4391 int java_lang_reflect_Method::annotations_offset;
4392 int java_lang_reflect_Method::parameter_annotations_offset;
4393 int java_lang_reflect_Method::annotation_default_offset;
4394 int java_lang_reflect_Constructor::clazz_offset;
4395 int java_lang_reflect_Constructor::parameterTypes_offset;
4396 int java_lang_reflect_Constructor::exceptionTypes_offset;
4397 int java_lang_reflect_Constructor::slot_offset;
4398 int java_lang_reflect_Constructor::modifiers_offset;
4399 int java_lang_reflect_Constructor::signature_offset;
4400 int java_lang_reflect_Constructor::annotations_offset;
4401 int java_lang_reflect_Constructor::parameter_annotations_offset;
4402 int java_lang_reflect_Field::clazz_offset;
4403 int java_lang_reflect_Field::name_offset;
4404 int java_lang_reflect_Field::type_offset;
4405 int java_lang_reflect_Field::slot_offset;
4406 int java_lang_reflect_Field::modifiers_offset;
4407 int java_lang_reflect_Field::signature_offset;
4408 int java_lang_reflect_Field::annotations_offset;
4409 int java_lang_reflect_Parameter::name_offset;
4410 int java_lang_reflect_Parameter::modifiers_offset;
4411 int java_lang_reflect_Parameter::index_offset;
4412 int java_lang_reflect_Parameter::executable_offset;
4413 int java_lang_boxing_object::value_offset;
4414 int java_lang_boxing_object::long_value_offset;
4415 int java_lang_ref_Reference::referent_offset;
4416 int java_lang_ref_Reference::queue_offset;
4417 int java_lang_ref_Reference::next_offset;
4418 int java_lang_ref_Reference::discovered_offset;
4419 int java_lang_ref_SoftReference::timestamp_offset;
4420 int java_lang_ref_SoftReference::static_clock_offset;
4421 int java_lang_ClassLoader::parent_offset;
4422 int java_lang_System::static_in_offset;
4423 int java_lang_System::static_out_offset;
4424 int java_lang_System::static_err_offset;
4425 int java_lang_System::static_security_offset;
4426 int java_lang_StackTraceElement::methodName_offset;
4427 int java_lang_StackTraceElement::fileName_offset;
4428 int java_lang_StackTraceElement::lineNumber_offset;
4429 int java_lang_StackTraceElement::moduleName_offset;
4430 int java_lang_StackTraceElement::moduleVersion_offset;
4431 int java_lang_StackTraceElement::classLoaderName_offset;
4432 int java_lang_StackTraceElement::declaringClass_offset;
4433 int java_lang_StackTraceElement::declaringClassObject_offset;
4434 int java_lang_StackFrameInfo::_memberName_offset;
4435 int java_lang_StackFrameInfo::_bci_offset;
4436 int java_lang_StackFrameInfo::_version_offset;
4437 int java_lang_LiveStackFrameInfo::_monitors_offset;
4438 int java_lang_LiveStackFrameInfo::_locals_offset;
4439 int java_lang_LiveStackFrameInfo::_operands_offset;
4440 int java_lang_LiveStackFrameInfo::_mode_offset;
4441 int java_lang_AssertionStatusDirectives::classes_offset;
4442 int java_lang_AssertionStatusDirectives::classEnabled_offset;
4443 int java_lang_AssertionStatusDirectives::packages_offset;
4444 int java_lang_AssertionStatusDirectives::packageEnabled_offset;
4445 int java_lang_AssertionStatusDirectives::deflt_offset;
4446 int java_nio_Buffer::_limit_offset;
4447 int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;
4448 int reflect_ConstantPool::_oop_offset;
4449 int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;
4450 int java_lang_Integer_IntegerCache::_static_cache_offset;
4451 int java_lang_Long_LongCache::_static_cache_offset;
4452 int java_lang_Character_CharacterCache::_static_cache_offset;
4453 int java_lang_Short_ShortCache::_static_cache_offset;
4454 int java_lang_Byte_ByteCache::_static_cache_offset;
4455 int java_lang_Boolean::_static_TRUE_offset;
4456 int java_lang_Boolean::_static_FALSE_offset;
4457 int java_lang_reflect_RecordComponent::clazz_offset;
4458 int java_lang_reflect_RecordComponent::name_offset;
4459 int java_lang_reflect_RecordComponent::type_offset;
4460 int java_lang_reflect_RecordComponent::accessor_offset;
4461 int java_lang_reflect_RecordComponent::signature_offset;
4462 int java_lang_reflect_RecordComponent::annotations_offset;
4463 int java_lang_reflect_RecordComponent::typeAnnotations_offset;
<a name="15" id="anc15"></a><span class="line-added">4464 int jdk_internal_vm_jni_SubElementSelector::_arrayElementType_offset;</span>
<span class="line-added">4465 int jdk_internal_vm_jni_SubElementSelector::_subElementType_offset;</span>
<span class="line-added">4466 int jdk_internal_vm_jni_SubElementSelector::_offset_offset;</span>
<span class="line-added">4467 int jdk_internal_vm_jni_SubElementSelector::_isFlattened_offset;</span>
<span class="line-added">4468 int jdk_internal_vm_jni_SubElementSelector::_isFlattenable_offset;</span>
4469 
4470 
4471 
4472 #define STACKTRACEELEMENT_FIELDS_DO(macro) \
4473   macro(declaringClassObject_offset,  k, &quot;declaringClassObject&quot;, class_signature, false); \
4474   macro(classLoaderName_offset, k, &quot;classLoaderName&quot;, string_signature, false); \
4475   macro(moduleName_offset,      k, &quot;moduleName&quot;,      string_signature, false); \
4476   macro(moduleVersion_offset,   k, &quot;moduleVersion&quot;,   string_signature, false); \
4477   macro(declaringClass_offset,  k, &quot;declaringClass&quot;,  string_signature, false); \
4478   macro(methodName_offset,      k, &quot;methodName&quot;,      string_signature, false); \
4479   macro(fileName_offset,        k, &quot;fileName&quot;,        string_signature, false); \
4480   macro(lineNumber_offset,      k, &quot;lineNumber&quot;,      int_signature,    false)
4481 
4482 // Support for java_lang_StackTraceElement
4483 void java_lang_StackTraceElement::compute_offsets() {
4484   InstanceKlass* k = SystemDictionary::StackTraceElement_klass();
4485   STACKTRACEELEMENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4486 }
4487 
4488 #if INCLUDE_CDS
4489 void java_lang_StackTraceElement::serialize_offsets(SerializeClosure* f) {
4490   STACKTRACEELEMENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4491 }
4492 #endif
4493 
4494 void java_lang_StackTraceElement::set_fileName(oop element, oop value) {
4495   element-&gt;obj_field_put(fileName_offset, value);
4496 }
4497 
4498 void java_lang_StackTraceElement::set_declaringClass(oop element, oop value) {
4499   element-&gt;obj_field_put(declaringClass_offset, value);
4500 }
4501 
4502 void java_lang_StackTraceElement::set_methodName(oop element, oop value) {
4503   element-&gt;obj_field_put(methodName_offset, value);
4504 }
4505 
4506 void java_lang_StackTraceElement::set_lineNumber(oop element, int value) {
4507   element-&gt;int_field_put(lineNumber_offset, value);
4508 }
4509 
4510 void java_lang_StackTraceElement::set_moduleName(oop element, oop value) {
4511   element-&gt;obj_field_put(moduleName_offset, value);
4512 }
4513 
4514 void java_lang_StackTraceElement::set_moduleVersion(oop element, oop value) {
4515   element-&gt;obj_field_put(moduleVersion_offset, value);
4516 }
4517 
4518 void java_lang_StackTraceElement::set_classLoaderName(oop element, oop value) {
4519   element-&gt;obj_field_put(classLoaderName_offset, value);
4520 }
4521 
4522 void java_lang_StackTraceElement::set_declaringClassObject(oop element, oop value) {
4523   element-&gt;obj_field_put(declaringClassObject_offset, value);
4524 }
4525 
4526 void java_lang_StackFrameInfo::set_version(oop element, short value) {
4527   element-&gt;short_field_put(_version_offset, value);
4528 }
4529 
4530 void java_lang_StackFrameInfo::set_bci(oop element, int value) {
4531   assert(value &gt;= 0 &amp;&amp; value &lt; max_jushort, &quot;must be a valid bci value&quot;);
4532   element-&gt;int_field_put(_bci_offset, value);
4533 }
4534 
4535 void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {
4536   element-&gt;obj_field_put(_monitors_offset, value);
4537 }
4538 
4539 void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {
4540   element-&gt;obj_field_put(_locals_offset, value);
4541 }
4542 
4543 void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {
4544   element-&gt;obj_field_put(_operands_offset, value);
4545 }
4546 
4547 void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {
4548   element-&gt;int_field_put(_mode_offset, value);
4549 }
4550 
4551 // Support for java Assertions - java_lang_AssertionStatusDirectives.
4552 #define ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(macro) \
4553   macro(classes_offset,        k, &quot;classes&quot;,        string_array_signature, false); \
4554   macro(classEnabled_offset,   k, &quot;classEnabled&quot;,   bool_array_signature, false); \
4555   macro(packages_offset,       k, &quot;packages&quot;,       string_array_signature, false); \
4556   macro(packageEnabled_offset, k, &quot;packageEnabled&quot;, bool_array_signature,   false); \
4557   macro(deflt_offset,          k, &quot;deflt&quot;,          bool_signature,         false)
4558 
4559 void java_lang_AssertionStatusDirectives::compute_offsets() {
4560   InstanceKlass* k = SystemDictionary::AssertionStatusDirectives_klass();
4561   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4562 }
4563 
4564 #if INCLUDE_CDS
4565 void java_lang_AssertionStatusDirectives::serialize_offsets(SerializeClosure* f) {
4566   ASSERTIONSTATUSDIRECTIVES_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4567 }
4568 #endif
4569 
4570 void java_lang_AssertionStatusDirectives::set_classes(oop o, oop val) {
4571   o-&gt;obj_field_put(classes_offset, val);
4572 }
4573 
4574 void java_lang_AssertionStatusDirectives::set_classEnabled(oop o, oop val) {
4575   o-&gt;obj_field_put(classEnabled_offset, val);
4576 }
4577 
4578 void java_lang_AssertionStatusDirectives::set_packages(oop o, oop val) {
4579   o-&gt;obj_field_put(packages_offset, val);
4580 }
4581 
4582 void java_lang_AssertionStatusDirectives::set_packageEnabled(oop o, oop val) {
4583   o-&gt;obj_field_put(packageEnabled_offset, val);
4584 }
4585 
4586 void java_lang_AssertionStatusDirectives::set_deflt(oop o, bool val) {
4587   o-&gt;bool_field_put(deflt_offset, val);
4588 }
4589 
4590 
4591 // Support for intrinsification of java.nio.Buffer.checkIndex
4592 int java_nio_Buffer::limit_offset() {
4593   return _limit_offset;
4594 }
4595 
4596 #define BUFFER_FIELDS_DO(macro) \
4597   macro(_limit_offset, k, &quot;limit&quot;, int_signature, false)
4598 
4599 void java_nio_Buffer::compute_offsets() {
4600   InstanceKlass* k = SystemDictionary::nio_Buffer_klass();
4601   assert(k != NULL, &quot;must be loaded in 1.4+&quot;);
4602   BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4603 }
4604 
4605 #if INCLUDE_CDS
4606 void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {
4607   BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4608 }
4609 #endif
4610 
4611 #define AOS_FIELDS_DO(macro) \
4612   macro(_owner_offset, k, &quot;exclusiveOwnerThread&quot;, thread_signature, false)
4613 
4614 void java_util_concurrent_locks_AbstractOwnableSynchronizer::compute_offsets() {
4615   InstanceKlass* k = SystemDictionary::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass();
4616   AOS_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4617 }
4618 
4619 oop java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(oop obj) {
4620   assert(_owner_offset != 0, &quot;Must be initialized&quot;);
4621   return obj-&gt;obj_field(_owner_offset);
4622 }
4623 
4624 #if INCLUDE_CDS
4625 void java_util_concurrent_locks_AbstractOwnableSynchronizer::serialize_offsets(SerializeClosure* f) {
4626   AOS_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4627 }
4628 #endif
4629 
4630 #define INTEGER_CACHE_FIELDS_DO(macro) \
4631   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Integer_array_signature, true)
4632 
4633 void java_lang_Integer_IntegerCache::compute_offsets(InstanceKlass *k) {
4634   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4635   INTEGER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4636 }
4637 
4638 objArrayOop java_lang_Integer_IntegerCache::cache(InstanceKlass *ik) {
4639   oop base = ik-&gt;static_field_base_raw();
4640   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4641 }
4642 
4643 Symbol* java_lang_Integer_IntegerCache::symbol() {
4644   return vmSymbols::java_lang_Integer_IntegerCache();
4645 }
4646 
4647 #if INCLUDE_CDS
4648 void java_lang_Integer_IntegerCache::serialize_offsets(SerializeClosure* f) {
4649   INTEGER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4650 }
4651 #endif
4652 #undef INTEGER_CACHE_FIELDS_DO
4653 
4654 jint java_lang_Integer::value(oop obj) {
4655    jvalue v;
4656    java_lang_boxing_object::get_value(obj, &amp;v);
4657    return v.i;
4658 }
4659 
4660 #define LONG_CACHE_FIELDS_DO(macro) \
4661   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Long_array_signature, true)
4662 
4663 void java_lang_Long_LongCache::compute_offsets(InstanceKlass *k) {
4664   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4665   LONG_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4666 }
4667 
4668 objArrayOop java_lang_Long_LongCache::cache(InstanceKlass *ik) {
4669   oop base = ik-&gt;static_field_base_raw();
4670   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4671 }
4672 
4673 Symbol* java_lang_Long_LongCache::symbol() {
4674   return vmSymbols::java_lang_Long_LongCache();
4675 }
4676 
4677 #if INCLUDE_CDS
4678 void java_lang_Long_LongCache::serialize_offsets(SerializeClosure* f) {
4679   LONG_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4680 }
4681 #endif
4682 #undef LONG_CACHE_FIELDS_DO
4683 
4684 jlong java_lang_Long::value(oop obj) {
4685    jvalue v;
4686    java_lang_boxing_object::get_value(obj, &amp;v);
4687    return v.j;
4688 }
4689 
4690 #define CHARACTER_CACHE_FIELDS_DO(macro) \
4691   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Character_array_signature, true)
4692 
4693 void java_lang_Character_CharacterCache::compute_offsets(InstanceKlass *k) {
4694   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4695   CHARACTER_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4696 }
4697 
4698 objArrayOop java_lang_Character_CharacterCache::cache(InstanceKlass *ik) {
4699   oop base = ik-&gt;static_field_base_raw();
4700   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4701 }
4702 
4703 Symbol* java_lang_Character_CharacterCache::symbol() {
4704   return vmSymbols::java_lang_Character_CharacterCache();
4705 }
4706 
4707 #if INCLUDE_CDS
4708 void java_lang_Character_CharacterCache::serialize_offsets(SerializeClosure* f) {
4709   CHARACTER_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4710 }
4711 #endif
4712 #undef CHARACTER_CACHE_FIELDS_DO
4713 
4714 jchar java_lang_Character::value(oop obj) {
4715    jvalue v;
4716    java_lang_boxing_object::get_value(obj, &amp;v);
4717    return v.c;
4718 }
4719 
4720 #define SHORT_CACHE_FIELDS_DO(macro) \
4721   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Short_array_signature, true)
4722 
4723 void java_lang_Short_ShortCache::compute_offsets(InstanceKlass *k) {
4724   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4725   SHORT_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4726 }
4727 
4728 objArrayOop java_lang_Short_ShortCache::cache(InstanceKlass *ik) {
4729   oop base = ik-&gt;static_field_base_raw();
4730   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4731 }
4732 
4733 Symbol* java_lang_Short_ShortCache::symbol() {
4734   return vmSymbols::java_lang_Short_ShortCache();
4735 }
4736 
4737 #if INCLUDE_CDS
4738 void java_lang_Short_ShortCache::serialize_offsets(SerializeClosure* f) {
4739   SHORT_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4740 }
4741 #endif
4742 #undef SHORT_CACHE_FIELDS_DO
4743 
4744 jshort java_lang_Short::value(oop obj) {
4745    jvalue v;
4746    java_lang_boxing_object::get_value(obj, &amp;v);
4747    return v.s;
4748 }
4749 
4750 #define BYTE_CACHE_FIELDS_DO(macro) \
4751   macro(_static_cache_offset, k, &quot;cache&quot;, java_lang_Byte_array_signature, true)
4752 
4753 void java_lang_Byte_ByteCache::compute_offsets(InstanceKlass *k) {
4754   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4755   BYTE_CACHE_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4756 }
4757 
4758 objArrayOop java_lang_Byte_ByteCache::cache(InstanceKlass *ik) {
4759   oop base = ik-&gt;static_field_base_raw();
4760   return objArrayOop(base-&gt;obj_field(_static_cache_offset));
4761 }
4762 
4763 Symbol* java_lang_Byte_ByteCache::symbol() {
4764   return vmSymbols::java_lang_Byte_ByteCache();
4765 }
4766 
4767 #if INCLUDE_CDS
4768 void java_lang_Byte_ByteCache::serialize_offsets(SerializeClosure* f) {
4769   BYTE_CACHE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4770 }
4771 #endif
4772 #undef BYTE_CACHE_FIELDS_DO
4773 
<a name="16" id="anc16"></a><span class="line-added">4774 #define SUBELEMENT_SELECTOR_FIELDS_DO(macro) \</span>
<span class="line-added">4775   macro(_arrayElementType_offset,  k, &quot;arrayElementType&quot;, class_signature, false); \</span>
<span class="line-added">4776   macro(_subElementType_offset,    k, &quot;subElementType&quot;,   class_signature, false); \</span>
<span class="line-added">4777   macro(_offset_offset,            k, &quot;offset&quot;,           int_signature,   false); \</span>
<span class="line-added">4778   macro(_isFlattened_offset,       k, &quot;isFlattened&quot;,      bool_signature,  false); \</span>
<span class="line-added">4779   macro(_isFlattenable_offset,     k, &quot;isFlattenable&quot;,    bool_signature,  false);</span>
<span class="line-added">4780 </span>
<span class="line-added">4781 void jdk_internal_vm_jni_SubElementSelector::compute_offsets() {</span>
<span class="line-added">4782   InstanceKlass* k = SystemDictionary::jdk_internal_vm_jni_SubElementSelector_klass();</span>
<span class="line-added">4783   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_COMPUTE_OFFSET);</span>
<span class="line-added">4784 }</span>
<span class="line-added">4785 </span>
<span class="line-added">4786 #if INCLUDE_CDS</span>
<span class="line-added">4787 void jdk_internal_vm_jni_SubElementSelector::serialize_offsets(SerializeClosure* f) {</span>
<span class="line-added">4788   SUBELEMENT_SELECTOR_FIELDS_DO(FIELD_SERIALIZE_OFFSET);</span>
<span class="line-added">4789 }</span>
<span class="line-added">4790 #endif</span>
<span class="line-added">4791 #undef SUBELEMENT_SELECTOR_FIELDS_DO</span>
<span class="line-added">4792 </span>
<span class="line-added">4793 Symbol* jdk_internal_vm_jni_SubElementSelector::symbol() {</span>
<span class="line-added">4794   return vmSymbols::jdk_internal_vm_jni_SubElementSelector();</span>
<span class="line-added">4795 }</span>
<span class="line-added">4796 </span>
<span class="line-added">4797 oop jdk_internal_vm_jni_SubElementSelector::getArrayElementType(oop obj) {</span>
<span class="line-added">4798   return obj-&gt;obj_field(_arrayElementType_offset);</span>
<span class="line-added">4799 }</span>
<span class="line-added">4800 </span>
<span class="line-added">4801 void jdk_internal_vm_jni_SubElementSelector::setArrayElementType(oop obj, oop type) {</span>
<span class="line-added">4802   obj-&gt;obj_field_put(_arrayElementType_offset, type);</span>
<span class="line-added">4803 }</span>
<span class="line-added">4804 </span>
<span class="line-added">4805 oop jdk_internal_vm_jni_SubElementSelector::getSubElementType(oop obj) {</span>
<span class="line-added">4806   return obj-&gt;obj_field(_subElementType_offset);</span>
<span class="line-added">4807 }</span>
<span class="line-added">4808 </span>
<span class="line-added">4809 void jdk_internal_vm_jni_SubElementSelector::setSubElementType(oop obj, oop type) {</span>
<span class="line-added">4810   obj-&gt;obj_field_put(_subElementType_offset, type);</span>
<span class="line-added">4811 }</span>
<span class="line-added">4812 </span>
<span class="line-added">4813 int jdk_internal_vm_jni_SubElementSelector::getOffset(oop obj) {</span>
<span class="line-added">4814   return obj-&gt;int_field(_offset_offset);</span>
<span class="line-added">4815 }</span>
<span class="line-added">4816 </span>
<span class="line-added">4817 void jdk_internal_vm_jni_SubElementSelector::setOffset(oop obj, int offset) {</span>
<span class="line-added">4818   obj-&gt;int_field_put(_offset_offset, offset);</span>
<span class="line-added">4819 }</span>
<span class="line-added">4820 </span>
<span class="line-added">4821 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattened(oop obj) {</span>
<span class="line-added">4822   return obj-&gt;bool_field(_isFlattened_offset);</span>
<span class="line-added">4823 }</span>
<span class="line-added">4824 </span>
<span class="line-added">4825 void jdk_internal_vm_jni_SubElementSelector::setIsFlattened(oop obj, bool b) {</span>
<span class="line-added">4826   obj-&gt;bool_field_put(_isFlattened_offset, b);</span>
<span class="line-added">4827 }</span>
<span class="line-added">4828 </span>
<span class="line-added">4829 bool jdk_internal_vm_jni_SubElementSelector::getIsFlattenable(oop obj) {</span>
<span class="line-added">4830   return obj-&gt;bool_field(_isFlattenable_offset);</span>
<span class="line-added">4831 }</span>
<span class="line-added">4832 </span>
<span class="line-added">4833 void jdk_internal_vm_jni_SubElementSelector::setIsFlattenable(oop obj, bool b) {</span>
<span class="line-added">4834   obj-&gt;bool_field_put(_isFlattenable_offset, b);</span>
<span class="line-added">4835 }</span>
<span class="line-added">4836 </span>
4837 jbyte java_lang_Byte::value(oop obj) {
4838    jvalue v;
4839    java_lang_boxing_object::get_value(obj, &amp;v);
4840    return v.b;
4841 }
4842 #define BOOLEAN_FIELDS_DO(macro) \
4843   macro(_static_TRUE_offset, k, &quot;TRUE&quot;, java_lang_Boolean_signature, true); \
4844   macro(_static_FALSE_offset, k, &quot;FALSE&quot;, java_lang_Boolean_signature, true)
4845 
4846 
4847 void java_lang_Boolean::compute_offsets(InstanceKlass *k) {
4848   guarantee(k != NULL &amp;&amp; k-&gt;is_initialized(), &quot;must be loaded and initialized&quot;);
4849   BOOLEAN_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4850 }
4851 
4852 oop java_lang_Boolean::get_TRUE(InstanceKlass *ik) {
4853   oop base = ik-&gt;static_field_base_raw();
4854   return base-&gt;obj_field(_static_TRUE_offset);
4855 }
4856 
4857 oop java_lang_Boolean::get_FALSE(InstanceKlass *ik) {
4858   oop base = ik-&gt;static_field_base_raw();
4859   return base-&gt;obj_field(_static_FALSE_offset);
4860 }
4861 
4862 Symbol* java_lang_Boolean::symbol() {
4863   return vmSymbols::java_lang_Boolean();
4864 }
4865 
4866 #if INCLUDE_CDS
4867 void java_lang_Boolean::serialize_offsets(SerializeClosure* f) {
4868   BOOLEAN_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4869 }
4870 #endif
4871 #undef BOOLEAN_CACHE_FIELDS_DO
4872 
4873 jboolean java_lang_Boolean::value(oop obj) {
4874    jvalue v;
4875    java_lang_boxing_object::get_value(obj, &amp;v);
4876    return v.z;
4877 }
4878 
4879 static int member_offset(int hardcoded_offset) {
4880   return (hardcoded_offset * heapOopSize) + instanceOopDesc::base_offset_in_bytes();
4881 }
4882 
4883 #define RECORDCOMPONENT_FIELDS_DO(macro) \
4884   macro(clazz_offset,       k, &quot;clazz&quot;,       class_signature,  false); \
4885   macro(name_offset,        k, &quot;name&quot;,        string_signature, false); \
4886   macro(type_offset,        k, &quot;type&quot;,        class_signature,  false); \
4887   macro(accessor_offset,    k, &quot;accessor&quot;,    reflect_method_signature, false); \
4888   macro(signature_offset,   k, &quot;signature&quot;,   string_signature, false); \
4889   macro(annotations_offset, k, &quot;annotations&quot;, byte_array_signature,     false); \
4890   macro(typeAnnotations_offset, k, &quot;typeAnnotations&quot;, byte_array_signature, false);
4891 
4892 // Support for java_lang_reflect_RecordComponent
4893 void java_lang_reflect_RecordComponent::compute_offsets() {
4894   InstanceKlass* k = SystemDictionary::RecordComponent_klass();
4895   RECORDCOMPONENT_FIELDS_DO(FIELD_COMPUTE_OFFSET);
4896 }
4897 
4898 #if INCLUDE_CDS
4899 void java_lang_reflect_RecordComponent::serialize_offsets(SerializeClosure* f) {
4900   RECORDCOMPONENT_FIELDS_DO(FIELD_SERIALIZE_OFFSET);
4901 }
4902 #endif
4903 
4904 void java_lang_reflect_RecordComponent::set_clazz(oop element, oop value) {
4905   element-&gt;obj_field_put(clazz_offset, value);
4906 }
4907 
4908 void java_lang_reflect_RecordComponent::set_name(oop element, oop value) {
4909   element-&gt;obj_field_put(name_offset, value);
4910 }
4911 
4912 void java_lang_reflect_RecordComponent::set_type(oop element, oop value) {
4913   element-&gt;obj_field_put(type_offset, value);
4914 }
4915 
4916 void java_lang_reflect_RecordComponent::set_accessor(oop element, oop value) {
4917   element-&gt;obj_field_put(accessor_offset, value);
4918 }
4919 
4920 void java_lang_reflect_RecordComponent::set_signature(oop element, oop value) {
4921   element-&gt;obj_field_put(signature_offset, value);
4922 }
4923 
4924 void java_lang_reflect_RecordComponent::set_annotations(oop element, oop value) {
4925   element-&gt;obj_field_put(annotations_offset, value);
4926 }
4927 
4928 void java_lang_reflect_RecordComponent::set_typeAnnotations(oop element, oop value) {
4929   element-&gt;obj_field_put(typeAnnotations_offset, value);
4930 }
4931 
4932 // Compute hard-coded offsets
4933 // Invoked before SystemDictionary::initialize, so pre-loaded classes
4934 // are not available to determine the offset_of_static_fields.
4935 void JavaClasses::compute_hard_coded_offsets() {
4936 
4937   // java_lang_boxing_object
4938   java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);
4939   java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);
4940 
4941   // java_lang_ref_Reference
4942   java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);
4943   java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);
4944   java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);
4945   java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);
4946 }
4947 
4948 #define DO_COMPUTE_OFFSETS(k) k::compute_offsets();
4949 
4950 // Compute non-hard-coded field offsets of all the classes in this file
4951 void JavaClasses::compute_offsets() {
4952   if (UseSharedSpaces) {
4953     JVMTI_ONLY(assert(JvmtiExport::is_early_phase() &amp;&amp; !(JvmtiExport::should_post_class_file_load_hook() &amp;&amp;
4954                                                          JvmtiExport::has_early_class_hook_env()),
4955                       &quot;JavaClasses::compute_offsets() must be called in early JVMTI phase.&quot;));
4956     // None of the classes used by the rest of this function can be replaced by
4957     // JMVTI ClassFileLoadHook.
4958     // We are safe to use the archived offsets, which have already been restored
4959     // by JavaClasses::serialize_offsets, without computing the offsets again.
4960     return;
4961   }
4962 
4963   // We have already called the compute_offsets() of the
4964   // BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)
4965   // earlier inside SystemDictionary::resolve_well_known_classes()
4966   BASIC_JAVA_CLASSES_DO_PART2(DO_COMPUTE_OFFSETS);
4967 }
4968 
4969 #if INCLUDE_CDS
4970 #define DO_SERIALIZE_OFFSETS(k) k::serialize_offsets(soc);
4971 
4972 void JavaClasses::serialize_offsets(SerializeClosure* soc) {
4973   BASIC_JAVA_CLASSES_DO(DO_SERIALIZE_OFFSETS);
4974 }
4975 #endif
4976 
4977 #if INCLUDE_CDS_JAVA_HEAP
4978 bool JavaClasses::is_supported_for_archiving(oop obj) {
4979   Klass* klass = obj-&gt;klass();
4980 
4981   if (klass == SystemDictionary::ClassLoader_klass() ||  // ClassLoader::loader_data is malloc&#39;ed.
4982       klass == SystemDictionary::Module_klass() ||       // Module::module_entry is malloc&#39;ed
4983       // The next 3 classes are used to implement java.lang.invoke, and are not used directly in
4984       // regular Java code. The implementation of java.lang.invoke uses generated anonymoys classes
4985       // (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.
4986       // So for now we cannot not support these classes for archiving.
4987       //
4988       // These objects typically are not referenced by static fields, but rather by resolved
4989       // constant pool entries, so excluding them shouldn&#39;t affect the archiving of static fields.
4990       klass == SystemDictionary::ResolvedMethodName_klass() ||
4991       klass == SystemDictionary::MemberName_klass() ||
4992       klass == SystemDictionary::Context_klass()) {
4993     return false;
4994   }
4995 
4996   return true;
4997 }
4998 #endif
4999 
5000 #ifndef PRODUCT
5001 
5002 // These functions exist to assert the validity of hard-coded field offsets to guard
5003 // against changes in the class files
5004 
5005 bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {
5006   EXCEPTION_MARK;
5007   fieldDescriptor fd;
5008   TempNewSymbol klass_sym = SymbolTable::new_symbol(klass_name);
5009   Klass* k = SystemDictionary::resolve_or_fail(klass_sym, true, CATCH);
5010   InstanceKlass* ik = InstanceKlass::cast(k);
5011   TempNewSymbol f_name = SymbolTable::new_symbol(field_name);
5012   TempNewSymbol f_sig  = SymbolTable::new_symbol(field_sig);
5013   if (!ik-&gt;find_local_field(f_name, f_sig, &amp;fd)) {
5014     tty-&gt;print_cr(&quot;Nonstatic field %s.%s not found&quot;, klass_name, field_name);
5015     return false;
5016   }
5017   if (fd.is_static()) {
5018     tty-&gt;print_cr(&quot;Nonstatic field %s.%s appears to be static&quot;, klass_name, field_name);
5019     return false;
5020   }
5021   if (fd.offset() == hardcoded_offset ) {
5022     return true;
5023   } else {
5024     tty-&gt;print_cr(&quot;Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.&quot;,
5025                   klass_name, field_name, hardcoded_offset, fd.offset());
5026     return false;
5027   }
5028 }
5029 
5030 // Check the hard-coded field offsets of all the classes in this file
5031 
5032 void JavaClasses::check_offsets() {
5033   bool valid = true;
5034 
5035 #define CHECK_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5036   valid &amp;= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)
5037 
5038 #define CHECK_LONG_OFFSET(klass_name, cpp_klass_name, field_name, field_sig) \
5039   valid &amp;= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)
5040 
5041   // Boxed primitive objects (java_lang_boxing_object)
5042 
5043   CHECK_OFFSET(&quot;java/lang/Boolean&quot;,   java_lang_boxing_object, value, &quot;Z&quot;);
5044   CHECK_OFFSET(&quot;java/lang/Character&quot;, java_lang_boxing_object, value, &quot;C&quot;);
5045   CHECK_OFFSET(&quot;java/lang/Float&quot;,     java_lang_boxing_object, value, &quot;F&quot;);
5046   CHECK_LONG_OFFSET(&quot;java/lang/Double&quot;, java_lang_boxing_object, value, &quot;D&quot;);
5047   CHECK_OFFSET(&quot;java/lang/Byte&quot;,      java_lang_boxing_object, value, &quot;B&quot;);
5048   CHECK_OFFSET(&quot;java/lang/Short&quot;,     java_lang_boxing_object, value, &quot;S&quot;);
5049   CHECK_OFFSET(&quot;java/lang/Integer&quot;,   java_lang_boxing_object, value, &quot;I&quot;);
5050   CHECK_LONG_OFFSET(&quot;java/lang/Long&quot;, java_lang_boxing_object, value, &quot;J&quot;);
5051 
5052   // java.lang.ref.Reference
5053 
5054   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, referent, &quot;Ljava/lang/Object;&quot;);
5055   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, queue, &quot;Ljava/lang/ref/ReferenceQueue;&quot;);
5056   CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, next, &quot;Ljava/lang/ref/Reference;&quot;);
5057   // Fake field
5058   //CHECK_OFFSET(&quot;java/lang/ref/Reference&quot;, java_lang_ref_Reference, discovered, &quot;Ljava/lang/ref/Reference;&quot;);
5059 
5060   if (!valid) vm_exit_during_initialization(&quot;Hard-coded field offset verification failed&quot;);
5061 }
5062 
5063 #endif // PRODUCT
5064 
5065 int InjectedField::compute_offset() {
5066   InstanceKlass* ik = InstanceKlass::cast(klass());
5067   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5068     if (!may_be_java &amp;&amp; !fs.access_flags().is_internal()) {
5069       // Only look at injected fields
5070       continue;
5071     }
5072     if (fs.name() == name() &amp;&amp; fs.signature() == signature()) {
5073       return fs.offset();
5074     }
5075   }
5076   ResourceMark rm;
5077   tty-&gt;print_cr(&quot;Invalid layout of %s at %s/%s%s&quot;, ik-&gt;external_name(), name()-&gt;as_C_string(), signature()-&gt;as_C_string(), may_be_java ? &quot; (may_be_java)&quot; : &quot;&quot;);
5078 #ifndef PRODUCT
5079   ik-&gt;print();
5080   tty-&gt;print_cr(&quot;all fields:&quot;);
5081   for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
5082     tty-&gt;print_cr(&quot;  name: %s, sig: %s, flags: %08x&quot;, fs.name()-&gt;as_C_string(), fs.signature()-&gt;as_C_string(), fs.access_flags().as_int());
5083   }
5084 #endif //PRODUCT
5085   vm_exit_during_initialization(&quot;Invalid layout of well-known class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
5086   return -1;
5087 }
5088 
5089 void javaClasses_init() {
5090   JavaClasses::compute_offsets();
5091   JavaClasses::check_offsets();
5092   FilteredFieldsMap::initialize();  // must be done after computing offsets.
5093 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
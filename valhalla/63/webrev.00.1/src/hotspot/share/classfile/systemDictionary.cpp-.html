<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;gc/shared/oopStorage.inline.hpp&quot;
  50 #include &quot;gc/shared/oopStorageSet.hpp&quot;
  51 #include &quot;interpreter/bytecodeStream.hpp&quot;
  52 #include &quot;interpreter/interpreter.hpp&quot;
  53 #include &quot;jfr/jfrEvents.hpp&quot;
  54 #include &quot;logging/log.hpp&quot;
  55 #include &quot;logging/logStream.hpp&quot;
  56 #include &quot;memory/filemap.hpp&quot;
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/access.inline.hpp&quot;
  63 #include &quot;oops/instanceKlass.hpp&quot;
  64 #include &quot;oops/instanceRefKlass.hpp&quot;
  65 #include &quot;oops/klass.inline.hpp&quot;
  66 #include &quot;oops/method.inline.hpp&quot;
  67 #include &quot;oops/methodData.hpp&quot;
  68 #include &quot;oops/objArrayKlass.hpp&quot;
  69 #include &quot;oops/objArrayOop.inline.hpp&quot;
  70 #include &quot;oops/oop.inline.hpp&quot;
  71 #include &quot;oops/symbol.hpp&quot;
  72 #include &quot;oops/typeArrayKlass.hpp&quot;
  73 #include &quot;prims/jvmtiExport.hpp&quot;
  74 #include &quot;prims/methodHandles.hpp&quot;
  75 #include &quot;runtime/arguments.hpp&quot;
  76 #include &quot;runtime/biasedLocking.hpp&quot;
  77 #include &quot;runtime/handles.inline.hpp&quot;
  78 #include &quot;runtime/java.hpp&quot;
  79 #include &quot;runtime/javaCalls.hpp&quot;
  80 #include &quot;runtime/mutexLocker.hpp&quot;
  81 #include &quot;runtime/sharedRuntime.hpp&quot;
  82 #include &quot;runtime/signature.hpp&quot;
  83 #include &quot;services/classLoadingService.hpp&quot;
  84 #include &quot;services/diagnosticCommand.hpp&quot;
  85 #include &quot;services/threadService.hpp&quot;
  86 #include &quot;utilities/macros.hpp&quot;
  87 #if INCLUDE_CDS
  88 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  89 #endif
  90 #if INCLUDE_JFR
  91 #include &quot;jfr/jfr.hpp&quot;
  92 #endif
  93 
  94 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  95 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  96 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
  97 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
  98 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
  99 
 100 oop         SystemDictionary::_system_loader_lock_obj     =  NULL;
 101 
 102 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 103                                                           =  { NULL /*, NULL...*/ };
 104 
 105 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 106 
 107 oop         SystemDictionary::_java_system_loader         =  NULL;
 108 oop         SystemDictionary::_java_platform_loader       =  NULL;
 109 
 110 // Default ProtectionDomainCacheSize value
 111 
 112 const int defaultProtectionDomainCacheSize = 1009;
 113 
 114 ClassLoadInfo::ClassLoadInfo() {
 115   _protection_domain = Handle();
 116   _unsafe_anonymous_host = NULL;
 117   _cp_patches = NULL;
 118   _class_hidden_info._dynamic_nest_host = NULL;
 119   _class_hidden_info._class_data = Handle();
 120   _is_hidden = false;
 121   _is_strong_hidden = false;
 122   _can_access_vm_annotations = false;
 123 }
 124 
 125 ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {
 126   _protection_domain = protection_domain;
 127   _unsafe_anonymous_host = NULL;
 128   _cp_patches = NULL;
 129   _class_hidden_info._dynamic_nest_host = NULL;
 130   _class_hidden_info._class_data = Handle();
 131   _is_hidden = false;
 132   _is_strong_hidden = false;
 133   _can_access_vm_annotations = false;
 134 }
 135 
 136 ClassLoadInfo::ClassLoadInfo(Handle protection_domain,
 137                              const InstanceKlass* unsafe_anonymous_host,
 138                              GrowableArray&lt;Handle&gt;* cp_patches,
 139                              InstanceKlass* dynamic_nest_host,
 140                              Handle class_data,
 141                              bool is_hidden,
 142                              bool is_strong_hidden,
 143                              bool can_access_vm_annotations) {
 144   _protection_domain = protection_domain;
 145   _unsafe_anonymous_host = unsafe_anonymous_host;
 146   _cp_patches = cp_patches;
 147   _class_hidden_info._dynamic_nest_host = dynamic_nest_host;
 148   _class_hidden_info._class_data = class_data;
 149   _is_hidden = is_hidden;
 150   _is_strong_hidden = is_strong_hidden;
 151   _can_access_vm_annotations = can_access_vm_annotations;
 152 }
 153 
 154 // ----------------------------------------------------------------------------
 155 // Java-level SystemLoader and PlatformLoader
 156 
 157 oop SystemDictionary::java_system_loader() {
 158   return _java_system_loader;
 159 }
 160 
 161 oop SystemDictionary::java_platform_loader() {
 162   return _java_platform_loader;
 163 }
 164 
 165 void SystemDictionary::compute_java_loaders(TRAPS) {
 166   JavaValue result(T_OBJECT);
 167   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 168   JavaCalls::call_static(&amp;result,
 169                          class_loader_klass,
 170                          vmSymbols::getSystemClassLoader_name(),
 171                          vmSymbols::void_classloader_signature(),
 172                          CHECK);
 173 
 174   _java_system_loader = (oop)result.get_jobject();
 175 
 176   JavaCalls::call_static(&amp;result,
 177                          class_loader_klass,
 178                          vmSymbols::getPlatformClassLoader_name(),
 179                          vmSymbols::void_classloader_signature(),
 180                          CHECK);
 181 
 182   _java_platform_loader = (oop)result.get_jobject();
 183 }
 184 
 185 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader) {
 186   if (class_loader.is_null()) return ClassLoaderData::the_null_class_loader_data();
 187   return ClassLoaderDataGraph::find_or_create(class_loader);
 188 }
 189 
 190 // ----------------------------------------------------------------------------
 191 // Parallel class loading check
 192 
 193 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 194   if (class_loader.is_null()) return true;
 195   if (AlwaysLockClassLoader) return false;
 196   return java_lang_ClassLoader::parallelCapable(class_loader());
 197 }
 198 // ----------------------------------------------------------------------------
 199 // ParallelDefineClass flag does not apply to bootclass loader
 200 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 201    if (class_loader.is_null()) return false;
 202    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 203      return true;
 204    }
 205    return false;
 206 }
 207 
 208 // Returns true if the passed class loader is the builtin application class loader
 209 // or a custom system class loader. A customer system class loader can be
 210 // specified via -Djava.system.class.loader.
 211 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 212   if (class_loader == NULL) {
 213     return false;
 214   }
 215   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
 216          class_loader == _java_system_loader);
 217 }
 218 
 219 // Returns true if the passed class loader is the platform class loader.
 220 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 221   if (class_loader == NULL) {
 222     return false;
 223   }
 224   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 225 }
 226 
 227 // ----------------------------------------------------------------------------
 228 // Resolving of classes
 229 
 230 // Forwards to resolve_or_null
 231 
 232 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name, Handle class_loader, Handle protection_domain, bool throw_error, TRAPS) {
 233   Klass* klass = resolve_or_null(class_name, class_loader, protection_domain, THREAD);
 234   if (HAS_PENDING_EXCEPTION || klass == NULL) {
 235     // can return a null klass
 236     klass = handle_resolution_exception(class_name, throw_error, klass, THREAD);
 237   }
 238   return klass;
 239 }
 240 
 241 Klass* SystemDictionary::handle_resolution_exception(Symbol* class_name,
 242                                                      bool throw_error,
 243                                                      Klass* klass, TRAPS) {
 244   if (HAS_PENDING_EXCEPTION) {
 245     // If we have a pending exception we forward it to the caller, unless throw_error is true,
 246     // in which case we have to check whether the pending exception is a ClassNotFoundException,
 247     // and if so convert it to a NoClassDefFoundError
 248     // And chain the original ClassNotFoundException
 249     if (throw_error &amp;&amp; PENDING_EXCEPTION-&gt;is_a(SystemDictionary::ClassNotFoundException_klass())) {
 250       ResourceMark rm(THREAD);
 251       assert(klass == NULL, &quot;Should not have result with exception pending&quot;);
 252       Handle e(THREAD, PENDING_EXCEPTION);
 253       CLEAR_PENDING_EXCEPTION;
 254       THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string(), e);
 255     } else {
 256       return NULL;
 257     }
 258   }
 259   // Class not found, throw appropriate error or exception depending on value of throw_error
 260   if (klass == NULL) {
 261     ResourceMark rm(THREAD);
 262     if (throw_error) {
 263       THROW_MSG_NULL(vmSymbols::java_lang_NoClassDefFoundError(), class_name-&gt;as_C_string());
 264     } else {
 265       THROW_MSG_NULL(vmSymbols::java_lang_ClassNotFoundException(), class_name-&gt;as_C_string());
 266     }
 267   }
 268   return klass;
 269 }
 270 
 271 
 272 Klass* SystemDictionary::resolve_or_fail(Symbol* class_name,
 273                                            bool throw_error, TRAPS)
 274 {
 275   return resolve_or_fail(class_name, Handle(), Handle(), throw_error, THREAD);
 276 }
 277 
 278 
 279 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 280 
 281 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 282   if (Signature::is_array(class_name)) {
 283     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 284   } else {
 285     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 286   }
 287 }
 288 
 289 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 290 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 291                                                                        Handle class_loader,
 292                                                                        Handle protection_domain,
 293                                                                        TRAPS) {
 294   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 295   if (Signature::has_envelope(class_name)) {
 296     ResourceMark rm(THREAD);
 297     // Ignore wrapping L and ;.
 298     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 299                                                  class_name-&gt;utf8_length() - 2);
 300     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 301   } else {
 302     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 303   }
 304 }
 305 
 306 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 307   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 308 }
 309 
 310 // Forwards to resolve_instance_class_or_null
 311 
 312 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 313                                                      Handle class_loader,
 314                                                      Handle protection_domain,
 315                                                      TRAPS) {
 316   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 317   ResourceMark rm(THREAD);
 318   SignatureStream ss(class_name, false);
 319   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 320   Klass* k = NULL;
 321   BasicType t = ss.type();
 322   if (ss.has_envelope()) {
 323     Symbol* obj_class = ss.as_symbol();
 324     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 325                                                          class_loader,
 326                                                          protection_domain,
 327                                                          CHECK_NULL);
 328     if (k != NULL) {
 329       k = k-&gt;array_klass(ndims, CHECK_NULL);
 330     }
 331   } else {
 332     k = Universe::typeArrayKlassObj(t);
 333     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 334   }
 335   return k;
 336 }
 337 
 338 
 339 // Must be called for any super-class or super-interface resolution
 340 // during class definition to allow class circularity checking
 341 // super-interface callers:
 342 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 343 // super-class callers:
 344 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 345 //   load_shared_class - while loading a class from shared archive
 346 //   resolve_instance_class_or_null:
 347 //     via: handle_parallel_super_load
 348 //      when resolving a class that has an existing placeholder with
 349 //      a saved superclass [i.e. a defineClass is currently in progress]
 350 //      if another thread is trying to resolve the class, it must do
 351 //      super-class checks on its own thread to catch class circularity
 352 // This last call is critical in class circularity checking for cases
 353 // where classloading is delegated to different threads and the
 354 // classloader lock is released.
 355 // Take the case: Base-&gt;Super-&gt;Base
 356 //   1. If thread T1 tries to do a defineClass of class Base
 357 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 358 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
 359 //    so it tries to load Super
 360 //   3. If we load the class internally, or user classloader uses same thread
 361 //      loadClassFromxxx or defineClass via parseClassFile Super ...
 362 //      3.1 resolve_super_or_fail creates placeholder: T1, Super (super Base)
 363 //      3.3 resolve_instance_class_or_null Base, finds placeholder for Base
 364 //      3.4 calls resolve_super_or_fail Base
 365 //      3.5 finds T1,Base -&gt; throws class circularity
 366 //OR 4. If T2 tries to resolve Super via defineClass Super ...
 367 //      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)
 368 //      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)
 369 //      4.3 calls resolve_super_or_fail Super in parallel on own thread T2
 370 //      4.4 finds T2, Super -&gt; throws class circularity
 371 // Must be called, even if superclass is null, since this is
 372 // where the placeholder entry is created which claims this
 373 // thread is loading this class/classloader.
 374 // Be careful when modifying this code: once you have run
 375 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_SUPER),
 376 // you need to find_and_remove it before returning.
 377 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 378 InstanceKlass* SystemDictionary::resolve_super_or_fail(Symbol* child_name,
 379                                                        Symbol* super_name,
 380                                                        Handle class_loader,
 381                                                        Handle protection_domain,
 382                                                        bool is_superclass,
 383                                                        TRAPS) {
 384   assert(!Signature::is_array(super_name), &quot;invalid super class name&quot;);
 385 #if INCLUDE_CDS
 386   if (DumpSharedSpaces) {
 387     // Special processing for handling UNREGISTERED shared classes.
 388     InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(child_name,
 389         super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);
 390     if (k) {
 391       return k;
 392     }
 393   }
 394 #endif // INCLUDE_CDS
 395 
 396   // Double-check, if child class is already loaded, just return super-class,interface
 397   // Don&#39;t add a placedholder if already loaded, i.e. already in appropriate class loader
 398   // dictionary.
 399   // Make sure there&#39;s a placeholder for the *child* before resolving.
 400   // Used as a claim that this thread is currently loading superclass/classloader
 401   // Used here for ClassCircularity checks and also for heap verification
 402   // (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).
 403   // Must check ClassCircularity before checking if super class is already loaded.
 404   //
 405   // We might not already have a placeholder if this child_name was
 406   // first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);
 407   // the name of the class might not be known until the stream is actually
 408   // parsed.
 409   // Bugs 4643874, 4715493
 410 
 411   ClassLoaderData* loader_data = class_loader_data(class_loader);
 412   Dictionary* dictionary = loader_data-&gt;dictionary();
 413   unsigned int d_hash = dictionary-&gt;compute_hash(child_name);
 414   unsigned int p_hash = placeholders()-&gt;compute_hash(child_name);
 415   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 416   // can&#39;t throw error holding a lock
 417   bool child_already_loaded = false;
 418   bool throw_circularity_error = false;
 419   {
 420     MutexLocker mu(THREAD, SystemDictionary_lock);
 421     InstanceKlass* childk = find_class(d_hash, child_name, dictionary);
 422     InstanceKlass* quicksuperk;
 423     // to support // loading: if child done loading, just return superclass
 424     // if super_name, &amp; class_loader don&#39;t match:
 425     // if initial define, SD update will give LinkageError
 426     // if redefine: compare_class_versions will give HIERARCHY_CHANGED
 427     // so we don&#39;t throw an exception here.
 428     // see: nsk redefclass014 &amp; java.lang.instrument Instrument032
 429     if ((childk != NULL ) &amp;&amp; (is_superclass) &amp;&amp;
 430         ((quicksuperk = childk-&gt;java_super()) != NULL) &amp;&amp;
 431          ((quicksuperk-&gt;name() == super_name) &amp;&amp;
 432             (quicksuperk-&gt;class_loader() == class_loader()))) {
 433            return quicksuperk;
 434     } else {
 435       PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, child_name, loader_data);
 436       if (probe &amp;&amp; probe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_SUPER)) {
 437           throw_circularity_error = true;
 438       }
 439     }
 440     if (!throw_circularity_error) {
 441       // Be careful not to exit resolve_super
 442       PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);
 443     }
 444   }
 445   if (throw_circularity_error) {
 446       ResourceMark rm(THREAD);
 447       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name-&gt;as_C_string());
 448   }
 449 
 450 // java.lang.Object should have been found above
 451   assert(super_name != NULL, &quot;null super class for resolving&quot;);
 452   // Resolve the super class or interface, check results on return
 453   InstanceKlass* superk =
 454     SystemDictionary::resolve_instance_class_or_null_helper(super_name,
 455                                                             class_loader,
 456                                                             protection_domain,
 457                                                             THREAD);
 458 
 459   // Clean up of placeholders moved so that each classloadAction registrar self-cleans up
 460   // It is no longer necessary to keep the placeholder table alive until update_dictionary
 461   // or error. GC used to walk the placeholder table as strong roots.
 462   // The instanceKlass is kept alive because the class loader is on the stack,
 463   // which keeps the loader_data alive, as well as all instanceKlasses in
 464   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 465   {
 466     MutexLocker mu(THREAD, SystemDictionary_lock);
 467     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 468     SystemDictionary_lock-&gt;notify_all();
 469   }
 470   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 471     // can null superk
 472     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 473     assert(k == NULL || k == superk, &quot;must be&quot;);
 474     if (k == NULL) {
 475       superk = NULL;
 476     }
 477   }
 478 
 479   return superk;
 480 }
 481 
 482 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 483                                                   Handle class_loader,
 484                                                   Handle protection_domain,
 485                                                   TRAPS) {
 486   // Now we have to call back to java to check if the initating class has access
 487   JavaValue result(T_VOID);
 488   LogTarget(Debug, protectiondomain) lt;
 489   if (lt.is_enabled()) {
 490     ResourceMark rm(THREAD);
 491     // Print out trace information
 492     LogStream ls(lt);
 493     ls.print_cr(&quot;Checking package access&quot;);
 494     if (class_loader() != NULL) {
 495       ls.print(&quot;class loader: &quot;);
 496       class_loader()-&gt;print_value_on(&amp;ls);
 497     } else {
 498       ls.print_cr(&quot;class loader: NULL&quot;);
 499     }
 500     if (protection_domain() != NULL) {
 501       ls.print(&quot; protection domain: &quot;);
 502       protection_domain()-&gt;print_value_on(&amp;ls);
 503     } else {
 504       ls.print_cr(&quot; protection domain: NULL&quot;);
 505     }
 506     ls.print(&quot; loading: &quot;); klass-&gt;print_value_on(&amp;ls);
 507     ls.cr();
 508   }
 509 
 510   // This handle and the class_loader handle passed in keeps this class from
 511   // being unloaded through several GC points.
 512   // The class_loader handle passed in is the initiating loader.
 513   Handle mirror(THREAD, klass-&gt;java_mirror());
 514 
 515   InstanceKlass* system_loader = SystemDictionary::ClassLoader_klass();
 516   JavaCalls::call_special(&amp;result,
 517                          class_loader,
 518                          system_loader,
 519                          vmSymbols::checkPackageAccess_name(),
 520                          vmSymbols::class_protectiondomain_signature(),
 521                          mirror,
 522                          protection_domain,
 523                          THREAD);
 524 
 525   if (HAS_PENDING_EXCEPTION) {
 526     log_debug(protectiondomain)(&quot;DENIED !!!!!!!!!!!!!!!!!!!!!&quot;);
 527   } else {
 528    log_debug(protectiondomain)(&quot;granted&quot;);
 529   }
 530 
 531   if (HAS_PENDING_EXCEPTION) return;
 532 
 533   // If no exception has been thrown, we have validated the protection domain
 534   // Insert the protection domain of the initiating class into the set.
 535   {
 536     ClassLoaderData* loader_data = class_loader_data(class_loader);
 537     Dictionary* dictionary = loader_data-&gt;dictionary();
 538 
 539     Symbol*  kn = klass-&gt;name();
 540     unsigned int d_hash = dictionary-&gt;compute_hash(kn);
 541 
 542     MutexLocker mu(THREAD, SystemDictionary_lock);
 543     int d_index = dictionary-&gt;hash_to_index(d_hash);
 544     dictionary-&gt;add_protection_domain(d_index, d_hash, klass,
 545                                       protection_domain, THREAD);
 546   }
 547 }
 548 
 549 // We only get here if this thread finds that another thread
 550 // has already claimed the placeholder token for the current operation,
 551 // but that other thread either never owned or gave up the
 552 // object lock
 553 // Waits on SystemDictionary_lock to indicate placeholder table updated
 554 // On return, caller must recheck placeholder table state
 555 //
 556 // We only get here if
 557 //  1) custom classLoader, i.e. not bootstrap classloader
 558 //  2) custom classLoader has broken the class loader objectLock
 559 //     so another thread got here in parallel
 560 //
 561 // lockObject must be held.
 562 // Complicated dance due to lock ordering:
 563 // Must first release the classloader object lock to
 564 // allow initial definer to complete the class definition
 565 // and to avoid deadlock
 566 // Reclaim classloader lock object with same original recursion count
 567 // Must release SystemDictionary_lock after notify, since
 568 // class loader lock must be claimed before SystemDictionary_lock
 569 // to prevent deadlocks
 570 //
 571 // The notify allows applications that did an untimed wait() on
 572 // the classloader object lock to not hang.
 573 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 574   assert_lock_strong(SystemDictionary_lock);
 575 
 576   bool calledholdinglock
 577       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 578   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
 579   assert((lockObject() != _system_loader_lock_obj &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);
 580   ObjectSynchronizer::notifyall(lockObject, THREAD);
 581   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 582   SystemDictionary_lock-&gt;wait();
 583   SystemDictionary_lock-&gt;unlock();
 584   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 585   SystemDictionary_lock-&gt;lock();
 586 }
 587 
 588 // If the class in is in the placeholder table, class loading is in progress
 589 // For cases where the application changes threads to load classes, it
 590 // is critical to ClassCircularity detection that we try loading
 591 // the superclass on the same thread internally, so we do parallel
 592 // super class loading here.
 593 // This also is critical in cases where the original thread gets stalled
 594 // even in non-circularity situations.
 595 // Note: must call resolve_super_or_fail even if null super -
 596 // to force placeholder entry creation for this class for circularity detection
 597 // Caller must check for pending exception
 598 // Returns non-null Klass* if other thread has completed load
 599 // and we are done,
 600 // If return null Klass* and no pending exception, the caller must load the class
 601 InstanceKlass* SystemDictionary::handle_parallel_super_load(
 602     Symbol* name, Symbol* superclassname, Handle class_loader,
 603     Handle protection_domain, Handle lockObject, TRAPS) {
 604 
 605   ClassLoaderData* loader_data = class_loader_data(class_loader);
 606   Dictionary* dictionary = loader_data-&gt;dictionary();
 607   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 608   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 609   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 610 
 611   // superk is not used, resolve_super called for circularity check only
 612   // This code is reached in two situations. One if this thread
 613   // is loading the same class twice (e.g. ClassCircularity, or
 614   // java.lang.instrument).
 615   // The second is if another thread started the resolve_super first
 616   // and has not yet finished.
 617   // In both cases the original caller will clean up the placeholder
 618   // entry on error.
 619   Klass* superk = SystemDictionary::resolve_super_or_fail(name,
 620                                                           superclassname,
 621                                                           class_loader,
 622                                                           protection_domain,
 623                                                           true,
 624                                                           CHECK_NULL);
 625 
 626   // parallelCapable class loaders do NOT wait for parallel superclass loads to complete
 627   // Serial class loaders and bootstrap classloader do wait for superclass loads
 628  if (!class_loader.is_null() &amp;&amp; is_parallelCapable(class_loader)) {
 629     MutexLocker mu(THREAD, SystemDictionary_lock);
 630     // Check if classloading completed while we were loading superclass or waiting
 631     return find_class(d_hash, name, dictionary);
 632   }
 633 
 634   // must loop to both handle other placeholder updates
 635   // and spurious notifications
 636   bool super_load_in_progress = true;
 637   PlaceholderEntry* placeholder;
 638   while (super_load_in_progress) {
 639     MutexLocker mu(THREAD, SystemDictionary_lock);
 640     // Check if classloading completed while we were loading superclass or waiting
 641     InstanceKlass* check = find_class(d_hash, name, dictionary);
 642     if (check != NULL) {
 643       // Klass is already loaded, so just return it
 644       return check;
 645     } else {
 646       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 647       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress() ){
 648         // We only get here if the application has released the
 649         // classloader lock when another thread was in the middle of loading a
 650         // superclass/superinterface for this class, and now
 651         // this thread is also trying to load this class.
 652         // To minimize surprises, the first thread that started to
 653         // load a class should be the one to complete the loading
 654         // with the classfile it initially expected.
 655         // This logic has the current thread wait once it has done
 656         // all the superclass/superinterface loading it can, until
 657         // the original thread completes the class loading or fails
 658         // If it completes we will use the resulting InstanceKlass
 659         // which we will find below in the systemDictionary.
 660         // We also get here for parallel bootstrap classloader
 661         if (class_loader.is_null()) {
 662           SystemDictionary_lock-&gt;wait();
 663         } else {
 664           double_lock_wait(lockObject, THREAD);
 665         }
 666       } else {
 667         // If not in SD and not in PH, other thread&#39;s load must have failed
 668         super_load_in_progress = false;
 669       }
 670     }
 671   }
 672   return NULL;
 673 }
 674 
 675 static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {
 676   assert(event != NULL, &quot;invariant&quot;);
 677   assert(k != NULL, &quot;invariant&quot;);
 678   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 679   event-&gt;set_loadedClass(k);
 680   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 681   event-&gt;set_initiatingClassLoader(init_cld);
 682   event-&gt;commit();
 683 }
 684 
 685 
 686 // Be careful when modifying this code: once you have run
 687 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 688 // you need to find_and_remove it before returning.
 689 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 690 //
 691 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 692 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 693                                                                 Handle class_loader,
 694                                                                 Handle protection_domain,
 695                                                                 TRAPS) {
 696   assert(name != NULL &amp;&amp; !Signature::is_array(name) &amp;&amp;
 697          !Signature::has_envelope(name), &quot;invalid class name&quot;);
 698 
 699   EventClassLoad class_load_start_event;
 700 
 701   HandleMark hm(THREAD);
 702 
 703   // Fix for 4474172; see evaluation for more details
 704   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 705   ClassLoaderData* loader_data = register_loader(class_loader);
 706   Dictionary* dictionary = loader_data-&gt;dictionary();
 707   unsigned int d_hash = dictionary-&gt;compute_hash(name);
 708 
 709   // Do lookup to see if class already exist and the protection domain
 710   // has the right access
 711   // This call uses find which checks protection domain already matches
 712   // All subsequent calls use find_class, and set has_loaded_class so that
 713   // before we return a result we call out to java to check for valid protection domain
 714   // to allow returning the Klass* and add it to the pd_set if it is valid
 715   {
 716     InstanceKlass* probe = dictionary-&gt;find(d_hash, name, protection_domain);
 717     if (probe != NULL) return probe;
 718   }
 719 
 720   // Non-bootstrap class loaders will call out to class loader and
 721   // define via jvm/jni_DefineClass which will acquire the
 722   // class loader object lock to protect against multiple threads
 723   // defining the class in parallel by accident.
 724   // This lock must be acquired here so the waiter will find
 725   // any successful result in the SystemDictionary and not attempt
 726   // the define.
 727   // ParallelCapable Classloaders and the bootstrap classloader
 728   // do not acquire lock here.
 729   bool DoObjectLock = true;
 730   if (is_parallelCapable(class_loader)) {
 731     DoObjectLock = false;
 732   }
 733 
 734   unsigned int p_hash = placeholders()-&gt;compute_hash(name);
 735   int p_index = placeholders()-&gt;hash_to_index(p_hash);
 736 
 737   // Class is not in SystemDictionary so we have to do loading.
 738   // Make sure we are synchronized on the class loader before we proceed
 739   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
 740   check_loader_lock_contention(lockObject, THREAD);
 741   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
 742 
 743   // Check again (after locking) if class already exist in SystemDictionary
 744   bool class_has_been_loaded   = false;
 745   bool super_load_in_progress  = false;
 746   bool havesupername = false;
 747   InstanceKlass* k = NULL;
 748   PlaceholderEntry* placeholder;
 749   Symbol* superclassname = NULL;
 750 
 751   assert(THREAD-&gt;can_call_java(),
 752          &quot;can not load classes with compiler thread: class=%s, classloader=%s&quot;,
 753          name-&gt;as_C_string(),
 754          class_loader.is_null() ? &quot;null&quot; : class_loader-&gt;klass()-&gt;name()-&gt;as_C_string());
 755   {
 756     MutexLocker mu(THREAD, SystemDictionary_lock);
 757     InstanceKlass* check = find_class(d_hash, name, dictionary);
 758     if (check != NULL) {
 759       // InstanceKlass is already loaded, so just return it
 760       class_has_been_loaded = true;
 761       k = check;
 762     } else {
 763       placeholder = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 764       if (placeholder &amp;&amp; placeholder-&gt;super_load_in_progress()) {
 765          super_load_in_progress = true;
 766          if (placeholder-&gt;havesupername() == true) {
 767            superclassname = placeholder-&gt;supername();
 768            havesupername = true;
 769          }
 770       }
 771     }
 772   }
 773 
 774   // If the class is in the placeholder table, class loading is in progress
 775   if (super_load_in_progress &amp;&amp; havesupername==true) {
 776     k = handle_parallel_super_load(name,
 777                                    superclassname,
 778                                    class_loader,
 779                                    protection_domain,
 780                                    lockObject, THREAD);
 781     if (HAS_PENDING_EXCEPTION) {
 782       return NULL;
 783     }
 784     if (k != NULL) {
 785       class_has_been_loaded = true;
 786     }
 787   }
 788 
 789   bool throw_circularity_error = false;
 790   if (!class_has_been_loaded) {
 791     bool load_instance_added = false;
 792 
 793     // add placeholder entry to record loading instance class
 794     // Five cases:
 795     // All cases need to prevent modifying bootclasssearchpath
 796     // in parallel with a classload of same classname
 797     // Redefineclasses uses existence of the placeholder for the duration
 798     // of the class load to prevent concurrent redefinition of not completely
 799     // defined classes.
 800     // case 1. traditional classloaders that rely on the classloader object lock
 801     //   - no other need for LOAD_INSTANCE
 802     // case 2. traditional classloaders that break the classloader object lock
 803     //    as a deadlock workaround. Detection of this case requires that
 804     //    this check is done while holding the classloader object lock,
 805     //    and that lock is still held when calling classloader&#39;s loadClass.
 806     //    For these classloaders, we ensure that the first requestor
 807     //    completes the load and other requestors wait for completion.
 808     // case 3. Bootstrap classloader - don&#39;t own objectLocker
 809     //    This classloader supports parallelism at the classloader level,
 810     //    but only allows a single load of a class/classloader pair.
 811     //    No performance benefit and no deadlock issues.
 812     // case 4. parallelCapable user level classloaders - without objectLocker
 813     //    Allow parallel classloading of a class/classloader pair
 814 
 815     {
 816       MutexLocker mu(THREAD, SystemDictionary_lock);
 817       if (class_loader.is_null() || !is_parallelCapable(class_loader)) {
 818         PlaceholderEntry* oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 819         if (oldprobe) {
 820           // only need check_seen_thread once, not on each loop
 821           // 6341374 java/lang/Instrument with -Xcomp
 822           if (oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {
 823             throw_circularity_error = true;
 824           } else {
 825             // case 1: traditional: should never see load_in_progress.
 826             while (!class_has_been_loaded &amp;&amp; oldprobe &amp;&amp; oldprobe-&gt;instance_load_in_progress()) {
 827 
 828               // case 3: bootstrap classloader: prevent futile classloading,
 829               // wait on first requestor
 830               if (class_loader.is_null()) {
 831                 SystemDictionary_lock-&gt;wait();
 832               } else {
 833               // case 2: traditional with broken classloader lock. wait on first
 834               // requestor.
 835                 double_lock_wait(lockObject, THREAD);
 836               }
 837               // Check if classloading completed while we were waiting
 838               InstanceKlass* check = find_class(d_hash, name, dictionary);
 839               if (check != NULL) {
 840                 // Klass is already loaded, so just return it
 841                 k = check;
 842                 class_has_been_loaded = true;
 843               }
 844               // check if other thread failed to load and cleaned up
 845               oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, name, loader_data);
 846             }
 847           }
 848         }
 849       }
 850       // All cases: add LOAD_INSTANCE holding SystemDictionary_lock
 851       // case 4: parallelCapable: allow competing threads to try
 852       // LOAD_INSTANCE in parallel
 853 
 854       if (!throw_circularity_error &amp;&amp; !class_has_been_loaded) {
 855         PlaceholderEntry* newprobe = placeholders()-&gt;find_and_add(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, NULL, THREAD);
 856         load_instance_added = true;
 857         // For class loaders that do not acquire the classloader object lock,
 858         // if they did not catch another thread holding LOAD_INSTANCE,
 859         // need a check analogous to the acquire ObjectLocker/find_class
 860         // i.e. now that we hold the LOAD_INSTANCE token on loading this class/CL
 861         // one final check if the load has already completed
 862         // class loaders holding the ObjectLock shouldn&#39;t find the class here
 863         InstanceKlass* check = find_class(d_hash, name, dictionary);
 864         if (check != NULL) {
 865           // Klass is already loaded, so return it after checking/adding protection domain
 866           k = check;
 867           class_has_been_loaded = true;
 868         }
 869       }
 870     }
 871 
 872     // must throw error outside of owning lock
 873     if (throw_circularity_error) {
 874       assert(!HAS_PENDING_EXCEPTION &amp;&amp; load_instance_added == false,&quot;circularity error cleanup&quot;);
 875       ResourceMark rm(THREAD);
 876       THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), name-&gt;as_C_string());
 877     }
 878 
 879     if (!class_has_been_loaded) {
 880 
 881       // Do actual loading
 882       k = load_instance_class(name, class_loader, THREAD);
 883 
 884       // If everything was OK (no exceptions, no null return value), and
 885       // class_loader is NOT the defining loader, do a little more bookkeeping.
 886       if (!HAS_PENDING_EXCEPTION &amp;&amp; k != NULL &amp;&amp;
 887         k-&gt;class_loader() != class_loader()) {
 888 
 889         check_constraints(d_hash, k, class_loader, false, THREAD);
 890 
 891         // Need to check for a PENDING_EXCEPTION again; check_constraints
 892         // can throw but we may have to remove entry from the placeholder table below.
 893         if (!HAS_PENDING_EXCEPTION) {
 894           // Record dependency for non-parent delegation.
 895           // This recording keeps the defining class loader of the klass (k) found
 896           // from being unloaded while the initiating class loader is loaded
 897           // even if the reference to the defining class loader is dropped
 898           // before references to the initiating class loader.
 899           loader_data-&gt;record_dependency(k);
 900 
 901           { // Grabbing the Compile_lock prevents systemDictionary updates
 902             // during compilations.
 903             MutexLocker mu(THREAD, Compile_lock);
 904             update_dictionary(d_hash, p_index, p_hash,
 905               k, class_loader, THREAD);
 906           }
 907 
 908           if (JvmtiExport::should_post_class_load()) {
 909             Thread *thread = THREAD;
 910             assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 911             JvmtiExport::post_class_load((JavaThread *) thread, k);
 912           }
 913         }
 914       }
 915     } // load_instance_class
 916 
 917     if (load_instance_added == true) {
 918       // clean up placeholder entries for LOAD_INSTANCE success or error
 919       // This brackets the SystemDictionary updates for both defining
 920       // and initiating loaders
 921       MutexLocker mu(THREAD, SystemDictionary_lock);
 922       placeholders()-&gt;find_and_remove(p_index, p_hash, name, loader_data, PlaceholderTable::LOAD_INSTANCE, THREAD);
 923       SystemDictionary_lock-&gt;notify_all();
 924     }
 925   }
 926 
 927   if (HAS_PENDING_EXCEPTION || k == NULL) {
 928     return NULL;
 929   }
 930   if (class_load_start_event.should_commit()) {
 931     post_class_load_event(&amp;class_load_start_event, k, loader_data);
 932   }
 933 #ifdef ASSERT
 934   {
 935     ClassLoaderData* loader_data = k-&gt;class_loader_data();
 936     MutexLocker mu(THREAD, SystemDictionary_lock);
 937     InstanceKlass* kk = find_class(name, loader_data);
 938     assert(kk == k, &quot;should be present in dictionary&quot;);
 939   }
 940 #endif
 941 
 942   // return if the protection domain in NULL
 943   if (protection_domain() == NULL) return k;
 944 
 945   // Check the protection domain has the right access
 946   if (dictionary-&gt;is_valid_protection_domain(d_hash, name,
 947                                              protection_domain)) {
 948     return k;
 949   }
 950 
 951   // Verify protection domain. If it fails an exception is thrown
 952   validate_protection_domain(k, class_loader, protection_domain, CHECK_NULL);
 953 
 954   return k;
 955 }
 956 
 957 
 958 // This routine does not lock the system dictionary.
 959 //
 960 // Since readers don&#39;t hold a lock, we must make sure that system
 961 // dictionary entries are only removed at a safepoint (when only one
 962 // thread is running), and are added to in a safe way (all links must
 963 // be updated in an MT-safe manner).
 964 //
 965 // Callers should be aware that an entry could be added just after
 966 // _dictionary-&gt;bucket(index) is read here, so the caller will not see
 967 // the new entry.
 968 
 969 Klass* SystemDictionary::find(Symbol* class_name,
 970                               Handle class_loader,
 971                               Handle protection_domain,
 972                               TRAPS) {
 973 
 974   // The result of this call should be consistent with the result
 975   // of the call to resolve_instance_class_or_null().
 976   // See evaluation 6790209 and 4474172 for more details.
 977   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));
 978   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data_or_null(class_loader());
 979 
 980   if (loader_data == NULL) {
 981     // If the ClassLoaderData has not been setup,
 982     // then the class loader has no entries in the dictionary.
 983     return NULL;
 984   }
 985 
 986   Dictionary* dictionary = loader_data-&gt;dictionary();
 987   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
 988   return dictionary-&gt;find(d_hash, class_name,
 989                           protection_domain);
 990 }
 991 
 992 
 993 // Look for a loaded instance or array klass by name.  Do not do any loading.
 994 // return NULL in case of error.
 995 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
 996                                                       Handle class_loader,
 997                                                       Handle protection_domain,
 998                                                       TRAPS) {
 999   Klass* k = NULL;
1000   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1001 
1002   if (Signature::is_array(class_name)) {
1003     // The name refers to an array.  Parse the name.
1004     // dimension and object_key in FieldArrayInfo are assigned as a
1005     // side-effect of this call
1006     SignatureStream ss(class_name, false);
1007     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1008     BasicType t = ss.type();
1009     if (t != T_OBJECT) {
1010       k = Universe::typeArrayKlassObj(t);
1011     } else {
1012       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1013     }
1014     if (k != NULL) {
1015       k = k-&gt;array_klass_or_null(ndims);
1016     }
1017   } else {
1018     k = find(class_name, class_loader, protection_domain, THREAD);
1019   }
1020   return k;
1021 }
1022 
1023 // Note: this method is much like resolve_from_stream, but
1024 // does not publish the classes via the SystemDictionary.
1025 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1026 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1027 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1028                                               Handle class_loader,
1029                                               ClassFileStream* st,
1030                                               const ClassLoadInfo&amp; cl_info,
1031                                               TRAPS) {
1032 
1033   EventClassLoad class_load_start_event;
1034 
1035   ClassLoaderData* loader_data;
1036 
1037   bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;
1038 
1039   if (is_unsafe_anon_class) {
1040     // - for unsafe anonymous class: create a new CLD whith a class holder that uses
1041     //                               the same class loader as the unsafe_anonymous_host.
1042     guarantee(cl_info.unsafe_anonymous_host()-&gt;class_loader() == class_loader(),
1043               &quot;should be the same&quot;);
1044     loader_data = ClassLoaderData::has_class_mirror_holder_cld(class_loader);
1045   } else if (cl_info.is_hidden()) {
1046     // - for hidden classes that are not strong: create a new CLD that has a class holder and
1047     //                                           whose loader is the Lookup class&#39; loader.
1048     // - for hidden class: add the class to the Lookup class&#39; loader&#39;s CLD.
1049     if (!cl_info.is_strong_hidden()) {
1050       loader_data = ClassLoaderData::has_class_mirror_holder_cld(class_loader);
1051     } else {
1052       // This hidden class goes into the regular CLD pool for this loader.
1053       loader_data = register_loader(class_loader);
1054     }
1055   } else {
1056     loader_data = ClassLoaderData::class_loader_data(class_loader());
1057   }
1058 
1059   assert(st != NULL, &quot;invariant&quot;);
1060   assert(st-&gt;need_verify(), &quot;invariant&quot;);
1061 
1062   // Parse stream and create a klass.
1063   // Note that we do this even though this klass might
1064   // already be present in the SystemDictionary, otherwise we would not
1065   // throw potential ClassFormatErrors.
1066 
1067   InstanceKlass* k = KlassFactory::create_from_stream(st,
1068                                                       class_name,
1069                                                       loader_data,
1070                                                       cl_info,
1071                                                       CHECK_NULL);
1072 
1073   if ((cl_info.is_hidden() || is_unsafe_anon_class) &amp;&amp; k != NULL) {
1074     // Hidden classes that are not strong and unsafe anonymous classes must update
1075     // ClassLoaderData holder so that they can be unloaded when the mirror is no
1076     // longer referenced.
1077     if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {
1078       k-&gt;class_loader_data()-&gt;initialize_holder(Handle(THREAD, k-&gt;java_mirror()));
1079     }
1080 
1081     {
1082       MutexLocker mu_r(THREAD, Compile_lock);
1083 
1084       // Add to class hierarchy, initialize vtables, and do possible
1085       // deoptimizations.
1086       add_to_hierarchy(k, CHECK_NULL); // No exception, but can block
1087       // But, do not add to dictionary.
1088     }
1089 
1090     // Rewrite and patch constant pool here.
1091     k-&gt;link_class(CHECK_NULL);
1092     if (cl_info.cp_patches() != NULL) {
1093       k-&gt;constants()-&gt;patch_resolved_references(cl_info.cp_patches());
1094     }
1095 
1096     // If it&#39;s anonymous, initialize it now, since nobody else will.
1097     if (is_unsafe_anon_class) {
1098       k-&gt;eager_initialize(CHECK_NULL);
1099     }
1100 
1101     // notify jvmti
1102     if (JvmtiExport::should_post_class_load()) {
1103         assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1104         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1105     }
1106     if (class_load_start_event.should_commit()) {
1107       post_class_load_event(&amp;class_load_start_event, k, loader_data);
1108     }
1109   }
1110   assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),
1111          &quot;cp_patches only found with unsafe_anonymous_host&quot;);
1112 
1113   return k;
1114 }
1115 
1116 // Add a klass to the system from a stream (called by jni_DefineClass and
1117 // JVM_DefineClass).
1118 // Note: class_name can be NULL. In that case we do not know the name of
1119 // the class until we have parsed the stream.
1120 
1121 InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,
1122                                                      Handle class_loader,
1123                                                      Handle protection_domain,
1124                                                      ClassFileStream* st,
1125                                                      TRAPS) {
1126 
1127   HandleMark hm(THREAD);
1128 
1129   // Classloaders that support parallelism, e.g. bootstrap classloader,
1130   // do not acquire lock here
1131   bool DoObjectLock = true;
1132   if (is_parallelCapable(class_loader)) {
1133     DoObjectLock = false;
1134   }
1135 
1136   ClassLoaderData* loader_data = register_loader(class_loader);
1137 
1138   // Make sure we are synchronized on the class loader before we proceed
1139   Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1140   check_loader_lock_contention(lockObject, THREAD);
1141   ObjectLocker ol(lockObject, THREAD, DoObjectLock);
1142 
1143   assert(st != NULL, &quot;invariant&quot;);
1144 
1145   // Parse the stream and create a klass.
1146   // Note that we do this even though this klass might
1147   // already be present in the SystemDictionary, otherwise we would not
1148   // throw potential ClassFormatErrors.
1149  InstanceKlass* k = NULL;
1150 
1151 #if INCLUDE_CDS
1152   if (!DumpSharedSpaces) {
1153     k = SystemDictionaryShared::lookup_from_stream(class_name,
1154                                                    class_loader,
1155                                                    protection_domain,
1156                                                    st,
1157                                                    CHECK_NULL);
1158   }
1159 #endif
1160 
1161   if (k == NULL) {
1162     if (st-&gt;buffer() == NULL) {
1163       return NULL;
1164     }
1165     ClassLoadInfo cl_info(protection_domain);
1166     k = KlassFactory::create_from_stream(st, class_name, loader_data, cl_info, CHECK_NULL);
1167   }
1168 
1169   assert(k != NULL, &quot;no klass created&quot;);
1170   Symbol* h_name = k-&gt;name();
1171   assert(class_name == NULL || class_name == h_name, &quot;name mismatch&quot;);
1172 
1173   // Add class just loaded
1174   // If a class loader supports parallel classloading handle parallel define requests
1175   // find_or_define_instance_class may return a different InstanceKlass
1176   if (is_parallelCapable(class_loader)) {
1177     InstanceKlass* defined_k = find_or_define_instance_class(h_name, class_loader, k, THREAD);
1178     if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1179       // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1180       assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1181       loader_data-&gt;add_to_deallocate_list(k);
1182       k = defined_k;
1183     }
1184   } else {
1185     define_instance_class(k, THREAD);
1186   }
1187 
1188   // If defining the class throws an exception register &#39;k&#39; for cleanup.
1189   if (HAS_PENDING_EXCEPTION) {
1190     assert(k != NULL, &quot;Must have an instance klass here!&quot;);
1191     loader_data-&gt;add_to_deallocate_list(k);
1192     return NULL;
1193   }
1194 
1195   // Make sure we have an entry in the SystemDictionary on success
1196   debug_only( {
1197     MutexLocker mu(THREAD, SystemDictionary_lock);
1198 
1199     Klass* check = find_class(h_name, k-&gt;class_loader_data());
1200     assert(check == k, &quot;should be present in the dictionary&quot;);
1201   } );
1202 
1203   return k;
1204 }
1205 
1206 #if INCLUDE_CDS
1207 // Load a class for boot loader from the shared spaces. This also
1208 // forces the super class and all interfaces to be loaded.
1209 InstanceKlass* SystemDictionary::load_shared_boot_class(Symbol* class_name,
1210                                                         PackageEntry* pkg_entry,
1211                                                         TRAPS) {
1212   InstanceKlass* ik = SystemDictionaryShared::find_builtin_class(class_name);
1213   if (ik != NULL &amp;&amp; ik-&gt;is_shared_boot_class()) {
1214     return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);
1215   }
1216   return NULL;
1217 }
1218 
1219 // Check if a shared class can be loaded by the specific classloader:
1220 //
1221 // NULL classloader:
1222 //   - Module class from &quot;modules&quot; jimage. ModuleEntry must be defined in the classloader.
1223 //   - Class from -Xbootclasspath/a. The class has no defined PackageEntry, or must
1224 //     be defined in an unnamed module.
1225 bool SystemDictionary::is_shared_class_visible(Symbol* class_name,
1226                                                InstanceKlass* ik,
1227                                                PackageEntry* pkg_entry,
1228                                                Handle class_loader, TRAPS) {
1229   assert(!ModuleEntryTable::javabase_moduleEntry()-&gt;is_patched(),
1230          &quot;Cannot use sharing if java.base is patched&quot;);
1231   ResourceMark rm(THREAD);
1232   int path_index = ik-&gt;shared_classpath_index();
1233   ClassLoaderData* loader_data = class_loader_data(class_loader);
1234   if (path_index &lt; 0) {
1235     // path_index &lt; 0 indicates that the class is intended for a custom loader
1236     // and should not be loaded by boot/platform/app loaders
1237     if (loader_data-&gt;is_builtin_class_loader_data()) {
1238       return false;
1239     } else {
1240       return true;
1241     }
1242   }
1243   SharedClassPathEntry* ent =
1244             (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);
1245   if (!Universe::is_module_initialized()) {
1246     assert(ent != NULL &amp;&amp; ent-&gt;is_modules_image(),
1247            &quot;Loading non-bootstrap classes before the module system is initialized&quot;);
1248     assert(class_loader.is_null(), &quot;sanity&quot;);
1249     return true;
1250   }
1251   // Get the pkg_entry from the classloader
1252   ModuleEntry* mod_entry = NULL;
1253   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() :
1254                                                ClassLoader::package_from_class_name(class_name);
1255   if (pkg_name != NULL) {
1256     if (loader_data != NULL) {
1257       if (pkg_entry != NULL) {
1258         mod_entry = pkg_entry-&gt;module();
1259         // If the archived class is from a module that has been patched at runtime,
1260         // the class cannot be loaded from the archive.
1261         if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_patched()) {
1262           return false;
1263         }
1264       }
1265     }
1266   }
1267 
1268   if (class_loader.is_null()) {
1269     assert(ent != NULL, &quot;Shared class for NULL classloader must have valid SharedClassPathEntry&quot;);
1270     // The NULL classloader can load archived class originated from the
1271     // &quot;modules&quot; jimage and the -Xbootclasspath/a. For class from the
1272     // &quot;modules&quot; jimage, the PackageEntry/ModuleEntry must be defined
1273     // by the NULL classloader.
1274     if (mod_entry != NULL) {
1275       // PackageEntry/ModuleEntry is found in the classloader. Check if the
1276       // ModuleEntry&#39;s location agrees with the archived class&#39; origination.
1277       if (ent-&gt;is_modules_image() &amp;&amp; mod_entry-&gt;location()-&gt;starts_with(&quot;jrt:&quot;)) {
1278         return true; // Module class from the &quot;module&quot; jimage
1279       }
1280     }
1281 
1282     // If the archived class is not from the &quot;module&quot; jimage, the class can be
1283     // loaded by the NULL classloader if
1284     //
1285     // 1. the class is from the unamed package
1286     // 2. or, the class is not from a module defined in the NULL classloader
1287     // 3. or, the class is from an unamed module
1288     if (!ent-&gt;is_modules_image() &amp;&amp; ik-&gt;is_shared_boot_class()) {
1289       // the class is from the -Xbootclasspath/a
1290       if (pkg_name == NULL ||
1291           pkg_entry == NULL ||
1292           pkg_entry-&gt;in_unnamed_module()) {
1293         assert(mod_entry == NULL ||
1294                mod_entry == loader_data-&gt;unnamed_module(),
1295                &quot;the unnamed module is not defined in the classloader&quot;);
1296         return true;
1297       }
1298     }
1299     return false;
1300   } else {
1301     bool res = SystemDictionaryShared::is_shared_class_visible_for_classloader(
1302               ik, class_loader, pkg_name, pkg_entry, mod_entry, CHECK_(false));
1303     return res;
1304   }
1305 }
1306 
1307 bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,
1308                                                      Handle class_loader,  Handle protection_domain,
1309                                                      bool is_superclass, TRAPS) {
1310   assert(super_type-&gt;is_shared(), &quot;must be&quot;);
1311 
1312   Klass *found = resolve_super_or_fail(child-&gt;name(), super_type-&gt;name(),
1313                                        class_loader, protection_domain, is_superclass, CHECK_0);
1314   if (found == super_type) {
1315     return true;
1316   } else {
1317     // The dynamically resolved super type is not the same as the one we used during dump time,
1318     // so we cannot use the child class.
1319     return false;
1320   }
1321 }
1322 
1323 bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
1324                                                       Handle protection_domain, TRAPS) {
1325   // Check the superclass and interfaces. They must be the same
1326   // as in dump time, because the layout of &lt;ik&gt; depends on
1327   // the specific layout of ik-&gt;super() and ik-&gt;local_interfaces().
1328   //
1329   // If unexpected superclass or interfaces are found, we cannot
1330   // load &lt;ik&gt; from the shared archive.
1331 
1332   if (ik-&gt;super() != NULL &amp;&amp;
1333       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1334                                      class_loader, protection_domain, true, THREAD)) {
1335     return false;
1336   }
1337 
1338   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1339   int num_interfaces = interfaces-&gt;length();
1340   for (int index = 0; index &lt; num_interfaces; index++) {
1341     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1342       return false;
1343     }
1344   }
1345 
1346   return true;
1347 }
1348 
1349 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1350                                                    Handle class_loader,
1351                                                    Handle protection_domain,
1352                                                    const ClassFileStream *cfs,
1353                                                    PackageEntry* pkg_entry,
1354                                                    TRAPS) {
1355   assert(ik != NULL, &quot;sanity&quot;);
1356   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1357   Symbol* class_name = ik-&gt;name();
1358 
1359   bool visible = is_shared_class_visible(
1360                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1361   if (!visible) {
1362     return NULL;
1363   }
1364 
1365   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1366     return NULL;
1367   }
1368 
1369   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(
1370       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
1371   if (new_ik != NULL) {
1372     // The class is changed by CFLH. Return the new class. The shared class is
1373     // not used.
1374     return new_ik;
1375   }
1376 
1377   // Adjust methods to recover missing data.  They need addresses for
1378   // interpreter entry points and their default native method address
1379   // must be reset.
1380 
1381   // Updating methods must be done under a lock so multiple
1382   // threads don&#39;t update these in parallel
1383   //
1384   // Shared classes are all currently loaded by either the bootstrap or
1385   // internal parallel class loaders, so this will never cause a deadlock
1386   // on a custom class loader lock.
1387 
1388   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1389   {
1390     HandleMark hm(THREAD);
1391     Handle lockObject = compute_loader_lock_object(class_loader, THREAD);
1392     check_loader_lock_contention(lockObject, THREAD);
1393     ObjectLocker ol(lockObject, THREAD, true);
1394     // prohibited package check assumes all classes loaded from archive call
1395     // restore_unshareable_info which calls ik-&gt;set_package()
1396     ik-&gt;restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);
1397   }
1398 
1399   load_shared_class_misc(ik, loader_data, CHECK_NULL);
1400   return ik;
1401 }
1402 
1403 void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {
1404   ik-&gt;print_class_load_logging(loader_data, NULL, NULL);
1405 
1406   // For boot loader, ensure that GetSystemPackage knows that a class in this
1407   // package was loaded.
1408   if (loader_data-&gt;is_the_null_class_loader_data()) {
1409     int path_index = ik-&gt;shared_classpath_index();
1410     ik-&gt;set_classpath_index(path_index, THREAD);
1411   }
1412 
1413   if (DumpLoadedClassList != NULL &amp;&amp; classlist_file-&gt;is_open()) {
1414     // Only dump the classes that can be stored into CDS archive
1415     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
1416       ResourceMark rm(THREAD);
1417       classlist_file-&gt;print_cr(&quot;%s&quot;, ik-&gt;name()-&gt;as_C_string());
1418       classlist_file-&gt;flush();
1419     }
1420   }
1421 
1422   // notify a class loaded from shared object
1423   ClassLoadingService::notify_class_loaded(ik, true /* shared class */);
1424 
1425   ik-&gt;set_has_passed_fingerprint_check(false);
1426   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
1427     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
1428     uint64_t cds_fp = ik-&gt;get_stored_fingerprint();
1429     if (aot_fp != 0 &amp;&amp; aot_fp == cds_fp) {
1430       // This class matches with a class saved in an AOT library
1431       ik-&gt;set_has_passed_fingerprint_check(true);
1432     } else {
1433       if (log_is_enabled(Info, class, fingerprint)) {
1434         ResourceMark rm(THREAD);
1435         log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT, ik-&gt;external_name(), aot_fp, cds_fp);
1436       }
1437     }
1438   }
1439 }
1440 
1441 void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {
1442   assert(!Universe::is_fully_initialized(), &quot;We can make short cuts only during VM initialization&quot;);
1443   assert(klass-&gt;is_shared(), &quot;Must be shared class&quot;);
1444   if (klass-&gt;class_loader_data() != NULL) {
1445     return;
1446   }
1447 
1448   // add super and interfaces first
1449   Klass* super = klass-&gt;super();
1450   if (super != NULL &amp;&amp; super-&gt;class_loader_data() == NULL) {
1451     assert(super-&gt;is_instance_klass(), &quot;Super should be instance klass&quot;);
1452     quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);
1453   }
1454 
1455   Array&lt;InstanceKlass*&gt;* ifs = klass-&gt;local_interfaces();
1456   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
1457     InstanceKlass* ik = ifs-&gt;at(i);
1458     if (ik-&gt;class_loader_data()  == NULL) {
1459       quick_resolve(ik, loader_data, domain, CHECK);
1460     }
1461   }
1462 
1463   klass-&gt;restore_unshareable_info(loader_data, domain, NULL, THREAD);
1464   load_shared_class_misc(klass, loader_data, CHECK);
1465   Dictionary* dictionary = loader_data-&gt;dictionary();
1466   unsigned int hash = dictionary-&gt;compute_hash(klass-&gt;name());
1467   dictionary-&gt;add_klass(hash, klass-&gt;name(), klass);
1468   add_to_hierarchy(klass, CHECK);
1469   assert(klass-&gt;is_loaded(), &quot;Must be in at least loaded state&quot;);
1470 }
1471 #endif // INCLUDE_CDS
1472 
1473 InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {
1474 
1475   if (class_loader.is_null()) {
1476     ResourceMark rm(THREAD);
1477     PackageEntry* pkg_entry = NULL;
1478     bool search_only_bootloader_append = false;
1479     ClassLoaderData *loader_data = class_loader_data(class_loader);
1480 
1481     // Find the package in the boot loader&#39;s package entry table.
1482     TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);
1483     if (pkg_name != NULL) {
1484       pkg_entry = loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
1485     }
1486 
1487     // Prior to attempting to load the class, enforce the boot loader&#39;s
1488     // visibility boundaries.
1489     if (!Universe::is_module_initialized()) {
1490       // During bootstrapping, prior to module initialization, any
1491       // class attempting to be loaded must be checked against the
1492       // java.base packages in the boot loader&#39;s PackageEntryTable.
1493       // No class outside of java.base is allowed to be loaded during
1494       // this bootstrapping window.
1495       if (pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1496         // Class is either in the unnamed package or in
1497         // a named package within the unnamed module.  Either
1498         // case is outside of java.base, do not attempt to
1499         // load the class post java.base definition.  If
1500         // java.base has not been defined, let the class load
1501         // and its package will be checked later by
1502         // ModuleEntryTable::verify_javabase_packages.
1503         if (ModuleEntryTable::javabase_defined()) {
1504           return NULL;
1505         }
1506       } else {
1507         // Check that the class&#39; package is defined within java.base.
1508         ModuleEntry* mod_entry = pkg_entry-&gt;module();
1509         Symbol* mod_entry_name = mod_entry-&gt;name();
1510         if (mod_entry_name-&gt;fast_compare(vmSymbols::java_base()) != 0) {
1511           return NULL;
1512         }
1513       }
1514     } else {
1515       // After the module system has been initialized, check if the class&#39;
1516       // package is in a module defined to the boot loader.
1517       if (pkg_name == NULL || pkg_entry == NULL || pkg_entry-&gt;in_unnamed_module()) {
1518         // Class is either in the unnamed package, in a named package
1519         // within a module not defined to the boot loader or in a
1520         // a named package within the unnamed module.  In all cases,
1521         // limit visibility to search for the class only in the boot
1522         // loader&#39;s append path.
1523         if (!ClassLoader::has_bootclasspath_append()) {
1524            // If there is no bootclasspath append entry, no need to continue
1525            // searching.
1526            return NULL;
1527         }
1528         search_only_bootloader_append = true;
1529       }
1530     }
1531 
1532     // Prior to bootstrapping&#39;s module initialization, never load a class outside
1533     // of the boot loader&#39;s module path
1534     assert(Universe::is_module_initialized() ||
1535            !search_only_bootloader_append,
1536            &quot;Attempt to load a class outside of boot loader&#39;s module path&quot;);
1537 
1538     // Search for classes in the CDS archive.
1539     InstanceKlass* k = NULL;
1540     {
1541 #if INCLUDE_CDS
1542       PerfTraceTime vmtimer(ClassLoader::perf_shared_classload_time());
1543       k = load_shared_boot_class(class_name, pkg_entry, THREAD);
1544 #endif
1545     }
1546 
1547     if (k == NULL) {
1548       // Use VM class loader
1549       PerfTraceTime vmtimer(ClassLoader::perf_sys_classload_time());
1550       k = ClassLoader::load_class(class_name, search_only_bootloader_append, CHECK_NULL);
1551     }
1552 
1553     // find_or_define_instance_class may return a different InstanceKlass
1554     if (k != NULL) {
1555       InstanceKlass* defined_k =
1556         find_or_define_instance_class(class_name, class_loader, k, THREAD);
1557       if (!HAS_PENDING_EXCEPTION &amp;&amp; defined_k != k) {
1558         // If a parallel capable class loader already defined this class, register &#39;k&#39; for cleanup.
1559         assert(defined_k != NULL, &quot;Should have a klass if there&#39;s no exception&quot;);
1560         loader_data-&gt;add_to_deallocate_list(k);
1561         k = defined_k;
1562       } else if (HAS_PENDING_EXCEPTION) {
1563         loader_data-&gt;add_to_deallocate_list(k);
1564         return NULL;
1565       }
1566     }
1567     return k;
1568   } else {
1569     // Use user specified class loader to load class. Call loadClass operation on class_loader.
1570     ResourceMark rm(THREAD);
1571 
1572     assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1573     JavaThread* jt = (JavaThread*) THREAD;
1574 
1575     PerfClassTraceTime vmtimer(ClassLoader::perf_app_classload_time(),
1576                                ClassLoader::perf_app_classload_selftime(),
1577                                ClassLoader::perf_app_classload_count(),
1578                                jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1579                                jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1580                                PerfClassTraceTime::CLASS_LOAD);
1581 
1582     Handle s = java_lang_String::create_from_symbol(class_name, CHECK_NULL);
1583     // Translate to external class name format, i.e., convert &#39;/&#39; chars to &#39;.&#39;
1584     Handle string = java_lang_String::externalize_classname(s, CHECK_NULL);
1585 
1586     JavaValue result(T_OBJECT);
1587 
1588     InstanceKlass* spec_klass = SystemDictionary::ClassLoader_klass();
1589 
1590     // Call public unsynchronized loadClass(String) directly for all class loaders.
1591     // For parallelCapable class loaders, JDK &gt;=7, loadClass(String, boolean) will
1592     // acquire a class-name based lock rather than the class loader object lock.
1593     // JDK &lt; 7 already acquire the class loader lock in loadClass(String, boolean).
1594     JavaCalls::call_virtual(&amp;result,
1595                             class_loader,
1596                             spec_klass,
1597                             vmSymbols::loadClass_name(),
1598                             vmSymbols::string_class_signature(),
1599                             string,
1600                             CHECK_NULL);
1601 
1602     assert(result.get_type() == T_OBJECT, &quot;just checking&quot;);
1603     oop obj = (oop) result.get_jobject();
1604 
1605     // Primitive classes return null since forName() can not be
1606     // used to obtain any of the Class objects representing primitives or void
1607     if ((obj != NULL) &amp;&amp; !(java_lang_Class::is_primitive(obj))) {
1608       InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));
1609       // For user defined Java class loaders, check that the name returned is
1610       // the same as that requested.  This check is done for the bootstrap
1611       // loader when parsing the class file.
1612       if (class_name == k-&gt;name()) {
1613         return k;
1614       }
1615     }
1616     // Class is not found or has the wrong name, return NULL
1617     return NULL;
1618   }
1619 }
1620 
1621 static void post_class_define_event(InstanceKlass* k, const ClassLoaderData* def_cld) {
1622   EventClassDefine event;
1623   if (event.should_commit()) {
1624     event.set_definedClass(k);
1625     event.set_definingClassLoader(def_cld);
1626     event.commit();
1627   }
1628 }
1629 
1630 void SystemDictionary::define_instance_class(InstanceKlass* k, TRAPS) {
1631 
1632   HandleMark hm(THREAD);
1633   ClassLoaderData* loader_data = k-&gt;class_loader_data();
1634   Handle class_loader_h(THREAD, loader_data-&gt;class_loader());
1635 
1636  // for bootstrap and other parallel classloaders don&#39;t acquire lock,
1637  // use placeholder token
1638  // If a parallelCapable class loader calls define_instance_class instead of
1639  // find_or_define_instance_class to get here, we have a timing
1640  // hole with systemDictionary updates and check_constraints
1641  if (!class_loader_h.is_null() &amp;&amp; !is_parallelCapable(class_loader_h)) {
1642     assert(ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD,
1643          compute_loader_lock_object(class_loader_h, THREAD)),
1644          &quot;define called without lock&quot;);
1645   }
1646 
1647   // Check class-loading constraints. Throw exception if violation is detected.
1648   // Grabs and releases SystemDictionary_lock
1649   // The check_constraints/find_class call and update_dictionary sequence
1650   // must be &quot;atomic&quot; for a specific class/classloader pair so we never
1651   // define two different instanceKlasses for that class/classloader pair.
1652   // Existing classloaders will call define_instance_class with the
1653   // classloader lock held
1654   // Parallel classloaders will call find_or_define_instance_class
1655   // which will require a token to perform the define class
1656   Symbol*  name_h = k-&gt;name();
1657   Dictionary* dictionary = loader_data-&gt;dictionary();
1658   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1659   check_constraints(d_hash, k, class_loader_h, true, CHECK);
1660 
1661   // Register class just loaded with class loader (placed in ArrayList)
1662   // Note we do this before updating the dictionary, as this can
1663   // fail with an OutOfMemoryError (if it does, we will *not* put this
1664   // class in the dictionary and will not update the class hierarchy).
1665   // JVMTI FollowReferences needs to find the classes this way.
1666   if (k-&gt;class_loader() != NULL) {
1667     methodHandle m(THREAD, Universe::loader_addClass_method());
1668     JavaValue result(T_VOID);
1669     JavaCallArguments args(class_loader_h);
1670     args.push_oop(Handle(THREAD, k-&gt;java_mirror()));
1671     JavaCalls::call(&amp;result, m, &amp;args, CHECK);
1672   }
1673 
1674   // Add the new class. We need recompile lock during update of CHA.
1675   {
1676     unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1677     int p_index = placeholders()-&gt;hash_to_index(p_hash);
1678 
1679     MutexLocker mu_r(THREAD, Compile_lock);
1680 
1681     // Add to class hierarchy, initialize vtables, and do possible
1682     // deoptimizations.
1683     add_to_hierarchy(k, CHECK); // No exception, but can block
1684 
1685     // Add to systemDictionary - so other classes can see it.
1686     // Grabs and releases SystemDictionary_lock
1687     update_dictionary(d_hash, p_index, p_hash,
1688                       k, class_loader_h, THREAD);
1689   }
1690   k-&gt;eager_initialize(THREAD);
1691 
1692   // notify jvmti
1693   if (JvmtiExport::should_post_class_load()) {
1694       assert(THREAD-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1695       JvmtiExport::post_class_load((JavaThread *) THREAD, k);
1696 
1697   }
1698   post_class_define_event(k, loader_data);
1699 }
1700 
1701 // Support parallel classloading
1702 // All parallel class loaders, including bootstrap classloader
1703 // lock a placeholder entry for this class/class_loader pair
1704 // to allow parallel defines of different classes for this class loader
1705 // With AllowParallelDefine flag==true, in case they do not synchronize around
1706 // FindLoadedClass/DefineClass, calls, we check for parallel
1707 // loading for them, wait if a defineClass is in progress
1708 // and return the initial requestor&#39;s results
1709 // This flag does not apply to the bootstrap classloader.
1710 // With AllowParallelDefine flag==false, call through to define_instance_class
1711 // which will throw LinkageError: duplicate class definition.
1712 // False is the requested default.
1713 // For better performance, the class loaders should synchronize
1714 // findClass(), i.e. FindLoadedClass/DefineClassIfAbsent or they
1715 // potentially waste time reading and parsing the bytestream.
1716 // Note: VM callers should ensure consistency of k/class_name,class_loader
1717 // Be careful when modifying this code: once you have run
1718 // placeholders()-&gt;find_and_add(PlaceholderTable::DEFINE_CLASS),
1719 // you need to find_and_remove it before returning.
1720 // So be careful to not exit with a CHECK_ macro betweeen these calls.
1721 InstanceKlass* SystemDictionary::find_or_define_instance_class(Symbol* class_name, Handle class_loader,
1722                                                                InstanceKlass* k, TRAPS) {
1723 
1724   Symbol*  name_h = k-&gt;name(); // passed in class_name may be null
1725   ClassLoaderData* loader_data = class_loader_data(class_loader);
1726   Dictionary* dictionary = loader_data-&gt;dictionary();
1727 
1728   unsigned int d_hash = dictionary-&gt;compute_hash(name_h);
1729 
1730   // Hold SD lock around find_class and placeholder creation for DEFINE_CLASS
1731   unsigned int p_hash = placeholders()-&gt;compute_hash(name_h);
1732   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1733   PlaceholderEntry* probe;
1734 
1735   {
1736     MutexLocker mu(THREAD, SystemDictionary_lock);
1737     // First check if class already defined
1738     if (is_parallelDefine(class_loader)) {
1739       InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1740       if (check != NULL) {
1741         return check;
1742       }
1743     }
1744 
1745     // Acquire define token for this class/classloader
1746     probe = placeholders()-&gt;find_and_add(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, NULL, THREAD);
1747     // Wait if another thread defining in parallel
1748     // All threads wait - even those that will throw duplicate class: otherwise
1749     // caller is surprised by LinkageError: duplicate, but findLoadedClass fails
1750     // if other thread has not finished updating dictionary
1751     while (probe-&gt;definer() != NULL) {
1752       SystemDictionary_lock-&gt;wait();
1753     }
1754     // Only special cases allow parallel defines and can use other thread&#39;s results
1755     // Other cases fall through, and may run into duplicate defines
1756     // caught by finding an entry in the SystemDictionary
1757     if (is_parallelDefine(class_loader) &amp;&amp; (probe-&gt;instance_klass() != NULL)) {
1758         placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1759         SystemDictionary_lock-&gt;notify_all();
1760 #ifdef ASSERT
1761         InstanceKlass* check = find_class(d_hash, name_h, dictionary);
1762         assert(check != NULL, &quot;definer missed recording success&quot;);
1763 #endif
1764         return probe-&gt;instance_klass();
1765     } else {
1766       // This thread will define the class (even if earlier thread tried and had an error)
1767       probe-&gt;set_definer(THREAD);
1768     }
1769   }
1770 
1771   define_instance_class(k, THREAD);
1772 
1773   Handle linkage_exception = Handle(); // null handle
1774 
1775   // definer must notify any waiting threads
1776   {
1777     MutexLocker mu(THREAD, SystemDictionary_lock);
1778     PlaceholderEntry* probe = placeholders()-&gt;get_entry(p_index, p_hash, name_h, loader_data);
1779     assert(probe != NULL, &quot;DEFINE_CLASS placeholder lost?&quot;);
1780     if (probe != NULL) {
1781       if (HAS_PENDING_EXCEPTION) {
1782         linkage_exception = Handle(THREAD,PENDING_EXCEPTION);
1783         CLEAR_PENDING_EXCEPTION;
1784       } else {
1785         probe-&gt;set_instance_klass(k);
1786       }
1787       probe-&gt;set_definer(NULL);
1788       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1789       SystemDictionary_lock-&gt;notify_all();
1790     }
1791   }
1792 
1793   // Can&#39;t throw exception while holding lock due to rank ordering
1794   if (linkage_exception() != NULL) {
1795     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1796   }
1797 
1798   return k;
1799 }
1800 
1801 Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
1802   // If class_loader is NULL we synchronize on _system_loader_lock_obj
1803   if (class_loader.is_null()) {
1804     return Handle(THREAD, _system_loader_lock_obj);
1805   } else {
1806     return class_loader;
1807   }
1808 }
1809 
1810 // This method is added to check how often we have to wait to grab loader
1811 // lock. The results are being recorded in the performance counters defined in
1812 // ClassLoader::_sync_systemLoaderLockContentionRate and
1813 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1814 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1815   if (!UsePerfData) {
1816     return;
1817   }
1818 
1819   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1820 
1821   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1822       == ObjectSynchronizer::owner_other) {
1823     // contention will likely happen, so increment the corresponding
1824     // contention counter.
1825     if (loader_lock() == _system_loader_lock_obj) {
1826       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1827     } else {
1828       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1829     }
1830   }
1831 }
1832 
1833 // ----------------------------------------------------------------------------
1834 // Lookup
1835 
1836 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
1837                                             Symbol* class_name,
1838                                             Dictionary* dictionary) {
1839   assert_locked_or_safepoint(SystemDictionary_lock);
1840   int index = dictionary-&gt;hash_to_index(hash);
1841   return dictionary-&gt;find_class(index, hash, class_name);
1842 }
1843 
1844 
1845 // Basic find on classes in the midst of being loaded
1846 Symbol* SystemDictionary::find_placeholder(Symbol* class_name,
1847                                            ClassLoaderData* loader_data) {
1848   assert_locked_or_safepoint(SystemDictionary_lock);
1849   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);
1850   int p_index = placeholders()-&gt;hash_to_index(p_hash);
1851   return placeholders()-&gt;find_entry(p_index, p_hash, class_name, loader_data);
1852 }
1853 
1854 
1855 // Used for assertions and verification only
1856 // Precalculating the hash and index is an optimization because there are many lookups
1857 // before adding the class.
1858 InstanceKlass* SystemDictionary::find_class(Symbol* class_name, ClassLoaderData* loader_data) {
1859   assert_locked_or_safepoint(SystemDictionary_lock);
1860   #ifndef ASSERT
1861   guarantee(VerifyBeforeGC      ||
1862             VerifyDuringGC      ||
1863             VerifyBeforeExit    ||
1864             VerifyDuringStartup ||
1865             VerifyAfterGC, &quot;too expensive&quot;);
1866   #endif
1867 
1868   Dictionary* dictionary = loader_data-&gt;dictionary();
1869   unsigned int d_hash = dictionary-&gt;compute_hash(class_name);
1870   return find_class(d_hash, class_name, dictionary);
1871 }
1872 
1873 
1874 // ----------------------------------------------------------------------------
1875 // Update hierachy. This is done before the new klass has been added to the SystemDictionary. The Recompile_lock
1876 // is held, to ensure that the compiler is not using the class hierachy, and that deoptimization will kick in
1877 // before a new class is used.
1878 
1879 void SystemDictionary::add_to_hierarchy(InstanceKlass* k, TRAPS) {
1880   assert(k != NULL, &quot;just checking&quot;);
1881   if (Universe::is_fully_initialized()) {
1882     assert_locked_or_safepoint(Compile_lock);
1883   }
1884 
1885   k-&gt;set_init_state(InstanceKlass::loaded);
1886   // make sure init_state store is already done.
1887   // The compiler reads the hierarchy outside of the Compile_lock.
1888   // Access ordering is used to add to hierarchy.
1889 
1890   // Link into hierachy.
1891   k-&gt;append_to_sibling_list();                    // add to superklass/sibling list
1892   k-&gt;process_interfaces(THREAD);                  // handle all &quot;implements&quot; declarations
1893 
1894   // Now flush all code that depended on old class hierarchy.
1895   // Note: must be done *after* linking k into the hierarchy (was bug 12/9/97)
1896   if (Universe::is_fully_initialized()) {
1897     CodeCache::flush_dependents_on(k);
1898   }
1899 }
1900 
1901 // ----------------------------------------------------------------------------
1902 // GC support
1903 
1904 // Assumes classes in the SystemDictionary are only unloaded at a safepoint
1905 // Note: anonymous classes are not in the SD.
1906 bool SystemDictionary::do_unloading(GCTimer* gc_timer) {
1907 
1908   bool unloading_occurred;
1909   bool is_concurrent = !SafepointSynchronize::is_at_safepoint();
1910   {
1911     GCTraceTime(Debug, gc, phases) t(&quot;ClassLoaderData&quot;, gc_timer);
1912     assert_locked_or_safepoint(ClassLoaderDataGraph_lock);  // caller locks.
1913     // First, mark for unload all ClassLoaderData referencing a dead class loader.
1914     unloading_occurred = ClassLoaderDataGraph::do_unloading();
1915     if (unloading_occurred) {
1916       MutexLocker ml2(is_concurrent ? Module_lock : NULL);
1917       JFR_ONLY(Jfr::on_unloading_classes();)
1918 
1919       MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);
1920       ClassLoaderDataGraph::clean_module_and_package_info();
1921       constraints()-&gt;purge_loader_constraints();
1922       resolution_errors()-&gt;purge_resolution_errors();
1923     }
1924   }
1925 
1926   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
1927 
1928   if (unloading_occurred) {
1929     SymbolTable::trigger_cleanup();
1930 
1931     // Oops referenced by the protection domain cache table may get unreachable independently
1932     // of the class loader (eg. cached protection domain oops). So we need to
1933     // explicitly unlink them here.
1934     // All protection domain oops are linked to the caller class, so if nothing
1935     // unloads, this is not needed.
1936     _pd_cache_table-&gt;trigger_cleanup();
1937   }
1938 
1939   return unloading_occurred;
1940 }
1941 
1942 void SystemDictionary::oops_do(OopClosure* f, bool include_handles) {
1943   f-&gt;do_oop(&amp;_java_system_loader);
1944   f-&gt;do_oop(&amp;_java_platform_loader);
1945   f-&gt;do_oop(&amp;_system_loader_lock_obj);
1946   CDS_ONLY(SystemDictionaryShared::oops_do(f);)
1947 
1948   // Visit extra methods
1949   invoke_method_table()-&gt;oops_do(f);
1950 
1951   if (include_handles) {
1952     OopStorageSet::vm_global()-&gt;oops_do(f);
1953   }
1954 }
1955 
1956 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
1957 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
1958   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
1959     it-&gt;push(well_known_klass_addr((WKID)id));
1960   }
1961 }
1962 
1963 void SystemDictionary::methods_do(void f(Method*)) {
1964   // Walk methods in loaded classes
1965   MutexLocker ml(ClassLoaderDataGraph_lock);
1966   ClassLoaderDataGraph::methods_do(f);
1967   // Walk method handle intrinsics
1968   invoke_method_table()-&gt;methods_do(f);
1969 }
1970 
1971 // ----------------------------------------------------------------------------
1972 // Initialization
1973 
1974 void SystemDictionary::initialize(TRAPS) {
1975   // Allocate arrays
1976   _placeholders        = new PlaceholderTable(_placeholder_table_size);
1977   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
1978   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
1979   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
1980   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
1981 
1982   // Allocate private object used as system class loader lock
1983   _system_loader_lock_obj = oopFactory::new_intArray(0, CHECK);
1984   // Initialize basic classes
1985   resolve_well_known_classes(CHECK);
1986 }
1987 
1988 // Compact table of directions on the initialization of klasses:
1989 static const short wk_init_info[] = {
1990   #define WK_KLASS_INIT_INFO(name, symbol) \
1991     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
1992 
1993   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
1994   #undef WK_KLASS_INIT_INFO
1995   0
1996 };
1997 
1998 #ifdef ASSERT
1999 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
2000   int sid;
2001   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
2002     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2003     if (class_name == symbol) {
2004       return true;
2005     }
2006   }
2007   return false;
2008 }
2009 #endif
2010 
2011 bool SystemDictionary::resolve_wk_klass(WKID id, TRAPS) {
2012   assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2013   int sid = wk_init_info[id - FIRST_WKID];
2014   Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2015   InstanceKlass** klassp = &amp;_well_known_klasses[id];
2016 
2017 #if INCLUDE_CDS
2018   if (UseSharedSpaces &amp;&amp; !JvmtiExport::should_post_class_prepare()) {
2019     InstanceKlass* k = *klassp;
2020     assert(k-&gt;is_shared_boot_class(), &quot;must be&quot;);
2021 
2022     ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
2023     quick_resolve(k, loader_data, Handle(), CHECK_false);
2024     return true;
2025   }
2026 #endif // INCLUDE_CDS
2027 
2028   if (!is_wk_klass_loaded(*klassp)) {
2029     Klass* k = resolve_or_fail(symbol, true, CHECK_false);
2030     (*klassp) = InstanceKlass::cast(k);
2031   }
2032   return ((*klassp) != NULL);
2033 }
2034 
2035 void SystemDictionary::resolve_wk_klasses_until(WKID limit_id, WKID &amp;start_id, TRAPS) {
2036   assert((int)start_id &lt;= (int)limit_id, &quot;IDs are out of order!&quot;);
2037   for (int id = (int)start_id; id &lt; (int)limit_id; id++) {
2038     assert(id &gt;= (int)FIRST_WKID &amp;&amp; id &lt; (int)WKID_LIMIT, &quot;oob&quot;);
2039     resolve_wk_klass((WKID)id, CHECK);
2040   }
2041 
2042   // move the starting value forward to the limit:
2043   start_id = limit_id;
2044 }
2045 
2046 void SystemDictionary::resolve_well_known_classes(TRAPS) {
2047   assert(!Object_klass_loaded(), &quot;well-known classes should only be initialized once&quot;);
2048 
2049   // Create the ModuleEntry for java.base.  This call needs to be done here,
2050   // after vmSymbols::initialize() is called but before any classes are pre-loaded.
2051   ClassLoader::classLoader_init2(CHECK);
2052 
2053   // Preload commonly used klasses
2054   WKID scan = FIRST_WKID;
2055   // first do Object, then String, Class
2056 #if INCLUDE_CDS
2057   if (UseSharedSpaces) {
2058     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Object_klass), scan, CHECK);
2059 
2060     // It&#39;s unsafe to access the archived heap regions before they
2061     // are fixed up, so we must do the fixup as early as possible
2062     // before the archived java objects are accessed by functions
2063     // such as java_lang_Class::restore_archived_mirror and
2064     // ConstantPool::restore_unshareable_info (restores the archived
2065     // resolved_references array object).
2066     //
2067     // HeapShared::fixup_mapped_heap_regions() fills the empty
2068     // spaces in the archived heap regions and may use
2069     // SystemDictionary::Object_klass(), so we can do this only after
2070     // Object_klass is resolved. See the above resolve_wk_klasses_through()
2071     // call. No mirror objects are accessed/restored in the above call.
2072     // Mirrors are restored after java.lang.Class is loaded.
2073     HeapShared::fixup_mapped_heap_regions();
2074 
2075     // Initialize the constant pool for the Object_class
2076     assert(Object_klass()-&gt;is_shared(), &quot;must be&quot;);
2077     Object_klass()-&gt;constants()-&gt;restore_unshareable_info(CHECK);
2078     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2079   } else
2080 #endif
2081   {
2082     resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Class_klass), scan, CHECK);
2083   }
2084 
2085   assert(WK_KLASS(Object_klass) != NULL, &quot;well-known classes should now be initialized&quot;);
2086 
2087   java_lang_Object::register_natives(CHECK);
2088 
2089   // Calculate offsets for String and Class classes since they are loaded and
2090   // can be used after this point.
2091   java_lang_String::compute_offsets();
2092   java_lang_Class::compute_offsets();
2093 
2094   // Fixup mirrors for classes loaded before java.lang.Class.
2095   Universe::initialize_basic_type_mirrors(CHECK);
2096   Universe::fixup_mirrors(CHECK);
2097 
2098   // do a bunch more:
2099   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(Reference_klass), scan, CHECK);
2100 
2101   // Preload ref klasses and set reference types
2102   WK_KLASS(Reference_klass)-&gt;set_reference_type(REF_OTHER);
2103   InstanceRefKlass::update_nonstatic_oop_maps(WK_KLASS(Reference_klass));
2104 
2105   resolve_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);
2106   WK_KLASS(SoftReference_klass)-&gt;set_reference_type(REF_SOFT);
2107   WK_KLASS(WeakReference_klass)-&gt;set_reference_type(REF_WEAK);
2108   WK_KLASS(FinalReference_klass)-&gt;set_reference_type(REF_FINAL);
2109   WK_KLASS(PhantomReference_klass)-&gt;set_reference_type(REF_PHANTOM);
2110 
2111   // JSR 292 classes
2112   WKID jsr292_group_start = WK_KLASS_ENUM_NAME(MethodHandle_klass);
2113   WKID jsr292_group_end   = WK_KLASS_ENUM_NAME(VolatileCallSite_klass);
2114   resolve_wk_klasses_until(jsr292_group_start, scan, CHECK);
2115   resolve_wk_klasses_through(jsr292_group_end, scan, CHECK);
2116   WKID last = WKID_LIMIT;
2117   resolve_wk_klasses_until(last, scan, CHECK);
2118 
2119   _box_klasses[T_BOOLEAN] = WK_KLASS(Boolean_klass);
2120   _box_klasses[T_CHAR]    = WK_KLASS(Character_klass);
2121   _box_klasses[T_FLOAT]   = WK_KLASS(Float_klass);
2122   _box_klasses[T_DOUBLE]  = WK_KLASS(Double_klass);
2123   _box_klasses[T_BYTE]    = WK_KLASS(Byte_klass);
2124   _box_klasses[T_SHORT]   = WK_KLASS(Short_klass);
2125   _box_klasses[T_INT]     = WK_KLASS(Integer_klass);
2126   _box_klasses[T_LONG]    = WK_KLASS(Long_klass);
2127   //_box_klasses[T_OBJECT]  = WK_KLASS(object_klass);
2128   //_box_klasses[T_ARRAY]   = WK_KLASS(object_klass);
2129 
2130 #ifdef ASSERT
2131   if (UseSharedSpaces) {
2132     JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),
2133                       &quot;All well known classes must be resolved in JVMTI early phase&quot;));
2134     for (int i = FIRST_WKID; i &lt; last; i++) {
2135       InstanceKlass* k = _well_known_klasses[i];
2136       assert(k-&gt;is_shared(), &quot;must not be replaced by JVMTI class file load hook&quot;);
2137     }
2138   }
2139 #endif
2140 }
2141 
2142 // Tells if a given klass is a box (wrapper class, such as java.lang.Integer).
2143 // If so, returns the basic type it holds.  If not, returns T_OBJECT.
2144 BasicType SystemDictionary::box_klass_type(Klass* k) {
2145   assert(k != NULL, &quot;&quot;);
2146   for (int i = T_BOOLEAN; i &lt; T_VOID+1; i++) {
2147     if (_box_klasses[i] == k)
2148       return (BasicType)i;
2149   }
2150   return T_OBJECT;
2151 }
2152 
2153 // Constraints on class loaders. The details of the algorithm can be
2154 // found in the OOPSLA&#39;98 paper &quot;Dynamic Class Loading in the Java
2155 // Virtual Machine&quot; by Sheng Liang and Gilad Bracha.  The basic idea is
2156 // that the dictionary needs to maintain a set of contraints that
2157 // must be satisfied by all classes in the dictionary.
2158 // if defining is true, then LinkageError if already in dictionary
2159 // if initiating loader, then ok if InstanceKlass matches existing entry
2160 
2161 void SystemDictionary::check_constraints(unsigned int d_hash,
2162                                          InstanceKlass* k,
2163                                          Handle class_loader,
2164                                          bool defining,
2165                                          TRAPS) {
2166   ResourceMark rm(THREAD);
2167   stringStream ss;
2168   bool throwException = false;
2169 
2170   {
2171     Symbol *name = k-&gt;name();
2172     ClassLoaderData *loader_data = class_loader_data(class_loader);
2173 
2174     MutexLocker mu(THREAD, SystemDictionary_lock);
2175 
2176     InstanceKlass* check = find_class(d_hash, name, loader_data-&gt;dictionary());
2177     if (check != NULL) {
2178       // If different InstanceKlass - duplicate class definition,
2179       // else - ok, class loaded by a different thread in parallel.
2180       // We should only have found it if it was done loading and ok to use.
2181       // The dictionary only holds instance classes, placeholders
2182       // also hold array classes.
2183 
2184       assert(check-&gt;is_instance_klass(), &quot;noninstance in systemdictionary&quot;);
2185       if ((defining == true) || (k != check)) {
2186         throwException = true;
2187         ss.print(&quot;loader %s&quot;, loader_data-&gt;loader_name_and_id());
2188         ss.print(&quot; attempted duplicate %s definition for %s. (%s)&quot;,
2189                  k-&gt;external_kind(), k-&gt;external_name(), k-&gt;class_in_module_of_loader(false, true));
2190       } else {
2191         return;
2192       }
2193     }
2194 
2195 #ifdef ASSERT
2196     Symbol* ph_check = find_placeholder(name, loader_data);
2197     assert(ph_check == NULL || ph_check == name, &quot;invalid symbol&quot;);
2198 #endif
2199 
2200     if (throwException == false) {
2201       if (constraints()-&gt;check_or_update(k, class_loader, name) == false) {
2202         throwException = true;
2203         ss.print(&quot;loader constraint violation: loader %s&quot;, loader_data-&gt;loader_name_and_id());
2204         ss.print(&quot; wants to load %s %s.&quot;,
2205                  k-&gt;external_kind(), k-&gt;external_name());
2206         Klass *existing_klass = constraints()-&gt;find_constrained_klass(name, class_loader);
2207         if (existing_klass != NULL &amp;&amp; existing_klass-&gt;class_loader() != class_loader()) {
2208           ss.print(&quot; A different %s with the same name was previously loaded by %s. (%s)&quot;,
2209                    existing_klass-&gt;external_kind(),
2210                    existing_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
2211                    existing_klass-&gt;class_in_module_of_loader(false, true));
2212         } else {
2213           ss.print(&quot; (%s)&quot;, k-&gt;class_in_module_of_loader(false, true));
2214         }
2215       }
2216     }
2217   }
2218 
2219   // Throw error now if needed (cannot throw while holding
2220   // SystemDictionary_lock because of rank ordering)
2221   if (throwException == true) {
2222     THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());
2223   }
2224 }
2225 
2226 // Update class loader data dictionary - done after check_constraint and add_to_hierachy
2227 // have been called.
2228 void SystemDictionary::update_dictionary(unsigned int d_hash,
2229                                          int p_index, unsigned int p_hash,
2230                                          InstanceKlass* k,
2231                                          Handle class_loader,
2232                                          TRAPS) {
2233   // Compile_lock prevents systemDictionary updates during compilations
2234   assert_locked_or_safepoint(Compile_lock);
2235   Symbol*  name  = k-&gt;name();
2236   ClassLoaderData *loader_data = class_loader_data(class_loader);
2237 
2238   {
2239     MutexLocker mu1(THREAD, SystemDictionary_lock);
2240 
2241     // Make a new dictionary entry.
2242     Dictionary* dictionary = loader_data-&gt;dictionary();
2243     InstanceKlass* sd_check = find_class(d_hash, name, dictionary);
2244     if (sd_check == NULL) {
2245       dictionary-&gt;add_klass(d_hash, name, k);
2246     }
2247   #ifdef ASSERT
2248     sd_check = find_class(d_hash, name, dictionary);
2249     assert (sd_check != NULL, &quot;should have entry in dictionary&quot;);
2250     // Note: there may be a placeholder entry: for circularity testing
2251     // or for parallel defines
2252   #endif
2253     SystemDictionary_lock-&gt;notify_all();
2254   }
2255 }
2256 
2257 
2258 // Try to find a class name using the loader constraints.  The
2259 // loader constraints might know about a class that isn&#39;t fully loaded
2260 // yet and these will be ignored.
2261 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2262                     Symbol* class_name, Handle class_loader, TRAPS) {
2263 
2264   // First see if it has been loaded directly.
2265   // Force the protection domain to be null.  (This removes protection checks.)
2266   Handle no_protection_domain;
2267   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2268                                               no_protection_domain, CHECK_NULL);
2269   if (klass != NULL)
2270     return klass;
2271 
2272   // Now look to see if it has been loaded elsewhere, and is subject to
2273   // a loader constraint that would require this loader to return the
2274   // klass that is already loaded.
2275   if (Signature::is_array(class_name)) {
2276     // For array classes, their Klass*s are not kept in the
2277     // constraint table. The element Klass*s are.
2278     SignatureStream ss(class_name, false);
2279     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2280     BasicType t = ss.type();
2281     if (t != T_OBJECT) {
2282       klass = Universe::typeArrayKlassObj(t);
2283     } else {
2284       MutexLocker mu(THREAD, SystemDictionary_lock);
2285       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2286     }
2287     // If element class already loaded, allocate array klass
2288     if (klass != NULL) {
2289       klass = klass-&gt;array_klass_or_null(ndims);
2290     }
2291   } else {
2292     MutexLocker mu(THREAD, SystemDictionary_lock);
2293     // Non-array classes are easy: simply check the constraint table.
2294     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2295   }
2296 
2297   return klass;
2298 }
2299 
2300 
2301 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2302                                              Handle class_loader1,
2303                                              Handle class_loader2,
2304                                              Thread* THREAD) {
2305   ClassLoaderData* loader_data1 = class_loader_data(class_loader1);
2306   ClassLoaderData* loader_data2 = class_loader_data(class_loader2);
2307 
2308   Symbol* constraint_name = NULL;
2309 
2310   if (!Signature::is_array(class_name)) {
2311     constraint_name = class_name;
2312   } else {
2313     // For array classes, their Klass*s are not kept in the
2314     // constraint table. The element classes are.
2315     SignatureStream ss(class_name, false);
2316     ss.skip_array_prefix();  // skip all &#39;[&#39;s
2317     if (!ss.has_envelope()) {
2318       return true;     // primitive types always pass
2319     }
2320     constraint_name = ss.as_symbol();
2321     // Increment refcount to keep constraint_name alive after
2322     // SignatureStream is destructed. It will be decremented below
2323     // before returning.
2324     constraint_name-&gt;increment_refcount();
2325   }
2326 
2327   Dictionary* dictionary1 = loader_data1-&gt;dictionary();
2328   unsigned int d_hash1 = dictionary1-&gt;compute_hash(constraint_name);
2329 
2330   Dictionary* dictionary2 = loader_data2-&gt;dictionary();
2331   unsigned int d_hash2 = dictionary2-&gt;compute_hash(constraint_name);
2332 
2333   {
2334     MutexLocker mu_s(THREAD, SystemDictionary_lock);
2335     InstanceKlass* klass1 = find_class(d_hash1, constraint_name, dictionary1);
2336     InstanceKlass* klass2 = find_class(d_hash2, constraint_name, dictionary2);
2337     bool result = constraints()-&gt;add_entry(constraint_name, klass1, class_loader1,
2338                                            klass2, class_loader2);
2339     if (Signature::is_array(class_name)) {
2340       constraint_name-&gt;decrement_refcount();
2341     }
2342     return result;
2343   }
2344 }
2345 
2346 // Add entry to resolution error table to record the error when the first
2347 // attempt to resolve a reference to a class has failed.
2348 void SystemDictionary::add_resolution_error(const constantPoolHandle&amp; pool, int which,
2349                                             Symbol* error, Symbol* message) {
2350   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2351   int index = resolution_errors()-&gt;hash_to_index(hash);
2352   {
2353     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2354     resolution_errors()-&gt;add_entry(index, hash, pool, which, error, message);
2355   }
2356 }
2357 
2358 // Delete a resolution error for RedefineClasses for a constant pool is going away
2359 void SystemDictionary::delete_resolution_error(ConstantPool* pool) {
2360   resolution_errors()-&gt;delete_entry(pool);
2361 }
2362 
2363 // Lookup resolution error table. Returns error if found, otherwise NULL.
2364 Symbol* SystemDictionary::find_resolution_error(const constantPoolHandle&amp; pool, int which,
2365                                                 Symbol** message) {
2366   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2367   int index = resolution_errors()-&gt;hash_to_index(hash);
2368   {
2369     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2370     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2371     if (entry != NULL) {
2372       *message = entry-&gt;message();
2373       return entry-&gt;error();
2374     } else {
2375       return NULL;
2376     }
2377   }
2378 }
2379 
2380 // Add an entry to resolution error table to record an error in resolving or
2381 // validating a nest host. This is used to construct informative error
2382 // messages when IllegalAccessError&#39;s occur. If an entry already exists it will
2383 // be updated with the nest host error message.
2384 void SystemDictionary::add_nest_host_error(const constantPoolHandle&amp; pool,
2385                                            int which,
2386                                            const char* message) {
2387   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2388   int index = resolution_errors()-&gt;hash_to_index(hash);
2389   {
2390     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2391     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2392     if (entry != NULL) {
2393       assert(entry-&gt;nest_host_error() == NULL, &quot;Nest host error message already set!&quot;);
2394       entry-&gt;set_nest_host_error(message);
2395     } else {
2396       resolution_errors()-&gt;add_entry(index, hash, pool, which, message);
2397     }
2398   }
2399 }
2400 
2401 // Lookup any nest host error
2402 const char* SystemDictionary::find_nest_host_error(const constantPoolHandle&amp; pool, int which) {
2403   unsigned int hash = resolution_errors()-&gt;compute_hash(pool, which);
2404   int index = resolution_errors()-&gt;hash_to_index(hash);
2405   {
2406     MutexLocker ml(Thread::current(), SystemDictionary_lock);
2407     ResolutionErrorEntry* entry = resolution_errors()-&gt;find_entry(index, hash, pool, which);
2408     if (entry != NULL) {
2409       return entry-&gt;nest_host_error();
2410     } else {
2411       return NULL;
2412     }
2413   }
2414 }
2415 
2416 
2417 // Signature constraints ensure that callers and callees agree about
2418 // the meaning of type names in their signatures.  This routine is the
2419 // intake for constraints.  It collects them from several places:
2420 //
2421 //  * LinkResolver::resolve_method (if check_access is true) requires
2422 //    that the resolving class (the caller) and the defining class of
2423 //    the resolved method (the callee) agree on each type in the
2424 //    method&#39;s signature.
2425 //
2426 //  * LinkResolver::resolve_interface_method performs exactly the same
2427 //    checks.
2428 //
2429 //  * LinkResolver::resolve_field requires that the constant pool
2430 //    attempting to link to a field agree with the field&#39;s defining
2431 //    class about the type of the field signature.
2432 //
2433 //  * klassVtable::initialize_vtable requires that, when a class
2434 //    overrides a vtable entry allocated by a superclass, that the
2435 //    overriding method (i.e., the callee) agree with the superclass
2436 //    on each type in the method&#39;s signature.
2437 //
2438 //  * klassItable::initialize_itable requires that, when a class fills
2439 //    in its itables, for each non-abstract method installed in an
2440 //    itable, the method (i.e., the callee) agree with the interface
2441 //    on each type in the method&#39;s signature.
2442 //
2443 // All those methods have a boolean (check_access, checkconstraints)
2444 // which turns off the checks.  This is used from specialized contexts
2445 // such as bootstrapping, dumping, and debugging.
2446 //
2447 // No direct constraint is placed between the class and its
2448 // supertypes.  Constraints are only placed along linked relations
2449 // between callers and callees.  When a method overrides or implements
2450 // an abstract method in a supertype (superclass or interface), the
2451 // constraints are placed as if the supertype were the caller to the
2452 // overriding method.  (This works well, since callers to the
2453 // supertype have already established agreement between themselves and
2454 // the supertype.)  As a result of all this, a class can disagree with
2455 // its supertype about the meaning of a type name, as long as that
2456 // class neither calls a relevant method of the supertype, nor is
2457 // called (perhaps via an override) from the supertype.
2458 //
2459 //
2460 // SystemDictionary::check_signature_loaders(sig, l1, l2)
2461 //
2462 // Make sure all class components (including arrays) in the given
2463 // signature will be resolved to the same class in both loaders.
2464 // Returns the name of the type that failed a loader constraint check, or
2465 // NULL if no constraint failed.  No exception except OOME is thrown.
2466 // Arrays are not added to the loader constraint table, their elements are.
2467 Symbol* SystemDictionary::check_signature_loaders(Symbol* signature,
2468                                                Handle loader1, Handle loader2,
2469                                                bool is_method, TRAPS)  {
2470   // Nothing to do if loaders are the same.
2471   if (loader1() == loader2()) {
2472     return NULL;
2473   }
2474 
2475   for (SignatureStream ss(signature, is_method); !ss.is_done(); ss.next()) {
2476     if (ss.is_reference()) {
2477       Symbol* sig = ss.as_symbol();
2478       // Note: In the future, if template-like types can take
2479       // arguments, we will want to recognize them and dig out class
2480       // names hiding inside the argument lists.
2481       if (!add_loader_constraint(sig, loader1, loader2, THREAD)) {
2482         return sig;
2483       }
2484     }
2485   }
2486   return NULL;
2487 }
2488 
2489 
2490 Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,
2491                                                        Symbol* signature,
2492                                                        TRAPS) {
2493   methodHandle empty;
2494   assert(MethodHandles::is_signature_polymorphic(iid) &amp;&amp;
2495          MethodHandles::is_signature_polymorphic_intrinsic(iid) &amp;&amp;
2496          iid != vmIntrinsics::_invokeGeneric,
2497          &quot;must be a known MH intrinsic iid=%d: %s&quot;, iid, vmIntrinsics::name_at(iid));
2498 
2499   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, iid);
2500   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2501   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2502   methodHandle m;
2503   if (spe == NULL || spe-&gt;method() == NULL) {
2504     spe = NULL;
2505     // Must create lots of stuff here, but outside of the SystemDictionary lock.
2506     m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);
2507     if (!Arguments::is_interpreter_only()) {
2508       // Generate a compiled form of the MH intrinsic.
2509       AdapterHandlerLibrary::create_native_wrapper(m);
2510       // Check if have the compiled code.
2511       if (!m-&gt;has_compiled_code()) {
2512         THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),
2513                        &quot;Out of space in CodeCache for method handle intrinsic&quot;);
2514       }
2515     }
2516     // Now grab the lock.  We might have to throw away the new method,
2517     // if a racing thread has managed to install one at the same time.
2518     {
2519       MutexLocker ml(THREAD, SystemDictionary_lock);
2520       spe = invoke_method_table()-&gt;find_entry(index, hash, signature, iid);
2521       if (spe == NULL)
2522         spe = invoke_method_table()-&gt;add_entry(index, hash, signature, iid);
2523       if (spe-&gt;method() == NULL)
2524         spe-&gt;set_method(m());
2525     }
2526   }
2527 
2528   assert(spe != NULL &amp;&amp; spe-&gt;method() != NULL, &quot;&quot;);
2529   assert(Arguments::is_interpreter_only() || (spe-&gt;method()-&gt;has_compiled_code() &amp;&amp;
2530          spe-&gt;method()-&gt;code()-&gt;entry_point() == spe-&gt;method()-&gt;from_compiled_entry()),
2531          &quot;MH intrinsic invariant&quot;);
2532   return spe-&gt;method();
2533 }
2534 
2535 // Helper for unpacking the return value from linkMethod and linkCallSite.
2536 static Method* unpack_method_and_appendix(Handle mname,
2537                                           Klass* accessing_klass,
2538                                           objArrayHandle appendix_box,
2539                                           Handle* appendix_result,
2540                                           TRAPS) {
2541   if (mname.not_null()) {
2542     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
2543     if (m != NULL) {
2544       oop appendix = appendix_box-&gt;obj_at(0);
2545       LogTarget(Info, methodhandles) lt;
2546       if (lt.develop_is_enabled()) {
2547         ResourceMark rm(THREAD);
2548         LogStream ls(lt);
2549         ls.print(&quot;Linked method=&quot; INTPTR_FORMAT &quot;: &quot;, p2i(m));
2550         m-&gt;print_on(&amp;ls);
2551         if (appendix != NULL) { ls.print(&quot;appendix = &quot;); appendix-&gt;print_on(&amp;ls); }
2552         ls.cr();
2553       }
2554 
2555       (*appendix_result) = Handle(THREAD, appendix);
2556       // the target is stored in the cpCache and if a reference to this
2557       // MemberName is dropped we need a way to make sure the
2558       // class_loader containing this method is kept alive.
2559       methodHandle mh(THREAD, m); // record_dependency can safepoint.
2560       ClassLoaderData* this_key = accessing_klass-&gt;class_loader_data();
2561       this_key-&gt;record_dependency(m-&gt;method_holder());
2562       return mh();
2563     }
2564   }
2565   THROW_MSG_NULL(vmSymbols::java_lang_LinkageError(), &quot;bad value from MethodHandleNatives&quot;);
2566 }
2567 
2568 Method* SystemDictionary::find_method_handle_invoker(Klass* klass,
2569                                                      Symbol* name,
2570                                                      Symbol* signature,
2571                                                           Klass* accessing_klass,
2572                                                           Handle *appendix_result,
2573                                                           TRAPS) {
2574   assert(THREAD-&gt;can_call_java() ,&quot;&quot;);
2575   Handle method_type =
2576     SystemDictionary::find_method_handle_type(signature, accessing_klass, CHECK_NULL);
2577 
2578   int ref_kind = JVM_REF_invokeVirtual;
2579   oop name_oop = StringTable::intern(name, CHECK_NULL);
2580   Handle name_str (THREAD, name_oop);
2581   objArrayHandle appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK_NULL);
2582   assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2583 
2584   // This should not happen.  JDK code should take care of that.
2585   if (accessing_klass == NULL || method_type.is_null()) {
2586     THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;bad invokehandle&quot;);
2587   }
2588 
2589   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -&gt; MemberName
2590   JavaCallArguments args;
2591   args.push_oop(Handle(THREAD, accessing_klass-&gt;java_mirror()));
2592   args.push_int(ref_kind);
2593   args.push_oop(Handle(THREAD, klass-&gt;java_mirror()));
2594   args.push_oop(name_str);
2595   args.push_oop(method_type);
2596   args.push_oop(appendix_box);
2597   JavaValue result(T_OBJECT);
2598   JavaCalls::call_static(&amp;result,
2599                          SystemDictionary::MethodHandleNatives_klass(),
2600                          vmSymbols::linkMethod_name(),
2601                          vmSymbols::linkMethod_signature(),
2602                          &amp;args, CHECK_NULL);
2603   Handle mname(THREAD, (oop) result.get_jobject());
2604   return unpack_method_and_appendix(mname, accessing_klass, appendix_box, appendix_result, THREAD);
2605 }
2606 
2607 // Decide if we can globally cache a lookup of this class, to be returned to any client that asks.
2608 // We must ensure that all class loaders everywhere will reach this class, for any client.
2609 // This is a safe bet for public classes in java.lang, such as Object and String.
2610 // We also include public classes in java.lang.invoke, because they appear frequently in system-level method types.
2611 // Out of an abundance of caution, we do not include any other classes, not even for packages like java.util.
2612 static bool is_always_visible_class(oop mirror) {
2613   Klass* klass = java_lang_Class::as_Klass(mirror);
2614   if (klass-&gt;is_objArray_klass()) {
2615     klass = ObjArrayKlass::cast(klass)-&gt;bottom_klass(); // check element type
2616   }
2617   if (klass-&gt;is_typeArray_klass()) {
2618     return true; // primitive array
2619   }
2620   assert(klass-&gt;is_instance_klass(), &quot;%s&quot;, klass-&gt;external_name());
2621   return klass-&gt;is_public() &amp;&amp;
2622          (InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::Object_klass()) ||       // java.lang
2623           InstanceKlass::cast(klass)-&gt;is_same_class_package(SystemDictionary::MethodHandle_klass()));  // java.lang.invoke
2624 }
2625 
2626 // Find or construct the Java mirror (java.lang.Class instance) for
2627 // the given field type signature, as interpreted relative to the
2628 // given class loader.  Handles primitives, void, references, arrays,
2629 // and all other reflectable types, except method types.
2630 // N.B.  Code in reflection should use this entry point.
2631 Handle SystemDictionary::find_java_mirror_for_type(Symbol* signature,
2632                                                    Klass* accessing_klass,
2633                                                    Handle class_loader,
2634                                                    Handle protection_domain,
2635                                                    SignatureStream::FailureMode failure_mode,
2636                                                    TRAPS) {
2637   assert(accessing_klass == NULL || (class_loader.is_null() &amp;&amp; protection_domain.is_null()),
2638          &quot;one or the other, or perhaps neither&quot;);
2639 
2640   // What we have here must be a valid field descriptor,
2641   // and all valid field descriptors are supported.
2642   // Produce the same java.lang.Class that reflection reports.
2643   if (accessing_klass != NULL) {
2644     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2645     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2646   }
2647   ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);
2648   oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);
2649   if (mirror_oop == NULL) {
2650     return Handle();  // report failure this way
2651   }
2652   Handle mirror(THREAD, mirror_oop);
2653 
2654   if (accessing_klass != NULL) {
2655     // Check accessibility, emulating ConstantPool::verify_constant_pool_resolve.
2656     Klass* sel_klass = java_lang_Class::as_Klass(mirror());
2657     if (sel_klass != NULL) {
2658       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_NH);
2659     }
2660   }
2661   return mirror;
2662 }
2663 
2664 
2665 // Ask Java code to find or construct a java.lang.invoke.MethodType for the given
2666 // signature, as interpreted relative to the given class loader.
2667 // Because of class loader constraints, all method handle usage must be
2668 // consistent with this loader.
2669 Handle SystemDictionary::find_method_handle_type(Symbol* signature,
2670                                                  Klass* accessing_klass,
2671                                                  TRAPS) {
2672   Handle empty;
2673   vmIntrinsics::ID null_iid = vmIntrinsics::_none;  // distinct from all method handle invoker intrinsics
2674   unsigned int hash  = invoke_method_table()-&gt;compute_hash(signature, null_iid);
2675   int          index = invoke_method_table()-&gt;hash_to_index(hash);
2676   SymbolPropertyEntry* spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2677   if (spe != NULL &amp;&amp; spe-&gt;method_type() != NULL) {
2678     assert(java_lang_invoke_MethodType::is_instance(spe-&gt;method_type()), &quot;&quot;);
2679     return Handle(THREAD, spe-&gt;method_type());
2680   } else if (!THREAD-&gt;can_call_java()) {
2681     warning(&quot;SystemDictionary::find_method_handle_type called from compiler thread&quot;);  // FIXME
2682     return Handle();  // do not attempt from within compiler, unless it was cached
2683   }
2684 
2685   Handle class_loader, protection_domain;
2686   if (accessing_klass != NULL) {
2687     class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2688     protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2689   }
2690   bool can_be_cached = true;
2691   int npts = ArgumentCount(signature).size();
2692   objArrayHandle pts = oopFactory::new_objArray_handle(SystemDictionary::Class_klass(), npts, CHECK_(empty));
2693   int arg = 0;
2694   Handle rt; // the return type from the signature
2695   ResourceMark rm(THREAD);
2696   for (SignatureStream ss(signature); !ss.is_done(); ss.next()) {
2697     oop mirror = NULL;
2698     if (can_be_cached) {
2699       // Use neutral class loader to lookup candidate classes to be placed in the cache.
2700       mirror = ss.as_java_mirror(Handle(), Handle(),
2701                                  SignatureStream::ReturnNull, CHECK_(empty));
2702       if (mirror == NULL || (ss.is_reference() &amp;&amp; !is_always_visible_class(mirror))) {
2703         // Fall back to accessing_klass context.
2704         can_be_cached = false;
2705       }
2706     }
2707     if (!can_be_cached) {
2708       // Resolve, throwing a real error if it doesn&#39;t work.
2709       mirror = ss.as_java_mirror(class_loader, protection_domain,
2710                                  SignatureStream::NCDFError, CHECK_(empty));
2711     }
2712     assert(mirror != NULL, &quot;%s&quot;, ss.as_symbol()-&gt;as_C_string());
2713     if (ss.at_return_type())
2714       rt = Handle(THREAD, mirror);
2715     else
2716       pts-&gt;obj_at_put(arg++, mirror);
2717 
2718     // Check accessibility.
2719     if (!java_lang_Class::is_primitive(mirror) &amp;&amp; accessing_klass != NULL) {
2720       Klass* sel_klass = java_lang_Class::as_Klass(mirror);
2721       mirror = NULL;  // safety
2722       // Emulate ConstantPool::verify_constant_pool_resolve.
2723       LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_(empty));
2724     }
2725   }
2726   assert(arg == npts, &quot;&quot;);
2727 
2728   // call java.lang.invoke.MethodHandleNatives::findMethodHandleType(Class rt, Class[] pts) -&gt; MethodType
2729   JavaCallArguments args(Handle(THREAD, rt()));
2730   args.push_oop(pts);
2731   JavaValue result(T_OBJECT);
2732   JavaCalls::call_static(&amp;result,
2733                          SystemDictionary::MethodHandleNatives_klass(),
2734                          vmSymbols::findMethodHandleType_name(),
2735                          vmSymbols::findMethodHandleType_signature(),
2736                          &amp;args, CHECK_(empty));
2737   Handle method_type(THREAD, (oop) result.get_jobject());
2738 
2739   if (can_be_cached) {
2740     // We can cache this MethodType inside the JVM.
2741     MutexLocker ml(THREAD, SystemDictionary_lock);
2742     spe = invoke_method_table()-&gt;find_entry(index, hash, signature, null_iid);
2743     if (spe == NULL)
2744       spe = invoke_method_table()-&gt;add_entry(index, hash, signature, null_iid);
2745     if (spe-&gt;method_type() == NULL) {
2746       spe-&gt;set_method_type(method_type());
2747     }
2748   }
2749 
2750   // report back to the caller with the MethodType
2751   return method_type;
2752 }
2753 
2754 Handle SystemDictionary::find_field_handle_type(Symbol* signature,
2755                                                 Klass* accessing_klass,
2756                                                 TRAPS) {
2757   Handle empty;
2758   ResourceMark rm(THREAD);
2759   SignatureStream ss(signature, /*is_method=*/ false);
2760   if (!ss.is_done()) {
2761     Handle class_loader, protection_domain;
2762     if (accessing_klass != NULL) {
2763       class_loader      = Handle(THREAD, accessing_klass-&gt;class_loader());
2764       protection_domain = Handle(THREAD, accessing_klass-&gt;protection_domain());
2765     }
2766     oop mirror = ss.as_java_mirror(class_loader, protection_domain, SignatureStream::NCDFError, CHECK_(empty));
2767     ss.next();
2768     if (ss.is_done()) {
2769       return Handle(THREAD, mirror);
2770     }
2771   }
2772   return empty;
2773 }
2774 
2775 // Ask Java code to find or construct a method handle constant.
2776 Handle SystemDictionary::link_method_handle_constant(Klass* caller,
2777                                                      int ref_kind, //e.g., JVM_REF_invokeVirtual
2778                                                      Klass* callee,
2779                                                      Symbol* name,
2780                                                      Symbol* signature,
2781                                                      TRAPS) {
2782   Handle empty;
2783   if (caller == NULL) {
2784     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;bad MH constant&quot;, empty);
2785   }
2786   Handle name_str      = java_lang_String::create_from_symbol(name,      CHECK_(empty));
2787   Handle signature_str = java_lang_String::create_from_symbol(signature, CHECK_(empty));
2788 
2789   // Put symbolic info from the MH constant into freshly created MemberName and resolve it.
2790   Handle mname = MemberName_klass()-&gt;allocate_instance_handle(CHECK_(empty));
2791   java_lang_invoke_MemberName::set_clazz(mname(), callee-&gt;java_mirror());
2792   java_lang_invoke_MemberName::set_name (mname(), name_str());
2793   java_lang_invoke_MemberName::set_type (mname(), signature_str());
2794   java_lang_invoke_MemberName::set_flags(mname(), MethodHandles::ref_kind_to_flags(ref_kind));
2795 
2796   if (ref_kind == JVM_REF_invokeVirtual &amp;&amp;
2797       MethodHandles::is_signature_polymorphic_public_name(callee, name)) {
2798     // Skip resolution for public signature polymorphic methods such as
2799     // j.l.i.MethodHandle.invoke()/invokeExact() and those on VarHandle
2800     // They require appendix argument which MemberName resolution doesn&#39;t handle.
2801     // There&#39;s special logic on JDK side to handle them
2802     // (see MethodHandles.linkMethodHandleConstant() and MethodHandles.findVirtualForMH()).
2803   } else {
2804     MethodHandles::resolve_MemberName(mname, caller, /*speculative_resolve*/false, CHECK_(empty));
2805   }
2806 
2807   // After method/field resolution succeeded, it&#39;s safe to resolve MH signature as well.
2808   Handle type = MethodHandles::resolve_MemberName_type(mname, caller, CHECK_(empty));
2809 
2810   // call java.lang.invoke.MethodHandleNatives::linkMethodHandleConstant(Class caller, int refKind, Class callee, String name, Object type) -&gt; MethodHandle
2811   JavaCallArguments args;
2812   args.push_oop(Handle(THREAD, caller-&gt;java_mirror()));  // the referring class
2813   args.push_int(ref_kind);
2814   args.push_oop(Handle(THREAD, callee-&gt;java_mirror()));  // the target class
2815   args.push_oop(name_str);
2816   args.push_oop(type);
2817   JavaValue result(T_OBJECT);
2818   JavaCalls::call_static(&amp;result,
2819                          SystemDictionary::MethodHandleNatives_klass(),
2820                          vmSymbols::linkMethodHandleConstant_name(),
2821                          vmSymbols::linkMethodHandleConstant_signature(),
2822                          &amp;args, CHECK_(empty));
2823   return Handle(THREAD, (oop) result.get_jobject());
2824 }
2825 
2826 // Ask Java to run a bootstrap method, in order to create a dynamic call site
2827 // while linking an invokedynamic op, or compute a constant for Dynamic_info CP entry
2828 // with linkage results being stored back into the bootstrap specifier.
2829 void SystemDictionary::invoke_bootstrap_method(BootstrapInfo&amp; bootstrap_specifier, TRAPS) {
2830   // Resolve the bootstrap specifier, its name, type, and static arguments
2831   bootstrap_specifier.resolve_bsm(CHECK);
2832 
2833   // This should not happen.  JDK code should take care of that.
2834   if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {
2835     THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;Invalid bootstrap method invocation with no caller or type argument&quot;);
2836   }
2837 
2838   bool is_indy = bootstrap_specifier.is_method_call();
2839   objArrayHandle appendix_box;
2840   if (is_indy) {
2841     // Some method calls may require an appendix argument.  Arrange to receive it.
2842     appendix_box = oopFactory::new_objArray_handle(SystemDictionary::Object_klass(), 1, CHECK);
2843     assert(appendix_box-&gt;obj_at(0) == NULL, &quot;&quot;);
2844   }
2845 
2846   // call condy: java.lang.invoke.MethodHandleNatives::linkDynamicConstant(caller, condy_index, bsm, type, info)
2847   //       indy: java.lang.invoke.MethodHandleNatives::linkCallSite(caller, indy_index, bsm, name, mtype, info, &amp;appendix)
2848   JavaCallArguments args;
2849   args.push_oop(Handle(THREAD, bootstrap_specifier.caller_mirror()));
2850   args.push_int(bootstrap_specifier.bss_index());
2851   args.push_oop(bootstrap_specifier.bsm());
2852   args.push_oop(bootstrap_specifier.name_arg());
2853   args.push_oop(bootstrap_specifier.type_arg());
2854   args.push_oop(bootstrap_specifier.arg_values());
2855   if (is_indy) {
2856     args.push_oop(appendix_box);
2857   }
2858   JavaValue result(T_OBJECT);
2859   JavaCalls::call_static(&amp;result,
2860                          SystemDictionary::MethodHandleNatives_klass(),
2861                          is_indy ? vmSymbols::linkCallSite_name() : vmSymbols::linkDynamicConstant_name(),
2862                          is_indy ? vmSymbols::linkCallSite_signature() : vmSymbols::linkDynamicConstant_signature(),
2863                          &amp;args, CHECK);
2864 
2865   Handle value(THREAD, (oop) result.get_jobject());
2866   if (is_indy) {
2867     Handle appendix;
2868     Method* method = unpack_method_and_appendix(value,
2869                                                 bootstrap_specifier.caller(),
2870                                                 appendix_box,
2871                                                 &amp;appendix, CHECK);
2872     methodHandle mh(THREAD, method);
2873     bootstrap_specifier.set_resolved_method(mh, appendix);
2874   } else {
2875     bootstrap_specifier.set_resolved_value(value);
2876   }
2877 
2878   // sanity check
2879   assert(bootstrap_specifier.is_resolved() ||
2880          (bootstrap_specifier.is_method_call() &amp;&amp;
2881           bootstrap_specifier.resolved_method().not_null()), &quot;bootstrap method call failed&quot;);
2882 }
2883 
2884 // Protection domain cache table handling
2885 
2886 ProtectionDomainCacheEntry* SystemDictionary::cache_get(Handle protection_domain) {
2887   return _pd_cache_table-&gt;get(protection_domain);
2888 }
2889 
2890 // ----------------------------------------------------------------------------
2891 
2892 void SystemDictionary::print_on(outputStream *st) {
2893   CDS_ONLY(SystemDictionaryShared::print_on(st));
2894   GCMutexLocker mu(SystemDictionary_lock);
2895 
2896   ClassLoaderDataGraph::print_dictionary(st);
2897 
2898   // Placeholders
2899   placeholders()-&gt;print_on(st);
2900   st-&gt;cr();
2901 
2902   // loader constraints - print under SD_lock
2903   constraints()-&gt;print_on(st);
2904   st-&gt;cr();
2905 
2906   _pd_cache_table-&gt;print_on(st);
2907   st-&gt;cr();
2908 }
2909 
2910 void SystemDictionary::print() { print_on(tty); }
2911 
2912 void SystemDictionary::verify() {
2913   guarantee(constraints() != NULL,
2914             &quot;Verify of loader constraints failed&quot;);
2915   guarantee(placeholders()-&gt;number_of_entries() &gt;= 0,
2916             &quot;Verify of placeholders failed&quot;);
2917 
2918   GCMutexLocker mu(SystemDictionary_lock);
2919 
2920   // Verify dictionary
2921   ClassLoaderDataGraph::verify_dictionary();
2922 
2923   placeholders()-&gt;verify();
2924 
2925   // Verify constraint table
2926   guarantee(constraints() != NULL, &quot;Verify of loader constraints failed&quot;);
2927   constraints()-&gt;verify(placeholders());
2928 
2929   _pd_cache_table-&gt;verify();
2930 }
2931 
2932 void SystemDictionary::dump(outputStream *st, bool verbose) {
2933   assert_locked_or_safepoint(SystemDictionary_lock);
2934   if (verbose) {
2935     print_on(st);
2936   } else {
2937     CDS_ONLY(SystemDictionaryShared::print_table_statistics(st));
2938     ClassLoaderDataGraph::print_table_statistics(st);
2939     placeholders()-&gt;print_table_statistics(st, &quot;Placeholder Table&quot;);
2940     constraints()-&gt;print_table_statistics(st, &quot;LoaderConstraints Table&quot;);
2941     pd_cache_table()-&gt;print_table_statistics(st, &quot;ProtectionDomainCache Table&quot;);
2942   }
2943 }
2944 
2945 TableStatistics SystemDictionary::placeholders_statistics() {
2946   MutexLocker ml(SystemDictionary_lock);
2947   return placeholders()-&gt;statistics_calculate();
2948 }
2949 
2950 TableStatistics SystemDictionary::loader_constraints_statistics() {
2951   MutexLocker ml(SystemDictionary_lock);
2952   return constraints()-&gt;statistics_calculate();
2953 }
2954 
2955 TableStatistics SystemDictionary::protection_domain_cache_statistics() {
2956   MutexLocker ml(SystemDictionary_lock);
2957   return pd_cache_table()-&gt;statistics_calculate();
2958 }
2959 
2960 // Utility for dumping dictionaries.
2961 SystemDictionaryDCmd::SystemDictionaryDCmd(outputStream* output, bool heap) :
2962                                  DCmdWithParser(output, heap),
2963   _verbose(&quot;-verbose&quot;, &quot;Dump the content of each dictionary entry for all class loaders&quot;,
2964            &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
2965   _dcmdparser.add_dcmd_option(&amp;_verbose);
2966 }
2967 
2968 void SystemDictionaryDCmd::execute(DCmdSource source, TRAPS) {
2969   VM_DumpHashtable dumper(output(), VM_DumpHashtable::DumpSysDict,
2970                          _verbose.value());
2971   VMThread::execute(&amp;dumper);
2972 }
2973 
2974 int SystemDictionaryDCmd::num_arguments() {
2975   ResourceMark rm;
2976   SystemDictionaryDCmd* dcmd = new SystemDictionaryDCmd(NULL, false);
2977   if (dcmd != NULL) {
2978     DCmdMark mark(dcmd);
2979     return dcmd-&gt;_dcmdparser.num_arguments();
2980   } else {
2981     return 0;
2982   }
2983 }
    </pre>
  </body>
</html>
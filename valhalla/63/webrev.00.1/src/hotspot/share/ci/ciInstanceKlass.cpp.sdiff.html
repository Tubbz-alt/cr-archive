<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/ci/ciInstanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="ciField.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/ci/ciInstanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciField.hpp&quot;
 27 #include &quot;ci/ciInstance.hpp&quot;
 28 #include &quot;ci/ciInstanceKlass.hpp&quot;
 29 #include &quot;ci/ciUtilities.inline.hpp&quot;

 30 #include &quot;classfile/systemDictionary.hpp&quot;
 31 #include &quot;memory/allocation.hpp&quot;
 32 #include &quot;memory/allocation.inline.hpp&quot;
 33 #include &quot;memory/resourceArea.hpp&quot;
 34 #include &quot;oops/oop.inline.hpp&quot;
 35 #include &quot;oops/fieldStreams.inline.hpp&quot;

 36 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 37 #include &quot;runtime/handles.inline.hpp&quot;
 38 #include &quot;runtime/jniHandles.inline.hpp&quot;
 39 
 40 // ciInstanceKlass
 41 //
 42 // This class represents a Klass* in the HotSpot virtual machine
 43 // whose Klass part in an InstanceKlass.
 44 
 45 
 46 // ------------------------------------------------------------------
 47 // ciInstanceKlass::ciInstanceKlass
 48 //
 49 // Loaded instance klass.
 50 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 51   ciKlass(k)
 52 {
 53   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 54   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 55   InstanceKlass* ik = get_instanceKlass();
</pre>
<hr />
<pre>
 97     _protection_domain = JNIHandles::make_global(h_protection_domain);
 98     _is_shared = true;
 99   }
100 
101   // Lazy fields get filled in only upon request.
102   _super  = NULL;
103   _java_mirror = NULL;
104 
105   if (is_shared()) {
106     if (k != SystemDictionary::Object_klass()) {
107       super();
108     }
109     //compute_nonstatic_fields();  // done outside of constructor
110   }
111 
112   _field_cache = NULL;
113 }
114 
115 // Version for unloaded classes:
116 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
<span class="line-modified">117                                  jobject loader, jobject protection_domain)</span>
<span class="line-modified">118   : ciKlass(name, T_OBJECT)</span>

119 {
120   assert(name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY, &quot;not an instance klass&quot;);
121   _init_state = (InstanceKlass::ClassState)0;
122   _nonstatic_field_size = -1;
123   _has_nonstatic_fields = false;
<span class="line-modified">124   _nonstatic_fields = NULL;</span>
125   _has_injected_fields = -1;
126   _is_unsafe_anonymous = false;
127   _is_hidden = false;
128   _loader = loader;
129   _protection_domain = protection_domain;
130   _is_shared = false;
131   _super = NULL;
132   _java_mirror = NULL;
133   _field_cache = NULL;
134 }
135 
136 
137 
138 // ------------------------------------------------------------------
139 // ciInstanceKlass::compute_shared_is_initialized
140 void ciInstanceKlass::compute_shared_init_state() {
141   GUARDED_VM_ENTRY(
142     InstanceKlass* ik = get_instanceKlass();
143     _init_state = ik-&gt;init_state();
144   )
</pre>
<hr />
<pre>
413       ciField* field = _nonstatic_fields-&gt;at(i);
414       int  field_off = field-&gt;offset_in_bytes();
415       if (field_off == field_offset)
416         return field;
417       if (field_off &gt; field_offset)
418         break;
419       // could do binary search or check bins, but probably not worth it
420     }
421     return NULL;
422   }
423   VM_ENTRY_MARK;
424   InstanceKlass* k = get_instanceKlass();
425   fieldDescriptor fd;
426   if (!k-&gt;find_field_from_offset(field_offset, is_static, &amp;fd)) {
427     return NULL;
428   }
429   ciField* field = new (CURRENT_THREAD_ENV-&gt;arena()) ciField(&amp;fd);
430   return field;
431 }
432 























433 // ------------------------------------------------------------------
434 // ciInstanceKlass::get_field_by_name
435 ciField* ciInstanceKlass::get_field_by_name(ciSymbol* name, ciSymbol* signature, bool is_static) {
436   VM_ENTRY_MARK;
437   InstanceKlass* k = get_instanceKlass();
438   fieldDescriptor fd;
439   Klass* def = k-&gt;find_field(name-&gt;get_symbol(), signature-&gt;get_symbol(), is_static, &amp;fd);
440   if (def == NULL) {
441     return NULL;
442   }
443   ciField* field = new (CURRENT_THREAD_ENV-&gt;arena()) ciField(&amp;fd);
444   return field;
445 }
446 
447 
448 static int sort_field_by_offset(ciField** a, ciField** b) {
449   return (*a)-&gt;offset_in_bytes() - (*b)-&gt;offset_in_bytes();
450   // (no worries about 32-bit overflow...)
451 }
452 
</pre>
<hr />
<pre>
474     int super_flen   = super-&gt;nof_nonstatic_fields();
475     super_fields = super-&gt;_nonstatic_fields;
476     assert(super_flen == 0 || super_fields != NULL, &quot;first get nof_fields&quot;);
477   }
478 
479   GrowableArray&lt;ciField*&gt;* fields = NULL;
480   GUARDED_VM_ENTRY({
481       fields = compute_nonstatic_fields_impl(super_fields);
482     });
483 
484   if (fields == NULL) {
485     // This can happen if this class (java.lang.Class) has invisible fields.
486     if (super_fields != NULL) {
487       _nonstatic_fields = super_fields;
488       return super_fields-&gt;length();
489     } else {
490       return 0;
491     }
492   }
493 
<span class="line-modified">494   int flen = fields-&gt;length();</span>
<span class="line-removed">495 </span>
<span class="line-removed">496   // Now sort them by offset, ascending.</span>
<span class="line-removed">497   // (In principle, they could mix with superclass fields.)</span>
<span class="line-removed">498   fields-&gt;sort(sort_field_by_offset);</span>
<span class="line-removed">499   _nonstatic_fields = fields;</span>
500   return flen;
501 }
502 
<span class="line-modified">503 GrowableArray&lt;ciField*&gt;*</span>
<span class="line-removed">504 ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray&lt;ciField*&gt;*</span>
<span class="line-removed">505                                                super_fields) {</span>
506   ASSERT_IN_VM;
507   Arena* arena = CURRENT_ENV-&gt;arena();
508   int flen = 0;
509   GrowableArray&lt;ciField*&gt;* fields = NULL;
510   InstanceKlass* k = get_instanceKlass();
511   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
512     if (fs.access_flags().is_static())  continue;
513     flen += 1;
514   }
515 
516   // allocate the array:
517   if (flen == 0) {
518     return NULL;  // return nothing if none are locally declared
519   }
520   if (super_fields != NULL) {
521     flen += super_fields-&gt;length();
522   }

523   fields = new (arena) GrowableArray&lt;ciField*&gt;(arena, flen, 0, NULL);
524   if (super_fields != NULL) {
525     fields-&gt;appendAll(super_fields);
526   }
527 
528   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
529     if (fs.access_flags().is_static())  continue;
530     fieldDescriptor&amp; fd = fs.field_descriptor();
<span class="line-modified">531     ciField* field = new (arena) ciField(&amp;fd);</span>
<span class="line-modified">532     fields-&gt;append(field);</span>




















533   }
534   assert(fields-&gt;length() == flen, &quot;sanity&quot;);



535   return fields;
536 }
537 
538 bool ciInstanceKlass::compute_injected_fields_helper() {
539   ASSERT_IN_VM;
540   InstanceKlass* k = get_instanceKlass();
541 
542   for (InternalFieldStream fs(k); !fs.done(); fs.next()) {
543     if (fs.access_flags().is_static())  continue;
544     return true;
545   }
546   return false;
547 }
548 
549 void ciInstanceKlass::compute_injected_fields() {
550   assert(is_loaded(), &quot;must be loaded&quot;);
551 
552   int has_injected_fields = 0;
553   if (super() != NULL &amp;&amp; super()-&gt;has_injected_fields()) {
554     has_injected_fields = 1;
</pre>
<hr />
<pre>
612       VM_ENTRY_MARK;
613       MutexLocker ml(Compile_lock);
614       Klass* k = get_instanceKlass()-&gt;implementor();
615       if (k != NULL) {
616         if (k == get_instanceKlass()) {
617           // More than one implementors. Use &#39;this&#39; in this case.
618           impl = this;
619         } else {
620           impl = CURRENT_THREAD_ENV-&gt;get_instance_klass(k);
621         }
622       }
623     }
624     // Memoize this result.
625     if (!is_shared()) {
626       _implementor = impl;
627     }
628   }
629   return impl;
630 }
631 






























632 ciInstanceKlass* ciInstanceKlass::unsafe_anonymous_host() {
633   assert(is_loaded(), &quot;must be loaded&quot;);
634   if (is_unsafe_anonymous()) {
635     VM_ENTRY_MARK
636     Klass* unsafe_anonymous_host = get_instanceKlass()-&gt;unsafe_anonymous_host();
637     return CURRENT_ENV-&gt;get_instance_klass(unsafe_anonymous_host);
638   }
639   return NULL;
640 }
641 
642 // Utility class for printing of the contents of the static fields for
643 // use by compilation replay.  It only prints out the information that
644 // could be consumed by the compiler, so for primitive types it prints
645 // out the actual value.  For Strings it&#39;s the actual string value.
646 // For array types it it&#39;s first level array size since that&#39;s the
647 // only value which statically unchangeable.  For all other reference
648 // types it simply prints out the dynamic type.
649 
<span class="line-modified">650 class StaticFinalFieldPrinter : public FieldClosure {</span>

651   outputStream* _out;








652   const char*   _holder;
653  public:
654   StaticFinalFieldPrinter(outputStream* out, const char* holder) :
<span class="line-modified">655     _out(out),</span>
<span class="line-removed">656     _holder(holder) {</span>
657   }
658   void do_field(fieldDescriptor* fd) {
659     if (fd-&gt;is_final() &amp;&amp; !fd-&gt;has_initial_value()) {
660       ResourceMark rm;
<span class="line-modified">661       oop mirror = fd-&gt;field_holder()-&gt;java_mirror();</span>
<span class="line-modified">662       _out-&gt;print(&quot;staticfield %s %s %s &quot;, _holder, fd-&gt;name()-&gt;as_quoted_ascii(), fd-&gt;signature()-&gt;as_quoted_ascii());</span>
<span class="line-modified">663       switch (fd-&gt;field_type()) {</span>
<span class="line-modified">664         case T_BYTE:    _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;byte_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">665         case T_BOOLEAN: _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;bool_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">666         case T_SHORT:   _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;short_field(fd-&gt;offset()));  break;</span>
<span class="line-modified">667         case T_CHAR:    _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;char_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">668         case T_INT:     _out-&gt;print_cr(&quot;%d&quot;, mirror-&gt;int_field(fd-&gt;offset()));    break;</span>
<span class="line-modified">669         case T_LONG:    _out-&gt;print_cr(INT64_FORMAT, (int64_t)(mirror-&gt;long_field(fd-&gt;offset())));   break;</span>
<span class="line-modified">670         case T_FLOAT: {</span>
<span class="line-modified">671           float f = mirror-&gt;float_field(fd-&gt;offset());</span>
<span class="line-modified">672           _out-&gt;print_cr(&quot;%d&quot;, *(int*)&amp;f);</span>
<span class="line-modified">673           break;</span>
<span class="line-modified">674         }</span>
<span class="line-modified">675         case T_DOUBLE: {</span>
<span class="line-modified">676           double d = mirror-&gt;double_field(fd-&gt;offset());</span>
<span class="line-modified">677           _out-&gt;print_cr(INT64_FORMAT, *(int64_t*)&amp;d);</span>
<span class="line-modified">678           break;</span>
<span class="line-modified">679         }</span>
<span class="line-modified">680         case T_ARRAY:  // fall-through</span>
<span class="line-modified">681         case T_OBJECT: {</span>
<span class="line-modified">682           oop value =  mirror-&gt;obj_field_acquire(fd-&gt;offset());</span>
<span class="line-modified">683           if (value == NULL) {</span>
<span class="line-modified">684             _out-&gt;print_cr(&quot;null&quot;);</span>
<span class="line-modified">685           } else if (value-&gt;is_instance()) {</span>
<span class="line-modified">686             assert(fd-&gt;field_type() == T_OBJECT, &quot;&quot;);</span>
<span class="line-modified">687             if (value-&gt;is_a(SystemDictionary::String_klass())) {</span>
<span class="line-modified">688               const char* ascii_value = java_lang_String::as_quoted_ascii(value);</span>
<span class="line-modified">689               _out-&gt;print(&quot;\&quot;%s\&quot;&quot;, (ascii_value != NULL) ? ascii_value : &quot;&quot;);</span>
<span class="line-modified">690             } else {</span>
<span class="line-modified">691               const char* klass_name  = value-&gt;klass()-&gt;name()-&gt;as_quoted_ascii();</span>
<span class="line-modified">692               _out-&gt;print_cr(&quot;%s&quot;, klass_name);</span>
<span class="line-modified">693             }</span>
<span class="line-modified">694           } else if (value-&gt;is_array()) {</span>
<span class="line-modified">695             typeArrayOop ta = (typeArrayOop)value;</span>
<span class="line-modified">696             _out-&gt;print(&quot;%d&quot;, ta-&gt;length());</span>
<span class="line-modified">697             if (value-&gt;is_objArray()) {</span>
<span class="line-modified">698               objArrayOop oa = (objArrayOop)value;</span>
<span class="line-modified">699               const char* klass_name  = value-&gt;klass()-&gt;name()-&gt;as_quoted_ascii();</span>
<span class="line-modified">700               _out-&gt;print(&quot; %s&quot;, klass_name);</span>
<span class="line-modified">701             }</span>
<span class="line-modified">702             _out-&gt;cr();</span>
<span class="line-modified">703           } else {</span>
<span class="line-modified">704             ShouldNotReachHere();</span>
<span class="line-modified">705           }</span>
<span class="line-modified">706           break;</span>












707         }
<span class="line-modified">708         default:</span>
<span class="line-modified">709           ShouldNotReachHere();</span>





710         }




711     }
























712   }
<span class="line-modified">713 };</span>
714 
715 
716 void ciInstanceKlass::dump_replay_data(outputStream* out) {
717   ResourceMark rm;
718 
719   InstanceKlass* ik = get_instanceKlass();
720   ConstantPool*  cp = ik-&gt;constants();
721 
722   // Try to record related loaded classes
723   Klass* sub = ik-&gt;subklass();
724   while (sub != NULL) {
725     if (sub-&gt;is_instance_klass()) {
726       out-&gt;print_cr(&quot;instanceKlass %s&quot;, sub-&gt;name()-&gt;as_quoted_ascii());
727     }
728     sub = sub-&gt;next_sibling();
729   }
730 
731   // Dump out the state of the constant pool tags.  During replay the
732   // tags will be validated for things which shouldn&#39;t change and
733   // classes will be resolved if the tags indicate that they were
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;ci/ciField.hpp&quot;
 27 #include &quot;ci/ciInstance.hpp&quot;
 28 #include &quot;ci/ciInstanceKlass.hpp&quot;
 29 #include &quot;ci/ciUtilities.inline.hpp&quot;
<span class="line-added"> 30 #include &quot;ci/ciValueKlass.hpp&quot;</span>
 31 #include &quot;classfile/systemDictionary.hpp&quot;
 32 #include &quot;memory/allocation.hpp&quot;
 33 #include &quot;memory/allocation.inline.hpp&quot;
 34 #include &quot;memory/resourceArea.hpp&quot;
 35 #include &quot;oops/oop.inline.hpp&quot;
 36 #include &quot;oops/fieldStreams.inline.hpp&quot;
<span class="line-added"> 37 #include &quot;oops/valueKlass.inline.hpp&quot;</span>
 38 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
 39 #include &quot;runtime/handles.inline.hpp&quot;
 40 #include &quot;runtime/jniHandles.inline.hpp&quot;
 41 
 42 // ciInstanceKlass
 43 //
 44 // This class represents a Klass* in the HotSpot virtual machine
 45 // whose Klass part in an InstanceKlass.
 46 
 47 
 48 // ------------------------------------------------------------------
 49 // ciInstanceKlass::ciInstanceKlass
 50 //
 51 // Loaded instance klass.
 52 ciInstanceKlass::ciInstanceKlass(Klass* k) :
 53   ciKlass(k)
 54 {
 55   assert(get_Klass()-&gt;is_instance_klass(), &quot;wrong type&quot;);
 56   assert(get_instanceKlass()-&gt;is_loaded(), &quot;must be at least loaded&quot;);
 57   InstanceKlass* ik = get_instanceKlass();
</pre>
<hr />
<pre>
 99     _protection_domain = JNIHandles::make_global(h_protection_domain);
100     _is_shared = true;
101   }
102 
103   // Lazy fields get filled in only upon request.
104   _super  = NULL;
105   _java_mirror = NULL;
106 
107   if (is_shared()) {
108     if (k != SystemDictionary::Object_klass()) {
109       super();
110     }
111     //compute_nonstatic_fields();  // done outside of constructor
112   }
113 
114   _field_cache = NULL;
115 }
116 
117 // Version for unloaded classes:
118 ciInstanceKlass::ciInstanceKlass(ciSymbol* name,
<span class="line-modified">119                                  jobject loader, jobject protection_domain,</span>
<span class="line-modified">120                                  BasicType bt)</span>
<span class="line-added">121   : ciKlass(name, bt)</span>
122 {
123   assert(name-&gt;char_at(0) != JVM_SIGNATURE_ARRAY, &quot;not an instance klass&quot;);
124   _init_state = (InstanceKlass::ClassState)0;
125   _nonstatic_field_size = -1;
126   _has_nonstatic_fields = false;
<span class="line-modified">127   _nonstatic_fields = NULL;            // initialized lazily by compute_nonstatic_fields</span>
128   _has_injected_fields = -1;
129   _is_unsafe_anonymous = false;
130   _is_hidden = false;
131   _loader = loader;
132   _protection_domain = protection_domain;
133   _is_shared = false;
134   _super = NULL;
135   _java_mirror = NULL;
136   _field_cache = NULL;
137 }
138 
139 
140 
141 // ------------------------------------------------------------------
142 // ciInstanceKlass::compute_shared_is_initialized
143 void ciInstanceKlass::compute_shared_init_state() {
144   GUARDED_VM_ENTRY(
145     InstanceKlass* ik = get_instanceKlass();
146     _init_state = ik-&gt;init_state();
147   )
</pre>
<hr />
<pre>
416       ciField* field = _nonstatic_fields-&gt;at(i);
417       int  field_off = field-&gt;offset_in_bytes();
418       if (field_off == field_offset)
419         return field;
420       if (field_off &gt; field_offset)
421         break;
422       // could do binary search or check bins, but probably not worth it
423     }
424     return NULL;
425   }
426   VM_ENTRY_MARK;
427   InstanceKlass* k = get_instanceKlass();
428   fieldDescriptor fd;
429   if (!k-&gt;find_field_from_offset(field_offset, is_static, &amp;fd)) {
430     return NULL;
431   }
432   ciField* field = new (CURRENT_THREAD_ENV-&gt;arena()) ciField(&amp;fd);
433   return field;
434 }
435 
<span class="line-added">436 ciField* ciInstanceKlass::get_non_flattened_field_by_offset(int field_offset) {</span>
<span class="line-added">437   if (super() != NULL &amp;&amp; super()-&gt;has_nonstatic_fields()) {</span>
<span class="line-added">438     ciField* f = super()-&gt;get_non_flattened_field_by_offset(field_offset);</span>
<span class="line-added">439     if (f != NULL) {</span>
<span class="line-added">440       return f;</span>
<span class="line-added">441     }</span>
<span class="line-added">442   }</span>
<span class="line-added">443 </span>
<span class="line-added">444   VM_ENTRY_MARK;</span>
<span class="line-added">445   InstanceKlass* k = get_instanceKlass();</span>
<span class="line-added">446   Arena* arena = CURRENT_ENV-&gt;arena();</span>
<span class="line-added">447   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {</span>
<span class="line-added">448     if (fs.access_flags().is_static())  continue;</span>
<span class="line-added">449     fieldDescriptor&amp; fd = fs.field_descriptor();</span>
<span class="line-added">450     if (fd.offset() == field_offset) {</span>
<span class="line-added">451       ciField* f = new (arena) ciField(&amp;fd);</span>
<span class="line-added">452       return f;</span>
<span class="line-added">453     }</span>
<span class="line-added">454   }</span>
<span class="line-added">455 </span>
<span class="line-added">456   return NULL;</span>
<span class="line-added">457 }</span>
<span class="line-added">458 </span>
459 // ------------------------------------------------------------------
460 // ciInstanceKlass::get_field_by_name
461 ciField* ciInstanceKlass::get_field_by_name(ciSymbol* name, ciSymbol* signature, bool is_static) {
462   VM_ENTRY_MARK;
463   InstanceKlass* k = get_instanceKlass();
464   fieldDescriptor fd;
465   Klass* def = k-&gt;find_field(name-&gt;get_symbol(), signature-&gt;get_symbol(), is_static, &amp;fd);
466   if (def == NULL) {
467     return NULL;
468   }
469   ciField* field = new (CURRENT_THREAD_ENV-&gt;arena()) ciField(&amp;fd);
470   return field;
471 }
472 
473 
474 static int sort_field_by_offset(ciField** a, ciField** b) {
475   return (*a)-&gt;offset_in_bytes() - (*b)-&gt;offset_in_bytes();
476   // (no worries about 32-bit overflow...)
477 }
478 
</pre>
<hr />
<pre>
500     int super_flen   = super-&gt;nof_nonstatic_fields();
501     super_fields = super-&gt;_nonstatic_fields;
502     assert(super_flen == 0 || super_fields != NULL, &quot;first get nof_fields&quot;);
503   }
504 
505   GrowableArray&lt;ciField*&gt;* fields = NULL;
506   GUARDED_VM_ENTRY({
507       fields = compute_nonstatic_fields_impl(super_fields);
508     });
509 
510   if (fields == NULL) {
511     // This can happen if this class (java.lang.Class) has invisible fields.
512     if (super_fields != NULL) {
513       _nonstatic_fields = super_fields;
514       return super_fields-&gt;length();
515     } else {
516       return 0;
517     }
518   }
519 
<span class="line-modified">520   _nonstatic_fields = fields;</span>





521   return fields-&gt;length();
522 }
523 
<span class="line-modified">524 GrowableArray&lt;ciField*&gt;* ciInstanceKlass::compute_nonstatic_fields_impl(GrowableArray&lt;ciField*&gt;* super_fields, bool flatten) {</span>


525   ASSERT_IN_VM;
526   Arena* arena = CURRENT_ENV-&gt;arena();
527   int flen = 0;
528   GrowableArray&lt;ciField*&gt;* fields = NULL;
529   InstanceKlass* k = get_instanceKlass();
530   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
531     if (fs.access_flags().is_static())  continue;
532     flen += 1;
533   }
534 
535   // allocate the array:
536   if (flen == 0) {
537     return NULL;  // return nothing if none are locally declared
538   }
539   if (super_fields != NULL) {
540     flen += super_fields-&gt;length();
541   }
<span class="line-added">542 </span>
543   fields = new (arena) GrowableArray&lt;ciField*&gt;(arena, flen, 0, NULL);
544   if (super_fields != NULL) {
545     fields-&gt;appendAll(super_fields);
546   }
547 
548   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
549     if (fs.access_flags().is_static())  continue;
550     fieldDescriptor&amp; fd = fs.field_descriptor();
<span class="line-modified">551     if (fd.is_flattened() &amp;&amp; flatten) {</span>
<span class="line-modified">552       // Value type fields are embedded</span>
<span class="line-added">553       int field_offset = fd.offset();</span>
<span class="line-added">554       // Get ValueKlass and adjust number of fields</span>
<span class="line-added">555       Klass* k = get_instanceKlass()-&gt;get_value_field_klass(fd.index());</span>
<span class="line-added">556       ciValueKlass* vk = CURRENT_ENV-&gt;get_klass(k)-&gt;as_value_klass();</span>
<span class="line-added">557       flen += vk-&gt;nof_nonstatic_fields() - 1;</span>
<span class="line-added">558       // Iterate over fields of the flattened value type and copy them to &#39;this&#39;</span>
<span class="line-added">559       for (int i = 0; i &lt; vk-&gt;nof_nonstatic_fields(); ++i) {</span>
<span class="line-added">560         ciField* flattened_field = vk-&gt;nonstatic_field_at(i);</span>
<span class="line-added">561         // Adjust offset to account for missing oop header</span>
<span class="line-added">562         int offset = field_offset + (flattened_field-&gt;offset() - vk-&gt;first_field_offset());</span>
<span class="line-added">563         // A flattened field can be treated as final if the non-flattened</span>
<span class="line-added">564         // field is declared final or the holder klass is a value type itself.</span>
<span class="line-added">565         bool is_final = fd.is_final() || is_valuetype();</span>
<span class="line-added">566         ciField* field = new (arena) ciField(flattened_field, this, offset, is_final);</span>
<span class="line-added">567         fields-&gt;append(field);</span>
<span class="line-added">568       }</span>
<span class="line-added">569     } else {</span>
<span class="line-added">570       ciField* field = new (arena) ciField(&amp;fd);</span>
<span class="line-added">571       fields-&gt;append(field);</span>
<span class="line-added">572     }</span>
573   }
574   assert(fields-&gt;length() == flen, &quot;sanity&quot;);
<span class="line-added">575   // Now sort them by offset, ascending.</span>
<span class="line-added">576   // (In principle, they could mix with superclass fields.)</span>
<span class="line-added">577   fields-&gt;sort(sort_field_by_offset);</span>
578   return fields;
579 }
580 
581 bool ciInstanceKlass::compute_injected_fields_helper() {
582   ASSERT_IN_VM;
583   InstanceKlass* k = get_instanceKlass();
584 
585   for (InternalFieldStream fs(k); !fs.done(); fs.next()) {
586     if (fs.access_flags().is_static())  continue;
587     return true;
588   }
589   return false;
590 }
591 
592 void ciInstanceKlass::compute_injected_fields() {
593   assert(is_loaded(), &quot;must be loaded&quot;);
594 
595   int has_injected_fields = 0;
596   if (super() != NULL &amp;&amp; super()-&gt;has_injected_fields()) {
597     has_injected_fields = 1;
</pre>
<hr />
<pre>
655       VM_ENTRY_MARK;
656       MutexLocker ml(Compile_lock);
657       Klass* k = get_instanceKlass()-&gt;implementor();
658       if (k != NULL) {
659         if (k == get_instanceKlass()) {
660           // More than one implementors. Use &#39;this&#39; in this case.
661           impl = this;
662         } else {
663           impl = CURRENT_THREAD_ENV-&gt;get_instance_klass(k);
664         }
665       }
666     }
667     // Memoize this result.
668     if (!is_shared()) {
669       _implementor = impl;
670     }
671   }
672   return impl;
673 }
674 
<span class="line-added">675 bool ciInstanceKlass::can_be_value_klass(bool is_exact) {</span>
<span class="line-added">676   if (!EnableValhalla) {</span>
<span class="line-added">677     return false;</span>
<span class="line-added">678   }</span>
<span class="line-added">679   if (!is_loaded() ||   // Not loaded, might be a value klass</span>
<span class="line-added">680       is_valuetype() || // Known to be a value klass</span>
<span class="line-added">681       // Non-exact j.l.Object or interface klass</span>
<span class="line-added">682       ((is_java_lang_Object() || is_interface()) &amp;&amp; !is_exact)) {</span>
<span class="line-added">683     return true;</span>
<span class="line-added">684   }</span>
<span class="line-added">685   if (is_abstract() &amp;&amp; !is_exact &amp;&amp; !has_nonstatic_fields()) {</span>
<span class="line-added">686     // TODO Factor out and re-use similar code from the ClassFileParser</span>
<span class="line-added">687     // An abstract class can only be implemented by a value type if it has no instance</span>
<span class="line-added">688     // fields, no synchronized instance methods and an empty, no-arg constructor.</span>
<span class="line-added">689     VM_ENTRY_MARK;</span>
<span class="line-added">690     Array&lt;Method*&gt;* methods = get_instanceKlass()-&gt;methods();</span>
<span class="line-added">691     for (int i = 0; i &lt; methods-&gt;length(); i++) {</span>
<span class="line-added">692       Method* m = methods-&gt;at(i);</span>
<span class="line-added">693       if ((m-&gt;is_synchronized() &amp;&amp; !m-&gt;is_static()) ||</span>
<span class="line-added">694           (m-&gt;is_object_constructor() &amp;&amp;</span>
<span class="line-added">695            (m-&gt;signature() != vmSymbols::void_method_signature() ||</span>
<span class="line-added">696             !m-&gt;is_vanilla_constructor()))) {</span>
<span class="line-added">697         return false;</span>
<span class="line-added">698       }</span>
<span class="line-added">699     }</span>
<span class="line-added">700     return true;</span>
<span class="line-added">701   }</span>
<span class="line-added">702   return false;</span>
<span class="line-added">703 }</span>
<span class="line-added">704 </span>
705 ciInstanceKlass* ciInstanceKlass::unsafe_anonymous_host() {
706   assert(is_loaded(), &quot;must be loaded&quot;);
707   if (is_unsafe_anonymous()) {
708     VM_ENTRY_MARK
709     Klass* unsafe_anonymous_host = get_instanceKlass()-&gt;unsafe_anonymous_host();
710     return CURRENT_ENV-&gt;get_instance_klass(unsafe_anonymous_host);
711   }
712   return NULL;
713 }
714 
715 // Utility class for printing of the contents of the static fields for
716 // use by compilation replay.  It only prints out the information that
717 // could be consumed by the compiler, so for primitive types it prints
718 // out the actual value.  For Strings it&#39;s the actual string value.
719 // For array types it it&#39;s first level array size since that&#39;s the
720 // only value which statically unchangeable.  For all other reference
721 // types it simply prints out the dynamic type.
722 
<span class="line-modified">723 class StaticFieldPrinter : public FieldClosure {</span>
<span class="line-added">724 protected:</span>
725   outputStream* _out;
<span class="line-added">726 public:</span>
<span class="line-added">727   StaticFieldPrinter(outputStream* out) :</span>
<span class="line-added">728     _out(out) {</span>
<span class="line-added">729   }</span>
<span class="line-added">730   void do_field_helper(fieldDescriptor* fd, oop obj, bool flattened);</span>
<span class="line-added">731 };</span>
<span class="line-added">732 </span>
<span class="line-added">733 class StaticFinalFieldPrinter : public StaticFieldPrinter {</span>
734   const char*   _holder;
735  public:
736   StaticFinalFieldPrinter(outputStream* out, const char* holder) :
<span class="line-modified">737     StaticFieldPrinter(out), _holder(holder) {</span>

738   }
739   void do_field(fieldDescriptor* fd) {
740     if (fd-&gt;is_final() &amp;&amp; !fd-&gt;has_initial_value()) {
741       ResourceMark rm;
<span class="line-modified">742       InstanceKlass* holder = fd-&gt;field_holder();</span>
<span class="line-modified">743       oop mirror = holder-&gt;java_mirror();</span>
<span class="line-modified">744       _out-&gt;print(&quot;staticfield %s %s &quot;, _holder, fd-&gt;name()-&gt;as_quoted_ascii());</span>
<span class="line-modified">745       BasicType bt = fd-&gt;field_type();</span>
<span class="line-modified">746       if (bt != T_OBJECT &amp;&amp; bt != T_ARRAY) {</span>
<span class="line-modified">747         _out-&gt;print(&quot;%s &quot;, fd-&gt;signature()-&gt;as_quoted_ascii());</span>
<span class="line-modified">748       }</span>
<span class="line-modified">749       do_field_helper(fd, mirror, false);</span>
<span class="line-modified">750       _out-&gt;cr();</span>
<span class="line-modified">751     }</span>
<span class="line-modified">752   }</span>
<span class="line-modified">753 };</span>
<span class="line-modified">754 </span>
<span class="line-modified">755 class ValueTypeFieldPrinter : public StaticFieldPrinter {</span>
<span class="line-modified">756   oop _obj;</span>
<span class="line-modified">757 public:</span>
<span class="line-modified">758   ValueTypeFieldPrinter(outputStream* out, oop obj) :</span>
<span class="line-modified">759     StaticFieldPrinter(out), _obj(obj) {</span>
<span class="line-modified">760   }</span>
<span class="line-modified">761   void do_field(fieldDescriptor* fd) {</span>
<span class="line-modified">762     do_field_helper(fd, _obj, true);</span>
<span class="line-modified">763     _out-&gt;print(&quot; &quot;);</span>
<span class="line-modified">764   }</span>
<span class="line-modified">765 };</span>
<span class="line-modified">766 </span>
<span class="line-modified">767 void StaticFieldPrinter::do_field_helper(fieldDescriptor* fd, oop mirror, bool flattened) {</span>
<span class="line-modified">768   BasicType bt = fd-&gt;field_type();</span>
<span class="line-modified">769   switch (bt) {</span>
<span class="line-modified">770     case T_BYTE:    _out-&gt;print(&quot;%d&quot;, mirror-&gt;byte_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">771     case T_BOOLEAN: _out-&gt;print(&quot;%d&quot;, mirror-&gt;bool_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">772     case T_SHORT:   _out-&gt;print(&quot;%d&quot;, mirror-&gt;short_field(fd-&gt;offset()));  break;</span>
<span class="line-modified">773     case T_CHAR:    _out-&gt;print(&quot;%d&quot;, mirror-&gt;char_field(fd-&gt;offset()));   break;</span>
<span class="line-modified">774     case T_INT:     _out-&gt;print(&quot;%d&quot;, mirror-&gt;int_field(fd-&gt;offset()));    break;</span>
<span class="line-modified">775     case T_LONG:    _out-&gt;print(INT64_FORMAT, (int64_t)(mirror-&gt;long_field(fd-&gt;offset())));   break;</span>
<span class="line-modified">776     case T_FLOAT: {</span>
<span class="line-modified">777       float f = mirror-&gt;float_field(fd-&gt;offset());</span>
<span class="line-modified">778       _out-&gt;print(&quot;%d&quot;, *(int*)&amp;f);</span>
<span class="line-modified">779       break;</span>
<span class="line-modified">780     }</span>
<span class="line-modified">781     case T_DOUBLE: {</span>
<span class="line-modified">782       double d = mirror-&gt;double_field(fd-&gt;offset());</span>
<span class="line-modified">783       _out-&gt;print(INT64_FORMAT, *(int64_t*)&amp;d);</span>
<span class="line-modified">784       break;</span>
<span class="line-modified">785     }</span>
<span class="line-modified">786     case T_ARRAY:  // fall-through</span>
<span class="line-modified">787     case T_OBJECT: {</span>
<span class="line-added">788       _out-&gt;print(&quot;%s &quot;, fd-&gt;signature()-&gt;as_quoted_ascii());</span>
<span class="line-added">789       oop value =  mirror-&gt;obj_field_acquire(fd-&gt;offset());</span>
<span class="line-added">790       if (value == NULL) {</span>
<span class="line-added">791         _out-&gt;print_cr(&quot;null&quot;);</span>
<span class="line-added">792       } else if (value-&gt;is_instance()) {</span>
<span class="line-added">793         assert(fd-&gt;field_type() == T_OBJECT, &quot;&quot;);</span>
<span class="line-added">794         if (value-&gt;is_a(SystemDictionary::String_klass())) {</span>
<span class="line-added">795           const char* ascii_value = java_lang_String::as_quoted_ascii(value);</span>
<span class="line-added">796           _out-&gt;print(&quot;\&quot;%s\&quot;&quot;, (ascii_value != NULL) ? ascii_value : &quot;&quot;);</span>
<span class="line-added">797          } else {</span>
<span class="line-added">798           const char* klass_name  = value-&gt;klass()-&gt;name()-&gt;as_quoted_ascii();</span>
<span class="line-added">799           _out-&gt;print(&quot;%s&quot;, klass_name);</span>
800         }
<span class="line-modified">801       } else if (value-&gt;is_array()) {</span>
<span class="line-modified">802         typeArrayOop ta = (typeArrayOop)value;</span>
<span class="line-added">803         _out-&gt;print(&quot;%d&quot;, ta-&gt;length());</span>
<span class="line-added">804         if (value-&gt;is_objArray() || value-&gt;is_valueArray()) {</span>
<span class="line-added">805           objArrayOop oa = (objArrayOop)value;</span>
<span class="line-added">806           const char* klass_name  = value-&gt;klass()-&gt;name()-&gt;as_quoted_ascii();</span>
<span class="line-added">807           _out-&gt;print(&quot; %s&quot;, klass_name);</span>
808         }
<span class="line-added">809       } else {</span>
<span class="line-added">810         ShouldNotReachHere();</span>
<span class="line-added">811       }</span>
<span class="line-added">812       break;</span>
813     }
<span class="line-added">814     case T_VALUETYPE: {</span>
<span class="line-added">815       ResetNoHandleMark rnhm;</span>
<span class="line-added">816       Thread* THREAD = Thread::current();</span>
<span class="line-added">817       SignatureStream ss(fd-&gt;signature(), false);</span>
<span class="line-added">818       Symbol* name = ss.as_symbol();</span>
<span class="line-added">819       assert(!HAS_PENDING_EXCEPTION, &quot;can resolve klass?&quot;);</span>
<span class="line-added">820       InstanceKlass* holder = fd-&gt;field_holder();</span>
<span class="line-added">821       Klass* k = SystemDictionary::find(name, Handle(THREAD, holder-&gt;class_loader()),</span>
<span class="line-added">822                                         Handle(THREAD, holder-&gt;protection_domain()), THREAD);</span>
<span class="line-added">823       assert(k != NULL &amp;&amp; !HAS_PENDING_EXCEPTION, &quot;can resolve klass?&quot;);</span>
<span class="line-added">824       ValueKlass* vk = ValueKlass::cast(k);</span>
<span class="line-added">825       oop obj;</span>
<span class="line-added">826       if (flattened) {</span>
<span class="line-added">827         int field_offset = fd-&gt;offset() - vk-&gt;first_field_offset();</span>
<span class="line-added">828         obj = (oop) (cast_from_oop&lt;address&gt;(mirror) + field_offset);</span>
<span class="line-added">829       } else {</span>
<span class="line-added">830         obj =  mirror-&gt;obj_field_acquire(fd-&gt;offset());</span>
<span class="line-added">831       }</span>
<span class="line-added">832       ValueTypeFieldPrinter print_field(_out, obj);</span>
<span class="line-added">833       vk-&gt;do_nonstatic_fields(&amp;print_field);</span>
<span class="line-added">834       break;</span>
<span class="line-added">835     }</span>
<span class="line-added">836     default:</span>
<span class="line-added">837       ShouldNotReachHere();</span>
838   }
<span class="line-modified">839 }</span>
840 
841 
842 void ciInstanceKlass::dump_replay_data(outputStream* out) {
843   ResourceMark rm;
844 
845   InstanceKlass* ik = get_instanceKlass();
846   ConstantPool*  cp = ik-&gt;constants();
847 
848   // Try to record related loaded classes
849   Klass* sub = ik-&gt;subklass();
850   while (sub != NULL) {
851     if (sub-&gt;is_instance_klass()) {
852       out-&gt;print_cr(&quot;instanceKlass %s&quot;, sub-&gt;name()-&gt;as_quoted_ascii());
853     }
854     sub = sub-&gt;next_sibling();
855   }
856 
857   // Dump out the state of the constant pool tags.  During replay the
858   // tags will be validated for things which shouldn&#39;t change and
859   // classes will be resolved if the tags indicate that they were
</pre>
</td>
</tr>
</table>
<center><a href="ciField.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="ciInstanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
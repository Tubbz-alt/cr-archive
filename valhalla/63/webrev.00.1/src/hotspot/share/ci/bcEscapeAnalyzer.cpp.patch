diff a/src/hotspot/share/ci/bcEscapeAnalyzer.cpp b/src/hotspot/share/ci/bcEscapeAnalyzer.cpp
--- a/src/hotspot/share/ci/bcEscapeAnalyzer.cpp
+++ b/src/hotspot/share/ci/bcEscapeAnalyzer.cpp
@@ -554,10 +554,13 @@
       case Bytecodes::_aastore:
       {
         set_global_escape(state.apop());
         state.spop();
         ArgumentMap arr = state.apop();
+        // If the array is flattened, a larger part of it is modified than
+        // the size of a reference. However, if OFFSET_ANY is given as
+        // parameter to set_modified(), size is not taken into account.
         set_modified(arr, OFFSET_ANY, type2size[T_OBJECT]*HeapWordSize);
         break;
       }
       case Bytecodes::_pop:
         state.raw_pop();
@@ -938,12 +941,28 @@
             state.lpush();
           }
         }
         break;
       case Bytecodes::_new:
+      case Bytecodes::_defaultvalue:
         state.apush(allocated_obj);
         break;
+      case Bytecodes::_withfield: {
+        bool will_link;
+        ciField* field = s.get_field(will_link);
+        BasicType field_type = field->type()->basic_type();
+        if (field_type == T_OBJECT || field_type == T_ARRAY) {
+          set_global_escape(state.apop());
+        } else if (type2size[field_type] == 1) {
+          state.spop();
+        } else {
+          state.lpop();
+        }
+        set_method_escape(state.apop());
+        state.apush(allocated_obj);
+        break;
+      }
       case Bytecodes::_newarray:
       case Bytecodes::_anewarray:
         state.spop();
         state.apush(allocated_obj);
         break;

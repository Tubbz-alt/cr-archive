<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/c1/c1_Runtime1.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LinearScan.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ci/bcEscapeAnalyzer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/c1/c1_Runtime1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  37 #include &quot;code/pcDesc.hpp&quot;
  38 #include &quot;code/scopeDesc.hpp&quot;
  39 #include &quot;code/vtableStubs.hpp&quot;
  40 #include &quot;compiler/compilationPolicy.hpp&quot;
  41 #include &quot;compiler/disassembler.hpp&quot;
  42 #include &quot;gc/shared/barrierSet.hpp&quot;
  43 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  44 #include &quot;gc/shared/collectedHeap.hpp&quot;
  45 #include &quot;interpreter/bytecode.hpp&quot;
  46 #include &quot;interpreter/interpreter.hpp&quot;
  47 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  48 #include &quot;logging/log.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/oopFactory.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/access.inline.hpp&quot;
  54 #include &quot;oops/objArrayOop.inline.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;


  57 #include &quot;runtime/atomic.hpp&quot;
  58 #include &quot;runtime/biasedLocking.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  60 #include &quot;runtime/frame.inline.hpp&quot;
  61 #include &quot;runtime/handles.inline.hpp&quot;
  62 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  63 #include &quot;runtime/javaCalls.hpp&quot;
  64 #include &quot;runtime/sharedRuntime.hpp&quot;
  65 #include &quot;runtime/threadCritical.hpp&quot;
  66 #include &quot;runtime/vframe.inline.hpp&quot;
  67 #include &quot;runtime/vframeArray.hpp&quot;
  68 #include &quot;runtime/vm_version.hpp&quot;
  69 #include &quot;utilities/copy.hpp&quot;
  70 #include &quot;utilities/events.hpp&quot;
  71 
  72 
  73 // Implementation of StubAssembler
  74 
  75 StubAssembler::StubAssembler(CodeBuffer* code, const char * name, int stub_id) : C1_MacroAssembler(code) {
  76   _name = name;
</pre>
<hr />
<pre>
 101   }
 102   assert(_num_rt_args == args, &quot;can&#39;t change the number of args&quot;);
 103 }
 104 
 105 // Implementation of Runtime1
 106 
 107 CodeBlob* Runtime1::_blobs[Runtime1::number_of_ids];
 108 const char *Runtime1::_blob_names[] = {
 109   RUNTIME1_STUBS(STUB_NAME, LAST_STUB_NAME)
 110 };
 111 
 112 #ifndef PRODUCT
 113 // statistics
 114 int Runtime1::_generic_arraycopy_cnt = 0;
 115 int Runtime1::_generic_arraycopystub_cnt = 0;
 116 int Runtime1::_arraycopy_slowcase_cnt = 0;
 117 int Runtime1::_arraycopy_checkcast_cnt = 0;
 118 int Runtime1::_arraycopy_checkcast_attempt_cnt = 0;
 119 int Runtime1::_new_type_array_slowcase_cnt = 0;
 120 int Runtime1::_new_object_array_slowcase_cnt = 0;

 121 int Runtime1::_new_instance_slowcase_cnt = 0;
 122 int Runtime1::_new_multi_array_slowcase_cnt = 0;





 123 int Runtime1::_monitorenter_slowcase_cnt = 0;
 124 int Runtime1::_monitorexit_slowcase_cnt = 0;
 125 int Runtime1::_patch_code_slowcase_cnt = 0;
 126 int Runtime1::_throw_range_check_exception_count = 0;
 127 int Runtime1::_throw_index_exception_count = 0;
 128 int Runtime1::_throw_div0_exception_count = 0;
 129 int Runtime1::_throw_null_pointer_exception_count = 0;
 130 int Runtime1::_throw_class_cast_exception_count = 0;
 131 int Runtime1::_throw_incompatible_class_change_error_count = 0;

 132 int Runtime1::_throw_array_store_exception_count = 0;
 133 int Runtime1::_throw_count = 0;
 134 
 135 static int _byte_arraycopy_stub_cnt = 0;
 136 static int _short_arraycopy_stub_cnt = 0;
 137 static int _int_arraycopy_stub_cnt = 0;
 138 static int _long_arraycopy_stub_cnt = 0;
 139 static int _oop_arraycopy_stub_cnt = 0;
 140 
 141 address Runtime1::arraycopy_count_address(BasicType type) {
 142   switch (type) {
 143   case T_BOOLEAN:
 144   case T_BYTE:   return (address)&amp;_byte_arraycopy_stub_cnt;
 145   case T_CHAR:
 146   case T_SHORT:  return (address)&amp;_short_arraycopy_stub_cnt;
 147   case T_FLOAT:
 148   case T_INT:    return (address)&amp;_int_arraycopy_stub_cnt;
 149   case T_DOUBLE:
 150   case T_LONG:   return (address)&amp;_long_arraycopy_stub_cnt;
 151   case T_ARRAY:
</pre>
<hr />
<pre>
 375   BasicType elt_type = TypeArrayKlass::cast(klass)-&gt;element_type();
 376   oop obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 377   thread-&gt;set_vm_result(obj);
 378   // This is pretty rare but this runtime patch is stressful to deoptimization
 379   // if we deoptimize here so force a deopt to stress the path.
 380   if (DeoptimizeALot) {
 381     deopt_caller();
 382   }
 383 
 384 JRT_END
 385 
 386 
 387 JRT_ENTRY(void, Runtime1::new_object_array(JavaThread* thread, Klass* array_klass, jint length))
 388   NOT_PRODUCT(_new_object_array_slowcase_cnt++;)
 389 
 390   // Note: no handle for klass needed since they are not used
 391   //       anymore after new_objArray() and no GC can happen before.
 392   //       (This may have to change if this code changes!)
 393   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);
 394   Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
<span class="line-modified"> 395   Klass* elem_klass = ObjArrayKlass::cast(array_klass)-&gt;element_klass();</span>
 396   objArrayOop obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 397   thread-&gt;set_vm_result(obj);
 398   // This is pretty rare but this runtime patch is stressful to deoptimization
 399   // if we deoptimize here so force a deopt to stress the path.
 400   if (DeoptimizeALot) {
 401     deopt_caller();
 402   }
 403 JRT_END
 404 
 405 






















 406 JRT_ENTRY(void, Runtime1::new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims))
 407   NOT_PRODUCT(_new_multi_array_slowcase_cnt++;)
 408 
 409   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 410   assert(rank &gt;= 1, &quot;rank must be nonzero&quot;);
 411   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 412   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 413   thread-&gt;set_vm_result(obj);
 414 JRT_END
 415 
 416 













































































 417 JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* thread, StubID id))
 418   tty-&gt;print_cr(&quot;Runtime1::entry_for(%d) returned unimplemented entry point&quot;, id);
 419 JRT_END
 420 
 421 
 422 JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* thread, oopDesc* obj))
 423   ResourceMark rm(thread);
 424   const char* klass_name = obj-&gt;klass()-&gt;external_name();
 425   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayStoreException(), klass_name);
 426 JRT_END
 427 
 428 
 429 // counter_overflow() is called from within C1-compiled methods. The enclosing method is the method
 430 // associated with the top activation record. The inlinee (that is possibly included in the enclosing
 431 // method) method oop is passed as an argument. In order to do that it is embedded in the code as
 432 // a constant.
 433 static nmethod* counter_overflow_helper(JavaThread* THREAD, int branch_bci, Method* m) {
 434   nmethod* osr_nm = NULL;
 435   methodHandle method(THREAD, m);
 436 
</pre>
<hr />
<pre>
 682 JRT_END
 683 
 684 
 685 JRT_ENTRY(void, Runtime1::throw_class_cast_exception(JavaThread* thread, oopDesc* object))
 686   NOT_PRODUCT(_throw_class_cast_exception_count++;)
 687   ResourceMark rm(thread);
 688   char* message = SharedRuntime::generate_class_cast_message(
 689     thread, object-&gt;klass());
 690   SharedRuntime::throw_and_post_jvmti_exception(
 691     thread, vmSymbols::java_lang_ClassCastException(), message);
 692 JRT_END
 693 
 694 
 695 JRT_ENTRY(void, Runtime1::throw_incompatible_class_change_error(JavaThread* thread))
 696   NOT_PRODUCT(_throw_incompatible_class_change_error_count++;)
 697   ResourceMark rm(thread);
 698   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError());
 699 JRT_END
 700 
 701 







 702 JRT_BLOCK_ENTRY(void, Runtime1::monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock))
 703   NOT_PRODUCT(_monitorenter_slowcase_cnt++;)
 704   if (!UseFastLocking) {
 705     lock-&gt;set_obj(obj);
 706   }
 707   assert(obj == lock-&gt;obj(), &quot;must match&quot;);
 708   SharedRuntime::monitor_enter_helper(obj, lock-&gt;lock(), thread);
 709 JRT_END
 710 
 711 
 712 JRT_LEAF(void, Runtime1::monitorexit(JavaThread* thread, BasicObjectLock* lock))
 713   NOT_PRODUCT(_monitorexit_slowcase_cnt++;)
 714   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
 715   oop obj = lock-&gt;obj();
 716   assert(oopDesc::is_oop(obj), &quot;must be NULL or an object&quot;);
 717   SharedRuntime::monitor_exit_helper(obj, lock-&gt;lock(), thread);
 718 JRT_END
 719 
 720 // Cf. OptoRuntime::deoptimize_caller_frame
 721 JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* thread, jint trap_request))
</pre>
<hr />
<pre>
 926     // accesses.
 927 
 928     patch_field_type = result.field_type();
 929     deoptimize_for_atomic = (AlwaysAtomicAccesses &amp;&amp; (patch_field_type == T_DOUBLE || patch_field_type == T_LONG));
 930 
 931   } else if (load_klass_or_mirror_patch_id) {
 932     Klass* k = NULL;
 933     switch (code) {
 934       case Bytecodes::_putstatic:
 935       case Bytecodes::_getstatic:
 936         { Klass* klass = resolve_field_return_klass(caller_method, bci, CHECK);
 937           init_klass = klass;
 938           mirror = Handle(THREAD, klass-&gt;java_mirror());
 939         }
 940         break;
 941       case Bytecodes::_new:
 942         { Bytecode_new bnew(caller_method(), caller_method-&gt;bcp_from(bci));
 943           k = caller_method-&gt;constants()-&gt;klass_at(bnew.index(), CHECK);
 944         }
 945         break;





 946       case Bytecodes::_multianewarray:
 947         { Bytecode_multianewarray mna(caller_method(), caller_method-&gt;bcp_from(bci));
 948           k = caller_method-&gt;constants()-&gt;klass_at(mna.index(), CHECK);




 949         }
 950         break;
 951       case Bytecodes::_instanceof:
 952         { Bytecode_instanceof io(caller_method(), caller_method-&gt;bcp_from(bci));
 953           k = caller_method-&gt;constants()-&gt;klass_at(io.index(), CHECK);
 954         }
 955         break;
 956       case Bytecodes::_checkcast:
 957         { Bytecode_checkcast cc(caller_method(), caller_method-&gt;bcp_from(bci));
 958           k = caller_method-&gt;constants()-&gt;klass_at(cc.index(), CHECK);
 959         }
 960         break;
 961       case Bytecodes::_anewarray:
 962         { Bytecode_anewarray anew(caller_method(), caller_method-&gt;bcp_from(bci));
 963           Klass* ek = caller_method-&gt;constants()-&gt;klass_at(anew.index(), CHECK);
 964           k = ek-&gt;array_klass(CHECK);
 965         }
 966         break;
 967       case Bytecodes::_ldc:
 968       case Bytecodes::_ldc_w:
</pre>
<hr />
<pre>
1450 void Runtime1::print_statistics() {
1451   tty-&gt;print_cr(&quot;C1 Runtime statistics:&quot;);
1452   tty-&gt;print_cr(&quot; _resolve_invoke_virtual_cnt:     %d&quot;, SharedRuntime::_resolve_virtual_ctr);
1453   tty-&gt;print_cr(&quot; _resolve_invoke_opt_virtual_cnt: %d&quot;, SharedRuntime::_resolve_opt_virtual_ctr);
1454   tty-&gt;print_cr(&quot; _resolve_invoke_static_cnt:      %d&quot;, SharedRuntime::_resolve_static_ctr);
1455   tty-&gt;print_cr(&quot; _handle_wrong_method_cnt:        %d&quot;, SharedRuntime::_wrong_method_ctr);
1456   tty-&gt;print_cr(&quot; _ic_miss_cnt:                    %d&quot;, SharedRuntime::_ic_miss_ctr);
1457   tty-&gt;print_cr(&quot; _generic_arraycopy_cnt:          %d&quot;, _generic_arraycopy_cnt);
1458   tty-&gt;print_cr(&quot; _generic_arraycopystub_cnt:      %d&quot;, _generic_arraycopystub_cnt);
1459   tty-&gt;print_cr(&quot; _byte_arraycopy_cnt:             %d&quot;, _byte_arraycopy_stub_cnt);
1460   tty-&gt;print_cr(&quot; _short_arraycopy_cnt:            %d&quot;, _short_arraycopy_stub_cnt);
1461   tty-&gt;print_cr(&quot; _int_arraycopy_cnt:              %d&quot;, _int_arraycopy_stub_cnt);
1462   tty-&gt;print_cr(&quot; _long_arraycopy_cnt:             %d&quot;, _long_arraycopy_stub_cnt);
1463   tty-&gt;print_cr(&quot; _oop_arraycopy_cnt:              %d&quot;, _oop_arraycopy_stub_cnt);
1464   tty-&gt;print_cr(&quot; _arraycopy_slowcase_cnt:         %d&quot;, _arraycopy_slowcase_cnt);
1465   tty-&gt;print_cr(&quot; _arraycopy_checkcast_cnt:        %d&quot;, _arraycopy_checkcast_cnt);
1466   tty-&gt;print_cr(&quot; _arraycopy_checkcast_attempt_cnt:%d&quot;, _arraycopy_checkcast_attempt_cnt);
1467 
1468   tty-&gt;print_cr(&quot; _new_type_array_slowcase_cnt:    %d&quot;, _new_type_array_slowcase_cnt);
1469   tty-&gt;print_cr(&quot; _new_object_array_slowcase_cnt:  %d&quot;, _new_object_array_slowcase_cnt);

1470   tty-&gt;print_cr(&quot; _new_instance_slowcase_cnt:      %d&quot;, _new_instance_slowcase_cnt);
1471   tty-&gt;print_cr(&quot; _new_multi_array_slowcase_cnt:   %d&quot;, _new_multi_array_slowcase_cnt);






1472   tty-&gt;print_cr(&quot; _monitorenter_slowcase_cnt:      %d&quot;, _monitorenter_slowcase_cnt);
1473   tty-&gt;print_cr(&quot; _monitorexit_slowcase_cnt:       %d&quot;, _monitorexit_slowcase_cnt);
1474   tty-&gt;print_cr(&quot; _patch_code_slowcase_cnt:        %d&quot;, _patch_code_slowcase_cnt);
1475 
1476   tty-&gt;print_cr(&quot; _throw_range_check_exception_count:            %d:&quot;, _throw_range_check_exception_count);
1477   tty-&gt;print_cr(&quot; _throw_index_exception_count:                  %d:&quot;, _throw_index_exception_count);
1478   tty-&gt;print_cr(&quot; _throw_div0_exception_count:                   %d:&quot;, _throw_div0_exception_count);
1479   tty-&gt;print_cr(&quot; _throw_null_pointer_exception_count:           %d:&quot;, _throw_null_pointer_exception_count);
1480   tty-&gt;print_cr(&quot; _throw_class_cast_exception_count:             %d:&quot;, _throw_class_cast_exception_count);
1481   tty-&gt;print_cr(&quot; _throw_incompatible_class_change_error_count:  %d:&quot;, _throw_incompatible_class_change_error_count);

1482   tty-&gt;print_cr(&quot; _throw_array_store_exception_count:            %d:&quot;, _throw_array_store_exception_count);
1483   tty-&gt;print_cr(&quot; _throw_count:                                  %d:&quot;, _throw_count);
1484 
1485   SharedRuntime::print_ic_miss_histogram();
1486   tty-&gt;cr();
1487 }
1488 #endif // PRODUCT
</pre>
</td>
<td>
<hr />
<pre>
  37 #include &quot;code/pcDesc.hpp&quot;
  38 #include &quot;code/scopeDesc.hpp&quot;
  39 #include &quot;code/vtableStubs.hpp&quot;
  40 #include &quot;compiler/compilationPolicy.hpp&quot;
  41 #include &quot;compiler/disassembler.hpp&quot;
  42 #include &quot;gc/shared/barrierSet.hpp&quot;
  43 #include &quot;gc/shared/c1/barrierSetC1.hpp&quot;
  44 #include &quot;gc/shared/collectedHeap.hpp&quot;
  45 #include &quot;interpreter/bytecode.hpp&quot;
  46 #include &quot;interpreter/interpreter.hpp&quot;
  47 #include &quot;jfr/support/jfrIntrinsics.hpp&quot;
  48 #include &quot;logging/log.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/oopFactory.hpp&quot;
  51 #include &quot;memory/resourceArea.hpp&quot;
  52 #include &quot;memory/universe.hpp&quot;
  53 #include &quot;oops/access.inline.hpp&quot;
  54 #include &quot;oops/objArrayOop.inline.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  57 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
<span class="line-added">  58 #include &quot;oops/valueArrayOop.inline.hpp&quot;</span>
  59 #include &quot;runtime/atomic.hpp&quot;
  60 #include &quot;runtime/biasedLocking.hpp&quot;
  61 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  62 #include &quot;runtime/frame.inline.hpp&quot;
  63 #include &quot;runtime/handles.inline.hpp&quot;
  64 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  65 #include &quot;runtime/javaCalls.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/threadCritical.hpp&quot;
  68 #include &quot;runtime/vframe.inline.hpp&quot;
  69 #include &quot;runtime/vframeArray.hpp&quot;
  70 #include &quot;runtime/vm_version.hpp&quot;
  71 #include &quot;utilities/copy.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;
  73 
  74 
  75 // Implementation of StubAssembler
  76 
  77 StubAssembler::StubAssembler(CodeBuffer* code, const char * name, int stub_id) : C1_MacroAssembler(code) {
  78   _name = name;
</pre>
<hr />
<pre>
 103   }
 104   assert(_num_rt_args == args, &quot;can&#39;t change the number of args&quot;);
 105 }
 106 
 107 // Implementation of Runtime1
 108 
 109 CodeBlob* Runtime1::_blobs[Runtime1::number_of_ids];
 110 const char *Runtime1::_blob_names[] = {
 111   RUNTIME1_STUBS(STUB_NAME, LAST_STUB_NAME)
 112 };
 113 
 114 #ifndef PRODUCT
 115 // statistics
 116 int Runtime1::_generic_arraycopy_cnt = 0;
 117 int Runtime1::_generic_arraycopystub_cnt = 0;
 118 int Runtime1::_arraycopy_slowcase_cnt = 0;
 119 int Runtime1::_arraycopy_checkcast_cnt = 0;
 120 int Runtime1::_arraycopy_checkcast_attempt_cnt = 0;
 121 int Runtime1::_new_type_array_slowcase_cnt = 0;
 122 int Runtime1::_new_object_array_slowcase_cnt = 0;
<span class="line-added"> 123 int Runtime1::_new_value_array_slowcase_cnt = 0;</span>
 124 int Runtime1::_new_instance_slowcase_cnt = 0;
 125 int Runtime1::_new_multi_array_slowcase_cnt = 0;
<span class="line-added"> 126 int Runtime1::_load_flattened_array_slowcase_cnt = 0;</span>
<span class="line-added"> 127 int Runtime1::_store_flattened_array_slowcase_cnt = 0;</span>
<span class="line-added"> 128 int Runtime1::_substitutability_check_slowcase_cnt = 0;</span>
<span class="line-added"> 129 int Runtime1::_buffer_value_args_slowcase_cnt = 0;</span>
<span class="line-added"> 130 int Runtime1::_buffer_value_args_no_receiver_slowcase_cnt = 0;</span>
 131 int Runtime1::_monitorenter_slowcase_cnt = 0;
 132 int Runtime1::_monitorexit_slowcase_cnt = 0;
 133 int Runtime1::_patch_code_slowcase_cnt = 0;
 134 int Runtime1::_throw_range_check_exception_count = 0;
 135 int Runtime1::_throw_index_exception_count = 0;
 136 int Runtime1::_throw_div0_exception_count = 0;
 137 int Runtime1::_throw_null_pointer_exception_count = 0;
 138 int Runtime1::_throw_class_cast_exception_count = 0;
 139 int Runtime1::_throw_incompatible_class_change_error_count = 0;
<span class="line-added"> 140 int Runtime1::_throw_illegal_monitor_state_exception_count = 0;</span>
 141 int Runtime1::_throw_array_store_exception_count = 0;
 142 int Runtime1::_throw_count = 0;
 143 
 144 static int _byte_arraycopy_stub_cnt = 0;
 145 static int _short_arraycopy_stub_cnt = 0;
 146 static int _int_arraycopy_stub_cnt = 0;
 147 static int _long_arraycopy_stub_cnt = 0;
 148 static int _oop_arraycopy_stub_cnt = 0;
 149 
 150 address Runtime1::arraycopy_count_address(BasicType type) {
 151   switch (type) {
 152   case T_BOOLEAN:
 153   case T_BYTE:   return (address)&amp;_byte_arraycopy_stub_cnt;
 154   case T_CHAR:
 155   case T_SHORT:  return (address)&amp;_short_arraycopy_stub_cnt;
 156   case T_FLOAT:
 157   case T_INT:    return (address)&amp;_int_arraycopy_stub_cnt;
 158   case T_DOUBLE:
 159   case T_LONG:   return (address)&amp;_long_arraycopy_stub_cnt;
 160   case T_ARRAY:
</pre>
<hr />
<pre>
 384   BasicType elt_type = TypeArrayKlass::cast(klass)-&gt;element_type();
 385   oop obj = oopFactory::new_typeArray(elt_type, length, CHECK);
 386   thread-&gt;set_vm_result(obj);
 387   // This is pretty rare but this runtime patch is stressful to deoptimization
 388   // if we deoptimize here so force a deopt to stress the path.
 389   if (DeoptimizeALot) {
 390     deopt_caller();
 391   }
 392 
 393 JRT_END
 394 
 395 
 396 JRT_ENTRY(void, Runtime1::new_object_array(JavaThread* thread, Klass* array_klass, jint length))
 397   NOT_PRODUCT(_new_object_array_slowcase_cnt++;)
 398 
 399   // Note: no handle for klass needed since they are not used
 400   //       anymore after new_objArray() and no GC can happen before.
 401   //       (This may have to change if this code changes!)
 402   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);
 403   Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive
<span class="line-modified"> 404   Klass* elem_klass = ArrayKlass::cast(array_klass)-&gt;element_klass();</span>
 405   objArrayOop obj = oopFactory::new_objArray(elem_klass, length, CHECK);
 406   thread-&gt;set_vm_result(obj);
 407   // This is pretty rare but this runtime patch is stressful to deoptimization
 408   // if we deoptimize here so force a deopt to stress the path.
 409   if (DeoptimizeALot) {
 410     deopt_caller();
 411   }
 412 JRT_END
 413 
 414 
<span class="line-added"> 415 JRT_ENTRY(void, Runtime1::new_value_array(JavaThread* thread, Klass* array_klass, jint length))</span>
<span class="line-added"> 416   NOT_PRODUCT(_new_value_array_slowcase_cnt++;)</span>
<span class="line-added"> 417 </span>
<span class="line-added"> 418   // Note: no handle for klass needed since they are not used</span>
<span class="line-added"> 419   //       anymore after new_objArray() and no GC can happen before.</span>
<span class="line-added"> 420   //       (This may have to change if this code changes!)</span>
<span class="line-added"> 421   assert(array_klass-&gt;is_klass(), &quot;not a class&quot;);</span>
<span class="line-added"> 422   Handle holder(THREAD, array_klass-&gt;klass_holder()); // keep the klass alive</span>
<span class="line-added"> 423   Klass* elem_klass = ArrayKlass::cast(array_klass)-&gt;element_klass();</span>
<span class="line-added"> 424   assert(elem_klass-&gt;is_value(), &quot;must be&quot;);</span>
<span class="line-added"> 425   // Logically creates elements, ensure klass init</span>
<span class="line-added"> 426   elem_klass-&gt;initialize(CHECK);</span>
<span class="line-added"> 427   arrayOop obj = oopFactory::new_valueArray(elem_klass, length, CHECK);</span>
<span class="line-added"> 428   thread-&gt;set_vm_result(obj);</span>
<span class="line-added"> 429   // This is pretty rare but this runtime patch is stressful to deoptimization</span>
<span class="line-added"> 430   // if we deoptimize here so force a deopt to stress the path.</span>
<span class="line-added"> 431   if (DeoptimizeALot) {</span>
<span class="line-added"> 432     deopt_caller();</span>
<span class="line-added"> 433   }</span>
<span class="line-added"> 434 JRT_END</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436 </span>
 437 JRT_ENTRY(void, Runtime1::new_multi_array(JavaThread* thread, Klass* klass, int rank, jint* dims))
 438   NOT_PRODUCT(_new_multi_array_slowcase_cnt++;)
 439 
 440   assert(klass-&gt;is_klass(), &quot;not a class&quot;);
 441   assert(rank &gt;= 1, &quot;rank must be nonzero&quot;);
 442   Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 443   oop obj = ArrayKlass::cast(klass)-&gt;multi_allocate(rank, dims, CHECK);
 444   thread-&gt;set_vm_result(obj);
 445 JRT_END
 446 
 447 
<span class="line-added"> 448 static void profile_flat_array(JavaThread* thread) {</span>
<span class="line-added"> 449   ResourceMark rm(thread);</span>
<span class="line-added"> 450   vframeStream vfst(thread, true);</span>
<span class="line-added"> 451   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);</span>
<span class="line-added"> 452   int bci = vfst.bci();</span>
<span class="line-added"> 453   Method* method = vfst.method();</span>
<span class="line-added"> 454   MethodData* md = method-&gt;method_data();</span>
<span class="line-added"> 455   if (md != NULL) {</span>
<span class="line-added"> 456     ProfileData* data = md-&gt;bci_to_data(bci);</span>
<span class="line-added"> 457     assert(data != NULL &amp;&amp; data-&gt;is_ArrayLoadStoreData(), &quot;incorrect profiling entry&quot;);</span>
<span class="line-added"> 458     ArrayLoadStoreData* load_store = (ArrayLoadStoreData*)data;</span>
<span class="line-added"> 459     load_store-&gt;set_flat_array();</span>
<span class="line-added"> 460   }</span>
<span class="line-added"> 461 }</span>
<span class="line-added"> 462 </span>
<span class="line-added"> 463 JRT_ENTRY(void, Runtime1::load_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index))</span>
<span class="line-added"> 464   assert(array-&gt;klass()-&gt;is_valueArray_klass(), &quot;should not be called&quot;);</span>
<span class="line-added"> 465   profile_flat_array(thread);</span>
<span class="line-added"> 466 </span>
<span class="line-added"> 467   NOT_PRODUCT(_load_flattened_array_slowcase_cnt++;)</span>
<span class="line-added"> 468   assert(array-&gt;length() &gt; 0 &amp;&amp; index &lt; array-&gt;length(), &quot;already checked&quot;);</span>
<span class="line-added"> 469   valueArrayHandle vah(thread, array);</span>
<span class="line-added"> 470   oop obj = valueArrayOopDesc::value_alloc_copy_from_index(vah, index, CHECK);</span>
<span class="line-added"> 471   thread-&gt;set_vm_result(obj);</span>
<span class="line-added"> 472 JRT_END</span>
<span class="line-added"> 473 </span>
<span class="line-added"> 474 </span>
<span class="line-added"> 475 JRT_ENTRY(void, Runtime1::store_flattened_array(JavaThread* thread, valueArrayOopDesc* array, int index, oopDesc* value))</span>
<span class="line-added"> 476   if (array-&gt;klass()-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 477     profile_flat_array(thread);</span>
<span class="line-added"> 478   }</span>
<span class="line-added"> 479 </span>
<span class="line-added"> 480   NOT_PRODUCT(_store_flattened_array_slowcase_cnt++;)</span>
<span class="line-added"> 481   if (value == NULL) {</span>
<span class="line-added"> 482     assert(array-&gt;klass()-&gt;is_valueArray_klass() || array-&gt;klass()-&gt;is_null_free_array_klass(), &quot;should not be called&quot;);</span>
<span class="line-added"> 483     SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());</span>
<span class="line-added"> 484   } else {</span>
<span class="line-added"> 485     assert(array-&gt;klass()-&gt;is_valueArray_klass(), &quot;should not be called&quot;);</span>
<span class="line-added"> 486     array-&gt;value_copy_to_index(value, index);</span>
<span class="line-added"> 487   }</span>
<span class="line-added"> 488 JRT_END</span>
<span class="line-added"> 489 </span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491 JRT_ENTRY(int, Runtime1::substitutability_check(JavaThread* thread, oopDesc* left, oopDesc* right))</span>
<span class="line-added"> 492   NOT_PRODUCT(_substitutability_check_slowcase_cnt++;)</span>
<span class="line-added"> 493   JavaCallArguments args;</span>
<span class="line-added"> 494   args.push_oop(Handle(THREAD, left));</span>
<span class="line-added"> 495   args.push_oop(Handle(THREAD, right));</span>
<span class="line-added"> 496   JavaValue result(T_BOOLEAN);</span>
<span class="line-added"> 497   JavaCalls::call_static(&amp;result,</span>
<span class="line-added"> 498                          SystemDictionary::ValueBootstrapMethods_klass(),</span>
<span class="line-added"> 499                          vmSymbols::isSubstitutable_name(),</span>
<span class="line-added"> 500                          vmSymbols::object_object_boolean_signature(),</span>
<span class="line-added"> 501                          &amp;args, CHECK_0);</span>
<span class="line-added"> 502   return result.get_jboolean() ? 1 : 0;</span>
<span class="line-added"> 503 JRT_END</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505 </span>
<span class="line-added"> 506 extern &quot;C&quot; void ps();</span>
<span class="line-added"> 507 </span>
<span class="line-added"> 508 void Runtime1::buffer_value_args_impl(JavaThread* thread, Method* m, bool allocate_receiver) {</span>
<span class="line-added"> 509   Thread* THREAD = thread;</span>
<span class="line-added"> 510   methodHandle method(thread, m); // We are inside the verified_entry or verified_value_ro_entry of this method.</span>
<span class="line-added"> 511   oop obj = SharedRuntime::allocate_value_types_impl(thread, method, allocate_receiver, CHECK);</span>
<span class="line-added"> 512   thread-&gt;set_vm_result(obj);</span>
<span class="line-added"> 513 }</span>
<span class="line-added"> 514 </span>
<span class="line-added"> 515 JRT_ENTRY(void, Runtime1::buffer_value_args(JavaThread* thread, Method* method))</span>
<span class="line-added"> 516   NOT_PRODUCT(_buffer_value_args_slowcase_cnt++;)</span>
<span class="line-added"> 517   buffer_value_args_impl(thread, method, true);</span>
<span class="line-added"> 518 JRT_END</span>
<span class="line-added"> 519 </span>
<span class="line-added"> 520 JRT_ENTRY(void, Runtime1::buffer_value_args_no_receiver(JavaThread* thread, Method* method))</span>
<span class="line-added"> 521   NOT_PRODUCT(_buffer_value_args_no_receiver_slowcase_cnt++;)</span>
<span class="line-added"> 522   buffer_value_args_impl(thread, method, false);</span>
<span class="line-added"> 523 JRT_END</span>
<span class="line-added"> 524 </span>
 525 JRT_ENTRY(void, Runtime1::unimplemented_entry(JavaThread* thread, StubID id))
 526   tty-&gt;print_cr(&quot;Runtime1::entry_for(%d) returned unimplemented entry point&quot;, id);
 527 JRT_END
 528 
 529 
 530 JRT_ENTRY(void, Runtime1::throw_array_store_exception(JavaThread* thread, oopDesc* obj))
 531   ResourceMark rm(thread);
 532   const char* klass_name = obj-&gt;klass()-&gt;external_name();
 533   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArrayStoreException(), klass_name);
 534 JRT_END
 535 
 536 
 537 // counter_overflow() is called from within C1-compiled methods. The enclosing method is the method
 538 // associated with the top activation record. The inlinee (that is possibly included in the enclosing
 539 // method) method oop is passed as an argument. In order to do that it is embedded in the code as
 540 // a constant.
 541 static nmethod* counter_overflow_helper(JavaThread* THREAD, int branch_bci, Method* m) {
 542   nmethod* osr_nm = NULL;
 543   methodHandle method(THREAD, m);
 544 
</pre>
<hr />
<pre>
 790 JRT_END
 791 
 792 
 793 JRT_ENTRY(void, Runtime1::throw_class_cast_exception(JavaThread* thread, oopDesc* object))
 794   NOT_PRODUCT(_throw_class_cast_exception_count++;)
 795   ResourceMark rm(thread);
 796   char* message = SharedRuntime::generate_class_cast_message(
 797     thread, object-&gt;klass());
 798   SharedRuntime::throw_and_post_jvmti_exception(
 799     thread, vmSymbols::java_lang_ClassCastException(), message);
 800 JRT_END
 801 
 802 
 803 JRT_ENTRY(void, Runtime1::throw_incompatible_class_change_error(JavaThread* thread))
 804   NOT_PRODUCT(_throw_incompatible_class_change_error_count++;)
 805   ResourceMark rm(thread);
 806   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError());
 807 JRT_END
 808 
 809 
<span class="line-added"> 810 JRT_ENTRY(void, Runtime1::throw_illegal_monitor_state_exception(JavaThread* thread))</span>
<span class="line-added"> 811   NOT_PRODUCT(_throw_illegal_monitor_state_exception_count++;)</span>
<span class="line-added"> 812   ResourceMark rm(thread);</span>
<span class="line-added"> 813   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IllegalMonitorStateException());</span>
<span class="line-added"> 814 JRT_END</span>
<span class="line-added"> 815 </span>
<span class="line-added"> 816 </span>
 817 JRT_BLOCK_ENTRY(void, Runtime1::monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock))
 818   NOT_PRODUCT(_monitorenter_slowcase_cnt++;)
 819   if (!UseFastLocking) {
 820     lock-&gt;set_obj(obj);
 821   }
 822   assert(obj == lock-&gt;obj(), &quot;must match&quot;);
 823   SharedRuntime::monitor_enter_helper(obj, lock-&gt;lock(), thread);
 824 JRT_END
 825 
 826 
 827 JRT_LEAF(void, Runtime1::monitorexit(JavaThread* thread, BasicObjectLock* lock))
 828   NOT_PRODUCT(_monitorexit_slowcase_cnt++;)
 829   assert(thread-&gt;last_Java_sp(), &quot;last_Java_sp must be set&quot;);
 830   oop obj = lock-&gt;obj();
 831   assert(oopDesc::is_oop(obj), &quot;must be NULL or an object&quot;);
 832   SharedRuntime::monitor_exit_helper(obj, lock-&gt;lock(), thread);
 833 JRT_END
 834 
 835 // Cf. OptoRuntime::deoptimize_caller_frame
 836 JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* thread, jint trap_request))
</pre>
<hr />
<pre>
1041     // accesses.
1042 
1043     patch_field_type = result.field_type();
1044     deoptimize_for_atomic = (AlwaysAtomicAccesses &amp;&amp; (patch_field_type == T_DOUBLE || patch_field_type == T_LONG));
1045 
1046   } else if (load_klass_or_mirror_patch_id) {
1047     Klass* k = NULL;
1048     switch (code) {
1049       case Bytecodes::_putstatic:
1050       case Bytecodes::_getstatic:
1051         { Klass* klass = resolve_field_return_klass(caller_method, bci, CHECK);
1052           init_klass = klass;
1053           mirror = Handle(THREAD, klass-&gt;java_mirror());
1054         }
1055         break;
1056       case Bytecodes::_new:
1057         { Bytecode_new bnew(caller_method(), caller_method-&gt;bcp_from(bci));
1058           k = caller_method-&gt;constants()-&gt;klass_at(bnew.index(), CHECK);
1059         }
1060         break;
<span class="line-added">1061       case Bytecodes::_defaultvalue:</span>
<span class="line-added">1062         { Bytecode_defaultvalue bdefaultvalue(caller_method(), caller_method-&gt;bcp_from(bci));</span>
<span class="line-added">1063           k = caller_method-&gt;constants()-&gt;klass_at(bdefaultvalue.index(), CHECK);</span>
<span class="line-added">1064         }</span>
<span class="line-added">1065         break;</span>
1066       case Bytecodes::_multianewarray:
1067         { Bytecode_multianewarray mna(caller_method(), caller_method-&gt;bcp_from(bci));
1068           k = caller_method-&gt;constants()-&gt;klass_at(mna.index(), CHECK);
<span class="line-added">1069           if (k-&gt;name()-&gt;is_Q_array_signature()) {</span>
<span class="line-added">1070             // Logically creates elements, ensure klass init</span>
<span class="line-added">1071             k-&gt;initialize(CHECK);</span>
<span class="line-added">1072           }</span>
1073         }
1074         break;
1075       case Bytecodes::_instanceof:
1076         { Bytecode_instanceof io(caller_method(), caller_method-&gt;bcp_from(bci));
1077           k = caller_method-&gt;constants()-&gt;klass_at(io.index(), CHECK);
1078         }
1079         break;
1080       case Bytecodes::_checkcast:
1081         { Bytecode_checkcast cc(caller_method(), caller_method-&gt;bcp_from(bci));
1082           k = caller_method-&gt;constants()-&gt;klass_at(cc.index(), CHECK);
1083         }
1084         break;
1085       case Bytecodes::_anewarray:
1086         { Bytecode_anewarray anew(caller_method(), caller_method-&gt;bcp_from(bci));
1087           Klass* ek = caller_method-&gt;constants()-&gt;klass_at(anew.index(), CHECK);
1088           k = ek-&gt;array_klass(CHECK);
1089         }
1090         break;
1091       case Bytecodes::_ldc:
1092       case Bytecodes::_ldc_w:
</pre>
<hr />
<pre>
1574 void Runtime1::print_statistics() {
1575   tty-&gt;print_cr(&quot;C1 Runtime statistics:&quot;);
1576   tty-&gt;print_cr(&quot; _resolve_invoke_virtual_cnt:     %d&quot;, SharedRuntime::_resolve_virtual_ctr);
1577   tty-&gt;print_cr(&quot; _resolve_invoke_opt_virtual_cnt: %d&quot;, SharedRuntime::_resolve_opt_virtual_ctr);
1578   tty-&gt;print_cr(&quot; _resolve_invoke_static_cnt:      %d&quot;, SharedRuntime::_resolve_static_ctr);
1579   tty-&gt;print_cr(&quot; _handle_wrong_method_cnt:        %d&quot;, SharedRuntime::_wrong_method_ctr);
1580   tty-&gt;print_cr(&quot; _ic_miss_cnt:                    %d&quot;, SharedRuntime::_ic_miss_ctr);
1581   tty-&gt;print_cr(&quot; _generic_arraycopy_cnt:          %d&quot;, _generic_arraycopy_cnt);
1582   tty-&gt;print_cr(&quot; _generic_arraycopystub_cnt:      %d&quot;, _generic_arraycopystub_cnt);
1583   tty-&gt;print_cr(&quot; _byte_arraycopy_cnt:             %d&quot;, _byte_arraycopy_stub_cnt);
1584   tty-&gt;print_cr(&quot; _short_arraycopy_cnt:            %d&quot;, _short_arraycopy_stub_cnt);
1585   tty-&gt;print_cr(&quot; _int_arraycopy_cnt:              %d&quot;, _int_arraycopy_stub_cnt);
1586   tty-&gt;print_cr(&quot; _long_arraycopy_cnt:             %d&quot;, _long_arraycopy_stub_cnt);
1587   tty-&gt;print_cr(&quot; _oop_arraycopy_cnt:              %d&quot;, _oop_arraycopy_stub_cnt);
1588   tty-&gt;print_cr(&quot; _arraycopy_slowcase_cnt:         %d&quot;, _arraycopy_slowcase_cnt);
1589   tty-&gt;print_cr(&quot; _arraycopy_checkcast_cnt:        %d&quot;, _arraycopy_checkcast_cnt);
1590   tty-&gt;print_cr(&quot; _arraycopy_checkcast_attempt_cnt:%d&quot;, _arraycopy_checkcast_attempt_cnt);
1591 
1592   tty-&gt;print_cr(&quot; _new_type_array_slowcase_cnt:    %d&quot;, _new_type_array_slowcase_cnt);
1593   tty-&gt;print_cr(&quot; _new_object_array_slowcase_cnt:  %d&quot;, _new_object_array_slowcase_cnt);
<span class="line-added">1594   tty-&gt;print_cr(&quot; _new_value_array_slowcase_cnt:   %d&quot;, _new_value_array_slowcase_cnt);</span>
1595   tty-&gt;print_cr(&quot; _new_instance_slowcase_cnt:      %d&quot;, _new_instance_slowcase_cnt);
1596   tty-&gt;print_cr(&quot; _new_multi_array_slowcase_cnt:   %d&quot;, _new_multi_array_slowcase_cnt);
<span class="line-added">1597   tty-&gt;print_cr(&quot; _load_flattened_array_slowcase_cnt:   %d&quot;, _load_flattened_array_slowcase_cnt);</span>
<span class="line-added">1598   tty-&gt;print_cr(&quot; _store_flattened_array_slowcase_cnt:  %d&quot;, _store_flattened_array_slowcase_cnt);</span>
<span class="line-added">1599   tty-&gt;print_cr(&quot; _substitutability_check_slowcase_cnt: %d&quot;, _substitutability_check_slowcase_cnt);</span>
<span class="line-added">1600   tty-&gt;print_cr(&quot; _buffer_value_args_slowcase_cnt:%d&quot;, _buffer_value_args_slowcase_cnt);</span>
<span class="line-added">1601   tty-&gt;print_cr(&quot; _buffer_value_args_no_receiver_slowcase_cnt:%d&quot;, _buffer_value_args_no_receiver_slowcase_cnt);</span>
<span class="line-added">1602 </span>
1603   tty-&gt;print_cr(&quot; _monitorenter_slowcase_cnt:      %d&quot;, _monitorenter_slowcase_cnt);
1604   tty-&gt;print_cr(&quot; _monitorexit_slowcase_cnt:       %d&quot;, _monitorexit_slowcase_cnt);
1605   tty-&gt;print_cr(&quot; _patch_code_slowcase_cnt:        %d&quot;, _patch_code_slowcase_cnt);
1606 
1607   tty-&gt;print_cr(&quot; _throw_range_check_exception_count:            %d:&quot;, _throw_range_check_exception_count);
1608   tty-&gt;print_cr(&quot; _throw_index_exception_count:                  %d:&quot;, _throw_index_exception_count);
1609   tty-&gt;print_cr(&quot; _throw_div0_exception_count:                   %d:&quot;, _throw_div0_exception_count);
1610   tty-&gt;print_cr(&quot; _throw_null_pointer_exception_count:           %d:&quot;, _throw_null_pointer_exception_count);
1611   tty-&gt;print_cr(&quot; _throw_class_cast_exception_count:             %d:&quot;, _throw_class_cast_exception_count);
1612   tty-&gt;print_cr(&quot; _throw_incompatible_class_change_error_count:  %d:&quot;, _throw_incompatible_class_change_error_count);
<span class="line-added">1613   tty-&gt;print_cr(&quot; _throw_illegal_monitor_state_exception_count:  %d:&quot;, _throw_illegal_monitor_state_exception_count);</span>
1614   tty-&gt;print_cr(&quot; _throw_array_store_exception_count:            %d:&quot;, _throw_array_store_exception_count);
1615   tty-&gt;print_cr(&quot; _throw_count:                                  %d:&quot;, _throw_count);
1616 
1617   SharedRuntime::print_ic_miss_histogram();
1618   tty-&gt;cr();
1619 }
1620 #endif // PRODUCT
</pre>
</td>
</tr>
</table>
<center><a href="c1_LinearScan.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../ci/bcEscapeAnalyzer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/method.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="method.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopsHierarchy.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/method.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  73  private:
  74   // If you add a new field that points to any metaspace object, you
  75   // must add this field to Method::metaspace_pointers_do().
  76   ConstMethod*      _constMethod;                // Method read-only data.
  77   MethodData*       _method_data;
  78   MethodCounters*   _method_counters;
  79   AccessFlags       _access_flags;               // Access flags
  80   int               _vtable_index;               // vtable index of this method (see VtableIndexFlag)
  81                                                  // note: can have vtables with &gt;2**16 elements (because of inheritance)
  82   u2                _intrinsic_id;               // vmSymbols::intrinsic_id (0 == _none)
  83 
  84   // Flags
  85   enum Flags {
  86     _caller_sensitive      = 1 &lt;&lt; 0,
  87     _force_inline          = 1 &lt;&lt; 1,
  88     _dont_inline           = 1 &lt;&lt; 2,
  89     _hidden                = 1 &lt;&lt; 3,
  90     _has_injected_profile  = 1 &lt;&lt; 4,
  91     _running_emcp          = 1 &lt;&lt; 5,
  92     _intrinsic_candidate   = 1 &lt;&lt; 6,
<span class="line-modified">  93     _reserved_stack_access = 1 &lt;&lt; 7</span>



  94   };
  95   mutable u2 _flags;
  96 
  97   JFR_ONLY(DEFINE_TRACE_FLAG;)
  98 
  99 #ifndef PRODUCT
 100   int               _compiled_invocation_count;  // Number of nmethod invocations so far (for perf. debugging)
 101 #endif
 102   // Entry point for calling both from and to the interpreter.
 103   address _i2i_entry;           // All-args-on-stack calling convention
 104   // Entry point for calling from compiled code, to compiled code if it exists
 105   // or else the interpreter.
<span class="line-modified"> 106   volatile address _from_compiled_entry;        // Cache of: _code ? _code-&gt;entry_point() : _adapter-&gt;c2i_entry()</span>


 107   // The entry point for calling both from and to compiled code is
 108   // &quot;_code-&gt;entry_point()&quot;.  Because of tiered compilation and de-opt, this
 109   // field can come and go.  It can transition from NULL to not-null at any
 110   // time (whenever a compile completes).  It can transition from not-null to
 111   // NULL only at safepoints (because of a de-opt).
 112   CompiledMethod* volatile _code;                       // Points to the corresponding piece of native code
 113   volatile address           _from_interpreted_entry; // Cache of _code ? _adapter-&gt;i2c_entry() : _i2i_entry

 114 
 115 #if INCLUDE_AOT &amp;&amp; defined(TIERED)
 116   CompiledMethod* _aot_code;
 117 #endif
 118 
 119   // Constructor
 120   Method(ConstMethod* xconst, AccessFlags access_flags);
 121  public:
 122 
 123   static Method* allocate(ClassLoaderData* loader_data,
 124                           int byte_code_size,
 125                           AccessFlags access_flags,
 126                           InlineTableSizes* sizes,
 127                           ConstMethod::MethodType method_type,
 128                           TRAPS);
 129 
 130   // CDS and vtbl checking can create an empty Method to get vtbl pointer.
 131   Method(){}
 132 
 133   bool is_method() const volatile { return true; }
 134 
 135   void restore_unshareable_info(TRAPS);
 136 
 137   // accessors for instance variables
 138 
 139   ConstMethod* constMethod() const             { return _constMethod; }
 140   void set_constMethod(ConstMethod* xconst)    { _constMethod = xconst; }
 141 
 142 
 143   static address make_adapters(const methodHandle&amp; mh, TRAPS);
 144   address from_compiled_entry() const;
<span class="line-modified"> 145   address from_compiled_entry_no_trampoline() const;</span>


 146   address from_interpreted_entry() const;
 147 
 148   // access flag
 149   AccessFlags access_flags() const               { return _access_flags;  }
 150   void set_access_flags(AccessFlags flags)       { _access_flags = flags; }
 151 
 152   // name
 153   Symbol* name() const                           { return constants()-&gt;symbol_at(name_index()); }
 154   int name_index() const                         { return constMethod()-&gt;name_index();         }
 155   void set_name_index(int index)                 { constMethod()-&gt;set_name_index(index);       }
 156 
 157   // signature
 158   Symbol* signature() const                      { return constants()-&gt;symbol_at(signature_index()); }
 159   int signature_index() const                    { return constMethod()-&gt;signature_index();         }
 160   void set_signature_index(int index)            { constMethod()-&gt;set_signature_index(index);       }
 161 
 162   // generics support
 163   Symbol* generic_signature() const              { int idx = generic_signature_index(); return ((idx != 0) ? constants()-&gt;symbol_at(idx) : (Symbol*)NULL); }
 164   int generic_signature_index() const            { return constMethod()-&gt;generic_signature_index(); }
 165   void set_generic_signature_index(int index)    { constMethod()-&gt;set_generic_signature_index(index); }
</pre>
<hr />
<pre>
 452     if (TieredCompilation) ShouldNotReachHere();
 453     MethodCounters* mcs = get_method_counters(CHECK_0);
 454     return (mcs == NULL) ? 0 : mcs-&gt;increment_interpreter_invocation_count();
 455   }
 456 #endif
 457 
 458 #ifndef PRODUCT
 459   int  compiled_invocation_count() const         { return _compiled_invocation_count;  }
 460   void set_compiled_invocation_count(int count)  { _compiled_invocation_count = count; }
 461 #else
 462   // for PrintMethodData in a product build
 463   int  compiled_invocation_count() const         { return 0;  }
 464 #endif // not PRODUCT
 465 
 466   // Clear (non-shared space) pointers which could not be relevant
 467   // if this (shared) method were mapped into another JVM.
 468   void remove_unshareable_info();
 469 
 470   // nmethod/verified compiler entry
 471   address verified_code_entry();


 472   bool check_code() const;      // Not inline to avoid circular ref
 473   CompiledMethod* volatile code() const;
 474 
 475   // Locks CompiledMethod_lock if not held.
 476   void unlink_code(CompiledMethod *compare);
 477   // Locks CompiledMethod_lock if not held.
 478   void unlink_code();
 479 
 480 private:
 481   // Either called with CompiledMethod_lock held or from constructor.
 482   void clear_code();
 483 
 484 public:
 485   static void set_code(const methodHandle&amp; mh, CompiledMethod* code);
 486   void set_adapter_entry(AdapterHandlerEntry* adapter) {
 487     constMethod()-&gt;set_adapter_entry(adapter);
 488   }
 489   void set_adapter_trampoline(AdapterHandlerEntry** trampoline) {
 490     constMethod()-&gt;set_adapter_trampoline(trampoline);
 491   }
 492   void update_adapter_trampoline(AdapterHandlerEntry* adapter) {
 493     constMethod()-&gt;update_adapter_trampoline(adapter);
 494   }
 495   void set_from_compiled_entry(address entry) {
<span class="line-modified"> 496     _from_compiled_entry =  entry;</span>






 497   }
 498 
 499   address get_i2c_entry();
 500   address get_c2i_entry();

 501   address get_c2i_unverified_entry();

 502   address get_c2i_no_clinit_check_entry();
 503   AdapterHandlerEntry* adapter() const {
 504     return constMethod()-&gt;adapter();
 505   }
 506   // setup entry points
 507   void link_method(const methodHandle&amp; method, TRAPS);
 508   // clear entry points. Used by sharing code during dump time
 509   void unlink_method() NOT_CDS_RETURN;
 510 
 511   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
 512   virtual MetaspaceObj::Type type() const { return MethodType; }
 513 
 514   // vtable index
 515   enum VtableIndexFlag {
 516     // Valid vtable indexes are non-negative (&gt;= 0).
 517     // These few negative values are used as sentinels.
 518     itable_index_max        = -10, // first itable index, growing downward
 519     pending_itable_index    = -9,  // itable index will be assigned
 520     invalid_vtable_index    = -4,  // distinct from any valid vtable index
 521     garbage_vtable_index    = -3,  // not yet linked; no vtable layout yet
</pre>
<hr />
<pre>
 594 
 595   // localvariable table
 596   bool has_localvariable_table() const
 597                           { return constMethod()-&gt;has_localvariable_table(); }
 598   int localvariable_table_length() const
 599                         { return constMethod()-&gt;localvariable_table_length(); }
 600   LocalVariableTableElement* localvariable_table_start() const
 601                          { return constMethod()-&gt;localvariable_table_start(); }
 602 
 603   bool has_linenumber_table() const
 604                               { return constMethod()-&gt;has_linenumber_table(); }
 605   u_char* compressed_linenumber_table() const
 606                        { return constMethod()-&gt;compressed_linenumber_table(); }
 607 
 608   // method holder (the Klass* holding this method)
 609   InstanceKlass* method_holder() const         { return constants()-&gt;pool_holder(); }
 610 
 611   Symbol* klass_name() const;                    // returns the name of the method holder
 612   BasicType result_type() const                  { return constMethod()-&gt;result_type(); }
 613   bool is_returning_oop() const                  { BasicType r = result_type(); return is_reference_type(r); }
<span class="line-modified"> 614   bool is_returning_fp() const                   { BasicType r = result_type(); return (r == T_FLOAT || r == T_DOUBLE); }</span>
 615 
 616   // Checked exceptions thrown by this method (resolved to mirrors)
 617   objArrayHandle resolved_checked_exceptions(TRAPS) { return resolved_checked_exceptions_impl(this, THREAD); }
 618 
 619   // Access flags
 620   bool is_public() const                         { return access_flags().is_public();      }
 621   bool is_private() const                        { return access_flags().is_private();     }
 622   bool is_protected() const                      { return access_flags().is_protected();   }
 623   bool is_package_private() const                { return !is_public() &amp;&amp; !is_private() &amp;&amp; !is_protected(); }
 624   bool is_static() const                         { return access_flags().is_static();      }
 625   bool is_final() const                          { return access_flags().is_final();       }
 626   bool is_synchronized() const                   { return access_flags().is_synchronized();}
 627   bool is_native() const                         { return access_flags().is_native();      }
 628   bool is_abstract() const                       { return access_flags().is_abstract();    }
 629   bool is_strict() const                         { return access_flags().is_strict();      }
 630   bool is_synthetic() const                      { return access_flags().is_synthetic();   }
 631 
 632   // returns true if contains only return operation
 633   bool is_empty_method() const;
 634 
</pre>
<hr />
<pre>
 667   void set_has_monitor_bytecodes()               { _access_flags.set_has_monitor_bytecodes(); }
 668 
 669   // monitor matching. This returns a conservative estimate of whether the monitorenter/monitorexit bytecodes
 670   // propererly nest in the method. It might return false, even though they actually nest properly, since the info.
 671   // has not been computed yet.
 672   bool guaranteed_monitor_matching() const       { return access_flags().is_monitor_matching(); }
 673   void set_guaranteed_monitor_matching()         { _access_flags.set_monitor_matching(); }
 674 
 675   // returns true if the method is an accessor function (setter/getter).
 676   bool is_accessor() const;
 677 
 678   // returns true if the method is a getter
 679   bool is_getter() const;
 680 
 681   // returns true if the method is a setter
 682   bool is_setter() const;
 683 
 684   // returns true if the method does nothing but return a constant of primitive type
 685   bool is_constant_getter() const;
 686 
<span class="line-removed"> 687   // returns true if the method is an initializer (&lt;init&gt; or &lt;clinit&gt;).</span>
<span class="line-removed"> 688   bool is_initializer() const;</span>
<span class="line-removed"> 689 </span>
<span class="line-removed"> 690   // returns true if the method is static OR if the classfile version &lt; 51</span>
<span class="line-removed"> 691   bool has_valid_initializer_flags() const;</span>
<span class="line-removed"> 692 </span>
 693   // returns true if the method name is &lt;clinit&gt; and the method has
 694   // valid static initializer flags.
<span class="line-modified"> 695   bool is_static_initializer() const;</span>



 696 
<span class="line-modified"> 697   // returns true if the method name is &lt;init&gt;</span>
<span class="line-modified"> 698   bool is_object_initializer() const;</span>




 699 
 700   // compiled code support
 701   // NOTE: code() is inherently racy as deopt can be clearing code
 702   // simultaneously. Use with caution.
 703   bool has_compiled_code() const;
 704 
 705 #ifdef TIERED
 706   bool has_aot_code() const                      { return aot_code() != NULL; }
 707 #endif
 708 
 709   bool needs_clinit_barrier() const;
 710 
 711   // sizing
 712   static int header_size()                       {
 713     return align_up((int)sizeof(Method), wordSize) / wordSize;
 714   }
 715   static int size(bool is_native);
 716   int size() const                               { return method_size(); }
 717   void log_touched(TRAPS);
 718   static void print_touched_methods(outputStream* out);
 719 
 720   // interpreter support
 721   static ByteSize const_offset()                 { return byte_offset_of(Method, _constMethod       ); }
 722   static ByteSize access_flags_offset()          { return byte_offset_of(Method, _access_flags      ); }
 723   static ByteSize from_compiled_offset()         { return byte_offset_of(Method, _from_compiled_entry); }


 724   static ByteSize code_offset()                  { return byte_offset_of(Method, _code); }

 725   static ByteSize method_data_offset()           {
 726     return byte_offset_of(Method, _method_data);
 727   }
 728   static ByteSize method_counters_offset()       {
 729     return byte_offset_of(Method, _method_counters);
 730   }
 731 #ifndef PRODUCT
 732   static ByteSize compiled_invocation_counter_offset() { return byte_offset_of(Method, _compiled_invocation_count); }
 733 #endif // not PRODUCT
 734   static ByteSize native_function_offset()       { return in_ByteSize(sizeof(Method));                 }
 735   static ByteSize from_interpreted_offset()      { return byte_offset_of(Method, _from_interpreted_entry ); }
 736   static ByteSize interpreter_entry_offset()     { return byte_offset_of(Method, _i2i_entry ); }
 737   static ByteSize signature_handler_offset()     { return in_ByteSize(sizeof(Method) + wordSize);      }
 738   static ByteSize itable_index_offset()          { return byte_offset_of(Method, _vtable_index ); }
 739 
 740   // for code generation
 741   static int method_data_offset_in_bytes()       { return offset_of(Method, _method_data); }
 742   static int intrinsic_id_offset_in_bytes()      { return offset_of(Method, _intrinsic_id); }
 743   static int intrinsic_id_size_in_bytes()        { return sizeof(u2); }
 744 


 745   // Static methods that are used to implement member methods where an exposed this pointer
 746   // is needed due to possible GCs
 747   static objArrayHandle resolved_checked_exceptions_impl(Method* method, TRAPS);
 748 
 749   // Returns the byte code index from the byte code pointer
 750   int     bci_from(address bcp) const;
 751   address bcp_from(int bci) const;
 752   address bcp_from(address bcp) const;
 753   int validate_bci_from_bcp(address bcp) const;
 754   int validate_bci(int bci) const;
 755 
 756   // Returns the line number for a bci if debugging information for the method is prowided,
 757   // -1 is returned otherwise.
 758   int line_number_from_bci(int bci) const;
 759 
 760   // Reflection support
 761   bool is_overridden_in(Klass* k) const;
 762 
 763   // Stack walking support
 764   bool is_ignored_by_security_stack_walk() const;
</pre>
<hr />
<pre>
 905   }
 906   void set_intrinsic_candidate(bool x) {
 907     _flags = x ? (_flags | _intrinsic_candidate) : (_flags &amp; ~_intrinsic_candidate);
 908   }
 909 
 910   bool has_injected_profile() {
 911     return (_flags &amp; _has_injected_profile) != 0;
 912   }
 913   void set_has_injected_profile(bool x) {
 914     _flags = x ? (_flags | _has_injected_profile) : (_flags &amp; ~_has_injected_profile);
 915   }
 916 
 917   bool has_reserved_stack_access() {
 918     return (_flags &amp; _reserved_stack_access) != 0;
 919   }
 920 
 921   void set_has_reserved_stack_access(bool x) {
 922     _flags = x ? (_flags | _reserved_stack_access) : (_flags &amp; ~_reserved_stack_access);
 923   }
 924 
























 925   JFR_ONLY(DEFINE_TRACE_FLAG_ACCESSOR;)
 926 
 927   ConstMethod::MethodType method_type() const {
 928       return _constMethod-&gt;method_type();
 929   }
 930   bool is_overpass() const { return method_type() == ConstMethod::OVERPASS; }
 931 
 932   // On-stack replacement support
 933   bool has_osr_nmethod(int level, bool match_level) {
 934    return method_holder()-&gt;lookup_osr_nmethod(this, InvocationEntryBci, level, match_level) != NULL;
 935   }
 936 
 937   int mark_osr_nmethods() {
 938     return method_holder()-&gt;mark_osr_nmethods(this);
 939   }
 940 
 941   nmethod* lookup_osr_nmethod_for(int bci, int level, bool match_level) {
 942     return method_holder()-&gt;lookup_osr_nmethod(this, bci, level, match_level);
 943   }
 944 
</pre>
</td>
<td>
<hr />
<pre>
  73  private:
  74   // If you add a new field that points to any metaspace object, you
  75   // must add this field to Method::metaspace_pointers_do().
  76   ConstMethod*      _constMethod;                // Method read-only data.
  77   MethodData*       _method_data;
  78   MethodCounters*   _method_counters;
  79   AccessFlags       _access_flags;               // Access flags
  80   int               _vtable_index;               // vtable index of this method (see VtableIndexFlag)
  81                                                  // note: can have vtables with &gt;2**16 elements (because of inheritance)
  82   u2                _intrinsic_id;               // vmSymbols::intrinsic_id (0 == _none)
  83 
  84   // Flags
  85   enum Flags {
  86     _caller_sensitive      = 1 &lt;&lt; 0,
  87     _force_inline          = 1 &lt;&lt; 1,
  88     _dont_inline           = 1 &lt;&lt; 2,
  89     _hidden                = 1 &lt;&lt; 3,
  90     _has_injected_profile  = 1 &lt;&lt; 4,
  91     _running_emcp          = 1 &lt;&lt; 5,
  92     _intrinsic_candidate   = 1 &lt;&lt; 6,
<span class="line-modified">  93     _reserved_stack_access = 1 &lt;&lt; 7,</span>
<span class="line-added">  94     _scalarized_args       = 1 &lt;&lt; 8,</span>
<span class="line-added">  95     _c1_needs_stack_repair = 1 &lt;&lt; 9,</span>
<span class="line-added">  96     _c2_needs_stack_repair = 1 &lt;&lt; 10</span>
  97   };
  98   mutable u2 _flags;
  99 
 100   JFR_ONLY(DEFINE_TRACE_FLAG;)
 101 
 102 #ifndef PRODUCT
 103   int               _compiled_invocation_count;  // Number of nmethod invocations so far (for perf. debugging)
 104 #endif
 105   // Entry point for calling both from and to the interpreter.
 106   address _i2i_entry;           // All-args-on-stack calling convention
 107   // Entry point for calling from compiled code, to compiled code if it exists
 108   // or else the interpreter.
<span class="line-modified"> 109   volatile address _from_compiled_entry;          // Cache of: _code ? _code-&gt;verified_entry_point()          : _adapter-&gt;c2i_entry()</span>
<span class="line-added"> 110   volatile address _from_compiled_value_ro_entry; // Cache of: _code ? _code-&gt;verified_value_ro_entry_point() : _adapter-&gt;c2i_value_ro_entry()</span>
<span class="line-added"> 111   volatile address _from_compiled_value_entry;    // Cache of: _code ? _code-&gt;verified_value_entry_point()    : _adapter-&gt;c2i_value_entry()</span>
 112   // The entry point for calling both from and to compiled code is
 113   // &quot;_code-&gt;entry_point()&quot;.  Because of tiered compilation and de-opt, this
 114   // field can come and go.  It can transition from NULL to not-null at any
 115   // time (whenever a compile completes).  It can transition from not-null to
 116   // NULL only at safepoints (because of a de-opt).
 117   CompiledMethod* volatile _code;                       // Points to the corresponding piece of native code
 118   volatile address           _from_interpreted_entry; // Cache of _code ? _adapter-&gt;i2c_entry() : _i2i_entry
<span class="line-added"> 119   int _max_vt_buffer; // max number of VT buffer chunk to use before recycling</span>
 120 
 121 #if INCLUDE_AOT &amp;&amp; defined(TIERED)
 122   CompiledMethod* _aot_code;
 123 #endif
 124 
 125   // Constructor
 126   Method(ConstMethod* xconst, AccessFlags access_flags);
 127  public:
 128 
 129   static Method* allocate(ClassLoaderData* loader_data,
 130                           int byte_code_size,
 131                           AccessFlags access_flags,
 132                           InlineTableSizes* sizes,
 133                           ConstMethod::MethodType method_type,
 134                           TRAPS);
 135 
 136   // CDS and vtbl checking can create an empty Method to get vtbl pointer.
 137   Method(){}
 138 
 139   bool is_method() const volatile { return true; }
 140 
 141   void restore_unshareable_info(TRAPS);
 142 
 143   // accessors for instance variables
 144 
 145   ConstMethod* constMethod() const             { return _constMethod; }
 146   void set_constMethod(ConstMethod* xconst)    { _constMethod = xconst; }
 147 
 148 
 149   static address make_adapters(const methodHandle&amp; mh, TRAPS);
 150   address from_compiled_entry() const;
<span class="line-modified"> 151   address from_compiled_value_ro_entry() const;</span>
<span class="line-added"> 152   address from_compiled_value_entry() const;</span>
<span class="line-added"> 153   address from_compiled_entry_no_trampoline(bool caller_is_c1) const;</span>
 154   address from_interpreted_entry() const;
 155 
 156   // access flag
 157   AccessFlags access_flags() const               { return _access_flags;  }
 158   void set_access_flags(AccessFlags flags)       { _access_flags = flags; }
 159 
 160   // name
 161   Symbol* name() const                           { return constants()-&gt;symbol_at(name_index()); }
 162   int name_index() const                         { return constMethod()-&gt;name_index();         }
 163   void set_name_index(int index)                 { constMethod()-&gt;set_name_index(index);       }
 164 
 165   // signature
 166   Symbol* signature() const                      { return constants()-&gt;symbol_at(signature_index()); }
 167   int signature_index() const                    { return constMethod()-&gt;signature_index();         }
 168   void set_signature_index(int index)            { constMethod()-&gt;set_signature_index(index);       }
 169 
 170   // generics support
 171   Symbol* generic_signature() const              { int idx = generic_signature_index(); return ((idx != 0) ? constants()-&gt;symbol_at(idx) : (Symbol*)NULL); }
 172   int generic_signature_index() const            { return constMethod()-&gt;generic_signature_index(); }
 173   void set_generic_signature_index(int index)    { constMethod()-&gt;set_generic_signature_index(index); }
</pre>
<hr />
<pre>
 460     if (TieredCompilation) ShouldNotReachHere();
 461     MethodCounters* mcs = get_method_counters(CHECK_0);
 462     return (mcs == NULL) ? 0 : mcs-&gt;increment_interpreter_invocation_count();
 463   }
 464 #endif
 465 
 466 #ifndef PRODUCT
 467   int  compiled_invocation_count() const         { return _compiled_invocation_count;  }
 468   void set_compiled_invocation_count(int count)  { _compiled_invocation_count = count; }
 469 #else
 470   // for PrintMethodData in a product build
 471   int  compiled_invocation_count() const         { return 0;  }
 472 #endif // not PRODUCT
 473 
 474   // Clear (non-shared space) pointers which could not be relevant
 475   // if this (shared) method were mapped into another JVM.
 476   void remove_unshareable_info();
 477 
 478   // nmethod/verified compiler entry
 479   address verified_code_entry();
<span class="line-added"> 480   address verified_value_code_entry();</span>
<span class="line-added"> 481   address verified_value_ro_code_entry();</span>
 482   bool check_code() const;      // Not inline to avoid circular ref
 483   CompiledMethod* volatile code() const;
 484 
 485   // Locks CompiledMethod_lock if not held.
 486   void unlink_code(CompiledMethod *compare);
 487   // Locks CompiledMethod_lock if not held.
 488   void unlink_code();
 489 
 490 private:
 491   // Either called with CompiledMethod_lock held or from constructor.
 492   void clear_code();
 493 
 494 public:
 495   static void set_code(const methodHandle&amp; mh, CompiledMethod* code);
 496   void set_adapter_entry(AdapterHandlerEntry* adapter) {
 497     constMethod()-&gt;set_adapter_entry(adapter);
 498   }
 499   void set_adapter_trampoline(AdapterHandlerEntry** trampoline) {
 500     constMethod()-&gt;set_adapter_trampoline(trampoline);
 501   }
 502   void update_adapter_trampoline(AdapterHandlerEntry* adapter) {
 503     constMethod()-&gt;update_adapter_trampoline(adapter);
 504   }
 505   void set_from_compiled_entry(address entry) {
<span class="line-modified"> 506     _from_compiled_entry = entry;</span>
<span class="line-added"> 507   }</span>
<span class="line-added"> 508   void set_from_compiled_value_ro_entry(address entry) {</span>
<span class="line-added"> 509     _from_compiled_value_ro_entry = entry;</span>
<span class="line-added"> 510   }</span>
<span class="line-added"> 511   void set_from_compiled_value_entry(address entry) {</span>
<span class="line-added"> 512     _from_compiled_value_entry = entry;</span>
 513   }
 514 
 515   address get_i2c_entry();
 516   address get_c2i_entry();
<span class="line-added"> 517   address get_c2i_value_entry();</span>
 518   address get_c2i_unverified_entry();
<span class="line-added"> 519   address get_c2i_unverified_value_entry();</span>
 520   address get_c2i_no_clinit_check_entry();
 521   AdapterHandlerEntry* adapter() const {
 522     return constMethod()-&gt;adapter();
 523   }
 524   // setup entry points
 525   void link_method(const methodHandle&amp; method, TRAPS);
 526   // clear entry points. Used by sharing code during dump time
 527   void unlink_method() NOT_CDS_RETURN;
 528 
 529   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
 530   virtual MetaspaceObj::Type type() const { return MethodType; }
 531 
 532   // vtable index
 533   enum VtableIndexFlag {
 534     // Valid vtable indexes are non-negative (&gt;= 0).
 535     // These few negative values are used as sentinels.
 536     itable_index_max        = -10, // first itable index, growing downward
 537     pending_itable_index    = -9,  // itable index will be assigned
 538     invalid_vtable_index    = -4,  // distinct from any valid vtable index
 539     garbage_vtable_index    = -3,  // not yet linked; no vtable layout yet
</pre>
<hr />
<pre>
 612 
 613   // localvariable table
 614   bool has_localvariable_table() const
 615                           { return constMethod()-&gt;has_localvariable_table(); }
 616   int localvariable_table_length() const
 617                         { return constMethod()-&gt;localvariable_table_length(); }
 618   LocalVariableTableElement* localvariable_table_start() const
 619                          { return constMethod()-&gt;localvariable_table_start(); }
 620 
 621   bool has_linenumber_table() const
 622                               { return constMethod()-&gt;has_linenumber_table(); }
 623   u_char* compressed_linenumber_table() const
 624                        { return constMethod()-&gt;compressed_linenumber_table(); }
 625 
 626   // method holder (the Klass* holding this method)
 627   InstanceKlass* method_holder() const         { return constants()-&gt;pool_holder(); }
 628 
 629   Symbol* klass_name() const;                    // returns the name of the method holder
 630   BasicType result_type() const                  { return constMethod()-&gt;result_type(); }
 631   bool is_returning_oop() const                  { BasicType r = result_type(); return is_reference_type(r); }
<span class="line-modified"> 632   ValueKlass* returned_value_type(Thread* thread) const;</span>
 633 
 634   // Checked exceptions thrown by this method (resolved to mirrors)
 635   objArrayHandle resolved_checked_exceptions(TRAPS) { return resolved_checked_exceptions_impl(this, THREAD); }
 636 
 637   // Access flags
 638   bool is_public() const                         { return access_flags().is_public();      }
 639   bool is_private() const                        { return access_flags().is_private();     }
 640   bool is_protected() const                      { return access_flags().is_protected();   }
 641   bool is_package_private() const                { return !is_public() &amp;&amp; !is_private() &amp;&amp; !is_protected(); }
 642   bool is_static() const                         { return access_flags().is_static();      }
 643   bool is_final() const                          { return access_flags().is_final();       }
 644   bool is_synchronized() const                   { return access_flags().is_synchronized();}
 645   bool is_native() const                         { return access_flags().is_native();      }
 646   bool is_abstract() const                       { return access_flags().is_abstract();    }
 647   bool is_strict() const                         { return access_flags().is_strict();      }
 648   bool is_synthetic() const                      { return access_flags().is_synthetic();   }
 649 
 650   // returns true if contains only return operation
 651   bool is_empty_method() const;
 652 
</pre>
<hr />
<pre>
 685   void set_has_monitor_bytecodes()               { _access_flags.set_has_monitor_bytecodes(); }
 686 
 687   // monitor matching. This returns a conservative estimate of whether the monitorenter/monitorexit bytecodes
 688   // propererly nest in the method. It might return false, even though they actually nest properly, since the info.
 689   // has not been computed yet.
 690   bool guaranteed_monitor_matching() const       { return access_flags().is_monitor_matching(); }
 691   void set_guaranteed_monitor_matching()         { _access_flags.set_monitor_matching(); }
 692 
 693   // returns true if the method is an accessor function (setter/getter).
 694   bool is_accessor() const;
 695 
 696   // returns true if the method is a getter
 697   bool is_getter() const;
 698 
 699   // returns true if the method is a setter
 700   bool is_setter() const;
 701 
 702   // returns true if the method does nothing but return a constant of primitive type
 703   bool is_constant_getter() const;
 704 






 705   // returns true if the method name is &lt;clinit&gt; and the method has
 706   // valid static initializer flags.
<span class="line-modified"> 707   bool is_class_initializer() const;</span>
<span class="line-added"> 708 </span>
<span class="line-added"> 709   // returns true if the method name is &lt;init&gt; and the method is not a static factory</span>
<span class="line-added"> 710   bool is_object_constructor() const;</span>
 711 
<span class="line-modified"> 712   // returns true if the method is an object constructor or class initializer</span>
<span class="line-modified"> 713   // (non-static &lt;init&gt; or &lt;clinit&gt;), but false for factories (static &lt;init&gt;).</span>
<span class="line-added"> 714   bool is_object_constructor_or_class_initializer() const;</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716   // returns true if the method name is &lt;init&gt; and the method is static</span>
<span class="line-added"> 717   bool is_static_init_factory() const;</span>
 718 
 719   // compiled code support
 720   // NOTE: code() is inherently racy as deopt can be clearing code
 721   // simultaneously. Use with caution.
 722   bool has_compiled_code() const;
 723 
 724 #ifdef TIERED
 725   bool has_aot_code() const                      { return aot_code() != NULL; }
 726 #endif
 727 
 728   bool needs_clinit_barrier() const;
 729 
 730   // sizing
 731   static int header_size()                       {
 732     return align_up((int)sizeof(Method), wordSize) / wordSize;
 733   }
 734   static int size(bool is_native);
 735   int size() const                               { return method_size(); }
 736   void log_touched(TRAPS);
 737   static void print_touched_methods(outputStream* out);
 738 
 739   // interpreter support
 740   static ByteSize const_offset()                 { return byte_offset_of(Method, _constMethod       ); }
 741   static ByteSize access_flags_offset()          { return byte_offset_of(Method, _access_flags      ); }
 742   static ByteSize from_compiled_offset()         { return byte_offset_of(Method, _from_compiled_entry); }
<span class="line-added"> 743   static ByteSize from_compiled_value_offset()   { return byte_offset_of(Method, _from_compiled_value_entry); }</span>
<span class="line-added"> 744   static ByteSize from_compiled_value_ro_offset(){ return byte_offset_of(Method, _from_compiled_value_ro_entry); }</span>
 745   static ByteSize code_offset()                  { return byte_offset_of(Method, _code); }
<span class="line-added"> 746   static ByteSize flags_offset()                 { return byte_offset_of(Method, _flags); }</span>
 747   static ByteSize method_data_offset()           {
 748     return byte_offset_of(Method, _method_data);
 749   }
 750   static ByteSize method_counters_offset()       {
 751     return byte_offset_of(Method, _method_counters);
 752   }
 753 #ifndef PRODUCT
 754   static ByteSize compiled_invocation_counter_offset() { return byte_offset_of(Method, _compiled_invocation_count); }
 755 #endif // not PRODUCT
 756   static ByteSize native_function_offset()       { return in_ByteSize(sizeof(Method));                 }
 757   static ByteSize from_interpreted_offset()      { return byte_offset_of(Method, _from_interpreted_entry ); }
 758   static ByteSize interpreter_entry_offset()     { return byte_offset_of(Method, _i2i_entry ); }
 759   static ByteSize signature_handler_offset()     { return in_ByteSize(sizeof(Method) + wordSize);      }
 760   static ByteSize itable_index_offset()          { return byte_offset_of(Method, _vtable_index ); }
 761 
 762   // for code generation
 763   static int method_data_offset_in_bytes()       { return offset_of(Method, _method_data); }
 764   static int intrinsic_id_offset_in_bytes()      { return offset_of(Method, _intrinsic_id); }
 765   static int intrinsic_id_size_in_bytes()        { return sizeof(u2); }
 766 
<span class="line-added"> 767   static ByteSize max_vt_buffer_offset()         { return byte_offset_of(Method, _max_vt_buffer); }</span>
<span class="line-added"> 768 </span>
 769   // Static methods that are used to implement member methods where an exposed this pointer
 770   // is needed due to possible GCs
 771   static objArrayHandle resolved_checked_exceptions_impl(Method* method, TRAPS);
 772 
 773   // Returns the byte code index from the byte code pointer
 774   int     bci_from(address bcp) const;
 775   address bcp_from(int bci) const;
 776   address bcp_from(address bcp) const;
 777   int validate_bci_from_bcp(address bcp) const;
 778   int validate_bci(int bci) const;
 779 
 780   // Returns the line number for a bci if debugging information for the method is prowided,
 781   // -1 is returned otherwise.
 782   int line_number_from_bci(int bci) const;
 783 
 784   // Reflection support
 785   bool is_overridden_in(Klass* k) const;
 786 
 787   // Stack walking support
 788   bool is_ignored_by_security_stack_walk() const;
</pre>
<hr />
<pre>
 929   }
 930   void set_intrinsic_candidate(bool x) {
 931     _flags = x ? (_flags | _intrinsic_candidate) : (_flags &amp; ~_intrinsic_candidate);
 932   }
 933 
 934   bool has_injected_profile() {
 935     return (_flags &amp; _has_injected_profile) != 0;
 936   }
 937   void set_has_injected_profile(bool x) {
 938     _flags = x ? (_flags | _has_injected_profile) : (_flags &amp; ~_has_injected_profile);
 939   }
 940 
 941   bool has_reserved_stack_access() {
 942     return (_flags &amp; _reserved_stack_access) != 0;
 943   }
 944 
 945   void set_has_reserved_stack_access(bool x) {
 946     _flags = x ? (_flags | _reserved_stack_access) : (_flags &amp; ~_reserved_stack_access);
 947   }
 948 
<span class="line-added"> 949   bool has_scalarized_args() {</span>
<span class="line-added"> 950     return (_flags &amp; _scalarized_args) != 0;</span>
<span class="line-added"> 951   }</span>
<span class="line-added"> 952 </span>
<span class="line-added"> 953   void set_has_scalarized_args(bool x) {</span>
<span class="line-added"> 954     _flags = x ? (_flags | _scalarized_args) : (_flags &amp; ~_scalarized_args);</span>
<span class="line-added"> 955   }</span>
<span class="line-added"> 956 </span>
<span class="line-added"> 957   bool c1_needs_stack_repair() {</span>
<span class="line-added"> 958     return (_flags &amp; _c1_needs_stack_repair) != 0;</span>
<span class="line-added"> 959   }</span>
<span class="line-added"> 960 </span>
<span class="line-added"> 961   bool c2_needs_stack_repair() {</span>
<span class="line-added"> 962     return (_flags &amp; _c2_needs_stack_repair) != 0;</span>
<span class="line-added"> 963   }</span>
<span class="line-added"> 964 </span>
<span class="line-added"> 965   void set_c1_needs_stack_repair(bool x) {</span>
<span class="line-added"> 966     _flags = x ? (_flags | _c1_needs_stack_repair) : (_flags &amp; ~_c1_needs_stack_repair);</span>
<span class="line-added"> 967   }</span>
<span class="line-added"> 968 </span>
<span class="line-added"> 969   void set_c2_needs_stack_repair(bool x) {</span>
<span class="line-added"> 970     _flags = x ? (_flags | _c2_needs_stack_repair) : (_flags &amp; ~_c2_needs_stack_repair);</span>
<span class="line-added"> 971   }</span>
<span class="line-added"> 972 </span>
 973   JFR_ONLY(DEFINE_TRACE_FLAG_ACCESSOR;)
 974 
 975   ConstMethod::MethodType method_type() const {
 976       return _constMethod-&gt;method_type();
 977   }
 978   bool is_overpass() const { return method_type() == ConstMethod::OVERPASS; }
 979 
 980   // On-stack replacement support
 981   bool has_osr_nmethod(int level, bool match_level) {
 982    return method_holder()-&gt;lookup_osr_nmethod(this, InvocationEntryBci, level, match_level) != NULL;
 983   }
 984 
 985   int mark_osr_nmethods() {
 986     return method_holder()-&gt;mark_osr_nmethods(this);
 987   }
 988 
 989   nmethod* lookup_osr_nmethod_for(int bci, int level, bool match_level) {
 990     return method_holder()-&gt;lookup_osr_nmethod(this, bci, level, match_level);
 991   }
 992 
</pre>
</td>
</tr>
</table>
<center><a href="method.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="oopsHierarchy.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
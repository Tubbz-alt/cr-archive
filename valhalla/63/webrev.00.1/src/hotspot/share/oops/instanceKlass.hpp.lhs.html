<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/oops/instanceKlass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OOPS_INSTANCEKLASS_HPP
  26 #define SHARE_OOPS_INSTANCEKLASS_HPP
  27 
  28 #include &quot;classfile/classLoaderData.hpp&quot;
<a name="1" id="anc1"></a>
  29 #include &quot;memory/referenceType.hpp&quot;
  30 #include &quot;oops/annotations.hpp&quot;
  31 #include &quot;oops/constMethod.hpp&quot;
  32 #include &quot;oops/fieldInfo.hpp&quot;
  33 #include &quot;oops/instanceOop.hpp&quot;
  34 #include &quot;oops/klassVtable.hpp&quot;
  35 #include &quot;runtime/handles.hpp&quot;
  36 #include &quot;runtime/os.hpp&quot;
  37 #include &quot;utilities/accessFlags.hpp&quot;
  38 #include &quot;utilities/align.hpp&quot;
  39 #include &quot;utilities/macros.hpp&quot;
  40 #if INCLUDE_JFR
  41 #include &quot;jfr/support/jfrKlassExtension.hpp&quot;
  42 #endif
  43 
  44 class RecordComponent;
  45 
  46 // An InstanceKlass is the VM level representation of a Java class.
  47 // It contains all information needed for at class at execution runtime.
  48 
  49 //  InstanceKlass embedded field layout (after declared fields):
  50 //    [EMBEDDED Java vtable             ] size in words = vtable_len
  51 //    [EMBEDDED nonstatic oop-map blocks] size in words = nonstatic_oop_map_size
  52 //      The embedded nonstatic oop-map blocks are short pairs (offset, length)
  53 //      indicating where oops are located in instances of this klass.
  54 //    [EMBEDDED implementor of the interface] only exist for interface
  55 //    [EMBEDDED unsafe_anonymous_host klass] only exist for an unsafe anonymous class (JSR 292 enabled)
  56 //    [EMBEDDED fingerprint       ] only if should_store_fingerprint()==true
<a name="2" id="anc2"></a>
  57 
  58 
  59 // forward declaration for class -- see below for definition
  60 #if INCLUDE_JVMTI
  61 class BreakpointInfo;
  62 #endif
  63 class ClassFileParser;
  64 class ClassFileStream;
  65 class KlassDepChange;
  66 class DependencyContext;
  67 class fieldDescriptor;
  68 class jniIdMapBase;
  69 class JNIid;
  70 class JvmtiCachedClassFieldMap;
  71 class nmethodBucket;
  72 class OopMapCache;
<a name="3" id="anc3"></a>
  73 class InterpreterOopMap;
  74 class PackageEntry;
  75 class ModuleEntry;
  76 
  77 // This is used in iterators below.
  78 class FieldClosure: public StackObj {
  79 public:
  80   virtual void do_field(fieldDescriptor* fd) = 0;
  81 };
  82 
  83 #ifndef PRODUCT
  84 // Print fields.
  85 // If &quot;obj&quot; argument to constructor is NULL, prints static fields, otherwise prints non-static fields.
  86 class FieldPrinter: public FieldClosure {
  87    oop _obj;
  88    outputStream* _st;
  89  public:
  90    FieldPrinter(outputStream* st, oop obj = NULL) : _obj(obj), _st(st) {}
  91    void do_field(fieldDescriptor* fd);
  92 };
  93 #endif  // !PRODUCT
  94 
  95 // Describes where oops are located in instances of this klass.
  96 class OopMapBlock {
  97  public:
  98   // Byte offset of the first oop mapped by this block.
  99   int offset() const          { return _offset; }
 100   void set_offset(int offset) { _offset = offset; }
 101 
 102   // Number of oops in this block.
 103   uint count() const         { return _count; }
 104   void set_count(uint count) { _count = count; }
 105 
 106   void increment_count(int diff) { _count += diff; }
 107 
 108   int offset_span() const { return _count * heapOopSize; }
 109 
 110   int end_offset() const {
 111     return offset() + offset_span();
 112   }
 113 
 114   bool is_contiguous(int another_offset) const {
 115     return another_offset == end_offset();
 116   }
 117 
 118   // sizeof(OopMapBlock) in words.
 119   static const int size_in_words() {
 120     return align_up((int)sizeof(OopMapBlock), wordSize) &gt;&gt;
 121       LogBytesPerWord;
 122   }
 123 
 124   static int compare_offset(const OopMapBlock* a, const OopMapBlock* b) {
 125     return a-&gt;offset() - b-&gt;offset();
 126   }
 127 
 128  private:
 129   int  _offset;
 130   uint _count;
 131 };
 132 
 133 struct JvmtiCachedClassFileData;
 134 
<a name="4" id="anc4"></a>






















 135 class InstanceKlass: public Klass {
 136   friend class VMStructs;
 137   friend class JVMCIVMStructs;
 138   friend class ClassFileParser;
 139   friend class CompileReplay;
<a name="5" id="anc5"></a>
 140 
 141  public:
 142   static const KlassID ID = InstanceKlassID;
 143 
 144  protected:
 145   InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id = ID);
 146 
 147  public:
 148   InstanceKlass() { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for CDS&quot;); }
 149 
 150   // See &quot;The Java Virtual Machine Specification&quot; section 2.16.2-5 for a detailed description
 151   // of the class loading &amp; initialization procedure, and the use of the states.
 152   enum ClassState {
 153     allocated,                          // allocated (but not yet linked)
 154     loaded,                             // loaded and inserted in class hierarchy (but not linked yet)
 155     linked,                             // successfully linked/verified (but not initialized yet)
 156     being_initialized,                  // currently running class initializer
<a name="6" id="anc6"></a><span class="line-modified"> 157     fully_initialized,                  // initialized (successfull final state)</span>
 158     initialization_error                // error happened during initialization
 159   };
 160 
 161  private:
 162   static InstanceKlass* allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS);
 163 
 164  protected:
 165   // If you add a new field that points to any metaspace object, you
 166   // must add this field to InstanceKlass::metaspace_pointers_do().
 167 
 168   // Annotations for this class
 169   Annotations*    _annotations;
 170   // Package this class is defined in
 171   PackageEntry*   _package_entry;
 172   // Array classes holding elements of this class.
 173   Klass* volatile _array_klasses;
 174   // Constant pool for this class.
 175   ConstantPool* _constants;
 176   // The InnerClasses attribute and EnclosingMethod attribute. The
 177   // _inner_classes is an array of shorts. If the class has InnerClasses
 178   // attribute, then the _inner_classes array begins with 4-tuples of shorts
 179   // [inner_class_info_index, outer_class_info_index,
 180   // inner_name_index, inner_class_access_flags] for the InnerClasses
 181   // attribute. If the EnclosingMethod attribute exists, it occupies the
 182   // last two shorts [class_index, method_index] of the array. If only
 183   // the InnerClasses attribute exists, the _inner_classes array length is
 184   // number_of_inner_classes * 4. If the class has both InnerClasses
 185   // and EnclosingMethod attributes the _inner_classes array length is
 186   // number_of_inner_classes * 4 + enclosing_method_attribute_size.
 187   Array&lt;jushort&gt;* _inner_classes;
 188 
 189   // The NestMembers attribute. An array of shorts, where each is a
 190   // class info index for the class that is a nest member. This data
 191   // has not been validated.
 192   Array&lt;jushort&gt;* _nest_members;
 193 
 194   // The NestHost attribute. The class info index for the class
 195   // that is the nest-host of this class. This data has not been validated.
 196   jushort _nest_host_index;
 197 
 198   // Resolved nest-host klass: either true nest-host or self if we are not
 199   // nested, or an error occurred resolving or validating the nominated
 200   // nest-host. Can also be set directly by JDK API&#39;s that establish nest
 201   // relationships.
 202   // By always being set it makes nest-member access checks simpler.
 203   InstanceKlass* _nest_host;
 204 
<a name="7" id="anc7"></a>

 205   // The contents of the Record attribute.
 206   Array&lt;RecordComponent*&gt;* _record_components;
 207 
 208   // the source debug extension for this klass, NULL if not specified.
 209   // Specified as UTF-8 string without terminating zero byte in the classfile,
 210   // it is stored in the instanceklass as a NULL-terminated UTF-8 string
 211   const char*     _source_debug_extension;
 212   // Array name derived from this class which needs unreferencing
 213   // if this class is unloaded.
 214   Symbol*         _array_name;
 215 
 216   // Number of heapOopSize words used by non-static fields in this klass
 217   // (including inherited fields but after header_size()).
 218   int             _nonstatic_field_size;
 219   int             _static_field_size;    // number words used by static fields (oop and non-oop) in this klass
 220   // Constant pool index to the utf8 entry of the Generic signature,
 221   // or 0 if none.
 222   u2              _generic_signature_index;
 223   // Constant pool index to the utf8 entry for the name of source file
 224   // containing this klass, 0 if not specified.
 225   u2              _source_file_name_index;
 226   u2              _static_oop_field_count;// number of static oop fields in this klass
 227   u2              _java_fields_count;    // The number of declared Java fields
 228   int             _nonstatic_oop_map_size;// size in words of nonstatic oop map blocks
 229 
 230   int             _itable_len;           // length of Java itable (in words)
 231   // _is_marked_dependent can be set concurrently, thus cannot be part of the
 232   // _misc_flags.
 233   bool            _is_marked_dependent;  // used for marking during flushing and deoptimization
 234 
<a name="8" id="anc8"></a><span class="line-modified"> 235   // The low two bits of _misc_flags contains the kind field.</span>
<span class="line-modified"> 236   // This can be used to quickly discriminate among the four kinds of</span>
 237   // InstanceKlass.
 238 
<a name="9" id="anc9"></a><span class="line-modified"> 239   static const unsigned _misc_kind_field_size = 2;</span>
 240   static const unsigned _misc_kind_field_pos  = 0;
 241   static const unsigned _misc_kind_field_mask = (1u &lt;&lt; _misc_kind_field_size) - 1u;
 242 
 243   static const unsigned _misc_kind_other        = 0; // concrete InstanceKlass
 244   static const unsigned _misc_kind_reference    = 1; // InstanceRefKlass
 245   static const unsigned _misc_kind_class_loader = 2; // InstanceClassLoaderKlass
 246   static const unsigned _misc_kind_mirror       = 3; // InstanceMirrorKlass
<a name="10" id="anc10"></a>
 247 
 248   // Start after _misc_kind field.
 249   enum {
<a name="11" id="anc11"></a><span class="line-modified"> 250     _misc_rewritten                           = 1 &lt;&lt; 2,  // methods rewritten.</span>
<span class="line-modified"> 251     _misc_has_nonstatic_fields                = 1 &lt;&lt; 3,  // for sizing with UseCompressedOops</span>
<span class="line-modified"> 252     _misc_should_verify_class                 = 1 &lt;&lt; 4,  // allow caching of preverification</span>
<span class="line-modified"> 253     _misc_is_unsafe_anonymous                 = 1 &lt;&lt; 5,  // has embedded _unsafe_anonymous_host field</span>
<span class="line-modified"> 254     _misc_is_contended                        = 1 &lt;&lt; 6,  // marked with contended annotation</span>
<span class="line-modified"> 255     _misc_has_nonstatic_concrete_methods      = 1 &lt;&lt; 7,  // class/superclass/implemented interfaces has non-static, concrete methods</span>
<span class="line-modified"> 256     _misc_declares_nonstatic_concrete_methods = 1 &lt;&lt; 8,  // directly declares non-static, concrete methods</span>
<span class="line-modified"> 257     _misc_has_been_redefined                  = 1 &lt;&lt; 9,  // class has been redefined</span>
<span class="line-modified"> 258     _misc_has_passed_fingerprint_check        = 1 &lt;&lt; 10, // when this class was loaded, the fingerprint computed from its</span>
 259                                                          // code source was found to be matching the value recorded by AOT.
<a name="12" id="anc12"></a><span class="line-modified"> 260     _misc_is_scratch_class                    = 1 &lt;&lt; 11, // class is the redefined scratch class</span>
<span class="line-modified"> 261     _misc_is_shared_boot_class                = 1 &lt;&lt; 12, // defining class loader is boot class loader</span>
<span class="line-modified"> 262     _misc_is_shared_platform_class            = 1 &lt;&lt; 13, // defining class loader is platform class loader</span>
<span class="line-modified"> 263     _misc_is_shared_app_class                 = 1 &lt;&lt; 14, // defining class loader is app class loader</span>
<span class="line-modified"> 264     _misc_has_resolved_methods                = 1 &lt;&lt; 15, // resolved methods table entries added for this class</span>
<span class="line-modified"> 265     _misc_is_being_redefined                  = 1 &lt;&lt; 16, // used for locking redefinition</span>
<span class="line-modified"> 266     _misc_has_contended_annotations           = 1 &lt;&lt; 17  // has @Contended annotation</span>







 267   };
 268   u2 shared_loader_type_bits() const {
 269     return _misc_is_shared_boot_class|_misc_is_shared_platform_class|_misc_is_shared_app_class;
 270   }
 271   u4              _misc_flags;
 272   u2              _minor_version;        // minor version number of class file
 273   u2              _major_version;        // major version number of class file
 274   Thread*         _init_thread;          // Pointer to current thread doing initialization (to handle recursive initialization)
 275   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
 276   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
 277   jmethodID*      volatile _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
 278   nmethodBucket*  volatile _dep_context;          // packed DependencyContext structure
 279   uint64_t        volatile _dep_context_last_cleaned;
 280   nmethod*        _osr_nmethods_head;    // Head of list of on-stack replacement nmethods for this class
 281 #if INCLUDE_JVMTI
 282   BreakpointInfo* _breakpoints;          // bpt lists, managed by Method*
 283   // Linked instanceKlasses of previous versions
 284   InstanceKlass* _previous_versions;
 285   // JVMTI fields can be moved to their own structure - see 6315920
 286   // JVMTI: cached class file, before retransformable agent modified it in CFLH
 287   JvmtiCachedClassFileData* _cached_class_file;
 288 #endif
 289 
 290   volatile u2     _idnum_allocated_count;         // JNI/JVMTI: increments with the addition of methods, old ids don&#39;t change
 291 
 292   // Class states are defined as ClassState (see above).
 293   // Place the _init_state here to utilize the unused 2-byte after
 294   // _idnum_allocated_count.
 295   u1              _init_state;                    // state of class
 296   u1              _reference_type;                // reference type
 297 
 298   u2              _this_class_index;              // constant pool entry
 299 #if INCLUDE_JVMTI
 300   JvmtiCachedClassFieldMap* _jvmti_cached_class_field_map;  // JVMTI: used during heap iteration
 301 #endif
 302 
 303   NOT_PRODUCT(int _verify_count;)  // to avoid redundant verifies
 304 
 305   // Method array.
 306   Array&lt;Method*&gt;* _methods;
 307   // Default Method Array, concrete methods inherited from interfaces
 308   Array&lt;Method*&gt;* _default_methods;
 309   // Interfaces (InstanceKlass*s) this class declares locally to implement.
 310   Array&lt;InstanceKlass*&gt;* _local_interfaces;
 311   // Interfaces (InstanceKlass*s) this class implements transitively.
 312   Array&lt;InstanceKlass*&gt;* _transitive_interfaces;
 313   // Int array containing the original order of method in the class file (for JVMTI).
 314   Array&lt;int&gt;*     _method_ordering;
 315   // Int array containing the vtable_indices for default_methods
 316   // offset matches _default_methods offset
 317   Array&lt;int&gt;*     _default_vtable_indices;
 318 
 319   // Instance and static variable information, starts with 6-tuples of shorts
 320   // [access, name index, sig index, initval index, low_offset, high_offset]
 321   // for all fields, followed by the generic signature data at the end of
 322   // the array. Only fields with generic signature attributes have the generic
 323   // signature data set in the array. The fields array looks like following:
 324   //
 325   // f1: [access, name index, sig index, initial value index, low_offset, high_offset]
 326   // f2: [access, name index, sig index, initial value index, low_offset, high_offset]
 327   //      ...
 328   // fn: [access, name index, sig index, initial value index, low_offset, high_offset]
 329   //     [generic signature index]
 330   //     [generic signature index]
 331   //     ...
 332   Array&lt;u2&gt;*      _fields;
<a name="13" id="anc13"></a>


 333 
 334   // embedded Java vtable follows here
 335   // embedded Java itables follows here
 336   // embedded static fields follows here
 337   // embedded nonstatic oop-map blocks follows here
 338   // embedded implementor of this interface follows here
 339   //   The embedded implementor only exists if the current klass is an
 340   //   iterface. The possible values of the implementor fall into following
 341   //   three cases:
 342   //     NULL: no implementor.
 343   //     A Klass* that&#39;s not itself: one implementor.
 344   //     Itself: more than one implementors.
 345   // embedded unsafe_anonymous_host klass follows here
 346   //   The embedded host klass only exists in an unsafe anonymous class for
 347   //   dynamic language support (JSR 292 enabled). The host class grants
 348   //   its access privileges to this class also. The host class is either
 349   //   named, or a previously loaded unsafe anonymous class. A non-anonymous class
 350   //   or an anonymous class loaded through normal classloading does not
 351   //   have this embedded field.
 352   //
 353 
 354   friend class SystemDictionary;
 355 
 356   static bool _disable_method_binary_search;
 357 
 358  public:
 359   // The three BUILTIN class loader types
 360   bool is_shared_boot_class() const {
 361     return (_misc_flags &amp; _misc_is_shared_boot_class) != 0;
 362   }
 363   bool is_shared_platform_class() const {
 364     return (_misc_flags &amp; _misc_is_shared_platform_class) != 0;
 365   }
 366   bool is_shared_app_class() const {
 367     return (_misc_flags &amp; _misc_is_shared_app_class) != 0;
 368   }
 369   // The UNREGISTERED class loader type
 370   bool is_shared_unregistered_class() const {
 371     return (_misc_flags &amp; shared_loader_type_bits()) == 0;
 372   }
 373 
 374   void clear_shared_class_loader_type() {
 375     _misc_flags &amp;= ~shared_loader_type_bits();
 376   }
 377 
 378   void set_shared_class_loader_type(s2 loader_type);
 379 
 380   bool has_nonstatic_fields() const        {
 381     return (_misc_flags &amp; _misc_has_nonstatic_fields) != 0;
 382   }
 383   void set_has_nonstatic_fields(bool b)    {
 384     if (b) {
 385       _misc_flags |= _misc_has_nonstatic_fields;
 386     } else {
 387       _misc_flags &amp;= ~_misc_has_nonstatic_fields;
 388     }
 389   }
 390 
<a name="14" id="anc14"></a>
































































 391   // field sizes
 392   int nonstatic_field_size() const         { return _nonstatic_field_size; }
 393   void set_nonstatic_field_size(int size)  { _nonstatic_field_size = size; }
 394 
 395   int static_field_size() const            { return _static_field_size; }
 396   void set_static_field_size(int size)     { _static_field_size = size; }
 397 
 398   int static_oop_field_count() const       { return (int)_static_oop_field_count; }
 399   void set_static_oop_field_count(u2 size) { _static_oop_field_count = size; }
 400 
 401   // Java itable
 402   int  itable_length() const               { return _itable_len; }
 403   void set_itable_length(int len)          { _itable_len = len; }
 404 
 405   // array klasses
 406   Klass* array_klasses() const             { return _array_klasses; }
 407   inline Klass* array_klasses_acquire() const; // load with acquire semantics
 408   void set_array_klasses(Klass* k)         { _array_klasses = k; }
 409   inline void release_set_array_klasses(Klass* k); // store with release semantics
 410 
 411   // methods
 412   Array&lt;Method*&gt;* methods() const          { return _methods; }
 413   void set_methods(Array&lt;Method*&gt;* a)      { _methods = a; }
 414   Method* method_with_idnum(int idnum);
 415   Method* method_with_orig_idnum(int idnum);
 416   Method* method_with_orig_idnum(int idnum, int version);
 417 
 418   // method ordering
 419   Array&lt;int&gt;* method_ordering() const     { return _method_ordering; }
 420   void set_method_ordering(Array&lt;int&gt;* m) { _method_ordering = m; }
 421   void copy_method_ordering(const intArray* m, TRAPS);
 422 
 423   // default_methods
 424   Array&lt;Method*&gt;* default_methods() const  { return _default_methods; }
 425   void set_default_methods(Array&lt;Method*&gt;* a) { _default_methods = a; }
 426 
 427   // default method vtable_indices
 428   Array&lt;int&gt;* default_vtable_indices() const { return _default_vtable_indices; }
 429   void set_default_vtable_indices(Array&lt;int&gt;* v) { _default_vtable_indices = v; }
 430   Array&lt;int&gt;* create_new_default_vtable_indices(int len, TRAPS);
 431 
 432   // interfaces
 433   Array&lt;InstanceKlass*&gt;* local_interfaces() const          { return _local_interfaces; }
 434   void set_local_interfaces(Array&lt;InstanceKlass*&gt;* a)      {
 435     guarantee(_local_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 436     _local_interfaces = a; }
 437 
 438   Array&lt;InstanceKlass*&gt;* transitive_interfaces() const     { return _transitive_interfaces; }
 439   void set_transitive_interfaces(Array&lt;InstanceKlass*&gt;* a) {
 440     guarantee(_transitive_interfaces == NULL || a == NULL, &quot;Just checking&quot;);
 441     _transitive_interfaces = a;
 442   }
 443 
 444  private:
 445   friend class fieldDescriptor;
 446   FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }
 447 
 448  public:
 449   int     field_offset      (int index) const { return field(index)-&gt;offset(); }
 450   int     field_access_flags(int index) const { return field(index)-&gt;access_flags(); }
 451   Symbol* field_name        (int index) const { return field(index)-&gt;name(constants()); }
 452   Symbol* field_signature   (int index) const { return field(index)-&gt;signature(constants()); }
<a name="15" id="anc15"></a>

 453 
 454   // Number of Java declared fields
 455   int java_fields_count() const           { return (int)_java_fields_count; }
 456 
 457   Array&lt;u2&gt;* fields() const            { return _fields; }
 458   void set_fields(Array&lt;u2&gt;* f, u2 java_fields_count) {
 459     guarantee(_fields == NULL || f == NULL, &quot;Just checking&quot;);
 460     _fields = f;
 461     _java_fields_count = java_fields_count;
 462   }
 463 
 464   // inner classes
 465   Array&lt;u2&gt;* inner_classes() const       { return _inner_classes; }
 466   void set_inner_classes(Array&lt;u2&gt;* f)   { _inner_classes = f; }
 467 
 468   // nest members
 469   Array&lt;u2&gt;* nest_members() const     { return _nest_members; }
 470   void set_nest_members(Array&lt;u2&gt;* m) { _nest_members = m; }
 471 
 472   // nest-host index
 473   jushort nest_host_index() const { return _nest_host_index; }
 474   void set_nest_host_index(u2 i)  { _nest_host_index = i; }
 475   // dynamic nest member support
 476   void set_nest_host(InstanceKlass* host, TRAPS);
 477 
 478   // record components
 479   Array&lt;RecordComponent*&gt;* record_components() const { return _record_components; }
 480   void set_record_components(Array&lt;RecordComponent*&gt;* record_components) {
 481     _record_components = record_components;
 482   }
 483   bool is_record() const { return _record_components != NULL; }
 484 
 485 private:
 486   // Called to verify that k is a member of this nest - does not look at k&#39;s nest-host
 487   bool has_nest_member(InstanceKlass* k, TRAPS) const;
 488 
 489 public:
 490   // Used to construct informative IllegalAccessError messages at a higher level,
 491   // if there was an issue resolving or validating the nest host.
 492   // Returns NULL if there was no error.
 493   const char* nest_host_error(TRAPS);
 494   // Returns nest-host class, resolving and validating it if needed.
 495   // Returns NULL if resolution is not possible from the calling context.
 496   InstanceKlass* nest_host(TRAPS);
 497   // Check if this klass is a nestmate of k - resolves this nest-host and k&#39;s
 498   bool has_nestmate_access_to(InstanceKlass* k, TRAPS);
 499 
 500   enum InnerClassAttributeOffset {
 501     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
 502     inner_class_inner_class_info_offset = 0,
 503     inner_class_outer_class_info_offset = 1,
 504     inner_class_inner_name_offset = 2,
 505     inner_class_access_flags_offset = 3,
 506     inner_class_next_offset = 4
 507   };
 508 
 509   enum EnclosingMethodAttributeOffset {
 510     enclosing_method_class_index_offset = 0,
 511     enclosing_method_method_index_offset = 1,
 512     enclosing_method_attribute_size = 2
 513   };
 514 
 515   // method override check
 516   bool is_override(const methodHandle&amp; super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);
 517 
 518   // package
 519   PackageEntry* package() const     { return _package_entry; }
 520   ModuleEntry* module() const;
 521   bool in_unnamed_package() const   { return (_package_entry == NULL); }
 522   void set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS);
 523   // If the package for the InstanceKlass is in the boot loader&#39;s package entry
 524   // table then sets the classpath_index field so that
 525   // get_system_package() will know to return a non-null value for the
 526   // package&#39;s location.  And, so that the package will be added to the list of
 527   // packages returned by get_system_packages().
 528   // For packages whose classes are loaded from the boot loader class path, the
 529   // classpath_index indicates which entry on the boot loader class path.
 530   void set_classpath_index(s2 path_index, TRAPS);
 531   bool is_same_class_package(const Klass* class2) const;
 532   bool is_same_class_package(oop other_class_loader, const Symbol* other_class_name) const;
 533 
 534   // find an enclosing class
 535   InstanceKlass* compute_enclosing_class(bool* inner_is_member, TRAPS) const;
 536 
 537   // Find InnerClasses attribute and return outer_class_info_index &amp; inner_name_index.
 538   bool find_inner_classes_attr(int* ooff, int* noff, TRAPS) const;
 539 
 540  private:
 541   // Check prohibited package (&quot;java/&quot; only loadable by boot or platform loaders)
 542   static void check_prohibited_package(Symbol* class_name,
 543                                        ClassLoaderData* loader_data,
 544                                        TRAPS);
 545  public:
 546   // initialization state
 547   bool is_loaded() const                   { return _init_state &gt;= loaded; }
 548   bool is_linked() const                   { return _init_state &gt;= linked; }
 549   bool is_initialized() const              { return _init_state == fully_initialized; }
 550   bool is_not_initialized() const          { return _init_state &lt;  being_initialized; }
 551   bool is_being_initialized() const        { return _init_state == being_initialized; }
 552   bool is_in_error_state() const           { return _init_state == initialization_error; }
 553   bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }
 554   ClassState  init_state()                 { return (ClassState)_init_state; }
 555   bool is_rewritten() const                { return (_misc_flags &amp; _misc_rewritten) != 0; }
 556 
 557   // defineClass specified verification
 558   bool should_verify_class() const         {
 559     return (_misc_flags &amp; _misc_should_verify_class) != 0;
 560   }
 561   void set_should_verify_class(bool value) {
 562     if (value) {
 563       _misc_flags |= _misc_should_verify_class;
 564     } else {
 565       _misc_flags &amp;= ~_misc_should_verify_class;
 566     }
 567   }
 568 
 569   // marking
 570   bool is_marked_dependent() const         { return _is_marked_dependent; }
 571   void set_is_marked_dependent(bool value) { _is_marked_dependent = value; }
 572 
<a name="16" id="anc16"></a>


 573   // initialization (virtuals from Klass)
 574   bool should_be_initialized() const;  // means that initialize should be called
 575   void initialize(TRAPS);
 576   void link_class(TRAPS);
 577   bool link_class_or_fail(TRAPS); // returns false on failure
 578   void rewrite_class(TRAPS);
 579   void link_methods(TRAPS);
 580   Method* class_initializer() const;
 581 
 582   // set the class to initialized if no static initializer is present
 583   void eager_initialize(Thread *thread);
 584 
 585   // reference type
 586   ReferenceType reference_type() const     { return (ReferenceType)_reference_type; }
 587   void set_reference_type(ReferenceType t) {
 588     assert(t == (u1)t, &quot;overflow&quot;);
 589     _reference_type = (u1)t;
 590   }
 591 
 592   // this class cp index
 593   u2 this_class_index() const             { return _this_class_index; }
 594   void set_this_class_index(u2 index)     { _this_class_index = index; }
 595 
 596   static ByteSize reference_type_offset() { return in_ByteSize(offset_of(InstanceKlass, _reference_type)); }
 597 
 598   // find local field, returns true if found
 599   bool find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 600   // find field in direct superinterfaces, returns the interface in which the field is defined
 601   Klass* find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 602   // find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 603   Klass* find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
 604   // find instance or static fields according to JVM spec 5.4.3.2, returns the klass in which the field is defined
 605   Klass* find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const;
 606 
 607   // find a non-static or static field given its offset within the class.
 608   bool contains_field_offset(int offset);
 609 
 610   bool find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 611   bool find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const;
 612 
 613  private:
 614   inline static int quick_search(const Array&lt;Method*&gt;* methods, const Symbol* name);
 615 
 616  public:
 617   static void disable_method_binary_search() {
 618     _disable_method_binary_search = true;
 619   }
 620 
 621   // find a local method (returns NULL if not found)
 622   Method* find_method(const Symbol* name, const Symbol* signature) const;
 623   static Method* find_method(const Array&lt;Method*&gt;* methods,
 624                              const Symbol* name,
 625                              const Symbol* signature);
 626 
 627   // find a local method, but skip static methods
 628   Method* find_instance_method(const Symbol* name, const Symbol* signature,
 629                                PrivateLookupMode private_mode) const;
 630   static Method* find_instance_method(const Array&lt;Method*&gt;* methods,
 631                                       const Symbol* name,
 632                                       const Symbol* signature,
 633                                       PrivateLookupMode private_mode);
 634 
 635   // find a local method (returns NULL if not found)
 636   Method* find_local_method(const Symbol* name,
 637                             const Symbol* signature,
 638                             OverpassLookupMode overpass_mode,
 639                             StaticLookupMode static_mode,
 640                             PrivateLookupMode private_mode) const;
 641 
 642   // find a local method from given methods array (returns NULL if not found)
 643   static Method* find_local_method(const Array&lt;Method*&gt;* methods,
 644                                    const Symbol* name,
 645                                    const Symbol* signature,
 646                                    OverpassLookupMode overpass_mode,
 647                                    StaticLookupMode static_mode,
 648                                    PrivateLookupMode private_mode);
 649 
 650   // find a local method index in methods or default_methods (returns -1 if not found)
 651   static int find_method_index(const Array&lt;Method*&gt;* methods,
 652                                const Symbol* name,
 653                                const Symbol* signature,
 654                                OverpassLookupMode overpass_mode,
 655                                StaticLookupMode static_mode,
 656                                PrivateLookupMode private_mode);
 657 
 658   // lookup operation (returns NULL if not found)
 659   Method* uncached_lookup_method(const Symbol* name,
 660                                  const Symbol* signature,
 661                                  OverpassLookupMode overpass_mode,
 662                                  PrivateLookupMode private_mode = find_private) const;
 663 
 664   // lookup a method in all the interfaces that this class implements
 665   // (returns NULL if not found)
 666   Method* lookup_method_in_all_interfaces(Symbol* name, Symbol* signature, DefaultsLookupMode defaults_mode) const;
 667 
 668   // lookup a method in local defaults then in all interfaces
 669   // (returns NULL if not found)
 670   Method* lookup_method_in_ordered_interfaces(Symbol* name, Symbol* signature) const;
 671 
 672   // Find method indices by name.  If a method with the specified name is
 673   // found the index to the first method is returned, and &#39;end&#39; is filled in
 674   // with the index of first non-name-matching method.  If no method is found
 675   // -1 is returned.
 676   int find_method_by_name(const Symbol* name, int* end) const;
 677   static int find_method_by_name(const Array&lt;Method*&gt;* methods,
 678                                  const Symbol* name, int* end);
 679 
 680   // constant pool
 681   ConstantPool* constants() const        { return _constants; }
 682   void set_constants(ConstantPool* c)    { _constants = c; }
 683 
 684   // protection domain
 685   oop protection_domain() const;
 686 
 687   // signers
 688   objArrayOop signers() const;
 689 
 690   // host class
 691   InstanceKlass* unsafe_anonymous_host() const {
 692     InstanceKlass** hk = adr_unsafe_anonymous_host();
 693     if (hk == NULL) {
 694       assert(!is_unsafe_anonymous(), &quot;Unsafe anonymous classes have host klasses&quot;);
 695       return NULL;
 696     } else {
 697       assert(*hk != NULL, &quot;host klass should always be set if the address is not null&quot;);
 698       assert(is_unsafe_anonymous(), &quot;Only unsafe anonymous classes have host klasses&quot;);
 699       return *hk;
 700     }
 701   }
 702   void set_unsafe_anonymous_host(const InstanceKlass* host) {
 703     assert(is_unsafe_anonymous(), &quot;not unsafe anonymous&quot;);
 704     const InstanceKlass** addr = (const InstanceKlass **)adr_unsafe_anonymous_host();
 705     assert(addr != NULL, &quot;no reversed space&quot;);
 706     if (addr != NULL) {
 707       *addr = host;
 708     }
 709   }
 710   bool is_unsafe_anonymous() const                {
 711     return (_misc_flags &amp; _misc_is_unsafe_anonymous) != 0;
 712   }
 713   void set_is_unsafe_anonymous(bool value)        {
 714     if (value) {
 715       _misc_flags |= _misc_is_unsafe_anonymous;
 716     } else {
 717       _misc_flags &amp;= ~_misc_is_unsafe_anonymous;
 718     }
 719   }
 720 
 721   bool is_contended() const                {
 722     return (_misc_flags &amp; _misc_is_contended) != 0;
 723   }
 724   void set_is_contended(bool value)        {
 725     if (value) {
 726       _misc_flags |= _misc_is_contended;
 727     } else {
 728       _misc_flags &amp;= ~_misc_is_contended;
 729     }
 730   }
 731 
 732   // source file name
 733   Symbol* source_file_name() const               {
 734     return (_source_file_name_index == 0) ?
 735       (Symbol*)NULL : _constants-&gt;symbol_at(_source_file_name_index);
 736   }
 737   u2 source_file_name_index() const              {
 738     return _source_file_name_index;
 739   }
 740   void set_source_file_name_index(u2 sourcefile_index) {
 741     _source_file_name_index = sourcefile_index;
 742   }
 743 
 744   // minor and major version numbers of class file
 745   u2 minor_version() const                 { return _minor_version; }
 746   void set_minor_version(u2 minor_version) { _minor_version = minor_version; }
 747   u2 major_version() const                 { return _major_version; }
 748   void set_major_version(u2 major_version) { _major_version = major_version; }
 749 
 750   // source debug extension
 751   const char* source_debug_extension() const { return _source_debug_extension; }
 752   void set_source_debug_extension(const char* array, int length);
 753 
 754   // symbol unloading support (refcount already added)
 755   Symbol* array_name()                     { return _array_name; }
 756   void set_array_name(Symbol* name)        { assert(_array_name == NULL  || name == NULL, &quot;name already created&quot;); _array_name = name; }
 757 
 758   // nonstatic oop-map blocks
 759   static int nonstatic_oop_map_size(unsigned int oop_map_count) {
 760     return oop_map_count * OopMapBlock::size_in_words();
 761   }
 762   unsigned int nonstatic_oop_map_count() const {
 763     return _nonstatic_oop_map_size / OopMapBlock::size_in_words();
 764   }
 765   int nonstatic_oop_map_size() const { return _nonstatic_oop_map_size; }
 766   void set_nonstatic_oop_map_size(int words) {
 767     _nonstatic_oop_map_size = words;
 768   }
 769 
 770   bool has_contended_annotations() const {
 771     return ((_misc_flags &amp; _misc_has_contended_annotations) != 0);
 772   }
 773   void set_has_contended_annotations(bool value)  {
 774     if (value) {
 775       _misc_flags |= _misc_has_contended_annotations;
 776     } else {
 777       _misc_flags &amp;= ~_misc_has_contended_annotations;
 778     }
 779   }
 780 
 781 #if INCLUDE_JVMTI
 782   // Redefinition locking.  Class can only be redefined by one thread at a time.
<a name="17" id="anc17"></a>
 783   bool is_being_redefined() const          {
<a name="18" id="anc18"></a><span class="line-modified"> 784     return ((_misc_flags &amp; _misc_is_being_redefined) != 0);</span>
 785   }
 786   void set_is_being_redefined(bool value)  {
 787     if (value) {
 788       _misc_flags |= _misc_is_being_redefined;
 789     } else {
 790       _misc_flags &amp;= ~_misc_is_being_redefined;
 791     }
 792   }
 793 
 794   // RedefineClasses() support for previous versions:
 795   void add_previous_version(InstanceKlass* ik, int emcp_method_count);
 796   void purge_previous_version_list();
 797 
 798   InstanceKlass* previous_versions() const { return _previous_versions; }
 799 #else
 800   InstanceKlass* previous_versions() const { return NULL; }
 801 #endif
 802 
 803   InstanceKlass* get_klass_version(int version) {
 804     for (InstanceKlass* ik = this; ik != NULL; ik = ik-&gt;previous_versions()) {
 805       if (ik-&gt;constants()-&gt;version() == version) {
 806         return ik;
 807       }
 808     }
 809     return NULL;
 810   }
 811 
 812   bool has_been_redefined() const {
 813     return (_misc_flags &amp; _misc_has_been_redefined) != 0;
 814   }
 815   void set_has_been_redefined() {
 816     _misc_flags |= _misc_has_been_redefined;
 817   }
 818 
 819   bool has_passed_fingerprint_check() const {
 820     return (_misc_flags &amp; _misc_has_passed_fingerprint_check) != 0;
 821   }
 822   void set_has_passed_fingerprint_check(bool b) {
 823     if (b) {
 824       _misc_flags |= _misc_has_passed_fingerprint_check;
 825     } else {
 826       _misc_flags &amp;= ~_misc_has_passed_fingerprint_check;
 827     }
 828   }
 829   bool supers_have_passed_fingerprint_checks();
 830 
 831   static bool should_store_fingerprint(bool is_hidden_or_anonymous);
 832   bool should_store_fingerprint() const { return should_store_fingerprint(is_hidden() || is_unsafe_anonymous()); }
 833   bool has_stored_fingerprint() const;
 834   uint64_t get_stored_fingerprint() const;
 835   void store_fingerprint(uint64_t fingerprint);
 836 
 837   bool is_scratch_class() const {
 838     return (_misc_flags &amp; _misc_is_scratch_class) != 0;
 839   }
 840 
 841   void set_is_scratch_class() {
 842     _misc_flags |= _misc_is_scratch_class;
 843   }
 844 
 845   bool has_resolved_methods() const {
 846     return (_misc_flags &amp; _misc_has_resolved_methods) != 0;
 847   }
 848 
 849   void set_has_resolved_methods() {
 850     _misc_flags |= _misc_has_resolved_methods;
 851   }
 852 private:
 853 
 854   void set_kind(unsigned kind) {
 855     assert(kind &lt;= _misc_kind_field_mask, &quot;Invalid InstanceKlass kind&quot;);
 856     unsigned fmask = _misc_kind_field_mask &lt;&lt; _misc_kind_field_pos;
 857     unsigned flags = _misc_flags &amp; ~fmask;
 858     _misc_flags = (flags | (kind &lt;&lt; _misc_kind_field_pos));
 859   }
 860 
 861   bool is_kind(unsigned desired) const {
 862     unsigned kind = (_misc_flags &gt;&gt; _misc_kind_field_pos) &amp; _misc_kind_field_mask;
 863     return kind == desired;
 864   }
 865 
 866 public:
 867 
 868   // Other is anything that is not one of the more specialized kinds of InstanceKlass.
 869   bool is_other_instance_klass() const        { return is_kind(_misc_kind_other); }
 870   bool is_reference_instance_klass() const    { return is_kind(_misc_kind_reference); }
 871   bool is_mirror_instance_klass() const       { return is_kind(_misc_kind_mirror); }
 872   bool is_class_loader_instance_klass() const { return is_kind(_misc_kind_class_loader); }
<a name="19" id="anc19"></a>
 873 
 874 #if INCLUDE_JVMTI
 875 
 876   void init_previous_versions() {
 877     _previous_versions = NULL;
 878   }
 879 
 880  private:
 881   static bool  _has_previous_versions;
 882  public:
 883   static void purge_previous_versions(InstanceKlass* ik) {
 884     if (ik-&gt;has_been_redefined()) {
 885       ik-&gt;purge_previous_version_list();
 886     }
 887   }
 888 
 889   static bool has_previous_versions_and_reset();
 890   static bool has_previous_versions() { return _has_previous_versions; }
 891 
 892   // JVMTI: Support for caching a class file before it is modified by an agent that can do retransformation
 893   void set_cached_class_file(JvmtiCachedClassFileData *data) {
 894     _cached_class_file = data;
 895   }
 896   JvmtiCachedClassFileData * get_cached_class_file();
 897   jint get_cached_class_file_len();
 898   unsigned char * get_cached_class_file_bytes();
 899 
 900   // JVMTI: Support for caching of field indices, types, and offsets
 901   void set_jvmti_cached_class_field_map(JvmtiCachedClassFieldMap* descriptor) {
 902     _jvmti_cached_class_field_map = descriptor;
 903   }
 904   JvmtiCachedClassFieldMap* jvmti_cached_class_field_map() const {
 905     return _jvmti_cached_class_field_map;
 906   }
 907 #else // INCLUDE_JVMTI
 908 
 909   static void purge_previous_versions(InstanceKlass* ik) { return; };
 910   static bool has_previous_versions_and_reset() { return false; }
 911 
 912   void set_cached_class_file(JvmtiCachedClassFileData *data) {
 913     assert(data == NULL, &quot;unexpected call with JVMTI disabled&quot;);
 914   }
 915   JvmtiCachedClassFileData * get_cached_class_file() { return (JvmtiCachedClassFileData *)NULL; }
 916 
 917 #endif // INCLUDE_JVMTI
 918 
 919   bool has_nonstatic_concrete_methods() const {
 920     return (_misc_flags &amp; _misc_has_nonstatic_concrete_methods) != 0;
 921   }
 922   void set_has_nonstatic_concrete_methods(bool b) {
 923     if (b) {
 924       _misc_flags |= _misc_has_nonstatic_concrete_methods;
 925     } else {
 926       _misc_flags &amp;= ~_misc_has_nonstatic_concrete_methods;
 927     }
 928   }
 929 
 930   bool declares_nonstatic_concrete_methods() const {
 931     return (_misc_flags &amp; _misc_declares_nonstatic_concrete_methods) != 0;
 932   }
 933   void set_declares_nonstatic_concrete_methods(bool b) {
 934     if (b) {
 935       _misc_flags |= _misc_declares_nonstatic_concrete_methods;
 936     } else {
 937       _misc_flags &amp;= ~_misc_declares_nonstatic_concrete_methods;
 938     }
 939   }
 940 
 941   // for adding methods, ConstMethod::UNSET_IDNUM means no more ids available
 942   inline u2 next_method_idnum();
 943   void set_initial_method_idnum(u2 value)             { _idnum_allocated_count = value; }
 944 
 945   // generics support
 946   Symbol* generic_signature() const                   {
 947     return (_generic_signature_index == 0) ?
 948       (Symbol*)NULL : _constants-&gt;symbol_at(_generic_signature_index);
 949   }
 950   u2 generic_signature_index() const                  {
 951     return _generic_signature_index;
 952   }
 953   void set_generic_signature_index(u2 sig_index)      {
 954     _generic_signature_index = sig_index;
 955   }
 956 
 957   u2 enclosing_method_data(int offset) const;
 958   u2 enclosing_method_class_index() const {
 959     return enclosing_method_data(enclosing_method_class_index_offset);
 960   }
 961   u2 enclosing_method_method_index() {
 962     return enclosing_method_data(enclosing_method_method_index_offset);
 963   }
 964   void set_enclosing_method_indices(u2 class_index,
 965                                     u2 method_index);
 966 
 967   // jmethodID support
 968   jmethodID get_jmethod_id(const methodHandle&amp; method_h);
 969   jmethodID get_jmethod_id_fetch_or_update(size_t idnum,
 970                      jmethodID new_id, jmethodID* new_jmeths,
 971                      jmethodID* to_dealloc_id_p,
 972                      jmethodID** to_dealloc_jmeths_p);
 973   static void get_jmethod_id_length_value(jmethodID* cache, size_t idnum,
 974                 size_t *length_p, jmethodID* id_p);
 975   void ensure_space_for_methodids(int start_offset = 0);
 976   jmethodID jmethod_id_or_null(Method* method);
 977 
 978   // annotations support
 979   Annotations* annotations() const          { return _annotations; }
 980   void set_annotations(Annotations* anno)   { _annotations = anno; }
 981 
 982   AnnotationArray* class_annotations() const {
 983     return (_annotations != NULL) ? _annotations-&gt;class_annotations() : NULL;
 984   }
 985   Array&lt;AnnotationArray*&gt;* fields_annotations() const {
 986     return (_annotations != NULL) ? _annotations-&gt;fields_annotations() : NULL;
 987   }
 988   AnnotationArray* class_type_annotations() const {
 989     return (_annotations != NULL) ? _annotations-&gt;class_type_annotations() : NULL;
 990   }
 991   Array&lt;AnnotationArray*&gt;* fields_type_annotations() const {
 992     return (_annotations != NULL) ? _annotations-&gt;fields_type_annotations() : NULL;
 993   }
 994   // allocation
 995   instanceOop allocate_instance(TRAPS);
 996 
 997   // additional member function to return a handle
 998   instanceHandle allocate_instance_handle(TRAPS);
 999 
1000   objArrayOop allocate_objArray(int n, int length, TRAPS);
1001   // Helper function
1002   static instanceOop register_finalizer(instanceOop i, TRAPS);
1003 
1004   // Check whether reflection/jni/jvm code is allowed to instantiate this class;
1005   // if not, throw either an Error or an Exception.
1006   virtual void check_valid_for_instantiation(bool throwError, TRAPS);
1007 
1008   // initialization
1009   void call_class_initializer(TRAPS);
1010   void set_initialization_state_and_notify(ClassState state, TRAPS);
1011 
1012   // OopMapCache support
1013   OopMapCache* oop_map_cache()               { return _oop_map_cache; }
1014   void set_oop_map_cache(OopMapCache *cache) { _oop_map_cache = cache; }
1015   void mask_for(const methodHandle&amp; method, int bci, InterpreterOopMap* entry);
1016 
1017   // JNI identifier support (for static fields - for jni performance)
1018   JNIid* jni_ids()                               { return _jni_ids; }
1019   void set_jni_ids(JNIid* ids)                   { _jni_ids = ids; }
1020   JNIid* jni_id_for(int offset);
1021 
1022   // maintenance of deoptimization dependencies
1023   inline DependencyContext dependencies();
1024   int  mark_dependent_nmethods(KlassDepChange&amp; changes);
1025   void add_dependent_nmethod(nmethod* nm);
1026   void remove_dependent_nmethod(nmethod* nm);
1027   void clean_dependency_context();
1028 
1029   // On-stack replacement support
1030   nmethod* osr_nmethods_head() const         { return _osr_nmethods_head; };
1031   void set_osr_nmethods_head(nmethod* h)     { _osr_nmethods_head = h; };
1032   void add_osr_nmethod(nmethod* n);
1033   bool remove_osr_nmethod(nmethod* n);
1034   int mark_osr_nmethods(const Method* m);
1035   nmethod* lookup_osr_nmethod(const Method* m, int bci, int level, bool match_level) const;
1036 
1037 #if INCLUDE_JVMTI
1038   // Breakpoint support (see methods on Method* for details)
1039   BreakpointInfo* breakpoints() const       { return _breakpoints; };
1040   void set_breakpoints(BreakpointInfo* bps) { _breakpoints = bps; };
1041 #endif
1042 
1043   // support for stub routines
1044   static ByteSize init_state_offset()  { return in_ByteSize(offset_of(InstanceKlass, _init_state)); }
1045   JFR_ONLY(DEFINE_KLASS_TRACE_ID_OFFSET;)
1046   static ByteSize init_thread_offset() { return in_ByteSize(offset_of(InstanceKlass, _init_thread)); }
1047 
<a name="20" id="anc20"></a>


1048   // subclass/subinterface checks
1049   bool implements_interface(Klass* k) const;
1050   bool is_same_or_direct_interface(Klass* k) const;
1051 
1052 #ifdef ASSERT
1053   // check whether this class or one of its superclasses was redefined
1054   bool has_redefined_this_or_super() const;
1055 #endif
1056 
1057   // Access to the implementor of an interface.
1058   Klass* implementor() const;
1059   void set_implementor(Klass* k);
1060   int  nof_implementors() const;
1061   void add_implementor(Klass* k);  // k is a new class that implements this interface
1062   void init_implementor();           // initialize
1063 
1064   // link this class into the implementors list of every interface it implements
1065   void process_interfaces(Thread *thread);
1066 
1067   // virtual operations from Klass
1068   GrowableArray&lt;Klass*&gt;* compute_secondary_supers(int num_extra_slots,
1069                                                   Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1070   bool can_be_primary_super_slow() const;
1071   int oop_size(oop obj)  const             { return size_helper(); }
1072   // slow because it&#39;s a virtual call and used for verifying the layout_helper.
1073   // Using the layout_helper bits, we can call is_instance_klass without a virtual call.
1074   DEBUG_ONLY(bool is_instance_klass_slow() const      { return true; })
1075 
1076   // Iterators
1077   void do_local_static_fields(FieldClosure* cl);
1078   void do_nonstatic_fields(FieldClosure* cl); // including inherited fields
1079   void do_local_static_fields(void f(fieldDescriptor*, Handle, TRAPS), Handle, TRAPS);
1080 
1081   void methods_do(void f(Method* method));
<a name="21" id="anc21"></a><span class="line-modified">1082   void array_klasses_do(void f(Klass* k));</span>
<span class="line-removed">1083   void array_klasses_do(void f(Klass* k, TRAPS), TRAPS);</span>
1084 
1085   static InstanceKlass* cast(Klass* k) {
1086     return const_cast&lt;InstanceKlass*&gt;(cast(const_cast&lt;const Klass*&gt;(k)));
1087   }
1088 
1089   static const InstanceKlass* cast(const Klass* k) {
1090     assert(k != NULL, &quot;k should not be null&quot;);
1091     assert(k-&gt;is_instance_klass(), &quot;cast to InstanceKlass&quot;);
1092     return static_cast&lt;const InstanceKlass*&gt;(k);
1093   }
1094 
1095   virtual InstanceKlass* java_super() const {
1096     return (super() == NULL) ? NULL : cast(super());
1097   }
1098 
1099   // Sizing (in words)
1100   static int header_size()            { return sizeof(InstanceKlass)/wordSize; }
1101 
1102   static int size(int vtable_length, int itable_length,
1103                   int nonstatic_oop_map_size,
<a name="22" id="anc22"></a><span class="line-modified">1104                   bool is_interface, bool is_unsafe_anonymous, bool has_stored_fingerprint) {</span>

1105     return align_metadata_size(header_size() +
1106            vtable_length +
1107            itable_length +
1108            nonstatic_oop_map_size +
1109            (is_interface ? (int)sizeof(Klass*)/wordSize : 0) +
1110            (is_unsafe_anonymous ? (int)sizeof(Klass*)/wordSize : 0) +
<a name="23" id="anc23"></a><span class="line-modified">1111            (has_stored_fingerprint ? (int)sizeof(uint64_t*)/wordSize : 0));</span>


1112   }
1113   int size() const                    { return size(vtable_length(),
1114                                                itable_length(),
1115                                                nonstatic_oop_map_size(),
1116                                                is_interface(),
1117                                                is_unsafe_anonymous(),
<a name="24" id="anc24"></a><span class="line-modified">1118                                                has_stored_fingerprint());</span>


1119   }
1120 
1121   intptr_t* start_of_itable()   const { return (intptr_t*)start_of_vtable() + vtable_length(); }
1122   intptr_t* end_of_itable()     const { return start_of_itable() + itable_length(); }
1123 
1124   int  itable_offset_in_words() const { return start_of_itable() - (intptr_t*)this; }
1125 
1126   oop static_field_base_raw() { return java_mirror(); }
1127 
<a name="25" id="anc25"></a>

1128   OopMapBlock* start_of_nonstatic_oop_maps() const {
1129     return (OopMapBlock*)(start_of_itable() + itable_length());
1130   }
1131 
1132   Klass** end_of_nonstatic_oop_maps() const {
1133     return (Klass**)(start_of_nonstatic_oop_maps() +
1134                      nonstatic_oop_map_count());
1135   }
1136 
1137   Klass* volatile* adr_implementor() const {
1138     if (is_interface()) {
1139       return (Klass* volatile*)end_of_nonstatic_oop_maps();
1140     } else {
1141       return NULL;
1142     }
1143   };
1144 
1145   InstanceKlass** adr_unsafe_anonymous_host() const {
1146     if (is_unsafe_anonymous()) {
1147       InstanceKlass** adr_impl = (InstanceKlass**)adr_implementor();
1148       if (adr_impl != NULL) {
1149         return adr_impl + 1;
1150       } else {
1151         return (InstanceKlass **)end_of_nonstatic_oop_maps();
1152       }
1153     } else {
1154       return NULL;
1155     }
1156   }
1157 
1158   address adr_fingerprint() const {
1159     if (has_stored_fingerprint()) {
1160       InstanceKlass** adr_host = adr_unsafe_anonymous_host();
1161       if (adr_host != NULL) {
1162         return (address)(adr_host + 1);
1163       }
1164 
1165       Klass* volatile* adr_impl = adr_implementor();
1166       if (adr_impl != NULL) {
1167         return (address)(adr_impl + 1);
1168       }
1169 
1170       return (address)end_of_nonstatic_oop_maps();
1171     } else {
1172       return NULL;
1173     }
1174   }
1175 
<a name="26" id="anc26"></a>












































1176   // Use this to return the size of an instance in heap words:
<a name="27" id="anc27"></a><span class="line-modified">1177   int size_helper() const {</span>
1178     return layout_helper_to_size_helper(layout_helper());
1179   }
1180 
1181   // This bit is initialized in classFileParser.cpp.
1182   // It is false under any of the following conditions:
1183   //  - the class is abstract (including any interface)
1184   //  - the class has a finalizer (if !RegisterFinalizersAtInit)
1185   //  - the class size is larger than FastAllocateSizeLimit
1186   //  - the class is java/lang/Class, which cannot be allocated directly
1187   bool can_be_fastpath_allocated() const {
1188     return !layout_helper_needs_slow_path(layout_helper());
1189   }
1190 
1191   // Java itable
1192   klassItable itable() const;        // return klassItable wrapper
1193   Method* method_at_itable(Klass* holder, int index, TRAPS);
1194 
1195 #if INCLUDE_JVMTI
1196   void adjust_default_methods(bool* trace_name_printed);
1197 #endif // INCLUDE_JVMTI
1198 
1199   void clean_weak_instanceklass_links();
1200  private:
1201   void clean_implementors_list();
1202   void clean_method_data();
1203 
1204  public:
1205   // Explicit metaspace deallocation of fields
1206   // For RedefineClasses and class file parsing errors, we need to deallocate
1207   // instanceKlasses and the metadata they point to.
1208   void deallocate_contents(ClassLoaderData* loader_data);
1209   static void deallocate_methods(ClassLoaderData* loader_data,
1210                                  Array&lt;Method*&gt;* methods);
1211   void static deallocate_interfaces(ClassLoaderData* loader_data,
1212                                     const Klass* super_klass,
1213                                     Array&lt;InstanceKlass*&gt;* local_interfaces,
1214                                     Array&lt;InstanceKlass*&gt;* transitive_interfaces);
1215   void static deallocate_record_components(ClassLoaderData* loader_data,
1216                                            Array&lt;RecordComponent*&gt;* record_component);
1217 
1218   // The constant pool is on stack if any of the methods are executing or
1219   // referenced by handles.
1220   bool on_stack() const { return _constants-&gt;on_stack(); }
1221 
1222   // callbacks for actions during class unloading
1223   static void unload_class(InstanceKlass* ik);
1224   static void release_C_heap_structures(InstanceKlass* ik);
1225 
1226   // Naming
1227   const char* signature_name() const;
1228 
1229   // Oop fields (and metadata) iterators
1230   //
1231   // The InstanceKlass iterators also visits the Object&#39;s klass.
1232 
1233   // Forward iteration
1234  public:
1235   // Iterate over all oop fields in the oop maps.
1236   template &lt;typename T, class OopClosureType&gt;
1237   inline void oop_oop_iterate_oop_maps(oop obj, OopClosureType* closure);
1238 
1239   // Iterate over all oop fields and metadata.
1240   template &lt;typename T, class OopClosureType&gt;
1241   inline void oop_oop_iterate(oop obj, OopClosureType* closure);
1242 
1243   // Iterate over all oop fields in one oop map.
1244   template &lt;typename T, class OopClosureType&gt;
1245   inline void oop_oop_iterate_oop_map(OopMapBlock* map, oop obj, OopClosureType* closure);
1246 
1247 
1248   // Reverse iteration
1249   // Iterate over all oop fields and metadata.
1250   template &lt;typename T, class OopClosureType&gt;
1251   inline void oop_oop_iterate_reverse(oop obj, OopClosureType* closure);
1252 
1253  private:
1254   // Iterate over all oop fields in the oop maps.
1255   template &lt;typename T, class OopClosureType&gt;
1256   inline void oop_oop_iterate_oop_maps_reverse(oop obj, OopClosureType* closure);
1257 
1258   // Iterate over all oop fields in one oop map.
1259   template &lt;typename T, class OopClosureType&gt;
1260   inline void oop_oop_iterate_oop_map_reverse(OopMapBlock* map, oop obj, OopClosureType* closure);
1261 
1262 
1263   // Bounded range iteration
1264  public:
1265   // Iterate over all oop fields in the oop maps.
1266   template &lt;typename T, class OopClosureType&gt;
1267   inline void oop_oop_iterate_oop_maps_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1268 
1269   // Iterate over all oop fields and metadata.
1270   template &lt;typename T, class OopClosureType&gt;
1271   inline void oop_oop_iterate_bounded(oop obj, OopClosureType* closure, MemRegion mr);
1272 
1273  private:
1274   // Iterate over all oop fields in one oop map.
1275   template &lt;typename T, class OopClosureType&gt;
1276   inline void oop_oop_iterate_oop_map_bounded(OopMapBlock* map, oop obj, OopClosureType* closure, MemRegion mr);
1277 
1278 
1279  public:
1280   u2 idnum_allocated_count() const      { return _idnum_allocated_count; }
1281 
1282 private:
1283   // initialization state
1284   void set_init_state(ClassState state);
1285   void set_rewritten()                  { _misc_flags |= _misc_rewritten; }
1286   void set_init_thread(Thread *thread)  { _init_thread = thread; }
1287 
1288   // The RedefineClasses() API can cause new method idnums to be needed
1289   // which will cause the caches to grow. Safety requires different
1290   // cache management logic if the caches can grow instead of just
1291   // going from NULL to non-NULL.
1292   bool idnum_can_increment() const      { return has_been_redefined(); }
1293   inline jmethodID* methods_jmethod_ids_acquire() const;
1294   inline void release_set_methods_jmethod_ids(jmethodID* jmeths);
1295 
1296   // Lock during initialization
1297 public:
1298   // Lock for (1) initialization; (2) access to the ConstantPool of this class.
1299   // Must be one per class and it has to be a VM internal object so java code
1300   // cannot lock it (like the mirror).
1301   // It has to be an object not a Mutex because it&#39;s held through java calls.
1302   oop init_lock() const;
1303 private:
1304   void fence_and_clear_init_lock();
1305 
1306   bool link_class_impl                           (TRAPS);
1307   bool verify_code                               (TRAPS);
1308   void initialize_impl                           (TRAPS);
1309   void initialize_super_interfaces               (TRAPS);
1310   void eager_initialize_impl                     ();
1311   /* jni_id_for_impl for jfieldID only */
1312   JNIid* jni_id_for_impl                         (int offset);
<a name="28" id="anc28"></a><span class="line-modified">1313 </span>
1314   // Returns the array class for the n&#39;th dimension
<a name="29" id="anc29"></a><span class="line-modified">1315   Klass* array_klass_impl(bool or_null, int n, TRAPS);</span>
1316 
1317   // Returns the array class with this class as element type
<a name="30" id="anc30"></a><span class="line-modified">1318   Klass* array_klass_impl(bool or_null, TRAPS);</span>


1319 
1320   // find a local method (returns NULL if not found)
1321   Method* find_method_impl(const Symbol* name,
1322                            const Symbol* signature,
1323                            OverpassLookupMode overpass_mode,
1324                            StaticLookupMode static_mode,
1325                            PrivateLookupMode private_mode) const;
1326 
1327   static Method* find_method_impl(const Array&lt;Method*&gt;* methods,
1328                                   const Symbol* name,
1329                                   const Symbol* signature,
1330                                   OverpassLookupMode overpass_mode,
1331                                   StaticLookupMode static_mode,
1332                                   PrivateLookupMode private_mode);
1333 
1334   // Free CHeap allocated fields.
1335   void release_C_heap_structures();
1336 
1337 #if INCLUDE_JVMTI
1338   // RedefineClasses support
1339   void link_previous_versions(InstanceKlass* pv) { _previous_versions = pv; }
1340   void mark_newly_obsolete_methods(Array&lt;Method*&gt;* old_methods, int emcp_method_count);
1341 #endif
1342 public:
1343   // CDS support - remove and restore oops from metadata. Oops are not shared.
1344   virtual void remove_unshareable_info();
1345   virtual void remove_java_mirror();
<a name="31" id="anc31"></a><span class="line-modified">1346   void restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, PackageEntry* pkg_entry, TRAPS);</span>
1347 
1348   // jvm support
1349   jint compute_modifier_flags(TRAPS) const;
1350 
1351 public:
1352   // JVMTI support
1353   jint jvmti_class_status() const;
1354 
1355   virtual void metaspace_pointers_do(MetaspaceClosure* iter);
1356 
1357  public:
1358   // Printing
1359 #ifndef PRODUCT
1360   void print_on(outputStream* st) const;
1361 #endif
1362   void print_value_on(outputStream* st) const;
1363 
1364   void oop_print_value_on(oop obj, outputStream* st);
1365 
1366 #ifndef PRODUCT
1367   void oop_print_on      (oop obj, outputStream* st);
1368 
1369   void print_dependent_nmethods(bool verbose = false);
1370   bool is_dependent_nmethod(nmethod* nm);
1371   bool verify_itable_index(int index);
1372 #endif
1373 
1374   const char* internal_name() const;
1375 
1376   // Verification
1377   void verify_on(outputStream* st);
1378 
1379   void oop_verify_on(oop obj, outputStream* st);
1380 
1381   // Logging
1382   void print_class_load_logging(ClassLoaderData* loader_data,
1383                                 const char* module_name,
1384                                 const ClassFileStream* cfs) const;
1385 };
1386 
1387 // for adding methods
1388 // UNSET_IDNUM return means no more ids available
1389 inline u2 InstanceKlass::next_method_idnum() {
1390   if (_idnum_allocated_count == ConstMethod::MAX_IDNUM) {
1391     return ConstMethod::UNSET_IDNUM; // no more ids available
1392   } else {
1393     return _idnum_allocated_count++;
1394   }
1395 }
1396 
1397 
1398 /* JNIid class for jfieldIDs only */
1399 class JNIid: public CHeapObj&lt;mtClass&gt; {
1400   friend class VMStructs;
1401  private:
1402   Klass*             _holder;
1403   JNIid*             _next;
1404   int                _offset;
1405 #ifdef ASSERT
1406   bool               _is_static_field_id;
1407 #endif
1408 
1409  public:
1410   // Accessors
1411   Klass* holder() const           { return _holder; }
1412   int offset() const              { return _offset; }
1413   JNIid* next()                   { return _next; }
1414   // Constructor
1415   JNIid(Klass* holder, int offset, JNIid* next);
1416   // Identifier lookup
1417   JNIid* find(int offset);
1418 
1419   bool find_local_field(fieldDescriptor* fd) {
1420     return InstanceKlass::cast(holder())-&gt;find_local_field_from_offset(offset(), true, fd);
1421   }
1422 
1423   static void deallocate(JNIid* id);
1424   // Debugging
1425 #ifdef ASSERT
1426   bool is_static_field_id() const { return _is_static_field_id; }
1427   void set_is_static_field_id()   { _is_static_field_id = true; }
1428 #endif
1429   void verify(Klass* holder);
1430 };
1431 
1432 // An iterator that&#39;s used to access the inner classes indices in the
1433 // InstanceKlass::_inner_classes array.
1434 class InnerClassesIterator : public StackObj {
1435  private:
1436   Array&lt;jushort&gt;* _inner_classes;
1437   int _length;
1438   int _idx;
1439  public:
1440 
1441   InnerClassesIterator(const InstanceKlass* k) {
1442     _inner_classes = k-&gt;inner_classes();
1443     if (k-&gt;inner_classes() != NULL) {
1444       _length = _inner_classes-&gt;length();
1445       // The inner class array&#39;s length should be the multiple of
1446       // inner_class_next_offset if it only contains the InnerClasses
1447       // attribute data, or it should be
1448       // n*inner_class_next_offset+enclosing_method_attribute_size
1449       // if it also contains the EnclosingMethod data.
1450       assert((_length % InstanceKlass::inner_class_next_offset == 0 ||
1451               _length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size),
1452              &quot;just checking&quot;);
1453       // Remove the enclosing_method portion if exists.
1454       if (_length % InstanceKlass::inner_class_next_offset == InstanceKlass::enclosing_method_attribute_size) {
1455         _length -= InstanceKlass::enclosing_method_attribute_size;
1456       }
1457     } else {
1458       _length = 0;
1459     }
1460     _idx = 0;
1461   }
1462 
1463   int length() const {
1464     return _length;
1465   }
1466 
1467   void next() {
1468     _idx += InstanceKlass::inner_class_next_offset;
1469   }
1470 
1471   bool done() const {
1472     return (_idx &gt;= _length);
1473   }
1474 
1475   u2 inner_class_info_index() const {
1476     return _inner_classes-&gt;at(
1477                _idx + InstanceKlass::inner_class_inner_class_info_offset);
1478   }
1479 
1480   void set_inner_class_info_index(u2 index) {
1481     _inner_classes-&gt;at_put(
1482                _idx + InstanceKlass::inner_class_inner_class_info_offset, index);
1483   }
1484 
1485   u2 outer_class_info_index() const {
1486     return _inner_classes-&gt;at(
1487                _idx + InstanceKlass::inner_class_outer_class_info_offset);
1488   }
1489 
1490   void set_outer_class_info_index(u2 index) {
1491     _inner_classes-&gt;at_put(
1492                _idx + InstanceKlass::inner_class_outer_class_info_offset, index);
1493   }
1494 
1495   u2 inner_name_index() const {
1496     return _inner_classes-&gt;at(
1497                _idx + InstanceKlass::inner_class_inner_name_offset);
1498   }
1499 
1500   void set_inner_name_index(u2 index) {
1501     _inner_classes-&gt;at_put(
1502                _idx + InstanceKlass::inner_class_inner_name_offset, index);
1503   }
1504 
1505   u2 inner_access_flags() const {
1506     return _inner_classes-&gt;at(
1507                _idx + InstanceKlass::inner_class_access_flags_offset);
1508   }
1509 };
1510 
1511 #endif // SHARE_OOPS_INSTANCEKLASS_HPP
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>
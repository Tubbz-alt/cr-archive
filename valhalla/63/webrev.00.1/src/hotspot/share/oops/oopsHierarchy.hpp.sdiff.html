<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/oopsHierarchy.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="method.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/c2compiler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/oopsHierarchy.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 
 32 // OBJECT hierarchy
 33 // This hierarchy is a representation hierarchy, i.e. if A is a superclass
 34 // of B, A&#39;s representation is a prefix of B&#39;s representation.
 35 
 36 typedef juint narrowOop; // Offset instead of address for an oop within a java object
 37 
 38 // If compressed klass pointers then use narrowKlass.
 39 typedef juint  narrowKlass;
 40 
 41 typedef void* OopOrNarrowOopStar;
 42 
 43 #ifndef CHECK_UNHANDLED_OOPS
 44 
 45 typedef class oopDesc*                    oop;
 46 typedef class   instanceOopDesc*            instanceOop;
 47 typedef class   arrayOopDesc*               arrayOop;
 48 typedef class     objArrayOopDesc*            objArrayOop;
 49 typedef class     typeArrayOopDesc*           typeArrayOop;

 50 
 51 #else
 52 
 53 // When CHECK_UNHANDLED_OOPS is defined, an &quot;oop&quot; is a class with a
 54 // carefully chosen set of constructors and conversion operators to go
 55 // to and from the underlying oopDesc pointer type.
 56 //
 57 // Because oop and its subclasses &lt;type&gt;Oop are class types, arbitrary
 58 // conversions are not accepted by the compiler.  Applying a cast to
 59 // an oop will cause the best matched conversion operator to be
 60 // invoked returning the underlying oopDesc* type if appropriate.
 61 // No copy constructors, explicit user conversions or operators of
 62 // numerical type should be defined within the oop class. Most C++
 63 // compilers will issue a compile time error concerning the overloading
 64 // ambiguity between operators of numerical and pointer types. If
 65 // a conversion to or from an oop to a numerical type is needed,
 66 // use the inline template methods, cast_*_oop, defined below.
 67 //
 68 // Converting NULL to oop to Handle implicit is no longer accepted by the
 69 // compiler because there are too many steps in the conversion.  Use Handle()
</pre>
<hr />
<pre>
144        }                                                                   \
145        volatile type##Oop&amp; operator=(const volatile type##Oop&amp; o) volatile {\
146             (void)const_cast&lt;oop&amp;&gt;(oop::operator=(o));                     \
147             return *this;                                                  \
148        }                                                                   \
149    };                                                                      \
150                                                                            \
151    template&lt;&gt;                                                              \
152    struct PrimitiveConversions::Translate&lt;type##Oop&gt; : public TrueType {   \
153      typedef type##Oop Value;                                              \
154      typedef type##OopDesc* Decayed;                                       \
155                                                                            \
156      static Decayed decay(Value x) { return (type##OopDesc*)x.obj(); }     \
157      static Value recover(Decayed x) { return type##Oop(x); }              \
158    };
159 
160 DEF_OOP(instance);
161 DEF_OOP(array);
162 DEF_OOP(objArray);
163 DEF_OOP(typeArray);

164 
165 #endif // CHECK_UNHANDLED_OOPS
166 
167 // For CHECK_UNHANDLED_OOPS, it is ambiguous C++ behavior to have the oop
168 // structure contain explicit user defined conversions of both numerical
169 // and pointer type. Define inline methods to provide the numerical conversions.
170 template &lt;class T&gt; inline oop cast_to_oop(T value) {
171   return (oop)(CHECK_UNHANDLED_OOPS_ONLY((void *))(value));
172 }
173 template &lt;class T&gt; inline T cast_from_oop(oop o) {
174   return (T)(CHECK_UNHANDLED_OOPS_ONLY((oopDesc*))o);
175 }
176 
177 // The metadata hierarchy is separate from the oop hierarchy
178 
179 //      class MetaspaceObj
180 class   ConstMethod;
181 class   ConstantPoolCache;
182 class   MethodData;
183 //      class Metadata
184 class   Method;
185 class   ConstantPool;
186 //      class CHeapObj
187 class   CompiledICHolder;
188 
189 
190 // The klass hierarchy is separate from the oop hierarchy.
191 
192 class Klass;
193 class   InstanceKlass;
194 class     InstanceMirrorKlass;
195 class     InstanceClassLoaderKlass;
196 class     InstanceRefKlass;

197 class   ArrayKlass;
198 class     ObjArrayKlass;
199 class     TypeArrayKlass;

200 
201 #endif // SHARE_OOPS_OOPSHIERARCHY_HPP
</pre>
</td>
<td>
<hr />
<pre>
 30 #include &quot;utilities/globalDefinitions.hpp&quot;
 31 
 32 // OBJECT hierarchy
 33 // This hierarchy is a representation hierarchy, i.e. if A is a superclass
 34 // of B, A&#39;s representation is a prefix of B&#39;s representation.
 35 
 36 typedef juint narrowOop; // Offset instead of address for an oop within a java object
 37 
 38 // If compressed klass pointers then use narrowKlass.
 39 typedef juint  narrowKlass;
 40 
 41 typedef void* OopOrNarrowOopStar;
 42 
 43 #ifndef CHECK_UNHANDLED_OOPS
 44 
 45 typedef class oopDesc*                    oop;
 46 typedef class   instanceOopDesc*            instanceOop;
 47 typedef class   arrayOopDesc*               arrayOop;
 48 typedef class     objArrayOopDesc*            objArrayOop;
 49 typedef class     typeArrayOopDesc*           typeArrayOop;
<span class="line-added"> 50 typedef class     valueArrayOopDesc*          valueArrayOop;</span>
 51 
 52 #else
 53 
 54 // When CHECK_UNHANDLED_OOPS is defined, an &quot;oop&quot; is a class with a
 55 // carefully chosen set of constructors and conversion operators to go
 56 // to and from the underlying oopDesc pointer type.
 57 //
 58 // Because oop and its subclasses &lt;type&gt;Oop are class types, arbitrary
 59 // conversions are not accepted by the compiler.  Applying a cast to
 60 // an oop will cause the best matched conversion operator to be
 61 // invoked returning the underlying oopDesc* type if appropriate.
 62 // No copy constructors, explicit user conversions or operators of
 63 // numerical type should be defined within the oop class. Most C++
 64 // compilers will issue a compile time error concerning the overloading
 65 // ambiguity between operators of numerical and pointer types. If
 66 // a conversion to or from an oop to a numerical type is needed,
 67 // use the inline template methods, cast_*_oop, defined below.
 68 //
 69 // Converting NULL to oop to Handle implicit is no longer accepted by the
 70 // compiler because there are too many steps in the conversion.  Use Handle()
</pre>
<hr />
<pre>
145        }                                                                   \
146        volatile type##Oop&amp; operator=(const volatile type##Oop&amp; o) volatile {\
147             (void)const_cast&lt;oop&amp;&gt;(oop::operator=(o));                     \
148             return *this;                                                  \
149        }                                                                   \
150    };                                                                      \
151                                                                            \
152    template&lt;&gt;                                                              \
153    struct PrimitiveConversions::Translate&lt;type##Oop&gt; : public TrueType {   \
154      typedef type##Oop Value;                                              \
155      typedef type##OopDesc* Decayed;                                       \
156                                                                            \
157      static Decayed decay(Value x) { return (type##OopDesc*)x.obj(); }     \
158      static Value recover(Decayed x) { return type##Oop(x); }              \
159    };
160 
161 DEF_OOP(instance);
162 DEF_OOP(array);
163 DEF_OOP(objArray);
164 DEF_OOP(typeArray);
<span class="line-added">165 DEF_OOP(valueArray);</span>
166 
167 #endif // CHECK_UNHANDLED_OOPS
168 
169 // For CHECK_UNHANDLED_OOPS, it is ambiguous C++ behavior to have the oop
170 // structure contain explicit user defined conversions of both numerical
171 // and pointer type. Define inline methods to provide the numerical conversions.
172 template &lt;class T&gt; inline oop cast_to_oop(T value) {
173   return (oop)(CHECK_UNHANDLED_OOPS_ONLY((void *))(value));
174 }
175 template &lt;class T&gt; inline T cast_from_oop(oop o) {
176   return (T)(CHECK_UNHANDLED_OOPS_ONLY((oopDesc*))o);
177 }
178 
179 // The metadata hierarchy is separate from the oop hierarchy
180 
181 //      class MetaspaceObj
182 class   ConstMethod;
183 class   ConstantPoolCache;
184 class   MethodData;
185 //      class Metadata
186 class   Method;
187 class   ConstantPool;
188 //      class CHeapObj
189 class   CompiledICHolder;
190 
191 
192 // The klass hierarchy is separate from the oop hierarchy.
193 
194 class Klass;
195 class   InstanceKlass;
196 class     InstanceMirrorKlass;
197 class     InstanceClassLoaderKlass;
198 class     InstanceRefKlass;
<span class="line-added">199 class     ValueKlass;</span>
200 class   ArrayKlass;
201 class     ObjArrayKlass;
202 class     TypeArrayKlass;
<span class="line-added">203 class     ValueArrayKlass;</span>
204 
205 #endif // SHARE_OOPS_OOPSHIERARCHY_HPP
</pre>
</td>
</tr>
</table>
<center><a href="method.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/c2compiler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
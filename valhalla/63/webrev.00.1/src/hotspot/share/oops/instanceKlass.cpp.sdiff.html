<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cpCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.inline.hpp&quot;
  51 #include &quot;memory/metadataFactory.hpp&quot;
  52 #include &quot;memory/metaspaceClosure.hpp&quot;
  53 #include &quot;memory/metaspaceShared.hpp&quot;
  54 #include &quot;memory/oopFactory.hpp&quot;
  55 #include &quot;memory/resourceArea.hpp&quot;
  56 #include &quot;memory/universe.hpp&quot;
  57 #include &quot;oops/fieldStreams.inline.hpp&quot;
  58 #include &quot;oops/constantPool.hpp&quot;
  59 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  60 #include &quot;oops/instanceKlass.inline.hpp&quot;
  61 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  62 #include &quot;oops/instanceOop.hpp&quot;
  63 #include &quot;oops/klass.inline.hpp&quot;
  64 #include &quot;oops/method.hpp&quot;
  65 #include &quot;oops/oop.inline.hpp&quot;
  66 #include &quot;oops/recordComponent.hpp&quot;
  67 #include &quot;oops/symbol.hpp&quot;

  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  70 #include &quot;prims/jvmtiThreadState.hpp&quot;
  71 #include &quot;prims/methodComparator.hpp&quot;
  72 #include &quot;runtime/atomic.hpp&quot;
  73 #include &quot;runtime/biasedLocking.hpp&quot;
  74 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  75 #include &quot;runtime/handles.inline.hpp&quot;
  76 #include &quot;runtime/javaCalls.hpp&quot;
  77 #include &quot;runtime/mutexLocker.hpp&quot;
  78 #include &quot;runtime/orderAccess.hpp&quot;
  79 #include &quot;runtime/thread.inline.hpp&quot;
  80 #include &quot;services/classLoadingService.hpp&quot;
  81 #include &quot;services/threadService.hpp&quot;
  82 #include &quot;utilities/dtrace.hpp&quot;
  83 #include &quot;utilities/events.hpp&quot;
  84 #include &quot;utilities/macros.hpp&quot;
  85 #include &quot;utilities/stringUtils.hpp&quot;
  86 #ifdef COMPILER1
  87 #include &quot;c1/c1_Compiler.hpp&quot;
</pre>
<hr />
<pre>
 405                               k-&gt;external_name());
 406   return access;
 407 }
 408 
 409 const char* InstanceKlass::nest_host_error(TRAPS) {
 410   if (_nest_host_index == 0) {
 411     return NULL;
 412   } else {
 413     constantPoolHandle cph(THREAD, constants());
 414     return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);
 415   }
 416 }
 417 
 418 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 419   bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();
 420   const int size = InstanceKlass::size(parser.vtable_size(),
 421                                        parser.itable_size(),
 422                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 423                                        parser.is_interface(),
 424                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 425                                        should_store_fingerprint(is_hidden_or_anonymous));</span>


 426 
 427   const Symbol* const class_name = parser.class_name();
 428   assert(class_name != NULL, &quot;invariant&quot;);
 429   ClassLoaderData* loader_data = parser.loader_data();
 430   assert(loader_data != NULL, &quot;invariant&quot;);
 431 
 432   InstanceKlass* ik;
 433 
 434   // Allocation
 435   if (REF_NONE == parser.reference_type()) {
 436     if (class_name == vmSymbols::java_lang_Class()) {
 437       // mirror
 438       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="line-modified"> 439     }</span>
<span class="line-removed"> 440     else if (is_class_loader(class_name, parser)) {</span>
 441       // class loader
 442       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);



 443     } else {
 444       // normal
 445       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other);
 446     }
 447   } else {
 448     // reference
 449     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 450   }
 451 
 452   // Check for pending exception before adding to the loader data and incrementing
 453   // class count.  Can get OOM here.
 454   if (HAS_PENDING_EXCEPTION) {
 455     return NULL;
 456   }
 457 







 458   return ik;
 459 }
 460 























 461 
 462 // copy method ordering from resource area to Metaspace
 463 void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
 464   if (m != NULL) {
 465     // allocate a new array and copy contents (memcpy?)
 466     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 467     for (int i = 0; i &lt; m-&gt;length(); i++) {
 468       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 469     }
 470   } else {
 471     _method_ordering = Universe::the_empty_int_array();
 472   }
 473 }
 474 
 475 // create a new array of vtable_indices for default methods
 476 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 477   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 478   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 479   set_default_vtable_indices(vtable_indices);
 480   return vtable_indices;
 481 }
 482 
 483 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 484   Klass(id),
 485   _nest_members(NULL),
 486   _nest_host_index(0),
 487   _nest_host(NULL),
 488   _record_components(NULL),
 489   _static_field_size(parser.static_field_size()),
 490   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 491   _itable_len(parser.itable_size()),
 492   _init_thread(NULL),
 493   _init_state(allocated),
<span class="line-modified"> 494   _reference_type(parser.reference_type())</span>


 495 {
 496   set_vtable_length(parser.vtable_size());
 497   set_kind(kind);
 498   set_access_flags(parser.access_flags());
 499   if (parser.is_hidden()) set_is_hidden();
 500   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 501   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 502                                                     false));




 503 
<span class="line-modified"> 504   assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="line-modified"> 505   assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="line-modified"> 506   assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
 507 
 508   if (Arguments::is_dumping_archive()) {
<span class="line-modified"> 509     SystemDictionaryShared::init_dumptime_info(this);</span>
<span class="line-modified"> 510   }</span>
 511 
 512   // Set biased locking bit for all instances of this class; it will be
 513   // cleared if revocation occurs too often for this type
 514   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 515     set_prototype_header(markWord::biased_locking_prototype());
 516   }



 517 }
 518 
 519 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 520                                        Array&lt;Method*&gt;* methods) {
 521   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 522       !methods-&gt;is_shared()) {
 523     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 524       Method* method = methods-&gt;at(i);
 525       if (method == NULL) continue;  // maybe null if error processing
 526       // Only want to delete methods that are not executing for RedefineClasses.
 527       // The previous version will point to them so they&#39;re not totally dangling
 528       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 529       MetadataFactory::free_metadata(loader_data, method);
 530     }
 531     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 532   }
 533 }
 534 
 535 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 536                                           const Klass* super_klass,
 537                                           Array&lt;InstanceKlass*&gt;* local_interfaces,
 538                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 539   // Only deallocate transitive interfaces if not empty, same as super class
 540   // or same as local interfaces.  See code in parseClassFile.
 541   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 542   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 543     // check that the interfaces don&#39;t come from super class
 544     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 545                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
<span class="line-modified"> 546     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared()) {</span>

 547       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 548     }
 549   }
 550 
 551   // local interfaces can be empty
 552   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
<span class="line-modified"> 553       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared()) {</span>

 554     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 555   }
 556 }
 557 
 558 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,
 559                                                  Array&lt;RecordComponent*&gt;* record_components) {
 560   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {
 561     for (int i = 0; i &lt; record_components-&gt;length(); i++) {
 562       RecordComponent* record_component = record_components-&gt;at(i);
 563       MetadataFactory::free_metadata(loader_data, record_component);
 564     }
 565     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);
 566   }
 567 }
 568 
 569 // This function deallocates the metadata and C heap pointers that the
 570 // InstanceKlass points to.
 571 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 572 
 573   // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
<hr />
<pre>
 848         vmSymbols::java_lang_IncompatibleClassChangeError(),
 849         &quot;class %s has interface %s as super class&quot;,
 850         external_name(),
 851         super_klass-&gt;external_name()
 852       );
 853       return false;
 854     }
 855 
 856     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 857     ik_super-&gt;link_class_impl(CHECK_false);
 858   }
 859 
 860   // link all interfaces implemented by this class before linking this class
 861   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 862   int num_interfaces = interfaces-&gt;length();
 863   for (int index = 0; index &lt; num_interfaces; index++) {
 864     InstanceKlass* interk = interfaces-&gt;at(index);
 865     interk-&gt;link_class_impl(CHECK_false);
 866   }
 867 
























































 868   // in case the class is linked in the process of linking its superclasses
 869   if (is_linked()) {
 870     return true;
 871   }
 872 
 873   // trace only the link time for this klass that includes
 874   // the verification time
 875   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
 876                              ClassLoader::perf_class_link_selftime(),
 877                              ClassLoader::perf_classes_linked(),
 878                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 879                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 880                              PerfClassTraceTime::CLASS_LINK);
 881 
 882   // verification &amp; rewriting
 883   {
 884     HandleMark hm(THREAD);
 885     Handle h_init_lock(THREAD, init_lock());
 886     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
 887     // rewritten will have been set if loader constraint error found
</pre>
<hr />
<pre>
 917       // Initialize the vtable and interface table after
 918       // methods have been rewritten since rewrite may
 919       // fabricate new Method*s.
 920       // also does loader constraint checking
 921       //
 922       // initialize_vtable and initialize_itable need to be rerun for
 923       // a shared class if the class is not loaded by the NULL classloader.
 924       ClassLoaderData * loader_data = class_loader_data();
 925       if (!(is_shared() &amp;&amp;
 926             loader_data-&gt;is_the_null_class_loader_data())) {
 927         vtable().initialize_vtable(true, CHECK_false);
 928         itable().initialize_itable(true, CHECK_false);
 929       }
 930 #ifdef ASSERT
 931       else {
 932         vtable().verify(tty, true);
 933         // In case itable verification is ever added.
 934         // itable().verify(tty, true);
 935       }
 936 #endif

 937       set_init_state(linked);
 938       if (JvmtiExport::should_post_class_prepare()) {
 939         Thread *thread = THREAD;
 940         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
 941         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
 942       }
 943     }
 944   }
 945   return true;
 946 }
 947 
 948 // Rewrite the byte codes of all of the methods of a class.
 949 // The rewriter must be called exactly once. Rewriting must happen after
 950 // verification but before the first method of the class is executed.
 951 void InstanceKlass::rewrite_class(TRAPS) {
 952   assert(is_loaded(), &quot;must be loaded&quot;);
 953   if (is_rewritten()) {
 954     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
 955     return;
 956   }
</pre>
<hr />
<pre>
1070     // having a superinterface that declares, non-static, concrete methods
1071     if (!HAS_PENDING_EXCEPTION &amp;&amp; has_nonstatic_concrete_methods()) {
1072       initialize_super_interfaces(THREAD);
1073     }
1074 
1075     // If any exceptions, complete abruptly, throwing the same exception as above.
1076     if (HAS_PENDING_EXCEPTION) {
1077       Handle e(THREAD, PENDING_EXCEPTION);
1078       CLEAR_PENDING_EXCEPTION;
1079       {
1080         EXCEPTION_MARK;
1081         // Locks object, set state, and notify all waiting threads
1082         set_initialization_state_and_notify(initialization_error, THREAD);
1083         CLEAR_PENDING_EXCEPTION;
1084       }
1085       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1086       THROW_OOP(e());
1087     }
1088   }
1089 































1090 
1091   // Look for aot compiled methods for this klass, including class initializer.
1092   AOTLoader::load_for_klass(this, THREAD);
1093 
<span class="line-modified">1094   // Step 8</span>
1095   {
1096     DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
1097     // Timer includes any side effects of class initialization (resolution,
1098     // etc), but not recursive entry into call_class_initializer().
1099     PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
1100                              ClassLoader::perf_class_init_selftime(),
1101                              ClassLoader::perf_classes_inited(),
1102                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1103                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1104                              PerfClassTraceTime::CLASS_CLINIT);
1105     call_class_initializer(THREAD);
1106   }
1107 
<span class="line-modified">1108   // Step 9</span>
1109   if (!HAS_PENDING_EXCEPTION) {
1110     set_initialization_state_and_notify(fully_initialized, CHECK);
1111     {
1112       debug_only(vtable().verify(tty, true);)
1113     }
1114   }
1115   else {
<span class="line-modified">1116     // Step 10 and 11</span>
1117     Handle e(THREAD, PENDING_EXCEPTION);
1118     CLEAR_PENDING_EXCEPTION;
1119     // JVMTI has already reported the pending exception
1120     // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1121     JvmtiExport::clear_detected_exception(jt);
1122     {
1123       EXCEPTION_MARK;
1124       set_initialization_state_and_notify(initialization_error, THREAD);
1125       CLEAR_PENDING_EXCEPTION;   // ignore any exception thrown, class initialization error is thrown below
1126       // JVMTI has already reported the pending exception
1127       // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1128       JvmtiExport::clear_detected_exception(jt);
1129     }
1130     DTRACE_CLASSINIT_PROBE_WAIT(error, -1, wait);
1131     if (e-&gt;is_a(SystemDictionary::Error_klass())) {
1132       THROW_OOP(e());
1133     } else {
1134       JavaCallArguments args(e);
1135       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1136                 vmSymbols::throwable_void_signature(),
</pre>
<hr />
<pre>
1361   if (this == SystemDictionary::Class_klass()) {
1362     ResourceMark rm(THREAD);
1363     THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()
1364               : vmSymbols::java_lang_IllegalAccessException(), external_name());
1365   }
1366 }
1367 
1368 Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {
1369   // Need load-acquire for lock-free read
1370   if (array_klasses_acquire() == NULL) {
1371     if (or_null) return NULL;
1372 
1373     ResourceMark rm(THREAD);
1374     JavaThread *jt = (JavaThread *)THREAD;
1375     {
1376       // Atomic creation of array_klasses
1377       MutexLocker ma(THREAD, MultiArray_lock);
1378 
1379       // Check if update has already taken place
1380       if (array_klasses() == NULL) {
<span class="line-modified">1381         Klass*    k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);</span>
1382         // use &#39;release&#39; to pair with lock-free load
1383         release_set_array_klasses(k);
1384       }
1385     }
1386   }
1387   // _this will always be set at this point
1388   ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();
1389   if (or_null) {
1390     return oak-&gt;array_klass_or_null(n);
1391   }
1392   return oak-&gt;array_klass(n, THREAD);
1393 }
1394 
1395 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1396   return array_klass_impl(or_null, 1, THREAD);
1397 }
1398 
1399 static int call_class_initializer_counter = 0;   // for debugging
1400 
1401 Method* InstanceKlass::class_initializer() const {
1402   Method* clinit = find_method(
1403       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="line-modified">1404   if (clinit != NULL &amp;&amp; clinit-&gt;has_valid_initializer_flags()) {</span>
1405     return clinit;
1406   }
1407   return NULL;
1408 }
1409 
1410 void InstanceKlass::call_class_initializer(TRAPS) {
1411   if (ReplayCompiles &amp;&amp;
1412       (ReplaySuppressInitializers == 1 ||
1413        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1414     // Hide the existence of the initializer for the purpose of replaying the compile
1415     return;
1416   }
1417 
1418   methodHandle h_method(THREAD, class_initializer());
1419   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1420   LogTarget(Info, class, init) lt;
1421   if (lt.is_enabled()) {
1422     ResourceMark rm(THREAD);
1423     LogStream ls(lt);
1424     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1425     name()-&gt;print_value_on(&amp;ls);
1426     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1427   }
1428   if (h_method() != NULL) {
1429     JavaCallArguments args; // No arguments
1430     JavaValue result(T_VOID);
1431     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1432   }
1433 }
1434 
1435 
1436 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1437   InterpreterOopMap* entry_for) {
1438   // Lazily create the _oop_map_cache at first request
1439   // Lock-free access requires load_acquire.
1440   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
1441   if (oop_map_cache == NULL) {
<span class="line-modified">1442     MutexLocker x(OopMapCacheAlloc_lock);</span>
1443     // Check if _oop_map_cache was allocated while we were waiting for this lock
1444     if ((oop_map_cache = _oop_map_cache) == NULL) {
1445       oop_map_cache = new OopMapCache();
1446       // Ensure _oop_map_cache is stable, since it is examined without a lock
1447       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
1448     }
1449   }
1450   // _oop_map_cache is constant after init; lookup below does its own locking.
1451   oop_map_cache-&gt;lookup(method, bci, entry_for);
1452 }
1453 
<span class="line-removed">1454 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-removed">1455   fieldDescriptor fd;</span>
<span class="line-removed">1456   return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-removed">1457 }</span>
<span class="line-removed">1458 </span>
1459 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1460   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1461     Symbol* f_name = fs.name();
1462     Symbol* f_sig  = fs.signature();
1463     if (f_name == name &amp;&amp; f_sig == sig) {
1464       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1465       return true;
1466     }
1467   }
1468   return false;
1469 }
1470 
1471 
1472 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1473   const int n = local_interfaces()-&gt;length();
1474   for (int i = 0; i &lt; n; i++) {
1475     Klass* intf1 = local_interfaces()-&gt;at(i);
1476     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1477     // search for field in current interface
1478     if (InstanceKlass::cast(intf1)-&gt;find_local_field(name, sig, fd)) {
</pre>
<hr />
<pre>
1509 
1510 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1511   // search order according to newest JVM spec (5.4.3.2, p.167).
1512   // 1) search for field in current klass
1513   if (find_local_field(name, sig, fd)) {
1514     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1515   }
1516   // 2) search for field recursively in direct superinterfaces
1517   if (is_static) {
1518     Klass* intf = find_interface_field(name, sig, fd);
1519     if (intf != NULL) return intf;
1520   }
1521   // 3) apply field lookup recursively if superclass exists
1522   { Klass* supr = super();
1523     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1524   }
1525   // 4) otherwise field lookup fails
1526   return NULL;
1527 }
1528 









1529 
1530 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1531   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1532     if (fs.offset() == offset) {
1533       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1534       if (fd-&gt;is_static() == is_static) return true;
1535     }
1536   }
1537   return false;
1538 }
1539 
1540 
1541 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1542   Klass* klass = const_cast&lt;InstanceKlass*&gt;(this);
1543   while (klass != NULL) {
1544     if (InstanceKlass::cast(klass)-&gt;find_local_field_from_offset(offset, is_static, fd)) {
1545       return true;
1546     }
1547     klass = klass-&gt;super();
1548   }
</pre>
<hr />
<pre>
1605     if (!fd.is_static()) {
1606       fields_sorted[j + 0] = fd.offset();
1607       fields_sorted[j + 1] = i;
1608       j += 2;
1609     }
1610   }
1611   if (j &gt; 0) {
1612     length = j;
1613     // _sort_Fn is defined in growableArray.hpp.
1614     qsort(fields_sorted, length/2, 2*sizeof(int), (_sort_Fn)compare_fields_by_offset);
1615     for (int i = 0; i &lt; length; i += 2) {
1616       fd.reinitialize(this, fields_sorted[i + 1]);
1617       assert(!fd.is_static() &amp;&amp; fd.offset() == fields_sorted[i], &quot;only nonstatic fields&quot;);
1618       cl-&gt;do_field(&amp;fd);
1619     }
1620   }
1621   FREE_C_HEAP_ARRAY(int, fields_sorted);
1622 }
1623 
1624 
<span class="line-removed">1625 void InstanceKlass::array_klasses_do(void f(Klass* k, TRAPS), TRAPS) {</span>
<span class="line-removed">1626   if (array_klasses() != NULL)</span>
<span class="line-removed">1627     ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f, THREAD);</span>
<span class="line-removed">1628 }</span>
<span class="line-removed">1629 </span>
1630 void InstanceKlass::array_klasses_do(void f(Klass* k)) {
1631   if (array_klasses() != NULL)
1632     ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f);
1633 }
1634 
1635 #ifdef ASSERT
1636 static int linear_search(const Array&lt;Method*&gt;* methods,
1637                          const Symbol* name,
1638                          const Symbol* signature) {
1639   const int len = methods-&gt;length();
1640   for (int index = 0; index &lt; len; index++) {
1641     const Method* const m = methods-&gt;at(index);
1642     assert(m-&gt;is_method(), &quot;must be method&quot;);
1643     if (m-&gt;signature() == signature &amp;&amp; m-&gt;name() == name) {
1644        return index;
1645     }
1646   }
1647   return -1;
1648 }
1649 #endif
</pre>
<hr />
<pre>
1893 }
1894 
1895 // uncached_lookup_method searches both the local class methods array and all
1896 // superclasses methods arrays, skipping any overpass methods in superclasses,
1897 // and possibly skipping private methods.
1898 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
1899                                               const Symbol* signature,
1900                                               OverpassLookupMode overpass_mode,
1901                                               PrivateLookupMode private_mode) const {
1902   OverpassLookupMode overpass_local_mode = overpass_mode;
1903   const Klass* klass = this;
1904   while (klass != NULL) {
1905     Method* const method = InstanceKlass::cast(klass)-&gt;find_method_impl(name,
1906                                                                         signature,
1907                                                                         overpass_local_mode,
1908                                                                         find_static,
1909                                                                         private_mode);
1910     if (method != NULL) {
1911       return method;
1912     }



1913     klass = klass-&gt;super();
1914     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
1915   }
1916   return NULL;
1917 }
1918 
1919 #ifdef ASSERT
1920 // search through class hierarchy and return true if this class or
1921 // one of the superclasses was redefined
1922 bool InstanceKlass::has_redefined_this_or_super() const {
1923   const Klass* klass = this;
1924   while (klass != NULL) {
1925     if (InstanceKlass::cast(klass)-&gt;has_been_redefined()) {
1926       return true;
1927     }
1928     klass = klass-&gt;super();
1929   }
1930   return false;
1931 }
1932 #endif
</pre>
<hr />
<pre>
2475 }
2476 
2477 void InstanceKlass::remove_java_mirror() {
2478   Klass::remove_java_mirror();
2479 
2480   // do array classes also.
2481   if (array_klasses() != NULL) {
2482     array_klasses()-&gt;remove_java_mirror();
2483   }
2484 }
2485 
2486 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2487                                              PackageEntry* pkg_entry, TRAPS) {
2488   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2489   // before the InstanceKlass is added to the SystemDictionary. Make
2490   // sure the current state is &lt;loaded.
2491   assert(!is_loaded(), &quot;invalid init state&quot;);
2492   set_package(loader_data, pkg_entry, CHECK);
2493   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2494 




2495   Array&lt;Method*&gt;* methods = this-&gt;methods();
2496   int num_methods = methods-&gt;length();
2497   for (int index = 0; index &lt; num_methods; ++index) {
2498     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2499   }
2500   if (JvmtiExport::has_redefined_a_class()) {
2501     // Reinitialize vtable because RedefineClasses may have changed some
2502     // entries in this vtable for super classes so the CDS vtable might
2503     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2504     // vtables in the shared system dictionary, only the main one.
2505     // It also redefines the itable too so fix that too.
2506     vtable().initialize_vtable(false, CHECK);
2507     itable().initialize_itable(false, CHECK);
2508   }
2509 
2510   // restore constant pool resolved references
2511   constants()-&gt;restore_unshareable_info(CHECK);
2512 
2513   if (array_klasses() != NULL) {
2514     // Array classes have null protection domain.
2515     // --&gt; see ArrayKlass::complete_create_array_klass()
2516     ArrayKlass::cast(array_klasses())-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2517   }
2518 
2519   // Initialize current biased locking state.
<span class="line-modified">2520   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
2521     set_prototype_header(markWord::biased_locking_prototype());
2522   }
2523 }
2524 
2525 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2526   switch (loader_type) {
2527   case ClassLoader::BOOT_LOADER:
2528     _misc_flags |= _misc_is_shared_boot_class;
2529     break;
2530   case ClassLoader::PLATFORM_LOADER:
2531     _misc_flags |= _misc_is_shared_platform_class;
2532     break;
2533   case ClassLoader::APP_LOADER:
2534     _misc_flags |= _misc_is_shared_app_class;
2535     break;
2536   default:
2537     ShouldNotReachHere();
2538     break;
2539   }
2540 }
</pre>
<hr />
<pre>
2618 #if INCLUDE_JVMTI
2619   // Deallocate breakpoint records
2620   if (breakpoints() != 0x0) {
2621     methods_do(clear_all_breakpoints);
2622     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2623   }
2624 
2625   // deallocate the cached class file
2626   if (_cached_class_file != NULL) {
2627     os::free(_cached_class_file);
2628     _cached_class_file = NULL;
2629   }
2630 #endif
2631 
2632   // Decrement symbol reference counts associated with the unloaded class.
2633   if (_name != NULL) _name-&gt;decrement_refcount();
2634 
2635   // unreference array name derived from this class name (arrays of an unloaded
2636   // class can&#39;t be referenced anymore).
2637   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();








2638   FREE_C_HEAP_ARRAY(char, _source_debug_extension);
2639 }
2640 
2641 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2642   if (array == NULL) {
2643     _source_debug_extension = NULL;
2644   } else {
2645     // Adding one to the attribute length in order to store a null terminator
2646     // character could cause an overflow because the attribute length is
2647     // already coded with an u4 in the classfile, but in practice, it&#39;s
2648     // unlikely to happen.
2649     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
2650     char* sde = NEW_C_HEAP_ARRAY(char, (length + 1), mtClass);
2651     for (int i = 0; i &lt; length; i++) {
2652       sde[i] = array[i];
2653     }
2654     sde[length] = &#39;\0&#39;;
2655     _source_debug_extension = sde;
2656   }
2657 }
2658 
2659 const char* InstanceKlass::signature_name() const {
2660   int hash_len = 0;
2661   char hash_buf[40];
2662 
2663   // If this is an unsafe anonymous class, append a hash to make the name unique
2664   if (is_unsafe_anonymous()) {
2665     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2666     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2667     hash_len = (int)strlen(hash_buf);
2668   }
2669 
2670   // Get the internal name as a c string
2671   const char* src = (const char*) (name()-&gt;as_C_string());
2672   const int src_length = (int)strlen(src);
2673 
2674   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2675 
<span class="line-modified">2676   // Add L as type indicator</span>
2677   int dest_index = 0;
<span class="line-modified">2678   dest[dest_index++] = JVM_SIGNATURE_CLASS;</span>
2679 
2680   // Add the actual class name
2681   for (int src_index = 0; src_index &lt; src_length; ) {
2682     dest[dest_index++] = src[src_index++];
2683   }
2684 
2685   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.
2686     for (int index = (int)src_length; index &gt; 0; index--) {
2687       if (dest[index] == &#39;+&#39;) {
2688         dest[index] = JVM_SIGNATURE_DOT;
2689         break;
2690       }
2691     }
2692   }
2693 
2694   // If we have a hash, append it
2695   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2696     dest[dest_index++] = hash_buf[hash_index++];
2697   }
2698 
</pre>
<hr />
<pre>
3218   }
3219 
3220   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);
3221   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {
3222     return best;
3223   }
3224   return NULL;
3225 }
3226 
3227 // -----------------------------------------------------------------------------------------------------
3228 // Printing
3229 
3230 #ifndef PRODUCT
3231 
3232 #define BULLET  &quot; - &quot;
3233 
3234 static const char* state_names[] = {
3235   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3236 };
3237 
<span class="line-modified">3238 static void print_vtable(intptr_t* start, int len, outputStream* st) {</span>



3239   for (int i = 0; i &lt; len; i++) {
3240     intptr_t e = start[i];
3241     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);





3242     if (MetaspaceObj::is_valid((Metadata*)e)) {
3243       st-&gt;print(&quot; &quot;);
3244       ((Metadata*)e)-&gt;print_value_on(st);






3245     }
3246     st-&gt;cr();
3247   }
3248 }
3249 
3250 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="line-modified">3251   return print_vtable(reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>





















3252 }
3253 
3254 void InstanceKlass::print_on(outputStream* st) const {
3255   assert(is_klass(), &quot;must be klass&quot;);
3256   Klass::print_on(st);
3257 
3258   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3259   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3260   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();

3261   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3262   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
3263   st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
3264   st-&gt;print(BULLET&quot;sub:               &quot;);
3265   Klass* sub = subklass();
3266   int n;
3267   for (n = 0; sub != NULL; n++, sub = sub-&gt;next_sibling()) {
3268     if (n &lt; MaxSubklassPrintSize) {
3269       sub-&gt;print_value_on(st);
3270       st-&gt;print(&quot;   &quot;);
3271     }
3272   }
3273   if (n &gt;= MaxSubklassPrintSize) st-&gt;print(&quot;(&quot; INTX_FORMAT &quot; more klasses...)&quot;, n - MaxSubklassPrintSize);
3274   st-&gt;cr();
3275 
3276   if (is_interface()) {
3277     st-&gt;print_cr(BULLET&quot;nof implementors:  %d&quot;, nof_implementors());
3278     if (nof_implementors() == 1) {
3279       st-&gt;print_cr(BULLET&quot;implementor:    &quot;);
3280       st-&gt;print(&quot;   &quot;);
3281       implementor()-&gt;print_value_on(st);
3282       st-&gt;cr();
3283     }
3284   }
3285 
3286   st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="line-modified">3287   st-&gt;print(BULLET&quot;methods:           &quot;); methods()-&gt;print_value_on(st);                  st-&gt;cr();</span>
<span class="line-modified">3288   if (Verbose || WizardMode) {</span>
<span class="line-modified">3289     Array&lt;Method*&gt;* method_array = methods();</span>
<span class="line-removed">3290     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="line-removed">3291       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="line-removed">3292     }</span>
<span class="line-removed">3293   }</span>
<span class="line-removed">3294   st-&gt;print(BULLET&quot;method ordering:   &quot;); method_ordering()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-removed">3295   st-&gt;print(BULLET&quot;default_methods:   &quot;); default_methods()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-removed">3296   if (Verbose &amp;&amp; default_methods() != NULL) {</span>
<span class="line-removed">3297     Array&lt;Method*&gt;* method_array = default_methods();</span>
<span class="line-removed">3298     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="line-removed">3299       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="line-removed">3300     }</span>
<span class="line-removed">3301   }</span>
3302   if (default_vtable_indices() != NULL) {
<span class="line-modified">3303     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); default_vtable_indices()-&gt;print_value_on(st);       st-&gt;cr();</span>
3304   }
<span class="line-modified">3305   st-&gt;print(BULLET&quot;local interfaces:  &quot;); local_interfaces()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-modified">3306   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); transitive_interfaces()-&gt;print_value_on(st); st-&gt;cr();</span>
3307   st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
3308   if (class_loader_data() != NULL) {
3309     st-&gt;print(BULLET&quot;class loader data:  &quot;);
3310     class_loader_data()-&gt;print_value_on(st);
3311     st-&gt;cr();
3312   }
3313   st-&gt;print(BULLET&quot;unsafe anonymous host class:        &quot;); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st-&gt;cr();
3314   if (source_file_name() != NULL) {
3315     st-&gt;print(BULLET&quot;source file:       &quot;);
3316     source_file_name()-&gt;print_value_on(st);
3317     st-&gt;cr();
3318   }
3319   if (source_debug_extension() != NULL) {
3320     st-&gt;print(BULLET&quot;source debug extension:       &quot;);
3321     st-&gt;print(&quot;%s&quot;, source_debug_extension());
3322     st-&gt;cr();
3323   }
3324   st-&gt;print(BULLET&quot;class annotations:       &quot;); class_annotations()-&gt;print_value_on(st); st-&gt;cr();
3325   st-&gt;print(BULLET&quot;class type annotations:  &quot;); class_type_annotations()-&gt;print_value_on(st); st-&gt;cr();
3326   st-&gt;print(BULLET&quot;field annotations:       &quot;); fields_annotations()-&gt;print_value_on(st); st-&gt;cr();
</pre>
<hr />
<pre>
3342   if (generic_signature() != NULL) {
3343     st-&gt;print(BULLET&quot;generic signature: &quot;);
3344     generic_signature()-&gt;print_value_on(st);
3345     st-&gt;cr();
3346   }
3347   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3348   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
3349   if (record_components() != NULL) {
3350     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();
3351   }
3352   if (java_mirror() != NULL) {
3353     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3354     java_mirror()-&gt;print_value_on(st);
3355     st-&gt;cr();
3356   } else {
3357     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3358   }
3359   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3360   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3361   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="line-modified">3362   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);</span>
3363   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3364   FieldPrinter print_static_field(st);
3365   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3366   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3367   FieldPrinter print_nonstatic_field(st);
3368   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3369   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3370 
3371   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
3372   OopMapBlock* map     = start_of_nonstatic_oop_maps();
3373   OopMapBlock* end_map = map + nonstatic_oop_map_count();
3374   while (map &lt; end_map) {
3375     st-&gt;print(&quot;%d-%d &quot;, map-&gt;offset(), map-&gt;offset() + heapOopSize*(map-&gt;count() - 1));
3376     map++;
3377   }
3378   st-&gt;cr();
3379 }
3380 
3381 #endif //PRODUCT
3382 
</pre>
<hr />
<pre>
4081   if (holder == NULL) {
4082     return NULL; // The version of klass is gone, no method is found
4083   }
4084   Method* method = holder-&gt;method_with_orig_idnum(idnum);
4085   return method;
4086 }
4087 
4088 #if INCLUDE_JVMTI
4089 JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {
4090   return _cached_class_file;
4091 }
4092 
4093 jint InstanceKlass::get_cached_class_file_len() {
4094   return VM_RedefineClasses::get_cached_class_file_len(_cached_class_file);
4095 }
4096 
4097 unsigned char * InstanceKlass::get_cached_class_file_bytes() {
4098   return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
4099 }
4100 #endif





</pre>
</td>
<td>
<hr />
<pre>
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.inline.hpp&quot;
  51 #include &quot;memory/metadataFactory.hpp&quot;
  52 #include &quot;memory/metaspaceClosure.hpp&quot;
  53 #include &quot;memory/metaspaceShared.hpp&quot;
  54 #include &quot;memory/oopFactory.hpp&quot;
  55 #include &quot;memory/resourceArea.hpp&quot;
  56 #include &quot;memory/universe.hpp&quot;
  57 #include &quot;oops/fieldStreams.inline.hpp&quot;
  58 #include &quot;oops/constantPool.hpp&quot;
  59 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  60 #include &quot;oops/instanceKlass.inline.hpp&quot;
  61 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  62 #include &quot;oops/instanceOop.hpp&quot;
  63 #include &quot;oops/klass.inline.hpp&quot;
  64 #include &quot;oops/method.hpp&quot;
  65 #include &quot;oops/oop.inline.hpp&quot;
  66 #include &quot;oops/recordComponent.hpp&quot;
  67 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  68 #include &quot;oops/valueKlass.hpp&quot;</span>
  69 #include &quot;prims/jvmtiExport.hpp&quot;
  70 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  71 #include &quot;prims/jvmtiThreadState.hpp&quot;
  72 #include &quot;prims/methodComparator.hpp&quot;
  73 #include &quot;runtime/atomic.hpp&quot;
  74 #include &quot;runtime/biasedLocking.hpp&quot;
  75 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  76 #include &quot;runtime/handles.inline.hpp&quot;
  77 #include &quot;runtime/javaCalls.hpp&quot;
  78 #include &quot;runtime/mutexLocker.hpp&quot;
  79 #include &quot;runtime/orderAccess.hpp&quot;
  80 #include &quot;runtime/thread.inline.hpp&quot;
  81 #include &quot;services/classLoadingService.hpp&quot;
  82 #include &quot;services/threadService.hpp&quot;
  83 #include &quot;utilities/dtrace.hpp&quot;
  84 #include &quot;utilities/events.hpp&quot;
  85 #include &quot;utilities/macros.hpp&quot;
  86 #include &quot;utilities/stringUtils.hpp&quot;
  87 #ifdef COMPILER1
  88 #include &quot;c1/c1_Compiler.hpp&quot;
</pre>
<hr />
<pre>
 406                               k-&gt;external_name());
 407   return access;
 408 }
 409 
 410 const char* InstanceKlass::nest_host_error(TRAPS) {
 411   if (_nest_host_index == 0) {
 412     return NULL;
 413   } else {
 414     constantPoolHandle cph(THREAD, constants());
 415     return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);
 416   }
 417 }
 418 
 419 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 420   bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();
 421   const int size = InstanceKlass::size(parser.vtable_size(),
 422                                        parser.itable_size(),
 423                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 424                                        parser.is_interface(),
 425                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 426                                        should_store_fingerprint(is_hidden_or_anonymous),</span>
<span class="line-added"> 427                                        parser.has_flattenable_fields() ? parser.java_fields_count() : 0,</span>
<span class="line-added"> 428                                        parser.is_inline_type());</span>
 429 
 430   const Symbol* const class_name = parser.class_name();
 431   assert(class_name != NULL, &quot;invariant&quot;);
 432   ClassLoaderData* loader_data = parser.loader_data();
 433   assert(loader_data != NULL, &quot;invariant&quot;);
 434 
 435   InstanceKlass* ik;
 436 
 437   // Allocation
 438   if (REF_NONE == parser.reference_type()) {
 439     if (class_name == vmSymbols::java_lang_Class()) {
 440       // mirror
 441       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="line-modified"> 442     } else if (is_class_loader(class_name, parser)) {</span>

 443       // class loader
 444       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
<span class="line-added"> 445     } else if (parser.is_inline_type()) {</span>
<span class="line-added"> 446       // inline type</span>
<span class="line-added"> 447       ik = new (loader_data, size, THREAD) ValueKlass(parser);</span>
 448     } else {
 449       // normal
 450       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other);
 451     }
 452   } else {
 453     // reference
 454     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 455   }
 456 
 457   // Check for pending exception before adding to the loader data and incrementing
 458   // class count.  Can get OOM here.
 459   if (HAS_PENDING_EXCEPTION) {
 460     return NULL;
 461   }
 462 
<span class="line-added"> 463 #ifdef ASSERT</span>
<span class="line-added"> 464   assert(ik-&gt;size() == size, &quot;&quot;);</span>
<span class="line-added"> 465   ik-&gt;bounds_check((address) ik-&gt;start_of_vtable(), false, size);</span>
<span class="line-added"> 466   ik-&gt;bounds_check((address) ik-&gt;start_of_itable(), false, size);</span>
<span class="line-added"> 467   ik-&gt;bounds_check((address) ik-&gt;end_of_itable(), true, size);</span>
<span class="line-added"> 468   ik-&gt;bounds_check((address) ik-&gt;end_of_nonstatic_oop_maps(), true, size);</span>
<span class="line-added"> 469 #endif //ASSERT</span>
 470   return ik;
 471 }
 472 
<span class="line-added"> 473 #ifndef PRODUCT</span>
<span class="line-added"> 474 bool InstanceKlass::bounds_check(address addr, bool edge_ok, intptr_t size_in_bytes) const {</span>
<span class="line-added"> 475   const char* bad = NULL;</span>
<span class="line-added"> 476   address end = NULL;</span>
<span class="line-added"> 477   if (addr &lt; (address)this) {</span>
<span class="line-added"> 478     bad = &quot;before&quot;;</span>
<span class="line-added"> 479   } else if (addr == (address)this) {</span>
<span class="line-added"> 480     if (edge_ok)  return true;</span>
<span class="line-added"> 481     bad = &quot;just before&quot;;</span>
<span class="line-added"> 482   } else if (addr == (end = (address)this + sizeof(intptr_t) * (size_in_bytes &lt; 0 ? size() : size_in_bytes))) {</span>
<span class="line-added"> 483     if (edge_ok)  return true;</span>
<span class="line-added"> 484     bad = &quot;just after&quot;;</span>
<span class="line-added"> 485   } else if (addr &gt; end) {</span>
<span class="line-added"> 486     bad = &quot;after&quot;;</span>
<span class="line-added"> 487   } else {</span>
<span class="line-added"> 488     return true;</span>
<span class="line-added"> 489   }</span>
<span class="line-added"> 490   tty-&gt;print_cr(&quot;%s object bounds: &quot; INTPTR_FORMAT &quot; [&quot; INTPTR_FORMAT &quot;..&quot; INTPTR_FORMAT &quot;]&quot;,</span>
<span class="line-added"> 491       bad, (intptr_t)addr, (intptr_t)this, (intptr_t)end);</span>
<span class="line-added"> 492   Verbose = WizardMode = true; this-&gt;print(); //@@</span>
<span class="line-added"> 493   return false;</span>
<span class="line-added"> 494 }</span>
<span class="line-added"> 495 #endif //PRODUCT</span>
 496 
 497 // copy method ordering from resource area to Metaspace
 498 void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
 499   if (m != NULL) {
 500     // allocate a new array and copy contents (memcpy?)
 501     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 502     for (int i = 0; i &lt; m-&gt;length(); i++) {
 503       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 504     }
 505   } else {
 506     _method_ordering = Universe::the_empty_int_array();
 507   }
 508 }
 509 
 510 // create a new array of vtable_indices for default methods
 511 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 512   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 513   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 514   set_default_vtable_indices(vtable_indices);
 515   return vtable_indices;
 516 }
 517 
 518 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 519   Klass(id),
 520   _nest_members(NULL),
 521   _nest_host_index(0),
 522   _nest_host(NULL),
 523   _record_components(NULL),
 524   _static_field_size(parser.static_field_size()),
 525   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 526   _itable_len(parser.itable_size()),
 527   _init_thread(NULL),
 528   _init_state(allocated),
<span class="line-modified"> 529   _reference_type(parser.reference_type()),</span>
<span class="line-added"> 530   _value_field_klasses(NULL),</span>
<span class="line-added"> 531   _adr_valueklass_fixed_block(NULL)</span>
 532 {
 533   set_vtable_length(parser.vtable_size());
 534   set_kind(kind);
 535   set_access_flags(parser.access_flags());
 536   if (parser.is_hidden()) set_is_hidden();
 537   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 538   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 539                                                     false));
<span class="line-added"> 540     if (parser.has_flattenable_fields()) {</span>
<span class="line-added"> 541       set_has_inline_fields();</span>
<span class="line-added"> 542     }</span>
<span class="line-added"> 543     _java_fields_count = parser.java_fields_count();</span>
 544 
<span class="line-modified"> 545     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="line-modified"> 546     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="line-modified"> 547     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
 548 
 549   if (Arguments::is_dumping_archive()) {
<span class="line-modified"> 550       SystemDictionaryShared::init_dumptime_info(this);</span>
<span class="line-modified"> 551     }</span>
 552 
 553   // Set biased locking bit for all instances of this class; it will be
 554   // cleared if revocation occurs too often for this type
 555   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 556     set_prototype_header(markWord::biased_locking_prototype());
 557   }
<span class="line-added"> 558   if (has_inline_fields()) {</span>
<span class="line-added"> 559     _value_field_klasses = (const Klass**) adr_value_fields_klasses();</span>
<span class="line-added"> 560   }</span>
 561 }
 562 
 563 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 564                                        Array&lt;Method*&gt;* methods) {
 565   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 566       !methods-&gt;is_shared()) {
 567     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 568       Method* method = methods-&gt;at(i);
 569       if (method == NULL) continue;  // maybe null if error processing
 570       // Only want to delete methods that are not executing for RedefineClasses.
 571       // The previous version will point to them so they&#39;re not totally dangling
 572       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 573       MetadataFactory::free_metadata(loader_data, method);
 574     }
 575     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 576   }
 577 }
 578 
 579 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 580                                           const Klass* super_klass,
 581                                           Array&lt;InstanceKlass*&gt;* local_interfaces,
 582                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 583   // Only deallocate transitive interfaces if not empty, same as super class
 584   // or same as local interfaces.  See code in parseClassFile.
 585   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 586   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 587     // check that the interfaces don&#39;t come from super class
 588     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 589                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
<span class="line-modified"> 590     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared() &amp;&amp;</span>
<span class="line-added"> 591         ti != Universe::the_single_IdentityObject_klass_array()) {</span>
 592       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 593     }
 594   }
 595 
 596   // local interfaces can be empty
 597   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
<span class="line-modified"> 598       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared() &amp;&amp;</span>
<span class="line-added"> 599       local_interfaces != Universe::the_single_IdentityObject_klass_array()) {</span>
 600     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 601   }
 602 }
 603 
 604 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,
 605                                                  Array&lt;RecordComponent*&gt;* record_components) {
 606   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {
 607     for (int i = 0; i &lt; record_components-&gt;length(); i++) {
 608       RecordComponent* record_component = record_components-&gt;at(i);
 609       MetadataFactory::free_metadata(loader_data, record_component);
 610     }
 611     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);
 612   }
 613 }
 614 
 615 // This function deallocates the metadata and C heap pointers that the
 616 // InstanceKlass points to.
 617 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 618 
 619   // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
<hr />
<pre>
 894         vmSymbols::java_lang_IncompatibleClassChangeError(),
 895         &quot;class %s has interface %s as super class&quot;,
 896         external_name(),
 897         super_klass-&gt;external_name()
 898       );
 899       return false;
 900     }
 901 
 902     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 903     ik_super-&gt;link_class_impl(CHECK_false);
 904   }
 905 
 906   // link all interfaces implemented by this class before linking this class
 907   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 908   int num_interfaces = interfaces-&gt;length();
 909   for (int index = 0; index &lt; num_interfaces; index++) {
 910     InstanceKlass* interk = interfaces-&gt;at(index);
 911     interk-&gt;link_class_impl(CHECK_false);
 912   }
 913 
<span class="line-added"> 914 </span>
<span class="line-added"> 915   // If a class declares a method that uses an inline class as an argument</span>
<span class="line-added"> 916   // type or return inline type, this inline class must be loaded during the</span>
<span class="line-added"> 917   // linking of this class because size and properties of the inline class</span>
<span class="line-added"> 918   // must be known in order to be able to perform inline type optimizations.</span>
<span class="line-added"> 919   // The implementation below is an approximation of this rule, the code</span>
<span class="line-added"> 920   // iterates over all methods of the current class (including overridden</span>
<span class="line-added"> 921   // methods), not only the methods declared by this class. This</span>
<span class="line-added"> 922   // approximation makes the code simpler, and doesn&#39;t change the semantic</span>
<span class="line-added"> 923   // because classes declaring methods overridden by the current class are</span>
<span class="line-added"> 924   // linked (and have performed their own pre-loading) before the linking</span>
<span class="line-added"> 925   // of the current class.</span>
<span class="line-added"> 926 </span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928   // Note:</span>
<span class="line-added"> 929   // Inline class types used for flattenable fields are loaded during</span>
<span class="line-added"> 930   // the loading phase (see ClassFileParser::post_process_parsed_stream()).</span>
<span class="line-added"> 931   // Inline class types used as element types for array creation</span>
<span class="line-added"> 932   // are not pre-loaded. Their loading is triggered by either anewarray</span>
<span class="line-added"> 933   // or multianewarray bytecodes.</span>
<span class="line-added"> 934 </span>
<span class="line-added"> 935   // Could it be possible to do the following processing only if the</span>
<span class="line-added"> 936   // class uses inline types?</span>
<span class="line-added"> 937   {</span>
<span class="line-added"> 938     ResourceMark rm(THREAD);</span>
<span class="line-added"> 939     for (int i = 0; i &lt; methods()-&gt;length(); i++) {</span>
<span class="line-added"> 940       Method* m = methods()-&gt;at(i);</span>
<span class="line-added"> 941       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {</span>
<span class="line-added"> 942         if (ss.is_reference()) {</span>
<span class="line-added"> 943           if (ss.is_array()) {</span>
<span class="line-added"> 944             ss.skip_array_prefix();</span>
<span class="line-added"> 945           }</span>
<span class="line-added"> 946           if (ss.type() == T_VALUETYPE) {</span>
<span class="line-added"> 947             Symbol* symb = ss.as_symbol();</span>
<span class="line-added"> 948 </span>
<span class="line-added"> 949             oop loader = class_loader();</span>
<span class="line-added"> 950             oop protection_domain = this-&gt;protection_domain();</span>
<span class="line-added"> 951             Klass* klass = SystemDictionary::resolve_or_fail(symb,</span>
<span class="line-added"> 952                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,</span>
<span class="line-added"> 953                                                              CHECK_false);</span>
<span class="line-added"> 954             if (klass == NULL) {</span>
<span class="line-added"> 955               THROW_(vmSymbols::java_lang_LinkageError(), false);</span>
<span class="line-added"> 956             }</span>
<span class="line-added"> 957             if (!klass-&gt;is_value()) {</span>
<span class="line-added"> 958               Exceptions::fthrow(</span>
<span class="line-added"> 959                 THREAD_AND_LOCATION,</span>
<span class="line-added"> 960                 vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added"> 961                 &quot;class %s is not an inline type&quot;,</span>
<span class="line-added"> 962                 klass-&gt;external_name());</span>
<span class="line-added"> 963             }</span>
<span class="line-added"> 964           }</span>
<span class="line-added"> 965         }</span>
<span class="line-added"> 966       }</span>
<span class="line-added"> 967     }</span>
<span class="line-added"> 968   }</span>
<span class="line-added"> 969 </span>
 970   // in case the class is linked in the process of linking its superclasses
 971   if (is_linked()) {
 972     return true;
 973   }
 974 
 975   // trace only the link time for this klass that includes
 976   // the verification time
 977   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
 978                              ClassLoader::perf_class_link_selftime(),
 979                              ClassLoader::perf_classes_linked(),
 980                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 981                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 982                              PerfClassTraceTime::CLASS_LINK);
 983 
 984   // verification &amp; rewriting
 985   {
 986     HandleMark hm(THREAD);
 987     Handle h_init_lock(THREAD, init_lock());
 988     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
 989     // rewritten will have been set if loader constraint error found
</pre>
<hr />
<pre>
1019       // Initialize the vtable and interface table after
1020       // methods have been rewritten since rewrite may
1021       // fabricate new Method*s.
1022       // also does loader constraint checking
1023       //
1024       // initialize_vtable and initialize_itable need to be rerun for
1025       // a shared class if the class is not loaded by the NULL classloader.
1026       ClassLoaderData * loader_data = class_loader_data();
1027       if (!(is_shared() &amp;&amp;
1028             loader_data-&gt;is_the_null_class_loader_data())) {
1029         vtable().initialize_vtable(true, CHECK_false);
1030         itable().initialize_itable(true, CHECK_false);
1031       }
1032 #ifdef ASSERT
1033       else {
1034         vtable().verify(tty, true);
1035         // In case itable verification is ever added.
1036         // itable().verify(tty, true);
1037       }
1038 #endif
<span class="line-added">1039 </span>
1040       set_init_state(linked);
1041       if (JvmtiExport::should_post_class_prepare()) {
1042         Thread *thread = THREAD;
1043         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1044         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
1045       }
1046     }
1047   }
1048   return true;
1049 }
1050 
1051 // Rewrite the byte codes of all of the methods of a class.
1052 // The rewriter must be called exactly once. Rewriting must happen after
1053 // verification but before the first method of the class is executed.
1054 void InstanceKlass::rewrite_class(TRAPS) {
1055   assert(is_loaded(), &quot;must be loaded&quot;);
1056   if (is_rewritten()) {
1057     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
1058     return;
1059   }
</pre>
<hr />
<pre>
1173     // having a superinterface that declares, non-static, concrete methods
1174     if (!HAS_PENDING_EXCEPTION &amp;&amp; has_nonstatic_concrete_methods()) {
1175       initialize_super_interfaces(THREAD);
1176     }
1177 
1178     // If any exceptions, complete abruptly, throwing the same exception as above.
1179     if (HAS_PENDING_EXCEPTION) {
1180       Handle e(THREAD, PENDING_EXCEPTION);
1181       CLEAR_PENDING_EXCEPTION;
1182       {
1183         EXCEPTION_MARK;
1184         // Locks object, set state, and notify all waiting threads
1185         set_initialization_state_and_notify(initialization_error, THREAD);
1186         CLEAR_PENDING_EXCEPTION;
1187       }
1188       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1189       THROW_OOP(e());
1190     }
1191   }
1192 
<span class="line-added">1193   // Step 8</span>
<span class="line-added">1194   // Initialize classes of flattenable fields</span>
<span class="line-added">1195   {</span>
<span class="line-added">1196     for (AllFieldStream fs(this); !fs.done(); fs.next()) {</span>
<span class="line-added">1197       if (fs.is_flattenable()) {</span>
<span class="line-added">1198         Klass* klass = this-&gt;get_value_field_klass_or_null(fs.index());</span>
<span class="line-added">1199         if (klass == NULL) {</span>
<span class="line-added">1200           assert(fs.access_flags().is_static() &amp;&amp; fs.access_flags().is_flattenable(),</span>
<span class="line-added">1201               &quot;Otherwise should have been pre-loaded&quot;);</span>
<span class="line-added">1202           klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())-&gt;fundamental_name(THREAD),</span>
<span class="line-added">1203               Handle(THREAD, class_loader()),</span>
<span class="line-added">1204               Handle(THREAD, protection_domain()),</span>
<span class="line-added">1205               true, CHECK);</span>
<span class="line-added">1206           if (klass == NULL) {</span>
<span class="line-added">1207             THROW(vmSymbols::java_lang_NoClassDefFoundError());</span>
<span class="line-added">1208           }</span>
<span class="line-added">1209           if (!klass-&gt;is_value()) {</span>
<span class="line-added">1210             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">1211           }</span>
<span class="line-added">1212           this-&gt;set_value_field_klass(fs.index(), klass);</span>
<span class="line-added">1213         }</span>
<span class="line-added">1214         InstanceKlass::cast(klass)-&gt;initialize(CHECK);</span>
<span class="line-added">1215         if (fs.access_flags().is_static()) {</span>
<span class="line-added">1216           if (java_mirror()-&gt;obj_field(fs.offset()) == NULL) {</span>
<span class="line-added">1217             java_mirror()-&gt;obj_field_put(fs.offset(), ValueKlass::cast(klass)-&gt;default_value());</span>
<span class="line-added">1218           }</span>
<span class="line-added">1219         }</span>
<span class="line-added">1220       }</span>
<span class="line-added">1221     }</span>
<span class="line-added">1222   }</span>
<span class="line-added">1223 </span>
1224 
1225   // Look for aot compiled methods for this klass, including class initializer.
1226   AOTLoader::load_for_klass(this, THREAD);
1227 
<span class="line-modified">1228   // Step 9</span>
1229   {
1230     DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
1231     // Timer includes any side effects of class initialization (resolution,
1232     // etc), but not recursive entry into call_class_initializer().
1233     PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
1234                              ClassLoader::perf_class_init_selftime(),
1235                              ClassLoader::perf_classes_inited(),
1236                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1237                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1238                              PerfClassTraceTime::CLASS_CLINIT);
1239     call_class_initializer(THREAD);
1240   }
1241 
<span class="line-modified">1242   // Step 10</span>
1243   if (!HAS_PENDING_EXCEPTION) {
1244     set_initialization_state_and_notify(fully_initialized, CHECK);
1245     {
1246       debug_only(vtable().verify(tty, true);)
1247     }
1248   }
1249   else {
<span class="line-modified">1250     // Step 11 and 12</span>
1251     Handle e(THREAD, PENDING_EXCEPTION);
1252     CLEAR_PENDING_EXCEPTION;
1253     // JVMTI has already reported the pending exception
1254     // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1255     JvmtiExport::clear_detected_exception(jt);
1256     {
1257       EXCEPTION_MARK;
1258       set_initialization_state_and_notify(initialization_error, THREAD);
1259       CLEAR_PENDING_EXCEPTION;   // ignore any exception thrown, class initialization error is thrown below
1260       // JVMTI has already reported the pending exception
1261       // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1262       JvmtiExport::clear_detected_exception(jt);
1263     }
1264     DTRACE_CLASSINIT_PROBE_WAIT(error, -1, wait);
1265     if (e-&gt;is_a(SystemDictionary::Error_klass())) {
1266       THROW_OOP(e());
1267     } else {
1268       JavaCallArguments args(e);
1269       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1270                 vmSymbols::throwable_void_signature(),
</pre>
<hr />
<pre>
1495   if (this == SystemDictionary::Class_klass()) {
1496     ResourceMark rm(THREAD);
1497     THROW_MSG(throwError ? vmSymbols::java_lang_IllegalAccessError()
1498               : vmSymbols::java_lang_IllegalAccessException(), external_name());
1499   }
1500 }
1501 
1502 Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {
1503   // Need load-acquire for lock-free read
1504   if (array_klasses_acquire() == NULL) {
1505     if (or_null) return NULL;
1506 
1507     ResourceMark rm(THREAD);
1508     JavaThread *jt = (JavaThread *)THREAD;
1509     {
1510       // Atomic creation of array_klasses
1511       MutexLocker ma(THREAD, MultiArray_lock);
1512 
1513       // Check if update has already taken place
1514       if (array_klasses() == NULL) {
<span class="line-modified">1515         Klass*    k = ObjArrayKlass::allocate_objArray_klass(1, this, CHECK_NULL);</span>
1516         // use &#39;release&#39; to pair with lock-free load
1517         release_set_array_klasses(k);
1518       }
1519     }
1520   }
1521   // _this will always be set at this point
1522   ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();
1523   if (or_null) {
1524     return oak-&gt;array_klass_or_null(n);
1525   }
1526   return oak-&gt;array_klass(n, THREAD);
1527 }
1528 
1529 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1530   return array_klass_impl(or_null, 1, THREAD);
1531 }
1532 
1533 static int call_class_initializer_counter = 0;   // for debugging
1534 
1535 Method* InstanceKlass::class_initializer() const {
1536   Method* clinit = find_method(
1537       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="line-modified">1538   if (clinit != NULL &amp;&amp; clinit-&gt;is_class_initializer()) {</span>
1539     return clinit;
1540   }
1541   return NULL;
1542 }
1543 
1544 void InstanceKlass::call_class_initializer(TRAPS) {
1545   if (ReplayCompiles &amp;&amp;
1546       (ReplaySuppressInitializers == 1 ||
1547        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1548     // Hide the existence of the initializer for the purpose of replaying the compile
1549     return;
1550   }
1551 
1552   methodHandle h_method(THREAD, class_initializer());
1553   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1554   LogTarget(Info, class, init) lt;
1555   if (lt.is_enabled()) {
1556     ResourceMark rm(THREAD);
1557     LogStream ls(lt);
1558     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1559     name()-&gt;print_value_on(&amp;ls);
1560     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1561   }
1562   if (h_method() != NULL) {
1563     JavaCallArguments args; // No arguments
1564     JavaValue result(T_VOID);
1565     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1566   }
1567 }
1568 
1569 
1570 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1571   InterpreterOopMap* entry_for) {
1572   // Lazily create the _oop_map_cache at first request
1573   // Lock-free access requires load_acquire.
1574   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
1575   if (oop_map_cache == NULL) {
<span class="line-modified">1576     MutexLocker x(OopMapCacheAlloc_lock,  Mutex::_no_safepoint_check_flag);</span>
1577     // Check if _oop_map_cache was allocated while we were waiting for this lock
1578     if ((oop_map_cache = _oop_map_cache) == NULL) {
1579       oop_map_cache = new OopMapCache();
1580       // Ensure _oop_map_cache is stable, since it is examined without a lock
1581       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
1582     }
1583   }
1584   // _oop_map_cache is constant after init; lookup below does its own locking.
1585   oop_map_cache-&gt;lookup(method, bci, entry_for);
1586 }
1587 





1588 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1589   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1590     Symbol* f_name = fs.name();
1591     Symbol* f_sig  = fs.signature();
1592     if (f_name == name &amp;&amp; f_sig == sig) {
1593       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1594       return true;
1595     }
1596   }
1597   return false;
1598 }
1599 
1600 
1601 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1602   const int n = local_interfaces()-&gt;length();
1603   for (int i = 0; i &lt; n; i++) {
1604     Klass* intf1 = local_interfaces()-&gt;at(i);
1605     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1606     // search for field in current interface
1607     if (InstanceKlass::cast(intf1)-&gt;find_local_field(name, sig, fd)) {
</pre>
<hr />
<pre>
1638 
1639 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1640   // search order according to newest JVM spec (5.4.3.2, p.167).
1641   // 1) search for field in current klass
1642   if (find_local_field(name, sig, fd)) {
1643     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1644   }
1645   // 2) search for field recursively in direct superinterfaces
1646   if (is_static) {
1647     Klass* intf = find_interface_field(name, sig, fd);
1648     if (intf != NULL) return intf;
1649   }
1650   // 3) apply field lookup recursively if superclass exists
1651   { Klass* supr = super();
1652     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1653   }
1654   // 4) otherwise field lookup fails
1655   return NULL;
1656 }
1657 
<span class="line-added">1658 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-added">1659   if (this-&gt;is_value()) {</span>
<span class="line-added">1660     ValueKlass* vk = ValueKlass::cast(this);</span>
<span class="line-added">1661     return offset &gt;= vk-&gt;first_field_offset() &amp;&amp; offset &lt; (vk-&gt;first_field_offset() + vk-&gt;get_exact_size_in_bytes());</span>
<span class="line-added">1662   } else {</span>
<span class="line-added">1663     fieldDescriptor fd;</span>
<span class="line-added">1664     return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-added">1665   }</span>
<span class="line-added">1666 }</span>
1667 
1668 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1669   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1670     if (fs.offset() == offset) {
1671       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1672       if (fd-&gt;is_static() == is_static) return true;
1673     }
1674   }
1675   return false;
1676 }
1677 
1678 
1679 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1680   Klass* klass = const_cast&lt;InstanceKlass*&gt;(this);
1681   while (klass != NULL) {
1682     if (InstanceKlass::cast(klass)-&gt;find_local_field_from_offset(offset, is_static, fd)) {
1683       return true;
1684     }
1685     klass = klass-&gt;super();
1686   }
</pre>
<hr />
<pre>
1743     if (!fd.is_static()) {
1744       fields_sorted[j + 0] = fd.offset();
1745       fields_sorted[j + 1] = i;
1746       j += 2;
1747     }
1748   }
1749   if (j &gt; 0) {
1750     length = j;
1751     // _sort_Fn is defined in growableArray.hpp.
1752     qsort(fields_sorted, length/2, 2*sizeof(int), (_sort_Fn)compare_fields_by_offset);
1753     for (int i = 0; i &lt; length; i += 2) {
1754       fd.reinitialize(this, fields_sorted[i + 1]);
1755       assert(!fd.is_static() &amp;&amp; fd.offset() == fields_sorted[i], &quot;only nonstatic fields&quot;);
1756       cl-&gt;do_field(&amp;fd);
1757     }
1758   }
1759   FREE_C_HEAP_ARRAY(int, fields_sorted);
1760 }
1761 
1762 





1763 void InstanceKlass::array_klasses_do(void f(Klass* k)) {
1764   if (array_klasses() != NULL)
1765     ArrayKlass::cast(array_klasses())-&gt;array_klasses_do(f);
1766 }
1767 
1768 #ifdef ASSERT
1769 static int linear_search(const Array&lt;Method*&gt;* methods,
1770                          const Symbol* name,
1771                          const Symbol* signature) {
1772   const int len = methods-&gt;length();
1773   for (int index = 0; index &lt; len; index++) {
1774     const Method* const m = methods-&gt;at(index);
1775     assert(m-&gt;is_method(), &quot;must be method&quot;);
1776     if (m-&gt;signature() == signature &amp;&amp; m-&gt;name() == name) {
1777        return index;
1778     }
1779   }
1780   return -1;
1781 }
1782 #endif
</pre>
<hr />
<pre>
2026 }
2027 
2028 // uncached_lookup_method searches both the local class methods array and all
2029 // superclasses methods arrays, skipping any overpass methods in superclasses,
2030 // and possibly skipping private methods.
2031 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
2032                                               const Symbol* signature,
2033                                               OverpassLookupMode overpass_mode,
2034                                               PrivateLookupMode private_mode) const {
2035   OverpassLookupMode overpass_local_mode = overpass_mode;
2036   const Klass* klass = this;
2037   while (klass != NULL) {
2038     Method* const method = InstanceKlass::cast(klass)-&gt;find_method_impl(name,
2039                                                                         signature,
2040                                                                         overpass_local_mode,
2041                                                                         find_static,
2042                                                                         private_mode);
2043     if (method != NULL) {
2044       return method;
2045     }
<span class="line-added">2046     if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">2047       break;  // &lt;init&gt; is never inherited, not even as a static factory</span>
<span class="line-added">2048     }</span>
2049     klass = klass-&gt;super();
2050     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
2051   }
2052   return NULL;
2053 }
2054 
2055 #ifdef ASSERT
2056 // search through class hierarchy and return true if this class or
2057 // one of the superclasses was redefined
2058 bool InstanceKlass::has_redefined_this_or_super() const {
2059   const Klass* klass = this;
2060   while (klass != NULL) {
2061     if (InstanceKlass::cast(klass)-&gt;has_been_redefined()) {
2062       return true;
2063     }
2064     klass = klass-&gt;super();
2065   }
2066   return false;
2067 }
2068 #endif
</pre>
<hr />
<pre>
2611 }
2612 
2613 void InstanceKlass::remove_java_mirror() {
2614   Klass::remove_java_mirror();
2615 
2616   // do array classes also.
2617   if (array_klasses() != NULL) {
2618     array_klasses()-&gt;remove_java_mirror();
2619   }
2620 }
2621 
2622 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2623                                              PackageEntry* pkg_entry, TRAPS) {
2624   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2625   // before the InstanceKlass is added to the SystemDictionary. Make
2626   // sure the current state is &lt;loaded.
2627   assert(!is_loaded(), &quot;invalid init state&quot;);
2628   set_package(loader_data, pkg_entry, CHECK);
2629   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2630 
<span class="line-added">2631   if (is_value()) {</span>
<span class="line-added">2632     ValueKlass::cast(this)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">2633   }</span>
<span class="line-added">2634 </span>
2635   Array&lt;Method*&gt;* methods = this-&gt;methods();
2636   int num_methods = methods-&gt;length();
2637   for (int index = 0; index &lt; num_methods; ++index) {
2638     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2639   }
2640   if (JvmtiExport::has_redefined_a_class()) {
2641     // Reinitialize vtable because RedefineClasses may have changed some
2642     // entries in this vtable for super classes so the CDS vtable might
2643     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2644     // vtables in the shared system dictionary, only the main one.
2645     // It also redefines the itable too so fix that too.
2646     vtable().initialize_vtable(false, CHECK);
2647     itable().initialize_itable(false, CHECK);
2648   }
2649 
2650   // restore constant pool resolved references
2651   constants()-&gt;restore_unshareable_info(CHECK);
2652 
2653   if (array_klasses() != NULL) {
2654     // Array classes have null protection domain.
2655     // --&gt; see ArrayKlass::complete_create_array_klass()
2656     ArrayKlass::cast(array_klasses())-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2657   }
2658 
2659   // Initialize current biased locking state.
<span class="line-modified">2660   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {</span>
2661     set_prototype_header(markWord::biased_locking_prototype());
2662   }
2663 }
2664 
2665 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2666   switch (loader_type) {
2667   case ClassLoader::BOOT_LOADER:
2668     _misc_flags |= _misc_is_shared_boot_class;
2669     break;
2670   case ClassLoader::PLATFORM_LOADER:
2671     _misc_flags |= _misc_is_shared_platform_class;
2672     break;
2673   case ClassLoader::APP_LOADER:
2674     _misc_flags |= _misc_is_shared_app_class;
2675     break;
2676   default:
2677     ShouldNotReachHere();
2678     break;
2679   }
2680 }
</pre>
<hr />
<pre>
2758 #if INCLUDE_JVMTI
2759   // Deallocate breakpoint records
2760   if (breakpoints() != 0x0) {
2761     methods_do(clear_all_breakpoints);
2762     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2763   }
2764 
2765   // deallocate the cached class file
2766   if (_cached_class_file != NULL) {
2767     os::free(_cached_class_file);
2768     _cached_class_file = NULL;
2769   }
2770 #endif
2771 
2772   // Decrement symbol reference counts associated with the unloaded class.
2773   if (_name != NULL) _name-&gt;decrement_refcount();
2774 
2775   // unreference array name derived from this class name (arrays of an unloaded
2776   // class can&#39;t be referenced anymore).
2777   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
<span class="line-added">2778   if (_inline_types != NULL) {</span>
<span class="line-added">2779     for (int i = 0; i &lt; _inline_types-&gt;length(); i++) {</span>
<span class="line-added">2780       Symbol* s = _inline_types-&gt;at(i)._class_name;</span>
<span class="line-added">2781       if (s != NULL) {</span>
<span class="line-added">2782         s-&gt;decrement_refcount();</span>
<span class="line-added">2783       }</span>
<span class="line-added">2784     }</span>
<span class="line-added">2785   }</span>
2786   FREE_C_HEAP_ARRAY(char, _source_debug_extension);
2787 }
2788 
2789 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2790   if (array == NULL) {
2791     _source_debug_extension = NULL;
2792   } else {
2793     // Adding one to the attribute length in order to store a null terminator
2794     // character could cause an overflow because the attribute length is
2795     // already coded with an u4 in the classfile, but in practice, it&#39;s
2796     // unlikely to happen.
2797     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
2798     char* sde = NEW_C_HEAP_ARRAY(char, (length + 1), mtClass);
2799     for (int i = 0; i &lt; length; i++) {
2800       sde[i] = array[i];
2801     }
2802     sde[length] = &#39;\0&#39;;
2803     _source_debug_extension = sde;
2804   }
2805 }
2806 
2807 const char* InstanceKlass::signature_name() const {
2808   int hash_len = 0;
2809   char hash_buf[40];
2810 
2811   // If this is an unsafe anonymous class, append a hash to make the name unique
2812   if (is_unsafe_anonymous()) {
2813     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2814     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2815     hash_len = (int)strlen(hash_buf);
2816   }
2817 
2818   // Get the internal name as a c string
2819   const char* src = (const char*) (name()-&gt;as_C_string());
2820   const int src_length = (int)strlen(src);
2821 
2822   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2823 
<span class="line-modified">2824   // Add L or Q as type indicator</span>
2825   int dest_index = 0;
<span class="line-modified">2826   dest[dest_index++] = is_value() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;</span>
2827 
2828   // Add the actual class name
2829   for (int src_index = 0; src_index &lt; src_length; ) {
2830     dest[dest_index++] = src[src_index++];
2831   }
2832 
2833   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.
2834     for (int index = (int)src_length; index &gt; 0; index--) {
2835       if (dest[index] == &#39;+&#39;) {
2836         dest[index] = JVM_SIGNATURE_DOT;
2837         break;
2838       }
2839     }
2840   }
2841 
2842   // If we have a hash, append it
2843   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2844     dest[dest_index++] = hash_buf[hash_index++];
2845   }
2846 
</pre>
<hr />
<pre>
3366   }
3367 
3368   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);
3369   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {
3370     return best;
3371   }
3372   return NULL;
3373 }
3374 
3375 // -----------------------------------------------------------------------------------------------------
3376 // Printing
3377 
3378 #ifndef PRODUCT
3379 
3380 #define BULLET  &quot; - &quot;
3381 
3382 static const char* state_names[] = {
3383   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3384 };
3385 
<span class="line-modified">3386 static void print_vtable(address self, intptr_t* start, int len, outputStream* st) {</span>
<span class="line-added">3387   ResourceMark rm;</span>
<span class="line-added">3388   int* forward_refs = NEW_RESOURCE_ARRAY(int, len);</span>
<span class="line-added">3389   for (int i = 0; i &lt; len; i++)  forward_refs[i] = 0;</span>
3390   for (int i = 0; i &lt; len; i++) {
3391     intptr_t e = start[i];
3392     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);
<span class="line-added">3393     if (forward_refs[i] != 0) {</span>
<span class="line-added">3394       int from = forward_refs[i];</span>
<span class="line-added">3395       int off = (int) start[from];</span>
<span class="line-added">3396       st-&gt;print(&quot; (offset %d &lt;= [%d])&quot;, off, from);</span>
<span class="line-added">3397     }</span>
3398     if (MetaspaceObj::is_valid((Metadata*)e)) {
3399       st-&gt;print(&quot; &quot;);
3400       ((Metadata*)e)-&gt;print_value_on(st);
<span class="line-added">3401     } else if (self != NULL &amp;&amp; e &gt; 0 &amp;&amp; e &lt; 0x10000) {</span>
<span class="line-added">3402       address location = self + e;</span>
<span class="line-added">3403       int index = (int)((intptr_t*)location - start);</span>
<span class="line-added">3404       st-&gt;print(&quot; (offset %d =&gt; [%d])&quot;, (int)e, index);</span>
<span class="line-added">3405       if (index &gt;= 0 &amp;&amp; index &lt; len)</span>
<span class="line-added">3406         forward_refs[index] = i;</span>
3407     }
3408     st-&gt;cr();
3409   }
3410 }
3411 
3412 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="line-modified">3413   return print_vtable(NULL, reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>
<span class="line-added">3414 }</span>
<span class="line-added">3415 </span>
<span class="line-added">3416 template&lt;typename T&gt;</span>
<span class="line-added">3417  static void print_array_on(outputStream* st, Array&lt;T&gt;* array) {</span>
<span class="line-added">3418    if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="line-added">3419    array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3420    if (Verbose || WizardMode) {</span>
<span class="line-added">3421      for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">3422        st-&gt;print(&quot;%d : &quot;, i); array-&gt;at(i)-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3423      }</span>
<span class="line-added">3424    }</span>
<span class="line-added">3425  }</span>
<span class="line-added">3426 </span>
<span class="line-added">3427 static void print_array_on(outputStream* st, Array&lt;int&gt;* array) {</span>
<span class="line-added">3428   if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="line-added">3429   array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3430   if (Verbose || WizardMode) {</span>
<span class="line-added">3431     for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">3432       st-&gt;print(&quot;%d : %d&quot;, i, array-&gt;at(i)); st-&gt;cr();</span>
<span class="line-added">3433     }</span>
<span class="line-added">3434   }</span>
3435 }
3436 
3437 void InstanceKlass::print_on(outputStream* st) const {
3438   assert(is_klass(), &quot;must be klass&quot;);
3439   Klass::print_on(st);
3440 
3441   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3442   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3443   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();
<span class="line-added">3444   st-&gt;print(BULLET&quot;misc flags:        0x%x&quot;, _misc_flags);                        st-&gt;cr();</span>
3445   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3446   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
3447   st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
3448   st-&gt;print(BULLET&quot;sub:               &quot;);
3449   Klass* sub = subklass();
3450   int n;
3451   for (n = 0; sub != NULL; n++, sub = sub-&gt;next_sibling()) {
3452     if (n &lt; MaxSubklassPrintSize) {
3453       sub-&gt;print_value_on(st);
3454       st-&gt;print(&quot;   &quot;);
3455     }
3456   }
3457   if (n &gt;= MaxSubklassPrintSize) st-&gt;print(&quot;(&quot; INTX_FORMAT &quot; more klasses...)&quot;, n - MaxSubklassPrintSize);
3458   st-&gt;cr();
3459 
3460   if (is_interface()) {
3461     st-&gt;print_cr(BULLET&quot;nof implementors:  %d&quot;, nof_implementors());
3462     if (nof_implementors() == 1) {
3463       st-&gt;print_cr(BULLET&quot;implementor:    &quot;);
3464       st-&gt;print(&quot;   &quot;);
3465       implementor()-&gt;print_value_on(st);
3466       st-&gt;cr();
3467     }
3468   }
3469 
3470   st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="line-modified">3471   st-&gt;print(BULLET&quot;methods:           &quot;); print_array_on(st, methods());</span>
<span class="line-modified">3472   st-&gt;print(BULLET&quot;method ordering:   &quot;); print_array_on(st, method_ordering());</span>
<span class="line-modified">3473   st-&gt;print(BULLET&quot;default_methods:   &quot;); print_array_on(st, default_methods());</span>












3474   if (default_vtable_indices() != NULL) {
<span class="line-modified">3475     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); print_array_on(st, default_vtable_indices());</span>
3476   }
<span class="line-modified">3477   st-&gt;print(BULLET&quot;local interfaces:  &quot;); print_array_on(st, local_interfaces());</span>
<span class="line-modified">3478   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); print_array_on(st, transitive_interfaces());</span>
3479   st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
3480   if (class_loader_data() != NULL) {
3481     st-&gt;print(BULLET&quot;class loader data:  &quot;);
3482     class_loader_data()-&gt;print_value_on(st);
3483     st-&gt;cr();
3484   }
3485   st-&gt;print(BULLET&quot;unsafe anonymous host class:        &quot;); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st-&gt;cr();
3486   if (source_file_name() != NULL) {
3487     st-&gt;print(BULLET&quot;source file:       &quot;);
3488     source_file_name()-&gt;print_value_on(st);
3489     st-&gt;cr();
3490   }
3491   if (source_debug_extension() != NULL) {
3492     st-&gt;print(BULLET&quot;source debug extension:       &quot;);
3493     st-&gt;print(&quot;%s&quot;, source_debug_extension());
3494     st-&gt;cr();
3495   }
3496   st-&gt;print(BULLET&quot;class annotations:       &quot;); class_annotations()-&gt;print_value_on(st); st-&gt;cr();
3497   st-&gt;print(BULLET&quot;class type annotations:  &quot;); class_type_annotations()-&gt;print_value_on(st); st-&gt;cr();
3498   st-&gt;print(BULLET&quot;field annotations:       &quot;); fields_annotations()-&gt;print_value_on(st); st-&gt;cr();
</pre>
<hr />
<pre>
3514   if (generic_signature() != NULL) {
3515     st-&gt;print(BULLET&quot;generic signature: &quot;);
3516     generic_signature()-&gt;print_value_on(st);
3517     st-&gt;cr();
3518   }
3519   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3520   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
3521   if (record_components() != NULL) {
3522     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();
3523   }
3524   if (java_mirror() != NULL) {
3525     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3526     java_mirror()-&gt;print_value_on(st);
3527     st-&gt;cr();
3528   } else {
3529     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3530   }
3531   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3532   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3533   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="line-modified">3534   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(NULL, start_of_itable(), itable_length(), st);</span>
3535   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3536   FieldPrinter print_static_field(st);
3537   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3538   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3539   FieldPrinter print_nonstatic_field(st);
3540   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3541   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3542 
3543   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
3544   OopMapBlock* map     = start_of_nonstatic_oop_maps();
3545   OopMapBlock* end_map = map + nonstatic_oop_map_count();
3546   while (map &lt; end_map) {
3547     st-&gt;print(&quot;%d-%d &quot;, map-&gt;offset(), map-&gt;offset() + heapOopSize*(map-&gt;count() - 1));
3548     map++;
3549   }
3550   st-&gt;cr();
3551 }
3552 
3553 #endif //PRODUCT
3554 
</pre>
<hr />
<pre>
4253   if (holder == NULL) {
4254     return NULL; // The version of klass is gone, no method is found
4255   }
4256   Method* method = holder-&gt;method_with_orig_idnum(idnum);
4257   return method;
4258 }
4259 
4260 #if INCLUDE_JVMTI
4261 JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {
4262   return _cached_class_file;
4263 }
4264 
4265 jint InstanceKlass::get_cached_class_file_len() {
4266   return VM_RedefineClasses::get_cached_class_file_len(_cached_class_file);
4267 }
4268 
4269 unsigned char * InstanceKlass::get_cached_class_file_bytes() {
4270   return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
4271 }
4272 #endif
<span class="line-added">4273 </span>
<span class="line-added">4274 #define THROW_DVT_ERROR(s) \</span>
<span class="line-added">4275   Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), \</span>
<span class="line-added">4276       &quot;ValueCapableClass class &#39;%s&#39; %s&quot;, external_name(),(s)); \</span>
<span class="line-added">4277       return</span>
</pre>
</td>
</tr>
</table>
<center><a href="cpCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
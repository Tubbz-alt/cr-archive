<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constantPool.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;

  53 #include &quot;runtime/atomic.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/init.hpp&quot;
  56 #include &quot;runtime/javaCalls.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vframe.inline.hpp&quot;
  60 #include &quot;utilities/copy.hpp&quot;
  61 
  62 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  63   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  64   int size = ConstantPool::size(length);
  65   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  66 }
  67 
  68 #ifdef ASSERT
  69 
  70 // MetaspaceObj allocation invariant is calloc equivalent memory
  71 // simple verification of this here (JVM_CONSTANT_Invalid == 0 )
  72 static bool tag_array_is_zero_initialized(Array&lt;u1&gt;* tags) {
</pre>
<hr />
<pre>
 196   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 197   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 198   set_resolved_klasses(rk);
 199 }
 200 
 201 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 202   int len = length();
 203   int num_klasses = 0;
 204   for (int i = 1; i &lt;len; i++) {
 205     switch (tag_at(i).value()) {
 206     case JVM_CONSTANT_ClassIndex:
 207       {
 208         const int class_index = klass_index_at(i);
 209         unresolved_klass_at_put(i, class_index, num_klasses++);
 210       }
 211       break;
 212 #ifndef PRODUCT
 213     case JVM_CONSTANT_Class:
 214     case JVM_CONSTANT_UnresolvedClass:
 215     case JVM_CONSTANT_UnresolvedClassInError:
<span class="line-modified"> 216       // All of these should have been reverted back to ClassIndex before calling</span>
 217       // this function.
 218       ShouldNotReachHere();
 219 #endif
 220     }
 221   }
 222   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 223 }
 224 
 225 // Unsafe anonymous class support:
 226 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 227   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 228   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 229   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 230   *int_at_addr(class_index) =
 231     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 232 
 233   symbol_at_put(name_index, name);
 234   name-&gt;increment_refcount();
 235   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 236   Atomic::release_store(adr, k);
 237 
 238   // The interpreter assumes when the tag is stored, the klass is resolved
 239   // and the Klass* non-NULL, so we need hardware store ordering here.

 240   if (k != NULL) {
<span class="line-modified"> 241     release_tag_at_put(class_index, JVM_CONSTANT_Class);</span>
 242   } else {
<span class="line-modified"> 243     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass);</span>
 244   }
 245 }
 246 
 247 // Unsafe anonymous class support:
 248 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 249   assert(k != NULL, &quot;must be valid klass&quot;);
 250   CPKlassSlot kslot = klass_slot_at(class_index);
 251   int resolved_klass_index = kslot.resolved_klass_index();
 252   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 253   Atomic::release_store(adr, k);
 254 
 255   // The interpreter assumes when the tag is stored, the klass is resolved
 256   // and the Klass* non-NULL, so we need hardware store ordering here.

 257   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 258 }
 259 
 260 #if INCLUDE_CDS_JAVA_HEAP
 261 // Archive the resolved references
 262 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 263   if (_cache == NULL) {
 264     return; // nothing to do
 265   }
 266 
 267   InstanceKlass *ik = pool_holder();
 268   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 269         ik-&gt;is_shared_app_class())) {
 270     // Archiving resolved references for classes from non-builtin loaders
 271     // is not yet supported.
 272     set_resolved_references(NULL);
 273     return;
 274   }
 275 
 276   objArrayOop rr = resolved_references();
</pre>
<hr />
<pre>
 437       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 438       if (s != NULL) {
 439         source_file = s-&gt;as_C_string();
 440       }
 441     }
 442   }
 443   if (k != this_cp-&gt;pool_holder()) {
 444     // only print something if the classes are different
 445     if (source_file != NULL) {
 446       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 447                  this_cp-&gt;pool_holder()-&gt;external_name(),
 448                  k-&gt;external_name(), source_file, line_number);
 449     } else {
 450       log_debug(class, resolve)(&quot;%s %s&quot;,
 451                  this_cp-&gt;pool_holder()-&gt;external_name(),
 452                  k-&gt;external_name());
 453     }
 454   }
 455 }
 456 






 457 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 458                                    bool save_resolution_error, TRAPS) {
 459   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 460   JavaThread* javaThread = (JavaThread*)THREAD;
 461 
 462   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 463   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 464   // the entry and tag is not updated atomicly.
 465   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 466   int resolved_klass_index = kslot.resolved_klass_index();
 467   int name_index = kslot.name_index();
 468   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 469 
 470   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 471   if (klass != NULL) {
 472     return klass;
 473   }
 474 
 475   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 476   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 477     // The original attempt to resolve this constant pool entry failed so find the
 478     // class of the original error and throw another error of the same class
 479     // (JVMS 5.4.3).
 480     // If there is a detail message, pass that detail message to the error.
 481     // The JVMS does not strictly require us to duplicate the same detail message,
 482     // or any internal exception fields such as cause or stacktrace.  But since the
 483     // detail message is often a class name or other literal string, we will repeat it
 484     // if we can find it in the symbol table.
 485     throw_resolution_error(this_cp, which, CHECK_NULL);
 486     ShouldNotReachHere();
 487   }
 488 
 489   Handle mirror_handle;
 490   Symbol* name = this_cp-&gt;symbol_at(name_index);





 491   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 492   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 493 
 494   Klass* k;
 495   {
 496     // Turn off the single stepping while doing class resolution
 497     JvmtiHideSingleStepping jhss(javaThread);
 498     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 499   } //  JvmtiHideSingleStepping jhss(javaThread);



 500 
 501   if (!HAS_PENDING_EXCEPTION) {
 502     // preserve the resolved klass from unloading
 503     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 504     // Do access check for klasses
 505     verify_constant_pool_resolve(this_cp, k, THREAD);
 506   }
 507 
















 508   // Failed to resolve class. We must record the errors so that subsequent attempts
 509   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 510   if (HAS_PENDING_EXCEPTION) {
 511     if (save_resolution_error) {
 512       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 513       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 514       // some other thread has beaten us and has resolved the class.
 515       // To preserve old behavior, we return the resolved class.
 516       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 517       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 518       return klass;
 519     } else {
 520       return NULL;  // return the pending exception
 521     }
 522   }
 523 
 524   // logging for class+resolve.
 525   if (log_is_enabled(Debug, class, resolve)){
 526     trace_class_resolution(this_cp, k);
 527   }
 528   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 529   Atomic::release_store(adr, k);
 530   // The interpreter assumes when the tag is stored, the klass is resolved
 531   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 532   // hardware store ordering here.
<span class="line-modified"> 533   this_cp-&gt;release_tag_at_put(which, JVM_CONSTANT_Class);</span>




 534   return k;
 535 }
 536 
 537 
 538 // Does not update ConstantPool* - to avoid any exception throwing. Used
 539 // by compiler and exception handling.  Also used to avoid classloads for
 540 // instanceof operations. Returns NULL if the class has not been loaded or
 541 // if the verification of constant pool failed
 542 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 543   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 544   int resolved_klass_index = kslot.resolved_klass_index();
 545   int name_index = kslot.name_index();
 546   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 547 
 548   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 549   if (k != NULL) {
 550     return k;
 551   } else {
 552     Thread *thread = Thread::current();
 553     Symbol* name = this_cp-&gt;symbol_at(name_index);
</pre>
<hr />
<pre>
1837       case JVM_CONSTANT_Long: {
1838         u8 val = Bytes::get_Java_u8(bytes);
1839         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1840         ent_size = 8;
1841         idx++; // Long takes two cpool slots
1842         break;
1843       }
1844       case JVM_CONSTANT_Double: {
1845         u8 val = Bytes::get_Java_u8(bytes);
1846         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1847         ent_size = 8;
1848         idx++; // Double takes two cpool slots
1849         break;
1850       }
1851       case JVM_CONSTANT_Class: {
1852         idx1 = Bytes::get_Java_u2(bytes);
1853         printf(&quot;class        #%03d&quot;, idx1);
1854         ent_size = 2;
1855         break;
1856       }






1857       case JVM_CONSTANT_String: {
1858         idx1 = Bytes::get_Java_u2(bytes);
1859         printf(&quot;String       #%03d&quot;, idx1);
1860         ent_size = 2;
1861         break;
1862       }
1863       case JVM_CONSTANT_Fieldref: {
1864         idx1 = Bytes::get_Java_u2(bytes);
1865         idx2 = Bytes::get_Java_u2(bytes+2);
1866         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1867         ent_size = 4;
1868         break;
1869       }
1870       case JVM_CONSTANT_Methodref: {
1871         idx1 = Bytes::get_Java_u2(bytes);
1872         idx2 = Bytes::get_Java_u2(bytes+2);
1873         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1874         ent_size = 4;
1875         break;
1876       }
</pre>
<hr />
<pre>
1879         idx2 = Bytes::get_Java_u2(bytes+2);
1880         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1881         ent_size = 4;
1882         break;
1883       }
1884       case JVM_CONSTANT_NameAndType: {
1885         idx1 = Bytes::get_Java_u2(bytes);
1886         idx2 = Bytes::get_Java_u2(bytes+2);
1887         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1888         ent_size = 4;
1889         break;
1890       }
1891       case JVM_CONSTANT_ClassIndex: {
1892         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1893         break;
1894       }
1895       case JVM_CONSTANT_UnresolvedClass: {
1896         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1897         break;
1898       }




1899       case JVM_CONSTANT_UnresolvedClassInError: {
1900         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1901         break;
1902       }
1903       case JVM_CONSTANT_StringIndex: {
1904         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1905         break;
1906       }
1907     }
1908     printf(&quot;;\n&quot;);
1909     bytes += ent_size;
1910     size  += ent_size;
1911   }
1912   printf(&quot;Cpool size: %d\n&quot;, size);
1913   fflush(0);
1914   return;
1915 } /* end print_cpool_bytes */
1916 
1917 
1918 // Returns size of constant pool entry.
</pre>
<hr />
<pre>
2050       case JVM_CONSTANT_Float: {
2051         jfloat val = float_at(idx);
2052         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2053         break;
2054       }
2055       case JVM_CONSTANT_Long: {
2056         jlong val = long_at(idx);
2057         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2058         idx++;             // Long takes two cpool slots
2059         break;
2060       }
2061       case JVM_CONSTANT_Double: {
2062         jdouble val = double_at(idx);
2063         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2064         idx++;             // Double takes two cpool slots
2065         break;
2066       }
2067       case JVM_CONSTANT_Class:
2068       case JVM_CONSTANT_UnresolvedClass:
2069       case JVM_CONSTANT_UnresolvedClassInError: {

2070         *bytes = JVM_CONSTANT_Class;
2071         Symbol* sym = klass_name_at(idx);
2072         idx1 = tbl-&gt;symbol_to_value(sym);
2073         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2074         Bytes::put_Java_u2((address) (bytes+1), idx1);
2075         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2076         break;
2077       }
2078       case JVM_CONSTANT_String: {
2079         *bytes = JVM_CONSTANT_String;
2080         Symbol* sym = unresolved_string_at(idx);
2081         idx1 = tbl-&gt;symbol_to_value(sym);
2082         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2083         Bytes::put_Java_u2((address) (bytes+1), idx1);
2084         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2085         break;
2086       }
2087       case JVM_CONSTANT_Fieldref:
2088       case JVM_CONSTANT_Methodref:
2089       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
</td>
<td>
<hr />
<pre>
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  53 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
  54 #include &quot;runtime/atomic.hpp&quot;
  55 #include &quot;runtime/handles.inline.hpp&quot;
  56 #include &quot;runtime/init.hpp&quot;
  57 #include &quot;runtime/javaCalls.hpp&quot;
  58 #include &quot;runtime/signature.hpp&quot;
  59 #include &quot;runtime/thread.inline.hpp&quot;
  60 #include &quot;runtime/vframe.inline.hpp&quot;
  61 #include &quot;utilities/copy.hpp&quot;
  62 
  63 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  64   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  65   int size = ConstantPool::size(length);
  66   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  67 }
  68 
  69 #ifdef ASSERT
  70 
  71 // MetaspaceObj allocation invariant is calloc equivalent memory
  72 // simple verification of this here (JVM_CONSTANT_Invalid == 0 )
  73 static bool tag_array_is_zero_initialized(Array&lt;u1&gt;* tags) {
</pre>
<hr />
<pre>
 197   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 198   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 199   set_resolved_klasses(rk);
 200 }
 201 
 202 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 203   int len = length();
 204   int num_klasses = 0;
 205   for (int i = 1; i &lt;len; i++) {
 206     switch (tag_at(i).value()) {
 207     case JVM_CONSTANT_ClassIndex:
 208       {
 209         const int class_index = klass_index_at(i);
 210         unresolved_klass_at_put(i, class_index, num_klasses++);
 211       }
 212       break;
 213 #ifndef PRODUCT
 214     case JVM_CONSTANT_Class:
 215     case JVM_CONSTANT_UnresolvedClass:
 216     case JVM_CONSTANT_UnresolvedClassInError:
<span class="line-modified"> 217       // All of these should have been reverted back to Unresolved before calling</span>
 218       // this function.
 219       ShouldNotReachHere();
 220 #endif
 221     }
 222   }
 223   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 224 }
 225 
 226 // Unsafe anonymous class support:
 227 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 228   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 229   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 230   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 231   *int_at_addr(class_index) =
 232     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 233 
 234   symbol_at_put(name_index, name);
 235   name-&gt;increment_refcount();
 236   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 237   Atomic::release_store(adr, k);
 238 
 239   // The interpreter assumes when the tag is stored, the klass is resolved
 240   // and the Klass* non-NULL, so we need hardware store ordering here.
<span class="line-added"> 241   jbyte qdesc_bit = (name-&gt;is_Q_signature()) ? (jbyte) JVM_CONSTANT_QDescBit : 0;</span>
 242   if (k != NULL) {
<span class="line-modified"> 243     release_tag_at_put(class_index, JVM_CONSTANT_Class | qdesc_bit);</span>
 244   } else {
<span class="line-modified"> 245     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);</span>
 246   }
 247 }
 248 
 249 // Unsafe anonymous class support:
 250 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 251   assert(k != NULL, &quot;must be valid klass&quot;);
 252   CPKlassSlot kslot = klass_slot_at(class_index);
 253   int resolved_klass_index = kslot.resolved_klass_index();
 254   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 255   Atomic::release_store(adr, k);
 256 
 257   // The interpreter assumes when the tag is stored, the klass is resolved
 258   // and the Klass* non-NULL, so we need hardware store ordering here.
<span class="line-added"> 259   assert(!k-&gt;name()-&gt;is_Q_signature(), &quot;Q-type without JVM_CONSTANT_QDescBit&quot;);</span>
 260   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 261 }
 262 
 263 #if INCLUDE_CDS_JAVA_HEAP
 264 // Archive the resolved references
 265 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 266   if (_cache == NULL) {
 267     return; // nothing to do
 268   }
 269 
 270   InstanceKlass *ik = pool_holder();
 271   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 272         ik-&gt;is_shared_app_class())) {
 273     // Archiving resolved references for classes from non-builtin loaders
 274     // is not yet supported.
 275     set_resolved_references(NULL);
 276     return;
 277   }
 278 
 279   objArrayOop rr = resolved_references();
</pre>
<hr />
<pre>
 440       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 441       if (s != NULL) {
 442         source_file = s-&gt;as_C_string();
 443       }
 444     }
 445   }
 446   if (k != this_cp-&gt;pool_holder()) {
 447     // only print something if the classes are different
 448     if (source_file != NULL) {
 449       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 450                  this_cp-&gt;pool_holder()-&gt;external_name(),
 451                  k-&gt;external_name(), source_file, line_number);
 452     } else {
 453       log_debug(class, resolve)(&quot;%s %s&quot;,
 454                  this_cp-&gt;pool_holder()-&gt;external_name(),
 455                  k-&gt;external_name());
 456     }
 457   }
 458 }
 459 
<span class="line-added"> 460 void check_is_inline_type(Klass* k, TRAPS) {</span>
<span class="line-added"> 461   if (!k-&gt;is_value()) {</span>
<span class="line-added"> 462     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added"> 463   }</span>
<span class="line-added"> 464 }</span>
<span class="line-added"> 465 </span>
 466 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 467                                    bool save_resolution_error, TRAPS) {
 468   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 469   JavaThread* javaThread = (JavaThread*)THREAD;
 470 
 471   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 472   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 473   // the entry and tag is not updated atomicly.
 474   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 475   int resolved_klass_index = kslot.resolved_klass_index();
 476   int name_index = kslot.name_index();
 477   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 478 
 479   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 480   if (klass != NULL) {
 481     return klass;
 482   }
 483 
 484   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 485   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 486     // The original attempt to resolve this constant pool entry failed so find the
 487     // class of the original error and throw another error of the same class
 488     // (JVMS 5.4.3).
 489     // If there is a detail message, pass that detail message to the error.
 490     // The JVMS does not strictly require us to duplicate the same detail message,
 491     // or any internal exception fields such as cause or stacktrace.  But since the
 492     // detail message is often a class name or other literal string, we will repeat it
 493     // if we can find it in the symbol table.
 494     throw_resolution_error(this_cp, which, CHECK_NULL);
 495     ShouldNotReachHere();
 496   }
 497 
 498   Handle mirror_handle;
 499   Symbol* name = this_cp-&gt;symbol_at(name_index);
<span class="line-added"> 500   bool inline_type_signature = false;</span>
<span class="line-added"> 501   if (name-&gt;is_Q_signature()) {</span>
<span class="line-added"> 502     name = name-&gt;fundamental_name(THREAD);</span>
<span class="line-added"> 503     inline_type_signature = true;</span>
<span class="line-added"> 504   }</span>
 505   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 506   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 507 
 508   Klass* k;
 509   {
 510     // Turn off the single stepping while doing class resolution
 511     JvmtiHideSingleStepping jhss(javaThread);
 512     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 513   } //  JvmtiHideSingleStepping jhss(javaThread);
<span class="line-added"> 514   if (inline_type_signature) {</span>
<span class="line-added"> 515     name-&gt;decrement_refcount();</span>
<span class="line-added"> 516   }</span>
 517 
 518   if (!HAS_PENDING_EXCEPTION) {
 519     // preserve the resolved klass from unloading
 520     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 521     // Do access check for klasses
 522     verify_constant_pool_resolve(this_cp, k, THREAD);
 523   }
 524 
<span class="line-added"> 525   if (!HAS_PENDING_EXCEPTION &amp;&amp; inline_type_signature) {</span>
<span class="line-added"> 526     check_is_inline_type(k, THREAD);</span>
<span class="line-added"> 527   }</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529   if (!HAS_PENDING_EXCEPTION) {</span>
<span class="line-added"> 530     Klass* bottom_klass = NULL;</span>
<span class="line-added"> 531     if (k-&gt;is_objArray_klass()) {</span>
<span class="line-added"> 532       bottom_klass = ObjArrayKlass::cast(k)-&gt;bottom_klass();</span>
<span class="line-added"> 533       assert(bottom_klass != NULL, &quot;Should be set&quot;);</span>
<span class="line-added"> 534       assert(bottom_klass-&gt;is_instance_klass() || bottom_klass-&gt;is_typeArray_klass(), &quot;Sanity check&quot;);</span>
<span class="line-added"> 535     } else if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 536       bottom_klass = ValueArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added"> 537       assert(bottom_klass != NULL, &quot;Should be set&quot;);</span>
<span class="line-added"> 538     }</span>
<span class="line-added"> 539   }</span>
<span class="line-added"> 540 </span>
 541   // Failed to resolve class. We must record the errors so that subsequent attempts
 542   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 543   if (HAS_PENDING_EXCEPTION) {
 544     if (save_resolution_error) {
 545       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 546       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 547       // some other thread has beaten us and has resolved the class.
 548       // To preserve old behavior, we return the resolved class.
 549       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 550       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 551       return klass;
 552     } else {
 553       return NULL;  // return the pending exception
 554     }
 555   }
 556 
 557   // logging for class+resolve.
 558   if (log_is_enabled(Debug, class, resolve)){
 559     trace_class_resolution(this_cp, k);
 560   }
 561   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 562   Atomic::release_store(adr, k);
 563   // The interpreter assumes when the tag is stored, the klass is resolved
 564   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 565   // hardware store ordering here.
<span class="line-modified"> 566   jbyte tag = JVM_CONSTANT_Class;</span>
<span class="line-added"> 567   if (this_cp-&gt;tag_at(which).is_Qdescriptor_klass()) {</span>
<span class="line-added"> 568     tag |= JVM_CONSTANT_QDescBit;</span>
<span class="line-added"> 569   }</span>
<span class="line-added"> 570   this_cp-&gt;release_tag_at_put(which, tag);</span>
 571   return k;
 572 }
 573 
 574 
 575 // Does not update ConstantPool* - to avoid any exception throwing. Used
 576 // by compiler and exception handling.  Also used to avoid classloads for
 577 // instanceof operations. Returns NULL if the class has not been loaded or
 578 // if the verification of constant pool failed
 579 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 580   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 581   int resolved_klass_index = kslot.resolved_klass_index();
 582   int name_index = kslot.name_index();
 583   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 584 
 585   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 586   if (k != NULL) {
 587     return k;
 588   } else {
 589     Thread *thread = Thread::current();
 590     Symbol* name = this_cp-&gt;symbol_at(name_index);
</pre>
<hr />
<pre>
1874       case JVM_CONSTANT_Long: {
1875         u8 val = Bytes::get_Java_u8(bytes);
1876         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1877         ent_size = 8;
1878         idx++; // Long takes two cpool slots
1879         break;
1880       }
1881       case JVM_CONSTANT_Double: {
1882         u8 val = Bytes::get_Java_u8(bytes);
1883         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1884         ent_size = 8;
1885         idx++; // Double takes two cpool slots
1886         break;
1887       }
1888       case JVM_CONSTANT_Class: {
1889         idx1 = Bytes::get_Java_u2(bytes);
1890         printf(&quot;class        #%03d&quot;, idx1);
1891         ent_size = 2;
1892         break;
1893       }
<span class="line-added">1894       case (JVM_CONSTANT_Class | JVM_CONSTANT_QDescBit): {</span>
<span class="line-added">1895         idx1 = Bytes::get_Java_u2(bytes);</span>
<span class="line-added">1896         printf(&quot;qclass        #%03d&quot;, idx1);</span>
<span class="line-added">1897         ent_size = 2;</span>
<span class="line-added">1898         break;</span>
<span class="line-added">1899       }</span>
1900       case JVM_CONSTANT_String: {
1901         idx1 = Bytes::get_Java_u2(bytes);
1902         printf(&quot;String       #%03d&quot;, idx1);
1903         ent_size = 2;
1904         break;
1905       }
1906       case JVM_CONSTANT_Fieldref: {
1907         idx1 = Bytes::get_Java_u2(bytes);
1908         idx2 = Bytes::get_Java_u2(bytes+2);
1909         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1910         ent_size = 4;
1911         break;
1912       }
1913       case JVM_CONSTANT_Methodref: {
1914         idx1 = Bytes::get_Java_u2(bytes);
1915         idx2 = Bytes::get_Java_u2(bytes+2);
1916         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1917         ent_size = 4;
1918         break;
1919       }
</pre>
<hr />
<pre>
1922         idx2 = Bytes::get_Java_u2(bytes+2);
1923         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1924         ent_size = 4;
1925         break;
1926       }
1927       case JVM_CONSTANT_NameAndType: {
1928         idx1 = Bytes::get_Java_u2(bytes);
1929         idx2 = Bytes::get_Java_u2(bytes+2);
1930         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1931         ent_size = 4;
1932         break;
1933       }
1934       case JVM_CONSTANT_ClassIndex: {
1935         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1936         break;
1937       }
1938       case JVM_CONSTANT_UnresolvedClass: {
1939         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1940         break;
1941       }
<span class="line-added">1942       case (JVM_CONSTANT_UnresolvedClass | JVM_CONSTANT_QDescBit): {</span>
<span class="line-added">1943         printf(&quot;UnresolvedQClass: %s&quot;, WARN_MSG);</span>
<span class="line-added">1944         break;</span>
<span class="line-added">1945       }</span>
1946       case JVM_CONSTANT_UnresolvedClassInError: {
1947         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1948         break;
1949       }
1950       case JVM_CONSTANT_StringIndex: {
1951         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1952         break;
1953       }
1954     }
1955     printf(&quot;;\n&quot;);
1956     bytes += ent_size;
1957     size  += ent_size;
1958   }
1959   printf(&quot;Cpool size: %d\n&quot;, size);
1960   fflush(0);
1961   return;
1962 } /* end print_cpool_bytes */
1963 
1964 
1965 // Returns size of constant pool entry.
</pre>
<hr />
<pre>
2097       case JVM_CONSTANT_Float: {
2098         jfloat val = float_at(idx);
2099         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2100         break;
2101       }
2102       case JVM_CONSTANT_Long: {
2103         jlong val = long_at(idx);
2104         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2105         idx++;             // Long takes two cpool slots
2106         break;
2107       }
2108       case JVM_CONSTANT_Double: {
2109         jdouble val = double_at(idx);
2110         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2111         idx++;             // Double takes two cpool slots
2112         break;
2113       }
2114       case JVM_CONSTANT_Class:
2115       case JVM_CONSTANT_UnresolvedClass:
2116       case JVM_CONSTANT_UnresolvedClassInError: {
<span class="line-added">2117         assert(!tag_at(idx).is_Qdescriptor_klass(), &quot;Failed to encode QDesc&quot;);</span>
2118         *bytes = JVM_CONSTANT_Class;
2119         Symbol* sym = klass_name_at(idx);
2120         idx1 = tbl-&gt;symbol_to_value(sym);
2121         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2122         Bytes::put_Java_u2((address) (bytes+1), idx1);
2123         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2124         break;
2125       }
2126       case JVM_CONSTANT_String: {
2127         *bytes = JVM_CONSTANT_String;
2128         Symbol* sym = unresolved_string_at(idx);
2129         idx1 = tbl-&gt;symbol_to_value(sym);
2130         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2131         Bytes::put_Java_u2((address) (bytes+1), idx1);
2132         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2133         break;
2134       }
2135       case JVM_CONSTANT_Fieldref:
2136       case JVM_CONSTANT_Methodref:
2137       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
</td>
</tr>
</table>
<center><a href="arrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
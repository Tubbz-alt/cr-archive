<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gc/parallel/psParallelCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jvmci/jvmciCodeInstaller.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 947     Exceptions::fthrow(THREAD_AND_LOCATION,
 948                        vmSymbols::java_lang_IllegalAccessError(),
 949                        &quot;%s&quot;,
 950                        ss.as_string()
 951                        );
 952     return;
 953   }
 954 }
 955 
 956 void LinkResolver::resolve_field_access(fieldDescriptor&amp; fd, const constantPoolHandle&amp; pool, int index, const methodHandle&amp; method, Bytecodes::Code byte, TRAPS) {
 957   LinkInfo link_info(pool, index, method, CHECK);
 958   resolve_field(fd, link_info, byte, true, CHECK);
 959 }
 960 
 961 void LinkResolver::resolve_field(fieldDescriptor&amp; fd,
 962                                  const LinkInfo&amp; link_info,
 963                                  Bytecodes::Code byte, bool initialize_class,
 964                                  TRAPS) {
 965   assert(byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic ||
 966          byte == Bytecodes::_getfield  || byte == Bytecodes::_putfield  ||

 967          byte == Bytecodes::_nofast_getfield  || byte == Bytecodes::_nofast_putfield  ||
 968          (byte == Bytecodes::_nop &amp;&amp; !link_info.check_access()), &quot;bad field access bytecode&quot;);
 969 
 970   bool is_static = (byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic);
<span class="line-modified"> 971   bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic || byte == Bytecodes::_nofast_putfield);</span>

 972   // Check if there&#39;s a resolved klass containing the field
 973   Klass* resolved_klass = link_info.resolved_klass();
 974   Symbol* field = link_info.name();
 975   Symbol* sig = link_info.signature();
 976 
 977   if (resolved_klass == NULL) {
 978     ResourceMark rm(THREAD);
 979     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 980   }
 981 
 982   // Resolve instance field
 983   Klass* sel_klass = resolved_klass-&gt;find_field(field, sig, &amp;fd);
 984   // check if field exists; i.e., if a klass containing the field def has been selected
 985   if (sel_klass == NULL) {
 986     ResourceMark rm(THREAD);
 987     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 988   }
 989 
 990   // Access checking may be turned off when calling from within the VM.
 991   Klass* current_klass = link_info.current_klass();
 992   if (link_info.check_access()) {
 993 
 994     // check access
 995     check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
 996 
 997     // check for errors
 998     if (is_static != fd.is_static()) {
 999       ResourceMark rm(THREAD);
1000       char msg[200];
1001       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
1002       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
1003     }
1004 
1005     // A final field can be modified only
1006     // (1) by methods declared in the class declaring the field and
1007     // (2) by the &lt;clinit&gt; method (in case of a static field)
1008     //     or by the &lt;init&gt; method (in case of an instance field).


1009     if (is_put &amp;&amp; fd.access_flags().is_final()) {
1010 
1011       if (sel_klass != current_klass) {









1012         ResourceMark rm(THREAD);
1013         stringStream ss;
1014         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
1015                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
<span class="line-modified">1016                 current_klass-&gt;external_name());</span>
1017         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1018       }

1019 
1020       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
1021         Method* m = link_info.current_method();
1022         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);
1023         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1024                                                    fd.is_static() &amp;&amp;
<span class="line-modified">1025                                                    !m-&gt;is_static_initializer());</span>
1026         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1027                                                      !fd.is_static() &amp;&amp;
<span class="line-modified">1028                                                      !m-&gt;is_object_initializer());</span>
1029 
1030         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
1031           ResourceMark rm(THREAD);
1032           stringStream ss;
1033           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1034                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1035                    m-&gt;name()-&gt;as_C_string(),
1036                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1037           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1038         }
1039       }
1040     }
1041 
1042     // initialize resolved_klass if necessary
1043     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1044     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1045     //
1046     // note 2: we don&#39;t want to force initialization if we are just checking
1047     //         if the field access is legal; e.g., during compilation
1048     if (is_static &amp;&amp; initialize_class) {
</pre>
<hr />
<pre>
1127 
1128 // throws linktime exceptions
1129 Method* LinkResolver::linktime_resolve_special_method(const LinkInfo&amp; link_info, TRAPS) {
1130 
1131   // Invokespecial is called for multiple special reasons:
1132   // &lt;init&gt;
1133   // local private method invocation, for classes and interfaces
1134   // superclass.method, which can also resolve to a default method
1135   // and the selected method is recalculated relative to the direct superclass
1136   // superinterface.method, which explicitly does not check shadowing
1137   Klass* resolved_klass = link_info.resolved_klass();
1138   Method* resolved_method;
1139 
1140   if (!resolved_klass-&gt;is_interface()) {
1141     resolved_method = resolve_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1142   } else {
1143     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1144   }
1145 
1146   // check if method name is &lt;init&gt;, that it is found in same klass as static type


1147   if (resolved_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
1148       resolved_method-&gt;method_holder() != resolved_klass) {
1149     ResourceMark rm(THREAD);
1150     stringStream ss;
1151     ss.print(&quot;%s: method &#39;&quot;, resolved_klass-&gt;external_name());
1152     resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);
1153     ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());
1154     resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);
1155     ss.print(&quot;)&#39; not found&quot;);
1156     Exceptions::fthrow(
1157       THREAD_AND_LOCATION,
1158       vmSymbols::java_lang_NoSuchMethodError(),
1159       &quot;%s&quot;, ss.as_string());
1160     return NULL;
1161   }
1162 
1163   // ensure that invokespecial&#39;s interface method reference is in
1164   // a direct superinterface, not an indirect superinterface
1165   Klass* current_klass = link_info.current_klass();
1166   if (current_klass != NULL &amp;&amp; resolved_klass-&gt;is_interface()) {
</pre>
<hr />
<pre>
1200   }
1201 
1202   return resolved_method;
1203 }
1204 
1205 // throws runtime exceptions
1206 void LinkResolver::runtime_resolve_special_method(CallInfo&amp; result,
1207                                                   const LinkInfo&amp; link_info,
1208                                                   const methodHandle&amp; resolved_method,
1209                                                   Handle recv, TRAPS) {
1210 
1211   Klass* resolved_klass = link_info.resolved_klass();
1212 
1213   // resolved method is selected method unless we have an old-style lookup
1214   // for a superclass method
1215   // Invokespecial for a superinterface, resolved method is selected method,
1216   // no checks for shadowing
1217   methodHandle sel_method(THREAD, resolved_method());
1218 
1219   if (link_info.check_access() &amp;&amp;
<span class="line-modified">1220       // check if the method is not &lt;init&gt;</span>
1221       resolved_method-&gt;name() != vmSymbols::object_initializer_name()) {
1222 
1223     Klass* current_klass = link_info.current_klass();
1224 
1225     // Check if the class of the resolved_klass is a superclass
1226     // (not supertype in order to exclude interface classes) of the current class.
1227     // This check is not performed for super.invoke for interface methods
1228     // in super interfaces.
1229     if (current_klass-&gt;is_subclass_of(resolved_klass) &amp;&amp;
1230         current_klass != resolved_klass) {
1231       // Lookup super method
1232       Klass* super_klass = current_klass-&gt;super();
1233       Method* instance_method = lookup_instance_method_in_klasses(super_klass,
1234                                                      resolved_method-&gt;name(),
1235                                                      resolved_method-&gt;signature(),
1236                                                      Klass::find_private, CHECK);
1237       sel_method = methodHandle(THREAD, instance_method);
1238 
1239       // check if found
1240       if (sel_method.is_null()) {
</pre>
<hr />
<pre>
1620 
1621 
1622 
1623 //------------------------------------------------------------------------------------------------------------------------
1624 // ConstantPool entries
1625 
1626 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, Bytecodes::Code byte, TRAPS) {
1627   switch (byte) {
1628     case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;
1629     case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index, CHECK); break;
1630     case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;
1631     case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;
1632     case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;
1633     case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;
1634     default                         :                                                            break;
1635   }
1636   return;
1637 }
1638 
1639 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
<span class="line-modified">1640                              const methodHandle&amp; attached_method,</span>
<span class="line-modified">1641                              Bytecodes::Code byte, TRAPS) {</span>
1642   Klass* defc = attached_method-&gt;method_holder();
1643   Symbol* name = attached_method-&gt;name();
1644   Symbol* type = attached_method-&gt;signature();
1645   LinkInfo link_info(defc, name, type);

1646   switch(byte) {
1647     case Bytecodes::_invokevirtual:
<span class="line-modified">1648       resolve_virtual_call(result, recv, recv-&gt;klass(), link_info,</span>
<span class="line-modified">1649                            /*check_null_and_abstract=*/true, CHECK);</span>
1650       break;
1651     case Bytecodes::_invokeinterface:
<span class="line-modified">1652       resolve_interface_call(result, recv, recv-&gt;klass(), link_info,</span>
<span class="line-modified">1653                              /*check_null_and_abstract=*/true, CHECK);</span>
1654       break;
1655     case Bytecodes::_invokestatic:
1656       resolve_static_call(result, link_info, /*initialize_class=*/false, CHECK);
1657       break;
1658     case Bytecodes::_invokespecial:
1659       resolve_special_call(result, recv, link_info, CHECK);
1660       break;
1661     default:
1662       fatal(&quot;bad call: %s&quot;, Bytecodes::name(byte));
1663       break;
1664   }
1665 }
1666 
1667 void LinkResolver::resolve_invokestatic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1668   LinkInfo link_info(pool, index, CHECK);
1669   resolve_static_call(result, link_info, /*initialize_class*/true, CHECK);
1670 }
1671 
1672 
1673 void LinkResolver::resolve_invokespecial(CallInfo&amp; result, Handle recv,
</pre>
</td>
<td>
<hr />
<pre>
 947     Exceptions::fthrow(THREAD_AND_LOCATION,
 948                        vmSymbols::java_lang_IllegalAccessError(),
 949                        &quot;%s&quot;,
 950                        ss.as_string()
 951                        );
 952     return;
 953   }
 954 }
 955 
 956 void LinkResolver::resolve_field_access(fieldDescriptor&amp; fd, const constantPoolHandle&amp; pool, int index, const methodHandle&amp; method, Bytecodes::Code byte, TRAPS) {
 957   LinkInfo link_info(pool, index, method, CHECK);
 958   resolve_field(fd, link_info, byte, true, CHECK);
 959 }
 960 
 961 void LinkResolver::resolve_field(fieldDescriptor&amp; fd,
 962                                  const LinkInfo&amp; link_info,
 963                                  Bytecodes::Code byte, bool initialize_class,
 964                                  TRAPS) {
 965   assert(byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic ||
 966          byte == Bytecodes::_getfield  || byte == Bytecodes::_putfield  ||
<span class="line-added"> 967          byte == Bytecodes::_withfield ||</span>
 968          byte == Bytecodes::_nofast_getfield  || byte == Bytecodes::_nofast_putfield  ||
 969          (byte == Bytecodes::_nop &amp;&amp; !link_info.check_access()), &quot;bad field access bytecode&quot;);
 970 
 971   bool is_static = (byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic);
<span class="line-modified"> 972   bool is_put    = (byte == Bytecodes::_putfield  || byte == Bytecodes::_putstatic ||</span>
<span class="line-added"> 973                     byte == Bytecodes::_nofast_putfield || byte == Bytecodes::_withfield);</span>
 974   // Check if there&#39;s a resolved klass containing the field
 975   Klass* resolved_klass = link_info.resolved_klass();
 976   Symbol* field = link_info.name();
 977   Symbol* sig = link_info.signature();
 978 
 979   if (resolved_klass == NULL) {
 980     ResourceMark rm(THREAD);
 981     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 982   }
 983 
 984   // Resolve instance field
 985   Klass* sel_klass = resolved_klass-&gt;find_field(field, sig, &amp;fd);
 986   // check if field exists; i.e., if a klass containing the field def has been selected
 987   if (sel_klass == NULL) {
 988     ResourceMark rm(THREAD);
 989     THROW_MSG(vmSymbols::java_lang_NoSuchFieldError(), field-&gt;as_C_string());
 990   }
 991 
 992   // Access checking may be turned off when calling from within the VM.
 993   Klass* current_klass = link_info.current_klass();
 994   if (link_info.check_access()) {
 995 
 996     // check access
 997     check_field_accessability(current_klass, resolved_klass, sel_klass, fd, CHECK);
 998 
 999     // check for errors
1000     if (is_static != fd.is_static()) {
1001       ResourceMark rm(THREAD);
1002       char msg[200];
1003       jio_snprintf(msg, sizeof(msg), &quot;Expected %s field %s.%s&quot;, is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string());
1004       THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(), msg);
1005     }
1006 
1007     // A final field can be modified only
1008     // (1) by methods declared in the class declaring the field and
1009     // (2) by the &lt;clinit&gt; method (in case of a static field)
1010     //     or by the &lt;init&gt; method (in case of an instance field).
<span class="line-added">1011     // (3) by withfield when field is in a value type and the</span>
<span class="line-added">1012     //     selected class and current class are nest mates.</span>
1013     if (is_put &amp;&amp; fd.access_flags().is_final()) {
1014 
1015       if (sel_klass != current_klass) {
<span class="line-added">1016       // If byte code is a withfield check if they are nestmates.</span>
<span class="line-added">1017       bool are_nestmates = false;</span>
<span class="line-added">1018       if (sel_klass-&gt;is_instance_klass() &amp;&amp;</span>
<span class="line-added">1019           InstanceKlass::cast(sel_klass)-&gt;is_value() &amp;&amp;</span>
<span class="line-added">1020           current_klass-&gt;is_instance_klass()) {</span>
<span class="line-added">1021         are_nestmates = InstanceKlass::cast(link_info.current_klass())-&gt;has_nestmate_access_to(</span>
<span class="line-added">1022                                                         InstanceKlass::cast(sel_klass), THREAD);</span>
<span class="line-added">1023       }</span>
<span class="line-added">1024       if (!are_nestmates) {</span>
1025         ResourceMark rm(THREAD);
1026         stringStream ss;
1027         ss.print(&quot;Update to %s final field %s.%s attempted from a different class (%s) than the field&#39;s declaring class&quot;,
1028                  is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
<span class="line-modified">1029                   current_klass-&gt;external_name());</span>
1030         THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1031       }
<span class="line-added">1032       }</span>
1033 
1034       if (fd.constants()-&gt;pool_holder()-&gt;major_version() &gt;= 53) {
1035         Method* m = link_info.current_method();
1036         assert(m != NULL, &quot;information about the current method must be available for &#39;put&#39; bytecodes&quot;);
1037         bool is_initialized_static_final_update = (byte == Bytecodes::_putstatic &amp;&amp;
1038                                                    fd.is_static() &amp;&amp;
<span class="line-modified">1039                                                    !m-&gt;is_class_initializer());</span>
1040         bool is_initialized_instance_final_update = ((byte == Bytecodes::_putfield || byte == Bytecodes::_nofast_putfield) &amp;&amp;
1041                                                      !fd.is_static() &amp;&amp;
<span class="line-modified">1042                                                      !m-&gt;is_object_constructor());</span>
1043 
1044         if (is_initialized_static_final_update || is_initialized_instance_final_update) {
1045           ResourceMark rm(THREAD);
1046           stringStream ss;
1047           ss.print(&quot;Update to %s final field %s.%s attempted from a different method (%s) than the initializer method %s &quot;,
1048                    is_static ? &quot;static&quot; : &quot;non-static&quot;, resolved_klass-&gt;external_name(), fd.name()-&gt;as_C_string(),
1049                    m-&gt;name()-&gt;as_C_string(),
1050                    is_static ? &quot;&lt;clinit&gt;&quot; : &quot;&lt;init&gt;&quot;);
1051           THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), ss.as_string());
1052         }
1053       }
1054     }
1055 
1056     // initialize resolved_klass if necessary
1057     // note 1: the klass which declared the field must be initialized (i.e, sel_klass)
1058     //         according to the newest JVM spec (5.5, p.170) - was bug (gri 7/28/99)
1059     //
1060     // note 2: we don&#39;t want to force initialization if we are just checking
1061     //         if the field access is legal; e.g., during compilation
1062     if (is_static &amp;&amp; initialize_class) {
</pre>
<hr />
<pre>
1141 
1142 // throws linktime exceptions
1143 Method* LinkResolver::linktime_resolve_special_method(const LinkInfo&amp; link_info, TRAPS) {
1144 
1145   // Invokespecial is called for multiple special reasons:
1146   // &lt;init&gt;
1147   // local private method invocation, for classes and interfaces
1148   // superclass.method, which can also resolve to a default method
1149   // and the selected method is recalculated relative to the direct superclass
1150   // superinterface.method, which explicitly does not check shadowing
1151   Klass* resolved_klass = link_info.resolved_klass();
1152   Method* resolved_method;
1153 
1154   if (!resolved_klass-&gt;is_interface()) {
1155     resolved_method = resolve_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1156   } else {
1157     resolved_method = resolve_interface_method(link_info, Bytecodes::_invokespecial, CHECK_NULL);
1158   }
1159 
1160   // check if method name is &lt;init&gt;, that it is found in same klass as static type
<span class="line-added">1161   // Since this method is never inherited from a super, any appearance here under</span>
<span class="line-added">1162   // the wrong class would be an error.</span>
1163   if (resolved_method-&gt;name() == vmSymbols::object_initializer_name() &amp;&amp;
1164       resolved_method-&gt;method_holder() != resolved_klass) {
1165     ResourceMark rm(THREAD);
1166     stringStream ss;
1167     ss.print(&quot;%s: method &#39;&quot;, resolved_klass-&gt;external_name());
1168     resolved_method-&gt;signature()-&gt;print_as_signature_external_return_type(&amp;ss);
1169     ss.print(&quot; %s(&quot;, resolved_method-&gt;name()-&gt;as_C_string());
1170     resolved_method-&gt;signature()-&gt;print_as_signature_external_parameters(&amp;ss);
1171     ss.print(&quot;)&#39; not found&quot;);
1172     Exceptions::fthrow(
1173       THREAD_AND_LOCATION,
1174       vmSymbols::java_lang_NoSuchMethodError(),
1175       &quot;%s&quot;, ss.as_string());
1176     return NULL;
1177   }
1178 
1179   // ensure that invokespecial&#39;s interface method reference is in
1180   // a direct superinterface, not an indirect superinterface
1181   Klass* current_klass = link_info.current_klass();
1182   if (current_klass != NULL &amp;&amp; resolved_klass-&gt;is_interface()) {
</pre>
<hr />
<pre>
1216   }
1217 
1218   return resolved_method;
1219 }
1220 
1221 // throws runtime exceptions
1222 void LinkResolver::runtime_resolve_special_method(CallInfo&amp; result,
1223                                                   const LinkInfo&amp; link_info,
1224                                                   const methodHandle&amp; resolved_method,
1225                                                   Handle recv, TRAPS) {
1226 
1227   Klass* resolved_klass = link_info.resolved_klass();
1228 
1229   // resolved method is selected method unless we have an old-style lookup
1230   // for a superclass method
1231   // Invokespecial for a superinterface, resolved method is selected method,
1232   // no checks for shadowing
1233   methodHandle sel_method(THREAD, resolved_method());
1234 
1235   if (link_info.check_access() &amp;&amp;
<span class="line-modified">1236       // check if the method is not &lt;init&gt;, which is never inherited</span>
1237       resolved_method-&gt;name() != vmSymbols::object_initializer_name()) {
1238 
1239     Klass* current_klass = link_info.current_klass();
1240 
1241     // Check if the class of the resolved_klass is a superclass
1242     // (not supertype in order to exclude interface classes) of the current class.
1243     // This check is not performed for super.invoke for interface methods
1244     // in super interfaces.
1245     if (current_klass-&gt;is_subclass_of(resolved_klass) &amp;&amp;
1246         current_klass != resolved_klass) {
1247       // Lookup super method
1248       Klass* super_klass = current_klass-&gt;super();
1249       Method* instance_method = lookup_instance_method_in_klasses(super_klass,
1250                                                      resolved_method-&gt;name(),
1251                                                      resolved_method-&gt;signature(),
1252                                                      Klass::find_private, CHECK);
1253       sel_method = methodHandle(THREAD, instance_method);
1254 
1255       // check if found
1256       if (sel_method.is_null()) {
</pre>
<hr />
<pre>
1636 
1637 
1638 
1639 //------------------------------------------------------------------------------------------------------------------------
1640 // ConstantPool entries
1641 
1642 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, Bytecodes::Code byte, TRAPS) {
1643   switch (byte) {
1644     case Bytecodes::_invokestatic   : resolve_invokestatic   (result,       pool, index, CHECK); break;
1645     case Bytecodes::_invokespecial  : resolve_invokespecial  (result, recv, pool, index, CHECK); break;
1646     case Bytecodes::_invokevirtual  : resolve_invokevirtual  (result, recv, pool, index, CHECK); break;
1647     case Bytecodes::_invokehandle   : resolve_invokehandle   (result,       pool, index, CHECK); break;
1648     case Bytecodes::_invokedynamic  : resolve_invokedynamic  (result,       pool, index, CHECK); break;
1649     case Bytecodes::_invokeinterface: resolve_invokeinterface(result, recv, pool, index, CHECK); break;
1650     default                         :                                                            break;
1651   }
1652   return;
1653 }
1654 
1655 void LinkResolver::resolve_invoke(CallInfo&amp; result, Handle&amp; recv,
<span class="line-modified">1656                                   const methodHandle&amp; attached_method,</span>
<span class="line-modified">1657                                   Bytecodes::Code byte, bool check_null_and_abstract, TRAPS) {</span>
1658   Klass* defc = attached_method-&gt;method_holder();
1659   Symbol* name = attached_method-&gt;name();
1660   Symbol* type = attached_method-&gt;signature();
1661   LinkInfo link_info(defc, name, type);
<span class="line-added">1662   Klass* recv_klass = recv.is_null() ? defc : recv-&gt;klass();</span>
1663   switch(byte) {
1664     case Bytecodes::_invokevirtual:
<span class="line-modified">1665       resolve_virtual_call(result, recv, recv_klass, link_info,</span>
<span class="line-modified">1666                            check_null_and_abstract, CHECK);</span>
1667       break;
1668     case Bytecodes::_invokeinterface:
<span class="line-modified">1669       resolve_interface_call(result, recv, recv_klass, link_info,</span>
<span class="line-modified">1670                              check_null_and_abstract, CHECK);</span>
1671       break;
1672     case Bytecodes::_invokestatic:
1673       resolve_static_call(result, link_info, /*initialize_class=*/false, CHECK);
1674       break;
1675     case Bytecodes::_invokespecial:
1676       resolve_special_call(result, recv, link_info, CHECK);
1677       break;
1678     default:
1679       fatal(&quot;bad call: %s&quot;, Bytecodes::name(byte));
1680       break;
1681   }
1682 }
1683 
1684 void LinkResolver::resolve_invokestatic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1685   LinkInfo link_info(pool, index, CHECK);
1686   resolve_static_call(result, link_info, /*initialize_class*/true, CHECK);
1687 }
1688 
1689 
1690 void LinkResolver::resolve_invokespecial(CallInfo&amp; result, Handle recv,
</pre>
</td>
</tr>
</table>
<center><a href="../gc/parallel/psParallelCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jvmci/jvmciCodeInstaller.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
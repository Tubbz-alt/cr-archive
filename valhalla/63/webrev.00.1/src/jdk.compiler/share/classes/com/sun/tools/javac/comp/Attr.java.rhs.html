<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
<a name="1" id="anc1"></a>
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.source.tree.CaseTree;
  35 import com.sun.source.tree.IdentifierTree;
  36 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  37 import com.sun.source.tree.MemberSelectTree;
  38 import com.sun.source.tree.TreeVisitor;
  39 import com.sun.source.util.SimpleTreeVisitor;
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Lint.LintCategory;
  42 import com.sun.tools.javac.code.Scope.WriteableScope;
  43 import com.sun.tools.javac.code.Source.Feature;
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Type.*;
  46 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  47 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  48 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  49 import com.sun.tools.javac.comp.Check.CheckContext;
  50 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  51 import com.sun.tools.javac.comp.MatchBindingsComputer.MatchBindings;
  52 import com.sun.tools.javac.jvm.*;
  53 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.Diamond;
  54 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArg;
  55 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArgs;
  56 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  57 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  58 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  59 import com.sun.tools.javac.tree.*;
  60 import com.sun.tools.javac.tree.JCTree.*;
  61 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  62 import com.sun.tools.javac.util.*;
  63 import com.sun.tools.javac.util.DefinedBy.Api;
  64 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  65 import com.sun.tools.javac.util.JCDiagnostic.Error;
  66 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  67 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  68 import com.sun.tools.javac.util.List;
  69 
  70 import static com.sun.tools.javac.code.Flags.*;
  71 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  72 import static com.sun.tools.javac.code.Flags.BLOCK;
  73 import static com.sun.tools.javac.code.Kinds.*;
  74 import static com.sun.tools.javac.code.Kinds.Kind.*;
  75 import static com.sun.tools.javac.code.TypeTag.*;
  76 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  77 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  78 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  79 
  80 /** This is the main context-dependent analysis phase in GJC. It
  81  *  encompasses name resolution, type checking and constant folding as
  82  *  subtasks. Some subtasks involve auxiliary classes.
  83  *  @see Check
  84  *  @see Resolve
  85  *  @see ConstFold
  86  *  @see Infer
  87  *
  88  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  89  *  If you write code that depends on this, you do so at your own risk.
  90  *  This code and its internal interfaces are subject to change or
  91  *  deletion without notice.&lt;/b&gt;
  92  */
  93 public class Attr extends JCTree.Visitor {
  94     protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
  95 
  96     final Names names;
  97     final Log log;
  98     final Symtab syms;
  99     final Resolve rs;
 100     final Operators operators;
 101     final Infer infer;
 102     final Analyzer analyzer;
 103     final DeferredAttr deferredAttr;
 104     final Check chk;
 105     final Flow flow;
 106     final MemberEnter memberEnter;
 107     final TypeEnter typeEnter;
 108     final TreeMaker make;
 109     final ConstFold cfolder;
 110     final Enter enter;
 111     final Target target;
 112     final Types types;
 113     final Preview preview;
 114     final JCDiagnostic.Factory diags;
 115     final TypeAnnotations typeAnnotations;
 116     final DeferredLintHandler deferredLintHandler;
 117     final TypeEnvs typeEnvs;
 118     final Dependencies dependencies;
 119     final Annotate annotate;
 120     final ArgumentAttr argumentAttr;
 121     final MatchBindingsComputer matchBindingsComputer;
 122 
 123     public static Attr instance(Context context) {
 124         Attr instance = context.get(attrKey);
 125         if (instance == null)
 126             instance = new Attr(context);
 127         return instance;
 128     }
 129 
 130     protected Attr(Context context) {
 131         context.put(attrKey, this);
 132 
 133         names = Names.instance(context);
 134         log = Log.instance(context);
 135         syms = Symtab.instance(context);
 136         rs = Resolve.instance(context);
 137         operators = Operators.instance(context);
 138         chk = Check.instance(context);
 139         flow = Flow.instance(context);
 140         memberEnter = MemberEnter.instance(context);
 141         typeEnter = TypeEnter.instance(context);
 142         make = TreeMaker.instance(context);
 143         enter = Enter.instance(context);
 144         infer = Infer.instance(context);
 145         analyzer = Analyzer.instance(context);
 146         deferredAttr = DeferredAttr.instance(context);
 147         cfolder = ConstFold.instance(context);
 148         target = Target.instance(context);
 149         types = Types.instance(context);
 150         preview = Preview.instance(context);
 151         diags = JCDiagnostic.Factory.instance(context);
 152         annotate = Annotate.instance(context);
 153         typeAnnotations = TypeAnnotations.instance(context);
 154         deferredLintHandler = DeferredLintHandler.instance(context);
 155         typeEnvs = TypeEnvs.instance(context);
 156         dependencies = Dependencies.instance(context);
 157         argumentAttr = ArgumentAttr.instance(context);
 158         matchBindingsComputer = MatchBindingsComputer.instance(context);
 159 
 160         Options options = Options.instance(context);
 161 
 162         Source source = Source.instance(context);
 163         allowPoly = Feature.POLY.allowedInSource(source);
 164         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 165         allowLambda = Feature.LAMBDA.allowedInSource(source);
 166         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 167         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
<a name="2" id="anc2"></a><span class="line-added"> 168         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);</span>
 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
<a name="3" id="anc3"></a><span class="line-added"> 174         allowEmptyValues = options.isSet(&quot;allowEmptyValues&quot;);</span>
<span class="line-added"> 175         allowValueMemberCycles = options.isSet(&quot;allowValueMemberCycles&quot;);</span>
 176 
 177         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 178         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 179         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 180         methodAttrInfo = new MethodAttrInfo();
 181         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 182         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 183         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 184     }
 185 
 186     /** Switch: support target-typing inference
 187      */
 188     boolean allowPoly;
 189 
 190     /** Switch: support type annotations.
 191      */
 192     boolean allowTypeAnnos;
 193 
 194     /** Switch: support lambda expressions ?
 195      */
 196     boolean allowLambda;
 197 
 198     /** Switch: support default methods ?
 199      */
 200     boolean allowDefaultMethods;
 201 
<a name="4" id="anc4"></a><span class="line-added"> 202     /** Switch: allow inline types?</span>
<span class="line-added"> 203      */</span>
<span class="line-added"> 204     boolean allowInlineTypes;</span>
<span class="line-added"> 205 </span>
 206     /** Switch: static interface methods enabled?
 207      */
 208     boolean allowStaticInterfaceMethods;
 209 
 210     /** Switch: reifiable types in instanceof enabled?
 211      */
 212     boolean allowReifiableTypesInInstanceof;
 213 
 214     /**
 215      * Switch: warn about use of variable before declaration?
 216      * RFE: 6425594
 217      */
 218     boolean useBeforeDeclarationWarning;
 219 
<a name="5" id="anc5"></a><span class="line-added"> 220     /**</span>
<span class="line-added"> 221      * Switch: Allow value types with no instance state?</span>
<span class="line-added"> 222      */</span>
<span class="line-added"> 223     boolean allowEmptyValues;</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225     /**</span>
<span class="line-added"> 226      * Switch: Allow value type member cycles?</span>
<span class="line-added"> 227      */</span>
<span class="line-added"> 228     boolean allowValueMemberCycles;</span>
<span class="line-added"> 229 </span>
 230     /**
 231      * Switch: name of source level; used for error reporting.
 232      */
 233     String sourceName;
 234 
 235     /** Check kind and type of given tree against protokind and prototype.
 236      *  If check succeeds, store type in tree and return it.
 237      *  If check fails, store errType in tree and return it.
 238      *  No checks are performed if the prototype is a method type.
 239      *  It is not necessary in this case since we know that kind and type
 240      *  are correct.
 241      *
 242      *  @param tree     The tree whose kind and type is checked
 243      *  @param found    The computed type of the tree
 244      *  @param ownkind  The computed kind of the tree
 245      *  @param resultInfo  The expected result of the tree
 246      */
 247     Type check(final JCTree tree,
 248                final Type found,
 249                final KindSelector ownkind,
 250                final ResultInfo resultInfo) {
 251         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
 252         Type owntype;
 253         boolean shouldCheck = !found.hasTag(ERROR) &amp;&amp;
 254                 !resultInfo.pt.hasTag(METHOD) &amp;&amp;
 255                 !resultInfo.pt.hasTag(FORALL);
 256         if (shouldCheck &amp;&amp; !ownkind.subset(resultInfo.pkind)) {
 257             log.error(tree.pos(),
 258                       Errors.UnexpectedType(resultInfo.pkind.kindNames(),
 259                                             ownkind.kindNames()));
 260             owntype = types.createErrorType(found);
 261         } else if (allowPoly &amp;&amp; inferenceContext.free(found)) {
 262             //delay the check if there are inference variables in the found type
 263             //this means we are dealing with a partially inferred poly expression
 264             owntype = shouldCheck ? resultInfo.pt : found;
 265             if (resultInfo.checkMode.installPostInferenceHook()) {
 266                 inferenceContext.addFreeTypeListener(List.of(found),
 267                         instantiatedContext -&gt; {
 268                             ResultInfo pendingResult =
 269                                     resultInfo.dup(inferenceContext.asInstType(resultInfo.pt));
 270                             check(tree, inferenceContext.asInstType(found), ownkind, pendingResult);
 271                         });
 272             }
 273         } else {
 274             owntype = shouldCheck ?
 275             resultInfo.check(tree, found) :
 276             found;
 277         }
 278         if (resultInfo.checkMode.updateTreeType()) {
 279             tree.type = owntype;
 280         }
 281         return owntype;
 282     }
 283 
 284     /** Is given blank final variable assignable, i.e. in a scope where it
 285      *  may be assigned to even though it is final?
 286      *  @param v      The blank final variable.
 287      *  @param env    The current environment.
 288      */
 289     boolean isAssignableAsBlankFinal(VarSymbol v, Env&lt;AttrContext&gt; env) {
 290         Symbol owner = env.info.scope.owner;
 291            // owner refers to the innermost variable, method or
 292            // initializer block declaration at this point.
 293         return
 294             v.owner == owner
 295             ||
 296             ((owner.name == names.init ||    // i.e. we are in a constructor
 297               owner.kind == VAR ||           // i.e. we are in a variable initializer
 298               (owner.flags() &amp; BLOCK) != 0)  // i.e. we are in an initializer block
 299              &amp;&amp;
 300              v.owner == owner.owner
 301              &amp;&amp;
 302              ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env));
 303     }
 304 
 305     /** Check that variable can be assigned to.
 306      *  @param pos    The current source code position.
 307      *  @param v      The assigned variable
 308      *  @param base   If the variable is referred to in a Select, the part
 309      *                to the left of the `.&#39;, null otherwise.
 310      *  @param env    The current environment.
 311      */
 312     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 313         if (v.name == names._this) {
 314             log.error(pos, Errors.CantAssignValToThis);
 315         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 316             ((v.flags() &amp; HASINIT) != 0
 317              ||
 318              !((base == null ||
 319                TreeInfo.isThisQualifier(base)) &amp;&amp;
 320                isAssignableAsBlankFinal(v, env)))) {
 321             if (v.isResourceVariable()) { //TWR resource
 322                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 323             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 324                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 325             } else {
<a name="6" id="anc6"></a><span class="line-modified"> 326                 boolean complain = true;</span>
<span class="line-added"> 327                 /* Allow updates to instance fields of value classes by any method in the same nest via the</span>
<span class="line-added"> 328                    withfield operator -This does not result in mutation of final fields; the code generator</span>
<span class="line-added"> 329                    would implement `copy on write&#39; semantics via the opcode `withfield&#39;.</span>
<span class="line-added"> 330                 */</span>
<span class="line-added"> 331                 if (env.info.inWithField &amp;&amp; v.getKind() == ElementKind.FIELD &amp;&amp; (v.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) {</span>
<span class="line-added"> 332                     if (env.enclClass.sym.outermostClass() == v.owner.outermostClass())</span>
<span class="line-added"> 333                         complain = false;</span>
<span class="line-added"> 334                 }</span>
<span class="line-added"> 335                 if (complain)</span>
<span class="line-added"> 336                     log.error(pos, Errors.CantAssignValToFinalVar(v));</span>
 337             }
 338         }
 339     }
 340 
 341     /** Does tree represent a static reference to an identifier?
 342      *  It is assumed that tree is either a SELECT or an IDENT.
 343      *  We have to weed out selects from non-type names here.
 344      *  @param tree    The candidate tree.
 345      */
 346     boolean isStaticReference(JCTree tree) {
 347         if (tree.hasTag(SELECT)) {
 348             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 349             if (lsym == null || lsym.kind != TYP) {
 350                 return false;
 351             }
 352         }
 353         return true;
 354     }
 355 
 356     /** Is this symbol a type?
 357      */
 358     static boolean isType(Symbol sym) {
 359         return sym != null &amp;&amp; sym.kind == TYP;
 360     }
 361 
 362     /** The current `this&#39; symbol.
 363      *  @param env    The current environment.
 364      */
 365     Symbol thisSym(DiagnosticPosition pos, Env&lt;AttrContext&gt; env) {
 366         return rs.resolveSelf(pos, env, env.enclClass.sym, names._this);
 367     }
 368 
 369     /** Attribute a parsed identifier.
 370      * @param tree Parsed identifier name
 371      * @param topLevel The toplevel to use
 372      */
 373     public Symbol attribIdent(JCTree tree, JCCompilationUnit topLevel) {
 374         Env&lt;AttrContext&gt; localEnv = enter.topLevelEnv(topLevel);
 375         localEnv.enclClass = make.ClassDef(make.Modifiers(0),
 376                                            syms.errSymbol.name,
 377                                            null, null, null, null);
 378         localEnv.enclClass.sym = syms.errSymbol;
 379         return attribIdent(tree, localEnv);
 380     }
 381 
 382     /** Attribute a parsed identifier.
 383      * @param tree Parsed identifier name
 384      * @param env The env to use
 385      */
 386     public Symbol attribIdent(JCTree tree, Env&lt;AttrContext&gt; env) {
 387         return tree.accept(identAttributer, env);
 388     }
 389     // where
 390         private TreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; identAttributer = new IdentAttributer();
 391         private class IdentAttributer extends SimpleTreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; {
 392             @Override @DefinedBy(Api.COMPILER_TREE)
 393             public Symbol visitMemberSelect(MemberSelectTree node, Env&lt;AttrContext&gt; env) {
 394                 Symbol site = visit(node.getExpression(), env);
 395                 if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)
 396                     return site;
 397                 Name name = (Name)node.getIdentifier();
 398                 if (site.kind == PCK) {
 399                     env.toplevel.packge = (PackageSymbol)site;
 400                     return rs.findIdentInPackage(null, env, (TypeSymbol)site, name,
 401                             KindSelector.TYP_PCK);
 402                 } else {
 403                     env.enclClass.sym = (ClassSymbol)site;
 404                     return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);
 405                 }
 406             }
 407 
 408             @Override @DefinedBy(Api.COMPILER_TREE)
 409             public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
 410                 return rs.findIdent(null, env, (Name)node.getName(), KindSelector.TYP_PCK);
 411             }
 412         }
 413 
 414     public Type coerce(Type etype, Type ttype) {
 415         return cfolder.coerce(etype, ttype);
 416     }
 417 
 418     public Type attribType(JCTree node, TypeSymbol sym) {
 419         Env&lt;AttrContext&gt; env = typeEnvs.get(sym);
 420         Env&lt;AttrContext&gt; localEnv = env.dup(node, env.info.dup());
 421         return attribTree(node, localEnv, unknownTypeInfo);
 422     }
 423 
 424     public Type attribImportQualifier(JCImport tree, Env&lt;AttrContext&gt; env) {
 425         // Attribute qualifying package or class.
 426         JCFieldAccess s = (JCFieldAccess)tree.qualid;
 427         return attribTree(s.selected, env,
 428                           new ResultInfo(tree.staticImport ?
 429                                          KindSelector.TYP : KindSelector.TYP_PCK,
 430                        Type.noType));
 431     }
 432 
 433     public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
 434         return attribToTree(expr, env, tree, unknownExprInfo);
 435     }
 436 
 437     public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {
 438         return attribToTree(stmt, env, tree, statInfo);
 439     }
 440 
 441     private Env&lt;AttrContext&gt; attribToTree(JCTree root, Env&lt;AttrContext&gt; env, JCTree tree, ResultInfo resultInfo) {
 442         breakTree = tree;
 443         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 444         try {
 445             deferredAttr.attribSpeculative(root, env, resultInfo,
 446                     null, DeferredAttr.AttributionMode.ANALYZER,
 447                     argumentAttr.withLocalCacheContext());
 448         } catch (BreakAttr b) {
 449             return b.env;
 450         } catch (AssertionError ae) {
 451             if (ae.getCause() instanceof BreakAttr) {
 452                 return ((BreakAttr)(ae.getCause())).env;
 453             } else {
 454                 throw ae;
 455             }
 456         } finally {
 457             breakTree = null;
 458             log.useSource(prev);
 459         }
 460         return env;
 461     }
 462 
 463     private JCTree breakTree = null;
 464 
 465     private static class BreakAttr extends RuntimeException {
 466         static final long serialVersionUID = -6924771130405446405L;
 467         private transient Env&lt;AttrContext&gt; env;
 468         private BreakAttr(Env&lt;AttrContext&gt; env) {
 469             this.env = env;
 470         }
 471     }
 472 
 473     /**
 474      * Mode controlling behavior of Attr.Check
 475      */
 476     enum CheckMode {
 477 
 478         NORMAL,
 479 
 480         /**
 481          * Mode signalling &#39;fake check&#39; - skip tree update. A side-effect of this mode is
 482          * that the captured var cache in {@code InferenceContext} will be used in read-only
 483          * mode when performing inference checks.
 484          */
 485         NO_TREE_UPDATE {
 486             @Override
 487             public boolean updateTreeType() {
 488                 return false;
 489             }
 490         },
 491         /**
 492          * Mode signalling that caller will manage free types in tree decorations.
 493          */
 494         NO_INFERENCE_HOOK {
 495             @Override
 496             public boolean installPostInferenceHook() {
 497                 return false;
 498             }
 499         };
 500 
 501         public boolean updateTreeType() {
 502             return true;
 503         }
 504         public boolean installPostInferenceHook() {
 505             return true;
 506         }
 507     }
 508 
 509 
 510     class ResultInfo {
 511         final KindSelector pkind;
 512         final Type pt;
 513         final CheckContext checkContext;
 514         final CheckMode checkMode;
 515 
 516         ResultInfo(KindSelector pkind, Type pt) {
 517             this(pkind, pt, chk.basicHandler, CheckMode.NORMAL);
 518         }
 519 
 520         ResultInfo(KindSelector pkind, Type pt, CheckMode checkMode) {
 521             this(pkind, pt, chk.basicHandler, checkMode);
 522         }
 523 
 524         protected ResultInfo(KindSelector pkind,
 525                              Type pt, CheckContext checkContext) {
 526             this(pkind, pt, checkContext, CheckMode.NORMAL);
 527         }
 528 
 529         protected ResultInfo(KindSelector pkind,
 530                              Type pt, CheckContext checkContext, CheckMode checkMode) {
 531             this.pkind = pkind;
 532             this.pt = pt;
 533             this.checkContext = checkContext;
 534             this.checkMode = checkMode;
 535         }
 536 
 537         /**
 538          * Should {@link Attr#attribTree} use the {@ArgumentAttr} visitor instead of this one?
 539          * @param tree The tree to be type-checked.
 540          * @return true if {@ArgumentAttr} should be used.
 541          */
 542         protected boolean needsArgumentAttr(JCTree tree) { return false; }
 543 
 544         protected Type check(final DiagnosticPosition pos, final Type found) {
 545             return chk.checkType(pos, found, pt, checkContext);
 546         }
 547 
 548         protected ResultInfo dup(Type newPt) {
 549             return new ResultInfo(pkind, newPt, checkContext, checkMode);
 550         }
 551 
 552         protected ResultInfo dup(CheckContext newContext) {
 553             return new ResultInfo(pkind, pt, newContext, checkMode);
 554         }
 555 
 556         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 557             return new ResultInfo(pkind, newPt, newContext, checkMode);
 558         }
 559 
 560         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 561             return new ResultInfo(pkind, newPt, newContext, newMode);
 562         }
 563 
 564         protected ResultInfo dup(CheckMode newMode) {
 565             return new ResultInfo(pkind, pt, checkContext, newMode);
 566         }
 567 
 568         @Override
 569         public String toString() {
 570             if (pt != null) {
 571                 return pt.toString();
 572             } else {
 573                 return &quot;&quot;;
 574             }
 575         }
 576     }
 577 
 578     class MethodAttrInfo extends ResultInfo {
 579         public MethodAttrInfo() {
 580             this(chk.basicHandler);
 581         }
 582 
 583         public MethodAttrInfo(CheckContext checkContext) {
 584             super(KindSelector.VAL, Infer.anyPoly, checkContext);
 585         }
 586 
 587         @Override
 588         protected boolean needsArgumentAttr(JCTree tree) {
 589             return true;
 590         }
 591 
 592         protected ResultInfo dup(Type newPt) {
 593             throw new IllegalStateException();
 594         }
 595 
 596         protected ResultInfo dup(CheckContext newContext) {
 597             return new MethodAttrInfo(newContext);
 598         }
 599 
 600         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 601             throw new IllegalStateException();
 602         }
 603 
 604         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 605             throw new IllegalStateException();
 606         }
 607 
 608         protected ResultInfo dup(CheckMode newMode) {
 609             throw new IllegalStateException();
 610         }
 611     }
 612 
 613     class RecoveryInfo extends ResultInfo {
 614 
 615         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext) {
 616             this(deferredAttrContext, Type.recoveryType);
 617         }
 618 
 619         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext, Type pt) {
 620             super(KindSelector.VAL, pt, new Check.NestedCheckContext(chk.basicHandler) {
 621                 @Override
 622                 public DeferredAttr.DeferredAttrContext deferredAttrContext() {
 623                     return deferredAttrContext;
 624                 }
 625                 @Override
 626                 public boolean compatible(Type found, Type req, Warner warn) {
 627                     return true;
 628                 }
 629                 @Override
 630                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 631                     if (pt == Type.recoveryType) {
 632                         chk.basicHandler.report(pos, details);
 633                     }
 634                 }
 635             });
 636         }
 637     }
 638 
 639     final ResultInfo statInfo;
 640     final ResultInfo varAssignmentInfo;
 641     final ResultInfo methodAttrInfo;
 642     final ResultInfo unknownExprInfo;
 643     final ResultInfo unknownTypeInfo;
 644     final ResultInfo unknownTypeExprInfo;
 645     final ResultInfo recoveryInfo;
 646 
 647     Type pt() {
 648         return resultInfo.pt;
 649     }
 650 
 651     KindSelector pkind() {
 652         return resultInfo.pkind;
 653     }
 654 
 655 /* ************************************************************************
 656  * Visitor methods
 657  *************************************************************************/
 658 
 659     /** Visitor argument: the current environment.
 660      */
 661     Env&lt;AttrContext&gt; env;
 662 
 663     /** Visitor argument: the currently expected attribution result.
 664      */
 665     ResultInfo resultInfo;
 666 
 667     /** Visitor result: the computed type.
 668      */
 669     Type result;
 670 
 671     MatchBindings matchBindings = MatchBindingsComputer.EMPTY;
 672 
 673     /** Visitor method: attribute a tree, catching any completion failure
 674      *  exceptions. Return the tree&#39;s type.
 675      *
 676      *  @param tree    The tree to be visited.
 677      *  @param env     The environment visitor argument.
 678      *  @param resultInfo   The result info visitor argument.
 679      */
 680     Type attribTree(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 681         Env&lt;AttrContext&gt; prevEnv = this.env;
 682         ResultInfo prevResult = this.resultInfo;
 683         try {
 684             this.env = env;
 685             this.resultInfo = resultInfo;
 686             if (resultInfo.needsArgumentAttr(tree)) {
 687                 result = argumentAttr.attribArg(tree, env);
 688             } else {
 689                 tree.accept(this);
 690             }
 691             matchBindings = matchBindingsComputer.finishBindings(tree,
 692                                                                  matchBindings);
 693             if (tree == breakTree &amp;&amp;
 694                     resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
 695                 breakTreeFound(copyEnv(env));
 696             }
 697             return result;
 698         } catch (CompletionFailure ex) {
 699             tree.type = syms.errType;
 700             return chk.completionError(tree.pos(), ex);
 701         } finally {
 702             this.env = prevEnv;
 703             this.resultInfo = prevResult;
 704         }
 705     }
 706 
 707     protected void breakTreeFound(Env&lt;AttrContext&gt; env) {
 708         throw new BreakAttr(env);
 709     }
 710 
 711     Env&lt;AttrContext&gt; copyEnv(Env&lt;AttrContext&gt; env) {
 712         Env&lt;AttrContext&gt; newEnv =
 713                 env.dup(env.tree, env.info.dup(copyScope(env.info.scope)));
 714         if (newEnv.outer != null) {
 715             newEnv.outer = copyEnv(newEnv.outer);
 716         }
 717         return newEnv;
 718     }
 719 
 720     WriteableScope copyScope(WriteableScope sc) {
 721         WriteableScope newScope = WriteableScope.create(sc.owner);
 722         List&lt;Symbol&gt; elemsList = List.nil();
 723         for (Symbol sym : sc.getSymbols()) {
 724             elemsList = elemsList.prepend(sym);
 725         }
 726         for (Symbol s : elemsList) {
 727             newScope.enter(s);
 728         }
 729         return newScope;
 730     }
 731 
 732     /** Derived visitor method: attribute an expression tree.
 733      */
 734     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 735         return attribTree(tree, env, new ResultInfo(KindSelector.VAL, !pt.hasTag(ERROR) ? pt : Type.noType));
 736     }
 737 
 738     /** Derived visitor method: attribute an expression tree with
 739      *  no constraints on the computed type.
 740      */
 741     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env) {
 742         return attribTree(tree, env, unknownExprInfo);
 743     }
 744 
 745     /** Derived visitor method: attribute a type tree.
 746      */
 747     public Type attribType(JCTree tree, Env&lt;AttrContext&gt; env) {
 748         Type result = attribType(tree, env, Type.noType);
 749         return result;
 750     }
 751 
 752     /** Derived visitor method: attribute a type tree.
 753      */
 754     Type attribType(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 755         Type result = attribTree(tree, env, new ResultInfo(KindSelector.TYP, pt));
 756         return result;
 757     }
 758 
 759     /** Derived visitor method: attribute a statement or definition tree.
 760      */
 761     public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {
 762         Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);
 763         Type result = attribTree(tree, env, statInfo);
 764         analyzer.analyzeIfNeeded(tree, analyzeEnv);
 765         return result;
 766     }
 767 
 768     /** Attribute a list of expressions, returning a list of types.
 769      */
 770     List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
 771         ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();
 772         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 773             ts.append(attribExpr(l.head, env, pt));
 774         return ts.toList();
 775     }
 776 
 777     /** Attribute a list of statements, returning nothing.
 778      */
 779     &lt;T extends JCTree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
 780         for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
 781             attribStat(l.head, env);
 782     }
 783 
 784     /** Attribute the arguments in a method call, returning the method kind.
 785      */
 786     KindSelector attribArgs(KindSelector initialKind, List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, ListBuffer&lt;Type&gt; argtypes) {
 787         KindSelector kind = initialKind;
 788         for (JCExpression arg : trees) {
 789             Type argtype = chk.checkNonVoid(arg, attribTree(arg, env, allowPoly ? methodAttrInfo : unknownExprInfo));
 790             if (argtype.hasTag(DEFERRED)) {
 791                 kind = KindSelector.of(KindSelector.POLY, kind);
 792             }
 793             argtypes.append(argtype);
 794         }
 795         return kind;
 796     }
 797 
 798     /** Attribute a type argument list, returning a list of types.
 799      *  Caller is responsible for calling checkRefTypes.
 800      */
 801     List&lt;Type&gt; attribAnyTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 802         ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();
 803         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 804             argtypes.append(attribType(l.head, env));
 805         return argtypes.toList();
 806     }
 807 
 808     /** Attribute a type argument list, returning a list of types.
 809      *  Check that all the types are references.
 810      */
 811     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 812         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 813         return chk.checkRefTypes(trees, types);
 814     }
 815 
 816     /**
 817      * Attribute type variables (of generic classes or methods).
 818      * Compound types are attributed later in attribBounds.
 819      * @param typarams the type variables to enter
 820      * @param env      the current environment
 821      */
 822     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 823         for (JCTypeParameter tvar : typarams) {
 824             TypeVar a = (TypeVar)tvar.type;
 825             a.tsym.flags_field |= UNATTRIBUTED;
 826             a.setUpperBound(Type.noType);
 827             if (!tvar.bounds.isEmpty()) {
<a name="7" id="anc7"></a><span class="line-modified"> 828                 List&lt;Type&gt; bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));</span>
 829                 for (JCExpression bound : tvar.bounds.tail)
<a name="8" id="anc8"></a><span class="line-modified"> 830                     bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));</span>
 831                 types.setBounds(a, bounds.reverse());
 832             } else {
 833                 // if no bounds are given, assume a single bound of
 834                 // java.lang.Object.
 835                 types.setBounds(a, List.of(syms.objectType));
 836             }
 837             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 838         }
 839         if (checkCyclic) {
 840             for (JCTypeParameter tvar : typarams) {
 841                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 842             }
 843         }
 844     }
 845 
 846     /**
 847      * Attribute the type references in a list of annotations.
 848      */
 849     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 850                                Env&lt;AttrContext&gt; env) {
 851         for (List&lt;JCAnnotation&gt; al = annotations; al.nonEmpty(); al = al.tail) {
 852             JCAnnotation a = al.head;
 853             attribType(a.annotationType, env);
 854         }
 855     }
 856 
 857     /**
 858      * Attribute a &quot;lazy constant value&quot;.
 859      *  @param env         The env for the const value
 860      *  @param variable    The initializer for the const value
 861      *  @param type        The expected type, or null
 862      *  @see VarSymbol#setLazyConstValue
 863      */
 864     public Object attribLazyConstantValue(Env&lt;AttrContext&gt; env,
 865                                       JCVariableDecl variable,
 866                                       Type type) {
 867 
 868         DiagnosticPosition prevLintPos
 869                 = deferredLintHandler.setPos(variable.pos());
 870 
 871         final JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);
 872         try {
 873             Type itype = attribExpr(variable.init, env, type);
 874             if (variable.isImplicitlyTyped()) {
 875                 //fixup local variable type
 876                 type = variable.type = variable.sym.type = chk.checkLocalVarType(variable, itype.baseType(), variable.name);
 877             }
 878             if (itype.constValue() != null) {
 879                 return coerce(itype, type).constValue();
 880             } else {
 881                 return null;
 882             }
 883         } finally {
 884             log.useSource(prevSource);
 885             deferredLintHandler.setPos(prevLintPos);
 886         }
 887     }
 888 
 889     /** Attribute type reference in an `extends&#39; or `implements&#39; clause.
 890      *  Supertypes of anonymous inner classes are usually already attributed.
 891      *
 892      *  @param tree              The tree making up the type reference.
 893      *  @param env               The environment current at the reference.
 894      *  @param classExpected     true if only a class is expected here.
 895      *  @param interfaceExpected true if only an interface is expected here.
 896      */
 897     Type attribBase(JCTree tree,
 898                     Env&lt;AttrContext&gt; env,
 899                     boolean classExpected,
 900                     boolean interfaceExpected,
 901                     boolean checkExtensible) {
 902         Type t = tree.type != null ?
 903             tree.type :
 904             attribType(tree, env);
 905         return checkBase(t, tree, env, classExpected, interfaceExpected, checkExtensible);
 906     }
 907     Type checkBase(Type t,
 908                    JCTree tree,
 909                    Env&lt;AttrContext&gt; env,
 910                    boolean classExpected,
 911                    boolean interfaceExpected,
 912                    boolean checkExtensible) {
 913         final DiagnosticPosition pos = tree.hasTag(TYPEAPPLY) ?
 914                 (((JCTypeApply) tree).clazz).pos() : tree.pos();
 915         if (t.tsym.isAnonymous()) {
 916             log.error(pos, Errors.CantInheritFromAnon);
 917             return types.createErrorType(t);
 918         }
 919         if (t.isErroneous())
 920             return t;
 921         if (t.hasTag(TYPEVAR) &amp;&amp; !classExpected &amp;&amp; !interfaceExpected) {
 922             // check that type variable is already visible
 923             if (t.getUpperBound() == null) {
 924                 log.error(pos, Errors.IllegalForwardRef);
 925                 return types.createErrorType(t);
 926             }
 927         } else {
 928             t = chk.checkClassType(pos, t, checkExtensible);
 929         }
 930         if (interfaceExpected &amp;&amp; (t.tsym.flags() &amp; INTERFACE) == 0) {
 931             log.error(pos, Errors.IntfExpectedHere);
 932             // return errType is necessary since otherwise there might
 933             // be undetected cycles which cause attribution to loop
 934             return types.createErrorType(t);
 935         } else if (checkExtensible &amp;&amp;
 936                    classExpected &amp;&amp;
 937                    (t.tsym.flags() &amp; INTERFACE) != 0) {
 938             log.error(pos, Errors.NoIntfExpectedHere);
 939             return types.createErrorType(t);
 940         }
 941         if (checkExtensible &amp;&amp;
 942             ((t.tsym.flags() &amp; FINAL) != 0)) {
 943             log.error(pos,
 944                       Errors.CantInheritFromFinal(t.tsym));
 945         }
 946         chk.checkNonCyclic(pos, t);
 947         return t;
 948     }
 949 
 950     Type attribIdentAsEnumType(Env&lt;AttrContext&gt; env, JCIdent id) {
 951         Assert.check((env.enclClass.sym.flags() &amp; ENUM) != 0);
 952         id.type = env.info.scope.owner.enclClass().type;
 953         id.sym = env.info.scope.owner.enclClass();
 954         return id.type;
 955     }
 956 
 957     public void visitClassDef(JCClassDecl tree) {
 958         Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =
 959                 Optional.ofNullable(env.info.attributionMode.isSpeculative ?
 960                         argumentAttr.withLocalCacheContext() : null);
 961         try {
 962             // Local and anonymous classes have not been entered yet, so we need to
 963             // do it now.
 964             if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
 965                 enter.classEnter(tree, env);
 966             } else {
 967                 // If this class declaration is part of a class level annotation,
 968                 // as in @MyAnno(new Object() {}) class MyClass {}, enter it in
 969                 // order to simplify later steps and allow for sensible error
 970                 // messages.
 971                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 972                     enter.classEnter(tree, env);
 973             }
 974 
 975             ClassSymbol c = tree.sym;
 976             if (c == null) {
 977                 // exit in case something drastic went wrong during enter.
 978                 result = null;
 979             } else {
 980                 // make sure class has been completed:
 981                 c.complete();
 982 
 983                 // If this class appears as an anonymous class
 984                 // in a superclass constructor call
 985                 // disable implicit outer instance from being passed.
 986                 // (This would be an illegal access to &quot;this before super&quot;).
 987                 if (env.info.isSelfCall &amp;&amp;
 988                         env.tree.hasTag(NEWCLASS)) {
 989                     c.flags_field |= NOOUTERTHIS;
 990                 }
<a name="9" id="anc9"></a><span class="line-added"> 991                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; types.isValue(c.getSuperclass())) {</span>
<span class="line-added"> 992                     c.flags_field |= VALUE; // avoid further secondary errors.</span>
<span class="line-added"> 993                 }</span>
 994                 attribClass(tree.pos(), c);
 995                 result = tree.type = c.type;
 996             }
 997         } finally {
 998             localCacheContext.ifPresent(LocalCacheContext::leave);
 999         }
1000     }
1001 
1002     public void visitMethodDef(JCMethodDecl tree) {
1003         MethodSymbol m = tree.sym;
1004         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
1005 
1006         Lint lint = env.info.lint.augment(m);
1007         Lint prevLint = chk.setLint(lint);
1008         MethodSymbol prevMethod = chk.setMethod(m);
1009         try {
1010             deferredLintHandler.flush(tree.pos());
1011             chk.checkDeprecatedAnnotation(tree.pos(), m);
1012 
1013 
1014             // Create a new environment with local scope
1015             // for attributing the method.
1016             Env&lt;AttrContext&gt; localEnv = memberEnter.methodEnv(tree, env);
1017             localEnv.info.lint = lint;
1018 
1019             attribStats(tree.typarams, localEnv);
1020 
1021             // If we override any other methods, check that we do so properly.
1022             // JLS ???
1023             if (m.isStatic()) {
1024                 chk.checkHideClashes(tree.pos(), env.enclClass.type, m);
1025             } else {
1026                 chk.checkOverrideClashes(tree.pos(), env.enclClass.type, m);
1027             }
1028             chk.checkOverride(env, tree, m);
1029 
1030             if (isDefaultMethod &amp;&amp; types.overridesObjectMethod(m.enclClass(), m)) {
1031                 log.error(tree, Errors.DefaultOverridesObjectMember(m.name, Kinds.kindName(m.location()), m.location()));
1032             }
1033 
1034             // Enter all type parameters into the local method scope.
1035             for (List&lt;JCTypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = l.tail)
1036                 localEnv.info.scope.enterIfAbsent(l.head.type.tsym);
1037 
1038             ClassSymbol owner = env.enclClass.sym;
1039             if ((owner.flags() &amp; ANNOTATION) != 0 &amp;&amp;
1040                     (tree.params.nonEmpty() ||
1041                     tree.recvparam != null))
1042                 log.error(tree.params.nonEmpty() ?
1043                         tree.params.head.pos() :
1044                         tree.recvparam.pos(),
1045                         Errors.IntfAnnotationMembersCantHaveParams);
1046 
1047             // Attribute all value parameters.
1048             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1049                 attribStat(l.head, localEnv);
1050             }
1051 
1052             chk.checkVarargsMethodDecl(localEnv, tree);
1053 
1054             // Check that type parameters are well-formed.
1055             chk.validate(tree.typarams, localEnv);
1056 
1057             // Check that result type is well-formed.
1058             if (tree.restype != null &amp;&amp; !tree.restype.type.hasTag(VOID))
1059                 chk.validate(tree.restype, localEnv);
1060 
1061             // Check that receiver type is well-formed.
1062             if (tree.recvparam != null) {
1063                 // Use a new environment to check the receiver parameter.
1064                 // Otherwise I get &quot;might not have been initialized&quot; errors.
1065                 // Is there a better way?
1066                 Env&lt;AttrContext&gt; newEnv = memberEnter.methodEnv(tree, env);
1067                 attribType(tree.recvparam, newEnv);
1068                 chk.validate(tree.recvparam, newEnv);
1069             }
1070 
1071             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP) {
1072                 // lets find if this method is an accessor
1073                 Optional&lt;? extends RecordComponent&gt; recordComponent = env.enclClass.sym.getRecordComponents().stream()
1074                         .filter(rc -&gt; rc.accessor == tree.sym &amp;&amp; (rc.accessor.flags_field &amp; GENERATED_MEMBER) == 0).findFirst();
1075                 if (recordComponent.isPresent()) {
1076                     // the method is a user defined accessor lets check that everything is fine
1077                     if (!tree.sym.isPublic()) {
1078                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.MethodMustBePublic));
1079                     }
1080                     if (!types.isSameType(tree.sym.type.getReturnType(), recordComponent.get().type)) {
1081                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym,
1082                                 Fragments.AccessorReturnTypeDoesntMatch(tree.sym, recordComponent.get())));
1083                     }
1084                     if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1085                         log.error(tree,
1086                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodCantThrowException));
1087                     }
1088                     if (!tree.typarams.isEmpty()) {
1089                         log.error(tree,
1090                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeGeneric));
1091                     }
1092                     if (tree.sym.isStatic()) {
1093                         log.error(tree,
1094                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeStatic));
1095                     }
1096                 }
1097 
1098                 if (tree.name == names.init) {
1099                     // if this a constructor other than the canonical one
1100                     if ((tree.sym.flags_field &amp; RECORD) == 0) {
1101                         JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1102                         if (app == null ||
1103                                 TreeInfo.name(app.meth) != names._this ||
1104                                 !checkFirstConstructorStat(app, tree, false)) {
1105                             log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);
1106                         }
1107                     } else {
1108                         // but if it is the canonical:
1109 
1110                         // if user generated, then it shouldn&#39;t explicitly invoke any other constructor
1111                         if ((tree.sym.flags_field &amp; GENERATEDCONSTR) == 0) {
1112                             JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1113                             if (app != null &amp;&amp;
1114                                     (TreeInfo.name(app.meth) == names._this ||
1115                                             TreeInfo.name(app.meth) == names._super) &amp;&amp;
1116                                     checkFirstConstructorStat(app, tree, false)) {
1117                                 log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1118                                         Fragments.Canonical, tree.sym.name,
1119                                         Fragments.CanonicalMustNotContainExplicitConstructorInvocation));
1120                             }
1121                         }
1122 
1123                         // also we want to check that no type variables have been defined
1124                         if (!tree.typarams.isEmpty()) {
1125                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1126                                     Fragments.Canonical, tree.sym.name, Fragments.CanonicalMustNotDeclareTypeVariables));
1127                         }
1128 
1129                         /* and now we need to check that the constructor&#39;s arguments are exactly the same as those of the
1130                          * record components
1131                          */
1132                         List&lt;Type&gt; recordComponentTypes = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.type);
1133                         for (JCVariableDecl param: tree.params) {
1134                             if (!types.isSameType(param.type, recordComponentTypes.head)) {
1135                                 log.error(param, Errors.InvalidCanonicalConstructorInRecord(
1136                                         Fragments.Canonical, tree.sym.name, Fragments.TypeMustBeIdenticalToCorrespondingRecordComponentType));
1137                             }
1138                             recordComponentTypes = recordComponentTypes.tail;
1139                         }
1140                     }
1141                 }
1142             }
1143 
1144             // annotation method checks
1145             if ((owner.flags() &amp; ANNOTATION) != 0) {
1146                 // annotation method cannot have throws clause
1147                 if (tree.thrown.nonEmpty()) {
1148                     log.error(tree.thrown.head.pos(),
1149                               Errors.ThrowsNotAllowedInIntfAnnotation);
1150                 }
1151                 // annotation method cannot declare type-parameters
1152                 if (tree.typarams.nonEmpty()) {
1153                     log.error(tree.typarams.head.pos(),
1154                               Errors.IntfAnnotationMembersCantHaveTypeParams);
1155                 }
1156                 // validate annotation method&#39;s return type (could be an annotation type)
1157                 chk.validateAnnotationType(tree.restype);
1158                 // ensure that annotation method does not clash with members of Object/Annotation
1159                 chk.validateAnnotationMethod(tree.pos(), m);
1160             }
1161 
1162             for (List&lt;JCExpression&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
1163                 chk.checkType(l.head.pos(), l.head.type, syms.throwableType);
1164 
1165             if (tree.body == null) {
1166                 // Empty bodies are only allowed for
1167                 // abstract, native, or interface methods, or for methods
1168                 // in a retrofit signature class.
1169                 if (tree.defaultValue != null) {
1170                     if ((owner.flags() &amp; ANNOTATION) == 0)
1171                         log.error(tree.pos(),
1172                                   Errors.DefaultAllowedInIntfAnnotationMember);
1173                 }
1174                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1175                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1176             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1177                 if ((owner.flags() &amp; INTERFACE) != 0) {
1178                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1179                 } else {
1180                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1181                 }
1182             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1183                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1184             } else {
1185                 // Add an implicit super() call unless an explicit call to
1186                 // super(...) or this(...) is given
1187                 // or we are compiling class java.lang.Object.
1188                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1189                     JCBlock body = tree.body;
1190                     if (body.stats.isEmpty() ||
<a name="10" id="anc10"></a><span class="line-modified">1191                             TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {</span>
1192                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1193                                 make.Ident(names._super), make.Idents(List.nil())));
1194                         body.stats = body.stats.prepend(supCall);
1195                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1196                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1197                             TreeInfo.isSuperCall(body.stats.head)) {
1198                         // enum constructors are not allowed to call super
1199                         // directly, so make sure there aren&#39;t any super calls
1200                         // in enum constructors, except in the compiler
1201                         // generated one.
1202                         log.error(tree.body.stats.head.pos(),
1203                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1204                     }
1205                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1206                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1207                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1208                         if (!initParamNames.equals(recordComponentNames)) {
1209                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1210                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1211                         }
1212                         if (!tree.sym.isPublic()) {
1213                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1214                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1215                                     env.enclClass.sym.name, Fragments.CanonicalConstructorMustBePublic));
1216                         }
1217                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1218                             log.error(tree,
1219                                     Errors.InvalidCanonicalConstructorInRecord(
1220                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1221                                             env.enclClass.sym.name,
1222                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1223                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1224                         }
1225                     }
1226                 }
<a name="11" id="anc11"></a><span class="line-added">1227                 if (m.isConstructor() &amp;&amp; m.type.getParameterTypes().size() == 0) {</span>
<span class="line-added">1228                     if ((owner.type == syms.objectType) ||</span>
<span class="line-added">1229                             (tree.body.stats.size() == 1 &amp;&amp; TreeInfo.getConstructorInvocationName(tree.body.stats, names, false) == names._super)) {</span>
<span class="line-added">1230                         m.flags_field |= EMPTYNOARGCONSTR;</span>
<span class="line-added">1231                     }</span>
<span class="line-added">1232                 }</span>
1233 
1234                 // Attribute all type annotations in the body
1235                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1236                 annotate.flush();
1237 
1238                 // Attribute method body.
1239                 attribStat(tree.body, localEnv);
1240             }
1241 
1242             localEnv.info.scope.leave();
1243             result = tree.type = m.type;
1244         } finally {
1245             chk.setLint(prevLint);
1246             chk.setMethod(prevMethod);
1247         }
1248     }
1249 
1250     public void visitVarDef(JCVariableDecl tree) {
1251         // Local variables have not been entered yet, so we need to do it now:
1252         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
1253             if (tree.sym != null) {
1254                 // parameters have already been entered
1255                 env.info.scope.enter(tree.sym);
1256             } else {
1257                 if (tree.isImplicitlyTyped() &amp;&amp; (tree.getModifiers().flags &amp; PARAMETER) == 0) {
1258                     if (tree.init == null) {
1259                         //cannot use &#39;var&#39; without initializer
1260                         log.error(tree, Errors.CantInferLocalVarType(tree.name, Fragments.LocalMissingInit));
1261                         tree.vartype = make.Erroneous();
1262                     } else {
1263                         Fragment msg = canInferLocalVarType(tree);
1264                         if (msg != null) {
1265                             //cannot use &#39;var&#39; with initializer which require an explicit target
1266                             //(e.g. lambda, method reference, array initializer).
1267                             log.error(tree, Errors.CantInferLocalVarType(tree.name, msg));
1268                             tree.vartype = make.Erroneous();
1269                         }
1270                     }
1271                 }
1272                 try {
1273                     annotate.blockAnnotations();
1274                     memberEnter.memberEnter(tree, env);
1275                 } finally {
1276                     annotate.unblockAnnotations();
1277                 }
1278             }
1279         } else {
1280             if (tree.init != null) {
1281                 // Field initializer expression need to be entered.
1282                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1283                 annotate.flush();
1284             }
1285         }
1286 
1287         VarSymbol v = tree.sym;
1288         Lint lint = env.info.lint.augment(v);
1289         Lint prevLint = chk.setLint(lint);
1290 
1291         // Check that the variable&#39;s declared type is well-formed.
1292         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1293                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1294                 (tree.sym.flags() &amp; PARAMETER) != 0;
1295         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1296 
1297         try {
1298             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1299             deferredLintHandler.flush(tree.pos());
1300             chk.checkDeprecatedAnnotation(tree.pos(), v);
1301 
<a name="12" id="anc12"></a><span class="line-added">1302             /* Don&#39;t want constant propagation/folding for instance fields of value classes,</span>
<span class="line-added">1303                as these can undergo updates via copy on write.</span>
<span class="line-added">1304             */</span>
1305             if (tree.init != null) {
<a name="13" id="anc13"></a><span class="line-modified">1306                 if ((v.flags_field &amp; FINAL) == 0 || ((v.flags_field &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) ||</span>
1307                     !memberEnter.needsLazyConstValue(tree.init)) {
1308                     // Not a compile-time constant
1309                     // Attribute initializer in a new environment
1310                     // with the declared variable as owner.
1311                     // Check that initializer conforms to variable&#39;s declared type.
1312                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1313                     initEnv.info.lint = lint;
1314                     // In order to catch self-references, we set the variable&#39;s
1315                     // declaration position to maximal possible value, effectively
1316                     // marking the variable as undefined.
1317                     initEnv.info.enclVar = v;
1318                     attribExpr(tree.init, initEnv, v.type);
1319                     if (tree.isImplicitlyTyped()) {
1320                         //fixup local variable type
1321                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1322                     }
1323                 }
1324                 if (tree.isImplicitlyTyped()) {
1325                     setSyntheticVariableType(tree, v.type);
1326                 }
1327             }
1328             result = tree.type = v.type;
1329             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP &amp;&amp; !v.isStatic()) {
1330                 if (isNonArgsMethodInObject(v.name)) {
1331                     log.error(tree, Errors.IllegalRecordComponentName(v));
1332                 }
1333             }
1334         }
1335         finally {
1336             chk.setLint(prevLint);
1337         }
1338     }
1339 
1340     private boolean isNonArgsMethodInObject(Name name) {
1341         for (Symbol s : syms.objectType.tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1342             if (s.type.getParameterTypes().isEmpty()) {
1343                 return true;
1344             }
1345         }
1346         return false;
1347     }
1348 
1349     Fragment canInferLocalVarType(JCVariableDecl tree) {
1350         LocalInitScanner lis = new LocalInitScanner();
1351         lis.scan(tree.init);
1352         return lis.badInferenceMsg;
1353     }
1354 
1355     static class LocalInitScanner extends TreeScanner {
1356         Fragment badInferenceMsg = null;
1357         boolean needsTarget = true;
1358 
1359         @Override
1360         public void visitNewArray(JCNewArray tree) {
1361             if (tree.elemtype == null &amp;&amp; needsTarget) {
1362                 badInferenceMsg = Fragments.LocalArrayMissingTarget;
1363             }
1364         }
1365 
1366         @Override
1367         public void visitLambda(JCLambda tree) {
1368             if (needsTarget) {
1369                 badInferenceMsg = Fragments.LocalLambdaMissingTarget;
1370             }
1371         }
1372 
1373         @Override
1374         public void visitTypeCast(JCTypeCast tree) {
1375             boolean prevNeedsTarget = needsTarget;
1376             try {
1377                 needsTarget = false;
1378                 super.visitTypeCast(tree);
1379             } finally {
1380                 needsTarget = prevNeedsTarget;
1381             }
1382         }
1383 
1384         @Override
1385         public void visitReference(JCMemberReference tree) {
1386             if (needsTarget) {
1387                 badInferenceMsg = Fragments.LocalMrefMissingTarget;
1388             }
1389         }
1390 
1391         @Override
1392         public void visitNewClass(JCNewClass tree) {
1393             boolean prevNeedsTarget = needsTarget;
1394             try {
1395                 needsTarget = false;
1396                 super.visitNewClass(tree);
1397             } finally {
1398                 needsTarget = prevNeedsTarget;
1399             }
1400         }
1401 
1402         @Override
1403         public void visitApply(JCMethodInvocation tree) {
1404             boolean prevNeedsTarget = needsTarget;
1405             try {
1406                 needsTarget = false;
1407                 super.visitApply(tree);
1408             } finally {
1409                 needsTarget = prevNeedsTarget;
1410             }
1411         }
1412     }
1413 
1414     public void visitSkip(JCSkip tree) {
1415         result = null;
1416     }
1417 
1418     public void visitBlock(JCBlock tree) {
1419         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1420             // Block is a static or instance initializer;
1421             // let the owner of the environment be a freshly
1422             // created BLOCK-method.
1423             Symbol fakeOwner =
1424                 new MethodSymbol(tree.flags | BLOCK |
1425                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1426                     env.info.scope.owner);
1427             final Env&lt;AttrContext&gt; localEnv =
1428                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1429 
<a name="14" id="anc14"></a><span class="line-modified">1430             if ((tree.flags &amp; STATIC) != 0)</span>
<span class="line-added">1431                 localEnv.info.staticLevel++;</span>
<span class="line-added">1432             else if (tree.stats.size() &gt; 0)</span>
<span class="line-added">1433                 env.info.scope.owner.flags_field |= HASINITBLOCK;</span>
<span class="line-added">1434 </span>
1435             // Attribute all type annotations in the block
1436             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1437             annotate.flush();
1438             attribStats(tree.stats, localEnv);
1439 
1440             {
1441                 // Store init and clinit type annotations with the ClassSymbol
1442                 // to allow output in Gen.normalizeDefs.
1443                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1444                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1445                 if ((tree.flags &amp; STATIC) != 0) {
1446                     cs.appendClassInitTypeAttributes(tas);
1447                 } else {
1448                     cs.appendInitTypeAttributes(tas);
1449                 }
1450             }
1451         } else {
1452             // Create a new local environment with a local scope.
1453             Env&lt;AttrContext&gt; localEnv =
1454                 env.dup(tree, env.info.dup(env.info.scope.dup()));
1455             try {
1456                 attribStats(tree.stats, localEnv);
1457             } finally {
1458                 localEnv.info.scope.leave();
1459             }
1460         }
1461         result = null;
1462     }
1463 
1464     public void visitDoLoop(JCDoWhileLoop tree) {
1465         attribStat(tree.body, env.dup(tree));
1466         attribExpr(tree.cond, env, syms.booleanType);
1467         if (!breaksOutOf(tree, tree.body)) {
1468             //include condition&#39;s body when false after the while, if cannot get out of the loop
1469             MatchBindings condBindings = matchBindings;
1470             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1471             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1472         }
1473         result = null;
1474     }
1475 
1476     public void visitWhileLoop(JCWhileLoop tree) {
1477         attribExpr(tree.cond, env, syms.booleanType);
1478         MatchBindings condBindings = matchBindings;
1479         // include condition&#39;s bindings when true in the body:
1480         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1481         try {
1482             attribStat(tree.body, whileEnv.dup(tree));
1483         } finally {
1484             whileEnv.info.scope.leave();
1485         }
1486         if (!breaksOutOf(tree, tree.body)) {
1487             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1488             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1489             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1490         }
1491         result = null;
1492     }
1493 
1494     private boolean breaksOutOf(JCTree loop, JCTree body) {
1495         preFlow(body);
1496         return flow.breaksOutOf(env, loop, body, make);
1497     }
1498 
<a name="15" id="anc15"></a><span class="line-added">1499     public void visitWithField(JCWithField tree) {</span>
<span class="line-added">1500         boolean inWithField = env.info.inWithField;</span>
<span class="line-added">1501         try {</span>
<span class="line-added">1502             env.info.inWithField = true;</span>
<span class="line-added">1503             Type fieldtype = attribTree(tree.field, env.dup(tree), varAssignmentInfo);</span>
<span class="line-added">1504             attribExpr(tree.value, env, fieldtype);</span>
<span class="line-added">1505             Type capturedType = syms.errType;</span>
<span class="line-added">1506             if (tree.field.type != null &amp;&amp; !tree.field.type.isErroneous()) {</span>
<span class="line-added">1507                 final Symbol sym = TreeInfo.symbol(tree.field);</span>
<span class="line-added">1508                 if (sym == null || sym.kind != VAR || sym.owner.kind != TYP ||</span>
<span class="line-added">1509                         (sym.flags() &amp; STATIC) != 0 || !types.isValue(sym.owner.type)) {</span>
<span class="line-added">1510                     log.error(tree.field.pos(), Errors.ValueInstanceFieldExpectedHere);</span>
<span class="line-added">1511                 } else {</span>
<span class="line-added">1512                     Type ownType = sym.owner.type;</span>
<span class="line-added">1513                     switch(tree.field.getTag()) {</span>
<span class="line-added">1514                         case IDENT:</span>
<span class="line-added">1515                             JCIdent ident = (JCIdent) tree.field;</span>
<span class="line-added">1516                             ownType = ident.sym.owner.type;</span>
<span class="line-added">1517                             break;</span>
<span class="line-added">1518                         case SELECT:</span>
<span class="line-added">1519                             JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;</span>
<span class="line-added">1520                             ownType = fieldAccess.selected.type;</span>
<span class="line-added">1521                             break;</span>
<span class="line-added">1522                     }</span>
<span class="line-added">1523                     capturedType = capture(ownType);</span>
<span class="line-added">1524                 }</span>
<span class="line-added">1525             }</span>
<span class="line-added">1526             result = check(tree, capturedType, KindSelector.VAL, resultInfo);</span>
<span class="line-added">1527         } finally {</span>
<span class="line-added">1528             env.info.inWithField = inWithField;</span>
<span class="line-added">1529         }</span>
<span class="line-added">1530     }</span>
<span class="line-added">1531 </span>
1532     public void visitForLoop(JCForLoop tree) {
1533         Env&lt;AttrContext&gt; loopEnv =
1534             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1535         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1536         try {
1537             attribStats(tree.init, loopEnv);
1538             if (tree.cond != null) {
1539                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1540                 // include condition&#39;s bindings when true in the body and step:
1541                 condBindings = matchBindings;
1542             }
1543             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1544             try {
1545                 bodyEnv.tree = tree; // before, we were not in loop!
1546                 attribStats(tree.step, bodyEnv);
1547                 attribStat(tree.body, bodyEnv);
1548             } finally {
1549                 bodyEnv.info.scope.leave();
1550             }
1551             result = null;
1552         }
1553         finally {
1554             loopEnv.info.scope.leave();
1555         }
1556         if (!breaksOutOf(tree, tree.body)) {
1557             //include condition&#39;s body when false after the while, if cannot get out of the loop
1558             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1559             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1560         }
1561     }
1562 
1563     public void visitForeachLoop(JCEnhancedForLoop tree) {
1564         Env&lt;AttrContext&gt; loopEnv =
1565             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1566         try {
1567             //the Formal Parameter of a for-each loop is not in the scope when
1568             //attributing the for-each expression; we mimic this by attributing
1569             //the for-each expression first (against original scope).
1570             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1571             chk.checkNonVoid(tree.pos(), exprType);
1572             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1573             if (elemtype == null) {
1574                 // or perhaps expr implements Iterable&lt;T&gt;?
<a name="16" id="anc16"></a><span class="line-modified">1575                 Type base = types.asSuper(exprType, syms.iterableType.tsym, true);</span>
1576                 if (base == null) {
1577                     log.error(tree.expr.pos(),
1578                               Errors.ForeachNotApplicableToType(exprType,
1579                                                                 Fragments.TypeReqArrayOrIterable));
1580                     elemtype = types.createErrorType(exprType);
1581                 } else {
1582                     List&lt;Type&gt; iterableParams = base.allparams();
1583                     elemtype = iterableParams.isEmpty()
1584                         ? syms.objectType
1585                         : types.wildUpperBound(iterableParams.head);
1586                 }
1587             }
1588             if (tree.var.isImplicitlyTyped()) {
1589                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1590                 setSyntheticVariableType(tree.var, inferredType);
1591             }
1592             attribStat(tree.var, loopEnv);
1593             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1594             loopEnv.tree = tree; // before, we were not in loop!
1595             attribStat(tree.body, loopEnv);
1596             result = null;
1597         }
1598         finally {
1599             loopEnv.info.scope.leave();
1600         }
1601     }
1602 
1603     public void visitLabelled(JCLabeledStatement tree) {
1604         // Check that label is not used in an enclosing statement
1605         Env&lt;AttrContext&gt; env1 = env;
1606         while (env1 != null &amp;&amp; !env1.tree.hasTag(CLASSDEF)) {
1607             if (env1.tree.hasTag(LABELLED) &amp;&amp;
1608                 ((JCLabeledStatement) env1.tree).label == tree.label) {
1609                 log.error(tree.pos(),
1610                           Errors.LabelAlreadyInUse(tree.label));
1611                 break;
1612             }
1613             env1 = env1.next;
1614         }
1615 
1616         attribStat(tree.body, env.dup(tree));
1617         result = null;
1618     }
1619 
1620     public void visitSwitch(JCSwitch tree) {
1621         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
1622             attribStats(c.stats, caseEnv);
1623         });
1624         result = null;
1625     }
1626 
1627     public void visitSwitchExpression(JCSwitchExpression tree) {
1628         tree.polyKind = (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly) ?
1629                 PolyKind.STANDALONE : PolyKind.POLY;
1630 
1631         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1632             //this means we are returning a poly conditional from void-compatible lambda expression
1633             resultInfo.checkContext.report(tree, diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
1634             result = tree.type = types.createErrorType(resultInfo.pt);
1635             return;
1636         }
1637 
1638         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1639                 unknownExprInfo :
1640                 resultInfo.dup(switchExpressionContext(resultInfo.checkContext));
1641 
1642         ListBuffer&lt;DiagnosticPosition&gt; caseTypePositions = new ListBuffer&lt;&gt;();
1643         ListBuffer&lt;Type&gt; caseTypes = new ListBuffer&lt;&gt;();
1644 
1645         handleSwitch(tree, tree.selector, tree.cases, (c, caseEnv) -&gt; {
1646             caseEnv.info.yieldResult = condInfo;
1647             attribStats(c.stats, caseEnv);
1648             new TreeScanner() {
1649                 @Override
1650                 public void visitYield(JCYield brk) {
1651                     if (brk.target == tree) {
1652                         caseTypePositions.append(brk.value != null ? brk.value.pos() : brk.pos());
1653                         caseTypes.append(brk.value != null ? brk.value.type : syms.errType);
1654                     }
1655                     super.visitYield(brk);
1656                 }
1657 
1658                 @Override public void visitClassDef(JCClassDecl tree) {}
1659                 @Override public void visitLambda(JCLambda tree) {}
1660             }.scan(c.stats);
1661         });
1662 
1663         if (tree.cases.isEmpty()) {
1664             log.error(tree.pos(),
1665                       Errors.SwitchExpressionEmpty);
1666         } else if (caseTypes.isEmpty()) {
1667             log.error(tree.pos(),
1668                       Errors.SwitchExpressionNoResultExpressions);
1669         }
1670 
1671         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(caseTypePositions.toList(), caseTypes.toList()) : pt();
1672 
1673         result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);
1674     }
1675     //where:
1676         CheckContext switchExpressionContext(CheckContext checkContext) {
1677             return new Check.NestedCheckContext(checkContext) {
1678                 //this will use enclosing check context to check compatibility of
1679                 //subexpression against target type; if we are in a method check context,
1680                 //depending on whether boxing is allowed, we could have incompatibilities
1681                 @Override
1682                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1683                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInSwitchExpression(details)));
1684                 }
1685             };
1686         }
1687 
1688     private void handleSwitch(JCTree switchTree,
1689                               JCExpression selector,
1690                               List&lt;JCCase&gt; cases,
1691                               BiConsumer&lt;JCCase, Env&lt;AttrContext&gt;&gt; attribCase) {
1692         Type seltype = attribExpr(selector, env);
1693 
1694         Env&lt;AttrContext&gt; switchEnv =
1695             env.dup(switchTree, env.info.dup(env.info.scope.dup()));
1696 
1697         try {
1698             boolean enumSwitch = (seltype.tsym.flags() &amp; Flags.ENUM) != 0;
1699             boolean stringSwitch = types.isSameType(seltype, syms.stringType);
1700             if (!enumSwitch &amp;&amp; !stringSwitch)
1701                 seltype = chk.checkType(selector.pos(), seltype, syms.intType);
1702 
1703             // Attribute all cases and
1704             // check that there are no duplicate case labels or default clauses.
1705             Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
1706             boolean hasDefault = false;      // Is there a default label?
1707             CaseTree.CaseKind caseKind = null;
1708             boolean wasError = false;
1709             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1710                 JCCase c = l.head;
1711                 if (caseKind == null) {
1712                     caseKind = c.caseKind;
1713                 } else if (caseKind != c.caseKind &amp;&amp; !wasError) {
1714                     log.error(c.pos(),
1715                               Errors.SwitchMixingCaseTypes);
1716                     wasError = true;
1717                 }
1718                 if (c.getExpressions().nonEmpty()) {
1719                     for (JCExpression pat : c.getExpressions()) {
1720                         if (TreeInfo.isNull(pat)) {
1721                             log.error(pat.pos(),
1722                                       Errors.SwitchNullNotAllowed);
1723                         } else if (enumSwitch) {
1724                             Symbol sym = enumConstant(pat, seltype);
1725                             if (sym == null) {
1726                                 log.error(pat.pos(), Errors.EnumLabelMustBeUnqualifiedEnum);
1727                             } else if (!labels.add(sym)) {
1728                                 log.error(c.pos(), Errors.DuplicateCaseLabel);
1729                             }
1730                         } else {
1731                             Type pattype = attribExpr(pat, switchEnv, seltype);
1732                             if (!pattype.hasTag(ERROR)) {
1733                                 if (pattype.constValue() == null) {
1734                                     log.error(pat.pos(),
1735                                               (stringSwitch ? Errors.StringConstReq : Errors.ConstExprReq));
1736                                 } else if (!labels.add(pattype.constValue())) {
1737                                     log.error(c.pos(), Errors.DuplicateCaseLabel);
1738                                 }
1739                             }
1740                         }
1741                     }
1742                 } else if (hasDefault) {
1743                     log.error(c.pos(), Errors.DuplicateDefaultLabel);
1744                 } else {
1745                     hasDefault = true;
1746                 }
1747                 Env&lt;AttrContext&gt; caseEnv =
1748                     switchEnv.dup(c, env.info.dup(switchEnv.info.scope.dup()));
1749                 try {
1750                     attribCase.accept(c, caseEnv);
1751                 } finally {
1752                     caseEnv.info.scope.leave();
1753                 }
1754                 addVars(c.stats, switchEnv.info.scope);
1755             }
1756         } finally {
1757             switchEnv.info.scope.leave();
1758         }
1759     }
1760     // where
1761         /** Add any variables defined in stats to the switch scope. */
1762         private static void addVars(List&lt;JCStatement&gt; stats, WriteableScope switchScope) {
1763             for (;stats.nonEmpty(); stats = stats.tail) {
1764                 JCTree stat = stats.head;
1765                 if (stat.hasTag(VARDEF))
1766                     switchScope.enter(((JCVariableDecl) stat).sym);
1767             }
1768         }
1769     // where
1770     /** Return the selected enumeration constant symbol, or null. */
1771     private Symbol enumConstant(JCTree tree, Type enumType) {
1772         if (tree.hasTag(IDENT)) {
1773             JCIdent ident = (JCIdent)tree;
1774             Name name = ident.name;
1775             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1776                 if (sym.kind == VAR) {
1777                     Symbol s = ident.sym = sym;
1778                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1779                     ident.type = s.type;
1780                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1781                         ? null : s;
1782                 }
1783             }
1784         }
1785         return null;
1786     }
1787 
1788     public void visitSynchronized(JCSynchronized tree) {
<a name="17" id="anc17"></a><span class="line-modified">1789         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env), false);</span>
1790         attribStat(tree.body, env);
1791         result = null;
1792     }
1793 
1794     public void visitTry(JCTry tree) {
1795         // Create a new local environment with a local
1796         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1797         try {
1798             boolean isTryWithResource = tree.resources.nonEmpty();
1799             // Create a nested environment for attributing the try block if needed
1800             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1801                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1802                 localEnv;
1803             try {
1804                 // Attribute resource declarations
1805                 for (JCTree resource : tree.resources) {
1806                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1807                         @Override
1808                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1809                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
1810                         }
1811                     };
1812                     ResultInfo twrResult =
1813                         new ResultInfo(KindSelector.VAR,
1814                                        syms.autoCloseableType,
1815                                        twrContext);
1816                     if (resource.hasTag(VARDEF)) {
1817                         attribStat(resource, tryEnv);
1818                         twrResult.check(resource, resource.type);
1819 
1820                         //check that resource type cannot throw InterruptedException
1821                         checkAutoCloseable(resource.pos(), localEnv, resource.type);
1822 
1823                         VarSymbol var = ((JCVariableDecl) resource).sym;
1824                         var.setData(ElementKind.RESOURCE_VARIABLE);
1825                     } else {
1826                         attribTree(resource, tryEnv, twrResult);
1827                     }
1828                 }
1829                 // Attribute body
1830                 attribStat(tree.body, tryEnv);
1831             } finally {
1832                 if (isTryWithResource)
1833                     tryEnv.info.scope.leave();
1834             }
1835 
1836             // Attribute catch clauses
1837             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1838                 JCCatch c = l.head;
1839                 Env&lt;AttrContext&gt; catchEnv =
1840                     localEnv.dup(c, localEnv.info.dup(localEnv.info.scope.dup()));
1841                 try {
1842                     Type ctype = attribStat(c.param, catchEnv);
1843                     if (TreeInfo.isMultiCatch(c)) {
1844                         //multi-catch parameter is implicitly marked as final
1845                         c.param.sym.flags_field |= FINAL | UNION;
1846                     }
1847                     if (c.param.sym.kind == VAR) {
1848                         c.param.sym.setData(ElementKind.EXCEPTION_PARAMETER);
1849                     }
1850                     chk.checkType(c.param.vartype.pos(),
1851                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1852                                   syms.throwableType);
1853                     attribStat(c.body, catchEnv);
1854                 } finally {
1855                     catchEnv.info.scope.leave();
1856                 }
1857             }
1858 
1859             // Attribute finalizer
1860             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1861             result = null;
1862         }
1863         finally {
1864             localEnv.info.scope.leave();
1865         }
1866     }
1867 
1868     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1869         if (!resource.isErroneous() &amp;&amp;
<a name="18" id="anc18"></a><span class="line-modified">1870             types.asSuper(resource, syms.autoCloseableType.tsym, true) != null &amp;&amp;</span>
1871             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1872             Symbol close = syms.noSymbol;
1873             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1874             try {
1875                 close = rs.resolveQualifiedMethod(pos,
1876                         env,
1877                         types.skipTypeVars(resource, false),
1878                         names.close,
1879                         List.nil(),
1880                         List.nil());
1881             }
1882             finally {
1883                 log.popDiagnosticHandler(discardHandler);
1884             }
1885             if (close.kind == MTH &amp;&amp;
1886                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1887                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1888                     env.info.lint.isEnabled(LintCategory.TRY)) {
1889                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1890             }
1891         }
1892     }
1893 
1894     public void visitConditional(JCConditional tree) {
1895         Type condtype = attribExpr(tree.cond, env, syms.booleanType);
1896         MatchBindings condBindings = matchBindings;
1897 
1898         tree.polyKind = (!allowPoly ||
1899                 pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly ||
1900                 isBooleanOrNumeric(env, tree)) ?
1901                 PolyKind.STANDALONE : PolyKind.POLY;
1902 
1903         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1904             //this means we are returning a poly conditional from void-compatible lambda expression
1905             resultInfo.checkContext.report(tree, diags.fragment(Fragments.ConditionalTargetCantBeVoid));
1906             result = tree.type = types.createErrorType(resultInfo.pt);
1907             return;
1908         }
1909 
1910         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1911                 unknownExprInfo :
1912                 resultInfo.dup(conditionalContext(resultInfo.checkContext));
1913 
1914 
1915         // x ? y : z
1916         // include x&#39;s bindings when true in y
1917         // include x&#39;s bindings when false in z
1918 
1919         Type truetype;
1920         Env&lt;AttrContext&gt; trueEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1921         try {
1922             truetype = attribTree(tree.truepart, trueEnv, condInfo);
1923         } finally {
1924             trueEnv.info.scope.leave();
1925         }
1926 
1927         MatchBindings trueBindings = matchBindings;
1928 
1929         Type falsetype;
1930         Env&lt;AttrContext&gt; falseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
1931         try {
1932             falsetype = attribTree(tree.falsepart, falseEnv, condInfo);
1933         } finally {
1934             falseEnv.info.scope.leave();
1935         }
1936 
1937         MatchBindings falseBindings = matchBindings;
1938 
1939         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ?
1940                 condType(List.of(tree.truepart.pos(), tree.falsepart.pos()),
1941                          List.of(truetype, falsetype)) : pt();
1942         if (condtype.constValue() != null &amp;&amp;
1943                 truetype.constValue() != null &amp;&amp;
1944                 falsetype.constValue() != null &amp;&amp;
1945                 !owntype.hasTag(NONE)) {
1946             //constant folding
1947             owntype = cfolder.coerce(condtype.isTrue() ? truetype : falsetype, owntype);
1948         }
1949         result = check(tree, owntype, KindSelector.VAL, resultInfo);
1950         matchBindings = matchBindingsComputer.conditional(tree, condBindings, trueBindings, falseBindings);
1951     }
1952     //where
1953         private boolean isBooleanOrNumeric(Env&lt;AttrContext&gt; env, JCExpression tree) {
1954             switch (tree.getTag()) {
1955                 case LITERAL: return ((JCLiteral)tree).typetag.isSubRangeOf(DOUBLE) ||
1956                               ((JCLiteral)tree).typetag == BOOLEAN ||
1957                               ((JCLiteral)tree).typetag == BOT;
1958                 case LAMBDA: case REFERENCE: return false;
1959                 case PARENS: return isBooleanOrNumeric(env, ((JCParens)tree).expr);
1960                 case CONDEXPR:
1961                     JCConditional condTree = (JCConditional)tree;
1962                     return isBooleanOrNumeric(env, condTree.truepart) &amp;&amp;
1963                             isBooleanOrNumeric(env, condTree.falsepart);
1964                 case APPLY:
1965                     JCMethodInvocation speculativeMethodTree =
1966                             (JCMethodInvocation)deferredAttr.attribSpeculative(
1967                                     tree, env, unknownExprInfo,
1968                                     argumentAttr.withLocalCacheContext());
1969                     Symbol msym = TreeInfo.symbol(speculativeMethodTree.meth);
1970                     Type receiverType = speculativeMethodTree.meth.hasTag(IDENT) ?
1971                             env.enclClass.type :
1972                             ((JCFieldAccess)speculativeMethodTree.meth).selected.type;
1973                     Type owntype = types.memberType(receiverType, msym).getReturnType();
1974                     return primitiveOrBoxed(owntype);
1975                 case NEWCLASS:
1976                     JCExpression className =
1977                             removeClassParams.translate(((JCNewClass)tree).clazz);
1978                     JCExpression speculativeNewClassTree =
1979                             (JCExpression)deferredAttr.attribSpeculative(
1980                                     className, env, unknownTypeInfo,
1981                                     argumentAttr.withLocalCacheContext());
1982                     return primitiveOrBoxed(speculativeNewClassTree.type);
1983                 default:
1984                     Type speculativeType = deferredAttr.attribSpeculative(tree, env, unknownExprInfo,
1985                             argumentAttr.withLocalCacheContext()).type;
1986                     return primitiveOrBoxed(speculativeType);
1987             }
1988         }
1989         //where
1990             boolean primitiveOrBoxed(Type t) {
1991                 return (!t.hasTag(TYPEVAR) &amp;&amp; types.unboxedTypeOrType(t).isPrimitive());
1992             }
1993 
1994             TreeTranslator removeClassParams = new TreeTranslator() {
1995                 @Override
1996                 public void visitTypeApply(JCTypeApply tree) {
1997                     result = translate(tree.clazz);
1998                 }
1999             };
2000 
2001         CheckContext conditionalContext(CheckContext checkContext) {
2002             return new Check.NestedCheckContext(checkContext) {
2003                 //this will use enclosing check context to check compatibility of
2004                 //subexpression against target type; if we are in a method check context,
2005                 //depending on whether boxing is allowed, we could have incompatibilities
2006                 @Override
2007                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
2008                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInConditional(details)));
2009                 }
2010             };
2011         }
2012 
2013         /** Compute the type of a conditional expression, after
2014          *  checking that it exists.  See JLS 15.25. Does not take into
2015          *  account the special case where condition and both arms
2016          *  are constants.
2017          *
2018          *  @param pos      The source position to be used for error
2019          *                  diagnostics.
2020          *  @param thentype The type of the expression&#39;s then-part.
2021          *  @param elsetype The type of the expression&#39;s else-part.
2022          */
2023         Type condType(List&lt;DiagnosticPosition&gt; positions, List&lt;Type&gt; condTypes) {
2024             if (condTypes.isEmpty()) {
2025                 return syms.objectType; //TODO: how to handle?
2026             }
2027             Type first = condTypes.head;
2028             // If same type, that is the result
2029             if (condTypes.tail.stream().allMatch(t -&gt; types.isSameType(first, t)))
2030                 return first.baseType();
2031 
2032             List&lt;Type&gt; unboxedTypes = condTypes.stream()
2033                                                .map(t -&gt; t.isPrimitive() ? t : types.unboxedType(t))
2034                                                .collect(List.collector());
2035 
2036             // Otherwise, if both arms can be converted to a numeric
2037             // type, return the least numeric type that fits both arms
2038             // (i.e. return larger of the two, or return int if one
2039             // arm is short, the other is char).
2040             if (unboxedTypes.stream().allMatch(t -&gt; t.isPrimitive())) {
2041                 // If one arm has an integer subrange type (i.e., byte,
2042                 // short, or char), and the other is an integer constant
2043                 // that fits into the subrange, return the subrange type.
2044                 for (Type type : unboxedTypes) {
2045                     if (!type.getTag().isStrictSubRangeOf(INT)) {
2046                         continue;
2047                     }
2048                     if (unboxedTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; t.hasTag(INT) &amp;&amp; types.isAssignable(t, type)))
2049                         return type.baseType();
2050                 }
2051 
2052                 for (TypeTag tag : primitiveTags) {
2053                     Type candidate = syms.typeOfTag[tag.ordinal()];
2054                     if (unboxedTypes.stream().allMatch(t -&gt; types.isSubtype(t, candidate))) {
2055                         return candidate;
2056                     }
2057                 }
2058             }
2059 
2060             // Those were all the cases that could result in a primitive
2061             condTypes = condTypes.stream()
2062                                  .map(t -&gt; t.isPrimitive() ? types.boxedClass(t).type : t)
2063                                  .collect(List.collector());
2064 
2065             for (Type type : condTypes) {
2066                 if (condTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; types.isAssignable(t, type)))
2067                     return type.baseType();
2068             }
2069 
2070             Iterator&lt;DiagnosticPosition&gt; posIt = positions.iterator();
2071 
2072             condTypes = condTypes.stream()
2073                                  .map(t -&gt; chk.checkNonVoid(posIt.next(), t))
2074                                  .collect(List.collector());
2075 
2076             // both are known to be reference types.  The result is
2077             // lub(thentype,elsetype). This cannot fail, as it will
2078             // always be possible to infer &quot;Object&quot; if nothing better.
2079             return types.lub(condTypes.stream().map(t -&gt; t.baseType()).collect(List.collector()));
2080         }
2081 
2082     final static TypeTag[] primitiveTags = new TypeTag[]{
2083         BYTE,
2084         CHAR,
2085         SHORT,
2086         INT,
2087         LONG,
2088         FLOAT,
2089         DOUBLE,
2090         BOOLEAN,
2091     };
2092 
2093     Env&lt;AttrContext&gt; bindingEnv(Env&lt;AttrContext&gt; env, List&lt;BindingSymbol&gt; bindings) {
2094         Env&lt;AttrContext&gt; env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));
2095         bindings.forEach(env1.info.scope::enter);
2096         return env1;
2097     }
2098 
2099     public void visitIf(JCIf tree) {
2100         attribExpr(tree.cond, env, syms.booleanType);
2101 
2102         // if (x) { y } [ else z ]
2103         // include x&#39;s bindings when true in y
2104         // include x&#39;s bindings when false in z
2105 
2106         MatchBindings condBindings = matchBindings;
2107         Env&lt;AttrContext&gt; thenEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
2108 
2109         try {
2110             attribStat(tree.thenpart, thenEnv);
2111         } finally {
2112             thenEnv.info.scope.leave();
2113         }
2114 
2115         preFlow(tree.thenpart);
2116         boolean aliveAfterThen = flow.aliveAfter(env, tree.thenpart, make);
2117         boolean aliveAfterElse;
2118 
2119         if (tree.elsepart != null) {
2120             Env&lt;AttrContext&gt; elseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
2121             try {
2122                 attribStat(tree.elsepart, elseEnv);
2123             } finally {
2124                 elseEnv.info.scope.leave();
2125             }
2126             preFlow(tree.elsepart);
2127             aliveAfterElse = flow.aliveAfter(env, tree.elsepart, make);
2128         } else {
2129             aliveAfterElse = true;
2130         }
2131 
2132         chk.checkEmptyIf(tree);
2133 
2134         List&lt;BindingSymbol&gt; afterIfBindings = List.nil();
2135 
2136         if (aliveAfterThen &amp;&amp; !aliveAfterElse) {
2137             afterIfBindings = condBindings.bindingsWhenTrue;
2138         } else if (aliveAfterElse &amp;&amp; !aliveAfterThen) {
2139             afterIfBindings = condBindings.bindingsWhenFalse;
2140         }
2141 
2142         afterIfBindings.forEach(env.info.scope::enter);
2143         afterIfBindings.forEach(BindingSymbol::preserveBinding);
2144 
2145         result = null;
2146     }
2147 
2148         void preFlow(JCTree tree) {
2149             new PostAttrAnalyzer() {
2150                 @Override
2151                 public void scan(JCTree tree) {
2152                     if (tree == null ||
2153                             (tree.type != null &amp;&amp;
2154                             tree.type == Type.stuckType)) {
2155                         //don&#39;t touch stuck expressions!
2156                         return;
2157                     }
2158                     super.scan(tree);
2159                 }
2160             }.scan(tree);
2161         }
2162 
2163     public void visitExec(JCExpressionStatement tree) {
2164         //a fresh environment is required for 292 inference to work properly ---
2165         //see Infer.instantiatePolymorphicSignatureInstance()
2166         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2167         attribExpr(tree.expr, localEnv);
2168         result = null;
2169     }
2170 
2171     public void visitBreak(JCBreak tree) {
2172         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2173         result = null;
2174     }
2175 
2176     public void visitYield(JCYield tree) {
2177         if (env.info.yieldResult != null) {
2178             attribTree(tree.value, env, env.info.yieldResult);
2179             tree.target = findJumpTarget(tree.pos(), tree.getTag(), names.empty, env);
2180         } else {
2181             log.error(tree.pos(), tree.value.hasTag(PARENS)
2182                     ? Errors.NoSwitchExpressionQualify
2183                     : Errors.NoSwitchExpression);
2184             attribTree(tree.value, env, unknownExprInfo);
2185         }
2186         result = null;
2187     }
2188 
2189     public void visitContinue(JCContinue tree) {
2190         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2191         result = null;
2192     }
2193     //where
2194         /** Return the target of a break, continue or yield statement,
2195          *  if it exists, report an error if not.
2196          *  Note: The target of a labelled break or continue is the
2197          *  (non-labelled) statement tree referred to by the label,
2198          *  not the tree representing the labelled statement itself.
2199          *
2200          *  @param pos     The position to be used for error diagnostics
2201          *  @param tag     The tag of the jump statement. This is either
2202          *                 Tree.BREAK or Tree.CONTINUE.
2203          *  @param label   The label of the jump statement, or null if no
2204          *                 label is given.
2205          *  @param env     The environment current at the jump statement.
2206          */
2207         private JCTree findJumpTarget(DiagnosticPosition pos,
2208                                                    JCTree.Tag tag,
2209                                                    Name label,
2210                                                    Env&lt;AttrContext&gt; env) {
2211             Pair&lt;JCTree, Error&gt; jumpTarget = findJumpTargetNoError(tag, label, env);
2212 
2213             if (jumpTarget.snd != null) {
2214                 log.error(pos, jumpTarget.snd);
2215             }
2216 
2217             return jumpTarget.fst;
2218         }
2219         /** Return the target of a break or continue statement, if it exists,
2220          *  report an error if not.
2221          *  Note: The target of a labelled break or continue is the
2222          *  (non-labelled) statement tree referred to by the label,
2223          *  not the tree representing the labelled statement itself.
2224          *
2225          *  @param tag     The tag of the jump statement. This is either
2226          *                 Tree.BREAK or Tree.CONTINUE.
2227          *  @param label   The label of the jump statement, or null if no
2228          *                 label is given.
2229          *  @param env     The environment current at the jump statement.
2230          */
2231         private Pair&lt;JCTree, JCDiagnostic.Error&gt; findJumpTargetNoError(JCTree.Tag tag,
2232                                                                        Name label,
2233                                                                        Env&lt;AttrContext&gt; env) {
2234             // Search environments outwards from the point of jump.
2235             Env&lt;AttrContext&gt; env1 = env;
2236             JCDiagnostic.Error pendingError = null;
2237             LOOP:
2238             while (env1 != null) {
2239                 switch (env1.tree.getTag()) {
2240                     case LABELLED:
2241                         JCLabeledStatement labelled = (JCLabeledStatement)env1.tree;
2242                         if (label == labelled.label) {
2243                             // If jump is a continue, check that target is a loop.
2244                             if (tag == CONTINUE) {
2245                                 if (!labelled.body.hasTag(DOLOOP) &amp;&amp;
2246                                         !labelled.body.hasTag(WHILELOOP) &amp;&amp;
2247                                         !labelled.body.hasTag(FORLOOP) &amp;&amp;
2248                                         !labelled.body.hasTag(FOREACHLOOP)) {
2249                                     pendingError = Errors.NotLoopLabel(label);
2250                                 }
2251                                 // Found labelled statement target, now go inwards
2252                                 // to next non-labelled tree.
2253                                 return Pair.of(TreeInfo.referencedStatement(labelled), pendingError);
2254                             } else {
2255                                 return Pair.of(labelled, pendingError);
2256                             }
2257                         }
2258                         break;
2259                     case DOLOOP:
2260                     case WHILELOOP:
2261                     case FORLOOP:
2262                     case FOREACHLOOP:
2263                         if (label == null) return Pair.of(env1.tree, pendingError);
2264                         break;
2265                     case SWITCH:
2266                         if (label == null &amp;&amp; tag == BREAK) return Pair.of(env1.tree, null);
2267                         break;
2268                     case SWITCH_EXPRESSION:
2269                         if (tag == YIELD) {
2270                             return Pair.of(env1.tree, null);
2271                         } else if (tag == BREAK) {
2272                             pendingError = Errors.BreakOutsideSwitchExpression;
2273                         } else {
2274                             pendingError = Errors.ContinueOutsideSwitchExpression;
2275                         }
2276                         break;
2277                     case LAMBDA:
2278                     case METHODDEF:
2279                     case CLASSDEF:
2280                         break LOOP;
2281                     default:
2282                 }
2283                 env1 = env1.next;
2284             }
2285             if (label != null)
2286                 return Pair.of(null, Errors.UndefLabel(label));
2287             else if (pendingError != null)
2288                 return Pair.of(null, pendingError);
2289             else if (tag == CONTINUE)
2290                 return Pair.of(null, Errors.ContOutsideLoop);
2291             else
2292                 return Pair.of(null, Errors.BreakOutsideSwitchLoop);
2293         }
2294 
2295     public void visitReturn(JCReturn tree) {
2296         // Check that there is an enclosing method which is
2297         // nested within than the enclosing class.
2298         if (env.info.returnResult == null) {
2299             log.error(tree.pos(), Errors.RetOutsideMeth);
2300         } else if (env.info.yieldResult != null) {
2301             log.error(tree.pos(), Errors.ReturnOutsideSwitchExpression);
2302         } else if (!env.info.isLambda &amp;&amp;
2303                 !env.info.isNewClass &amp;&amp;
2304                 env.enclMethod != null &amp;&amp;
2305                 TreeInfo.isCompactConstructor(env.enclMethod)) {
2306             log.error(env.enclMethod,
2307                     Errors.InvalidCanonicalConstructorInRecord(Fragments.Compact, env.enclMethod.sym.name, Fragments.CanonicalCantHaveReturnStatement));
2308         } else {
2309             // Attribute return expression, if it exists, and check that
2310             // it conforms to result type of enclosing method.
2311             if (tree.expr != null) {
2312                 if (env.info.returnResult.pt.hasTag(VOID)) {
2313                     env.info.returnResult.checkContext.report(tree.expr.pos(),
2314                               diags.fragment(Fragments.UnexpectedRetVal));
2315                 }
2316                 attribTree(tree.expr, env, env.info.returnResult);
2317             } else if (!env.info.returnResult.pt.hasTag(VOID) &amp;&amp;
2318                     !env.info.returnResult.pt.hasTag(NONE)) {
2319                 env.info.returnResult.checkContext.report(tree.pos(),
2320                               diags.fragment(Fragments.MissingRetVal(env.info.returnResult.pt)));
2321             }
2322         }
2323         result = null;
2324     }
2325 
2326     public void visitThrow(JCThrow tree) {
2327         Type owntype = attribExpr(tree.expr, env, allowPoly ? Type.noType : syms.throwableType);
2328         if (allowPoly) {
2329             chk.checkType(tree, owntype, syms.throwableType);
2330         }
2331         result = null;
2332     }
2333 
2334     public void visitAssert(JCAssert tree) {
2335         attribExpr(tree.cond, env, syms.booleanType);
2336         if (tree.detail != null) {
2337             chk.checkNonVoid(tree.detail.pos(), attribExpr(tree.detail, env));
2338         }
2339         result = null;
2340     }
2341 
2342      /** Visitor method for method invocations.
2343      *  NOTE: The method part of an application will have in its type field
2344      *        the return type of the method, not the method&#39;s type itself!
2345      */
2346     public void visitApply(JCMethodInvocation tree) {
2347         // The local environment of a method application is
2348         // a new environment nested in the current one.
2349         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2350 
2351         // The types of the actual method arguments.
2352         List&lt;Type&gt; argtypes;
2353 
2354         // The types of the actual method type arguments.
2355         List&lt;Type&gt; typeargtypes = null;
2356 
2357         Name methName = TreeInfo.name(tree.meth);
2358 
2359         boolean isConstructorCall =
2360             methName == names._this || methName == names._super;
2361 
2362         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2363         if (isConstructorCall) {
2364             // We are seeing a ...this(...) or ...super(...) call.
2365             // Check that this is the first statement in a constructor.
2366             checkFirstConstructorStat(tree, env.enclMethod, true);
2367 
2368             // Record the fact
2369             // that this is a constructor call (using isSelfCall).
2370             localEnv.info.isSelfCall = true;
2371 
2372             // Attribute arguments, yielding list of argument types.
2373             KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
2374             argtypes = argtypesBuf.toList();
2375             typeargtypes = attribTypes(tree.typeargs, localEnv);
2376 
2377             // Variable `site&#39; points to the class in which the called
2378             // constructor is defined.
2379             Type site = env.enclClass.sym.type;
2380             if (methName == names._super) {
2381                 if (site == syms.objectType) {
2382                     log.error(tree.meth.pos(), Errors.NoSuperclass(site));
2383                     site = types.createErrorType(syms.objectType);
2384                 } else {
2385                     site = types.supertype(site);
2386                 }
2387             }
2388 
2389             if (site.hasTag(CLASS)) {
2390                 Type encl = site.getEnclosingType();
2391                 while (encl != null &amp;&amp; encl.hasTag(TYPEVAR))
2392                     encl = encl.getUpperBound();
2393                 if (encl.hasTag(CLASS)) {
2394                     // we are calling a nested class
2395 
2396                     if (tree.meth.hasTag(SELECT)) {
2397                         JCTree qualifier = ((JCFieldAccess) tree.meth).selected;
2398 
2399                         // We are seeing a prefixed call, of the form
2400                         //     &lt;expr&gt;.super(...).
2401                         // Check that the prefix expression conforms
2402                         // to the outer instance type of the class.
2403                         chk.checkRefType(qualifier.pos(),
2404                                          attribExpr(qualifier, localEnv,
2405                                                     encl));
2406                     } else if (methName == names._super) {
2407                         // qualifier omitted; check for existence
2408                         // of an appropriate implicit qualifier.
2409                         rs.resolveImplicitThis(tree.meth.pos(),
2410                                                localEnv, site, true);
2411                     }
2412                 } else if (tree.meth.hasTag(SELECT)) {
2413                     log.error(tree.meth.pos(),
2414                               Errors.IllegalQualNotIcls(site.tsym));
2415                 }
2416 
2417                 // if we&#39;re calling a java.lang.Enum constructor,
2418                 // prefix the implicit String and int parameters
2419                 if (site.tsym == syms.enumSym)
2420                     argtypes = argtypes.prepend(syms.intType).prepend(syms.stringType);
2421 
2422                 // Resolve the called constructor under the assumption
2423                 // that we are referring to a superclass instance of the
2424                 // current instance (JLS ???).
2425                 boolean selectSuperPrev = localEnv.info.selectSuper;
2426                 localEnv.info.selectSuper = true;
2427                 localEnv.info.pendingResolutionPhase = null;
2428                 Symbol sym = rs.resolveConstructor(
2429                     tree.meth.pos(), localEnv, site, argtypes, typeargtypes);
2430                 localEnv.info.selectSuper = selectSuperPrev;
2431 
2432                 // Set method symbol to resolved constructor...
2433                 TreeInfo.setSymbol(tree.meth, sym);
2434 
2435                 // ...and check that it is legal in the current context.
2436                 // (this will also set the tree&#39;s type)
2437                 Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2438                 checkId(tree.meth, site, sym, localEnv,
2439                         new ResultInfo(kind, mpt));
2440             }
2441             // Otherwise, `site&#39; is an error type and we do nothing
2442             result = tree.type = syms.voidType;
2443         } else {
2444             // Otherwise, we are seeing a regular method call.
2445             // Attribute the arguments, yielding list of argument types, ...
2446             KindSelector kind = attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2447             argtypes = argtypesBuf.toList();
2448             typeargtypes = attribAnyTypes(tree.typeargs, localEnv);
2449 
2450             // ... and attribute the method using as a prototype a methodtype
2451             // whose formal argument types is exactly the list of actual
2452             // arguments (this will also set the method symbol).
2453             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2454             localEnv.info.pendingResolutionPhase = null;
2455             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2456 
2457             // Compute the result type.
2458             Type restype = mtype.getReturnType();
2459             if (restype.hasTag(WILDCARD))
2460                 throw new AssertionError(mtype);
2461 
2462             Type qualifier = (tree.meth.hasTag(SELECT))
2463                     ? ((JCFieldAccess) tree.meth).selected.type
2464                     : env.enclClass.sym.type;
2465             Symbol msym = TreeInfo.symbol(tree.meth);
2466             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2467 
2468             chk.checkRefTypes(tree.typeargs, typeargtypes);
2469 
<a name="19" id="anc19"></a><span class="line-added">2470             final Symbol symbol = TreeInfo.symbol(tree.meth);</span>
<span class="line-added">2471             if (symbol != null) {</span>
<span class="line-added">2472                 /* Is this an ill conceived attempt to invoke jlO methods not available on value types ??</span>
<span class="line-added">2473                  */</span>
<span class="line-added">2474                 boolean superCallOnValueReceiver = types.isValue(env.enclClass.sym.type)</span>
<span class="line-added">2475                         &amp;&amp; (tree.meth.hasTag(SELECT))</span>
<span class="line-added">2476                         &amp;&amp; ((JCFieldAccess)tree.meth).selected.hasTag(IDENT)</span>
<span class="line-added">2477                         &amp;&amp; TreeInfo.name(((JCFieldAccess)tree.meth).selected) == names._super;</span>
<span class="line-added">2478                 if (types.isValue(qualifier) || superCallOnValueReceiver) {</span>
<span class="line-added">2479                     int argSize = argtypes.size();</span>
<span class="line-added">2480                     Name name = symbol.name;</span>
<span class="line-added">2481                     switch (name.toString()) {</span>
<span class="line-added">2482                         case &quot;wait&quot;:</span>
<span class="line-added">2483                             if (argSize == 0</span>
<span class="line-added">2484                                     || (types.isConvertible(argtypes.head, syms.longType) &amp;&amp;</span>
<span class="line-added">2485                                     (argSize == 1 || (argSize == 2 &amp;&amp; types.isConvertible(argtypes.tail.head, syms.intType))))) {</span>
<span class="line-added">2486                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));</span>
<span class="line-added">2487                             }</span>
<span class="line-added">2488                             break;</span>
<span class="line-added">2489                         case &quot;notify&quot;:</span>
<span class="line-added">2490                         case &quot;notifyAll&quot;:</span>
<span class="line-added">2491                         case &quot;clone&quot;:</span>
<span class="line-added">2492                         case &quot;finalize&quot;:</span>
<span class="line-added">2493                             if (argSize == 0)</span>
<span class="line-added">2494                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));</span>
<span class="line-added">2495                             break;</span>
<span class="line-added">2496                         case &quot;hashCode&quot;:</span>
<span class="line-added">2497                         case &quot;equals&quot;:</span>
<span class="line-added">2498                         case &quot;toString&quot;:</span>
<span class="line-added">2499                             if (superCallOnValueReceiver)</span>
<span class="line-added">2500                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(names.fromString(&quot;invocation of super.&quot; + name)));</span>
<span class="line-added">2501                             break;</span>
<span class="line-added">2502                     }</span>
<span class="line-added">2503                 }</span>
<span class="line-added">2504             }</span>
<span class="line-added">2505 </span>
2506             // Check that value of resulting type is admissible in the
2507             // current context.  Also, capture the return type
2508             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2509             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2510         }
2511         chk.validate(tree.typeargs, localEnv);
2512     }
2513     //where
2514         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2515             if (msym != null &amp;&amp;
2516                     msym.owner == syms.objectType.tsym &amp;&amp;
2517                     methodName == names.getClass &amp;&amp;
2518                     argtypes.isEmpty()) {
2519                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;
<a name="20" id="anc20"></a><span class="line-added">2520                 // Temporary treatment for inline class: Given an inline class V that implements</span>
<span class="line-added">2521                 // I1, I2, ... In, v.getClass() is typed to be Class&lt;? extends Object &amp; I1 &amp; I2 .. &amp; In&gt;</span>
<span class="line-added">2522                 Type wcb;</span>
<span class="line-added">2523                 if (qualifierType.isValue()) {</span>
<span class="line-added">2524                     List&lt;Type&gt; bounds = List.of(syms.objectType).appendList(((ClassSymbol) qualifierType.tsym).getInterfaces());</span>
<span class="line-added">2525                     wcb = types.makeIntersectionType(bounds);</span>
<span class="line-added">2526                 } else {</span>
<span class="line-added">2527                     wcb = types.erasure(qualifierType);</span>
<span class="line-added">2528                 }</span>
2529                 return new ClassType(restype.getEnclosingType(),
<a name="21" id="anc21"></a><span class="line-modified">2530                         List.of(new WildcardType(wcb,</span>
2531                                 BoundKind.EXTENDS,
2532                                 syms.boundClass)),
2533                         restype.tsym,
2534                         restype.getMetadata());
2535             } else if (msym != null &amp;&amp;
2536                     msym.owner == syms.arrayClass &amp;&amp;
2537                     methodName == names.clone &amp;&amp;
2538                     types.isArray(qualifierType)) {
2539                 // as a special case, array.clone() has a result that is
2540                 // the same as static type of the array being cloned
2541                 return qualifierType;
2542             } else {
2543                 return restype;
2544             }
2545         }
2546 
2547         /** Check that given application node appears as first statement
2548          *  in a constructor call.
2549          *  @param tree          The application node
2550          *  @param enclMethod    The enclosing method of the application.
2551          *  @param error         Should an error be issued?
2552          */
2553         boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {
2554             if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
2555                 JCBlock body = enclMethod.body;
2556                 if (body.stats.head.hasTag(EXEC) &amp;&amp;
2557                     ((JCExpressionStatement) body.stats.head).expr == tree)
2558                     return true;
2559             }
2560             if (error) {
2561                 log.error(tree.pos(),
2562                         Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));
2563             }
2564             return false;
2565         }
2566 
2567         /** Obtain a method type with given argument types.
2568          */
2569         Type newMethodTemplate(Type restype, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2570             MethodType mt = new MethodType(argtypes, restype, List.nil(), syms.methodClass);
2571             return (typeargtypes == null) ? mt : (Type)new ForAll(typeargtypes, mt);
2572         }
2573 
2574     public void visitNewClass(final JCNewClass tree) {
2575         Type owntype = types.createErrorType(tree.type);
2576 
2577         // The local environment of a class creation is
2578         // a new environment nested in the current one.
2579         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2580 
2581         // The anonymous inner class definition of the new expression,
2582         // if one is defined by it.
2583         JCClassDecl cdef = tree.def;
2584 
2585         // If enclosing class is given, attribute it, and
2586         // complete class name to be fully qualified
2587         JCExpression clazz = tree.clazz; // Class field following new
2588         JCExpression clazzid;            // Identifier in class field
2589         JCAnnotatedType annoclazzid;     // Annotated type enclosing clazzid
2590         annoclazzid = null;
2591 
2592         if (clazz.hasTag(TYPEAPPLY)) {
2593             clazzid = ((JCTypeApply) clazz).clazz;
2594             if (clazzid.hasTag(ANNOTATED_TYPE)) {
2595                 annoclazzid = (JCAnnotatedType) clazzid;
2596                 clazzid = annoclazzid.underlyingType;
2597             }
2598         } else {
2599             if (clazz.hasTag(ANNOTATED_TYPE)) {
2600                 annoclazzid = (JCAnnotatedType) clazz;
2601                 clazzid = annoclazzid.underlyingType;
2602             } else {
2603                 clazzid = clazz;
2604             }
2605         }
2606 
2607         JCExpression clazzid1 = clazzid; // The same in fully qualified form
2608 
2609         if (tree.encl != null) {
2610             // We are seeing a qualified new, of the form
2611             //    &lt;expr&gt;.new C &lt;...&gt; (...) ...
2612             // In this case, we let clazz stand for the name of the
2613             // allocated class C prefixed with the type of the qualifier
2614             // expression, so that we can
2615             // resolve it with standard techniques later. I.e., if
2616             // &lt;expr&gt; has type T, then &lt;expr&gt;.new C &lt;...&gt; (...)
2617             // yields a clazz T.C.
2618             Type encltype = chk.checkRefType(tree.encl.pos(),
2619                                              attribExpr(tree.encl, env));
2620             // TODO 308: in &lt;expr&gt;.new C, do we also want to add the type annotations
2621             // from expr to the combined type, or not? Yes, do this.
2622             clazzid1 = make.at(clazz.pos).Select(make.Type(encltype),
2623                                                  ((JCIdent) clazzid).name);
2624 
2625             EndPosTable endPosTable = this.env.toplevel.endPositions;
2626             endPosTable.storeEnd(clazzid1, tree.getEndPosition(endPosTable));
2627             if (clazz.hasTag(ANNOTATED_TYPE)) {
2628                 JCAnnotatedType annoType = (JCAnnotatedType) clazz;
2629                 List&lt;JCAnnotation&gt; annos = annoType.annotations;
2630 
2631                 if (annoType.underlyingType.hasTag(TYPEAPPLY)) {
2632                     clazzid1 = make.at(tree.pos).
2633                         TypeApply(clazzid1,
2634                                   ((JCTypeApply) clazz).arguments);
2635                 }
2636 
2637                 clazzid1 = make.at(tree.pos).
2638                     AnnotatedType(annos, clazzid1);
2639             } else if (clazz.hasTag(TYPEAPPLY)) {
2640                 clazzid1 = make.at(tree.pos).
2641                     TypeApply(clazzid1,
2642                               ((JCTypeApply) clazz).arguments);
2643             }
2644 
2645             clazz = clazzid1;
2646         }
2647 
2648         // Attribute clazz expression and store
2649         // symbol + type back into the attributed tree.
2650         Type clazztype;
2651 
2652         try {
2653             env.info.isNewClass = true;
2654             clazztype = TreeInfo.isEnumInit(env.tree) ?
2655                 attribIdentAsEnumType(env, (JCIdent)clazz) :
2656                 attribType(clazz, env);
2657         } finally {
2658             env.info.isNewClass = false;
2659         }
2660 
2661         clazztype = chk.checkDiamond(tree, clazztype);
2662         chk.validate(clazz, localEnv);
2663         if (tree.encl != null) {
2664             // We have to work in this case to store
2665             // symbol + type back into the attributed tree.
2666             tree.clazz.type = clazztype;
2667             TreeInfo.setSymbol(clazzid, TreeInfo.symbol(clazzid1));
2668             clazzid.type = ((JCIdent) clazzid).sym.type;
2669             if (annoclazzid != null) {
2670                 annoclazzid.type = clazzid.type;
2671             }
2672             if (!clazztype.isErroneous()) {
2673                 if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2674                     log.error(tree.encl.pos(), Errors.AnonClassImplIntfNoQualForNew);
2675                 } else if (clazztype.tsym.isStatic()) {
2676                     log.error(tree.encl.pos(), Errors.QualifiedNewOfStaticClass(clazztype.tsym));
2677                 }
2678             }
2679         } else if (!clazztype.tsym.isInterface() &amp;&amp;
2680                    clazztype.getEnclosingType().hasTag(CLASS)) {
2681             // Check for the existence of an apropos outer instance
2682             rs.resolveImplicitThis(tree.pos(), env, clazztype);
2683         }
2684 
2685         // Attribute constructor arguments.
2686         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2687         final KindSelector pkind =
2688             attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2689         List&lt;Type&gt; argtypes = argtypesBuf.toList();
2690         List&lt;Type&gt; typeargtypes = attribTypes(tree.typeargs, localEnv);
2691 
2692         if (clazztype.hasTag(CLASS) || clazztype.hasTag(ERROR)) {
2693             // Enums may not be instantiated except implicitly
2694             if ((clazztype.tsym.flags_field &amp; Flags.ENUM) != 0 &amp;&amp;
2695                 (!env.tree.hasTag(VARDEF) ||
2696                  (((JCVariableDecl) env.tree).mods.flags &amp; Flags.ENUM) == 0 ||
2697                  ((JCVariableDecl) env.tree).init != tree))
2698                 log.error(tree.pos(), Errors.EnumCantBeInstantiated);
2699 
2700             boolean isSpeculativeDiamondInferenceRound = TreeInfo.isDiamond(tree) &amp;&amp;
2701                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
2702             boolean skipNonDiamondPath = false;
2703             // Check that class is not abstract
2704             if (cdef == null &amp;&amp; !isSpeculativeDiamondInferenceRound &amp;&amp; // class body may be nulled out in speculative tree copy
2705                 (clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
2706                 log.error(tree.pos(),
2707                           Errors.AbstractCantBeInstantiated(clazztype.tsym));
2708                 skipNonDiamondPath = true;
2709             } else if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2710                 // Check that no constructor arguments are given to
2711                 // anonymous classes implementing an interface
2712                 if (!argtypes.isEmpty())
2713                     log.error(tree.args.head.pos(), Errors.AnonClassImplIntfNoArgs);
2714 
2715                 if (!typeargtypes.isEmpty())
2716                     log.error(tree.typeargs.head.pos(), Errors.AnonClassImplIntfNoTypeargs);
2717 
2718                 // Error recovery: pretend no arguments were supplied.
2719                 argtypes = List.nil();
2720                 typeargtypes = List.nil();
2721                 skipNonDiamondPath = true;
2722             }
2723             if (TreeInfo.isDiamond(tree)) {
2724                 ClassType site = new ClassType(clazztype.getEnclosingType(),
2725                             clazztype.tsym.type.getTypeArguments(),
2726                                                clazztype.tsym,
2727                                                clazztype.getMetadata());
2728 
2729                 Env&lt;AttrContext&gt; diamondEnv = localEnv.dup(tree);
2730                 diamondEnv.info.selectSuper = cdef != null || tree.classDeclRemoved();
2731                 diamondEnv.info.pendingResolutionPhase = null;
2732 
2733                 //if the type of the instance creation expression is a class type
2734                 //apply method resolution inference (JLS 15.12.2.7). The return type
2735                 //of the resolved constructor will be a partially instantiated type
2736                 Symbol constructor = rs.resolveDiamond(tree.pos(),
2737                             diamondEnv,
2738                             site,
2739                             argtypes,
2740                             typeargtypes);
2741                 tree.constructor = constructor.baseSymbol();
2742 
2743                 final TypeSymbol csym = clazztype.tsym;
2744                 ResultInfo diamondResult = new ResultInfo(pkind, newMethodTemplate(resultInfo.pt, argtypes, typeargtypes),
2745                         diamondContext(tree, csym, resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
2746                 Type constructorType = tree.constructorType = types.createErrorType(clazztype);
2747                 constructorType = checkId(tree, site,
2748                         constructor,
2749                         diamondEnv,
2750                         diamondResult);
2751 
2752                 tree.clazz.type = types.createErrorType(clazztype);
2753                 if (!constructorType.isErroneous()) {
2754                     tree.clazz.type = clazz.type = constructorType.getReturnType();
2755                     tree.constructorType = types.createMethodTypeWithReturn(constructorType, syms.voidType);
2756                 }
2757                 clazztype = chk.checkClassType(tree.clazz, tree.clazz.type, true);
2758             }
2759 
2760             // Resolve the called constructor under the assumption
2761             // that we are referring to a superclass instance of the
2762             // current instance (JLS ???).
2763             else if (!skipNonDiamondPath) {
2764                 //the following code alters some of the fields in the current
2765                 //AttrContext - hence, the current context must be dup&#39;ed in
2766                 //order to avoid downstream failures
2767                 Env&lt;AttrContext&gt; rsEnv = localEnv.dup(tree);
2768                 rsEnv.info.selectSuper = cdef != null;
2769                 rsEnv.info.pendingResolutionPhase = null;
2770                 tree.constructor = rs.resolveConstructor(
2771                     tree.pos(), rsEnv, clazztype, argtypes, typeargtypes);
2772                 if (cdef == null) { //do not check twice!
2773                     tree.constructorType = checkId(tree,
2774                             clazztype,
2775                             tree.constructor,
2776                             rsEnv,
2777                             new ResultInfo(pkind, newMethodTemplate(syms.voidType, argtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2778                     if (rsEnv.info.lastResolveVarargs())
2779                         Assert.check(tree.constructorType.isErroneous() || tree.varargsElement != null);
2780                 }
2781             }
2782 
2783             if (cdef != null) {
2784                 visitAnonymousClassDefinition(tree, clazz, clazztype, cdef, localEnv, argtypes, typeargtypes, pkind);
2785                 return;
2786             }
2787 
2788             if (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH)
2789                 owntype = clazztype;
2790         }
2791         result = check(tree, owntype, KindSelector.VAL, resultInfo);
2792         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2793         if (tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType)) {
2794             //we need to wait for inference to finish and then replace inference vars in the constructor type
2795             inferenceContext.addFreeTypeListener(List.of(tree.constructorType),
2796                     instantiatedContext -&gt; {
2797                         tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2798                     });
2799         }
2800         chk.validate(tree.typeargs, localEnv);
2801     }
2802 
2803         // where
2804         private void visitAnonymousClassDefinition(JCNewClass tree, JCExpression clazz, Type clazztype,
2805                                                    JCClassDecl cdef, Env&lt;AttrContext&gt; localEnv,
2806                                                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
2807                                                    KindSelector pkind) {
2808             // We are seeing an anonymous class instance creation.
2809             // In this case, the class instance creation
2810             // expression
2811             //
2812             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2813             //
2814             // is represented internally as
2815             //
2816             //    E . new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) ( class &lt;empty-name&gt; { ... } )  .
2817             //
2818             // This expression is then *transformed* as follows:
2819             //
2820             // (1) add an extends or implements clause
2821             // (2) add a constructor.
2822             //
2823             // For instance, if C is a class, and ET is the type of E,
2824             // the expression
2825             //
2826             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2827             //
2828             // is translated to (where X is a fresh name and typarams is the
2829             // parameter list of the super constructor):
2830             //
2831             //   new &lt;typeargs1&gt;X(&lt;*nullchk*&gt;E, args) where
2832             //     X extends C&lt;typargs2&gt; {
2833             //       &lt;typarams&gt; X(ET e, args) {
2834             //         e.&lt;typeargs1&gt;super(args)
2835             //       }
2836             //       ...
2837             //     }
2838             InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2839             final boolean isDiamond = TreeInfo.isDiamond(tree);
2840             if (isDiamond
2841                     &amp;&amp; ((tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType))
2842                     || (tree.clazz.type != null &amp;&amp; inferenceContext.free(tree.clazz.type)))) {
2843                 final ResultInfo resultInfoForClassDefinition = this.resultInfo;
2844                 inferenceContext.addFreeTypeListener(List.of(tree.constructorType, tree.clazz.type),
2845                         instantiatedContext -&gt; {
2846                             tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2847                             tree.clazz.type = clazz.type = instantiatedContext.asInstType(clazz.type);
2848                             ResultInfo prevResult = this.resultInfo;
2849                             try {
2850                                 this.resultInfo = resultInfoForClassDefinition;
2851                                 visitAnonymousClassDefinition(tree, clazz, clazz.type, cdef,
2852                                                             localEnv, argtypes, typeargtypes, pkind);
2853                             } finally {
2854                                 this.resultInfo = prevResult;
2855                             }
2856                         });
2857             } else {
2858                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2859                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2860                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2861                         // One or more types inferred in the previous steps is non-denotable.
2862                         Fragment fragment = Diamond(clazztype.tsym);
2863                         log.error(tree.clazz.pos(),
2864                                 Errors.CantApplyDiamond1(
2865                                         fragment,
2866                                         invalidDiamondArgs.size() &gt; 1 ?
2867                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2868                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2869                     }
2870                     // For &lt;&gt;(){}, inferred types must also be accessible.
2871                     for (Type t : clazztype.getTypeArguments()) {
2872                         rs.checkAccessibleType(env, t);
2873                     }
<a name="22" id="anc22"></a><span class="line-added">2874                     chk.checkParameterizationWithValues(tree, clazztype);</span>
2875                 }
2876 
2877                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2878                 // false for isInterface call even when the original type is an interface.
2879                 boolean implementing = clazztype.tsym.isInterface() ||
2880                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2881                         clazztype.getOriginalType().tsym.isInterface();
2882 
2883                 if (implementing) {
2884                     cdef.implementing = List.of(clazz);
2885                 } else {
2886                     cdef.extending = clazz;
2887                 }
2888 
2889                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2890                     isSerializable(clazztype)) {
2891                     localEnv.info.isSerializable = true;
2892                 }
2893 
2894                 attribStat(cdef, localEnv);
2895 
2896                 List&lt;Type&gt; finalargtypes;
2897                 // If an outer instance is given,
2898                 // prefix it to the constructor arguments
2899                 // and delete it from the new expression
2900                 if (tree.encl != null &amp;&amp; !clazztype.tsym.isInterface()) {
2901                     finalargtypes = argtypes.prepend(tree.encl.type);
2902                 } else {
2903                     finalargtypes = argtypes;
2904                 }
2905 
2906                 // Reassign clazztype and recompute constructor. As this necessarily involves
2907                 // another attribution pass for deferred types in the case of &lt;&gt;, replicate
2908                 // them. Original arguments have right decorations already.
2909                 if (isDiamond &amp;&amp; pkind.contains(KindSelector.POLY)) {
2910                     finalargtypes = finalargtypes.map(deferredAttr.deferredCopier);
2911                 }
2912 
2913                 clazztype = clazztype.hasTag(ERROR) ? types.createErrorType(cdef.sym.type)
2914                                                     : cdef.sym.type;
2915                 Symbol sym = tree.constructor = rs.resolveConstructor(
2916                         tree.pos(), localEnv, clazztype, finalargtypes, typeargtypes);
2917                 Assert.check(!sym.kind.isResolutionError());
2918                 tree.constructor = sym;
2919                 tree.constructorType = checkId(tree,
2920                         clazztype,
2921                         tree.constructor,
2922                         localEnv,
2923                         new ResultInfo(pkind, newMethodTemplate(syms.voidType, finalargtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2924             }
2925             Type owntype = (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH) ?
2926                                 clazztype : types.createErrorType(tree.type);
2927             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2928             chk.validate(tree.typeargs, localEnv);
2929         }
2930 
2931         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2932             return new Check.NestedCheckContext(checkContext) {
2933                 @Override
2934                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2935                     enclosingContext.report(clazz.clazz,
2936                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2937                 }
2938             };
2939         }
2940 
2941     /** Make an attributed null check tree.
2942      */
2943     public JCExpression makeNullCheck(JCExpression arg) {
2944         // optimization: new Outer() can never be null; skip null check
2945         if (arg.getTag() == NEWCLASS)
2946             return arg;
<a name="23" id="anc23"></a><span class="line-added">2947         // Likewise arg can&#39;t be null if it is a value.</span>
<span class="line-added">2948         if (types.isValue(arg.type))</span>
<span class="line-added">2949             return arg;</span>
2950         // optimization: X.this is never null; skip null check
2951         Name name = TreeInfo.name(arg);
2952         if (name == names._this || name == names._super) return arg;
2953 
2954         JCTree.Tag optag = NULLCHK;
2955         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2956         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2957         tree.type = arg.type;
2958         return tree;
2959     }
2960 
2961     public void visitNewArray(JCNewArray tree) {
2962         Type owntype = types.createErrorType(tree.type);
2963         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2964         Type elemtype;
2965         if (tree.elemtype != null) {
2966             elemtype = attribType(tree.elemtype, localEnv);
2967             chk.validate(tree.elemtype, localEnv);
2968             owntype = elemtype;
2969             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2970                 attribExpr(l.head, localEnv, syms.intType);
2971                 owntype = new ArrayType(owntype, syms.arrayClass);
2972             }
2973         } else {
2974             // we are seeing an untyped aggregate { ... }
2975             // this is allowed only if the prototype is an array
2976             if (pt().hasTag(ARRAY)) {
2977                 elemtype = types.elemtype(pt());
2978             } else {
2979                 if (!pt().hasTag(ERROR) &amp;&amp;
2980                         (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
2981                     log.error(tree.pos(),
2982                               Errors.IllegalInitializerForType(pt()));
2983                 }
2984                 elemtype = types.createErrorType(pt());
2985             }
2986         }
2987         if (tree.elems != null) {
2988             attribExprs(tree.elems, localEnv, elemtype);
2989             owntype = new ArrayType(elemtype, syms.arrayClass);
2990         }
2991         if (!types.isReifiable(elemtype))
2992             log.error(tree.pos(), Errors.GenericArrayCreation);
2993         result = check(tree, owntype, KindSelector.VAL, resultInfo);
2994     }
2995 
2996     /*
2997      * A lambda expression can only be attributed when a target-type is available.
2998      * In addition, if the target-type is that of a functional interface whose
2999      * descriptor contains inference variables in argument position the lambda expression
3000      * is &#39;stuck&#39; (see DeferredAttr).
3001      */
3002     @Override
3003     public void visitLambda(final JCLambda that) {
3004         boolean wrongContext = false;
3005         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3006             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3007                 //lambda only allowed in assignment or method invocation/cast context
3008                 log.error(that.pos(), Errors.UnexpectedLambda);
3009             }
3010             resultInfo = recoveryInfo;
3011             wrongContext = true;
3012         }
3013         //create an environment for attribution of the lambda expression
3014         final Env&lt;AttrContext&gt; localEnv = lambdaEnv(that, env);
3015         boolean needsRecovery =
3016                 resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;
3017         try {
3018             if (needsRecovery &amp;&amp; isSerializable(pt())) {
3019                 localEnv.info.isSerializable = true;
3020                 localEnv.info.isSerializableLambda = true;
3021             }
3022             localEnv.info.isLambda = true;
3023             List&lt;Type&gt; explicitParamTypes = null;
3024             if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
3025                 //attribute lambda parameters
3026                 attribStats(that.params, localEnv);
3027                 explicitParamTypes = TreeInfo.types(that.params);
3028             }
3029 
3030             TargetInfo targetInfo = getTargetInfo(that, resultInfo, explicitParamTypes);
3031             Type currentTarget = targetInfo.target;
3032             Type lambdaType = targetInfo.descriptor;
3033 
3034             if (currentTarget.isErroneous()) {
3035                 result = that.type = currentTarget;
3036                 return;
3037             }
3038 
3039             setFunctionalInfo(localEnv, that, pt(), lambdaType, currentTarget, resultInfo.checkContext);
3040 
3041             if (lambdaType.hasTag(FORALL)) {
3042                 //lambda expression target desc cannot be a generic method
3043                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
3044                                                                     kindName(currentTarget.tsym),
3045                                                                     currentTarget.tsym);
3046                 resultInfo.checkContext.report(that, diags.fragment(msg));
3047                 result = that.type = types.createErrorType(pt());
3048                 return;
3049             }
3050 
3051             if (that.paramKind == JCLambda.ParameterKind.IMPLICIT) {
3052                 //add param type info in the AST
3053                 List&lt;Type&gt; actuals = lambdaType.getParameterTypes();
3054                 List&lt;JCVariableDecl&gt; params = that.params;
3055 
3056                 boolean arityMismatch = false;
3057 
3058                 while (params.nonEmpty()) {
3059                     if (actuals.isEmpty()) {
3060                         //not enough actuals to perform lambda parameter inference
3061                         arityMismatch = true;
3062                     }
3063                     //reset previously set info
3064                     Type argType = arityMismatch ?
3065                             syms.errType :
3066                             actuals.head;
3067                     if (params.head.isImplicitlyTyped()) {
3068                         setSyntheticVariableType(params.head, argType);
3069                     }
3070                     params.head.sym = null;
3071                     actuals = actuals.isEmpty() ?
3072                             actuals :
3073                             actuals.tail;
3074                     params = params.tail;
3075                 }
3076 
3077                 //attribute lambda parameters
3078                 attribStats(that.params, localEnv);
3079 
3080                 if (arityMismatch) {
3081                     resultInfo.checkContext.report(that, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3082                         result = that.type = types.createErrorType(currentTarget);
3083                         return;
3084                 }
3085             }
3086 
3087             //from this point on, no recovery is needed; if we are in assignment context
3088             //we will be able to attribute the whole lambda body, regardless of errors;
3089             //if we are in a &#39;check&#39; method context, and the lambda is not compatible
3090             //with the target-type, it will be recovered anyway in Attr.checkId
3091             needsRecovery = false;
3092 
3093             ResultInfo bodyResultInfo = localEnv.info.returnResult =
3094                     lambdaBodyResult(that, lambdaType, resultInfo);
3095 
3096             if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
3097                 attribTree(that.getBody(), localEnv, bodyResultInfo);
3098             } else {
3099                 JCBlock body = (JCBlock)that.body;
3100                 if (body == breakTree &amp;&amp;
3101                         resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3102                     breakTreeFound(copyEnv(localEnv));
3103                 }
3104                 attribStats(body.stats, localEnv);
3105             }
3106 
3107             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3108 
3109             boolean isSpeculativeRound =
3110                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3111 
3112             preFlow(that);
3113             flow.analyzeLambda(env, that, make, isSpeculativeRound);
3114 
3115             that.type = currentTarget; //avoids recovery at this stage
3116             checkLambdaCompatible(that, lambdaType, resultInfo.checkContext);
3117 
3118             if (!isSpeculativeRound) {
3119                 //add thrown types as bounds to the thrown types free variables if needed:
3120                 if (resultInfo.checkContext.inferenceContext().free(lambdaType.getThrownTypes())) {
3121                     List&lt;Type&gt; inferredThrownTypes = flow.analyzeLambdaThrownTypes(env, that, make);
3122                     if(!checkExConstraints(inferredThrownTypes, lambdaType.getThrownTypes(), resultInfo.checkContext.inferenceContext())) {
3123                         log.error(that, Errors.IncompatibleThrownTypesInMref(lambdaType.getThrownTypes()));
3124                     }
3125                 }
3126 
3127                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), lambdaType, currentTarget);
3128             }
3129             result = wrongContext ? that.type = types.createErrorType(pt())
3130                                   : check(that, currentTarget, KindSelector.VAL, resultInfo);
3131         } catch (Types.FunctionDescriptorLookupError ex) {
3132             JCDiagnostic cause = ex.getDiagnostic();
3133             resultInfo.checkContext.report(that, cause);
3134             result = that.type = types.createErrorType(pt());
3135             return;
3136         } catch (CompletionFailure cf) {
3137             chk.completionError(that.pos(), cf);
3138         } catch (Throwable t) {
3139             //when an unexpected exception happens, avoid attempts to attribute the same tree again
3140             //as that would likely cause the same exception again.
3141             needsRecovery = false;
3142             throw t;
3143         } finally {
3144             localEnv.info.scope.leave();
3145             if (needsRecovery) {
3146                 attribTree(that, env, recoveryInfo);
3147             }
3148         }
3149     }
3150     //where
3151         class TargetInfo {
3152             Type target;
3153             Type descriptor;
3154 
3155             public TargetInfo(Type target, Type descriptor) {
3156                 this.target = target;
3157                 this.descriptor = descriptor;
3158             }
3159         }
3160 
3161         TargetInfo getTargetInfo(JCPolyExpression that, ResultInfo resultInfo, List&lt;Type&gt; explicitParamTypes) {
3162             Type lambdaType;
3163             Type currentTarget = resultInfo.pt;
3164             if (resultInfo.pt != Type.recoveryType) {
3165                 /* We need to adjust the target. If the target is an
3166                  * intersection type, for example: SAM &amp; I1 &amp; I2 ...
3167                  * the target will be updated to SAM
3168                  */
3169                 currentTarget = targetChecker.visit(currentTarget, that);
3170                 if (!currentTarget.isIntersection()) {
3171                     if (explicitParamTypes != null) {
3172                         currentTarget = infer.instantiateFunctionalInterface(that,
3173                                 currentTarget, explicitParamTypes, resultInfo.checkContext);
3174                     }
3175                     currentTarget = types.removeWildcards(currentTarget);
3176                     lambdaType = types.findDescriptorType(currentTarget);
3177                 } else {
3178                     IntersectionClassType ict = (IntersectionClassType)currentTarget;
3179                     ListBuffer&lt;Type&gt; components = new ListBuffer&lt;&gt;();
3180                     for (Type bound : ict.getExplicitComponents()) {
3181                         if (explicitParamTypes != null) {
3182                             try {
3183                                 bound = infer.instantiateFunctionalInterface(that,
3184                                         bound, explicitParamTypes, resultInfo.checkContext);
3185                             } catch (FunctionDescriptorLookupError t) {
3186                                 // do nothing
3187                             }
3188                         }
3189                         bound = types.removeWildcards(bound);
3190                         components.add(bound);
3191                     }
3192                     currentTarget = types.makeIntersectionType(components.toList());
3193                     currentTarget.tsym.flags_field |= INTERFACE;
3194                     lambdaType = types.findDescriptorType(currentTarget);
3195                 }
3196 
3197             } else {
3198                 currentTarget = Type.recoveryType;
3199                 lambdaType = fallbackDescriptorType(that);
3200             }
3201             if (that.hasTag(LAMBDA) &amp;&amp; lambdaType.hasTag(FORALL)) {
3202                 //lambda expression target desc cannot be a generic method
3203                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
3204                                                                     kindName(currentTarget.tsym),
3205                                                                     currentTarget.tsym);
3206                 resultInfo.checkContext.report(that, diags.fragment(msg));
3207                 currentTarget = types.createErrorType(pt());
3208             }
3209             return new TargetInfo(currentTarget, lambdaType);
3210         }
3211 
3212         void preFlow(JCLambda tree) {
3213             new PostAttrAnalyzer() {
3214                 @Override
3215                 public void scan(JCTree tree) {
3216                     if (tree == null ||
3217                             (tree.type != null &amp;&amp;
3218                             tree.type == Type.stuckType)) {
3219                         //don&#39;t touch stuck expressions!
3220                         return;
3221                     }
3222                     super.scan(tree);
3223                 }
3224 
3225                 @Override
3226                 public void visitClassDef(JCClassDecl that) {
3227                     // or class declaration trees!
3228                 }
3229 
3230                 public void visitLambda(JCLambda that) {
3231                     // or lambda expressions!
3232                 }
3233             }.scan(tree.body);
3234         }
3235 
3236         Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
3237 
3238             @Override
3239             public Type visitClassType(ClassType t, DiagnosticPosition pos) {
3240                 return t.isIntersection() ?
3241                         visitIntersectionClassType((IntersectionClassType)t, pos) : t;
3242             }
3243 
3244             public Type visitIntersectionClassType(IntersectionClassType ict, DiagnosticPosition pos) {
3245                 types.findDescriptorSymbol(makeNotionalInterface(ict, pos));
3246                 return ict;
3247             }
3248 
3249             private TypeSymbol makeNotionalInterface(IntersectionClassType ict, DiagnosticPosition pos) {
3250                 ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
3251                 ListBuffer&lt;Type&gt; supertypes = new ListBuffer&lt;&gt;();
3252                 for (Type i : ict.interfaces_field) {
3253                     if (i.isParameterized()) {
3254                         targs.appendList(i.tsym.type.allparams());
3255                     }
3256                     supertypes.append(i.tsym.type);
3257                 }
3258                 IntersectionClassType notionalIntf = types.makeIntersectionType(supertypes.toList());
3259                 notionalIntf.allparams_field = targs.toList();
3260                 notionalIntf.tsym.flags_field |= INTERFACE;
3261                 return notionalIntf.tsym;
3262             }
3263         };
3264 
3265         private Type fallbackDescriptorType(JCExpression tree) {
3266             switch (tree.getTag()) {
3267                 case LAMBDA:
3268                     JCLambda lambda = (JCLambda)tree;
3269                     List&lt;Type&gt; argtypes = List.nil();
3270                     for (JCVariableDecl param : lambda.params) {
3271                         argtypes = param.vartype != null &amp;&amp; param.vartype.type != null ?
3272                                 argtypes.append(param.vartype.type) :
3273                                 argtypes.append(syms.errType);
3274                     }
3275                     return new MethodType(argtypes, Type.recoveryType,
3276                             List.of(syms.throwableType), syms.methodClass);
3277                 case REFERENCE:
3278                     return new MethodType(List.nil(), Type.recoveryType,
3279                             List.of(syms.throwableType), syms.methodClass);
3280                 default:
3281                     Assert.error(&quot;Cannot get here!&quot;);
3282             }
3283             return null;
3284         }
3285 
3286         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3287                 final InferenceContext inferenceContext, final Type... ts) {
3288             checkAccessibleTypes(pos, env, inferenceContext, List.from(ts));
3289         }
3290 
3291         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3292                 final InferenceContext inferenceContext, final List&lt;Type&gt; ts) {
3293             if (inferenceContext.free(ts)) {
3294                 inferenceContext.addFreeTypeListener(ts,
3295                         solvedContext -&gt; checkAccessibleTypes(pos, env, solvedContext, solvedContext.asInstTypes(ts)));
3296             } else {
3297                 for (Type t : ts) {
3298                     rs.checkAccessibleType(env, t);
3299                 }
3300             }
3301         }
3302 
3303         /**
3304          * Lambda/method reference have a special check context that ensures
3305          * that i.e. a lambda return type is compatible with the expected
3306          * type according to both the inherited context and the assignment
3307          * context.
3308          */
3309         class FunctionalReturnContext extends Check.NestedCheckContext {
3310 
3311             FunctionalReturnContext(CheckContext enclosingContext) {
3312                 super(enclosingContext);
3313             }
3314 
3315             @Override
3316             public boolean compatible(Type found, Type req, Warner warn) {
3317                 //return type must be compatible in both current context and assignment context
3318                 return chk.basicHandler.compatible(inferenceContext().asUndetVar(found), inferenceContext().asUndetVar(req), warn);
3319             }
3320 
3321             @Override
3322             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3323                 enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleRetTypeInLambda(details)));
3324             }
3325         }
3326 
3327         class ExpressionLambdaReturnContext extends FunctionalReturnContext {
3328 
3329             JCExpression expr;
3330             boolean expStmtExpected;
3331 
3332             ExpressionLambdaReturnContext(JCExpression expr, CheckContext enclosingContext) {
3333                 super(enclosingContext);
3334                 this.expr = expr;
3335             }
3336 
3337             @Override
3338             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3339                 if (expStmtExpected) {
3340                     enclosingContext.report(pos, diags.fragment(Fragments.StatExprExpected));
3341                 } else {
3342                     super.report(pos, details);
3343                 }
3344             }
3345 
3346             @Override
3347             public boolean compatible(Type found, Type req, Warner warn) {
3348                 //a void return is compatible with an expression statement lambda
3349                 if (req.hasTag(VOID)) {
3350                     expStmtExpected = true;
3351                     return TreeInfo.isExpressionStatement(expr);
3352                 } else {
3353                     return super.compatible(found, req, warn);
3354                 }
3355             }
3356         }
3357 
3358         ResultInfo lambdaBodyResult(JCLambda that, Type descriptor, ResultInfo resultInfo) {
3359             FunctionalReturnContext funcContext = that.getBodyKind() == JCLambda.BodyKind.EXPRESSION ?
3360                     new ExpressionLambdaReturnContext((JCExpression)that.getBody(), resultInfo.checkContext) :
3361                     new FunctionalReturnContext(resultInfo.checkContext);
3362 
3363             return descriptor.getReturnType() == Type.recoveryType ?
3364                     recoveryInfo :
3365                     new ResultInfo(KindSelector.VAL,
3366                             descriptor.getReturnType(), funcContext);
3367         }
3368 
3369         /**
3370         * Lambda compatibility. Check that given return types, thrown types, parameter types
3371         * are compatible with the expected functional interface descriptor. This means that:
3372         * (i) parameter types must be identical to those of the target descriptor; (ii) return
3373         * types must be compatible with the return type of the expected descriptor.
3374         */
3375         void checkLambdaCompatible(JCLambda tree, Type descriptor, CheckContext checkContext) {
3376             Type returnType = checkContext.inferenceContext().asUndetVar(descriptor.getReturnType());
3377 
3378             //return values have already been checked - but if lambda has no return
3379             //values, we must ensure that void/value compatibility is correct;
3380             //this amounts at checking that, if a lambda body can complete normally,
3381             //the descriptor&#39;s return type must be void
3382             if (tree.getBodyKind() == JCLambda.BodyKind.STATEMENT &amp;&amp; tree.canCompleteNormally &amp;&amp;
3383                     !returnType.hasTag(VOID) &amp;&amp; returnType != Type.recoveryType) {
3384                 Fragment msg =
3385                         Fragments.IncompatibleRetTypeInLambda(Fragments.MissingRetVal(returnType));
3386                 checkContext.report(tree,
3387                                     diags.fragment(msg));
3388             }
3389 
3390             List&lt;Type&gt; argTypes = checkContext.inferenceContext().asUndetVars(descriptor.getParameterTypes());
3391             if (!types.isSameTypes(argTypes, TreeInfo.types(tree.params))) {
3392                 checkContext.report(tree, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3393             }
3394         }
3395 
3396         /* Map to hold &#39;fake&#39; clinit methods. If a lambda is used to initialize a
3397          * static field and that lambda has type annotations, these annotations will
3398          * also be stored at these fake clinit methods.
3399          *
3400          * LambdaToMethod also use fake clinit methods so they can be reused.
3401          * Also as LTM is a phase subsequent to attribution, the methods from
3402          * clinits can be safely removed by LTM to save memory.
3403          */
3404         private Map&lt;ClassSymbol, MethodSymbol&gt; clinits = new HashMap&lt;&gt;();
3405 
3406         public MethodSymbol removeClinit(ClassSymbol sym) {
3407             return clinits.remove(sym);
3408         }
3409 
3410         /* This method returns an environment to be used to attribute a lambda
3411          * expression.
3412          *
3413          * The owner of this environment is a method symbol. If the current owner
3414          * is not a method, for example if the lambda is used to initialize
3415          * a field, then if the field is:
3416          *
3417          * - an instance field, we use the first constructor.
3418          * - a static field, we create a fake clinit method.
3419          */
3420         public Env&lt;AttrContext&gt; lambdaEnv(JCLambda that, Env&lt;AttrContext&gt; env) {
3421             Env&lt;AttrContext&gt; lambdaEnv;
3422             Symbol owner = env.info.scope.owner;
3423             if (owner.kind == VAR &amp;&amp; owner.owner.kind == TYP) {
3424                 //field initializer
3425                 ClassSymbol enclClass = owner.enclClass();
3426                 Symbol newScopeOwner = env.info.scope.owner;
3427                 /* if the field isn&#39;t static, then we can get the first constructor
3428                  * and use it as the owner of the environment. This is what
3429                  * LTM code is doing to look for type annotations so we are fine.
3430                  */
3431                 if ((owner.flags() &amp; STATIC) == 0) {
3432                     for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {
3433                         newScopeOwner = s;
3434                         break;
3435                     }
3436                 } else {
3437                     /* if the field is static then we need to create a fake clinit
3438                      * method, this method can later be reused by LTM.
3439                      */
3440                     MethodSymbol clinit = clinits.get(enclClass);
3441                     if (clinit == null) {
3442                         Type clinitType = new MethodType(List.nil(),
3443                                 syms.voidType, List.nil(), syms.methodClass);
3444                         clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,
3445                                 names.clinit, clinitType, enclClass);
3446                         clinit.params = List.nil();
3447                         clinits.put(enclClass, clinit);
3448                     }
3449                     newScopeOwner = clinit;
3450                 }
3451                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
3452             } else {
3453                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
3454             }
3455             lambdaEnv.info.yieldResult = null;
3456             return lambdaEnv;
3457         }
3458 
3459     @Override
3460     public void visitReference(final JCMemberReference that) {
3461         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3462             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3463                 //method reference only allowed in assignment or method invocation/cast context
3464                 log.error(that.pos(), Errors.UnexpectedMref);
3465             }
3466             result = that.type = types.createErrorType(pt());
3467             return;
3468         }
3469         final Env&lt;AttrContext&gt; localEnv = env.dup(that);
3470         try {
3471             //attribute member reference qualifier - if this is a constructor
3472             //reference, the expected kind must be a type
3473             Type exprType = attribTree(that.expr, env, memberReferenceQualifierResult(that));
3474 
3475             if (that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3476                 exprType = chk.checkConstructorRefType(that.expr, exprType);
3477                 if (!exprType.isErroneous() &amp;&amp;
3478                     exprType.isRaw() &amp;&amp;
3479                     that.typeargs != null) {
3480                     log.error(that.expr.pos(),
3481                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3482                                                  Fragments.MrefInferAndExplicitParams));
3483                     exprType = types.createErrorType(exprType);
3484                 }
3485             }
3486 
3487             if (exprType.isErroneous()) {
3488                 //if the qualifier expression contains problems,
3489                 //give up attribution of method reference
3490                 result = that.type = exprType;
3491                 return;
3492             }
3493 
3494             if (TreeInfo.isStaticSelector(that.expr, names)) {
3495                 //if the qualifier is a type, validate it; raw warning check is
3496                 //omitted as we don&#39;t know at this stage as to whether this is a
3497                 //raw selector (because of inference)
3498                 chk.validate(that.expr, env, false);
3499             } else {
3500                 Symbol lhsSym = TreeInfo.symbol(that.expr);
3501                 localEnv.info.selectSuper = lhsSym != null &amp;&amp; lhsSym.name == names._super;
3502             }
3503             //attrib type-arguments
3504             List&lt;Type&gt; typeargtypes = List.nil();
3505             if (that.typeargs != null) {
3506                 typeargtypes = attribTypes(that.typeargs, localEnv);
3507             }
3508 
3509             boolean isTargetSerializable =
3510                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3511                     isSerializable(pt());
3512             TargetInfo targetInfo = getTargetInfo(that, resultInfo, null);
3513             Type currentTarget = targetInfo.target;
3514             Type desc = targetInfo.descriptor;
3515 
3516             setFunctionalInfo(localEnv, that, pt(), desc, currentTarget, resultInfo.checkContext);
3517             List&lt;Type&gt; argtypes = desc.getParameterTypes();
3518             Resolve.MethodCheck referenceCheck = rs.resolveMethodCheck;
3519 
3520             if (resultInfo.checkContext.inferenceContext().free(argtypes)) {
3521                 referenceCheck = rs.new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
3522             }
3523 
3524             Pair&lt;Symbol, Resolve.ReferenceLookupHelper&gt; refResult = null;
3525             List&lt;Type&gt; saved_undet = resultInfo.checkContext.inferenceContext().save();
3526             try {
3527                 refResult = rs.resolveMemberReference(localEnv, that, that.expr.type,
3528                         that.name, argtypes, typeargtypes, targetInfo.descriptor, referenceCheck,
3529                         resultInfo.checkContext.inferenceContext(), rs.basicReferenceChooser);
3530             } finally {
3531                 resultInfo.checkContext.inferenceContext().rollback(saved_undet);
3532             }
3533 
3534             Symbol refSym = refResult.fst;
3535             Resolve.ReferenceLookupHelper lookupHelper = refResult.snd;
3536 
3537             /** this switch will need to go away and be replaced by the new RESOLUTION_TARGET testing
3538              *  JDK-8075541
3539              */
3540             if (refSym.kind != MTH) {
3541                 boolean targetError;
3542                 switch (refSym.kind) {
3543                     case ABSENT_MTH:
3544                     case MISSING_ENCL:
3545                         targetError = false;
3546                         break;
3547                     case WRONG_MTH:
3548                     case WRONG_MTHS:
3549                     case AMBIGUOUS:
3550                     case HIDDEN:
3551                     case STATICERR:
3552                         targetError = true;
3553                         break;
3554                     default:
3555                         Assert.error(&quot;unexpected result kind &quot; + refSym.kind);
3556                         targetError = false;
3557                 }
3558 
3559                 JCDiagnostic detailsDiag = ((Resolve.ResolveError)refSym.baseSymbol())
3560                         .getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT,
3561                                 that, exprType.tsym, exprType, that.name, argtypes, typeargtypes);
3562 
3563                 JCDiagnostic diag = diags.create(log.currentSource(), that,
3564                         targetError ?
3565                             Fragments.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag) :
3566                             Errors.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag));
3567 
3568                 if (targetError &amp;&amp; currentTarget == Type.recoveryType) {
3569                     //a target error doesn&#39;t make sense during recovery stage
3570                     //as we don&#39;t know what actual parameter types are
3571                     result = that.type = currentTarget;
3572                     return;
3573                 } else {
3574                     if (targetError) {
3575                         resultInfo.checkContext.report(that, diag);
3576                     } else {
3577                         log.report(diag);
3578                     }
3579                     result = that.type = types.createErrorType(currentTarget);
3580                     return;
3581                 }
3582             }
3583 
3584             that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;
3585             that.kind = lookupHelper.referenceKind(that.sym);
3586             that.ownerAccessible = rs.isAccessible(localEnv, that.sym.enclClass());
3587 
3588             if (desc.getReturnType() == Type.recoveryType) {
3589                 // stop here
3590                 result = that.type = currentTarget;
3591                 return;
3592             }
3593 
3594             if (!env.info.attributionMode.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3595                 Type enclosingType = exprType.getEnclosingType();
3596                 if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {
3597                     // Check for the existence of an appropriate outer instance
3598                     rs.resolveImplicitThis(that.pos(), env, exprType);
3599                 }
3600             }
3601 
3602             if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3603 
3604                 if (that.getMode() == ReferenceMode.INVOKE &amp;&amp;
3605                         TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3606                         that.kind.isUnbound() &amp;&amp;
3607                         lookupHelper.site.isRaw()) {
3608                     chk.checkRaw(that.expr, localEnv);
3609                 }
3610 
3611                 if (that.sym.isStatic() &amp;&amp; TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3612                         exprType.getTypeArguments().nonEmpty()) {
3613                     //static ref with class type-args
3614                     log.error(that.expr.pos(),
3615                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3616                                                  Fragments.StaticMrefWithTargs));
3617                     result = that.type = types.createErrorType(currentTarget);
3618                     return;
3619                 }
3620 
3621                 if (!refSym.isStatic() &amp;&amp; that.kind == JCMemberReference.ReferenceKind.SUPER) {
3622                     // Check that super-qualified symbols are not abstract (JLS)
3623                     rs.checkNonAbstract(that.pos(), that.sym);
3624                 }
3625 
3626                 if (isTargetSerializable) {
3627                     chk.checkAccessFromSerializableElement(that, true);
3628                 }
3629             }
3630 
3631             ResultInfo checkInfo =
3632                     resultInfo.dup(newMethodTemplate(
3633                         desc.getReturnType().hasTag(VOID) ? Type.noType : desc.getReturnType(),
3634                         that.kind.isUnbound() ? argtypes.tail : argtypes, typeargtypes),
3635                         new FunctionalReturnContext(resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
3636 
3637             Type refType = checkId(that, lookupHelper.site, refSym, localEnv, checkInfo);
3638 
3639             if (that.kind.isUnbound() &amp;&amp;
3640                     resultInfo.checkContext.inferenceContext().free(argtypes.head)) {
3641                 //re-generate inference constraints for unbound receiver
3642                 if (!types.isSubtype(resultInfo.checkContext.inferenceContext().asUndetVar(argtypes.head), exprType)) {
3643                     //cannot happen as this has already been checked - we just need
3644                     //to regenerate the inference constraints, as that has been lost
3645                     //as a result of the call to inferenceContext.save()
3646                     Assert.error(&quot;Can&#39;t get here&quot;);
3647                 }
3648             }
3649 
3650             if (!refType.isErroneous()) {
3651                 refType = types.createMethodTypeWithReturn(refType,
3652                         adjustMethodReturnType(refSym, lookupHelper.site, that.name, checkInfo.pt.getParameterTypes(), refType.getReturnType()));
3653             }
3654 
3655             //go ahead with standard method reference compatibility check - note that param check
3656             //is a no-op (as this has been taken care during method applicability)
3657             boolean isSpeculativeRound =
3658                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3659 
3660             that.type = currentTarget; //avoids recovery at this stage
3661             checkReferenceCompatible(that, desc, refType, resultInfo.checkContext, isSpeculativeRound);
3662             if (!isSpeculativeRound) {
3663                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), desc, currentTarget);
3664             }
3665             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3666         } catch (Types.FunctionDescriptorLookupError ex) {
3667             JCDiagnostic cause = ex.getDiagnostic();
3668             resultInfo.checkContext.report(that, cause);
3669             result = that.type = types.createErrorType(pt());
3670             return;
3671         }
3672     }
3673     //where
3674         ResultInfo memberReferenceQualifierResult(JCMemberReference tree) {
3675             //if this is a constructor reference, the expected kind must be a type
3676             return new ResultInfo(tree.getMode() == ReferenceMode.INVOKE ?
3677                                   KindSelector.VAL_TYP : KindSelector.TYP,
3678                                   Type.noType);
3679         }
3680 
3681 
3682     @SuppressWarnings(&quot;fallthrough&quot;)
3683     void checkReferenceCompatible(JCMemberReference tree, Type descriptor, Type refType, CheckContext checkContext, boolean speculativeAttr) {
3684         InferenceContext inferenceContext = checkContext.inferenceContext();
3685         Type returnType = inferenceContext.asUndetVar(descriptor.getReturnType());
3686 
3687         Type resType;
3688         switch (tree.getMode()) {
3689             case NEW:
3690                 if (!tree.expr.type.isRaw()) {
3691                     resType = tree.expr.type;
3692                     break;
3693                 }
3694             default:
3695                 resType = refType.getReturnType();
3696         }
3697 
3698         Type incompatibleReturnType = resType;
3699 
3700         if (returnType.hasTag(VOID)) {
3701             incompatibleReturnType = null;
3702         }
3703 
3704         if (!returnType.hasTag(VOID) &amp;&amp; !resType.hasTag(VOID)) {
3705             if (resType.isErroneous() ||
3706                     new FunctionalReturnContext(checkContext).compatible(resType, returnType,
3707                             checkContext.checkWarner(tree, resType, returnType))) {
3708                 incompatibleReturnType = null;
3709             }
3710         }
3711 
3712         if (incompatibleReturnType != null) {
3713             Fragment msg =
3714                     Fragments.IncompatibleRetTypeInMref(Fragments.InconvertibleTypes(resType, descriptor.getReturnType()));
3715             checkContext.report(tree, diags.fragment(msg));
3716         } else {
3717             if (inferenceContext.free(refType)) {
3718                 // we need to wait for inference to finish and then replace inference vars in the referent type
3719                 inferenceContext.addFreeTypeListener(List.of(refType),
3720                         instantiatedContext -&gt; {
3721                             tree.referentType = instantiatedContext.asInstType(refType);
3722                         });
3723             } else {
3724                 tree.referentType = refType;
3725             }
3726         }
3727 
3728         if (!speculativeAttr) {
3729             if (!checkExConstraints(refType.getThrownTypes(), descriptor.getThrownTypes(), inferenceContext)) {
3730                 log.error(tree, Errors.IncompatibleThrownTypesInMref(refType.getThrownTypes()));
3731             }
3732         }
3733     }
3734 
3735     boolean checkExConstraints(
3736             List&lt;Type&gt; thrownByFuncExpr,
3737             List&lt;Type&gt; thrownAtFuncType,
3738             InferenceContext inferenceContext) {
3739         /** 18.2.5: Otherwise, let E1, ..., En be the types in the function type&#39;s throws clause that
3740          *  are not proper types
3741          */
3742         List&lt;Type&gt; nonProperList = thrownAtFuncType.stream()
3743                 .filter(e -&gt; inferenceContext.free(e)).collect(List.collector());
3744         List&lt;Type&gt; properList = thrownAtFuncType.diff(nonProperList);
3745 
3746         /** Let X1,...,Xm be the checked exception types that the lambda body can throw or
3747          *  in the throws clause of the invocation type of the method reference&#39;s compile-time
3748          *  declaration
3749          */
3750         List&lt;Type&gt; checkedList = thrownByFuncExpr.stream()
3751                 .filter(e -&gt; chk.isChecked(e)).collect(List.collector());
3752 
3753         /** If n = 0 (the function type&#39;s throws clause consists only of proper types), then
3754          *  if there exists some i (1 &lt;= i &lt;= m) such that Xi is not a subtype of any proper type
3755          *  in the throws clause, the constraint reduces to false; otherwise, the constraint
3756          *  reduces to true
3757          */
3758         ListBuffer&lt;Type&gt; uncaughtByProperTypes = new ListBuffer&lt;&gt;();
3759         for (Type checked : checkedList) {
3760             boolean isSubtype = false;
3761             for (Type proper : properList) {
3762                 if (types.isSubtype(checked, proper)) {
3763                     isSubtype = true;
3764                     break;
3765                 }
3766             }
3767             if (!isSubtype) {
3768                 uncaughtByProperTypes.add(checked);
3769             }
3770         }
3771 
3772         if (nonProperList.isEmpty() &amp;&amp; !uncaughtByProperTypes.isEmpty()) {
3773             return false;
3774         }
3775 
3776         /** If n &gt; 0, the constraint reduces to a set of subtyping constraints:
3777          *  for all i (1 &lt;= i &lt;= m), if Xi is not a subtype of any proper type in the
3778          *  throws clause, then the constraints include, for all j (1 &lt;= j &lt;= n), &lt;Xi &lt;: Ej&gt;
3779          */
3780         List&lt;Type&gt; nonProperAsUndet = inferenceContext.asUndetVars(nonProperList);
3781         uncaughtByProperTypes.forEach(checkedEx -&gt; {
3782             nonProperAsUndet.forEach(nonProper -&gt; {
3783                 types.isSubtype(checkedEx, nonProper);
3784             });
3785         });
3786 
3787         /** In addition, for all j (1 &lt;= j &lt;= n), the constraint reduces to the bound throws Ej
3788          */
3789         nonProperAsUndet.stream()
3790                 .filter(t -&gt; t.hasTag(UNDETVAR))
3791                 .forEach(t -&gt; ((UndetVar)t).setThrow());
3792         return true;
3793     }
3794 
3795     /**
3796      * Set functional type info on the underlying AST. Note: as the target descriptor
3797      * might contain inference variables, we might need to register an hook in the
3798      * current inference context.
3799      */
3800     private void setFunctionalInfo(final Env&lt;AttrContext&gt; env, final JCFunctionalExpression fExpr,
3801             final Type pt, final Type descriptorType, final Type primaryTarget, final CheckContext checkContext) {
3802         if (checkContext.inferenceContext().free(descriptorType)) {
3803             checkContext.inferenceContext().addFreeTypeListener(List.of(pt, descriptorType),
3804                     inferenceContext -&gt; setFunctionalInfo(env, fExpr, pt, inferenceContext.asInstType(descriptorType),
3805                     inferenceContext.asInstType(primaryTarget), checkContext));
3806         } else {
3807             if (pt.hasTag(CLASS)) {
3808                 fExpr.target = primaryTarget;
3809             }
3810             if (checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3811                     pt != Type.recoveryType) {
3812                 //check that functional interface class is well-formed
3813                 try {
3814                     /* Types.makeFunctionalInterfaceClass() may throw an exception
3815                      * when it&#39;s executed post-inference. See the listener code
3816                      * above.
3817                      */
3818                     ClassSymbol csym = types.makeFunctionalInterfaceClass(env,
3819                             names.empty, fExpr.target, ABSTRACT);
3820                     if (csym != null) {
3821                         chk.checkImplementations(env.tree, csym, csym);
3822                         try {
3823                             //perform an additional functional interface check on the synthetic class,
3824                             //as there may be spurious errors for raw targets - because of existing issues
3825                             //with membership and inheritance (see JDK-8074570).
3826                             csym.flags_field |= INTERFACE;
3827                             types.findDescriptorType(csym.type);
3828                         } catch (FunctionDescriptorLookupError err) {
3829                             resultInfo.checkContext.report(fExpr,
3830                                     diags.fragment(Fragments.NoSuitableFunctionalIntfInst(fExpr.target)));
3831                         }
3832                     }
3833                 } catch (Types.FunctionDescriptorLookupError ex) {
3834                     JCDiagnostic cause = ex.getDiagnostic();
3835                     resultInfo.checkContext.report(env.tree, cause);
3836                 }
3837             }
3838         }
3839     }
3840 
3841     public void visitParens(JCParens tree) {
3842         Type owntype = attribTree(tree.expr, env, resultInfo);
3843         result = check(tree, owntype, pkind(), resultInfo);
3844         Symbol sym = TreeInfo.symbol(tree);
3845         if (sym != null &amp;&amp; sym.kind.matches(KindSelector.TYP_PCK))
3846             log.error(tree.pos(), Errors.IllegalParenthesizedExpression);
3847     }
3848 
3849     public void visitAssign(JCAssign tree) {
3850         Type owntype = attribTree(tree.lhs, env.dup(tree), varAssignmentInfo);
3851         Type capturedType = capture(owntype);
3852         attribExpr(tree.rhs, env, owntype);
3853         result = check(tree, capturedType, KindSelector.VAL, resultInfo);
3854     }
3855 
3856     public void visitAssignop(JCAssignOp tree) {
3857         // Attribute arguments.
3858         Type owntype = attribTree(tree.lhs, env, varAssignmentInfo);
3859         Type operand = attribExpr(tree.rhs, env);
3860         // Find operator.
3861         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), owntype, operand);
3862         if (operator != operators.noOpSymbol &amp;&amp;
3863                 !owntype.isErroneous() &amp;&amp;
3864                 !operand.isErroneous()) {
3865             chk.checkDivZero(tree.rhs.pos(), operator, operand);
3866             chk.checkCastable(tree.rhs.pos(),
3867                               operator.type.getReturnType(),
3868                               owntype);
3869         }
3870         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3871     }
3872 
3873     public void visitUnary(JCUnary tree) {
3874         // Attribute arguments.
3875         Type argtype = (tree.getTag().isIncOrDecUnaryOp())
3876             ? attribTree(tree.arg, env, varAssignmentInfo)
3877             : chk.checkNonVoid(tree.arg.pos(), attribExpr(tree.arg, env));
3878 
3879         // Find operator.
3880         Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);
3881         Type owntype = types.createErrorType(tree.type);
3882         if (operator != operators.noOpSymbol &amp;&amp;
3883                 !argtype.isErroneous()) {
3884             owntype = (tree.getTag().isIncOrDecUnaryOp())
3885                 ? tree.arg.type
3886                 : operator.type.getReturnType();
3887             int opc = ((OperatorSymbol)operator).opcode;
3888 
3889             // If the argument is constant, fold it.
3890             if (argtype.constValue() != null) {
3891                 Type ctype = cfolder.fold1(opc, argtype);
3892                 if (ctype != null) {
3893                     owntype = cfolder.coerce(ctype, owntype);
3894                 }
3895             }
3896         }
3897         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3898         matchBindings = matchBindingsComputer.unary(tree, matchBindings);
3899     }
3900 
3901     public void visitBinary(JCBinary tree) {
3902         // Attribute arguments.
3903         Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
3904         // x &amp;&amp; y
3905         // include x&#39;s bindings when true in y
3906 
3907         // x || y
3908         // include x&#39;s bindings when false in y
3909 
3910         MatchBindings lhsBindings = matchBindings;
3911         List&lt;BindingSymbol&gt; propagatedBindings;
3912         switch (tree.getTag()) {
3913             case AND:
3914                 propagatedBindings = lhsBindings.bindingsWhenTrue;
3915                 break;
3916             case OR:
3917                 propagatedBindings = lhsBindings.bindingsWhenFalse;
3918                 break;
3919             default:
3920                 propagatedBindings = List.nil();
3921                 break;
3922         }
3923         Env&lt;AttrContext&gt; rhsEnv = bindingEnv(env, propagatedBindings);
3924         Type right;
3925         try {
3926             right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, rhsEnv));
3927         } finally {
3928             rhsEnv.info.scope.leave();
3929         }
3930 
3931         matchBindings = matchBindingsComputer.binary(tree, lhsBindings, matchBindings);
3932 
3933         // Find operator.
3934         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);
3935         Type owntype = types.createErrorType(tree.type);
3936         if (operator != operators.noOpSymbol &amp;&amp;
3937                 !left.isErroneous() &amp;&amp;
3938                 !right.isErroneous()) {
3939             owntype = operator.type.getReturnType();
3940             int opc = ((OperatorSymbol)operator).opcode;
3941             // If both arguments are constants, fold them.
3942             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3943                 Type ctype = cfolder.fold2(opc, left, right);
3944                 if (ctype != null) {
3945                     owntype = cfolder.coerce(ctype, owntype);
3946                 }
3947             }
3948 
3949             // Check that argument types of a reference ==, != are
3950             // castable to each other, (JLS 15.21).  Note: unboxing
3951             // comparisons will not have an acmp* opc at this point.
3952             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3953                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3954                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3955                 }
<a name="24" id="anc24"></a><span class="line-added">3956                 chk.checkForSuspectClassLiteralComparison(tree, left, right);</span>
3957             }
3958 
3959             chk.checkDivZero(tree.rhs.pos(), operator, right);
3960         }
3961         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3962     }
3963 
3964     public void visitTypeCast(final JCTypeCast tree) {
3965         Type clazztype = attribType(tree.clazz, env);
3966         chk.validate(tree.clazz, env, false);
3967         //a fresh environment is required for 292 inference to work properly ---
3968         //see Infer.instantiatePolymorphicSignatureInstance()
3969         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
3970         //should we propagate the target type?
3971         final ResultInfo castInfo;
3972         JCExpression expr = TreeInfo.skipParens(tree.expr);
3973         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
3974         if (isPoly) {
3975             //expression is a poly - we need to propagate target type info
3976             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
3977                                       new Check.NestedCheckContext(resultInfo.checkContext) {
3978                 @Override
3979                 public boolean compatible(Type found, Type req, Warner warn) {
3980                     return types.isCastable(found, req, warn);
3981                 }
3982             });
3983         } else {
3984             //standalone cast - target-type info is not propagated
3985             castInfo = unknownExprInfo;
3986         }
3987         Type exprtype = attribTree(tree.expr, localEnv, castInfo);
3988         Type owntype = isPoly ? clazztype : chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3989         if (exprtype.constValue() != null)
3990             owntype = cfolder.coerce(exprtype, owntype);
3991         result = check(tree, capture(owntype), KindSelector.VAL, resultInfo);
3992         if (!isPoly)
3993             chk.checkRedundantCast(localEnv, tree);
3994     }
3995 
3996     public void visitTypeTest(JCInstanceOf tree) {
3997         Type exprtype = chk.checkNullOrRefType(
3998                 tree.expr.pos(), attribExpr(tree.expr, env));
3999         Type clazztype;
4000         JCTree typeTree;
4001         if (tree.pattern.getTag() == BINDINGPATTERN) {
4002             attribTree(tree.pattern, env, unknownExprInfo);
4003             clazztype = tree.pattern.type;
4004             JCBindingPattern pattern = (JCBindingPattern) tree.pattern;
4005             typeTree = pattern.vartype;
4006             if (!clazztype.hasTag(TYPEVAR)) {
4007                 clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);
4008             }
4009         } else {
4010             clazztype = attribType(tree.pattern, env);
4011             typeTree = tree.pattern;
4012         }
4013         if (!clazztype.hasTag(TYPEVAR)) {
4014             clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);
4015         }
4016         if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
4017             boolean valid = false;
4018             if (allowReifiableTypesInInstanceof) {
4019                 if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {
4020                     preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);
4021                 }
4022                 Warner warner = new Warner();
4023                 if (!types.isCastable(exprtype, clazztype, warner)) {
4024                     chk.basicHandler.report(tree.expr.pos(),
4025                                             diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));
4026                 } else if (warner.hasLint(LintCategory.UNCHECKED)) {
4027                     log.error(tree.expr.pos(),
4028                               Errors.InstanceofReifiableNotSafe(exprtype, clazztype));
4029                 } else {
4030                     valid = true;
4031                 }
4032             } else {
4033                 log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);
4034             }
4035             if (!valid) {
4036                 clazztype = types.createErrorType(clazztype);
4037             }
4038         }
4039         chk.validate(typeTree, env, false);
4040         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
4041         result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
4042     }
4043 
4044     public void visitBindingPattern(JCBindingPattern tree) {
4045         ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);
4046         tree.type = attribTree(tree.vartype, env, varInfo);
4047         VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype.type, env.info.scope.owner);
4048         if (chk.checkUnique(tree.pos(), v, env.info.scope)) {
4049             chk.checkTransparentVar(tree.pos(), v, env.info.scope);
4050         }
4051         annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());
4052         annotate.flush();
4053         result = tree.type;
4054         matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());
4055     }
4056 
4057     public void visitIndexed(JCArrayAccess tree) {
4058         Type owntype = types.createErrorType(tree.type);
4059         Type atype = attribExpr(tree.indexed, env);
4060         attribExpr(tree.index, env, syms.intType);
4061         if (types.isArray(atype))
4062             owntype = types.elemtype(atype);
4063         else if (!atype.hasTag(ERROR))
4064             log.error(tree.pos(), Errors.ArrayReqButFound(atype));
4065         if (!pkind().contains(KindSelector.VAL))
4066             owntype = capture(owntype);
4067         result = check(tree, owntype, KindSelector.VAR, resultInfo);
4068     }
4069 
4070     public void visitIdent(JCIdent tree) {
4071         Symbol sym;
4072 
4073         // Find symbol
4074         if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
4075             // If we are looking for a method, the prototype `pt&#39; will be a
4076             // method type with the type of the call&#39;s arguments as parameters.
4077             env.info.pendingResolutionPhase = null;
4078             sym = rs.resolveMethod(tree.pos(), env, tree.name, pt().getParameterTypes(), pt().getTypeArguments());
4079         } else if (tree.sym != null &amp;&amp; tree.sym.kind != VAR) {
4080             sym = tree.sym;
4081         } else {
4082             sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind());
4083         }
4084         tree.sym = sym;
4085 
4086         // (1) Also find the environment current for the class where
4087         //     sym is defined (`symEnv&#39;).
4088         // Only for pre-tiger versions (1.4 and earlier):
4089         // (2) Also determine whether we access symbol out of an anonymous
4090         //     class in a this or super call.  This is illegal for instance
4091         //     members since such classes don&#39;t carry a this$n link.
4092         //     (`noOuterThisPath&#39;).
4093         Env&lt;AttrContext&gt; symEnv = env;
4094         boolean noOuterThisPath = false;
4095         if (env.enclClass.sym.owner.kind != PCK &amp;&amp; // we are in an inner class
4096             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4097             sym.owner.kind == TYP &amp;&amp;
4098             tree.name != names._this &amp;&amp; tree.name != names._super) {
4099 
4100             // Find environment in which identifier is defined.
4101             while (symEnv.outer != null &amp;&amp;
4102                    !sym.isMemberOf(symEnv.enclClass.sym, types)) {
4103                 if ((symEnv.enclClass.sym.flags() &amp; NOOUTERTHIS) != 0)
4104                     noOuterThisPath = false;
4105                 symEnv = symEnv.outer;
4106             }
4107         }
4108 
4109         // If symbol is a variable, ...
4110         if (sym.kind == VAR) {
4111             VarSymbol v = (VarSymbol)sym;
4112 
4113             // ..., evaluate its initializer, if it has one, and check for
4114             // illegal forward reference.
4115             checkInit(tree, env, v, false);
4116 
4117             // If we are expecting a variable (as opposed to a value), check
4118             // that the variable is assignable in the current environment.
4119             if (KindSelector.ASG.subset(pkind()))
4120                 checkAssignable(tree.pos(), v, null, env);
4121         }
4122 
4123         // In a constructor body,
4124         // if symbol is a field or instance method, check that it is
4125         // not accessed before the supertype constructor is called.
4126         if ((symEnv.info.isSelfCall || noOuterThisPath) &amp;&amp;
4127             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4128             sym.owner.kind == TYP &amp;&amp;
4129             (sym.flags() &amp; STATIC) == 0) {
4130             chk.earlyRefError(tree.pos(), sym.kind == VAR ?
4131                                           sym : thisSym(tree.pos(), env));
4132         }
4133         Env&lt;AttrContext&gt; env1 = env;
4134         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4135             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4136             // If the found symbol is inaccessible, then it is
4137             // accessed through an enclosing instance.  Locate this
4138             // enclosing instance:
4139             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4140                 env1 = env1.outer;
4141         }
4142 
4143         if (env.info.isSerializable) {
4144             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4145         }
4146 
4147         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4148     }
4149 
4150     public void visitSelect(JCFieldAccess tree) {
4151         // Determine the expected kind of the qualifier expression.
4152         KindSelector skind = KindSelector.NIL;
4153         if (tree.name == names._this || tree.name == names._super ||
<a name="25" id="anc25"></a><span class="line-modified">4154                 tree.name == names._class || tree.name == names._default)</span>
4155         {
<a name="26" id="anc26"></a><span class="line-added">4156             if (tree.name == names._default &amp;&amp; !allowInlineTypes) {</span>
<span class="line-added">4157                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),</span>
<span class="line-added">4158                         Feature.INLINE_TYPES.error(sourceName));</span>
<span class="line-added">4159             }</span>
4160             skind = KindSelector.TYP;
4161         } else {
4162             if (pkind().contains(KindSelector.PCK))
4163                 skind = KindSelector.of(skind, KindSelector.PCK);
4164             if (pkind().contains(KindSelector.TYP))
4165                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4166             if (pkind().contains(KindSelector.VAL_MTH))
4167                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4168         }
4169 
4170         // Attribute the qualifier expression, and determine its symbol (if any).
4171         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4172         if (!pkind().contains(KindSelector.TYP_PCK))
4173             site = capture(site); // Capture field access
4174 
4175         // don&#39;t allow T.class T[].class, etc
4176         if (skind == KindSelector.TYP) {
4177             Type elt = site;
4178             while (elt.hasTag(ARRAY))
4179                 elt = ((ArrayType)elt).elemtype;
4180             if (elt.hasTag(TYPEVAR)) {
<a name="27" id="anc27"></a><span class="line-modified">4181                 if (tree.name == names._default) {</span>
<span class="line-modified">4182                     result = check(tree, litType(BOT).constType(null),</span>
<span class="line-modified">4183                             KindSelector.VAL, resultInfo);</span>
<span class="line-modified">4184                 } else {</span>
<span class="line-added">4185                     log.error(tree.pos(), Errors.TypeVarCantBeDeref);</span>
<span class="line-added">4186                     result = tree.type = types.createErrorType(tree.name, site.tsym, site);</span>
<span class="line-added">4187                     tree.sym = tree.type.tsym;</span>
<span class="line-added">4188                     return;</span>
<span class="line-added">4189                 }</span>
4190             }
4191         }
4192 
4193         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4194         // for the selection. This is relevant for determining whether
4195         // protected symbols are accessible.
4196         Symbol sitesym = TreeInfo.symbol(tree.selected);
<a name="28" id="anc28"></a><span class="line-added">4197 </span>
4198         boolean selectSuperPrev = env.info.selectSuper;
4199         env.info.selectSuper =
4200             sitesym != null &amp;&amp;
4201             sitesym.name == names._super;
4202 
4203         // Determine the symbol represented by the selection.
4204         env.info.pendingResolutionPhase = null;
4205         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4206         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4207             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4208             sym = syms.errSymbol;
4209         }
4210         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4211             site = capture(site);
4212             sym = selectSym(tree, sitesym, site, env, resultInfo);
4213         }
4214         boolean varArgs = env.info.lastResolveVarargs();
4215         tree.sym = sym;
4216 
4217         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
4218             site = types.skipTypeVars(site, true);
4219         }
4220 
4221         // If that symbol is a variable, ...
4222         if (sym.kind == VAR) {
4223             VarSymbol v = (VarSymbol)sym;
4224 
4225             // ..., evaluate its initializer, if it has one, and check for
4226             // illegal forward reference.
4227             checkInit(tree, env, v, true);
4228 
4229             // If we are expecting a variable (as opposed to a value), check
4230             // that the variable is assignable in the current environment.
4231             if (KindSelector.ASG.subset(pkind()))
4232                 checkAssignable(tree.pos(), v, tree.selected, env);
4233         }
4234 
4235         if (sitesym != null &amp;&amp;
4236                 sitesym.kind == VAR &amp;&amp;
4237                 ((VarSymbol)sitesym).isResourceVariable() &amp;&amp;
4238                 sym.kind == MTH &amp;&amp;
4239                 sym.name.equals(names.close) &amp;&amp;
4240                 sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true) &amp;&amp;
4241                 env.info.lint.isEnabled(LintCategory.TRY)) {
4242             log.warning(LintCategory.TRY, tree, Warnings.TryExplicitCloseCall);
4243         }
4244 
4245         // Disallow selecting a type from an expression
4246         if (isType(sym) &amp;&amp; (sitesym == null || !sitesym.kind.matches(KindSelector.TYP_PCK))) {
4247             tree.type = check(tree.selected, pt(),
4248                               sitesym == null ?
4249                                       KindSelector.VAL : sitesym.kind.toSelector(),
4250                               new ResultInfo(KindSelector.TYP_PCK, pt()));
4251         }
4252 
4253         if (isType(sitesym)) {
4254             if (sym.name == names._this) {
4255                 // If `C&#39; is the currently compiled class, check that
4256                 // C.this&#39; does not appear in a call to a super(...)
4257                 if (env.info.isSelfCall &amp;&amp;
4258                     site.tsym == env.enclClass.sym) {
4259                     chk.earlyRefError(tree.pos(), sym);
4260                 }
4261             } else {
4262                 // Check if type-qualified fields or methods are static (JLS)
4263                 if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4264                     sym.name != names._super &amp;&amp;
4265                     (sym.kind == VAR || sym.kind == MTH)) {
4266                     rs.accessBase(rs.new StaticError(sym),
4267                               tree.pos(), site, sym.name, true);
4268                 }
4269             }
4270             if (!allowStaticInterfaceMethods &amp;&amp; sitesym.isInterface() &amp;&amp;
4271                     sym.isStatic() &amp;&amp; sym.kind == MTH) {
4272                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(), Feature.STATIC_INTERFACE_METHODS_INVOKE.error(sourceName));
4273             }
4274         } else if (sym.kind != ERR &amp;&amp;
4275                    (sym.flags() &amp; STATIC) != 0 &amp;&amp;
4276                    sym.name != names._class) {
4277             // If the qualified item is not a type and the selected item is static, report
4278             // a warning. Make allowance for the class of an array type e.g. Object[].class)
4279             chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));
4280         }
4281 
4282         // If we are selecting an instance member via a `super&#39;, ...
4283         if (env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
4284 
4285             // Check that super-qualified symbols are not abstract (JLS)
4286             rs.checkNonAbstract(tree.pos(), sym);
4287 
4288             if (site.isRaw()) {
4289                 // Determine argument types for site.
4290                 Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);
4291                 if (site1 != null) site = site1;
4292             }
4293         }
4294 
4295         if (env.info.isSerializable) {
4296             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4297         }
4298 
4299         env.info.selectSuper = selectSuperPrev;
4300         result = checkId(tree, site, sym, env, resultInfo);
4301     }
4302     //where
4303         /** Determine symbol referenced by a Select expression,
4304          *
4305          *  @param tree   The select tree.
4306          *  @param site   The type of the selected expression,
4307          *  @param env    The current environment.
4308          *  @param resultInfo The current result.
4309          */
4310         private Symbol selectSym(JCFieldAccess tree,
4311                                  Symbol location,
4312                                  Type site,
4313                                  Env&lt;AttrContext&gt; env,
4314                                  ResultInfo resultInfo) {
4315             DiagnosticPosition pos = tree.pos();
4316             Name name = tree.name;
4317             switch (site.getTag()) {
4318             case PACKAGE:
4319                 return rs.accessBase(
4320                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4321                     pos, location, site, name, true);
4322             case ARRAY:
4323             case CLASS:
4324                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4325                     return rs.resolveQualifiedMethod(
4326                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4327                 } else if (name == names._this || name == names._super) {
4328                     return rs.resolveSelf(pos, env, site.tsym, name);
4329                 } else if (name == names._class) {
4330                     // In this case, we have already made sure in
4331                     // visitSelect that qualifier expression is a type.
4332                     return syms.getClassField(site, types);
<a name="29" id="anc29"></a><span class="line-added">4333                 } else if (name == names._default) {</span>
<span class="line-added">4334                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
<span class="line-added">4335                 } else if (name == names.ref &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {</span>
<span class="line-added">4336                     return site.tsym.referenceProjection();</span>
<span class="line-added">4337                 } else if (name == names.val &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {</span>
<span class="line-added">4338                     return site.tsym;</span>
4339                 } else {
4340                     // We are seeing a plain identifier as selector.
4341                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4342                         sym = rs.accessBase(sym, pos, location, site, name, true);
4343                     return sym;
4344                 }
4345             case WILDCARD:
4346                 throw new AssertionError(tree);
4347             case TYPEVAR:
<a name="30" id="anc30"></a><span class="line-added">4348                 if (name == names._default) {</span>
<span class="line-added">4349                     // Be sure to return the default value before examining bounds</span>
<span class="line-added">4350                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
<span class="line-added">4351                 }</span>
4352                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4353                 // It should only happen during memberEnter/attribBase
4354                 // when determining the super type which *must* be
4355                 // done before attributing the type variables.  In
4356                 // other words, we are seeing this illegal program:
4357                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4358                 Symbol sym = (site.getUpperBound() != null)
4359                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4360                     : null;
4361                 if (sym == null) {
4362                     log.error(pos, Errors.TypeVarCantBeDeref);
4363                     return syms.errSymbol;
4364                 } else {
4365                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4366                         rs.new AccessError(env, site, sym) :
4367                                 sym;
4368                     rs.accessBase(sym2, pos, location, site, name, true);
4369                     return sym;
4370                 }
4371             case ERROR:
4372                 // preserve identifier names through errors
4373                 return types.createErrorType(name, site.tsym, site).tsym;
4374             default:
4375                 // The qualifier expression is of a primitive type -- only
<a name="31" id="anc31"></a><span class="line-modified">4376                 // .class and .default is allowed for these.</span>
4377                 if (name == names._class) {
4378                     // In this case, we have already made sure in Select that
4379                     // qualifier expression is a type.
4380                     return syms.getClassField(site, types);
<a name="32" id="anc32"></a><span class="line-added">4381                 } else if (name == names._default) {</span>
<span class="line-added">4382                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
4383                 } else {
4384                     log.error(pos, Errors.CantDeref(site));
4385                     return syms.errSymbol;
4386                 }
4387             }
4388         }
4389 
4390         /** Determine type of identifier or select expression and check that
4391          *  (1) the referenced symbol is not deprecated
4392          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4393          *  (3) if symbol is a variable, check that its type and kind are
4394          *      compatible with the prototype and protokind.
4395          *  (4) if symbol is an instance field of a raw type,
4396          *      which is being assigned to, issue an unchecked warning if its
4397          *      type changes under erasure.
4398          *  (5) if symbol is an instance method of a raw type, issue an
4399          *      unchecked warning if its argument types change under erasure.
4400          *  If checks succeed:
4401          *    If symbol is a constant, return its constant type
4402          *    else if symbol is a method, return its result type
4403          *    otherwise return its type.
4404          *  Otherwise return errType.
4405          *
4406          *  @param tree       The syntax tree representing the identifier
4407          *  @param site       If this is a select, the type of the selected
4408          *                    expression, otherwise the type of the current class.
4409          *  @param sym        The symbol representing the identifier.
4410          *  @param env        The current environment.
4411          *  @param resultInfo    The expected result
4412          */
4413         Type checkId(JCTree tree,
4414                      Type site,
4415                      Symbol sym,
4416                      Env&lt;AttrContext&gt; env,
4417                      ResultInfo resultInfo) {
4418             return (resultInfo.pt.hasTag(FORALL) || resultInfo.pt.hasTag(METHOD)) ?
4419                     checkMethodIdInternal(tree, site, sym, env, resultInfo) :
4420                     checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4421         }
4422 
4423         Type checkMethodIdInternal(JCTree tree,
4424                      Type site,
4425                      Symbol sym,
4426                      Env&lt;AttrContext&gt; env,
4427                      ResultInfo resultInfo) {
4428             if (resultInfo.pkind.contains(KindSelector.POLY)) {
4429                 Type pt = resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, sym, env.info.pendingResolutionPhase));
4430                 Type owntype = checkIdInternal(tree, site, sym, pt, env, resultInfo);
4431                 resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4432                 return owntype;
4433             } else {
4434                 return checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4435             }
4436         }
4437 
4438         Type checkIdInternal(JCTree tree,
4439                      Type site,
4440                      Symbol sym,
4441                      Type pt,
4442                      Env&lt;AttrContext&gt; env,
4443                      ResultInfo resultInfo) {
4444             if (pt.isErroneous()) {
4445                 return types.createErrorType(site);
4446             }
4447             Type owntype; // The computed type of this identifier occurrence.
4448             switch (sym.kind) {
4449             case TYP:
4450                 // For types, the computed type equals the symbol&#39;s type,
4451                 // except for two situations:
4452                 owntype = sym.type;
4453                 if (owntype.hasTag(CLASS)) {
4454                     chk.checkForBadAuxiliaryClassAccess(tree.pos(), env, (ClassSymbol)sym);
4455                     Type ownOuter = owntype.getEnclosingType();
4456 
4457                     // (a) If the symbol&#39;s type is parameterized, erase it
4458                     // because no type parameters were given.
4459                     // We recover generic outer type later in visitTypeApply.
4460                     if (owntype.tsym.type.getTypeArguments().nonEmpty()) {
4461                         owntype = types.erasure(owntype);
4462                     }
4463 
4464                     // (b) If the symbol&#39;s type is an inner class, then
4465                     // we have to interpret its outer type as a superclass
4466                     // of the site type. Example:
4467                     //
4468                     // class Tree&lt;A&gt; { class Visitor { ... } }
4469                     // class PointTree extends Tree&lt;Point&gt; { ... }
4470                     // ...PointTree.Visitor...
4471                     //
4472                     // Then the type of the last expression above is
4473                     // Tree&lt;Point&gt;.Visitor.
4474                     else if (ownOuter.hasTag(CLASS) &amp;&amp; site != ownOuter) {
4475                         Type normOuter = site;
4476                         if (normOuter.hasTag(CLASS)) {
4477                             normOuter = types.asEnclosingSuper(site, ownOuter.tsym);
4478                         }
4479                         if (normOuter == null) // perhaps from an import
4480                             normOuter = types.erasure(ownOuter);
4481                         if (normOuter != ownOuter)
4482                             owntype = new ClassType(
4483                                 normOuter, List.nil(), owntype.tsym,
4484                                 owntype.getMetadata());
4485                     }
4486                 }
4487                 break;
4488             case VAR:
4489                 VarSymbol v = (VarSymbol)sym;
4490 
4491                 if (env.info.enclVar != null
4492                         &amp;&amp; v.type.hasTag(NONE)) {
4493                     //self reference to implicitly typed variable declaration
4494                     log.error(TreeInfo.positionFor(v, env.enclClass), Errors.CantInferLocalVarType(v.name, Fragments.LocalSelfRef));
4495                     return v.type = types.createErrorType(v.type);
4496                 }
4497 
4498                 // Test (4): if symbol is an instance field of a raw type,
4499                 // which is being assigned to, issue an unchecked warning if
4500                 // its type changes under erasure.
4501                 if (KindSelector.ASG.subset(pkind()) &amp;&amp;
4502                     v.owner.kind == TYP &amp;&amp;
4503                     (v.flags() &amp; STATIC) == 0 &amp;&amp;
4504                     (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4505                     Type s = types.asOuterSuper(site, v.owner);
4506                     if (s != null &amp;&amp;
4507                         s.isRaw() &amp;&amp;
4508                         !types.isSameType(v.type, v.erasure(types))) {
4509                         chk.warnUnchecked(tree.pos(), Warnings.UncheckedAssignToVar(v, s));
4510                     }
4511                 }
4512                 // The computed type of a variable is the type of the
4513                 // variable symbol, taken as a member of the site type.
4514                 owntype = (sym.owner.kind == TYP &amp;&amp;
4515                            sym.name != names._this &amp;&amp; sym.name != names._super)
4516                     ? types.memberType(site, sym)
4517                     : sym.type;
4518 
4519                 // If the variable is a constant, record constant value in
4520                 // computed type.
4521                 if (v.getConstValue() != null &amp;&amp; isStaticReference(tree))
4522                     owntype = owntype.constType(v.getConstValue());
4523 
4524                 if (resultInfo.pkind == KindSelector.VAL) {
4525                     owntype = capture(owntype); // capture &quot;names as expressions&quot;
4526                 }
4527                 break;
4528             case MTH: {
4529                 owntype = checkMethod(site, sym,
4530                         new ResultInfo(resultInfo.pkind, resultInfo.pt.getReturnType(), resultInfo.checkContext, resultInfo.checkMode),
4531                         env, TreeInfo.args(env.tree), resultInfo.pt.getParameterTypes(),
4532                         resultInfo.pt.getTypeArguments());
4533                 break;
4534             }
4535             case PCK: case ERR:
4536                 owntype = sym.type;
4537                 break;
4538             default:
4539                 throw new AssertionError(&quot;unexpected kind: &quot; + sym.kind +
4540                                          &quot; in tree &quot; + tree);
4541             }
4542 
4543             // Emit a `deprecation&#39; warning if symbol is deprecated.
4544             // (for constructors (but not for constructor references), the error
4545             // was given when the constructor was resolved)
4546 
4547             if (sym.name != names.init || tree.hasTag(REFERENCE)) {
4548                 chk.checkDeprecated(tree.pos(), env.info.scope.owner, sym);
4549                 chk.checkSunAPI(tree.pos(), sym);
4550                 chk.checkProfile(tree.pos(), sym);
4551                 chk.checkPreview(tree.pos(), sym);
4552             }
4553 
4554             // If symbol is a variable, check that its type and
4555             // kind are compatible with the prototype and protokind.
4556             return check(tree, owntype, sym.kind.toSelector(), resultInfo);
4557         }
4558 
4559         /** Check that variable is initialized and evaluate the variable&#39;s
4560          *  initializer, if not yet done. Also check that variable is not
4561          *  referenced before it is defined.
4562          *  @param tree    The tree making up the variable reference.
4563          *  @param env     The current environment.
4564          *  @param v       The variable&#39;s symbol.
4565          */
4566         private void checkInit(JCTree tree,
4567                                Env&lt;AttrContext&gt; env,
4568                                VarSymbol v,
4569                                boolean onlyWarning) {
4570             // A forward reference is diagnosed if the declaration position
4571             // of the variable is greater than the current tree position
4572             // and the tree and variable definition occur in the same class
4573             // definition.  Note that writes don&#39;t count as references.
4574             // This check applies only to class and instance
4575             // variables.  Local variables follow different scope rules,
4576             // and are subject to definite assignment checking.
4577             Env&lt;AttrContext&gt; initEnv = enclosingInitEnv(env);
4578             if (initEnv != null &amp;&amp;
4579                 (initEnv.info.enclVar == v || v.pos &gt; tree.pos) &amp;&amp;
4580                 v.owner.kind == TYP &amp;&amp;
4581                 v.owner == env.info.scope.owner.enclClass() &amp;&amp;
4582                 ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env) &amp;&amp;
4583                 (!env.tree.hasTag(ASSIGN) ||
4584                  TreeInfo.skipParens(((JCAssign) env.tree).lhs) != tree)) {
4585                 if (!onlyWarning || isStaticEnumField(v)) {
4586                     Error errkey = (initEnv.info.enclVar == v) ?
4587                                 Errors.IllegalSelfRef : Errors.IllegalForwardRef;
4588                     log.error(tree.pos(), errkey);
4589                 } else if (useBeforeDeclarationWarning) {
4590                     Warning warnkey = (initEnv.info.enclVar == v) ?
4591                                 Warnings.SelfRef(v) : Warnings.ForwardRef(v);
4592                     log.warning(tree.pos(), warnkey);
4593                 }
4594             }
4595 
4596             v.getConstValue(); // ensure initializer is evaluated
4597 
4598             checkEnumInitializer(tree, env, v);
4599         }
4600 
4601         /**
4602          * Returns the enclosing init environment associated with this env (if any). An init env
4603          * can be either a field declaration env or a static/instance initializer env.
4604          */
4605         Env&lt;AttrContext&gt; enclosingInitEnv(Env&lt;AttrContext&gt; env) {
4606             while (true) {
4607                 switch (env.tree.getTag()) {
4608                     case VARDEF:
4609                         JCVariableDecl vdecl = (JCVariableDecl)env.tree;
4610                         if (vdecl.sym.owner.kind == TYP) {
4611                             //field
4612                             return env;
4613                         }
4614                         break;
4615                     case BLOCK:
4616                         if (env.next.tree.hasTag(CLASSDEF)) {
4617                             //instance/static initializer
4618                             return env;
4619                         }
4620                         break;
4621                     case METHODDEF:
4622                     case CLASSDEF:
4623                     case TOPLEVEL:
4624                         return null;
4625                 }
4626                 Assert.checkNonNull(env.next);
4627                 env = env.next;
4628             }
4629         }
4630 
4631         /**
4632          * Check for illegal references to static members of enum.  In
4633          * an enum type, constructors and initializers may not
4634          * reference its static members unless they are constant.
4635          *
4636          * @param tree    The tree making up the variable reference.
4637          * @param env     The current environment.
4638          * @param v       The variable&#39;s symbol.
4639          * @jls 8.9 Enum Types
4640          */
4641         private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
4642             // JLS:
4643             //
4644             // &quot;It is a compile-time error to reference a static field
4645             // of an enum type that is not a compile-time constant
4646             // (15.28) from constructors, instance initializer blocks,
4647             // or instance variable initializer expressions of that
4648             // type. It is a compile-time error for the constructors,
4649             // instance initializer blocks, or instance variable
4650             // initializer expressions of an enum constant e to refer
4651             // to itself or to an enum constant of the same type that
4652             // is declared to the right of e.&quot;
4653             if (isStaticEnumField(v)) {
4654                 ClassSymbol enclClass = env.info.scope.owner.enclClass();
4655 
4656                 if (enclClass == null || enclClass.owner == null)
4657                     return;
4658 
4659                 // See if the enclosing class is the enum (or a
4660                 // subclass thereof) declaring v.  If not, this
4661                 // reference is OK.
4662                 if (v.owner != enclClass &amp;&amp; !types.isSubtype(enclClass.type, v.owner.type))
4663                     return;
4664 
4665                 // If the reference isn&#39;t from an initializer, then
4666                 // the reference is OK.
4667                 if (!Resolve.isInitializer(env))
4668                     return;
4669 
4670                 log.error(tree.pos(), Errors.IllegalEnumStaticRef);
4671             }
4672         }
4673 
4674         /** Is the given symbol a static, non-constant field of an Enum?
4675          *  Note: enum literals should not be regarded as such
4676          */
4677         private boolean isStaticEnumField(VarSymbol v) {
4678             return Flags.isEnum(v.owner) &amp;&amp;
4679                    Flags.isStatic(v) &amp;&amp;
4680                    !Flags.isConstant(v) &amp;&amp;
4681                    v.name != names._class;
4682         }
4683 
4684     /**
4685      * Check that method arguments conform to its instantiation.
4686      **/
4687     public Type checkMethod(Type site,
4688                             final Symbol sym,
4689                             ResultInfo resultInfo,
4690                             Env&lt;AttrContext&gt; env,
4691                             final List&lt;JCExpression&gt; argtrees,
4692                             List&lt;Type&gt; argtypes,
4693                             List&lt;Type&gt; typeargtypes) {
4694         // Test (5): if symbol is an instance method of a raw type, issue
4695         // an unchecked warning if its argument types change under erasure.
4696         if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4697             (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4698             Type s = types.asOuterSuper(site, sym.owner);
4699             if (s != null &amp;&amp; s.isRaw() &amp;&amp;
4700                 !types.isSameTypes(sym.type.getParameterTypes(),
4701                                    sym.erasure(types).getParameterTypes())) {
4702                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedCallMbrOfRawType(sym, s));
4703             }
4704         }
4705 
4706         if (env.info.defaultSuperCallSite != null) {
4707             for (Type sup : types.interfaces(env.enclClass.type).prepend(types.supertype((env.enclClass.type)))) {
4708                 if (!sup.tsym.isSubClass(sym.enclClass(), types) ||
4709                         types.isSameType(sup, env.info.defaultSuperCallSite)) continue;
4710                 List&lt;MethodSymbol&gt; icand_sup =
4711                         types.interfaceCandidates(sup, (MethodSymbol)sym);
4712                 if (icand_sup.nonEmpty() &amp;&amp;
4713                         icand_sup.head != sym &amp;&amp;
4714                         icand_sup.head.overrides(sym, icand_sup.head.enclClass(), types, true)) {
4715                     log.error(env.tree.pos(),
4716                               Errors.IllegalDefaultSuperCall(env.info.defaultSuperCallSite, Fragments.OverriddenDefault(sym, sup)));
4717                     break;
4718                 }
4719             }
4720             env.info.defaultSuperCallSite = null;
4721         }
4722 
4723         if (sym.isStatic() &amp;&amp; site.isInterface() &amp;&amp; env.tree.hasTag(APPLY)) {
4724             JCMethodInvocation app = (JCMethodInvocation)env.tree;
4725             if (app.meth.hasTag(SELECT) &amp;&amp;
4726                     !TreeInfo.isStaticSelector(((JCFieldAccess)app.meth).selected, names)) {
4727                 log.error(env.tree.pos(), Errors.IllegalStaticIntfMethCall(site));
4728             }
4729         }
4730 
4731         // Compute the identifier&#39;s instantiated type.
4732         // For methods, we need to compute the instance type by
4733         // Resolve.instantiate from the symbol&#39;s type as well as
4734         // any type arguments and value arguments.
4735         Warner noteWarner = new Warner();
4736         try {
4737             Type owntype = rs.checkMethod(
4738                     env,
4739                     site,
4740                     sym,
4741                     resultInfo,
4742                     argtypes,
4743                     typeargtypes,
4744                     noteWarner);
4745 
4746             DeferredAttr.DeferredTypeMap&lt;Void&gt; checkDeferredMap =
4747                 deferredAttr.new DeferredTypeMap&lt;&gt;(DeferredAttr.AttrMode.CHECK, sym, env.info.pendingResolutionPhase);
4748 
4749             argtypes = argtypes.map(checkDeferredMap);
4750 
4751             if (noteWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
4752                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedMethInvocationApplied(kindName(sym),
4753                         sym.name,
4754                         rs.methodArguments(sym.type.getParameterTypes()),
4755                         rs.methodArguments(argtypes.map(checkDeferredMap)),
4756                         kindName(sym.location()),
4757                         sym.location()));
4758                 if (resultInfo.pt != Infer.anyPoly ||
4759                         !owntype.hasTag(METHOD) ||
4760                         !owntype.isPartial()) {
4761                     //if this is not a partially inferred method type, erase return type. Otherwise,
4762                     //erasure is carried out in PartiallyInferredMethodType.check().
4763                     owntype = new MethodType(owntype.getParameterTypes(),
4764                             types.erasure(owntype.getReturnType()),
4765                             types.erasure(owntype.getThrownTypes()),
4766                             syms.methodClass);
4767                 }
4768             }
4769 
4770             PolyKind pkind = (sym.type.hasTag(FORALL) &amp;&amp;
4771                  sym.type.getReturnType().containsAny(((ForAll)sym.type).tvars)) ?
4772                  PolyKind.POLY : PolyKind.STANDALONE;
4773             TreeInfo.setPolyKind(env.tree, pkind);
4774 
4775             return (resultInfo.pt == Infer.anyPoly) ?
4776                     owntype :
4777                     chk.checkMethod(owntype, sym, env, argtrees, argtypes, env.info.lastResolveVarargs(),
4778                             resultInfo.checkContext.inferenceContext());
4779         } catch (Infer.InferenceException ex) {
4780             //invalid target type - propagate exception outwards or report error
4781             //depending on the current check context
4782             resultInfo.checkContext.report(env.tree.pos(), ex.getDiagnostic());
4783             return types.createErrorType(site);
4784         } catch (Resolve.InapplicableMethodException ex) {
4785             final JCDiagnostic diag = ex.getDiagnostic();
4786             Resolve.InapplicableSymbolError errSym = rs.new InapplicableSymbolError(null) {
4787                 @Override
4788                 protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4789                     return new Pair&lt;&gt;(sym, diag);
4790                 }
4791             };
4792             List&lt;Type&gt; argtypes2 = argtypes.map(
4793                     rs.new ResolveDeferredRecoveryMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4794             JCDiagnostic errDiag = errSym.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
4795                     env.tree, sym, site, sym.name, argtypes2, typeargtypes);
4796             log.report(errDiag);
4797             return types.createErrorType(site);
4798         }
4799     }
4800 
4801     public void visitLiteral(JCLiteral tree) {
4802         result = check(tree, litType(tree.typetag).constType(tree.value),
4803                 KindSelector.VAL, resultInfo);
4804     }
4805     //where
4806     /** Return the type of a literal with given type tag.
4807      */
4808     Type litType(TypeTag tag) {
4809         return (tag == CLASS) ? syms.stringType : syms.typeOfTag[tag.ordinal()];
4810     }
4811 
4812     public void visitTypeIdent(JCPrimitiveTypeTree tree) {
4813         result = check(tree, syms.typeOfTag[tree.typetag.ordinal()], KindSelector.TYP, resultInfo);
4814     }
4815 
4816     public void visitTypeArray(JCArrayTypeTree tree) {
4817         Type etype = attribType(tree.elemtype, env);
4818         Type type = new ArrayType(etype, syms.arrayClass);
4819         result = check(tree, type, KindSelector.TYP, resultInfo);
4820     }
4821 
4822     /** Visitor method for parameterized types.
4823      *  Bound checking is left until later, since types are attributed
4824      *  before supertype structure is completely known
4825      */
4826     public void visitTypeApply(JCTypeApply tree) {
4827         Type owntype = types.createErrorType(tree.type);
4828 
4829         // Attribute functor part of application and make sure it&#39;s a class.
4830         Type clazztype = chk.checkClassType(tree.clazz.pos(), attribType(tree.clazz, env));
4831 
4832         // Attribute type parameters
4833         List&lt;Type&gt; actuals = attribTypes(tree.arguments, env);
4834 
4835         if (clazztype.hasTag(CLASS)) {
4836             List&lt;Type&gt; formals = clazztype.tsym.type.getTypeArguments();
4837             if (actuals.isEmpty()) //diamond
4838                 actuals = formals;
4839 
4840             if (actuals.length() == formals.length()) {
4841                 List&lt;Type&gt; a = actuals;
4842                 List&lt;Type&gt; f = formals;
4843                 while (a.nonEmpty()) {
4844                     a.head = a.head.withTypeVar(f.head);
4845                     a = a.tail;
4846                     f = f.tail;
4847                 }
4848                 // Compute the proper generic outer
4849                 Type clazzOuter = clazztype.getEnclosingType();
4850                 if (clazzOuter.hasTag(CLASS)) {
4851                     Type site;
4852                     JCExpression clazz = TreeInfo.typeIn(tree.clazz);
4853                     if (clazz.hasTag(IDENT)) {
4854                         site = env.enclClass.sym.type;
4855                     } else if (clazz.hasTag(SELECT)) {
4856                         site = ((JCFieldAccess) clazz).selected.type;
4857                     } else throw new AssertionError(&quot;&quot;+tree);
4858                     if (clazzOuter.hasTag(CLASS) &amp;&amp; site != clazzOuter) {
4859                         if (site.hasTag(CLASS))
4860                             site = types.asOuterSuper(site, clazzOuter.tsym);
4861                         if (site == null)
4862                             site = types.erasure(clazzOuter);
4863                         clazzOuter = site;
4864                     }
4865                 }
4866                 owntype = new ClassType(clazzOuter, actuals, clazztype.tsym,
4867                                         clazztype.getMetadata());
4868             } else {
4869                 if (formals.length() != 0) {
4870                     log.error(tree.pos(),
4871                               Errors.WrongNumberTypeArgs(Integer.toString(formals.length())));
4872                 } else {
4873                     log.error(tree.pos(), Errors.TypeDoesntTakeParams(clazztype.tsym));
4874                 }
4875                 owntype = types.createErrorType(tree.type);
4876             }
4877         }
4878         result = check(tree, owntype, KindSelector.TYP, resultInfo);
4879     }
4880 
4881     public void visitTypeUnion(JCTypeUnion tree) {
4882         ListBuffer&lt;Type&gt; multicatchTypes = new ListBuffer&lt;&gt;();
4883         ListBuffer&lt;Type&gt; all_multicatchTypes = null; // lazy, only if needed
4884         for (JCExpression typeTree : tree.alternatives) {
4885             Type ctype = attribType(typeTree, env);
4886             ctype = chk.checkType(typeTree.pos(),
4887                           chk.checkClassType(typeTree.pos(), ctype),
4888                           syms.throwableType);
4889             if (!ctype.isErroneous()) {
4890                 //check that alternatives of a union type are pairwise
4891                 //unrelated w.r.t. subtyping
4892                 if (chk.intersects(ctype,  multicatchTypes.toList())) {
4893                     for (Type t : multicatchTypes) {
4894                         boolean sub = types.isSubtype(ctype, t);
4895                         boolean sup = types.isSubtype(t, ctype);
4896                         if (sub || sup) {
4897                             //assume &#39;a&#39; &lt;: &#39;b&#39;
4898                             Type a = sub ? ctype : t;
4899                             Type b = sub ? t : ctype;
4900                             log.error(typeTree.pos(), Errors.MulticatchTypesMustBeDisjoint(a, b));
4901                         }
4902                     }
4903                 }
4904                 multicatchTypes.append(ctype);
4905                 if (all_multicatchTypes != null)
4906                     all_multicatchTypes.append(ctype);
4907             } else {
4908                 if (all_multicatchTypes == null) {
4909                     all_multicatchTypes = new ListBuffer&lt;&gt;();
4910                     all_multicatchTypes.appendList(multicatchTypes);
4911                 }
4912                 all_multicatchTypes.append(ctype);
4913             }
4914         }
4915         Type t = check(tree, types.lub(multicatchTypes.toList()),
4916                 KindSelector.TYP, resultInfo.dup(CheckMode.NO_TREE_UPDATE));
4917         if (t.hasTag(CLASS)) {
4918             List&lt;Type&gt; alternatives =
4919                 ((all_multicatchTypes == null) ? multicatchTypes : all_multicatchTypes).toList();
4920             t = new UnionClassType((ClassType) t, alternatives);
4921         }
4922         tree.type = result = t;
4923     }
4924 
4925     public void visitTypeIntersection(JCTypeIntersection tree) {
4926         attribTypes(tree.bounds, env);
4927         tree.type = result = checkIntersection(tree, tree.bounds);
4928     }
4929 
4930     public void visitTypeParameter(JCTypeParameter tree) {
4931         TypeVar typeVar = (TypeVar) tree.type;
4932 
4933         if (tree.annotations != null &amp;&amp; tree.annotations.nonEmpty()) {
4934             annotate.annotateTypeParameterSecondStage(tree, tree.annotations);
4935         }
4936 
4937         if (!typeVar.getUpperBound().isErroneous()) {
4938             //fixup type-parameter bound computed in &#39;attribTypeVariables&#39;
4939             typeVar.setUpperBound(checkIntersection(tree, tree.bounds));
4940         }
4941     }
4942 
4943     Type checkIntersection(JCTree tree, List&lt;JCExpression&gt; bounds) {
4944         Set&lt;Type&gt; boundSet = new HashSet&lt;&gt;();
4945         if (bounds.nonEmpty()) {
4946             // accept class or interface or typevar as first bound.
4947             bounds.head.type = checkBase(bounds.head.type, bounds.head, env, false, false, false);
4948             boundSet.add(types.erasure(bounds.head.type));
4949             if (bounds.head.type.isErroneous()) {
4950                 return bounds.head.type;
4951             }
4952             else if (bounds.head.type.hasTag(TYPEVAR)) {
4953                 // if first bound was a typevar, do not accept further bounds.
4954                 if (bounds.tail.nonEmpty()) {
4955                     log.error(bounds.tail.head.pos(),
4956                               Errors.TypeVarMayNotBeFollowedByOtherBounds);
4957                     return bounds.head.type;
4958                 }
4959             } else {
4960                 // if first bound was a class or interface, accept only interfaces
4961                 // as further bounds.
4962                 for (JCExpression bound : bounds.tail) {
4963                     bound.type = checkBase(bound.type, bound, env, false, true, false);
4964                     if (bound.type.isErroneous()) {
4965                         bounds = List.of(bound);
4966                     }
4967                     else if (bound.type.hasTag(CLASS)) {
4968                         chk.checkNotRepeated(bound.pos(), types.erasure(bound.type), boundSet);
4969                     }
4970                 }
4971             }
4972         }
4973 
4974         if (bounds.length() == 0) {
4975             return syms.objectType;
4976         } else if (bounds.length() == 1) {
4977             return bounds.head.type;
4978         } else {
4979             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
4980             // ... the variable&#39;s bound is a class type flagged COMPOUND
4981             // (see comment for TypeVar.bound).
4982             // In this case, generate a class tree that represents the
4983             // bound class, ...
4984             JCExpression extending;
4985             List&lt;JCExpression&gt; implementing;
4986             if (!bounds.head.type.isInterface()) {
4987                 extending = bounds.head;
4988                 implementing = bounds.tail;
4989             } else {
4990                 extending = null;
4991                 implementing = bounds;
4992             }
4993             JCClassDecl cd = make.at(tree).ClassDef(
<a name="33" id="anc33"></a><span class="line-modified">4994                 make.Modifiers(PUBLIC | ABSTRACT | (extending != null &amp;&amp; TreeInfo.symbol(extending).isValue() ? VALUE : 0)),</span>
4995                 names.empty, List.nil(),
4996                 extending, implementing, List.nil());
4997 
4998             ClassSymbol c = (ClassSymbol)owntype.tsym;
4999             Assert.check((c.flags() &amp; COMPOUND) != 0);
5000             cd.sym = c;
5001             c.sourcefile = env.toplevel.sourcefile;
5002 
5003             // ... and attribute the bound class
5004             c.flags_field |= UNATTRIBUTED;
5005             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
5006             typeEnvs.put(c, cenv);
5007             attribClass(c);
5008             return owntype;
5009         }
5010     }
5011 
5012     public void visitWildcard(JCWildcard tree) {
5013         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
5014         Type type = (tree.kind.kind == BoundKind.UNBOUND)
5015             ? syms.objectType
5016             : attribType(tree.inner, env);
<a name="34" id="anc34"></a><span class="line-modified">5017         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),</span>
5018                                               tree.kind.kind,
5019                                               syms.boundClass),
5020                 KindSelector.TYP, resultInfo);
5021     }
5022 
5023     public void visitAnnotation(JCAnnotation tree) {
5024         Assert.error(&quot;should be handled in annotate&quot;);
5025     }
5026 
5027     public void visitAnnotatedType(JCAnnotatedType tree) {
5028         attribAnnotationTypes(tree.annotations, env);
5029         Type underlyingType = attribType(tree.underlyingType, env);
5030         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
5031 
5032         if (!env.info.isNewClass)
5033             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
5034         result = tree.type = annotatedType;
5035     }
5036 
5037     public void visitErroneous(JCErroneous tree) {
5038         if (tree.errs != null)
5039             for (JCTree err : tree.errs)
5040                 attribTree(err, env, new ResultInfo(KindSelector.ERR, pt()));
5041         result = tree.type = syms.errType;
5042     }
5043 
5044     /** Default visitor method for all other trees.
5045      */
5046     public void visitTree(JCTree tree) {
5047         throw new AssertionError();
5048     }
5049 
5050     /**
5051      * Attribute an env for either a top level tree or class or module declaration.
5052      */
5053     public void attrib(Env&lt;AttrContext&gt; env) {
5054         switch (env.tree.getTag()) {
5055             case MODULEDEF:
5056                 attribModule(env.tree.pos(), ((JCModuleDecl)env.tree).sym);
5057                 break;
5058             case TOPLEVEL:
5059                 attribTopLevel(env);
5060                 break;
5061             case PACKAGEDEF:
5062                 attribPackage(env.tree.pos(), ((JCPackageDecl) env.tree).packge);
5063                 break;
5064             default:
5065                 attribClass(env.tree.pos(), env.enclClass.sym);
5066         }
5067     }
5068 
5069     /**
5070      * Attribute a top level tree. These trees are encountered when the
5071      * package declaration has annotations.
5072      */
5073     public void attribTopLevel(Env&lt;AttrContext&gt; env) {
5074         JCCompilationUnit toplevel = env.toplevel;
5075         try {
5076             annotate.flush();
5077         } catch (CompletionFailure ex) {
5078             chk.completionError(toplevel.pos(), ex);
5079         }
5080     }
5081 
5082     public void attribPackage(DiagnosticPosition pos, PackageSymbol p) {
5083         try {
5084             annotate.flush();
5085             attribPackage(p);
5086         } catch (CompletionFailure ex) {
5087             chk.completionError(pos, ex);
5088         }
5089     }
5090 
5091     void attribPackage(PackageSymbol p) {
5092         Env&lt;AttrContext&gt; env = typeEnvs.get(p);
5093         chk.checkDeprecatedAnnotation(((JCPackageDecl) env.tree).pid.pos(), p);
5094     }
5095 
5096     public void attribModule(DiagnosticPosition pos, ModuleSymbol m) {
5097         try {
5098             annotate.flush();
5099             attribModule(m);
5100         } catch (CompletionFailure ex) {
5101             chk.completionError(pos, ex);
5102         }
5103     }
5104 
5105     void attribModule(ModuleSymbol m) {
5106         // Get environment current at the point of module definition.
5107         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
5108         attribStat(env.tree, env);
5109     }
5110 
5111     /** Main method: attribute class definition associated with given class symbol.
5112      *  reporting completion failures at the given position.
5113      *  @param pos The source position at which completion errors are to be
5114      *             reported.
5115      *  @param c   The class symbol whose definition will be attributed.
5116      */
5117     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
5118         try {
5119             annotate.flush();
5120             attribClass(c);
<a name="35" id="anc35"></a><span class="line-added">5121             if (types.isValue(c.type)) {</span>
<span class="line-added">5122                 final Env&lt;AttrContext&gt; env = typeEnvs.get(c);</span>
<span class="line-added">5123                 if (!allowValueMemberCycles) {</span>
<span class="line-added">5124                     if (env != null &amp;&amp; env.tree != null &amp;&amp; env.tree.hasTag(CLASSDEF))</span>
<span class="line-added">5125                         chk.checkNonCyclicMembership((JCClassDecl)env.tree);</span>
<span class="line-added">5126                 }</span>
<span class="line-added">5127             }</span>
5128         } catch (CompletionFailure ex) {
5129             chk.completionError(pos, ex);
5130         }
5131     }
5132 
5133     /** Attribute class definition associated with given class symbol.
5134      *  @param c   The class symbol whose definition will be attributed.
5135      */
5136     void attribClass(ClassSymbol c) throws CompletionFailure {
5137         if (c.type.hasTag(ERROR)) return;
5138 
5139         // Check for cycles in the inheritance graph, which can arise from
5140         // ill-formed class files.
5141         chk.checkNonCyclic(null, c.type);
5142 
5143         Type st = types.supertype(c.type);
5144         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5145             // First, attribute superclass.
5146             if (st.hasTag(CLASS))
5147                 attribClass((ClassSymbol)st.tsym);
5148 
5149             // Next attribute owner, if it is a class.
5150             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5151                 attribClass((ClassSymbol)c.owner);
5152         }
5153 
5154         // The previous operations might have attributed the current class
5155         // if there was a cycle. So we test first whether the class is still
5156         // UNATTRIBUTED.
5157         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5158             c.flags_field &amp;= ~UNATTRIBUTED;
5159 
5160             // Get environment current at the point of class definition.
5161             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5162 
5163             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5164             // because the annotations were not available at the time the env was created. Therefore,
5165             // we look up the environment chain for the first enclosing environment for which the
5166             // lint value is set. Typically, this is the parent env, but might be further if there
5167             // are any envs created as a result of TypeParameter nodes.
5168             Env&lt;AttrContext&gt; lintEnv = env;
5169             while (lintEnv.info.lint == null)
5170                 lintEnv = lintEnv.next;
5171 
5172             // Having found the enclosing lint value, we can initialize the lint value for this class
5173             env.info.lint = lintEnv.info.lint.augment(c);
5174 
5175             Lint prevLint = chk.setLint(env.info.lint);
5176             JavaFileObject prev = log.useSource(c.sourcefile);
5177             ResultInfo prevReturnRes = env.info.returnResult;
5178 
5179             try {
5180                 deferredLintHandler.flush(env.tree);
5181                 env.info.returnResult = null;
5182                 // java.lang.Enum may not be subclassed by a non-enum
5183                 if (st.tsym == syms.enumSym &amp;&amp;
5184                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5185                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5186 
5187                 // Enums may not be extended by source-level classes
5188                 if (st.tsym != null &amp;&amp;
5189                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5190                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5191                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5192                 }
5193 
5194                 if (isSerializable(c.type)) {
5195                     env.info.isSerializable = true;
5196                 }
5197 
5198                 attribClassBody(env, c);
5199 
<a name="36" id="anc36"></a><span class="line-added">5200                 if ((c.flags() &amp; (VALUE | ABSTRACT)) == VALUE) { // for non-intersection, concrete values.</span>
<span class="line-added">5201                     Assert.check(env.tree.hasTag(CLASSDEF));</span>
<span class="line-added">5202                     JCClassDecl classDecl = (JCClassDecl) env.tree;</span>
<span class="line-added">5203                     if (classDecl.extending != null) {</span>
<span class="line-added">5204                         chk.checkConstraintsOfInlineSuper(env.tree.pos(), c);</span>
<span class="line-added">5205                     }</span>
<span class="line-added">5206                 }</span>
<span class="line-added">5207 </span>
5208                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5209                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5210                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5211                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5212             } finally {
5213                 env.info.returnResult = prevReturnRes;
5214                 log.useSource(prev);
5215                 chk.setLint(prevLint);
5216             }
5217 
5218         }
5219     }
5220 
5221     public void visitImport(JCImport tree) {
5222         // nothing to do
5223     }
5224 
5225     public void visitModuleDef(JCModuleDecl tree) {
5226         tree.sym.completeUsesProvides();
5227         ModuleSymbol msym = tree.sym;
5228         Lint lint = env.outer.info.lint = env.outer.info.lint.augment(msym);
5229         Lint prevLint = chk.setLint(lint);
5230         chk.checkModuleName(tree);
5231         chk.checkDeprecatedAnnotation(tree, msym);
5232 
5233         try {
5234             deferredLintHandler.flush(tree.pos());
5235         } finally {
5236             chk.setLint(prevLint);
5237         }
5238     }
5239 
5240     /** Finish the attribution of a class. */
5241     private void attribClassBody(Env&lt;AttrContext&gt; env, ClassSymbol c) {
5242         JCClassDecl tree = (JCClassDecl)env.tree;
5243         Assert.check(c == tree.sym);
5244 
5245         // Validate type parameters, supertype and interfaces.
5246         attribStats(tree.typarams, env);
5247         if (!c.isAnonymous()) {
5248             //already checked if anonymous
5249             chk.validate(tree.typarams, env);
5250             chk.validate(tree.extending, env);
5251             chk.validate(tree.implementing, env);
5252         }
5253 
5254         c.markAbstractIfNeeded(types);
5255 
5256         // If this is a non-abstract class, check that it has no abstract
5257         // methods or unimplemented methods of an implemented interface.
5258         if ((c.flags() &amp; (ABSTRACT | INTERFACE)) == 0) {
5259             chk.checkAllDefined(tree.pos(), c);
5260         }
5261 
5262         if ((c.flags() &amp; ANNOTATION) != 0) {
5263             if (tree.implementing.nonEmpty())
5264                 log.error(tree.implementing.head.pos(),
5265                           Errors.CantExtendIntfAnnotation);
5266             if (tree.typarams.nonEmpty()) {
5267                 log.error(tree.typarams.head.pos(),
5268                           Errors.IntfAnnotationCantHaveTypeParams(c));
5269             }
5270 
5271             // If this annotation type has a @Repeatable, validate
5272             Attribute.Compound repeatable = c.getAnnotationTypeMetadata().getRepeatable();
5273             // If this annotation type has a @Repeatable, validate
5274             if (repeatable != null) {
5275                 // get diagnostic position for error reporting
5276                 DiagnosticPosition cbPos = getDiagnosticPosition(tree, repeatable.type);
5277                 Assert.checkNonNull(cbPos);
5278 
5279                 chk.validateRepeatable(c, repeatable, cbPos);
5280             }
5281         } else {
5282             // Check that all extended classes and interfaces
5283             // are compatible (i.e. no two define methods with same arguments
5284             // yet different return types).  (JLS 8.4.6.3)
5285             chk.checkCompatibleSupertypes(tree.pos(), c.type);
5286             if (allowDefaultMethods) {
5287                 chk.checkDefaultMethodClashes(tree.pos(), c.type);
5288             }
5289         }
5290 
5291         // Check that class does not import the same parameterized interface
5292         // with two different argument lists.
5293         chk.checkClassBounds(tree.pos(), c.type);
5294 
5295         tree.type = c.type;
5296 
5297         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5298              l.nonEmpty(); l = l.tail) {
5299              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5300         }
5301 
5302         // Check that a generic class doesn&#39;t extend Throwable
5303         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5304             log.error(tree.extending.pos(), Errors.GenericThrowable);
5305 
5306         // Check that all methods which implement some
5307         // method conform to the method they implement.
5308         chk.checkImplementations(tree);
5309 
5310         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5311         checkAutoCloseable(tree.pos(), env, c.type);
5312 
<a name="37" id="anc37"></a><span class="line-added">5313         boolean hasInstanceFields = false;</span>
5314         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5315             // Attribute declaration
5316             attribStat(l.head, env);
<a name="38" id="anc38"></a><span class="line-added">5317 </span>
<span class="line-added">5318             if (l.head.hasTag(VARDEF) &amp;&amp; (TreeInfo.flags(l.head) &amp; STATIC) == 0)</span>
<span class="line-added">5319                 hasInstanceFields = true;</span>
<span class="line-added">5320 </span>
5321             // Check that declarations in inner classes are not static (JLS 8.1.2)
5322             // Make an exception for static constants.
5323             if (c.owner.kind != PCK &amp;&amp;
5324                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5325                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5326                 Symbol sym = null;
5327                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5328                 if (sym == null ||
5329                     sym.kind != VAR ||
5330                     ((VarSymbol) sym).getConstValue() == null)
5331                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5332             }
5333         }
<a name="39" id="anc39"></a><span class="line-added">5334         if (!allowEmptyValues &amp;&amp; !hasInstanceFields &amp;&amp; (c.flags() &amp; (VALUE | SYNTHETIC)) == VALUE) {</span>
<span class="line-added">5335             log.error(tree.pos(), Errors.EmptyValueNotYet);</span>
<span class="line-added">5336         }</span>
5337 
5338         // Check for cycles among non-initial constructors.
5339         chk.checkCyclicConstructors(tree);
5340 
5341         // Check for cycles among annotation elements.
5342         chk.checkNonCyclicElements(tree);
5343 
5344         // Check for proper use of serialVersionUID
5345         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5346                 &amp;&amp; isSerializable(c.type)
5347                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5348                 &amp;&amp; !c.isAnonymous()) {
5349             checkSerialVersionUID(tree, c);
5350         }
5351         if (allowTypeAnnos) {
5352             // Correctly organize the positions of the type annotations
5353             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5354 
5355             // Check type annotations applicability rules
5356             validateTypeAnnotations(tree, false);
5357         }
5358     }
5359         // where
5360         /** get a diagnostic position for an attribute of Type t, or null if attribute missing */
5361         private DiagnosticPosition getDiagnosticPosition(JCClassDecl tree, Type t) {
5362             for(List&lt;JCAnnotation&gt; al = tree.mods.annotations; !al.isEmpty(); al = al.tail) {
5363                 if (types.isSameType(al.head.annotationType.type, t))
5364                     return al.head.pos();
5365             }
5366 
5367             return null;
5368         }
5369 
5370         /** check if a type is a subtype of Serializable, if that is available. */
5371         boolean isSerializable(Type t) {
5372             try {
5373                 syms.serializableType.complete();
5374             }
5375             catch (CompletionFailure e) {
5376                 return false;
5377             }
5378             return types.isSubtype(t, syms.serializableType);
5379         }
5380 
5381         /** Check that an appropriate serialVersionUID member is defined. */
5382         private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c) {
5383 
5384             // check for presence of serialVersionUID
5385             VarSymbol svuid = null;
5386             for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {
5387                 if (sym.kind == VAR) {
5388                     svuid = (VarSymbol)sym;
5389                     break;
5390                 }
5391             }
5392 
5393             if (svuid == null) {
5394                 log.warning(LintCategory.SERIAL,
5395                         tree.pos(), Warnings.MissingSVUID(c));
5396                 return;
5397             }
5398 
5399             // check that it is static final
5400             if ((svuid.flags() &amp; (STATIC | FINAL)) !=
5401                 (STATIC | FINAL))
5402                 log.warning(LintCategory.SERIAL,
5403                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID(c));
5404 
5405             // check that it is long
5406             else if (!svuid.type.hasTag(LONG))
5407                 log.warning(LintCategory.SERIAL,
5408                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.LongSVUID(c));
5409 
5410             // check constant
5411             else if (svuid.getConstValue() == null)
5412                 log.warning(LintCategory.SERIAL,
5413                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ConstantSVUID(c));
5414         }
5415 
5416     private Type capture(Type type) {
5417         return types.capture(type);
5418     }
5419 
5420     private void setSyntheticVariableType(JCVariableDecl tree, Type type) {
5421         if (type.isErroneous()) {
5422             tree.vartype = make.at(Position.NOPOS).Erroneous();
5423         } else {
5424             tree.vartype = make.at(Position.NOPOS).Type(type);
5425         }
5426     }
5427 
5428     public void validateTypeAnnotations(JCTree tree, boolean sigOnly) {
5429         tree.accept(new TypeAnnotationsValidator(sigOnly));
5430     }
5431     //where
5432     private final class TypeAnnotationsValidator extends TreeScanner {
5433 
5434         private final boolean sigOnly;
5435         public TypeAnnotationsValidator(boolean sigOnly) {
5436             this.sigOnly = sigOnly;
5437         }
5438 
5439         public void visitAnnotation(JCAnnotation tree) {
5440             chk.validateTypeAnnotation(tree, false);
5441             super.visitAnnotation(tree);
5442         }
5443         public void visitAnnotatedType(JCAnnotatedType tree) {
5444             if (!tree.underlyingType.type.isErroneous()) {
5445                 super.visitAnnotatedType(tree);
5446             }
5447         }
5448         public void visitTypeParameter(JCTypeParameter tree) {
5449             chk.validateTypeAnnotations(tree.annotations, true);
5450             scan(tree.bounds);
5451             // Don&#39;t call super.
5452             // This is needed because above we call validateTypeAnnotation with
5453             // false, which would forbid annotations on type parameters.
5454             // super.visitTypeParameter(tree);
5455         }
5456         public void visitMethodDef(JCMethodDecl tree) {
5457             if (tree.recvparam != null &amp;&amp;
5458                     !tree.recvparam.vartype.type.isErroneous()) {
5459                 checkForDeclarationAnnotations(tree.recvparam.mods.annotations,
5460                         tree.recvparam.vartype.type.tsym);
5461             }
5462             if (tree.restype != null &amp;&amp; tree.restype.type != null) {
5463                 validateAnnotatedType(tree.restype, tree.restype.type);
5464             }
5465             if (sigOnly) {
5466                 scan(tree.mods);
5467                 scan(tree.restype);
5468                 scan(tree.typarams);
5469                 scan(tree.recvparam);
5470                 scan(tree.params);
5471                 scan(tree.thrown);
5472             } else {
5473                 scan(tree.defaultValue);
5474                 scan(tree.body);
5475             }
5476         }
5477         public void visitVarDef(final JCVariableDecl tree) {
5478             //System.err.println(&quot;validateTypeAnnotations.visitVarDef &quot; + tree);
5479             if (tree.sym != null &amp;&amp; tree.sym.type != null &amp;&amp; !tree.isImplicitlyTyped())
5480                 validateAnnotatedType(tree.vartype, tree.sym.type);
5481             scan(tree.mods);
5482             scan(tree.vartype);
5483             if (!sigOnly) {
5484                 scan(tree.init);
5485             }
5486         }
5487         public void visitTypeCast(JCTypeCast tree) {
5488             if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
5489                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5490             super.visitTypeCast(tree);
5491         }
5492         public void visitTypeTest(JCInstanceOf tree) {
5493             if (tree.pattern != null &amp;&amp; !(tree.pattern instanceof JCPattern) &amp;&amp; tree.pattern.type != null)
5494                 validateAnnotatedType(tree.pattern, tree.pattern.type);
5495             super.visitTypeTest(tree);
5496         }
5497         public void visitNewClass(JCNewClass tree) {
5498             if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
5499                 if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
5500                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.clazz).annotations,
5501                             tree.clazz.type.tsym);
5502                 }
5503                 if (tree.def != null) {
5504                     checkForDeclarationAnnotations(tree.def.mods.annotations, tree.clazz.type.tsym);
5505                 }
5506 
5507                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5508             }
5509             super.visitNewClass(tree);
5510         }
5511         public void visitNewArray(JCNewArray tree) {
5512             if (tree.elemtype != null &amp;&amp; tree.elemtype.type != null) {
5513                 if (tree.elemtype.hasTag(ANNOTATED_TYPE)) {
5514                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.elemtype).annotations,
5515                             tree.elemtype.type.tsym);
5516                 }
5517                 validateAnnotatedType(tree.elemtype, tree.elemtype.type);
5518             }
5519             super.visitNewArray(tree);
5520         }
5521         public void visitClassDef(JCClassDecl tree) {
5522             //System.err.println(&quot;validateTypeAnnotations.visitClassDef &quot; + tree);
5523             if (sigOnly) {
5524                 scan(tree.mods);
5525                 scan(tree.typarams);
5526                 scan(tree.extending);
5527                 scan(tree.implementing);
5528             }
5529             for (JCTree member : tree.defs) {
5530                 if (member.hasTag(Tag.CLASSDEF)) {
5531                     continue;
5532                 }
5533                 scan(member);
5534             }
5535         }
5536         public void visitBlock(JCBlock tree) {
5537             if (!sigOnly) {
5538                 scan(tree.stats);
5539             }
5540         }
5541 
5542         /* I would want to model this after
5543          * com.sun.tools.javac.comp.Check.Validator.visitSelectInternal(JCFieldAccess)
5544          * and override visitSelect and visitTypeApply.
5545          * However, we only set the annotated type in the top-level type
5546          * of the symbol.
5547          * Therefore, we need to override each individual location where a type
5548          * can occur.
5549          */
5550         private void validateAnnotatedType(final JCTree errtree, final Type type) {
5551             //System.err.println(&quot;Attr.validateAnnotatedType: &quot; + errtree + &quot; type: &quot; + type);
5552 
5553             if (type.isPrimitiveOrVoid()) {
5554                 return;
5555             }
5556 
5557             JCTree enclTr = errtree;
5558             Type enclTy = type;
5559 
5560             boolean repeat = true;
5561             while (repeat) {
5562                 if (enclTr.hasTag(TYPEAPPLY)) {
5563                     List&lt;Type&gt; tyargs = enclTy.getTypeArguments();
5564                     List&lt;JCExpression&gt; trargs = ((JCTypeApply)enclTr).getTypeArguments();
5565                     if (trargs.length() &gt; 0) {
5566                         // Nothing to do for diamonds
5567                         if (tyargs.length() == trargs.length()) {
5568                             for (int i = 0; i &lt; tyargs.length(); ++i) {
5569                                 validateAnnotatedType(trargs.get(i), tyargs.get(i));
5570                             }
5571                         }
5572                         // If the lengths don&#39;t match, it&#39;s either a diamond
5573                         // or some nested type that redundantly provides
5574                         // type arguments in the tree.
5575                     }
5576 
5577                     // Look at the clazz part of a generic type
5578                     enclTr = ((JCTree.JCTypeApply)enclTr).clazz;
5579                 }
5580 
5581                 if (enclTr.hasTag(SELECT)) {
5582                     enclTr = ((JCTree.JCFieldAccess)enclTr).getExpression();
5583                     if (enclTy != null &amp;&amp;
5584                             !enclTy.hasTag(NONE)) {
5585                         enclTy = enclTy.getEnclosingType();
5586                     }
5587                 } else if (enclTr.hasTag(ANNOTATED_TYPE)) {
5588                     JCAnnotatedType at = (JCTree.JCAnnotatedType) enclTr;
5589                     if (enclTy == null || enclTy.hasTag(NONE)) {
5590                         if (at.getAnnotations().size() == 1) {
5591                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping1(at.getAnnotations().head.attribute));
5592                         } else {
5593                             ListBuffer&lt;Attribute.Compound&gt; comps = new ListBuffer&lt;&gt;();
5594                             for (JCAnnotation an : at.getAnnotations()) {
5595                                 comps.add(an.attribute);
5596                             }
5597                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping(comps.toList()));
5598                         }
5599                         repeat = false;
5600                     }
5601                     enclTr = at.underlyingType;
5602                     // enclTy doesn&#39;t need to be changed
5603                 } else if (enclTr.hasTag(IDENT)) {
5604                     repeat = false;
5605                 } else if (enclTr.hasTag(JCTree.Tag.WILDCARD)) {
5606                     JCWildcard wc = (JCWildcard) enclTr;
5607                     if (wc.getKind() == JCTree.Kind.EXTENDS_WILDCARD ||
5608                             wc.getKind() == JCTree.Kind.SUPER_WILDCARD) {
5609                         validateAnnotatedType(wc.getBound(), wc.getBound().type);
5610                     } else {
5611                         // Nothing to do for UNBOUND
5612                     }
5613                     repeat = false;
5614                 } else if (enclTr.hasTag(TYPEARRAY)) {
5615                     JCArrayTypeTree art = (JCArrayTypeTree) enclTr;
5616                     validateAnnotatedType(art.getType(), art.elemtype.type);
5617                     repeat = false;
5618                 } else if (enclTr.hasTag(TYPEUNION)) {
5619                     JCTypeUnion ut = (JCTypeUnion) enclTr;
5620                     for (JCTree t : ut.getTypeAlternatives()) {
5621                         validateAnnotatedType(t, t.type);
5622                     }
5623                     repeat = false;
5624                 } else if (enclTr.hasTag(TYPEINTERSECTION)) {
5625                     JCTypeIntersection it = (JCTypeIntersection) enclTr;
5626                     for (JCTree t : it.getBounds()) {
5627                         validateAnnotatedType(t, t.type);
5628                     }
5629                     repeat = false;
5630                 } else if (enclTr.getKind() == JCTree.Kind.PRIMITIVE_TYPE ||
5631                            enclTr.getKind() == JCTree.Kind.ERRONEOUS) {
5632                     repeat = false;
5633                 } else {
5634                     Assert.error(&quot;Unexpected tree: &quot; + enclTr + &quot; with kind: &quot; + enclTr.getKind() +
5635                             &quot; within: &quot;+ errtree + &quot; with kind: &quot; + errtree.getKind());
5636                 }
5637             }
5638         }
5639 
5640         private void checkForDeclarationAnnotations(List&lt;? extends JCAnnotation&gt; annotations,
5641                 Symbol sym) {
5642             // Ensure that no declaration annotations are present.
5643             // Note that a tree type might be an AnnotatedType with
5644             // empty annotations, if only declaration annotations were given.
5645             // This method will raise an error for such a type.
5646             for (JCAnnotation ai : annotations) {
5647                 if (!ai.type.isErroneous() &amp;&amp;
5648                         typeAnnotations.annotationTargetType(ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {
5649                     log.error(ai.pos(), Errors.AnnotationTypeNotApplicableToType(ai.type));
5650                 }
5651             }
5652         }
5653     }
5654 
5655     // &lt;editor-fold desc=&quot;post-attribution visitor&quot;&gt;
5656 
5657     /**
5658      * Handle missing types/symbols in an AST. This routine is useful when
5659      * the compiler has encountered some errors (which might have ended up
5660      * terminating attribution abruptly); if the compiler is used in fail-over
5661      * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
5662      * prevents NPE to be propagated during subsequent compilation steps.
5663      */
5664     public void postAttr(JCTree tree) {
5665         new PostAttrAnalyzer().scan(tree);
5666     }
5667 
5668     class PostAttrAnalyzer extends TreeScanner {
5669 
5670         private void initTypeIfNeeded(JCTree that) {
5671             if (that.type == null) {
5672                 if (that.hasTag(METHODDEF)) {
5673                     that.type = dummyMethodType((JCMethodDecl)that);
5674                 } else {
5675                     that.type = syms.unknownType;
5676                 }
5677             }
5678         }
5679 
5680         /* Construct a dummy method type. If we have a method declaration,
5681          * and the declared return type is void, then use that return type
5682          * instead of UNKNOWN to avoid spurious error messages in lambda
5683          * bodies (see:JDK-8041704).
5684          */
5685         private Type dummyMethodType(JCMethodDecl md) {
5686             Type restype = syms.unknownType;
5687             if (md != null &amp;&amp; md.restype != null &amp;&amp; md.restype.hasTag(TYPEIDENT)) {
5688                 JCPrimitiveTypeTree prim = (JCPrimitiveTypeTree)md.restype;
5689                 if (prim.typetag == VOID)
5690                     restype = syms.voidType;
5691             }
5692             return new MethodType(List.nil(), restype,
5693                                   List.nil(), syms.methodClass);
5694         }
5695         private Type dummyMethodType() {
5696             return dummyMethodType(null);
5697         }
5698 
5699         @Override
5700         public void scan(JCTree tree) {
5701             if (tree == null) return;
5702             if (tree instanceof JCExpression) {
5703                 initTypeIfNeeded(tree);
5704             }
5705             super.scan(tree);
5706         }
5707 
5708         @Override
5709         public void visitIdent(JCIdent that) {
5710             if (that.sym == null) {
5711                 that.sym = syms.unknownSymbol;
5712             }
5713         }
5714 
5715         @Override
5716         public void visitSelect(JCFieldAccess that) {
5717             if (that.sym == null) {
5718                 that.sym = syms.unknownSymbol;
5719             }
5720             super.visitSelect(that);
5721         }
5722 
5723         @Override
5724         public void visitClassDef(JCClassDecl that) {
5725             initTypeIfNeeded(that);
5726             if (that.sym == null) {
5727                 that.sym = new ClassSymbol(0, that.name, that.type, syms.noSymbol);
5728             }
5729             super.visitClassDef(that);
5730         }
5731 
5732         @Override
5733         public void visitMethodDef(JCMethodDecl that) {
5734             initTypeIfNeeded(that);
5735             if (that.sym == null) {
5736                 that.sym = new MethodSymbol(0, that.name, that.type, syms.noSymbol);
5737             }
5738             super.visitMethodDef(that);
5739         }
5740 
5741         @Override
5742         public void visitVarDef(JCVariableDecl that) {
5743             initTypeIfNeeded(that);
5744             if (that.sym == null) {
5745                 that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
5746                 that.sym.adr = 0;
5747             }
5748             if (that.vartype == null) {
5749                 that.vartype = make.at(Position.NOPOS).Erroneous();
5750             }
5751             super.visitVarDef(that);
5752         }
5753 
5754         @Override
5755         public void visitBindingPattern(JCBindingPattern that) {
5756             if (that.symbol == null) {
5757                 that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);
5758                 that.symbol.adr = 0;
5759             }
5760             super.visitBindingPattern(that);
5761         }
5762 
5763         @Override
5764         public void visitNewClass(JCNewClass that) {
5765             if (that.constructor == null) {
5766                 that.constructor = new MethodSymbol(0, names.init,
5767                         dummyMethodType(), syms.noSymbol);
5768             }
5769             if (that.constructorType == null) {
5770                 that.constructorType = syms.unknownType;
5771             }
5772             super.visitNewClass(that);
5773         }
5774 
5775         @Override
5776         public void visitAssignop(JCAssignOp that) {
5777             if (that.operator == null) {
5778                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5779                         -1, syms.noSymbol);
5780             }
5781             super.visitAssignop(that);
5782         }
5783 
5784         @Override
5785         public void visitBinary(JCBinary that) {
5786             if (that.operator == null) {
5787                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5788                         -1, syms.noSymbol);
5789             }
5790             super.visitBinary(that);
5791         }
5792 
5793         @Override
5794         public void visitUnary(JCUnary that) {
5795             if (that.operator == null) {
5796                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5797                         -1, syms.noSymbol);
5798             }
5799             super.visitUnary(that);
5800         }
5801 
5802         @Override
5803         public void visitReference(JCMemberReference that) {
5804             super.visitReference(that);
5805             if (that.sym == null) {
5806                 that.sym = new MethodSymbol(0, names.empty, dummyMethodType(),
5807                         syms.noSymbol);
5808             }
5809         }
5810     }
5811     // &lt;/editor-fold&gt;
5812 
5813     public void setPackageSymbols(JCExpression pid, Symbol pkg) {
5814         new TreeScanner() {
5815             Symbol packge = pkg;
5816             @Override
5817             public void visitIdent(JCIdent that) {
5818                 that.sym = packge;
5819             }
5820 
5821             @Override
5822             public void visitSelect(JCFieldAccess that) {
5823                 that.sym = packge;
5824                 packge = packge.owner;
5825                 super.visitSelect(that);
5826             }
5827         }.scan(pid);
5828     }
5829 
5830 }
<a name="40" id="anc40"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="40" type="hidden" />
</body>
</html>
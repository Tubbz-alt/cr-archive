<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.annotation.Inherited;
  30 import java.util.Collections;
  31 import java.util.EnumSet;
  32 import java.util.HashMap;
  33 import java.util.Map;
  34 import java.util.Set;
  35 import java.util.concurrent.Callable;
  36 import java.util.function.Supplier;
  37 
  38 import javax.lang.model.element.Element;
  39 import javax.lang.model.element.ElementKind;
  40 import javax.lang.model.element.ElementVisitor;
  41 import javax.lang.model.element.ExecutableElement;
  42 import javax.lang.model.element.Modifier;
  43 import javax.lang.model.element.ModuleElement;
  44 import javax.lang.model.element.NestingKind;
  45 import javax.lang.model.element.PackageElement;
  46 import javax.lang.model.element.RecordComponentElement;
  47 import javax.lang.model.element.TypeElement;
  48 import javax.lang.model.element.TypeParameterElement;
  49 import javax.lang.model.element.VariableElement;
  50 import javax.tools.JavaFileManager;
  51 import javax.tools.JavaFileObject;
  52 
  53 import com.sun.tools.javac.code.Kinds.Kind;
  54 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  55 import com.sun.tools.javac.code.Type.*;
  56 import com.sun.tools.javac.comp.Attr;
  57 import com.sun.tools.javac.comp.AttrContext;
  58 import com.sun.tools.javac.comp.Env;
  59 import com.sun.tools.javac.jvm.*;
  60 import com.sun.tools.javac.jvm.PoolConstant;
  61 import com.sun.tools.javac.tree.JCTree;
  62 import com.sun.tools.javac.tree.JCTree.JCAnnotation;
  63 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
  64 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  65 import com.sun.tools.javac.tree.JCTree.Tag;
  66 import com.sun.tools.javac.util.*;
  67 import com.sun.tools.javac.util.DefinedBy.Api;
  68 import com.sun.tools.javac.util.List;
  69 import com.sun.tools.javac.util.Name;
  70 
  71 import static com.sun.tools.javac.code.Flags.*;
  72 import static com.sun.tools.javac.code.Kinds.*;
  73 import static com.sun.tools.javac.code.Kinds.Kind.*;
  74 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  75 import com.sun.tools.javac.code.Scope.WriteableScope;
  76 import static com.sun.tools.javac.code.TypeTag.CLASS;
  77 import static com.sun.tools.javac.code.TypeTag.FORALL;
  78 import static com.sun.tools.javac.code.TypeTag.TYPEVAR;
  79 import static com.sun.tools.javac.jvm.ByteCodes.iadd;
  80 import static com.sun.tools.javac.jvm.ByteCodes.ishll;
  81 import static com.sun.tools.javac.jvm.ByteCodes.lushrl;
  82 import static com.sun.tools.javac.jvm.ByteCodes.lxor;
  83 import static com.sun.tools.javac.jvm.ByteCodes.string_add;
  84 
  85 /** Root class for Java symbols. It contains subclasses
  86  *  for specific sorts of symbols, such as variables, methods and operators,
  87  *  types, packages. Each subclass is represented as a static inner class
  88  *  inside Symbol.
  89  *
  90  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  91  *  If you write code that depends on this, you do so at your own risk.
  92  *  This code and its internal interfaces are subject to change or
  93  *  deletion without notice.&lt;/b&gt;
  94  */
  95 public abstract class Symbol extends AnnoConstruct implements PoolConstant, Element {
  96 
  97     /** The kind of this symbol.
  98      *  @see Kinds
  99      */
 100     public Kind kind;
 101 
 102     /** The flags of this symbol.
 103      */
 104     public long flags_field;
 105 
 106     /** An accessor method for the flags of this symbol.
 107      *  Flags of class symbols should be accessed through the accessor
 108      *  method to make sure that the class symbol is loaded.
 109      */
 110     public long flags() { return flags_field; }
 111 
 112     /** The name of this symbol in Utf8 representation.
 113      */
 114     public Name name;
 115 
 116     /** The type of this symbol.
 117      */
 118     public Type type;
 119 
 120     /** The owner of this symbol.
 121      */
 122     public Symbol owner;
 123 
 124     /** The completer of this symbol.
 125      * This should never equal null (NULL_COMPLETER should be used instead).
 126      */
 127     public Completer completer;
 128 
 129     /** A cache for the type erasure of this symbol.
 130      */
 131     public Type erasure_field;
 132 
 133     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;annotations&quot;&gt;
 134 
 135     /** The attributes of this symbol are contained in this
 136      * SymbolMetadata. The SymbolMetadata instance is NOT immutable.
 137      */
 138     protected SymbolMetadata metadata;
 139 
 140 
 141     /** An accessor method for the attributes of this symbol.
 142      *  Attributes of class symbols should be accessed through the accessor
 143      *  method to make sure that the class symbol is loaded.
 144      */
 145     public List&lt;Attribute.Compound&gt; getRawAttributes() {
 146         return (metadata == null)
 147                 ? List.nil()
 148                 : metadata.getDeclarationAttributes();
 149     }
 150 
 151     /** An accessor method for the type attributes of this symbol.
 152      *  Attributes of class symbols should be accessed through the accessor
 153      *  method to make sure that the class symbol is loaded.
 154      */
 155     public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
 156         return (metadata == null)
 157                 ? List.nil()
 158                 : metadata.getTypeAttributes();
 159     }
 160 
 161     /** Fetch a particular annotation from a symbol. */
 162     public Attribute.Compound attribute(Symbol anno) {
 163         for (Attribute.Compound a : getRawAttributes()) {
 164             if (a.type.tsym == anno) return a;
 165         }
 166         return null;
 167     }
 168 
 169     public boolean annotationsPendingCompletion() {
 170         return metadata == null ? false : metadata.pendingCompletion();
 171     }
 172 
 173     public void appendAttributes(List&lt;Attribute.Compound&gt; l) {
 174         if (l.nonEmpty()) {
 175             initedMetadata().append(l);
 176         }
 177     }
 178 
 179     public void appendClassInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 180         if (l.nonEmpty()) {
 181             initedMetadata().appendClassInitTypeAttributes(l);
 182         }
 183     }
 184 
 185     public void appendInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 186         if (l.nonEmpty()) {
 187             initedMetadata().appendInitTypeAttributes(l);
 188         }
 189     }
 190 
 191     public void appendUniqueTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 192         if (l.nonEmpty()) {
 193             initedMetadata().appendUniqueTypes(l);
 194         }
 195     }
 196 
 197     public List&lt;Attribute.TypeCompound&gt; getClassInitTypeAttributes() {
 198         return (metadata == null)
 199                 ? List.nil()
 200                 : metadata.getClassInitTypeAttributes();
 201     }
 202 
 203     public List&lt;Attribute.TypeCompound&gt; getInitTypeAttributes() {
 204         return (metadata == null)
 205                 ? List.nil()
 206                 : metadata.getInitTypeAttributes();
 207     }
 208 
 209     public void setInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 210         initedMetadata().setInitTypeAttributes(l);
 211     }
 212 
 213     public void setClassInitTypeAttributes(List&lt;Attribute.TypeCompound&gt; l) {
 214         initedMetadata().setClassInitTypeAttributes(l);
 215     }
 216 
 217     public List&lt;Attribute.Compound&gt; getDeclarationAttributes() {
 218         return (metadata == null)
 219                 ? List.nil()
 220                 : metadata.getDeclarationAttributes();
 221     }
 222 
 223     public boolean hasAnnotations() {
 224         return (metadata != null &amp;&amp; !metadata.isEmpty());
 225     }
 226 
 227     public boolean hasTypeAnnotations() {
 228         return (metadata != null &amp;&amp; !metadata.isTypesEmpty());
 229     }
 230 
 231     public boolean isCompleted() {
 232         return completer.isTerminal();
 233     }
 234 
 235     public void prependAttributes(List&lt;Attribute.Compound&gt; l) {
 236         if (l.nonEmpty()) {
 237             initedMetadata().prepend(l);
 238         }
 239     }
 240 
 241     public void resetAnnotations() {
 242         initedMetadata().reset();
 243     }
 244 
 245     public void setAttributes(Symbol other) {
 246         if (metadata != null || other.metadata != null) {
 247             initedMetadata().setAttributes(other.metadata);
 248         }
 249     }
 250 
 251     public void setDeclarationAttributes(List&lt;Attribute.Compound&gt; a) {
 252         if (metadata != null || a.nonEmpty()) {
 253             initedMetadata().setDeclarationAttributes(a);
 254         }
 255     }
 256 
 257     public void setTypeAttributes(List&lt;Attribute.TypeCompound&gt; a) {
 258         if (metadata != null || a.nonEmpty()) {
 259             if (metadata == null)
 260                 metadata = new SymbolMetadata(this);
 261             metadata.setTypeAttributes(a);
 262         }
 263     }
 264 
 265     private SymbolMetadata initedMetadata() {
 266         if (metadata == null)
 267             metadata = new SymbolMetadata(this);
 268         return metadata;
 269     }
 270 
 271     /** This method is intended for debugging only. */
 272     public SymbolMetadata getMetadata() {
 273         return metadata;
 274     }
 275 
 276     // &lt;/editor-fold&gt;
 277 
 278     /** Construct a symbol with given kind, flags, name, type and owner.
 279      */
 280     public Symbol(Kind kind, long flags, Name name, Type type, Symbol owner) {
 281         this.kind = kind;
 282         this.flags_field = flags;
 283         this.type = type;
 284         this.owner = owner;
 285         this.completer = Completer.NULL_COMPLETER;
 286         this.erasure_field = null;
 287         this.name = name;
 288     }
 289 
 290     @Override
 291     public int poolTag() {
 292         throw new AssertionError(&quot;Invalid pool entry&quot;);
 293     }
 294 
 295     /** Clone this symbol with new owner.
 296      *  Legal only for fields and methods.
 297      */
 298     public Symbol clone(Symbol newOwner) {
 299         throw new AssertionError();
 300     }
 301 
 302     public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 303         return v.visitSymbol(this, p);
 304     }
 305 
 306     /** The Java source which this symbol represents.
 307      *  A description of this symbol; overrides Object.
 308      */
 309     public String toString() {
 310         return name.toString();
 311     }
 312 
 313     /** A Java source description of the location of this symbol; used for
 314      *  error reporting.
 315      *
 316      * @return null if the symbol is a package or a toplevel class defined in
 317      * the default package; otherwise, the owner symbol is returned
 318      */
 319     public Symbol location() {
 320         if (owner.name == null || (owner.name.isEmpty() &amp;&amp;
 321                                    (owner.flags() &amp; BLOCK) == 0 &amp;&amp;
 322                                    owner.kind != PCK &amp;&amp;
 323                                    owner.kind != TYP)) {
 324             return null;
 325         }
 326         return owner;
 327     }
 328 
 329     public Symbol location(Type site, Types types) {
 330         if (owner.name == null || owner.name.isEmpty()) {
 331             return location();
 332         }
 333         if (owner.type.hasTag(CLASS)) {
 334             Type ownertype = types.asOuterSuper(site, owner);
 335             if (ownertype != null) return ownertype.tsym;
 336         }
 337         return owner;
 338     }
 339 
 340     public Symbol baseSymbol() {
 341         return this;
 342     }
 343 
 344     /** The symbol&#39;s erased type.
 345      */
 346     public Type erasure(Types types) {
 347         if (erasure_field == null)
 348             erasure_field = types.erasure(type);
 349         return erasure_field;
 350     }
 351 
 352     /** The external type of a symbol. This is the symbol&#39;s erased type
 353      *  except for constructors of inner classes which get the enclosing
 354      *  instance class added as first argument.
 355      */
 356     public Type externalType(Types types) {
 357         Type t = erasure(types);
 358         if (name == name.table.names.init &amp;&amp; owner.hasOuterInstance()) {
 359             Type outerThisType = types.erasure(owner.type.getEnclosingType());
 360             return new MethodType(t.getParameterTypes().prepend(outerThisType),
 361                                   t.getReturnType(),
 362                                   t.getThrownTypes(),
 363                                   t.tsym);
 364         } else {
 365             return t;
 366         }
 367     }
 368 
 369     public boolean isDeprecated() {
 370         return (flags_field &amp; DEPRECATED) != 0;
 371     }
 372 
 373     public boolean hasDeprecatedAnnotation() {
 374         return (flags_field &amp; DEPRECATED_ANNOTATION) != 0;
 375     }
 376 
 377     public boolean isDeprecatedForRemoval() {
 378         return (flags_field &amp; DEPRECATED_REMOVAL) != 0;
 379     }
 380 
 381     public boolean isPreviewApi() {
 382         return (flags_field &amp; PREVIEW_API) != 0;
 383     }
 384 
 385     public boolean isDeprecatableViaAnnotation() {
 386         switch (getKind()) {
 387             case LOCAL_VARIABLE:
 388             case PACKAGE:
 389             case PARAMETER:
 390             case RESOURCE_VARIABLE:
 391             case EXCEPTION_PARAMETER:
 392                 return false;
 393             default:
 394                 return true;
 395         }
 396     }
 397 
 398     public boolean isStatic() {
 399         return
 400             (flags() &amp; STATIC) != 0 ||
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
<a name="1" id="anc1"></a><span class="line-added"> 417     public boolean isValue() {</span>
<span class="line-added"> 418         return (flags() &amp; VALUE) != 0;</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420 </span>
<span class="line-added"> 421     /**</span>
<span class="line-added"> 422      * Is this a *derived* reference projection symbol ??</span>
<span class="line-added"> 423      */</span>
<span class="line-added"> 424     public boolean isReferenceProjection() {</span>
<span class="line-added"> 425         return false;</span>
<span class="line-added"> 426     }</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428     /**</span>
<span class="line-added"> 429      * Return the value projection IFF &#39;this&#39; happens to be derived reference projection, null</span>
<span class="line-added"> 430      * otherwise.</span>
<span class="line-added"> 431      */</span>
<span class="line-added"> 432     public Symbol valueProjection() {</span>
<span class="line-added"> 433         return null;</span>
<span class="line-added"> 434     }</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436     /**</span>
<span class="line-added"> 437      * Return the reference projection IFF &#39;this&#39; happens to be value projection, null</span>
<span class="line-added"> 438      * otherwise.</span>
<span class="line-added"> 439      */</span>
<span class="line-added"> 440     public Symbol referenceProjection() {</span>
<span class="line-added"> 441         return null;</span>
<span class="line-added"> 442     }</span>
<span class="line-added"> 443 </span>
 444     public boolean isPublic() {
 445         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 446     }
 447 
 448     public boolean isEnum() {
 449         return (flags() &amp; ENUM) != 0;
 450     }
 451 
 452     public boolean isFinal() {
 453         return (flags_field &amp; FINAL) != 0;
 454     }
 455 
 456    /** Is this symbol declared (directly or indirectly) local
 457      *  to a method or variable initializer?
 458      *  Also includes fields of inner classes which are in
 459      *  turn local to a method or variable initializer.
 460      */
 461     public boolean isLocal() {
 462         return
 463             (owner.kind.matches(KindSelector.VAL_MTH) ||
 464              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 465     }
 466 
 467     /** Has this symbol an empty name? This includes anonymous
 468      *  inner classes.
 469      */
 470     public boolean isAnonymous() {
 471         return name.isEmpty();
 472     }
 473 
 474     /** Is this symbol a constructor?
 475      */
 476     public boolean isConstructor() {
<a name="2" id="anc2"></a><span class="line-modified"> 477         return name == name.table.names.init &amp;&amp; (flags() &amp; STATIC) == 0;</span>
<span class="line-added"> 478     }</span>
<span class="line-added"> 479 </span>
<span class="line-added"> 480     /** Is this symbol a value factory?</span>
<span class="line-added"> 481      */</span>
<span class="line-added"> 482     public boolean isValueFactory() {</span>
<span class="line-added"> 483         return ((name == name.table.names.init &amp;&amp; this.type.getReturnType().tsym == this.owner));</span>
 484     }
 485 
 486     public boolean isDynamic() {
 487         return false;
 488     }
 489 
 490     /** The fully qualified name of this symbol.
 491      *  This is the same as the symbol&#39;s name except for class symbols,
 492      *  which are handled separately.
 493      */
 494     public Name getQualifiedName() {
 495         return name;
 496     }
 497 
 498     /** The fully qualified name of this symbol after converting to flat
 499      *  representation. This is the same as the symbol&#39;s name except for
 500      *  class symbols, which are handled separately.
 501      */
 502     public Name flatName() {
 503         return getQualifiedName();
 504     }
 505 
 506     /** If this is a class or package, its members, otherwise null.
 507      */
 508     public WriteableScope members() {
 509         return null;
 510     }
 511 
 512     /** A class is an inner class if it it has an enclosing instance class.
 513      */
 514     public boolean isInner() {
 515         return kind == TYP &amp;&amp; type.getEnclosingType().hasTag(CLASS);
 516     }
 517 
 518     /** An inner class has an outer instance if it is not an interface
 519      *  it has an enclosing instance class which might be referenced from the class.
 520      *  Nested classes can see instance members of their enclosing class.
 521      *  Their constructors carry an additional this$n parameter, inserted
 522      *  implicitly by the compiler.
 523      *
 524      *  @see #isInner
 525      */
 526     public boolean hasOuterInstance() {
 527         return
 528             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 529     }
 530 
 531     /** The closest enclosing class of this symbol&#39;s declaration.
 532      *  Warning: this (misnamed) method returns the receiver itself
 533      *  when the receiver is a class (as opposed to its enclosing
 534      *  class as one may be misled to believe.)
 535      */
 536     public ClassSymbol enclClass() {
 537         Symbol c = this;
 538         while (c != null &amp;&amp;
 539                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 540             c = c.owner;
 541         }
 542         return (ClassSymbol)c;
 543     }
 544 
 545     /** The outermost class which indirectly owns this symbol.
<a name="3" id="anc3"></a><span class="line-added"> 546      * &#39;outermost&#39; being a lexical construct, should transcend</span>
<span class="line-added"> 547      *  projections</span>
 548      */
 549     public ClassSymbol outermostClass() {
 550         Symbol sym = this;
 551         Symbol prev = null;
 552         while (sym.kind != PCK) {
 553             prev = sym;
 554             sym = sym.owner;
 555         }
<a name="4" id="anc4"></a><span class="line-modified"> 556         return (ClassSymbol) (prev!= null &amp;&amp; prev.isReferenceProjection() ? prev.valueProjection() : prev);</span>
 557     }
 558 
 559     /** The package which indirectly owns this symbol.
 560      */
 561     public PackageSymbol packge() {
 562         Symbol sym = this;
 563         while (sym.kind != PCK) {
 564             sym = sym.owner;
 565         }
 566         return (PackageSymbol) sym;
 567     }
 568 
 569     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 570      */
 571     public boolean isSubClass(Symbol base, Types types) {
 572         throw new AssertionError(&quot;isSubClass &quot; + this);
 573     }
 574 
 575     /** Fully check membership: hierarchy, protection, and hiding.
 576      *  Does not exclude methods not inherited due to overriding.
 577      */
 578     public boolean isMemberOf(TypeSymbol clazz, Types types) {
 579         return
 580             owner == clazz ||
 581             clazz.isSubClass(owner, types) &amp;&amp;
 582             isInheritedIn(clazz, types) &amp;&amp;
 583             !hiddenIn((ClassSymbol)clazz, types);
 584     }
 585 
 586     /** Is this symbol the same as or enclosed by the given class? */
 587     public boolean isEnclosedBy(ClassSymbol clazz) {
 588         for (Symbol sym = this; sym.kind != PCK; sym = sym.owner)
 589             if (sym == clazz) return true;
 590         return false;
 591     }
 592 
 593     private boolean hiddenIn(ClassSymbol clazz, Types types) {
 594         Symbol sym = hiddenInInternal(clazz, types);
 595         Assert.check(sym != null, &quot;the result of hiddenInInternal() can&#39;t be null&quot;);
 596         /* If we find the current symbol then there is no symbol hiding it
 597          */
 598         return sym != this;
 599     }
 600 
 601     /** This method looks in the supertypes graph that has the current class as the
 602      * initial node, till it finds the current symbol or another symbol that hides it.
 603      * If the current class has more than one supertype (extends one class and
 604      * implements one or more interfaces) then null can be returned, meaning that
 605      * a wrong path in the supertypes graph was selected. Null can only be returned
 606      * as a temporary value, as a result of the recursive call.
 607      */
 608     private Symbol hiddenInInternal(ClassSymbol currentClass, Types types) {
 609         if (currentClass == owner) {
 610             return this;
 611         }
 612         for (Symbol sym : currentClass.members().getSymbolsByName(name)) {
 613             if (sym.kind == kind &amp;&amp;
 614                     (kind != MTH ||
 615                     (sym.flags() &amp; STATIC) != 0 &amp;&amp;
 616                     types.isSubSignature(sym.type, type))) {
 617                 return sym;
 618             }
 619         }
 620         Symbol hiddenSym = null;
 621         for (Type st : types.interfaces(currentClass.type)
 622                 .prepend(types.supertype(currentClass.type))) {
 623             if (st != null &amp;&amp; (st.hasTag(CLASS))) {
 624                 Symbol sym = hiddenInInternal((ClassSymbol)st.tsym, types);
 625                 if (sym == this) {
 626                     return this;
 627                 } else if (sym != null) {
 628                     hiddenSym = sym;
 629                 }
 630             }
 631         }
 632         return hiddenSym;
 633     }
 634 
 635     /** Is this symbol accessible in a given class?
 636      *  PRE: If symbol&#39;s owner is a interface,
 637      *       it is already assumed that the interface is a superinterface
 638      *       the given class.
 639      *  @param clazz  The class for which we want to establish membership.
 640      *                This must be a subclass of the member&#39;s owner.
 641      */
 642     public final boolean isAccessibleIn(Symbol clazz, Types types) {
 643         switch ((int)(flags_field &amp; Flags.AccessFlags)) {
 644         default: // error recovery
 645         case PUBLIC:
 646             return true;
 647         case PRIVATE:
 648             return this.owner == clazz;
 649         case PROTECTED:
 650             // we model interfaces as extending Object
 651             return (clazz.flags() &amp; INTERFACE) == 0;
 652         case 0:
 653             PackageSymbol thisPackage = this.packge();
 654             for (Symbol sup = clazz;
 655                  sup != null &amp;&amp; sup != this.owner;
 656                  sup = types.supertype(sup.type).tsym) {
 657                 while (sup.type.hasTag(TYPEVAR))
 658                     sup = sup.type.getUpperBound().tsym;
 659                 if (sup.type.isErroneous())
 660                     return true; // error recovery
 661                 if ((sup.flags() &amp; COMPOUND) != 0)
 662                     continue;
 663                 if (sup.packge() != thisPackage)
 664                     return false;
 665             }
 666             return (clazz.flags() &amp; INTERFACE) == 0;
 667         }
 668     }
 669 
 670     /** Is this symbol inherited into a given class?
 671      *  PRE: If symbol&#39;s owner is a interface,
 672      *       it is already assumed that the interface is a superinterface
 673      *       of the given class.
 674      *  @param clazz  The class for which we want to establish membership.
 675      *                This must be a subclass of the member&#39;s owner.
 676      */
 677     public boolean isInheritedIn(Symbol clazz, Types types) {
 678         return isAccessibleIn(clazz, types);
 679     }
 680 
 681     /** The (variable or method) symbol seen as a member of given
 682      *  class type`site&#39; (this might change the symbol&#39;s type).
 683      *  This is used exclusively for producing diagnostics.
 684      */
 685     public Symbol asMemberOf(Type site, Types types) {
 686         throw new AssertionError();
 687     }
 688 
 689     /** Does this method symbol override `other&#39; symbol, when both are seen as
 690      *  members of class `origin&#39;?  It is assumed that _other is a member
 691      *  of origin.
 692      *
 693      *  It is assumed that both symbols have the same name.  The static
 694      *  modifier is ignored for this test.
 695      *
 696      *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
 697      */
 698     public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult) {
 699         return false;
 700     }
 701 
 702     /** Complete the elaboration of this symbol&#39;s definition.
 703      */
 704     public void complete() throws CompletionFailure {
 705         if (completer != Completer.NULL_COMPLETER) {
 706             Completer c = completer;
 707             completer = Completer.NULL_COMPLETER;
 708             c.complete(this);
 709         }
 710     }
 711 
 712     public void apiComplete() throws CompletionFailure {
 713         try {
 714             complete();
 715         } catch (CompletionFailure cf) {
 716             cf.dcfh.handleAPICompletionFailure(cf);
 717         }
 718     }
 719 
 720     /** True if the symbol represents an entity that exists.
 721      */
 722     public boolean exists() {
 723         return true;
 724     }
 725 
 726     @DefinedBy(Api.LANGUAGE_MODEL)
 727     public Type asType() {
 728         return type;
 729     }
 730 
 731     @DefinedBy(Api.LANGUAGE_MODEL)
 732     public Symbol getEnclosingElement() {
 733         return owner;
 734     }
 735 
 736     @DefinedBy(Api.LANGUAGE_MODEL)
 737     public ElementKind getKind() {
 738         return ElementKind.OTHER;       // most unkind
 739     }
 740 
 741     @DefinedBy(Api.LANGUAGE_MODEL)
 742     public Set&lt;Modifier&gt; getModifiers() {
 743         apiComplete();
 744         return Flags.asModifierSet(flags());
 745     }
 746 
 747     @DefinedBy(Api.LANGUAGE_MODEL)
 748     public Name getSimpleName() {
 749         return name;
 750     }
 751 
 752     /**
 753      * This is the implementation for {@code
 754      * javax.lang.model.element.Element.getAnnotationMirrors()}.
 755      */
 756     @Override @DefinedBy(Api.LANGUAGE_MODEL)
 757     public List&lt;Attribute.Compound&gt; getAnnotationMirrors() {
 758         apiComplete();
 759         return getRawAttributes();
 760     }
 761 
 762 
 763     // TODO: getEnclosedElements should return a javac List, fix in FilteredMemberList
 764     @DefinedBy(Api.LANGUAGE_MODEL)
 765     public java.util.List&lt;Symbol&gt; getEnclosedElements() {
 766         return List.nil();
 767     }
 768 
 769     public List&lt;TypeVariableSymbol&gt; getTypeParameters() {
 770         ListBuffer&lt;TypeVariableSymbol&gt; l = new ListBuffer&lt;&gt;();
 771         for (Type t : type.getTypeArguments()) {
 772             Assert.check(t.tsym.getKind() == ElementKind.TYPE_PARAMETER);
 773             l.append((TypeVariableSymbol)t.tsym);
 774         }
 775         return l.toList();
 776     }
 777 
 778     public static class DelegatedSymbol&lt;T extends Symbol&gt; extends Symbol {
 779         protected T other;
 780         public DelegatedSymbol(T other) {
 781             super(other.kind, other.flags_field, other.name, other.type, other.owner);
 782             this.other = other;
 783         }
 784         public String toString() { return other.toString(); }
 785         public Symbol location() { return other.location(); }
 786         public Symbol location(Type site, Types types) { return other.location(site, types); }
 787         public Symbol baseSymbol() { return other; }
 788         public Type erasure(Types types) { return other.erasure(types); }
 789         public Type externalType(Types types) { return other.externalType(types); }
 790         public boolean isLocal() { return other.isLocal(); }
 791         public boolean isConstructor() { return other.isConstructor(); }
 792         public Name getQualifiedName() { return other.getQualifiedName(); }
 793         public Name flatName() { return other.flatName(); }
 794         public WriteableScope members() { return other.members(); }
 795         public boolean isInner() { return other.isInner(); }
 796         public boolean hasOuterInstance() { return other.hasOuterInstance(); }
 797         public ClassSymbol enclClass() { return other.enclClass(); }
 798         public ClassSymbol outermostClass() { return other.outermostClass(); }
 799         public PackageSymbol packge() { return other.packge(); }
 800         public boolean isSubClass(Symbol base, Types types) { return other.isSubClass(base, types); }
 801         public boolean isMemberOf(TypeSymbol clazz, Types types) { return other.isMemberOf(clazz, types); }
 802         public boolean isEnclosedBy(ClassSymbol clazz) { return other.isEnclosedBy(clazz); }
 803         public boolean isInheritedIn(Symbol clazz, Types types) { return other.isInheritedIn(clazz, types); }
 804         public Symbol asMemberOf(Type site, Types types) { return other.asMemberOf(site, types); }
 805         public void complete() throws CompletionFailure { other.complete(); }
 806 
 807         @DefinedBy(Api.LANGUAGE_MODEL)
 808         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 809             return other.accept(v, p);
 810         }
 811 
 812         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 813             return v.visitSymbol(other, p);
 814         }
 815 
 816         public T getUnderlyingSymbol() {
 817             return other;
 818         }
 819     }
 820 
 821     /** A base class for Symbols representing types.
 822      */
 823     public static abstract class TypeSymbol extends Symbol {
 824         public TypeSymbol(Kind kind, long flags, Name name, Type type, Symbol owner) {
 825             super(kind, flags, name, type, owner);
 826         }
 827         /** form a fully qualified name from a name and an owner
 828          */
 829         static public Name formFullName(Name name, Symbol owner) {
 830             if (owner == null) return name;
 831             if ((owner.kind != ERR) &amp;&amp;
 832                 (owner.kind.matches(KindSelector.VAL_MTH) ||
 833                  (owner.kind == TYP &amp;&amp; owner.type.hasTag(TYPEVAR))
 834                  )) return name;
 835             Name prefix = owner.getQualifiedName();
 836             if (prefix == null || prefix == prefix.table.names.empty)
 837                 return name;
 838             else return prefix.append(&#39;.&#39;, name);
 839         }
 840 
 841         /** form a fully qualified name from a name and an owner, after
 842          *  converting to flat representation
 843          */
 844         static public Name formFlatName(Name name, Symbol owner) {
 845             if (owner == null || owner.kind.matches(KindSelector.VAL_MTH) ||
 846                 (owner.kind == TYP &amp;&amp; owner.type.hasTag(TYPEVAR))
 847                 ) return name;
 848             char sep = owner.kind == TYP ? &#39;$&#39; : &#39;.&#39;;
 849             Name prefix = owner.flatName();
 850             if (prefix == null || prefix == prefix.table.names.empty)
 851                 return name;
 852             else return prefix.append(sep, name);
 853         }
 854 
 855         /**
 856          * A partial ordering between type symbols that refines the
 857          * class inheritance graph.
 858          *
 859          * Type variables always precede other kinds of symbols.
 860          */
 861         public final boolean precedes(TypeSymbol that, Types types) {
 862             if (this == that)
 863                 return false;
 864             if (type.hasTag(that.type.getTag())) {
 865                 if (type.hasTag(CLASS)) {
 866                     return
 867                         types.rank(that.type) &lt; types.rank(this.type) ||
 868                         types.rank(that.type) == types.rank(this.type) &amp;&amp;
 869                         that.getQualifiedName().compareTo(this.getQualifiedName()) &lt; 0;
 870                 } else if (type.hasTag(TYPEVAR)) {
 871                     return types.isSubtype(this.type, that.type);
 872                 }
 873             }
 874             return type.hasTag(TYPEVAR);
 875         }
 876 
 877         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 878         public List&lt;Symbol&gt; getEnclosedElements() {
 879             List&lt;Symbol&gt; list = List.nil();
 880             if (kind == TYP &amp;&amp; type.hasTag(TYPEVAR)) {
 881                 return list;
 882             }
 883             apiComplete();
 884             for (Symbol sym : members().getSymbols(NON_RECURSIVE)) {
 885                 sym.apiComplete();
 886                 if ((sym.flags() &amp; SYNTHETIC) == 0 &amp;&amp; sym.owner == this &amp;&amp; sym.kind != ERR) {
 887                     list = list.prepend(sym);
 888                 }
 889             }
 890             return list;
 891         }
 892 
 893         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
 894             Assert.error(&quot;Only on ClassSymbol&quot;);
 895             return null; //unreachable
 896         }
 897 
 898         public boolean isAnnotationType() { return false; }
 899 
 900         @Override
 901         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
 902             return v.visitTypeSymbol(this, p);
 903         }
 904     }
 905 
 906     /**
 907      * Type variables are represented by instances of this class.
 908      */
 909     public static class TypeVariableSymbol
 910             extends TypeSymbol implements TypeParameterElement {
 911 
 912         public TypeVariableSymbol(long flags, Name name, Type type, Symbol owner) {
 913             super(TYP, flags, name, type, owner);
 914         }
 915 
 916         @DefinedBy(Api.LANGUAGE_MODEL)
 917         public ElementKind getKind() {
 918             return ElementKind.TYPE_PARAMETER;
 919         }
 920 
 921         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 922         public Symbol getGenericElement() {
 923             return owner;
 924         }
 925 
 926         @DefinedBy(Api.LANGUAGE_MODEL)
 927         public List&lt;Type&gt; getBounds() {
 928             TypeVar t = (TypeVar)type;
 929             Type bound = t.getUpperBound();
 930             if (!bound.isCompound())
 931                 return List.of(bound);
 932             ClassType ct = (ClassType)bound;
 933             if (!ct.tsym.erasure_field.isInterface()) {
 934                 return ct.interfaces_field.prepend(ct.supertype_field);
 935             } else {
 936                 // No superclass was given in bounds.
 937                 // In this case, supertype is Object, erasure is first interface.
 938                 return ct.interfaces_field;
 939             }
 940         }
 941 
 942         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 943         public List&lt;Attribute.Compound&gt; getAnnotationMirrors() {
 944             // Declaration annotations on type variables are stored in type attributes
 945             // on the owner of the TypeVariableSymbol
 946             List&lt;Attribute.TypeCompound&gt; candidates = owner.getRawTypeAttributes();
 947             int index = owner.getTypeParameters().indexOf(this);
 948             List&lt;Attribute.Compound&gt; res = List.nil();
 949             for (Attribute.TypeCompound a : candidates) {
 950                 if (isCurrentSymbolsAnnotation(a, index))
 951                     res = res.prepend(a);
 952             }
 953 
 954             return res.reverse();
 955         }
 956 
 957         // Helper to getAnnotation[s]
 958         @Override
 959         public &lt;A extends Annotation&gt; Attribute.Compound getAttribute(Class&lt;A&gt; annoType) {
 960             String name = annoType.getName();
 961 
 962             // Declaration annotations on type variables are stored in type attributes
 963             // on the owner of the TypeVariableSymbol
 964             List&lt;Attribute.TypeCompound&gt; candidates = owner.getRawTypeAttributes();
 965             int index = owner.getTypeParameters().indexOf(this);
 966             for (Attribute.TypeCompound anno : candidates)
 967                 if (isCurrentSymbolsAnnotation(anno, index) &amp;&amp;
 968                     name.contentEquals(anno.type.tsym.flatName()))
 969                     return anno;
 970 
 971             return null;
 972         }
 973             //where:
 974             boolean isCurrentSymbolsAnnotation(Attribute.TypeCompound anno, int index) {
 975                 return (anno.position.type == TargetType.CLASS_TYPE_PARAMETER ||
 976                         anno.position.type == TargetType.METHOD_TYPE_PARAMETER) &amp;&amp;
 977                         anno.position.parameter_index == index;
 978             }
 979 
 980 
 981         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 982         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 983             return v.visitTypeParameter(this, p);
 984         }
 985     }
 986     /** A class for module symbols.
 987      */
 988     public static class ModuleSymbol extends TypeSymbol
 989             implements ModuleElement {
 990 
 991         public Name version;
 992         public JavaFileManager.Location sourceLocation;
 993         public JavaFileManager.Location classLocation;
 994         public JavaFileManager.Location patchLocation;
 995         public JavaFileManager.Location patchOutputLocation;
 996 
 997         /** All directives, in natural order. */
 998         public List&lt;com.sun.tools.javac.code.Directive&gt; directives;
 999         public List&lt;com.sun.tools.javac.code.Directive.RequiresDirective&gt; requires;
1000         public List&lt;com.sun.tools.javac.code.Directive.ExportsDirective&gt; exports;
1001         public List&lt;com.sun.tools.javac.code.Directive.OpensDirective&gt; opens;
1002         public List&lt;com.sun.tools.javac.code.Directive.ProvidesDirective&gt; provides;
1003         public List&lt;com.sun.tools.javac.code.Directive.UsesDirective&gt; uses;
1004 
1005         public ClassSymbol module_info;
1006 
1007         public PackageSymbol unnamedPackage;
1008         public Map&lt;Name, PackageSymbol&gt; visiblePackages;
1009         public Set&lt;ModuleSymbol&gt; readModules;
1010         public List&lt;Symbol&gt; enclosedPackages = List.nil();
1011 
1012         public Completer usesProvidesCompleter = Completer.NULL_COMPLETER;
1013         public final Set&lt;ModuleFlags&gt; flags = EnumSet.noneOf(ModuleFlags.class);
1014         public final Set&lt;ModuleResolutionFlags&gt; resolutionFlags = EnumSet.noneOf(ModuleResolutionFlags.class);
1015 
1016         /**
1017          * Create a ModuleSymbol with an associated module-info ClassSymbol.
1018          */
1019         public static ModuleSymbol create(Name name, Name module_info) {
1020             ModuleSymbol msym = new ModuleSymbol(name, null);
1021             ClassSymbol info = new ClassSymbol(Flags.MODULE, module_info, msym);
1022             info.fullname = formFullName(module_info, msym);
1023             info.flatname = info.fullname;
1024             info.members_field = WriteableScope.create(info);
1025             msym.module_info = info;
1026             return msym;
1027         }
1028 
1029         public ModuleSymbol(Name name, Symbol owner) {
1030             super(MDL, 0, name, null, owner);
1031             Assert.checkNonNull(name);
1032             this.type = new ModuleType(this);
1033         }
1034 
1035         @Override
1036         public int poolTag() {
1037             return ClassFile.CONSTANT_Module;
1038         }
1039 
1040         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1041         public Name getSimpleName() {
1042             return Convert.shortName(name);
1043         }
1044 
1045         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1046         public boolean isOpen() {
1047             return flags.contains(ModuleFlags.OPEN);
1048         }
1049 
1050         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1051         public boolean isUnnamed() {
1052             return name.isEmpty() &amp;&amp; owner == null;
1053         }
1054 
1055         @Override
1056         public boolean isDeprecated() {
1057             return hasDeprecatedAnnotation();
1058         }
1059 
1060         public boolean isNoModule() {
1061             return false;
1062         }
1063 
1064         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1065         public ElementKind getKind() {
1066             return ElementKind.MODULE;
1067         }
1068 
1069         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1070         public java.util.List&lt;Directive&gt; getDirectives() {
1071             apiComplete();
1072             completeUsesProvides();
1073             return Collections.unmodifiableList(directives);
1074         }
1075 
1076         public void completeUsesProvides() {
1077             if (usesProvidesCompleter != Completer.NULL_COMPLETER) {
1078                 Completer c = usesProvidesCompleter;
1079                 usesProvidesCompleter = Completer.NULL_COMPLETER;
1080                 c.complete(this);
1081             }
1082         }
1083 
1084         @Override
1085         public ClassSymbol outermostClass() {
1086             return null;
1087         }
1088 
1089         @Override
1090         public String toString() {
1091             // TODO: the following strings should be localized
1092             // Do this with custom anon subtypes in Symtab
1093             String n = (name == null) ? &quot;&lt;unknown&gt;&quot;
1094                     : (name.isEmpty()) ? &quot;&lt;unnamed&gt;&quot;
1095                     : String.valueOf(name);
1096             return n;
1097         }
1098 
1099         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1100         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1101             return v.visitModule(this, p);
1102         }
1103 
1104         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1105         public List&lt;Symbol&gt; getEnclosedElements() {
1106             List&lt;Symbol&gt; list = List.nil();
1107             for (Symbol sym : enclosedPackages) {
1108                 if (sym.members().anyMatch(m -&gt; m.kind == TYP))
1109                     list = list.prepend(sym);
1110             }
1111             return list;
1112         }
1113 
1114         public void reset() {
1115             this.directives = null;
1116             this.requires = null;
1117             this.exports = null;
1118             this.provides = null;
1119             this.uses = null;
1120             this.visiblePackages = null;
1121         }
1122 
1123     }
1124 
1125     public enum ModuleFlags {
1126         OPEN(0x0020),
1127         SYNTHETIC(0x1000),
1128         MANDATED(0x8000);
1129 
1130         public static int value(Set&lt;ModuleFlags&gt; s) {
1131             int v = 0;
1132             for (ModuleFlags f: s)
1133                 v |= f.value;
1134             return v;
1135         }
1136 
1137         private ModuleFlags(int value) {
1138             this.value = value;
1139         }
1140 
1141         public final int value;
1142     }
1143 
1144     public enum ModuleResolutionFlags {
1145         DO_NOT_RESOLVE_BY_DEFAULT(0x0001),
1146         WARN_DEPRECATED(0x0002),
1147         WARN_DEPRECATED_REMOVAL(0x0004),
1148         WARN_INCUBATING(0x0008);
1149 
1150         public static int value(Set&lt;ModuleResolutionFlags&gt; s) {
1151             int v = 0;
1152             for (ModuleResolutionFlags f: s)
1153                 v |= f.value;
1154             return v;
1155         }
1156 
1157         private ModuleResolutionFlags(int value) {
1158             this.value = value;
1159         }
1160 
1161         public final int value;
1162     }
1163 
1164     /** A class for package symbols
1165      */
1166     public static class PackageSymbol extends TypeSymbol
1167         implements PackageElement {
1168 
1169         public WriteableScope members_field;
1170         public Name fullname;
1171         public ClassSymbol package_info; // see bug 6443073
1172         public ModuleSymbol modle;
1173         // the file containing the documentation comments for the package
1174         public JavaFileObject sourcefile;
1175 
1176         public PackageSymbol(Name name, Type type, Symbol owner) {
1177             super(PCK, 0, name, type, owner);
1178             this.members_field = null;
1179             this.fullname = formFullName(name, owner);
1180         }
1181 
1182         public PackageSymbol(Name name, Symbol owner) {
1183             this(name, null, owner);
1184             this.type = new PackageType(this);
1185         }
1186 
1187         public String toString() {
1188             return fullname.toString();
1189         }
1190 
1191         @DefinedBy(Api.LANGUAGE_MODEL)
1192         public Name getQualifiedName() {
1193             return fullname;
1194         }
1195 
1196         @DefinedBy(Api.LANGUAGE_MODEL)
1197         public boolean isUnnamed() {
1198             return name.isEmpty() &amp;&amp; owner != null;
1199         }
1200 
1201         public WriteableScope members() {
1202             complete();
1203             return members_field;
1204         }
1205 
1206         @Override
1207         public int poolTag() {
1208             return ClassFile.CONSTANT_Package;
1209         }
1210 
1211         public long flags() {
1212             complete();
1213             return flags_field;
1214         }
1215 
1216         @Override
1217         public List&lt;Attribute.Compound&gt; getRawAttributes() {
1218             complete();
1219             if (package_info != null) {
1220                 package_info.complete();
1221                 mergeAttributes();
1222             }
1223             return super.getRawAttributes();
1224         }
1225 
1226         private void mergeAttributes() {
1227             if (metadata == null &amp;&amp;
1228                 package_info.metadata != null) {
1229                 metadata = new SymbolMetadata(this);
1230                 metadata.setAttributes(package_info.metadata);
1231             }
1232         }
1233 
1234         /** A package &quot;exists&quot; if a type or package that exists has
1235          *  been seen within it.
1236          */
1237         public boolean exists() {
1238             return (flags_field &amp; EXISTS) != 0;
1239         }
1240 
1241         @DefinedBy(Api.LANGUAGE_MODEL)
1242         public ElementKind getKind() {
1243             return ElementKind.PACKAGE;
1244         }
1245 
1246         @DefinedBy(Api.LANGUAGE_MODEL)
1247         public Symbol getEnclosingElement() {
1248             return modle != null &amp;&amp; !modle.isNoModule() ? modle : null;
1249         }
1250 
1251         @DefinedBy(Api.LANGUAGE_MODEL)
1252         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1253             return v.visitPackage(this, p);
1254         }
1255 
1256         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1257             return v.visitPackageSymbol(this, p);
1258         }
1259 
1260         /**Resets the Symbol into the state good for next round of annotation processing.*/
1261         public void reset() {
1262             metadata = null;
1263         }
1264 
1265     }
1266 
1267     public static class RootPackageSymbol extends PackageSymbol {
1268         public final MissingInfoHandler missingInfoHandler;
1269         public final boolean allowPrivateInvokeVirtual;
1270 
1271         public RootPackageSymbol(Name name, Symbol owner,
1272                                  MissingInfoHandler missingInfoHandler,
1273                                  boolean allowPrivateInvokeVirtual) {
1274             super(name, owner);
1275             this.missingInfoHandler = missingInfoHandler;
1276             this.allowPrivateInvokeVirtual = allowPrivateInvokeVirtual;
1277         }
1278 
1279     }
1280 
1281     /** A class for class symbols
1282      */
1283     public static class ClassSymbol extends TypeSymbol implements TypeElement {
1284 
1285         /** a scope for all class members; variables, methods and inner classes
1286          *  type parameters are not part of this scope
1287          */
1288         public WriteableScope members_field;
1289 
1290         /** the fully qualified name of the class, i.e. pck.outer.inner.
1291          *  null for anonymous classes
1292          */
1293         public Name fullname;
1294 
1295         /** the fully qualified name of the class after converting to flat
1296          *  representation, i.e. pck.outer$inner,
1297          *  set externally for local and anonymous classes
1298          */
1299         public Name flatname;
1300 
1301         /** the sourcefile where the class came from
1302          */
1303         public JavaFileObject sourcefile;
1304 
1305         /** the classfile from where to load this class
1306          *  this will have extension .class or .java
1307          */
1308         public JavaFileObject classfile;
1309 
1310         /** the list of translated local classes (used for generating
1311          * InnerClasses attribute)
1312          */
1313         public List&lt;ClassSymbol&gt; trans_local;
1314 
1315         /** the annotation metadata attached to this class */
1316         private AnnotationTypeMetadata annotationTypeMetadata;
1317 
1318         /* the list of any of record components, only non empty if the class is a record
1319          * and it has at least one record component
1320          */
1321         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1322 
<a name="5" id="anc5"></a><span class="line-added">1323         /* the &#39;other&#39; projection: If &#39;this&#39; is an inline class then &#39;projection&#39; is its reference projection</span>
<span class="line-added">1324            and vice versa.</span>
<span class="line-added">1325          */</span>
<span class="line-added">1326         public ClassSymbol projection;</span>
<span class="line-added">1327 </span>
<span class="line-added">1328 </span>
1329         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1330             super(TYP, flags, name, type, owner);
1331             this.members_field = null;
1332             this.fullname = formFullName(name, owner);
1333             this.flatname = formFlatName(name, owner);
1334             this.sourcefile = null;
1335             this.classfile = null;
1336             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1337         }
1338 
1339         public ClassSymbol(long flags, Name name, Symbol owner) {
1340             this(
1341                 flags,
1342                 name,
1343                 new ClassType(Type.noType, null, null),
1344                 owner);
1345             this.type.tsym = this;
1346         }
1347 
1348         /** The Java source which this symbol represents.
1349          */
1350         public String toString() {
1351             return className();
1352         }
1353 
1354         public long flags() {
1355             complete();
1356             return flags_field;
1357         }
1358 
1359         public WriteableScope members() {
1360             complete();
1361             return members_field;
1362         }
1363 
1364         @Override
1365         public List&lt;Attribute.Compound&gt; getRawAttributes() {
1366             complete();
1367             return super.getRawAttributes();
1368         }
1369 
1370         @Override
1371         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1372             complete();
1373             return super.getRawTypeAttributes();
1374         }
1375 
1376         public Type erasure(Types types) {
1377             if (erasure_field == null)
1378                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1379                                               List.nil(), this,
1380                                               type.getMetadata());
1381             return erasure_field;
1382         }
1383 
1384         public String className() {
1385             if (name.isEmpty())
1386                 return
1387                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
<a name="6" id="anc6"></a><span class="line-modified">1388 </span>
1389                 return fullname.toString();
1390         }
1391 
1392         @DefinedBy(Api.LANGUAGE_MODEL)
1393         public Name getQualifiedName() {
1394             return fullname;
1395         }
1396 
1397         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1398         public List&lt;Symbol&gt; getEnclosedElements() {
1399             List&lt;Symbol&gt; result = super.getEnclosedElements();
1400             if (!recordComponents.isEmpty()) {
1401                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1402                 for (RecordComponent rc : reversed) {
1403                     result = result.prepend(rc);
1404                 }
1405             }
1406             return result;
1407         }
1408 
1409         public Name flatName() {
1410             return flatname;
1411         }
1412 
1413         public boolean isSubClass(Symbol base, Types types) {
1414             if (this == base) {
1415                 return true;
1416             } else if ((base.flags() &amp; INTERFACE) != 0) {
1417                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1418                     for (List&lt;Type&gt; is = types.interfaces(t);
1419                          is.nonEmpty();
1420                          is = is.tail)
1421                         if (is.head.tsym.isSubClass(base, types)) return true;
1422             } else {
1423                 for (Type t = type; t.hasTag(CLASS); t = types.supertype(t))
1424                     if (t.tsym == base) return true;
1425             }
1426             return false;
1427         }
1428 
1429         /** Complete the elaboration of this symbol&#39;s definition.
1430          */
1431         public void complete() throws CompletionFailure {
1432             Completer origCompleter = completer;
1433             try {
1434                 super.complete();
1435             } catch (CompletionFailure ex) {
1436                 ex.dcfh.classSymbolCompleteFailed(this, origCompleter);
1437                 // quiet error recovery
1438                 flags_field |= (PUBLIC|STATIC);
1439                 this.type = new ErrorType(this, Type.noType);
1440                 throw ex;
1441             }
1442         }
1443 
1444         @DefinedBy(Api.LANGUAGE_MODEL)
1445         public List&lt;Type&gt; getInterfaces() {
1446             apiComplete();
1447             if (type instanceof ClassType) {
1448                 ClassType t = (ClassType)type;
1449                 if (t.interfaces_field == null) // FIXME: shouldn&#39;t be null
1450                     t.interfaces_field = List.nil();
1451                 if (t.all_interfaces_field != null)
1452                     return Type.getModelTypes(t.all_interfaces_field);
1453                 return t.interfaces_field;
1454             } else {
1455                 return List.nil();
1456             }
1457         }
1458 
1459         @DefinedBy(Api.LANGUAGE_MODEL)
1460         public Type getSuperclass() {
1461             apiComplete();
1462             if (type instanceof ClassType) {
1463                 ClassType t = (ClassType)type;
1464                 if (t.supertype_field == null) // FIXME: shouldn&#39;t be null
1465                     t.supertype_field = Type.noType;
1466                 // An interface has no superclass; its supertype is Object.
1467                 return t.isInterface()
1468                     ? Type.noType
1469                     : t.supertype_field.getModelType();
1470             } else {
1471                 return Type.noType;
1472             }
1473         }
1474 
1475         /**
1476          * Returns the next class to search for inherited annotations or {@code null}
1477          * if the next class can&#39;t be found.
1478          */
1479         private ClassSymbol getSuperClassToSearchForAnnotations() {
1480 
1481             Type sup = getSuperclass();
1482 
1483             if (!sup.hasTag(CLASS) || sup.isErroneous())
1484                 return null;
1485 
1486             return (ClassSymbol) sup.tsym;
1487         }
1488 
1489 
1490         @Override
1491         protected &lt;A extends Annotation&gt; A[] getInheritedAnnotations(Class&lt;A&gt; annoType) {
1492 
1493             ClassSymbol sup = getSuperClassToSearchForAnnotations();
1494 
1495             return sup == null ? super.getInheritedAnnotations(annoType)
1496                                : sup.getAnnotationsByType(annoType);
1497         }
1498 
1499 
1500         @DefinedBy(Api.LANGUAGE_MODEL)
1501         @SuppressWarnings(&quot;preview&quot;)
1502         public ElementKind getKind() {
1503             apiComplete();
1504             long flags = flags();
1505             if ((flags &amp; ANNOTATION) != 0)
1506                 return ElementKind.ANNOTATION_TYPE;
1507             else if ((flags &amp; INTERFACE) != 0)
1508                 return ElementKind.INTERFACE;
1509             else if ((flags &amp; ENUM) != 0)
1510                 return ElementKind.ENUM;
1511             else if ((flags &amp; RECORD) != 0)
1512                 return ElementKind.RECORD;
1513             else
1514                 return ElementKind.CLASS;
1515         }
1516 
1517         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1518         public Set&lt;Modifier&gt; getModifiers() {
1519             apiComplete();
1520             long flags = flags();
1521             return Flags.asModifierSet(flags &amp; ~DEFAULT);
1522         }
1523 
1524         public RecordComponent getRecordComponent(VarSymbol field) {
1525             for (RecordComponent rc : recordComponents) {
1526                 if (rc.name == field.name) {
1527                     return rc;
1528                 }
1529             }
1530             return null;
1531         }
1532 
1533         public RecordComponent getRecordComponent(JCVariableDecl var, boolean addIfMissing, List&lt;JCAnnotation&gt; annotations) {
1534             for (RecordComponent rc : recordComponents) {
1535                 if (rc.name == var.name) {
1536                     return rc;
1537                 }
1538             }
1539             RecordComponent rc = null;
1540             if (addIfMissing) {
1541                 recordComponents = recordComponents.append(rc = new RecordComponent(var, annotations));
1542             }
1543             return rc;
1544         }
1545 
1546         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1547         @SuppressWarnings(&quot;preview&quot;)
1548         public List&lt;? extends RecordComponent&gt; getRecordComponents() {
1549             return recordComponents;
1550         }
1551 
1552         @DefinedBy(Api.LANGUAGE_MODEL)
1553         public NestingKind getNestingKind() {
1554             apiComplete();
1555             if (owner.kind == PCK)
1556                 return NestingKind.TOP_LEVEL;
1557             else if (name.isEmpty())
1558                 return NestingKind.ANONYMOUS;
1559             else if (owner.kind == MTH)
1560                 return NestingKind.LOCAL;
1561             else
1562                 return NestingKind.MEMBER;
1563         }
1564 
1565         @Override
1566         protected &lt;A extends Annotation&gt; Attribute.Compound getAttribute(final Class&lt;A&gt; annoType) {
1567 
1568             Attribute.Compound attrib = super.getAttribute(annoType);
1569 
1570             boolean inherited = annoType.isAnnotationPresent(Inherited.class);
1571             if (attrib != null || !inherited)
1572                 return attrib;
1573 
1574             // Search supertypes
1575             ClassSymbol superType = getSuperClassToSearchForAnnotations();
1576             return superType == null ? null
1577                                      : superType.getAttribute(annoType);
1578         }
1579 
1580         @DefinedBy(Api.LANGUAGE_MODEL)
1581         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1582             return v.visitType(this, p);
1583         }
1584 
1585         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1586             return v.visitClassSymbol(this, p);
1587         }
1588 
1589         public void markAbstractIfNeeded(Types types) {
1590             if (types.enter.getEnv(this) != null &amp;&amp;
1591                 (flags() &amp; ENUM) != 0 &amp;&amp; types.supertype(type).tsym == types.syms.enumSym &amp;&amp;
1592                 (flags() &amp; (FINAL | ABSTRACT)) == 0) {
1593                 if (types.firstUnimplementedAbstract(this) != null)
1594                     // add the ABSTRACT flag to an enum
1595                     flags_field |= ABSTRACT;
1596             }
1597         }
1598 
1599         /**Resets the Symbol into the state good for next round of annotation processing.*/
1600         public void reset() {
1601             kind = TYP;
1602             erasure_field = null;
1603             members_field = null;
1604             flags_field = 0;
1605             if (type instanceof ClassType) {
1606                 ClassType t = (ClassType)type;
1607                 t.setEnclosingType(Type.noType);
1608                 t.rank_field = -1;
1609                 t.typarams_field = null;
1610                 t.allparams_field = null;
1611                 t.supertype_field = null;
1612                 t.interfaces_field = null;
1613                 t.all_interfaces_field = null;
1614             }
1615             clearAnnotationMetadata();
1616         }
1617 
1618         public void clearAnnotationMetadata() {
1619             metadata = null;
1620             annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1621         }
1622 
1623         @Override
1624         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1625             return annotationTypeMetadata;
1626         }
1627 
1628         @Override
1629         public boolean isAnnotationType() {
1630             return (flags_field &amp; Flags.ANNOTATION) != 0;
1631         }
1632 
1633         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1634             Assert.checkNonNull(a);
1635             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1636             this.annotationTypeMetadata = a;
1637         }
1638 
1639         public boolean isRecord() {
1640             return (flags_field &amp; RECORD) != 0;
1641         }
<a name="7" id="anc7"></a><span class="line-added">1642 </span>
<span class="line-added">1643         @Override</span>
<span class="line-added">1644         public boolean isReferenceProjection() {</span>
<span class="line-added">1645             return projection != null &amp;&amp; projection.isValue();</span>
<span class="line-added">1646         }</span>
<span class="line-added">1647 </span>
<span class="line-added">1648         @Override</span>
<span class="line-added">1649         public ClassSymbol valueProjection() {</span>
<span class="line-added">1650             return isReferenceProjection() ? projection : null;</span>
<span class="line-added">1651         }</span>
<span class="line-added">1652 </span>
<span class="line-added">1653         @Override</span>
<span class="line-added">1654         public ClassSymbol referenceProjection() {</span>
<span class="line-added">1655             if (!isValue() || projection != null)</span>
<span class="line-added">1656                 return projection;</span>
<span class="line-added">1657 </span>
<span class="line-added">1658             ClassType ct = (ClassType) this.type;</span>
<span class="line-added">1659             ClassType projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);</span>
<span class="line-added">1660             projectedType.allparams_field = ct.allparams_field;</span>
<span class="line-added">1661             projectedType.supertype_field = ct.supertype_field;</span>
<span class="line-added">1662 </span>
<span class="line-added">1663             projectedType.interfaces_field = ct.interfaces_field;</span>
<span class="line-added">1664             projectedType.all_interfaces_field = ct.all_interfaces_field;</span>
<span class="line-added">1665             projectedType.projection = ct;</span>
<span class="line-added">1666             ct.projection = projectedType;</span>
<span class="line-added">1667 </span>
<span class="line-added">1668             Name projectionName = this.name.append(&#39;$&#39;, this.name.table.names.ref);</span>
<span class="line-added">1669             long projectionFlags = (this.flags() &amp; ~(VALUE | UNATTRIBUTED));</span>
<span class="line-added">1670 </span>
<span class="line-added">1671             projection = new ClassSymbol(projectionFlags, projectionName, projectedType, this.owner);</span>
<span class="line-added">1672             projection.members_field = WriteableScope.create(projection);</span>
<span class="line-added">1673             for (Symbol s : this.members().getSymbols(s-&gt;(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {</span>
<span class="line-added">1674                 Symbol clone = null;</span>
<span class="line-added">1675                 if (s.kind == MTH) {</span>
<span class="line-added">1676                     MethodSymbol valMethod = (MethodSymbol)s;</span>
<span class="line-added">1677                     MethodSymbol refMethod = valMethod.clone(projection);</span>
<span class="line-added">1678                     valMethod.projection = refMethod;</span>
<span class="line-added">1679                     refMethod.projection = valMethod;</span>
<span class="line-added">1680                     clone = refMethod;</span>
<span class="line-added">1681                 } else if (s.kind == VAR) {</span>
<span class="line-added">1682                     VarSymbol valVar = (VarSymbol)s;</span>
<span class="line-added">1683                     VarSymbol refVar = valVar.clone(projection);</span>
<span class="line-added">1684                     valVar.projection = refVar;</span>
<span class="line-added">1685                     refVar.projection = valVar;</span>
<span class="line-added">1686                     clone = refVar;</span>
<span class="line-added">1687                 }</span>
<span class="line-added">1688                 projection.members_field.enter(clone);</span>
<span class="line-added">1689             }</span>
<span class="line-added">1690             projection.completer = Completer.NULL_COMPLETER;</span>
<span class="line-added">1691             projection.sourcefile = this.sourcefile;</span>
<span class="line-added">1692             projection.flatname = this.flatname.append(&#39;$&#39;, this.name.table.names.ref);</span>
<span class="line-added">1693             projection.projection = this;</span>
<span class="line-added">1694             projectedType.tsym = projection;</span>
<span class="line-added">1695             return projection;</span>
<span class="line-added">1696         }</span>
1697     }
1698 
1699 
1700     /** A class for variable symbols
1701      */
1702     public static class VarSymbol extends Symbol implements VariableElement {
1703 
1704         /** The variable&#39;s declaration position.
1705          */
1706         public int pos = Position.NOPOS;
1707 
1708         /** The variable&#39;s address. Used for different purposes during
1709          *  flow analysis, translation and code generation.
1710          *  Flow analysis:
1711          *    If this is a blank final or local variable, its sequence number.
1712          *  Translation:
1713          *    If this is a private field, its access number.
1714          *  Code generation:
1715          *    If this is a local variable, its logical slot number.
1716          */
1717         public int adr = -1;
1718 
<a name="8" id="anc8"></a><span class="line-added">1719         /* The &#39;other&#39; projection: If &#39;this&#39; is a field of an inline class, then &#39;projection&#39; is the</span>
<span class="line-added">1720            its doppleganger in its referene projection class and vice versa.</span>
<span class="line-added">1721         */</span>
<span class="line-added">1722         public VarSymbol projection;</span>
<span class="line-added">1723 </span>
1724         /** Construct a variable symbol, given its flags, name, type and owner.
1725          */
1726         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1727             super(VAR, flags, name, type, owner);
1728         }
1729 
1730         @Override
1731         public int poolTag() {
1732             return ClassFile.CONSTANT_Fieldref;
1733         }
1734 
1735         public MethodHandleSymbol asMethodHandle(boolean getter) {
1736             return new MethodHandleSymbol(this, getter);
1737         }
1738 
1739         /** Clone this symbol with new owner.
1740          */
1741         public VarSymbol clone(Symbol newOwner) {
1742             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1743                 @Override
1744                 public Symbol baseSymbol() {
1745                     return VarSymbol.this;
1746                 }
1747 
1748                 @Override
1749                 public Object poolKey(Types types) {
1750                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1751                 }
1752             };
1753             v.pos = pos;
1754             v.adr = adr;
1755             v.data = data;
<a name="9" id="anc9"></a><span class="line-added">1756             v.projection = projection;</span>
1757 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1758             return v;
1759         }
1760 
1761         public String toString() {
1762             return name.toString();
1763         }
1764 
1765         public Symbol asMemberOf(Type site, Types types) {
1766             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1767         }
1768 
1769         @DefinedBy(Api.LANGUAGE_MODEL)
1770         public ElementKind getKind() {
1771             long flags = flags();
1772             if ((flags &amp; PARAMETER) != 0) {
1773                 if (isExceptionParameter())
1774                     return ElementKind.EXCEPTION_PARAMETER;
1775                 else
1776                     return ElementKind.PARAMETER;
1777             } else if ((flags &amp; ENUM) != 0) {
1778                 return ElementKind.ENUM_CONSTANT;
1779             } else if (owner.kind == TYP || owner.kind == ERR) {
1780                 return ElementKind.FIELD;
1781             } else if (isResourceVariable()) {
1782                 return ElementKind.RESOURCE_VARIABLE;
1783             } else if ((flags &amp; MATCH_BINDING) != 0) {
1784                 @SuppressWarnings(&quot;preview&quot;)
1785                 ElementKind kind = ElementKind.BINDING_VARIABLE;
1786                 return kind;
1787             } else {
1788                 return ElementKind.LOCAL_VARIABLE;
1789             }
1790         }
1791 
1792         @DefinedBy(Api.LANGUAGE_MODEL)
1793         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1794             return v.visitVariable(this, p);
1795         }
1796 
1797         @DefinedBy(Api.LANGUAGE_MODEL)
1798         public Object getConstantValue() { // Mirror API
1799             return Constants.decode(getConstValue(), type);
1800         }
1801 
1802         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1803                                       final Attr attr,
1804                                       final JCVariableDecl variable)
1805         {
1806             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1807         }
1808 
<a name="10" id="anc10"></a><span class="line-added">1809         @Override</span>
<span class="line-added">1810         public VarSymbol referenceProjection() {</span>
<span class="line-added">1811             return this.owner.isValue() ?</span>
<span class="line-added">1812                     this.owner.referenceProjection() != null ? projection : null</span>
<span class="line-added">1813                                : null;</span>
<span class="line-added">1814         }</span>
<span class="line-added">1815 </span>
<span class="line-added">1816         @Override</span>
<span class="line-added">1817         public VarSymbol valueProjection() {</span>
<span class="line-added">1818             return  projection != null ? projection.owner.isValue() ? projection : null: null;</span>
<span class="line-added">1819         }</span>
<span class="line-added">1820 </span>
1821         /**
1822          * The variable&#39;s constant value, if this is a constant.
1823          * Before the constant value is evaluated, it points to an
1824          * initializer environment.  If this is not a constant, it can
1825          * be used for other stuff.
1826          */
1827         private Object data;
1828 
1829         public boolean isExceptionParameter() {
1830             return data == ElementKind.EXCEPTION_PARAMETER;
1831         }
1832 
1833         public boolean isResourceVariable() {
1834             return data == ElementKind.RESOURCE_VARIABLE;
1835         }
1836 
1837         public Object getConstValue() {
1838             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1839             if (data == ElementKind.EXCEPTION_PARAMETER ||
1840                 data == ElementKind.RESOURCE_VARIABLE) {
1841                 return null;
1842             } else if (data instanceof Callable&lt;?&gt;) {
1843                 // In this case, this is a final variable, with an as
1844                 // yet unevaluated initializer.
1845                 Callable&lt;?&gt; eval = (Callable&lt;?&gt;)data;
1846                 data = null; // to make sure we don&#39;t evaluate this twice.
1847                 try {
1848                     data = eval.call();
1849                 } catch (Exception ex) {
1850                     throw new AssertionError(ex);
1851                 }
1852             }
1853             return data;
1854         }
1855 
1856         public void setData(Object data) {
1857             Assert.check(!(data instanceof Env&lt;?&gt;), this);
1858             this.data = data;
1859         }
1860 
1861         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1862             return v.visitVarSymbol(this, p);
1863         }
1864     }
1865 
1866     @SuppressWarnings(&quot;preview&quot;)
1867     public static class RecordComponent extends VarSymbol implements RecordComponentElement {
1868         public MethodSymbol accessor;
1869         public JCTree.JCMethodDecl accessorMeth;
1870         private final List&lt;JCAnnotation&gt; originalAnnos;
1871 
1872         /**
1873          * Construct a record component, given its flags, name, type and owner.
1874          */
1875         public RecordComponent(JCVariableDecl fieldDecl, List&lt;JCAnnotation&gt; annotations) {
1876             super(PUBLIC, fieldDecl.sym.name, fieldDecl.sym.type, fieldDecl.sym.owner);
1877             this.originalAnnos = annotations;
1878         }
1879 
1880         public List&lt;JCAnnotation&gt; getOriginalAnnos() { return originalAnnos; }
1881 
1882         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1883         @SuppressWarnings(&quot;preview&quot;)
1884         public ElementKind getKind() {
1885             return ElementKind.RECORD_COMPONENT;
1886         }
1887 
1888         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1889         public ExecutableElement getAccessor() {
1890             return accessor;
1891         }
1892 
1893         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1894         @SuppressWarnings(&quot;preview&quot;)
1895         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1896             return v.visitRecordComponent(this, p);
1897         }
1898     }
1899 
1900     public static class ParamSymbol extends VarSymbol {
1901         public ParamSymbol(long flags, Name name, Type type, Symbol owner) {
1902             super(flags, name, type, owner);
1903         }
1904 
1905         @Override
1906         public Name getSimpleName() {
1907             if ((flags_field &amp; NAME_FILLED) == 0) {
1908                 flags_field |= NAME_FILLED;
1909                 Symbol rootPack = this;
1910                 while (rootPack != null &amp;&amp; !(rootPack instanceof RootPackageSymbol)) {
1911                     rootPack = rootPack.owner;
1912                 }
1913                 if (rootPack != null) {
1914                     Name inferredName =
1915                             ((RootPackageSymbol) rootPack).missingInfoHandler.getParameterName(this);
1916                     if (inferredName != null) {
1917                         this.name = inferredName;
1918                     }
1919                 }
1920             }
1921             return super.getSimpleName();
1922         }
1923 
1924     }
1925 
1926     public static class BindingSymbol extends VarSymbol {
1927 
1928         public BindingSymbol(Name name, Type type, Symbol owner) {
1929             super(Flags.FINAL | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);
1930         }
1931 
1932         public boolean isAliasFor(BindingSymbol b) {
1933             return aliases().containsAll(b.aliases());
1934         }
1935 
1936         List&lt;BindingSymbol&gt; aliases() {
1937             return List.of(this);
1938         }
1939 
1940         public void preserveBinding() {
1941             flags_field |= Flags.MATCH_BINDING_TO_OUTER;
1942         }
1943 
1944         public boolean isPreserved() {
1945             return (flags_field &amp; Flags.MATCH_BINDING_TO_OUTER) != 0;
1946         }
1947     }
1948 
1949     /** A class for method symbols.
1950      */
1951     public static class MethodSymbol extends Symbol implements ExecutableElement {
1952 
1953         /** The code of the method. */
1954         public Code code = null;
1955 
1956         /** The extra (synthetic/mandated) parameters of the method. */
1957         public List&lt;VarSymbol&gt; extraParams = List.nil();
1958 
1959         /** The captured local variables in an anonymous class */
1960         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1961 
1962         /** The parameters of the method. */
1963         public List&lt;VarSymbol&gt; params = null;
1964 
1965         /** For an annotation type element, its default value if any.
1966          *  The value is null if none appeared in the method
1967          *  declaration.
1968          */
1969         public Attribute defaultValue = null;
1970 
<a name="11" id="anc11"></a><span class="line-added">1971         /* The &#39;other&#39; projection: If &#39;this&#39; is a method of an inline class, then &#39;projection&#39; is the</span>
<span class="line-added">1972            its doppleganger in its referene projection class and vice versa.</span>
<span class="line-added">1973         */</span>
<span class="line-added">1974         public MethodSymbol projection;</span>
<span class="line-added">1975 </span>
1976         /** Construct a method symbol, given its flags, name, type and owner.
1977          */
1978         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1979             super(MTH, flags, name, type, owner);
1980             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1981         }
1982 
1983         /** Clone this symbol with new owner.
1984          */
1985         public MethodSymbol clone(Symbol newOwner) {
1986             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1987                 @Override
1988                 public Symbol baseSymbol() {
1989                     return MethodSymbol.this;
1990                 }
1991 
1992                 @Override
1993                 public Object poolKey(Types types) {
1994                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1995                 }
1996             };
1997             m.code = code;
<a name="12" id="anc12"></a><span class="line-added">1998             m.projection = projection;</span>
1999             return m;
2000         }
2001 
2002         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2003         public Set&lt;Modifier&gt; getModifiers() {
2004             long flags = flags();
2005             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
2006         }
2007 
2008         /** The Java source which this symbol represents.
2009          */
2010         public String toString() {
2011             if ((flags() &amp; BLOCK) != 0) {
2012                 return owner.name.toString();
2013             } else {
2014                 String s = (name == name.table.names.init)
2015                     ? owner.name.toString()
2016                     : name.toString();
2017                 if (type != null) {
2018                     if (type.hasTag(FORALL))
2019                         s = &quot;&lt;&quot; + ((ForAll)type).getTypeArguments() + &quot;&gt;&quot; + s;
2020                     s += &quot;(&quot; + type.argtypes((flags() &amp; VARARGS) != 0) + &quot;)&quot;;
2021                 }
2022                 return s;
2023             }
2024         }
2025 
2026         @Override
2027         public int poolTag() {
2028             return owner.isInterface() ?
2029                     ClassFile.CONSTANT_InterfaceMethodref : ClassFile.CONSTANT_Methodref;
2030         }
2031 
2032         public boolean isHandle() {
2033             return false;
2034         }
2035 
2036 
2037         public MethodHandleSymbol asHandle() {
2038             return new MethodHandleSymbol(this);
2039         }
2040 
2041         /** find a symbol that this (proxy method) symbol implements.
2042          *  @param    c       The class whose members are searched for
2043          *                    implementations
2044          */
2045         public Symbol implemented(TypeSymbol c, Types types) {
2046             Symbol impl = null;
2047             for (List&lt;Type&gt; is = types.interfaces(c.type);
2048                  impl == null &amp;&amp; is.nonEmpty();
2049                  is = is.tail) {
2050                 TypeSymbol i = is.head.tsym;
2051                 impl = implementedIn(i, types);
2052                 if (impl == null)
2053                     impl = implemented(i, types);
2054             }
2055             return impl;
2056         }
2057 
2058         public Symbol implementedIn(TypeSymbol c, Types types) {
2059             Symbol impl = null;
2060             for (Symbol sym : c.members().getSymbolsByName(name)) {
2061                 if (this.overrides(sym, (TypeSymbol)owner, types, true) &amp;&amp;
2062                     // FIXME: I suspect the following requires a
2063                     // subst() for a parametric return type.
2064                     types.isSameType(type.getReturnType(),
2065                                      types.memberType(owner.type, sym).getReturnType())) {
2066                     impl = sym;
2067                 }
2068             }
2069             return impl;
2070         }
2071 
2072         /** Will the erasure of this method be considered by the VM to
2073          *  override the erasure of the other when seen from class `origin&#39;?
2074          */
2075         public boolean binaryOverrides(Symbol _other, TypeSymbol origin, Types types) {
2076             if (isConstructor() || _other.kind != MTH) return false;
2077 
2078             if (this == _other) return true;
2079             MethodSymbol other = (MethodSymbol)_other;
2080 
2081             // check for a direct implementation
2082             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2083                 types.asSuper(owner.type, other.owner) != null &amp;&amp;
2084                 types.isSameType(erasure(types), other.erasure(types)))
2085                 return true;
2086 
2087             // check for an inherited implementation
2088             return
2089                 (flags() &amp; ABSTRACT) == 0 &amp;&amp;
2090                 other.isOverridableIn(origin) &amp;&amp;
2091                 this.isMemberOf(origin, types) &amp;&amp;
2092                 types.isSameType(erasure(types), other.erasure(types));
2093         }
2094 
2095         /** The implementation of this (abstract) symbol in class origin,
2096          *  from the VM&#39;s point of view, null if method does not have an
2097          *  implementation in class.
2098          *  @param origin   The class of which the implementation is a member.
2099          */
2100         public MethodSymbol binaryImplementation(ClassSymbol origin, Types types) {
2101             for (TypeSymbol c = origin; c != null; c = types.supertype(c.type).tsym) {
2102                 for (Symbol sym : c.members().getSymbolsByName(name)) {
2103                     if (sym.kind == MTH &amp;&amp;
2104                         ((MethodSymbol)sym).binaryOverrides(this, origin, types))
2105                         return (MethodSymbol)sym;
2106                 }
2107             }
2108             return null;
2109         }
2110 
2111         /** Does this symbol override `other&#39; symbol, when both are seen as
2112          *  members of class `origin&#39;?  It is assumed that _other is a member
2113          *  of origin.
2114          *
2115          *  It is assumed that both symbols have the same name.  The static
2116          *  modifier is ignored for this test.
2117          *
2118          *  A quirk in the works is that if the receiver is a method symbol for
2119          *  an inherited abstract method we answer false summarily all else being
2120          *  immaterial. Abstract &quot;own&quot; methods (i.e `this&#39; is a direct member of
2121          *  origin) don&#39;t get rejected as summarily and are put to test against the
2122          *  suitable criteria.
2123          *
2124          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2125          */
2126         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult) {
2127             return overrides(_other, origin, types, checkResult, true);
2128         }
2129 
2130         /** Does this symbol override `other&#39; symbol, when both are seen as
2131          *  members of class `origin&#39;?  It is assumed that _other is a member
2132          *  of origin.
2133          *
2134          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2135          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2136          *  is false.
2137          *
2138          *  It is assumed that both symbols have the same name.  The static
2139          *  modifier is ignored for this test.
2140          *
2141          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2142          */
2143         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2144                                             boolean requireConcreteIfInherited) {
2145             if (isConstructor() || _other.kind != MTH) return false;
2146 
<a name="13" id="anc13"></a><span class="line-added">2147 </span>
<span class="line-added">2148             /* If any inline types are involved, ask the same question in the reference universe,</span>
<span class="line-added">2149                where the hierarchy is navigable</span>
<span class="line-added">2150             */</span>
<span class="line-added">2151             if (origin.isValue())</span>
<span class="line-added">2152                 origin = (TypeSymbol) origin.referenceProjection();</span>
<span class="line-added">2153 </span>
<span class="line-added">2154             if (this.owner.isValue())</span>
<span class="line-added">2155                 return this.projection.overrides(_other, origin, types, checkResult, requireConcreteIfInherited);</span>
<span class="line-added">2156 </span>
2157             if (this == _other) return true;
2158             MethodSymbol other = (MethodSymbol)_other;
2159 
2160             // check for a direct implementation
2161             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2162                 types.asSuper(owner.type, other.owner) != null) {
2163                 Type mt = types.memberType(owner.type, this);
2164                 Type ot = types.memberType(owner.type, other);
2165                 if (types.isSubSignature(mt, ot)) {
2166                     if (!checkResult)
2167                         return true;
2168                     if (types.returnTypeSubstitutable(mt, ot))
2169                         return true;
2170                 }
2171             }
2172 
2173             // check for an inherited implementation
2174             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2175                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2176                     !other.isOverridableIn(origin) ||
2177                     !this.isMemberOf(origin, types))
2178                 return false;
2179 
2180             // assert types.asSuper(origin.type, other.owner) != null;
2181             Type mt = types.memberType(origin.type, this);
2182             Type ot = types.memberType(origin.type, other);
2183             return
2184                 types.isSubSignature(mt, ot) &amp;&amp;
2185                 (!checkResult || types.resultSubtype(mt, ot, types.noWarnings));
2186         }
2187 
2188         private boolean isOverridableIn(TypeSymbol origin) {
2189             // JLS 8.4.6.1
2190             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2191             case Flags.PRIVATE:
2192                 return false;
2193             case Flags.PUBLIC:
2194                 return !this.owner.isInterface() ||
2195                         (flags_field &amp; STATIC) == 0;
2196             case Flags.PROTECTED:
2197                 return (origin.flags() &amp; INTERFACE) == 0;
2198             case 0:
2199                 // for package private: can only override in the same
2200                 // package
2201                 return
2202                     this.packge() == origin.packge() &amp;&amp;
2203                     (origin.flags() &amp; INTERFACE) == 0;
2204             default:
2205                 return false;
2206             }
2207         }
2208 
2209         @Override
2210         public boolean isInheritedIn(Symbol clazz, Types types) {
<a name="14" id="anc14"></a><span class="line-added">2211 </span>
<span class="line-added">2212             /* If any inline types are involved, ask the same question in the reference universe,</span>
<span class="line-added">2213                where the hierarchy is navigable</span>
<span class="line-added">2214             */</span>
<span class="line-added">2215             if (clazz.isValue())</span>
<span class="line-added">2216                 clazz = clazz.referenceProjection();</span>
<span class="line-added">2217             if (this.owner.isValue())</span>
<span class="line-added">2218                 return this.projection.isInheritedIn(clazz, types);</span>
<span class="line-added">2219 </span>
2220             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2221                 case PUBLIC:
2222                     return !this.owner.isInterface() ||
2223                             clazz == owner ||
2224                             (flags_field &amp; STATIC) == 0;
2225                 default:
2226                     return super.isInheritedIn(clazz, types);
2227             }
2228         }
2229 
2230         public boolean isLambdaMethod() {
2231             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2232         }
2233 
<a name="15" id="anc15"></a><span class="line-added">2234         @Override</span>
<span class="line-added">2235         public MethodSymbol referenceProjection() {</span>
<span class="line-added">2236             return this.owner.isValue() ?</span>
<span class="line-added">2237                     this.owner.referenceProjection() != null ? projection : null</span>
<span class="line-added">2238                     : null;</span>
<span class="line-added">2239         }</span>
<span class="line-added">2240 </span>
<span class="line-added">2241         @Override</span>
<span class="line-added">2242         public MethodSymbol valueProjection() {</span>
<span class="line-added">2243             return  projection != null ? projection.owner.isValue() ? projection : null : null;</span>
<span class="line-added">2244         }</span>
<span class="line-added">2245 </span>
2246         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2247          *  lambda method
2248          */
2249         public MethodSymbol originalEnclosingMethod() {
2250             return this;
2251         }
2252 
2253         /** The implementation of this (abstract) symbol in class origin;
2254          *  null if none exists. Synthetic methods are not considered
2255          *  as possible implementations.
2256          */
2257         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2258             return implementation(origin, types, checkResult, implementation_filter);
2259         }
2260         // where
2261             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2262                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2263 
2264         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2265             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
2266             if (res != null)
2267                 return res;
2268             // if origin is derived from a raw type, we might have missed
2269             // an implementation because we do not know enough about instantiations.
2270             // in this case continue with the supertype as origin.
2271             if (types.isDerivedRaw(origin.type) &amp;&amp; !origin.isInterface())
2272                 return implementation(types.supertype(origin.type).tsym, types, checkResult);
2273             else
2274                 return null;
2275         }
2276 
2277         public List&lt;VarSymbol&gt; params() {
2278             owner.complete();
2279             if (params == null) {
2280                 ListBuffer&lt;VarSymbol&gt; newParams = new ListBuffer&lt;&gt;();
2281                 int i = 0;
2282                 for (Type t : type.getParameterTypes()) {
2283                     Name paramName = name.table.fromString(&quot;arg&quot; + i);
2284                     VarSymbol param = new VarSymbol(PARAMETER, paramName, t, this);
2285                     newParams.append(param);
2286                     i++;
2287                 }
2288                 params = newParams.toList();
2289             }
2290             Assert.checkNonNull(params);
2291             return params;
2292         }
2293 
2294         public Symbol asMemberOf(Type site, Types types) {
2295             return new MethodSymbol(flags_field, name, types.memberType(site, this), owner);
2296         }
2297 
2298         @DefinedBy(Api.LANGUAGE_MODEL)
2299         public ElementKind getKind() {
2300             if (name == name.table.names.init)
2301                 return ElementKind.CONSTRUCTOR;
2302             else if (name == name.table.names.clinit)
2303                 return ElementKind.STATIC_INIT;
2304             else if ((flags() &amp; BLOCK) != 0)
2305                 return isStatic() ? ElementKind.STATIC_INIT : ElementKind.INSTANCE_INIT;
2306             else
2307                 return ElementKind.METHOD;
2308         }
2309 
2310         public boolean isStaticOrInstanceInit() {
2311             return getKind() == ElementKind.STATIC_INIT ||
2312                     getKind() == ElementKind.INSTANCE_INIT;
2313         }
2314 
2315         @DefinedBy(Api.LANGUAGE_MODEL)
2316         public Attribute getDefaultValue() {
2317             return defaultValue;
2318         }
2319 
2320         @DefinedBy(Api.LANGUAGE_MODEL)
2321         public List&lt;VarSymbol&gt; getParameters() {
2322             return params();
2323         }
2324 
2325         @DefinedBy(Api.LANGUAGE_MODEL)
2326         public boolean isVarArgs() {
2327             return (flags() &amp; VARARGS) != 0;
2328         }
2329 
2330         @DefinedBy(Api.LANGUAGE_MODEL)
2331         public boolean isDefault() {
2332             return (flags() &amp; DEFAULT) != 0;
2333         }
2334 
2335         @DefinedBy(Api.LANGUAGE_MODEL)
2336         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
2337             return v.visitExecutable(this, p);
2338         }
2339 
2340         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2341             return v.visitMethodSymbol(this, p);
2342         }
2343 
2344         @DefinedBy(Api.LANGUAGE_MODEL)
2345         public Type getReceiverType() {
2346             Type result = asType().getReceiverType();
2347             return (result == null) ? Type.noType : result;
2348         }
2349 
2350         @DefinedBy(Api.LANGUAGE_MODEL)
2351         public Type getReturnType() {
2352             return asType().getReturnType();
2353         }
2354 
2355         @DefinedBy(Api.LANGUAGE_MODEL)
2356         public List&lt;Type&gt; getThrownTypes() {
2357             return asType().getThrownTypes();
2358         }
2359     }
2360 
2361     /** A class for invokedynamic method calls.
2362      */
2363     public static class DynamicMethodSymbol extends MethodSymbol implements Dynamic {
2364 
2365         public LoadableConstant[] staticArgs;
2366         public MethodHandleSymbol bsm;
2367 
2368         public DynamicMethodSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {
2369             super(0, name, type, owner);
2370             this.bsm = bsm;
2371             this.staticArgs = staticArgs;
2372         }
2373 
2374         @Override
2375         public boolean isDynamic() {
2376             return true;
2377         }
2378 
2379         @Override
2380         public LoadableConstant[] staticArgs() {
2381             return staticArgs;
2382         }
2383 
2384         @Override
2385         public MethodHandleSymbol bootstrapMethod() {
2386             return bsm;
2387         }
2388 
2389         @Override
2390         public int poolTag() {
2391             return ClassFile.CONSTANT_InvokeDynamic;
2392         }
2393 
2394         @Override
2395         public Type dynamicType() {
2396             return type;
2397         }
2398     }
2399 
2400     /** A class for condy.
2401      */
2402     public static class DynamicVarSymbol extends VarSymbol implements Dynamic, LoadableConstant {
2403         public LoadableConstant[] staticArgs;
2404         public MethodHandleSymbol bsm;
2405 
2406         public DynamicVarSymbol(Name name, Symbol owner, MethodHandleSymbol bsm, Type type, LoadableConstant[] staticArgs) {
2407             super(0, name, type, owner);
2408             this.bsm = bsm;
2409             this.staticArgs = staticArgs;
2410         }
2411 
2412         @Override
2413         public boolean isDynamic() {
2414             return true;
2415         }
2416 
2417         @Override
2418         public PoolConstant dynamicType() {
2419             return type;
2420         }
2421 
2422         @Override
2423         public LoadableConstant[] staticArgs() {
2424             return staticArgs;
2425         }
2426 
2427         @Override
2428         public LoadableConstant bootstrapMethod() {
2429             return bsm;
2430         }
2431 
2432         @Override
2433         public int poolTag() {
2434             return ClassFile.CONSTANT_Dynamic;
2435         }
2436     }
2437 
2438     /** A class for method handles.
2439      */
2440     public static class MethodHandleSymbol extends MethodSymbol implements LoadableConstant {
2441 
2442         private Symbol refSym;
2443         private boolean getter;
2444 
2445         public MethodHandleSymbol(Symbol msym) {
2446             this(msym, false);
2447         }
2448 
2449         public MethodHandleSymbol(Symbol msym, boolean getter) {
2450             super(msym.flags_field, msym.name, msym.type, msym.owner);
2451             this.refSym = msym;
2452             this.getter = getter;
2453         }
2454 
2455         /**
2456          * Returns the kind associated with this method handle.
2457          */
2458         public int referenceKind() {
2459             if (refSym.kind == VAR) {
2460                 return getter ?
2461                         refSym.isStatic() ? ClassFile.REF_getStatic : ClassFile.REF_getField :
2462                         refSym.isStatic() ? ClassFile.REF_putStatic : ClassFile.REF_putField;
2463             } else {
2464                 if (refSym.isConstructor()) {
2465                     return ClassFile.REF_newInvokeSpecial;
2466                 } else {
2467                     if (refSym.isStatic()) {
2468                         return ClassFile.REF_invokeStatic;
2469                     } else if ((refSym.flags() &amp; PRIVATE) != 0 &amp;&amp; !allowPrivateInvokeVirtual()) {
2470                         return ClassFile.REF_invokeSpecial;
2471                     } else if (refSym.enclClass().isInterface()) {
2472                         return ClassFile.REF_invokeInterface;
2473                     } else {
2474                         return ClassFile.REF_invokeVirtual;
2475                     }
2476                 }
2477             }
2478         }
2479 
2480         private boolean allowPrivateInvokeVirtual() {
2481             Symbol rootPack = this;
2482             while (rootPack != null &amp;&amp; !(rootPack instanceof RootPackageSymbol)) {
2483                 rootPack = rootPack.owner;
2484             }
2485             return rootPack != null &amp;&amp; ((RootPackageSymbol) rootPack).allowPrivateInvokeVirtual;
2486         }
2487         @Override
2488         public int poolTag() {
2489             return ClassFile.CONSTANT_MethodHandle;
2490         }
2491 
2492         @Override
2493         public Object poolKey(Types types) {
2494             return new Pair&lt;&gt;(baseSymbol(), referenceKind());
2495         }
2496 
2497         @Override
2498         public MethodHandleSymbol asHandle() {
2499             return this;
2500         }
2501 
2502         @Override
2503         public Symbol baseSymbol() {
2504             return refSym;
2505         }
2506 
2507 
2508         @Override
2509         public boolean isHandle() {
2510             return true;
2511         }
2512     }
2513 
2514     /** A class for predefined operators.
2515      */
2516     public static class OperatorSymbol extends MethodSymbol {
2517 
2518         public int opcode;
2519         private int accessCode = Integer.MIN_VALUE;
2520 
2521         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2522             super(PUBLIC | STATIC, name, type, owner);
2523             this.opcode = opcode;
2524         }
2525 
2526         @Override
2527         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2528             return v.visitOperatorSymbol(this, p);
2529         }
2530 
2531         public int getAccessCode(Tag tag) {
2532             if (accessCode != Integer.MIN_VALUE &amp;&amp; !tag.isIncOrDecUnaryOp()) {
2533                 return accessCode;
2534             }
2535             accessCode = AccessCode.from(tag, opcode);
2536             return accessCode;
2537         }
2538 
<a name="16" id="anc16"></a><span class="line-modified">2539         /** Access codes for dereferencing, assignment, withfield</span>
2540          *  and pre/post increment/decrement.
2541 
2542          *  All access codes for accesses to the current class are even.
2543          *  If a member of the superclass should be accessed instead (because
2544          *  access was via a qualified super), add one to the corresponding code
2545          *  for the current class, making the number odd.
2546          *  This numbering scheme is used by the backend to decide whether
2547          *  to issue an invokevirtual or invokespecial call.
2548          *
2549          *  @see Gen#visitSelect(JCFieldAccess tree)
2550          */
2551         public enum AccessCode {
2552             UNKNOWN(-1, Tag.NO_TAG),
2553             DEREF(0, Tag.NO_TAG),
2554             ASSIGN(2, Tag.ASSIGN),
2555             PREINC(4, Tag.PREINC),
2556             PREDEC(6, Tag.PREDEC),
2557             POSTINC(8, Tag.POSTINC),
2558             POSTDEC(10, Tag.POSTDEC),
<a name="17" id="anc17"></a><span class="line-modified">2559             WITHFIELD(12, Tag.WITHFIELD),</span>
<span class="line-added">2560             FIRSTASGOP(14, Tag.NO_TAG);</span>
2561 
2562             public final int code;
2563             public final Tag tag;
2564             public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;
2565 
2566             AccessCode(int code, Tag tag) {
2567                 this.code = code;
2568                 this.tag = tag;
2569             }
2570 
2571             static public AccessCode getFromCode(int code) {
2572                 for (AccessCode aCodes : AccessCode.values()) {
2573                     if (aCodes.code == code) {
2574                         return aCodes;
2575                     }
2576                 }
2577                 return UNKNOWN;
2578             }
2579 
2580             static int from(Tag tag, int opcode) {
2581                 /** Map bytecode of binary operation to access code of corresponding
2582                 *  assignment operation. This is always an even number.
2583                 */
2584                 switch (tag) {
2585                     case PREINC:
2586                         return AccessCode.PREINC.code;
2587                     case PREDEC:
2588                         return AccessCode.PREDEC.code;
2589                     case POSTINC:
2590                         return AccessCode.POSTINC.code;
2591                     case POSTDEC:
2592                         return AccessCode.POSTDEC.code;
<a name="18" id="anc18"></a><span class="line-added">2593                     case WITHFIELD:</span>
<span class="line-added">2594                         return AccessCode.WITHFIELD.code;</span>
2595                 }
2596                 if (iadd &lt;= opcode &amp;&amp; opcode &lt;= lxor) {
2597                     return (opcode - iadd) * 2 + FIRSTASGOP.code;
2598                 } else if (opcode == string_add) {
2599                     return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;
2600                 } else if (ishll &lt;= opcode &amp;&amp; opcode &lt;= lushrl) {
2601                     return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;
2602                 }
2603                 return -1;
2604             }
2605         }
2606     }
2607 
2608     /** Symbol completer interface.
2609      */
2610     public static interface Completer {
2611 
2612         /** Dummy completer to be used when the symbol has been completed or
2613          * does not need completion.
2614          */
2615         public final static Completer NULL_COMPLETER = new Completer() {
2616             public void complete(Symbol sym) { }
2617             public boolean isTerminal() { return true; }
2618         };
2619 
2620         void complete(Symbol sym) throws CompletionFailure;
2621 
2622         /** Returns true if this completer is &lt;em&gt;terminal&lt;/em&gt;. A terminal
2623          * completer is used as a place holder when the symbol is completed.
2624          * Calling complete on a terminal completer will not affect the symbol.
2625          *
2626          * The dummy NULL_COMPLETER and the GraphDependencies completer are
2627          * examples of terminal completers.
2628          *
2629          * @return true iff this completer is terminal
2630          */
2631         default boolean isTerminal() {
2632             return false;
2633         }
2634     }
2635 
2636     public static class CompletionFailure extends RuntimeException {
2637         private static final long serialVersionUID = 0;
2638         public final transient DeferredCompletionFailureHandler dcfh;
2639         public transient Symbol sym;
2640 
2641         /** A diagnostic object describing the failure
2642          */
2643         private transient JCDiagnostic diag;
2644 
2645         private transient Supplier&lt;JCDiagnostic&gt; diagSupplier;
2646 
2647         public CompletionFailure(Symbol sym, Supplier&lt;JCDiagnostic&gt; diagSupplier, DeferredCompletionFailureHandler dcfh) {
2648             this.dcfh = dcfh;
2649             this.sym = sym;
2650             this.diagSupplier = diagSupplier;
2651 //          this.printStackTrace();//DEBUG
2652         }
2653 
2654         public JCDiagnostic getDiagnostic() {
2655             if (diag == null &amp;&amp; diagSupplier != null) {
2656                 diag = diagSupplier.get();
2657             }
2658             return diag;
2659         }
2660 
2661         @Override
2662         public String getMessage() {
2663             return getDiagnostic().getMessage(null);
2664         }
2665 
2666         public JCDiagnostic getDetailValue() {
2667             return getDiagnostic();
2668         }
2669 
2670         @Override
2671         public CompletionFailure initCause(Throwable cause) {
2672             super.initCause(cause);
2673             return this;
2674         }
2675 
2676         public void resetDiagnostic(Supplier&lt;JCDiagnostic&gt; diagSupplier) {
2677             this.diagSupplier = diagSupplier;
2678             this.diag = null;
2679         }
2680 
2681     }
2682 
2683     /**
2684      * A visitor for symbols.  A visitor is used to implement operations
2685      * (or relations) on symbols.  Most common operations on types are
2686      * binary relations and this interface is designed for binary
2687      * relations, that is, operations on the form
2688      * Symbol&amp;nbsp;&amp;times;&amp;nbsp;P&amp;nbsp;&amp;rarr;&amp;nbsp;R.
2689      * &lt;!-- In plain text: Type x P -&gt; R --&gt;
2690      *
2691      * @param &lt;R&gt; the return type of the operation implemented by this
2692      * visitor; use Void if no return type is needed.
2693      * @param &lt;P&gt; the type of the second argument (the first being the
2694      * symbol itself) of the operation implemented by this visitor; use
2695      * Void if a second argument is not needed.
2696      */
2697     public interface Visitor&lt;R,P&gt; {
2698         R visitClassSymbol(ClassSymbol s, P arg);
2699         R visitMethodSymbol(MethodSymbol s, P arg);
2700         R visitPackageSymbol(PackageSymbol s, P arg);
2701         R visitOperatorSymbol(OperatorSymbol s, P arg);
2702         R visitVarSymbol(VarSymbol s, P arg);
2703         R visitTypeSymbol(TypeSymbol s, P arg);
2704         R visitSymbol(Symbol s, P arg);
2705     }
2706 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
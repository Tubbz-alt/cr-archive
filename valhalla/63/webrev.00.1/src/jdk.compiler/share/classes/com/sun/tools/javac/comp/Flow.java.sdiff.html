<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LambdaToMethod.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  35 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Scope.WriteableScope;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  40 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  41 import com.sun.tools.javac.tree.*;
  42 import com.sun.tools.javac.util.*;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.JCDiagnostic.Error;
  45 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  46 
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;



  55 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  56 
  57 /** This pass implements dataflow analysis for Java programs though
  58  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  59  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  60  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  61  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  62  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  63  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
  64  *  determines that local variables accessed within the scope of an inner class/lambda
  65  *  are either final or effectively-final.
  66  *
  67  *  &lt;p&gt;The JLS has a number of problems in the
  68  *  specification of these flow analysis problems. This implementation
  69  *  attempts to address those issues.
  70  *
  71  *  &lt;p&gt;First, there is no accommodation for a finally clause that cannot
  72  *  complete normally. For liveness analysis, an intervening finally
  73  *  clause can cause a break, continue, or return not to reach its
  74  *  target.  For exception analysis, an intervening finally clause can
</pre>
<hr />
<pre>
1214                 }
1215             }
1216 
1217             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1218             pendingExits = new ListBuffer&lt;&gt;();
1219             for (JCTree resource : tree.resources) {
1220                 if (resource instanceof JCVariableDecl) {
1221                     JCVariableDecl vdecl = (JCVariableDecl) resource;
1222                     visitVarDef(vdecl);
1223                 } else if (resource instanceof JCExpression) {
1224                     scan((JCExpression) resource);
1225                 } else {
1226                     throw new AssertionError(tree);  // parser error
1227                 }
1228             }
1229             for (JCTree resource : tree.resources) {
1230                 List&lt;Type&gt; closeableSupertypes = resource.type.isCompound() ?
1231                     types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
1232                     List.of(resource.type);
1233                 for (Type sup : closeableSupertypes) {
<span class="line-modified">1234                     if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {</span>
1235                         Symbol closeMethod = rs.resolveQualifiedMethod(tree,
1236                                 attrEnv,
1237                                 types.skipTypeVars(sup, false),
1238                                 names.close,
1239                                 List.nil(),
1240                                 List.nil());
1241                         Type mt = types.memberType(resource.type, closeMethod);
1242                         if (closeMethod.kind == MTH) {
1243                             for (Type t : mt.getThrownTypes()) {
1244                                 markThrown(resource, t);
1245                             }
1246                         }
1247                     }
1248                 }
1249             }
1250             scan(tree.body);
1251             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1252             thrown = thrownPrev;
1253             caught = caughtPrev;
1254 
</pre>
<hr />
<pre>
1632             inLambda = true;
1633             try {
1634                 pendingExits = new ListBuffer&lt;&gt;();
1635                 caught = List.of(syms.throwableType);
1636                 thrown = List.nil();
1637                 scan(tree.body);
1638                 inferredThrownTypes = thrown;
1639             } finally {
1640                 pendingExits = prevPending;
1641                 caught = prevCaught;
1642                 thrown = prevThrown;
1643                 inLambda = false;
1644             }
1645         }
1646         @Override
1647         public void visitClassDef(JCClassDecl tree) {
1648             //skip
1649         }
1650     }
1651 









1652     /**
1653      * This pass implements (i) definite assignment analysis, which ensures that
1654      * each variable is assigned when used and (ii) definite unassignment analysis,
1655      * which ensures that no final variable is assigned more than once. This visitor
1656      * depends on the results of the liveliness analyzer. This pass is also used to mark
1657      * effectively-final local variables/parameters.
1658      */
1659 
1660     public class AssignAnalyzer extends BaseAnalyzer {
1661 
1662         /** The set of definitely assigned variables.
1663          */
1664         final Bits inits;
1665 
1666         /** The set of definitely unassigned variables.
1667          */
1668         final Bits uninits;
1669 
1670         /** The set of variables that are definitely unassigned everywhere
1671          *  in current try block. This variable is maintained lazily; it is
</pre>
<hr />
<pre>
1720             final Bits inits;
1721             final Bits uninits;
1722             final Bits exit_inits = new Bits(true);
1723             final Bits exit_uninits = new Bits(true);
1724 
1725             public AssignPendingExit(JCTree tree, final Bits inits, final Bits uninits) {
1726                 super(tree);
1727                 this.inits = inits;
1728                 this.uninits = uninits;
1729                 this.exit_inits.assign(inits);
1730                 this.exit_uninits.assign(uninits);
1731             }
1732 
1733             @Override
1734             public void resolveJump() {
1735                 inits.andSet(exit_inits);
1736                 uninits.andSet(exit_uninits);
1737             }
1738         }
1739 



1740         public AssignAnalyzer() {
1741             this.inits = new Bits();
1742             uninits = new Bits();
1743             uninitsTry = new Bits();
1744             initsWhenTrue = new Bits(true);
1745             initsWhenFalse = new Bits(true);
1746             uninitsWhenTrue = new Bits(true);
1747             uninitsWhenFalse = new Bits(true);
1748         }
1749 
1750         private boolean isInitialConstructor = false;
1751 
1752         @Override
1753         protected void markDead() {
1754             if (!isInitialConstructor) {
1755                 inits.inclRange(returnadr, nextadr);
1756             } else {
1757                 for (int address = returnadr; address &lt; nextadr; address++) {
1758                     if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {
1759                         inits.incl(address);
</pre>
<hr />
<pre>
1845                 } else {
1846                     //log.rawWarning(pos, &quot;unreachable assignment&quot;);//DEBUG
1847                     uninits.excl(sym.adr);
1848                 }
1849             }
1850 
1851         /** If tree is either a simple name or of the form this.name or
1852          *  C.this.name, and tree represents a trackable variable,
1853          *  record an initialization of the variable.
1854          */
1855         void letInit(JCTree tree) {
1856             tree = TreeInfo.skipParens(tree);
1857             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1858                 Symbol sym = TreeInfo.symbol(tree);
1859                 if (sym.kind == VAR) {
1860                     letInit(tree.pos(), (VarSymbol)sym);
1861                 }
1862             }
1863         }
1864 
























1865         /** Check that trackable variable is initialized.
1866          */
1867         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1868             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1869         }
1870 
1871         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1872             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1873                 trackable(sym) &amp;&amp;
1874                 !inits.isMember(sym.adr)) {
1875                     log.error(pos, errkey);
1876                 inits.incl(sym.adr);
1877             }
1878         }
1879 
1880         /** Utility method to reset several Bits instances.
1881          */
1882         private void resetBits(Bits... bits) {
1883             for (Bits b : bits) {
1884                 b.reset();
</pre>
<hr />
<pre>
2040                     classDef = classDefPrev;
2041                 }
2042             } finally {
2043                 lint = lintPrev;
2044             }
2045         }
2046 
2047         public void visitMethodDef(JCMethodDecl tree) {
2048             if (tree.body == null) {
2049                 return;
2050             }
2051 
2052             /*  MemberEnter can generate synthetic methods ignore them
2053              */
2054             if ((tree.sym.flags() &amp; SYNTHETIC) != 0) {
2055                 return;
2056             }
2057 
2058             Lint lintPrev = lint;
2059             lint = lint.augment(tree.sym);

2060             try {
2061                 if (tree.body == null) {
2062                     return;
2063                 }
2064                 /*  Ignore synthetic methods, except for translated lambda methods.
2065                  */
2066                 if ((tree.sym.flags() &amp; (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {
2067                     return;
2068                 }
2069 
2070                 final Bits initsPrev = new Bits(inits);
2071                 final Bits uninitsPrev = new Bits(uninits);
2072                 int nextadrPrev = nextadr;
2073                 int firstadrPrev = firstadr;
2074                 int returnadrPrev = returnadr;
2075 
2076                 Assert.check(pendingExits.isEmpty());
2077                 boolean lastInitialConstructor = isInitialConstructor;
2078                 try {
2079                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2080 
2081                     if (!isInitialConstructor) {
2082                         firstadr = nextadr;








2083                     }
2084                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2085                         JCVariableDecl def = l.head;
2086                         scan(def);
2087                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2088                         /*  If we are executing the code from Gen, then there can be
2089                          *  synthetic or mandated variables, ignore them.
2090                          */
2091                         initParam(def);
2092                     }
2093                     // else we are in an instance initializer block;
2094                     // leave caught unchanged.
2095                     scan(tree.body);
2096 
2097                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;
2098                     if (isInitialConstructor) {
2099                         boolean isSynthesized = (tree.sym.flags() &amp;
2100                                                  GENERATEDCONSTR) != 0;
2101                         for (int i = firstadr; i &lt; nextadr; i++) {
2102                             JCVariableDecl vardecl = vardecls[i];
</pre>
<hr />
<pre>
2125                                     } else {
2126                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2127                                     }
2128                                 } else {
2129                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2130                                 }
2131                             }
2132                         }
2133                     }
2134                     clearPendingExits(true);
2135                 } finally {
2136                     inits.assign(initsPrev);
2137                     uninits.assign(uninitsPrev);
2138                     nextadr = nextadrPrev;
2139                     firstadr = firstadrPrev;
2140                     returnadr = returnadrPrev;
2141                     isInitialConstructor = lastInitialConstructor;
2142                 }
2143             } finally {
2144                 lint = lintPrev;

2145             }
2146         }
2147 
2148         private void clearPendingExits(boolean inMethod) {
2149             List&lt;PendingExit&gt; exits = pendingExits.toList();
2150             pendingExits = new ListBuffer&lt;&gt;();
2151             while (exits.nonEmpty()) {
2152                 PendingExit exit = exits.head;
2153                 exits = exits.tail;
2154                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
2155                                  log.hasErrorOn(exit.tree.pos()),
2156                              exit.tree);
2157                 if (inMethod &amp;&amp; isInitialConstructor) {
2158                     Assert.check(exit instanceof AssignPendingExit);
2159                     inits.assign(((AssignPendingExit) exit).exit_inits);
2160                     for (int i = firstadr; i &lt; nextadr; i++) {
2161                         checkInit(exit.tree.pos(), vardecls[i].sym);
2162                     }
2163                 }
2164             }
</pre>
<hr />
<pre>
2600 
2601         @Override
2602         public void visitContinue(JCContinue tree) {
2603             recordExit(new AssignPendingExit(tree, inits, uninits));
2604         }
2605 
2606         @Override
2607         public void visitReturn(JCReturn tree) {
2608             scanExpr(tree.expr);
2609             recordExit(new AssignPendingExit(tree, inits, uninits));
2610         }
2611 
2612         public void visitThrow(JCThrow tree) {
2613             scanExpr(tree.expr);
2614             markDead();
2615         }
2616 
2617         public void visitApply(JCMethodInvocation tree) {
2618             scanExpr(tree.meth);
2619             scanExprs(tree.args);





2620         }
2621 
2622         public void visitNewClass(JCNewClass tree) {
2623             scanExpr(tree.encl);
2624             scanExprs(tree.args);
2625             scan(tree.def);






2626         }
2627 
2628         @Override
2629         public void visitLambda(JCLambda tree) {
2630             final Bits prevUninits = new Bits(uninits);
2631             final Bits prevInits = new Bits(inits);
2632             int returnadrPrev = returnadr;
2633             int nextadrPrev = nextadr;
2634             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
2635             try {
2636                 returnadr = nextadr;
2637                 pendingExits = new ListBuffer&lt;&gt;();
2638                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2639                     JCVariableDecl def = l.head;
2640                     scan(def);
2641                     inits.incl(def.sym.adr);
2642                     uninits.excl(def.sym.adr);
2643                 }
2644                 if (tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2645                     scanExpr(tree.body);
</pre>
<hr />
<pre>
2668             uninitsExit.andSet(uninitsWhenTrue);
2669             if (tree.detail != null) {
2670                 inits.assign(initsWhenFalse);
2671                 uninits.assign(uninitsWhenFalse);
2672                 scanExpr(tree.detail);
2673             }
2674             inits.assign(initsExit);
2675             uninits.assign(uninitsExit);
2676         }
2677 
2678         public void visitAssign(JCAssign tree) {
2679             if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))
2680                 scanExpr(tree.lhs);
2681             scanExpr(tree.rhs);
2682             letInit(tree.lhs);
2683         }
2684 
2685         // check fields accessed through this.&lt;field&gt; are definitely
2686         // assigned before reading their value
2687         public void visitSelect(JCFieldAccess tree) {
<span class="line-modified">2688             super.visitSelect(tree);</span>







2689             if (TreeInfo.isThisQualifier(tree.selected) &amp;&amp;
2690                 tree.sym.kind == VAR) {
<span class="line-modified">2691                 checkInit(tree.pos(), (VarSymbol)tree.sym);</span>



2692             }
2693         }
2694 
2695         public void visitAssignop(JCAssignOp tree) {
2696             scanExpr(tree.lhs);
2697             scanExpr(tree.rhs);
2698             letInit(tree.lhs);
2699         }
2700 
2701         public void visitUnary(JCUnary tree) {
2702             switch (tree.getTag()) {
2703             case NOT:
2704                 scanCond(tree.arg);
2705                 final Bits t = new Bits(initsWhenFalse);
2706                 initsWhenFalse.assign(initsWhenTrue);
2707                 initsWhenTrue.assign(t);
2708                 t.assign(uninitsWhenFalse);
2709                 uninitsWhenFalse.assign(uninitsWhenTrue);
2710                 uninitsWhenTrue.assign(t);
2711                 break;
</pre>
<hr />
<pre>
2735                 scanCond(tree.lhs);
2736                 final Bits initsWhenTrueLeft = new Bits(initsWhenTrue);
2737                 final Bits uninitsWhenTrueLeft = new Bits(uninitsWhenTrue);
2738                 inits.assign(initsWhenFalse);
2739                 uninits.assign(uninitsWhenFalse);
2740                 scanCond(tree.rhs);
2741                 initsWhenTrue.andSet(initsWhenTrueLeft);
2742                 uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
2743                 break;
2744             default:
2745                 scanExpr(tree.lhs);
2746                 scanExpr(tree.rhs);
2747             }
2748         }
2749 
2750         public void visitIdent(JCIdent tree) {
2751             if (tree.sym.kind == VAR) {
2752                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2753                 referenced(tree.sym);
2754             }



2755         }
2756 
2757         void referenced(Symbol sym) {
2758             unrefdResources.remove(sym);
2759         }
2760 
2761         public void visitAnnotatedType(JCAnnotatedType tree) {
2762             // annotations don&#39;t get scanned
2763             tree.underlyingType.accept(this);
2764         }
2765 
2766         public void visitModuleDef(JCModuleDecl tree) {
2767             // Do nothing for modules
2768         }
2769 
2770     /**************************************************************************
2771      * main method
2772      *************************************************************************/
2773 
2774         /** Perform definite assignment/unassignment analysis on a tree.
</pre>
</td>
<td>
<hr />
<pre>
  35 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Scope.WriteableScope;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  40 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  41 import com.sun.tools.javac.tree.*;
  42 import com.sun.tools.javac.util.*;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.JCDiagnostic.Error;
  45 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  46 
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;
<span class="line-added">  55 import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;</span>
<span class="line-added">  56 import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;</span>
<span class="line-added">  57 import static com.sun.tools.javac.comp.Flow.ThisExposability.DISCOURAGED;</span>
  58 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  59 
  60 /** This pass implements dataflow analysis for Java programs though
  61  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  62  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  63  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  64  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  65  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  66  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
  67  *  determines that local variables accessed within the scope of an inner class/lambda
  68  *  are either final or effectively-final.
  69  *
  70  *  &lt;p&gt;The JLS has a number of problems in the
  71  *  specification of these flow analysis problems. This implementation
  72  *  attempts to address those issues.
  73  *
  74  *  &lt;p&gt;First, there is no accommodation for a finally clause that cannot
  75  *  complete normally. For liveness analysis, an intervening finally
  76  *  clause can cause a break, continue, or return not to reach its
  77  *  target.  For exception analysis, an intervening finally clause can
</pre>
<hr />
<pre>
1217                 }
1218             }
1219 
1220             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1221             pendingExits = new ListBuffer&lt;&gt;();
1222             for (JCTree resource : tree.resources) {
1223                 if (resource instanceof JCVariableDecl) {
1224                     JCVariableDecl vdecl = (JCVariableDecl) resource;
1225                     visitVarDef(vdecl);
1226                 } else if (resource instanceof JCExpression) {
1227                     scan((JCExpression) resource);
1228                 } else {
1229                     throw new AssertionError(tree);  // parser error
1230                 }
1231             }
1232             for (JCTree resource : tree.resources) {
1233                 List&lt;Type&gt; closeableSupertypes = resource.type.isCompound() ?
1234                     types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
1235                     List.of(resource.type);
1236                 for (Type sup : closeableSupertypes) {
<span class="line-modified">1237                     if (types.asSuper(sup, syms.autoCloseableType.tsym, true) != null) {</span>
1238                         Symbol closeMethod = rs.resolveQualifiedMethod(tree,
1239                                 attrEnv,
1240                                 types.skipTypeVars(sup, false),
1241                                 names.close,
1242                                 List.nil(),
1243                                 List.nil());
1244                         Type mt = types.memberType(resource.type, closeMethod);
1245                         if (closeMethod.kind == MTH) {
1246                             for (Type t : mt.getThrownTypes()) {
1247                                 markThrown(resource, t);
1248                             }
1249                         }
1250                     }
1251                 }
1252             }
1253             scan(tree.body);
1254             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1255             thrown = thrownPrev;
1256             caught = caughtPrev;
1257 
</pre>
<hr />
<pre>
1635             inLambda = true;
1636             try {
1637                 pendingExits = new ListBuffer&lt;&gt;();
1638                 caught = List.of(syms.throwableType);
1639                 thrown = List.nil();
1640                 scan(tree.body);
1641                 inferredThrownTypes = thrown;
1642             } finally {
1643                 pendingExits = prevPending;
1644                 caught = prevCaught;
1645                 thrown = prevThrown;
1646                 inLambda = false;
1647             }
1648         }
1649         @Override
1650         public void visitClassDef(JCClassDecl tree) {
1651             //skip
1652         }
1653     }
1654 
<span class="line-added">1655     /** Enum to model whether constructors allowed to &quot;leak&quot; this reference before</span>
<span class="line-added">1656         all instance fields are DA.</span>
<span class="line-added">1657      */</span>
<span class="line-added">1658     enum ThisExposability {</span>
<span class="line-added">1659         ALLOWED,     // Normal Object classes - NOP</span>
<span class="line-added">1660         BANNED,      // Value types           - Error</span>
<span class="line-added">1661         DISCOURAGED  // Value based types     - Warning</span>
<span class="line-added">1662     }</span>
<span class="line-added">1663 </span>
1664     /**
1665      * This pass implements (i) definite assignment analysis, which ensures that
1666      * each variable is assigned when used and (ii) definite unassignment analysis,
1667      * which ensures that no final variable is assigned more than once. This visitor
1668      * depends on the results of the liveliness analyzer. This pass is also used to mark
1669      * effectively-final local variables/parameters.
1670      */
1671 
1672     public class AssignAnalyzer extends BaseAnalyzer {
1673 
1674         /** The set of definitely assigned variables.
1675          */
1676         final Bits inits;
1677 
1678         /** The set of definitely unassigned variables.
1679          */
1680         final Bits uninits;
1681 
1682         /** The set of variables that are definitely unassigned everywhere
1683          *  in current try block. This variable is maintained lazily; it is
</pre>
<hr />
<pre>
1732             final Bits inits;
1733             final Bits uninits;
1734             final Bits exit_inits = new Bits(true);
1735             final Bits exit_uninits = new Bits(true);
1736 
1737             public AssignPendingExit(JCTree tree, final Bits inits, final Bits uninits) {
1738                 super(tree);
1739                 this.inits = inits;
1740                 this.uninits = uninits;
1741                 this.exit_inits.assign(inits);
1742                 this.exit_uninits.assign(uninits);
1743             }
1744 
1745             @Override
1746             public void resolveJump() {
1747                 inits.andSet(exit_inits);
1748                 uninits.andSet(exit_uninits);
1749             }
1750         }
1751 
<span class="line-added">1752         // Are constructors allowed to leak this reference ?</span>
<span class="line-added">1753         ThisExposability thisExposability = ALLOWED;</span>
<span class="line-added">1754 </span>
1755         public AssignAnalyzer() {
1756             this.inits = new Bits();
1757             uninits = new Bits();
1758             uninitsTry = new Bits();
1759             initsWhenTrue = new Bits(true);
1760             initsWhenFalse = new Bits(true);
1761             uninitsWhenTrue = new Bits(true);
1762             uninitsWhenFalse = new Bits(true);
1763         }
1764 
1765         private boolean isInitialConstructor = false;
1766 
1767         @Override
1768         protected void markDead() {
1769             if (!isInitialConstructor) {
1770                 inits.inclRange(returnadr, nextadr);
1771             } else {
1772                 for (int address = returnadr; address &lt; nextadr; address++) {
1773                     if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {
1774                         inits.incl(address);
</pre>
<hr />
<pre>
1860                 } else {
1861                     //log.rawWarning(pos, &quot;unreachable assignment&quot;);//DEBUG
1862                     uninits.excl(sym.adr);
1863                 }
1864             }
1865 
1866         /** If tree is either a simple name or of the form this.name or
1867          *  C.this.name, and tree represents a trackable variable,
1868          *  record an initialization of the variable.
1869          */
1870         void letInit(JCTree tree) {
1871             tree = TreeInfo.skipParens(tree);
1872             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1873                 Symbol sym = TreeInfo.symbol(tree);
1874                 if (sym.kind == VAR) {
1875                     letInit(tree.pos(), (VarSymbol)sym);
1876                 }
1877             }
1878         }
1879 
<span class="line-added">1880         void checkEmbryonicThisExposure(JCTree node) {</span>
<span class="line-added">1881             if (this.thisExposability == ALLOWED || classDef == null)</span>
<span class="line-added">1882                 return;</span>
<span class="line-added">1883 </span>
<span class="line-added">1884             // Note: for non-initial constructors, firstadr is post all instance fields.</span>
<span class="line-added">1885             for (int i = firstadr; i &lt; nextadr; i++) {</span>
<span class="line-added">1886                 VarSymbol sym = vardecls[i].sym;</span>
<span class="line-added">1887                 if (sym.owner != classDef.sym)</span>
<span class="line-added">1888                     continue;</span>
<span class="line-added">1889                 if ((sym.flags() &amp; (FINAL | HASINIT | STATIC | PARAMETER)) != FINAL)</span>
<span class="line-added">1890                     continue;</span>
<span class="line-added">1891                 if (sym.pos &lt; startPos || sym.adr &lt; firstadr)</span>
<span class="line-added">1892                     continue;</span>
<span class="line-added">1893                 if (!inits.isMember(sym.adr)) {</span>
<span class="line-added">1894                     if (this.thisExposability == BANNED) {</span>
<span class="line-added">1895                         log.error(node, Errors.ThisExposedPrematurely);</span>
<span class="line-added">1896                     } else {</span>
<span class="line-added">1897                         log.warning(node, Warnings.ThisExposedPrematurely);</span>
<span class="line-added">1898                     }</span>
<span class="line-added">1899                     return; // don&#39;t flog a dead horse.</span>
<span class="line-added">1900                 }</span>
<span class="line-added">1901             }</span>
<span class="line-added">1902         }</span>
<span class="line-added">1903 </span>
1904         /** Check that trackable variable is initialized.
1905          */
1906         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1907             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1908         }
1909 
1910         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1911             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1912                 trackable(sym) &amp;&amp;
1913                 !inits.isMember(sym.adr)) {
1914                     log.error(pos, errkey);
1915                 inits.incl(sym.adr);
1916             }
1917         }
1918 
1919         /** Utility method to reset several Bits instances.
1920          */
1921         private void resetBits(Bits... bits) {
1922             for (Bits b : bits) {
1923                 b.reset();
</pre>
<hr />
<pre>
2079                     classDef = classDefPrev;
2080                 }
2081             } finally {
2082                 lint = lintPrev;
2083             }
2084         }
2085 
2086         public void visitMethodDef(JCMethodDecl tree) {
2087             if (tree.body == null) {
2088                 return;
2089             }
2090 
2091             /*  MemberEnter can generate synthetic methods ignore them
2092              */
2093             if ((tree.sym.flags() &amp; SYNTHETIC) != 0) {
2094                 return;
2095             }
2096 
2097             Lint lintPrev = lint;
2098             lint = lint.augment(tree.sym);
<span class="line-added">2099             ThisExposability priorThisExposability = this.thisExposability;</span>
2100             try {
2101                 if (tree.body == null) {
2102                     return;
2103                 }
2104                 /*  Ignore synthetic methods, except for translated lambda methods.
2105                  */
2106                 if ((tree.sym.flags() &amp; (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {
2107                     return;
2108                 }
2109 
2110                 final Bits initsPrev = new Bits(inits);
2111                 final Bits uninitsPrev = new Bits(uninits);
2112                 int nextadrPrev = nextadr;
2113                 int firstadrPrev = firstadr;
2114                 int returnadrPrev = returnadr;
2115 
2116                 Assert.check(pendingExits.isEmpty());
2117                 boolean lastInitialConstructor = isInitialConstructor;
2118                 try {
2119                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2120 
2121                     if (!isInitialConstructor) {
2122                         firstadr = nextadr;
<span class="line-added">2123                         this.thisExposability = ALLOWED;</span>
<span class="line-added">2124                     } else {</span>
<span class="line-added">2125                         if (types.isValueBased(tree.sym.owner.type))</span>
<span class="line-added">2126                             this.thisExposability = DISCOURAGED;</span>
<span class="line-added">2127                         else if (types.isValue(tree.sym.owner.type))</span>
<span class="line-added">2128                             this.thisExposability = BANNED;</span>
<span class="line-added">2129                         else</span>
<span class="line-added">2130                             this.thisExposability = ALLOWED;</span>
2131                     }
2132                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2133                         JCVariableDecl def = l.head;
2134                         scan(def);
2135                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2136                         /*  If we are executing the code from Gen, then there can be
2137                          *  synthetic or mandated variables, ignore them.
2138                          */
2139                         initParam(def);
2140                     }
2141                     // else we are in an instance initializer block;
2142                     // leave caught unchanged.
2143                     scan(tree.body);
2144 
2145                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;
2146                     if (isInitialConstructor) {
2147                         boolean isSynthesized = (tree.sym.flags() &amp;
2148                                                  GENERATEDCONSTR) != 0;
2149                         for (int i = firstadr; i &lt; nextadr; i++) {
2150                             JCVariableDecl vardecl = vardecls[i];
</pre>
<hr />
<pre>
2173                                     } else {
2174                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2175                                     }
2176                                 } else {
2177                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2178                                 }
2179                             }
2180                         }
2181                     }
2182                     clearPendingExits(true);
2183                 } finally {
2184                     inits.assign(initsPrev);
2185                     uninits.assign(uninitsPrev);
2186                     nextadr = nextadrPrev;
2187                     firstadr = firstadrPrev;
2188                     returnadr = returnadrPrev;
2189                     isInitialConstructor = lastInitialConstructor;
2190                 }
2191             } finally {
2192                 lint = lintPrev;
<span class="line-added">2193                 this.thisExposability = priorThisExposability;</span>
2194             }
2195         }
2196 
2197         private void clearPendingExits(boolean inMethod) {
2198             List&lt;PendingExit&gt; exits = pendingExits.toList();
2199             pendingExits = new ListBuffer&lt;&gt;();
2200             while (exits.nonEmpty()) {
2201                 PendingExit exit = exits.head;
2202                 exits = exits.tail;
2203                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
2204                                  log.hasErrorOn(exit.tree.pos()),
2205                              exit.tree);
2206                 if (inMethod &amp;&amp; isInitialConstructor) {
2207                     Assert.check(exit instanceof AssignPendingExit);
2208                     inits.assign(((AssignPendingExit) exit).exit_inits);
2209                     for (int i = firstadr; i &lt; nextadr; i++) {
2210                         checkInit(exit.tree.pos(), vardecls[i].sym);
2211                     }
2212                 }
2213             }
</pre>
<hr />
<pre>
2649 
2650         @Override
2651         public void visitContinue(JCContinue tree) {
2652             recordExit(new AssignPendingExit(tree, inits, uninits));
2653         }
2654 
2655         @Override
2656         public void visitReturn(JCReturn tree) {
2657             scanExpr(tree.expr);
2658             recordExit(new AssignPendingExit(tree, inits, uninits));
2659         }
2660 
2661         public void visitThrow(JCThrow tree) {
2662             scanExpr(tree.expr);
2663             markDead();
2664         }
2665 
2666         public void visitApply(JCMethodInvocation tree) {
2667             scanExpr(tree.meth);
2668             scanExprs(tree.args);
<span class="line-added">2669             if (tree.meth.hasTag(IDENT)) {</span>
<span class="line-added">2670                 JCIdent ident = (JCIdent) tree.meth;</span>
<span class="line-added">2671                 if (ident.name != names._super &amp;&amp; !ident.sym.isStatic())</span>
<span class="line-added">2672                     checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2673             }</span>
2674         }
2675 
2676         public void visitNewClass(JCNewClass tree) {
2677             scanExpr(tree.encl);
2678             scanExprs(tree.args);
2679             scan(tree.def);
<span class="line-added">2680             if (classDef != null &amp;&amp; tree.encl == null &amp;&amp; tree.clazz.hasTag(IDENT)) {</span>
<span class="line-added">2681                 JCIdent clazz = (JCIdent) tree.clazz;</span>
<span class="line-added">2682                 if (!clazz.sym.isStatic() &amp;&amp; clazz.type.getEnclosingType().tsym == classDef.sym) {</span>
<span class="line-added">2683                     checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2684                 }</span>
<span class="line-added">2685             }</span>
2686         }
2687 
2688         @Override
2689         public void visitLambda(JCLambda tree) {
2690             final Bits prevUninits = new Bits(uninits);
2691             final Bits prevInits = new Bits(inits);
2692             int returnadrPrev = returnadr;
2693             int nextadrPrev = nextadr;
2694             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
2695             try {
2696                 returnadr = nextadr;
2697                 pendingExits = new ListBuffer&lt;&gt;();
2698                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2699                     JCVariableDecl def = l.head;
2700                     scan(def);
2701                     inits.incl(def.sym.adr);
2702                     uninits.excl(def.sym.adr);
2703                 }
2704                 if (tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2705                     scanExpr(tree.body);
</pre>
<hr />
<pre>
2728             uninitsExit.andSet(uninitsWhenTrue);
2729             if (tree.detail != null) {
2730                 inits.assign(initsWhenFalse);
2731                 uninits.assign(uninitsWhenFalse);
2732                 scanExpr(tree.detail);
2733             }
2734             inits.assign(initsExit);
2735             uninits.assign(uninitsExit);
2736         }
2737 
2738         public void visitAssign(JCAssign tree) {
2739             if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))
2740                 scanExpr(tree.lhs);
2741             scanExpr(tree.rhs);
2742             letInit(tree.lhs);
2743         }
2744 
2745         // check fields accessed through this.&lt;field&gt; are definitely
2746         // assigned before reading their value
2747         public void visitSelect(JCFieldAccess tree) {
<span class="line-modified">2748             ThisExposability priorThisExposability = this.thisExposability;</span>
<span class="line-added">2749             try {</span>
<span class="line-added">2750                 if (tree.name == names._this &amp;&amp; classDef != null &amp;&amp; tree.sym.owner == classDef.sym) {</span>
<span class="line-added">2751                     checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2752                 } else if (tree.sym.kind == VAR || tree.sym.isStatic()) {</span>
<span class="line-added">2753                     this.thisExposability = ALLOWED;</span>
<span class="line-added">2754                 }</span>
<span class="line-added">2755                 super.visitSelect(tree);</span>
2756             if (TreeInfo.isThisQualifier(tree.selected) &amp;&amp;
2757                 tree.sym.kind == VAR) {
<span class="line-modified">2758                     checkInit(tree.pos(), (VarSymbol)tree.sym);</span>
<span class="line-added">2759                 }</span>
<span class="line-added">2760             } finally {</span>
<span class="line-added">2761                  this.thisExposability = priorThisExposability;</span>
2762             }
2763         }
2764 
2765         public void visitAssignop(JCAssignOp tree) {
2766             scanExpr(tree.lhs);
2767             scanExpr(tree.rhs);
2768             letInit(tree.lhs);
2769         }
2770 
2771         public void visitUnary(JCUnary tree) {
2772             switch (tree.getTag()) {
2773             case NOT:
2774                 scanCond(tree.arg);
2775                 final Bits t = new Bits(initsWhenFalse);
2776                 initsWhenFalse.assign(initsWhenTrue);
2777                 initsWhenTrue.assign(t);
2778                 t.assign(uninitsWhenFalse);
2779                 uninitsWhenFalse.assign(uninitsWhenTrue);
2780                 uninitsWhenTrue.assign(t);
2781                 break;
</pre>
<hr />
<pre>
2805                 scanCond(tree.lhs);
2806                 final Bits initsWhenTrueLeft = new Bits(initsWhenTrue);
2807                 final Bits uninitsWhenTrueLeft = new Bits(uninitsWhenTrue);
2808                 inits.assign(initsWhenFalse);
2809                 uninits.assign(uninitsWhenFalse);
2810                 scanCond(tree.rhs);
2811                 initsWhenTrue.andSet(initsWhenTrueLeft);
2812                 uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
2813                 break;
2814             default:
2815                 scanExpr(tree.lhs);
2816                 scanExpr(tree.rhs);
2817             }
2818         }
2819 
2820         public void visitIdent(JCIdent tree) {
2821             if (tree.sym.kind == VAR) {
2822                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2823                 referenced(tree.sym);
2824             }
<span class="line-added">2825             if (tree.name == names._this) {</span>
<span class="line-added">2826                 checkEmbryonicThisExposure(tree);</span>
<span class="line-added">2827             }</span>
2828         }
2829 
2830         void referenced(Symbol sym) {
2831             unrefdResources.remove(sym);
2832         }
2833 
2834         public void visitAnnotatedType(JCAnnotatedType tree) {
2835             // annotations don&#39;t get scanned
2836             tree.underlyingType.accept(this);
2837         }
2838 
2839         public void visitModuleDef(JCModuleDecl tree) {
2840             // Do nothing for modules
2841         }
2842 
2843     /**************************************************************************
2844      * main method
2845      *************************************************************************/
2846 
2847         /** Perform definite assignment/unassignment analysis on a tree.
</pre>
</td>
</tr>
</table>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LambdaToMethod.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
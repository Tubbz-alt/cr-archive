<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.Supplier;
  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileManager;
  33 
  34 import com.sun.tools.javac.code.*;
  35 import com.sun.tools.javac.code.Attribute.Compound;
  36 import com.sun.tools.javac.code.Directive.ExportsDirective;
  37 import com.sun.tools.javac.code.Directive.RequiresDirective;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
  40 import com.sun.tools.javac.jvm.*;
  41 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  42 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  43 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  48 import com.sun.tools.javac.util.JCDiagnostic.Error;
  49 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  50 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  51 import com.sun.tools.javac.util.List;
  52 
  53 import com.sun.tools.javac.code.Lint;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Scope.WriteableScope;
  56 import com.sun.tools.javac.code.Type.*;
  57 import com.sun.tools.javac.code.Symbol.*;
  58 import com.sun.tools.javac.comp.DeferredAttr.DeferredAttrContext;
  59 import com.sun.tools.javac.tree.JCTree.*;
  60 
  61 import static com.sun.tools.javac.code.Flags.*;
  62 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  63 import static com.sun.tools.javac.code.Flags.SYNCHRONIZED;
  64 import static com.sun.tools.javac.code.Kinds.*;
  65 import static com.sun.tools.javac.code.Kinds.Kind.*;
  66 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  67 import static com.sun.tools.javac.code.TypeTag.*;
  68 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  69 
  70 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  71 
  72 /** Type checking helper class for the attribution phase.
  73  *
  74  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  75  *  If you write code that depends on this, you do so at your own risk.
  76  *  This code and its internal interfaces are subject to change or
  77  *  deletion without notice.&lt;/b&gt;
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;
<a name="1" id="anc1"></a>
  98 
  99     // The set of lint options currently in effect. It is initialized
 100     // from the context, and then is set/reset as needed by Attr as it
 101     // visits all the various parts of the trees during attribution.
 102     private Lint lint;
 103 
 104     // The method being analyzed in Attr - it is set/reset as needed by
 105     // Attr as it visits new method declarations.
 106     private MethodSymbol method;
 107 
 108     public static Check instance(Context context) {
 109         Check instance = context.get(checkKey);
 110         if (instance == null)
 111             instance = new Check(context);
 112         return instance;
 113     }
 114 
 115     protected Check(Context context) {
 116         context.put(checkKey, this);
 117 
 118         names = Names.instance(context);
 119         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 120             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 121             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 122         log = Log.instance(context);
 123         rs = Resolve.instance(context);
 124         syms = Symtab.instance(context);
 125         enter = Enter.instance(context);
 126         deferredAttr = DeferredAttr.instance(context);
 127         infer = Infer.instance(context);
 128         types = Types.instance(context);
 129         typeAnnotations = TypeAnnotations.instance(context);
 130         diags = JCDiagnostic.Factory.instance(context);
 131         Options options = Options.instance(context);
 132         lint = Lint.instance(context);
 133         fileManager = context.get(JavaFileManager.class);
 134 
 135         source = Source.instance(context);
 136         target = Target.instance(context);
 137         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
<a name="2" id="anc2"></a><span class="line-modified"> 138 </span>
 139         Target target = Target.instance(context);
 140         syntheticNameChar = target.syntheticNameChar();
 141 
 142         profile = Profile.instance(context);
 143         preview = Preview.instance(context);
 144 
 145         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 146         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 147         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 148         boolean enforceMandatoryWarnings = true;
 149 
 150         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 151                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 152         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 153                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 154         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 155                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 156         sunApiHandler = new MandatoryWarningHandler(log, false,
 157                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 158 
 159         deferredLintHandler = DeferredLintHandler.instance(context);
 160 
 161         allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 162                 Feature.RECORDS.allowedInSource(source);
 163     }
 164 
 165     /** Character for synthetic names
 166      */
 167     char syntheticNameChar;
 168 
 169     /** A table mapping flat names of all compiled classes for each module in this run
 170      *  to their symbols; maintained from outside.
 171      */
 172     private Map&lt;Pair&lt;ModuleSymbol, Name&gt;,ClassSymbol&gt; compiled = new HashMap&lt;&gt;();
 173 
 174     /** A handler for messages about deprecated usage.
 175      */
 176     private MandatoryWarningHandler deprecationHandler;
 177 
 178     /** A handler for messages about deprecated-for-removal usage.
 179      */
 180     private MandatoryWarningHandler removalHandler;
 181 
 182     /** A handler for messages about unchecked or unsafe usage.
 183      */
 184     private MandatoryWarningHandler uncheckedHandler;
 185 
 186     /** A handler for messages about using proprietary API.
 187      */
 188     private MandatoryWarningHandler sunApiHandler;
 189 
 190     /** A handler for deferred lint warnings.
 191      */
 192     private DeferredLintHandler deferredLintHandler;
 193 
 194     /** Are records allowed
 195      */
 196     private final boolean allowRecords;
 197 
 198 /* *************************************************************************
 199  * Errors and Warnings
 200  **************************************************************************/
 201 
 202     Lint setLint(Lint newLint) {
 203         Lint prev = lint;
 204         lint = newLint;
 205         return prev;
 206     }
 207 
 208     MethodSymbol setMethod(MethodSymbol newMethod) {
 209         MethodSymbol prev = method;
 210         method = newMethod;
 211         return prev;
 212     }
 213 
 214     /** Warn about deprecated symbol.
 215      *  @param pos        Position to be used for error reporting.
 216      *  @param sym        The deprecated symbol.
 217      */
 218     void warnDeprecated(DiagnosticPosition pos, Symbol sym) {
 219         if (sym.isDeprecatedForRemoval()) {
 220             if (!lint.isSuppressed(LintCategory.REMOVAL)) {
 221                 if (sym.kind == MDL) {
 222                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemovalModule(sym));
 223                 } else {
 224                     removalHandler.report(pos, Warnings.HasBeenDeprecatedForRemoval(sym, sym.location()));
 225                 }
 226             }
 227         } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {
 228             if (sym.kind == MDL) {
 229                 deprecationHandler.report(pos, Warnings.HasBeenDeprecatedModule(sym));
 230             } else {
 231                 deprecationHandler.report(pos, Warnings.HasBeenDeprecated(sym, sym.location()));
 232             }
 233         }
 234     }
 235 
 236     /** Warn about deprecated symbol.
 237      *  @param pos        Position to be used for error reporting.
 238      *  @param sym        The deprecated symbol.
 239      */
 240     void warnPreview(DiagnosticPosition pos, Symbol sym) {
 241         warnPreview(pos, Warnings.IsPreview(sym));
 242     }
 243 
 244     /** Log a preview warning.
 245      *  @param pos        Position to be used for error reporting.
 246      *  @param msg        A Warning describing the problem.
 247      */
 248     public void warnPreview(DiagnosticPosition pos, Warning warnKey) {
 249         if (!lint.isSuppressed(LintCategory.PREVIEW))
 250             preview.reportPreviewWarning(pos, warnKey);
 251     }
 252 
 253     /** Warn about unchecked operation.
 254      *  @param pos        Position to be used for error reporting.
 255      *  @param msg        A string describing the problem.
 256      */
 257     public void warnUnchecked(DiagnosticPosition pos, Warning warnKey) {
 258         if (!lint.isSuppressed(LintCategory.UNCHECKED))
 259             uncheckedHandler.report(pos, warnKey);
 260     }
 261 
 262     /** Warn about unsafe vararg method decl.
 263      *  @param pos        Position to be used for error reporting.
 264      */
 265     void warnUnsafeVararg(DiagnosticPosition pos, Warning warnKey) {
 266         if (lint.isEnabled(LintCategory.VARARGS))
 267             log.warning(LintCategory.VARARGS, pos, warnKey);
 268     }
 269 
 270     public void warnStatic(DiagnosticPosition pos, Warning warnKey) {
 271         if (lint.isEnabled(LintCategory.STATIC))
 272             log.warning(LintCategory.STATIC, pos, warnKey);
 273     }
 274 
 275     /** Warn about division by integer constant zero.
 276      *  @param pos        Position to be used for error reporting.
 277      */
 278     void warnDivZero(DiagnosticPosition pos) {
 279         if (lint.isEnabled(LintCategory.DIVZERO))
 280             log.warning(LintCategory.DIVZERO, pos, Warnings.DivZero);
 281     }
 282 
 283     /**
 284      * Report any deferred diagnostics.
 285      */
 286     public void reportDeferredDiagnostics() {
 287         deprecationHandler.reportDeferredDiagnostic();
 288         removalHandler.reportDeferredDiagnostic();
 289         uncheckedHandler.reportDeferredDiagnostic();
 290         sunApiHandler.reportDeferredDiagnostic();
 291     }
 292 
 293 
 294     /** Report a failure to complete a class.
 295      *  @param pos        Position to be used for error reporting.
 296      *  @param ex         The failure to report.
 297      */
 298     public Type completionError(DiagnosticPosition pos, CompletionFailure ex) {
 299         log.error(JCDiagnostic.DiagnosticFlag.NON_DEFERRABLE, pos, Errors.CantAccess(ex.sym, ex.getDetailValue()));
 300         return syms.errType;
 301     }
 302 
 303     /** Report an error that wrong type tag was found.
 304      *  @param pos        Position to be used for error reporting.
 305      *  @param required   An internationalized string describing the type tag
 306      *                    required.
 307      *  @param found      The type that was found.
 308      */
 309     Type typeTagError(DiagnosticPosition pos, JCDiagnostic required, Object found) {
 310         // this error used to be raised by the parser,
 311         // but has been delayed to this point:
 312         if (found instanceof Type &amp;&amp; ((Type)found).hasTag(VOID)) {
 313             log.error(pos, Errors.IllegalStartOfType);
 314             return syms.errType;
 315         }
 316         log.error(pos, Errors.TypeFoundReq(found, required));
 317         return types.createErrorType(found instanceof Type ? (Type)found : syms.errType);
 318     }
 319 
 320     /** Report an error that symbol cannot be referenced before super
 321      *  has been called.
 322      *  @param pos        Position to be used for error reporting.
 323      *  @param sym        The referenced symbol.
 324      */
 325     void earlyRefError(DiagnosticPosition pos, Symbol sym) {
 326         log.error(pos, Errors.CantRefBeforeCtorCalled(sym));
 327     }
 328 
 329     /** Report duplicate declaration error.
 330      */
 331     void duplicateError(DiagnosticPosition pos, Symbol sym) {
 332         if (!sym.type.isErroneous()) {
 333             Symbol location = sym.location();
 334             if (location.kind == MTH &amp;&amp;
 335                     ((MethodSymbol)location).isStaticOrInstanceInit()) {
 336                 log.error(pos,
 337                           Errors.AlreadyDefinedInClinit(kindName(sym),
 338                                                         sym,
 339                                                         kindName(sym.location()),
 340                                                         kindName(sym.location().enclClass()),
 341                                                         sym.location().enclClass()));
 342             } else {
 343                 /* dont error if this is a duplicated parameter of a generated canonical constructor
 344                  * as we should have issued an error for the duplicated fields
 345                  */
 346                 if (location.kind != MTH ||
 347                         ((sym.owner.flags_field &amp; GENERATEDCONSTR) == 0) ||
 348                         ((sym.owner.flags_field &amp; RECORD) == 0)) {
 349                     log.error(pos,
 350                             Errors.AlreadyDefined(kindName(sym),
 351                                     sym,
 352                                     kindName(sym.location()),
 353                                     sym.location()));
 354                 }
 355             }
 356         }
 357     }
 358 
 359     /** Report array/varargs duplicate declaration
 360      */
 361     void varargsDuplicateError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
 362         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
 363             log.error(pos, Errors.ArrayAndVarargs(sym1, sym2, sym2.location()));
 364         }
 365     }
 366 
 367 /* ************************************************************************
 368  * duplicate declaration checking
 369  *************************************************************************/
 370 
 371     /** Check that variable does not hide variable with same name in
 372      *  immediately enclosing local scope.
 373      *  @param pos           Position for error reporting.
 374      *  @param v             The symbol.
 375      *  @param s             The scope.
 376      */
 377     void checkTransparentVar(DiagnosticPosition pos, VarSymbol v, Scope s) {
 378         for (Symbol sym : s.getSymbolsByName(v.name)) {
 379             if (sym.owner != v.owner) break;
 380             if (sym.kind == VAR &amp;&amp;
 381                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 382                 v.name != names.error) {
 383                 duplicateError(pos, sym);
 384                 return;
 385             }
 386         }
 387     }
 388 
 389     /** Check that a class or interface does not hide a class or
 390      *  interface with same name in immediately enclosing local scope.
 391      *  @param pos           Position for error reporting.
 392      *  @param c             The symbol.
 393      *  @param s             The scope.
 394      */
 395     void checkTransparentClass(DiagnosticPosition pos, ClassSymbol c, Scope s) {
 396         for (Symbol sym : s.getSymbolsByName(c.name)) {
 397             if (sym.owner != c.owner) break;
 398             if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR) &amp;&amp;
 399                 sym.owner.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
 400                 c.name != names.error) {
 401                 duplicateError(pos, sym);
 402                 return;
 403             }
 404         }
 405     }
 406 
 407     /** Check that class does not have the same name as one of
 408      *  its enclosing classes, or as a class defined in its enclosing scope.
 409      *  return true if class is unique in its enclosing scope.
 410      *  @param pos           Position for error reporting.
 411      *  @param name          The class name.
 412      *  @param s             The enclosing scope.
 413      */
 414     boolean checkUniqueClassName(DiagnosticPosition pos, Name name, Scope s) {
 415         for (Symbol sym : s.getSymbolsByName(name, NON_RECURSIVE)) {
 416             if (sym.kind == TYP &amp;&amp; sym.name != names.error) {
 417                 duplicateError(pos, sym);
 418                 return false;
 419             }
 420         }
 421         for (Symbol sym = s.owner; sym != null; sym = sym.owner) {
 422             if (sym.kind == TYP &amp;&amp; sym.name == name &amp;&amp; sym.name != names.error) {
 423                 duplicateError(pos, sym);
 424                 return true;
 425             }
 426         }
 427         return true;
 428     }
 429 
 430 /* *************************************************************************
 431  * Class name generation
 432  **************************************************************************/
 433 
 434 
 435     private Map&lt;Pair&lt;Name, Name&gt;, Integer&gt; localClassNameIndexes = new HashMap&lt;&gt;();
 436 
 437     /** Return name of local class.
 438      *  This is of the form   {@code &lt;enclClass&gt; $ n &lt;classname&gt; }
 439      *  where
 440      *    enclClass is the flat name of the enclosing class,
 441      *    classname is the simple name of the local class
 442      */
 443     public Name localClassName(ClassSymbol c) {
 444         Name enclFlatname = c.owner.enclClass().flatname;
 445         String enclFlatnameStr = enclFlatname.toString();
 446         Pair&lt;Name, Name&gt; key = new Pair&lt;&gt;(enclFlatname, c.name);
 447         Integer index = localClassNameIndexes.get(key);
 448         for (int i = (index == null) ? 1 : index; ; i++) {
 449             Name flatname = names.fromString(enclFlatnameStr
 450                     + syntheticNameChar + i + c.name);
 451             if (getCompiled(c.packge().modle, flatname) == null) {
 452                 localClassNameIndexes.put(key, i + 1);
 453                 return flatname;
 454             }
 455         }
 456     }
 457 
 458     public void clearLocalClassNameIndexes(ClassSymbol c) {
 459         if (c.owner != null &amp;&amp; c.owner.kind != NIL) {
 460             localClassNameIndexes.remove(new Pair&lt;&gt;(
 461                     c.owner.enclClass().flatname, c.name));
 462         }
 463     }
 464 
 465     public void newRound() {
 466         compiled.clear();
 467         localClassNameIndexes.clear();
 468     }
 469 
 470     public void clear() {
 471         deprecationHandler.clear();
 472         removalHandler.clear();
 473         uncheckedHandler.clear();
 474         sunApiHandler.clear();
 475     }
 476 
 477     public void putCompiled(ClassSymbol csym) {
 478         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 479     }
 480 
 481     public ClassSymbol getCompiled(ClassSymbol csym) {
 482         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 483     }
 484 
 485     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 486         return compiled.get(Pair.of(msym, flatname));
 487     }
 488 
 489     public void removeCompiled(ClassSymbol csym) {
 490         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 491     }
 492 
<a name="3" id="anc3"></a><span class="line-modified"> 493 /* *************************************************************************</span>
 494  * Type Checking
 495  **************************************************************************/
 496 
 497     /**
 498      * A check context is an object that can be used to perform compatibility
 499      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 500      * vary significantly.
 501      */
 502     public interface CheckContext {
 503         /**
 504          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 505          */
 506         boolean compatible(Type found, Type req, Warner warn);
 507         /**
 508          * Report a check error
 509          */
 510         void report(DiagnosticPosition pos, JCDiagnostic details);
 511         /**
 512          * Obtain a warner for this check context
 513          */
 514         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req);
 515 
 516         public InferenceContext inferenceContext();
 517 
 518         public DeferredAttr.DeferredAttrContext deferredAttrContext();
 519     }
 520 
 521     /**
 522      * This class represent a check context that is nested within another check
 523      * context - useful to check sub-expressions. The default behavior simply
 524      * redirects all method calls to the enclosing check context leveraging
 525      * the forwarding pattern.
 526      */
 527     static class NestedCheckContext implements CheckContext {
 528         CheckContext enclosingContext;
 529 
 530         NestedCheckContext(CheckContext enclosingContext) {
 531             this.enclosingContext = enclosingContext;
 532         }
 533 
 534         public boolean compatible(Type found, Type req, Warner warn) {
 535             return enclosingContext.compatible(found, req, warn);
 536         }
 537 
 538         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 539             enclosingContext.report(pos, details);
 540         }
 541 
 542         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 543             return enclosingContext.checkWarner(pos, found, req);
 544         }
 545 
 546         public InferenceContext inferenceContext() {
 547             return enclosingContext.inferenceContext();
 548         }
 549 
 550         public DeferredAttrContext deferredAttrContext() {
 551             return enclosingContext.deferredAttrContext();
 552         }
 553     }
 554 
 555     /**
 556      * Check context to be used when evaluating assignment/return statements
 557      */
 558     CheckContext basicHandler = new CheckContext() {
 559         public void report(DiagnosticPosition pos, JCDiagnostic details) {
 560             log.error(pos, Errors.ProbFoundReq(details));
 561         }
 562         public boolean compatible(Type found, Type req, Warner warn) {
 563             return types.isAssignable(found, req, warn);
 564         }
 565 
 566         public Warner checkWarner(DiagnosticPosition pos, Type found, Type req) {
 567             return convertWarner(pos, found, req);
 568         }
 569 
 570         public InferenceContext inferenceContext() {
 571             return infer.emptyContext;
 572         }
 573 
 574         public DeferredAttrContext deferredAttrContext() {
 575             return deferredAttr.emptyDeferredAttrContext;
 576         }
 577 
 578         @Override
 579         public String toString() {
 580             return &quot;CheckContext: basicHandler&quot;;
 581         }
 582     };
 583 
 584     /** Check that a given type is assignable to a given proto-type.
 585      *  If it is, return the type, otherwise return errType.
 586      *  @param pos        Position to be used for error reporting.
 587      *  @param found      The type that was found.
 588      *  @param req        The type that was required.
 589      */
 590     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 591         return checkType(pos, found, req, basicHandler);
 592     }
 593 
 594     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 595         final InferenceContext inferenceContext = checkContext.inferenceContext();
 596         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 597             inferenceContext.addFreeTypeListener(List.of(req, found),
 598                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
<a name="4" id="anc4"></a>




 599         }
 600         if (req.hasTag(ERROR))
 601             return req;
 602         if (req.hasTag(NONE))
 603             return found;
 604         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
<a name="5" id="anc5"></a>


 605             return found;
 606         } else {
 607             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 608                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 609                 return types.createErrorType(found);
 610             }
 611             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 612             return types.createErrorType(found);
 613         }
 614     }
 615 
 616     /** Check that a given type can be cast to a given target type.
 617      *  Return the result of the cast.
 618      *  @param pos        Position to be used for error reporting.
 619      *  @param found      The type that is being cast.
 620      *  @param req        The target type of the cast.
 621      */
 622     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 623         return checkCastable(pos, found, req, basicHandler);
 624     }
 625     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 626         if (types.isCastable(found, req, castWarner(pos, found, req))) {
<a name="6" id="anc6"></a>






 627             return req;
 628         } else {
 629             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 630             return types.createErrorType(found);
 631         }
 632     }
 633 
 634     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 635      * The problem should only be reported for non-292 cast
 636      */
 637     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 638         if (!tree.type.isErroneous()
 639                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 640                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 641                 &amp;&amp; !is292targetTypeCast(tree)) {
 642             deferredLintHandler.report(() -&gt; {
 643                 if (lint.isEnabled(LintCategory.CAST))
 644                     log.warning(LintCategory.CAST,
 645                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 646             });
 647         }
 648     }
 649     //where
 650         private boolean is292targetTypeCast(JCTypeCast tree) {
 651             boolean is292targetTypeCast = false;
 652             JCExpression expr = TreeInfo.skipParens(tree.expr);
 653             if (expr.hasTag(APPLY)) {
 654                 JCMethodInvocation apply = (JCMethodInvocation)expr;
 655                 Symbol sym = TreeInfo.symbol(apply.meth);
 656                 is292targetTypeCast = sym != null &amp;&amp;
 657                     sym.kind == MTH &amp;&amp;
 658                     (sym.flags() &amp; HYPOTHETICAL) != 0;
 659             }
 660             return is292targetTypeCast;
 661         }
 662 
 663         private static final boolean ignoreAnnotatedCasts = true;
 664 
 665     /** Check that a type is within some bounds.
 666      *
 667      *  Used in TypeApply to verify that, e.g., X in {@code V&lt;X&gt;} is a valid
 668      *  type argument.
 669      *  @param a             The type that should be bounded by bs.
 670      *  @param bound         The bound.
 671      */
 672     private boolean checkExtends(Type a, Type bound) {
 673          if (a.isUnbound()) {
 674              return true;
 675          } else if (!a.hasTag(WILDCARD)) {
 676              a = types.cvarUpperBound(a);
 677              return types.isSubtype(a, bound);
 678          } else if (a.isExtendsBound()) {
 679              return types.isCastable(bound, types.wildUpperBound(a), types.noWarnings);
 680          } else if (a.isSuperBound()) {
 681              return !types.notSoftSubtype(types.wildLowerBound(a), bound);
 682          }
 683          return true;
 684      }
 685 
 686     /** Check that type is different from &#39;void&#39;.
 687      *  @param pos           Position to be used for error reporting.
 688      *  @param t             The type to be checked.
 689      */
 690     Type checkNonVoid(DiagnosticPosition pos, Type t) {
 691         if (t.hasTag(VOID)) {
 692             log.error(pos, Errors.VoidNotAllowedHere);
 693             return types.createErrorType(t);
 694         } else {
 695             return t;
 696         }
 697     }
 698 
 699     Type checkClassOrArrayType(DiagnosticPosition pos, Type t) {
 700         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ARRAY) &amp;&amp; !t.hasTag(ERROR)) {
 701             return typeTagError(pos,
 702                                 diags.fragment(Fragments.TypeReqClassArray),
 703                                 asTypeParam(t));
 704         } else {
 705             return t;
 706         }
 707     }
 708 
 709     /** Check that type is a class or interface type.
 710      *  @param pos           Position to be used for error reporting.
 711      *  @param t             The type to be checked.
 712      */
 713     Type checkClassType(DiagnosticPosition pos, Type t) {
 714         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 715             return typeTagError(pos,
 716                                 diags.fragment(Fragments.TypeReqClass),
 717                                 asTypeParam(t));
 718         } else {
 719             return t;
 720         }
 721     }
 722     //where
 723         private Object asTypeParam(Type t) {
 724             return (t.hasTag(TYPEVAR))
 725                                     ? diags.fragment(Fragments.TypeParameter(t))
 726                                     : t;
 727         }
 728 
<a name="7" id="anc7"></a>










































 729     /** Check that type is a valid qualifier for a constructor reference expression
 730      */
 731     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 732         t = checkClassOrArrayType(pos, t);
 733         if (t.hasTag(CLASS)) {
 734             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 735                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 736                 t = types.createErrorType(t);
 737             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 738                 log.error(pos, Errors.EnumCantBeInstantiated);
 739                 t = types.createErrorType(t);
 740             } else {
 741                 t = checkClassType(pos, t, true);
 742             }
 743         } else if (t.hasTag(ARRAY)) {
 744             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 745                 log.error(pos, Errors.GenericArrayCreation);
 746                 t = types.createErrorType(t);
 747             }
 748         }
 749         return t;
 750     }
 751 
 752     /** Check that type is a class or interface type.
 753      *  @param pos           Position to be used for error reporting.
 754      *  @param t             The type to be checked.
 755      *  @param noBounds    True if type bounds are illegal here.
 756      */
 757     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 758         t = checkClassType(pos, t);
 759         if (noBounds &amp;&amp; t.isParameterized()) {
 760             List&lt;Type&gt; args = t.getTypeArguments();
 761             while (args.nonEmpty()) {
 762                 if (args.head.hasTag(WILDCARD))
 763                     return typeTagError(pos,
 764                                         diags.fragment(Fragments.TypeReqExact),
 765                                         args.head);
 766                 args = args.tail;
 767             }
 768         }
 769         return t;
 770     }
 771 
 772     /** Check that type is a reference type, i.e. a class, interface or array type
 773      *  or a type variable.
 774      *  @param pos           Position to be used for error reporting.
 775      *  @param t             The type to be checked.
<a name="8" id="anc8"></a>
 776      */
<a name="9" id="anc9"></a><span class="line-modified"> 777     Type checkRefType(DiagnosticPosition pos, Type t) {</span>
<span class="line-modified"> 778         if (t.isReference())</span>
 779             return t;
 780         else
 781             return typeTagError(pos,
 782                                 diags.fragment(Fragments.TypeReqRef),
 783                                 t);
 784     }
 785 
<a name="10" id="anc10"></a>








 786     /** Check that each type is a reference type, i.e. a class, interface or array type
 787      *  or a type variable.
 788      *  @param trees         Original trees, used for error reporting.
 789      *  @param types         The types to be checked.
 790      */
 791     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 792         List&lt;JCExpression&gt; tl = trees;
 793         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
<a name="11" id="anc11"></a><span class="line-modified"> 794             l.head = checkRefType(tl.head.pos(), l.head);</span>
 795             tl = tl.tail;
 796         }
 797         return types;
 798     }
 799 
 800     /** Check that type is a null or reference type.
 801      *  @param pos           Position to be used for error reporting.
 802      *  @param t             The type to be checked.
 803      */
 804     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 805         if (t.isReference() || t.hasTag(BOT))
 806             return t;
 807         else
 808             return typeTagError(pos,
 809                                 diags.fragment(Fragments.TypeReqRef),
 810                                 t);
 811     }
 812 
 813     /** Check that flag set does not contain elements of two conflicting sets. s
 814      *  Return true if it doesn&#39;t.
 815      *  @param pos           Position to be used for error reporting.
 816      *  @param flags         The set of flags to be checked.
 817      *  @param set1          Conflicting flags set #1.
 818      *  @param set2          Conflicting flags set #2.
 819      */
 820     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 821         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 822             log.error(pos,
 823                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 824                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 825             return false;
 826         } else
 827             return true;
 828     }
 829 
<a name="12" id="anc12"></a>















































 830     /** Check that usage of diamond operator is correct (i.e. diamond should not
 831      * be used with non-generic classes or in anonymous class creation expressions)
 832      */
 833     Type checkDiamond(JCNewClass tree, Type t) {
 834         if (!TreeInfo.isDiamond(tree) ||
 835                 t.isErroneous()) {
 836             return checkClassType(tree.clazz.pos(), t, true);
 837         } else {
 838             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 839                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 840                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 841             }
 842             if (t.tsym.type.getTypeArguments().isEmpty()) {
 843                 log.error(tree.clazz.pos(),
 844                           Errors.CantApplyDiamond1(t,
 845                                                    Fragments.DiamondNonGeneric(t)));
 846                 return types.createErrorType(t);
 847             } else if (tree.typeargs != null &amp;&amp;
 848                     tree.typeargs.nonEmpty()) {
 849                 log.error(tree.clazz.pos(),
 850                           Errors.CantApplyDiamond1(t,
 851                                                    Fragments.DiamondAndExplicitParams(t)));
 852                 return types.createErrorType(t);
 853             } else {
 854                 return t;
 855             }
 856         }
 857     }
 858 
 859     /** Check that the type inferred using the diamond operator does not contain
 860      *  non-denotable types such as captured types or intersection types.
 861      *  @param t the type inferred using the diamond operator
 862      *  @return  the (possibly empty) list of non-denotable types.
 863      */
 864     List&lt;Type&gt; checkDiamondDenotable(ClassType t) {
 865         ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
 866         for (Type arg : t.allparams()) {
 867             if (!checkDenotable(arg)) {
 868                 buf.append(arg);
 869             }
 870         }
 871         return buf.toList();
 872     }
 873 
 874     public boolean checkDenotable(Type t) {
 875         return denotableChecker.visit(t, null);
 876     }
 877         // where
 878 
 879         /** diamondTypeChecker: A type visitor that descends down the given type looking for non-denotable
 880          *  types. The visit methods return false as soon as a non-denotable type is encountered and true
 881          *  otherwise.
 882          */
 883         private static final Types.SimpleVisitor&lt;Boolean, Void&gt; denotableChecker = new Types.SimpleVisitor&lt;Boolean, Void&gt;() {
 884             @Override
 885             public Boolean visitType(Type t, Void s) {
 886                 return true;
 887             }
 888             @Override
 889             public Boolean visitClassType(ClassType t, Void s) {
 890                 if (t.isUnion() || t.isIntersection()) {
 891                     return false;
 892                 }
 893                 for (Type targ : t.allparams()) {
 894                     if (!visit(targ, s)) {
 895                         return false;
 896                     }
 897                 }
 898                 return true;
 899             }
 900 
 901             @Override
 902             public Boolean visitTypeVar(TypeVar t, Void s) {
 903                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
 904                   (i.e cannot have been produced by inference (18.4))
 905                 */
 906                 return (t.tsym.flags() &amp; SYNTHETIC) == 0;
 907             }
 908 
 909             @Override
 910             public Boolean visitCapturedType(CapturedType t, Void s) {
 911                 /* Any type variable mentioned in the inferred type must have been declared as a type parameter
 912                   (i.e cannot have been produced by capture conversion (5.1.10))
 913                 */
 914                 return false;
 915             }
 916 
 917             @Override
 918             public Boolean visitArrayType(ArrayType t, Void s) {
 919                 return visit(t.elemtype, s);
 920             }
 921 
 922             @Override
 923             public Boolean visitWildcardType(WildcardType t, Void s) {
 924                 return visit(t.type, s);
 925             }
 926         };
 927 
 928     void checkVarargsMethodDecl(Env&lt;AttrContext&gt; env, JCMethodDecl tree) {
 929         MethodSymbol m = tree.sym;
 930         boolean hasTrustMeAnno = m.attribute(syms.trustMeType.tsym) != null;
 931         Type varargElemType = null;
 932         if (m.isVarArgs()) {
 933             varargElemType = types.elemtype(tree.params.last().type);
 934         }
 935         if (hasTrustMeAnno &amp;&amp; !isTrustMeAllowedOnMethod(m)) {
 936             if (varargElemType != null) {
 937                 JCDiagnostic msg = Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ?
 938                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargs(m)) :
 939                         diags.fragment(Fragments.VarargsTrustmeOnVirtualVarargsFinalOnly(m));
 940                 log.error(tree,
 941                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
 942                                                            msg));
 943             } else {
 944                 log.error(tree,
 945                           Errors.VarargsInvalidTrustmeAnno(syms.trustMeType.tsym,
 946                                                            Fragments.VarargsTrustmeOnNonVarargsMeth(m)));
 947             }
 948         } else if (hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
 949                             types.isReifiable(varargElemType)) {
 950             warnUnsafeVararg(tree, Warnings.VarargsRedundantTrustmeAnno(
 951                                 syms.trustMeType.tsym,
 952                                 diags.fragment(Fragments.VarargsTrustmeOnReifiableVarargs(varargElemType))));
 953         }
 954         else if (!hasTrustMeAnno &amp;&amp; varargElemType != null &amp;&amp;
 955                 !types.isReifiable(varargElemType)) {
 956             warnUnchecked(tree.params.head.pos(), Warnings.UncheckedVarargsNonReifiableType(varargElemType));
 957         }
 958     }
 959     //where
 960         private boolean isTrustMeAllowedOnMethod(Symbol s) {
 961             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
 962                 (s.isConstructor() ||
 963                     (s.flags() &amp; (STATIC | FINAL |
 964                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
 965         }
 966 
 967     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
 968         //check that resulting type is not the null type
 969         if (t.hasTag(BOT)) {
 970             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
 971             return types.createErrorType(t);
 972         } else if (t.hasTag(VOID)) {
 973             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
 974             return types.createErrorType(t);
 975         }
 976 
 977         //upward project the initializer type
<a name="13" id="anc13"></a><span class="line-modified"> 978         return types.upward(t, types.captures(t));</span>





































 979     }
 980 
 981     Type checkMethod(final Type mtype,
 982             final Symbol sym,
 983             final Env&lt;AttrContext&gt; env,
 984             final List&lt;JCExpression&gt; argtrees,
 985             final List&lt;Type&gt; argtypes,
 986             final boolean useVarargs,
 987             InferenceContext inferenceContext) {
 988         // System.out.println(&quot;call   : &quot; + env.tree);
 989         // System.out.println(&quot;method : &quot; + owntype);
 990         // System.out.println(&quot;actuals: &quot; + argtypes);
 991         if (inferenceContext.free(mtype)) {
 992             inferenceContext.addFreeTypeListener(List.of(mtype),
 993                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
 994             return mtype;
 995         }
 996         Type owntype = mtype;
 997         List&lt;Type&gt; formals = owntype.getParameterTypes();
 998         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
 999         if (nonInferred.length() != formals.length()) nonInferred = formals;
1000         Type last = useVarargs ? formals.last() : null;
1001         if (sym.name == names.init &amp;&amp; sym.owner == syms.enumSym) {
1002             formals = formals.tail.tail;
1003             nonInferred = nonInferred.tail.tail;
1004         }
1005         if ((sym.flags() &amp; ANONCONSTR_BASED) != 0) {
1006             formals = formals.tail;
1007             nonInferred = nonInferred.tail;
1008         }
1009         List&lt;JCExpression&gt; args = argtrees;
1010         if (args != null) {
1011             //this is null when type-checking a method reference
1012             while (formals.head != last) {
1013                 JCTree arg = args.head;
1014                 Warner warn = convertWarner(arg.pos(), arg.type, nonInferred.head);
1015                 assertConvertible(arg, arg.type, formals.head, warn);
1016                 args = args.tail;
1017                 formals = formals.tail;
1018                 nonInferred = nonInferred.tail;
1019             }
1020             if (useVarargs) {
1021                 Type varArg = types.elemtype(last);
1022                 while (args.tail != null) {
1023                     JCTree arg = args.head;
1024                     Warner warn = convertWarner(arg.pos(), arg.type, varArg);
1025                     assertConvertible(arg, arg.type, varArg, warn);
1026                     args = args.tail;
1027                 }
1028             } else if ((sym.flags() &amp; (VARARGS | SIGNATURE_POLYMORPHIC)) == VARARGS) {
1029                 // non-varargs call to varargs method
1030                 Type varParam = owntype.getParameterTypes().last();
1031                 Type lastArg = argtypes.last();
1032                 if (types.isSubtypeUnchecked(lastArg, types.elemtype(varParam)) &amp;&amp;
1033                     !types.isSameType(types.erasure(varParam), types.erasure(lastArg)))
1034                     log.warning(argtrees.last().pos(),
1035                                 Warnings.InexactNonVarargsCall(types.elemtype(varParam),varParam));
1036             }
1037         }
1038         if (useVarargs) {
1039             Type argtype = owntype.getParameterTypes().last();
1040             if (!types.isReifiable(argtype) &amp;&amp;
1041                 (sym.baseSymbol().attribute(syms.trustMeType.tsym) == null ||
1042                  !isTrustMeAllowedOnMethod(sym))) {
1043                 warnUnchecked(env.tree.pos(), Warnings.UncheckedGenericArrayCreation(argtype));
1044             }
1045             TreeInfo.setVarargsElement(env.tree, types.elemtype(argtype));
1046          }
1047          return owntype;
1048     }
1049     //where
1050     private void assertConvertible(JCTree tree, Type actual, Type formal, Warner warn) {
1051         if (types.isConvertible(actual, formal, warn))
1052             return;
1053 
1054         if (formal.isCompound()
1055             &amp;&amp; types.isSubtype(actual, types.supertype(formal))
1056             &amp;&amp; types.isSubtypeUnchecked(actual, types.interfaces(formal), warn))
1057             return;
1058     }
1059 
1060     /**
1061      * Check that type &#39;t&#39; is a valid instantiation of a generic class
1062      * (see JLS 4.5)
1063      *
1064      * @param t class type to be checked
1065      * @return true if &#39;t&#39; is well-formed
1066      */
1067     public boolean checkValidGenericType(Type t) {
1068         return firstIncompatibleTypeArg(t) == null;
1069     }
1070     //WHERE
1071         private Type firstIncompatibleTypeArg(Type type) {
1072             List&lt;Type&gt; formals = type.tsym.type.allparams();
1073             List&lt;Type&gt; actuals = type.allparams();
1074             List&lt;Type&gt; args = type.getTypeArguments();
1075             List&lt;Type&gt; forms = type.tsym.type.getTypeArguments();
1076             ListBuffer&lt;Type&gt; bounds_buf = new ListBuffer&lt;&gt;();
1077 
1078             // For matching pairs of actual argument types `a&#39; and
1079             // formal type parameters with declared bound `b&#39; ...
1080             while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1081                 // exact type arguments needs to know their
1082                 // bounds (for upper and lower bound
1083                 // calculations).  So we create new bounds where
1084                 // type-parameters are replaced with actuals argument types.
1085                 bounds_buf.append(types.subst(forms.head.getUpperBound(), formals, actuals));
1086                 args = args.tail;
1087                 forms = forms.tail;
1088             }
1089 
1090             args = type.getTypeArguments();
1091             List&lt;Type&gt; tvars_cap = types.substBounds(formals,
1092                                       formals,
1093                                       types.capture(type).allparams());
1094             while (args.nonEmpty() &amp;&amp; tvars_cap.nonEmpty()) {
1095                 // Let the actual arguments know their bound
1096                 args.head.withTypeVar((TypeVar)tvars_cap.head);
1097                 args = args.tail;
1098                 tvars_cap = tvars_cap.tail;
1099             }
1100 
1101             args = type.getTypeArguments();
1102             List&lt;Type&gt; bounds = bounds_buf.toList();
1103 
1104             while (args.nonEmpty() &amp;&amp; bounds.nonEmpty()) {
1105                 Type actual = args.head;
1106                 if (!isTypeArgErroneous(actual) &amp;&amp;
1107                         !bounds.head.isErroneous() &amp;&amp;
1108                         !checkExtends(actual, bounds.head)) {
1109                     return args.head;
1110                 }
1111                 args = args.tail;
1112                 bounds = bounds.tail;
1113             }
1114 
1115             args = type.getTypeArguments();
1116             bounds = bounds_buf.toList();
1117 
1118             for (Type arg : types.capture(type).getTypeArguments()) {
1119                 if (arg.hasTag(TYPEVAR) &amp;&amp;
1120                         arg.getUpperBound().isErroneous() &amp;&amp;
1121                         !bounds.head.isErroneous() &amp;&amp;
1122                         !isTypeArgErroneous(args.head)) {
1123                     return args.head;
1124                 }
1125                 bounds = bounds.tail;
1126                 args = args.tail;
1127             }
1128 
1129             return null;
1130         }
1131         //where
1132         boolean isTypeArgErroneous(Type t) {
1133             return isTypeArgErroneous.visit(t);
1134         }
1135 
1136         Types.UnaryVisitor&lt;Boolean&gt; isTypeArgErroneous = new Types.UnaryVisitor&lt;Boolean&gt;() {
1137             public Boolean visitType(Type t, Void s) {
1138                 return t.isErroneous();
1139             }
1140             @Override
1141             public Boolean visitTypeVar(TypeVar t, Void s) {
1142                 return visit(t.getUpperBound());
1143             }
1144             @Override
1145             public Boolean visitCapturedType(CapturedType t, Void s) {
1146                 return visit(t.getUpperBound()) ||
1147                         visit(t.getLowerBound());
1148             }
1149             @Override
1150             public Boolean visitWildcardType(WildcardType t, Void s) {
1151                 return visit(t.type);
1152             }
1153         };
1154 
1155     /** Check that given modifiers are legal for given symbol and
1156      *  return modifiers together with any implicit modifiers for that symbol.
1157      *  Warning: we can&#39;t use flags() here since this method
1158      *  is called during class enter, when flags() would cause a premature
1159      *  completion.
1160      *  @param pos           Position to be used for error reporting.
1161      *  @param flags         The set of modifiers given in a definition.
1162      *  @param sym           The defined symbol.
1163      */
1164     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1165         long mask;
1166         long implicit = 0;
1167 
1168         switch (sym.kind) {
1169         case VAR:
1170             if (TreeInfo.isReceiverParam(tree))
1171                 mask = ReceiverParamFlags;
1172             else if (sym.owner.kind != TYP)
1173                 mask = LocalVarFlags;
1174             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1175                 mask = implicit = InterfaceVarFlags;
<a name="14" id="anc14"></a><span class="line-modified">1176             else</span>
1177                 mask = VarFlags;
<a name="15" id="anc15"></a>



1178             break;
1179         case MTH:
1180             if (sym.name == names.init) {
1181                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1182                     // enum constructors cannot be declared public or
1183                     // protected and must be implicitly or explicitly
1184                     // private
1185                     implicit = PRIVATE;
1186                     mask = PRIVATE;
1187                 } else
1188                     mask = ConstructorFlags;
1189             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1190                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1191                     mask = AnnotationTypeElementMask;
1192                     implicit = PUBLIC | ABSTRACT;
1193                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1194                     mask = InterfaceMethodMask;
1195                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1196                     if ((flags &amp; DEFAULT) != 0) {
1197                         implicit |= ABSTRACT;
1198                     }
1199                 } else {
1200                     mask = implicit = InterfaceMethodFlags;
1201                 }
1202             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1203                 mask = RecordMethodFlags;
1204             } else {
<a name="16" id="anc16"></a><span class="line-modified">1205                 mask = MethodFlags;</span>


1206             }
1207             // Imply STRICTFP if owner has STRICTFP set.
1208             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1209                 ((flags) &amp; Flags.DEFAULT) != 0)
1210                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1211             break;
1212         case TYP:
1213             if (sym.isLocal()) {
1214                 mask = (flags &amp; RECORD) != 0 ? LocalRecordFlags : LocalClassFlags;
1215                 if ((flags &amp; RECORD) != 0) {
1216                     implicit = STATIC;
1217                     if (sym.owner.kind == TYP) {
1218                         log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1219                     }
1220                 }
1221                 if ((sym.owner.flags_field &amp; STATIC) == 0 &amp;&amp;
1222                     (flags &amp; ENUM) != 0) {
1223                     log.error(pos, Errors.EnumsMustBeStatic);
1224                 }
1225             } else if (sym.owner.kind == TYP) {
1226                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;
1227                 if (sym.owner.owner.kind == PCK ||
1228                     (sym.owner.flags_field &amp; STATIC) != 0)
1229                     mask |= STATIC;
1230                 else if ((flags &amp; ENUM) != 0) {
1231                     log.error(pos, Errors.EnumsMustBeStatic);
1232                 } else if ((flags &amp; RECORD) != 0) {
1233                     log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1234                 }
1235                 // Nested interfaces and enums are always STATIC (Spec ???)
1236                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1237             } else {
1238                 mask = ClassFlags;
1239             }
1240             // Interfaces are always ABSTRACT
1241             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1242 
1243             if ((flags &amp; ENUM) != 0) {
<a name="17" id="anc17"></a><span class="line-modified">1244                 // enums can&#39;t be declared abstract or final</span>
<span class="line-modified">1245                 mask &amp;= ~(ABSTRACT | FINAL);</span>
1246                 implicit |= implicitEnumFinalFlag(tree);
1247             }
1248             if ((flags &amp; RECORD) != 0) {
1249                 // records can&#39;t be declared abstract
1250                 mask &amp;= ~ABSTRACT;
1251                 implicit |= FINAL;
1252             }
1253             // Imply STRICTFP if owner has STRICTFP set.
1254             implicit |= sym.owner.flags_field &amp; STRICTFP;
1255             break;
1256         default:
1257             throw new AssertionError();
1258         }
1259         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1260         if (illegal != 0) {
1261             if ((illegal &amp; INTERFACE) != 0) {
1262                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1263                 mask |= INTERFACE;
1264             }
1265             else {
1266                 log.error(pos,
1267                           Errors.ModNotAllowedHere(asFlagSet(illegal)));
1268             }
1269         }
1270         else if ((sym.kind == TYP ||
1271                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1272                   // in the presence of inner classes. Should it be deleted here?
1273                   checkDisjoint(pos, flags,
1274                                 ABSTRACT,
1275                                 PRIVATE | STATIC | DEFAULT))
1276                  &amp;&amp;
1277                  checkDisjoint(pos, flags,
1278                                 STATIC | PRIVATE,
1279                                 DEFAULT)
1280                  &amp;&amp;
1281                  checkDisjoint(pos, flags,
1282                                ABSTRACT | INTERFACE,
<a name="18" id="anc18"></a><span class="line-modified">1283                                FINAL | NATIVE | SYNCHRONIZED)</span>
1284                  &amp;&amp;
1285                  checkDisjoint(pos, flags,
1286                                PUBLIC,
1287                                PRIVATE | PROTECTED)
1288                  &amp;&amp;
1289                  checkDisjoint(pos, flags,
1290                                PRIVATE,
1291                                PUBLIC | PROTECTED)
1292                  &amp;&amp;
<a name="19" id="anc19"></a><span class="line-modified">1293                  checkDisjoint(pos, flags,</span>
1294                                FINAL,
1295                                VOLATILE)
1296                  &amp;&amp;
1297                  (sym.kind == TYP ||
1298                   checkDisjoint(pos, flags,
1299                                 ABSTRACT | NATIVE,
1300                                 STRICTFP))) {
1301             // skip
1302         }
1303         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1304     }
1305 
1306 
1307     /** Determine if this enum should be implicitly final.
1308      *
1309      *  If the enum has no specialized enum constants, it is final.
1310      *
1311      *  If the enum does have specialized enum constants, it is
1312      *  &lt;i&gt;not&lt;/i&gt; final.
1313      */
1314     private long implicitEnumFinalFlag(JCTree tree) {
1315         if (!tree.hasTag(CLASSDEF)) return 0;
1316         class SpecialTreeVisitor extends JCTree.Visitor {
1317             boolean specialized;
1318             SpecialTreeVisitor() {
1319                 this.specialized = false;
1320             }
1321 
1322             @Override
1323             public void visitTree(JCTree tree) { /* no-op */ }
1324 
1325             @Override
1326             public void visitVarDef(JCVariableDecl tree) {
1327                 if ((tree.mods.flags &amp; ENUM) != 0) {
1328                     if (tree.init instanceof JCNewClass &amp;&amp;
1329                         ((JCNewClass) tree.init).def != null) {
1330                         specialized = true;
1331                     }
1332                 }
1333             }
1334         }
1335 
1336         SpecialTreeVisitor sts = new SpecialTreeVisitor();
1337         JCClassDecl cdef = (JCClassDecl) tree;
1338         for (JCTree defs: cdef.defs) {
1339             defs.accept(sts);
1340             if (sts.specialized) return 0;
1341         }
1342         return FINAL;
1343     }
1344 
1345 /* *************************************************************************
1346  * Type Validation
1347  **************************************************************************/
1348 
1349     /** Validate a type expression. That is,
1350      *  check that all type arguments of a parametric type are within
1351      *  their bounds. This must be done in a second phase after type attribution
1352      *  since a class might have a subclass as type parameter bound. E.g:
1353      *
1354      *  &lt;pre&gt;{@code
1355      *  class B&lt;A extends C&gt; { ... }
1356      *  class C extends B&lt;C&gt; { ... }
1357      *  }&lt;/pre&gt;
1358      *
1359      *  and we can&#39;t make sure that the bound is already attributed because
1360      *  of possible cycles.
1361      *
1362      * Visitor method: Validate a type expression, if it is not null, catching
1363      *  and reporting any completion failures.
1364      */
1365     void validate(JCTree tree, Env&lt;AttrContext&gt; env) {
1366         validate(tree, env, true);
1367     }
1368     void validate(JCTree tree, Env&lt;AttrContext&gt; env, boolean checkRaw) {
1369         new Validator(env).validateTree(tree, checkRaw, true);
1370     }
1371 
1372     /** Visitor method: Validate a list of type expressions.
1373      */
1374     void validate(List&lt;? extends JCTree&gt; trees, Env&lt;AttrContext&gt; env) {
1375         for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1376             validate(l.head, env);
1377     }
1378 
1379     /** A visitor class for type validation.
1380      */
1381     class Validator extends JCTree.Visitor {
1382 
1383         boolean checkRaw;
1384         boolean isOuter;
1385         Env&lt;AttrContext&gt; env;
1386 
1387         Validator(Env&lt;AttrContext&gt; env) {
1388             this.env = env;
1389         }
1390 
1391         @Override
1392         public void visitTypeArray(JCArrayTypeTree tree) {
1393             validateTree(tree.elemtype, checkRaw, isOuter);
1394         }
1395 
1396         @Override
1397         public void visitTypeApply(JCTypeApply tree) {
1398             if (tree.type.hasTag(CLASS)) {
1399                 List&lt;JCExpression&gt; args = tree.arguments;
1400                 List&lt;Type&gt; forms = tree.type.tsym.type.getTypeArguments();
1401 
1402                 Type incompatibleArg = firstIncompatibleTypeArg(tree.type);
1403                 if (incompatibleArg != null) {
1404                     for (JCTree arg : tree.arguments) {
1405                         if (arg.type == incompatibleArg) {
1406                             log.error(arg, Errors.NotWithinBounds(incompatibleArg, forms.head));
1407                         }
1408                         forms = forms.tail;
1409                      }
1410                  }
1411 
1412                 forms = tree.type.tsym.type.getTypeArguments();
1413 
1414                 boolean is_java_lang_Class = tree.type.tsym.flatName() == names.java_lang_Class;
1415 
1416                 // For matching pairs of actual argument types `a&#39; and
1417                 // formal type parameters with declared bound `b&#39; ...
1418                 while (args.nonEmpty() &amp;&amp; forms.nonEmpty()) {
1419                     validateTree(args.head,
1420                             !(isOuter &amp;&amp; is_java_lang_Class),
1421                             false);
1422                     args = args.tail;
1423                     forms = forms.tail;
1424                 }
1425 
1426                 // Check that this type is either fully parameterized, or
1427                 // not parameterized at all.
1428                 if (tree.type.getEnclosingType().isRaw())
1429                     log.error(tree.pos(), Errors.ImproperlyFormedTypeInnerRawParam);
1430                 if (tree.clazz.hasTag(SELECT))
1431                     visitSelectInternal((JCFieldAccess)tree.clazz);
1432             }
1433         }
1434 
1435         @Override
1436         public void visitTypeParameter(JCTypeParameter tree) {
1437             validateTrees(tree.bounds, true, isOuter);
1438             checkClassBounds(tree.pos(), tree.type);
1439         }
1440 
1441         @Override
1442         public void visitWildcard(JCWildcard tree) {
1443             if (tree.inner != null)
1444                 validateTree(tree.inner, true, isOuter);
1445         }
1446 
1447         @Override
1448         public void visitSelect(JCFieldAccess tree) {
1449             if (tree.type.hasTag(CLASS)) {
1450                 visitSelectInternal(tree);
1451 
1452                 // Check that this type is either fully parameterized, or
1453                 // not parameterized at all.
1454                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1455                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1456             }
1457         }
1458 
1459         public void visitSelectInternal(JCFieldAccess tree) {
1460             if (tree.type.tsym.isStatic() &amp;&amp;
<a name="20" id="anc20"></a><span class="line-modified">1461                 tree.selected.type.isParameterized()) {</span>

1462                 // The enclosing type is not a class, so we are
1463                 // looking at a static member type.  However, the
1464                 // qualifying expression is parameterized.
<a name="21" id="anc21"></a>

1465                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1466             } else {
1467                 // otherwise validate the rest of the expression
1468                 tree.selected.accept(this);
1469             }
1470         }
1471 
1472         @Override
1473         public void visitAnnotatedType(JCAnnotatedType tree) {
1474             tree.underlyingType.accept(this);
1475         }
1476 
1477         @Override
1478         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1479             if (that.type.hasTag(TypeTag.VOID)) {
1480                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1481             }
1482             super.visitTypeIdent(that);
1483         }
1484 
1485         /** Default visitor method: do nothing.
1486          */
1487         @Override
1488         public void visitTree(JCTree tree) {
1489         }
1490 
1491         public void validateTree(JCTree tree, boolean checkRaw, boolean isOuter) {
1492             if (tree != null) {
1493                 boolean prevCheckRaw = this.checkRaw;
1494                 this.checkRaw = checkRaw;
1495                 this.isOuter = isOuter;
1496 
1497                 try {
1498                     tree.accept(this);
1499                     if (checkRaw)
1500                         checkRaw(tree, env);
1501                 } catch (CompletionFailure ex) {
1502                     completionError(tree.pos(), ex);
1503                 } finally {
1504                     this.checkRaw = prevCheckRaw;
1505                 }
1506             }
1507         }
1508 
1509         public void validateTrees(List&lt;? extends JCTree&gt; trees, boolean checkRaw, boolean isOuter) {
1510             for (List&lt;? extends JCTree&gt; l = trees; l.nonEmpty(); l = l.tail)
1511                 validateTree(l.head, checkRaw, isOuter);
1512         }
1513     }
1514 
1515     void checkRaw(JCTree tree, Env&lt;AttrContext&gt; env) {
1516         if (lint.isEnabled(LintCategory.RAW) &amp;&amp;
1517             tree.type.hasTag(CLASS) &amp;&amp;
1518             !TreeInfo.isDiamond(tree) &amp;&amp;
1519             !withinAnonConstr(env) &amp;&amp;
1520             tree.type.isRaw()) {
1521             log.warning(LintCategory.RAW,
1522                     tree.pos(), Warnings.RawClassUse(tree.type, tree.type.tsym.type));
1523         }
1524     }
1525     //where
1526         private boolean withinAnonConstr(Env&lt;AttrContext&gt; env) {
1527             return env.enclClass.name.isEmpty() &amp;&amp;
1528                     env.enclMethod != null &amp;&amp; env.enclMethod.name == names.init;
1529         }
1530 
1531 /* *************************************************************************
1532  * Exception checking
1533  **************************************************************************/
1534 
1535     /* The following methods treat classes as sets that contain
1536      * the class itself and all their subclasses
1537      */
1538 
1539     /** Is given type a subtype of some of the types in given list?
1540      */
1541     boolean subset(Type t, List&lt;Type&gt; ts) {
1542         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1543             if (types.isSubtype(t, l.head)) return true;
1544         return false;
1545     }
1546 
1547     /** Is given type a subtype or supertype of
1548      *  some of the types in given list?
1549      */
1550     boolean intersects(Type t, List&lt;Type&gt; ts) {
1551         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1552             if (types.isSubtype(t, l.head) || types.isSubtype(l.head, t)) return true;
1553         return false;
1554     }
1555 
1556     /** Add type set to given type list, unless it is a subclass of some class
1557      *  in the list.
1558      */
1559     List&lt;Type&gt; incl(Type t, List&lt;Type&gt; ts) {
1560         return subset(t, ts) ? ts : excl(t, ts).prepend(t);
1561     }
1562 
1563     /** Remove type set from type set list.
1564      */
1565     List&lt;Type&gt; excl(Type t, List&lt;Type&gt; ts) {
1566         if (ts.isEmpty()) {
1567             return ts;
1568         } else {
1569             List&lt;Type&gt; ts1 = excl(t, ts.tail);
1570             if (types.isSubtype(ts.head, t)) return ts1;
1571             else if (ts1 == ts.tail) return ts;
1572             else return ts1.prepend(ts.head);
1573         }
1574     }
1575 
1576     /** Form the union of two type set lists.
1577      */
1578     List&lt;Type&gt; union(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1579         List&lt;Type&gt; ts = ts1;
1580         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1581             ts = incl(l.head, ts);
1582         return ts;
1583     }
1584 
1585     /** Form the difference of two type lists.
1586      */
1587     List&lt;Type&gt; diff(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1588         List&lt;Type&gt; ts = ts1;
1589         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1590             ts = excl(l.head, ts);
1591         return ts;
1592     }
1593 
1594     /** Form the intersection of two type lists.
1595      */
1596     public List&lt;Type&gt; intersect(List&lt;Type&gt; ts1, List&lt;Type&gt; ts2) {
1597         List&lt;Type&gt; ts = List.nil();
1598         for (List&lt;Type&gt; l = ts1; l.nonEmpty(); l = l.tail)
1599             if (subset(l.head, ts2)) ts = incl(l.head, ts);
1600         for (List&lt;Type&gt; l = ts2; l.nonEmpty(); l = l.tail)
1601             if (subset(l.head, ts1)) ts = incl(l.head, ts);
1602         return ts;
1603     }
1604 
1605     /** Is exc an exception symbol that need not be declared?
1606      */
1607     boolean isUnchecked(ClassSymbol exc) {
1608         return
1609             exc.kind == ERR ||
1610             exc.isSubClass(syms.errorType.tsym, types) ||
1611             exc.isSubClass(syms.runtimeExceptionType.tsym, types);
1612     }
1613 
1614     /** Is exc an exception type that need not be declared?
1615      */
1616     boolean isUnchecked(Type exc) {
1617         return
1618             (exc.hasTag(TYPEVAR)) ? isUnchecked(types.supertype(exc)) :
1619             (exc.hasTag(CLASS)) ? isUnchecked((ClassSymbol)exc.tsym) :
1620             exc.hasTag(BOT);
1621     }
1622 
1623     boolean isChecked(Type exc) {
1624         return !isUnchecked(exc);
1625     }
1626 
1627     /** Same, but handling completion failures.
1628      */
1629     boolean isUnchecked(DiagnosticPosition pos, Type exc) {
1630         try {
1631             return isUnchecked(exc);
1632         } catch (CompletionFailure ex) {
1633             completionError(pos, ex);
1634             return true;
1635         }
1636     }
1637 
1638     /** Is exc handled by given exception list?
1639      */
1640     boolean isHandled(Type exc, List&lt;Type&gt; handled) {
1641         return isUnchecked(exc) || subset(exc, handled);
1642     }
1643 
1644     /** Return all exceptions in thrown list that are not in handled list.
1645      *  @param thrown     The list of thrown exceptions.
1646      *  @param handled    The list of handled exceptions.
1647      */
1648     List&lt;Type&gt; unhandled(List&lt;Type&gt; thrown, List&lt;Type&gt; handled) {
1649         List&lt;Type&gt; unhandled = List.nil();
1650         for (List&lt;Type&gt; l = thrown; l.nonEmpty(); l = l.tail)
1651             if (!isHandled(l.head, handled)) unhandled = unhandled.prepend(l.head);
1652         return unhandled;
1653     }
1654 
1655 /* *************************************************************************
1656  * Overriding/Implementation checking
1657  **************************************************************************/
1658 
1659     /** The level of access protection given by a flag set,
1660      *  where PRIVATE is highest and PUBLIC is lowest.
1661      */
1662     static int protection(long flags) {
1663         switch ((short)(flags &amp; AccessFlags)) {
1664         case PRIVATE: return 3;
1665         case PROTECTED: return 1;
1666         default:
1667         case PUBLIC: return 0;
1668         case 0: return 2;
1669         }
1670     }
1671 
1672     /** A customized &quot;cannot override&quot; error message.
1673      *  @param m      The overriding method.
1674      *  @param other  The overridden method.
1675      *  @return       An internationalized string.
1676      */
1677     Fragment cannotOverride(MethodSymbol m, MethodSymbol other) {
1678         Symbol mloc = m.location();
1679         Symbol oloc = other.location();
1680 
1681         if ((other.owner.flags() &amp; INTERFACE) == 0)
1682             return Fragments.CantOverride(m, mloc, other, oloc);
1683         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1684             return Fragments.CantImplement(m, mloc, other, oloc);
1685         else
1686             return Fragments.ClashesWith(m, mloc, other, oloc);
1687     }
1688 
1689     /** A customized &quot;override&quot; warning message.
1690      *  @param m      The overriding method.
1691      *  @param other  The overridden method.
1692      *  @return       An internationalized string.
1693      */
1694     Fragment uncheckedOverrides(MethodSymbol m, MethodSymbol other) {
1695         Symbol mloc = m.location();
1696         Symbol oloc = other.location();
1697 
1698         if ((other.owner.flags() &amp; INTERFACE) == 0)
1699             return Fragments.UncheckedOverride(m, mloc, other, oloc);
1700         else if ((m.owner.flags() &amp; INTERFACE) == 0)
1701             return Fragments.UncheckedImplement(m, mloc, other, oloc);
1702         else
1703             return Fragments.UncheckedClashWith(m, mloc, other, oloc);
1704     }
1705 
1706     /** A customized &quot;override&quot; warning message.
1707      *  @param m      The overriding method.
1708      *  @param other  The overridden method.
1709      *  @return       An internationalized string.
1710      */
1711     Fragment varargsOverrides(MethodSymbol m, MethodSymbol other) {
1712         Symbol mloc = m.location();
1713         Symbol oloc = other.location();
1714 
1715         if ((other.owner.flags() &amp; INTERFACE) == 0)
1716             return Fragments.VarargsOverride(m, mloc, other, oloc);
1717         else  if ((m.owner.flags() &amp; INTERFACE) == 0)
1718             return Fragments.VarargsImplement(m, mloc, other, oloc);
1719         else
1720             return Fragments.VarargsClashWith(m, mloc, other, oloc);
1721     }
1722 
1723     /** Check that this method conforms with overridden method &#39;other&#39;.
1724      *  where `origin&#39; is the class where checking started.
1725      *  Complications:
1726      *  (1) Do not check overriding of synthetic methods
1727      *      (reason: they might be final).
1728      *      todo: check whether this is still necessary.
1729      *  (2) Admit the case where an interface proxy throws fewer exceptions
1730      *      than the method it implements. Augment the proxy methods with the
1731      *      undeclared exceptions in this case.
1732      *  (3) When generics are enabled, admit the case where an interface proxy
1733      *      has a result type
1734      *      extended by the result type of the method it implements.
1735      *      Change the proxies result type to the smaller type in this case.
1736      *
1737      *  @param tree         The tree from which positions
1738      *                      are extracted for errors.
1739      *  @param m            The overriding method.
1740      *  @param other        The overridden method.
1741      *  @param origin       The class of which the overriding method
1742      *                      is a member.
1743      */
1744     void checkOverride(JCTree tree,
1745                        MethodSymbol m,
1746                        MethodSymbol other,
1747                        ClassSymbol origin) {
1748         // Don&#39;t check overriding of synthetic methods or by bridge methods.
1749         if ((m.flags() &amp; (SYNTHETIC|BRIDGE)) != 0 || (other.flags() &amp; SYNTHETIC) != 0) {
1750             return;
1751         }
1752 
1753         // Error if static method overrides instance method (JLS 8.4.6.2).
1754         if ((m.flags() &amp; STATIC) != 0 &amp;&amp;
1755                    (other.flags() &amp; STATIC) == 0) {
1756             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1757                       Errors.OverrideStatic(cannotOverride(m, other)));
1758             m.flags_field |= BAD_OVERRIDE;
1759             return;
1760         }
1761 
1762         // Error if instance method overrides static or final
1763         // method (JLS 8.4.6.1).
1764         if ((other.flags() &amp; FINAL) != 0 ||
1765                  (m.flags() &amp; STATIC) == 0 &amp;&amp;
1766                  (other.flags() &amp; STATIC) != 0) {
1767             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1768                       Errors.OverrideMeth(cannotOverride(m, other),
1769                                           asFlagSet(other.flags() &amp; (FINAL | STATIC))));
1770             m.flags_field |= BAD_OVERRIDE;
1771             return;
1772         }
1773 
1774         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1775             // handled in validateAnnotationMethod
1776             return;
1777         }
1778 
1779         // Error if overriding method has weaker access (JLS 8.4.6.3).
1780         if (protection(m.flags()) &gt; protection(other.flags())) {
1781             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1782                       (other.flags() &amp; AccessFlags) == 0 ?
1783                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1784                                                           &quot;package&quot;) :
1785                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1786                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1787             m.flags_field |= BAD_OVERRIDE;
1788             return;
1789         }
1790 
<a name="22" id="anc22"></a>








1791         Type mt = types.memberType(origin.type, m);
1792         Type ot = types.memberType(origin.type, other);
1793         // Error if overriding result type is different
1794         // (or, in the case of generics mode, not a subtype) of
1795         // overridden result type. We have to rename any type parameters
1796         // before comparing types.
1797         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1798         List&lt;Type&gt; otvars = ot.getTypeArguments();
1799         Type mtres = mt.getReturnType();
1800         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1801 
1802         overrideWarner.clear();
1803         boolean resultTypesOK =
1804             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1805         if (!resultTypesOK) {
1806             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1807                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1808                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1809                                         other.location()), mtres, otres));
1810                 m.flags_field |= BAD_OVERRIDE;
1811             } else {
1812                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1813                           Errors.OverrideIncompatibleRet(cannotOverride(m, other), mtres, otres));
1814                 m.flags_field |= BAD_OVERRIDE;
1815             }
1816             return;
1817         } else if (overrideWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
1818             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
1819                     Warnings.OverrideUncheckedRet(uncheckedOverrides(m, other), mtres, otres));
1820         }
1821 
1822         // Error if overriding method throws an exception not reported
1823         // by overridden method.
1824         List&lt;Type&gt; otthrown = types.subst(ot.getThrownTypes(), otvars, mtvars);
1825         List&lt;Type&gt; unhandledErased = unhandled(mt.getThrownTypes(), types.erasure(otthrown));
1826         List&lt;Type&gt; unhandledUnerased = unhandled(mt.getThrownTypes(), otthrown);
1827         if (unhandledErased.nonEmpty()) {
1828             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1829                       Errors.OverrideMethDoesntThrow(cannotOverride(m, other), unhandledUnerased.head));
1830             m.flags_field |= BAD_OVERRIDE;
1831             return;
1832         }
1833         else if (unhandledUnerased.nonEmpty()) {
1834             warnUnchecked(TreeInfo.diagnosticPositionFor(m, tree),
1835                           Warnings.OverrideUncheckedThrown(cannotOverride(m, other), unhandledUnerased.head));
1836             return;
1837         }
1838 
1839         // Optional warning if varargs don&#39;t agree
1840         if ((((m.flags() ^ other.flags()) &amp; Flags.VARARGS) != 0)
1841             &amp;&amp; lint.isEnabled(LintCategory.OVERRIDES)) {
1842             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
1843                         ((m.flags() &amp; Flags.VARARGS) != 0)
1844                         ? Warnings.OverrideVarargsMissing(varargsOverrides(m, other))
1845                         : Warnings.OverrideVarargsExtra(varargsOverrides(m, other)));
1846         }
1847 
1848         // Warn if instance method overrides bridge method (compiler spec ??)
1849         if ((other.flags() &amp; BRIDGE) != 0) {
1850             log.warning(TreeInfo.diagnosticPositionFor(m, tree),
1851                         Warnings.OverrideBridge(uncheckedOverrides(m, other)));
1852         }
1853 
1854         // Warn if a deprecated method overridden by a non-deprecated one.
1855         if (!isDeprecatedOverrideIgnorable(other, origin)) {
1856             Lint prevLint = setLint(lint.augment(m));
1857             try {
1858                 checkDeprecated(() -&gt; TreeInfo.diagnosticPositionFor(m, tree), m, other);
1859             } finally {
1860                 setLint(prevLint);
1861             }
1862         }
1863     }
1864     // where
1865         private boolean isDeprecatedOverrideIgnorable(MethodSymbol m, ClassSymbol origin) {
1866             // If the method, m, is defined in an interface, then ignore the issue if the method
1867             // is only inherited via a supertype and also implemented in the supertype,
1868             // because in that case, we will rediscover the issue when examining the method
1869             // in the supertype.
1870             // If the method, m, is not defined in an interface, then the only time we need to
1871             // address the issue is when the method is the supertype implementation: any other
1872             // case, we will have dealt with when examining the supertype classes
1873             ClassSymbol mc = m.enclClass();
1874             Type st = types.supertype(origin.type);
1875             if (!st.hasTag(CLASS))
1876                 return true;
1877             MethodSymbol stimpl = m.implementation((ClassSymbol)st.tsym, types, false);
1878 
1879             if (mc != null &amp;&amp; ((mc.flags() &amp; INTERFACE) != 0)) {
1880                 List&lt;Type&gt; intfs = types.interfaces(origin.type);
1881                 return (intfs.contains(mc.type) ? false : (stimpl != null));
1882             }
1883             else
1884                 return (stimpl != m);
1885         }
1886 
1887 
1888     // used to check if there were any unchecked conversions
1889     Warner overrideWarner = new Warner();
1890 
1891     /** Check that a class does not inherit two concrete methods
1892      *  with the same signature.
1893      *  @param pos          Position to be used for error reporting.
1894      *  @param site         The class type to be checked.
1895      */
1896     public void checkCompatibleConcretes(DiagnosticPosition pos, Type site) {
1897         Type sup = types.supertype(site);
1898         if (!sup.hasTag(CLASS)) return;
1899 
1900         for (Type t1 = sup;
1901              t1.hasTag(CLASS) &amp;&amp; t1.tsym.type.isParameterized();
1902              t1 = types.supertype(t1)) {
1903             for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
1904                 if (s1.kind != MTH ||
1905                     (s1.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
1906                     !s1.isInheritedIn(site.tsym, types) ||
1907                     ((MethodSymbol)s1).implementation(site.tsym,
1908                                                       types,
1909                                                       true) != s1)
1910                     continue;
1911                 Type st1 = types.memberType(t1, s1);
1912                 int s1ArgsLength = st1.getParameterTypes().length();
1913                 if (st1 == s1.type) continue;
1914 
1915                 for (Type t2 = sup;
1916                      t2.hasTag(CLASS);
1917                      t2 = types.supertype(t2)) {
1918                     for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
1919                         if (s2 == s1 ||
1920                             s2.kind != MTH ||
1921                             (s2.flags() &amp; (STATIC|SYNTHETIC|BRIDGE)) != 0 ||
1922                             s2.type.getParameterTypes().length() != s1ArgsLength ||
1923                             !s2.isInheritedIn(site.tsym, types) ||
1924                             ((MethodSymbol)s2).implementation(site.tsym,
1925                                                               types,
1926                                                               true) != s2)
1927                             continue;
1928                         Type st2 = types.memberType(t2, s2);
1929                         if (types.overrideEquivalent(st1, st2))
1930                             log.error(pos,
1931                                       Errors.ConcreteInheritanceConflict(s1, t1, s2, t2, sup));
1932                     }
1933                 }
1934             }
1935         }
1936     }
1937 
1938     /** Check that classes (or interfaces) do not each define an abstract
1939      *  method with same name and arguments but incompatible return types.
1940      *  @param pos          Position to be used for error reporting.
1941      *  @param t1           The first argument type.
1942      *  @param t2           The second argument type.
1943      */
1944     public boolean checkCompatibleAbstracts(DiagnosticPosition pos,
1945                                             Type t1,
1946                                             Type t2,
1947                                             Type site) {
1948         if ((site.tsym.flags() &amp; COMPOUND) != 0) {
1949             // special case for intersections: need to eliminate wildcards in supertypes
1950             t1 = types.capture(t1);
1951             t2 = types.capture(t2);
1952         }
1953         return firstIncompatibility(pos, t1, t2, site) == null;
1954     }
1955 
1956     /** Return the first method which is defined with same args
1957      *  but different return types in two given interfaces, or null if none
1958      *  exists.
1959      *  @param t1     The first type.
1960      *  @param t2     The second type.
1961      *  @param site   The most derived type.
1962      *  @return symbol from t2 that conflicts with one in t1.
1963      */
1964     private Symbol firstIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
1965         Map&lt;TypeSymbol,Type&gt; interfaces1 = new HashMap&lt;&gt;();
1966         closure(t1, interfaces1);
1967         Map&lt;TypeSymbol,Type&gt; interfaces2;
1968         if (t1 == t2)
1969             interfaces2 = interfaces1;
1970         else
1971             closure(t2, interfaces1, interfaces2 = new HashMap&lt;&gt;());
1972 
1973         for (Type t3 : interfaces1.values()) {
1974             for (Type t4 : interfaces2.values()) {
1975                 Symbol s = firstDirectIncompatibility(pos, t3, t4, site);
1976                 if (s != null) return s;
1977             }
1978         }
1979         return null;
1980     }
1981 
1982     /** Compute all the supertypes of t, indexed by type symbol. */
1983     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typeMap) {
1984         if (!t.hasTag(CLASS)) return;
1985         if (typeMap.put(t.tsym, t) == null) {
1986             closure(types.supertype(t), typeMap);
1987             for (Type i : types.interfaces(t))
1988                 closure(i, typeMap);
1989         }
1990     }
1991 
1992     /** Compute all the supertypes of t, indexed by type symbol (except those in typesSkip). */
1993     private void closure(Type t, Map&lt;TypeSymbol,Type&gt; typesSkip, Map&lt;TypeSymbol,Type&gt; typeMap) {
1994         if (!t.hasTag(CLASS)) return;
1995         if (typesSkip.get(t.tsym) != null) return;
1996         if (typeMap.put(t.tsym, t) == null) {
1997             closure(types.supertype(t), typesSkip, typeMap);
1998             for (Type i : types.interfaces(t))
1999                 closure(i, typesSkip, typeMap);
2000         }
2001     }
2002 
2003     /** Return the first method in t2 that conflicts with a method from t1. */
2004     private Symbol firstDirectIncompatibility(DiagnosticPosition pos, Type t1, Type t2, Type site) {
2005         for (Symbol s1 : t1.tsym.members().getSymbols(NON_RECURSIVE)) {
2006             Type st1 = null;
2007             if (s1.kind != MTH || !s1.isInheritedIn(site.tsym, types) ||
2008                     (s1.flags() &amp; SYNTHETIC) != 0) continue;
2009             Symbol impl = ((MethodSymbol)s1).implementation(site.tsym, types, false);
2010             if (impl != null &amp;&amp; (impl.flags() &amp; ABSTRACT) == 0) continue;
2011             for (Symbol s2 : t2.tsym.members().getSymbolsByName(s1.name)) {
2012                 if (s1 == s2) continue;
2013                 if (s2.kind != MTH || !s2.isInheritedIn(site.tsym, types) ||
2014                         (s2.flags() &amp; SYNTHETIC) != 0) continue;
2015                 if (st1 == null) st1 = types.memberType(t1, s1);
2016                 Type st2 = types.memberType(t2, s2);
2017                 if (types.overrideEquivalent(st1, st2)) {
2018                     List&lt;Type&gt; tvars1 = st1.getTypeArguments();
2019                     List&lt;Type&gt; tvars2 = st2.getTypeArguments();
2020                     Type rt1 = st1.getReturnType();
2021                     Type rt2 = types.subst(st2.getReturnType(), tvars2, tvars1);
2022                     boolean compat =
2023                         types.isSameType(rt1, rt2) ||
2024                         !rt1.isPrimitiveOrVoid() &amp;&amp;
2025                         !rt2.isPrimitiveOrVoid() &amp;&amp;
2026                         (types.covariantReturnType(rt1, rt2, types.noWarnings) ||
2027                          types.covariantReturnType(rt2, rt1, types.noWarnings)) ||
2028                          checkCommonOverriderIn(s1,s2,site);
2029                     if (!compat) {
2030                         log.error(pos, Errors.TypesIncompatible(t1, t2,
2031                                 Fragments.IncompatibleDiffRet(s2.name, types.memberType(t2, s2).getParameterTypes())));
2032                         return s2;
2033                     }
2034                 } else if (checkNameClash((ClassSymbol)site.tsym, s1, s2) &amp;&amp;
2035                         !checkCommonOverriderIn(s1, s2, site)) {
2036                     log.error(pos, Errors.NameClashSameErasureNoOverride(
2037                             s1.name, types.memberType(site, s1).asMethodType().getParameterTypes(), s1.location(),
2038                             s2.name, types.memberType(site, s2).asMethodType().getParameterTypes(), s2.location()));
2039                     return s2;
2040                 }
2041             }
2042         }
2043         return null;
2044     }
2045     //WHERE
2046     boolean checkCommonOverriderIn(Symbol s1, Symbol s2, Type site) {
2047         Map&lt;TypeSymbol,Type&gt; supertypes = new HashMap&lt;&gt;();
2048         Type st1 = types.memberType(site, s1);
2049         Type st2 = types.memberType(site, s2);
2050         closure(site, supertypes);
2051         for (Type t : supertypes.values()) {
2052             for (Symbol s3 : t.tsym.members().getSymbolsByName(s1.name)) {
2053                 if (s3 == s1 || s3 == s2 || s3.kind != MTH || (s3.flags() &amp; (BRIDGE|SYNTHETIC)) != 0) continue;
2054                 Type st3 = types.memberType(site,s3);
2055                 if (types.overrideEquivalent(st3, st1) &amp;&amp;
2056                         types.overrideEquivalent(st3, st2) &amp;&amp;
2057                         types.returnTypeSubstitutable(st3, st1) &amp;&amp;
2058                         types.returnTypeSubstitutable(st3, st2)) {
2059                     return true;
2060                 }
2061             }
2062         }
2063         return false;
2064     }
2065 
2066     /** Check that a given method conforms with any method it overrides.
2067      *  @param tree         The tree from which positions are extracted
2068      *                      for errors.
2069      *  @param m            The overriding method.
2070      */
2071     void checkOverride(Env&lt;AttrContext&gt; env, JCMethodDecl tree, MethodSymbol m) {
2072         ClassSymbol origin = (ClassSymbol)m.owner;
2073         if ((origin.flags() &amp; ENUM) != 0 &amp;&amp; names.finalize.equals(m.name))
2074             if (m.overrides(syms.enumFinalFinalize, origin, types, false)) {
2075                 log.error(tree.pos(), Errors.EnumNoFinalize);
2076                 return;
2077             }
2078         for (Type t = origin.type; t.hasTag(CLASS);
2079              t = types.supertype(t)) {
2080             if (t != origin.type) {
2081                 checkOverride(tree, t, origin, m);
2082             }
2083             for (Type t2 : types.interfaces(t)) {
2084                 checkOverride(tree, t2, origin, m);
2085             }
2086         }
2087 
2088         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2089         // Check if this method must override a super method due to being annotated with @Override
2090         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2091         // be treated &quot;as if as they were annotated&quot; with @Override.
2092         boolean mustOverride = explicitOverride ||
<a name="23" id="anc23"></a><span class="line-modified">2093                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate());</span>

2094         if (mustOverride &amp;&amp; !isOverrider(m)) {
2095             DiagnosticPosition pos = tree.pos();
2096             for (JCAnnotation a : tree.getModifiers().annotations) {
2097                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2098                     pos = a.pos();
2099                     break;
2100                 }
2101             }
2102             log.error(pos,
2103                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2104                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2105         }
2106     }
2107 
2108     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2109         TypeSymbol c = site.tsym;
2110         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2111             if (m.overrides(sym, origin, types, false)) {
2112                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2113                     checkOverride(tree, m, (MethodSymbol)sym, origin);
2114                 }
2115             }
2116         }
2117     }
2118 
2119     private Filter&lt;Symbol&gt; equalsHasCodeFilter = s -&gt; MethodSymbol.implementation_filter.accepts(s) &amp;&amp;
2120             (s.flags() &amp; BAD_OVERRIDE) == 0;
2121 
2122     public void checkClassOverrideEqualsAndHashIfNeeded(DiagnosticPosition pos,
2123             ClassSymbol someClass) {
2124         /* At present, annotations cannot possibly have a method that is override
2125          * equivalent with Object.equals(Object) but in any case the condition is
2126          * fine for completeness.
2127          */
2128         if (someClass == (ClassSymbol)syms.objectType.tsym ||
2129             someClass.isInterface() || someClass.isEnum() ||
2130             (someClass.flags() &amp; ANNOTATION) != 0 ||
2131             (someClass.flags() &amp; ABSTRACT) != 0) return;
2132         //anonymous inner classes implementing interfaces need especial treatment
2133         if (someClass.isAnonymous()) {
2134             List&lt;Type&gt; interfaces =  types.interfaces(someClass.type);
2135             if (interfaces != null &amp;&amp; !interfaces.isEmpty() &amp;&amp;
2136                 interfaces.head.tsym == syms.comparatorType.tsym) return;
2137         }
2138         checkClassOverrideEqualsAndHash(pos, someClass);
2139     }
2140 
2141     private void checkClassOverrideEqualsAndHash(DiagnosticPosition pos,
2142             ClassSymbol someClass) {
2143         if (lint.isEnabled(LintCategory.OVERRIDES)) {
2144             MethodSymbol equalsAtObject = (MethodSymbol)syms.objectType
2145                     .tsym.members().findFirst(names.equals);
2146             MethodSymbol hashCodeAtObject = (MethodSymbol)syms.objectType
2147                     .tsym.members().findFirst(names.hashCode);
2148             MethodSymbol equalsImpl = types.implementation(equalsAtObject,
2149                     someClass, false, equalsHasCodeFilter);
2150             boolean overridesEquals = equalsImpl != null &amp;&amp;
2151                                       equalsImpl.owner == someClass;
2152             boolean overridesHashCode = types.implementation(hashCodeAtObject,
2153                 someClass, false, equalsHasCodeFilter) != hashCodeAtObject;
2154 
2155             if (overridesEquals &amp;&amp; !overridesHashCode) {
2156                 log.warning(LintCategory.OVERRIDES, pos,
2157                             Warnings.OverrideEqualsButNotHashcode(someClass));
2158             }
2159         }
2160     }
2161 
2162     public void checkModuleName (JCModuleDecl tree) {
2163         Name moduleName = tree.sym.name;
2164         Assert.checkNonNull(moduleName);
2165         if (lint.isEnabled(LintCategory.MODULE)) {
2166             JCExpression qualId = tree.qualId;
2167             while (qualId != null) {
2168                 Name componentName;
2169                 DiagnosticPosition pos;
2170                 switch (qualId.getTag()) {
2171                     case SELECT:
2172                         JCFieldAccess selectNode = ((JCFieldAccess) qualId);
2173                         componentName = selectNode.name;
2174                         pos = selectNode.pos();
2175                         qualId = selectNode.selected;
2176                         break;
2177                     case IDENT:
2178                         componentName = ((JCIdent) qualId).name;
2179                         pos = qualId.pos();
2180                         qualId = null;
2181                         break;
2182                     default:
2183                         throw new AssertionError(&quot;Unexpected qualified identifier: &quot; + qualId.toString());
2184                 }
2185                 if (componentName != null) {
2186                     String moduleNameComponentString = componentName.toString();
2187                     int nameLength = moduleNameComponentString.length();
2188                     if (nameLength &gt; 0 &amp;&amp; Character.isDigit(moduleNameComponentString.charAt(nameLength - 1))) {
2189                         log.warning(Lint.LintCategory.MODULE, pos, Warnings.PoorChoiceForModuleName(componentName));
2190                     }
2191                 }
2192             }
2193         }
2194     }
2195 
2196     private boolean checkNameClash(ClassSymbol origin, Symbol s1, Symbol s2) {
2197         ClashFilter cf = new ClashFilter(origin.type);
2198         return (cf.accepts(s1) &amp;&amp;
2199                 cf.accepts(s2) &amp;&amp;
2200                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2201     }
2202 
2203 
2204     /** Check that all abstract members of given class have definitions.
2205      *  @param pos          Position to be used for error reporting.
2206      *  @param c            The class.
2207      */
2208     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2209         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2210         if (undef != null) {
2211             MethodSymbol undef1 =
2212                 new MethodSymbol(undef.flags(), undef.name,
2213                                  types.memberType(c.type, undef), undef.owner);
2214             log.error(pos,
2215                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2216         }
2217     }
2218 
<a name="24" id="anc24"></a>






































2219     void checkNonCyclicDecl(JCClassDecl tree) {
2220         CycleChecker cc = new CycleChecker();
2221         cc.scan(tree);
2222         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2223             tree.sym.flags_field |= ACYCLIC;
2224         }
2225     }
2226 
2227     class CycleChecker extends TreeScanner {
2228 
2229         List&lt;Symbol&gt; seenClasses = List.nil();
2230         boolean errorFound = false;
2231         boolean partialCheck = false;
2232 
2233         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2234             if (sym != null &amp;&amp; sym.kind == TYP) {
2235                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2236                 if (classEnv != null) {
2237                     DiagnosticSource prevSource = log.currentSource();
2238                     try {
2239                         log.useSource(classEnv.toplevel.sourcefile);
2240                         scan(classEnv.tree);
2241                     }
2242                     finally {
2243                         log.useSource(prevSource.getFile());
2244                     }
2245                 } else if (sym.kind == TYP) {
2246                     checkClass(pos, sym, List.nil());
2247                 }
2248             } else {
2249                 //not completed yet
2250                 partialCheck = true;
2251             }
2252         }
2253 
2254         @Override
2255         public void visitSelect(JCFieldAccess tree) {
2256             super.visitSelect(tree);
2257             checkSymbol(tree.pos(), tree.sym);
2258         }
2259 
2260         @Override
2261         public void visitIdent(JCIdent tree) {
2262             checkSymbol(tree.pos(), tree.sym);
2263         }
2264 
2265         @Override
2266         public void visitTypeApply(JCTypeApply tree) {
2267             scan(tree.clazz);
2268         }
2269 
2270         @Override
2271         public void visitTypeArray(JCArrayTypeTree tree) {
2272             scan(tree.elemtype);
2273         }
2274 
2275         @Override
2276         public void visitClassDef(JCClassDecl tree) {
2277             List&lt;JCTree&gt; supertypes = List.nil();
2278             if (tree.getExtendsClause() != null) {
2279                 supertypes = supertypes.prepend(tree.getExtendsClause());
2280             }
2281             if (tree.getImplementsClause() != null) {
2282                 for (JCTree intf : tree.getImplementsClause()) {
2283                     supertypes = supertypes.prepend(intf);
2284                 }
2285             }
2286             checkClass(tree.pos(), tree.sym, supertypes);
2287         }
2288 
2289         void checkClass(DiagnosticPosition pos, Symbol c, List&lt;JCTree&gt; supertypes) {
2290             if ((c.flags_field &amp; ACYCLIC) != 0)
2291                 return;
2292             if (seenClasses.contains(c)) {
2293                 errorFound = true;
2294                 noteCyclic(pos, (ClassSymbol)c);
2295             } else if (!c.type.isErroneous()) {
2296                 try {
2297                     seenClasses = seenClasses.prepend(c);
2298                     if (c.type.hasTag(CLASS)) {
2299                         if (supertypes.nonEmpty()) {
2300                             scan(supertypes);
2301                         }
2302                         else {
2303                             ClassType ct = (ClassType)c.type;
2304                             if (ct.supertype_field == null ||
2305                                     ct.interfaces_field == null) {
2306                                 //not completed yet
2307                                 partialCheck = true;
2308                                 return;
2309                             }
2310                             checkSymbol(pos, ct.supertype_field.tsym);
2311                             for (Type intf : ct.interfaces_field) {
2312                                 checkSymbol(pos, intf.tsym);
2313                             }
2314                         }
2315                         if (c.owner.kind == TYP) {
2316                             checkSymbol(pos, c.owner);
2317                         }
2318                     }
2319                 } finally {
2320                     seenClasses = seenClasses.tail;
2321                 }
2322             }
2323         }
2324     }
2325 
2326     /** Check for cyclic references. Issue an error if the
2327      *  symbol of the type referred to has a LOCKED flag set.
2328      *
2329      *  @param pos      Position to be used for error reporting.
2330      *  @param t        The type referred to.
2331      */
2332     void checkNonCyclic(DiagnosticPosition pos, Type t) {
2333         checkNonCyclicInternal(pos, t);
2334     }
2335 
2336 
2337     void checkNonCyclic(DiagnosticPosition pos, TypeVar t) {
2338         checkNonCyclic1(pos, t, List.nil());
2339     }
2340 
2341     private void checkNonCyclic1(DiagnosticPosition pos, Type t, List&lt;TypeVar&gt; seen) {
2342         final TypeVar tv;
2343         if  (t.hasTag(TYPEVAR) &amp;&amp; (t.tsym.flags() &amp; UNATTRIBUTED) != 0)
2344             return;
2345         if (seen.contains(t)) {
2346             tv = (TypeVar)t;
2347             tv.setUpperBound(types.createErrorType(t));
2348             log.error(pos, Errors.CyclicInheritance(t));
2349         } else if (t.hasTag(TYPEVAR)) {
2350             tv = (TypeVar)t;
2351             seen = seen.prepend(tv);
2352             for (Type b : types.getBounds(tv))
2353                 checkNonCyclic1(pos, b, seen);
2354         }
2355     }
2356 
2357     /** Check for cyclic references. Issue an error if the
2358      *  symbol of the type referred to has a LOCKED flag set.
2359      *
2360      *  @param pos      Position to be used for error reporting.
2361      *  @param t        The type referred to.
2362      *  @returns        True if the check completed on all attributed classes
2363      */
2364     private boolean checkNonCyclicInternal(DiagnosticPosition pos, Type t) {
2365         boolean complete = true; // was the check complete?
2366         //- System.err.println(&quot;checkNonCyclicInternal(&quot;+t+&quot;);&quot;);//DEBUG
2367         Symbol c = t.tsym;
2368         if ((c.flags_field &amp; ACYCLIC) != 0) return true;
2369 
2370         if ((c.flags_field &amp; LOCKED) != 0) {
2371             noteCyclic(pos, (ClassSymbol)c);
2372         } else if (!c.type.isErroneous()) {
2373             try {
2374                 c.flags_field |= LOCKED;
2375                 if (c.type.hasTag(CLASS)) {
2376                     ClassType clazz = (ClassType)c.type;
2377                     if (clazz.interfaces_field != null)
2378                         for (List&lt;Type&gt; l=clazz.interfaces_field; l.nonEmpty(); l=l.tail)
2379                             complete &amp;= checkNonCyclicInternal(pos, l.head);
2380                     if (clazz.supertype_field != null) {
2381                         Type st = clazz.supertype_field;
2382                         if (st != null &amp;&amp; st.hasTag(CLASS))
2383                             complete &amp;= checkNonCyclicInternal(pos, st);
2384                     }
2385                     if (c.owner.kind == TYP)
2386                         complete &amp;= checkNonCyclicInternal(pos, c.owner.type);
2387                 }
2388             } finally {
2389                 c.flags_field &amp;= ~LOCKED;
2390             }
2391         }
2392         if (complete)
2393             complete = ((c.flags_field &amp; UNATTRIBUTED) == 0) &amp;&amp; c.isCompleted();
2394         if (complete) c.flags_field |= ACYCLIC;
2395         return complete;
2396     }
2397 
2398     /** Note that we found an inheritance cycle. */
2399     private void noteCyclic(DiagnosticPosition pos, ClassSymbol c) {
2400         log.error(pos, Errors.CyclicInheritance(c));
2401         for (List&lt;Type&gt; l=types.interfaces(c.type); l.nonEmpty(); l=l.tail)
2402             l.head = types.createErrorType((ClassSymbol)l.head.tsym, Type.noType);
2403         Type st = types.supertype(c.type);
2404         if (st.hasTag(CLASS))
2405             ((ClassType)c.type).supertype_field = types.createErrorType((ClassSymbol)st.tsym, Type.noType);
2406         c.type = types.createErrorType(c, c.type);
2407         c.flags_field |= ACYCLIC;
2408     }
2409 
2410     /** Check that all methods which implement some
2411      *  method conform to the method they implement.
2412      *  @param tree         The class definition whose members are checked.
2413      */
2414     void checkImplementations(JCClassDecl tree) {
2415         checkImplementations(tree, tree.sym, tree.sym);
2416     }
2417     //where
2418         /** Check that all methods which implement some
2419          *  method in `ic&#39; conform to the method they implement.
2420          */
2421         void checkImplementations(JCTree tree, ClassSymbol origin, ClassSymbol ic) {
2422             for (List&lt;Type&gt; l = types.closure(ic.type); l.nonEmpty(); l = l.tail) {
2423                 ClassSymbol lc = (ClassSymbol)l.head.tsym;
2424                 if ((lc.flags() &amp; ABSTRACT) != 0) {
2425                     for (Symbol sym : lc.members().getSymbols(NON_RECURSIVE)) {
2426                         if (sym.kind == MTH &amp;&amp;
2427                             (sym.flags() &amp; (STATIC|ABSTRACT)) == ABSTRACT) {
2428                             MethodSymbol absmeth = (MethodSymbol)sym;
2429                             MethodSymbol implmeth = absmeth.implementation(origin, types, false);
2430                             if (implmeth != null &amp;&amp; implmeth != absmeth &amp;&amp;
2431                                 (implmeth.owner.flags() &amp; INTERFACE) ==
2432                                 (origin.flags() &amp; INTERFACE)) {
2433                                 // don&#39;t check if implmeth is in a class, yet
2434                                 // origin is an interface. This case arises only
2435                                 // if implmeth is declared in Object. The reason is
2436                                 // that interfaces really don&#39;t inherit from
2437                                 // Object it&#39;s just that the compiler represents
2438                                 // things that way.
2439                                 checkOverride(tree, implmeth, absmeth, origin);
2440                             }
2441                         }
2442                     }
2443                 }
2444             }
2445         }
2446 
2447     /** Check that all abstract methods implemented by a class are
2448      *  mutually compatible.
2449      *  @param pos          Position to be used for error reporting.
2450      *  @param c            The class whose interfaces are checked.
2451      */
2452     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2453         List&lt;Type&gt; supertypes = types.interfaces(c);
2454         Type supertype = types.supertype(c);
2455         if (supertype.hasTag(CLASS) &amp;&amp;
2456             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2457             supertypes = supertypes.prepend(supertype);
2458         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2459             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2460                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2461                 return;
2462             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2463                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2464                     return;
2465         }
2466         checkCompatibleConcretes(pos, c);
<a name="25" id="anc25"></a>



2467     }
2468 
2469     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2470      *  are mutually compatible (JLS 8.4.8/9.4.1).
2471      *
2472      *  @param pos  Position to be used for error reporting.
2473      *  @param site The class whose methods are checked.
2474      *  @param sym  The method symbol to be checked.
2475      */
2476     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2477          ClashFilter cf = new ClashFilter(site);
2478         //for each method m1 that is overridden (directly or indirectly)
2479         //by method &#39;sym&#39; in &#39;site&#39;...
2480 
2481         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2482         boolean overridesAny = false;
2483         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2484         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2485         for (Symbol m1 : symbolsByName) {
2486             if (!sym.overrides(m1, site.tsym, types, false)) {
2487                 if (m1 == sym) {
2488                     continue;
2489                 }
2490 
2491                 if (!overridesAny) {
2492                     potentiallyAmbiguousList = potentiallyAmbiguousList.prepend((MethodSymbol)m1);
2493                 }
2494                 continue;
2495             }
2496 
2497             if (m1 != sym) {
2498                 overridesAny = true;
2499                 potentiallyAmbiguousList = List.nil();
2500             }
2501 
2502             //...check each method m2 that is a member of &#39;site&#39;
2503             for (Symbol m2 : symbolsByName) {
2504                 if (m2 == m1) continue;
2505                 //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2506                 //a member of &#39;site&#39;) and (ii) m1 has the same erasure as m2, issue an error
2507                 if (!types.isSubSignature(sym.type, types.memberType(site, m2), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source)) &amp;&amp;
2508                         types.hasSameArgs(m2.erasure(types), m1.erasure(types))) {
2509                     sym.flags_field |= CLASH;
2510                     if (m1 == sym) {
2511                         log.error(pos, Errors.NameClashSameErasureNoOverride(
2512                             m1.name, types.memberType(site, m1).asMethodType().getParameterTypes(), m1.location(),
2513                             m2.name, types.memberType(site, m2).asMethodType().getParameterTypes(), m2.location()));
2514                     } else {
2515                         ClassType ct = (ClassType)site;
2516                         String kind = ct.isInterface() ? &quot;interface&quot; : &quot;class&quot;;
2517                         log.error(pos, Errors.NameClashSameErasureNoOverride1(
2518                             kind,
2519                             ct.tsym.name,
2520                             m1.name,
2521                             types.memberType(site, m1).asMethodType().getParameterTypes(),
2522                             m1.location(),
2523                             m2.name,
2524                             types.memberType(site, m2).asMethodType().getParameterTypes(),
2525                             m2.location()));
2526                     }
2527                     return;
2528                 }
2529             }
2530         }
2531 
2532         if (!overridesAny) {
2533             for (MethodSymbol m: potentiallyAmbiguousList) {
2534                 checkPotentiallyAmbiguousOverloads(pos, site, sym, m);
2535             }
2536         }
2537     }
2538 
2539     /** Check that all static methods accessible from &#39;site&#39; are
2540      *  mutually compatible (JLS 8.4.8).
2541      *
2542      *  @param pos  Position to be used for error reporting.
2543      *  @param site The class whose methods are checked.
2544      *  @param sym  The method symbol to be checked.
2545      */
2546     void checkHideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2547         ClashFilter cf = new ClashFilter(site);
2548         //for each method m1 that is a member of &#39;site&#39;...
2549         for (Symbol s : types.membersClosure(site, true).getSymbolsByName(sym.name, cf)) {
2550             //if (i) the signature of &#39;sym&#39; is not a subsignature of m1 (seen as
2551             //a member of &#39;site&#39;) and (ii) &#39;sym&#39; has the same erasure as m1, issue an error
2552             if (!types.isSubSignature(sym.type, types.memberType(site, s), Feature.STRICT_METHOD_CLASH_CHECK.allowedInSource(source))) {
2553                 if (types.hasSameArgs(s.erasure(types), sym.erasure(types))) {
2554                     log.error(pos,
2555                               Errors.NameClashSameErasureNoHide(sym, sym.location(), s, s.location()));
2556                     return;
2557                 } else {
2558                     checkPotentiallyAmbiguousOverloads(pos, site, sym, (MethodSymbol)s);
2559                 }
2560             }
2561          }
2562      }
2563 
2564      //where
2565      private class ClashFilter implements Filter&lt;Symbol&gt; {
2566 
2567          Type site;
2568 
2569          ClashFilter(Type site) {
2570              this.site = site;
2571          }
2572 
2573          boolean shouldSkip(Symbol s) {
2574              return (s.flags() &amp; CLASH) != 0 &amp;&amp;
2575                 s.owner == site.tsym;
2576          }
2577 
2578          public boolean accepts(Symbol s) {
2579              return s.kind == MTH &amp;&amp;
2580                      (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
2581                      !shouldSkip(s) &amp;&amp;
2582                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2583                      !s.isConstructor();
2584          }
2585      }
2586 
2587     void checkDefaultMethodClashes(DiagnosticPosition pos, Type site) {
2588         DefaultMethodClashFilter dcf = new DefaultMethodClashFilter(site);
2589         for (Symbol m : types.membersClosure(site, false).getSymbols(dcf)) {
2590             Assert.check(m.kind == MTH);
2591             List&lt;MethodSymbol&gt; prov = types.interfaceCandidates(site, (MethodSymbol)m);
2592             if (prov.size() &gt; 1) {
2593                 ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
2594                 ListBuffer&lt;Symbol&gt; defaults = new ListBuffer&lt;&gt;();
2595                 for (MethodSymbol provSym : prov) {
2596                     if ((provSym.flags() &amp; DEFAULT) != 0) {
2597                         defaults = defaults.append(provSym);
2598                     } else if ((provSym.flags() &amp; ABSTRACT) != 0) {
2599                         abstracts = abstracts.append(provSym);
2600                     }
2601                     if (defaults.nonEmpty() &amp;&amp; defaults.size() + abstracts.size() &gt;= 2) {
2602                         //strong semantics - issue an error if two sibling interfaces
2603                         //have two override-equivalent defaults - or if one is abstract
2604                         //and the other is default
2605                         Fragment diagKey;
2606                         Symbol s1 = defaults.first();
2607                         Symbol s2;
2608                         if (defaults.size() &gt; 1) {
2609                             s2 = defaults.toList().tail.head;
2610                             diagKey = Fragments.IncompatibleUnrelatedDefaults(Kinds.kindName(site.tsym), site,
2611                                     m.name, types.memberType(site, m).getParameterTypes(),
2612                                     s1.location(), s2.location());
2613 
2614                         } else {
2615                             s2 = abstracts.first();
2616                             diagKey = Fragments.IncompatibleAbstractDefault(Kinds.kindName(site.tsym), site,
2617                                     m.name, types.memberType(site, m).getParameterTypes(),
2618                                     s1.location(), s2.location());
2619                         }
2620                         log.error(pos, Errors.TypesIncompatible(s1.location().type, s2.location().type, diagKey));
2621                         break;
2622                     }
2623                 }
2624             }
2625         }
2626     }
2627 
2628     //where
2629      private class DefaultMethodClashFilter implements Filter&lt;Symbol&gt; {
2630 
2631          Type site;
2632 
2633          DefaultMethodClashFilter(Type site) {
2634              this.site = site;
2635          }
2636 
2637          public boolean accepts(Symbol s) {
2638              return s.kind == MTH &amp;&amp;
2639                      (s.flags() &amp; DEFAULT) != 0 &amp;&amp;
2640                      s.isInheritedIn(site.tsym, types) &amp;&amp;
2641                      !s.isConstructor();
2642          }
2643      }
2644 
2645     /**
2646       * Report warnings for potentially ambiguous method declarations. Two declarations
2647       * are potentially ambiguous if they feature two unrelated functional interface
2648       * in same argument position (in which case, a call site passing an implicit
2649       * lambda would be ambiguous).
2650       */
2651     void checkPotentiallyAmbiguousOverloads(DiagnosticPosition pos, Type site,
2652             MethodSymbol msym1, MethodSymbol msym2) {
2653         if (msym1 != msym2 &amp;&amp;
2654                 Feature.DEFAULT_METHODS.allowedInSource(source) &amp;&amp;
2655                 lint.isEnabled(LintCategory.OVERLOADS) &amp;&amp;
2656                 (msym1.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0 &amp;&amp;
2657                 (msym2.flags() &amp; POTENTIALLY_AMBIGUOUS) == 0) {
2658             Type mt1 = types.memberType(site, msym1);
2659             Type mt2 = types.memberType(site, msym2);
2660             //if both generic methods, adjust type variables
2661             if (mt1.hasTag(FORALL) &amp;&amp; mt2.hasTag(FORALL) &amp;&amp;
2662                     types.hasSameBounds((ForAll)mt1, (ForAll)mt2)) {
2663                 mt2 = types.subst(mt2, ((ForAll)mt2).tvars, ((ForAll)mt1).tvars);
2664             }
2665             //expand varargs methods if needed
2666             int maxLength = Math.max(mt1.getParameterTypes().length(), mt2.getParameterTypes().length());
2667             List&lt;Type&gt; args1 = rs.adjustArgs(mt1.getParameterTypes(), msym1, maxLength, true);
2668             List&lt;Type&gt; args2 = rs.adjustArgs(mt2.getParameterTypes(), msym2, maxLength, true);
2669             //if arities don&#39;t match, exit
2670             if (args1.length() != args2.length()) return;
2671             boolean potentiallyAmbiguous = false;
2672             while (args1.nonEmpty() &amp;&amp; args2.nonEmpty()) {
2673                 Type s = args1.head;
2674                 Type t = args2.head;
2675                 if (!types.isSubtype(t, s) &amp;&amp; !types.isSubtype(s, t)) {
2676                     if (types.isFunctionalInterface(s) &amp;&amp; types.isFunctionalInterface(t) &amp;&amp;
2677                             types.findDescriptorType(s).getParameterTypes().length() &gt; 0 &amp;&amp;
2678                             types.findDescriptorType(s).getParameterTypes().length() ==
2679                             types.findDescriptorType(t).getParameterTypes().length()) {
2680                         potentiallyAmbiguous = true;
2681                     } else {
2682                         break;
2683                     }
2684                 }
2685                 args1 = args1.tail;
2686                 args2 = args2.tail;
2687             }
2688             if (potentiallyAmbiguous) {
2689                 //we found two incompatible functional interfaces with same arity
2690                 //this means a call site passing an implicit lambda would be ambiguous
2691                 msym1.flags_field |= POTENTIALLY_AMBIGUOUS;
2692                 msym2.flags_field |= POTENTIALLY_AMBIGUOUS;
2693                 log.warning(LintCategory.OVERLOADS, pos,
2694                             Warnings.PotentiallyAmbiguousOverload(msym1, msym1.location(),
2695                                                                   msym2, msym2.location()));
2696                 return;
2697             }
2698         }
2699     }
2700 
2701     void checkAccessFromSerializableElement(final JCTree tree, boolean isLambda) {
2702         if (warnOnAnyAccessToMembers ||
2703             (lint.isEnabled(LintCategory.SERIAL) &amp;&amp;
2704             !lint.isSuppressed(LintCategory.SERIAL) &amp;&amp;
2705             isLambda)) {
2706             Symbol sym = TreeInfo.symbol(tree);
2707             if (!sym.kind.matches(KindSelector.VAL_MTH)) {
2708                 return;
2709             }
2710 
2711             if (sym.kind == VAR) {
2712                 if ((sym.flags() &amp; PARAMETER) != 0 ||
2713                     sym.isLocal() ||
2714                     sym.name == names._this ||
2715                     sym.name == names._super) {
2716                     return;
2717                 }
2718             }
2719 
2720             if (!types.isSubtype(sym.owner.type, syms.serializableType) &amp;&amp;
2721                 isEffectivelyNonPublic(sym)) {
2722                 if (isLambda) {
2723                     if (belongsToRestrictedPackage(sym)) {
2724                         log.warning(LintCategory.SERIAL, tree.pos(),
2725                                     Warnings.AccessToMemberFromSerializableLambda(sym));
2726                     }
2727                 } else {
2728                     log.warning(tree.pos(),
2729                                 Warnings.AccessToMemberFromSerializableElement(sym));
2730                 }
2731             }
2732         }
2733     }
2734 
2735     private boolean isEffectivelyNonPublic(Symbol sym) {
2736         if (sym.packge() == syms.rootPackage) {
2737             return false;
2738         }
2739 
2740         while (sym.kind != PCK) {
2741             if ((sym.flags() &amp; PUBLIC) == 0) {
2742                 return true;
2743             }
2744             sym = sym.owner;
2745         }
2746         return false;
2747     }
2748 
2749     private boolean belongsToRestrictedPackage(Symbol sym) {
2750         String fullName = sym.packge().fullname.toString();
2751         return fullName.startsWith(&quot;java.&quot;) ||
2752                 fullName.startsWith(&quot;javax.&quot;) ||
2753                 fullName.startsWith(&quot;sun.&quot;) ||
2754                 fullName.contains(&quot;.internal.&quot;);
2755     }
2756 
2757     /** Check that class c does not implement directly or indirectly
2758      *  the same parameterized interface with two different argument lists.
2759      *  @param pos          Position to be used for error reporting.
2760      *  @param type         The type whose interfaces are checked.
2761      */
2762     void checkClassBounds(DiagnosticPosition pos, Type type) {
2763         checkClassBounds(pos, new HashMap&lt;TypeSymbol,Type&gt;(), type);
2764     }
2765 //where
2766         /** Enter all interfaces of type `type&#39; into the hash table `seensofar&#39;
2767          *  with their class symbol as key and their type as value. Make
2768          *  sure no class is entered with two different types.
2769          */
2770         void checkClassBounds(DiagnosticPosition pos,
2771                               Map&lt;TypeSymbol,Type&gt; seensofar,
2772                               Type type) {
2773             if (type.isErroneous()) return;
2774             for (List&lt;Type&gt; l = types.interfaces(type); l.nonEmpty(); l = l.tail) {
2775                 Type it = l.head;
2776                 if (type.hasTag(CLASS) &amp;&amp; !it.hasTag(CLASS)) continue; // JLS 8.1.5
2777 
2778                 Type oldit = seensofar.put(it.tsym, it);
2779                 if (oldit != null) {
2780                     List&lt;Type&gt; oldparams = oldit.allparams();
2781                     List&lt;Type&gt; newparams = it.allparams();
2782                     if (!types.containsTypeEquivalent(oldparams, newparams))
2783                         log.error(pos,
2784                                   Errors.CantInheritDiffArg(it.tsym,
2785                                                             Type.toString(oldparams),
2786                                                             Type.toString(newparams)));
2787                 }
2788                 checkClassBounds(pos, seensofar, it);
2789             }
2790             Type st = types.supertype(type);
2791             if (type.hasTag(CLASS) &amp;&amp; !st.hasTag(CLASS)) return; // JLS 8.1.4
2792             if (st != Type.noType) checkClassBounds(pos, seensofar, st);
2793         }
2794 
2795     /** Enter interface into into set.
2796      *  If it existed already, issue a &quot;repeated interface&quot; error.
2797      */
2798     void checkNotRepeated(DiagnosticPosition pos, Type it, Set&lt;Type&gt; its) {
2799         if (its.contains(it))
2800             log.error(pos, Errors.RepeatedInterface);
2801         else {
2802             its.add(it);
2803         }
2804     }
2805 
2806 /* *************************************************************************
2807  * Check annotations
2808  **************************************************************************/
2809 
2810     /**
2811      * Recursively validate annotations values
2812      */
2813     void validateAnnotationTree(JCTree tree) {
2814         class AnnotationValidator extends TreeScanner {
2815             @Override
2816             public void visitAnnotation(JCAnnotation tree) {
2817                 if (!tree.type.isErroneous() &amp;&amp; tree.type.tsym.isAnnotationType()) {
2818                     super.visitAnnotation(tree);
2819                     validateAnnotation(tree);
2820                 }
2821             }
2822         }
2823         tree.accept(new AnnotationValidator());
2824     }
2825 
2826     /**
2827      *  {@literal
2828      *  Annotation types are restricted to primitives, String, an
2829      *  enum, an annotation, Class, Class&lt;?&gt;, Class&lt;? extends
2830      *  Anything&gt;, arrays of the preceding.
2831      *  }
2832      */
2833     void validateAnnotationType(JCTree restype) {
2834         // restype may be null if an error occurred, so don&#39;t bother validating it
2835         if (restype != null) {
2836             validateAnnotationType(restype.pos(), restype.type);
2837         }
2838     }
2839 
2840     void validateAnnotationType(DiagnosticPosition pos, Type type) {
2841         if (type.isPrimitive()) return;
2842         if (types.isSameType(type, syms.stringType)) return;
2843         if ((type.tsym.flags() &amp; Flags.ENUM) != 0) return;
2844         if ((type.tsym.flags() &amp; Flags.ANNOTATION) != 0) return;
2845         if (types.cvarLowerBound(type).tsym == syms.classType.tsym) return;
2846         if (types.isArray(type) &amp;&amp; !types.isArray(types.elemtype(type))) {
2847             validateAnnotationType(pos, types.elemtype(type));
2848             return;
2849         }
2850         log.error(pos, Errors.InvalidAnnotationMemberType);
2851     }
2852 
2853     /**
2854      * &quot;It is also a compile-time error if any method declared in an
2855      * annotation type has a signature that is override-equivalent to
2856      * that of any public or protected method declared in class Object
2857      * or in the interface annotation.Annotation.&quot;
2858      *
2859      * @jls 9.6 Annotation Types
2860      */
2861     void validateAnnotationMethod(DiagnosticPosition pos, MethodSymbol m) {
2862         for (Type sup = syms.annotationType; sup.hasTag(CLASS); sup = types.supertype(sup)) {
2863             Scope s = sup.tsym.members();
2864             for (Symbol sym : s.getSymbolsByName(m.name)) {
2865                 if (sym.kind == MTH &amp;&amp;
2866                     (sym.flags() &amp; (PUBLIC | PROTECTED)) != 0 &amp;&amp;
2867                     types.overrideEquivalent(m.type, sym.type))
2868                     log.error(pos, Errors.IntfAnnotationMemberClash(sym, sup));
2869             }
2870         }
2871     }
2872 
2873     /** Check the annotations of a symbol.
2874      */
2875     public void validateAnnotations(List&lt;JCAnnotation&gt; annotations, JCTree declarationTree, Symbol s) {
2876         for (JCAnnotation a : annotations)
2877             validateAnnotation(a, declarationTree, s);
2878     }
2879 
2880     /** Check the type annotations.
2881      */
2882     public void validateTypeAnnotations(List&lt;JCAnnotation&gt; annotations, boolean isTypeParameter) {
2883         for (JCAnnotation a : annotations)
2884             validateTypeAnnotation(a, isTypeParameter);
2885     }
2886 
2887     /** Check an annotation of a symbol.
2888      */
2889     private void validateAnnotation(JCAnnotation a, JCTree declarationTree, Symbol s) {
2890         validateAnnotationTree(a);
2891         boolean isRecordMember = (s.flags_field &amp; RECORD) != 0 || s.enclClass() != null &amp;&amp; s.enclClass().isRecord();
2892 
2893         boolean isRecordField = isRecordMember &amp;&amp;
2894                 (s.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
2895                 declarationTree.hasTag(VARDEF) &amp;&amp;
2896                 s.owner.kind == TYP;
2897 
2898         if (isRecordField) {
2899             // first we need to check if the annotation is applicable to records
2900             Name[] targets = getTargetNames(a);
2901             boolean appliesToRecords = false;
2902             for (Name target : targets) {
2903                 appliesToRecords =
2904                                 target == names.FIELD ||
2905                                 target == names.PARAMETER ||
2906                                 target == names.METHOD ||
2907                                 target == names.TYPE_USE ||
2908                                 target == names.RECORD_COMPONENT;
2909                 if (appliesToRecords) {
2910                     break;
2911                 }
2912             }
2913             if (!appliesToRecords) {
2914                 log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
2915             } else {
2916                 /* lets now find the annotations in the field that are targeted to record components and append them to
2917                  * the corresponding record component
2918                  */
2919                 ClassSymbol recordClass = (ClassSymbol) s.owner;
2920                 RecordComponent rc = recordClass.getRecordComponent((VarSymbol)s);
2921                 SymbolMetadata metadata = rc.getMetadata();
2922                 if (metadata == null || metadata.isEmpty()) {
2923                     /* if not is empty then we have already been here, which is the case if multiple annotations are applied
2924                      * to the record component declaration
2925                      */
2926                     rc.appendAttributes(s.getRawAttributes().stream().filter(anno -&gt;
2927                             Arrays.stream(getTargetNames(anno.type.tsym)).anyMatch(name -&gt; name == names.RECORD_COMPONENT)
2928                     ).collect(List.collector()));
2929                     rc.setTypeAttributes(s.getRawTypeAttributes());
2930                     // to get all the type annotations applied to the type
2931                     rc.type = s.type;
2932                 }
2933             }
2934         }
2935 
2936         /* the section below is tricky. Annotations applied to record components are propagated to the corresponding
2937          * record member so if an annotation has target: FIELD, it is propagated to the corresponding FIELD, if it has
2938          * target METHOD, it is propagated to the accessor and so on. But at the moment when method members are generated
2939          * there is no enough information to propagate only the right annotations. So all the annotations are propagated
2940          * to all the possible locations.
2941          *
2942          * At this point we need to remove all the annotations that are not in place before going on with the annotation
2943          * party. On top of the above there is the issue that there is no AST representing record components, just symbols
2944          * so the corresponding field has been holding all the annotations and it&#39;s metadata has been modified as if it
2945          * was both a field and a record component.
2946          *
2947          * So there are two places where we need to trim annotations from: the metadata of the symbol and / or the modifiers
2948          * in the AST. Whatever is in the metadata will be written to the class file, whatever is in the modifiers could
2949          * be see by annotation processors.
2950          *
2951          * The metadata contains both type annotations and declaration annotations. At this point of the game we don&#39;t
2952          * need to care about type annotations, they are all in the right place. But we could need to remove declaration
2953          * annotations. So for declaration annotations if they are not applicable to the record member, excluding type
2954          * annotations which are already correct, then we will remove it. For the AST modifiers if the annotation is not
2955          * applicable either as type annotation and or declaration annotation, only in that case it will be removed.
2956          *
2957          * So it could be that annotation is removed as a declaration annotation but it is kept in the AST modifier for
2958          * further inspection by annotation processors.
2959          *
2960          * For example:
2961          *
2962          *     import java.lang.annotation.*;
2963          *
2964          *     @Target({ElementType.TYPE_USE, ElementType.RECORD_COMPONENT})
2965          *     @Retention(RetentionPolicy.RUNTIME)
2966          *     @interface Anno { }
2967          *
2968          *     record R(@Anno String s) {}
2969          *
2970          * at this point we will have for the case of the generated field:
2971          *   - @Anno in the modifier
2972          *   - @Anno as a type annotation
2973          *   - @Anno as a declaration annotation
2974          *
2975          * the last one should be removed because the annotation has not FIELD as target but it was applied as a
2976          * declaration annotation because the field was being treated both as a field and as a record component
2977          * as we have already copied the annotations to the record component, now the field doesn&#39;t need to hold
2978          * annotations that are not intended for it anymore. Still @Anno has to be kept in the AST&#39;s modifiers as it
2979          * is applicable as a type annotation to the type of the field.
2980          */
2981 
2982         if (a.type.tsym.isAnnotationType()) {
2983             Optional&lt;Set&lt;Name&gt;&gt; applicableTargetsOp = getApplicableTargets(a, s);
2984             if (!applicableTargetsOp.isEmpty()) {
2985                 Set&lt;Name&gt; applicableTargets = applicableTargetsOp.get();
2986                 boolean notApplicableOrIsTypeUseOnly = applicableTargets.isEmpty() ||
2987                         applicableTargets.size() == 1 &amp;&amp; applicableTargets.contains(names.TYPE_USE);
2988                 boolean isRecordMemberWithNonApplicableDeclAnno =
2989                         isRecordMember &amp;&amp; (s.flags_field &amp; Flags.GENERATED_MEMBER) != 0 &amp;&amp; notApplicableOrIsTypeUseOnly;
2990 
2991                 if (applicableTargets.isEmpty() || isRecordMemberWithNonApplicableDeclAnno) {
2992                     if (isRecordMemberWithNonApplicableDeclAnno) {
2993                             /* so we have found an annotation that is not applicable to a record member that was generated by the
2994                              * compiler. This was intentionally done at TypeEnter, now is the moment strip away the annotations
2995                              * that are not applicable to the given record member
2996                              */
2997                         JCModifiers modifiers = TreeInfo.getModifiers(declarationTree);
2998                             /* lets first remove the annotation from the modifier if it is not applicable, we have to check again as
2999                              * it could be a type annotation
3000                              */
3001                         if (modifiers != null &amp;&amp; applicableTargets.isEmpty()) {
3002                             ListBuffer&lt;JCAnnotation&gt; newAnnotations = new ListBuffer&lt;&gt;();
3003                             for (JCAnnotation anno : modifiers.annotations) {
3004                                 if (anno != a) {
3005                                     newAnnotations.add(anno);
3006                                 }
3007                             }
3008                             modifiers.annotations = newAnnotations.toList();
3009                         }
3010                         // now lets remove it from the symbol
3011                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3012                     } else {
3013                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3014                     }
3015                 }
3016             }
3017         }
3018 
3019         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3020             if (s.kind != TYP) {
3021                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3022             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3023                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3024             }
3025         }
<a name="26" id="anc26"></a>






3026     }
3027 
3028     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3029         Assert.checkNonNull(a.type);
3030         validateAnnotationTree(a);
3031 
3032         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3033                 !a.annotationType.type.isErroneous() &amp;&amp;
3034                 !isTypeAnnotation(a, isTypeParameter)) {
3035             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3036         }
3037     }
3038 
3039     /**
3040      * Validate the proposed container &#39;repeatable&#39; on the
3041      * annotation type symbol &#39;s&#39;. Report errors at position
3042      * &#39;pos&#39;.
3043      *
3044      * @param s The (annotation)type declaration annotated with a @Repeatable
3045      * @param repeatable the @Repeatable on &#39;s&#39;
3046      * @param pos where to report errors
3047      */
3048     public void validateRepeatable(TypeSymbol s, Attribute.Compound repeatable, DiagnosticPosition pos) {
3049         Assert.check(types.isSameType(repeatable.type, syms.repeatableType));
3050 
3051         Type t = null;
3052         List&lt;Pair&lt;MethodSymbol,Attribute&gt;&gt; l = repeatable.values;
3053         if (!l.isEmpty()) {
3054             Assert.check(l.head.fst.name == names.value);
3055             t = ((Attribute.Class)l.head.snd).getValue();
3056         }
3057 
3058         if (t == null) {
3059             // errors should already have been reported during Annotate
3060             return;
3061         }
3062 
3063         validateValue(t.tsym, s, pos);
3064         validateRetention(t.tsym, s, pos);
3065         validateDocumented(t.tsym, s, pos);
3066         validateInherited(t.tsym, s, pos);
3067         validateTarget(t.tsym, s, pos);
3068         validateDefault(t.tsym, pos);
3069     }
3070 
3071     private void validateValue(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3072         Symbol sym = container.members().findFirst(names.value);
3073         if (sym != null &amp;&amp; sym.kind == MTH) {
3074             MethodSymbol m = (MethodSymbol) sym;
3075             Type ret = m.getReturnType();
3076             if (!(ret.hasTag(ARRAY) &amp;&amp; types.isSameType(((ArrayType)ret).elemtype, contained.type))) {
3077                 log.error(pos,
3078                           Errors.InvalidRepeatableAnnotationValueReturn(container,
3079                                                                         ret,
3080                                                                         types.makeArrayType(contained.type)));
3081             }
3082         } else {
3083             log.error(pos, Errors.InvalidRepeatableAnnotationNoValue(container));
3084         }
3085     }
3086 
3087     private void validateRetention(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3088         Attribute.RetentionPolicy containerRetention = types.getRetention(container);
3089         Attribute.RetentionPolicy containedRetention = types.getRetention(contained);
3090 
3091         boolean error = false;
3092         switch (containedRetention) {
3093         case RUNTIME:
3094             if (containerRetention != Attribute.RetentionPolicy.RUNTIME) {
3095                 error = true;
3096             }
3097             break;
3098         case CLASS:
3099             if (containerRetention == Attribute.RetentionPolicy.SOURCE)  {
3100                 error = true;
3101             }
3102         }
3103         if (error ) {
3104             log.error(pos,
3105                       Errors.InvalidRepeatableAnnotationRetention(container,
3106                                                                   containerRetention.name(),
3107                                                                   contained,
3108                                                                   containedRetention.name()));
3109         }
3110     }
3111 
3112     private void validateDocumented(Symbol container, Symbol contained, DiagnosticPosition pos) {
3113         if (contained.attribute(syms.documentedType.tsym) != null) {
3114             if (container.attribute(syms.documentedType.tsym) == null) {
3115                 log.error(pos, Errors.InvalidRepeatableAnnotationNotDocumented(container, contained));
3116             }
3117         }
3118     }
3119 
3120     private void validateInherited(Symbol container, Symbol contained, DiagnosticPosition pos) {
3121         if (contained.attribute(syms.inheritedType.tsym) != null) {
3122             if (container.attribute(syms.inheritedType.tsym) == null) {
3123                 log.error(pos, Errors.InvalidRepeatableAnnotationNotInherited(container, contained));
3124             }
3125         }
3126     }
3127 
3128     private void validateTarget(TypeSymbol container, TypeSymbol contained, DiagnosticPosition pos) {
3129         // The set of targets the container is applicable to must be a subset
3130         // (with respect to annotation target semantics) of the set of targets
3131         // the contained is applicable to. The target sets may be implicit or
3132         // explicit.
3133 
3134         Set&lt;Name&gt; containerTargets;
3135         Attribute.Array containerTarget = getAttributeTargetAttribute(container);
3136         if (containerTarget == null) {
3137             containerTargets = getDefaultTargetSet();
3138         } else {
3139             containerTargets = new HashSet&lt;&gt;();
3140             for (Attribute app : containerTarget.values) {
3141                 if (!(app instanceof Attribute.Enum)) {
3142                     continue; // recovery
3143                 }
3144                 Attribute.Enum e = (Attribute.Enum)app;
3145                 containerTargets.add(e.value.name);
3146             }
3147         }
3148 
3149         Set&lt;Name&gt; containedTargets;
3150         Attribute.Array containedTarget = getAttributeTargetAttribute(contained);
3151         if (containedTarget == null) {
3152             containedTargets = getDefaultTargetSet();
3153         } else {
3154             containedTargets = new HashSet&lt;&gt;();
3155             for (Attribute app : containedTarget.values) {
3156                 if (!(app instanceof Attribute.Enum)) {
3157                     continue; // recovery
3158                 }
3159                 Attribute.Enum e = (Attribute.Enum)app;
3160                 containedTargets.add(e.value.name);
3161             }
3162         }
3163 
3164         if (!isTargetSubsetOf(containerTargets, containedTargets)) {
3165             log.error(pos, Errors.InvalidRepeatableAnnotationIncompatibleTarget(container, contained));
3166         }
3167     }
3168 
3169     /* get a set of names for the default target */
3170     private Set&lt;Name&gt; getDefaultTargetSet() {
3171         if (defaultTargets == null) {
3172             Set&lt;Name&gt; targets = new HashSet&lt;&gt;();
3173             targets.add(names.ANNOTATION_TYPE);
3174             targets.add(names.CONSTRUCTOR);
3175             targets.add(names.FIELD);
3176             if (allowRecords) {
3177                 targets.add(names.RECORD_COMPONENT);
3178             }
3179             targets.add(names.LOCAL_VARIABLE);
3180             targets.add(names.METHOD);
3181             targets.add(names.PACKAGE);
3182             targets.add(names.PARAMETER);
3183             targets.add(names.TYPE);
3184 
3185             defaultTargets = java.util.Collections.unmodifiableSet(targets);
3186         }
3187 
3188         return defaultTargets;
3189     }
3190     private Set&lt;Name&gt; defaultTargets;
3191 
3192 
3193     /** Checks that s is a subset of t, with respect to ElementType
3194      * semantics, specifically {ANNOTATION_TYPE} is a subset of {TYPE},
3195      * and {TYPE_USE} covers the set {ANNOTATION_TYPE, TYPE, TYPE_USE,
3196      * TYPE_PARAMETER}.
3197      */
3198     private boolean isTargetSubsetOf(Set&lt;Name&gt; s, Set&lt;Name&gt; t) {
3199         // Check that all elements in s are present in t
3200         for (Name n2 : s) {
3201             boolean currentElementOk = false;
3202             for (Name n1 : t) {
3203                 if (n1 == n2) {
3204                     currentElementOk = true;
3205                     break;
3206                 } else if (n1 == names.TYPE &amp;&amp; n2 == names.ANNOTATION_TYPE) {
3207                     currentElementOk = true;
3208                     break;
3209                 } else if (n1 == names.TYPE_USE &amp;&amp;
3210                         (n2 == names.TYPE ||
3211                          n2 == names.ANNOTATION_TYPE ||
3212                          n2 == names.TYPE_PARAMETER)) {
3213                     currentElementOk = true;
3214                     break;
3215                 }
3216             }
3217             if (!currentElementOk)
3218                 return false;
3219         }
3220         return true;
3221     }
3222 
3223     private void validateDefault(Symbol container, DiagnosticPosition pos) {
3224         // validate that all other elements of containing type has defaults
3225         Scope scope = container.members();
3226         for(Symbol elm : scope.getSymbols()) {
3227             if (elm.name != names.value &amp;&amp;
3228                 elm.kind == MTH &amp;&amp;
3229                 ((MethodSymbol)elm).defaultValue == null) {
3230                 log.error(pos,
3231                           Errors.InvalidRepeatableAnnotationElemNondefault(container, elm));
3232             }
3233         }
3234     }
3235 
3236     /** Is s a method symbol that overrides a method in a superclass? */
3237     boolean isOverrider(Symbol s) {
3238         if (s.kind != MTH || s.isStatic())
3239             return false;
3240         MethodSymbol m = (MethodSymbol)s;
3241         TypeSymbol owner = (TypeSymbol)m.owner;
3242         for (Type sup : types.closure(owner.type)) {
3243             if (sup == owner.type)
3244                 continue; // skip &quot;this&quot;
3245             Scope scope = sup.tsym.members();
3246             for (Symbol sym : scope.getSymbolsByName(m.name)) {
3247                 if (!sym.isStatic() &amp;&amp; m.overrides(sym, owner, types, true))
3248                     return true;
3249             }
3250         }
3251         return false;
3252     }
3253 
3254     /** Is the annotation applicable to types? */
3255     protected boolean isTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3256         List&lt;Attribute&gt; targets = typeAnnotations.annotationTargets(a.annotationType.type.tsym);
3257         return (targets == null) ?
3258                 false :
3259                 targets.stream()
3260                         .anyMatch(attr -&gt; isTypeAnnotation(attr, isTypeParameter));
3261     }
3262     //where
3263         boolean isTypeAnnotation(Attribute a, boolean isTypeParameter) {
3264             Attribute.Enum e = (Attribute.Enum)a;
3265             return (e.value.name == names.TYPE_USE ||
3266                     (isTypeParameter &amp;&amp; e.value.name == names.TYPE_PARAMETER));
3267         }
3268 
3269     /** Is the annotation applicable to the symbol? */
3270     Name[] getTargetNames(JCAnnotation a) {
3271         return getTargetNames(a.annotationType.type.tsym);
3272     }
3273 
3274     public Name[] getTargetNames(TypeSymbol annoSym) {
3275         Attribute.Array arr = getAttributeTargetAttribute(annoSym);
3276         Name[] targets;
3277         if (arr == null) {
3278             targets = defaultTargetMetaInfo();
3279         } else {
3280             // TODO: can we optimize this?
3281             targets = new Name[arr.values.length];
3282             for (int i=0; i&lt;arr.values.length; ++i) {
3283                 Attribute app = arr.values[i];
3284                 if (!(app instanceof Attribute.Enum)) {
3285                     return new Name[0];
3286                 }
3287                 Attribute.Enum e = (Attribute.Enum) app;
3288                 targets[i] = e.value.name;
3289             }
3290         }
3291         return targets;
3292     }
3293 
3294     boolean annotationApplicable(JCAnnotation a, Symbol s) {
3295         Optional&lt;Set&lt;Name&gt;&gt; targets = getApplicableTargets(a, s);
3296         /* the optional could be emtpy if the annotation is unknown in that case
3297          * we return that it is applicable and if it is erroneous that should imply
3298          * an error at the declaration site
3299          */
3300         return targets.isEmpty() || targets.isPresent() &amp;&amp; !targets.get().isEmpty();
3301     }
3302 
3303     @SuppressWarnings(&quot;preview&quot;)
3304     Optional&lt;Set&lt;Name&gt;&gt; getApplicableTargets(JCAnnotation a, Symbol s) {
3305         Attribute.Array arr = getAttributeTargetAttribute(a.annotationType.type.tsym);
3306         Name[] targets;
3307         Set&lt;Name&gt; applicableTargets = new HashSet&lt;&gt;();
3308 
3309         if (arr == null) {
3310             targets = defaultTargetMetaInfo();
3311         } else {
3312             // TODO: can we optimize this?
3313             targets = new Name[arr.values.length];
3314             for (int i=0; i&lt;arr.values.length; ++i) {
3315                 Attribute app = arr.values[i];
3316                 if (!(app instanceof Attribute.Enum)) {
3317                     // recovery
3318                     return Optional.empty();
3319                 }
3320                 Attribute.Enum e = (Attribute.Enum) app;
3321                 targets[i] = e.value.name;
3322             }
3323         }
3324         for (Name target : targets) {
3325             if (target == names.TYPE) {
3326                 if (s.kind == TYP)
3327                     applicableTargets.add(names.TYPE);
3328             } else if (target == names.FIELD) {
3329                 if (s.kind == VAR &amp;&amp; s.owner.kind != MTH)
3330                     applicableTargets.add(names.FIELD);
3331             } else if (target == names.RECORD_COMPONENT) {
3332                 if (s.getKind() == ElementKind.RECORD_COMPONENT) {
3333                     applicableTargets.add(names.RECORD_COMPONENT);
3334                 }
3335             } else if (target == names.METHOD) {
3336                 if (s.kind == MTH &amp;&amp; !s.isConstructor())
3337                     applicableTargets.add(names.METHOD);
3338             } else if (target == names.PARAMETER) {
3339                 if (s.kind == VAR &amp;&amp;
3340                     (s.owner.kind == MTH &amp;&amp; (s.flags() &amp; PARAMETER) != 0)) {
3341                     applicableTargets.add(names.PARAMETER);
3342                 }
3343             } else if (target == names.CONSTRUCTOR) {
3344                 if (s.kind == MTH &amp;&amp; s.isConstructor())
3345                     applicableTargets.add(names.CONSTRUCTOR);
3346             } else if (target == names.LOCAL_VARIABLE) {
3347                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp;
3348                       (s.flags() &amp; PARAMETER) == 0) {
3349                     applicableTargets.add(names.LOCAL_VARIABLE);
3350                 }
3351             } else if (target == names.ANNOTATION_TYPE) {
3352                 if (s.kind == TYP &amp;&amp; (s.flags() &amp; ANNOTATION) != 0) {
3353                     applicableTargets.add(names.ANNOTATION_TYPE);
3354                 }
3355             } else if (target == names.PACKAGE) {
3356                 if (s.kind == PCK)
3357                     applicableTargets.add(names.PACKAGE);
3358             } else if (target == names.TYPE_USE) {
3359                 if (s.kind == VAR &amp;&amp; s.owner.kind == MTH &amp;&amp; s.type.hasTag(NONE)) {
3360                     //cannot type annotate implicitly typed locals
3361                     continue;
3362                 } else if (s.kind == TYP || s.kind == VAR ||
3363                         (s.kind == MTH &amp;&amp; !s.isConstructor() &amp;&amp;
3364                                 !s.type.getReturnType().hasTag(VOID)) ||
3365                         (s.kind == MTH &amp;&amp; s.isConstructor())) {
3366                     applicableTargets.add(names.TYPE_USE);
3367                 }
3368             } else if (target == names.TYPE_PARAMETER) {
3369                 if (s.kind == TYP &amp;&amp; s.type.hasTag(TYPEVAR))
3370                     applicableTargets.add(names.TYPE_PARAMETER);
3371             } else
3372                 return Optional.empty(); // Unknown ElementType. This should be an error at declaration site,
3373                                          // assume applicable.
3374         }
3375         return Optional.of(applicableTargets);
3376     }
3377 
3378     Attribute.Array getAttributeTargetAttribute(TypeSymbol s) {
3379         Attribute.Compound atTarget = s.getAnnotationTypeMetadata().getTarget();
3380         if (atTarget == null) return null; // ok, is applicable
3381         Attribute atValue = atTarget.member(names.value);
3382         if (!(atValue instanceof Attribute.Array)) return null; // error recovery
3383         return (Attribute.Array) atValue;
3384     }
3385 
3386     public final Name[] dfltTargetMeta;
3387     private Name[] defaultTargetMetaInfo() {
3388         return dfltTargetMeta;
3389     }
3390 
3391     /** Check an annotation value.
3392      *
3393      * @param a The annotation tree to check
3394      * @return true if this annotation tree is valid, otherwise false
3395      */
3396     public boolean validateAnnotationDeferErrors(JCAnnotation a) {
3397         boolean res = false;
3398         final Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
3399         try {
3400             res = validateAnnotation(a);
3401         } finally {
3402             log.popDiagnosticHandler(diagHandler);
3403         }
3404         return res;
3405     }
3406 
3407     private boolean validateAnnotation(JCAnnotation a) {
3408         boolean isValid = true;
3409         AnnotationTypeMetadata metadata = a.annotationType.type.tsym.getAnnotationTypeMetadata();
3410 
3411         // collect an inventory of the annotation elements
3412         Set&lt;MethodSymbol&gt; elements = metadata.getAnnotationElements();
3413 
3414         // remove the ones that are assigned values
3415         for (JCTree arg : a.args) {
3416             if (!arg.hasTag(ASSIGN)) continue; // recovery
3417             JCAssign assign = (JCAssign)arg;
3418             Symbol m = TreeInfo.symbol(assign.lhs);
3419             if (m == null || m.type.isErroneous()) continue;
3420             if (!elements.remove(m)) {
3421                 isValid = false;
3422                 log.error(assign.lhs.pos(),
3423                           Errors.DuplicateAnnotationMemberValue(m.name, a.type));
3424             }
3425         }
3426 
3427         // all the remaining ones better have default values
3428         List&lt;Name&gt; missingDefaults = List.nil();
3429         Set&lt;MethodSymbol&gt; membersWithDefault = metadata.getAnnotationElementsWithDefault();
3430         for (MethodSymbol m : elements) {
3431             if (m.type.isErroneous())
3432                 continue;
3433 
3434             if (!membersWithDefault.contains(m))
3435                 missingDefaults = missingDefaults.append(m.name);
3436         }
3437         missingDefaults = missingDefaults.reverse();
3438         if (missingDefaults.nonEmpty()) {
3439             isValid = false;
3440             Error errorKey = (missingDefaults.size() &gt; 1)
3441                     ? Errors.AnnotationMissingDefaultValue1(a.type, missingDefaults)
3442                     : Errors.AnnotationMissingDefaultValue(a.type, missingDefaults);
3443             log.error(a.pos(), errorKey);
3444         }
3445 
3446         return isValid &amp;&amp; validateTargetAnnotationValue(a);
3447     }
3448 
3449     /* Validate the special java.lang.annotation.Target annotation */
3450     boolean validateTargetAnnotationValue(JCAnnotation a) {
3451         // special case: java.lang.annotation.Target must not have
3452         // repeated values in its value member
3453         if (a.annotationType.type.tsym != syms.annotationTargetType.tsym ||
3454                 a.args.tail == null)
3455             return true;
3456 
3457         boolean isValid = true;
3458         if (!a.args.head.hasTag(ASSIGN)) return false; // error recovery
3459         JCAssign assign = (JCAssign) a.args.head;
3460         Symbol m = TreeInfo.symbol(assign.lhs);
3461         if (m.name != names.value) return false;
3462         JCTree rhs = assign.rhs;
3463         if (!rhs.hasTag(NEWARRAY)) return false;
3464         JCNewArray na = (JCNewArray) rhs;
3465         Set&lt;Symbol&gt; targets = new HashSet&lt;&gt;();
3466         for (JCTree elem : na.elems) {
3467             if (!targets.add(TreeInfo.symbol(elem))) {
3468                 isValid = false;
3469                 log.error(elem.pos(), Errors.RepeatedAnnotationTarget);
3470             }
3471         }
3472         return isValid;
3473     }
3474 
3475     void checkDeprecatedAnnotation(DiagnosticPosition pos, Symbol s) {
3476         if (lint.isEnabled(LintCategory.DEP_ANN) &amp;&amp; s.isDeprecatableViaAnnotation() &amp;&amp;
3477             (s.flags() &amp; DEPRECATED) != 0 &amp;&amp;
3478             !syms.deprecatedType.isErroneous() &amp;&amp;
3479             s.attribute(syms.deprecatedType.tsym) == null) {
3480             log.warning(LintCategory.DEP_ANN,
3481                     pos, Warnings.MissingDeprecatedAnnotation);
3482         }
3483         // Note: @Deprecated has no effect on local variables, parameters and package decls.
3484         if (lint.isEnabled(LintCategory.DEPRECATION) &amp;&amp; !s.isDeprecatableViaAnnotation()) {
3485             if (!syms.deprecatedType.isErroneous() &amp;&amp; s.attribute(syms.deprecatedType.tsym) != null) {
3486                 log.warning(LintCategory.DEPRECATION, pos,
3487                             Warnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));
3488             }
3489         }
3490     }
3491 
3492     void checkDeprecated(final DiagnosticPosition pos, final Symbol other, final Symbol s) {
3493         checkDeprecated(() -&gt; pos, other, s);
3494     }
3495 
3496     void checkDeprecated(Supplier&lt;DiagnosticPosition&gt; pos, final Symbol other, final Symbol s) {
3497         if ( (s.isDeprecatedForRemoval()
3498                 || s.isDeprecated() &amp;&amp; !other.isDeprecated())
3499                 &amp;&amp; (s.outermostClass() != other.outermostClass() || s.outermostClass() == null)) {
3500             deferredLintHandler.report(() -&gt; warnDeprecated(pos.get(), s));
3501         }
3502     }
3503 
3504     void checkSunAPI(final DiagnosticPosition pos, final Symbol s) {
3505         if ((s.flags() &amp; PROPRIETARY) != 0) {
3506             deferredLintHandler.report(() -&gt; {
3507                 log.mandatoryWarning(pos, Warnings.SunProprietary(s));
3508             });
3509         }
3510     }
3511 
3512     void checkProfile(final DiagnosticPosition pos, final Symbol s) {
3513         if (profile != Profile.DEFAULT &amp;&amp; (s.flags() &amp; NOT_IN_PROFILE) != 0) {
3514             log.error(pos, Errors.NotInProfile(s, profile));
3515         }
3516     }
3517 
3518     void checkPreview(DiagnosticPosition pos, Symbol s) {
3519         if ((s.flags() &amp; PREVIEW_API) != 0) {
3520             if ((s.flags() &amp; PREVIEW_ESSENTIAL_API) != 0 &amp;&amp; !preview.isEnabled()) {
3521                 log.error(pos, Errors.IsPreview(s));
3522             } else {
3523                 deferredLintHandler.report(() -&gt; warnPreview(pos, s));
3524             }
3525         }
3526     }
3527 
3528 /* *************************************************************************
3529  * Check for recursive annotation elements.
3530  **************************************************************************/
3531 
3532     /** Check for cycles in the graph of annotation elements.
3533      */
3534     void checkNonCyclicElements(JCClassDecl tree) {
3535         if ((tree.sym.flags_field &amp; ANNOTATION) == 0) return;
3536         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);
3537         try {
3538             tree.sym.flags_field |= LOCKED;
3539             for (JCTree def : tree.defs) {
3540                 if (!def.hasTag(METHODDEF)) continue;
3541                 JCMethodDecl meth = (JCMethodDecl)def;
3542                 checkAnnotationResType(meth.pos(), meth.restype.type);
3543             }
3544         } finally {
3545             tree.sym.flags_field &amp;= ~LOCKED;
3546             tree.sym.flags_field |= ACYCLIC_ANN;
3547         }
3548     }
3549 
3550     void checkNonCyclicElementsInternal(DiagnosticPosition pos, TypeSymbol tsym) {
3551         if ((tsym.flags_field &amp; ACYCLIC_ANN) != 0)
3552             return;
3553         if ((tsym.flags_field &amp; LOCKED) != 0) {
3554             log.error(pos, Errors.CyclicAnnotationElement(tsym));
3555             return;
3556         }
3557         try {
3558             tsym.flags_field |= LOCKED;
3559             for (Symbol s : tsym.members().getSymbols(NON_RECURSIVE)) {
3560                 if (s.kind != MTH)
3561                     continue;
3562                 checkAnnotationResType(pos, ((MethodSymbol)s).type.getReturnType());
3563             }
3564         } finally {
3565             tsym.flags_field &amp;= ~LOCKED;
3566             tsym.flags_field |= ACYCLIC_ANN;
3567         }
3568     }
3569 
3570     void checkAnnotationResType(DiagnosticPosition pos, Type type) {
3571         switch (type.getTag()) {
3572         case CLASS:
3573             if ((type.tsym.flags() &amp; ANNOTATION) != 0)
3574                 checkNonCyclicElementsInternal(pos, type.tsym);
3575             break;
3576         case ARRAY:
3577             checkAnnotationResType(pos, types.elemtype(type));
3578             break;
3579         default:
3580             break; // int etc
3581         }
3582     }
3583 
3584 /* *************************************************************************
3585  * Check for cycles in the constructor call graph.
3586  **************************************************************************/
3587 
3588     /** Check for cycles in the graph of constructors calling other
3589      *  constructors.
3590      */
3591     void checkCyclicConstructors(JCClassDecl tree) {
3592         Map&lt;Symbol,Symbol&gt; callMap = new HashMap&lt;&gt;();
3593 
3594         // enter each constructor this-call into the map
3595         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
3596             JCMethodInvocation app = TreeInfo.firstConstructorCall(l.head);
3597             if (app == null) continue;
3598             JCMethodDecl meth = (JCMethodDecl) l.head;
3599             if (TreeInfo.name(app.meth) == names._this) {
3600                 callMap.put(meth.sym, TreeInfo.symbol(app.meth));
3601             } else {
3602                 meth.sym.flags_field |= ACYCLIC;
3603             }
3604         }
3605 
3606         // Check for cycles in the map
3607         Symbol[] ctors = new Symbol[0];
3608         ctors = callMap.keySet().toArray(ctors);
3609         for (Symbol caller : ctors) {
3610             checkCyclicConstructor(tree, caller, callMap);
3611         }
3612     }
3613 
3614     /** Look in the map to see if the given constructor is part of a
3615      *  call cycle.
3616      */
3617     private void checkCyclicConstructor(JCClassDecl tree, Symbol ctor,
3618                                         Map&lt;Symbol,Symbol&gt; callMap) {
3619         if (ctor != null &amp;&amp; (ctor.flags_field &amp; ACYCLIC) == 0) {
3620             if ((ctor.flags_field &amp; LOCKED) != 0) {
3621                 log.error(TreeInfo.diagnosticPositionFor(ctor, tree),
3622                           Errors.RecursiveCtorInvocation);
3623             } else {
3624                 ctor.flags_field |= LOCKED;
3625                 checkCyclicConstructor(tree, callMap.remove(ctor), callMap);
3626                 ctor.flags_field &amp;= ~LOCKED;
3627             }
3628             ctor.flags_field |= ACYCLIC;
3629         }
3630     }
3631 
3632 /* *************************************************************************
3633  * Miscellaneous
3634  **************************************************************************/
3635 
3636     /**
3637      *  Check for division by integer constant zero
3638      *  @param pos           Position for error reporting.
3639      *  @param operator      The operator for the expression
3640      *  @param operand       The right hand operand for the expression
3641      */
3642     void checkDivZero(final DiagnosticPosition pos, Symbol operator, Type operand) {
3643         if (operand.constValue() != null
3644             &amp;&amp; operand.getTag().isSubRangeOf(LONG)
3645             &amp;&amp; ((Number) (operand.constValue())).longValue() == 0) {
3646             int opc = ((OperatorSymbol)operator).opcode;
3647             if (opc == ByteCodes.idiv || opc == ByteCodes.imod
3648                 || opc == ByteCodes.ldiv || opc == ByteCodes.lmod) {
3649                 deferredLintHandler.report(() -&gt; warnDivZero(pos));
3650             }
3651         }
3652     }
3653 
3654     /**
3655      * Check for empty statements after if
3656      */
3657     void checkEmptyIf(JCIf tree) {
3658         if (tree.thenpart.hasTag(SKIP) &amp;&amp; tree.elsepart == null &amp;&amp;
3659                 lint.isEnabled(LintCategory.EMPTY))
3660             log.warning(LintCategory.EMPTY, tree.thenpart.pos(), Warnings.EmptyIf);
3661     }
3662 
3663     /** Check that symbol is unique in given scope.
3664      *  @param pos           Position for error reporting.
3665      *  @param sym           The symbol.
3666      *  @param s             The scope.
3667      */
3668     boolean checkUnique(DiagnosticPosition pos, Symbol sym, Scope s) {
3669         if (sym.type.isErroneous())
3670             return true;
3671         if (sym.owner.name == names.any) return false;
3672         for (Symbol byName : s.getSymbolsByName(sym.name, NON_RECURSIVE)) {
3673             if (sym != byName &amp;&amp;
3674                     (byName.flags() &amp; CLASH) == 0 &amp;&amp;
3675                     sym.kind == byName.kind &amp;&amp;
3676                     sym.name != names.error &amp;&amp;
3677                     (sym.kind != MTH ||
3678                      types.hasSameArgs(sym.type, byName.type) ||
3679                      types.hasSameArgs(types.erasure(sym.type), types.erasure(byName.type)))) {
3680                 if ((sym.flags() &amp; VARARGS) != (byName.flags() &amp; VARARGS)) {
3681                     sym.flags_field |= CLASH;
3682                     varargsDuplicateError(pos, sym, byName);
3683                     return true;
3684                 } else if (sym.kind == MTH &amp;&amp; !types.hasSameArgs(sym.type, byName.type, false)) {
3685                     duplicateErasureError(pos, sym, byName);
3686                     sym.flags_field |= CLASH;
3687                     return true;
3688                 } else if ((sym.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3689                            (byName.flags() &amp; MATCH_BINDING) != 0 &amp;&amp;
3690                            (byName.flags() &amp; MATCH_BINDING_TO_OUTER) == 0) {
3691                     if (!sym.type.isErroneous()) {
3692                         log.error(pos, Errors.MatchBindingExists);
3693                         sym.flags_field |= CLASH;
3694                     }
3695                     return false;
3696                 } else {
3697                     duplicateError(pos, byName);
3698                     return false;
3699                 }
3700             }
3701         }
3702         return true;
3703     }
3704 
3705     /** Report duplicate declaration error.
3706      */
3707     void duplicateErasureError(DiagnosticPosition pos, Symbol sym1, Symbol sym2) {
3708         if (!sym1.type.isErroneous() &amp;&amp; !sym2.type.isErroneous()) {
3709             log.error(pos, Errors.NameClashSameErasure(sym1, sym2));
3710         }
3711     }
3712 
3713     /**Check that types imported through the ordinary imports don&#39;t clash with types imported
3714      * by other (static or ordinary) imports. Note that two static imports may import two clashing
3715      * types without an error on the imports.
3716      * @param toplevel       The toplevel tree for which the test should be performed.
3717      */
3718     void checkImportsUnique(JCCompilationUnit toplevel) {
3719         WriteableScope ordinallyImportedSoFar = WriteableScope.create(toplevel.packge);
3720         WriteableScope staticallyImportedSoFar = WriteableScope.create(toplevel.packge);
3721         WriteableScope topLevelScope = toplevel.toplevelScope;
3722 
3723         for (JCTree def : toplevel.defs) {
3724             if (!def.hasTag(IMPORT))
3725                 continue;
3726 
3727             JCImport imp = (JCImport) def;
3728 
3729             if (imp.importScope == null)
3730                 continue;
3731 
3732             for (Symbol sym : imp.importScope.getSymbols(sym -&gt; sym.kind == TYP)) {
3733                 if (imp.isStatic()) {
3734                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, true);
3735                     staticallyImportedSoFar.enter(sym);
3736                 } else {
3737                     checkUniqueImport(imp.pos(), ordinallyImportedSoFar, staticallyImportedSoFar, topLevelScope, sym, false);
3738                     ordinallyImportedSoFar.enter(sym);
3739                 }
3740             }
3741 
3742             imp.importScope = null;
3743         }
3744     }
3745 
3746     /** Check that single-type import is not already imported or top-level defined,
3747      *  but make an exception for two single-type imports which denote the same type.
3748      *  @param pos                     Position for error reporting.
3749      *  @param ordinallyImportedSoFar  A Scope containing types imported so far through
3750      *                                 ordinary imports.
3751      *  @param staticallyImportedSoFar A Scope containing types imported so far through
3752      *                                 static imports.
3753      *  @param topLevelScope           The current file&#39;s top-level Scope
3754      *  @param sym                     The symbol.
3755      *  @param staticImport            Whether or not this was a static import
3756      */
3757     private boolean checkUniqueImport(DiagnosticPosition pos, Scope ordinallyImportedSoFar,
3758                                       Scope staticallyImportedSoFar, Scope topLevelScope,
3759                                       Symbol sym, boolean staticImport) {
3760         Filter&lt;Symbol&gt; duplicates = candidate -&gt; candidate != sym &amp;&amp; !candidate.type.isErroneous();
3761         Symbol ordinaryClashing = ordinallyImportedSoFar.findFirst(sym.name, duplicates);
3762         Symbol staticClashing = null;
3763         if (ordinaryClashing == null &amp;&amp; !staticImport) {
3764             staticClashing = staticallyImportedSoFar.findFirst(sym.name, duplicates);
3765         }
3766         if (ordinaryClashing != null || staticClashing != null) {
3767             if (ordinaryClashing != null)
3768                 log.error(pos, Errors.AlreadyDefinedSingleImport(ordinaryClashing));
3769             else
3770                 log.error(pos, Errors.AlreadyDefinedStaticSingleImport(staticClashing));
3771             return false;
3772         }
3773         Symbol clashing = topLevelScope.findFirst(sym.name, duplicates);
3774         if (clashing != null) {
3775             log.error(pos, Errors.AlreadyDefinedThisUnit(clashing));
3776             return false;
3777         }
3778         return true;
3779     }
3780 
3781     /** Check that a qualified name is in canonical form (for import decls).
3782      */
3783     public void checkCanonical(JCTree tree) {
3784         if (!isCanonical(tree))
3785             log.error(tree.pos(),
3786                       Errors.ImportRequiresCanonical(TreeInfo.symbol(tree)));
3787     }
3788         // where
3789         private boolean isCanonical(JCTree tree) {
3790             while (tree.hasTag(SELECT)) {
3791                 JCFieldAccess s = (JCFieldAccess) tree;
3792                 if (s.sym.owner.getQualifiedName() != TreeInfo.symbol(s.selected).getQualifiedName())
3793                     return false;
3794                 tree = s.selected;
3795             }
3796             return true;
3797         }
3798 
3799     /** Check that an auxiliary class is not accessed from any other file than its own.
3800      */
3801     void checkForBadAuxiliaryClassAccess(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, ClassSymbol c) {
3802         if (lint.isEnabled(Lint.LintCategory.AUXILIARYCLASS) &amp;&amp;
3803             (c.flags() &amp; AUXILIARY) != 0 &amp;&amp;
3804             rs.isAccessible(env, c) &amp;&amp;
3805             !fileManager.isSameFile(c.sourcefile, env.toplevel.sourcefile))
3806         {
3807             log.warning(pos,
3808                         Warnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));
3809         }
3810     }
3811 
3812     private class ConversionWarner extends Warner {
3813         final String uncheckedKey;
3814         final Type found;
3815         final Type expected;
3816         public ConversionWarner(DiagnosticPosition pos, String uncheckedKey, Type found, Type expected) {
3817             super(pos);
3818             this.uncheckedKey = uncheckedKey;
3819             this.found = found;
3820             this.expected = expected;
3821         }
3822 
3823         @Override
3824         public void warn(LintCategory lint) {
3825             boolean warned = this.warned;
3826             super.warn(lint);
3827             if (warned) return; // suppress redundant diagnostics
3828             switch (lint) {
3829                 case UNCHECKED:
3830                     Check.this.warnUnchecked(pos(), Warnings.ProbFoundReq(diags.fragment(uncheckedKey), found, expected));
3831                     break;
3832                 case VARARGS:
3833                     if (method != null &amp;&amp;
3834                             method.attribute(syms.trustMeType.tsym) != null &amp;&amp;
3835                             isTrustMeAllowedOnMethod(method) &amp;&amp;
3836                             !types.isReifiable(method.type.getParameterTypes().last())) {
3837                         Check.this.warnUnsafeVararg(pos(), Warnings.VarargsUnsafeUseVarargsParam(method.params.last()));
3838                     }
3839                     break;
3840                 default:
3841                     throw new AssertionError(&quot;Unexpected lint: &quot; + lint);
3842             }
3843         }
3844     }
3845 
3846     public Warner castWarner(DiagnosticPosition pos, Type found, Type expected) {
3847         return new ConversionWarner(pos, &quot;unchecked.cast.to.type&quot;, found, expected);
3848     }
3849 
3850     public Warner convertWarner(DiagnosticPosition pos, Type found, Type expected) {
3851         return new ConversionWarner(pos, &quot;unchecked.assign&quot;, found, expected);
3852     }
3853 
3854     public void checkFunctionalInterface(JCClassDecl tree, ClassSymbol cs) {
3855         Compound functionalType = cs.attribute(syms.functionalInterfaceType.tsym);
3856 
3857         if (functionalType != null) {
3858             try {
3859                 types.findDescriptorSymbol((TypeSymbol)cs);
3860             } catch (Types.FunctionDescriptorLookupError ex) {
3861                 DiagnosticPosition pos = tree.pos();
3862                 for (JCAnnotation a : tree.getModifiers().annotations) {
3863                     if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3864                         pos = a.pos();
3865                         break;
3866                     }
3867                 }
3868                 log.error(pos, Errors.BadFunctionalIntfAnno1(ex.getDiagnostic()));
3869             }
3870         }
3871     }
3872 
3873     public void checkImportsResolvable(final JCCompilationUnit toplevel) {
3874         for (final JCImport imp : toplevel.getImports()) {
3875             if (!imp.staticImport || !imp.qualid.hasTag(SELECT))
3876                 continue;
3877             final JCFieldAccess select = (JCFieldAccess) imp.qualid;
3878             final Symbol origin;
3879             if (select.name == names.asterisk || (origin = TreeInfo.symbol(select.selected)) == null || origin.kind != TYP)
3880                 continue;
3881 
3882             TypeSymbol site = (TypeSymbol) TreeInfo.symbol(select.selected);
3883             if (!checkTypeContainsImportableElement(site, site, toplevel.packge, select.name, new HashSet&lt;Symbol&gt;())) {
3884                 log.error(imp.pos(),
3885                           Errors.CantResolveLocation(KindName.STATIC,
3886                                                      select.name,
3887                                                      null,
3888                                                      null,
3889                                                      Fragments.Location(kindName(site),
3890                                                                         site,
3891                                                                         null)));
3892             }
3893         }
3894     }
3895 
3896     // Check that packages imported are in scope (JLS 7.4.3, 6.3, 6.5.3.1, 6.5.3.2)
3897     public void checkImportedPackagesObservable(final JCCompilationUnit toplevel) {
3898         OUTER: for (JCImport imp : toplevel.getImports()) {
3899             if (!imp.staticImport &amp;&amp; TreeInfo.name(imp.qualid) == names.asterisk) {
3900                 TypeSymbol tsym = ((JCFieldAccess)imp.qualid).selected.type.tsym;
3901                 if (tsym.kind == PCK &amp;&amp; tsym.members().isEmpty() &amp;&amp;
3902                     !(Feature.IMPORT_ON_DEMAND_OBSERVABLE_PACKAGES.allowedInSource(source) &amp;&amp; tsym.exists())) {
3903                     log.error(DiagnosticFlag.RESOLVE_ERROR, imp.pos, Errors.DoesntExist(tsym));
3904                 }
3905             }
3906         }
3907     }
3908 
3909     private boolean checkTypeContainsImportableElement(TypeSymbol tsym, TypeSymbol origin, PackageSymbol packge, Name name, Set&lt;Symbol&gt; processed) {
3910         if (tsym == null || !processed.add(tsym))
3911             return false;
3912 
3913             // also search through inherited names
3914         if (checkTypeContainsImportableElement(types.supertype(tsym.type).tsym, origin, packge, name, processed))
3915             return true;
3916 
3917         for (Type t : types.interfaces(tsym.type))
3918             if (checkTypeContainsImportableElement(t.tsym, origin, packge, name, processed))
3919                 return true;
3920 
3921         for (Symbol sym : tsym.members().getSymbolsByName(name)) {
3922             if (sym.isStatic() &amp;&amp;
3923                 importAccessible(sym, packge) &amp;&amp;
3924                 sym.isMemberOf(origin, types)) {
3925                 return true;
3926             }
3927         }
3928 
3929         return false;
3930     }
3931 
3932     // is the sym accessible everywhere in packge?
3933     public boolean importAccessible(Symbol sym, PackageSymbol packge) {
3934         try {
3935             int flags = (int)(sym.flags() &amp; AccessFlags);
3936             switch (flags) {
3937             default:
3938             case PUBLIC:
3939                 return true;
3940             case PRIVATE:
3941                 return false;
3942             case 0:
3943             case PROTECTED:
3944                 return sym.packge() == packge;
3945             }
3946         } catch (ClassFinder.BadClassFile err) {
3947             throw err;
3948         } catch (CompletionFailure ex) {
3949             return false;
3950         }
3951     }
3952 
3953     public void checkLeaksNotAccessible(Env&lt;AttrContext&gt; env, JCClassDecl check) {
3954         JCCompilationUnit toplevel = env.toplevel;
3955 
3956         if (   toplevel.modle == syms.unnamedModule
3957             || toplevel.modle == syms.noModule
3958             || (check.sym.flags() &amp; COMPOUND) != 0) {
3959             return ;
3960         }
3961 
3962         ExportsDirective currentExport = findExport(toplevel.packge);
3963 
3964         if (   currentExport == null //not exported
3965             || currentExport.modules != null) //don&#39;t check classes in qualified export
3966             return ;
3967 
3968         new TreeScanner() {
3969             Lint lint = env.info.lint;
3970             boolean inSuperType;
3971 
3972             @Override
3973             public void visitBlock(JCBlock tree) {
3974             }
3975             @Override
3976             public void visitMethodDef(JCMethodDecl tree) {
3977                 if (!isAPISymbol(tree.sym))
3978                     return;
3979                 Lint prevLint = lint;
3980                 try {
3981                     lint = lint.augment(tree.sym);
3982                     if (lint.isEnabled(LintCategory.EXPORTS)) {
3983                         super.visitMethodDef(tree);
3984                     }
3985                 } finally {
3986                     lint = prevLint;
3987                 }
3988             }
3989             @Override
3990             public void visitVarDef(JCVariableDecl tree) {
3991                 if (!isAPISymbol(tree.sym) &amp;&amp; tree.sym.owner.kind != MTH)
3992                     return;
3993                 Lint prevLint = lint;
3994                 try {
3995                     lint = lint.augment(tree.sym);
3996                     if (lint.isEnabled(LintCategory.EXPORTS)) {
3997                         scan(tree.mods);
3998                         scan(tree.vartype);
3999                     }
4000                 } finally {
4001                     lint = prevLint;
4002                 }
4003             }
4004             @Override
4005             public void visitClassDef(JCClassDecl tree) {
4006                 if (tree != check)
4007                     return ;
4008 
4009                 if (!isAPISymbol(tree.sym))
4010                     return ;
4011 
4012                 Lint prevLint = lint;
4013                 try {
4014                     lint = lint.augment(tree.sym);
4015                     if (lint.isEnabled(LintCategory.EXPORTS)) {
4016                         scan(tree.mods);
4017                         scan(tree.typarams);
4018                         try {
4019                             inSuperType = true;
4020                             scan(tree.extending);
4021                             scan(tree.implementing);
4022                         } finally {
4023                             inSuperType = false;
4024                         }
4025                         scan(tree.defs);
4026                     }
4027                 } finally {
4028                     lint = prevLint;
4029                 }
4030             }
4031             @Override
4032             public void visitTypeApply(JCTypeApply tree) {
4033                 scan(tree.clazz);
4034                 boolean oldInSuperType = inSuperType;
4035                 try {
4036                     inSuperType = false;
4037                     scan(tree.arguments);
4038                 } finally {
4039                     inSuperType = oldInSuperType;
4040                 }
4041             }
4042             @Override
4043             public void visitIdent(JCIdent tree) {
4044                 Symbol sym = TreeInfo.symbol(tree);
4045                 if (sym.kind == TYP &amp;&amp; !sym.type.hasTag(TYPEVAR)) {
4046                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4047                 }
4048             }
4049 
4050             @Override
4051             public void visitSelect(JCFieldAccess tree) {
4052                 Symbol sym = TreeInfo.symbol(tree);
4053                 Symbol sitesym = TreeInfo.symbol(tree.selected);
4054                 if (sym.kind == TYP &amp;&amp; sitesym.kind == PCK) {
4055                     checkVisible(tree.pos(), sym, toplevel.packge, inSuperType);
4056                 } else {
4057                     super.visitSelect(tree);
4058                 }
4059             }
4060 
4061             @Override
4062             public void visitAnnotation(JCAnnotation tree) {
4063                 if (tree.attribute.type.tsym.getAnnotation(java.lang.annotation.Documented.class) != null)
4064                     super.visitAnnotation(tree);
4065             }
4066 
4067         }.scan(check);
4068     }
4069         //where:
4070         private ExportsDirective findExport(PackageSymbol pack) {
4071             for (ExportsDirective d : pack.modle.exports) {
4072                 if (d.packge == pack)
4073                     return d;
4074             }
4075 
4076             return null;
4077         }
4078         private boolean isAPISymbol(Symbol sym) {
4079             while (sym.kind != PCK) {
4080                 if ((sym.flags() &amp; Flags.PUBLIC) == 0 &amp;&amp; (sym.flags() &amp; Flags.PROTECTED) == 0) {
4081                     return false;
4082                 }
4083                 sym = sym.owner;
4084             }
4085             return true;
4086         }
4087         private void checkVisible(DiagnosticPosition pos, Symbol what, PackageSymbol inPackage, boolean inSuperType) {
4088             if (!isAPISymbol(what) &amp;&amp; !inSuperType) { //package private/private element
4089                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessible(kindName(what), what, what.packge().modle));
4090                 return ;
4091             }
4092 
4093             PackageSymbol whatPackage = what.packge();
4094             ExportsDirective whatExport = findExport(whatPackage);
4095             ExportsDirective inExport = findExport(inPackage);
4096 
4097             if (whatExport == null) { //package not exported:
4098                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexported(kindName(what), what, what.packge().modle));
4099                 return ;
4100             }
4101 
4102             if (whatExport.modules != null) {
4103                 if (inExport.modules == null || !whatExport.modules.containsAll(inExport.modules)) {
4104                     log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleUnexportedQualified(kindName(what), what, what.packge().modle));
4105                 }
4106             }
4107 
4108             if (whatPackage.modle != inPackage.modle &amp;&amp; whatPackage.modle != syms.java_base) {
4109                 //check that relativeTo.modle requires transitive what.modle, somehow:
4110                 List&lt;ModuleSymbol&gt; todo = List.of(inPackage.modle);
4111 
4112                 while (todo.nonEmpty()) {
4113                     ModuleSymbol current = todo.head;
4114                     todo = todo.tail;
4115                     if (current == whatPackage.modle)
4116                         return ; //OK
4117                     if ((current.flags() &amp; Flags.AUTOMATIC_MODULE) != 0)
4118                         continue; //for automatic modules, don&#39;t look into their dependencies
4119                     for (RequiresDirective req : current.requires) {
4120                         if (req.isTransitive()) {
4121                             todo = todo.prepend(req.module);
4122                         }
4123                     }
4124                 }
4125 
4126                 log.warning(LintCategory.EXPORTS, pos, Warnings.LeaksNotAccessibleNotRequiredTransitive(kindName(what), what, what.packge().modle));
4127             }
4128         }
4129 
4130     void checkModuleExists(final DiagnosticPosition pos, ModuleSymbol msym) {
4131         if (msym.kind != MDL) {
4132             deferredLintHandler.report(() -&gt; {
4133                 if (lint.isEnabled(LintCategory.MODULE))
4134                     log.warning(LintCategory.MODULE, pos, Warnings.ModuleNotFound(msym));
4135             });
4136         }
4137     }
4138 
4139     void checkPackageExistsForOpens(final DiagnosticPosition pos, PackageSymbol packge) {
4140         if (packge.members().isEmpty() &amp;&amp;
4141             ((packge.flags() &amp; Flags.HAS_RESOURCE) == 0)) {
4142             deferredLintHandler.report(() -&gt; {
4143                 if (lint.isEnabled(LintCategory.OPENS))
4144                     log.warning(pos, Warnings.PackageEmptyOrNotFound(packge));
4145             });
4146         }
4147     }
4148 
4149     void checkModuleRequires(final DiagnosticPosition pos, final RequiresDirective rd) {
4150         if ((rd.module.flags() &amp; Flags.AUTOMATIC_MODULE) != 0) {
4151             deferredLintHandler.report(() -&gt; {
4152                 if (rd.isTransitive() &amp;&amp; lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {
4153                     log.warning(pos, Warnings.RequiresTransitiveAutomatic);
4154                 } else if (lint.isEnabled(LintCategory.REQUIRES_AUTOMATIC)) {
4155                     log.warning(pos, Warnings.RequiresAutomatic);
4156                 }
4157             });
4158         }
4159     }
4160 
4161 }
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Flow.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../jvm/Target.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2239             }
2240 
2241             boolean needsVarArgsConversion() {
2242                 return tree.varargsElement != null;
2243             }
2244 
2245             /**
2246              * @return Is this an array operation like clone()
2247              */
2248             boolean isArrayOp() {
2249                 return tree.sym.owner == syms.arrayClass;
2250             }
2251 
2252             boolean receiverAccessible() {
2253                 //hack needed to workaround 292 bug (7087658)
2254                 //when 292 issue is fixed we should remove this and change the backend
2255                 //code to always generate a method handle to an accessible method
2256                 return tree.ownerAccessible;
2257             }
2258 









2259             /**
2260              * This method should be called only when target release &lt;= 14
2261              * where LambdaMetaFactory does not spin nestmate classes.
2262              *
2263              * This method should be removed when --release 14 is not supported.
2264              */
2265             boolean isPrivateInOtherClass() {
2266                 assert !nestmateLambdas;
2267                 return  (tree.sym.flags() &amp; PRIVATE) != 0 &amp;&amp;
2268                         !types.isSameType(
2269                               types.erasure(tree.sym.enclClass().asType()),
2270                               types.erasure(owner.enclClass().asType()));
2271             }
2272 
2273             boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage() {
2274                 return ((tree.sym.flags() &amp; PROTECTED) != 0 &amp;&amp;
2275                         tree.sym.packge() != owner.packge());
2276             }
2277 
2278             /**
</pre>
<hr />
<pre>
2296                         return true;
2297                     case TYPEVAR:
2298                         TypeVar tv = (TypeVar) t;
2299                         return isIntersectionOrUnionType(tv.getUpperBound());
2300                 }
2301                 return false;
2302             }
2303 
2304             /**
2305              * Does this reference need to be converted to a lambda
2306              * (i.e. var args need to be expanded or &quot;super&quot; is used)
2307              */
2308             final boolean needsConversionToLambda() {
2309                 return interfaceParameterIsIntersectionOrUnionType() ||
2310                         isSuper ||
2311                         needsVarArgsConversion() ||
2312                         isArrayOp() ||
2313                         (!nestmateLambdas &amp;&amp; isPrivateInOtherClass()) ||
2314                         isProtectedInSuperClassOfEnclosingClassInOtherPackage() ||
2315                         !receiverAccessible() ||

2316                         (tree.getMode() == ReferenceMode.NEW &amp;&amp;
2317                           tree.kind != ReferenceKind.ARRAY_CTOR &amp;&amp;
<span class="line-modified">2318                           (tree.sym.owner.isLocal() || tree.sym.owner.isInner()));</span>
2319             }
2320 
2321             Type generatedRefSig() {
2322                 return types.erasure(tree.sym.type);
2323             }
2324 
2325             Type bridgedRefSig() {
2326                 return types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);
2327             }
2328         }
2329     }
2330     // &lt;/editor-fold&gt;
2331 
2332     /*
2333      * These keys provide mappings for various translated lambda symbols
2334      * and the prevailing order must be maintained.
2335      */
2336     enum LambdaSymbolKind {
2337         PARAM,          // original to translated lambda parameters
2338         LOCAL_VAR,      // original to translated lambda locals
</pre>
</td>
<td>
<hr />
<pre>
2239             }
2240 
2241             boolean needsVarArgsConversion() {
2242                 return tree.varargsElement != null;
2243             }
2244 
2245             /**
2246              * @return Is this an array operation like clone()
2247              */
2248             boolean isArrayOp() {
2249                 return tree.sym.owner == syms.arrayClass;
2250             }
2251 
2252             boolean receiverAccessible() {
2253                 //hack needed to workaround 292 bug (7087658)
2254                 //when 292 issue is fixed we should remove this and change the backend
2255                 //code to always generate a method handle to an accessible method
2256                 return tree.ownerAccessible;
2257             }
2258 
<span class="line-added">2259             /* Per our interim inline class translation scheme, the reference projection classes</span>
<span class="line-added">2260                are completely empty, so we want the methods in the value class to be invoked instead.</span>
<span class="line-added">2261                As the lambda meta factory isn&#39;t clued into this, it will try to invoke the method in</span>
<span class="line-added">2262                C$ref.class and fail with a NoSuchMethodError. we need to workaround it ourselves.</span>
<span class="line-added">2263             */</span>
<span class="line-added">2264             boolean receiverIsReferenceProjection() {</span>
<span class="line-added">2265                 return tree.sym.kind == MTH &amp;&amp; tree.sym.owner.isReferenceProjection();</span>
<span class="line-added">2266             }</span>
<span class="line-added">2267 </span>
2268             /**
2269              * This method should be called only when target release &lt;= 14
2270              * where LambdaMetaFactory does not spin nestmate classes.
2271              *
2272              * This method should be removed when --release 14 is not supported.
2273              */
2274             boolean isPrivateInOtherClass() {
2275                 assert !nestmateLambdas;
2276                 return  (tree.sym.flags() &amp; PRIVATE) != 0 &amp;&amp;
2277                         !types.isSameType(
2278                               types.erasure(tree.sym.enclClass().asType()),
2279                               types.erasure(owner.enclClass().asType()));
2280             }
2281 
2282             boolean isProtectedInSuperClassOfEnclosingClassInOtherPackage() {
2283                 return ((tree.sym.flags() &amp; PROTECTED) != 0 &amp;&amp;
2284                         tree.sym.packge() != owner.packge());
2285             }
2286 
2287             /**
</pre>
<hr />
<pre>
2305                         return true;
2306                     case TYPEVAR:
2307                         TypeVar tv = (TypeVar) t;
2308                         return isIntersectionOrUnionType(tv.getUpperBound());
2309                 }
2310                 return false;
2311             }
2312 
2313             /**
2314              * Does this reference need to be converted to a lambda
2315              * (i.e. var args need to be expanded or &quot;super&quot; is used)
2316              */
2317             final boolean needsConversionToLambda() {
2318                 return interfaceParameterIsIntersectionOrUnionType() ||
2319                         isSuper ||
2320                         needsVarArgsConversion() ||
2321                         isArrayOp() ||
2322                         (!nestmateLambdas &amp;&amp; isPrivateInOtherClass()) ||
2323                         isProtectedInSuperClassOfEnclosingClassInOtherPackage() ||
2324                         !receiverAccessible() ||
<span class="line-added">2325                         receiverIsReferenceProjection() ||</span>
2326                         (tree.getMode() == ReferenceMode.NEW &amp;&amp;
2327                           tree.kind != ReferenceKind.ARRAY_CTOR &amp;&amp;
<span class="line-modified">2328                           (tree.sym.owner.isLocal() || tree.sym.owner.isInner() || tree.sym.owner.isValue()));</span>
2329             }
2330 
2331             Type generatedRefSig() {
2332                 return types.erasure(tree.sym.type);
2333             }
2334 
2335             Type bridgedRefSig() {
2336                 return types.erasure(types.findDescriptorSymbol(tree.target.tsym).type);
2337             }
2338         }
2339     }
2340     // &lt;/editor-fold&gt;
2341 
2342     /*
2343      * These keys provide mappings for various translated lambda symbols
2344      * and the prevailing order must be maintained.
2345      */
2346     enum LambdaSymbolKind {
2347         PARAM,          // original to translated lambda parameters
2348         LOCAL_VAR,      // original to translated lambda locals
</pre>
</td>
</tr>
</table>
<center><a href="Flow.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../jvm/Target.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
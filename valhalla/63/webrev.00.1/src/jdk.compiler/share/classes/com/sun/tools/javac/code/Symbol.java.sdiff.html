<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Symtab.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 397 
 398     public boolean isStatic() {
 399         return
 400             (flags() &amp; STATIC) != 0 ||
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 



























 417     public boolean isPublic() {
 418         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 419     }
 420 
 421     public boolean isEnum() {
 422         return (flags() &amp; ENUM) != 0;
 423     }
 424 
 425     public boolean isFinal() {
 426         return (flags_field &amp; FINAL) != 0;
 427     }
 428 
 429    /** Is this symbol declared (directly or indirectly) local
 430      *  to a method or variable initializer?
 431      *  Also includes fields of inner classes which are in
 432      *  turn local to a method or variable initializer.
 433      */
 434     public boolean isLocal() {
 435         return
 436             (owner.kind.matches(KindSelector.VAL_MTH) ||
 437              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 438     }
 439 
 440     /** Has this symbol an empty name? This includes anonymous
 441      *  inner classes.
 442      */
 443     public boolean isAnonymous() {
 444         return name.isEmpty();
 445     }
 446 
 447     /** Is this symbol a constructor?
 448      */
 449     public boolean isConstructor() {
<span class="line-modified"> 450         return name == name.table.names.init;</span>






 451     }
 452 
 453     public boolean isDynamic() {
 454         return false;
 455     }
 456 
 457     /** The fully qualified name of this symbol.
 458      *  This is the same as the symbol&#39;s name except for class symbols,
 459      *  which are handled separately.
 460      */
 461     public Name getQualifiedName() {
 462         return name;
 463     }
 464 
 465     /** The fully qualified name of this symbol after converting to flat
 466      *  representation. This is the same as the symbol&#39;s name except for
 467      *  class symbols, which are handled separately.
 468      */
 469     public Name flatName() {
 470         return getQualifiedName();
</pre>
<hr />
<pre>
 493     public boolean hasOuterInstance() {
 494         return
 495             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 496     }
 497 
 498     /** The closest enclosing class of this symbol&#39;s declaration.
 499      *  Warning: this (misnamed) method returns the receiver itself
 500      *  when the receiver is a class (as opposed to its enclosing
 501      *  class as one may be misled to believe.)
 502      */
 503     public ClassSymbol enclClass() {
 504         Symbol c = this;
 505         while (c != null &amp;&amp;
 506                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 507             c = c.owner;
 508         }
 509         return (ClassSymbol)c;
 510     }
 511 
 512     /** The outermost class which indirectly owns this symbol.


 513      */
 514     public ClassSymbol outermostClass() {
 515         Symbol sym = this;
 516         Symbol prev = null;
 517         while (sym.kind != PCK) {
 518             prev = sym;
 519             sym = sym.owner;
 520         }
<span class="line-modified"> 521         return (ClassSymbol) prev;</span>
 522     }
 523 
 524     /** The package which indirectly owns this symbol.
 525      */
 526     public PackageSymbol packge() {
 527         Symbol sym = this;
 528         while (sym.kind != PCK) {
 529             sym = sym.owner;
 530         }
 531         return (PackageSymbol) sym;
 532     }
 533 
 534     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 535      */
 536     public boolean isSubClass(Symbol base, Types types) {
 537         throw new AssertionError(&quot;isSubClass &quot; + this);
 538     }
 539 
 540     /** Fully check membership: hierarchy, protection, and hiding.
 541      *  Does not exclude methods not inherited due to overriding.
</pre>
<hr />
<pre>
1268         public JavaFileObject sourcefile;
1269 
1270         /** the classfile from where to load this class
1271          *  this will have extension .class or .java
1272          */
1273         public JavaFileObject classfile;
1274 
1275         /** the list of translated local classes (used for generating
1276          * InnerClasses attribute)
1277          */
1278         public List&lt;ClassSymbol&gt; trans_local;
1279 
1280         /** the annotation metadata attached to this class */
1281         private AnnotationTypeMetadata annotationTypeMetadata;
1282 
1283         /* the list of any of record components, only non empty if the class is a record
1284          * and it has at least one record component
1285          */
1286         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1287 






1288         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1289             super(TYP, flags, name, type, owner);
1290             this.members_field = null;
1291             this.fullname = formFullName(name, owner);
1292             this.flatname = formFlatName(name, owner);
1293             this.sourcefile = null;
1294             this.classfile = null;
1295             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1296         }
1297 
1298         public ClassSymbol(long flags, Name name, Symbol owner) {
1299             this(
1300                 flags,
1301                 name,
1302                 new ClassType(Type.noType, null, null),
1303                 owner);
1304             this.type.tsym = this;
1305         }
1306 
1307         /** The Java source which this symbol represents.
</pre>
<hr />
<pre>
1327         }
1328 
1329         @Override
1330         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1331             complete();
1332             return super.getRawTypeAttributes();
1333         }
1334 
1335         public Type erasure(Types types) {
1336             if (erasure_field == null)
1337                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1338                                               List.nil(), this,
1339                                               type.getMetadata());
1340             return erasure_field;
1341         }
1342 
1343         public String className() {
1344             if (name.isEmpty())
1345                 return
1346                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
<span class="line-modified">1347             else</span>
1348                 return fullname.toString();
1349         }
1350 
1351         @DefinedBy(Api.LANGUAGE_MODEL)
1352         public Name getQualifiedName() {
1353             return fullname;
1354         }
1355 
1356         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1357         public List&lt;Symbol&gt; getEnclosedElements() {
1358             List&lt;Symbol&gt; result = super.getEnclosedElements();
1359             if (!recordComponents.isEmpty()) {
1360                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1361                 for (RecordComponent rc : reversed) {
1362                     result = result.prepend(rc);
1363                 }
1364             }
1365             return result;
1366         }
1367 
</pre>
<hr />
<pre>
1581 
1582         @Override
1583         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1584             return annotationTypeMetadata;
1585         }
1586 
1587         @Override
1588         public boolean isAnnotationType() {
1589             return (flags_field &amp; Flags.ANNOTATION) != 0;
1590         }
1591 
1592         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1593             Assert.checkNonNull(a);
1594             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1595             this.annotationTypeMetadata = a;
1596         }
1597 
1598         public boolean isRecord() {
1599             return (flags_field &amp; RECORD) != 0;
1600         }























































1601     }
1602 
1603 
1604     /** A class for variable symbols
1605      */
1606     public static class VarSymbol extends Symbol implements VariableElement {
1607 
1608         /** The variable&#39;s declaration position.
1609          */
1610         public int pos = Position.NOPOS;
1611 
1612         /** The variable&#39;s address. Used for different purposes during
1613          *  flow analysis, translation and code generation.
1614          *  Flow analysis:
1615          *    If this is a blank final or local variable, its sequence number.
1616          *  Translation:
1617          *    If this is a private field, its access number.
1618          *  Code generation:
1619          *    If this is a local variable, its logical slot number.
1620          */
1621         public int adr = -1;
1622 





1623         /** Construct a variable symbol, given its flags, name, type and owner.
1624          */
1625         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1626             super(VAR, flags, name, type, owner);
1627         }
1628 
1629         @Override
1630         public int poolTag() {
1631             return ClassFile.CONSTANT_Fieldref;
1632         }
1633 
1634         public MethodHandleSymbol asMethodHandle(boolean getter) {
1635             return new MethodHandleSymbol(this, getter);
1636         }
1637 
1638         /** Clone this symbol with new owner.
1639          */
1640         public VarSymbol clone(Symbol newOwner) {
1641             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1642                 @Override
1643                 public Symbol baseSymbol() {
1644                     return VarSymbol.this;
1645                 }
1646 
1647                 @Override
1648                 public Object poolKey(Types types) {
1649                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1650                 }
1651             };
1652             v.pos = pos;
1653             v.adr = adr;
1654             v.data = data;

1655 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1656             return v;
1657         }
1658 
1659         public String toString() {
1660             return name.toString();
1661         }
1662 
1663         public Symbol asMemberOf(Type site, Types types) {
1664             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1665         }
1666 
1667         @DefinedBy(Api.LANGUAGE_MODEL)
1668         public ElementKind getKind() {
1669             long flags = flags();
1670             if ((flags &amp; PARAMETER) != 0) {
1671                 if (isExceptionParameter())
1672                     return ElementKind.EXCEPTION_PARAMETER;
1673                 else
1674                     return ElementKind.PARAMETER;
</pre>
<hr />
<pre>
1687             }
1688         }
1689 
1690         @DefinedBy(Api.LANGUAGE_MODEL)
1691         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1692             return v.visitVariable(this, p);
1693         }
1694 
1695         @DefinedBy(Api.LANGUAGE_MODEL)
1696         public Object getConstantValue() { // Mirror API
1697             return Constants.decode(getConstValue(), type);
1698         }
1699 
1700         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1701                                       final Attr attr,
1702                                       final JCVariableDecl variable)
1703         {
1704             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1705         }
1706 












1707         /**
1708          * The variable&#39;s constant value, if this is a constant.
1709          * Before the constant value is evaluated, it points to an
1710          * initializer environment.  If this is not a constant, it can
1711          * be used for other stuff.
1712          */
1713         private Object data;
1714 
1715         public boolean isExceptionParameter() {
1716             return data == ElementKind.EXCEPTION_PARAMETER;
1717         }
1718 
1719         public boolean isResourceVariable() {
1720             return data == ElementKind.RESOURCE_VARIABLE;
1721         }
1722 
1723         public Object getConstValue() {
1724             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1725             if (data == ElementKind.EXCEPTION_PARAMETER ||
1726                 data == ElementKind.RESOURCE_VARIABLE) {
</pre>
<hr />
<pre>
1837     public static class MethodSymbol extends Symbol implements ExecutableElement {
1838 
1839         /** The code of the method. */
1840         public Code code = null;
1841 
1842         /** The extra (synthetic/mandated) parameters of the method. */
1843         public List&lt;VarSymbol&gt; extraParams = List.nil();
1844 
1845         /** The captured local variables in an anonymous class */
1846         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1847 
1848         /** The parameters of the method. */
1849         public List&lt;VarSymbol&gt; params = null;
1850 
1851         /** For an annotation type element, its default value if any.
1852          *  The value is null if none appeared in the method
1853          *  declaration.
1854          */
1855         public Attribute defaultValue = null;
1856 





1857         /** Construct a method symbol, given its flags, name, type and owner.
1858          */
1859         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1860             super(MTH, flags, name, type, owner);
1861             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1862         }
1863 
1864         /** Clone this symbol with new owner.
1865          */
1866         public MethodSymbol clone(Symbol newOwner) {
1867             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1868                 @Override
1869                 public Symbol baseSymbol() {
1870                     return MethodSymbol.this;
1871                 }
1872 
1873                 @Override
1874                 public Object poolKey(Types types) {
1875                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1876                 }
1877             };
1878             m.code = code;

1879             return m;
1880         }
1881 
1882         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1883         public Set&lt;Modifier&gt; getModifiers() {
1884             long flags = flags();
1885             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
1886         }
1887 
1888         /** The Java source which this symbol represents.
1889          */
1890         public String toString() {
1891             if ((flags() &amp; BLOCK) != 0) {
1892                 return owner.name.toString();
1893             } else {
1894                 String s = (name == name.table.names.init)
1895                     ? owner.name.toString()
1896                     : name.toString();
1897                 if (type != null) {
1898                     if (type.hasTag(FORALL))
</pre>
<hr />
<pre>
2007             return overrides(_other, origin, types, checkResult, true);
2008         }
2009 
2010         /** Does this symbol override `other&#39; symbol, when both are seen as
2011          *  members of class `origin&#39;?  It is assumed that _other is a member
2012          *  of origin.
2013          *
2014          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2015          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2016          *  is false.
2017          *
2018          *  It is assumed that both symbols have the same name.  The static
2019          *  modifier is ignored for this test.
2020          *
2021          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2022          */
2023         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2024                                             boolean requireConcreteIfInherited) {
2025             if (isConstructor() || _other.kind != MTH) return false;
2026 










2027             if (this == _other) return true;
2028             MethodSymbol other = (MethodSymbol)_other;
2029 
2030             // check for a direct implementation
2031             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2032                 types.asSuper(owner.type, other.owner) != null) {
2033                 Type mt = types.memberType(owner.type, this);
2034                 Type ot = types.memberType(owner.type, other);
2035                 if (types.isSubSignature(mt, ot)) {
2036                     if (!checkResult)
2037                         return true;
2038                     if (types.returnTypeSubstitutable(mt, ot))
2039                         return true;
2040                 }
2041             }
2042 
2043             // check for an inherited implementation
2044             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2045                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2046                     !other.isOverridableIn(origin) ||
</pre>
<hr />
<pre>
2061             case Flags.PRIVATE:
2062                 return false;
2063             case Flags.PUBLIC:
2064                 return !this.owner.isInterface() ||
2065                         (flags_field &amp; STATIC) == 0;
2066             case Flags.PROTECTED:
2067                 return (origin.flags() &amp; INTERFACE) == 0;
2068             case 0:
2069                 // for package private: can only override in the same
2070                 // package
2071                 return
2072                     this.packge() == origin.packge() &amp;&amp;
2073                     (origin.flags() &amp; INTERFACE) == 0;
2074             default:
2075                 return false;
2076             }
2077         }
2078 
2079         @Override
2080         public boolean isInheritedIn(Symbol clazz, Types types) {









2081             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2082                 case PUBLIC:
2083                     return !this.owner.isInterface() ||
2084                             clazz == owner ||
2085                             (flags_field &amp; STATIC) == 0;
2086                 default:
2087                     return super.isInheritedIn(clazz, types);
2088             }
2089         }
2090 
2091         public boolean isLambdaMethod() {
2092             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2093         }
2094 












2095         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2096          *  lambda method
2097          */
2098         public MethodSymbol originalEnclosingMethod() {
2099             return this;
2100         }
2101 
2102         /** The implementation of this (abstract) symbol in class origin;
2103          *  null if none exists. Synthetic methods are not considered
2104          *  as possible implementations.
2105          */
2106         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2107             return implementation(origin, types, checkResult, implementation_filter);
2108         }
2109         // where
2110             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2111                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2112 
2113         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2114             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
</pre>
<hr />
<pre>
2368         private int accessCode = Integer.MIN_VALUE;
2369 
2370         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2371             super(PUBLIC | STATIC, name, type, owner);
2372             this.opcode = opcode;
2373         }
2374 
2375         @Override
2376         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2377             return v.visitOperatorSymbol(this, p);
2378         }
2379 
2380         public int getAccessCode(Tag tag) {
2381             if (accessCode != Integer.MIN_VALUE &amp;&amp; !tag.isIncOrDecUnaryOp()) {
2382                 return accessCode;
2383             }
2384             accessCode = AccessCode.from(tag, opcode);
2385             return accessCode;
2386         }
2387 
<span class="line-modified">2388         /** Access codes for dereferencing, assignment,</span>
2389          *  and pre/post increment/decrement.
2390 
2391          *  All access codes for accesses to the current class are even.
2392          *  If a member of the superclass should be accessed instead (because
2393          *  access was via a qualified super), add one to the corresponding code
2394          *  for the current class, making the number odd.
2395          *  This numbering scheme is used by the backend to decide whether
2396          *  to issue an invokevirtual or invokespecial call.
2397          *
2398          *  @see Gen#visitSelect(JCFieldAccess tree)
2399          */
2400         public enum AccessCode {
2401             UNKNOWN(-1, Tag.NO_TAG),
2402             DEREF(0, Tag.NO_TAG),
2403             ASSIGN(2, Tag.ASSIGN),
2404             PREINC(4, Tag.PREINC),
2405             PREDEC(6, Tag.PREDEC),
2406             POSTINC(8, Tag.POSTINC),
2407             POSTDEC(10, Tag.POSTDEC),
<span class="line-modified">2408             FIRSTASGOP(12, Tag.NO_TAG);</span>

2409 
2410             public final int code;
2411             public final Tag tag;
2412             public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;
2413 
2414             AccessCode(int code, Tag tag) {
2415                 this.code = code;
2416                 this.tag = tag;
2417             }
2418 
2419             static public AccessCode getFromCode(int code) {
2420                 for (AccessCode aCodes : AccessCode.values()) {
2421                     if (aCodes.code == code) {
2422                         return aCodes;
2423                     }
2424                 }
2425                 return UNKNOWN;
2426             }
2427 
2428             static int from(Tag tag, int opcode) {
2429                 /** Map bytecode of binary operation to access code of corresponding
2430                 *  assignment operation. This is always an even number.
2431                 */
2432                 switch (tag) {
2433                     case PREINC:
2434                         return AccessCode.PREINC.code;
2435                     case PREDEC:
2436                         return AccessCode.PREDEC.code;
2437                     case POSTINC:
2438                         return AccessCode.POSTINC.code;
2439                     case POSTDEC:
2440                         return AccessCode.POSTDEC.code;


2441                 }
2442                 if (iadd &lt;= opcode &amp;&amp; opcode &lt;= lxor) {
2443                     return (opcode - iadd) * 2 + FIRSTASGOP.code;
2444                 } else if (opcode == string_add) {
2445                     return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;
2446                 } else if (ishll &lt;= opcode &amp;&amp; opcode &lt;= lushrl) {
2447                     return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;
2448                 }
2449                 return -1;
2450             }
2451         }
2452     }
2453 
2454     /** Symbol completer interface.
2455      */
2456     public static interface Completer {
2457 
2458         /** Dummy completer to be used when the symbol has been completed or
2459          * does not need completion.
2460          */
</pre>
</td>
<td>
<hr />
<pre>
 397 
 398     public boolean isStatic() {
 399         return
 400             (flags() &amp; STATIC) != 0 ||
 401             (owner.flags() &amp; INTERFACE) != 0 &amp;&amp; kind != MTH &amp;&amp;
 402              name != name.table.names._this;
 403     }
 404 
 405     public boolean isInterface() {
 406         return (flags() &amp; INTERFACE) != 0;
 407     }
 408 
 409     public boolean isAbstract() {
 410         return (flags_field &amp; ABSTRACT) != 0;
 411     }
 412 
 413     public boolean isPrivate() {
 414         return (flags_field &amp; Flags.AccessFlags) == PRIVATE;
 415     }
 416 
<span class="line-added"> 417     public boolean isValue() {</span>
<span class="line-added"> 418         return (flags() &amp; VALUE) != 0;</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420 </span>
<span class="line-added"> 421     /**</span>
<span class="line-added"> 422      * Is this a *derived* reference projection symbol ??</span>
<span class="line-added"> 423      */</span>
<span class="line-added"> 424     public boolean isReferenceProjection() {</span>
<span class="line-added"> 425         return false;</span>
<span class="line-added"> 426     }</span>
<span class="line-added"> 427 </span>
<span class="line-added"> 428     /**</span>
<span class="line-added"> 429      * Return the value projection IFF &#39;this&#39; happens to be derived reference projection, null</span>
<span class="line-added"> 430      * otherwise.</span>
<span class="line-added"> 431      */</span>
<span class="line-added"> 432     public Symbol valueProjection() {</span>
<span class="line-added"> 433         return null;</span>
<span class="line-added"> 434     }</span>
<span class="line-added"> 435 </span>
<span class="line-added"> 436     /**</span>
<span class="line-added"> 437      * Return the reference projection IFF &#39;this&#39; happens to be value projection, null</span>
<span class="line-added"> 438      * otherwise.</span>
<span class="line-added"> 439      */</span>
<span class="line-added"> 440     public Symbol referenceProjection() {</span>
<span class="line-added"> 441         return null;</span>
<span class="line-added"> 442     }</span>
<span class="line-added"> 443 </span>
 444     public boolean isPublic() {
 445         return (flags_field &amp; Flags.AccessFlags) == PUBLIC;
 446     }
 447 
 448     public boolean isEnum() {
 449         return (flags() &amp; ENUM) != 0;
 450     }
 451 
 452     public boolean isFinal() {
 453         return (flags_field &amp; FINAL) != 0;
 454     }
 455 
 456    /** Is this symbol declared (directly or indirectly) local
 457      *  to a method or variable initializer?
 458      *  Also includes fields of inner classes which are in
 459      *  turn local to a method or variable initializer.
 460      */
 461     public boolean isLocal() {
 462         return
 463             (owner.kind.matches(KindSelector.VAL_MTH) ||
 464              (owner.kind == TYP &amp;&amp; owner.isLocal()));
 465     }
 466 
 467     /** Has this symbol an empty name? This includes anonymous
 468      *  inner classes.
 469      */
 470     public boolean isAnonymous() {
 471         return name.isEmpty();
 472     }
 473 
 474     /** Is this symbol a constructor?
 475      */
 476     public boolean isConstructor() {
<span class="line-modified"> 477         return name == name.table.names.init &amp;&amp; (flags() &amp; STATIC) == 0;</span>
<span class="line-added"> 478     }</span>
<span class="line-added"> 479 </span>
<span class="line-added"> 480     /** Is this symbol a value factory?</span>
<span class="line-added"> 481      */</span>
<span class="line-added"> 482     public boolean isValueFactory() {</span>
<span class="line-added"> 483         return ((name == name.table.names.init &amp;&amp; this.type.getReturnType().tsym == this.owner));</span>
 484     }
 485 
 486     public boolean isDynamic() {
 487         return false;
 488     }
 489 
 490     /** The fully qualified name of this symbol.
 491      *  This is the same as the symbol&#39;s name except for class symbols,
 492      *  which are handled separately.
 493      */
 494     public Name getQualifiedName() {
 495         return name;
 496     }
 497 
 498     /** The fully qualified name of this symbol after converting to flat
 499      *  representation. This is the same as the symbol&#39;s name except for
 500      *  class symbols, which are handled separately.
 501      */
 502     public Name flatName() {
 503         return getQualifiedName();
</pre>
<hr />
<pre>
 526     public boolean hasOuterInstance() {
 527         return
 528             type.getEnclosingType().hasTag(CLASS) &amp;&amp; (flags() &amp; (INTERFACE | NOOUTERTHIS)) == 0;
 529     }
 530 
 531     /** The closest enclosing class of this symbol&#39;s declaration.
 532      *  Warning: this (misnamed) method returns the receiver itself
 533      *  when the receiver is a class (as opposed to its enclosing
 534      *  class as one may be misled to believe.)
 535      */
 536     public ClassSymbol enclClass() {
 537         Symbol c = this;
 538         while (c != null &amp;&amp;
 539                (!c.kind.matches(KindSelector.TYP) || !c.type.hasTag(CLASS))) {
 540             c = c.owner;
 541         }
 542         return (ClassSymbol)c;
 543     }
 544 
 545     /** The outermost class which indirectly owns this symbol.
<span class="line-added"> 546      * &#39;outermost&#39; being a lexical construct, should transcend</span>
<span class="line-added"> 547      *  projections</span>
 548      */
 549     public ClassSymbol outermostClass() {
 550         Symbol sym = this;
 551         Symbol prev = null;
 552         while (sym.kind != PCK) {
 553             prev = sym;
 554             sym = sym.owner;
 555         }
<span class="line-modified"> 556         return (ClassSymbol) (prev!= null &amp;&amp; prev.isReferenceProjection() ? prev.valueProjection() : prev);</span>
 557     }
 558 
 559     /** The package which indirectly owns this symbol.
 560      */
 561     public PackageSymbol packge() {
 562         Symbol sym = this;
 563         while (sym.kind != PCK) {
 564             sym = sym.owner;
 565         }
 566         return (PackageSymbol) sym;
 567     }
 568 
 569     /** Is this symbol a subclass of `base&#39;? Only defined for ClassSymbols.
 570      */
 571     public boolean isSubClass(Symbol base, Types types) {
 572         throw new AssertionError(&quot;isSubClass &quot; + this);
 573     }
 574 
 575     /** Fully check membership: hierarchy, protection, and hiding.
 576      *  Does not exclude methods not inherited due to overriding.
</pre>
<hr />
<pre>
1303         public JavaFileObject sourcefile;
1304 
1305         /** the classfile from where to load this class
1306          *  this will have extension .class or .java
1307          */
1308         public JavaFileObject classfile;
1309 
1310         /** the list of translated local classes (used for generating
1311          * InnerClasses attribute)
1312          */
1313         public List&lt;ClassSymbol&gt; trans_local;
1314 
1315         /** the annotation metadata attached to this class */
1316         private AnnotationTypeMetadata annotationTypeMetadata;
1317 
1318         /* the list of any of record components, only non empty if the class is a record
1319          * and it has at least one record component
1320          */
1321         private List&lt;RecordComponent&gt; recordComponents = List.nil();
1322 
<span class="line-added">1323         /* the &#39;other&#39; projection: If &#39;this&#39; is an inline class then &#39;projection&#39; is its reference projection</span>
<span class="line-added">1324            and vice versa.</span>
<span class="line-added">1325          */</span>
<span class="line-added">1326         public ClassSymbol projection;</span>
<span class="line-added">1327 </span>
<span class="line-added">1328 </span>
1329         public ClassSymbol(long flags, Name name, Type type, Symbol owner) {
1330             super(TYP, flags, name, type, owner);
1331             this.members_field = null;
1332             this.fullname = formFullName(name, owner);
1333             this.flatname = formFlatName(name, owner);
1334             this.sourcefile = null;
1335             this.classfile = null;
1336             this.annotationTypeMetadata = AnnotationTypeMetadata.notAnAnnotationType();
1337         }
1338 
1339         public ClassSymbol(long flags, Name name, Symbol owner) {
1340             this(
1341                 flags,
1342                 name,
1343                 new ClassType(Type.noType, null, null),
1344                 owner);
1345             this.type.tsym = this;
1346         }
1347 
1348         /** The Java source which this symbol represents.
</pre>
<hr />
<pre>
1368         }
1369 
1370         @Override
1371         public List&lt;Attribute.TypeCompound&gt; getRawTypeAttributes() {
1372             complete();
1373             return super.getRawTypeAttributes();
1374         }
1375 
1376         public Type erasure(Types types) {
1377             if (erasure_field == null)
1378                 erasure_field = new ClassType(types.erasure(type.getEnclosingType()),
1379                                               List.nil(), this,
1380                                               type.getMetadata());
1381             return erasure_field;
1382         }
1383 
1384         public String className() {
1385             if (name.isEmpty())
1386                 return
1387                     Log.getLocalizedString(&quot;anonymous.class&quot;, flatname);
<span class="line-modified">1388 </span>
1389                 return fullname.toString();
1390         }
1391 
1392         @DefinedBy(Api.LANGUAGE_MODEL)
1393         public Name getQualifiedName() {
1394             return fullname;
1395         }
1396 
1397         @Override @DefinedBy(Api.LANGUAGE_MODEL)
1398         public List&lt;Symbol&gt; getEnclosedElements() {
1399             List&lt;Symbol&gt; result = super.getEnclosedElements();
1400             if (!recordComponents.isEmpty()) {
1401                 List&lt;RecordComponent&gt; reversed = recordComponents.reverse();
1402                 for (RecordComponent rc : reversed) {
1403                     result = result.prepend(rc);
1404                 }
1405             }
1406             return result;
1407         }
1408 
</pre>
<hr />
<pre>
1622 
1623         @Override
1624         public AnnotationTypeMetadata getAnnotationTypeMetadata() {
1625             return annotationTypeMetadata;
1626         }
1627 
1628         @Override
1629         public boolean isAnnotationType() {
1630             return (flags_field &amp; Flags.ANNOTATION) != 0;
1631         }
1632 
1633         public void setAnnotationTypeMetadata(AnnotationTypeMetadata a) {
1634             Assert.checkNonNull(a);
1635             Assert.check(!annotationTypeMetadata.isMetadataForAnnotationType());
1636             this.annotationTypeMetadata = a;
1637         }
1638 
1639         public boolean isRecord() {
1640             return (flags_field &amp; RECORD) != 0;
1641         }
<span class="line-added">1642 </span>
<span class="line-added">1643         @Override</span>
<span class="line-added">1644         public boolean isReferenceProjection() {</span>
<span class="line-added">1645             return projection != null &amp;&amp; projection.isValue();</span>
<span class="line-added">1646         }</span>
<span class="line-added">1647 </span>
<span class="line-added">1648         @Override</span>
<span class="line-added">1649         public ClassSymbol valueProjection() {</span>
<span class="line-added">1650             return isReferenceProjection() ? projection : null;</span>
<span class="line-added">1651         }</span>
<span class="line-added">1652 </span>
<span class="line-added">1653         @Override</span>
<span class="line-added">1654         public ClassSymbol referenceProjection() {</span>
<span class="line-added">1655             if (!isValue() || projection != null)</span>
<span class="line-added">1656                 return projection;</span>
<span class="line-added">1657 </span>
<span class="line-added">1658             ClassType ct = (ClassType) this.type;</span>
<span class="line-added">1659             ClassType projectedType = new ClassType(ct.getEnclosingType(), ct.typarams_field, null);</span>
<span class="line-added">1660             projectedType.allparams_field = ct.allparams_field;</span>
<span class="line-added">1661             projectedType.supertype_field = ct.supertype_field;</span>
<span class="line-added">1662 </span>
<span class="line-added">1663             projectedType.interfaces_field = ct.interfaces_field;</span>
<span class="line-added">1664             projectedType.all_interfaces_field = ct.all_interfaces_field;</span>
<span class="line-added">1665             projectedType.projection = ct;</span>
<span class="line-added">1666             ct.projection = projectedType;</span>
<span class="line-added">1667 </span>
<span class="line-added">1668             Name projectionName = this.name.append(&#39;$&#39;, this.name.table.names.ref);</span>
<span class="line-added">1669             long projectionFlags = (this.flags() &amp; ~(VALUE | UNATTRIBUTED));</span>
<span class="line-added">1670 </span>
<span class="line-added">1671             projection = new ClassSymbol(projectionFlags, projectionName, projectedType, this.owner);</span>
<span class="line-added">1672             projection.members_field = WriteableScope.create(projection);</span>
<span class="line-added">1673             for (Symbol s : this.members().getSymbols(s-&gt;(s.kind == MTH || s.kind == VAR), NON_RECURSIVE)) {</span>
<span class="line-added">1674                 Symbol clone = null;</span>
<span class="line-added">1675                 if (s.kind == MTH) {</span>
<span class="line-added">1676                     MethodSymbol valMethod = (MethodSymbol)s;</span>
<span class="line-added">1677                     MethodSymbol refMethod = valMethod.clone(projection);</span>
<span class="line-added">1678                     valMethod.projection = refMethod;</span>
<span class="line-added">1679                     refMethod.projection = valMethod;</span>
<span class="line-added">1680                     clone = refMethod;</span>
<span class="line-added">1681                 } else if (s.kind == VAR) {</span>
<span class="line-added">1682                     VarSymbol valVar = (VarSymbol)s;</span>
<span class="line-added">1683                     VarSymbol refVar = valVar.clone(projection);</span>
<span class="line-added">1684                     valVar.projection = refVar;</span>
<span class="line-added">1685                     refVar.projection = valVar;</span>
<span class="line-added">1686                     clone = refVar;</span>
<span class="line-added">1687                 }</span>
<span class="line-added">1688                 projection.members_field.enter(clone);</span>
<span class="line-added">1689             }</span>
<span class="line-added">1690             projection.completer = Completer.NULL_COMPLETER;</span>
<span class="line-added">1691             projection.sourcefile = this.sourcefile;</span>
<span class="line-added">1692             projection.flatname = this.flatname.append(&#39;$&#39;, this.name.table.names.ref);</span>
<span class="line-added">1693             projection.projection = this;</span>
<span class="line-added">1694             projectedType.tsym = projection;</span>
<span class="line-added">1695             return projection;</span>
<span class="line-added">1696         }</span>
1697     }
1698 
1699 
1700     /** A class for variable symbols
1701      */
1702     public static class VarSymbol extends Symbol implements VariableElement {
1703 
1704         /** The variable&#39;s declaration position.
1705          */
1706         public int pos = Position.NOPOS;
1707 
1708         /** The variable&#39;s address. Used for different purposes during
1709          *  flow analysis, translation and code generation.
1710          *  Flow analysis:
1711          *    If this is a blank final or local variable, its sequence number.
1712          *  Translation:
1713          *    If this is a private field, its access number.
1714          *  Code generation:
1715          *    If this is a local variable, its logical slot number.
1716          */
1717         public int adr = -1;
1718 
<span class="line-added">1719         /* The &#39;other&#39; projection: If &#39;this&#39; is a field of an inline class, then &#39;projection&#39; is the</span>
<span class="line-added">1720            its doppleganger in its referene projection class and vice versa.</span>
<span class="line-added">1721         */</span>
<span class="line-added">1722         public VarSymbol projection;</span>
<span class="line-added">1723 </span>
1724         /** Construct a variable symbol, given its flags, name, type and owner.
1725          */
1726         public VarSymbol(long flags, Name name, Type type, Symbol owner) {
1727             super(VAR, flags, name, type, owner);
1728         }
1729 
1730         @Override
1731         public int poolTag() {
1732             return ClassFile.CONSTANT_Fieldref;
1733         }
1734 
1735         public MethodHandleSymbol asMethodHandle(boolean getter) {
1736             return new MethodHandleSymbol(this, getter);
1737         }
1738 
1739         /** Clone this symbol with new owner.
1740          */
1741         public VarSymbol clone(Symbol newOwner) {
1742             VarSymbol v = new VarSymbol(flags_field, name, type, newOwner) {
1743                 @Override
1744                 public Symbol baseSymbol() {
1745                     return VarSymbol.this;
1746                 }
1747 
1748                 @Override
1749                 public Object poolKey(Types types) {
1750                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1751                 }
1752             };
1753             v.pos = pos;
1754             v.adr = adr;
1755             v.data = data;
<span class="line-added">1756             v.projection = projection;</span>
1757 //          System.out.println(&quot;clone &quot; + v + &quot; in &quot; + newOwner);//DEBUG
1758             return v;
1759         }
1760 
1761         public String toString() {
1762             return name.toString();
1763         }
1764 
1765         public Symbol asMemberOf(Type site, Types types) {
1766             return new VarSymbol(flags_field, name, types.memberType(site, this), owner);
1767         }
1768 
1769         @DefinedBy(Api.LANGUAGE_MODEL)
1770         public ElementKind getKind() {
1771             long flags = flags();
1772             if ((flags &amp; PARAMETER) != 0) {
1773                 if (isExceptionParameter())
1774                     return ElementKind.EXCEPTION_PARAMETER;
1775                 else
1776                     return ElementKind.PARAMETER;
</pre>
<hr />
<pre>
1789             }
1790         }
1791 
1792         @DefinedBy(Api.LANGUAGE_MODEL)
1793         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1794             return v.visitVariable(this, p);
1795         }
1796 
1797         @DefinedBy(Api.LANGUAGE_MODEL)
1798         public Object getConstantValue() { // Mirror API
1799             return Constants.decode(getConstValue(), type);
1800         }
1801 
1802         public void setLazyConstValue(final Env&lt;AttrContext&gt; env,
1803                                       final Attr attr,
1804                                       final JCVariableDecl variable)
1805         {
1806             setData((Callable&lt;Object&gt;)() -&gt; attr.attribLazyConstantValue(env, variable, type));
1807         }
1808 
<span class="line-added">1809         @Override</span>
<span class="line-added">1810         public VarSymbol referenceProjection() {</span>
<span class="line-added">1811             return this.owner.isValue() ?</span>
<span class="line-added">1812                     this.owner.referenceProjection() != null ? projection : null</span>
<span class="line-added">1813                                : null;</span>
<span class="line-added">1814         }</span>
<span class="line-added">1815 </span>
<span class="line-added">1816         @Override</span>
<span class="line-added">1817         public VarSymbol valueProjection() {</span>
<span class="line-added">1818             return  projection != null ? projection.owner.isValue() ? projection : null: null;</span>
<span class="line-added">1819         }</span>
<span class="line-added">1820 </span>
1821         /**
1822          * The variable&#39;s constant value, if this is a constant.
1823          * Before the constant value is evaluated, it points to an
1824          * initializer environment.  If this is not a constant, it can
1825          * be used for other stuff.
1826          */
1827         private Object data;
1828 
1829         public boolean isExceptionParameter() {
1830             return data == ElementKind.EXCEPTION_PARAMETER;
1831         }
1832 
1833         public boolean isResourceVariable() {
1834             return data == ElementKind.RESOURCE_VARIABLE;
1835         }
1836 
1837         public Object getConstValue() {
1838             // TODO: Consider if getConstValue and getConstantValue can be collapsed
1839             if (data == ElementKind.EXCEPTION_PARAMETER ||
1840                 data == ElementKind.RESOURCE_VARIABLE) {
</pre>
<hr />
<pre>
1951     public static class MethodSymbol extends Symbol implements ExecutableElement {
1952 
1953         /** The code of the method. */
1954         public Code code = null;
1955 
1956         /** The extra (synthetic/mandated) parameters of the method. */
1957         public List&lt;VarSymbol&gt; extraParams = List.nil();
1958 
1959         /** The captured local variables in an anonymous class */
1960         public List&lt;VarSymbol&gt; capturedLocals = List.nil();
1961 
1962         /** The parameters of the method. */
1963         public List&lt;VarSymbol&gt; params = null;
1964 
1965         /** For an annotation type element, its default value if any.
1966          *  The value is null if none appeared in the method
1967          *  declaration.
1968          */
1969         public Attribute defaultValue = null;
1970 
<span class="line-added">1971         /* The &#39;other&#39; projection: If &#39;this&#39; is a method of an inline class, then &#39;projection&#39; is the</span>
<span class="line-added">1972            its doppleganger in its referene projection class and vice versa.</span>
<span class="line-added">1973         */</span>
<span class="line-added">1974         public MethodSymbol projection;</span>
<span class="line-added">1975 </span>
1976         /** Construct a method symbol, given its flags, name, type and owner.
1977          */
1978         public MethodSymbol(long flags, Name name, Type type, Symbol owner) {
1979             super(MTH, flags, name, type, owner);
1980             if (owner.type.hasTag(TYPEVAR)) Assert.error(owner + &quot;.&quot; + name);
1981         }
1982 
1983         /** Clone this symbol with new owner.
1984          */
1985         public MethodSymbol clone(Symbol newOwner) {
1986             MethodSymbol m = new MethodSymbol(flags_field, name, type, newOwner) {
1987                 @Override
1988                 public Symbol baseSymbol() {
1989                     return MethodSymbol.this;
1990                 }
1991 
1992                 @Override
1993                 public Object poolKey(Types types) {
1994                     return new Pair&lt;&gt;(newOwner, baseSymbol());
1995                 }
1996             };
1997             m.code = code;
<span class="line-added">1998             m.projection = projection;</span>
1999             return m;
2000         }
2001 
2002         @Override @DefinedBy(Api.LANGUAGE_MODEL)
2003         public Set&lt;Modifier&gt; getModifiers() {
2004             long flags = flags();
2005             return Flags.asModifierSet((flags &amp; DEFAULT) != 0 ? flags &amp; ~ABSTRACT : flags);
2006         }
2007 
2008         /** The Java source which this symbol represents.
2009          */
2010         public String toString() {
2011             if ((flags() &amp; BLOCK) != 0) {
2012                 return owner.name.toString();
2013             } else {
2014                 String s = (name == name.table.names.init)
2015                     ? owner.name.toString()
2016                     : name.toString();
2017                 if (type != null) {
2018                     if (type.hasTag(FORALL))
</pre>
<hr />
<pre>
2127             return overrides(_other, origin, types, checkResult, true);
2128         }
2129 
2130         /** Does this symbol override `other&#39; symbol, when both are seen as
2131          *  members of class `origin&#39;?  It is assumed that _other is a member
2132          *  of origin.
2133          *
2134          *  Caveat: If `this&#39; is an abstract inherited member of origin, it is
2135          *  deemed to override `other&#39; only when `requireConcreteIfInherited&#39;
2136          *  is false.
2137          *
2138          *  It is assumed that both symbols have the same name.  The static
2139          *  modifier is ignored for this test.
2140          *
2141          *  See JLS 8.4.6.1 (without transitivity) and 8.4.6.4
2142          */
2143         public boolean overrides(Symbol _other, TypeSymbol origin, Types types, boolean checkResult,
2144                                             boolean requireConcreteIfInherited) {
2145             if (isConstructor() || _other.kind != MTH) return false;
2146 
<span class="line-added">2147 </span>
<span class="line-added">2148             /* If any inline types are involved, ask the same question in the reference universe,</span>
<span class="line-added">2149                where the hierarchy is navigable</span>
<span class="line-added">2150             */</span>
<span class="line-added">2151             if (origin.isValue())</span>
<span class="line-added">2152                 origin = (TypeSymbol) origin.referenceProjection();</span>
<span class="line-added">2153 </span>
<span class="line-added">2154             if (this.owner.isValue())</span>
<span class="line-added">2155                 return this.projection.overrides(_other, origin, types, checkResult, requireConcreteIfInherited);</span>
<span class="line-added">2156 </span>
2157             if (this == _other) return true;
2158             MethodSymbol other = (MethodSymbol)_other;
2159 
2160             // check for a direct implementation
2161             if (other.isOverridableIn((TypeSymbol)owner) &amp;&amp;
2162                 types.asSuper(owner.type, other.owner) != null) {
2163                 Type mt = types.memberType(owner.type, this);
2164                 Type ot = types.memberType(owner.type, other);
2165                 if (types.isSubSignature(mt, ot)) {
2166                     if (!checkResult)
2167                         return true;
2168                     if (types.returnTypeSubstitutable(mt, ot))
2169                         return true;
2170                 }
2171             }
2172 
2173             // check for an inherited implementation
2174             if (((flags() &amp; ABSTRACT) != 0 &amp;&amp; requireConcreteIfInherited) ||
2175                     ((other.flags() &amp; ABSTRACT) == 0 &amp;&amp; (other.flags() &amp; DEFAULT) == 0) ||
2176                     !other.isOverridableIn(origin) ||
</pre>
<hr />
<pre>
2191             case Flags.PRIVATE:
2192                 return false;
2193             case Flags.PUBLIC:
2194                 return !this.owner.isInterface() ||
2195                         (flags_field &amp; STATIC) == 0;
2196             case Flags.PROTECTED:
2197                 return (origin.flags() &amp; INTERFACE) == 0;
2198             case 0:
2199                 // for package private: can only override in the same
2200                 // package
2201                 return
2202                     this.packge() == origin.packge() &amp;&amp;
2203                     (origin.flags() &amp; INTERFACE) == 0;
2204             default:
2205                 return false;
2206             }
2207         }
2208 
2209         @Override
2210         public boolean isInheritedIn(Symbol clazz, Types types) {
<span class="line-added">2211 </span>
<span class="line-added">2212             /* If any inline types are involved, ask the same question in the reference universe,</span>
<span class="line-added">2213                where the hierarchy is navigable</span>
<span class="line-added">2214             */</span>
<span class="line-added">2215             if (clazz.isValue())</span>
<span class="line-added">2216                 clazz = clazz.referenceProjection();</span>
<span class="line-added">2217             if (this.owner.isValue())</span>
<span class="line-added">2218                 return this.projection.isInheritedIn(clazz, types);</span>
<span class="line-added">2219 </span>
2220             switch ((int)(flags_field &amp; Flags.AccessFlags)) {
2221                 case PUBLIC:
2222                     return !this.owner.isInterface() ||
2223                             clazz == owner ||
2224                             (flags_field &amp; STATIC) == 0;
2225                 default:
2226                     return super.isInheritedIn(clazz, types);
2227             }
2228         }
2229 
2230         public boolean isLambdaMethod() {
2231             return (flags() &amp; LAMBDA_METHOD) == LAMBDA_METHOD;
2232         }
2233 
<span class="line-added">2234         @Override</span>
<span class="line-added">2235         public MethodSymbol referenceProjection() {</span>
<span class="line-added">2236             return this.owner.isValue() ?</span>
<span class="line-added">2237                     this.owner.referenceProjection() != null ? projection : null</span>
<span class="line-added">2238                     : null;</span>
<span class="line-added">2239         }</span>
<span class="line-added">2240 </span>
<span class="line-added">2241         @Override</span>
<span class="line-added">2242         public MethodSymbol valueProjection() {</span>
<span class="line-added">2243             return  projection != null ? projection.owner.isValue() ? projection : null : null;</span>
<span class="line-added">2244         }</span>
<span class="line-added">2245 </span>
2246         /** override this method to point to the original enclosing method if this method symbol represents a synthetic
2247          *  lambda method
2248          */
2249         public MethodSymbol originalEnclosingMethod() {
2250             return this;
2251         }
2252 
2253         /** The implementation of this (abstract) symbol in class origin;
2254          *  null if none exists. Synthetic methods are not considered
2255          *  as possible implementations.
2256          */
2257         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult) {
2258             return implementation(origin, types, checkResult, implementation_filter);
2259         }
2260         // where
2261             public static final Filter&lt;Symbol&gt; implementation_filter = s -&gt;
2262                     s.kind == MTH &amp;&amp; (s.flags() &amp; SYNTHETIC) == 0;
2263 
2264         public MethodSymbol implementation(TypeSymbol origin, Types types, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2265             MethodSymbol res = types.implementation(this, origin, checkResult, implFilter);
</pre>
<hr />
<pre>
2519         private int accessCode = Integer.MIN_VALUE;
2520 
2521         public OperatorSymbol(Name name, Type type, int opcode, Symbol owner) {
2522             super(PUBLIC | STATIC, name, type, owner);
2523             this.opcode = opcode;
2524         }
2525 
2526         @Override
2527         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
2528             return v.visitOperatorSymbol(this, p);
2529         }
2530 
2531         public int getAccessCode(Tag tag) {
2532             if (accessCode != Integer.MIN_VALUE &amp;&amp; !tag.isIncOrDecUnaryOp()) {
2533                 return accessCode;
2534             }
2535             accessCode = AccessCode.from(tag, opcode);
2536             return accessCode;
2537         }
2538 
<span class="line-modified">2539         /** Access codes for dereferencing, assignment, withfield</span>
2540          *  and pre/post increment/decrement.
2541 
2542          *  All access codes for accesses to the current class are even.
2543          *  If a member of the superclass should be accessed instead (because
2544          *  access was via a qualified super), add one to the corresponding code
2545          *  for the current class, making the number odd.
2546          *  This numbering scheme is used by the backend to decide whether
2547          *  to issue an invokevirtual or invokespecial call.
2548          *
2549          *  @see Gen#visitSelect(JCFieldAccess tree)
2550          */
2551         public enum AccessCode {
2552             UNKNOWN(-1, Tag.NO_TAG),
2553             DEREF(0, Tag.NO_TAG),
2554             ASSIGN(2, Tag.ASSIGN),
2555             PREINC(4, Tag.PREINC),
2556             PREDEC(6, Tag.PREDEC),
2557             POSTINC(8, Tag.POSTINC),
2558             POSTDEC(10, Tag.POSTDEC),
<span class="line-modified">2559             WITHFIELD(12, Tag.WITHFIELD),</span>
<span class="line-added">2560             FIRSTASGOP(14, Tag.NO_TAG);</span>
2561 
2562             public final int code;
2563             public final Tag tag;
2564             public static final int numberOfAccessCodes = (lushrl - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code + 2;
2565 
2566             AccessCode(int code, Tag tag) {
2567                 this.code = code;
2568                 this.tag = tag;
2569             }
2570 
2571             static public AccessCode getFromCode(int code) {
2572                 for (AccessCode aCodes : AccessCode.values()) {
2573                     if (aCodes.code == code) {
2574                         return aCodes;
2575                     }
2576                 }
2577                 return UNKNOWN;
2578             }
2579 
2580             static int from(Tag tag, int opcode) {
2581                 /** Map bytecode of binary operation to access code of corresponding
2582                 *  assignment operation. This is always an even number.
2583                 */
2584                 switch (tag) {
2585                     case PREINC:
2586                         return AccessCode.PREINC.code;
2587                     case PREDEC:
2588                         return AccessCode.PREDEC.code;
2589                     case POSTINC:
2590                         return AccessCode.POSTINC.code;
2591                     case POSTDEC:
2592                         return AccessCode.POSTDEC.code;
<span class="line-added">2593                     case WITHFIELD:</span>
<span class="line-added">2594                         return AccessCode.WITHFIELD.code;</span>
2595                 }
2596                 if (iadd &lt;= opcode &amp;&amp; opcode &lt;= lxor) {
2597                     return (opcode - iadd) * 2 + FIRSTASGOP.code;
2598                 } else if (opcode == string_add) {
2599                     return (lxor + 1 - iadd) * 2 + FIRSTASGOP.code;
2600                 } else if (ishll &lt;= opcode &amp;&amp; opcode &lt;= lushrl) {
2601                     return (opcode - ishll + lxor + 2 - iadd) * 2 + FIRSTASGOP.code;
2602                 }
2603                 return -1;
2604             }
2605         }
2606     }
2607 
2608     /** Symbol completer interface.
2609      */
2610     public static interface Completer {
2611 
2612         /** Dummy completer to be used when the symbol has been completed or
2613          * does not need completion.
2614          */
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Symtab.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
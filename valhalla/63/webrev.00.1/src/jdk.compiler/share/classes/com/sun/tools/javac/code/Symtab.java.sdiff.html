<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Attr.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 import javax.lang.model.element.ElementVisitor;
 36 
 37 import com.sun.tools.javac.code.Scope.WriteableScope;
 38 import com.sun.tools.javac.code.Source.Feature;
 39 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 40 import com.sun.tools.javac.code.Symbol.Completer;
 41 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 42 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 43 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 44 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 45 import com.sun.tools.javac.code.Symbol.RootPackageSymbol;
 46 import com.sun.tools.javac.code.Symbol.TypeSymbol;
 47 import com.sun.tools.javac.code.Symbol.VarSymbol;
 48 import com.sun.tools.javac.code.Type.BottomType;
 49 import com.sun.tools.javac.code.Type.ClassType;
 50 import com.sun.tools.javac.code.Type.ErrorType;
 51 import com.sun.tools.javac.code.Type.JCPrimitiveType;
 52 import com.sun.tools.javac.code.Type.JCVoidType;
 53 import com.sun.tools.javac.code.Type.MethodType;
 54 import com.sun.tools.javac.code.Type.UnknownType;

 55 import com.sun.tools.javac.code.Types.UniqueType;
 56 import com.sun.tools.javac.comp.Modules;
 57 import com.sun.tools.javac.jvm.Target;
 58 import com.sun.tools.javac.util.Assert;
 59 import com.sun.tools.javac.util.Context;
 60 import com.sun.tools.javac.util.Convert;
 61 import com.sun.tools.javac.util.DefinedBy;
 62 import com.sun.tools.javac.util.DefinedBy.Api;
 63 import com.sun.tools.javac.util.Iterators;
 64 import com.sun.tools.javac.util.JavacMessages;
 65 import com.sun.tools.javac.util.List;
 66 import com.sun.tools.javac.util.Name;
 67 import com.sun.tools.javac.util.Names;

 68 
 69 import static com.sun.tools.javac.code.Flags.*;
 70 import static com.sun.tools.javac.code.Kinds.Kind.*;
 71 import static com.sun.tools.javac.code.TypeTag.*;
 72 
 73 /** A class that defines all predefined constants and operators
 74  *  as well as special classes such as java.lang.Object, which need
 75  *  to be known to the compiler. All symbols are held in instance
 76  *  fields. This makes it possible to work in multiple concurrent
 77  *  projects, which might use different class files for library classes.
 78  *
 79  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 80  *  If you write code that depends on this, you do so at your own risk.
 81  *  This code and its internal interfaces are subject to change or
 82  *  deletion without notice.&lt;/b&gt;
 83  */
 84 public class Symtab {
 85     /** The context key for the symbol table. */
 86     protected static final Context.Key&lt;Symtab&gt; symtabKey = new Context.Key&lt;&gt;();
 87 
</pre>
<hr />
<pre>
195     public final Type collectionsType;
196     public final Type comparableType;
197     public final Type comparatorType;
198     public final Type arraysType;
199     public final Type iterableType;
200     public final Type iteratorType;
201     public final Type annotationTargetType;
202     public final Type overrideType;
203     public final Type retentionType;
204     public final Type deprecatedType;
205     public final Type suppressWarningsType;
206     public final Type supplierType;
207     public final Type inheritedType;
208     public final Type profileType;
209     public final Type proprietaryType;
210     public final Type systemType;
211     public final Type autoCloseableType;
212     public final Type trustMeType;
213     public final Type lambdaMetafactory;
214     public final Type stringConcatFactory;

215     public final Type repeatableType;
216     public final Type documentedType;
217     public final Type elementTypeType;
218     public final Type functionalInterfaceType;
219     public final Type previewFeatureType;
220     public final Type typeDescriptorType;
221     public final Type recordType;


222 
223     /** The symbol representing the length field of an array.
224      */
225     public final VarSymbol lengthVar;
226 
227     /** The symbol representing the final finalize method on enums */
228     public final MethodSymbol enumFinalFinalize;
229 
230     /** The symbol representing the close method on TWR AutoCloseable type */
231     public final MethodSymbol autoCloseableClose;
232 
233     /** The predefined type that belongs to a tag.
234      */
235     public final Type[] typeOfTag = new Type[TypeTag.getTypeTagCount()];
236 
237     /** The name of the class that belongs to a basic type tag.
238      */
239     public final Name[] boxedName = new Name[TypeTag.getTypeTagCount()];
240 
241     /** A hashtable containing the encountered top-level and member classes,
</pre>
<hr />
<pre>
244      *  by compiled source files.
245      */
246     private final Map&lt;Name, Map&lt;ModuleSymbol,ClassSymbol&gt;&gt; classes = new HashMap&lt;&gt;();
247 
248     /** A hashtable containing the encountered packages.
249      *  the table should be updated from outside to reflect packages defined
250      *  by compiled source files.
251      */
252     private final Map&lt;Name, Map&lt;ModuleSymbol,PackageSymbol&gt;&gt; packages = new HashMap&lt;&gt;();
253 
254     /** A hashtable giving the encountered modules.
255      */
256     private final Map&lt;Name, ModuleSymbol&gt; modules = new LinkedHashMap&lt;&gt;();
257 
258     private final Map&lt;Types.UniqueType, VarSymbol&gt; classFields = new HashMap&lt;&gt;();
259 
260     public VarSymbol getClassField(Type type, Types types) {
261         return classFields.computeIfAbsent(
262             new UniqueType(type, types), k -&gt; {
263                 Type arg = null;
<span class="line-modified">264                 if (type.getTag() == ARRAY || type.getTag() == CLASS)</span>
<span class="line-modified">265                     arg = types.erasure(type);</span>









266                 else if (type.isPrimitiveOrVoid())
267                     arg = types.boxedClass(type).type;
268                 else
269                     throw new AssertionError(type);
270 
271                 Type t = new ClassType(
272                     classType.getEnclosingType(), List.of(arg), classType.tsym);
273                 return new VarSymbol(
274                     STATIC | PUBLIC | FINAL, names._class, t, type.tsym);
275             });
276     }
277 
278     public void initType(Type type, ClassSymbol c) {
279         type.tsym = c;
280         typeOfTag[type.getTag().ordinal()] = type;
281     }
282 
283     public void initType(Type type, String name) {
284         initType(
285             type,
</pre>
<hr />
<pre>
561         overrideType = enterClass(&quot;java.lang.Override&quot;);
562         retentionType = enterClass(&quot;java.lang.annotation.Retention&quot;);
563         deprecatedType = enterClass(&quot;java.lang.Deprecated&quot;);
564         suppressWarningsType = enterClass(&quot;java.lang.SuppressWarnings&quot;);
565         supplierType = enterClass(&quot;java.util.function.Supplier&quot;);
566         inheritedType = enterClass(&quot;java.lang.annotation.Inherited&quot;);
567         repeatableType = enterClass(&quot;java.lang.annotation.Repeatable&quot;);
568         documentedType = enterClass(&quot;java.lang.annotation.Documented&quot;);
569         elementTypeType = enterClass(&quot;java.lang.annotation.ElementType&quot;);
570         systemType = enterClass(&quot;java.lang.System&quot;);
571         autoCloseableType = enterClass(&quot;java.lang.AutoCloseable&quot;);
572         autoCloseableClose = new MethodSymbol(PUBLIC,
573                              names.close,
574                              new MethodType(List.nil(), voidType,
575                                             List.of(exceptionType), methodClass),
576                              autoCloseableType.tsym);
577         trustMeType = enterClass(&quot;java.lang.SafeVarargs&quot;);
578         nativeHeaderType = enterClass(&quot;java.lang.annotation.Native&quot;);
579         lambdaMetafactory = enterClass(&quot;java.lang.invoke.LambdaMetafactory&quot;);
580         stringConcatFactory = enterClass(&quot;java.lang.invoke.StringConcatFactory&quot;);

581         functionalInterfaceType = enterClass(&quot;java.lang.FunctionalInterface&quot;);
582         previewFeatureType = enterClass(&quot;jdk.internal.PreviewFeature&quot;);
583         typeDescriptorType = enterClass(&quot;java.lang.invoke.TypeDescriptor&quot;);
584         recordType = enterClass(&quot;java.lang.Record&quot;);


585 
586         synthesizeEmptyInterfaceIfMissing(autoCloseableType);
587         synthesizeEmptyInterfaceIfMissing(cloneableType);
588         synthesizeEmptyInterfaceIfMissing(serializableType);
589         synthesizeEmptyInterfaceIfMissing(lambdaMetafactory);
590         synthesizeEmptyInterfaceIfMissing(serializedLambdaType);
591         synthesizeEmptyInterfaceIfMissing(stringConcatFactory);

592         synthesizeBoxTypeIfMissing(doubleType);
593         synthesizeBoxTypeIfMissing(floatType);
594         synthesizeBoxTypeIfMissing(voidType);
595 
596         // Enter a synthetic class that is used to mark internal
597         // proprietary classes in ct.sym.  This class does not have a
598         // class file.
599         proprietaryType = enterSyntheticAnnotation(&quot;sun.Proprietary+Annotation&quot;);
600 
601         // Enter a synthetic class that is used to provide profile info for
602         // classes in ct.sym.  This class does not have a class file.
603         profileType = enterSyntheticAnnotation(&quot;jdk.Profile+Annotation&quot;);
604         MethodSymbol m = new MethodSymbol(PUBLIC | ABSTRACT, names.value, intType, profileType.tsym);
605         profileType.tsym.members().enter(m);
606 
607         // Enter a class for arrays.
608         // The class implements java.lang.Cloneable and java.io.Serializable.
609         // It has a final length field and a clone method.
610         ClassType arrayClassType = (ClassType)arrayClass.type;
611         arrayClassType.supertype_field = objectType;
<span class="line-modified">612         arrayClassType.interfaces_field = List.of(cloneableType, serializableType);</span>


613         arrayClass.members_field = WriteableScope.create(arrayClass);
614         lengthVar = new VarSymbol(
615             PUBLIC | FINAL,
616             names.length,
617             intType,
618             arrayClass);
619         arrayClass.members().enter(lengthVar);
620         arrayCloneMethod = new MethodSymbol(
621             PUBLIC,
622             names.clone,
623             new MethodType(List.nil(), objectType,
624                            List.nil(), methodClass),
625             arrayClass);
626         arrayClass.members().enter(arrayCloneMethod);
627 
628         if (java_base != noModule)
629             java_base.completer = moduleCompleter::complete; //bootstrap issues
630 
631     }
632 
</pre>
</td>
<td>
<hr />
<pre>
 35 import javax.lang.model.element.ElementVisitor;
 36 
 37 import com.sun.tools.javac.code.Scope.WriteableScope;
 38 import com.sun.tools.javac.code.Source.Feature;
 39 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 40 import com.sun.tools.javac.code.Symbol.Completer;
 41 import com.sun.tools.javac.code.Symbol.CompletionFailure;
 42 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 43 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
 44 import com.sun.tools.javac.code.Symbol.PackageSymbol;
 45 import com.sun.tools.javac.code.Symbol.RootPackageSymbol;
 46 import com.sun.tools.javac.code.Symbol.TypeSymbol;
 47 import com.sun.tools.javac.code.Symbol.VarSymbol;
 48 import com.sun.tools.javac.code.Type.BottomType;
 49 import com.sun.tools.javac.code.Type.ClassType;
 50 import com.sun.tools.javac.code.Type.ErrorType;
 51 import com.sun.tools.javac.code.Type.JCPrimitiveType;
 52 import com.sun.tools.javac.code.Type.JCVoidType;
 53 import com.sun.tools.javac.code.Type.MethodType;
 54 import com.sun.tools.javac.code.Type.UnknownType;
<span class="line-added"> 55 import com.sun.tools.javac.code.Type.WildcardType;</span>
 56 import com.sun.tools.javac.code.Types.UniqueType;
 57 import com.sun.tools.javac.comp.Modules;
 58 import com.sun.tools.javac.jvm.Target;
 59 import com.sun.tools.javac.util.Assert;
 60 import com.sun.tools.javac.util.Context;
 61 import com.sun.tools.javac.util.Convert;
 62 import com.sun.tools.javac.util.DefinedBy;
 63 import com.sun.tools.javac.util.DefinedBy.Api;
 64 import com.sun.tools.javac.util.Iterators;
 65 import com.sun.tools.javac.util.JavacMessages;
 66 import com.sun.tools.javac.util.List;
 67 import com.sun.tools.javac.util.Name;
 68 import com.sun.tools.javac.util.Names;
<span class="line-added"> 69 import com.sun.tools.javac.util.Options;</span>
 70 
 71 import static com.sun.tools.javac.code.Flags.*;
 72 import static com.sun.tools.javac.code.Kinds.Kind.*;
 73 import static com.sun.tools.javac.code.TypeTag.*;
 74 
 75 /** A class that defines all predefined constants and operators
 76  *  as well as special classes such as java.lang.Object, which need
 77  *  to be known to the compiler. All symbols are held in instance
 78  *  fields. This makes it possible to work in multiple concurrent
 79  *  projects, which might use different class files for library classes.
 80  *
 81  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 82  *  If you write code that depends on this, you do so at your own risk.
 83  *  This code and its internal interfaces are subject to change or
 84  *  deletion without notice.&lt;/b&gt;
 85  */
 86 public class Symtab {
 87     /** The context key for the symbol table. */
 88     protected static final Context.Key&lt;Symtab&gt; symtabKey = new Context.Key&lt;&gt;();
 89 
</pre>
<hr />
<pre>
197     public final Type collectionsType;
198     public final Type comparableType;
199     public final Type comparatorType;
200     public final Type arraysType;
201     public final Type iterableType;
202     public final Type iteratorType;
203     public final Type annotationTargetType;
204     public final Type overrideType;
205     public final Type retentionType;
206     public final Type deprecatedType;
207     public final Type suppressWarningsType;
208     public final Type supplierType;
209     public final Type inheritedType;
210     public final Type profileType;
211     public final Type proprietaryType;
212     public final Type systemType;
213     public final Type autoCloseableType;
214     public final Type trustMeType;
215     public final Type lambdaMetafactory;
216     public final Type stringConcatFactory;
<span class="line-added">217     public final Type valueBootstrapMethods;</span>
218     public final Type repeatableType;
219     public final Type documentedType;
220     public final Type elementTypeType;
221     public final Type functionalInterfaceType;
222     public final Type previewFeatureType;
223     public final Type typeDescriptorType;
224     public final Type recordType;
<span class="line-added">225     public final Type valueBasedType;</span>
<span class="line-added">226     public final Type identityObjectType;</span>
227 
228     /** The symbol representing the length field of an array.
229      */
230     public final VarSymbol lengthVar;
231 
232     /** The symbol representing the final finalize method on enums */
233     public final MethodSymbol enumFinalFinalize;
234 
235     /** The symbol representing the close method on TWR AutoCloseable type */
236     public final MethodSymbol autoCloseableClose;
237 
238     /** The predefined type that belongs to a tag.
239      */
240     public final Type[] typeOfTag = new Type[TypeTag.getTypeTagCount()];
241 
242     /** The name of the class that belongs to a basic type tag.
243      */
244     public final Name[] boxedName = new Name[TypeTag.getTypeTagCount()];
245 
246     /** A hashtable containing the encountered top-level and member classes,
</pre>
<hr />
<pre>
249      *  by compiled source files.
250      */
251     private final Map&lt;Name, Map&lt;ModuleSymbol,ClassSymbol&gt;&gt; classes = new HashMap&lt;&gt;();
252 
253     /** A hashtable containing the encountered packages.
254      *  the table should be updated from outside to reflect packages defined
255      *  by compiled source files.
256      */
257     private final Map&lt;Name, Map&lt;ModuleSymbol,PackageSymbol&gt;&gt; packages = new HashMap&lt;&gt;();
258 
259     /** A hashtable giving the encountered modules.
260      */
261     private final Map&lt;Name, ModuleSymbol&gt; modules = new LinkedHashMap&lt;&gt;();
262 
263     private final Map&lt;Types.UniqueType, VarSymbol&gt; classFields = new HashMap&lt;&gt;();
264 
265     public VarSymbol getClassField(Type type, Types types) {
266         return classFields.computeIfAbsent(
267             new UniqueType(type, types), k -&gt; {
268                 Type arg = null;
<span class="line-modified">269                 if (type.getTag() == ARRAY || type.getTag() == CLASS) {</span>
<span class="line-modified">270                     /* Temporary treatment for inline class: Given an inline class V that implements</span>
<span class="line-added">271                        I1, I2, ... In, V.class is typed to be Class&lt;? extends Object &amp; I1 &amp; I2 .. &amp; In&gt;</span>
<span class="line-added">272                     */</span>
<span class="line-added">273                     if (type.isValue()) {</span>
<span class="line-added">274                         List&lt;Type&gt; bounds = List.of(objectType).appendList(((ClassSymbol) type.tsym).getInterfaces());</span>
<span class="line-added">275                         arg = new WildcardType(types.makeIntersectionType(bounds), BoundKind.EXTENDS, boundClass);</span>
<span class="line-added">276                     } else {</span>
<span class="line-added">277                         arg = types.erasure(type);</span>
<span class="line-added">278                     }</span>
<span class="line-added">279                 }</span>
280                 else if (type.isPrimitiveOrVoid())
281                     arg = types.boxedClass(type).type;
282                 else
283                     throw new AssertionError(type);
284 
285                 Type t = new ClassType(
286                     classType.getEnclosingType(), List.of(arg), classType.tsym);
287                 return new VarSymbol(
288                     STATIC | PUBLIC | FINAL, names._class, t, type.tsym);
289             });
290     }
291 
292     public void initType(Type type, ClassSymbol c) {
293         type.tsym = c;
294         typeOfTag[type.getTag().ordinal()] = type;
295     }
296 
297     public void initType(Type type, String name) {
298         initType(
299             type,
</pre>
<hr />
<pre>
575         overrideType = enterClass(&quot;java.lang.Override&quot;);
576         retentionType = enterClass(&quot;java.lang.annotation.Retention&quot;);
577         deprecatedType = enterClass(&quot;java.lang.Deprecated&quot;);
578         suppressWarningsType = enterClass(&quot;java.lang.SuppressWarnings&quot;);
579         supplierType = enterClass(&quot;java.util.function.Supplier&quot;);
580         inheritedType = enterClass(&quot;java.lang.annotation.Inherited&quot;);
581         repeatableType = enterClass(&quot;java.lang.annotation.Repeatable&quot;);
582         documentedType = enterClass(&quot;java.lang.annotation.Documented&quot;);
583         elementTypeType = enterClass(&quot;java.lang.annotation.ElementType&quot;);
584         systemType = enterClass(&quot;java.lang.System&quot;);
585         autoCloseableType = enterClass(&quot;java.lang.AutoCloseable&quot;);
586         autoCloseableClose = new MethodSymbol(PUBLIC,
587                              names.close,
588                              new MethodType(List.nil(), voidType,
589                                             List.of(exceptionType), methodClass),
590                              autoCloseableType.tsym);
591         trustMeType = enterClass(&quot;java.lang.SafeVarargs&quot;);
592         nativeHeaderType = enterClass(&quot;java.lang.annotation.Native&quot;);
593         lambdaMetafactory = enterClass(&quot;java.lang.invoke.LambdaMetafactory&quot;);
594         stringConcatFactory = enterClass(&quot;java.lang.invoke.StringConcatFactory&quot;);
<span class="line-added">595         valueBootstrapMethods = enterClass(&quot;java.lang.invoke.ValueBootstrapMethods&quot;);</span>
596         functionalInterfaceType = enterClass(&quot;java.lang.FunctionalInterface&quot;);
597         previewFeatureType = enterClass(&quot;jdk.internal.PreviewFeature&quot;);
598         typeDescriptorType = enterClass(&quot;java.lang.invoke.TypeDescriptor&quot;);
599         recordType = enterClass(&quot;java.lang.Record&quot;);
<span class="line-added">600         valueBasedType = enterClass(&quot;java.lang.ValueBased&quot;);</span>
<span class="line-added">601         identityObjectType = enterClass(&quot;java.lang.IdentityObject&quot;);</span>
602 
603         synthesizeEmptyInterfaceIfMissing(autoCloseableType);
604         synthesizeEmptyInterfaceIfMissing(cloneableType);
605         synthesizeEmptyInterfaceIfMissing(serializableType);
606         synthesizeEmptyInterfaceIfMissing(lambdaMetafactory);
607         synthesizeEmptyInterfaceIfMissing(serializedLambdaType);
608         synthesizeEmptyInterfaceIfMissing(stringConcatFactory);
<span class="line-added">609         synthesizeEmptyInterfaceIfMissing(identityObjectType);</span>
610         synthesizeBoxTypeIfMissing(doubleType);
611         synthesizeBoxTypeIfMissing(floatType);
612         synthesizeBoxTypeIfMissing(voidType);
613 
614         // Enter a synthetic class that is used to mark internal
615         // proprietary classes in ct.sym.  This class does not have a
616         // class file.
617         proprietaryType = enterSyntheticAnnotation(&quot;sun.Proprietary+Annotation&quot;);
618 
619         // Enter a synthetic class that is used to provide profile info for
620         // classes in ct.sym.  This class does not have a class file.
621         profileType = enterSyntheticAnnotation(&quot;jdk.Profile+Annotation&quot;);
622         MethodSymbol m = new MethodSymbol(PUBLIC | ABSTRACT, names.value, intType, profileType.tsym);
623         profileType.tsym.members().enter(m);
624 
625         // Enter a class for arrays.
626         // The class implements java.lang.Cloneable and java.io.Serializable.
627         // It has a final length field and a clone method.
628         ClassType arrayClassType = (ClassType)arrayClass.type;
629         arrayClassType.supertype_field = objectType;
<span class="line-modified">630         arrayClassType.interfaces_field =</span>
<span class="line-added">631                 List.of(cloneableType, serializableType, identityObjectType);</span>
<span class="line-added">632 </span>
633         arrayClass.members_field = WriteableScope.create(arrayClass);
634         lengthVar = new VarSymbol(
635             PUBLIC | FINAL,
636             names.length,
637             intType,
638             arrayClass);
639         arrayClass.members().enter(lengthVar);
640         arrayCloneMethod = new MethodSymbol(
641             PUBLIC,
642             names.clone,
643             new MethodType(List.nil(), objectType,
644                            List.nil(), methodClass),
645             arrayClass);
646         arrayClass.members().enter(arrayCloneMethod);
647 
648         if (java_base != noModule)
649             java_base.completer = moduleCompleter::complete; //bootstrap issues
650 
651     }
652 
</pre>
</td>
</tr>
</table>
<center><a href="Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Attr.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
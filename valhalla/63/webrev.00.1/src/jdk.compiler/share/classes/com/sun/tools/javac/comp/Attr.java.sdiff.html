<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Symtab.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
<span class="line-removed">  30 import java.util.stream.Collectors;</span>
  31 
  32 import javax.lang.model.element.ElementKind;
  33 import javax.tools.JavaFileObject;
  34 
  35 import com.sun.source.tree.CaseTree;
  36 import com.sun.source.tree.IdentifierTree;
  37 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  38 import com.sun.source.tree.MemberSelectTree;
  39 import com.sun.source.tree.TreeVisitor;
  40 import com.sun.source.util.SimpleTreeVisitor;
  41 import com.sun.tools.javac.code.*;
  42 import com.sun.tools.javac.code.Lint.LintCategory;
  43 import com.sun.tools.javac.code.Scope.WriteableScope;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Symbol.*;
  46 import com.sun.tools.javac.code.Type.*;
  47 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  48 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  49 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  50 import com.sun.tools.javac.comp.Check.CheckContext;
</pre>
<hr />
<pre>
 149         target = Target.instance(context);
 150         types = Types.instance(context);
 151         preview = Preview.instance(context);
 152         diags = JCDiagnostic.Factory.instance(context);
 153         annotate = Annotate.instance(context);
 154         typeAnnotations = TypeAnnotations.instance(context);
 155         deferredLintHandler = DeferredLintHandler.instance(context);
 156         typeEnvs = TypeEnvs.instance(context);
 157         dependencies = Dependencies.instance(context);
 158         argumentAttr = ArgumentAttr.instance(context);
 159         matchBindingsComputer = MatchBindingsComputer.instance(context);
 160 
 161         Options options = Options.instance(context);
 162 
 163         Source source = Source.instance(context);
 164         allowPoly = Feature.POLY.allowedInSource(source);
 165         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 166         allowLambda = Feature.LAMBDA.allowedInSource(source);
 167         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 168         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);

 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);


 174 
 175         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 176         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 177         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 178         methodAttrInfo = new MethodAttrInfo();
 179         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 180         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 181         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 182     }
 183 
 184     /** Switch: support target-typing inference
 185      */
 186     boolean allowPoly;
 187 
 188     /** Switch: support type annotations.
 189      */
 190     boolean allowTypeAnnos;
 191 
 192     /** Switch: support lambda expressions ?
 193      */
 194     boolean allowLambda;
 195 
 196     /** Switch: support default methods ?
 197      */
 198     boolean allowDefaultMethods;
 199 




 200     /** Switch: static interface methods enabled?
 201      */
 202     boolean allowStaticInterfaceMethods;
 203 
 204     /** Switch: reifiable types in instanceof enabled?
 205      */
 206     boolean allowReifiableTypesInInstanceof;
 207 
 208     /**
 209      * Switch: warn about use of variable before declaration?
 210      * RFE: 6425594
 211      */
 212     boolean useBeforeDeclarationWarning;
 213 










 214     /**
 215      * Switch: name of source level; used for error reporting.
 216      */
 217     String sourceName;
 218 
 219     /** Check kind and type of given tree against protokind and prototype.
 220      *  If check succeeds, store type in tree and return it.
 221      *  If check fails, store errType in tree and return it.
 222      *  No checks are performed if the prototype is a method type.
 223      *  It is not necessary in this case since we know that kind and type
 224      *  are correct.
 225      *
 226      *  @param tree     The tree whose kind and type is checked
 227      *  @param found    The computed type of the tree
 228      *  @param ownkind  The computed kind of the tree
 229      *  @param resultInfo  The expected result of the tree
 230      */
 231     Type check(final JCTree tree,
 232                final Type found,
 233                final KindSelector ownkind,
</pre>
<hr />
<pre>
 290      *  @param pos    The current source code position.
 291      *  @param v      The assigned variable
 292      *  @param base   If the variable is referred to in a Select, the part
 293      *                to the left of the `.&#39;, null otherwise.
 294      *  @param env    The current environment.
 295      */
 296     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 297         if (v.name == names._this) {
 298             log.error(pos, Errors.CantAssignValToThis);
 299         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 300             ((v.flags() &amp; HASINIT) != 0
 301              ||
 302              !((base == null ||
 303                TreeInfo.isThisQualifier(base)) &amp;&amp;
 304                isAssignableAsBlankFinal(v, env)))) {
 305             if (v.isResourceVariable()) { //TWR resource
 306                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 307             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 308                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 309             } else {
<span class="line-modified"> 310                 log.error(pos, Errors.CantAssignValToFinalVar(v));</span>










 311             }
 312         }
 313     }
 314 
 315     /** Does tree represent a static reference to an identifier?
 316      *  It is assumed that tree is either a SELECT or an IDENT.
 317      *  We have to weed out selects from non-type names here.
 318      *  @param tree    The candidate tree.
 319      */
 320     boolean isStaticReference(JCTree tree) {
 321         if (tree.hasTag(SELECT)) {
 322             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 323             if (lsym == null || lsym.kind != TYP) {
 324                 return false;
 325             }
 326         }
 327         return true;
 328     }
 329 
 330     /** Is this symbol a type?
</pre>
<hr />
<pre>
 782     /** Attribute a type argument list, returning a list of types.
 783      *  Check that all the types are references.
 784      */
 785     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 786         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 787         return chk.checkRefTypes(trees, types);
 788     }
 789 
 790     /**
 791      * Attribute type variables (of generic classes or methods).
 792      * Compound types are attributed later in attribBounds.
 793      * @param typarams the type variables to enter
 794      * @param env      the current environment
 795      */
 796     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 797         for (JCTypeParameter tvar : typarams) {
 798             TypeVar a = (TypeVar)tvar.type;
 799             a.tsym.flags_field |= UNATTRIBUTED;
 800             a.setUpperBound(Type.noType);
 801             if (!tvar.bounds.isEmpty()) {
<span class="line-modified"> 802                 List&lt;Type&gt; bounds = List.of(attribType(tvar.bounds.head, env));</span>
 803                 for (JCExpression bound : tvar.bounds.tail)
<span class="line-modified"> 804                     bounds = bounds.prepend(attribType(bound, env));</span>
 805                 types.setBounds(a, bounds.reverse());
 806             } else {
 807                 // if no bounds are given, assume a single bound of
 808                 // java.lang.Object.
 809                 types.setBounds(a, List.of(syms.objectType));
 810             }
 811             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 812         }
 813         if (checkCyclic) {
 814             for (JCTypeParameter tvar : typarams) {
 815                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 816             }
 817         }
 818     }
 819 
 820     /**
 821      * Attribute the type references in a list of annotations.
 822      */
 823     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 824                                Env&lt;AttrContext&gt; env) {
</pre>
<hr />
<pre>
 945                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 946                     enter.classEnter(tree, env);
 947             }
 948 
 949             ClassSymbol c = tree.sym;
 950             if (c == null) {
 951                 // exit in case something drastic went wrong during enter.
 952                 result = null;
 953             } else {
 954                 // make sure class has been completed:
 955                 c.complete();
 956 
 957                 // If this class appears as an anonymous class
 958                 // in a superclass constructor call
 959                 // disable implicit outer instance from being passed.
 960                 // (This would be an illegal access to &quot;this before super&quot;).
 961                 if (env.info.isSelfCall &amp;&amp;
 962                         env.tree.hasTag(NEWCLASS)) {
 963                     c.flags_field |= NOOUTERTHIS;
 964                 }



 965                 attribClass(tree.pos(), c);
 966                 result = tree.type = c.type;
 967             }
 968         } finally {
 969             localCacheContext.ifPresent(LocalCacheContext::leave);
 970         }
 971     }
 972 
 973     public void visitMethodDef(JCMethodDecl tree) {
 974         MethodSymbol m = tree.sym;
 975         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
 976 
 977         Lint lint = env.info.lint.augment(m);
 978         Lint prevLint = chk.setLint(lint);
 979         MethodSymbol prevMethod = chk.setMethod(m);
 980         try {
 981             deferredLintHandler.flush(tree.pos());
 982             chk.checkDeprecatedAnnotation(tree.pos(), m);
 983 
 984 
</pre>
<hr />
<pre>
1142                         log.error(tree.pos(),
1143                                   Errors.DefaultAllowedInIntfAnnotationMember);
1144                 }
1145                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1146                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1147             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1148                 if ((owner.flags() &amp; INTERFACE) != 0) {
1149                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1150                 } else {
1151                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1152                 }
1153             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1154                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1155             } else {
1156                 // Add an implicit super() call unless an explicit call to
1157                 // super(...) or this(...) is given
1158                 // or we are compiling class java.lang.Object.
1159                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1160                     JCBlock body = tree.body;
1161                     if (body.stats.isEmpty() ||
<span class="line-modified">1162                             TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {</span>
1163                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1164                                 make.Ident(names._super), make.Idents(List.nil())));
1165                         body.stats = body.stats.prepend(supCall);
1166                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1167                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1168                             TreeInfo.isSuperCall(body.stats.head)) {
1169                         // enum constructors are not allowed to call super
1170                         // directly, so make sure there aren&#39;t any super calls
1171                         // in enum constructors, except in the compiler
1172                         // generated one.
1173                         log.error(tree.body.stats.head.pos(),
1174                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1175                     }
1176                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1177                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1178                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1179                         if (!initParamNames.equals(recordComponentNames)) {
1180                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1181                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1182                         }
1183                         if (!tree.sym.isPublic()) {
1184                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1185                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1186                                     env.enclClass.sym.name, Fragments.CanonicalConstructorMustBePublic));
1187                         }
1188                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1189                             log.error(tree,
1190                                     Errors.InvalidCanonicalConstructorInRecord(
1191                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1192                                             env.enclClass.sym.name,
1193                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1194                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1195                         }
1196                     }
1197                 }






1198 
1199                 // Attribute all type annotations in the body
1200                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1201                 annotate.flush();
1202 
1203                 // Attribute method body.
1204                 attribStat(tree.body, localEnv);
1205             }
1206 
1207             localEnv.info.scope.leave();
1208             result = tree.type = m.type;
1209         } finally {
1210             chk.setLint(prevLint);
1211             chk.setMethod(prevMethod);
1212         }
1213     }
1214 
1215     public void visitVarDef(JCVariableDecl tree) {
1216         // Local variables have not been entered yet, so we need to do it now:
1217         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
</pre>
<hr />
<pre>
1247                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1248                 annotate.flush();
1249             }
1250         }
1251 
1252         VarSymbol v = tree.sym;
1253         Lint lint = env.info.lint.augment(v);
1254         Lint prevLint = chk.setLint(lint);
1255 
1256         // Check that the variable&#39;s declared type is well-formed.
1257         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1258                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1259                 (tree.sym.flags() &amp; PARAMETER) != 0;
1260         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1261 
1262         try {
1263             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1264             deferredLintHandler.flush(tree.pos());
1265             chk.checkDeprecatedAnnotation(tree.pos(), v);
1266 



1267             if (tree.init != null) {
<span class="line-modified">1268                 if ((v.flags_field &amp; FINAL) == 0 ||</span>
1269                     !memberEnter.needsLazyConstValue(tree.init)) {
1270                     // Not a compile-time constant
1271                     // Attribute initializer in a new environment
1272                     // with the declared variable as owner.
1273                     // Check that initializer conforms to variable&#39;s declared type.
1274                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1275                     initEnv.info.lint = lint;
1276                     // In order to catch self-references, we set the variable&#39;s
1277                     // declaration position to maximal possible value, effectively
1278                     // marking the variable as undefined.
1279                     initEnv.info.enclVar = v;
1280                     attribExpr(tree.init, initEnv, v.type);
1281                     if (tree.isImplicitlyTyped()) {
1282                         //fixup local variable type
1283                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1284                     }
1285                 }
1286                 if (tree.isImplicitlyTyped()) {
1287                     setSyntheticVariableType(tree, v.type);
1288                 }
</pre>
<hr />
<pre>
1372             }
1373         }
1374     }
1375 
1376     public void visitSkip(JCSkip tree) {
1377         result = null;
1378     }
1379 
1380     public void visitBlock(JCBlock tree) {
1381         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1382             // Block is a static or instance initializer;
1383             // let the owner of the environment be a freshly
1384             // created BLOCK-method.
1385             Symbol fakeOwner =
1386                 new MethodSymbol(tree.flags | BLOCK |
1387                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1388                     env.info.scope.owner);
1389             final Env&lt;AttrContext&gt; localEnv =
1390                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1391 
<span class="line-modified">1392             if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;</span>




1393             // Attribute all type annotations in the block
1394             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1395             annotate.flush();
1396             attribStats(tree.stats, localEnv);
1397 
1398             {
1399                 // Store init and clinit type annotations with the ClassSymbol
1400                 // to allow output in Gen.normalizeDefs.
1401                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1402                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1403                 if ((tree.flags &amp; STATIC) != 0) {
1404                     cs.appendClassInitTypeAttributes(tas);
1405                 } else {
1406                     cs.appendInitTypeAttributes(tas);
1407                 }
1408             }
1409         } else {
1410             // Create a new local environment with a local scope.
1411             Env&lt;AttrContext&gt; localEnv =
1412                 env.dup(tree, env.info.dup(env.info.scope.dup()));
</pre>
<hr />
<pre>
1437         // include condition&#39;s bindings when true in the body:
1438         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1439         try {
1440             attribStat(tree.body, whileEnv.dup(tree));
1441         } finally {
1442             whileEnv.info.scope.leave();
1443         }
1444         if (!breaksOutOf(tree, tree.body)) {
1445             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1446             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1447             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1448         }
1449         result = null;
1450     }
1451 
1452     private boolean breaksOutOf(JCTree loop, JCTree body) {
1453         preFlow(body);
1454         return flow.breaksOutOf(env, loop, body, make);
1455     }
1456 

































1457     public void visitForLoop(JCForLoop tree) {
1458         Env&lt;AttrContext&gt; loopEnv =
1459             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1460         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1461         try {
1462             attribStats(tree.init, loopEnv);
1463             if (tree.cond != null) {
1464                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1465                 // include condition&#39;s bindings when true in the body and step:
1466                 condBindings = matchBindings;
1467             }
1468             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1469             try {
1470                 bodyEnv.tree = tree; // before, we were not in loop!
1471                 attribStats(tree.step, bodyEnv);
1472                 attribStat(tree.body, bodyEnv);
1473             } finally {
1474                 bodyEnv.info.scope.leave();
1475             }
1476             result = null;
</pre>
<hr />
<pre>
1480         }
1481         if (!breaksOutOf(tree, tree.body)) {
1482             //include condition&#39;s body when false after the while, if cannot get out of the loop
1483             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1484             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1485         }
1486     }
1487 
1488     public void visitForeachLoop(JCEnhancedForLoop tree) {
1489         Env&lt;AttrContext&gt; loopEnv =
1490             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1491         try {
1492             //the Formal Parameter of a for-each loop is not in the scope when
1493             //attributing the for-each expression; we mimic this by attributing
1494             //the for-each expression first (against original scope).
1495             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1496             chk.checkNonVoid(tree.pos(), exprType);
1497             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1498             if (elemtype == null) {
1499                 // or perhaps expr implements Iterable&lt;T&gt;?
<span class="line-modified">1500                 Type base = types.asSuper(exprType, syms.iterableType.tsym);</span>
1501                 if (base == null) {
1502                     log.error(tree.expr.pos(),
1503                               Errors.ForeachNotApplicableToType(exprType,
1504                                                                 Fragments.TypeReqArrayOrIterable));
1505                     elemtype = types.createErrorType(exprType);
1506                 } else {
1507                     List&lt;Type&gt; iterableParams = base.allparams();
1508                     elemtype = iterableParams.isEmpty()
1509                         ? syms.objectType
1510                         : types.wildUpperBound(iterableParams.head);
1511                 }
1512             }
1513             if (tree.var.isImplicitlyTyped()) {
1514                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1515                 setSyntheticVariableType(tree.var, inferredType);
1516             }
1517             attribStat(tree.var, loopEnv);
1518             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1519             loopEnv.tree = tree; // before, we were not in loop!
1520             attribStat(tree.body, loopEnv);
</pre>
<hr />
<pre>
1694     // where
1695     /** Return the selected enumeration constant symbol, or null. */
1696     private Symbol enumConstant(JCTree tree, Type enumType) {
1697         if (tree.hasTag(IDENT)) {
1698             JCIdent ident = (JCIdent)tree;
1699             Name name = ident.name;
1700             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1701                 if (sym.kind == VAR) {
1702                     Symbol s = ident.sym = sym;
1703                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1704                     ident.type = s.type;
1705                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1706                         ? null : s;
1707                 }
1708             }
1709         }
1710         return null;
1711     }
1712 
1713     public void visitSynchronized(JCSynchronized tree) {
<span class="line-modified">1714         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env));</span>
1715         attribStat(tree.body, env);
1716         result = null;
1717     }
1718 
1719     public void visitTry(JCTry tree) {
1720         // Create a new local environment with a local
1721         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1722         try {
1723             boolean isTryWithResource = tree.resources.nonEmpty();
1724             // Create a nested environment for attributing the try block if needed
1725             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1726                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1727                 localEnv;
1728             try {
1729                 // Attribute resource declarations
1730                 for (JCTree resource : tree.resources) {
1731                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1732                         @Override
1733                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1734                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
</pre>
<hr />
<pre>
1775                     chk.checkType(c.param.vartype.pos(),
1776                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1777                                   syms.throwableType);
1778                     attribStat(c.body, catchEnv);
1779                 } finally {
1780                     catchEnv.info.scope.leave();
1781                 }
1782             }
1783 
1784             // Attribute finalizer
1785             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1786             result = null;
1787         }
1788         finally {
1789             localEnv.info.scope.leave();
1790         }
1791     }
1792 
1793     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1794         if (!resource.isErroneous() &amp;&amp;
<span class="line-modified">1795             types.asSuper(resource, syms.autoCloseableType.tsym) != null &amp;&amp;</span>
1796             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1797             Symbol close = syms.noSymbol;
1798             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1799             try {
1800                 close = rs.resolveQualifiedMethod(pos,
1801                         env,
1802                         types.skipTypeVars(resource, false),
1803                         names.close,
1804                         List.nil(),
1805                         List.nil());
1806             }
1807             finally {
1808                 log.popDiagnosticHandler(discardHandler);
1809             }
1810             if (close.kind == MTH &amp;&amp;
1811                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1812                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1813                     env.info.lint.isEnabled(LintCategory.TRY)) {
1814                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1815             }
</pre>
<hr />
<pre>
2375             // ... and attribute the method using as a prototype a methodtype
2376             // whose formal argument types is exactly the list of actual
2377             // arguments (this will also set the method symbol).
2378             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2379             localEnv.info.pendingResolutionPhase = null;
2380             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2381 
2382             // Compute the result type.
2383             Type restype = mtype.getReturnType();
2384             if (restype.hasTag(WILDCARD))
2385                 throw new AssertionError(mtype);
2386 
2387             Type qualifier = (tree.meth.hasTag(SELECT))
2388                     ? ((JCFieldAccess) tree.meth).selected.type
2389                     : env.enclClass.sym.type;
2390             Symbol msym = TreeInfo.symbol(tree.meth);
2391             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2392 
2393             chk.checkRefTypes(tree.typeargs, typeargtypes);
2394 




































2395             // Check that value of resulting type is admissible in the
2396             // current context.  Also, capture the return type
2397             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2398             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2399         }
2400         chk.validate(tree.typeargs, localEnv);
2401     }
2402     //where
2403         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2404             if (msym != null &amp;&amp;
2405                     msym.owner == syms.objectType.tsym &amp;&amp;
2406                     methodName == names.getClass &amp;&amp;
2407                     argtypes.isEmpty()) {
2408                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;









2409                 return new ClassType(restype.getEnclosingType(),
<span class="line-modified">2410                         List.of(new WildcardType(types.erasure(qualifierType),</span>
2411                                 BoundKind.EXTENDS,
2412                                 syms.boundClass)),
2413                         restype.tsym,
2414                         restype.getMetadata());
2415             } else if (msym != null &amp;&amp;
2416                     msym.owner == syms.arrayClass &amp;&amp;
2417                     methodName == names.clone &amp;&amp;
2418                     types.isArray(qualifierType)) {
2419                 // as a special case, array.clone() has a result that is
2420                 // the same as static type of the array being cloned
2421                 return qualifierType;
2422             } else {
2423                 return restype;
2424             }
2425         }
2426 
2427         /** Check that given application node appears as first statement
2428          *  in a constructor call.
2429          *  @param tree          The application node
2430          *  @param enclMethod    The enclosing method of the application.
</pre>
<hr />
<pre>
2734                                 this.resultInfo = prevResult;
2735                             }
2736                         });
2737             } else {
2738                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2739                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2740                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2741                         // One or more types inferred in the previous steps is non-denotable.
2742                         Fragment fragment = Diamond(clazztype.tsym);
2743                         log.error(tree.clazz.pos(),
2744                                 Errors.CantApplyDiamond1(
2745                                         fragment,
2746                                         invalidDiamondArgs.size() &gt; 1 ?
2747                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2748                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2749                     }
2750                     // For &lt;&gt;(){}, inferred types must also be accessible.
2751                     for (Type t : clazztype.getTypeArguments()) {
2752                         rs.checkAccessibleType(env, t);
2753                     }

2754                 }
2755 
2756                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2757                 // false for isInterface call even when the original type is an interface.
2758                 boolean implementing = clazztype.tsym.isInterface() ||
2759                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2760                         clazztype.getOriginalType().tsym.isInterface();
2761 
2762                 if (implementing) {
2763                     cdef.implementing = List.of(clazz);
2764                 } else {
2765                     cdef.extending = clazz;
2766                 }
2767 
2768                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2769                     isSerializable(clazztype)) {
2770                     localEnv.info.isSerializable = true;
2771                 }
2772 
2773                 attribStat(cdef, localEnv);
</pre>
<hr />
<pre>
2806             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2807             chk.validate(tree.typeargs, localEnv);
2808         }
2809 
2810         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2811             return new Check.NestedCheckContext(checkContext) {
2812                 @Override
2813                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2814                     enclosingContext.report(clazz.clazz,
2815                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2816                 }
2817             };
2818         }
2819 
2820     /** Make an attributed null check tree.
2821      */
2822     public JCExpression makeNullCheck(JCExpression arg) {
2823         // optimization: new Outer() can never be null; skip null check
2824         if (arg.getTag() == NEWCLASS)
2825             return arg;



2826         // optimization: X.this is never null; skip null check
2827         Name name = TreeInfo.name(arg);
2828         if (name == names._this || name == names._super) return arg;
2829 
2830         JCTree.Tag optag = NULLCHK;
2831         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2832         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2833         tree.type = arg.type;
2834         return tree;
2835     }
2836 
2837     public void visitNewArray(JCNewArray tree) {
2838         Type owntype = types.createErrorType(tree.type);
2839         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2840         Type elemtype;
2841         if (tree.elemtype != null) {
2842             elemtype = attribType(tree.elemtype, localEnv);
2843             chk.validate(tree.elemtype, localEnv);
2844             owntype = elemtype;
2845             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
3812         if (operator != operators.noOpSymbol &amp;&amp;
3813                 !left.isErroneous() &amp;&amp;
3814                 !right.isErroneous()) {
3815             owntype = operator.type.getReturnType();
3816             int opc = ((OperatorSymbol)operator).opcode;
3817             // If both arguments are constants, fold them.
3818             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3819                 Type ctype = cfolder.fold2(opc, left, right);
3820                 if (ctype != null) {
3821                     owntype = cfolder.coerce(ctype, owntype);
3822                 }
3823             }
3824 
3825             // Check that argument types of a reference ==, != are
3826             // castable to each other, (JLS 15.21).  Note: unboxing
3827             // comparisons will not have an acmp* opc at this point.
3828             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3829                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3830                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3831                 }

3832             }
3833 
3834             chk.checkDivZero(tree.rhs.pos(), operator, right);
3835         }
3836         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3837     }
3838 
3839     public void visitTypeCast(final JCTypeCast tree) {
3840         Type clazztype = attribType(tree.clazz, env);
3841         chk.validate(tree.clazz, env, false);
3842         //a fresh environment is required for 292 inference to work properly ---
3843         //see Infer.instantiatePolymorphicSignatureInstance()
3844         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
3845         //should we propagate the target type?
3846         final ResultInfo castInfo;
3847         JCExpression expr = TreeInfo.skipParens(tree.expr);
3848         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
3849         if (isPoly) {
3850             //expression is a poly - we need to propagate target type info
3851             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
</pre>
<hr />
<pre>
4009         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4010             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4011             // If the found symbol is inaccessible, then it is
4012             // accessed through an enclosing instance.  Locate this
4013             // enclosing instance:
4014             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4015                 env1 = env1.outer;
4016         }
4017 
4018         if (env.info.isSerializable) {
4019             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4020         }
4021 
4022         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4023     }
4024 
4025     public void visitSelect(JCFieldAccess tree) {
4026         // Determine the expected kind of the qualifier expression.
4027         KindSelector skind = KindSelector.NIL;
4028         if (tree.name == names._this || tree.name == names._super ||
<span class="line-modified">4029                 tree.name == names._class)</span>
4030         {




4031             skind = KindSelector.TYP;
4032         } else {
4033             if (pkind().contains(KindSelector.PCK))
4034                 skind = KindSelector.of(skind, KindSelector.PCK);
4035             if (pkind().contains(KindSelector.TYP))
4036                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4037             if (pkind().contains(KindSelector.VAL_MTH))
4038                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4039         }
4040 
4041         // Attribute the qualifier expression, and determine its symbol (if any).
4042         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4043         if (!pkind().contains(KindSelector.TYP_PCK))
4044             site = capture(site); // Capture field access
4045 
4046         // don&#39;t allow T.class T[].class, etc
4047         if (skind == KindSelector.TYP) {
4048             Type elt = site;
4049             while (elt.hasTag(ARRAY))
4050                 elt = ((ArrayType)elt).elemtype;
4051             if (elt.hasTag(TYPEVAR)) {
<span class="line-modified">4052                 log.error(tree.pos(), Errors.TypeVarCantBeDeref);</span>
<span class="line-modified">4053                 result = tree.type = types.createErrorType(tree.name, site.tsym, site);</span>
<span class="line-modified">4054                 tree.sym = tree.type.tsym;</span>
<span class="line-modified">4055                 return ;</span>





4056             }
4057         }
4058 
4059         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4060         // for the selection. This is relevant for determining whether
4061         // protected symbols are accessible.
4062         Symbol sitesym = TreeInfo.symbol(tree.selected);

4063         boolean selectSuperPrev = env.info.selectSuper;
4064         env.info.selectSuper =
4065             sitesym != null &amp;&amp;
4066             sitesym.name == names._super;
4067 
4068         // Determine the symbol represented by the selection.
4069         env.info.pendingResolutionPhase = null;
4070         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4071         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4072             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4073             sym = syms.errSymbol;
4074         }
4075         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4076             site = capture(site);
4077             sym = selectSym(tree, sitesym, site, env, resultInfo);
4078         }
4079         boolean varArgs = env.info.lastResolveVarargs();
4080         tree.sym = sym;
4081 
4082         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
</pre>
<hr />
<pre>
4178                                  Env&lt;AttrContext&gt; env,
4179                                  ResultInfo resultInfo) {
4180             DiagnosticPosition pos = tree.pos();
4181             Name name = tree.name;
4182             switch (site.getTag()) {
4183             case PACKAGE:
4184                 return rs.accessBase(
4185                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4186                     pos, location, site, name, true);
4187             case ARRAY:
4188             case CLASS:
4189                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4190                     return rs.resolveQualifiedMethod(
4191                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4192                 } else if (name == names._this || name == names._super) {
4193                     return rs.resolveSelf(pos, env, site.tsym, name);
4194                 } else if (name == names._class) {
4195                     // In this case, we have already made sure in
4196                     // visitSelect that qualifier expression is a type.
4197                     return syms.getClassField(site, types);






4198                 } else {
4199                     // We are seeing a plain identifier as selector.
4200                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4201                         sym = rs.accessBase(sym, pos, location, site, name, true);
4202                     return sym;
4203                 }
4204             case WILDCARD:
4205                 throw new AssertionError(tree);
4206             case TYPEVAR:




4207                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4208                 // It should only happen during memberEnter/attribBase
4209                 // when determining the super type which *must* be
4210                 // done before attributing the type variables.  In
4211                 // other words, we are seeing this illegal program:
4212                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4213                 Symbol sym = (site.getUpperBound() != null)
4214                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4215                     : null;
4216                 if (sym == null) {
4217                     log.error(pos, Errors.TypeVarCantBeDeref);
4218                     return syms.errSymbol;
4219                 } else {
4220                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4221                         rs.new AccessError(env, site, sym) :
4222                                 sym;
4223                     rs.accessBase(sym2, pos, location, site, name, true);
4224                     return sym;
4225                 }
4226             case ERROR:
4227                 // preserve identifier names through errors
4228                 return types.createErrorType(name, site.tsym, site).tsym;
4229             default:
4230                 // The qualifier expression is of a primitive type -- only
<span class="line-modified">4231                 // .class is allowed for these.</span>
4232                 if (name == names._class) {
4233                     // In this case, we have already made sure in Select that
4234                     // qualifier expression is a type.
4235                     return syms.getClassField(site, types);


4236                 } else {
4237                     log.error(pos, Errors.CantDeref(site));
4238                     return syms.errSymbol;
4239                 }
4240             }
4241         }
4242 
4243         /** Determine type of identifier or select expression and check that
4244          *  (1) the referenced symbol is not deprecated
4245          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4246          *  (3) if symbol is a variable, check that its type and kind are
4247          *      compatible with the prototype and protokind.
4248          *  (4) if symbol is an instance field of a raw type,
4249          *      which is being assigned to, issue an unchecked warning if its
4250          *      type changes under erasure.
4251          *  (5) if symbol is an instance method of a raw type, issue an
4252          *      unchecked warning if its argument types change under erasure.
4253          *  If checks succeed:
4254          *    If symbol is a constant, return its constant type
4255          *    else if symbol is a method, return its result type
</pre>
<hr />
<pre>
4827         if (bounds.length() == 0) {
4828             return syms.objectType;
4829         } else if (bounds.length() == 1) {
4830             return bounds.head.type;
4831         } else {
4832             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
4833             // ... the variable&#39;s bound is a class type flagged COMPOUND
4834             // (see comment for TypeVar.bound).
4835             // In this case, generate a class tree that represents the
4836             // bound class, ...
4837             JCExpression extending;
4838             List&lt;JCExpression&gt; implementing;
4839             if (!bounds.head.type.isInterface()) {
4840                 extending = bounds.head;
4841                 implementing = bounds.tail;
4842             } else {
4843                 extending = null;
4844                 implementing = bounds;
4845             }
4846             JCClassDecl cd = make.at(tree).ClassDef(
<span class="line-modified">4847                 make.Modifiers(PUBLIC | ABSTRACT),</span>
4848                 names.empty, List.nil(),
4849                 extending, implementing, List.nil());
4850 
4851             ClassSymbol c = (ClassSymbol)owntype.tsym;
4852             Assert.check((c.flags() &amp; COMPOUND) != 0);
4853             cd.sym = c;
4854             c.sourcefile = env.toplevel.sourcefile;
4855 
4856             // ... and attribute the bound class
4857             c.flags_field |= UNATTRIBUTED;
4858             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
4859             typeEnvs.put(c, cenv);
4860             attribClass(c);
4861             return owntype;
4862         }
4863     }
4864 
4865     public void visitWildcard(JCWildcard tree) {
4866         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
4867         Type type = (tree.kind.kind == BoundKind.UNBOUND)
4868             ? syms.objectType
4869             : attribType(tree.inner, env);
<span class="line-modified">4870         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),</span>
4871                                               tree.kind.kind,
4872                                               syms.boundClass),
4873                 KindSelector.TYP, resultInfo);
4874     }
4875 
4876     public void visitAnnotation(JCAnnotation tree) {
4877         Assert.error(&quot;should be handled in annotate&quot;);
4878     }
4879 
4880     public void visitAnnotatedType(JCAnnotatedType tree) {
4881         attribAnnotationTypes(tree.annotations, env);
4882         Type underlyingType = attribType(tree.underlyingType, env);
4883         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
4884 
4885         if (!env.info.isNewClass)
4886             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
4887         result = tree.type = annotatedType;
4888     }
4889 
4890     public void visitErroneous(JCErroneous tree) {
</pre>
<hr />
<pre>
4954             chk.completionError(pos, ex);
4955         }
4956     }
4957 
4958     void attribModule(ModuleSymbol m) {
4959         // Get environment current at the point of module definition.
4960         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
4961         attribStat(env.tree, env);
4962     }
4963 
4964     /** Main method: attribute class definition associated with given class symbol.
4965      *  reporting completion failures at the given position.
4966      *  @param pos The source position at which completion errors are to be
4967      *             reported.
4968      *  @param c   The class symbol whose definition will be attributed.
4969      */
4970     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
4971         try {
4972             annotate.flush();
4973             attribClass(c);







4974         } catch (CompletionFailure ex) {
4975             chk.completionError(pos, ex);
4976         }
4977     }
4978 
4979     /** Attribute class definition associated with given class symbol.
4980      *  @param c   The class symbol whose definition will be attributed.
4981      */
4982     void attribClass(ClassSymbol c) throws CompletionFailure {
4983         if (c.type.hasTag(ERROR)) return;
4984 
4985         // Check for cycles in the inheritance graph, which can arise from
4986         // ill-formed class files.
4987         chk.checkNonCyclic(null, c.type);
4988 
4989         Type st = types.supertype(c.type);
4990         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
4991             // First, attribute superclass.
4992             if (st.hasTag(CLASS))
4993                 attribClass((ClassSymbol)st.tsym);
</pre>
<hr />
<pre>
5026                 deferredLintHandler.flush(env.tree);
5027                 env.info.returnResult = null;
5028                 // java.lang.Enum may not be subclassed by a non-enum
5029                 if (st.tsym == syms.enumSym &amp;&amp;
5030                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5031                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5032 
5033                 // Enums may not be extended by source-level classes
5034                 if (st.tsym != null &amp;&amp;
5035                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5036                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5037                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5038                 }
5039 
5040                 if (isSerializable(c.type)) {
5041                     env.info.isSerializable = true;
5042                 }
5043 
5044                 attribClassBody(env, c);
5045 








5046                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5047                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5048                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5049                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5050             } finally {
5051                 env.info.returnResult = prevReturnRes;
5052                 log.useSource(prev);
5053                 chk.setLint(prevLint);
5054             }
5055 
5056         }
5057     }
5058 
5059     public void visitImport(JCImport tree) {
5060         // nothing to do
5061     }
5062 
5063     public void visitModuleDef(JCModuleDecl tree) {
5064         tree.sym.completeUsesProvides();
5065         ModuleSymbol msym = tree.sym;
</pre>
<hr />
<pre>
5131         chk.checkClassBounds(tree.pos(), c.type);
5132 
5133         tree.type = c.type;
5134 
5135         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5136              l.nonEmpty(); l = l.tail) {
5137              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5138         }
5139 
5140         // Check that a generic class doesn&#39;t extend Throwable
5141         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5142             log.error(tree.extending.pos(), Errors.GenericThrowable);
5143 
5144         // Check that all methods which implement some
5145         // method conform to the method they implement.
5146         chk.checkImplementations(tree);
5147 
5148         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5149         checkAutoCloseable(tree.pos(), env, c.type);
5150 

5151         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5152             // Attribute declaration
5153             attribStat(l.head, env);




5154             // Check that declarations in inner classes are not static (JLS 8.1.2)
5155             // Make an exception for static constants.
5156             if (c.owner.kind != PCK &amp;&amp;
5157                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5158                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5159                 Symbol sym = null;
5160                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5161                 if (sym == null ||
5162                     sym.kind != VAR ||
5163                     ((VarSymbol) sym).getConstValue() == null)
5164                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5165             }
5166         }



5167 
5168         // Check for cycles among non-initial constructors.
5169         chk.checkCyclicConstructors(tree);
5170 
5171         // Check for cycles among annotation elements.
5172         chk.checkNonCyclicElements(tree);
5173 
5174         // Check for proper use of serialVersionUID
5175         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5176                 &amp;&amp; isSerializable(c.type)
5177                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5178                 &amp;&amp; !c.isAnonymous()) {
5179             checkSerialVersionUID(tree, c);
5180         }
5181         if (allowTypeAnnos) {
5182             // Correctly organize the positions of the type annotations
5183             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5184 
5185             // Check type annotations applicability rules
5186             validateTypeAnnotations(tree, false);
</pre>
</td>
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;

  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.source.tree.CaseTree;
  35 import com.sun.source.tree.IdentifierTree;
  36 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  37 import com.sun.source.tree.MemberSelectTree;
  38 import com.sun.source.tree.TreeVisitor;
  39 import com.sun.source.util.SimpleTreeVisitor;
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Lint.LintCategory;
  42 import com.sun.tools.javac.code.Scope.WriteableScope;
  43 import com.sun.tools.javac.code.Source.Feature;
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Type.*;
  46 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  47 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  48 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  49 import com.sun.tools.javac.comp.Check.CheckContext;
</pre>
<hr />
<pre>
 148         target = Target.instance(context);
 149         types = Types.instance(context);
 150         preview = Preview.instance(context);
 151         diags = JCDiagnostic.Factory.instance(context);
 152         annotate = Annotate.instance(context);
 153         typeAnnotations = TypeAnnotations.instance(context);
 154         deferredLintHandler = DeferredLintHandler.instance(context);
 155         typeEnvs = TypeEnvs.instance(context);
 156         dependencies = Dependencies.instance(context);
 157         argumentAttr = ArgumentAttr.instance(context);
 158         matchBindingsComputer = MatchBindingsComputer.instance(context);
 159 
 160         Options options = Options.instance(context);
 161 
 162         Source source = Source.instance(context);
 163         allowPoly = Feature.POLY.allowedInSource(source);
 164         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 165         allowLambda = Feature.LAMBDA.allowedInSource(source);
 166         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 167         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
<span class="line-added"> 168         allowInlineTypes = Feature.INLINE_TYPES.allowedInSource(source);</span>
 169         allowReifiableTypesInInstanceof =
 170                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 171                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 172         sourceName = source.name;
 173         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
<span class="line-added"> 174         allowEmptyValues = options.isSet(&quot;allowEmptyValues&quot;);</span>
<span class="line-added"> 175         allowValueMemberCycles = options.isSet(&quot;allowValueMemberCycles&quot;);</span>
 176 
 177         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 178         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 179         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 180         methodAttrInfo = new MethodAttrInfo();
 181         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 182         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 183         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 184     }
 185 
 186     /** Switch: support target-typing inference
 187      */
 188     boolean allowPoly;
 189 
 190     /** Switch: support type annotations.
 191      */
 192     boolean allowTypeAnnos;
 193 
 194     /** Switch: support lambda expressions ?
 195      */
 196     boolean allowLambda;
 197 
 198     /** Switch: support default methods ?
 199      */
 200     boolean allowDefaultMethods;
 201 
<span class="line-added"> 202     /** Switch: allow inline types?</span>
<span class="line-added"> 203      */</span>
<span class="line-added"> 204     boolean allowInlineTypes;</span>
<span class="line-added"> 205 </span>
 206     /** Switch: static interface methods enabled?
 207      */
 208     boolean allowStaticInterfaceMethods;
 209 
 210     /** Switch: reifiable types in instanceof enabled?
 211      */
 212     boolean allowReifiableTypesInInstanceof;
 213 
 214     /**
 215      * Switch: warn about use of variable before declaration?
 216      * RFE: 6425594
 217      */
 218     boolean useBeforeDeclarationWarning;
 219 
<span class="line-added"> 220     /**</span>
<span class="line-added"> 221      * Switch: Allow value types with no instance state?</span>
<span class="line-added"> 222      */</span>
<span class="line-added"> 223     boolean allowEmptyValues;</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225     /**</span>
<span class="line-added"> 226      * Switch: Allow value type member cycles?</span>
<span class="line-added"> 227      */</span>
<span class="line-added"> 228     boolean allowValueMemberCycles;</span>
<span class="line-added"> 229 </span>
 230     /**
 231      * Switch: name of source level; used for error reporting.
 232      */
 233     String sourceName;
 234 
 235     /** Check kind and type of given tree against protokind and prototype.
 236      *  If check succeeds, store type in tree and return it.
 237      *  If check fails, store errType in tree and return it.
 238      *  No checks are performed if the prototype is a method type.
 239      *  It is not necessary in this case since we know that kind and type
 240      *  are correct.
 241      *
 242      *  @param tree     The tree whose kind and type is checked
 243      *  @param found    The computed type of the tree
 244      *  @param ownkind  The computed kind of the tree
 245      *  @param resultInfo  The expected result of the tree
 246      */
 247     Type check(final JCTree tree,
 248                final Type found,
 249                final KindSelector ownkind,
</pre>
<hr />
<pre>
 306      *  @param pos    The current source code position.
 307      *  @param v      The assigned variable
 308      *  @param base   If the variable is referred to in a Select, the part
 309      *                to the left of the `.&#39;, null otherwise.
 310      *  @param env    The current environment.
 311      */
 312     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 313         if (v.name == names._this) {
 314             log.error(pos, Errors.CantAssignValToThis);
 315         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 316             ((v.flags() &amp; HASINIT) != 0
 317              ||
 318              !((base == null ||
 319                TreeInfo.isThisQualifier(base)) &amp;&amp;
 320                isAssignableAsBlankFinal(v, env)))) {
 321             if (v.isResourceVariable()) { //TWR resource
 322                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 323             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 324                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 325             } else {
<span class="line-modified"> 326                 boolean complain = true;</span>
<span class="line-added"> 327                 /* Allow updates to instance fields of value classes by any method in the same nest via the</span>
<span class="line-added"> 328                    withfield operator -This does not result in mutation of final fields; the code generator</span>
<span class="line-added"> 329                    would implement `copy on write&#39; semantics via the opcode `withfield&#39;.</span>
<span class="line-added"> 330                 */</span>
<span class="line-added"> 331                 if (env.info.inWithField &amp;&amp; v.getKind() == ElementKind.FIELD &amp;&amp; (v.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) {</span>
<span class="line-added"> 332                     if (env.enclClass.sym.outermostClass() == v.owner.outermostClass())</span>
<span class="line-added"> 333                         complain = false;</span>
<span class="line-added"> 334                 }</span>
<span class="line-added"> 335                 if (complain)</span>
<span class="line-added"> 336                     log.error(pos, Errors.CantAssignValToFinalVar(v));</span>
 337             }
 338         }
 339     }
 340 
 341     /** Does tree represent a static reference to an identifier?
 342      *  It is assumed that tree is either a SELECT or an IDENT.
 343      *  We have to weed out selects from non-type names here.
 344      *  @param tree    The candidate tree.
 345      */
 346     boolean isStaticReference(JCTree tree) {
 347         if (tree.hasTag(SELECT)) {
 348             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 349             if (lsym == null || lsym.kind != TYP) {
 350                 return false;
 351             }
 352         }
 353         return true;
 354     }
 355 
 356     /** Is this symbol a type?
</pre>
<hr />
<pre>
 808     /** Attribute a type argument list, returning a list of types.
 809      *  Check that all the types are references.
 810      */
 811     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 812         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 813         return chk.checkRefTypes(trees, types);
 814     }
 815 
 816     /**
 817      * Attribute type variables (of generic classes or methods).
 818      * Compound types are attributed later in attribBounds.
 819      * @param typarams the type variables to enter
 820      * @param env      the current environment
 821      */
 822     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 823         for (JCTypeParameter tvar : typarams) {
 824             TypeVar a = (TypeVar)tvar.type;
 825             a.tsym.flags_field |= UNATTRIBUTED;
 826             a.setUpperBound(Type.noType);
 827             if (!tvar.bounds.isEmpty()) {
<span class="line-modified"> 828                 List&lt;Type&gt; bounds = List.of(chk.checkRefType(tvar.bounds.head, attribType(tvar.bounds.head, env), false));</span>
 829                 for (JCExpression bound : tvar.bounds.tail)
<span class="line-modified"> 830                     bounds = bounds.prepend(chk.checkRefType(bound, attribType(bound, env), false));</span>
 831                 types.setBounds(a, bounds.reverse());
 832             } else {
 833                 // if no bounds are given, assume a single bound of
 834                 // java.lang.Object.
 835                 types.setBounds(a, List.of(syms.objectType));
 836             }
 837             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 838         }
 839         if (checkCyclic) {
 840             for (JCTypeParameter tvar : typarams) {
 841                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 842             }
 843         }
 844     }
 845 
 846     /**
 847      * Attribute the type references in a list of annotations.
 848      */
 849     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 850                                Env&lt;AttrContext&gt; env) {
</pre>
<hr />
<pre>
 971                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 972                     enter.classEnter(tree, env);
 973             }
 974 
 975             ClassSymbol c = tree.sym;
 976             if (c == null) {
 977                 // exit in case something drastic went wrong during enter.
 978                 result = null;
 979             } else {
 980                 // make sure class has been completed:
 981                 c.complete();
 982 
 983                 // If this class appears as an anonymous class
 984                 // in a superclass constructor call
 985                 // disable implicit outer instance from being passed.
 986                 // (This would be an illegal access to &quot;this before super&quot;).
 987                 if (env.info.isSelfCall &amp;&amp;
 988                         env.tree.hasTag(NEWCLASS)) {
 989                     c.flags_field |= NOOUTERTHIS;
 990                 }
<span class="line-added"> 991                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; types.isValue(c.getSuperclass())) {</span>
<span class="line-added"> 992                     c.flags_field |= VALUE; // avoid further secondary errors.</span>
<span class="line-added"> 993                 }</span>
 994                 attribClass(tree.pos(), c);
 995                 result = tree.type = c.type;
 996             }
 997         } finally {
 998             localCacheContext.ifPresent(LocalCacheContext::leave);
 999         }
1000     }
1001 
1002     public void visitMethodDef(JCMethodDecl tree) {
1003         MethodSymbol m = tree.sym;
1004         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
1005 
1006         Lint lint = env.info.lint.augment(m);
1007         Lint prevLint = chk.setLint(lint);
1008         MethodSymbol prevMethod = chk.setMethod(m);
1009         try {
1010             deferredLintHandler.flush(tree.pos());
1011             chk.checkDeprecatedAnnotation(tree.pos(), m);
1012 
1013 
</pre>
<hr />
<pre>
1171                         log.error(tree.pos(),
1172                                   Errors.DefaultAllowedInIntfAnnotationMember);
1173                 }
1174                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1175                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1176             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1177                 if ((owner.flags() &amp; INTERFACE) != 0) {
1178                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1179                 } else {
1180                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1181                 }
1182             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1183                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1184             } else {
1185                 // Add an implicit super() call unless an explicit call to
1186                 // super(...) or this(...) is given
1187                 // or we are compiling class java.lang.Object.
1188                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1189                     JCBlock body = tree.body;
1190                     if (body.stats.isEmpty() ||
<span class="line-modified">1191                             TreeInfo.getConstructorInvocationName(body.stats, names, true) == names.empty) {</span>
1192                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1193                                 make.Ident(names._super), make.Idents(List.nil())));
1194                         body.stats = body.stats.prepend(supCall);
1195                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1196                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1197                             TreeInfo.isSuperCall(body.stats.head)) {
1198                         // enum constructors are not allowed to call super
1199                         // directly, so make sure there aren&#39;t any super calls
1200                         // in enum constructors, except in the compiler
1201                         // generated one.
1202                         log.error(tree.body.stats.head.pos(),
1203                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1204                     }
1205                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1206                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1207                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1208                         if (!initParamNames.equals(recordComponentNames)) {
1209                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1210                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1211                         }
1212                         if (!tree.sym.isPublic()) {
1213                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1214                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1215                                     env.enclClass.sym.name, Fragments.CanonicalConstructorMustBePublic));
1216                         }
1217                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1218                             log.error(tree,
1219                                     Errors.InvalidCanonicalConstructorInRecord(
1220                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1221                                             env.enclClass.sym.name,
1222                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1223                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1224                         }
1225                     }
1226                 }
<span class="line-added">1227                 if (m.isConstructor() &amp;&amp; m.type.getParameterTypes().size() == 0) {</span>
<span class="line-added">1228                     if ((owner.type == syms.objectType) ||</span>
<span class="line-added">1229                             (tree.body.stats.size() == 1 &amp;&amp; TreeInfo.getConstructorInvocationName(tree.body.stats, names, false) == names._super)) {</span>
<span class="line-added">1230                         m.flags_field |= EMPTYNOARGCONSTR;</span>
<span class="line-added">1231                     }</span>
<span class="line-added">1232                 }</span>
1233 
1234                 // Attribute all type annotations in the body
1235                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1236                 annotate.flush();
1237 
1238                 // Attribute method body.
1239                 attribStat(tree.body, localEnv);
1240             }
1241 
1242             localEnv.info.scope.leave();
1243             result = tree.type = m.type;
1244         } finally {
1245             chk.setLint(prevLint);
1246             chk.setMethod(prevMethod);
1247         }
1248     }
1249 
1250     public void visitVarDef(JCVariableDecl tree) {
1251         // Local variables have not been entered yet, so we need to do it now:
1252         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
</pre>
<hr />
<pre>
1282                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1283                 annotate.flush();
1284             }
1285         }
1286 
1287         VarSymbol v = tree.sym;
1288         Lint lint = env.info.lint.augment(v);
1289         Lint prevLint = chk.setLint(lint);
1290 
1291         // Check that the variable&#39;s declared type is well-formed.
1292         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1293                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1294                 (tree.sym.flags() &amp; PARAMETER) != 0;
1295         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1296 
1297         try {
1298             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1299             deferredLintHandler.flush(tree.pos());
1300             chk.checkDeprecatedAnnotation(tree.pos(), v);
1301 
<span class="line-added">1302             /* Don&#39;t want constant propagation/folding for instance fields of value classes,</span>
<span class="line-added">1303                as these can undergo updates via copy on write.</span>
<span class="line-added">1304             */</span>
1305             if (tree.init != null) {
<span class="line-modified">1306                 if ((v.flags_field &amp; FINAL) == 0 || ((v.flags_field &amp; STATIC) == 0 &amp;&amp; types.isValue(v.owner.type)) ||</span>
1307                     !memberEnter.needsLazyConstValue(tree.init)) {
1308                     // Not a compile-time constant
1309                     // Attribute initializer in a new environment
1310                     // with the declared variable as owner.
1311                     // Check that initializer conforms to variable&#39;s declared type.
1312                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1313                     initEnv.info.lint = lint;
1314                     // In order to catch self-references, we set the variable&#39;s
1315                     // declaration position to maximal possible value, effectively
1316                     // marking the variable as undefined.
1317                     initEnv.info.enclVar = v;
1318                     attribExpr(tree.init, initEnv, v.type);
1319                     if (tree.isImplicitlyTyped()) {
1320                         //fixup local variable type
1321                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1322                     }
1323                 }
1324                 if (tree.isImplicitlyTyped()) {
1325                     setSyntheticVariableType(tree, v.type);
1326                 }
</pre>
<hr />
<pre>
1410             }
1411         }
1412     }
1413 
1414     public void visitSkip(JCSkip tree) {
1415         result = null;
1416     }
1417 
1418     public void visitBlock(JCBlock tree) {
1419         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1420             // Block is a static or instance initializer;
1421             // let the owner of the environment be a freshly
1422             // created BLOCK-method.
1423             Symbol fakeOwner =
1424                 new MethodSymbol(tree.flags | BLOCK |
1425                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1426                     env.info.scope.owner);
1427             final Env&lt;AttrContext&gt; localEnv =
1428                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1429 
<span class="line-modified">1430             if ((tree.flags &amp; STATIC) != 0)</span>
<span class="line-added">1431                 localEnv.info.staticLevel++;</span>
<span class="line-added">1432             else if (tree.stats.size() &gt; 0)</span>
<span class="line-added">1433                 env.info.scope.owner.flags_field |= HASINITBLOCK;</span>
<span class="line-added">1434 </span>
1435             // Attribute all type annotations in the block
1436             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1437             annotate.flush();
1438             attribStats(tree.stats, localEnv);
1439 
1440             {
1441                 // Store init and clinit type annotations with the ClassSymbol
1442                 // to allow output in Gen.normalizeDefs.
1443                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1444                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1445                 if ((tree.flags &amp; STATIC) != 0) {
1446                     cs.appendClassInitTypeAttributes(tas);
1447                 } else {
1448                     cs.appendInitTypeAttributes(tas);
1449                 }
1450             }
1451         } else {
1452             // Create a new local environment with a local scope.
1453             Env&lt;AttrContext&gt; localEnv =
1454                 env.dup(tree, env.info.dup(env.info.scope.dup()));
</pre>
<hr />
<pre>
1479         // include condition&#39;s bindings when true in the body:
1480         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1481         try {
1482             attribStat(tree.body, whileEnv.dup(tree));
1483         } finally {
1484             whileEnv.info.scope.leave();
1485         }
1486         if (!breaksOutOf(tree, tree.body)) {
1487             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1488             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1489             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1490         }
1491         result = null;
1492     }
1493 
1494     private boolean breaksOutOf(JCTree loop, JCTree body) {
1495         preFlow(body);
1496         return flow.breaksOutOf(env, loop, body, make);
1497     }
1498 
<span class="line-added">1499     public void visitWithField(JCWithField tree) {</span>
<span class="line-added">1500         boolean inWithField = env.info.inWithField;</span>
<span class="line-added">1501         try {</span>
<span class="line-added">1502             env.info.inWithField = true;</span>
<span class="line-added">1503             Type fieldtype = attribTree(tree.field, env.dup(tree), varAssignmentInfo);</span>
<span class="line-added">1504             attribExpr(tree.value, env, fieldtype);</span>
<span class="line-added">1505             Type capturedType = syms.errType;</span>
<span class="line-added">1506             if (tree.field.type != null &amp;&amp; !tree.field.type.isErroneous()) {</span>
<span class="line-added">1507                 final Symbol sym = TreeInfo.symbol(tree.field);</span>
<span class="line-added">1508                 if (sym == null || sym.kind != VAR || sym.owner.kind != TYP ||</span>
<span class="line-added">1509                         (sym.flags() &amp; STATIC) != 0 || !types.isValue(sym.owner.type)) {</span>
<span class="line-added">1510                     log.error(tree.field.pos(), Errors.ValueInstanceFieldExpectedHere);</span>
<span class="line-added">1511                 } else {</span>
<span class="line-added">1512                     Type ownType = sym.owner.type;</span>
<span class="line-added">1513                     switch(tree.field.getTag()) {</span>
<span class="line-added">1514                         case IDENT:</span>
<span class="line-added">1515                             JCIdent ident = (JCIdent) tree.field;</span>
<span class="line-added">1516                             ownType = ident.sym.owner.type;</span>
<span class="line-added">1517                             break;</span>
<span class="line-added">1518                         case SELECT:</span>
<span class="line-added">1519                             JCFieldAccess fieldAccess = (JCFieldAccess) tree.field;</span>
<span class="line-added">1520                             ownType = fieldAccess.selected.type;</span>
<span class="line-added">1521                             break;</span>
<span class="line-added">1522                     }</span>
<span class="line-added">1523                     capturedType = capture(ownType);</span>
<span class="line-added">1524                 }</span>
<span class="line-added">1525             }</span>
<span class="line-added">1526             result = check(tree, capturedType, KindSelector.VAL, resultInfo);</span>
<span class="line-added">1527         } finally {</span>
<span class="line-added">1528             env.info.inWithField = inWithField;</span>
<span class="line-added">1529         }</span>
<span class="line-added">1530     }</span>
<span class="line-added">1531 </span>
1532     public void visitForLoop(JCForLoop tree) {
1533         Env&lt;AttrContext&gt; loopEnv =
1534             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1535         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1536         try {
1537             attribStats(tree.init, loopEnv);
1538             if (tree.cond != null) {
1539                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1540                 // include condition&#39;s bindings when true in the body and step:
1541                 condBindings = matchBindings;
1542             }
1543             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1544             try {
1545                 bodyEnv.tree = tree; // before, we were not in loop!
1546                 attribStats(tree.step, bodyEnv);
1547                 attribStat(tree.body, bodyEnv);
1548             } finally {
1549                 bodyEnv.info.scope.leave();
1550             }
1551             result = null;
</pre>
<hr />
<pre>
1555         }
1556         if (!breaksOutOf(tree, tree.body)) {
1557             //include condition&#39;s body when false after the while, if cannot get out of the loop
1558             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1559             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1560         }
1561     }
1562 
1563     public void visitForeachLoop(JCEnhancedForLoop tree) {
1564         Env&lt;AttrContext&gt; loopEnv =
1565             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1566         try {
1567             //the Formal Parameter of a for-each loop is not in the scope when
1568             //attributing the for-each expression; we mimic this by attributing
1569             //the for-each expression first (against original scope).
1570             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1571             chk.checkNonVoid(tree.pos(), exprType);
1572             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1573             if (elemtype == null) {
1574                 // or perhaps expr implements Iterable&lt;T&gt;?
<span class="line-modified">1575                 Type base = types.asSuper(exprType, syms.iterableType.tsym, true);</span>
1576                 if (base == null) {
1577                     log.error(tree.expr.pos(),
1578                               Errors.ForeachNotApplicableToType(exprType,
1579                                                                 Fragments.TypeReqArrayOrIterable));
1580                     elemtype = types.createErrorType(exprType);
1581                 } else {
1582                     List&lt;Type&gt; iterableParams = base.allparams();
1583                     elemtype = iterableParams.isEmpty()
1584                         ? syms.objectType
1585                         : types.wildUpperBound(iterableParams.head);
1586                 }
1587             }
1588             if (tree.var.isImplicitlyTyped()) {
1589                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1590                 setSyntheticVariableType(tree.var, inferredType);
1591             }
1592             attribStat(tree.var, loopEnv);
1593             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1594             loopEnv.tree = tree; // before, we were not in loop!
1595             attribStat(tree.body, loopEnv);
</pre>
<hr />
<pre>
1769     // where
1770     /** Return the selected enumeration constant symbol, or null. */
1771     private Symbol enumConstant(JCTree tree, Type enumType) {
1772         if (tree.hasTag(IDENT)) {
1773             JCIdent ident = (JCIdent)tree;
1774             Name name = ident.name;
1775             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1776                 if (sym.kind == VAR) {
1777                     Symbol s = ident.sym = sym;
1778                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1779                     ident.type = s.type;
1780                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1781                         ? null : s;
1782                 }
1783             }
1784         }
1785         return null;
1786     }
1787 
1788     public void visitSynchronized(JCSynchronized tree) {
<span class="line-modified">1789         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env), false);</span>
1790         attribStat(tree.body, env);
1791         result = null;
1792     }
1793 
1794     public void visitTry(JCTry tree) {
1795         // Create a new local environment with a local
1796         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1797         try {
1798             boolean isTryWithResource = tree.resources.nonEmpty();
1799             // Create a nested environment for attributing the try block if needed
1800             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1801                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1802                 localEnv;
1803             try {
1804                 // Attribute resource declarations
1805                 for (JCTree resource : tree.resources) {
1806                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1807                         @Override
1808                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1809                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
</pre>
<hr />
<pre>
1850                     chk.checkType(c.param.vartype.pos(),
1851                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1852                                   syms.throwableType);
1853                     attribStat(c.body, catchEnv);
1854                 } finally {
1855                     catchEnv.info.scope.leave();
1856                 }
1857             }
1858 
1859             // Attribute finalizer
1860             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1861             result = null;
1862         }
1863         finally {
1864             localEnv.info.scope.leave();
1865         }
1866     }
1867 
1868     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1869         if (!resource.isErroneous() &amp;&amp;
<span class="line-modified">1870             types.asSuper(resource, syms.autoCloseableType.tsym, true) != null &amp;&amp;</span>
1871             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1872             Symbol close = syms.noSymbol;
1873             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1874             try {
1875                 close = rs.resolveQualifiedMethod(pos,
1876                         env,
1877                         types.skipTypeVars(resource, false),
1878                         names.close,
1879                         List.nil(),
1880                         List.nil());
1881             }
1882             finally {
1883                 log.popDiagnosticHandler(discardHandler);
1884             }
1885             if (close.kind == MTH &amp;&amp;
1886                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1887                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1888                     env.info.lint.isEnabled(LintCategory.TRY)) {
1889                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1890             }
</pre>
<hr />
<pre>
2450             // ... and attribute the method using as a prototype a methodtype
2451             // whose formal argument types is exactly the list of actual
2452             // arguments (this will also set the method symbol).
2453             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2454             localEnv.info.pendingResolutionPhase = null;
2455             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2456 
2457             // Compute the result type.
2458             Type restype = mtype.getReturnType();
2459             if (restype.hasTag(WILDCARD))
2460                 throw new AssertionError(mtype);
2461 
2462             Type qualifier = (tree.meth.hasTag(SELECT))
2463                     ? ((JCFieldAccess) tree.meth).selected.type
2464                     : env.enclClass.sym.type;
2465             Symbol msym = TreeInfo.symbol(tree.meth);
2466             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2467 
2468             chk.checkRefTypes(tree.typeargs, typeargtypes);
2469 
<span class="line-added">2470             final Symbol symbol = TreeInfo.symbol(tree.meth);</span>
<span class="line-added">2471             if (symbol != null) {</span>
<span class="line-added">2472                 /* Is this an ill conceived attempt to invoke jlO methods not available on value types ??</span>
<span class="line-added">2473                  */</span>
<span class="line-added">2474                 boolean superCallOnValueReceiver = types.isValue(env.enclClass.sym.type)</span>
<span class="line-added">2475                         &amp;&amp; (tree.meth.hasTag(SELECT))</span>
<span class="line-added">2476                         &amp;&amp; ((JCFieldAccess)tree.meth).selected.hasTag(IDENT)</span>
<span class="line-added">2477                         &amp;&amp; TreeInfo.name(((JCFieldAccess)tree.meth).selected) == names._super;</span>
<span class="line-added">2478                 if (types.isValue(qualifier) || superCallOnValueReceiver) {</span>
<span class="line-added">2479                     int argSize = argtypes.size();</span>
<span class="line-added">2480                     Name name = symbol.name;</span>
<span class="line-added">2481                     switch (name.toString()) {</span>
<span class="line-added">2482                         case &quot;wait&quot;:</span>
<span class="line-added">2483                             if (argSize == 0</span>
<span class="line-added">2484                                     || (types.isConvertible(argtypes.head, syms.longType) &amp;&amp;</span>
<span class="line-added">2485                                     (argSize == 1 || (argSize == 2 &amp;&amp; types.isConvertible(argtypes.tail.head, syms.intType))))) {</span>
<span class="line-added">2486                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));</span>
<span class="line-added">2487                             }</span>
<span class="line-added">2488                             break;</span>
<span class="line-added">2489                         case &quot;notify&quot;:</span>
<span class="line-added">2490                         case &quot;notifyAll&quot;:</span>
<span class="line-added">2491                         case &quot;clone&quot;:</span>
<span class="line-added">2492                         case &quot;finalize&quot;:</span>
<span class="line-added">2493                             if (argSize == 0)</span>
<span class="line-added">2494                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(name));</span>
<span class="line-added">2495                             break;</span>
<span class="line-added">2496                         case &quot;hashCode&quot;:</span>
<span class="line-added">2497                         case &quot;equals&quot;:</span>
<span class="line-added">2498                         case &quot;toString&quot;:</span>
<span class="line-added">2499                             if (superCallOnValueReceiver)</span>
<span class="line-added">2500                                 log.error(tree.pos(), Errors.ValueDoesNotSupport(names.fromString(&quot;invocation of super.&quot; + name)));</span>
<span class="line-added">2501                             break;</span>
<span class="line-added">2502                     }</span>
<span class="line-added">2503                 }</span>
<span class="line-added">2504             }</span>
<span class="line-added">2505 </span>
2506             // Check that value of resulting type is admissible in the
2507             // current context.  Also, capture the return type
2508             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2509             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2510         }
2511         chk.validate(tree.typeargs, localEnv);
2512     }
2513     //where
2514         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2515             if (msym != null &amp;&amp;
2516                     msym.owner == syms.objectType.tsym &amp;&amp;
2517                     methodName == names.getClass &amp;&amp;
2518                     argtypes.isEmpty()) {
2519                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;
<span class="line-added">2520                 // Temporary treatment for inline class: Given an inline class V that implements</span>
<span class="line-added">2521                 // I1, I2, ... In, v.getClass() is typed to be Class&lt;? extends Object &amp; I1 &amp; I2 .. &amp; In&gt;</span>
<span class="line-added">2522                 Type wcb;</span>
<span class="line-added">2523                 if (qualifierType.isValue()) {</span>
<span class="line-added">2524                     List&lt;Type&gt; bounds = List.of(syms.objectType).appendList(((ClassSymbol) qualifierType.tsym).getInterfaces());</span>
<span class="line-added">2525                     wcb = types.makeIntersectionType(bounds);</span>
<span class="line-added">2526                 } else {</span>
<span class="line-added">2527                     wcb = types.erasure(qualifierType);</span>
<span class="line-added">2528                 }</span>
2529                 return new ClassType(restype.getEnclosingType(),
<span class="line-modified">2530                         List.of(new WildcardType(wcb,</span>
2531                                 BoundKind.EXTENDS,
2532                                 syms.boundClass)),
2533                         restype.tsym,
2534                         restype.getMetadata());
2535             } else if (msym != null &amp;&amp;
2536                     msym.owner == syms.arrayClass &amp;&amp;
2537                     methodName == names.clone &amp;&amp;
2538                     types.isArray(qualifierType)) {
2539                 // as a special case, array.clone() has a result that is
2540                 // the same as static type of the array being cloned
2541                 return qualifierType;
2542             } else {
2543                 return restype;
2544             }
2545         }
2546 
2547         /** Check that given application node appears as first statement
2548          *  in a constructor call.
2549          *  @param tree          The application node
2550          *  @param enclMethod    The enclosing method of the application.
</pre>
<hr />
<pre>
2854                                 this.resultInfo = prevResult;
2855                             }
2856                         });
2857             } else {
2858                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2859                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2860                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2861                         // One or more types inferred in the previous steps is non-denotable.
2862                         Fragment fragment = Diamond(clazztype.tsym);
2863                         log.error(tree.clazz.pos(),
2864                                 Errors.CantApplyDiamond1(
2865                                         fragment,
2866                                         invalidDiamondArgs.size() &gt; 1 ?
2867                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2868                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2869                     }
2870                     // For &lt;&gt;(){}, inferred types must also be accessible.
2871                     for (Type t : clazztype.getTypeArguments()) {
2872                         rs.checkAccessibleType(env, t);
2873                     }
<span class="line-added">2874                     chk.checkParameterizationWithValues(tree, clazztype);</span>
2875                 }
2876 
2877                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2878                 // false for isInterface call even when the original type is an interface.
2879                 boolean implementing = clazztype.tsym.isInterface() ||
2880                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2881                         clazztype.getOriginalType().tsym.isInterface();
2882 
2883                 if (implementing) {
2884                     cdef.implementing = List.of(clazz);
2885                 } else {
2886                     cdef.extending = clazz;
2887                 }
2888 
2889                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2890                     isSerializable(clazztype)) {
2891                     localEnv.info.isSerializable = true;
2892                 }
2893 
2894                 attribStat(cdef, localEnv);
</pre>
<hr />
<pre>
2927             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2928             chk.validate(tree.typeargs, localEnv);
2929         }
2930 
2931         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2932             return new Check.NestedCheckContext(checkContext) {
2933                 @Override
2934                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2935                     enclosingContext.report(clazz.clazz,
2936                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2937                 }
2938             };
2939         }
2940 
2941     /** Make an attributed null check tree.
2942      */
2943     public JCExpression makeNullCheck(JCExpression arg) {
2944         // optimization: new Outer() can never be null; skip null check
2945         if (arg.getTag() == NEWCLASS)
2946             return arg;
<span class="line-added">2947         // Likewise arg can&#39;t be null if it is a value.</span>
<span class="line-added">2948         if (types.isValue(arg.type))</span>
<span class="line-added">2949             return arg;</span>
2950         // optimization: X.this is never null; skip null check
2951         Name name = TreeInfo.name(arg);
2952         if (name == names._this || name == names._super) return arg;
2953 
2954         JCTree.Tag optag = NULLCHK;
2955         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2956         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2957         tree.type = arg.type;
2958         return tree;
2959     }
2960 
2961     public void visitNewArray(JCNewArray tree) {
2962         Type owntype = types.createErrorType(tree.type);
2963         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2964         Type elemtype;
2965         if (tree.elemtype != null) {
2966             elemtype = attribType(tree.elemtype, localEnv);
2967             chk.validate(tree.elemtype, localEnv);
2968             owntype = elemtype;
2969             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
</pre>
<hr />
<pre>
3936         if (operator != operators.noOpSymbol &amp;&amp;
3937                 !left.isErroneous() &amp;&amp;
3938                 !right.isErroneous()) {
3939             owntype = operator.type.getReturnType();
3940             int opc = ((OperatorSymbol)operator).opcode;
3941             // If both arguments are constants, fold them.
3942             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3943                 Type ctype = cfolder.fold2(opc, left, right);
3944                 if (ctype != null) {
3945                     owntype = cfolder.coerce(ctype, owntype);
3946                 }
3947             }
3948 
3949             // Check that argument types of a reference ==, != are
3950             // castable to each other, (JLS 15.21).  Note: unboxing
3951             // comparisons will not have an acmp* opc at this point.
3952             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3953                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3954                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3955                 }
<span class="line-added">3956                 chk.checkForSuspectClassLiteralComparison(tree, left, right);</span>
3957             }
3958 
3959             chk.checkDivZero(tree.rhs.pos(), operator, right);
3960         }
3961         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3962     }
3963 
3964     public void visitTypeCast(final JCTypeCast tree) {
3965         Type clazztype = attribType(tree.clazz, env);
3966         chk.validate(tree.clazz, env, false);
3967         //a fresh environment is required for 292 inference to work properly ---
3968         //see Infer.instantiatePolymorphicSignatureInstance()
3969         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
3970         //should we propagate the target type?
3971         final ResultInfo castInfo;
3972         JCExpression expr = TreeInfo.skipParens(tree.expr);
3973         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
3974         if (isPoly) {
3975             //expression is a poly - we need to propagate target type info
3976             castInfo = new ResultInfo(KindSelector.VAL, clazztype,
</pre>
<hr />
<pre>
4134         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4135             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4136             // If the found symbol is inaccessible, then it is
4137             // accessed through an enclosing instance.  Locate this
4138             // enclosing instance:
4139             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4140                 env1 = env1.outer;
4141         }
4142 
4143         if (env.info.isSerializable) {
4144             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4145         }
4146 
4147         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4148     }
4149 
4150     public void visitSelect(JCFieldAccess tree) {
4151         // Determine the expected kind of the qualifier expression.
4152         KindSelector skind = KindSelector.NIL;
4153         if (tree.name == names._this || tree.name == names._super ||
<span class="line-modified">4154                 tree.name == names._class || tree.name == names._default)</span>
4155         {
<span class="line-added">4156             if (tree.name == names._default &amp;&amp; !allowInlineTypes) {</span>
<span class="line-added">4157                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),</span>
<span class="line-added">4158                         Feature.INLINE_TYPES.error(sourceName));</span>
<span class="line-added">4159             }</span>
4160             skind = KindSelector.TYP;
4161         } else {
4162             if (pkind().contains(KindSelector.PCK))
4163                 skind = KindSelector.of(skind, KindSelector.PCK);
4164             if (pkind().contains(KindSelector.TYP))
4165                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4166             if (pkind().contains(KindSelector.VAL_MTH))
4167                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4168         }
4169 
4170         // Attribute the qualifier expression, and determine its symbol (if any).
4171         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4172         if (!pkind().contains(KindSelector.TYP_PCK))
4173             site = capture(site); // Capture field access
4174 
4175         // don&#39;t allow T.class T[].class, etc
4176         if (skind == KindSelector.TYP) {
4177             Type elt = site;
4178             while (elt.hasTag(ARRAY))
4179                 elt = ((ArrayType)elt).elemtype;
4180             if (elt.hasTag(TYPEVAR)) {
<span class="line-modified">4181                 if (tree.name == names._default) {</span>
<span class="line-modified">4182                     result = check(tree, litType(BOT).constType(null),</span>
<span class="line-modified">4183                             KindSelector.VAL, resultInfo);</span>
<span class="line-modified">4184                 } else {</span>
<span class="line-added">4185                     log.error(tree.pos(), Errors.TypeVarCantBeDeref);</span>
<span class="line-added">4186                     result = tree.type = types.createErrorType(tree.name, site.tsym, site);</span>
<span class="line-added">4187                     tree.sym = tree.type.tsym;</span>
<span class="line-added">4188                     return;</span>
<span class="line-added">4189                 }</span>
4190             }
4191         }
4192 
4193         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4194         // for the selection. This is relevant for determining whether
4195         // protected symbols are accessible.
4196         Symbol sitesym = TreeInfo.symbol(tree.selected);
<span class="line-added">4197 </span>
4198         boolean selectSuperPrev = env.info.selectSuper;
4199         env.info.selectSuper =
4200             sitesym != null &amp;&amp;
4201             sitesym.name == names._super;
4202 
4203         // Determine the symbol represented by the selection.
4204         env.info.pendingResolutionPhase = null;
4205         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4206         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4207             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4208             sym = syms.errSymbol;
4209         }
4210         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4211             site = capture(site);
4212             sym = selectSym(tree, sitesym, site, env, resultInfo);
4213         }
4214         boolean varArgs = env.info.lastResolveVarargs();
4215         tree.sym = sym;
4216 
4217         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
</pre>
<hr />
<pre>
4313                                  Env&lt;AttrContext&gt; env,
4314                                  ResultInfo resultInfo) {
4315             DiagnosticPosition pos = tree.pos();
4316             Name name = tree.name;
4317             switch (site.getTag()) {
4318             case PACKAGE:
4319                 return rs.accessBase(
4320                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4321                     pos, location, site, name, true);
4322             case ARRAY:
4323             case CLASS:
4324                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4325                     return rs.resolveQualifiedMethod(
4326                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4327                 } else if (name == names._this || name == names._super) {
4328                     return rs.resolveSelf(pos, env, site.tsym, name);
4329                 } else if (name == names._class) {
4330                     // In this case, we have already made sure in
4331                     // visitSelect that qualifier expression is a type.
4332                     return syms.getClassField(site, types);
<span class="line-added">4333                 } else if (name == names._default) {</span>
<span class="line-added">4334                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
<span class="line-added">4335                 } else if (name == names.ref &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {</span>
<span class="line-added">4336                     return site.tsym.referenceProjection();</span>
<span class="line-added">4337                 } else if (name == names.val &amp;&amp; site.isValue() &amp;&amp; resultInfo.pkind.contains(KindSelector.TYP)) {</span>
<span class="line-added">4338                     return site.tsym;</span>
4339                 } else {
4340                     // We are seeing a plain identifier as selector.
4341                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4342                         sym = rs.accessBase(sym, pos, location, site, name, true);
4343                     return sym;
4344                 }
4345             case WILDCARD:
4346                 throw new AssertionError(tree);
4347             case TYPEVAR:
<span class="line-added">4348                 if (name == names._default) {</span>
<span class="line-added">4349                     // Be sure to return the default value before examining bounds</span>
<span class="line-added">4350                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
<span class="line-added">4351                 }</span>
4352                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4353                 // It should only happen during memberEnter/attribBase
4354                 // when determining the super type which *must* be
4355                 // done before attributing the type variables.  In
4356                 // other words, we are seeing this illegal program:
4357                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4358                 Symbol sym = (site.getUpperBound() != null)
4359                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4360                     : null;
4361                 if (sym == null) {
4362                     log.error(pos, Errors.TypeVarCantBeDeref);
4363                     return syms.errSymbol;
4364                 } else {
4365                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4366                         rs.new AccessError(env, site, sym) :
4367                                 sym;
4368                     rs.accessBase(sym2, pos, location, site, name, true);
4369                     return sym;
4370                 }
4371             case ERROR:
4372                 // preserve identifier names through errors
4373                 return types.createErrorType(name, site.tsym, site).tsym;
4374             default:
4375                 // The qualifier expression is of a primitive type -- only
<span class="line-modified">4376                 // .class and .default is allowed for these.</span>
4377                 if (name == names._class) {
4378                     // In this case, we have already made sure in Select that
4379                     // qualifier expression is a type.
4380                     return syms.getClassField(site, types);
<span class="line-added">4381                 } else if (name == names._default) {</span>
<span class="line-added">4382                     return new VarSymbol(STATIC, names._default, site, site.tsym);</span>
4383                 } else {
4384                     log.error(pos, Errors.CantDeref(site));
4385                     return syms.errSymbol;
4386                 }
4387             }
4388         }
4389 
4390         /** Determine type of identifier or select expression and check that
4391          *  (1) the referenced symbol is not deprecated
4392          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4393          *  (3) if symbol is a variable, check that its type and kind are
4394          *      compatible with the prototype and protokind.
4395          *  (4) if symbol is an instance field of a raw type,
4396          *      which is being assigned to, issue an unchecked warning if its
4397          *      type changes under erasure.
4398          *  (5) if symbol is an instance method of a raw type, issue an
4399          *      unchecked warning if its argument types change under erasure.
4400          *  If checks succeed:
4401          *    If symbol is a constant, return its constant type
4402          *    else if symbol is a method, return its result type
</pre>
<hr />
<pre>
4974         if (bounds.length() == 0) {
4975             return syms.objectType;
4976         } else if (bounds.length() == 1) {
4977             return bounds.head.type;
4978         } else {
4979             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
4980             // ... the variable&#39;s bound is a class type flagged COMPOUND
4981             // (see comment for TypeVar.bound).
4982             // In this case, generate a class tree that represents the
4983             // bound class, ...
4984             JCExpression extending;
4985             List&lt;JCExpression&gt; implementing;
4986             if (!bounds.head.type.isInterface()) {
4987                 extending = bounds.head;
4988                 implementing = bounds.tail;
4989             } else {
4990                 extending = null;
4991                 implementing = bounds;
4992             }
4993             JCClassDecl cd = make.at(tree).ClassDef(
<span class="line-modified">4994                 make.Modifiers(PUBLIC | ABSTRACT | (extending != null &amp;&amp; TreeInfo.symbol(extending).isValue() ? VALUE : 0)),</span>
4995                 names.empty, List.nil(),
4996                 extending, implementing, List.nil());
4997 
4998             ClassSymbol c = (ClassSymbol)owntype.tsym;
4999             Assert.check((c.flags() &amp; COMPOUND) != 0);
5000             cd.sym = c;
5001             c.sourcefile = env.toplevel.sourcefile;
5002 
5003             // ... and attribute the bound class
5004             c.flags_field |= UNATTRIBUTED;
5005             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
5006             typeEnvs.put(c, cenv);
5007             attribClass(c);
5008             return owntype;
5009         }
5010     }
5011 
5012     public void visitWildcard(JCWildcard tree) {
5013         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
5014         Type type = (tree.kind.kind == BoundKind.UNBOUND)
5015             ? syms.objectType
5016             : attribType(tree.inner, env);
<span class="line-modified">5017         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type, false),</span>
5018                                               tree.kind.kind,
5019                                               syms.boundClass),
5020                 KindSelector.TYP, resultInfo);
5021     }
5022 
5023     public void visitAnnotation(JCAnnotation tree) {
5024         Assert.error(&quot;should be handled in annotate&quot;);
5025     }
5026 
5027     public void visitAnnotatedType(JCAnnotatedType tree) {
5028         attribAnnotationTypes(tree.annotations, env);
5029         Type underlyingType = attribType(tree.underlyingType, env);
5030         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
5031 
5032         if (!env.info.isNewClass)
5033             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
5034         result = tree.type = annotatedType;
5035     }
5036 
5037     public void visitErroneous(JCErroneous tree) {
</pre>
<hr />
<pre>
5101             chk.completionError(pos, ex);
5102         }
5103     }
5104 
5105     void attribModule(ModuleSymbol m) {
5106         // Get environment current at the point of module definition.
5107         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
5108         attribStat(env.tree, env);
5109     }
5110 
5111     /** Main method: attribute class definition associated with given class symbol.
5112      *  reporting completion failures at the given position.
5113      *  @param pos The source position at which completion errors are to be
5114      *             reported.
5115      *  @param c   The class symbol whose definition will be attributed.
5116      */
5117     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
5118         try {
5119             annotate.flush();
5120             attribClass(c);
<span class="line-added">5121             if (types.isValue(c.type)) {</span>
<span class="line-added">5122                 final Env&lt;AttrContext&gt; env = typeEnvs.get(c);</span>
<span class="line-added">5123                 if (!allowValueMemberCycles) {</span>
<span class="line-added">5124                     if (env != null &amp;&amp; env.tree != null &amp;&amp; env.tree.hasTag(CLASSDEF))</span>
<span class="line-added">5125                         chk.checkNonCyclicMembership((JCClassDecl)env.tree);</span>
<span class="line-added">5126                 }</span>
<span class="line-added">5127             }</span>
5128         } catch (CompletionFailure ex) {
5129             chk.completionError(pos, ex);
5130         }
5131     }
5132 
5133     /** Attribute class definition associated with given class symbol.
5134      *  @param c   The class symbol whose definition will be attributed.
5135      */
5136     void attribClass(ClassSymbol c) throws CompletionFailure {
5137         if (c.type.hasTag(ERROR)) return;
5138 
5139         // Check for cycles in the inheritance graph, which can arise from
5140         // ill-formed class files.
5141         chk.checkNonCyclic(null, c.type);
5142 
5143         Type st = types.supertype(c.type);
5144         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5145             // First, attribute superclass.
5146             if (st.hasTag(CLASS))
5147                 attribClass((ClassSymbol)st.tsym);
</pre>
<hr />
<pre>
5180                 deferredLintHandler.flush(env.tree);
5181                 env.info.returnResult = null;
5182                 // java.lang.Enum may not be subclassed by a non-enum
5183                 if (st.tsym == syms.enumSym &amp;&amp;
5184                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5185                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5186 
5187                 // Enums may not be extended by source-level classes
5188                 if (st.tsym != null &amp;&amp;
5189                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5190                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5191                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5192                 }
5193 
5194                 if (isSerializable(c.type)) {
5195                     env.info.isSerializable = true;
5196                 }
5197 
5198                 attribClassBody(env, c);
5199 
<span class="line-added">5200                 if ((c.flags() &amp; (VALUE | ABSTRACT)) == VALUE) { // for non-intersection, concrete values.</span>
<span class="line-added">5201                     Assert.check(env.tree.hasTag(CLASSDEF));</span>
<span class="line-added">5202                     JCClassDecl classDecl = (JCClassDecl) env.tree;</span>
<span class="line-added">5203                     if (classDecl.extending != null) {</span>
<span class="line-added">5204                         chk.checkConstraintsOfInlineSuper(env.tree.pos(), c);</span>
<span class="line-added">5205                     }</span>
<span class="line-added">5206                 }</span>
<span class="line-added">5207 </span>
5208                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5209                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5210                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5211                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5212             } finally {
5213                 env.info.returnResult = prevReturnRes;
5214                 log.useSource(prev);
5215                 chk.setLint(prevLint);
5216             }
5217 
5218         }
5219     }
5220 
5221     public void visitImport(JCImport tree) {
5222         // nothing to do
5223     }
5224 
5225     public void visitModuleDef(JCModuleDecl tree) {
5226         tree.sym.completeUsesProvides();
5227         ModuleSymbol msym = tree.sym;
</pre>
<hr />
<pre>
5293         chk.checkClassBounds(tree.pos(), c.type);
5294 
5295         tree.type = c.type;
5296 
5297         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5298              l.nonEmpty(); l = l.tail) {
5299              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5300         }
5301 
5302         // Check that a generic class doesn&#39;t extend Throwable
5303         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5304             log.error(tree.extending.pos(), Errors.GenericThrowable);
5305 
5306         // Check that all methods which implement some
5307         // method conform to the method they implement.
5308         chk.checkImplementations(tree);
5309 
5310         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5311         checkAutoCloseable(tree.pos(), env, c.type);
5312 
<span class="line-added">5313         boolean hasInstanceFields = false;</span>
5314         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5315             // Attribute declaration
5316             attribStat(l.head, env);
<span class="line-added">5317 </span>
<span class="line-added">5318             if (l.head.hasTag(VARDEF) &amp;&amp; (TreeInfo.flags(l.head) &amp; STATIC) == 0)</span>
<span class="line-added">5319                 hasInstanceFields = true;</span>
<span class="line-added">5320 </span>
5321             // Check that declarations in inner classes are not static (JLS 8.1.2)
5322             // Make an exception for static constants.
5323             if (c.owner.kind != PCK &amp;&amp;
5324                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5325                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5326                 Symbol sym = null;
5327                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5328                 if (sym == null ||
5329                     sym.kind != VAR ||
5330                     ((VarSymbol) sym).getConstValue() == null)
5331                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5332             }
5333         }
<span class="line-added">5334         if (!allowEmptyValues &amp;&amp; !hasInstanceFields &amp;&amp; (c.flags() &amp; (VALUE | SYNTHETIC)) == VALUE) {</span>
<span class="line-added">5335             log.error(tree.pos(), Errors.EmptyValueNotYet);</span>
<span class="line-added">5336         }</span>
5337 
5338         // Check for cycles among non-initial constructors.
5339         chk.checkCyclicConstructors(tree);
5340 
5341         // Check for cycles among annotation elements.
5342         chk.checkNonCyclicElements(tree);
5343 
5344         // Check for proper use of serialVersionUID
5345         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5346                 &amp;&amp; isSerializable(c.type)
5347                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5348                 &amp;&amp; !c.isAnonymous()) {
5349             checkSerialVersionUID(tree, c);
5350         }
5351         if (allowTypeAnnos) {
5352             // Correctly organize the positions of the type annotations
5353             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5354 
5355             // Check type annotations applicability rules
5356             validateTypeAnnotations(tree, false);
</pre>
</td>
</tr>
</table>
<center><a href="../code/Symtab.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
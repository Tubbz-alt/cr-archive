<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Flow.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;

  98 
  99     // The set of lint options currently in effect. It is initialized
 100     // from the context, and then is set/reset as needed by Attr as it
 101     // visits all the various parts of the trees during attribution.
 102     private Lint lint;
 103 
 104     // The method being analyzed in Attr - it is set/reset as needed by
 105     // Attr as it visits new method declarations.
 106     private MethodSymbol method;
 107 
 108     public static Check instance(Context context) {
 109         Check instance = context.get(checkKey);
 110         if (instance == null)
 111             instance = new Check(context);
 112         return instance;
 113     }
 114 
 115     protected Check(Context context) {
 116         context.put(checkKey, this);
 117 
 118         names = Names.instance(context);
 119         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 120             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 121             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 122         log = Log.instance(context);
 123         rs = Resolve.instance(context);
 124         syms = Symtab.instance(context);
 125         enter = Enter.instance(context);
 126         deferredAttr = DeferredAttr.instance(context);
 127         infer = Infer.instance(context);
 128         types = Types.instance(context);
 129         typeAnnotations = TypeAnnotations.instance(context);
 130         diags = JCDiagnostic.Factory.instance(context);
 131         Options options = Options.instance(context);
 132         lint = Lint.instance(context);
 133         fileManager = context.get(JavaFileManager.class);
 134 
 135         source = Source.instance(context);
 136         target = Target.instance(context);
 137         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
<span class="line-modified"> 138 </span>
 139         Target target = Target.instance(context);
 140         syntheticNameChar = target.syntheticNameChar();
 141 
 142         profile = Profile.instance(context);
 143         preview = Preview.instance(context);
 144 
 145         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 146         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 147         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 148         boolean enforceMandatoryWarnings = true;
 149 
 150         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 151                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 152         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 153                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 154         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 155                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 156         sunApiHandler = new MandatoryWarningHandler(log, false,
 157                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 158 
</pre>
<hr />
<pre>
 473         uncheckedHandler.clear();
 474         sunApiHandler.clear();
 475     }
 476 
 477     public void putCompiled(ClassSymbol csym) {
 478         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 479     }
 480 
 481     public ClassSymbol getCompiled(ClassSymbol csym) {
 482         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 483     }
 484 
 485     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 486         return compiled.get(Pair.of(msym, flatname));
 487     }
 488 
 489     public void removeCompiled(ClassSymbol csym) {
 490         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 491     }
 492 
<span class="line-modified"> 493 /* *************************************************************************</span>
 494  * Type Checking
 495  **************************************************************************/
 496 
 497     /**
 498      * A check context is an object that can be used to perform compatibility
 499      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 500      * vary significantly.
 501      */
 502     public interface CheckContext {
 503         /**
 504          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 505          */
 506         boolean compatible(Type found, Type req, Warner warn);
 507         /**
 508          * Report a check error
 509          */
 510         void report(DiagnosticPosition pos, JCDiagnostic details);
 511         /**
 512          * Obtain a warner for this check context
 513          */
</pre>
<hr />
<pre>
 579         public String toString() {
 580             return &quot;CheckContext: basicHandler&quot;;
 581         }
 582     };
 583 
 584     /** Check that a given type is assignable to a given proto-type.
 585      *  If it is, return the type, otherwise return errType.
 586      *  @param pos        Position to be used for error reporting.
 587      *  @param found      The type that was found.
 588      *  @param req        The type that was required.
 589      */
 590     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 591         return checkType(pos, found, req, basicHandler);
 592     }
 593 
 594     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 595         final InferenceContext inferenceContext = checkContext.inferenceContext();
 596         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 597             inferenceContext.addFreeTypeListener(List.of(req, found),
 598                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));





 599         }
 600         if (req.hasTag(ERROR))
 601             return req;
 602         if (req.hasTag(NONE))
 603             return found;
 604         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {



 605             return found;
 606         } else {
 607             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 608                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 609                 return types.createErrorType(found);
 610             }
 611             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 612             return types.createErrorType(found);
 613         }
 614     }
 615 
 616     /** Check that a given type can be cast to a given target type.
 617      *  Return the result of the cast.
 618      *  @param pos        Position to be used for error reporting.
 619      *  @param found      The type that is being cast.
 620      *  @param req        The target type of the cast.
 621      */
 622     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 623         return checkCastable(pos, found, req, basicHandler);
 624     }
 625     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 626         if (types.isCastable(found, req, castWarner(pos, found, req))) {







 627             return req;
 628         } else {
 629             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 630             return types.createErrorType(found);
 631         }
 632     }
 633 
 634     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 635      * The problem should only be reported for non-292 cast
 636      */
 637     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 638         if (!tree.type.isErroneous()
 639                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 640                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 641                 &amp;&amp; !is292targetTypeCast(tree)) {
 642             deferredLintHandler.report(() -&gt; {
 643                 if (lint.isEnabled(LintCategory.CAST))
 644                     log.warning(LintCategory.CAST,
 645                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 646             });
</pre>
<hr />
<pre>
 709     /** Check that type is a class or interface type.
 710      *  @param pos           Position to be used for error reporting.
 711      *  @param t             The type to be checked.
 712      */
 713     Type checkClassType(DiagnosticPosition pos, Type t) {
 714         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 715             return typeTagError(pos,
 716                                 diags.fragment(Fragments.TypeReqClass),
 717                                 asTypeParam(t));
 718         } else {
 719             return t;
 720         }
 721     }
 722     //where
 723         private Object asTypeParam(Type t) {
 724             return (t.hasTag(TYPEVAR))
 725                                     ? diags.fragment(Fragments.TypeParameter(t))
 726                                     : t;
 727         }
 728 











































 729     /** Check that type is a valid qualifier for a constructor reference expression
 730      */
 731     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 732         t = checkClassOrArrayType(pos, t);
 733         if (t.hasTag(CLASS)) {
 734             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 735                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 736                 t = types.createErrorType(t);
 737             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 738                 log.error(pos, Errors.EnumCantBeInstantiated);
 739                 t = types.createErrorType(t);
 740             } else {
 741                 t = checkClassType(pos, t, true);
 742             }
 743         } else if (t.hasTag(ARRAY)) {
 744             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 745                 log.error(pos, Errors.GenericArrayCreation);
 746                 t = types.createErrorType(t);
 747             }
 748         }
</pre>
<hr />
<pre>
 756      */
 757     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 758         t = checkClassType(pos, t);
 759         if (noBounds &amp;&amp; t.isParameterized()) {
 760             List&lt;Type&gt; args = t.getTypeArguments();
 761             while (args.nonEmpty()) {
 762                 if (args.head.hasTag(WILDCARD))
 763                     return typeTagError(pos,
 764                                         diags.fragment(Fragments.TypeReqExact),
 765                                         args.head);
 766                 args = args.tail;
 767             }
 768         }
 769         return t;
 770     }
 771 
 772     /** Check that type is a reference type, i.e. a class, interface or array type
 773      *  or a type variable.
 774      *  @param pos           Position to be used for error reporting.
 775      *  @param t             The type to be checked.

 776      */
<span class="line-modified"> 777     Type checkRefType(DiagnosticPosition pos, Type t) {</span>
<span class="line-modified"> 778         if (t.isReference())</span>
 779             return t;
 780         else
 781             return typeTagError(pos,
 782                                 diags.fragment(Fragments.TypeReqRef),
 783                                 t);
 784     }
 785 









 786     /** Check that each type is a reference type, i.e. a class, interface or array type
 787      *  or a type variable.
 788      *  @param trees         Original trees, used for error reporting.
 789      *  @param types         The types to be checked.
 790      */
 791     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 792         List&lt;JCExpression&gt; tl = trees;
 793         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
<span class="line-modified"> 794             l.head = checkRefType(tl.head.pos(), l.head);</span>
 795             tl = tl.tail;
 796         }
 797         return types;
 798     }
 799 
 800     /** Check that type is a null or reference type.
 801      *  @param pos           Position to be used for error reporting.
 802      *  @param t             The type to be checked.
 803      */
 804     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 805         if (t.isReference() || t.hasTag(BOT))
 806             return t;
 807         else
 808             return typeTagError(pos,
 809                                 diags.fragment(Fragments.TypeReqRef),
 810                                 t);
 811     }
 812 
 813     /** Check that flag set does not contain elements of two conflicting sets. s
 814      *  Return true if it doesn&#39;t.
 815      *  @param pos           Position to be used for error reporting.
 816      *  @param flags         The set of flags to be checked.
 817      *  @param set1          Conflicting flags set #1.
 818      *  @param set2          Conflicting flags set #2.
 819      */
 820     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 821         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 822             log.error(pos,
 823                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 824                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 825             return false;
 826         } else
 827             return true;
 828     }
 829 
















































 830     /** Check that usage of diamond operator is correct (i.e. diamond should not
 831      * be used with non-generic classes or in anonymous class creation expressions)
 832      */
 833     Type checkDiamond(JCNewClass tree, Type t) {
 834         if (!TreeInfo.isDiamond(tree) ||
 835                 t.isErroneous()) {
 836             return checkClassType(tree.clazz.pos(), t, true);
 837         } else {
 838             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 839                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 840                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 841             }
 842             if (t.tsym.type.getTypeArguments().isEmpty()) {
 843                 log.error(tree.clazz.pos(),
 844                           Errors.CantApplyDiamond1(t,
 845                                                    Fragments.DiamondNonGeneric(t)));
 846                 return types.createErrorType(t);
 847             } else if (tree.typeargs != null &amp;&amp;
 848                     tree.typeargs.nonEmpty()) {
 849                 log.error(tree.clazz.pos(),
</pre>
<hr />
<pre>
 958     }
 959     //where
 960         private boolean isTrustMeAllowedOnMethod(Symbol s) {
 961             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
 962                 (s.isConstructor() ||
 963                     (s.flags() &amp; (STATIC | FINAL |
 964                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
 965         }
 966 
 967     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
 968         //check that resulting type is not the null type
 969         if (t.hasTag(BOT)) {
 970             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
 971             return types.createErrorType(t);
 972         } else if (t.hasTag(VOID)) {
 973             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
 974             return types.createErrorType(t);
 975         }
 976 
 977         //upward project the initializer type
<span class="line-modified"> 978         return types.upward(t, types.captures(t));</span>





































 979     }
 980 
 981     Type checkMethod(final Type mtype,
 982             final Symbol sym,
 983             final Env&lt;AttrContext&gt; env,
 984             final List&lt;JCExpression&gt; argtrees,
 985             final List&lt;Type&gt; argtypes,
 986             final boolean useVarargs,
 987             InferenceContext inferenceContext) {
 988         // System.out.println(&quot;call   : &quot; + env.tree);
 989         // System.out.println(&quot;method : &quot; + owntype);
 990         // System.out.println(&quot;actuals: &quot; + argtypes);
 991         if (inferenceContext.free(mtype)) {
 992             inferenceContext.addFreeTypeListener(List.of(mtype),
 993                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
 994             return mtype;
 995         }
 996         Type owntype = mtype;
 997         List&lt;Type&gt; formals = owntype.getParameterTypes();
 998         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
</pre>
<hr />
<pre>
1156      *  return modifiers together with any implicit modifiers for that symbol.
1157      *  Warning: we can&#39;t use flags() here since this method
1158      *  is called during class enter, when flags() would cause a premature
1159      *  completion.
1160      *  @param pos           Position to be used for error reporting.
1161      *  @param flags         The set of modifiers given in a definition.
1162      *  @param sym           The defined symbol.
1163      */
1164     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1165         long mask;
1166         long implicit = 0;
1167 
1168         switch (sym.kind) {
1169         case VAR:
1170             if (TreeInfo.isReceiverParam(tree))
1171                 mask = ReceiverParamFlags;
1172             else if (sym.owner.kind != TYP)
1173                 mask = LocalVarFlags;
1174             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1175                 mask = implicit = InterfaceVarFlags;
<span class="line-modified">1176             else</span>
1177                 mask = VarFlags;




1178             break;
1179         case MTH:
1180             if (sym.name == names.init) {
1181                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1182                     // enum constructors cannot be declared public or
1183                     // protected and must be implicitly or explicitly
1184                     // private
1185                     implicit = PRIVATE;
1186                     mask = PRIVATE;
1187                 } else
1188                     mask = ConstructorFlags;
1189             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1190                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1191                     mask = AnnotationTypeElementMask;
1192                     implicit = PUBLIC | ABSTRACT;
1193                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1194                     mask = InterfaceMethodMask;
1195                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1196                     if ((flags &amp; DEFAULT) != 0) {
1197                         implicit |= ABSTRACT;
1198                     }
1199                 } else {
1200                     mask = implicit = InterfaceMethodFlags;
1201                 }
1202             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1203                 mask = RecordMethodFlags;
1204             } else {
<span class="line-modified">1205                 mask = MethodFlags;</span>


1206             }
1207             // Imply STRICTFP if owner has STRICTFP set.
1208             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1209                 ((flags) &amp; Flags.DEFAULT) != 0)
1210                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1211             break;
1212         case TYP:
1213             if (sym.isLocal()) {
1214                 mask = (flags &amp; RECORD) != 0 ? LocalRecordFlags : LocalClassFlags;
1215                 if ((flags &amp; RECORD) != 0) {
1216                     implicit = STATIC;
1217                     if (sym.owner.kind == TYP) {
1218                         log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1219                     }
1220                 }
1221                 if ((sym.owner.flags_field &amp; STATIC) == 0 &amp;&amp;
1222                     (flags &amp; ENUM) != 0) {
1223                     log.error(pos, Errors.EnumsMustBeStatic);
1224                 }
1225             } else if (sym.owner.kind == TYP) {
1226                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;
1227                 if (sym.owner.owner.kind == PCK ||
1228                     (sym.owner.flags_field &amp; STATIC) != 0)
1229                     mask |= STATIC;
1230                 else if ((flags &amp; ENUM) != 0) {
1231                     log.error(pos, Errors.EnumsMustBeStatic);
1232                 } else if ((flags &amp; RECORD) != 0) {
1233                     log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1234                 }
1235                 // Nested interfaces and enums are always STATIC (Spec ???)
1236                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1237             } else {
1238                 mask = ClassFlags;
1239             }
1240             // Interfaces are always ABSTRACT
1241             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1242 
1243             if ((flags &amp; ENUM) != 0) {
<span class="line-modified">1244                 // enums can&#39;t be declared abstract or final</span>
<span class="line-modified">1245                 mask &amp;= ~(ABSTRACT | FINAL);</span>
1246                 implicit |= implicitEnumFinalFlag(tree);
1247             }
1248             if ((flags &amp; RECORD) != 0) {
1249                 // records can&#39;t be declared abstract
1250                 mask &amp;= ~ABSTRACT;
1251                 implicit |= FINAL;
1252             }
1253             // Imply STRICTFP if owner has STRICTFP set.
1254             implicit |= sym.owner.flags_field &amp; STRICTFP;
1255             break;
1256         default:
1257             throw new AssertionError();
1258         }
1259         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1260         if (illegal != 0) {
1261             if ((illegal &amp; INTERFACE) != 0) {
1262                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1263                 mask |= INTERFACE;
1264             }
1265             else {
1266                 log.error(pos,
1267                           Errors.ModNotAllowedHere(asFlagSet(illegal)));
1268             }
1269         }
1270         else if ((sym.kind == TYP ||
1271                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1272                   // in the presence of inner classes. Should it be deleted here?
1273                   checkDisjoint(pos, flags,
1274                                 ABSTRACT,
1275                                 PRIVATE | STATIC | DEFAULT))
1276                  &amp;&amp;
1277                  checkDisjoint(pos, flags,
1278                                 STATIC | PRIVATE,
1279                                 DEFAULT)
1280                  &amp;&amp;
1281                  checkDisjoint(pos, flags,
1282                                ABSTRACT | INTERFACE,
<span class="line-modified">1283                                FINAL | NATIVE | SYNCHRONIZED)</span>
1284                  &amp;&amp;
1285                  checkDisjoint(pos, flags,
1286                                PUBLIC,
1287                                PRIVATE | PROTECTED)
1288                  &amp;&amp;
1289                  checkDisjoint(pos, flags,
1290                                PRIVATE,
1291                                PUBLIC | PROTECTED)
1292                  &amp;&amp;
<span class="line-modified">1293                  checkDisjoint(pos, flags,</span>
1294                                FINAL,
1295                                VOLATILE)
1296                  &amp;&amp;
1297                  (sym.kind == TYP ||
1298                   checkDisjoint(pos, flags,
1299                                 ABSTRACT | NATIVE,
1300                                 STRICTFP))) {
1301             // skip
1302         }
1303         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1304     }
1305 
1306 
1307     /** Determine if this enum should be implicitly final.
1308      *
1309      *  If the enum has no specialized enum constants, it is final.
1310      *
1311      *  If the enum does have specialized enum constants, it is
1312      *  &lt;i&gt;not&lt;/i&gt; final.
1313      */
</pre>
<hr />
<pre>
1441         @Override
1442         public void visitWildcard(JCWildcard tree) {
1443             if (tree.inner != null)
1444                 validateTree(tree.inner, true, isOuter);
1445         }
1446 
1447         @Override
1448         public void visitSelect(JCFieldAccess tree) {
1449             if (tree.type.hasTag(CLASS)) {
1450                 visitSelectInternal(tree);
1451 
1452                 // Check that this type is either fully parameterized, or
1453                 // not parameterized at all.
1454                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1455                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1456             }
1457         }
1458 
1459         public void visitSelectInternal(JCFieldAccess tree) {
1460             if (tree.type.tsym.isStatic() &amp;&amp;
<span class="line-modified">1461                 tree.selected.type.isParameterized()) {</span>

1462                 // The enclosing type is not a class, so we are
1463                 // looking at a static member type.  However, the
1464                 // qualifying expression is parameterized.


1465                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1466             } else {
1467                 // otherwise validate the rest of the expression
1468                 tree.selected.accept(this);
1469             }
1470         }
1471 
1472         @Override
1473         public void visitAnnotatedType(JCAnnotatedType tree) {
1474             tree.underlyingType.accept(this);
1475         }
1476 
1477         @Override
1478         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1479             if (that.type.hasTag(TypeTag.VOID)) {
1480                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1481             }
1482             super.visitTypeIdent(that);
1483         }
1484 
</pre>
<hr />
<pre>
1771             return;
1772         }
1773 
1774         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1775             // handled in validateAnnotationMethod
1776             return;
1777         }
1778 
1779         // Error if overriding method has weaker access (JLS 8.4.6.3).
1780         if (protection(m.flags()) &gt; protection(other.flags())) {
1781             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1782                       (other.flags() &amp; AccessFlags) == 0 ?
1783                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1784                                                           &quot;package&quot;) :
1785                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1786                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1787             m.flags_field |= BAD_OVERRIDE;
1788             return;
1789         }
1790 









1791         Type mt = types.memberType(origin.type, m);
1792         Type ot = types.memberType(origin.type, other);
1793         // Error if overriding result type is different
1794         // (or, in the case of generics mode, not a subtype) of
1795         // overridden result type. We have to rename any type parameters
1796         // before comparing types.
1797         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1798         List&lt;Type&gt; otvars = ot.getTypeArguments();
1799         Type mtres = mt.getReturnType();
1800         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1801 
1802         overrideWarner.clear();
1803         boolean resultTypesOK =
1804             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1805         if (!resultTypesOK) {
1806             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1807                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1808                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1809                                         other.location()), mtres, otres));
1810                 m.flags_field |= BAD_OVERRIDE;
</pre>
<hr />
<pre>
2073         if ((origin.flags() &amp; ENUM) != 0 &amp;&amp; names.finalize.equals(m.name))
2074             if (m.overrides(syms.enumFinalFinalize, origin, types, false)) {
2075                 log.error(tree.pos(), Errors.EnumNoFinalize);
2076                 return;
2077             }
2078         for (Type t = origin.type; t.hasTag(CLASS);
2079              t = types.supertype(t)) {
2080             if (t != origin.type) {
2081                 checkOverride(tree, t, origin, m);
2082             }
2083             for (Type t2 : types.interfaces(t)) {
2084                 checkOverride(tree, t2, origin, m);
2085             }
2086         }
2087 
2088         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2089         // Check if this method must override a super method due to being annotated with @Override
2090         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2091         // be treated &quot;as if as they were annotated&quot; with @Override.
2092         boolean mustOverride = explicitOverride ||
<span class="line-modified">2093                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate());</span>

2094         if (mustOverride &amp;&amp; !isOverrider(m)) {
2095             DiagnosticPosition pos = tree.pos();
2096             for (JCAnnotation a : tree.getModifiers().annotations) {
2097                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2098                     pos = a.pos();
2099                     break;
2100                 }
2101             }
2102             log.error(pos,
2103                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2104                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2105         }
2106     }
2107 
2108     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2109         TypeSymbol c = site.tsym;
2110         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2111             if (m.overrides(sym, origin, types, false)) {
2112                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2113                     checkOverride(tree, m, (MethodSymbol)sym, origin);
</pre>
<hr />
<pre>
2199                 cf.accepts(s2) &amp;&amp;
2200                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2201     }
2202 
2203 
2204     /** Check that all abstract members of given class have definitions.
2205      *  @param pos          Position to be used for error reporting.
2206      *  @param c            The class.
2207      */
2208     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2209         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2210         if (undef != null) {
2211             MethodSymbol undef1 =
2212                 new MethodSymbol(undef.flags(), undef.name,
2213                                  types.memberType(c.type, undef), undef.owner);
2214             log.error(pos,
2215                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2216         }
2217     }
2218 







































2219     void checkNonCyclicDecl(JCClassDecl tree) {
2220         CycleChecker cc = new CycleChecker();
2221         cc.scan(tree);
2222         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2223             tree.sym.flags_field |= ACYCLIC;
2224         }
2225     }
2226 
2227     class CycleChecker extends TreeScanner {
2228 
2229         List&lt;Symbol&gt; seenClasses = List.nil();
2230         boolean errorFound = false;
2231         boolean partialCheck = false;
2232 
2233         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2234             if (sym != null &amp;&amp; sym.kind == TYP) {
2235                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2236                 if (classEnv != null) {
2237                     DiagnosticSource prevSource = log.currentSource();
2238                     try {
</pre>
<hr />
<pre>
2447     /** Check that all abstract methods implemented by a class are
2448      *  mutually compatible.
2449      *  @param pos          Position to be used for error reporting.
2450      *  @param c            The class whose interfaces are checked.
2451      */
2452     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2453         List&lt;Type&gt; supertypes = types.interfaces(c);
2454         Type supertype = types.supertype(c);
2455         if (supertype.hasTag(CLASS) &amp;&amp;
2456             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2457             supertypes = supertypes.prepend(supertype);
2458         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2459             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2460                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2461                 return;
2462             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2463                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2464                     return;
2465         }
2466         checkCompatibleConcretes(pos, c);




2467     }
2468 
2469     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2470      *  are mutually compatible (JLS 8.4.8/9.4.1).
2471      *
2472      *  @param pos  Position to be used for error reporting.
2473      *  @param site The class whose methods are checked.
2474      *  @param sym  The method symbol to be checked.
2475      */
2476     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2477          ClashFilter cf = new ClashFilter(site);
2478         //for each method m1 that is overridden (directly or indirectly)
2479         //by method &#39;sym&#39; in &#39;site&#39;...
2480 
2481         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2482         boolean overridesAny = false;
2483         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2484         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2485         for (Symbol m1 : symbolsByName) {
2486             if (!sym.overrides(m1, site.tsym, types, false)) {
</pre>
<hr />
<pre>
3006                                 }
3007                             }
3008                             modifiers.annotations = newAnnotations.toList();
3009                         }
3010                         // now lets remove it from the symbol
3011                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3012                     } else {
3013                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3014                     }
3015                 }
3016             }
3017         }
3018 
3019         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3020             if (s.kind != TYP) {
3021                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3022             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3023                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3024             }
3025         }







3026     }
3027 
3028     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3029         Assert.checkNonNull(a.type);
3030         validateAnnotationTree(a);
3031 
3032         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3033                 !a.annotationType.type.isErroneous() &amp;&amp;
3034                 !isTypeAnnotation(a, isTypeParameter)) {
3035             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3036         }
3037     }
3038 
3039     /**
3040      * Validate the proposed container &#39;repeatable&#39; on the
3041      * annotation type symbol &#39;s&#39;. Report errors at position
3042      * &#39;pos&#39;.
3043      *
3044      * @param s The (annotation)type declaration annotated with a @Repeatable
3045      * @param repeatable the @Repeatable on &#39;s&#39;
</pre>
</td>
<td>
<hr />
<pre>
  78  */
  79 public class Check {
  80     protected static final Context.Key&lt;Check&gt; checkKey = new Context.Key&lt;&gt;();
  81 
  82     private final Names names;
  83     private final Log log;
  84     private final Resolve rs;
  85     private final Symtab syms;
  86     private final Enter enter;
  87     private final DeferredAttr deferredAttr;
  88     private final Infer infer;
  89     private final Types types;
  90     private final TypeAnnotations typeAnnotations;
  91     private final JCDiagnostic.Factory diags;
  92     private final JavaFileManager fileManager;
  93     private final Source source;
  94     private final Target target;
  95     private final Profile profile;
  96     private final Preview preview;
  97     private final boolean warnOnAnyAccessToMembers;
<span class="line-added">  98     private final boolean allowValueBasedClasses;</span>
  99 
 100     // The set of lint options currently in effect. It is initialized
 101     // from the context, and then is set/reset as needed by Attr as it
 102     // visits all the various parts of the trees during attribution.
 103     private Lint lint;
 104 
 105     // The method being analyzed in Attr - it is set/reset as needed by
 106     // Attr as it visits new method declarations.
 107     private MethodSymbol method;
 108 
 109     public static Check instance(Context context) {
 110         Check instance = context.get(checkKey);
 111         if (instance == null)
 112             instance = new Check(context);
 113         return instance;
 114     }
 115 
 116     protected Check(Context context) {
 117         context.put(checkKey, this);
 118 
 119         names = Names.instance(context);
 120         dfltTargetMeta = new Name[] { names.PACKAGE, names.TYPE,
 121             names.FIELD, names.RECORD_COMPONENT, names.METHOD, names.CONSTRUCTOR,
 122             names.ANNOTATION_TYPE, names.LOCAL_VARIABLE, names.PARAMETER};
 123         log = Log.instance(context);
 124         rs = Resolve.instance(context);
 125         syms = Symtab.instance(context);
 126         enter = Enter.instance(context);
 127         deferredAttr = DeferredAttr.instance(context);
 128         infer = Infer.instance(context);
 129         types = Types.instance(context);
 130         typeAnnotations = TypeAnnotations.instance(context);
 131         diags = JCDiagnostic.Factory.instance(context);
 132         Options options = Options.instance(context);
 133         lint = Lint.instance(context);
 134         fileManager = context.get(JavaFileManager.class);
 135 
 136         source = Source.instance(context);
 137         target = Target.instance(context);
 138         warnOnAnyAccessToMembers = options.isSet(&quot;warnOnAccessToMembers&quot;);
<span class="line-modified"> 139         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);</span>
 140         Target target = Target.instance(context);
 141         syntheticNameChar = target.syntheticNameChar();
 142 
 143         profile = Profile.instance(context);
 144         preview = Preview.instance(context);
 145 
 146         boolean verboseDeprecated = lint.isEnabled(LintCategory.DEPRECATION);
 147         boolean verboseRemoval = lint.isEnabled(LintCategory.REMOVAL);
 148         boolean verboseUnchecked = lint.isEnabled(LintCategory.UNCHECKED);
 149         boolean enforceMandatoryWarnings = true;
 150 
 151         deprecationHandler = new MandatoryWarningHandler(log, verboseDeprecated,
 152                 enforceMandatoryWarnings, &quot;deprecated&quot;, LintCategory.DEPRECATION);
 153         removalHandler = new MandatoryWarningHandler(log, verboseRemoval,
 154                 enforceMandatoryWarnings, &quot;removal&quot;, LintCategory.REMOVAL);
 155         uncheckedHandler = new MandatoryWarningHandler(log, verboseUnchecked,
 156                 enforceMandatoryWarnings, &quot;unchecked&quot;, LintCategory.UNCHECKED);
 157         sunApiHandler = new MandatoryWarningHandler(log, false,
 158                 enforceMandatoryWarnings, &quot;sunapi&quot;, null);
 159 
</pre>
<hr />
<pre>
 474         uncheckedHandler.clear();
 475         sunApiHandler.clear();
 476     }
 477 
 478     public void putCompiled(ClassSymbol csym) {
 479         compiled.put(Pair.of(csym.packge().modle, csym.flatname), csym);
 480     }
 481 
 482     public ClassSymbol getCompiled(ClassSymbol csym) {
 483         return compiled.get(Pair.of(csym.packge().modle, csym.flatname));
 484     }
 485 
 486     public ClassSymbol getCompiled(ModuleSymbol msym, Name flatname) {
 487         return compiled.get(Pair.of(msym, flatname));
 488     }
 489 
 490     public void removeCompiled(ClassSymbol csym) {
 491         compiled.remove(Pair.of(csym.packge().modle, csym.flatname));
 492     }
 493 
<span class="line-modified"> 494     /* *************************************************************************</span>
 495  * Type Checking
 496  **************************************************************************/
 497 
 498     /**
 499      * A check context is an object that can be used to perform compatibility
 500      * checks - depending on the check context, meaning of &#39;compatibility&#39; might
 501      * vary significantly.
 502      */
 503     public interface CheckContext {
 504         /**
 505          * Is type &#39;found&#39; compatible with type &#39;req&#39; in given context
 506          */
 507         boolean compatible(Type found, Type req, Warner warn);
 508         /**
 509          * Report a check error
 510          */
 511         void report(DiagnosticPosition pos, JCDiagnostic details);
 512         /**
 513          * Obtain a warner for this check context
 514          */
</pre>
<hr />
<pre>
 580         public String toString() {
 581             return &quot;CheckContext: basicHandler&quot;;
 582         }
 583     };
 584 
 585     /** Check that a given type is assignable to a given proto-type.
 586      *  If it is, return the type, otherwise return errType.
 587      *  @param pos        Position to be used for error reporting.
 588      *  @param found      The type that was found.
 589      *  @param req        The type that was required.
 590      */
 591     public Type checkType(DiagnosticPosition pos, Type found, Type req) {
 592         return checkType(pos, found, req, basicHandler);
 593     }
 594 
 595     Type checkType(final DiagnosticPosition pos, final Type found, final Type req, final CheckContext checkContext) {
 596         final InferenceContext inferenceContext = checkContext.inferenceContext();
 597         if (inferenceContext.free(req) || inferenceContext.free(found)) {
 598             inferenceContext.addFreeTypeListener(List.of(req, found),
 599                     solvedContext -&gt; checkType(pos, solvedContext.asInstType(found), solvedContext.asInstType(req), checkContext));
<span class="line-added"> 600         } else {</span>
<span class="line-added"> 601             if (found.hasTag(CLASS)) {</span>
<span class="line-added"> 602                 if (inferenceContext != infer.emptyContext)</span>
<span class="line-added"> 603                     checkParameterizationWithValues(pos, found);</span>
<span class="line-added"> 604             }</span>
 605         }
 606         if (req.hasTag(ERROR))
 607             return req;
 608         if (req.hasTag(NONE))
 609             return found;
 610         if (checkContext.compatible(found, req, checkContext.checkWarner(pos, found, req))) {
<span class="line-added"> 611             if (found.hasTag(BOT) &amp;&amp; types.isValueBased(req)) {</span>
<span class="line-added"> 612                 log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));</span>
<span class="line-added"> 613             }</span>
 614             return found;
 615         } else {
 616             if (found.isNumeric() &amp;&amp; req.isNumeric()) {
 617                 checkContext.report(pos, diags.fragment(Fragments.PossibleLossOfPrecision(found, req)));
 618                 return types.createErrorType(found);
 619             }
 620             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 621             return types.createErrorType(found);
 622         }
 623     }
 624 
 625     /** Check that a given type can be cast to a given target type.
 626      *  Return the result of the cast.
 627      *  @param pos        Position to be used for error reporting.
 628      *  @param found      The type that is being cast.
 629      *  @param req        The target type of the cast.
 630      */
 631     Type checkCastable(DiagnosticPosition pos, Type found, Type req) {
 632         return checkCastable(pos, found, req, basicHandler);
 633     }
 634     Type checkCastable(DiagnosticPosition pos, Type found, Type req, CheckContext checkContext) {
 635         if (types.isCastable(found, req, castWarner(pos, found, req))) {
<span class="line-added"> 636             if (types.isValueBased(req)) {</span>
<span class="line-added"> 637                 if (found.hasTag(BOT)) {</span>
<span class="line-added"> 638                     log.warning(pos, Warnings.SuspiciousMixOfNullWithValueBasedClass(req));</span>
<span class="line-added"> 639                 } else if (!types.isValueBased(found)) {</span>
<span class="line-added"> 640                     log.warning(pos, Warnings.PotentialNullPollution(found));</span>
<span class="line-added"> 641                 }</span>
<span class="line-added"> 642             }</span>
 643             return req;
 644         } else {
 645             checkContext.report(pos, diags.fragment(Fragments.InconvertibleTypes(found, req)));
 646             return types.createErrorType(found);
 647         }
 648     }
 649 
 650     /** Check for redundant casts (i.e. where source type is a subtype of target type)
 651      * The problem should only be reported for non-292 cast
 652      */
 653     public void checkRedundantCast(Env&lt;AttrContext&gt; env, final JCTypeCast tree) {
 654         if (!tree.type.isErroneous()
 655                 &amp;&amp; types.isSameType(tree.expr.type, tree.clazz.type)
 656                 &amp;&amp; !(ignoreAnnotatedCasts &amp;&amp; TreeInfo.containsTypeAnnotation(tree.clazz))
 657                 &amp;&amp; !is292targetTypeCast(tree)) {
 658             deferredLintHandler.report(() -&gt; {
 659                 if (lint.isEnabled(LintCategory.CAST))
 660                     log.warning(LintCategory.CAST,
 661                             tree.pos(), Warnings.RedundantCast(tree.clazz.type));
 662             });
</pre>
<hr />
<pre>
 725     /** Check that type is a class or interface type.
 726      *  @param pos           Position to be used for error reporting.
 727      *  @param t             The type to be checked.
 728      */
 729     Type checkClassType(DiagnosticPosition pos, Type t) {
 730         if (!t.hasTag(CLASS) &amp;&amp; !t.hasTag(ERROR)) {
 731             return typeTagError(pos,
 732                                 diags.fragment(Fragments.TypeReqClass),
 733                                 asTypeParam(t));
 734         } else {
 735             return t;
 736         }
 737     }
 738     //where
 739         private Object asTypeParam(Type t) {
 740             return (t.hasTag(TYPEVAR))
 741                                     ? diags.fragment(Fragments.TypeParameter(t))
 742                                     : t;
 743         }
 744 
<span class="line-added"> 745     void checkConstraintsOfInlineSuper(DiagnosticPosition pos, ClassSymbol c) {</span>
<span class="line-added"> 746         for(Type st = types.supertype(c.type); st != Type.noType; st = types.supertype(st)) {</span>
<span class="line-added"> 747             if (st == null || st.tsym == null || st.tsym.kind == ERR)</span>
<span class="line-added"> 748                 return;</span>
<span class="line-added"> 749             if  (st.tsym == syms.objectType.tsym)</span>
<span class="line-added"> 750                 return;</span>
<span class="line-added"> 751             if (!st.tsym.isAbstract()) {</span>
<span class="line-added"> 752                 log.error(pos, Errors.ConcreteSupertypeForInlineClass(c, st));</span>
<span class="line-added"> 753             }</span>
<span class="line-added"> 754             if ((st.tsym.flags() &amp; HASINITBLOCK) != 0) {</span>
<span class="line-added"> 755                 log.error(pos, Errors.SuperClassDeclaresInitBlock(c, st));</span>
<span class="line-added"> 756             }</span>
<span class="line-added"> 757             // No instance fields and no arged constructors both mean inner classes cannot be inline supers.</span>
<span class="line-added"> 758             Type encl = st.getEnclosingType();</span>
<span class="line-added"> 759             if (encl != null &amp;&amp; encl.hasTag(CLASS)) {</span>
<span class="line-added"> 760                 log.error(pos, Errors.SuperClassCannotBeInner(c, st));</span>
<span class="line-added"> 761             }</span>
<span class="line-added"> 762             for (Symbol s : st.tsym.members().getSymbols(NON_RECURSIVE)) {</span>
<span class="line-added"> 763                 switch (s.kind) {</span>
<span class="line-added"> 764                 case VAR:</span>
<span class="line-added"> 765                     if ((s.flags() &amp; STATIC) == 0) {</span>
<span class="line-added"> 766                         log.error(pos, Errors.SuperFieldNotAllowed(s, c, st));</span>
<span class="line-added"> 767                     }</span>
<span class="line-added"> 768                     break;</span>
<span class="line-added"> 769                 case MTH:</span>
<span class="line-added"> 770                     if ((s.flags() &amp; SYNCHRONIZED) != 0) {</span>
<span class="line-added"> 771                         log.error(pos, Errors.SuperMethodCannotBeSynchronized(s, c, st));</span>
<span class="line-added"> 772                     } else if (s.isConstructor()) {</span>
<span class="line-added"> 773                         MethodSymbol m = (MethodSymbol)s;</span>
<span class="line-added"> 774                         if (m.getParameters().size() &gt; 0) {</span>
<span class="line-added"> 775                             log.error(pos, Errors.SuperConstructorCannotTakeArguments(m, c, st));</span>
<span class="line-added"> 776                         } else {</span>
<span class="line-added"> 777                             if ((m.flags() &amp; (GENERATEDCONSTR | EMPTYNOARGCONSTR)) == 0) {</span>
<span class="line-added"> 778                                 log.error(pos, Errors.SuperNoArgConstructorMustBeEmpty(m, c, st));</span>
<span class="line-added"> 779                             }</span>
<span class="line-added"> 780                         }</span>
<span class="line-added"> 781                     }</span>
<span class="line-added"> 782                     break;</span>
<span class="line-added"> 783                 }</span>
<span class="line-added"> 784             }</span>
<span class="line-added"> 785         }</span>
<span class="line-added"> 786     }</span>
<span class="line-added"> 787 </span>
 788     /** Check that type is a valid qualifier for a constructor reference expression
 789      */
 790     Type checkConstructorRefType(DiagnosticPosition pos, Type t) {
 791         t = checkClassOrArrayType(pos, t);
 792         if (t.hasTag(CLASS)) {
 793             if ((t.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
 794                 log.error(pos, Errors.AbstractCantBeInstantiated(t.tsym));
 795                 t = types.createErrorType(t);
 796             } else if ((t.tsym.flags() &amp; ENUM) != 0) {
 797                 log.error(pos, Errors.EnumCantBeInstantiated);
 798                 t = types.createErrorType(t);
 799             } else {
 800                 t = checkClassType(pos, t, true);
 801             }
 802         } else if (t.hasTag(ARRAY)) {
 803             if (!types.isReifiable(((ArrayType)t).elemtype)) {
 804                 log.error(pos, Errors.GenericArrayCreation);
 805                 t = types.createErrorType(t);
 806             }
 807         }
</pre>
<hr />
<pre>
 815      */
 816     Type checkClassType(DiagnosticPosition pos, Type t, boolean noBounds) {
 817         t = checkClassType(pos, t);
 818         if (noBounds &amp;&amp; t.isParameterized()) {
 819             List&lt;Type&gt; args = t.getTypeArguments();
 820             while (args.nonEmpty()) {
 821                 if (args.head.hasTag(WILDCARD))
 822                     return typeTagError(pos,
 823                                         diags.fragment(Fragments.TypeReqExact),
 824                                         args.head);
 825                 args = args.tail;
 826             }
 827         }
 828         return t;
 829     }
 830 
 831     /** Check that type is a reference type, i.e. a class, interface or array type
 832      *  or a type variable.
 833      *  @param pos           Position to be used for error reporting.
 834      *  @param t             The type to be checked.
<span class="line-added"> 835      *  @param valueOK       If false, a value class does not qualify</span>
 836      */
<span class="line-modified"> 837     Type checkRefType(DiagnosticPosition pos, Type t, boolean valueOK) {</span>
<span class="line-modified"> 838         if (t.isReference() &amp;&amp; (valueOK || !types.isValue(t)))</span>
 839             return t;
 840         else
 841             return typeTagError(pos,
 842                                 diags.fragment(Fragments.TypeReqRef),
 843                                 t);
 844     }
 845 
<span class="line-added"> 846     /** Check that type is a reference type, i.e. a class, interface or array type</span>
<span class="line-added"> 847      *  or a type variable.</span>
<span class="line-added"> 848      *  @param pos           Position to be used for error reporting.</span>
<span class="line-added"> 849      *  @param t             The type to be checked.</span>
<span class="line-added"> 850      */</span>
<span class="line-added"> 851     Type checkRefType(DiagnosticPosition pos, Type t) {</span>
<span class="line-added"> 852         return checkRefType(pos, t, true);</span>
<span class="line-added"> 853     }</span>
<span class="line-added"> 854 </span>
 855     /** Check that each type is a reference type, i.e. a class, interface or array type
 856      *  or a type variable.
 857      *  @param trees         Original trees, used for error reporting.
 858      *  @param types         The types to be checked.
 859      */
 860     List&lt;Type&gt; checkRefTypes(List&lt;JCExpression&gt; trees, List&lt;Type&gt; types) {
 861         List&lt;JCExpression&gt; tl = trees;
 862         for (List&lt;Type&gt; l = types; l.nonEmpty(); l = l.tail) {
<span class="line-modified"> 863             l.head = checkRefType(tl.head.pos(), l.head, false);</span>
 864             tl = tl.tail;
 865         }
 866         return types;
 867     }
 868 
 869     /** Check that type is a null or reference type.
 870      *  @param pos           Position to be used for error reporting.
 871      *  @param t             The type to be checked.
 872      */
 873     Type checkNullOrRefType(DiagnosticPosition pos, Type t) {
 874         if (t.isReference() || t.hasTag(BOT))
 875             return t;
 876         else
 877             return typeTagError(pos,
 878                                 diags.fragment(Fragments.TypeReqRef),
 879                                 t);
 880     }
 881 
 882     /** Check that flag set does not contain elements of two conflicting sets. s
 883      *  Return true if it doesn&#39;t.
 884      *  @param pos           Position to be used for error reporting.
 885      *  @param flags         The set of flags to be checked.
 886      *  @param set1          Conflicting flags set #1.
 887      *  @param set2          Conflicting flags set #2.
 888      */
 889     boolean checkDisjoint(DiagnosticPosition pos, long flags, long set1, long set2) {
 890         if ((flags &amp; set1) != 0 &amp;&amp; (flags &amp; set2) != 0) {
 891             log.error(pos,
 892                       Errors.IllegalCombinationOfModifiers(asFlagSet(TreeInfo.firstFlag(flags &amp; set1)),
 893                                                            asFlagSet(TreeInfo.firstFlag(flags &amp; set2))));
 894             return false;
 895         } else
 896             return true;
 897     }
 898 
<span class="line-added"> 899     void checkParameterizationWithValues(DiagnosticPosition pos, Type t) {</span>
<span class="line-added"> 900         valueParameterizationChecker.visit(t, pos);</span>
<span class="line-added"> 901     }</span>
<span class="line-added"> 902 </span>
<span class="line-added"> 903     /** valueParameterizationChecker: A type visitor that descends down the given type looking for instances of value types</span>
<span class="line-added"> 904      *  being used as type arguments and issues error against those usages.</span>
<span class="line-added"> 905      */</span>
<span class="line-added"> 906     private final Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt; valueParameterizationChecker = new Types.SimpleVisitor&lt;Void, DiagnosticPosition&gt;() {</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908         @Override</span>
<span class="line-added"> 909         public Void visitType(Type t, DiagnosticPosition pos) {</span>
<span class="line-added"> 910             return null;</span>
<span class="line-added"> 911         }</span>
<span class="line-added"> 912 </span>
<span class="line-added"> 913         @Override</span>
<span class="line-added"> 914         public Void visitClassType(ClassType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 915             for (Type targ : t.allparams()) {</span>
<span class="line-added"> 916                 if (types.isValue(targ)) {</span>
<span class="line-added"> 917                     log.error(pos, Errors.GenericParameterizationWithValueType(t));</span>
<span class="line-added"> 918                 }</span>
<span class="line-added"> 919                 visit(targ, pos);</span>
<span class="line-added"> 920             }</span>
<span class="line-added"> 921             return null;</span>
<span class="line-added"> 922         }</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924         @Override</span>
<span class="line-added"> 925         public Void visitTypeVar(TypeVar t, DiagnosticPosition pos) {</span>
<span class="line-added"> 926              return null;</span>
<span class="line-added"> 927         }</span>
<span class="line-added"> 928 </span>
<span class="line-added"> 929         @Override</span>
<span class="line-added"> 930         public Void visitCapturedType(CapturedType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 931             return null;</span>
<span class="line-added"> 932         }</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934         @Override</span>
<span class="line-added"> 935         public Void visitArrayType(ArrayType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 936             return visit(t.elemtype, pos);</span>
<span class="line-added"> 937         }</span>
<span class="line-added"> 938 </span>
<span class="line-added"> 939         @Override</span>
<span class="line-added"> 940         public Void visitWildcardType(WildcardType t, DiagnosticPosition pos) {</span>
<span class="line-added"> 941             return visit(t.type, pos);</span>
<span class="line-added"> 942         }</span>
<span class="line-added"> 943     };</span>
<span class="line-added"> 944 </span>
<span class="line-added"> 945 </span>
<span class="line-added"> 946 </span>
 947     /** Check that usage of diamond operator is correct (i.e. diamond should not
 948      * be used with non-generic classes or in anonymous class creation expressions)
 949      */
 950     Type checkDiamond(JCNewClass tree, Type t) {
 951         if (!TreeInfo.isDiamond(tree) ||
 952                 t.isErroneous()) {
 953             return checkClassType(tree.clazz.pos(), t, true);
 954         } else {
 955             if (tree.def != null &amp;&amp; !Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.allowedInSource(source)) {
 956                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.clazz.pos(),
 957                         Errors.CantApplyDiamond1(t, Feature.DIAMOND_WITH_ANONYMOUS_CLASS_CREATION.fragment(source.name)));
 958             }
 959             if (t.tsym.type.getTypeArguments().isEmpty()) {
 960                 log.error(tree.clazz.pos(),
 961                           Errors.CantApplyDiamond1(t,
 962                                                    Fragments.DiamondNonGeneric(t)));
 963                 return types.createErrorType(t);
 964             } else if (tree.typeargs != null &amp;&amp;
 965                     tree.typeargs.nonEmpty()) {
 966                 log.error(tree.clazz.pos(),
</pre>
<hr />
<pre>
1075     }
1076     //where
1077         private boolean isTrustMeAllowedOnMethod(Symbol s) {
1078             return (s.flags() &amp; VARARGS) != 0 &amp;&amp;
1079                 (s.isConstructor() ||
1080                     (s.flags() &amp; (STATIC | FINAL |
1081                                   (Feature.PRIVATE_SAFE_VARARGS.allowedInSource(source) ? PRIVATE : 0) )) != 0);
1082         }
1083 
1084     Type checkLocalVarType(DiagnosticPosition pos, Type t, Name name) {
1085         //check that resulting type is not the null type
1086         if (t.hasTag(BOT)) {
1087             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferNull));
1088             return types.createErrorType(t);
1089         } else if (t.hasTag(VOID)) {
1090             log.error(pos, Errors.CantInferLocalVarType(name, Fragments.LocalCantInferVoid));
1091             return types.createErrorType(t);
1092         }
1093 
1094         //upward project the initializer type
<span class="line-modified">1095         Type varType = types.upward(t, types.captures(t));</span>
<span class="line-added">1096         if (varType.hasTag(CLASS)) {</span>
<span class="line-added">1097             checkParameterizationWithValues(pos, varType);</span>
<span class="line-added">1098         }</span>
<span class="line-added">1099         return varType;</span>
<span class="line-added">1100     }</span>
<span class="line-added">1101 </span>
<span class="line-added">1102     public void checkForSuspectClassLiteralComparison(</span>
<span class="line-added">1103             final JCBinary tree,</span>
<span class="line-added">1104             final Type leftType,</span>
<span class="line-added">1105             final Type rightType) {</span>
<span class="line-added">1106 </span>
<span class="line-added">1107         if (lint.isEnabled(LintCategory.MIGRATION)) {</span>
<span class="line-added">1108             if (isInvocationOfGetClass(tree.lhs) &amp;&amp; isClassOfSomeInterface(rightType) ||</span>
<span class="line-added">1109                     isInvocationOfGetClass(tree.rhs) &amp;&amp; isClassOfSomeInterface(leftType)) {</span>
<span class="line-added">1110                 log.warning(LintCategory.MIGRATION, tree.pos(), Warnings.GetClassComparedWithInterface);</span>
<span class="line-added">1111             }</span>
<span class="line-added">1112         }</span>
<span class="line-added">1113     }</span>
<span class="line-added">1114     //where</span>
<span class="line-added">1115     private boolean isClassOfSomeInterface(Type someClass) {</span>
<span class="line-added">1116         if (someClass.tsym.flatName() == names.java_lang_Class) {</span>
<span class="line-added">1117             List&lt;Type&gt; arguments = someClass.getTypeArguments();</span>
<span class="line-added">1118             if (arguments.length() == 1) {</span>
<span class="line-added">1119                 return arguments.head.isInterface();</span>
<span class="line-added">1120             }</span>
<span class="line-added">1121         }</span>
<span class="line-added">1122         return false;</span>
<span class="line-added">1123     }</span>
<span class="line-added">1124     //where</span>
<span class="line-added">1125     private boolean isInvocationOfGetClass(JCExpression tree) {</span>
<span class="line-added">1126         tree = TreeInfo.skipParens(tree);</span>
<span class="line-added">1127         if (tree.hasTag(APPLY)) {</span>
<span class="line-added">1128             JCMethodInvocation apply = (JCMethodInvocation)tree;</span>
<span class="line-added">1129             MethodSymbol msym = (MethodSymbol)TreeInfo.symbol(apply.meth);</span>
<span class="line-added">1130             return msym.name == names.getClass &amp;&amp; msym.implementedIn(syms.objectType.tsym, types) != null;</span>
<span class="line-added">1131         }</span>
<span class="line-added">1132         return false;</span>
1133     }
1134 
1135     Type checkMethod(final Type mtype,
1136             final Symbol sym,
1137             final Env&lt;AttrContext&gt; env,
1138             final List&lt;JCExpression&gt; argtrees,
1139             final List&lt;Type&gt; argtypes,
1140             final boolean useVarargs,
1141             InferenceContext inferenceContext) {
1142         // System.out.println(&quot;call   : &quot; + env.tree);
1143         // System.out.println(&quot;method : &quot; + owntype);
1144         // System.out.println(&quot;actuals: &quot; + argtypes);
1145         if (inferenceContext.free(mtype)) {
1146             inferenceContext.addFreeTypeListener(List.of(mtype),
1147                     solvedContext -&gt; checkMethod(solvedContext.asInstType(mtype), sym, env, argtrees, argtypes, useVarargs, solvedContext));
1148             return mtype;
1149         }
1150         Type owntype = mtype;
1151         List&lt;Type&gt; formals = owntype.getParameterTypes();
1152         List&lt;Type&gt; nonInferred = sym.type.getParameterTypes();
</pre>
<hr />
<pre>
1310      *  return modifiers together with any implicit modifiers for that symbol.
1311      *  Warning: we can&#39;t use flags() here since this method
1312      *  is called during class enter, when flags() would cause a premature
1313      *  completion.
1314      *  @param pos           Position to be used for error reporting.
1315      *  @param flags         The set of modifiers given in a definition.
1316      *  @param sym           The defined symbol.
1317      */
1318     long checkFlags(DiagnosticPosition pos, long flags, Symbol sym, JCTree tree) {
1319         long mask;
1320         long implicit = 0;
1321 
1322         switch (sym.kind) {
1323         case VAR:
1324             if (TreeInfo.isReceiverParam(tree))
1325                 mask = ReceiverParamFlags;
1326             else if (sym.owner.kind != TYP)
1327                 mask = LocalVarFlags;
1328             else if ((sym.owner.flags_field &amp; INTERFACE) != 0)
1329                 mask = implicit = InterfaceVarFlags;
<span class="line-modified">1330             else {</span>
1331                 mask = VarFlags;
<span class="line-added">1332                 if (types.isValue(sym.owner.type) &amp;&amp; (flags &amp; STATIC) == 0) {</span>
<span class="line-added">1333                     implicit |= FINAL;</span>
<span class="line-added">1334                 }</span>
<span class="line-added">1335             }</span>
1336             break;
1337         case MTH:
1338             if (sym.name == names.init) {
1339                 if ((sym.owner.flags_field &amp; ENUM) != 0) {
1340                     // enum constructors cannot be declared public or
1341                     // protected and must be implicitly or explicitly
1342                     // private
1343                     implicit = PRIVATE;
1344                     mask = PRIVATE;
1345                 } else
1346                     mask = ConstructorFlags;
1347             }  else if ((sym.owner.flags_field &amp; INTERFACE) != 0) {
1348                 if ((sym.owner.flags_field &amp; ANNOTATION) != 0) {
1349                     mask = AnnotationTypeElementMask;
1350                     implicit = PUBLIC | ABSTRACT;
1351                 } else if ((flags &amp; (DEFAULT | STATIC | PRIVATE)) != 0) {
1352                     mask = InterfaceMethodMask;
1353                     implicit = (flags &amp; PRIVATE) != 0 ? 0 : PUBLIC;
1354                     if ((flags &amp; DEFAULT) != 0) {
1355                         implicit |= ABSTRACT;
1356                     }
1357                 } else {
1358                     mask = implicit = InterfaceMethodFlags;
1359                 }
1360             } else if ((sym.owner.flags_field &amp; RECORD) != 0) {
1361                 mask = RecordMethodFlags;
1362             } else {
<span class="line-modified">1363                 // instance methods of value types do not have a monitor associated with their `this&#39;</span>
<span class="line-added">1364                 mask = ((sym.owner.flags_field &amp; VALUE) != 0 &amp;&amp; (flags &amp; Flags.STATIC) == 0) ?</span>
<span class="line-added">1365                         MethodFlags &amp; ~SYNCHRONIZED : MethodFlags;</span>
1366             }
1367             // Imply STRICTFP if owner has STRICTFP set.
1368             if (((flags|implicit) &amp; Flags.ABSTRACT) == 0 ||
1369                 ((flags) &amp; Flags.DEFAULT) != 0)
1370                 implicit |= sym.owner.flags_field &amp; STRICTFP;
1371             break;
1372         case TYP:
1373             if (sym.isLocal()) {
1374                 mask = (flags &amp; RECORD) != 0 ? LocalRecordFlags : LocalClassFlags;
1375                 if ((flags &amp; RECORD) != 0) {
1376                     implicit = STATIC;
1377                     if (sym.owner.kind == TYP) {
1378                         log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1379                     }
1380                 }
1381                 if ((sym.owner.flags_field &amp; STATIC) == 0 &amp;&amp;
1382                     (flags &amp; ENUM) != 0) {
1383                     log.error(pos, Errors.EnumsMustBeStatic);
1384                 }
1385             } else if (sym.owner.kind == TYP) {
1386                 mask = (flags &amp; RECORD) != 0 ? MemberRecordFlags : MemberClassFlags;
1387                 if (sym.owner.owner.kind == PCK ||
1388                     (sym.owner.flags_field &amp; STATIC) != 0)
1389                     mask |= STATIC;
1390                 else if ((flags &amp; ENUM) != 0) {
1391                     log.error(pos, Errors.EnumsMustBeStatic);
1392                 } else if ((flags &amp; RECORD) != 0) {
1393                     log.error(pos, Errors.RecordDeclarationNotAllowedInInnerClasses);
1394                 }
1395                 // Nested interfaces and enums are always STATIC (Spec ???)
1396                 if ((flags &amp; (INTERFACE | ENUM | RECORD)) != 0 ) implicit = STATIC;
1397             } else {
1398                 mask = ClassFlags;
1399             }
1400             // Interfaces are always ABSTRACT
1401             if ((flags &amp; INTERFACE) != 0) implicit |= ABSTRACT;
1402 
1403             if ((flags &amp; ENUM) != 0) {
<span class="line-modified">1404                 // enums can&#39;t be declared abstract or final or value type</span>
<span class="line-modified">1405                 mask &amp;= ~(ABSTRACT | FINAL | VALUE);</span>
1406                 implicit |= implicitEnumFinalFlag(tree);
1407             }
1408             if ((flags &amp; RECORD) != 0) {
1409                 // records can&#39;t be declared abstract
1410                 mask &amp;= ~ABSTRACT;
1411                 implicit |= FINAL;
1412             }
1413             // Imply STRICTFP if owner has STRICTFP set.
1414             implicit |= sym.owner.flags_field &amp; STRICTFP;
1415             break;
1416         default:
1417             throw new AssertionError();
1418         }
1419         long illegal = flags &amp; ExtendedStandardFlags &amp; ~mask;
1420         if (illegal != 0) {
1421             if ((illegal &amp; INTERFACE) != 0) {
1422                 log.error(pos, ((flags &amp; ANNOTATION) != 0) ? Errors.AnnotationDeclNotAllowedHere : Errors.IntfNotAllowedHere);
1423                 mask |= INTERFACE;
1424             }
1425             else {
1426                 log.error(pos,
1427                           Errors.ModNotAllowedHere(asFlagSet(illegal)));
1428             }
1429         }
1430         else if ((sym.kind == TYP ||
1431                   // ISSUE: Disallowing abstract&amp;private is no longer appropriate
1432                   // in the presence of inner classes. Should it be deleted here?
1433                   checkDisjoint(pos, flags,
1434                                 ABSTRACT,
1435                                 PRIVATE | STATIC | DEFAULT))
1436                  &amp;&amp;
1437                  checkDisjoint(pos, flags,
1438                                 STATIC | PRIVATE,
1439                                 DEFAULT)
1440                  &amp;&amp;
1441                  checkDisjoint(pos, flags,
1442                                ABSTRACT | INTERFACE,
<span class="line-modified">1443                                FINAL | NATIVE | SYNCHRONIZED | VALUE)</span>
1444                  &amp;&amp;
1445                  checkDisjoint(pos, flags,
1446                                PUBLIC,
1447                                PRIVATE | PROTECTED)
1448                  &amp;&amp;
1449                  checkDisjoint(pos, flags,
1450                                PRIVATE,
1451                                PUBLIC | PROTECTED)
1452                  &amp;&amp;
<span class="line-modified">1453                  checkDisjoint(pos, (flags | implicit), // complain against volatile &amp; implcitly final entities too.</span>
1454                                FINAL,
1455                                VOLATILE)
1456                  &amp;&amp;
1457                  (sym.kind == TYP ||
1458                   checkDisjoint(pos, flags,
1459                                 ABSTRACT | NATIVE,
1460                                 STRICTFP))) {
1461             // skip
1462         }
1463         return flags &amp; (mask | ~ExtendedStandardFlags) | implicit;
1464     }
1465 
1466 
1467     /** Determine if this enum should be implicitly final.
1468      *
1469      *  If the enum has no specialized enum constants, it is final.
1470      *
1471      *  If the enum does have specialized enum constants, it is
1472      *  &lt;i&gt;not&lt;/i&gt; final.
1473      */
</pre>
<hr />
<pre>
1601         @Override
1602         public void visitWildcard(JCWildcard tree) {
1603             if (tree.inner != null)
1604                 validateTree(tree.inner, true, isOuter);
1605         }
1606 
1607         @Override
1608         public void visitSelect(JCFieldAccess tree) {
1609             if (tree.type.hasTag(CLASS)) {
1610                 visitSelectInternal(tree);
1611 
1612                 // Check that this type is either fully parameterized, or
1613                 // not parameterized at all.
1614                 if (tree.selected.type.isParameterized() &amp;&amp; tree.type.tsym.type.getTypeArguments().nonEmpty())
1615                     log.error(tree.pos(), Errors.ImproperlyFormedTypeParamMissing);
1616             }
1617         }
1618 
1619         public void visitSelectInternal(JCFieldAccess tree) {
1620             if (tree.type.tsym.isStatic() &amp;&amp;
<span class="line-modified">1621                 tree.selected.type.isParameterized() &amp;&amp;</span>
<span class="line-added">1622                     (tree.name != names.ref || !tree.type.isReferenceProjection())) {</span>
1623                 // The enclosing type is not a class, so we are
1624                 // looking at a static member type.  However, the
1625                 // qualifying expression is parameterized.
<span class="line-added">1626                 // Tolerate the pseudo-select V.ref: V&lt;T&gt;.ref will be static if V&lt;T&gt; is and</span>
<span class="line-added">1627                 // should not be confused as selecting a static member of a parameterized type.</span>
1628                 log.error(tree.pos(), Errors.CantSelectStaticClassFromParamType);
1629             } else {
1630                 // otherwise validate the rest of the expression
1631                 tree.selected.accept(this);
1632             }
1633         }
1634 
1635         @Override
1636         public void visitAnnotatedType(JCAnnotatedType tree) {
1637             tree.underlyingType.accept(this);
1638         }
1639 
1640         @Override
1641         public void visitTypeIdent(JCPrimitiveTypeTree that) {
1642             if (that.type.hasTag(TypeTag.VOID)) {
1643                 log.error(that.pos(), Errors.VoidNotAllowedHere);
1644             }
1645             super.visitTypeIdent(that);
1646         }
1647 
</pre>
<hr />
<pre>
1934             return;
1935         }
1936 
1937         if ((m.owner.flags() &amp; ANNOTATION) != 0) {
1938             // handled in validateAnnotationMethod
1939             return;
1940         }
1941 
1942         // Error if overriding method has weaker access (JLS 8.4.6.3).
1943         if (protection(m.flags()) &gt; protection(other.flags())) {
1944             log.error(TreeInfo.diagnosticPositionFor(m, tree),
1945                       (other.flags() &amp; AccessFlags) == 0 ?
1946                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1947                                                           &quot;package&quot;) :
1948                               Errors.OverrideWeakerAccess(cannotOverride(m, other),
1949                                                           asFlagSet(other.flags() &amp; AccessFlags)));
1950             m.flags_field |= BAD_OVERRIDE;
1951             return;
1952         }
1953 
<span class="line-added">1954         if (origin.isValue() &amp;&amp; other.owner == syms.objectType.tsym &amp;&amp; m.type.getParameterTypes().size() == 0) {</span>
<span class="line-added">1955             if (m.name == names.clone || m.name == names.finalize) {</span>
<span class="line-added">1956                 log.error(TreeInfo.diagnosticPositionFor(m, tree),</span>
<span class="line-added">1957                         Errors.InlineClassMayNotOverride(m.name));</span>
<span class="line-added">1958                 m.flags_field |= BAD_OVERRIDE;</span>
<span class="line-added">1959                 return;</span>
<span class="line-added">1960             }</span>
<span class="line-added">1961         }</span>
<span class="line-added">1962 </span>
1963         Type mt = types.memberType(origin.type, m);
1964         Type ot = types.memberType(origin.type, other);
1965         // Error if overriding result type is different
1966         // (or, in the case of generics mode, not a subtype) of
1967         // overridden result type. We have to rename any type parameters
1968         // before comparing types.
1969         List&lt;Type&gt; mtvars = mt.getTypeArguments();
1970         List&lt;Type&gt; otvars = ot.getTypeArguments();
1971         Type mtres = mt.getReturnType();
1972         Type otres = types.subst(ot.getReturnType(), otvars, mtvars);
1973 
1974         overrideWarner.clear();
1975         boolean resultTypesOK =
1976             types.returnTypeSubstitutable(mt, ot, otres, overrideWarner);
1977         if (!resultTypesOK) {
1978             if ((m.flags() &amp; STATIC) != 0 &amp;&amp; (other.flags() &amp; STATIC) != 0) {
1979                 log.error(TreeInfo.diagnosticPositionFor(m, tree),
1980                           Errors.OverrideIncompatibleRet(Fragments.CantHide(m, m.location(), other,
1981                                         other.location()), mtres, otres));
1982                 m.flags_field |= BAD_OVERRIDE;
</pre>
<hr />
<pre>
2245         if ((origin.flags() &amp; ENUM) != 0 &amp;&amp; names.finalize.equals(m.name))
2246             if (m.overrides(syms.enumFinalFinalize, origin, types, false)) {
2247                 log.error(tree.pos(), Errors.EnumNoFinalize);
2248                 return;
2249             }
2250         for (Type t = origin.type; t.hasTag(CLASS);
2251              t = types.supertype(t)) {
2252             if (t != origin.type) {
2253                 checkOverride(tree, t, origin, m);
2254             }
2255             for (Type t2 : types.interfaces(t)) {
2256                 checkOverride(tree, t2, origin, m);
2257             }
2258         }
2259 
2260         final boolean explicitOverride = m.attribute(syms.overrideType.tsym) != null;
2261         // Check if this method must override a super method due to being annotated with @Override
2262         // or by virtue of being a member of a diamond inferred anonymous class. Latter case is to
2263         // be treated &quot;as if as they were annotated&quot; with @Override.
2264         boolean mustOverride = explicitOverride ||
<span class="line-modified">2265                 (env.info.isAnonymousDiamond &amp;&amp; !m.isConstructor() &amp;&amp; !m.isPrivate() &amp;&amp;</span>
<span class="line-added">2266                         (!m.owner.isValue() || (tree.body.flags &amp; SYNTHETIC) == 0));</span>
2267         if (mustOverride &amp;&amp; !isOverrider(m)) {
2268             DiagnosticPosition pos = tree.pos();
2269             for (JCAnnotation a : tree.getModifiers().annotations) {
2270                 if (a.annotationType.type.tsym == syms.overrideType.tsym) {
2271                     pos = a.pos();
2272                     break;
2273                 }
2274             }
2275             log.error(pos,
2276                       explicitOverride ? (m.isStatic() ? Errors.StaticMethodsCannotBeAnnotatedWithOverride : Errors.MethodDoesNotOverrideSuperclass) :
2277                                 Errors.AnonymousDiamondMethodDoesNotOverrideSuperclass(Fragments.DiamondAnonymousMethodsImplicitlyOverride));
2278         }
2279     }
2280 
2281     void checkOverride(JCTree tree, Type site, ClassSymbol origin, MethodSymbol m) {
2282         TypeSymbol c = site.tsym;
2283         for (Symbol sym : c.members().getSymbolsByName(m.name)) {
2284             if (m.overrides(sym, origin, types, false)) {
2285                 if ((sym.flags() &amp; ABSTRACT) == 0) {
2286                     checkOverride(tree, m, (MethodSymbol)sym, origin);
</pre>
<hr />
<pre>
2372                 cf.accepts(s2) &amp;&amp;
2373                 types.hasSameArgs(s1.erasure(types), s2.erasure(types)));
2374     }
2375 
2376 
2377     /** Check that all abstract members of given class have definitions.
2378      *  @param pos          Position to be used for error reporting.
2379      *  @param c            The class.
2380      */
2381     void checkAllDefined(DiagnosticPosition pos, ClassSymbol c) {
2382         MethodSymbol undef = types.firstUnimplementedAbstract(c);
2383         if (undef != null) {
2384             MethodSymbol undef1 =
2385                 new MethodSymbol(undef.flags(), undef.name,
2386                                  types.memberType(c.type, undef), undef.owner);
2387             log.error(pos,
2388                       Errors.DoesNotOverrideAbstract(c, undef1, undef1.location()));
2389         }
2390     }
2391 
<span class="line-added">2392     // A value class cannot contain a field of its own type either or indirectly.</span>
<span class="line-added">2393     void checkNonCyclicMembership(JCClassDecl tree) {</span>
<span class="line-added">2394         Assert.check((tree.sym.flags_field &amp; LOCKED) == 0);</span>
<span class="line-added">2395         try {</span>
<span class="line-added">2396             tree.sym.flags_field |= LOCKED;</span>
<span class="line-added">2397             for (List&lt;? extends JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {</span>
<span class="line-added">2398                 if (l.head.hasTag(VARDEF)) {</span>
<span class="line-added">2399                     JCVariableDecl field = (JCVariableDecl) l.head;</span>
<span class="line-added">2400                     if (cyclePossible(field.sym)) {</span>
<span class="line-added">2401                         Type fieldType = field.sym.type;</span>
<span class="line-added">2402                         checkNonCyclicMembership((ClassSymbol) fieldType.tsym, field.pos());</span>
<span class="line-added">2403                     }</span>
<span class="line-added">2404                 }</span>
<span class="line-added">2405             }</span>
<span class="line-added">2406         } finally {</span>
<span class="line-added">2407             tree.sym.flags_field &amp;= ~LOCKED;</span>
<span class="line-added">2408         }</span>
<span class="line-added">2409 </span>
<span class="line-added">2410     }</span>
<span class="line-added">2411     // where</span>
<span class="line-added">2412     private void checkNonCyclicMembership(ClassSymbol c, DiagnosticPosition pos) {</span>
<span class="line-added">2413         if ((c.flags_field &amp; LOCKED) != 0) {</span>
<span class="line-added">2414             log.error(pos, Errors.CyclicValueTypeMembership(c));</span>
<span class="line-added">2415             return;</span>
<span class="line-added">2416         }</span>
<span class="line-added">2417         try {</span>
<span class="line-added">2418             c.flags_field |= LOCKED;</span>
<span class="line-added">2419             for (Symbol fld : c.members().getSymbols(s -&gt; s.kind == VAR &amp;&amp; cyclePossible((VarSymbol) s), NON_RECURSIVE)) {</span>
<span class="line-added">2420                 checkNonCyclicMembership((ClassSymbol) fld.type.tsym, pos);</span>
<span class="line-added">2421             }</span>
<span class="line-added">2422         } finally {</span>
<span class="line-added">2423             c.flags_field &amp;= ~LOCKED;</span>
<span class="line-added">2424         }</span>
<span class="line-added">2425     }</span>
<span class="line-added">2426         // where</span>
<span class="line-added">2427         private boolean cyclePossible(VarSymbol symbol) {</span>
<span class="line-added">2428             return (symbol.flags() &amp; STATIC) == 0 &amp;&amp; types.isValue(symbol.type);</span>
<span class="line-added">2429         }</span>
<span class="line-added">2430 </span>
2431     void checkNonCyclicDecl(JCClassDecl tree) {
2432         CycleChecker cc = new CycleChecker();
2433         cc.scan(tree);
2434         if (!cc.errorFound &amp;&amp; !cc.partialCheck) {
2435             tree.sym.flags_field |= ACYCLIC;
2436         }
2437     }
2438 
2439     class CycleChecker extends TreeScanner {
2440 
2441         List&lt;Symbol&gt; seenClasses = List.nil();
2442         boolean errorFound = false;
2443         boolean partialCheck = false;
2444 
2445         private void checkSymbol(DiagnosticPosition pos, Symbol sym) {
2446             if (sym != null &amp;&amp; sym.kind == TYP) {
2447                 Env&lt;AttrContext&gt; classEnv = enter.getEnv((TypeSymbol)sym);
2448                 if (classEnv != null) {
2449                     DiagnosticSource prevSource = log.currentSource();
2450                     try {
</pre>
<hr />
<pre>
2659     /** Check that all abstract methods implemented by a class are
2660      *  mutually compatible.
2661      *  @param pos          Position to be used for error reporting.
2662      *  @param c            The class whose interfaces are checked.
2663      */
2664     void checkCompatibleSupertypes(DiagnosticPosition pos, Type c) {
2665         List&lt;Type&gt; supertypes = types.interfaces(c);
2666         Type supertype = types.supertype(c);
2667         if (supertype.hasTag(CLASS) &amp;&amp;
2668             (supertype.tsym.flags() &amp; ABSTRACT) != 0)
2669             supertypes = supertypes.prepend(supertype);
2670         for (List&lt;Type&gt; l = supertypes; l.nonEmpty(); l = l.tail) {
2671             if (!l.head.getTypeArguments().isEmpty() &amp;&amp;
2672                 !checkCompatibleAbstracts(pos, l.head, l.head, c))
2673                 return;
2674             for (List&lt;Type&gt; m = supertypes; m != l; m = m.tail)
2675                 if (!checkCompatibleAbstracts(pos, l.head, m.head, c))
2676                     return;
2677         }
2678         checkCompatibleConcretes(pos, c);
<span class="line-added">2679 </span>
<span class="line-added">2680         if (c.isValue() &amp;&amp; types.asSuper(c, syms.identityObjectType.tsym, true) != null) {</span>
<span class="line-added">2681             log.error(pos, Errors.InlineTypeMustNotImplementIdentityObject(c));</span>
<span class="line-added">2682         }</span>
2683     }
2684 
2685     /** Check that all non-override equivalent methods accessible from &#39;site&#39;
2686      *  are mutually compatible (JLS 8.4.8/9.4.1).
2687      *
2688      *  @param pos  Position to be used for error reporting.
2689      *  @param site The class whose methods are checked.
2690      *  @param sym  The method symbol to be checked.
2691      */
2692     void checkOverrideClashes(DiagnosticPosition pos, Type site, MethodSymbol sym) {
2693          ClashFilter cf = new ClashFilter(site);
2694         //for each method m1 that is overridden (directly or indirectly)
2695         //by method &#39;sym&#39; in &#39;site&#39;...
2696 
2697         List&lt;MethodSymbol&gt; potentiallyAmbiguousList = List.nil();
2698         boolean overridesAny = false;
2699         ArrayList&lt;Symbol&gt; symbolsByName = new ArrayList&lt;&gt;();
2700         types.membersClosure(site, false).getSymbolsByName(sym.name, cf).forEach(symbolsByName::add);
2701         for (Symbol m1 : symbolsByName) {
2702             if (!sym.overrides(m1, site.tsym, types, false)) {
</pre>
<hr />
<pre>
3222                                 }
3223                             }
3224                             modifiers.annotations = newAnnotations.toList();
3225                         }
3226                         // now lets remove it from the symbol
3227                         s.getMetadata().removeDeclarationMetadata(a.attribute);
3228                     } else {
3229                         log.error(a.pos(), Errors.AnnotationTypeNotApplicable);
3230                     }
3231                 }
3232             }
3233         }
3234 
3235         if (a.annotationType.type.tsym == syms.functionalInterfaceType.tsym) {
3236             if (s.kind != TYP) {
3237                 log.error(a.pos(), Errors.BadFunctionalIntfAnno);
3238             } else if (!s.isInterface() || (s.flags() &amp; ANNOTATION) != 0) {
3239                 log.error(a.pos(), Errors.BadFunctionalIntfAnno1(Fragments.NotAFunctionalIntf(s)));
3240             }
3241         }
<span class="line-added">3242         if (a.annotationType.type.tsym == syms.valueBasedType.tsym) {</span>
<span class="line-added">3243             if (s.isInterface() || s.isEnum()) {</span>
<span class="line-added">3244                 log.error(a.pos(), Errors.BadValueBasedAnno);</span>
<span class="line-added">3245             } else if (allowValueBasedClasses) {</span>
<span class="line-added">3246                 s.flags_field |= VALUEBASED;</span>
<span class="line-added">3247             }</span>
<span class="line-added">3248         }</span>
3249     }
3250 
3251     public void validateTypeAnnotation(JCAnnotation a, boolean isTypeParameter) {
3252         Assert.checkNonNull(a.type);
3253         validateAnnotationTree(a);
3254 
3255         if (a.hasTag(TYPE_ANNOTATION) &amp;&amp;
3256                 !a.annotationType.type.isErroneous() &amp;&amp;
3257                 !isTypeAnnotation(a, isTypeParameter)) {
3258             log.error(a.pos(), Errors.AnnotationTypeNotApplicableToType(a.type));
3259         }
3260     }
3261 
3262     /**
3263      * Validate the proposed container &#39;repeatable&#39; on the
3264      * annotation type symbol &#39;s&#39;. Report errors at position
3265      * &#39;pos&#39;.
3266      *
3267      * @param s The (annotation)type declaration annotated with a @Repeatable
3268      * @param repeatable the @Repeatable on &#39;s&#39;
</pre>
</td>
</tr>
</table>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Flow.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //todo: one might eliminate uninits.andSets when monotonic
  27 
  28 package com.sun.tools.javac.comp;
  29 
  30 import java.util.HashMap;
  31 import java.util.HashSet;
  32 import java.util.Set;
  33 import java.util.stream.Collectors;
  34 
  35 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Scope.WriteableScope;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  40 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  41 import com.sun.tools.javac.tree.*;
  42 import com.sun.tools.javac.util.*;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.JCDiagnostic.Error;
  45 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  46 
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;
<a name="1" id="anc1"></a>


  55 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  56 
  57 /** This pass implements dataflow analysis for Java programs though
  58  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  59  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  60  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  61  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  62  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  63  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
  64  *  determines that local variables accessed within the scope of an inner class/lambda
  65  *  are either final or effectively-final.
  66  *
  67  *  &lt;p&gt;The JLS has a number of problems in the
  68  *  specification of these flow analysis problems. This implementation
  69  *  attempts to address those issues.
  70  *
  71  *  &lt;p&gt;First, there is no accommodation for a finally clause that cannot
  72  *  complete normally. For liveness analysis, an intervening finally
  73  *  clause can cause a break, continue, or return not to reach its
  74  *  target.  For exception analysis, an intervening finally clause can
  75  *  cause any exception to be &quot;caught&quot;.  For DA/DU analysis, the finally
  76  *  clause can prevent a transfer of control from propagating DA/DU
  77  *  state to the target.  In addition, code in the finally clause can
  78  *  affect the DA/DU status of variables.
  79  *
  80  *  &lt;p&gt;For try statements, we introduce the idea of a variable being
  81  *  definitely unassigned &quot;everywhere&quot; in a block.  A variable V is
  82  *  &quot;unassigned everywhere&quot; in a block iff it is unassigned at the
  83  *  beginning of the block and there is no reachable assignment to V
  84  *  in the block.  An assignment V=e is reachable iff V is not DA
  85  *  after e.  Then we can say that V is DU at the beginning of the
  86  *  catch block iff V is DU everywhere in the try block.  Similarly, V
  87  *  is DU at the beginning of the finally block iff V is DU everywhere
  88  *  in the try block and in every catch block.  Specifically, the
  89  *  following bullet is added to 16.2.2
  90  *  &lt;pre&gt;
  91  *      V is &lt;em&gt;unassigned everywhere&lt;/em&gt; in a block if it is
  92  *      unassigned before the block and there is no reachable
  93  *      assignment to V within the block.
  94  *  &lt;/pre&gt;
  95  *  &lt;p&gt;In 16.2.15, the third bullet (and all of its sub-bullets) for all
  96  *  try blocks is changed to
  97  *  &lt;pre&gt;
  98  *      V is definitely unassigned before a catch block iff V is
  99  *      definitely unassigned everywhere in the try block.
 100  *  &lt;/pre&gt;
 101  *  &lt;p&gt;The last bullet (and all of its sub-bullets) for try blocks that
 102  *  have a finally block is changed to
 103  *  &lt;pre&gt;
 104  *      V is definitely unassigned before the finally block iff
 105  *      V is definitely unassigned everywhere in the try block
 106  *      and everywhere in each catch block of the try statement.
 107  *  &lt;/pre&gt;
 108  *  &lt;p&gt;In addition,
 109  *  &lt;pre&gt;
 110  *      V is definitely assigned at the end of a constructor iff
 111  *      V is definitely assigned after the block that is the body
 112  *      of the constructor and V is definitely assigned at every
 113  *      return that can return from the constructor.
 114  *  &lt;/pre&gt;
 115  *  &lt;p&gt;In addition, each continue statement with the loop as its target
 116  *  is treated as a jump to the end of the loop body, and &quot;intervening&quot;
 117  *  finally clauses are treated as follows: V is DA &quot;due to the
 118  *  continue&quot; iff V is DA before the continue statement or V is DA at
 119  *  the end of any intervening finally block.  V is DU &quot;due to the
 120  *  continue&quot; iff any intervening finally cannot complete normally or V
 121  *  is DU at the end of every intervening finally block.  This &quot;due to
 122  *  the continue&quot; concept is then used in the spec for the loops.
 123  *
 124  *  &lt;p&gt;Similarly, break statements must consider intervening finally
 125  *  blocks.  For liveness analysis, a break statement for which any
 126  *  intervening finally cannot complete normally is not considered to
 127  *  cause the target statement to be able to complete normally. Then
 128  *  we say V is DA &quot;due to the break&quot; iff V is DA before the break or
 129  *  V is DA at the end of any intervening finally block.  V is DU &quot;due
 130  *  to the break&quot; iff any intervening finally cannot complete normally
 131  *  or V is DU at the break and at the end of every intervening
 132  *  finally block.  (I suspect this latter condition can be
 133  *  simplified.)  This &quot;due to the break&quot; is then used in the spec for
 134  *  all statements that can be &quot;broken&quot;.
 135  *
 136  *  &lt;p&gt;The return statement is treated similarly.  V is DA &quot;due to a
 137  *  return statement&quot; iff V is DA before the return statement or V is
 138  *  DA at the end of any intervening finally block.  Note that we
 139  *  don&#39;t have to worry about the return expression because this
 140  *  concept is only used for constructors.
 141  *
 142  *  &lt;p&gt;There is no spec in the JLS for when a variable is definitely
 143  *  assigned at the end of a constructor, which is needed for final
 144  *  fields (8.3.1.2).  We implement the rule that V is DA at the end
 145  *  of the constructor iff it is DA and the end of the body of the
 146  *  constructor and V is DA &quot;due to&quot; every return of the constructor.
 147  *
 148  *  &lt;p&gt;Intervening finally blocks similarly affect exception analysis.  An
 149  *  intervening finally that cannot complete normally allows us to ignore
 150  *  an otherwise uncaught exception.
 151  *
 152  *  &lt;p&gt;To implement the semantics of intervening finally clauses, all
 153  *  nonlocal transfers (break, continue, return, throw, method call that
 154  *  can throw a checked exception, and a constructor invocation that can
 155  *  thrown a checked exception) are recorded in a queue, and removed
 156  *  from the queue when we complete processing the target of the
 157  *  nonlocal transfer.  This allows us to modify the queue in accordance
 158  *  with the above rules when we encounter a finally clause.  The only
 159  *  exception to this [no pun intended] is that checked exceptions that
 160  *  are known to be caught or declared to be caught in the enclosing
 161  *  method are not recorded in the queue, but instead are recorded in a
 162  *  global variable &quot;{@code Set&lt;Type&gt; thrown}&quot; that records the type of all
 163  *  exceptions that can be thrown.
 164  *
 165  *  &lt;p&gt;Other minor issues the treatment of members of other classes
 166  *  (always considered DA except that within an anonymous class
 167  *  constructor, where DA status from the enclosing scope is
 168  *  preserved), treatment of the case expression (V is DA before the
 169  *  case expression iff V is DA after the switch expression),
 170  *  treatment of variables declared in a switch block (the implied
 171  *  DA/DU status after the switch expression is DU and not DA for
 172  *  variables defined in a switch block), the treatment of boolean ?:
 173  *  expressions (The JLS rules only handle b and c non-boolean; the
 174  *  new rule is that if b and c are boolean valued, then V is
 175  *  (un)assigned after a?b:c when true/false iff V is (un)assigned
 176  *  after b when true/false and V is (un)assigned after c when
 177  *  true/false).
 178  *
 179  *  &lt;p&gt;There is the remaining question of what syntactic forms constitute a
 180  *  reference to a variable.  It is conventional to allow this.x on the
 181  *  left-hand-side to initialize a final instance field named x, yet
 182  *  this.x isn&#39;t considered a &quot;use&quot; when appearing on a right-hand-side
 183  *  in most implementations.  Should parentheses affect what is
 184  *  considered a variable reference?  The simplest rule would be to
 185  *  allow unqualified forms only, parentheses optional, and phase out
 186  *  support for assigning to a final field via this.x.
 187  *
 188  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 189  *  If you write code that depends on this, you do so at your own risk.
 190  *  This code and its internal interfaces are subject to change or
 191  *  deletion without notice.&lt;/b&gt;
 192  */
 193 public class Flow {
 194     protected static final Context.Key&lt;Flow&gt; flowKey = new Context.Key&lt;&gt;();
 195 
 196     private final Names names;
 197     private final Log log;
 198     private final Symtab syms;
 199     private final Types types;
 200     private final Check chk;
 201     private       TreeMaker make;
 202     private final Resolve rs;
 203     private final JCDiagnostic.Factory diags;
 204     private Env&lt;AttrContext&gt; attrEnv;
 205     private       Lint lint;
 206     private final boolean allowEffectivelyFinalInInnerClasses;
 207 
 208     public static Flow instance(Context context) {
 209         Flow instance = context.get(flowKey);
 210         if (instance == null)
 211             instance = new Flow(context);
 212         return instance;
 213     }
 214 
 215     public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 216         new AliveAnalyzer().analyzeTree(env, make);
 217         new AssignAnalyzer().analyzeTree(env, make);
 218         new FlowAnalyzer().analyzeTree(env, make);
 219         new CaptureAnalyzer().analyzeTree(env, make);
 220     }
 221 
 222     public void analyzeLambda(Env&lt;AttrContext&gt; env, JCLambda that, TreeMaker make, boolean speculative) {
 223         Log.DiagnosticHandler diagHandler = null;
 224         //we need to disable diagnostics temporarily; the problem is that if
 225         //a lambda expression contains e.g. an unreachable statement, an error
 226         //message will be reported and will cause compilation to skip the flow analysis
 227         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 228         //related errors, which will allow for more errors to be detected
 229         if (!speculative) {
 230             diagHandler = new Log.DiscardDiagnosticHandler(log);
 231         }
 232         try {
 233             new LambdaAliveAnalyzer().analyzeTree(env, that, make);
 234         } finally {
 235             if (!speculative) {
 236                 log.popDiagnosticHandler(diagHandler);
 237             }
 238         }
 239     }
 240 
 241     public List&lt;Type&gt; analyzeLambdaThrownTypes(final Env&lt;AttrContext&gt; env,
 242             JCLambda that, TreeMaker make) {
 243         //we need to disable diagnostics temporarily; the problem is that if
 244         //a lambda expression contains e.g. an unreachable statement, an error
 245         //message will be reported and will cause compilation to skip the flow analysis
 246         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 247         //related errors, which will allow for more errors to be detected
 248         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 249         try {
 250             new LambdaAssignAnalyzer(env).analyzeTree(env, that, make);
 251             LambdaFlowAnalyzer flowAnalyzer = new LambdaFlowAnalyzer();
 252             flowAnalyzer.analyzeTree(env, that, make);
 253             return flowAnalyzer.inferredThrownTypes;
 254         } finally {
 255             log.popDiagnosticHandler(diagHandler);
 256         }
 257     }
 258 
 259     public boolean aliveAfter(Env&lt;AttrContext&gt; env, JCTree that, TreeMaker make) {
 260         //we need to disable diagnostics temporarily; the problem is that if
 261         //&quot;that&quot; contains e.g. an unreachable statement, an error
 262         //message will be reported and will cause compilation to skip the flow analysis
 263         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 264         //related errors, which will allow for more errors to be detected
 265         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 266         try {
 267             SnippetAliveAnalyzer analyzer = new SnippetAliveAnalyzer();
 268 
 269             analyzer.analyzeTree(env, that, make);
 270             return analyzer.isAlive();
 271         } finally {
 272             log.popDiagnosticHandler(diagHandler);
 273         }
 274     }
 275 
 276     public boolean breaksOutOf(Env&lt;AttrContext&gt; env, JCTree loop, JCTree body, TreeMaker make) {
 277         //we need to disable diagnostics temporarily; the problem is that if
 278         //&quot;that&quot; contains e.g. an unreachable statement, an error
 279         //message will be reported and will cause compilation to skip the flow analysis
 280         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 281         //related errors, which will allow for more errors to be detected
 282         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 283         try {
 284             SnippetBreakAnalyzer analyzer = new SnippetBreakAnalyzer();
 285 
 286             analyzer.analyzeTree(env, body, make);
 287             return analyzer.breaksOut();
 288         } finally {
 289             log.popDiagnosticHandler(diagHandler);
 290         }
 291     }
 292 
 293     /**
 294      * Definite assignment scan mode
 295      */
 296     enum FlowKind {
 297         /**
 298          * This is the normal DA/DU analysis mode
 299          */
 300         NORMAL(&quot;var.might.already.be.assigned&quot;, false),
 301         /**
 302          * This is the speculative DA/DU analysis mode used to speculatively
 303          * derive assertions within loop bodies
 304          */
 305         SPECULATIVE_LOOP(&quot;var.might.be.assigned.in.loop&quot;, true);
 306 
 307         final String errKey;
 308         final boolean isFinal;
 309 
 310         FlowKind(String errKey, boolean isFinal) {
 311             this.errKey = errKey;
 312             this.isFinal = isFinal;
 313         }
 314 
 315         boolean isFinal() {
 316             return isFinal;
 317         }
 318     }
 319 
 320     protected Flow(Context context) {
 321         context.put(flowKey, this);
 322         names = Names.instance(context);
 323         log = Log.instance(context);
 324         syms = Symtab.instance(context);
 325         types = Types.instance(context);
 326         chk = Check.instance(context);
 327         lint = Lint.instance(context);
 328         rs = Resolve.instance(context);
 329         diags = JCDiagnostic.Factory.instance(context);
 330         Source source = Source.instance(context);
 331         allowEffectivelyFinalInInnerClasses = Feature.EFFECTIVELY_FINAL_IN_INNER_CLASSES.allowedInSource(source);
 332     }
 333 
 334     /**
 335      * Base visitor class for all visitors implementing dataflow analysis logic.
 336      * This class define the shared logic for handling jumps (break/continue statements).
 337      */
 338     static abstract class BaseAnalyzer extends TreeScanner {
 339 
 340         enum JumpKind {
 341             BREAK(JCTree.Tag.BREAK) {
 342                 @Override
 343                 JCTree getTarget(JCTree tree) {
 344                     return ((JCBreak)tree).target;
 345                 }
 346             },
 347             CONTINUE(JCTree.Tag.CONTINUE) {
 348                 @Override
 349                 JCTree getTarget(JCTree tree) {
 350                     return ((JCContinue)tree).target;
 351                 }
 352             },
 353             YIELD(JCTree.Tag.YIELD) {
 354                 @Override
 355                 JCTree getTarget(JCTree tree) {
 356                     return ((JCYield)tree).target;
 357                 }
 358             };
 359 
 360             final JCTree.Tag treeTag;
 361 
 362             private JumpKind(Tag treeTag) {
 363                 this.treeTag = treeTag;
 364             }
 365 
 366             abstract JCTree getTarget(JCTree tree);
 367         }
 368 
 369         /** The currently pending exits that go from current inner blocks
 370          *  to an enclosing block, in source order.
 371          */
 372         ListBuffer&lt;PendingExit&gt; pendingExits;
 373 
 374         /** A pending exit.  These are the statements return, break, and
 375          *  continue.  In addition, exception-throwing expressions or
 376          *  statements are put here when not known to be caught.  This
 377          *  will typically result in an error unless it is within a
 378          *  try-finally whose finally block cannot complete normally.
 379          */
 380         static class PendingExit {
 381             JCTree tree;
 382 
 383             PendingExit(JCTree tree) {
 384                 this.tree = tree;
 385             }
 386 
 387             void resolveJump() {
 388                 //do nothing
 389             }
 390         }
 391 
 392         abstract void markDead();
 393 
 394         /** Record an outward transfer of control. */
 395         void recordExit(PendingExit pe) {
 396             pendingExits.append(pe);
 397             markDead();
 398         }
 399 
 400         /** Resolve all jumps of this statement. */
 401         private Liveness resolveJump(JCTree tree,
 402                          ListBuffer&lt;PendingExit&gt; oldPendingExits,
 403                          JumpKind jk) {
 404             boolean resolved = false;
 405             List&lt;PendingExit&gt; exits = pendingExits.toList();
 406             pendingExits = oldPendingExits;
 407             for (; exits.nonEmpty(); exits = exits.tail) {
 408                 PendingExit exit = exits.head;
 409                 if (exit.tree.hasTag(jk.treeTag) &amp;&amp;
 410                         jk.getTarget(exit.tree) == tree) {
 411                     exit.resolveJump();
 412                     resolved = true;
 413                 } else {
 414                     pendingExits.append(exit);
 415                 }
 416             }
 417             return Liveness.from(resolved);
 418         }
 419 
 420         /** Resolve all continues of this statement. */
 421         Liveness resolveContinues(JCTree tree) {
 422             return resolveJump(tree, new ListBuffer&lt;PendingExit&gt;(), JumpKind.CONTINUE);
 423         }
 424 
 425         /** Resolve all breaks of this statement. */
 426         Liveness resolveBreaks(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 427             return resolveJump(tree, oldPendingExits, JumpKind.BREAK);
 428         }
 429 
 430         /** Resolve all yields of this statement. */
 431         Liveness resolveYields(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 432             return resolveJump(tree, oldPendingExits, JumpKind.YIELD);
 433         }
 434 
 435         @Override
 436         public void scan(JCTree tree) {
 437             if (tree != null &amp;&amp; (
 438                     tree.type == null ||
 439                     tree.type != Type.stuckType)) {
 440                 super.scan(tree);
 441             }
 442         }
 443 
 444         public void visitPackageDef(JCPackageDecl tree) {
 445             // Do nothing for PackageDecl
 446         }
 447 
 448         protected void scanSyntheticBreak(TreeMaker make, JCTree swtch) {
 449             if (swtch.hasTag(SWITCH_EXPRESSION)) {
 450                 JCYield brk = make.at(Position.NOPOS).Yield(null);
 451                 brk.target = swtch;
 452                 scan(brk);
 453             } else {
 454                 JCBreak brk = make.at(Position.NOPOS).Break(null);
 455                 brk.target = swtch;
 456                 scan(brk);
 457             }
 458         }
 459     }
 460 
 461     /**
 462      * This pass implements the first step of the dataflow analysis, namely
 463      * the liveness analysis check. This checks that every statement is reachable.
 464      * The output of this analysis pass are used by other analyzers. This analyzer
 465      * sets the &#39;finallyCanCompleteNormally&#39; field in the JCTry class.
 466      */
 467     class AliveAnalyzer extends BaseAnalyzer {
 468 
 469         /** A flag that indicates whether the last statement could
 470          *  complete normally.
 471          */
 472         private Liveness alive;
 473 
 474         @Override
 475         void markDead() {
 476             alive = Liveness.DEAD;
 477         }
 478 
 479     /*************************************************************************
 480      * Visitor methods for statements and definitions
 481      *************************************************************************/
 482 
 483         /** Analyze a definition.
 484          */
 485         void scanDef(JCTree tree) {
 486             scanStat(tree);
 487             if (tree != null &amp;&amp; tree.hasTag(JCTree.Tag.BLOCK) &amp;&amp; alive == Liveness.DEAD) {
 488                 log.error(tree.pos(),
 489                           Errors.InitializerMustBeAbleToCompleteNormally);
 490             }
 491         }
 492 
 493         /** Analyze a statement. Check that statement is reachable.
 494          */
 495         void scanStat(JCTree tree) {
 496             if (alive == Liveness.DEAD &amp;&amp; tree != null) {
 497                 log.error(tree.pos(), Errors.UnreachableStmt);
 498                 if (!tree.hasTag(SKIP)) alive = Liveness.RECOVERY;
 499             }
 500             scan(tree);
 501         }
 502 
 503         /** Analyze list of statements.
 504          */
 505         void scanStats(List&lt;? extends JCStatement&gt; trees) {
 506             if (trees != null)
 507                 for (List&lt;? extends JCStatement&gt; l = trees; l.nonEmpty(); l = l.tail)
 508                     scanStat(l.head);
 509         }
 510 
 511         /* ------------ Visitor methods for various sorts of trees -------------*/
 512 
 513         public void visitClassDef(JCClassDecl tree) {
 514             if (tree.sym == null) return;
 515             Liveness alivePrev = alive;
 516             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 517             Lint lintPrev = lint;
 518 
 519             pendingExits = new ListBuffer&lt;&gt;();
 520             lint = lint.augment(tree.sym);
 521 
 522             try {
 523                 // process all the static initializers
 524                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 525                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 526                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
 527                         scanDef(l.head);
 528                         clearPendingExits(false);
 529                     }
 530                 }
 531 
 532                 // process all the instance initializers
 533                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 534                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 535                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
 536                         scanDef(l.head);
 537                         clearPendingExits(false);
 538                     }
 539                 }
 540 
 541                 // process all the methods
 542                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 543                     if (l.head.hasTag(METHODDEF)) {
 544                         scan(l.head);
 545                     }
 546                 }
 547             } finally {
 548                 pendingExits = pendingExitsPrev;
 549                 alive = alivePrev;
 550                 lint = lintPrev;
 551             }
 552         }
 553 
 554         public void visitMethodDef(JCMethodDecl tree) {
 555             if (tree.body == null) return;
 556             Lint lintPrev = lint;
 557 
 558             lint = lint.augment(tree.sym);
 559 
 560             Assert.check(pendingExits.isEmpty());
 561 
 562             try {
 563                 alive = Liveness.ALIVE;
 564                 scanStat(tree.body);
 565                 tree.completesNormally = alive != Liveness.DEAD;
 566 
 567                 if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
 568                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 569 
 570                 clearPendingExits(true);
 571             } finally {
 572                 lint = lintPrev;
 573             }
 574         }
 575 
 576         private void clearPendingExits(boolean inMethod) {
 577             List&lt;PendingExit&gt; exits = pendingExits.toList();
 578             pendingExits = new ListBuffer&lt;&gt;();
 579             while (exits.nonEmpty()) {
 580                 PendingExit exit = exits.head;
 581                 exits = exits.tail;
 582                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
 583                                 log.hasErrorOn(exit.tree.pos()));
 584             }
 585         }
 586 
 587         public void visitVarDef(JCVariableDecl tree) {
 588             if (tree.init != null) {
 589                 Lint lintPrev = lint;
 590                 lint = lint.augment(tree.sym);
 591                 try{
 592                     scan(tree.init);
 593                 } finally {
 594                     lint = lintPrev;
 595                 }
 596             }
 597         }
 598 
 599         public void visitBlock(JCBlock tree) {
 600             scanStats(tree.stats);
 601         }
 602 
 603         public void visitDoLoop(JCDoWhileLoop tree) {
 604             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 605             pendingExits = new ListBuffer&lt;&gt;();
 606             scanStat(tree.body);
 607             alive = alive.or(resolveContinues(tree));
 608             scan(tree.cond);
 609             alive = alive.and(!tree.cond.type.isTrue());
 610             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 611         }
 612 
 613         public void visitWhileLoop(JCWhileLoop tree) {
 614             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 615             pendingExits = new ListBuffer&lt;&gt;();
 616             scan(tree.cond);
 617             alive = Liveness.from(!tree.cond.type.isFalse());
 618             scanStat(tree.body);
 619             alive = alive.or(resolveContinues(tree));
 620             alive = resolveBreaks(tree, prevPendingExits).or(
 621                 !tree.cond.type.isTrue());
 622         }
 623 
 624         public void visitForLoop(JCForLoop tree) {
 625             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 626             scanStats(tree.init);
 627             pendingExits = new ListBuffer&lt;&gt;();
 628             if (tree.cond != null) {
 629                 scan(tree.cond);
 630                 alive = Liveness.from(!tree.cond.type.isFalse());
 631             } else {
 632                 alive = Liveness.ALIVE;
 633             }
 634             scanStat(tree.body);
 635             alive = alive.or(resolveContinues(tree));
 636             scan(tree.step);
 637             alive = resolveBreaks(tree, prevPendingExits).or(
 638                 tree.cond != null &amp;&amp; !tree.cond.type.isTrue());
 639         }
 640 
 641         public void visitForeachLoop(JCEnhancedForLoop tree) {
 642             visitVarDef(tree.var);
 643             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 644             scan(tree.expr);
 645             pendingExits = new ListBuffer&lt;&gt;();
 646             scanStat(tree.body);
 647             alive = alive.or(resolveContinues(tree));
 648             resolveBreaks(tree, prevPendingExits);
 649             alive = Liveness.ALIVE;
 650         }
 651 
 652         public void visitLabelled(JCLabeledStatement tree) {
 653             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 654             pendingExits = new ListBuffer&lt;&gt;();
 655             scanStat(tree.body);
 656             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 657         }
 658 
 659         public void visitSwitch(JCSwitch tree) {
 660             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 661             pendingExits = new ListBuffer&lt;&gt;();
 662             scan(tree.selector);
 663             boolean hasDefault = false;
 664             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 665                 alive = Liveness.ALIVE;
 666                 JCCase c = l.head;
 667                 if (c.pats.isEmpty())
 668                     hasDefault = true;
 669                 else {
 670                     for (JCExpression pat : c.pats) {
 671                         scan(pat);
 672                     }
 673                 }
 674                 scanStats(c.stats);
 675                 c.completesNormally = alive != Liveness.DEAD;
 676                 if (alive != Liveness.DEAD &amp;&amp; c.caseKind == JCCase.RULE) {
 677                     scanSyntheticBreak(make, tree);
 678                     alive = Liveness.DEAD;
 679                 }
 680                 // Warn about fall-through if lint switch fallthrough enabled.
 681                 if (alive == Liveness.ALIVE &amp;&amp;
 682                     lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &amp;&amp;
 683                     c.stats.nonEmpty() &amp;&amp; l.tail.nonEmpty())
 684                     log.warning(Lint.LintCategory.FALLTHROUGH,
 685                                 l.tail.head.pos(),
 686                                 Warnings.PossibleFallThroughIntoCase);
 687             }
 688             if (!hasDefault) {
 689                 alive = Liveness.ALIVE;
 690             }
 691             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 692         }
 693 
 694         @Override
 695         public void visitSwitchExpression(JCSwitchExpression tree) {
 696             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 697             pendingExits = new ListBuffer&lt;&gt;();
 698             scan(tree.selector);
 699             Set&lt;Object&gt; constants = null;
 700             if ((tree.selector.type.tsym.flags() &amp; ENUM) != 0) {
 701                 constants = new HashSet&lt;&gt;();
 702                 for (Symbol s : tree.selector.type.tsym.members().getSymbols(s -&gt; (s.flags() &amp; ENUM) != 0)) {
 703                     constants.add(s.name);
 704                 }
 705             }
 706             boolean hasDefault = false;
 707             Liveness prevAlive = alive;
 708             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 709                 alive = Liveness.ALIVE;
 710                 JCCase c = l.head;
 711                 if (c.pats.isEmpty())
 712                     hasDefault = true;
 713                 else {
 714                     for (JCExpression pat : c.pats) {
 715                         scan(pat);
 716                         if (constants != null) {
 717                             if (pat.hasTag(IDENT))
 718                                 constants.remove(((JCIdent) pat).name);
 719                             if (pat.type != null)
 720                                 constants.remove(pat.type.constValue());
 721                         }
 722                     }
 723                 }
 724                 scanStats(c.stats);
 725                 if (alive == Liveness.ALIVE) {
 726                     if (c.caseKind == JCCase.RULE) {
 727                         log.error(TreeInfo.diagEndPos(c.body),
 728                                   Errors.RuleCompletesNormally);
 729                     } else if (l.tail.isEmpty()) {
 730                         log.error(TreeInfo.diagEndPos(tree),
 731                                   Errors.SwitchExpressionCompletesNormally);
 732                     }
 733                 }
 734                 c.completesNormally = alive != Liveness.DEAD;
 735             }
 736             if ((constants == null || !constants.isEmpty()) &amp;&amp; !hasDefault) {
 737                 log.error(tree, Errors.NotExhaustive);
 738             }
 739             alive = prevAlive;
 740             alive = alive.or(resolveYields(tree, prevPendingExits));
 741         }
 742 
 743         public void visitTry(JCTry tree) {
 744             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 745             pendingExits = new ListBuffer&lt;&gt;();
 746             for (JCTree resource : tree.resources) {
 747                 if (resource instanceof JCVariableDecl) {
 748                     JCVariableDecl vdecl = (JCVariableDecl) resource;
 749                     visitVarDef(vdecl);
 750                 } else if (resource instanceof JCExpression) {
 751                     scan((JCExpression) resource);
 752                 } else {
 753                     throw new AssertionError(tree);  // parser error
 754                 }
 755             }
 756 
 757             scanStat(tree.body);
 758             Liveness aliveEnd = alive;
 759 
 760             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
 761                 alive = Liveness.ALIVE;
 762                 JCVariableDecl param = l.head.param;
 763                 scan(param);
 764                 scanStat(l.head.body);
 765                 aliveEnd = aliveEnd.or(alive);
 766             }
 767             if (tree.finalizer != null) {
 768                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 769                 pendingExits = prevPendingExits;
 770                 alive = Liveness.ALIVE;
 771                 scanStat(tree.finalizer);
 772                 tree.finallyCanCompleteNormally = alive != Liveness.DEAD;
 773                 if (alive == Liveness.DEAD) {
 774                     if (lint.isEnabled(Lint.LintCategory.FINALLY)) {
 775                         log.warning(Lint.LintCategory.FINALLY,
 776                                 TreeInfo.diagEndPos(tree.finalizer),
 777                                 Warnings.FinallyCannotComplete);
 778                     }
 779                 } else {
 780                     while (exits.nonEmpty()) {
 781                         pendingExits.append(exits.next());
 782                     }
 783                     alive = aliveEnd;
 784                 }
 785             } else {
 786                 alive = aliveEnd;
 787                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 788                 pendingExits = prevPendingExits;
 789                 while (exits.nonEmpty()) pendingExits.append(exits.next());
 790             }
 791         }
 792 
 793         @Override
 794         public void visitIf(JCIf tree) {
 795             scan(tree.cond);
 796             scanStat(tree.thenpart);
 797             if (tree.elsepart != null) {
 798                 Liveness aliveAfterThen = alive;
 799                 alive = Liveness.ALIVE;
 800                 scanStat(tree.elsepart);
 801                 alive = alive.or(aliveAfterThen);
 802             } else {
 803                 alive = Liveness.ALIVE;
 804             }
 805         }
 806 
 807         public void visitBreak(JCBreak tree) {
 808             recordExit(new PendingExit(tree));
 809         }
 810 
 811         @Override
 812         public void visitYield(JCYield tree) {
 813             scan(tree.value);
 814             recordExit(new PendingExit(tree));
 815         }
 816 
 817         public void visitContinue(JCContinue tree) {
 818             recordExit(new PendingExit(tree));
 819         }
 820 
 821         public void visitReturn(JCReturn tree) {
 822             scan(tree.expr);
 823             recordExit(new PendingExit(tree));
 824         }
 825 
 826         public void visitThrow(JCThrow tree) {
 827             scan(tree.expr);
 828             markDead();
 829         }
 830 
 831         public void visitApply(JCMethodInvocation tree) {
 832             scan(tree.meth);
 833             scan(tree.args);
 834         }
 835 
 836         public void visitNewClass(JCNewClass tree) {
 837             scan(tree.encl);
 838             scan(tree.args);
 839             if (tree.def != null) {
 840                 scan(tree.def);
 841             }
 842         }
 843 
 844         @Override
 845         public void visitLambda(JCLambda tree) {
 846             if (tree.type != null &amp;&amp;
 847                     tree.type.isErroneous()) {
 848                 return;
 849             }
 850 
 851             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
 852             Liveness prevAlive = alive;
 853             try {
 854                 pendingExits = new ListBuffer&lt;&gt;();
 855                 alive = Liveness.ALIVE;
 856                 scanStat(tree.body);
 857                 tree.canCompleteNormally = alive != Liveness.DEAD;
 858             }
 859             finally {
 860                 pendingExits = prevPending;
 861                 alive = prevAlive;
 862             }
 863         }
 864 
 865         public void visitModuleDef(JCModuleDecl tree) {
 866             // Do nothing for modules
 867         }
 868 
 869     /**************************************************************************
 870      * main method
 871      *************************************************************************/
 872 
 873         /** Perform definite assignment/unassignment analysis on a tree.
 874          */
 875         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 876             analyzeTree(env, env.tree, make);
 877         }
 878         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
 879             try {
 880                 attrEnv = env;
 881                 Flow.this.make = make;
 882                 pendingExits = new ListBuffer&lt;&gt;();
 883                 alive = Liveness.ALIVE;
 884                 scan(tree);
 885             } finally {
 886                 pendingExits = null;
 887                 Flow.this.make = null;
 888             }
 889         }
 890     }
 891 
 892     /**
 893      * This pass implements the second step of the dataflow analysis, namely
 894      * the exception analysis. This is to ensure that every checked exception that is
 895      * thrown is declared or caught. The analyzer uses some info that has been set by
 896      * the liveliness analyzer.
 897      */
 898     class FlowAnalyzer extends BaseAnalyzer {
 899 
 900         /** A flag that indicates whether the last statement could
 901          *  complete normally.
 902          */
 903         HashMap&lt;Symbol, List&lt;Type&gt;&gt; preciseRethrowTypes;
 904 
 905         /** The current class being defined.
 906          */
 907         JCClassDecl classDef;
 908 
 909         /** The list of possibly thrown declarable exceptions.
 910          */
 911         List&lt;Type&gt; thrown;
 912 
 913         /** The list of exceptions that are either caught or declared to be
 914          *  thrown.
 915          */
 916         List&lt;Type&gt; caught;
 917 
 918         class ThrownPendingExit extends BaseAnalyzer.PendingExit {
 919 
 920             Type thrown;
 921 
 922             ThrownPendingExit(JCTree tree, Type thrown) {
 923                 super(tree);
 924                 this.thrown = thrown;
 925             }
 926         }
 927 
 928         @Override
 929         void markDead() {
 930             //do nothing
 931         }
 932 
 933         /*-------------------- Exceptions ----------------------*/
 934 
 935         /** Complain that pending exceptions are not caught.
 936          */
 937         void errorUncaught() {
 938             for (PendingExit exit = pendingExits.next();
 939                  exit != null;
 940                  exit = pendingExits.next()) {
 941                 if (exit instanceof ThrownPendingExit) {
 942                     ThrownPendingExit thrownExit = (ThrownPendingExit) exit;
 943                     if (classDef != null &amp;&amp;
 944                         classDef.pos == exit.tree.pos) {
 945                         log.error(exit.tree.pos(),
 946                                   Errors.UnreportedExceptionDefaultConstructor(thrownExit.thrown));
 947                     } else if (exit.tree.hasTag(VARDEF) &amp;&amp;
 948                             ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {
 949                         log.error(exit.tree.pos(),
 950                                   Errors.UnreportedExceptionImplicitClose(thrownExit.thrown,
 951                                                                           ((JCVariableDecl)exit.tree).sym.name));
 952                     } else {
 953                         log.error(exit.tree.pos(),
 954                                   Errors.UnreportedExceptionNeedToCatchOrThrow(thrownExit.thrown));
 955                     }
 956                 } else {
 957                     Assert.check(log.hasErrorOn(exit.tree.pos()));
 958                 }
 959             }
 960         }
 961 
 962         /** Record that exception is potentially thrown and check that it
 963          *  is caught.
 964          */
 965         void markThrown(JCTree tree, Type exc) {
 966             if (!chk.isUnchecked(tree.pos(), exc)) {
 967                 if (!chk.isHandled(exc, caught)) {
 968                     pendingExits.append(new ThrownPendingExit(tree, exc));
 969                 }
 970                 thrown = chk.incl(exc, thrown);
 971             }
 972         }
 973 
 974     /*************************************************************************
 975      * Visitor methods for statements and definitions
 976      *************************************************************************/
 977 
 978         /* ------------ Visitor methods for various sorts of trees -------------*/
 979 
 980         public void visitClassDef(JCClassDecl tree) {
 981             if (tree.sym == null) return;
 982 
 983             JCClassDecl classDefPrev = classDef;
 984             List&lt;Type&gt; thrownPrev = thrown;
 985             List&lt;Type&gt; caughtPrev = caught;
 986             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 987             Lint lintPrev = lint;
 988             boolean anonymousClass = tree.name == names.empty;
 989             pendingExits = new ListBuffer&lt;&gt;();
 990             if (!anonymousClass) {
 991                 caught = List.nil();
 992             }
 993             classDef = tree;
 994             thrown = List.nil();
 995             lint = lint.augment(tree.sym);
 996 
 997             try {
 998                 // process all the static initializers
 999                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1000                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
1001                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
1002                         scan(l.head);
1003                         errorUncaught();
1004                     }
1005                 }
1006 
1007                 // add intersection of all thrown clauses of initial constructors
1008                 // to set of caught exceptions, unless class is anonymous.
1009                 if (!anonymousClass) {
1010                     boolean firstConstructor = true;
1011                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1012                         if (TreeInfo.isInitialConstructor(l.head)) {
1013                             List&lt;Type&gt; mthrown =
1014                                 ((JCMethodDecl) l.head).sym.type.getThrownTypes();
1015                             if (firstConstructor) {
1016                                 caught = mthrown;
1017                                 firstConstructor = false;
1018                             } else {
1019                                 caught = chk.intersect(mthrown, caught);
1020                             }
1021                         }
1022                     }
1023                 }
1024 
1025                 // process all the instance initializers
1026                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1027                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
1028                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
1029                         scan(l.head);
1030                         errorUncaught();
1031                     }
1032                 }
1033 
1034                 // in an anonymous class, add the set of thrown exceptions to
1035                 // the throws clause of the synthetic constructor and propagate
1036                 // outwards.
1037                 // Changing the throws clause on the fly is okay here because
1038                 // the anonymous constructor can&#39;t be invoked anywhere else,
1039                 // and its type hasn&#39;t been cached.
1040                 if (anonymousClass) {
1041                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1042                         if (TreeInfo.isConstructor(l.head)) {
1043                             JCMethodDecl mdef = (JCMethodDecl)l.head;
1044                             scan(mdef);
1045                             mdef.thrown = make.Types(thrown);
1046                             mdef.sym.type = types.createMethodTypeWithThrown(mdef.sym.type, thrown);
1047                         }
1048                     }
1049                     thrownPrev = chk.union(thrown, thrownPrev);
1050                 }
1051 
1052                 // process all the methods
1053                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1054                     if (anonymousClass &amp;&amp; TreeInfo.isConstructor(l.head))
1055                         continue; // there can never be an uncaught exception.
1056                     if (l.head.hasTag(METHODDEF)) {
1057                         scan(l.head);
1058                         errorUncaught();
1059                     }
1060                 }
1061 
1062                 thrown = thrownPrev;
1063             } finally {
1064                 pendingExits = pendingExitsPrev;
1065                 caught = caughtPrev;
1066                 classDef = classDefPrev;
1067                 lint = lintPrev;
1068             }
1069         }
1070 
1071         public void visitMethodDef(JCMethodDecl tree) {
1072             if (tree.body == null) return;
1073 
1074             List&lt;Type&gt; caughtPrev = caught;
1075             List&lt;Type&gt; mthrown = tree.sym.type.getThrownTypes();
1076             Lint lintPrev = lint;
1077 
1078             lint = lint.augment(tree.sym);
1079 
1080             Assert.check(pendingExits.isEmpty());
1081 
1082             try {
1083                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1084                     JCVariableDecl def = l.head;
1085                     scan(def);
1086                 }
1087                 if (TreeInfo.isInitialConstructor(tree))
1088                     caught = chk.union(caught, mthrown);
1089                 else if ((tree.sym.flags() &amp; (BLOCK | STATIC)) != BLOCK)
1090                     caught = mthrown;
1091                 // else we are in an instance initializer block;
1092                 // leave caught unchanged.
1093 
1094                 scan(tree.body);
1095 
1096                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1097                 pendingExits = new ListBuffer&lt;&gt;();
1098                 while (exits.nonEmpty()) {
1099                     PendingExit exit = exits.head;
1100                     exits = exits.tail;
1101                     if (!(exit instanceof ThrownPendingExit)) {
1102                         Assert.check(exit.tree.hasTag(RETURN) ||
1103                                          log.hasErrorOn(exit.tree.pos()));
1104                     } else {
1105                         // uncaught throws will be reported later
1106                         pendingExits.append(exit);
1107                     }
1108                 }
1109             } finally {
1110                 caught = caughtPrev;
1111                 lint = lintPrev;
1112             }
1113         }
1114 
1115         public void visitVarDef(JCVariableDecl tree) {
1116             if (tree.init != null) {
1117                 Lint lintPrev = lint;
1118                 lint = lint.augment(tree.sym);
1119                 try{
1120                     scan(tree.init);
1121                 } finally {
1122                     lint = lintPrev;
1123                 }
1124             }
1125         }
1126 
1127         public void visitBlock(JCBlock tree) {
1128             scan(tree.stats);
1129         }
1130 
1131         public void visitDoLoop(JCDoWhileLoop tree) {
1132             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1133             pendingExits = new ListBuffer&lt;&gt;();
1134             scan(tree.body);
1135             resolveContinues(tree);
1136             scan(tree.cond);
1137             resolveBreaks(tree, prevPendingExits);
1138         }
1139 
1140         public void visitWhileLoop(JCWhileLoop tree) {
1141             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1142             pendingExits = new ListBuffer&lt;&gt;();
1143             scan(tree.cond);
1144             scan(tree.body);
1145             resolveContinues(tree);
1146             resolveBreaks(tree, prevPendingExits);
1147         }
1148 
1149         public void visitForLoop(JCForLoop tree) {
1150             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1151             scan(tree.init);
1152             pendingExits = new ListBuffer&lt;&gt;();
1153             if (tree.cond != null) {
1154                 scan(tree.cond);
1155             }
1156             scan(tree.body);
1157             resolveContinues(tree);
1158             scan(tree.step);
1159             resolveBreaks(tree, prevPendingExits);
1160         }
1161 
1162         public void visitForeachLoop(JCEnhancedForLoop tree) {
1163             visitVarDef(tree.var);
1164             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1165             scan(tree.expr);
1166             pendingExits = new ListBuffer&lt;&gt;();
1167             scan(tree.body);
1168             resolveContinues(tree);
1169             resolveBreaks(tree, prevPendingExits);
1170         }
1171 
1172         public void visitLabelled(JCLabeledStatement tree) {
1173             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1174             pendingExits = new ListBuffer&lt;&gt;();
1175             scan(tree.body);
1176             resolveBreaks(tree, prevPendingExits);
1177         }
1178 
1179         public void visitSwitch(JCSwitch tree) {
1180             handleSwitch(tree, tree.selector, tree.cases);
1181         }
1182 
1183         @Override
1184         public void visitSwitchExpression(JCSwitchExpression tree) {
1185             handleSwitch(tree, tree.selector, tree.cases);
1186         }
1187 
1188         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
1189             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1190             pendingExits = new ListBuffer&lt;&gt;();
1191             scan(selector);
1192             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1193                 JCCase c = l.head;
1194                 scan(c.pats);
1195                 scan(c.stats);
1196             }
1197             if (tree.hasTag(SWITCH_EXPRESSION)) {
1198                 resolveYields(tree, prevPendingExits);
1199             } else {
1200                 resolveBreaks(tree, prevPendingExits);
1201             }
1202         }
1203 
1204         public void visitTry(JCTry tree) {
1205             List&lt;Type&gt; caughtPrev = caught;
1206             List&lt;Type&gt; thrownPrev = thrown;
1207             thrown = List.nil();
1208             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1209                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1210                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1211                         List.of(l.head.param.vartype);
1212                 for (JCExpression ct : subClauses) {
1213                     caught = chk.incl(ct.type, caught);
1214                 }
1215             }
1216 
1217             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1218             pendingExits = new ListBuffer&lt;&gt;();
1219             for (JCTree resource : tree.resources) {
1220                 if (resource instanceof JCVariableDecl) {
1221                     JCVariableDecl vdecl = (JCVariableDecl) resource;
1222                     visitVarDef(vdecl);
1223                 } else if (resource instanceof JCExpression) {
1224                     scan((JCExpression) resource);
1225                 } else {
1226                     throw new AssertionError(tree);  // parser error
1227                 }
1228             }
1229             for (JCTree resource : tree.resources) {
1230                 List&lt;Type&gt; closeableSupertypes = resource.type.isCompound() ?
1231                     types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
1232                     List.of(resource.type);
1233                 for (Type sup : closeableSupertypes) {
<a name="2" id="anc2"></a><span class="line-modified">1234                     if (types.asSuper(sup, syms.autoCloseableType.tsym) != null) {</span>
1235                         Symbol closeMethod = rs.resolveQualifiedMethod(tree,
1236                                 attrEnv,
1237                                 types.skipTypeVars(sup, false),
1238                                 names.close,
1239                                 List.nil(),
1240                                 List.nil());
1241                         Type mt = types.memberType(resource.type, closeMethod);
1242                         if (closeMethod.kind == MTH) {
1243                             for (Type t : mt.getThrownTypes()) {
1244                                 markThrown(resource, t);
1245                             }
1246                         }
1247                     }
1248                 }
1249             }
1250             scan(tree.body);
1251             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1252             thrown = thrownPrev;
1253             caught = caughtPrev;
1254 
1255             List&lt;Type&gt; caughtInTry = List.nil();
1256             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1257                 JCVariableDecl param = l.head.param;
1258                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1259                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1260                         List.of(l.head.param.vartype);
1261                 List&lt;Type&gt; ctypes = List.nil();
1262                 List&lt;Type&gt; rethrownTypes = chk.diff(thrownInTry, caughtInTry);
1263                 for (JCExpression ct : subClauses) {
1264                     Type exc = ct.type;
1265                     if (exc != syms.unknownType) {
1266                         ctypes = ctypes.append(exc);
1267                         if (types.isSameType(exc, syms.objectType))
1268                             continue;
1269                         checkCaughtType(l.head.pos(), exc, thrownInTry, caughtInTry);
1270                         caughtInTry = chk.incl(exc, caughtInTry);
1271                     }
1272                 }
1273                 scan(param);
1274                 preciseRethrowTypes.put(param.sym, chk.intersect(ctypes, rethrownTypes));
1275                 scan(l.head.body);
1276                 preciseRethrowTypes.remove(param.sym);
1277             }
1278             if (tree.finalizer != null) {
1279                 List&lt;Type&gt; savedThrown = thrown;
1280                 thrown = List.nil();
1281                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1282                 pendingExits = prevPendingExits;
1283                 scan(tree.finalizer);
1284                 if (!tree.finallyCanCompleteNormally) {
1285                     // discard exits and exceptions from try and finally
1286                     thrown = chk.union(thrown, thrownPrev);
1287                 } else {
1288                     thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1289                     thrown = chk.union(thrown, savedThrown);
1290                     // FIX: this doesn&#39;t preserve source order of exits in catch
1291                     // versus finally!
1292                     while (exits.nonEmpty()) {
1293                         pendingExits.append(exits.next());
1294                     }
1295                 }
1296             } else {
1297                 thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1298                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1299                 pendingExits = prevPendingExits;
1300                 while (exits.nonEmpty()) pendingExits.append(exits.next());
1301             }
1302         }
1303 
1304         @Override
1305         public void visitIf(JCIf tree) {
1306             scan(tree.cond);
1307             scan(tree.thenpart);
1308             if (tree.elsepart != null) {
1309                 scan(tree.elsepart);
1310             }
1311         }
1312 
1313         void checkCaughtType(DiagnosticPosition pos, Type exc, List&lt;Type&gt; thrownInTry, List&lt;Type&gt; caughtInTry) {
1314             if (chk.subset(exc, caughtInTry)) {
1315                 log.error(pos, Errors.ExceptAlreadyCaught(exc));
1316             } else if (!chk.isUnchecked(pos, exc) &amp;&amp;
1317                     !isExceptionOrThrowable(exc) &amp;&amp;
1318                     !chk.intersects(exc, thrownInTry)) {
1319                 log.error(pos, Errors.ExceptNeverThrownInTry(exc));
1320             } else {
1321                 List&lt;Type&gt; catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
1322                 // &#39;catchableThrownTypes&#39; cannot possibly be empty - if &#39;exc&#39; was an
1323                 // unchecked exception, the result list would not be empty, as the augmented
1324                 // thrown set includes { RuntimeException, Error }; if &#39;exc&#39; was a checked
1325                 // exception, that would have been covered in the branch above
1326                 if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &amp;&amp;
1327                         !isExceptionOrThrowable(exc)) {
1328                     Warning key = catchableThrownTypes.length() == 1 ?
1329                             Warnings.UnreachableCatch(catchableThrownTypes) :
1330                             Warnings.UnreachableCatch1(catchableThrownTypes);
1331                     log.warning(pos, key);
1332                 }
1333             }
1334         }
1335         //where
1336             private boolean isExceptionOrThrowable(Type exc) {
1337                 return exc.tsym == syms.throwableType.tsym ||
1338                     exc.tsym == syms.exceptionType.tsym;
1339             }
1340 
1341         public void visitBreak(JCBreak tree) {
1342             recordExit(new PendingExit(tree));
1343         }
1344 
1345         public void visitYield(JCYield tree) {
1346             scan(tree.value);
1347             recordExit(new PendingExit(tree));
1348         }
1349 
1350         public void visitContinue(JCContinue tree) {
1351             recordExit(new PendingExit(tree));
1352         }
1353 
1354         public void visitReturn(JCReturn tree) {
1355             scan(tree.expr);
1356             recordExit(new PendingExit(tree));
1357         }
1358 
1359         public void visitThrow(JCThrow tree) {
1360             scan(tree.expr);
1361             Symbol sym = TreeInfo.symbol(tree.expr);
1362             if (sym != null &amp;&amp;
1363                 sym.kind == VAR &amp;&amp;
1364                 (sym.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) != 0 &amp;&amp;
1365                 preciseRethrowTypes.get(sym) != null) {
1366                 for (Type t : preciseRethrowTypes.get(sym)) {
1367                     markThrown(tree, t);
1368                 }
1369             }
1370             else {
1371                 markThrown(tree, tree.expr.type);
1372             }
1373             markDead();
1374         }
1375 
1376         public void visitApply(JCMethodInvocation tree) {
1377             scan(tree.meth);
1378             scan(tree.args);
1379             for (List&lt;Type&gt; l = tree.meth.type.getThrownTypes(); l.nonEmpty(); l = l.tail)
1380                 markThrown(tree, l.head);
1381         }
1382 
1383         public void visitNewClass(JCNewClass tree) {
1384             scan(tree.encl);
1385             scan(tree.args);
1386            // scan(tree.def);
1387             for (List&lt;Type&gt; l = tree.constructorType.getThrownTypes();
1388                  l.nonEmpty();
1389                  l = l.tail) {
1390                 markThrown(tree, l.head);
1391             }
1392             List&lt;Type&gt; caughtPrev = caught;
1393             try {
1394                 // If the new class expression defines an anonymous class,
1395                 // analysis of the anonymous constructor may encounter thrown
1396                 // types which are unsubstituted type variables.
1397                 // However, since the constructor&#39;s actual thrown types have
1398                 // already been marked as thrown, it is safe to simply include
1399                 // each of the constructor&#39;s formal thrown types in the set of
1400                 // &#39;caught/declared to be thrown&#39; types, for the duration of
1401                 // the class def analysis.
1402                 if (tree.def != null)
1403                     for (List&lt;Type&gt; l = tree.constructor.type.getThrownTypes();
1404                          l.nonEmpty();
1405                          l = l.tail) {
1406                         caught = chk.incl(l.head, caught);
1407                     }
1408                 scan(tree.def);
1409             }
1410             finally {
1411                 caught = caughtPrev;
1412             }
1413         }
1414 
1415         @Override
1416         public void visitLambda(JCLambda tree) {
1417             if (tree.type != null &amp;&amp;
1418                     tree.type.isErroneous()) {
1419                 return;
1420             }
1421             List&lt;Type&gt; prevCaught = caught;
1422             List&lt;Type&gt; prevThrown = thrown;
1423             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1424             try {
1425                 pendingExits = new ListBuffer&lt;&gt;();
1426                 caught = tree.getDescriptorType(types).getThrownTypes();
1427                 thrown = List.nil();
1428                 scan(tree.body);
1429                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1430                 pendingExits = new ListBuffer&lt;&gt;();
1431                 while (exits.nonEmpty()) {
1432                     PendingExit exit = exits.head;
1433                     exits = exits.tail;
1434                     if (!(exit instanceof ThrownPendingExit)) {
1435                         Assert.check(exit.tree.hasTag(RETURN) ||
1436                                         log.hasErrorOn(exit.tree.pos()));
1437                     } else {
1438                         // uncaught throws will be reported later
1439                         pendingExits.append(exit);
1440                     }
1441                 }
1442 
1443                 errorUncaught();
1444             } finally {
1445                 pendingExits = prevPending;
1446                 caught = prevCaught;
1447                 thrown = prevThrown;
1448             }
1449         }
1450 
1451         public void visitModuleDef(JCModuleDecl tree) {
1452             // Do nothing for modules
1453         }
1454 
1455     /**************************************************************************
1456      * main method
1457      *************************************************************************/
1458 
1459         /** Perform definite assignment/unassignment analysis on a tree.
1460          */
1461         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
1462             analyzeTree(env, env.tree, make);
1463         }
1464         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
1465             try {
1466                 attrEnv = env;
1467                 Flow.this.make = make;
1468                 pendingExits = new ListBuffer&lt;&gt;();
1469                 preciseRethrowTypes = new HashMap&lt;&gt;();
1470                 this.thrown = this.caught = null;
1471                 this.classDef = null;
1472                 scan(tree);
1473             } finally {
1474                 pendingExits = null;
1475                 Flow.this.make = null;
1476                 this.thrown = this.caught = null;
1477                 this.classDef = null;
1478             }
1479         }
1480     }
1481 
1482     /**
1483      * Specialized pass that performs reachability analysis on a lambda
1484      */
1485     class LambdaAliveAnalyzer extends AliveAnalyzer {
1486 
1487         boolean inLambda;
1488 
1489         @Override
1490         public void visitReturn(JCReturn tree) {
1491             //ignore lambda return expression (which might not even be attributed)
1492             recordExit(new PendingExit(tree));
1493         }
1494 
1495         @Override
1496         public void visitLambda(JCLambda tree) {
1497             if (inLambda || tree.getBodyKind() == BodyKind.EXPRESSION) {
1498                 return;
1499             }
1500             inLambda = true;
1501             try {
1502                 super.visitLambda(tree);
1503             } finally {
1504                 inLambda = false;
1505             }
1506         }
1507 
1508         @Override
1509         public void visitClassDef(JCClassDecl tree) {
1510             //skip
1511         }
1512     }
1513 
1514     /**
1515      * Determine if alive after the given tree.
1516      */
1517     class SnippetAliveAnalyzer extends AliveAnalyzer {
1518         @Override
1519         public void visitClassDef(JCClassDecl tree) {
1520             //skip
1521         }
1522         public boolean isAlive() {
1523             return super.alive != Liveness.DEAD;
1524         }
1525     }
1526 
1527     class SnippetBreakAnalyzer extends AliveAnalyzer {
1528         private final Set&lt;JCTree&gt; seenTrees = new HashSet&lt;&gt;();
1529         private boolean breaksOut;
1530 
1531         public SnippetBreakAnalyzer() {
1532         }
1533 
1534         @Override
1535         public void visitLabelled(JCTree.JCLabeledStatement tree) {
1536             seenTrees.add(tree);
1537             super.visitLabelled(tree);
1538         }
1539 
1540         @Override
1541         public void visitWhileLoop(JCTree.JCWhileLoop tree) {
1542             seenTrees.add(tree);
1543             super.visitWhileLoop(tree);
1544         }
1545 
1546         @Override
1547         public void visitForLoop(JCTree.JCForLoop tree) {
1548             seenTrees.add(tree);
1549             super.visitForLoop(tree);
1550         }
1551 
1552         @Override
1553         public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {
1554             seenTrees.add(tree);
1555             super.visitForeachLoop(tree);
1556         }
1557 
1558         @Override
1559         public void visitDoLoop(JCTree.JCDoWhileLoop tree) {
1560             seenTrees.add(tree);
1561             super.visitDoLoop(tree);
1562         }
1563 
1564         @Override
1565         public void visitBreak(JCBreak tree) {
1566             breaksOut |= (super.alive == Liveness.ALIVE &amp;&amp;
1567                           !seenTrees.contains(tree.target));
1568             super.visitBreak(tree);
1569         }
1570 
1571         public boolean breaksOut() {
1572             return breaksOut;
1573         }
1574     }
1575 
1576     /**
1577      * Specialized pass that performs DA/DU on a lambda
1578      */
1579     class LambdaAssignAnalyzer extends AssignAnalyzer {
1580         WriteableScope enclosedSymbols;
1581         boolean inLambda;
1582 
1583         LambdaAssignAnalyzer(Env&lt;AttrContext&gt; env) {
1584             enclosedSymbols = WriteableScope.create(env.enclClass.sym);
1585         }
1586 
1587         @Override
1588         public void visitLambda(JCLambda tree) {
1589             if (inLambda) {
1590                 return;
1591             }
1592             inLambda = true;
1593             try {
1594                 super.visitLambda(tree);
1595             } finally {
1596                 inLambda = false;
1597             }
1598         }
1599 
1600         @Override
1601         public void visitVarDef(JCVariableDecl tree) {
1602             enclosedSymbols.enter(tree.sym);
1603             super.visitVarDef(tree);
1604         }
1605         @Override
1606         protected boolean trackable(VarSymbol sym) {
1607             return enclosedSymbols.includes(sym) &amp;&amp;
1608                    sym.owner.kind == MTH;
1609         }
1610 
1611         @Override
1612         public void visitClassDef(JCClassDecl tree) {
1613             //skip
1614         }
1615     }
1616 
1617     /**
1618      * Specialized pass that performs inference of thrown types for lambdas.
1619      */
1620     class LambdaFlowAnalyzer extends FlowAnalyzer {
1621         List&lt;Type&gt; inferredThrownTypes;
1622         boolean inLambda;
1623         @Override
1624         public void visitLambda(JCLambda tree) {
1625             if ((tree.type != null &amp;&amp;
1626                     tree.type.isErroneous()) || inLambda) {
1627                 return;
1628             }
1629             List&lt;Type&gt; prevCaught = caught;
1630             List&lt;Type&gt; prevThrown = thrown;
1631             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1632             inLambda = true;
1633             try {
1634                 pendingExits = new ListBuffer&lt;&gt;();
1635                 caught = List.of(syms.throwableType);
1636                 thrown = List.nil();
1637                 scan(tree.body);
1638                 inferredThrownTypes = thrown;
1639             } finally {
1640                 pendingExits = prevPending;
1641                 caught = prevCaught;
1642                 thrown = prevThrown;
1643                 inLambda = false;
1644             }
1645         }
1646         @Override
1647         public void visitClassDef(JCClassDecl tree) {
1648             //skip
1649         }
1650     }
1651 
<a name="3" id="anc3"></a>








1652     /**
1653      * This pass implements (i) definite assignment analysis, which ensures that
1654      * each variable is assigned when used and (ii) definite unassignment analysis,
1655      * which ensures that no final variable is assigned more than once. This visitor
1656      * depends on the results of the liveliness analyzer. This pass is also used to mark
1657      * effectively-final local variables/parameters.
1658      */
1659 
1660     public class AssignAnalyzer extends BaseAnalyzer {
1661 
1662         /** The set of definitely assigned variables.
1663          */
1664         final Bits inits;
1665 
1666         /** The set of definitely unassigned variables.
1667          */
1668         final Bits uninits;
1669 
1670         /** The set of variables that are definitely unassigned everywhere
1671          *  in current try block. This variable is maintained lazily; it is
1672          *  updated only when something gets removed from uninits,
1673          *  typically by being assigned in reachable code.  To obtain the
1674          *  correct set of variables which are definitely unassigned
1675          *  anywhere in current try block, intersect uninitsTry and
1676          *  uninits.
1677          */
1678         final Bits uninitsTry;
1679 
1680         /** When analyzing a condition, inits and uninits are null.
1681          *  Instead we have:
1682          */
1683         final Bits initsWhenTrue;
1684         final Bits initsWhenFalse;
1685         final Bits uninitsWhenTrue;
1686         final Bits uninitsWhenFalse;
1687 
1688         /** A mapping from addresses to variable symbols.
1689          */
1690         protected JCVariableDecl[] vardecls;
1691 
1692         /** The current class being defined.
1693          */
1694         JCClassDecl classDef;
1695 
1696         /** The first variable sequence number in this class definition.
1697          */
1698         int firstadr;
1699 
1700         /** The next available variable sequence number.
1701          */
1702         protected int nextadr;
1703 
1704         /** The first variable sequence number in a block that can return.
1705          */
1706         protected int returnadr;
1707 
1708         /** The list of unreferenced automatic resources.
1709          */
1710         WriteableScope unrefdResources;
1711 
1712         /** Modified when processing a loop body the second time for DU analysis. */
1713         FlowKind flowKind = FlowKind.NORMAL;
1714 
1715         /** The starting position of the analyzed tree */
1716         int startPos;
1717 
1718         public class AssignPendingExit extends BaseAnalyzer.PendingExit {
1719 
1720             final Bits inits;
1721             final Bits uninits;
1722             final Bits exit_inits = new Bits(true);
1723             final Bits exit_uninits = new Bits(true);
1724 
1725             public AssignPendingExit(JCTree tree, final Bits inits, final Bits uninits) {
1726                 super(tree);
1727                 this.inits = inits;
1728                 this.uninits = uninits;
1729                 this.exit_inits.assign(inits);
1730                 this.exit_uninits.assign(uninits);
1731             }
1732 
1733             @Override
1734             public void resolveJump() {
1735                 inits.andSet(exit_inits);
1736                 uninits.andSet(exit_uninits);
1737             }
1738         }
1739 
<a name="4" id="anc4"></a>


1740         public AssignAnalyzer() {
1741             this.inits = new Bits();
1742             uninits = new Bits();
1743             uninitsTry = new Bits();
1744             initsWhenTrue = new Bits(true);
1745             initsWhenFalse = new Bits(true);
1746             uninitsWhenTrue = new Bits(true);
1747             uninitsWhenFalse = new Bits(true);
1748         }
1749 
1750         private boolean isInitialConstructor = false;
1751 
1752         @Override
1753         protected void markDead() {
1754             if (!isInitialConstructor) {
1755                 inits.inclRange(returnadr, nextadr);
1756             } else {
1757                 for (int address = returnadr; address &lt; nextadr; address++) {
1758                     if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {
1759                         inits.incl(address);
1760                     }
1761                 }
1762             }
1763             uninits.inclRange(returnadr, nextadr);
1764         }
1765 
1766         /*-------------- Processing variables ----------------------*/
1767 
1768         /** Do we need to track init/uninit state of this symbol?
1769          *  I.e. is symbol either a local or a blank final variable?
1770          */
1771         protected boolean trackable(VarSymbol sym) {
1772             return
1773                 sym.pos &gt;= startPos &amp;&amp;
1774                 ((sym.owner.kind == MTH || sym.owner.kind == VAR ||
1775                 isFinalUninitializedField(sym)));
1776         }
1777 
1778         boolean isFinalUninitializedField(VarSymbol sym) {
1779             return sym.owner.kind == TYP &amp;&amp;
1780                    ((sym.flags() &amp; (FINAL | HASINIT | PARAMETER)) == FINAL &amp;&amp;
1781                    classDef.sym.isEnclosedBy((ClassSymbol)sym.owner));
1782         }
1783 
1784         boolean isFinalUninitializedStaticField(VarSymbol sym) {
1785             return isFinalUninitializedField(sym) &amp;&amp; sym.isStatic();
1786         }
1787 
1788         /** Initialize new trackable variable by setting its address field
1789          *  to the next available sequence number and entering it under that
1790          *  index into the vars array.
1791          */
1792         void newVar(JCVariableDecl varDecl) {
1793             VarSymbol sym = varDecl.sym;
1794             vardecls = ArrayUtils.ensureCapacity(vardecls, nextadr);
1795             if ((sym.flags() &amp; FINAL) == 0) {
1796                 sym.flags_field |= EFFECTIVELY_FINAL;
1797             }
1798             sym.adr = nextadr;
1799             vardecls[nextadr] = varDecl;
1800             inits.excl(nextadr);
1801             uninits.incl(nextadr);
1802             nextadr++;
1803         }
1804 
1805         /** Record an initialization of a trackable variable.
1806          */
1807         void letInit(DiagnosticPosition pos, VarSymbol sym) {
1808             if (sym.adr &gt;= firstadr &amp;&amp; trackable(sym)) {
1809                 if ((sym.flags() &amp; EFFECTIVELY_FINAL) != 0) {
1810                     if (!uninits.isMember(sym.adr)) {
1811                         //assignment targeting an effectively final variable
1812                         //makes the variable lose its status of effectively final
1813                         //if the variable is _not_ definitively unassigned
1814                         sym.flags_field &amp;= ~EFFECTIVELY_FINAL;
1815                     } else {
1816                         uninit(sym);
1817                     }
1818                 }
1819                 else if ((sym.flags() &amp; FINAL) != 0) {
1820                     if ((sym.flags() &amp; PARAMETER) != 0) {
1821                         if ((sym.flags() &amp; UNION) != 0) { //multi-catch parameter
1822                             log.error(pos, Errors.MulticatchParameterMayNotBeAssigned(sym));
1823                         }
1824                         else {
1825                             log.error(pos,
1826                                       Errors.FinalParameterMayNotBeAssigned(sym));
1827                         }
1828                     } else if (!uninits.isMember(sym.adr)) {
1829                         log.error(pos, diags.errorKey(flowKind.errKey, sym));
1830                     } else {
1831                         uninit(sym);
1832                     }
1833                 }
1834                 inits.incl(sym.adr);
1835             } else if ((sym.flags() &amp; FINAL) != 0) {
1836                 log.error(pos, Errors.VarMightAlreadyBeAssigned(sym));
1837             }
1838         }
1839         //where
1840             void uninit(VarSymbol sym) {
1841                 if (!inits.isMember(sym.adr)) {
1842                     // reachable assignment
1843                     uninits.excl(sym.adr);
1844                     uninitsTry.excl(sym.adr);
1845                 } else {
1846                     //log.rawWarning(pos, &quot;unreachable assignment&quot;);//DEBUG
1847                     uninits.excl(sym.adr);
1848                 }
1849             }
1850 
1851         /** If tree is either a simple name or of the form this.name or
1852          *  C.this.name, and tree represents a trackable variable,
1853          *  record an initialization of the variable.
1854          */
1855         void letInit(JCTree tree) {
1856             tree = TreeInfo.skipParens(tree);
1857             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1858                 Symbol sym = TreeInfo.symbol(tree);
1859                 if (sym.kind == VAR) {
1860                     letInit(tree.pos(), (VarSymbol)sym);
1861                 }
1862             }
1863         }
1864 
<a name="5" id="anc5"></a>























1865         /** Check that trackable variable is initialized.
1866          */
1867         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1868             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1869         }
1870 
1871         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1872             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1873                 trackable(sym) &amp;&amp;
1874                 !inits.isMember(sym.adr)) {
1875                     log.error(pos, errkey);
1876                 inits.incl(sym.adr);
1877             }
1878         }
1879 
1880         /** Utility method to reset several Bits instances.
1881          */
1882         private void resetBits(Bits... bits) {
1883             for (Bits b : bits) {
1884                 b.reset();
1885             }
1886         }
1887 
1888         /** Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
1889          */
1890         void split(boolean setToNull) {
1891             initsWhenFalse.assign(inits);
1892             uninitsWhenFalse.assign(uninits);
1893             initsWhenTrue.assign(inits);
1894             uninitsWhenTrue.assign(uninits);
1895             if (setToNull) {
1896                 resetBits(inits, uninits);
1897             }
1898         }
1899 
1900         /** Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.
1901          */
1902         protected void merge() {
1903             inits.assign(initsWhenFalse.andSet(initsWhenTrue));
1904             uninits.assign(uninitsWhenFalse.andSet(uninitsWhenTrue));
1905         }
1906 
1907     /* ************************************************************************
1908      * Visitor methods for statements and definitions
1909      *************************************************************************/
1910 
1911         /** Analyze an expression. Make sure to set (un)inits rather than
1912          *  (un)initsWhenTrue(WhenFalse) on exit.
1913          */
1914         void scanExpr(JCTree tree) {
1915             if (tree != null) {
1916                 scan(tree);
1917                 if (inits.isReset()) {
1918                     merge();
1919                 }
1920             }
1921         }
1922 
1923         /** Analyze a list of expressions.
1924          */
1925         void scanExprs(List&lt;? extends JCExpression&gt; trees) {
1926             if (trees != null)
1927                 for (List&lt;? extends JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
1928                     scanExpr(l.head);
1929         }
1930 
1931         /** Analyze a condition. Make sure to set (un)initsWhenTrue(WhenFalse)
1932          *  rather than (un)inits on exit.
1933          */
1934         void scanCond(JCTree tree) {
1935             if (tree.type.isFalse()) {
1936                 if (inits.isReset()) merge();
1937                 initsWhenTrue.assign(inits);
1938                 initsWhenTrue.inclRange(firstadr, nextadr);
1939                 uninitsWhenTrue.assign(uninits);
1940                 uninitsWhenTrue.inclRange(firstadr, nextadr);
1941                 initsWhenFalse.assign(inits);
1942                 uninitsWhenFalse.assign(uninits);
1943             } else if (tree.type.isTrue()) {
1944                 if (inits.isReset()) merge();
1945                 initsWhenFalse.assign(inits);
1946                 initsWhenFalse.inclRange(firstadr, nextadr);
1947                 uninitsWhenFalse.assign(uninits);
1948                 uninitsWhenFalse.inclRange(firstadr, nextadr);
1949                 initsWhenTrue.assign(inits);
1950                 uninitsWhenTrue.assign(uninits);
1951             } else {
1952                 scan(tree);
1953                 if (!inits.isReset())
1954                     split(tree.type != syms.unknownType);
1955             }
1956             if (tree.type != syms.unknownType) {
1957                 resetBits(inits, uninits);
1958             }
1959         }
1960 
1961         /* ------------ Visitor methods for various sorts of trees -------------*/
1962 
1963         public void visitClassDef(JCClassDecl tree) {
1964             if (tree.sym == null) {
1965                 return;
1966             }
1967 
1968             Lint lintPrev = lint;
1969             lint = lint.augment(tree.sym);
1970             try {
1971                 if (tree.sym == null) {
1972                     return;
1973                 }
1974 
1975                 JCClassDecl classDefPrev = classDef;
1976                 int firstadrPrev = firstadr;
1977                 int nextadrPrev = nextadr;
1978                 ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
1979 
1980                 pendingExits = new ListBuffer&lt;&gt;();
1981                 if (tree.name != names.empty) {
1982                     firstadr = nextadr;
1983                 }
1984                 classDef = tree;
1985                 try {
1986                     // define all the static fields
1987                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1988                         if (l.head.hasTag(VARDEF)) {
1989                             JCVariableDecl def = (JCVariableDecl)l.head;
1990                             if ((def.mods.flags &amp; STATIC) != 0) {
1991                                 VarSymbol sym = def.sym;
1992                                 if (trackable(sym)) {
1993                                     newVar(def);
1994                                 }
1995                             }
1996                         }
1997                     }
1998 
1999                     // process all the static initializers
2000                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2001                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2002                             (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
2003                             scan(l.head);
2004                             clearPendingExits(false);
2005                         }
2006                     }
2007 
2008                     // define all the instance fields
2009                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2010                         if (l.head.hasTag(VARDEF)) {
2011                             JCVariableDecl def = (JCVariableDecl)l.head;
2012                             if ((def.mods.flags &amp; STATIC) == 0) {
2013                                 VarSymbol sym = def.sym;
2014                                 if (trackable(sym)) {
2015                                     newVar(def);
2016                                 }
2017                             }
2018                         }
2019                     }
2020 
2021                     // process all the instance initializers
2022                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2023                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2024                             (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
2025                             scan(l.head);
2026                             clearPendingExits(false);
2027                         }
2028                     }
2029 
2030                     // process all the methods
2031                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2032                         if (l.head.hasTag(METHODDEF)) {
2033                             scan(l.head);
2034                         }
2035                     }
2036                 } finally {
2037                     pendingExits = pendingExitsPrev;
2038                     nextadr = nextadrPrev;
2039                     firstadr = firstadrPrev;
2040                     classDef = classDefPrev;
2041                 }
2042             } finally {
2043                 lint = lintPrev;
2044             }
2045         }
2046 
2047         public void visitMethodDef(JCMethodDecl tree) {
2048             if (tree.body == null) {
2049                 return;
2050             }
2051 
2052             /*  MemberEnter can generate synthetic methods ignore them
2053              */
2054             if ((tree.sym.flags() &amp; SYNTHETIC) != 0) {
2055                 return;
2056             }
2057 
2058             Lint lintPrev = lint;
2059             lint = lint.augment(tree.sym);
<a name="6" id="anc6"></a>
2060             try {
2061                 if (tree.body == null) {
2062                     return;
2063                 }
2064                 /*  Ignore synthetic methods, except for translated lambda methods.
2065                  */
2066                 if ((tree.sym.flags() &amp; (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {
2067                     return;
2068                 }
2069 
2070                 final Bits initsPrev = new Bits(inits);
2071                 final Bits uninitsPrev = new Bits(uninits);
2072                 int nextadrPrev = nextadr;
2073                 int firstadrPrev = firstadr;
2074                 int returnadrPrev = returnadr;
2075 
2076                 Assert.check(pendingExits.isEmpty());
2077                 boolean lastInitialConstructor = isInitialConstructor;
2078                 try {
2079                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2080 
2081                     if (!isInitialConstructor) {
2082                         firstadr = nextadr;
<a name="7" id="anc7"></a>







2083                     }
2084                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2085                         JCVariableDecl def = l.head;
2086                         scan(def);
2087                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2088                         /*  If we are executing the code from Gen, then there can be
2089                          *  synthetic or mandated variables, ignore them.
2090                          */
2091                         initParam(def);
2092                     }
2093                     // else we are in an instance initializer block;
2094                     // leave caught unchanged.
2095                     scan(tree.body);
2096 
2097                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;
2098                     if (isInitialConstructor) {
2099                         boolean isSynthesized = (tree.sym.flags() &amp;
2100                                                  GENERATEDCONSTR) != 0;
2101                         for (int i = firstadr; i &lt; nextadr; i++) {
2102                             JCVariableDecl vardecl = vardecls[i];
2103                             VarSymbol var = vardecl.sym;
2104                             if (var.owner == classDef.sym) {
2105                                 // choose the diagnostic position based on whether
2106                                 // the ctor is default(synthesized) or not
2107                                 if (isSynthesized &amp;&amp; !isCompactConstructor) {
2108                                     checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),
2109                                             var, Errors.VarNotInitializedInDefaultConstructor(var));
2110                                 } else if (isCompactConstructor) {
2111                                     boolean isInstanceRecordField = var.enclClass().isRecord() &amp;&amp;
2112                                             (var.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
2113                                             !var.isStatic() &amp;&amp;
2114                                             var.owner.kind == TYP;
2115                                     if (isInstanceRecordField) {
2116                                         boolean notInitialized = !inits.isMember(var.adr);
2117                                         if (notInitialized &amp;&amp; uninits.isMember(var.adr) &amp;&amp; tree.completesNormally) {
2118                                         /*  this way we indicate Lower that it should generate an initialization for this field
2119                                          *  in the compact constructor
2120                                          */
2121                                             var.flags_field |= UNINITIALIZED_FIELD;
2122                                         } else {
2123                                             checkInit(TreeInfo.diagEndPos(tree.body), var);
2124                                         }
2125                                     } else {
2126                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2127                                     }
2128                                 } else {
2129                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2130                                 }
2131                             }
2132                         }
2133                     }
2134                     clearPendingExits(true);
2135                 } finally {
2136                     inits.assign(initsPrev);
2137                     uninits.assign(uninitsPrev);
2138                     nextadr = nextadrPrev;
2139                     firstadr = firstadrPrev;
2140                     returnadr = returnadrPrev;
2141                     isInitialConstructor = lastInitialConstructor;
2142                 }
2143             } finally {
2144                 lint = lintPrev;
<a name="8" id="anc8"></a>
2145             }
2146         }
2147 
2148         private void clearPendingExits(boolean inMethod) {
2149             List&lt;PendingExit&gt; exits = pendingExits.toList();
2150             pendingExits = new ListBuffer&lt;&gt;();
2151             while (exits.nonEmpty()) {
2152                 PendingExit exit = exits.head;
2153                 exits = exits.tail;
2154                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
2155                                  log.hasErrorOn(exit.tree.pos()),
2156                              exit.tree);
2157                 if (inMethod &amp;&amp; isInitialConstructor) {
2158                     Assert.check(exit instanceof AssignPendingExit);
2159                     inits.assign(((AssignPendingExit) exit).exit_inits);
2160                     for (int i = firstadr; i &lt; nextadr; i++) {
2161                         checkInit(exit.tree.pos(), vardecls[i].sym);
2162                     }
2163                 }
2164             }
2165         }
2166         protected void initParam(JCVariableDecl def) {
2167             inits.incl(def.sym.adr);
2168             uninits.excl(def.sym.adr);
2169         }
2170 
2171         public void visitVarDef(JCVariableDecl tree) {
2172             Lint lintPrev = lint;
2173             lint = lint.augment(tree.sym);
2174             try{
2175                 boolean track = trackable(tree.sym);
2176                 if (track &amp;&amp; (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {
2177                     newVar(tree);
2178                 }
2179                 if (tree.init != null) {
2180                     scanExpr(tree.init);
2181                     if (track) {
2182                         letInit(tree.pos(), tree.sym);
2183                     }
2184                 }
2185             } finally {
2186                 lint = lintPrev;
2187             }
2188         }
2189 
2190         public void visitBlock(JCBlock tree) {
2191             int nextadrPrev = nextadr;
2192             scan(tree.stats);
2193             nextadr = nextadrPrev;
2194         }
2195 
2196         public void visitDoLoop(JCDoWhileLoop tree) {
2197             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2198             FlowKind prevFlowKind = flowKind;
2199             flowKind = FlowKind.NORMAL;
2200             final Bits initsSkip = new Bits(true);
2201             final Bits uninitsSkip = new Bits(true);
2202             pendingExits = new ListBuffer&lt;&gt;();
2203             int prevErrors = log.nerrors;
2204             do {
2205                 final Bits uninitsEntry = new Bits(uninits);
2206                 uninitsEntry.excludeFrom(nextadr);
2207                 scan(tree.body);
2208                 resolveContinues(tree);
2209                 scanCond(tree.cond);
2210                 if (!flowKind.isFinal()) {
2211                     initsSkip.assign(initsWhenFalse);
2212                     uninitsSkip.assign(uninitsWhenFalse);
2213                 }
2214                 if (log.nerrors !=  prevErrors ||
2215                     flowKind.isFinal() ||
2216                     new Bits(uninitsEntry).diffSet(uninitsWhenTrue).nextBit(firstadr)==-1)
2217                     break;
2218                 inits.assign(initsWhenTrue);
2219                 uninits.assign(uninitsEntry.andSet(uninitsWhenTrue));
2220                 flowKind = FlowKind.SPECULATIVE_LOOP;
2221             } while (true);
2222             flowKind = prevFlowKind;
2223             inits.assign(initsSkip);
2224             uninits.assign(uninitsSkip);
2225             resolveBreaks(tree, prevPendingExits);
2226         }
2227 
2228         public void visitWhileLoop(JCWhileLoop tree) {
2229             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2230             FlowKind prevFlowKind = flowKind;
2231             flowKind = FlowKind.NORMAL;
2232             final Bits initsSkip = new Bits(true);
2233             final Bits uninitsSkip = new Bits(true);
2234             pendingExits = new ListBuffer&lt;&gt;();
2235             int prevErrors = log.nerrors;
2236             final Bits uninitsEntry = new Bits(uninits);
2237             uninitsEntry.excludeFrom(nextadr);
2238             do {
2239                 scanCond(tree.cond);
2240                 if (!flowKind.isFinal()) {
2241                     initsSkip.assign(initsWhenFalse) ;
2242                     uninitsSkip.assign(uninitsWhenFalse);
2243                 }
2244                 inits.assign(initsWhenTrue);
2245                 uninits.assign(uninitsWhenTrue);
2246                 scan(tree.body);
2247                 resolveContinues(tree);
2248                 if (log.nerrors != prevErrors ||
2249                     flowKind.isFinal() ||
2250                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1) {
2251                     break;
2252                 }
2253                 uninits.assign(uninitsEntry.andSet(uninits));
2254                 flowKind = FlowKind.SPECULATIVE_LOOP;
2255             } while (true);
2256             flowKind = prevFlowKind;
2257             //a variable is DA/DU after the while statement, if it&#39;s DA/DU assuming the
2258             //branch is not taken AND if it&#39;s DA/DU before any break statement
2259             inits.assign(initsSkip);
2260             uninits.assign(uninitsSkip);
2261             resolveBreaks(tree, prevPendingExits);
2262         }
2263 
2264         public void visitForLoop(JCForLoop tree) {
2265             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2266             FlowKind prevFlowKind = flowKind;
2267             flowKind = FlowKind.NORMAL;
2268             int nextadrPrev = nextadr;
2269             scan(tree.init);
2270             final Bits initsSkip = new Bits(true);
2271             final Bits uninitsSkip = new Bits(true);
2272             pendingExits = new ListBuffer&lt;&gt;();
2273             int prevErrors = log.nerrors;
2274             do {
2275                 final Bits uninitsEntry = new Bits(uninits);
2276                 uninitsEntry.excludeFrom(nextadr);
2277                 if (tree.cond != null) {
2278                     scanCond(tree.cond);
2279                     if (!flowKind.isFinal()) {
2280                         initsSkip.assign(initsWhenFalse);
2281                         uninitsSkip.assign(uninitsWhenFalse);
2282                     }
2283                     inits.assign(initsWhenTrue);
2284                     uninits.assign(uninitsWhenTrue);
2285                 } else if (!flowKind.isFinal()) {
2286                     initsSkip.assign(inits);
2287                     initsSkip.inclRange(firstadr, nextadr);
2288                     uninitsSkip.assign(uninits);
2289                     uninitsSkip.inclRange(firstadr, nextadr);
2290                 }
2291                 scan(tree.body);
2292                 resolveContinues(tree);
2293                 scan(tree.step);
2294                 if (log.nerrors != prevErrors ||
2295                     flowKind.isFinal() ||
2296                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2297                     break;
2298                 uninits.assign(uninitsEntry.andSet(uninits));
2299                 flowKind = FlowKind.SPECULATIVE_LOOP;
2300             } while (true);
2301             flowKind = prevFlowKind;
2302             //a variable is DA/DU after a for loop, if it&#39;s DA/DU assuming the
2303             //branch is not taken AND if it&#39;s DA/DU before any break statement
2304             inits.assign(initsSkip);
2305             uninits.assign(uninitsSkip);
2306             resolveBreaks(tree, prevPendingExits);
2307             nextadr = nextadrPrev;
2308         }
2309 
2310         public void visitForeachLoop(JCEnhancedForLoop tree) {
2311             visitVarDef(tree.var);
2312 
2313             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2314             FlowKind prevFlowKind = flowKind;
2315             flowKind = FlowKind.NORMAL;
2316             int nextadrPrev = nextadr;
2317             scan(tree.expr);
2318             final Bits initsStart = new Bits(inits);
2319             final Bits uninitsStart = new Bits(uninits);
2320 
2321             letInit(tree.pos(), tree.var.sym);
2322             pendingExits = new ListBuffer&lt;&gt;();
2323             int prevErrors = log.nerrors;
2324             do {
2325                 final Bits uninitsEntry = new Bits(uninits);
2326                 uninitsEntry.excludeFrom(nextadr);
2327                 scan(tree.body);
2328                 resolveContinues(tree);
2329                 if (log.nerrors != prevErrors ||
2330                     flowKind.isFinal() ||
2331                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2332                     break;
2333                 uninits.assign(uninitsEntry.andSet(uninits));
2334                 flowKind = FlowKind.SPECULATIVE_LOOP;
2335             } while (true);
2336             flowKind = prevFlowKind;
2337             inits.assign(initsStart);
2338             uninits.assign(uninitsStart.andSet(uninits));
2339             resolveBreaks(tree, prevPendingExits);
2340             nextadr = nextadrPrev;
2341         }
2342 
2343         public void visitLabelled(JCLabeledStatement tree) {
2344             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2345             pendingExits = new ListBuffer&lt;&gt;();
2346             scan(tree.body);
2347             resolveBreaks(tree, prevPendingExits);
2348         }
2349 
2350         public void visitSwitch(JCSwitch tree) {
2351             handleSwitch(tree, tree.selector, tree.cases);
2352         }
2353 
2354         public void visitSwitchExpression(JCSwitchExpression tree) {
2355             handleSwitch(tree, tree.selector, tree.cases);
2356         }
2357 
2358         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
2359             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2360             pendingExits = new ListBuffer&lt;&gt;();
2361             int nextadrPrev = nextadr;
2362             scanExpr(selector);
2363             final Bits initsSwitch = new Bits(inits);
2364             final Bits uninitsSwitch = new Bits(uninits);
2365             boolean hasDefault = false;
2366             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
2367                 inits.assign(initsSwitch);
2368                 uninits.assign(uninits.andSet(uninitsSwitch));
2369                 JCCase c = l.head;
2370                 if (c.pats.isEmpty()) {
2371                     hasDefault = true;
2372                 } else {
2373                     for (JCExpression pat : c.pats) {
2374                         scanExpr(pat);
2375                     }
2376                 }
2377                 if (hasDefault) {
2378                     inits.assign(initsSwitch);
2379                     uninits.assign(uninits.andSet(uninitsSwitch));
2380                 }
2381                 scan(c.stats);
2382                 if (c.completesNormally &amp;&amp; c.caseKind == JCCase.RULE) {
2383                     scanSyntheticBreak(make, tree);
2384                 }
2385                 addVars(c.stats, initsSwitch, uninitsSwitch);
2386                 if (!hasDefault) {
2387                     inits.assign(initsSwitch);
2388                     uninits.assign(uninits.andSet(uninitsSwitch));
2389                 }
2390                 // Warn about fall-through if lint switch fallthrough enabled.
2391             }
2392             if (!hasDefault) {
2393                 if (tree.hasTag(SWITCH_EXPRESSION)) {
2394                     markDead();
2395                 } else {
2396                     inits.andSet(initsSwitch);
2397                 }
2398             }
2399             if (tree.hasTag(SWITCH_EXPRESSION)) {
2400                 resolveYields(tree, prevPendingExits);
2401             } else {
2402                 resolveBreaks(tree, prevPendingExits);
2403             }
2404             nextadr = nextadrPrev;
2405         }
2406         // where
2407             /** Add any variables defined in stats to inits and uninits. */
2408             private void addVars(List&lt;JCStatement&gt; stats, final Bits inits,
2409                                         final Bits uninits) {
2410                 for (;stats.nonEmpty(); stats = stats.tail) {
2411                     JCTree stat = stats.head;
2412                     if (stat.hasTag(VARDEF)) {
2413                         int adr = ((JCVariableDecl) stat).sym.adr;
2414                         inits.excl(adr);
2415                         uninits.incl(adr);
2416                     }
2417                 }
2418             }
2419 
2420         public void visitTry(JCTry tree) {
2421             ListBuffer&lt;JCVariableDecl&gt; resourceVarDecls = new ListBuffer&lt;&gt;();
2422             final Bits uninitsTryPrev = new Bits(uninitsTry);
2423             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2424             pendingExits = new ListBuffer&lt;&gt;();
2425             final Bits initsTry = new Bits(inits);
2426             uninitsTry.assign(uninits);
2427             for (JCTree resource : tree.resources) {
2428                 if (resource instanceof JCVariableDecl) {
2429                     JCVariableDecl vdecl = (JCVariableDecl) resource;
2430                     visitVarDef(vdecl);
2431                     unrefdResources.enter(vdecl.sym);
2432                     resourceVarDecls.append(vdecl);
2433                 } else if (resource instanceof JCExpression) {
2434                     scanExpr((JCExpression) resource);
2435                 } else {
2436                     throw new AssertionError(tree);  // parser error
2437                 }
2438             }
2439             scan(tree.body);
2440             uninitsTry.andSet(uninits);
2441             final Bits initsEnd = new Bits(inits);
2442             final Bits uninitsEnd = new Bits(uninits);
2443             int nextadrCatch = nextadr;
2444 
2445             if (!resourceVarDecls.isEmpty() &amp;&amp;
2446                     lint.isEnabled(Lint.LintCategory.TRY)) {
2447                 for (JCVariableDecl resVar : resourceVarDecls) {
2448                     if (unrefdResources.includes(resVar.sym)) {
2449                         log.warning(Lint.LintCategory.TRY, resVar.pos(),
2450                                     Warnings.TryResourceNotReferenced(resVar.sym));
2451                         unrefdResources.remove(resVar.sym);
2452                     }
2453                 }
2454             }
2455 
2456             /*  The analysis of each catch should be independent.
2457              *  Each one should have the same initial values of inits and
2458              *  uninits.
2459              */
2460             final Bits initsCatchPrev = new Bits(initsTry);
2461             final Bits uninitsCatchPrev = new Bits(uninitsTry);
2462 
2463             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
2464                 JCVariableDecl param = l.head.param;
2465                 inits.assign(initsCatchPrev);
2466                 uninits.assign(uninitsCatchPrev);
2467                 scan(param);
2468                 /* If this is a TWR and we are executing the code from Gen,
2469                  * then there can be synthetic variables, ignore them.
2470                  */
2471                 initParam(param);
2472                 scan(l.head.body);
2473                 initsEnd.andSet(inits);
2474                 uninitsEnd.andSet(uninits);
2475                 nextadr = nextadrCatch;
2476             }
2477             if (tree.finalizer != null) {
2478                 inits.assign(initsTry);
2479                 uninits.assign(uninitsTry);
2480                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2481                 pendingExits = prevPendingExits;
2482                 scan(tree.finalizer);
2483                 if (!tree.finallyCanCompleteNormally) {
2484                     // discard exits and exceptions from try and finally
2485                 } else {
2486                     uninits.andSet(uninitsEnd);
2487                     // FIX: this doesn&#39;t preserve source order of exits in catch
2488                     // versus finally!
2489                     while (exits.nonEmpty()) {
2490                         PendingExit exit = exits.next();
2491                         if (exit instanceof AssignPendingExit) {
2492                             ((AssignPendingExit) exit).exit_inits.orSet(inits);
2493                             ((AssignPendingExit) exit).exit_uninits.andSet(uninits);
2494                         }
2495                         pendingExits.append(exit);
2496                     }
2497                     inits.orSet(initsEnd);
2498                 }
2499             } else {
2500                 inits.assign(initsEnd);
2501                 uninits.assign(uninitsEnd);
2502                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2503                 pendingExits = prevPendingExits;
2504                 while (exits.nonEmpty()) pendingExits.append(exits.next());
2505             }
2506             uninitsTry.andSet(uninitsTryPrev).andSet(uninits);
2507         }
2508 
2509         public void visitConditional(JCConditional tree) {
2510             scanCond(tree.cond);
2511             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2512             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2513             inits.assign(initsWhenTrue);
2514             uninits.assign(uninitsWhenTrue);
2515             if (tree.truepart.type.hasTag(BOOLEAN) &amp;&amp;
2516                 tree.falsepart.type.hasTag(BOOLEAN)) {
2517                 // if b and c are boolean valued, then
2518                 // v is (un)assigned after a?b:c when true iff
2519                 //    v is (un)assigned after b when true and
2520                 //    v is (un)assigned after c when true
2521                 scanCond(tree.truepart);
2522                 final Bits initsAfterThenWhenTrue = new Bits(initsWhenTrue);
2523                 final Bits initsAfterThenWhenFalse = new Bits(initsWhenFalse);
2524                 final Bits uninitsAfterThenWhenTrue = new Bits(uninitsWhenTrue);
2525                 final Bits uninitsAfterThenWhenFalse = new Bits(uninitsWhenFalse);
2526                 inits.assign(initsBeforeElse);
2527                 uninits.assign(uninitsBeforeElse);
2528                 scanCond(tree.falsepart);
2529                 initsWhenTrue.andSet(initsAfterThenWhenTrue);
2530                 initsWhenFalse.andSet(initsAfterThenWhenFalse);
2531                 uninitsWhenTrue.andSet(uninitsAfterThenWhenTrue);
2532                 uninitsWhenFalse.andSet(uninitsAfterThenWhenFalse);
2533             } else {
2534                 scanExpr(tree.truepart);
2535                 final Bits initsAfterThen = new Bits(inits);
2536                 final Bits uninitsAfterThen = new Bits(uninits);
2537                 inits.assign(initsBeforeElse);
2538                 uninits.assign(uninitsBeforeElse);
2539                 scanExpr(tree.falsepart);
2540                 inits.andSet(initsAfterThen);
2541                 uninits.andSet(uninitsAfterThen);
2542             }
2543         }
2544 
2545         public void visitIf(JCIf tree) {
2546             scanCond(tree.cond);
2547             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2548             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2549             inits.assign(initsWhenTrue);
2550             uninits.assign(uninitsWhenTrue);
2551             scan(tree.thenpart);
2552             if (tree.elsepart != null) {
2553                 final Bits initsAfterThen = new Bits(inits);
2554                 final Bits uninitsAfterThen = new Bits(uninits);
2555                 inits.assign(initsBeforeElse);
2556                 uninits.assign(uninitsBeforeElse);
2557                 scan(tree.elsepart);
2558                 inits.andSet(initsAfterThen);
2559                 uninits.andSet(uninitsAfterThen);
2560             } else {
2561                 inits.andSet(initsBeforeElse);
2562                 uninits.andSet(uninitsBeforeElse);
2563             }
2564         }
2565 
2566         @Override
2567         public void visitBreak(JCBreak tree) {
2568             recordExit(new AssignPendingExit(tree, inits, uninits));
2569         }
2570 
2571         @Override
2572         public void visitYield(JCYield tree) {
2573             JCSwitchExpression expr = (JCSwitchExpression) tree.target;
2574             if (expr != null &amp;&amp; expr.type.hasTag(BOOLEAN)) {
2575                 scanCond(tree.value);
2576                 Bits initsAfterBreakWhenTrue = new Bits(initsWhenTrue);
2577                 Bits initsAfterBreakWhenFalse = new Bits(initsWhenFalse);
2578                 Bits uninitsAfterBreakWhenTrue = new Bits(uninitsWhenTrue);
2579                 Bits uninitsAfterBreakWhenFalse = new Bits(uninitsWhenFalse);
2580                 PendingExit exit = new PendingExit(tree) {
2581                     @Override
2582                     void resolveJump() {
2583                         if (!inits.isReset()) {
2584                             split(true);
2585                         }
2586                         initsWhenTrue.andSet(initsAfterBreakWhenTrue);
2587                         initsWhenFalse.andSet(initsAfterBreakWhenFalse);
2588                         uninitsWhenTrue.andSet(uninitsAfterBreakWhenTrue);
2589                         uninitsWhenFalse.andSet(uninitsAfterBreakWhenFalse);
2590                     }
2591                 };
2592                 merge();
2593                 recordExit(exit);
2594                 return ;
2595             } else {
2596                 scanExpr(tree.value);
2597                 recordExit(new AssignPendingExit(tree, inits, uninits));
2598             }
2599         }
2600 
2601         @Override
2602         public void visitContinue(JCContinue tree) {
2603             recordExit(new AssignPendingExit(tree, inits, uninits));
2604         }
2605 
2606         @Override
2607         public void visitReturn(JCReturn tree) {
2608             scanExpr(tree.expr);
2609             recordExit(new AssignPendingExit(tree, inits, uninits));
2610         }
2611 
2612         public void visitThrow(JCThrow tree) {
2613             scanExpr(tree.expr);
2614             markDead();
2615         }
2616 
2617         public void visitApply(JCMethodInvocation tree) {
2618             scanExpr(tree.meth);
2619             scanExprs(tree.args);
<a name="9" id="anc9"></a>




2620         }
2621 
2622         public void visitNewClass(JCNewClass tree) {
2623             scanExpr(tree.encl);
2624             scanExprs(tree.args);
2625             scan(tree.def);
<a name="10" id="anc10"></a>





2626         }
2627 
2628         @Override
2629         public void visitLambda(JCLambda tree) {
2630             final Bits prevUninits = new Bits(uninits);
2631             final Bits prevInits = new Bits(inits);
2632             int returnadrPrev = returnadr;
2633             int nextadrPrev = nextadr;
2634             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
2635             try {
2636                 returnadr = nextadr;
2637                 pendingExits = new ListBuffer&lt;&gt;();
2638                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2639                     JCVariableDecl def = l.head;
2640                     scan(def);
2641                     inits.incl(def.sym.adr);
2642                     uninits.excl(def.sym.adr);
2643                 }
2644                 if (tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2645                     scanExpr(tree.body);
2646                 } else {
2647                     scan(tree.body);
2648                 }
2649             }
2650             finally {
2651                 returnadr = returnadrPrev;
2652                 uninits.assign(prevUninits);
2653                 inits.assign(prevInits);
2654                 pendingExits = prevPending;
2655                 nextadr = nextadrPrev;
2656             }
2657         }
2658 
2659         public void visitNewArray(JCNewArray tree) {
2660             scanExprs(tree.dims);
2661             scanExprs(tree.elems);
2662         }
2663 
2664         public void visitAssert(JCAssert tree) {
2665             final Bits initsExit = new Bits(inits);
2666             final Bits uninitsExit = new Bits(uninits);
2667             scanCond(tree.cond);
2668             uninitsExit.andSet(uninitsWhenTrue);
2669             if (tree.detail != null) {
2670                 inits.assign(initsWhenFalse);
2671                 uninits.assign(uninitsWhenFalse);
2672                 scanExpr(tree.detail);
2673             }
2674             inits.assign(initsExit);
2675             uninits.assign(uninitsExit);
2676         }
2677 
2678         public void visitAssign(JCAssign tree) {
2679             if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))
2680                 scanExpr(tree.lhs);
2681             scanExpr(tree.rhs);
2682             letInit(tree.lhs);
2683         }
2684 
2685         // check fields accessed through this.&lt;field&gt; are definitely
2686         // assigned before reading their value
2687         public void visitSelect(JCFieldAccess tree) {
<a name="11" id="anc11"></a><span class="line-modified">2688             super.visitSelect(tree);</span>







2689             if (TreeInfo.isThisQualifier(tree.selected) &amp;&amp;
2690                 tree.sym.kind == VAR) {
<a name="12" id="anc12"></a><span class="line-modified">2691                 checkInit(tree.pos(), (VarSymbol)tree.sym);</span>



2692             }
2693         }
2694 
2695         public void visitAssignop(JCAssignOp tree) {
2696             scanExpr(tree.lhs);
2697             scanExpr(tree.rhs);
2698             letInit(tree.lhs);
2699         }
2700 
2701         public void visitUnary(JCUnary tree) {
2702             switch (tree.getTag()) {
2703             case NOT:
2704                 scanCond(tree.arg);
2705                 final Bits t = new Bits(initsWhenFalse);
2706                 initsWhenFalse.assign(initsWhenTrue);
2707                 initsWhenTrue.assign(t);
2708                 t.assign(uninitsWhenFalse);
2709                 uninitsWhenFalse.assign(uninitsWhenTrue);
2710                 uninitsWhenTrue.assign(t);
2711                 break;
2712             case PREINC: case POSTINC:
2713             case PREDEC: case POSTDEC:
2714                 scanExpr(tree.arg);
2715                 letInit(tree.arg);
2716                 break;
2717             default:
2718                 scanExpr(tree.arg);
2719             }
2720         }
2721 
2722         public void visitBinary(JCBinary tree) {
2723             switch (tree.getTag()) {
2724             case AND:
2725                 scanCond(tree.lhs);
2726                 final Bits initsWhenFalseLeft = new Bits(initsWhenFalse);
2727                 final Bits uninitsWhenFalseLeft = new Bits(uninitsWhenFalse);
2728                 inits.assign(initsWhenTrue);
2729                 uninits.assign(uninitsWhenTrue);
2730                 scanCond(tree.rhs);
2731                 initsWhenFalse.andSet(initsWhenFalseLeft);
2732                 uninitsWhenFalse.andSet(uninitsWhenFalseLeft);
2733                 break;
2734             case OR:
2735                 scanCond(tree.lhs);
2736                 final Bits initsWhenTrueLeft = new Bits(initsWhenTrue);
2737                 final Bits uninitsWhenTrueLeft = new Bits(uninitsWhenTrue);
2738                 inits.assign(initsWhenFalse);
2739                 uninits.assign(uninitsWhenFalse);
2740                 scanCond(tree.rhs);
2741                 initsWhenTrue.andSet(initsWhenTrueLeft);
2742                 uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
2743                 break;
2744             default:
2745                 scanExpr(tree.lhs);
2746                 scanExpr(tree.rhs);
2747             }
2748         }
2749 
2750         public void visitIdent(JCIdent tree) {
2751             if (tree.sym.kind == VAR) {
2752                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2753                 referenced(tree.sym);
2754             }
<a name="13" id="anc13"></a>


2755         }
2756 
2757         void referenced(Symbol sym) {
2758             unrefdResources.remove(sym);
2759         }
2760 
2761         public void visitAnnotatedType(JCAnnotatedType tree) {
2762             // annotations don&#39;t get scanned
2763             tree.underlyingType.accept(this);
2764         }
2765 
2766         public void visitModuleDef(JCModuleDecl tree) {
2767             // Do nothing for modules
2768         }
2769 
2770     /**************************************************************************
2771      * main method
2772      *************************************************************************/
2773 
2774         /** Perform definite assignment/unassignment analysis on a tree.
2775          */
2776         public void analyzeTree(Env&lt;?&gt; env, TreeMaker make) {
2777             analyzeTree(env, env.tree, make);
2778          }
2779 
2780         public void analyzeTree(Env&lt;?&gt; env, JCTree tree, TreeMaker make) {
2781             try {
2782                 startPos = tree.pos().getStartPosition();
2783 
2784                 if (vardecls == null)
2785                     vardecls = new JCVariableDecl[32];
2786                 else
2787                     for (int i=0; i&lt;vardecls.length; i++)
2788                         vardecls[i] = null;
2789                 firstadr = 0;
2790                 nextadr = 0;
2791                 Flow.this.make = make;
2792                 pendingExits = new ListBuffer&lt;&gt;();
2793                 this.classDef = null;
2794                 unrefdResources = WriteableScope.create(env.enclClass.sym);
2795                 scan(tree);
2796             } finally {
2797                 // note that recursive invocations of this method fail hard
2798                 startPos = -1;
2799                 resetBits(inits, uninits, uninitsTry, initsWhenTrue,
2800                         initsWhenFalse, uninitsWhenTrue, uninitsWhenFalse);
2801                 if (vardecls != null) {
2802                     for (int i=0; i&lt;vardecls.length; i++)
2803                         vardecls[i] = null;
2804                 }
2805                 firstadr = 0;
2806                 nextadr = 0;
2807                 Flow.this.make = null;
2808                 pendingExits = null;
2809                 this.classDef = null;
2810                 unrefdResources = null;
2811             }
2812         }
2813     }
2814 
2815     /**
2816      * This pass implements the last step of the dataflow analysis, namely
2817      * the effectively-final analysis check. This checks that every local variable
2818      * reference from a lambda body/local inner class is either final or effectively final.
2819      * Additional this also checks that every variable that is used as an operand to
2820      * try-with-resources is final or effectively final.
2821      * As effectively final variables are marked as such during DA/DU, this pass must run after
2822      * AssignAnalyzer.
2823      */
2824     class CaptureAnalyzer extends BaseAnalyzer {
2825 
2826         JCTree currentTree; //local class or lambda
2827 
2828         @Override
2829         void markDead() {
2830             //do nothing
2831         }
2832 
2833         @SuppressWarnings(&quot;fallthrough&quot;)
2834         void checkEffectivelyFinal(DiagnosticPosition pos, VarSymbol sym) {
2835             if (currentTree != null &amp;&amp;
2836                     sym.owner.kind == MTH &amp;&amp;
2837                     sym.pos &lt; currentTree.getStartPosition()) {
2838                 switch (currentTree.getTag()) {
2839                     case CLASSDEF:
2840                         if (!allowEffectivelyFinalInInnerClasses) {
2841                             if ((sym.flags() &amp; FINAL) == 0) {
2842                                 reportInnerClsNeedsFinalError(pos, sym);
2843                             }
2844                             break;
2845                         }
2846                     case LAMBDA:
2847                         if ((sym.flags() &amp; (EFFECTIVELY_FINAL | FINAL)) == 0) {
2848                            reportEffectivelyFinalError(pos, sym);
2849                         }
2850                 }
2851             }
2852         }
2853 
2854         @SuppressWarnings(&quot;fallthrough&quot;)
2855         void letInit(JCTree tree) {
2856             tree = TreeInfo.skipParens(tree);
2857             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
2858                 Symbol sym = TreeInfo.symbol(tree);
2859                 if (currentTree != null &amp;&amp;
2860                         sym.kind == VAR &amp;&amp;
2861                         sym.owner.kind == MTH &amp;&amp;
2862                         ((VarSymbol)sym).pos &lt; currentTree.getStartPosition()) {
2863                     switch (currentTree.getTag()) {
2864                         case CLASSDEF:
2865                             if (!allowEffectivelyFinalInInnerClasses) {
2866                                 reportInnerClsNeedsFinalError(tree, sym);
2867                                 break;
2868                             }
2869                         case LAMBDA:
2870                             reportEffectivelyFinalError(tree, sym);
2871                     }
2872                 }
2873             }
2874         }
2875 
2876         void reportEffectivelyFinalError(DiagnosticPosition pos, Symbol sym) {
2877             String subKey = currentTree.hasTag(LAMBDA) ?
2878                   &quot;lambda&quot;  : &quot;inner.cls&quot;;
2879             log.error(pos, Errors.CantRefNonEffectivelyFinalVar(sym, diags.fragment(subKey)));
2880         }
2881 
2882         void reportInnerClsNeedsFinalError(DiagnosticPosition pos, Symbol sym) {
2883             log.error(pos,
2884                       Errors.LocalVarAccessedFromIclsNeedsFinal(sym));
2885         }
2886 
2887     /*************************************************************************
2888      * Visitor methods for statements and definitions
2889      *************************************************************************/
2890 
2891         /* ------------ Visitor methods for various sorts of trees -------------*/
2892 
2893         public void visitClassDef(JCClassDecl tree) {
2894             JCTree prevTree = currentTree;
2895             try {
2896                 currentTree = tree.sym.isLocal() ? tree : null;
2897                 super.visitClassDef(tree);
2898             } finally {
2899                 currentTree = prevTree;
2900             }
2901         }
2902 
2903         @Override
2904         public void visitLambda(JCLambda tree) {
2905             JCTree prevTree = currentTree;
2906             try {
2907                 currentTree = tree;
2908                 super.visitLambda(tree);
2909             } finally {
2910                 currentTree = prevTree;
2911             }
2912         }
2913 
2914         @Override
2915         public void visitIdent(JCIdent tree) {
2916             if (tree.sym.kind == VAR) {
2917                 checkEffectivelyFinal(tree, (VarSymbol)tree.sym);
2918             }
2919         }
2920 
2921         public void visitAssign(JCAssign tree) {
2922             JCTree lhs = TreeInfo.skipParens(tree.lhs);
2923             if (!(lhs instanceof JCIdent)) {
2924                 scan(lhs);
2925             }
2926             scan(tree.rhs);
2927             letInit(lhs);
2928         }
2929 
2930         public void visitAssignop(JCAssignOp tree) {
2931             scan(tree.lhs);
2932             scan(tree.rhs);
2933             letInit(tree.lhs);
2934         }
2935 
2936         public void visitUnary(JCUnary tree) {
2937             switch (tree.getTag()) {
2938                 case PREINC: case POSTINC:
2939                 case PREDEC: case POSTDEC:
2940                     scan(tree.arg);
2941                     letInit(tree.arg);
2942                     break;
2943                 default:
2944                     scan(tree.arg);
2945             }
2946         }
2947 
2948         public void visitTry(JCTry tree) {
2949             for (JCTree resource : tree.resources) {
2950                 if (!resource.hasTag(VARDEF)) {
2951                     Symbol var = TreeInfo.symbol(resource);
2952                     if (var != null &amp;&amp; (var.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) == 0) {
2953                         log.error(resource.pos(), Errors.TryWithResourcesExprEffectivelyFinalVar(var));
2954                     }
2955                 }
2956             }
2957             super.visitTry(tree);
2958         }
2959 
2960         @Override
2961         public void visitYield(JCYield tree) {
2962             scan(tree.value);
2963         }
2964 
2965         public void visitModuleDef(JCModuleDecl tree) {
2966             // Do nothing for modules
2967         }
2968 
2969     /**************************************************************************
2970      * main method
2971      *************************************************************************/
2972 
2973         /** Perform definite assignment/unassignment analysis on a tree.
2974          */
2975         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
2976             analyzeTree(env, env.tree, make);
2977         }
2978         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
2979             try {
2980                 attrEnv = env;
2981                 Flow.this.make = make;
2982                 pendingExits = new ListBuffer&lt;&gt;();
2983                 scan(tree);
2984             } finally {
2985                 pendingExits = null;
2986                 Flow.this.make = null;
2987             }
2988         }
2989     }
2990 
2991     enum Liveness {
2992         ALIVE {
2993             @Override
2994             public Liveness or(Liveness other) {
2995                 return this;
2996             }
2997             @Override
2998             public Liveness and(Liveness other) {
2999                 return other;
3000             }
3001         },
3002         DEAD {
3003             @Override
3004             public Liveness or(Liveness other) {
3005                 return other;
3006             }
3007             @Override
3008             public Liveness and(Liveness other) {
3009                 return this;
3010             }
3011         },
3012         RECOVERY {
3013             @Override
3014             public Liveness or(Liveness other) {
3015                 if (other == ALIVE) {
3016                     return ALIVE;
3017                 } else {
3018                     return this;
3019                 }
3020             }
3021             @Override
3022             public Liveness and(Liveness other) {
3023                 if (other == DEAD) {
3024                     return DEAD;
3025                 } else {
3026                     return this;
3027                 }
3028             }
3029         };
3030 
3031         public abstract Liveness or(Liveness other);
3032         public abstract Liveness and(Liveness other);
3033         public Liveness or(boolean value) {
3034             return or(from(value));
3035         }
3036         public Liveness and(boolean value) {
3037             return and(from(value));
3038         }
3039         public static Liveness from(boolean value) {
3040             return value ? ALIVE : DEAD;
3041         }
3042     }
3043 
3044 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
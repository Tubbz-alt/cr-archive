<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jdwp.agent/share/native/libjdwp/util.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;ctype.h&gt;
  27 
  28 #include &quot;util.h&quot;
  29 #include &quot;transport.h&quot;
  30 #include &quot;eventHandler.h&quot;
  31 #include &quot;threadControl.h&quot;
  32 #include &quot;outStream.h&quot;
  33 #include &quot;inStream.h&quot;
  34 #include &quot;invoker.h&quot;
  35 
  36 /* Global data area */
  37 BackendGlobalData *gdata = NULL;
  38 
  39 /* Forward declarations */
  40 static jboolean isInterface(jclass clazz);
  41 static jboolean isArrayClass(jclass clazz);
  42 static char * getPropertyUTF8(JNIEnv *env, char *propertyName);
  43 
  44 /* Save an object reference for use later (create a NewGlobalRef) */
  45 void
  46 saveGlobalRef(JNIEnv *env, jobject obj, jobject *pobj)
  47 {
  48     jobject newobj;
  49 
  50     if ( pobj == NULL ) {
  51         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef pobj&quot;);
  52     }
  53     if ( *pobj != NULL ) {
  54         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef *pobj&quot;);
  55     }
  56     if ( env == NULL ) {
  57         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef env&quot;);
  58     }
  59     if ( obj == NULL ) {
  60         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;saveGlobalRef obj&quot;);
  61     }
  62     newobj = JNI_FUNC_PTR(env,NewGlobalRef)(env, obj);
  63     if ( newobj == NULL ) {
  64         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,&quot;NewGlobalRef&quot;);
  65     }
  66     *pobj = newobj;
  67 }
  68 
  69 /* Toss a previously saved object reference */
  70 void
  71 tossGlobalRef(JNIEnv *env, jobject *pobj)
  72 {
  73     jobject obj;
  74 
  75     if ( pobj == NULL ) {
  76         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;tossGlobalRef pobj&quot;);
  77     }
  78     obj = *pobj;
  79     if ( env == NULL ) {
  80         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;tossGlobalRef env&quot;);
  81     }
  82     if ( obj == NULL ) {
  83         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,&quot;tossGlobalRef obj&quot;);
  84     }
  85     JNI_FUNC_PTR(env,DeleteGlobalRef)(env, obj);
  86     *pobj = NULL;
  87 }
  88 
  89 jclass
  90 findClass(JNIEnv *env, const char * name)
  91 {
  92     jclass x;
  93 
  94     if ( env == NULL ) {
  95         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;findClass env&quot;);
  96     }
  97     if ( name == NULL || name[0] == 0 ) {
  98         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;findClass name&quot;);
  99     }
 100     x = JNI_FUNC_PTR(env,FindClass)(env, name);
 101     if (x == NULL) {
 102         ERROR_MESSAGE((&quot;JDWP Can&#39;t find class %s&quot;, name));
 103         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 104     }
 105     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 106         ERROR_MESSAGE((&quot;JDWP Exception occurred finding class %s&quot;, name));
 107         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 108     }
 109     return x;
 110 }
 111 
 112 jmethodID
 113 getMethod(JNIEnv *env, jclass clazz, const char * name, const char *signature)
 114 {
 115     jmethodID method;
 116 
 117     if ( env == NULL ) {
 118         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod env&quot;);
 119     }
 120     if ( clazz == NULL ) {
 121         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod clazz&quot;);
 122     }
 123     if ( name == NULL || name[0] == 0 ) {
 124         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod name&quot;);
 125     }
 126     if ( signature == NULL || signature[0] == 0 ) {
 127         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getMethod signature&quot;);
 128     }
 129     method = JNI_FUNC_PTR(env,GetMethodID)(env, clazz, name, signature);
 130     if (method == NULL) {
 131         ERROR_MESSAGE((&quot;JDWP Can&#39;t find method %s with signature %s&quot;,
 132                                 name, signature));
 133         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 134     }
 135     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 136         ERROR_MESSAGE((&quot;JDWP Exception occurred finding method %s with signature %s&quot;,
 137                                 name, signature));
 138         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 139     }
 140     return method;
 141 }
 142 
 143 static jmethodID
 144 getStaticMethod(JNIEnv *env, jclass clazz, const char * name, const char *signature)
 145 {
 146     jmethodID method;
 147 
 148     if ( env == NULL ) {
 149         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod env&quot;);
 150     }
 151     if ( clazz == NULL ) {
 152         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod clazz&quot;);
 153     }
 154     if ( name == NULL || name[0] == 0 ) {
 155         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod name&quot;);
 156     }
 157     if ( signature == NULL || signature[0] == 0 ) {
 158         EXIT_ERROR(AGENT_ERROR_ILLEGAL_ARGUMENT,&quot;getStaticMethod signature&quot;);
 159     }
 160     method = JNI_FUNC_PTR(env,GetStaticMethodID)(env, clazz, name, signature);
 161     if (method == NULL) {
 162         ERROR_MESSAGE((&quot;JDWP Can&#39;t find method %s with signature %s&quot;,
 163                                 name, signature));
 164         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 165     }
 166     if ( JNI_FUNC_PTR(env,ExceptionOccurred)(env) ) {
 167         ERROR_MESSAGE((&quot;JDWP Exception occurred finding method %s with signature %s&quot;,
 168                                 name, signature));
 169         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
 170     }
 171     return method;
 172 }
 173 
 174 void
 175 util_initialize(JNIEnv *env)
 176 {
 177     WITH_LOCAL_REFS(env, 6) {
 178 
 179         jvmtiError error;
 180         jclass localClassClass;
 181         jclass localThreadClass;
 182         jclass localThreadGroupClass;
 183         jclass localClassLoaderClass;
 184         jclass localStringClass;
 185         jclass localSystemClass;
 186         jclass localPropertiesClass;
 187         jclass localVMSupportClass;
 188         jobject localAgentProperties;
 189         jmethodID getAgentProperties;
 190         jint groupCount;
 191         jthreadGroup *groups;
 192         jthreadGroup localSystemThreadGroup;
 193 
 194         /* Find some standard classes */
 195 
 196         localClassClass         = findClass(env,&quot;java/lang/Class&quot;);
 197         localThreadClass        = findClass(env,&quot;java/lang/Thread&quot;);
 198         localThreadGroupClass   = findClass(env,&quot;java/lang/ThreadGroup&quot;);
 199         localClassLoaderClass   = findClass(env,&quot;java/lang/ClassLoader&quot;);
 200         localStringClass        = findClass(env,&quot;java/lang/String&quot;);
 201         localSystemClass        = findClass(env,&quot;java/lang/System&quot;);
 202         localPropertiesClass    = findClass(env,&quot;java/util/Properties&quot;);
 203 
 204         /* Save references */
 205 
 206         saveGlobalRef(env, localClassClass,       &amp;(gdata-&gt;classClass));
 207         saveGlobalRef(env, localThreadClass,      &amp;(gdata-&gt;threadClass));
 208         saveGlobalRef(env, localThreadGroupClass, &amp;(gdata-&gt;threadGroupClass));
 209         saveGlobalRef(env, localClassLoaderClass, &amp;(gdata-&gt;classLoaderClass));
 210         saveGlobalRef(env, localStringClass,      &amp;(gdata-&gt;stringClass));
 211         saveGlobalRef(env, localSystemClass,      &amp;(gdata-&gt;systemClass));
 212 
 213         /* Find some standard methods */
 214 
 215         gdata-&gt;threadConstructor =
 216                 getMethod(env, gdata-&gt;threadClass,
 217                     &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/ThreadGroup;Ljava/lang/String;)V&quot;);
 218         gdata-&gt;threadSetDaemon =
 219                 getMethod(env, gdata-&gt;threadClass, &quot;setDaemon&quot;, &quot;(Z)V&quot;);
 220         gdata-&gt;threadResume =
 221                 getMethod(env, gdata-&gt;threadClass, &quot;resume&quot;, &quot;()V&quot;);
 222         gdata-&gt;systemGetProperty =
 223                 getStaticMethod(env, gdata-&gt;systemClass,
 224                     &quot;getProperty&quot;, &quot;(Ljava/lang/String;)Ljava/lang/String;&quot;);
 225         gdata-&gt;setProperty =
 226                 getMethod(env, localPropertiesClass,
 227                     &quot;setProperty&quot;, &quot;(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;&quot;);
 228 
 229         /* Find the system thread group */
 230 
 231         groups = NULL;
 232         groupCount = 0;
 233         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetTopThreadGroups)
 234                     (gdata-&gt;jvmti, &amp;groupCount, &amp;groups);
 235         if (error != JVMTI_ERROR_NONE ) {
 236             EXIT_ERROR(error, &quot;Can&#39;t get system thread group&quot;);
 237         }
 238         if ( groupCount == 0 ) {
 239             EXIT_ERROR(AGENT_ERROR_NULL_POINTER, &quot;Can&#39;t get system thread group&quot;);
 240         }
 241         localSystemThreadGroup = groups[0];
 242         saveGlobalRef(env, localSystemThreadGroup, &amp;(gdata-&gt;systemThreadGroup));
 243 
 244         /* Get some basic Java property values we will need at some point */
 245         gdata-&gt;property_java_version
 246                         = getPropertyUTF8(env, &quot;java.version&quot;);
 247         gdata-&gt;property_java_vm_name
 248                         = getPropertyUTF8(env, &quot;java.vm.name&quot;);
 249         gdata-&gt;property_java_vm_info
 250                         = getPropertyUTF8(env, &quot;java.vm.info&quot;);
 251         gdata-&gt;property_java_class_path
 252                         = getPropertyUTF8(env, &quot;java.class.path&quot;);
 253         gdata-&gt;property_sun_boot_library_path
 254                         = getPropertyUTF8(env, &quot;sun.boot.library.path&quot;);
 255         gdata-&gt;property_path_separator
 256                         = getPropertyUTF8(env, &quot;path.separator&quot;);
 257         gdata-&gt;property_user_dir
 258                         = getPropertyUTF8(env, &quot;user.dir&quot;);
 259 
 260         /* Get agent properties: invoke VMSupport.getAgentProperties */
 261         localVMSupportClass = JNI_FUNC_PTR(env,FindClass)
 262                                           (env, &quot;jdk/internal/vm/VMSupport&quot;);
 263         if (localVMSupportClass == NULL) {
 264             gdata-&gt;agent_properties = NULL;
 265             if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 266                 JNI_FUNC_PTR(env,ExceptionClear)(env);
 267             }
 268         } else {
 269             getAgentProperties  =
 270                 getStaticMethod(env, localVMSupportClass,
 271                                 &quot;getAgentProperties&quot;, &quot;()Ljava/util/Properties;&quot;);
 272             localAgentProperties =
 273                 JNI_FUNC_PTR(env,CallStaticObjectMethod)
 274                             (env, localVMSupportClass, getAgentProperties);
 275             saveGlobalRef(env, localAgentProperties, &amp;(gdata-&gt;agent_properties));
 276             if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 277                 JNI_FUNC_PTR(env,ExceptionClear)(env);
 278                 EXIT_ERROR(AGENT_ERROR_INTERNAL,
 279                     &quot;Exception occurred calling VMSupport.getAgentProperties&quot;);
 280             }
 281         }
 282 
 283     } END_WITH_LOCAL_REFS(env);
 284 
 285 }
 286 
 287 void
 288 util_reset(void)
 289 {
 290 }
 291 
 292 jboolean
 293 isObjectTag(jbyte tag) {
 294     return (tag == JDWP_TAG(OBJECT)) ||
<a name="1" id="anc1"></a>
 295            (tag == JDWP_TAG(STRING)) ||
 296            (tag == JDWP_TAG(THREAD)) ||
 297            (tag == JDWP_TAG(THREAD_GROUP)) ||
 298            (tag == JDWP_TAG(CLASS_LOADER)) ||
 299            (tag == JDWP_TAG(CLASS_OBJECT)) ||
 300            (tag == JDWP_TAG(ARRAY));
 301 }
 302 
 303 jbyte
 304 specificTypeKey(JNIEnv *env, jobject object)
 305 {
 306     if (object == NULL) {
 307         return JDWP_TAG(OBJECT);
 308     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;stringClass)) {
 309         return JDWP_TAG(STRING);
 310     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadClass)) {
 311         return JDWP_TAG(THREAD);
 312     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadGroupClass)) {
 313         return JDWP_TAG(THREAD_GROUP);
 314     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classLoaderClass)) {
 315         return JDWP_TAG(CLASS_LOADER);
 316     } else if (JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classClass)) {
 317         return JDWP_TAG(CLASS_OBJECT);
 318     } else {
 319         jboolean classIsArray;
 320 
 321         WITH_LOCAL_REFS(env, 1) {
 322             jclass clazz;
 323             clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 324             classIsArray = isArrayClass(clazz);
 325         } END_WITH_LOCAL_REFS(env);
 326 
 327         return (classIsArray ? JDWP_TAG(ARRAY) : JDWP_TAG(OBJECT));
 328     }
 329 }
 330 
 331 static void
 332 writeFieldValue(JNIEnv *env, PacketOutputStream *out, jobject object,
 333                 jfieldID field)
 334 {
 335     jclass clazz;
 336     char *signature = NULL;
 337     jvmtiError error;
 338     jbyte typeKey;
 339 
 340     clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
 341     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 342     if (error != JVMTI_ERROR_NONE) {
 343         outStream_setError(out, map2jdwpError(error));
 344         return;
 345     }
 346     typeKey = signature[0];
 347     jvmtiDeallocate(signature);
 348 
 349     /*
 350      * For primitive types, the type key is bounced back as is. Objects
 351      * are handled in the switch statement below.
 352      */
<a name="2" id="anc2"></a><span class="line-modified"> 353     if ((typeKey != JDWP_TAG(OBJECT)) &amp;&amp; (typeKey != JDWP_TAG(ARRAY))) {</span>
 354         (void)outStream_writeByte(out, typeKey);
 355     }
 356 
 357     switch (typeKey) {
 358         case JDWP_TAG(OBJECT):
<a name="3" id="anc3"></a><span class="line-modified"> 359         case JDWP_TAG(ARRAY):   {</span>

 360             jobject value = JNI_FUNC_PTR(env,GetObjectField)(env, object, field);
 361             (void)outStream_writeByte(out, specificTypeKey(env, value));
 362             (void)outStream_writeObjectRef(env, out, value);
 363             break;
 364         }
 365 
 366         case JDWP_TAG(BYTE):
 367             (void)outStream_writeByte(out,
 368                       JNI_FUNC_PTR(env,GetByteField)(env, object, field));
 369             break;
 370 
 371         case JDWP_TAG(CHAR):
 372             (void)outStream_writeChar(out,
 373                       JNI_FUNC_PTR(env,GetCharField)(env, object, field));
 374             break;
 375 
 376         case JDWP_TAG(FLOAT):
 377             (void)outStream_writeFloat(out,
 378                       JNI_FUNC_PTR(env,GetFloatField)(env, object, field));
 379             break;
 380 
 381         case JDWP_TAG(DOUBLE):
 382             (void)outStream_writeDouble(out,
 383                       JNI_FUNC_PTR(env,GetDoubleField)(env, object, field));
 384             break;
 385 
 386         case JDWP_TAG(INT):
 387             (void)outStream_writeInt(out,
 388                       JNI_FUNC_PTR(env,GetIntField)(env, object, field));
 389             break;
 390 
 391         case JDWP_TAG(LONG):
 392             (void)outStream_writeLong(out,
 393                       JNI_FUNC_PTR(env,GetLongField)(env, object, field));
 394             break;
 395 
 396         case JDWP_TAG(SHORT):
 397             (void)outStream_writeShort(out,
 398                       JNI_FUNC_PTR(env,GetShortField)(env, object, field));
 399             break;
 400 
 401         case JDWP_TAG(BOOLEAN):
 402             (void)outStream_writeBoolean(out,
 403                       JNI_FUNC_PTR(env,GetBooleanField)(env, object, field));
 404             break;
 405     }
 406 }
 407 
 408 static void
 409 writeStaticFieldValue(JNIEnv *env, PacketOutputStream *out, jclass clazz,
 410                       jfieldID field)
 411 {
 412     jvmtiError error;
 413     char *signature = NULL;
 414     jbyte typeKey;
 415 
 416     error = fieldSignature(clazz, field, NULL, &amp;signature, NULL);
 417     if (error != JVMTI_ERROR_NONE) {
 418         outStream_setError(out, map2jdwpError(error));
 419         return;
 420     }
 421     typeKey = signature[0];
 422     jvmtiDeallocate(signature);
 423 
 424     /*
 425      * For primitive types, the type key is bounced back as is. Objects
 426      * are handled in the switch statement below.
 427      */
<a name="4" id="anc4"></a><span class="line-modified"> 428     if ((typeKey != JDWP_TAG(OBJECT)) &amp;&amp; (typeKey != JDWP_TAG(ARRAY))) {</span>
 429         (void)outStream_writeByte(out, typeKey);
 430     }
 431 
 432     switch (typeKey) {
 433         case JDWP_TAG(OBJECT):
<a name="5" id="anc5"></a><span class="line-modified"> 434         case JDWP_TAG(ARRAY):   {</span>

 435             jobject value = JNI_FUNC_PTR(env,GetStaticObjectField)(env, clazz, field);
 436             (void)outStream_writeByte(out, specificTypeKey(env, value));
 437             (void)outStream_writeObjectRef(env, out, value);
 438             break;
 439         }
 440 
 441         case JDWP_TAG(BYTE):
 442             (void)outStream_writeByte(out,
 443                       JNI_FUNC_PTR(env,GetStaticByteField)(env, clazz, field));
 444             break;
 445 
 446         case JDWP_TAG(CHAR):
 447             (void)outStream_writeChar(out,
 448                       JNI_FUNC_PTR(env,GetStaticCharField)(env, clazz, field));
 449             break;
 450 
 451         case JDWP_TAG(FLOAT):
 452             (void)outStream_writeFloat(out,
 453                       JNI_FUNC_PTR(env,GetStaticFloatField)(env, clazz, field));
 454             break;
 455 
 456         case JDWP_TAG(DOUBLE):
 457             (void)outStream_writeDouble(out,
 458                       JNI_FUNC_PTR(env,GetStaticDoubleField)(env, clazz, field));
 459             break;
 460 
 461         case JDWP_TAG(INT):
 462             (void)outStream_writeInt(out,
 463                       JNI_FUNC_PTR(env,GetStaticIntField)(env, clazz, field));
 464             break;
 465 
 466         case JDWP_TAG(LONG):
 467             (void)outStream_writeLong(out,
 468                       JNI_FUNC_PTR(env,GetStaticLongField)(env, clazz, field));
 469             break;
 470 
 471         case JDWP_TAG(SHORT):
 472             (void)outStream_writeShort(out,
 473                       JNI_FUNC_PTR(env,GetStaticShortField)(env, clazz, field));
 474             break;
 475 
 476         case JDWP_TAG(BOOLEAN):
 477             (void)outStream_writeBoolean(out,
 478                       JNI_FUNC_PTR(env,GetStaticBooleanField)(env, clazz, field));
 479             break;
 480     }
 481 }
 482 
 483 void
 484 sharedGetFieldValues(PacketInputStream *in, PacketOutputStream *out,
 485                      jboolean isStatic)
 486 {
 487     JNIEnv *env = getEnv();
 488     jint length;
 489     jobject object;
 490     jclass clazz;
 491 
 492     object = NULL;
 493     clazz  = NULL;
 494 
 495     if (isStatic) {
 496         clazz = inStream_readClassRef(env, in);
 497     } else {
 498         object = inStream_readObjectRef(env, in);
 499     }
 500 
 501     length = inStream_readInt(in);
 502     if (inStream_error(in)) {
 503         return;
 504     }
 505 
 506     WITH_LOCAL_REFS(env, length + 1) { /* +1 for class with instance fields */
 507 
 508         int i;
 509 
 510         (void)outStream_writeInt(out, length);
 511         for (i = 0; (i &lt; length) &amp;&amp; !outStream_error(out); i++) {
 512             jfieldID field = inStream_readFieldID(in);
 513 
 514             if (isStatic) {
 515                 writeStaticFieldValue(env, out, clazz, field);
 516             } else {
 517                 writeFieldValue(env, out, object, field);
 518             }
 519         }
 520 
 521     } END_WITH_LOCAL_REFS(env);
 522 }
 523 
 524 jboolean
 525 sharedInvoke(PacketInputStream *in, PacketOutputStream *out)
 526 {
 527     jvalue *arguments = NULL;
 528     jint options;
 529     jvmtiError error;
 530     jbyte invokeType;
 531     jclass clazz;
 532     jmethodID method;
 533     jint argumentCount;
 534     jobject instance;
 535     jthread thread;
 536     JNIEnv *env;
 537 
 538     /*
 539      * Instance methods start with the instance, thread and class,
 540      * and statics and constructors start with the class and then the
 541      * thread.
 542      */
 543     env = getEnv();
 544     if (inStream_command(in) == JDWP_COMMAND(ObjectReference, InvokeMethod)) {
 545         instance = inStream_readObjectRef(env, in);
 546         thread = inStream_readThreadRef(env, in);
 547         clazz = inStream_readClassRef(env, in);
 548     } else { /* static method or constructor */
 549         instance = NULL;
 550         clazz = inStream_readClassRef(env, in);
 551         thread = inStream_readThreadRef(env, in);
 552     }
 553 
 554     /*
 555      * ... and the rest of the packet is identical for all commands
 556      */
 557     method = inStream_readMethodID(in);
 558     argumentCount = inStream_readInt(in);
 559     if (inStream_error(in)) {
 560         return JNI_TRUE;
 561     }
 562 
 563     /* If count == 0, don&#39;t try and allocate 0 bytes, you&#39;ll get NULL */
 564     if ( argumentCount &gt; 0 ) {
 565         int i;
 566         /*LINTED*/
 567         arguments = jvmtiAllocate(argumentCount * (jint)sizeof(*arguments));
 568         if (arguments == NULL) {
 569             outStream_setError(out, JDWP_ERROR(OUT_OF_MEMORY));
 570             return JNI_TRUE;
 571         }
 572         for (i = 0; (i &lt; argumentCount) &amp;&amp; !inStream_error(in); i++) {
 573             arguments[i] = inStream_readValue(in, NULL);
 574         }
 575         if (inStream_error(in)) {
 576             return JNI_TRUE;
 577         }
 578     }
 579 
 580     options = inStream_readInt(in);
 581     if (inStream_error(in)) {
 582         if ( arguments != NULL ) {
 583             jvmtiDeallocate(arguments);
 584         }
 585         return JNI_TRUE;
 586     }
 587 
 588     if (inStream_command(in) == JDWP_COMMAND(ClassType, NewInstance)) {
 589         invokeType = INVOKE_CONSTRUCTOR;
 590     } else if (inStream_command(in) == JDWP_COMMAND(ClassType, InvokeMethod)) {
 591         invokeType = INVOKE_STATIC;
 592     } else if (inStream_command(in) == JDWP_COMMAND(InterfaceType, InvokeMethod)) {
 593         invokeType = INVOKE_STATIC;
 594     } else if (inStream_command(in) == JDWP_COMMAND(ObjectReference, InvokeMethod)) {
 595         invokeType = INVOKE_INSTANCE;
 596     } else {
 597         outStream_setError(out, JDWP_ERROR(INTERNAL));
 598         if ( arguments != NULL ) {
 599             jvmtiDeallocate(arguments);
 600         }
 601         return JNI_TRUE;
 602     }
 603 
 604     /*
 605      * Request the invoke. If there are no errors in the request,
 606      * the interrupting thread will actually do the invoke and a
 607      * reply will be generated subsequently, so we don&#39;t reply here.
 608      */
 609     error = invoker_requestInvoke(invokeType, (jbyte)options, inStream_id(in),
 610                                   thread, clazz, method,
 611                                   instance, arguments, argumentCount);
 612     if (error != JVMTI_ERROR_NONE) {
 613         outStream_setError(out, map2jdwpError(error));
 614         if ( arguments != NULL ) {
 615             jvmtiDeallocate(arguments);
 616         }
 617         return JNI_TRUE;
 618     }
 619 
 620     return JNI_FALSE;   /* Don&#39;t reply */
 621 }
 622 
 623 jint
 624 uniqueID(void)
 625 {
 626     static jint currentID = 0;
 627     return currentID++;
 628 }
 629 
 630 int
 631 filterDebugThreads(jthread *threads, int count)
 632 {
 633     int i;
 634     int current;
 635 
 636     /* Squish out all of the debugger-spawned threads */
 637     for (i = 0, current = 0; i &lt; count; i++) {
 638         jthread thread = threads[i];
 639         if (!threadControl_isDebugThread(thread)) {
 640             if (i &gt; current) {
 641                 threads[current] = thread;
 642             }
 643             current++;
 644         }
 645     }
 646     return current;
 647 }
 648 
 649 jbyte
 650 referenceTypeTag(jclass clazz)
 651 {
 652     jbyte tag;
 653 
 654     if (isInterface(clazz)) {
 655         tag = JDWP_TYPE_TAG(INTERFACE);
 656     } else if (isArrayClass(clazz)) {
 657         tag = JDWP_TYPE_TAG(ARRAY);
 658     } else {
 659         tag = JDWP_TYPE_TAG(CLASS);
 660     }
 661 
 662     return tag;
 663 }
 664 
 665 /**
 666  * Get field modifiers
 667  */
 668 jvmtiError
 669 fieldModifiers(jclass clazz, jfieldID field, jint *pmodifiers)
 670 {
 671     jvmtiError error;
 672 
 673     *pmodifiers = 0;
 674     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFieldModifiers)
 675             (gdata-&gt;jvmti, clazz, field, pmodifiers);
 676     return error;
 677 }
 678 
 679 /**
 680  * Get method modifiers
 681  */
 682 jvmtiError
 683 methodModifiers(jmethodID method, jint *pmodifiers)
 684 {
 685     jvmtiError error;
 686 
 687     *pmodifiers = 0;
 688     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetMethodModifiers)
 689             (gdata-&gt;jvmti, method, pmodifiers);
 690     return error;
 691 }
 692 
 693 /* Returns a local ref to the declaring class for a method, or NULL. */
 694 jvmtiError
 695 methodClass(jmethodID method, jclass *pclazz)
 696 {
 697     jvmtiError error;
 698 
 699     *pclazz = NULL;
 700     error = FUNC_PTR(gdata-&gt;jvmti,GetMethodDeclaringClass)
 701                                 (gdata-&gt;jvmti, method, pclazz);
 702     return error;
 703 }
 704 
 705 /* Returns a local ref to the declaring class for a method, or NULL. */
 706 jvmtiError
 707 methodLocation(jmethodID method, jlocation *ploc1, jlocation *ploc2)
 708 {
 709     jvmtiError error;
 710 
 711     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetMethodLocation)
 712                                 (gdata-&gt;jvmti, method, ploc1, ploc2);
 713     return error;
 714 }
 715 
 716 /**
 717  * Get method signature
 718  */
 719 jvmtiError
 720 methodSignature(jmethodID method,
 721         char **pname, char **psignature, char **pgeneric_signature)
 722 {
 723     jvmtiError error;
 724     char *name = NULL;
 725     char *signature = NULL;
 726     char *generic_signature = NULL;
 727 
 728     error = FUNC_PTR(gdata-&gt;jvmti,GetMethodName)
 729             (gdata-&gt;jvmti, method, &amp;name, &amp;signature, &amp;generic_signature);
 730 
 731     if ( pname != NULL ) {
 732         *pname = name;
 733     } else if ( name != NULL )  {
 734         jvmtiDeallocate(name);
 735     }
 736     if ( psignature != NULL ) {
 737         *psignature = signature;
 738     } else if ( signature != NULL ) {
 739         jvmtiDeallocate(signature);
 740     }
 741     if ( pgeneric_signature != NULL ) {
 742         *pgeneric_signature = generic_signature;
 743     } else if ( generic_signature != NULL )  {
 744         jvmtiDeallocate(generic_signature);
 745     }
 746     return error;
 747 }
 748 
 749 /*
 750  * Get the return type key of the method
 751  *     V or B C D F I J S Z L  [
 752  */
 753 jvmtiError
 754 methodReturnType(jmethodID method, char *typeKey)
 755 {
 756     char       *signature;
 757     jvmtiError  error;
 758 
 759     signature = NULL;
 760     error     = methodSignature(method, NULL, &amp;signature, NULL);
 761     if (error == JVMTI_ERROR_NONE) {
 762         if (signature == NULL ) {
 763             error = AGENT_ERROR_INVALID_TAG;
 764         } else {
 765             char * xx;
 766 
 767             xx = strchr(signature, &#39;)&#39;);
 768             if (xx == NULL || *(xx + 1) == 0) {
 769                 error = AGENT_ERROR_INVALID_TAG;
 770             } else {
 771                *typeKey = *(xx + 1);
 772             }
 773             jvmtiDeallocate(signature);
 774         }
 775     }
 776     return error;
 777 }
 778 
 779 
 780 /**
 781  * Return class loader for a class (must be inside a WITH_LOCAL_REFS)
 782  */
 783 jvmtiError
 784 classLoader(jclass clazz, jobject *pclazz)
 785 {
 786     jvmtiError error;
 787 
 788     *pclazz = NULL;
 789     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassLoader)
 790             (gdata-&gt;jvmti, clazz, pclazz);
 791     return error;
 792 }
 793 
 794 /**
 795  * Get field signature
 796  */
 797 jvmtiError
 798 fieldSignature(jclass clazz, jfieldID field,
 799         char **pname, char **psignature, char **pgeneric_signature)
 800 {
 801     jvmtiError error;
 802     char *name = NULL;
 803     char *signature = NULL;
 804     char *generic_signature = NULL;
 805 
 806     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetFieldName)
 807             (gdata-&gt;jvmti, clazz, field, &amp;name, &amp;signature, &amp;generic_signature);
 808 
 809     if ( pname != NULL ) {
 810         *pname = name;
 811     } else if ( name != NULL )  {
 812         jvmtiDeallocate(name);
 813     }
 814     if ( psignature != NULL ) {
 815         *psignature = signature;
 816     } else if ( signature != NULL )  {
 817         jvmtiDeallocate(signature);
 818     }
 819     if ( pgeneric_signature != NULL ) {
 820         *pgeneric_signature = generic_signature;
 821     } else if ( generic_signature != NULL )  {
 822         jvmtiDeallocate(generic_signature);
 823     }
 824     return error;
 825 }
 826 
 827 JNIEnv *
 828 getEnv(void)
 829 {
 830     JNIEnv *env = NULL;
 831     jint rc;
 832 
 833     rc = FUNC_PTR(gdata-&gt;jvm,GetEnv)
 834                 (gdata-&gt;jvm, (void **)&amp;env, JNI_VERSION_1_2);
 835     if (rc != JNI_OK) {
 836         ERROR_MESSAGE((&quot;JDWP Unable to get JNI 1.2 environment, jvm-&gt;GetEnv() return code = %d&quot;,
 837                 rc));
 838         EXIT_ERROR(AGENT_ERROR_NO_JNI_ENV,NULL);
 839     }
 840     return env;
 841 }
 842 
 843 jvmtiError
 844 spawnNewThread(jvmtiStartFunction func, void *arg, char *name)
 845 {
 846     JNIEnv *env = getEnv();
 847     jvmtiError error;
 848 
 849     LOG_MISC((&quot;Spawning new thread: %s&quot;, name));
 850 
 851     WITH_LOCAL_REFS(env, 3) {
 852 
 853         jthread thread;
 854         jstring nameString;
 855 
 856         nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, name);
 857         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 858             JNI_FUNC_PTR(env,ExceptionClear)(env);
 859             error = AGENT_ERROR_OUT_OF_MEMORY;
 860             goto err;
 861         }
 862 
 863         thread = JNI_FUNC_PTR(env,NewObject)
 864                         (env, gdata-&gt;threadClass, gdata-&gt;threadConstructor,
 865                                    gdata-&gt;systemThreadGroup, nameString);
 866         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 867             JNI_FUNC_PTR(env,ExceptionClear)(env);
 868             error = AGENT_ERROR_OUT_OF_MEMORY;
 869             goto err;
 870         }
 871 
 872         /*
 873          * Make the debugger thread a daemon
 874          */
 875         JNI_FUNC_PTR(env,CallVoidMethod)
 876                         (env, thread, gdata-&gt;threadSetDaemon, JNI_TRUE);
 877         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
 878             JNI_FUNC_PTR(env,ExceptionClear)(env);
 879             error = AGENT_ERROR_JNI_EXCEPTION;
 880             goto err;
 881         }
 882 
 883         error = threadControl_addDebugThread(thread);
 884         if (error == JVMTI_ERROR_NONE) {
 885             /*
 886              * Debugger threads need cycles in all sorts of strange
 887              * situations (e.g. infinite cpu-bound loops), so give the
 888              * thread a high priority. Note that if the VM has an application
 889              * thread running at the max priority, there is still a chance
 890              * that debugger threads will be starved. (There needs to be
 891              * a way to give debugger threads a priority higher than any
 892              * application thread).
 893              */
 894             error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,RunAgentThread)
 895                         (gdata-&gt;jvmti, thread, func, arg,
 896                                         JVMTI_THREAD_MAX_PRIORITY);
 897         }
 898 
 899         err: ;
 900 
 901     } END_WITH_LOCAL_REFS(env);
 902 
 903     return error;
 904 }
 905 
 906 jvmtiError
 907 jvmtiGetCapabilities(jvmtiCapabilities *caps)
 908 {
 909     if ( gdata-&gt;vmDead ) {
 910         return AGENT_ERROR_VM_DEAD;
 911     }
 912     if (!gdata-&gt;haveCachedJvmtiCapabilities) {
 913         jvmtiError error;
 914 
 915         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetCapabilities)
 916                         (gdata-&gt;jvmti, &amp;(gdata-&gt;cachedJvmtiCapabilities));
 917         if (error != JVMTI_ERROR_NONE) {
 918             return error;
 919         }
 920         gdata-&gt;haveCachedJvmtiCapabilities = JNI_TRUE;
 921     }
 922 
 923     *caps = gdata-&gt;cachedJvmtiCapabilities;
 924 
 925     return JVMTI_ERROR_NONE;
 926 }
 927 
 928 static jint
 929 jvmtiVersion(void)
 930 {
 931     if (gdata-&gt;cachedJvmtiVersion == 0) {
 932         jvmtiError error;
 933         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetVersionNumber)
 934                         (gdata-&gt;jvmti, &amp;(gdata-&gt;cachedJvmtiVersion));
 935         if (error != JVMTI_ERROR_NONE) {
 936             EXIT_ERROR(error, &quot;on getting the JVMTI version number&quot;);
 937         }
 938     }
 939     return gdata-&gt;cachedJvmtiVersion;
 940 }
 941 
 942 jint
 943 jvmtiMajorVersion(void)
 944 {
 945     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MAJOR)
 946                     &gt;&gt; JVMTI_VERSION_SHIFT_MAJOR;
 947 }
 948 
 949 jint
 950 jvmtiMinorVersion(void)
 951 {
 952     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MINOR)
 953                     &gt;&gt; JVMTI_VERSION_SHIFT_MINOR;
 954 }
 955 
 956 jint
 957 jvmtiMicroVersion(void)
 958 {
 959     return (jvmtiVersion() &amp; JVMTI_VERSION_MASK_MICRO)
 960                     &gt;&gt; JVMTI_VERSION_SHIFT_MICRO;
 961 }
 962 
 963 jboolean
 964 canSuspendResumeThreadLists(void)
 965 {
 966     jvmtiError error;
 967     jvmtiCapabilities cap;
 968 
 969     error = jvmtiGetCapabilities(&amp;cap);
 970     return (error == JVMTI_ERROR_NONE &amp;&amp; cap.can_suspend);
 971 }
 972 
 973 jvmtiError
 974 getSourceDebugExtension(jclass clazz, char **extensionPtr)
 975 {
 976     return JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetSourceDebugExtension)
 977                 (gdata-&gt;jvmti, clazz, extensionPtr);
 978 }
 979 
 980 /*
 981  * Convert the signature &quot;Ljava/lang/Foo;&quot; to a
 982  * classname &quot;java.lang.Foo&quot; compatible with the pattern.
 983  * Signature is overwritten in-place.
 984  */
 985 void
 986 convertSignatureToClassname(char *convert)
 987 {
 988     char *p;
 989 
 990     p = convert + 1;
 991     while ((*p != &#39;;&#39;) &amp;&amp; (*p != &#39;\0&#39;)) {
 992         char c = *p;
 993         if (c == &#39;/&#39;) {
 994             *(p-1) = &#39;.&#39;;
 995         } else if (c == &#39;.&#39;) {
 996             // class signature of a hidden class is &quot;Ljava/lang/Foo.1234;&quot;
 997             // map to &quot;java.lang.Foo/1234&quot;
 998             *(p-1) = &#39;/&#39;;
 999         } else {
1000             *(p-1) = c;
1001         }
1002         p++;
1003     }
1004     *(p-1) = &#39;\0&#39;;
1005 }
1006 
1007 static void
1008 handleInterrupt(void)
1009 {
1010     /*
1011      * An interrupt is handled:
1012      *
1013      * 1) for running application threads by deferring the interrupt
1014      * until the current event handler has concluded.
1015      *
1016      * 2) for debugger threads by ignoring the interrupt; this is the
1017      * most robust solution since debugger threads don&#39;t use interrupts
1018      * to signal any condition.
1019      *
1020      * 3) for application threads that have not started or already
1021      * ended by ignoring the interrupt. In the former case, the application
1022      * is relying on timing to determine whether or not the thread sees
1023      * the interrupt; in the latter case, the interrupt is meaningless.
1024      */
1025     jthread thread = threadControl_currentThread();
1026     if ((thread != NULL) &amp;&amp; (!threadControl_isDebugThread(thread))) {
1027         threadControl_setPendingInterrupt(thread);
1028     }
1029 }
1030 
1031 static jvmtiError
1032 ignore_vm_death(jvmtiError error)
1033 {
1034     if (error == JVMTI_ERROR_WRONG_PHASE) {
1035         LOG_MISC((&quot;VM_DEAD, in debugMonitor*()?&quot;));
1036         return JVMTI_ERROR_NONE; /* JVMTI does this, not JVMDI? */
1037     }
1038     return error;
1039 }
1040 
1041 void
1042 debugMonitorEnter(jrawMonitorID monitor)
1043 {
1044     jvmtiError error;
1045     while (JNI_TRUE) {
1046         error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorEnter)
1047                         (gdata-&gt;jvmti, monitor);
1048         error = ignore_vm_death(error);
1049         if (error == JVMTI_ERROR_INTERRUPT) {
1050             handleInterrupt();
1051         } else {
1052             break;
1053         }
1054     }
1055     if (error != JVMTI_ERROR_NONE) {
1056         EXIT_ERROR(error, &quot;on raw monitor enter&quot;);
1057     }
1058 }
1059 
1060 void
1061 debugMonitorExit(jrawMonitorID monitor)
1062 {
1063     jvmtiError error;
1064 
1065     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorExit)
1066                 (gdata-&gt;jvmti, monitor);
1067     error = ignore_vm_death(error);
1068     if (error != JVMTI_ERROR_NONE) {
1069         EXIT_ERROR(error, &quot;on raw monitor exit&quot;);
1070     }
1071 }
1072 
1073 void
1074 debugMonitorWait(jrawMonitorID monitor)
1075 {
1076     jvmtiError error;
1077     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorWait)
1078         (gdata-&gt;jvmti, monitor, ((jlong)(-1)));
1079 
1080     /*
1081      * According to the JLS (17.8), here we have
1082      * either :
1083      * a- been notified
1084      * b- gotten a suprious wakeup
1085      * c- been interrupted
1086      * If both a and c have happened, the VM must choose
1087      * which way to return - a or c.  If it chooses c
1088      * then the notify is gone - either to some other
1089      * thread that is also waiting, or it is dropped
1090      * on the floor.
1091      *
1092      * a is what we expect.  b won&#39;t hurt us any -
1093      * callers should be programmed to handle
1094      * spurious wakeups.  In case of c,
1095      * then the interrupt has been cleared, but
1096      * we don&#39;t want to consume it.  It came from
1097      * user code and is intended for user code, not us.
1098      * So, we will remember that the interrupt has
1099      * occurred and re-activate it when this thread
1100      * goes back into user code.
1101      * That being said, what do we do here?  Since
1102      * we could have been notified too, here we will
1103      * just pretend that we have been.  It won&#39;t hurt
1104      * anything to return in the same way as if
1105      * we were notified since callers have to be able to
1106      * handle spurious wakeups anyway.
1107      */
1108     if (error == JVMTI_ERROR_INTERRUPT) {
1109         handleInterrupt();
1110         error = JVMTI_ERROR_NONE;
1111     }
1112     error = ignore_vm_death(error);
1113     if (error != JVMTI_ERROR_NONE) {
1114         EXIT_ERROR(error, &quot;on raw monitor wait&quot;);
1115     }
1116 }
1117 
1118 void
1119 debugMonitorTimedWait(jrawMonitorID monitor, jlong millis)
1120 {
1121     jvmtiError error;
1122     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorWait)
1123         (gdata-&gt;jvmti, monitor, millis);
1124     if (error == JVMTI_ERROR_INTERRUPT) {
1125         /* See comment above */
1126         handleInterrupt();
1127         error = JVMTI_ERROR_NONE;
1128     }
1129     error = ignore_vm_death(error);
1130     if (error != JVMTI_ERROR_NONE) {
1131         EXIT_ERROR(error, &quot;on raw monitor timed wait&quot;);
1132     }
1133 }
1134 
1135 void
1136 debugMonitorNotify(jrawMonitorID monitor)
1137 {
1138     jvmtiError error;
1139 
1140     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorNotify)
1141                 (gdata-&gt;jvmti, monitor);
1142     error = ignore_vm_death(error);
1143     if (error != JVMTI_ERROR_NONE) {
1144         EXIT_ERROR(error, &quot;on raw monitor notify&quot;);
1145     }
1146 }
1147 
1148 void
1149 debugMonitorNotifyAll(jrawMonitorID monitor)
1150 {
1151     jvmtiError error;
1152 
1153     error = FUNC_PTR(gdata-&gt;jvmti,RawMonitorNotifyAll)
1154                 (gdata-&gt;jvmti, monitor);
1155     error = ignore_vm_death(error);
1156     if (error != JVMTI_ERROR_NONE) {
1157         EXIT_ERROR(error, &quot;on raw monitor notify all&quot;);
1158     }
1159 }
1160 
1161 jrawMonitorID
1162 debugMonitorCreate(char *name)
1163 {
1164     jrawMonitorID monitor;
1165     jvmtiError error;
1166 
1167     error = FUNC_PTR(gdata-&gt;jvmti,CreateRawMonitor)
1168                 (gdata-&gt;jvmti, name, &amp;monitor);
1169     if (error != JVMTI_ERROR_NONE) {
1170         EXIT_ERROR(error, &quot;on creation of a raw monitor&quot;);
1171     }
1172     return monitor;
1173 }
1174 
1175 void
1176 debugMonitorDestroy(jrawMonitorID monitor)
1177 {
1178     jvmtiError error;
1179 
1180     error = FUNC_PTR(gdata-&gt;jvmti,DestroyRawMonitor)
1181                 (gdata-&gt;jvmti, monitor);
1182     error = ignore_vm_death(error);
1183     if (error != JVMTI_ERROR_NONE) {
1184         EXIT_ERROR(error, &quot;on destruction of raw monitor&quot;);
1185     }
1186 }
1187 
1188 /**
1189  * Return array of all threads (must be inside a WITH_LOCAL_REFS)
1190  */
1191 jthread *
1192 allThreads(jint *count)
1193 {
1194     jthread *threads;
1195     jvmtiError error;
1196 
1197     *count = 0;
1198     threads = NULL;
1199     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetAllThreads)
1200                 (gdata-&gt;jvmti, count, &amp;threads);
1201     if (error == AGENT_ERROR_OUT_OF_MEMORY) {
1202         return NULL; /* Let caller deal with no memory? */
1203     }
1204     if (error != JVMTI_ERROR_NONE) {
1205         EXIT_ERROR(error, &quot;getting all threads&quot;);
1206     }
1207     return threads;
1208 }
1209 
1210 /**
1211  * Fill the passed in structure with thread group info.
1212  * name field is JVMTI allocated.  parent is global ref.
1213  */
1214 void
1215 threadGroupInfo(jthreadGroup group, jvmtiThreadGroupInfo *info)
1216 {
1217     jvmtiError error;
1218 
1219     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetThreadGroupInfo)
1220                 (gdata-&gt;jvmti, group, info);
1221     if (error != JVMTI_ERROR_NONE) {
1222         EXIT_ERROR(error, &quot;on getting thread group info&quot;);
1223     }
1224 }
1225 
1226 /**
1227  * Return class signature string
1228  */
1229 jvmtiError
1230 classSignature(jclass clazz, char **psignature, char **pgeneric_signature)
1231 {
1232     jvmtiError error;
1233     char *signature = NULL;
1234 
1235     /*
1236      * pgeneric_signature can be NULL, and GetClassSignature
1237      * accepts NULL.
1238      */
1239     error = FUNC_PTR(gdata-&gt;jvmti,GetClassSignature)
1240                 (gdata-&gt;jvmti, clazz, &amp;signature, pgeneric_signature);
1241 
1242     if ( psignature != NULL ) {
1243         *psignature = signature;
1244     } else if ( signature != NULL )  {
1245         jvmtiDeallocate(signature);
1246     }
1247     return error;
1248 }
1249 
1250 /* Get class name (not signature) */
1251 char *
1252 getClassname(jclass clazz)
1253 {
1254     char *classname;
1255 
1256     classname = NULL;
1257     if ( clazz != NULL ) {
1258         if (classSignature(clazz, &amp;classname, NULL) != JVMTI_ERROR_NONE) {
1259             classname = NULL;
1260         } else {
1261             /* Convert in place */
1262             convertSignatureToClassname(classname);
1263         }
1264     }
1265     return classname; /* Caller must free this memory */
1266 }
1267 
1268 void
1269 writeGenericSignature(PacketOutputStream *out, char *genericSignature)
1270 {
1271     if (genericSignature == NULL) {
1272         (void)outStream_writeString(out, &quot;&quot;);
1273     } else {
1274         (void)outStream_writeString(out, genericSignature);
1275     }
1276 }
1277 
1278 jint
1279 classStatus(jclass clazz)
1280 {
1281     jint status;
1282     jvmtiError error;
1283 
1284     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassStatus)
1285                 (gdata-&gt;jvmti, clazz, &amp;status);
1286     if (error != JVMTI_ERROR_NONE) {
1287         EXIT_ERROR(error, &quot;on getting class status&quot;);
1288     }
1289     return status;
1290 }
1291 
1292 static jboolean
1293 isArrayClass(jclass clazz)
1294 {
1295     jboolean isArray = JNI_FALSE;
1296     jvmtiError error;
1297 
1298     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsArrayClass)
1299                 (gdata-&gt;jvmti, clazz, &amp;isArray);
1300     if (error != JVMTI_ERROR_NONE) {
1301         EXIT_ERROR(error, &quot;on checking for an array class&quot;);
1302     }
1303     return isArray;
1304 }
1305 
1306 static jboolean
1307 isInterface(jclass clazz)
1308 {
1309     jboolean isInterface = JNI_FALSE;
1310     jvmtiError error;
1311 
1312     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsInterface)
1313                 (gdata-&gt;jvmti, clazz, &amp;isInterface);
1314     if (error != JVMTI_ERROR_NONE) {
1315         EXIT_ERROR(error, &quot;on checking for an interface&quot;);
1316     }
1317     return isInterface;
1318 }
1319 
1320 jvmtiError
1321 isFieldSynthetic(jclass clazz, jfieldID field, jboolean *psynthetic)
1322 {
1323     jvmtiError error;
1324 
1325     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsFieldSynthetic)
1326                 (gdata-&gt;jvmti, clazz, field, psynthetic);
1327     if ( error == JVMTI_ERROR_MUST_POSSESS_CAPABILITY ) {
1328         /* If the query is not supported, we assume it is not synthetic. */
1329         *psynthetic = JNI_FALSE;
1330         return JVMTI_ERROR_NONE;
1331     }
1332     return error;
1333 }
1334 
1335 jvmtiError
1336 isMethodSynthetic(jmethodID method, jboolean *psynthetic)
1337 {
1338     jvmtiError error;
1339 
1340     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodSynthetic)
1341                 (gdata-&gt;jvmti, method, psynthetic);
1342     if ( error == JVMTI_ERROR_MUST_POSSESS_CAPABILITY ) {
1343         /* If the query is not supported, we assume it is not synthetic. */
1344         *psynthetic = JNI_FALSE;
1345         return JVMTI_ERROR_NONE;
1346     }
1347     return error;
1348 }
1349 
1350 jboolean
1351 isMethodNative(jmethodID method)
1352 {
1353     jboolean isNative = JNI_FALSE;
1354     jvmtiError error;
1355 
1356     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodNative)
1357                 (gdata-&gt;jvmti, method, &amp;isNative);
1358     if (error != JVMTI_ERROR_NONE) {
1359         EXIT_ERROR(error, &quot;on checking for a native interface&quot;);
1360     }
1361     return isNative;
1362 }
1363 
1364 jboolean
1365 isSameObject(JNIEnv *env, jobject o1, jobject o2)
1366 {
1367     if ( o1==o2 ) {
1368         return JNI_TRUE;
1369     }
1370     return FUNC_PTR(env,IsSameObject)(env, o1, o2);
1371 }
1372 
1373 jint
1374 objectHashCode(jobject object)
1375 {
1376     jint hashCode = 0;
1377     jvmtiError error;
1378 
1379     if ( object!=NULL ) {
1380         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetObjectHashCode)
1381                     (gdata-&gt;jvmti, object, &amp;hashCode);
1382         if (error != JVMTI_ERROR_NONE) {
1383             EXIT_ERROR(error, &quot;on getting an object hash code&quot;);
1384         }
1385     }
1386     return hashCode;
1387 }
1388 
1389 /* Get all implemented interfaces (must be inside a WITH_LOCAL_REFS) */
1390 jvmtiError
1391 allInterfaces(jclass clazz, jclass **ppinterfaces, jint *pcount)
1392 {
1393     jvmtiError error;
1394 
1395     *pcount = 0;
1396     *ppinterfaces = NULL;
1397     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetImplementedInterfaces)
1398                 (gdata-&gt;jvmti, clazz, pcount, ppinterfaces);
1399     return error;
1400 }
1401 
1402 /* Get all loaded classes (must be inside a WITH_LOCAL_REFS) */
1403 jvmtiError
1404 allLoadedClasses(jclass **ppclasses, jint *pcount)
1405 {
1406     jvmtiError error;
1407 
1408     *pcount = 0;
1409     *ppclasses = NULL;
1410     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetLoadedClasses)
1411                 (gdata-&gt;jvmti, pcount, ppclasses);
1412     return error;
1413 }
1414 
1415 /* Get all loaded classes for a loader (must be inside a WITH_LOCAL_REFS) */
1416 jvmtiError
1417 allClassLoaderClasses(jobject loader, jclass **ppclasses, jint *pcount)
1418 {
1419     jvmtiError error;
1420 
1421     *pcount = 0;
1422     *ppclasses = NULL;
1423     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetClassLoaderClasses)
1424                 (gdata-&gt;jvmti, loader, pcount, ppclasses);
1425     return error;
1426 }
1427 
1428 static jboolean
1429 is_a_nested_class(char *outer_sig, int outer_sig_len, char *sig, int sep)
1430 {
1431     char *inner;
1432 
1433     /* Assumed outer class signature is  &quot;LOUTERCLASSNAME;&quot;
1434      *         inner class signature is  &quot;LOUTERCLASSNAME$INNERNAME;&quot;
1435      *
1436      * INNERNAME can take the form:
1437      *    [0-9][1-9]*        anonymous class somewhere in the file
1438      *    [0-9][1-9]*NAME    local class somewhere in the OUTER class
1439      *    NAME               nested class in OUTER
1440      *
1441      * If NAME itself contains a $ (sep) then classname is further nested
1442      *    inside another class.
1443      *
1444      */
1445 
1446     /* Check prefix first */
1447     if ( strncmp(sig, outer_sig, outer_sig_len-1) != 0 ) {
1448         return JNI_FALSE;
1449     }
1450 
1451     /* Prefix must be followed by a $ (sep) */
1452     if ( sig[outer_sig_len-1] != sep ) {
1453         return JNI_FALSE;  /* No sep follows the match, must not be nested. */
1454     }
1455 
1456     /* Walk past any digits, if we reach the end, must be pure anonymous */
1457     inner = sig + outer_sig_len;
1458 #if 1 /* We want to return local classes */
1459     while ( *inner &amp;&amp; isdigit(*inner) ) {
1460         inner++;
1461     }
1462     /* But anonymous class names can&#39;t be trusted. */
1463     if ( *inner == &#39;;&#39; ) {
1464         return JNI_FALSE;  /* A pure anonymous class */
1465     }
1466 #else
1467     if ( *inner &amp;&amp; isdigit(*inner) ) {
1468         return JNI_FALSE;  /* A pure anonymous or local class */
1469     }
1470 #endif
1471 
1472     /* Nested deeper? */
1473     if ( strchr(inner, sep) != NULL ) {
1474         return JNI_FALSE;  /* Nested deeper than we want? */
1475     }
1476     return JNI_TRUE;
1477 }
1478 
1479 /* Get all nested classes for a class (must be inside a WITH_LOCAL_REFS) */
1480 jvmtiError
1481 allNestedClasses(jclass parent_clazz, jclass **ppnested, jint *pcount)
1482 {
1483     jvmtiError error;
1484     jobject parent_loader;
1485     jclass *classes;
1486     char *signature;
1487     size_t len;
1488     jint count;
1489     jint ncount;
1490     int i;
1491 
1492     *ppnested   = NULL;
1493     *pcount     = 0;
1494 
1495     parent_loader = NULL;
1496     classes       = NULL;
1497     signature     = NULL;
1498     count         = 0;
1499     ncount        = 0;
1500 
1501     error = classLoader(parent_clazz, &amp;parent_loader);
1502     if (error != JVMTI_ERROR_NONE) {
1503         return error;
1504     }
1505     error = classSignature(parent_clazz, &amp;signature, NULL);
1506     if (error != JVMTI_ERROR_NONE) {
1507         return error;
1508     }
1509     len = strlen(signature);
1510 
1511     error = allClassLoaderClasses(parent_loader, &amp;classes, &amp;count);
1512     if ( error != JVMTI_ERROR_NONE ) {
1513         jvmtiDeallocate(signature);
1514         return error;
1515     }
1516 
1517     for (i=0; i&lt;count; i++) {
1518         jclass clazz;
1519         char *candidate_signature;
1520 
1521         clazz = classes[i];
1522         candidate_signature = NULL;
1523         error = classSignature(clazz, &amp;candidate_signature, NULL);
1524         if (error != JVMTI_ERROR_NONE) {
1525             break;
1526         }
1527 
1528         if ( is_a_nested_class(signature, (int)len, candidate_signature, &#39;$&#39;) ||
1529              is_a_nested_class(signature, (int)len, candidate_signature, &#39;#&#39;) ) {
1530             /* Float nested classes to top */
1531             classes[i] = classes[ncount];
1532             classes[ncount++] = clazz;
1533         }
1534         jvmtiDeallocate(candidate_signature);
1535     }
1536 
1537     jvmtiDeallocate(signature);
1538 
1539     if ( count != 0 &amp;&amp;  ncount == 0 ) {
1540         jvmtiDeallocate(classes);
1541         classes = NULL;
1542     }
1543 
1544     *ppnested = classes;
1545     *pcount = ncount;
1546     return error;
1547 }
1548 
1549 void
1550 createLocalRefSpace(JNIEnv *env, jint capacity)
1551 {
1552     /*
1553      * Save current exception since it might get overwritten by
1554      * the calls below. Note we must depend on space in the existing
1555      * frame because asking for a new frame may generate an exception.
1556      */
1557     jobject throwable = JNI_FUNC_PTR(env,ExceptionOccurred)(env);
1558 
1559     /*
1560      * Use the current frame if necessary; otherwise create a new one
1561      */
1562     if (JNI_FUNC_PTR(env,PushLocalFrame)(env, capacity) &lt; 0) {
1563         EXIT_ERROR(AGENT_ERROR_OUT_OF_MEMORY,&quot;PushLocalFrame: Unable to push JNI frame&quot;);
1564     }
1565 
1566     /*
1567      * TO DO: This could be more efficient if it used EnsureLocalCapacity,
1568      * but that would not work if two functions on the call stack
1569      * use this function. We would need to either track reserved
1570      * references on a per-thread basis or come up with a convention
1571      * that would prevent two functions from depending on this function
1572      * at the same time.
1573      */
1574 
1575     /*
1576      * Restore exception state from before call
1577      */
1578     if (throwable != NULL) {
1579         JNI_FUNC_PTR(env,Throw)(env, throwable);
1580     } else {
1581         JNI_FUNC_PTR(env,ExceptionClear)(env);
1582     }
1583 }
1584 
1585 jboolean
1586 isClass(jobject object)
1587 {
1588     JNIEnv *env = getEnv();
1589     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classClass);
1590 }
1591 
1592 jboolean
1593 isThread(jobject object)
1594 {
1595     JNIEnv *env = getEnv();
1596     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadClass);
1597 }
1598 
1599 jboolean
1600 isThreadGroup(jobject object)
1601 {
1602     JNIEnv *env = getEnv();
1603     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;threadGroupClass);
1604 }
1605 
1606 jboolean
1607 isString(jobject object)
1608 {
1609     JNIEnv *env = getEnv();
1610     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;stringClass);
1611 }
1612 
1613 jboolean
1614 isClassLoader(jobject object)
1615 {
1616     JNIEnv *env = getEnv();
1617     return JNI_FUNC_PTR(env,IsInstanceOf)(env, object, gdata-&gt;classLoaderClass);
1618 }
1619 
1620 jboolean
1621 isArray(jobject object)
1622 {
1623     JNIEnv *env = getEnv();
1624     jboolean is;
1625 
1626     WITH_LOCAL_REFS(env, 1) {
1627         jclass clazz;
1628         clazz = JNI_FUNC_PTR(env,GetObjectClass)(env, object);
1629         is = isArrayClass(clazz);
1630     } END_WITH_LOCAL_REFS(env);
1631 
1632     return is;
1633 }
1634 
1635 /**
1636  * Return property value as jstring
1637  */
1638 static jstring
1639 getPropertyValue(JNIEnv *env, char *propertyName)
1640 {
1641     jstring valueString;
1642     jstring nameString;
1643 
1644     valueString = NULL;
1645 
1646     /* Create new String object to hold the property name */
1647     nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, propertyName);
1648     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1649         JNI_FUNC_PTR(env,ExceptionClear)(env);
1650         /* NULL will be returned below */
1651     } else {
1652         /* Call valueString = System.getProperty(nameString) */
1653         valueString = JNI_FUNC_PTR(env,CallStaticObjectMethod)
1654             (env, gdata-&gt;systemClass, gdata-&gt;systemGetProperty, nameString);
1655         if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1656             JNI_FUNC_PTR(env,ExceptionClear)(env);
1657             valueString = NULL;
1658         }
1659     }
1660     return valueString;
1661 }
1662 
1663 /**
1664  * Set an agent property
1665  */
1666 void
1667 setAgentPropertyValue(JNIEnv *env, char *propertyName, char* propertyValue)
1668 {
1669     jstring nameString;
1670     jstring valueString;
1671 
1672     if (gdata-&gt;agent_properties == NULL) {
1673         /* VMSupport doesn&#39;t exist; so ignore */
1674         return;
1675     }
1676 
1677     /* Create jstrings for property name and value */
1678     nameString = JNI_FUNC_PTR(env,NewStringUTF)(env, propertyName);
1679     if (nameString != NULL) {
1680         valueString = JNU_NewStringPlatform(env, propertyValue);
1681         if (valueString != NULL) {
1682             /* invoke Properties.setProperty */
1683             JNI_FUNC_PTR(env,CallObjectMethod)
1684                 (env, gdata-&gt;agent_properties,
1685                  gdata-&gt;setProperty,
1686                  nameString, valueString);
1687         }
1688     }
1689     if (JNI_FUNC_PTR(env,ExceptionOccurred)(env)) {
1690         JNI_FUNC_PTR(env,ExceptionClear)(env);
1691     }
1692 }
1693 
1694 /**
1695  * Return property value as JDWP allocated string in UTF8 encoding
1696  */
1697 static char *
1698 getPropertyUTF8(JNIEnv *env, char *propertyName)
1699 {
1700     jvmtiError  error;
1701     char       *value;
1702 
1703     value = NULL;
1704     error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,GetSystemProperty)
1705                 (gdata-&gt;jvmti, (const char *)propertyName, &amp;value);
1706     if (error != JVMTI_ERROR_NONE) {
1707         jstring valueString;
1708 
1709         value = NULL;
1710         valueString = getPropertyValue(env, propertyName);
1711 
1712         if (valueString != NULL) {
1713             const char *utf;
1714 
1715             /* Get the UTF8 encoding for this property value string */
1716             utf = JNI_FUNC_PTR(env,GetStringUTFChars)(env, valueString, NULL);
1717             /* Make a copy for returning, release the JNI copy */
1718             value = jvmtiAllocate((int)strlen(utf) + 1);
1719             if (value != NULL) {
1720                 (void)strcpy(value, utf);
1721             }
1722             JNI_FUNC_PTR(env,ReleaseStringUTFChars)(env, valueString, utf);
1723         }
1724     }
1725     if ( value == NULL ) {
1726         ERROR_MESSAGE((&quot;JDWP Can&#39;t get property value for %s&quot;, propertyName));
1727         EXIT_ERROR(AGENT_ERROR_NULL_POINTER,NULL);
1728     }
1729     return value;
1730 }
1731 
1732 jboolean
1733 isMethodObsolete(jmethodID method)
1734 {
1735     jvmtiError error;
1736     jboolean obsolete = JNI_TRUE;
1737 
1738     if ( method != NULL ) {
1739         error = JVMTI_FUNC_PTR(gdata-&gt;jvmti,IsMethodObsolete)
1740                     (gdata-&gt;jvmti, method, &amp;obsolete);
1741         if (error != JVMTI_ERROR_NONE) {
1742             obsolete = JNI_TRUE;
1743         }
1744     }
1745     return obsolete;
1746 }
1747 
1748 /* Get the jvmti environment to be used with tags */
1749 jvmtiEnv *
1750 getSpecialJvmti(void)
1751 {
1752     jvmtiEnv  *jvmti;
1753     jvmtiError error;
1754     int        rc;
1755 
1756     /* Get one time use JVMTI Env */
1757     jvmtiCapabilities caps;
1758 
1759     rc = JVM_FUNC_PTR(gdata-&gt;jvm,GetEnv)
1760                      (gdata-&gt;jvm, (void **)&amp;jvmti, JVMTI_VERSION_1);
1761     if (rc != JNI_OK) {
1762         return NULL;
1763     }
1764     (void)memset(&amp;caps, 0, (int)sizeof(caps));
1765     caps.can_tag_objects = 1;
1766     error = JVMTI_FUNC_PTR(jvmti,AddCapabilities)(jvmti, &amp;caps);
1767     if ( error != JVMTI_ERROR_NONE ) {
1768         return NULL;
1769     }
1770     return jvmti;
1771 }
1772 
1773 void
1774 writeCodeLocation(PacketOutputStream *out, jclass clazz,
1775                        jmethodID method, jlocation location)
1776 {
1777     jbyte tag;
1778 
1779     if (clazz != NULL) {
1780         tag = referenceTypeTag(clazz);
1781     } else {
1782         tag = JDWP_TYPE_TAG(CLASS);
1783     }
1784     (void)outStream_writeByte(out, tag);
1785     (void)outStream_writeObjectRef(getEnv(), out, clazz);
1786     (void)outStream_writeMethodID(out, isMethodObsolete(method)?NULL:method);
1787     (void)outStream_writeLocation(out, location);
1788 }
1789 
1790 void *
1791 jvmtiAllocate(jint numBytes)
1792 {
1793     void *ptr;
1794     jvmtiError error;
1795     if ( numBytes == 0 ) {
1796         return NULL;
1797     }
1798     error = FUNC_PTR(gdata-&gt;jvmti,Allocate)
1799                 (gdata-&gt;jvmti, numBytes, (unsigned char**)&amp;ptr);
1800     if (error != JVMTI_ERROR_NONE ) {
1801         EXIT_ERROR(error, &quot;Can&#39;t allocate jvmti memory&quot;);
1802     }
1803     return ptr;
1804 }
1805 
1806 void
1807 jvmtiDeallocate(void *ptr)
1808 {
1809     jvmtiError error;
1810     if ( ptr == NULL ) {
1811         return;
1812     }
1813     error = FUNC_PTR(gdata-&gt;jvmti,Deallocate)
1814                 (gdata-&gt;jvmti, ptr);
1815     if (error != JVMTI_ERROR_NONE ) {
1816         EXIT_ERROR(error, &quot;Can&#39;t deallocate jvmti memory&quot;);
1817     }
1818 }
1819 
1820 /* Rarely needed, transport library uses JDWP errors, only use? */
1821 jvmtiError
1822 map2jvmtiError(jdwpError error)
1823 {
1824     switch ( error ) {
1825         case JDWP_ERROR(NONE):
1826             return JVMTI_ERROR_NONE;
1827         case JDWP_ERROR(INVALID_THREAD):
1828             return JVMTI_ERROR_INVALID_THREAD;
1829         case JDWP_ERROR(INVALID_THREAD_GROUP):
1830             return JVMTI_ERROR_INVALID_THREAD_GROUP;
1831         case JDWP_ERROR(INVALID_PRIORITY):
1832             return JVMTI_ERROR_INVALID_PRIORITY;
1833         case JDWP_ERROR(THREAD_NOT_SUSPENDED):
1834             return JVMTI_ERROR_THREAD_NOT_SUSPENDED;
1835         case JDWP_ERROR(THREAD_SUSPENDED):
1836             return JVMTI_ERROR_THREAD_SUSPENDED;
1837         case JDWP_ERROR(INVALID_OBJECT):
1838             return JVMTI_ERROR_INVALID_OBJECT;
1839         case JDWP_ERROR(INVALID_CLASS):
1840             return JVMTI_ERROR_INVALID_CLASS;
1841         case JDWP_ERROR(CLASS_NOT_PREPARED):
1842             return JVMTI_ERROR_CLASS_NOT_PREPARED;
1843         case JDWP_ERROR(INVALID_METHODID):
1844             return JVMTI_ERROR_INVALID_METHODID;
1845         case JDWP_ERROR(INVALID_LOCATION):
1846             return JVMTI_ERROR_INVALID_LOCATION;
1847         case JDWP_ERROR(INVALID_FIELDID):
1848             return JVMTI_ERROR_INVALID_FIELDID;
1849         case JDWP_ERROR(INVALID_FRAMEID):
1850             return AGENT_ERROR_INVALID_FRAMEID;
1851         case JDWP_ERROR(NO_MORE_FRAMES):
1852             return JVMTI_ERROR_NO_MORE_FRAMES;
1853         case JDWP_ERROR(OPAQUE_FRAME):
1854             return JVMTI_ERROR_OPAQUE_FRAME;
1855         case JDWP_ERROR(NOT_CURRENT_FRAME):
1856             return AGENT_ERROR_NOT_CURRENT_FRAME;
1857         case JDWP_ERROR(TYPE_MISMATCH):
1858             return JVMTI_ERROR_TYPE_MISMATCH;
1859         case JDWP_ERROR(INVALID_SLOT):
1860             return JVMTI_ERROR_INVALID_SLOT;
1861         case JDWP_ERROR(DUPLICATE):
1862             return JVMTI_ERROR_DUPLICATE;
1863         case JDWP_ERROR(NOT_FOUND):
1864             return JVMTI_ERROR_NOT_FOUND;
1865         case JDWP_ERROR(INVALID_MONITOR):
1866             return JVMTI_ERROR_INVALID_MONITOR;
1867         case JDWP_ERROR(NOT_MONITOR_OWNER):
1868             return JVMTI_ERROR_NOT_MONITOR_OWNER;
1869         case JDWP_ERROR(INTERRUPT):
1870             return JVMTI_ERROR_INTERRUPT;
1871         case JDWP_ERROR(INVALID_CLASS_FORMAT):
1872             return JVMTI_ERROR_INVALID_CLASS_FORMAT;
1873         case JDWP_ERROR(CIRCULAR_CLASS_DEFINITION):
1874             return JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION;
1875         case JDWP_ERROR(FAILS_VERIFICATION):
1876             return JVMTI_ERROR_FAILS_VERIFICATION;
1877         case JDWP_ERROR(ADD_METHOD_NOT_IMPLEMENTED):
1878             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED;
1879         case JDWP_ERROR(SCHEMA_CHANGE_NOT_IMPLEMENTED):
1880             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED;
1881         case JDWP_ERROR(INVALID_TYPESTATE):
1882             return JVMTI_ERROR_INVALID_TYPESTATE;
1883         case JDWP_ERROR(HIERARCHY_CHANGE_NOT_IMPLEMENTED):
1884             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED;
1885         case JDWP_ERROR(DELETE_METHOD_NOT_IMPLEMENTED):
1886             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED;
1887         case JDWP_ERROR(UNSUPPORTED_VERSION):
1888             return JVMTI_ERROR_UNSUPPORTED_VERSION;
1889         case JDWP_ERROR(NAMES_DONT_MATCH):
1890             return JVMTI_ERROR_NAMES_DONT_MATCH;
1891         case JDWP_ERROR(CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED):
1892             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED;
1893         case JDWP_ERROR(METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED):
1894             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED;
1895         case JDWP_ERROR(CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED):
1896             return JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED;
1897         case JDWP_ERROR(NOT_IMPLEMENTED):
1898             return JVMTI_ERROR_NOT_AVAILABLE;
1899         case JDWP_ERROR(NULL_POINTER):
1900             return JVMTI_ERROR_NULL_POINTER;
1901         case JDWP_ERROR(ABSENT_INFORMATION):
1902             return JVMTI_ERROR_ABSENT_INFORMATION;
1903         case JDWP_ERROR(INVALID_EVENT_TYPE):
1904             return JVMTI_ERROR_INVALID_EVENT_TYPE;
1905         case JDWP_ERROR(ILLEGAL_ARGUMENT):
1906             return JVMTI_ERROR_ILLEGAL_ARGUMENT;
1907         case JDWP_ERROR(OUT_OF_MEMORY):
1908             return JVMTI_ERROR_OUT_OF_MEMORY;
1909         case JDWP_ERROR(ACCESS_DENIED):
1910             return JVMTI_ERROR_ACCESS_DENIED;
1911         case JDWP_ERROR(VM_DEAD):
1912             return JVMTI_ERROR_WRONG_PHASE;
1913         case JDWP_ERROR(UNATTACHED_THREAD):
1914             return JVMTI_ERROR_UNATTACHED_THREAD;
1915         case JDWP_ERROR(INVALID_TAG):
1916             return AGENT_ERROR_INVALID_TAG;
1917         case JDWP_ERROR(ALREADY_INVOKING):
1918             return AGENT_ERROR_ALREADY_INVOKING;
1919         case JDWP_ERROR(INVALID_INDEX):
1920             return AGENT_ERROR_INVALID_INDEX;
1921         case JDWP_ERROR(INVALID_LENGTH):
1922             return AGENT_ERROR_INVALID_LENGTH;
1923         case JDWP_ERROR(INVALID_STRING):
1924             return AGENT_ERROR_INVALID_STRING;
1925         case JDWP_ERROR(INVALID_CLASS_LOADER):
1926             return AGENT_ERROR_INVALID_CLASS_LOADER;
1927         case JDWP_ERROR(INVALID_ARRAY):
1928             return AGENT_ERROR_INVALID_ARRAY;
1929         case JDWP_ERROR(TRANSPORT_LOAD):
1930             return AGENT_ERROR_TRANSPORT_LOAD;
1931         case JDWP_ERROR(TRANSPORT_INIT):
1932             return AGENT_ERROR_TRANSPORT_INIT;
1933         case JDWP_ERROR(NATIVE_METHOD):
1934             return AGENT_ERROR_NATIVE_METHOD;
1935         case JDWP_ERROR(INVALID_COUNT):
1936             return AGENT_ERROR_INVALID_COUNT;
1937         case JDWP_ERROR(INTERNAL):
1938             return AGENT_ERROR_JDWP_INTERNAL;
1939     }
1940     return AGENT_ERROR_INTERNAL;
1941 }
1942 
1943 static jvmtiEvent index2jvmti[EI_max-EI_min+1];
1944 static jdwpEvent  index2jdwp [EI_max-EI_min+1];
1945 
1946 void
1947 eventIndexInit(void)
1948 {
1949     (void)memset(index2jvmti, 0, (int)sizeof(index2jvmti));
1950     (void)memset(index2jdwp,  0, (int)sizeof(index2jdwp));
1951 
1952     index2jvmti[EI_SINGLE_STEP        -EI_min] = JVMTI_EVENT_SINGLE_STEP;
1953     index2jvmti[EI_BREAKPOINT         -EI_min] = JVMTI_EVENT_BREAKPOINT;
1954     index2jvmti[EI_FRAME_POP          -EI_min] = JVMTI_EVENT_FRAME_POP;
1955     index2jvmti[EI_EXCEPTION          -EI_min] = JVMTI_EVENT_EXCEPTION;
1956     index2jvmti[EI_THREAD_START       -EI_min] = JVMTI_EVENT_THREAD_START;
1957     index2jvmti[EI_THREAD_END         -EI_min] = JVMTI_EVENT_THREAD_END;
1958     index2jvmti[EI_CLASS_PREPARE      -EI_min] = JVMTI_EVENT_CLASS_PREPARE;
1959     index2jvmti[EI_GC_FINISH          -EI_min] = JVMTI_EVENT_GARBAGE_COLLECTION_FINISH;
1960     index2jvmti[EI_CLASS_LOAD         -EI_min] = JVMTI_EVENT_CLASS_LOAD;
1961     index2jvmti[EI_FIELD_ACCESS       -EI_min] = JVMTI_EVENT_FIELD_ACCESS;
1962     index2jvmti[EI_FIELD_MODIFICATION -EI_min] = JVMTI_EVENT_FIELD_MODIFICATION;
1963     index2jvmti[EI_EXCEPTION_CATCH    -EI_min] = JVMTI_EVENT_EXCEPTION_CATCH;
1964     index2jvmti[EI_METHOD_ENTRY       -EI_min] = JVMTI_EVENT_METHOD_ENTRY;
1965     index2jvmti[EI_METHOD_EXIT        -EI_min] = JVMTI_EVENT_METHOD_EXIT;
1966     index2jvmti[EI_MONITOR_CONTENDED_ENTER      -EI_min] = JVMTI_EVENT_MONITOR_CONTENDED_ENTER;
1967     index2jvmti[EI_MONITOR_CONTENDED_ENTERED    -EI_min] = JVMTI_EVENT_MONITOR_CONTENDED_ENTERED;
1968     index2jvmti[EI_MONITOR_WAIT       -EI_min] = JVMTI_EVENT_MONITOR_WAIT;
1969     index2jvmti[EI_MONITOR_WAITED     -EI_min] = JVMTI_EVENT_MONITOR_WAITED;
1970     index2jvmti[EI_VM_INIT            -EI_min] = JVMTI_EVENT_VM_INIT;
1971     index2jvmti[EI_VM_DEATH           -EI_min] = JVMTI_EVENT_VM_DEATH;
1972 
1973     index2jdwp[EI_SINGLE_STEP         -EI_min] = JDWP_EVENT(SINGLE_STEP);
1974     index2jdwp[EI_BREAKPOINT          -EI_min] = JDWP_EVENT(BREAKPOINT);
1975     index2jdwp[EI_FRAME_POP           -EI_min] = JDWP_EVENT(FRAME_POP);
1976     index2jdwp[EI_EXCEPTION           -EI_min] = JDWP_EVENT(EXCEPTION);
1977     index2jdwp[EI_THREAD_START        -EI_min] = JDWP_EVENT(THREAD_START);
1978     index2jdwp[EI_THREAD_END          -EI_min] = JDWP_EVENT(THREAD_END);
1979     index2jdwp[EI_CLASS_PREPARE       -EI_min] = JDWP_EVENT(CLASS_PREPARE);
1980     index2jdwp[EI_GC_FINISH           -EI_min] = JDWP_EVENT(CLASS_UNLOAD);
1981     index2jdwp[EI_CLASS_LOAD          -EI_min] = JDWP_EVENT(CLASS_LOAD);
1982     index2jdwp[EI_FIELD_ACCESS        -EI_min] = JDWP_EVENT(FIELD_ACCESS);
1983     index2jdwp[EI_FIELD_MODIFICATION  -EI_min] = JDWP_EVENT(FIELD_MODIFICATION);
1984     index2jdwp[EI_EXCEPTION_CATCH     -EI_min] = JDWP_EVENT(EXCEPTION_CATCH);
1985     index2jdwp[EI_METHOD_ENTRY        -EI_min] = JDWP_EVENT(METHOD_ENTRY);
1986     index2jdwp[EI_METHOD_EXIT         -EI_min] = JDWP_EVENT(METHOD_EXIT);
1987     index2jdwp[EI_MONITOR_CONTENDED_ENTER             -EI_min] = JDWP_EVENT(MONITOR_CONTENDED_ENTER);
1988     index2jdwp[EI_MONITOR_CONTENDED_ENTERED           -EI_min] = JDWP_EVENT(MONITOR_CONTENDED_ENTERED);
1989     index2jdwp[EI_MONITOR_WAIT        -EI_min] = JDWP_EVENT(MONITOR_WAIT);
1990     index2jdwp[EI_MONITOR_WAITED      -EI_min] = JDWP_EVENT(MONITOR_WAITED);
1991     index2jdwp[EI_VM_INIT             -EI_min] = JDWP_EVENT(VM_INIT);
1992     index2jdwp[EI_VM_DEATH            -EI_min] = JDWP_EVENT(VM_DEATH);
1993 }
1994 
1995 jdwpEvent
1996 eventIndex2jdwp(EventIndex i)
1997 {
1998     if ( i &lt; EI_min || i &gt; EI_max ) {
1999         EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;bad EventIndex&quot;);
2000     }
2001     return index2jdwp[i-EI_min];
2002 }
2003 
2004 jvmtiEvent
2005 eventIndex2jvmti(EventIndex i)
2006 {
2007     if ( i &lt; EI_min || i &gt; EI_max ) {
2008         EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;bad EventIndex&quot;);
2009     }
2010     return index2jvmti[i-EI_min];
2011 }
2012 
2013 EventIndex
2014 jdwp2EventIndex(jdwpEvent eventType)
2015 {
2016     switch ( eventType ) {
2017         case JDWP_EVENT(SINGLE_STEP):
2018             return EI_SINGLE_STEP;
2019         case JDWP_EVENT(BREAKPOINT):
2020             return EI_BREAKPOINT;
2021         case JDWP_EVENT(FRAME_POP):
2022             return EI_FRAME_POP;
2023         case JDWP_EVENT(EXCEPTION):
2024             return EI_EXCEPTION;
2025         case JDWP_EVENT(THREAD_START):
2026             return EI_THREAD_START;
2027         case JDWP_EVENT(THREAD_END):
2028             return EI_THREAD_END;
2029         case JDWP_EVENT(CLASS_PREPARE):
2030             return EI_CLASS_PREPARE;
2031         case JDWP_EVENT(CLASS_UNLOAD):
2032             return EI_GC_FINISH;
2033         case JDWP_EVENT(CLASS_LOAD):
2034             return EI_CLASS_LOAD;
2035         case JDWP_EVENT(FIELD_ACCESS):
2036             return EI_FIELD_ACCESS;
2037         case JDWP_EVENT(FIELD_MODIFICATION):
2038             return EI_FIELD_MODIFICATION;
2039         case JDWP_EVENT(EXCEPTION_CATCH):
2040             return EI_EXCEPTION_CATCH;
2041         case JDWP_EVENT(METHOD_ENTRY):
2042             return EI_METHOD_ENTRY;
2043         case JDWP_EVENT(METHOD_EXIT):
2044             return EI_METHOD_EXIT;
2045         case JDWP_EVENT(METHOD_EXIT_WITH_RETURN_VALUE):
2046             return EI_METHOD_EXIT;
2047         case JDWP_EVENT(MONITOR_CONTENDED_ENTER):
2048             return EI_MONITOR_CONTENDED_ENTER;
2049         case JDWP_EVENT(MONITOR_CONTENDED_ENTERED):
2050             return EI_MONITOR_CONTENDED_ENTERED;
2051         case JDWP_EVENT(MONITOR_WAIT):
2052             return EI_MONITOR_WAIT;
2053         case JDWP_EVENT(MONITOR_WAITED):
2054             return EI_MONITOR_WAITED;
2055         case JDWP_EVENT(VM_INIT):
2056             return EI_VM_INIT;
2057         case JDWP_EVENT(VM_DEATH):
2058             return EI_VM_DEATH;
2059         default:
2060             break;
2061     }
2062 
2063     /*
2064      * Event type not recognized - don&#39;t exit with error as caller
2065      * may wish to return error to debugger.
2066      */
2067     return (EventIndex)0;
2068 }
2069 
2070 EventIndex
2071 jvmti2EventIndex(jvmtiEvent kind)
2072 {
2073     switch ( kind ) {
2074         case JVMTI_EVENT_SINGLE_STEP:
2075             return EI_SINGLE_STEP;
2076         case JVMTI_EVENT_BREAKPOINT:
2077             return EI_BREAKPOINT;
2078         case JVMTI_EVENT_FRAME_POP:
2079             return EI_FRAME_POP;
2080         case JVMTI_EVENT_EXCEPTION:
2081             return EI_EXCEPTION;
2082         case JVMTI_EVENT_THREAD_START:
2083             return EI_THREAD_START;
2084         case JVMTI_EVENT_THREAD_END:
2085             return EI_THREAD_END;
2086         case JVMTI_EVENT_CLASS_PREPARE:
2087             return EI_CLASS_PREPARE;
2088         case JVMTI_EVENT_GARBAGE_COLLECTION_FINISH:
2089             return EI_GC_FINISH;
2090         case JVMTI_EVENT_CLASS_LOAD:
2091             return EI_CLASS_LOAD;
2092         case JVMTI_EVENT_FIELD_ACCESS:
2093             return EI_FIELD_ACCESS;
2094         case JVMTI_EVENT_FIELD_MODIFICATION:
2095             return EI_FIELD_MODIFICATION;
2096         case JVMTI_EVENT_EXCEPTION_CATCH:
2097             return EI_EXCEPTION_CATCH;
2098         case JVMTI_EVENT_METHOD_ENTRY:
2099             return EI_METHOD_ENTRY;
2100         case JVMTI_EVENT_METHOD_EXIT:
2101             return EI_METHOD_EXIT;
2102         /*
2103          * There is no JVMTI_EVENT_METHOD_EXIT_WITH_RETURN_VALUE.
2104          * The normal JVMTI_EVENT_METHOD_EXIT always contains the return value.
2105          */
2106         case JVMTI_EVENT_MONITOR_CONTENDED_ENTER:
2107             return EI_MONITOR_CONTENDED_ENTER;
2108         case JVMTI_EVENT_MONITOR_CONTENDED_ENTERED:
2109             return EI_MONITOR_CONTENDED_ENTERED;
2110         case JVMTI_EVENT_MONITOR_WAIT:
2111             return EI_MONITOR_WAIT;
2112         case JVMTI_EVENT_MONITOR_WAITED:
2113             return EI_MONITOR_WAITED;
2114         case JVMTI_EVENT_VM_INIT:
2115             return EI_VM_INIT;
2116         case JVMTI_EVENT_VM_DEATH:
2117             return EI_VM_DEATH;
2118         default:
2119             EXIT_ERROR(AGENT_ERROR_INVALID_INDEX,&quot;JVMTI to EventIndex mapping&quot;);
2120             break;
2121     }
2122     return (EventIndex)0;
2123 }
2124 
2125 /* This routine is commonly used, maps jvmti and agent errors to the best
2126  *    jdwp error code we can map to.
2127  */
2128 jdwpError
2129 map2jdwpError(jvmtiError error)
2130 {
2131     switch ( (int)error ) {
2132         case JVMTI_ERROR_NONE:
2133             return JDWP_ERROR(NONE);
2134         case AGENT_ERROR_INVALID_THREAD:
2135         case JVMTI_ERROR_INVALID_THREAD:
2136             return JDWP_ERROR(INVALID_THREAD);
2137         case JVMTI_ERROR_INVALID_THREAD_GROUP:
2138             return JDWP_ERROR(INVALID_THREAD_GROUP);
2139         case JVMTI_ERROR_INVALID_PRIORITY:
2140             return JDWP_ERROR(INVALID_PRIORITY);
2141         case JVMTI_ERROR_THREAD_NOT_SUSPENDED:
2142             return JDWP_ERROR(THREAD_NOT_SUSPENDED);
2143         case JVMTI_ERROR_THREAD_SUSPENDED:
2144             return JDWP_ERROR(THREAD_SUSPENDED);
2145         case JVMTI_ERROR_THREAD_NOT_ALIVE:
2146             return JDWP_ERROR(INVALID_THREAD);
2147         case AGENT_ERROR_INVALID_OBJECT:
2148         case JVMTI_ERROR_INVALID_OBJECT:
2149             return JDWP_ERROR(INVALID_OBJECT);
2150         case JVMTI_ERROR_INVALID_CLASS:
2151             return JDWP_ERROR(INVALID_CLASS);
2152         case JVMTI_ERROR_CLASS_NOT_PREPARED:
2153             return JDWP_ERROR(CLASS_NOT_PREPARED);
2154         case JVMTI_ERROR_INVALID_METHODID:
2155             return JDWP_ERROR(INVALID_METHODID);
2156         case JVMTI_ERROR_INVALID_LOCATION:
2157             return JDWP_ERROR(INVALID_LOCATION);
2158         case JVMTI_ERROR_INVALID_FIELDID:
2159             return JDWP_ERROR(INVALID_FIELDID);
2160         case AGENT_ERROR_NO_MORE_FRAMES:
2161         case JVMTI_ERROR_NO_MORE_FRAMES:
2162             return JDWP_ERROR(NO_MORE_FRAMES);
2163         case JVMTI_ERROR_OPAQUE_FRAME:
2164             return JDWP_ERROR(OPAQUE_FRAME);
2165         case JVMTI_ERROR_TYPE_MISMATCH:
2166             return JDWP_ERROR(TYPE_MISMATCH);
2167         case JVMTI_ERROR_INVALID_SLOT:
2168             return JDWP_ERROR(INVALID_SLOT);
2169         case JVMTI_ERROR_DUPLICATE:
2170             return JDWP_ERROR(DUPLICATE);
2171         case JVMTI_ERROR_NOT_FOUND:
2172             return JDWP_ERROR(NOT_FOUND);
2173         case JVMTI_ERROR_INVALID_MONITOR:
2174             return JDWP_ERROR(INVALID_MONITOR);
2175         case JVMTI_ERROR_NOT_MONITOR_OWNER:
2176             return JDWP_ERROR(NOT_MONITOR_OWNER);
2177         case JVMTI_ERROR_INTERRUPT:
2178             return JDWP_ERROR(INTERRUPT);
2179         case JVMTI_ERROR_INVALID_CLASS_FORMAT:
2180             return JDWP_ERROR(INVALID_CLASS_FORMAT);
2181         case JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION:
2182             return JDWP_ERROR(CIRCULAR_CLASS_DEFINITION);
2183         case JVMTI_ERROR_FAILS_VERIFICATION:
2184             return JDWP_ERROR(FAILS_VERIFICATION);
2185         case JVMTI_ERROR_INVALID_TYPESTATE:
2186             return JDWP_ERROR(INVALID_TYPESTATE);
2187         case JVMTI_ERROR_UNSUPPORTED_VERSION:
2188             return JDWP_ERROR(UNSUPPORTED_VERSION);
2189         case JVMTI_ERROR_NAMES_DONT_MATCH:
2190             return JDWP_ERROR(NAMES_DONT_MATCH);
2191         case AGENT_ERROR_NULL_POINTER:
2192         case JVMTI_ERROR_NULL_POINTER:
2193             return JDWP_ERROR(NULL_POINTER);
2194         case JVMTI_ERROR_ABSENT_INFORMATION:
2195             return JDWP_ERROR(ABSENT_INFORMATION);
2196         case AGENT_ERROR_INVALID_EVENT_TYPE:
2197         case JVMTI_ERROR_INVALID_EVENT_TYPE:
2198             return JDWP_ERROR(INVALID_EVENT_TYPE);
2199         case AGENT_ERROR_ILLEGAL_ARGUMENT:
2200         case JVMTI_ERROR_ILLEGAL_ARGUMENT:
2201             return JDWP_ERROR(ILLEGAL_ARGUMENT);
2202         case JVMTI_ERROR_OUT_OF_MEMORY:
2203         case AGENT_ERROR_OUT_OF_MEMORY:
2204             return JDWP_ERROR(OUT_OF_MEMORY);
2205         case JVMTI_ERROR_ACCESS_DENIED:
2206             return JDWP_ERROR(ACCESS_DENIED);
2207         case JVMTI_ERROR_WRONG_PHASE:
2208         case AGENT_ERROR_VM_DEAD:
2209         case AGENT_ERROR_NO_JNI_ENV:
2210             return JDWP_ERROR(VM_DEAD);
2211         case AGENT_ERROR_JNI_EXCEPTION:
2212         case JVMTI_ERROR_UNATTACHED_THREAD:
2213             return JDWP_ERROR(UNATTACHED_THREAD);
2214         case JVMTI_ERROR_NOT_AVAILABLE:
2215         case JVMTI_ERROR_MUST_POSSESS_CAPABILITY:
2216             return JDWP_ERROR(NOT_IMPLEMENTED);
2217         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED:
2218             return JDWP_ERROR(HIERARCHY_CHANGE_NOT_IMPLEMENTED);
2219         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED:
2220             return JDWP_ERROR(DELETE_METHOD_NOT_IMPLEMENTED);
2221         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED:
2222             return JDWP_ERROR(ADD_METHOD_NOT_IMPLEMENTED);
2223         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED:
2224             return JDWP_ERROR(SCHEMA_CHANGE_NOT_IMPLEMENTED);
2225         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED:
2226             return JDWP_ERROR(CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED);
2227         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED:
2228             return JDWP_ERROR(METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED);
2229         case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_ATTRIBUTE_CHANGED:
2230             return JDWP_ERROR(CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED);
2231         case AGENT_ERROR_NOT_CURRENT_FRAME:
2232             return JDWP_ERROR(NOT_CURRENT_FRAME);
2233         case AGENT_ERROR_INVALID_TAG:
2234             return JDWP_ERROR(INVALID_TAG);
2235         case AGENT_ERROR_ALREADY_INVOKING:
2236             return JDWP_ERROR(ALREADY_INVOKING);
2237         case AGENT_ERROR_INVALID_INDEX:
2238             return JDWP_ERROR(INVALID_INDEX);
2239         case AGENT_ERROR_INVALID_LENGTH:
2240             return JDWP_ERROR(INVALID_LENGTH);
2241         case AGENT_ERROR_INVALID_STRING:
2242             return JDWP_ERROR(INVALID_STRING);
2243         case AGENT_ERROR_INVALID_CLASS_LOADER:
2244             return JDWP_ERROR(INVALID_CLASS_LOADER);
2245         case AGENT_ERROR_INVALID_ARRAY:
2246             return JDWP_ERROR(INVALID_ARRAY);
2247         case AGENT_ERROR_TRANSPORT_LOAD:
2248             return JDWP_ERROR(TRANSPORT_LOAD);
2249         case AGENT_ERROR_TRANSPORT_INIT:
2250             return JDWP_ERROR(TRANSPORT_INIT);
2251         case AGENT_ERROR_NATIVE_METHOD:
2252             return JDWP_ERROR(NATIVE_METHOD);
2253         case AGENT_ERROR_INVALID_COUNT:
2254             return JDWP_ERROR(INVALID_COUNT);
2255         case AGENT_ERROR_INVALID_FRAMEID:
2256             return JDWP_ERROR(INVALID_FRAMEID);
2257         case JVMTI_ERROR_INTERNAL:
2258         case JVMTI_ERROR_INVALID_ENVIRONMENT:
2259         case AGENT_ERROR_INTERNAL:
2260         case AGENT_ERROR_JVMTI_INTERNAL:
2261         case AGENT_ERROR_JDWP_INTERNAL:
2262             return JDWP_ERROR(INTERNAL);
2263         default:
2264             break;
2265     }
2266     return JDWP_ERROR(INTERNAL);
2267 }
2268 
2269 jint
2270 map2jdwpSuspendStatus(jint state)
2271 {
2272     jint status = 0;
2273     if ( ( state &amp; JVMTI_THREAD_STATE_SUSPENDED ) != 0 )  {
2274         status = JDWP_SUSPEND_STATUS(SUSPENDED);
2275     }
2276     return status;
2277 }
2278 
2279 jdwpThreadStatus
2280 map2jdwpThreadStatus(jint state)
2281 {
2282     jdwpThreadStatus status;
2283 
2284     status = (jdwpThreadStatus)(-1);
2285 
2286     if ( ! ( state &amp; JVMTI_THREAD_STATE_ALIVE ) ) {
2287         if ( state &amp; JVMTI_THREAD_STATE_TERMINATED ) {
2288             status = JDWP_THREAD_STATUS(ZOMBIE);
2289         } else {
2290             /* FIXUP? New JDWP #define for not started? */
2291             status = (jdwpThreadStatus)(-1);
2292         }
2293     } else {
2294         if ( state &amp; JVMTI_THREAD_STATE_SLEEPING ) {
2295             status = JDWP_THREAD_STATUS(SLEEPING);
2296         } else if ( state &amp; JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER ) {
2297             status = JDWP_THREAD_STATUS(MONITOR);
2298         } else if ( state &amp; JVMTI_THREAD_STATE_WAITING ) {
2299             status = JDWP_THREAD_STATUS(WAIT);
2300         } else if ( state &amp; JVMTI_THREAD_STATE_RUNNABLE ) {
2301             status = JDWP_THREAD_STATUS(RUNNING);
2302         }
2303     }
2304     return status;
2305 }
2306 
2307 jint
2308 map2jdwpClassStatus(jint classStatus)
2309 {
2310     jint status = 0;
2311     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_VERIFIED ) != 0 ) {
2312         status |= JDWP_CLASS_STATUS(VERIFIED);
2313     }
2314     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_PREPARED ) != 0 ) {
2315         status |= JDWP_CLASS_STATUS(PREPARED);
2316     }
2317     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_INITIALIZED ) != 0 ) {
2318         status |= JDWP_CLASS_STATUS(INITIALIZED);
2319     }
2320     if ( ( classStatus &amp; JVMTI_CLASS_STATUS_ERROR ) != 0 ) {
2321         status |= JDWP_CLASS_STATUS(ERROR);
2322     }
2323     return status;
2324 }
2325 
2326 void
2327 log_debugee_location(const char *func,
2328         jthread thread, jmethodID method, jlocation location)
2329 {
2330     int logging_locations = LOG_TEST(JDWP_LOG_LOC);
2331 
2332     if ( logging_locations ) {
2333         char *method_name;
2334         char *class_sig;
2335         jvmtiError error;
2336         jvmtiThreadInfo info;
2337         jint state;
2338 
2339         /* Get thread information */
2340         info.name = NULL;
2341         error = FUNC_PTR(gdata-&gt;jvmti,GetThreadInfo)
2342                                 (gdata-&gt;jvmti, thread, &amp;info);
2343         if ( error != JVMTI_ERROR_NONE) {
2344             info.name = NULL;
2345         }
2346         error = FUNC_PTR(gdata-&gt;jvmti,GetThreadState)
2347                                 (gdata-&gt;jvmti, thread, &amp;state);
2348         if ( error != JVMTI_ERROR_NONE) {
2349             state = 0;
2350         }
2351 
2352         /* Get method if necessary */
2353         if ( method==NULL ) {
2354             error = FUNC_PTR(gdata-&gt;jvmti,GetFrameLocation)
2355                         (gdata-&gt;jvmti, thread, 0, &amp;method, &amp;location);
2356             if ( error != JVMTI_ERROR_NONE ) {
2357                 method = NULL;
2358                 location = 0;
2359             }
2360         }
2361 
2362         /* Get method name */
2363         method_name = NULL;
2364         if ( method != NULL ) {
2365             error = methodSignature(method, &amp;method_name, NULL, NULL);
2366             if ( error != JVMTI_ERROR_NONE ) {
2367                 method_name = NULL;
2368             }
2369         }
2370 
2371         /* Get class signature */
2372         class_sig = NULL;
2373         if ( method != NULL ) {
2374             jclass clazz;
2375 
2376             error = methodClass(method, &amp;clazz);
2377             if ( error == JVMTI_ERROR_NONE ) {
2378                 error = classSignature(clazz, &amp;class_sig, NULL);
2379                 if ( error != JVMTI_ERROR_NONE ) {
2380                     class_sig = NULL;
2381                 }
2382             }
2383         }
2384 
2385         /* Issue log message */
2386         LOG_LOC((&quot;%s: debugee: thread=%p(%s:0x%x),method=%p(%s@%d;%s)&quot;,
2387                 func,
2388                 thread, info.name==NULL ? &quot;?&quot; : info.name, state,
2389                 method, method_name==NULL ? &quot;?&quot; : method_name,
2390                 (int)location, class_sig==NULL ? &quot;?&quot; : class_sig));
2391 
2392         /* Free memory */
2393         if ( class_sig != NULL ) {
2394             jvmtiDeallocate(class_sig);
2395         }
2396         if ( method_name != NULL ) {
2397             jvmtiDeallocate(method_name);
2398         }
2399         if ( info.name != NULL ) {
2400             jvmtiDeallocate(info.name);
2401         }
2402     }
2403 }
2404 
2405 /* ********************************************************************* */
2406 /* JDK 6.0: Use of new Heap Iteration functions */
2407 /* ********************************************************************* */
2408 
2409 /* ********************************************************************* */
2410 /* Instances */
2411 
2412 /* Structure to hold class instances heap iteration data (arg user_data) */
2413 typedef struct ClassInstancesData {
2414     jint         instCount;
2415     jint         maxInstances;
2416     jlong        objTag;
2417     jvmtiError   error;
2418 } ClassInstancesData;
2419 
2420 /* Callback for instance object tagging (heap_reference_callback). */
2421 static jint JNICALL
2422 cbObjectTagInstance(jvmtiHeapReferenceKind reference_kind,
2423      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2424      jlong referrer_class_tag, jlong size,
2425      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2426 {
2427     ClassInstancesData  *data;
2428 
2429     /* Check data structure */
2430     data = (ClassInstancesData*)user_data;
2431     if (data == NULL) {
2432         return JVMTI_VISIT_ABORT;
2433     }
2434 
2435     /* If we have tagged enough objects, just abort */
2436     if ( data-&gt;maxInstances != 0 &amp;&amp; data-&gt;instCount &gt;= data-&gt;maxInstances ) {
2437         return JVMTI_VISIT_ABORT;
2438     }
2439 
2440     /* If tagged already, just continue */
2441     if ( (*tag_ptr) != (jlong)0 ) {
2442         return JVMTI_VISIT_OBJECTS;
2443     }
2444 
2445     /* Tag the object so we don&#39;t count it again, and so we can retrieve it */
2446     (*tag_ptr) = data-&gt;objTag;
2447     data-&gt;instCount++;
2448     return JVMTI_VISIT_OBJECTS;
2449 }
2450 
2451 /* Get instances for one class */
2452 jvmtiError
2453 classInstances(jclass klass, ObjectBatch *instances, int maxInstances)
2454 {
2455     ClassInstancesData data;
2456     jvmtiHeapCallbacks heap_callbacks;
2457     jvmtiError         error;
2458     jvmtiEnv          *jvmti;
2459 
2460     /* Check interface assumptions */
2461 
2462     if (klass == NULL) {
2463         return AGENT_ERROR_INVALID_OBJECT;
2464     }
2465 
2466     if ( maxInstances &lt; 0 || instances == NULL) {
2467         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2468     }
2469 
2470     /* Initialize return information */
2471     instances-&gt;count   = 0;
2472     instances-&gt;objects = NULL;
2473 
2474     /* Get jvmti environment to use */
2475     jvmti = getSpecialJvmti();
2476     if ( jvmti == NULL ) {
2477         return AGENT_ERROR_INTERNAL;
2478     }
2479 
2480     /* Setup data to passed around the callbacks */
2481     data.instCount    = 0;
2482     data.maxInstances = maxInstances;
2483     data.objTag       = (jlong)1;
2484     data.error        = JVMTI_ERROR_NONE;
2485 
2486     /* Clear out callbacks structure */
2487     (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2488 
2489     /* Set the callbacks we want */
2490     heap_callbacks.heap_reference_callback = &amp;cbObjectTagInstance;
2491 
2492     /* Follow references, no initiating object, just this class, all objects */
2493     error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2494                  (jvmti, 0, klass, NULL, &amp;heap_callbacks, &amp;data);
2495     if ( error == JVMTI_ERROR_NONE ) {
2496         error = data.error;
2497     }
2498 
2499     /* Get all the instances now that they are tagged */
2500     if ( error == JVMTI_ERROR_NONE ) {
2501         error = JVMTI_FUNC_PTR(jvmti,GetObjectsWithTags)
2502                       (jvmti, 1, &amp;(data.objTag), &amp;(instances-&gt;count),
2503                        &amp;(instances-&gt;objects), NULL);
2504         /* Verify we got the count we expected */
2505         if ( data.instCount != instances-&gt;count ) {
2506             error = AGENT_ERROR_INTERNAL;
2507         }
2508     }
2509 
2510     /* Dispose of any special jvmti environment */
2511     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2512     return error;
2513 }
2514 
2515 /* ********************************************************************* */
2516 /* Instance counts. */
2517 
2518 /* Macros to convert a class or instance tag to an index and back again */
2519 #define INDEX2CLASSTAG(i)      ((jlong)((i)+1))
2520 #define CLASSTAG2INDEX(t)      (((int)(t))-1)
2521 #define JLONG_ABS(x)           (((x)&lt;(jlong)0)?-(x):(x))
2522 
2523 /* Structure to hold class count heap traversal data (arg user_data) */
2524 typedef struct ClassCountData {
2525     int          classCount;
2526     jlong       *counts;
2527     jlong        negObjTag;
2528     jvmtiError   error;
2529 } ClassCountData;
2530 
2531 /* Two different cbObjectCounter&#39;s, one for FollowReferences, one for
2532  *    IterateThroughHeap. Pick a card, any card.
2533  */
2534 
2535 /* Callback for object count heap traversal (heap_reference_callback) */
2536 static jint JNICALL
2537 cbObjectCounterFromRef(jvmtiHeapReferenceKind reference_kind,
2538      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2539      jlong referrer_class_tag, jlong size,
2540      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2541 {
2542     ClassCountData  *data;
2543     int              index;
2544     jlong            jindex;
2545     jlong            tag;
2546 
2547     /* Check data structure */
2548     data = (ClassCountData*)user_data;
2549     if (data == NULL) {
2550         return JVMTI_VISIT_ABORT;
2551     }
2552 
2553     /* Classes with no class_tag should have been filtered out. */
2554     if ( class_tag == (jlong)0 ) {
2555         data-&gt;error = AGENT_ERROR_INTERNAL;
2556         return JVMTI_VISIT_ABORT;
2557     }
2558 
2559     /* Class tag not one we really want (jclass not in supplied list) */
2560     if ( class_tag == data-&gt;negObjTag ) {
2561         return JVMTI_VISIT_OBJECTS;
2562     }
2563 
2564     /* If object tag is negative, just continue, we counted it */
2565     tag = (*tag_ptr);
2566     if ( tag &lt; (jlong)0 ) {
2567         return JVMTI_VISIT_OBJECTS;
2568     }
2569 
2570     /* Tag the object with a negative value just so we don&#39;t count it again */
2571     if ( tag == (jlong)0 ) {
2572         /* This object had no tag value, so we give it the negObjTag value */
2573         (*tag_ptr) = data-&gt;negObjTag;
2574     } else {
2575         /* If this object had a positive tag value, it must be one of the
2576          *    jclass objects we tagged. We need to preserve the value of
2577          *    this tag for later objects that might have this as a class
2578          *    tag, so we just make the existing tag value negative.
2579          */
2580         (*tag_ptr) = -tag;
2581     }
2582 
2583     /* Absolute value of class tag is an index into the counts[] array */
2584     jindex = JLONG_ABS(class_tag);
2585     index = CLASSTAG2INDEX(jindex);
2586     if (index &lt; 0 || index &gt;= data-&gt;classCount) {
2587         data-&gt;error = AGENT_ERROR_ILLEGAL_ARGUMENT;
2588         return JVMTI_VISIT_ABORT;
2589     }
2590 
2591     /* Bump instance count on this class */
2592     data-&gt;counts[index]++;
2593     return JVMTI_VISIT_OBJECTS;
2594 }
2595 
2596 /* Callback for instance count heap traversal (heap_iteration_callback) */
2597 static jint JNICALL
2598 cbObjectCounter(jlong class_tag, jlong size, jlong* tag_ptr, jint length,
2599                         void* user_data)
2600 {
2601     ClassCountData  *data;
2602     int              index;
2603 
2604     /* Check data structure */
2605     data = (ClassCountData*)user_data;
2606     if (data == NULL) {
2607         return JVMTI_VISIT_ABORT;
2608     }
2609 
2610     /* Classes with no tag should be filtered out. */
2611     if ( class_tag == (jlong)0 ) {
2612         data-&gt;error = AGENT_ERROR_INTERNAL;
2613         return JVMTI_VISIT_ABORT;
2614     }
2615 
2616     /* Class tag is actually an index into data arrays */
2617     index = CLASSTAG2INDEX(class_tag);
2618     if (index &lt; 0 || index &gt;= data-&gt;classCount) {
2619         data-&gt;error = AGENT_ERROR_ILLEGAL_ARGUMENT;
2620         return JVMTI_VISIT_ABORT;
2621     }
2622 
2623     /* Bump instance count on this class */
2624     data-&gt;counts[index]++;
2625     return JVMTI_VISIT_OBJECTS;
2626 }
2627 
2628 /* Get instance counts for a set of classes */
2629 jvmtiError
2630 classInstanceCounts(jint classCount, jclass *classes, jlong *counts)
2631 {
2632     jvmtiHeapCallbacks heap_callbacks;
2633     ClassCountData     data;
2634     jvmtiError         error;
2635     jvmtiEnv          *jvmti;
2636     int                i;
2637 
2638     /* Check interface assumptions */
2639     if ( classes == NULL || classCount &lt;= 0 || counts == NULL ) {
2640         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2641     }
2642 
2643     /* Initialize return information */
2644     for ( i = 0 ; i &lt; classCount ; i++ ) {
2645         counts[i] = (jlong)0;
2646     }
2647 
2648     /* Get jvmti environment to use */
2649     jvmti = getSpecialJvmti();
2650     if ( jvmti == NULL ) {
2651         return AGENT_ERROR_INTERNAL;
2652     }
2653 
2654     /* Setup class data structure */
2655     data.error        = JVMTI_ERROR_NONE;
2656     data.classCount   = classCount;
2657     data.counts       = counts;
2658 
2659     error = JVMTI_ERROR_NONE;
2660     /* Set tags on classes, use index in classes[] as the tag value. */
2661     error             = JVMTI_ERROR_NONE;
2662     for ( i = 0 ; i &lt; classCount ; i++ ) {
2663         if (classes[i] != NULL) {
2664             jlong tag;
2665 
2666             tag = INDEX2CLASSTAG(i);
2667             error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, classes[i], tag);
2668             if ( error != JVMTI_ERROR_NONE ) {
2669                 break;
2670             }
2671         }
2672     }
2673 
2674     /* Traverse heap, two ways to do this for instance counts. */
2675     if ( error == JVMTI_ERROR_NONE ) {
2676 
2677         /* Clear out callbacks structure */
2678         (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2679 
2680         /* Check debug flags to see how to do this. */
2681         if ( (gdata-&gt;debugflags &amp; USE_ITERATE_THROUGH_HEAP) == 0 ) {
2682 
2683             /* Using FollowReferences only gives us live objects, but we
2684              *   need to tag the objects to avoid counting them twice since
2685              *   the callback is per reference.
2686              *   The jclass objects have been tagged with their index in the
2687              *   supplied list, and that tag may flip to negative if it
2688              *   is also an object of interest.
2689              *   All other objects being counted that weren&#39;t in the
2690              *   supplied classes list will have a negative classCount
2691              *   tag value. So all objects counted will have negative tags.
2692              *   If the absolute tag value is an index in the supplied
2693              *   list, then it&#39;s one of the supplied classes.
2694              */
2695             data.negObjTag = -INDEX2CLASSTAG(classCount);
2696 
2697             /* Setup callbacks, only using object reference callback */
2698             heap_callbacks.heap_reference_callback = &amp;cbObjectCounterFromRef;
2699 
2700             /* Follow references, no initiating object, tagged classes only */
2701             error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2702                           (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,
2703                            NULL, NULL, &amp;heap_callbacks, &amp;data);
2704 
2705         } else {
2706 
2707             /* Using IterateThroughHeap means that we will visit each object
2708              *   once, so no special tag tricks here. Just simple counting.
2709              *   However in this case the object might not be live, so we do
2710              *   a GC beforehand to make sure we minimize this.
2711              */
2712 
2713             /* FIXUP: Need some kind of trigger here to avoid excessive GC&#39;s? */
2714             error = JVMTI_FUNC_PTR(jvmti,ForceGarbageCollection)(jvmti);
2715             if ( error != JVMTI_ERROR_NONE ) {
2716 
2717                 /* Setup callbacks, just need object callback */
2718                 heap_callbacks.heap_iteration_callback = &amp;cbObjectCounter;
2719 
2720                 /* Iterate through entire heap, tagged classes only */
2721                 error = JVMTI_FUNC_PTR(jvmti,IterateThroughHeap)
2722                               (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,
2723                                NULL, &amp;heap_callbacks, &amp;data);
2724 
2725             }
2726         }
2727 
2728         /* Use data error if needed */
2729         if ( error == JVMTI_ERROR_NONE ) {
2730             error = data.error;
2731         }
2732 
2733     }
2734 
2735     /* Dispose of any special jvmti environment */
2736     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2737     return error;
2738 }
2739 
2740 /* ********************************************************************* */
2741 /* Referrers */
2742 
2743 /* Structure to hold object referrer heap traversal data (arg user_data) */
2744 typedef struct ReferrerData {
2745   int        refCount;
2746   int        maxObjects;
2747   jlong      refTag;
2748   jlong      objTag;
2749   jboolean   selfRef;
2750   jvmtiError error;
2751 } ReferrerData;
2752 
2753 /* Callback for referrers object tagging (heap_reference_callback). */
2754 static jint JNICALL
2755 cbObjectTagReferrer(jvmtiHeapReferenceKind reference_kind,
2756      const jvmtiHeapReferenceInfo* reference_info, jlong class_tag,
2757      jlong referrer_class_tag, jlong size,
2758      jlong* tag_ptr, jlong* referrer_tag_ptr, jint length, void* user_data)
2759 {
2760     ReferrerData  *data;
2761 
2762     /* Check data structure */
2763     data = (ReferrerData*)user_data;
2764     if (data == NULL) {
2765         return JVMTI_VISIT_ABORT;
2766     }
2767 
2768     /* If we have tagged enough objects, just abort */
2769     if ( data-&gt;maxObjects != 0 &amp;&amp; data-&gt;refCount &gt;= data-&gt;maxObjects ) {
2770         return JVMTI_VISIT_ABORT;
2771     }
2772 
2773     /* If not of interest, just continue */
2774     if ( (*tag_ptr) != data-&gt;objTag ) {
2775         return JVMTI_VISIT_OBJECTS;
2776     }
2777 
2778     /* Self reference that we haven&#39;t counted? */
2779     if ( tag_ptr == referrer_tag_ptr ) {
2780         if ( data-&gt;selfRef == JNI_FALSE ) {
2781             data-&gt;selfRef = JNI_TRUE;
2782             data-&gt;refCount++;
2783         }
2784         return JVMTI_VISIT_OBJECTS;
2785     }
2786 
2787     /* If the referrer can be tagged, and hasn&#39;t been tagged, tag it */
2788     if ( referrer_tag_ptr != NULL ) {
2789         if ( (*referrer_tag_ptr) == (jlong)0 ) {
2790             *referrer_tag_ptr = data-&gt;refTag;
2791             data-&gt;refCount++;
2792         }
2793     }
2794     return JVMTI_VISIT_OBJECTS;
2795 }
2796 
2797 /* Heap traversal to find referrers of an object */
2798 jvmtiError
2799 objectReferrers(jobject obj, ObjectBatch *referrers, int maxObjects)
2800 {
2801     jvmtiHeapCallbacks heap_callbacks;
2802     ReferrerData       data;
2803     jvmtiError         error;
2804     jvmtiEnv          *jvmti;
2805 
2806     /* Check interface assumptions */
2807     if (obj == NULL) {
2808         return AGENT_ERROR_INVALID_OBJECT;
2809     }
2810     if (referrers == NULL || maxObjects &lt; 0 ) {
2811         return AGENT_ERROR_ILLEGAL_ARGUMENT;
2812     }
2813 
2814     /* Initialize return information */
2815     referrers-&gt;count = 0;
2816     referrers-&gt;objects = NULL;
2817 
2818     /* Get jvmti environment to use */
2819     jvmti = getSpecialJvmti();
2820     if ( jvmti == NULL ) {
2821         return AGENT_ERROR_INTERNAL;
2822     }
2823 
2824     /* Fill in the data structure passed around the callbacks */
2825     data.refCount   = 0;
2826     data.maxObjects = maxObjects;
2827     data.objTag     = (jlong)1;
2828     data.refTag     = (jlong)2;
2829     data.selfRef    = JNI_FALSE;
2830     data.error      = JVMTI_ERROR_NONE;
2831 
2832     /* Tag the object of interest */
2833     error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, obj, data.objTag);
2834 
2835     /* No need to go any further if we can&#39;t tag the object */
2836     if ( error == JVMTI_ERROR_NONE ) {
2837 
2838         /* Clear out callbacks structure */
2839         (void)memset(&amp;heap_callbacks,0,sizeof(heap_callbacks));
2840 
2841         /* Setup callbacks we want */
2842         heap_callbacks.heap_reference_callback = &amp;cbObjectTagReferrer;
2843 
2844         /* Follow references, no initiating object, all classes, 1 tagged objs */
2845         error = JVMTI_FUNC_PTR(jvmti,FollowReferences)
2846                       (jvmti, JVMTI_HEAP_FILTER_UNTAGGED,
2847                        NULL, NULL, &amp;heap_callbacks, &amp;data);
2848 
2849         /* Use data error if needed */
2850         if ( error == JVMTI_ERROR_NONE ) {
2851             error = data.error;
2852         }
2853 
2854     }
2855 
2856     /* Watch out for self-reference */
2857     if ( error == JVMTI_ERROR_NONE &amp;&amp; data.selfRef == JNI_TRUE ) {
2858         /* Tag itself as a referer */
2859         error = JVMTI_FUNC_PTR(jvmti,SetTag) (jvmti, obj, data.refTag);
2860     }
2861 
2862     /* Get the jobjects for the tagged referrer objects.  */
2863     if ( error == JVMTI_ERROR_NONE ) {
2864         error = JVMTI_FUNC_PTR(jvmti,GetObjectsWithTags)
2865                     (jvmti, 1, &amp;(data.refTag), &amp;(referrers-&gt;count),
2866                           &amp;(referrers-&gt;objects), NULL);
2867         /* Verify we got the count we expected */
2868         if ( data.refCount != referrers-&gt;count ) {
2869             error = AGENT_ERROR_INTERNAL;
2870         }
2871     }
2872 
2873     /* Dispose of any special jvmti environment */
2874     (void)JVMTI_FUNC_PTR(jvmti,DisposeEnvironment)(jvmti);
2875     return error;
2876 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
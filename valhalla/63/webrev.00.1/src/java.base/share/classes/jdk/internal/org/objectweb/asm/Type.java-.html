<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/jdk/internal/org/objectweb/asm/Type.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  * This file is available under and governed by the GNU General Public
 27  * License version 2 only, as published by the Free Software Foundation.
 28  * However, the following notice accompanied the original version of this
 29  * file:
 30  *
 31  * ASM: a very small and fast Java bytecode manipulation framework
 32  * Copyright (c) 2000-2011 INRIA, France Telecom
 33  * All rights reserved.
 34  *
 35  * Redistribution and use in source and binary forms, with or without
 36  * modification, are permitted provided that the following conditions
 37  * are met:
 38  * 1. Redistributions of source code must retain the above copyright
 39  *    notice, this list of conditions and the following disclaimer.
 40  * 2. Redistributions in binary form must reproduce the above copyright
 41  *    notice, this list of conditions and the following disclaimer in the
 42  *    documentation and/or other materials provided with the distribution.
 43  * 3. Neither the name of the copyright holders nor the names of its
 44  *    contributors may be used to endorse or promote products derived from
 45  *    this software without specific prior written permission.
 46  *
 47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 57  * THE POSSIBILITY OF SUCH DAMAGE.
 58  */
 59 package jdk.internal.org.objectweb.asm;
 60 
 61 import java.lang.reflect.Constructor;
 62 import java.lang.reflect.Method;
 63 
 64 /**
 65  * A Java field or method type. This class can be used to make it easier to manipulate type and
 66  * method descriptors.
 67  *
 68  * @author Eric Bruneton
 69  * @author Chris Nokleberg
 70  */
 71 public final class Type {
 72 
 73     /** The sort of the {@code void} type. See {@link #getSort}. */
 74     public static final int VOID = 0;
 75 
 76     /** The sort of the {@code boolean} type. See {@link #getSort}. */
 77     public static final int BOOLEAN = 1;
 78 
 79     /** The sort of the {@code char} type. See {@link #getSort}. */
 80     public static final int CHAR = 2;
 81 
 82     /** The sort of the {@code byte} type. See {@link #getSort}. */
 83     public static final int BYTE = 3;
 84 
 85     /** The sort of the {@code short} type. See {@link #getSort}. */
 86     public static final int SHORT = 4;
 87 
 88     /** The sort of the {@code int} type. See {@link #getSort}. */
 89     public static final int INT = 5;
 90 
 91     /** The sort of the {@code float} type. See {@link #getSort}. */
 92     public static final int FLOAT = 6;
 93 
 94     /** The sort of the {@code long} type. See {@link #getSort}. */
 95     public static final int LONG = 7;
 96 
 97     /** The sort of the {@code double} type. See {@link #getSort}. */
 98     public static final int DOUBLE = 8;
 99 
100     /** The sort of array reference types. See {@link #getSort}. */
101     public static final int ARRAY = 9;
102 
103     /** The sort of object reference types. See {@link #getSort}. */
104     public static final int OBJECT = 10;
105 
106     /** The sort of method types. See {@link #getSort}. */
107     public static final int METHOD = 11;
108 
109     /** The (private) sort of object reference types represented with an internal name. */
110     private static final int INTERNAL = 12;
111 
112     /** The descriptors of the primitive types. */
113     private static final String PRIMITIVE_DESCRIPTORS = &quot;VZCBSIFJD&quot;;
114 
115     /** The {@code void} type. */
116     public static final Type VOID_TYPE = new Type(VOID, PRIMITIVE_DESCRIPTORS, VOID, VOID + 1);
117 
118     /** The {@code boolean} type. */
119     public static final Type BOOLEAN_TYPE =
120             new Type(BOOLEAN, PRIMITIVE_DESCRIPTORS, BOOLEAN, BOOLEAN + 1);
121 
122     /** The {@code char} type. */
123     public static final Type CHAR_TYPE = new Type(CHAR, PRIMITIVE_DESCRIPTORS, CHAR, CHAR + 1);
124 
125     /** The {@code byte} type. */
126     public static final Type BYTE_TYPE = new Type(BYTE, PRIMITIVE_DESCRIPTORS, BYTE, BYTE + 1);
127 
128     /** The {@code short} type. */
129     public static final Type SHORT_TYPE = new Type(SHORT, PRIMITIVE_DESCRIPTORS, SHORT, SHORT + 1);
130 
131     /** The {@code int} type. */
132     public static final Type INT_TYPE = new Type(INT, PRIMITIVE_DESCRIPTORS, INT, INT + 1);
133 
134     /** The {@code float} type. */
135     public static final Type FLOAT_TYPE = new Type(FLOAT, PRIMITIVE_DESCRIPTORS, FLOAT, FLOAT + 1);
136 
137     /** The {@code long} type. */
138     public static final Type LONG_TYPE = new Type(LONG, PRIMITIVE_DESCRIPTORS, LONG, LONG + 1);
139 
140     /** The {@code double} type. */
141     public static final Type DOUBLE_TYPE =
142             new Type(DOUBLE, PRIMITIVE_DESCRIPTORS, DOUBLE, DOUBLE + 1);
143 
144     // -----------------------------------------------------------------------------------------------
145     // Fields
146     // -----------------------------------------------------------------------------------------------
147 
148     /**
149       * The sort of this type. Either {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE},
150       * {@link #SHORT}, {@link #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY},
151       * {@link #OBJECT}, {@link #METHOD} or {@link #INTERNAL}.
152       */
153     private final int sort;
154 
155     /**
156       * A buffer containing the value of this field or method type. This value is an internal name for
157       * {@link #OBJECT} and {@link #INTERNAL} types, and a field or method descriptor in the other
158       * cases.
159       *
160       * &lt;p&gt;For {@link #OBJECT} types, this field also contains the descriptor: the characters in
161       * [{@link #valueBegin},{@link #valueEnd}) contain the internal name, and those in [{@link
162       * #valueBegin} - 1, {@link #valueEnd} + 1) contain the descriptor.
163       */
164     private final String valueBuffer;
165 
166     /**
167       * The beginning index, inclusive, of the value of this Java field or method type in {@link
168       * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,
169       * and a field or method descriptor in the other cases.
170       */
171     private final int valueBegin;
172 
173     /**
174       * The end index, exclusive, of the value of this Java field or method type in {@link
175       * #valueBuffer}. This value is an internal name for {@link #OBJECT} and {@link #INTERNAL} types,
176       * and a field or method descriptor in the other cases.
177       */
178     private final int valueEnd;
179 
180     /**
181       * Constructs a reference type.
182       *
183       * @param sort the sort of this type, see {@link #sort}.
184       * @param valueBuffer a buffer containing the value of this field or method type.
185       * @param valueBegin the beginning index, inclusive, of the value of this field or method type in
186       *     valueBuffer.
187       * @param valueEnd the end index, exclusive, of the value of this field or method type in
188       *     valueBuffer.
189       */
190     private Type(final int sort, final String valueBuffer, final int valueBegin, final int valueEnd) {
191         this.sort = sort;
192         this.valueBuffer = valueBuffer;
193         this.valueBegin = valueBegin;
194         this.valueEnd = valueEnd;
195     }
196 
197     // -----------------------------------------------------------------------------------------------
198     // Methods to get Type(s) from a descriptor, a reflected Method or Constructor, other types, etc.
199     // -----------------------------------------------------------------------------------------------
200 
201     /**
202       * Returns the {@link Type} corresponding to the given type descriptor.
203       *
204       * @param typeDescriptor a field or method type descriptor.
205       * @return the {@link Type} corresponding to the given type descriptor.
206       */
207     public static Type getType(final String typeDescriptor) {
208         return getTypeInternal(typeDescriptor, 0, typeDescriptor.length());
209     }
210 
211     /**
212       * Returns the {@link Type} corresponding to the given class.
213       *
214       * @param clazz a class.
215       * @return the {@link Type} corresponding to the given class.
216       */
217     public static Type getType(final Class&lt;?&gt; clazz) {
218         if (clazz.isPrimitive()) {
219             if (clazz == Integer.TYPE) {
220                 return INT_TYPE;
221             } else if (clazz == Void.TYPE) {
222                 return VOID_TYPE;
223             } else if (clazz == Boolean.TYPE) {
224                 return BOOLEAN_TYPE;
225             } else if (clazz == Byte.TYPE) {
226                 return BYTE_TYPE;
227             } else if (clazz == Character.TYPE) {
228                 return CHAR_TYPE;
229             } else if (clazz == Short.TYPE) {
230                 return SHORT_TYPE;
231             } else if (clazz == Double.TYPE) {
232                 return DOUBLE_TYPE;
233             } else if (clazz == Float.TYPE) {
234                 return FLOAT_TYPE;
235             } else if (clazz == Long.TYPE) {
236                 return LONG_TYPE;
237             } else {
238                 throw new AssertionError();
239             }
240         } else {
241             return getType(getDescriptor(clazz));
242         }
243     }
244 
245     /**
246       * Returns the method {@link Type} corresponding to the given constructor.
247       *
248       * @param constructor a {@link Constructor} object.
249       * @return the method {@link Type} corresponding to the given constructor.
250       */
251     public static Type getType(final Constructor&lt;?&gt; constructor) {
252         return getType(getConstructorDescriptor(constructor));
253     }
254 
255     /**
256       * Returns the method {@link Type} corresponding to the given method.
257       *
258       * @param method a {@link Method} object.
259       * @return the method {@link Type} corresponding to the given method.
260       */
261     public static Type getType(final Method method) {
262         return getType(getMethodDescriptor(method));
263     }
264 
265     /**
266       * Returns the type of the elements of this array type. This method should only be used for an
267       * array type.
268       *
269       * @return Returns the type of the elements of this array type.
270       */
271     public Type getElementType() {
272         final int numDimensions = getDimensions();
273         return getTypeInternal(valueBuffer, valueBegin + numDimensions, valueEnd);
274     }
275 
276     /**
277       * Returns the {@link Type} corresponding to the given internal name.
278       *
279       * @param internalName an internal name.
280       * @return the {@link Type} corresponding to the given internal name.
281       */
282     public static Type getObjectType(final String internalName) {
283         return new Type(
284                 internalName.charAt(0) == &#39;[&#39; ? ARRAY : INTERNAL, internalName, 0, internalName.length());
285     }
286 
287     /**
288       * Returns the {@link Type} corresponding to the given method descriptor. Equivalent to &lt;code&gt;
289       * Type.getType(methodDescriptor)&lt;/code&gt;.
290       *
291       * @param methodDescriptor a method descriptor.
292       * @return the {@link Type} corresponding to the given method descriptor.
293       */
294     public static Type getMethodType(final String methodDescriptor) {
295         return new Type(METHOD, methodDescriptor, 0, methodDescriptor.length());
296     }
297 
298     /**
299       * Returns the method {@link Type} corresponding to the given argument and return types.
300       *
301       * @param returnType the return type of the method.
302       * @param argumentTypes the argument types of the method.
303       * @return the method {@link Type} corresponding to the given argument and return types.
304       */
305     public static Type getMethodType(final Type returnType, final Type... argumentTypes) {
306         return getType(getMethodDescriptor(returnType, argumentTypes));
307     }
308 
309     /**
310       * Returns the argument types of methods of this type. This method should only be used for method
311       * types.
312       *
313       * @return the argument types of methods of this type.
314       */
315     public Type[] getArgumentTypes() {
316         return getArgumentTypes(getDescriptor());
317     }
318 
319     /**
320       * Returns the {@link Type} values corresponding to the argument types of the given method
321       * descriptor.
322       *
323       * @param methodDescriptor a method descriptor.
324       * @return the {@link Type} values corresponding to the argument types of the given method
325       *     descriptor.
326       */
327     public static Type[] getArgumentTypes(final String methodDescriptor) {
328         // First step: compute the number of argument types in methodDescriptor.
329         int numArgumentTypes = 0;
330         // Skip the first character, which is always a &#39;(&#39;.
331         int currentOffset = 1;
332         // Parse the argument types, one at a each loop iteration.
333         while (methodDescriptor.charAt(currentOffset) != &#39;)&#39;) {
334             while (methodDescriptor.charAt(currentOffset) == &#39;[&#39;) {
335                 currentOffset++;
336             }
337             if (methodDescriptor.charAt(currentOffset++) == &#39;L&#39;) {
338                 // Skip the argument descriptor content.
339                 int semiColumnOffset = methodDescriptor.indexOf(&#39;;&#39;, currentOffset);
340                 currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
341             }
342             ++numArgumentTypes;
343         }
344 
345         // Second step: create a Type instance for each argument type.
346         Type[] argumentTypes = new Type[numArgumentTypes];
347         // Skip the first character, which is always a &#39;(&#39;.
348         currentOffset = 1;
349         // Parse and create the argument types, one at each loop iteration.
350         int currentArgumentTypeIndex = 0;
351         while (methodDescriptor.charAt(currentOffset) != &#39;)&#39;) {
352             final int currentArgumentTypeOffset = currentOffset;
353             while (methodDescriptor.charAt(currentOffset) == &#39;[&#39;) {
354                 currentOffset++;
355             }
356             if (methodDescriptor.charAt(currentOffset++) == &#39;L&#39;) {
357                 // Skip the argument descriptor content.
358                 int semiColumnOffset = methodDescriptor.indexOf(&#39;;&#39;, currentOffset);
359                 currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
360             }
361             argumentTypes[currentArgumentTypeIndex++] =
362                     getTypeInternal(methodDescriptor, currentArgumentTypeOffset, currentOffset);
363         }
364         return argumentTypes;
365     }
366 
367     /**
368       * Returns the {@link Type} values corresponding to the argument types of the given method.
369       *
370       * @param method a method.
371       * @return the {@link Type} values corresponding to the argument types of the given method.
372       */
373     public static Type[] getArgumentTypes(final Method method) {
374         Class&lt;?&gt;[] classes = method.getParameterTypes();
375         Type[] types = new Type[classes.length];
376         for (int i = classes.length - 1; i &gt;= 0; --i) {
377             types[i] = getType(classes[i]);
378         }
379         return types;
380     }
381 
382     /**
383       * Returns the return type of methods of this type. This method should only be used for method
384       * types.
385       *
386       * @return the return type of methods of this type.
387       */
388     public Type getReturnType() {
389         return getReturnType(getDescriptor());
390     }
391 
392     /**
393       * Returns the {@link Type} corresponding to the return type of the given method descriptor.
394       *
395       * @param methodDescriptor a method descriptor.
396       * @return the {@link Type} corresponding to the return type of the given method descriptor.
397       */
398     public static Type getReturnType(final String methodDescriptor) {
399         return getTypeInternal(
400                 methodDescriptor, getReturnTypeOffset(methodDescriptor), methodDescriptor.length());
401     }
402 
403     /**
404       * Returns the {@link Type} corresponding to the return type of the given method.
405       *
406       * @param method a method.
407       * @return the {@link Type} corresponding to the return type of the given method.
408       */
409     public static Type getReturnType(final Method method) {
410         return getType(method.getReturnType());
411     }
412 
413     /**
414       * Returns the start index of the return type of the given method descriptor.
415       *
416       * @param methodDescriptor a method descriptor.
417       * @return the start index of the return type of the given method descriptor.
418       */
419     static int getReturnTypeOffset(final String methodDescriptor) {
420         // Skip the first character, which is always a &#39;(&#39;.
421         int currentOffset = 1;
422         // Skip the argument types, one at a each loop iteration.
423         while (methodDescriptor.charAt(currentOffset) != &#39;)&#39;) {
424             while (methodDescriptor.charAt(currentOffset) == &#39;[&#39;) {
425                 currentOffset++;
426             }
427             if (methodDescriptor.charAt(currentOffset++) == &#39;L&#39;) {
428                 // Skip the argument descriptor content.
429                 int semiColumnOffset = methodDescriptor.indexOf(&#39;;&#39;, currentOffset);
430                 currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
431             }
432         }
433         return currentOffset + 1;
434     }
435 
436     /**
437       * Returns the {@link Type} corresponding to the given field or method descriptor.
438       *
439       * @param descriptorBuffer a buffer containing the field or method descriptor.
440       * @param descriptorBegin the beginning index, inclusive, of the field or method descriptor in
441       *     descriptorBuffer.
442       * @param descriptorEnd the end index, exclusive, of the field or method descriptor in
443       *     descriptorBuffer.
444       * @return the {@link Type} corresponding to the given type descriptor.
445       */
446     private static Type getTypeInternal(
447             final String descriptorBuffer, final int descriptorBegin, final int descriptorEnd) {
448         switch (descriptorBuffer.charAt(descriptorBegin)) {
449             case &#39;V&#39;:
450                 return VOID_TYPE;
451             case &#39;Z&#39;:
452                 return BOOLEAN_TYPE;
453             case &#39;C&#39;:
454                 return CHAR_TYPE;
455             case &#39;B&#39;:
456                 return BYTE_TYPE;
457             case &#39;S&#39;:
458                 return SHORT_TYPE;
459             case &#39;I&#39;:
460                 return INT_TYPE;
461             case &#39;F&#39;:
462                 return FLOAT_TYPE;
463             case &#39;J&#39;:
464                 return LONG_TYPE;
465             case &#39;D&#39;:
466                 return DOUBLE_TYPE;
467             case &#39;[&#39;:
468                 return new Type(ARRAY, descriptorBuffer, descriptorBegin, descriptorEnd);
469             case &#39;L&#39;:
470                 return new Type(OBJECT, descriptorBuffer, descriptorBegin + 1, descriptorEnd - 1);
471             case &#39;(&#39;:
472                 return new Type(METHOD, descriptorBuffer, descriptorBegin, descriptorEnd);
473             default:
474                 throw new IllegalArgumentException();
475         }
476     }
477 
478     // -----------------------------------------------------------------------------------------------
479     // Methods to get class names, internal names or descriptors.
480     // -----------------------------------------------------------------------------------------------
481 
482     /**
483       * Returns the binary name of the class corresponding to this type. This method must not be used
484       * on method types.
485       *
486       * @return the binary name of the class corresponding to this type.
487       */
488     public String getClassName() {
489         switch (sort) {
490             case VOID:
491                 return &quot;void&quot;;
492             case BOOLEAN:
493                 return &quot;boolean&quot;;
494             case CHAR:
495                 return &quot;char&quot;;
496             case BYTE:
497                 return &quot;byte&quot;;
498             case SHORT:
499                 return &quot;short&quot;;
500             case INT:
501                 return &quot;int&quot;;
502             case FLOAT:
503                 return &quot;float&quot;;
504             case LONG:
505                 return &quot;long&quot;;
506             case DOUBLE:
507                 return &quot;double&quot;;
508             case ARRAY:
509                 StringBuilder stringBuilder = new StringBuilder(getElementType().getClassName());
510                 for (int i = getDimensions(); i &gt; 0; --i) {
511                     stringBuilder.append(&quot;[]&quot;);
512                 }
513                 return stringBuilder.toString();
514             case OBJECT:
515             case INTERNAL:
516                 return valueBuffer.substring(valueBegin, valueEnd).replace(&#39;/&#39;, &#39;.&#39;);
517             default:
518                 throw new AssertionError();
519         }
520     }
521 
522     /**
523       * Returns the internal name of the class corresponding to this object or array type. The internal
524       * name of a class is its fully qualified name (as returned by Class.getName(), where &#39;.&#39; are
525       * replaced by &#39;/&#39;). This method should only be used for an object or array type.
526       *
527       * @return the internal name of the class corresponding to this object type.
528       */
529     public String getInternalName() {
530         return valueBuffer.substring(valueBegin, valueEnd);
531     }
532 
533     /**
534       * Returns the internal name of the given class. The internal name of a class is its fully
535       * qualified name, as returned by Class.getName(), where &#39;.&#39; are replaced by &#39;/&#39;.
536       *
537       * @param clazz an object or array class.
538       * @return the internal name of the given class.
539       */
540     public static String getInternalName(final Class&lt;?&gt; clazz) {
541         return clazz.getName().replace(&#39;.&#39;, &#39;/&#39;);
542     }
543 
544     /**
545       * Returns the descriptor corresponding to this type.
546       *
547       * @return the descriptor corresponding to this type.
548       */
549     public String getDescriptor() {
550         if (sort == OBJECT) {
551             return valueBuffer.substring(valueBegin - 1, valueEnd + 1);
552         } else if (sort == INTERNAL) {
553             return &#39;L&#39; + valueBuffer.substring(valueBegin, valueEnd) + &#39;;&#39;;
554         } else {
555             return valueBuffer.substring(valueBegin, valueEnd);
556         }
557     }
558 
559     /**
560       * Returns the descriptor corresponding to the given class.
561       *
562       * @param clazz an object class, a primitive class or an array class.
563       * @return the descriptor corresponding to the given class.
564       */
565     public static String getDescriptor(final Class&lt;?&gt; clazz) {
566         StringBuilder stringBuilder = new StringBuilder();
567         appendDescriptor(clazz, stringBuilder);
568         return stringBuilder.toString();
569     }
570 
571     /**
572       * Returns the descriptor corresponding to the given constructor.
573       *
574       * @param constructor a {@link Constructor} object.
575       * @return the descriptor of the given constructor.
576       */
577     public static String getConstructorDescriptor(final Constructor&lt;?&gt; constructor) {
578         StringBuilder stringBuilder = new StringBuilder();
579         stringBuilder.append(&#39;(&#39;);
580         Class&lt;?&gt;[] parameters = constructor.getParameterTypes();
581         for (Class&lt;?&gt; parameter : parameters) {
582             appendDescriptor(parameter, stringBuilder);
583         }
584         return stringBuilder.append(&quot;)V&quot;).toString();
585     }
586 
587     /**
588       * Returns the descriptor corresponding to the given argument and return types.
589       *
590       * @param returnType the return type of the method.
591       * @param argumentTypes the argument types of the method.
592       * @return the descriptor corresponding to the given argument and return types.
593       */
594     public static String getMethodDescriptor(final Type returnType, final Type... argumentTypes) {
595         StringBuilder stringBuilder = new StringBuilder();
596         stringBuilder.append(&#39;(&#39;);
597         for (Type argumentType : argumentTypes) {
598             argumentType.appendDescriptor(stringBuilder);
599         }
600         stringBuilder.append(&#39;)&#39;);
601         returnType.appendDescriptor(stringBuilder);
602         return stringBuilder.toString();
603     }
604 
605     /**
606       * Returns the descriptor corresponding to the given method.
607       *
608       * @param method a {@link Method} object.
609       * @return the descriptor of the given method.
610       */
611     public static String getMethodDescriptor(final Method method) {
612         StringBuilder stringBuilder = new StringBuilder();
613         stringBuilder.append(&#39;(&#39;);
614         Class&lt;?&gt;[] parameters = method.getParameterTypes();
615         for (Class&lt;?&gt; parameter : parameters) {
616             appendDescriptor(parameter, stringBuilder);
617         }
618         stringBuilder.append(&#39;)&#39;);
619         appendDescriptor(method.getReturnType(), stringBuilder);
620         return stringBuilder.toString();
621     }
622 
623     /**
624       * Appends the descriptor corresponding to this type to the given string buffer.
625       *
626       * @param stringBuilder the string builder to which the descriptor must be appended.
627       */
628     private void appendDescriptor(final StringBuilder stringBuilder) {
629         if (sort == OBJECT) {
630             stringBuilder.append(valueBuffer, valueBegin - 1, valueEnd + 1);
631         } else if (sort == INTERNAL) {
632             stringBuilder.append(&#39;L&#39;).append(valueBuffer, valueBegin, valueEnd).append(&#39;;&#39;);
633         } else {
634             stringBuilder.append(valueBuffer, valueBegin, valueEnd);
635         }
636     }
637 
638     /**
639       * Appends the descriptor of the given class to the given string builder.
640       *
641       * @param clazz the class whose descriptor must be computed.
642       * @param stringBuilder the string builder to which the descriptor must be appended.
643       */
644     private static void appendDescriptor(final Class&lt;?&gt; clazz, final StringBuilder stringBuilder) {
645         Class&lt;?&gt; currentClass = clazz;
646         while (currentClass.isArray()) {
647             stringBuilder.append(&#39;[&#39;);
648             currentClass = currentClass.getComponentType();
649         }
650         if (currentClass.isPrimitive()) {
651             char descriptor;
652             if (currentClass == Integer.TYPE) {
653                 descriptor = &#39;I&#39;;
654             } else if (currentClass == Void.TYPE) {
655                 descriptor = &#39;V&#39;;
656             } else if (currentClass == Boolean.TYPE) {
657                 descriptor = &#39;Z&#39;;
658             } else if (currentClass == Byte.TYPE) {
659                 descriptor = &#39;B&#39;;
660             } else if (currentClass == Character.TYPE) {
661                 descriptor = &#39;C&#39;;
662             } else if (currentClass == Short.TYPE) {
663                 descriptor = &#39;S&#39;;
664             } else if (currentClass == Double.TYPE) {
665                 descriptor = &#39;D&#39;;
666             } else if (currentClass == Float.TYPE) {
667                 descriptor = &#39;F&#39;;
668             } else if (currentClass == Long.TYPE) {
669                 descriptor = &#39;J&#39;;
670             } else {
671                 throw new AssertionError();
672             }
673             stringBuilder.append(descriptor);
674         } else {
675             stringBuilder.append(&#39;L&#39;).append(getInternalName(currentClass)).append(&#39;;&#39;);
676         }
677     }
678 
679     // -----------------------------------------------------------------------------------------------
680     // Methods to get the sort, dimension, size, and opcodes corresponding to a Type or descriptor.
681     // -----------------------------------------------------------------------------------------------
682 
683     /**
684       * Returns the sort of this type.
685       *
686       * @return {@link #VOID}, {@link #BOOLEAN}, {@link #CHAR}, {@link #BYTE}, {@link #SHORT}, {@link
687       *     #INT}, {@link #FLOAT}, {@link #LONG}, {@link #DOUBLE}, {@link #ARRAY}, {@link #OBJECT} or
688       *     {@link #METHOD}.
689       */
690     public int getSort() {
691         return sort == INTERNAL ? OBJECT : sort;
692     }
693 
694     /**
695       * Returns the number of dimensions of this array type. This method should only be used for an
696       * array type.
697       *
698       * @return the number of dimensions of this array type.
699       */
700     public int getDimensions() {
701         int numDimensions = 1;
702         while (valueBuffer.charAt(valueBegin + numDimensions) == &#39;[&#39;) {
703             numDimensions++;
704         }
705         return numDimensions;
706     }
707 
708     /**
709       * Returns the size of values of this type. This method must not be used for method types.
710       *
711       * @return the size of values of this type, i.e., 2 for {@code long} and {@code double}, 0 for
712       *     {@code void} and 1 otherwise.
713       */
714     public int getSize() {
715         switch (sort) {
716             case VOID:
717                 return 0;
718             case BOOLEAN:
719             case CHAR:
720             case BYTE:
721             case SHORT:
722             case INT:
723             case FLOAT:
724             case ARRAY:
725             case OBJECT:
726             case INTERNAL:
727                 return 1;
728             case LONG:
729             case DOUBLE:
730                 return 2;
731             default:
732                 throw new AssertionError();
733         }
734     }
735 
736     /**
737       * Returns the size of the arguments and of the return value of methods of this type. This method
738       * should only be used for method types.
739       *
740       * @return the size of the arguments of the method (plus one for the implicit this argument),
741       *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =
742       *     {@code (argumentsSize &amp;lt;&amp;lt; 2) | returnSize} (argumentsSize is therefore equal to {@code
743       *     i &amp;gt;&amp;gt; 2}, and returnSize to {@code i &amp;amp; 0x03}).
744       */
745     public int getArgumentsAndReturnSizes() {
746         return getArgumentsAndReturnSizes(getDescriptor());
747     }
748 
749     /**
750       * Computes the size of the arguments and of the return value of a method.
751       *
752       * @param methodDescriptor a method descriptor.
753       * @return the size of the arguments of the method (plus one for the implicit this argument),
754       *     argumentsSize, and the size of its return value, returnSize, packed into a single int i =
755       *     {@code (argumentsSize &amp;lt;&amp;lt; 2) | returnSize} (argumentsSize is therefore equal to {@code
756       *     i &amp;gt;&amp;gt; 2}, and returnSize to {@code i &amp;amp; 0x03}).
757       */
758     public static int getArgumentsAndReturnSizes(final String methodDescriptor) {
759         int argumentsSize = 1;
760         // Skip the first character, which is always a &#39;(&#39;.
761         int currentOffset = 1;
762         int currentChar = methodDescriptor.charAt(currentOffset);
763         // Parse the argument types and compute their size, one at a each loop iteration.
764         while (currentChar != &#39;)&#39;) {
765             if (currentChar == &#39;J&#39; || currentChar == &#39;D&#39;) {
766                 currentOffset++;
767                 argumentsSize += 2;
768             } else {
769                 while (methodDescriptor.charAt(currentOffset) == &#39;[&#39;) {
770                     currentOffset++;
771                 }
772                 if (methodDescriptor.charAt(currentOffset++) == &#39;L&#39;) {
773                     // Skip the argument descriptor content.
774                     int semiColumnOffset = methodDescriptor.indexOf(&#39;;&#39;, currentOffset);
775                     currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
776                 }
777                 argumentsSize += 1;
778             }
779             currentChar = methodDescriptor.charAt(currentOffset);
780         }
781         currentChar = methodDescriptor.charAt(currentOffset + 1);
782         if (currentChar == &#39;V&#39;) {
783             return argumentsSize &lt;&lt; 2;
784         } else {
785             int returnSize = (currentChar == &#39;J&#39; || currentChar == &#39;D&#39;) ? 2 : 1;
786             return argumentsSize &lt;&lt; 2 | returnSize;
787         }
788     }
789 
790     /**
791       * Returns a JVM instruction opcode adapted to this {@link Type}. This method must not be used for
792       * method types.
793       *
794       * @param opcode a JVM instruction opcode. This opcode must be one of ILOAD, ISTORE, IALOAD,
795       *     IASTORE, IADD, ISUB, IMUL, IDIV, IREM, INEG, ISHL, ISHR, IUSHR, IAND, IOR, IXOR and
796       *     IRETURN.
797       * @return an opcode that is similar to the given opcode, but adapted to this {@link Type}. For
798       *     example, if this type is {@code float} and {@code opcode} is IRETURN, this method returns
799       *     FRETURN.
800       */
801     public int getOpcode(final int opcode) {
802         if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {
803             switch (sort) {
804                 case BOOLEAN:
805                 case BYTE:
806                     return opcode + (Opcodes.BALOAD - Opcodes.IALOAD);
807                 case CHAR:
808                     return opcode + (Opcodes.CALOAD - Opcodes.IALOAD);
809                 case SHORT:
810                     return opcode + (Opcodes.SALOAD - Opcodes.IALOAD);
811                 case INT:
812                     return opcode;
813                 case FLOAT:
814                     return opcode + (Opcodes.FALOAD - Opcodes.IALOAD);
815                 case LONG:
816                     return opcode + (Opcodes.LALOAD - Opcodes.IALOAD);
817                 case DOUBLE:
818                     return opcode + (Opcodes.DALOAD - Opcodes.IALOAD);
819                 case ARRAY:
820                 case OBJECT:
821                 case INTERNAL:
822                     return opcode + (Opcodes.AALOAD - Opcodes.IALOAD);
823                 case METHOD:
824                 case VOID:
825                     throw new UnsupportedOperationException();
826                 default:
827                     throw new AssertionError();
828             }
829         } else {
830             switch (sort) {
831                 case VOID:
832                     if (opcode != Opcodes.IRETURN) {
833                         throw new UnsupportedOperationException();
834                     }
835                     return Opcodes.RETURN;
836                 case BOOLEAN:
837                 case BYTE:
838                 case CHAR:
839                 case SHORT:
840                 case INT:
841                     return opcode;
842                 case FLOAT:
843                     return opcode + (Opcodes.FRETURN - Opcodes.IRETURN);
844                 case LONG:
845                     return opcode + (Opcodes.LRETURN - Opcodes.IRETURN);
846                 case DOUBLE:
847                     return opcode + (Opcodes.DRETURN - Opcodes.IRETURN);
848                 case ARRAY:
849                 case OBJECT:
850                 case INTERNAL:
851                     if (opcode != Opcodes.ILOAD &amp;&amp; opcode != Opcodes.ISTORE &amp;&amp; opcode != Opcodes.IRETURN) {
852                         throw new UnsupportedOperationException();
853                     }
854                     return opcode + (Opcodes.ARETURN - Opcodes.IRETURN);
855                 case METHOD:
856                     throw new UnsupportedOperationException();
857                 default:
858                     throw new AssertionError();
859             }
860         }
861     }
862 
863     // -----------------------------------------------------------------------------------------------
864     // Equals, hashCode and toString.
865     // -----------------------------------------------------------------------------------------------
866 
867     /**
868       * Tests if the given object is equal to this type.
869       *
870       * @param object the object to be compared to this type.
871       * @return {@literal true} if the given object is equal to this type.
872       */
873     @Override
874     public boolean equals(final Object object) {
875         if (this == object) {
876             return true;
877         }
878         if (!(object instanceof Type)) {
879             return false;
880         }
881         Type other = (Type) object;
882         if ((sort == INTERNAL ? OBJECT : sort) != (other.sort == INTERNAL ? OBJECT : other.sort)) {
883             return false;
884         }
885         int begin = valueBegin;
886         int end = valueEnd;
887         int otherBegin = other.valueBegin;
888         int otherEnd = other.valueEnd;
889         // Compare the values.
890         if (end - begin != otherEnd - otherBegin) {
891             return false;
892         }
893         for (int i = begin, j = otherBegin; i &lt; end; i++, j++) {
894             if (valueBuffer.charAt(i) != other.valueBuffer.charAt(j)) {
895                 return false;
896             }
897         }
898         return true;
899     }
900 
901     /**
902       * Returns a hash code value for this type.
903       *
904       * @return a hash code value for this type.
905       */
906     @Override
907     public int hashCode() {
908         int hashCode = 13 * (sort == INTERNAL ? OBJECT : sort);
909         if (sort &gt;= ARRAY) {
910             for (int i = valueBegin, end = valueEnd; i &lt; end; i++) {
911                 hashCode = 17 * (hashCode + valueBuffer.charAt(i));
912             }
913         }
914         return hashCode;
915     }
916 
917     /**
918       * Returns a string representation of this type.
919       *
920       * @return the descriptor of this type.
921       */
922     @Override
923     public String toString() {
924         return getDescriptor();
925     }
926 }
    </pre>
  </body>
</html>
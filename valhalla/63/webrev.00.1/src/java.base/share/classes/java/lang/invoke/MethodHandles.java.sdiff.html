<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleNatives.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/AccessibleObject.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2314 ...
2315 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2316   &quot;asList&quot;, methodType(List.class, Object[].class));
2317 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2318          * }&lt;/pre&gt;&lt;/blockquote&gt;
2319          * @param refc the class from which the method is accessed
2320          * @param name the name of the method
2321          * @param type the type of the method
2322          * @return the desired method handle
2323          * @throws NoSuchMethodException if the method does not exist
2324          * @throws IllegalAccessException if access checking fails,
2325          *                                or if the method is not {@code static},
2326          *                                or if the method&#39;s variable arity modifier bit
2327          *                                is set and {@code asVarargsCollector} fails
2328          * @throws    SecurityException if a security manager is present and it
2329          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2330          * @throws NullPointerException if any argument is null
2331          */
2332         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2333             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);






2334             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2335         }
2336 
2337         /**
2338          * Produces a method handle for a virtual method.
2339          * The type of the method handle will be that of the method,
2340          * with the receiver type (usually {@code refc}) prepended.
2341          * The method and all its argument types must be accessible to the lookup object.
2342          * &lt;p&gt;
2343          * When called, the handle will treat the first argument as a receiver
2344          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2345          * implementation to enter.
2346          * For private methods the named method in {@code refc} will be invoked on the receiver.
2347          * (The dispatching action is identical with that performed by an
2348          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2349          * &lt;p&gt;
2350          * The first argument will be of type {@code refc} if the lookup
2351          * class has full privileges to access the member.  Otherwise
2352          * the member must be {@code protected} and the first argument
2353          * will be restricted in type to the lookup class.
</pre>
<hr />
<pre>
2459          * If the returned method handle is invoked, the constructor&#39;s class will
2460          * be initialized, if it has not already been initialized.
2461          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2462          * &lt;blockquote&gt;&lt;pre&gt;{@code
2463 import static java.lang.invoke.MethodHandles.*;
2464 import static java.lang.invoke.MethodType.*;
2465 ...
2466 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2467   ArrayList.class, methodType(void.class, Collection.class));
2468 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2469 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2470 assert(orig != copy);
2471 assertEquals(orig, copy);
2472 // a variable-arity constructor:
2473 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2474   ProcessBuilder.class, methodType(void.class, String[].class));
2475 ProcessBuilder pb = (ProcessBuilder)
2476   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2477 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2478          * }&lt;/pre&gt;&lt;/blockquote&gt;







2479          * @param refc the class or interface from which the method is accessed
2480          * @param type the type of the method, with the receiver argument omitted, and a void return type
2481          * @return the desired method handle
2482          * @throws NoSuchMethodException if the constructor does not exist
2483          * @throws IllegalAccessException if access checking fails
2484          *                                or if the method&#39;s variable arity modifier bit
2485          *                                is set and {@code asVarargsCollector} fails
2486          * @throws    SecurityException if a security manager is present and it
2487          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2488          * @throws NullPointerException if any argument is null
2489          */
2490         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2491             if (refc.isArray()) {
2492                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2493             }



2494             String name = &quot;&lt;init&gt;&quot;;
2495             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2496             return getDirectConstructor(refc, ctor);
2497         }
2498 
2499         /**
2500          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2501          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2502          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2503          * and then determines whether the class is accessible to this lookup object.
2504          * &lt;p&gt;
2505          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2506          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2507          *
2508          * @param targetName the fully qualified name of the class to be looked up.
2509          * @return the requested class.
2510          * @throws SecurityException if a security manager is present and it
2511          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2512          * @throws LinkageError if the linkage fails
2513          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
</pre>
<hr />
<pre>
3091          * arguments passed to the method handle.
3092          * &lt;p&gt;
3093          * If the constructor&#39;s {@code accessible} flag is not set,
3094          * access checking is performed immediately on behalf of the lookup class.
3095          * &lt;p&gt;
3096          * The returned method handle will have
3097          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3098          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3099          * &lt;p&gt;
3100          * If the returned method handle is invoked, the constructor&#39;s class will
3101          * be initialized, if it has not already been initialized.
3102          * @param c the reflected constructor
3103          * @return a method handle which can invoke the reflected constructor
3104          * @throws IllegalAccessException if access checking fails
3105          *                                or if the method&#39;s variable arity modifier bit
3106          *                                is set and {@code asVarargsCollector} fails
3107          * @throws NullPointerException if the argument is null
3108          */
3109         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3110             MemberName ctor = new MemberName(c);
<span class="line-modified">3111             assert(ctor.isConstructor());</span>
3112             @SuppressWarnings(&quot;deprecation&quot;)
3113             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">3114             return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>








3115         }
3116 
3117         /**
3118          * Produces a method handle giving read access to a reflected field.
3119          * The type of the method handle will have a return type of the field&#39;s
3120          * value type.
3121          * If the field is {@code static}, the method handle will take no arguments.
3122          * Otherwise, its single argument will be the instance containing
3123          * the field.
3124          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3125          * access checking is performed immediately on behalf of the lookup class.
3126          * &lt;p&gt;
3127          * If the field is static, and
3128          * if the returned method handle is invoked, the field&#39;s class will
3129          * be initialized, if it has not already been initialized.
3130          * @param f the reflected field
3131          * @return a method handle which can load values from the reflected field
3132          * @throws IllegalAccessException if access checking fails
3133          * @throws NullPointerException if the argument is null
3134          */
</pre>
<hr />
<pre>
3348             }
3349             Objects.requireNonNull(member.getName());
3350             Objects.requireNonNull(member.getType());
3351             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3352         }
3353 
3354         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3355             if (!isClassAccessible(refc)) {
3356                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3357             }
3358         }
3359 
3360         boolean isClassAccessible(Class&lt;?&gt; refc) {
3361             Objects.requireNonNull(refc);
3362             Class&lt;?&gt; caller = lookupClassOrNull();
3363             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3364         }
3365 
3366         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3367         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<span class="line-modified">3368             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial)</span>
<span class="line-modified">3369                 throw new NoSuchMethodException(&quot;illegal method name: &quot;+name);</span>



3370         }
3371 
<span class="line-removed">3372 </span>
3373         /**
3374          * Find my trustable caller class if m is a caller sensitive method.
3375          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3376          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3377          */
3378         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3379             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3380                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3381                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3382             }
3383             return this;
3384         }
3385 
3386         /**
3387          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3388          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3389          *
3390          * @deprecated This method was originally designed to test {@code PRIVATE} access
3391          * that implies full privilege access but {@code MODULE} access has since become
3392          * independent of {@code PRIVATE} access.  It is recommended to call
</pre>
<hr />
<pre>
3437                 }
3438                 return;
3439             }
3440 
3441             // Step 2a:
3442             if (m.isPublic()) return;
3443             if (!fullPowerLookup) {
3444                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3445             }
3446 
3447             // Step 3:
3448             Class&lt;?&gt; defc = m.getDeclaringClass();
3449             if (!fullPowerLookup &amp;&amp; defc != refc) {
3450                 ReflectUtil.checkPackageAccess(defc);
3451             }
3452         }
3453 
3454         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3455             boolean wantStatic = (refKind == REF_invokeStatic);
3456             String message;
<span class="line-modified">3457             if (m.isConstructor())</span>
3458                 message = &quot;expected a method, not a constructor&quot;;
3459             else if (!m.isMethod())
3460                 message = &quot;expected a method&quot;;
3461             else if (wantStatic != m.isStatic())
3462                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3463             else
3464                 { checkAccess(refKind, refc, m); return; }
3465             throw m.makeAccessException(message, this);
3466         }
3467 
3468         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3469             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3470             String message;
3471             if (wantStatic != m.isStatic())
3472                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3473             else
3474                 { checkAccess(refKind, refc, m); return; }
3475             throw m.makeAccessException(message, this);
3476         }
3477 
</pre>
<hr />
<pre>
3736                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3737                 }
3738                 refc = lookupClass();
3739             }
3740             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3741                                              this.allowedModes == TRUSTED &amp;&amp; !getField.getDeclaringClass().isHidden());
3742         }
3743         /** Check access and get the requested constructor. */
3744         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3745             final boolean checkSecurity = true;
3746             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3747         }
3748         /** Check access and get the requested constructor, eliding security manager checks. */
3749         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3750             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3751             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3752         }
3753         /** Common code for all constructors; do not call directly except from immediately above. */
3754         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3755                                                   boolean checkSecurity) throws IllegalAccessException {
<span class="line-modified">3756             assert(ctor.isConstructor());</span>
3757             checkAccess(REF_newInvokeSpecial, refc, ctor);
3758             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3759             if (checkSecurity)
3760                 checkSecurityManager(refc, ctor);
3761             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3762             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3763         }
3764 
3765         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3766          */
3767         /*non-public*/
3768         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3769                 throws ReflectiveOperationException {
3770             if (!(type instanceof Class || type instanceof MethodType))
3771                 throw new InternalError(&quot;unresolved MemberName&quot;);
3772             MemberName member = new MemberName(refKind, defc, name, type);
3773             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3774             if (mh != null) {
3775                 checkSymbolicClass(defc);
3776                 return mh;
</pre>
<hr />
<pre>
3926      * Produces a method handle giving write access to elements of an array,
3927      * as if by the {@code astore} bytecode.
3928      * The type of the method handle will have a void return type.
3929      * Its last argument will be the array&#39;s element type.
3930      * The first and second arguments will be the array type and int.
3931      *
3932      * &lt;p&gt; When the returned method handle is invoked,
3933      * the array reference and array index are checked.
3934      * A {@code NullPointerException} will be thrown if the array reference
3935      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
3936      * thrown if the index is negative or if it is greater than or equal to
3937      * the length of the array.
3938      *
3939      * @param arrayClass the class of an array
3940      * @return a method handle which can store values into the array type
3941      * @throws NullPointerException if the argument is null
3942      * @throws IllegalArgumentException if arrayClass is not an array type
3943      * @jvms 6.5 {@code aastore} Instruction
3944      */
3945     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {



3946         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
3947     }
3948 
3949     /**
3950      * Produces a VarHandle giving access to elements of an array of type
3951      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
3952      * of {@code arrayClass} and the list of coordinate types is
3953      * {@code (arrayClass, int)}, where the {@code int} coordinate type
3954      * corresponds to an argument that is an index into an array.
3955      * &lt;p&gt;
3956      * Certain access modes of the returned VarHandle are unsupported under
3957      * the following conditions:
3958      * &lt;ul&gt;
3959      * &lt;li&gt;if the component type is anything other than {@code byte},
3960      *     {@code short}, {@code char}, {@code int}, {@code long},
3961      *     {@code float}, or {@code double} then numeric atomic update access
3962      *     modes are unsupported.
3963      * &lt;li&gt;if the field type is anything other than {@code boolean},
3964      *     {@code byte}, {@code short}, {@code char}, {@code int} or
3965      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
4686     }
4687 
4688     /**
4689      * Produces a constant method handle of the requested return type which
4690      * returns the default value for that type every time it is invoked.
4691      * The resulting constant method handle will have no side effects.
4692      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4693      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4694      * since {@code explicitCastArguments} converts {@code null} to default values.
4695      * @param type the expected return type of the desired method handle
4696      * @return a constant method handle that takes no arguments
4697      *         and returns the default value of the given type (or void, if the type is void)
4698      * @throws NullPointerException if the argument is null
4699      * @see MethodHandles#constant
4700      * @see MethodHandles#empty
4701      * @see MethodHandles#explicitCastArguments
4702      * @since 9
4703      */
4704     public static MethodHandle zero(Class&lt;?&gt; type) {
4705         Objects.requireNonNull(type);
<span class="line-modified">4706         return type.isPrimitive() ?  zero(Wrapper.forPrimitiveType(type), type) : zero(Wrapper.OBJECT, type);</span>






4707     }
4708 
4709     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4710         return type == void.class ? zero(type) : identity(type);
4711     }
4712 
4713     /**
4714      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4715      * and returns a suitable default depending on the return type.
4716      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4717      * &lt;p&gt;The returned method handle is equivalent to
4718      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4719      *
4720      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4721      * {@code guardWithTest(pred, target, empty(target.type())}.
4722      * @param type the type of the desired method handle
4723      * @return a constant method handle of the given type, which returns a default value of the given return type
4724      * @throws NullPointerException if the argument is null
4725      * @see MethodHandles#zero
4726      * @see MethodHandles#constant
4727      * @since 9
4728      */
4729     public static  MethodHandle empty(MethodType type) {
4730         Objects.requireNonNull(type);
4731         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4732     }
4733 
4734     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4735     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<span class="line-modified">4736         MethodType mtype = methodType(ptype, ptype);</span>
4737         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4738         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4739     }
4740 
4741     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4742         int pos = btw.ordinal();
4743         MethodHandle zero = ZERO_MHS[pos];
4744         if (zero == null) {
4745             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4746         }
4747         if (zero.type().returnType() == rtype)
4748             return zero;
4749         assert(btw == Wrapper.OBJECT);
4750         return makeZero(rtype);
4751     }
4752     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4753     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4754         MethodType mtype = methodType(rtype);
4755         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4756         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
</pre>
</td>
<td>
<hr />
<pre>
2314 ...
2315 MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
2316   &quot;asList&quot;, methodType(List.class, Object[].class));
2317 assertEquals(&quot;[x, y]&quot;, MH_asList.invoke(&quot;x&quot;, &quot;y&quot;).toString());
2318          * }&lt;/pre&gt;&lt;/blockquote&gt;
2319          * @param refc the class from which the method is accessed
2320          * @param name the name of the method
2321          * @param type the type of the method
2322          * @return the desired method handle
2323          * @throws NoSuchMethodException if the method does not exist
2324          * @throws IllegalAccessException if access checking fails,
2325          *                                or if the method is not {@code static},
2326          *                                or if the method&#39;s variable arity modifier bit
2327          *                                is set and {@code asVarargsCollector} fails
2328          * @throws    SecurityException if a security manager is present and it
2329          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2330          * @throws NullPointerException if any argument is null
2331          */
2332         public MethodHandle findStatic(Class&lt;?&gt; refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2333             MemberName method = resolveOrFail(REF_invokeStatic, refc, name, type);
<span class="line-added">2334             // resolveOrFail could return a non-static &lt;init&gt; method if present</span>
<span class="line-added">2335             // detect and throw NSME before producing a MethodHandle</span>
<span class="line-added">2336             if (!method.isStatic() &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;)) {</span>
<span class="line-added">2337                 throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">2338             }</span>
<span class="line-added">2339 </span>
2340             return getDirectMethod(REF_invokeStatic, refc, method, findBoundCallerLookup(method));
2341         }
2342 
2343         /**
2344          * Produces a method handle for a virtual method.
2345          * The type of the method handle will be that of the method,
2346          * with the receiver type (usually {@code refc}) prepended.
2347          * The method and all its argument types must be accessible to the lookup object.
2348          * &lt;p&gt;
2349          * When called, the handle will treat the first argument as a receiver
2350          * and, for non-private methods, dispatch on the receiver&#39;s type to determine which method
2351          * implementation to enter.
2352          * For private methods the named method in {@code refc} will be invoked on the receiver.
2353          * (The dispatching action is identical with that performed by an
2354          * {@code invokevirtual} or {@code invokeinterface} instruction.)
2355          * &lt;p&gt;
2356          * The first argument will be of type {@code refc} if the lookup
2357          * class has full privileges to access the member.  Otherwise
2358          * the member must be {@code protected} and the first argument
2359          * will be restricted in type to the lookup class.
</pre>
<hr />
<pre>
2465          * If the returned method handle is invoked, the constructor&#39;s class will
2466          * be initialized, if it has not already been initialized.
2467          * &lt;p&gt;&lt;b&gt;Example:&lt;/b&gt;
2468          * &lt;blockquote&gt;&lt;pre&gt;{@code
2469 import static java.lang.invoke.MethodHandles.*;
2470 import static java.lang.invoke.MethodType.*;
2471 ...
2472 MethodHandle MH_newArrayList = publicLookup().findConstructor(
2473   ArrayList.class, methodType(void.class, Collection.class));
2474 Collection orig = Arrays.asList(&quot;x&quot;, &quot;y&quot;);
2475 Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
2476 assert(orig != copy);
2477 assertEquals(orig, copy);
2478 // a variable-arity constructor:
2479 MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
2480   ProcessBuilder.class, methodType(void.class, String[].class));
2481 ProcessBuilder pb = (ProcessBuilder)
2482   MH_newProcessBuilder.invoke(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;);
2483 assertEquals(&quot;[x, y, z]&quot;, pb.command().toString());
2484          * }&lt;/pre&gt;&lt;/blockquote&gt;
<span class="line-added">2485          *</span>
<span class="line-added">2486          * @apiNote</span>
<span class="line-added">2487          * This method does not find a static {@code &lt;init&gt;} factory method as it is invoked</span>
<span class="line-added">2488          * via {@code invokestatic} bytecode as opposed to {@code invokespecial} for an</span>
<span class="line-added">2489          * object constructor.  To look up static {@code &lt;init&gt;} factory method, use</span>
<span class="line-added">2490          * the {@link #findStatic(Class, String, MethodType) findStatic} method.</span>
<span class="line-added">2491          *</span>
2492          * @param refc the class or interface from which the method is accessed
2493          * @param type the type of the method, with the receiver argument omitted, and a void return type
2494          * @return the desired method handle
2495          * @throws NoSuchMethodException if the constructor does not exist
2496          * @throws IllegalAccessException if access checking fails
2497          *                                or if the method&#39;s variable arity modifier bit
2498          *                                is set and {@code asVarargsCollector} fails
2499          * @throws    SecurityException if a security manager is present and it
2500          *                              &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2501          * @throws NullPointerException if any argument is null
2502          */
2503         public MethodHandle findConstructor(Class&lt;?&gt; refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
2504             if (refc.isArray()) {
2505                 throw new NoSuchMethodException(&quot;no constructor for array class: &quot; + refc.getName());
2506             }
<span class="line-added">2507             if (type.returnType() != void.class) {</span>
<span class="line-added">2508                 throw new NoSuchMethodException(&quot;Constructors must have void return type: &quot; + refc.getName());</span>
<span class="line-added">2509             }</span>
2510             String name = &quot;&lt;init&gt;&quot;;
2511             MemberName ctor = resolveOrFail(REF_newInvokeSpecial, refc, name, type);
2512             return getDirectConstructor(refc, ctor);
2513         }
2514 
2515         /**
2516          * Looks up a class by name from the lookup context defined by this {@code Lookup} object,
2517          * &lt;a href=&quot;MethodHandles.Lookup.html#equiv&quot;&gt;as if resolved&lt;/a&gt; by an {@code ldc} instruction.
2518          * Such a resolution, as specified in JVMS 5.4.3.1 section, attempts to locate and load the class,
2519          * and then determines whether the class is accessible to this lookup object.
2520          * &lt;p&gt;
2521          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2522          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2523          *
2524          * @param targetName the fully qualified name of the class to be looked up.
2525          * @return the requested class.
2526          * @throws SecurityException if a security manager is present and it
2527          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2528          * @throws LinkageError if the linkage fails
2529          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
</pre>
<hr />
<pre>
3107          * arguments passed to the method handle.
3108          * &lt;p&gt;
3109          * If the constructor&#39;s {@code accessible} flag is not set,
3110          * access checking is performed immediately on behalf of the lookup class.
3111          * &lt;p&gt;
3112          * The returned method handle will have
3113          * {@linkplain MethodHandle#asVarargsCollector variable arity} if and only if
3114          * the constructor&#39;s variable arity modifier bit ({@code 0x0080}) is set.
3115          * &lt;p&gt;
3116          * If the returned method handle is invoked, the constructor&#39;s class will
3117          * be initialized, if it has not already been initialized.
3118          * @param c the reflected constructor
3119          * @return a method handle which can invoke the reflected constructor
3120          * @throws IllegalAccessException if access checking fails
3121          *                                or if the method&#39;s variable arity modifier bit
3122          *                                is set and {@code asVarargsCollector} fails
3123          * @throws NullPointerException if the argument is null
3124          */
3125         public MethodHandle unreflectConstructor(Constructor&lt;?&gt; c) throws IllegalAccessException {
3126             MemberName ctor = new MemberName(c);
<span class="line-modified">3127             assert(ctor.isObjectConstructorOrStaticInitMethod());</span>
3128             @SuppressWarnings(&quot;deprecation&quot;)
3129             Lookup lookup = c.isAccessible() ? IMPL_LOOKUP : this;
<span class="line-modified">3130             if (ctor.isObjectConstructor()) {</span>
<span class="line-added">3131                 assert(ctor.getReturnType() == void.class);</span>
<span class="line-added">3132                 return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);</span>
<span class="line-added">3133             } else {</span>
<span class="line-added">3134                 // static init factory is a static method</span>
<span class="line-added">3135                 assert(ctor.isMethod() &amp;&amp; ctor.getReturnType() == ctor.getDeclaringClass() &amp;&amp; ctor.getReferenceKind() == REF_invokeStatic);</span>
<span class="line-added">3136                 assert(!MethodHandleNatives.isCallerSensitive(ctor));  // must not be caller-sensitive</span>
<span class="line-added">3137                 return lookup.getDirectMethodNoSecurityManager(ctor.getReferenceKind(), ctor.getDeclaringClass(), ctor, lookup);</span>
<span class="line-added">3138             }</span>
3139         }
3140 
3141         /**
3142          * Produces a method handle giving read access to a reflected field.
3143          * The type of the method handle will have a return type of the field&#39;s
3144          * value type.
3145          * If the field is {@code static}, the method handle will take no arguments.
3146          * Otherwise, its single argument will be the instance containing
3147          * the field.
3148          * If the {@code Field} object&#39;s {@code accessible} flag is not set,
3149          * access checking is performed immediately on behalf of the lookup class.
3150          * &lt;p&gt;
3151          * If the field is static, and
3152          * if the returned method handle is invoked, the field&#39;s class will
3153          * be initialized, if it has not already been initialized.
3154          * @param f the reflected field
3155          * @return a method handle which can load values from the reflected field
3156          * @throws IllegalAccessException if access checking fails
3157          * @throws NullPointerException if the argument is null
3158          */
</pre>
<hr />
<pre>
3372             }
3373             Objects.requireNonNull(member.getName());
3374             Objects.requireNonNull(member.getType());
3375             return IMPL_NAMES.resolveOrNull(refKind, member, lookupClassOrNull());
3376         }
3377 
3378         void checkSymbolicClass(Class&lt;?&gt; refc) throws IllegalAccessException {
3379             if (!isClassAccessible(refc)) {
3380                 throw new MemberName(refc).makeAccessException(&quot;symbolic reference class is not accessible&quot;, this);
3381             }
3382         }
3383 
3384         boolean isClassAccessible(Class&lt;?&gt; refc) {
3385             Objects.requireNonNull(refc);
3386             Class&lt;?&gt; caller = lookupClassOrNull();
3387             return caller == null || VerifyAccess.isClassAccessible(refc, caller, prevLookupClass, allowedModes);
3388         }
3389 
3390         /** Check name for an illegal leading &quot;&amp;lt;&quot; character. */
3391         void checkMethodName(byte refKind, String name) throws NoSuchMethodException {
<span class="line-modified">3392             // &quot;&lt;init&gt;&quot; can only be invoked via invokespecial or it&#39;s a static init factory</span>
<span class="line-modified">3393             if (name.startsWith(&quot;&lt;&quot;) &amp;&amp; refKind != REF_newInvokeSpecial &amp;&amp;</span>
<span class="line-added">3394                     !(refKind == REF_invokeStatic &amp;&amp; name.equals(&quot;&lt;init&gt;&quot;))) {</span>
<span class="line-added">3395                     throw new NoSuchMethodException(&quot;illegal method name: &quot; + name);</span>
<span class="line-added">3396             }</span>
3397         }
3398 

3399         /**
3400          * Find my trustable caller class if m is a caller sensitive method.
3401          * If this lookup object has full privilege access, then the caller class is the lookupClass.
3402          * Otherwise, if m is caller-sensitive, throw IllegalAccessException.
3403          */
3404         Lookup findBoundCallerLookup(MemberName m) throws IllegalAccessException {
3405             if (MethodHandleNatives.isCallerSensitive(m) &amp;&amp; !hasFullPrivilegeAccess()) {
3406                 // Only lookups with full privilege access are allowed to resolve caller-sensitive methods
3407                 throw new IllegalAccessException(&quot;Attempt to lookup caller-sensitive method using restricted lookup object&quot;);
3408             }
3409             return this;
3410         }
3411 
3412         /**
3413          * Returns {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3414          * @return {@code true} if this lookup has {@code PRIVATE} and {@code MODULE} access.
3415          *
3416          * @deprecated This method was originally designed to test {@code PRIVATE} access
3417          * that implies full privilege access but {@code MODULE} access has since become
3418          * independent of {@code PRIVATE} access.  It is recommended to call
</pre>
<hr />
<pre>
3463                 }
3464                 return;
3465             }
3466 
3467             // Step 2a:
3468             if (m.isPublic()) return;
3469             if (!fullPowerLookup) {
3470                 smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3471             }
3472 
3473             // Step 3:
3474             Class&lt;?&gt; defc = m.getDeclaringClass();
3475             if (!fullPowerLookup &amp;&amp; defc != refc) {
3476                 ReflectUtil.checkPackageAccess(defc);
3477             }
3478         }
3479 
3480         void checkMethod(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3481             boolean wantStatic = (refKind == REF_invokeStatic);
3482             String message;
<span class="line-modified">3483             if (m.isObjectConstructor())</span>
3484                 message = &quot;expected a method, not a constructor&quot;;
3485             else if (!m.isMethod())
3486                 message = &quot;expected a method&quot;;
3487             else if (wantStatic != m.isStatic())
3488                 message = wantStatic ? &quot;expected a static method&quot; : &quot;expected a non-static method&quot;;
3489             else
3490                 { checkAccess(refKind, refc, m); return; }
3491             throw m.makeAccessException(message, this);
3492         }
3493 
3494         void checkField(byte refKind, Class&lt;?&gt; refc, MemberName m) throws IllegalAccessException {
3495             boolean wantStatic = !MethodHandleNatives.refKindHasReceiver(refKind);
3496             String message;
3497             if (wantStatic != m.isStatic())
3498                 message = wantStatic ? &quot;expected a static field&quot; : &quot;expected a non-static field&quot;;
3499             else
3500                 { checkAccess(refKind, refc, m); return; }
3501             throw m.makeAccessException(message, this);
3502         }
3503 
</pre>
<hr />
<pre>
3762                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3763                 }
3764                 refc = lookupClass();
3765             }
3766             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
3767                                              this.allowedModes == TRUSTED &amp;&amp; !getField.getDeclaringClass().isHidden());
3768         }
3769         /** Check access and get the requested constructor. */
3770         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3771             final boolean checkSecurity = true;
3772             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3773         }
3774         /** Check access and get the requested constructor, eliding security manager checks. */
3775         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3776             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3777             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3778         }
3779         /** Common code for all constructors; do not call directly except from immediately above. */
3780         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3781                                                   boolean checkSecurity) throws IllegalAccessException {
<span class="line-modified">3782             assert(ctor.isObjectConstructor());</span>
3783             checkAccess(REF_newInvokeSpecial, refc, ctor);
3784             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3785             if (checkSecurity)
3786                 checkSecurityManager(refc, ctor);
3787             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
3788             return DirectMethodHandle.make(ctor).setVarargs(ctor);
3789         }
3790 
3791         /** Hook called from the JVM (via MethodHandleNatives) to link MH constants:
3792          */
3793         /*non-public*/
3794         MethodHandle linkMethodHandleConstant(byte refKind, Class&lt;?&gt; defc, String name, Object type)
3795                 throws ReflectiveOperationException {
3796             if (!(type instanceof Class || type instanceof MethodType))
3797                 throw new InternalError(&quot;unresolved MemberName&quot;);
3798             MemberName member = new MemberName(refKind, defc, name, type);
3799             MethodHandle mh = LOOKASIDE_TABLE.get(member);
3800             if (mh != null) {
3801                 checkSymbolicClass(defc);
3802                 return mh;
</pre>
<hr />
<pre>
3952      * Produces a method handle giving write access to elements of an array,
3953      * as if by the {@code astore} bytecode.
3954      * The type of the method handle will have a void return type.
3955      * Its last argument will be the array&#39;s element type.
3956      * The first and second arguments will be the array type and int.
3957      *
3958      * &lt;p&gt; When the returned method handle is invoked,
3959      * the array reference and array index are checked.
3960      * A {@code NullPointerException} will be thrown if the array reference
3961      * is {@code null} and an {@code ArrayIndexOutOfBoundsException} will be
3962      * thrown if the index is negative or if it is greater than or equal to
3963      * the length of the array.
3964      *
3965      * @param arrayClass the class of an array
3966      * @return a method handle which can store values into the array type
3967      * @throws NullPointerException if the argument is null
3968      * @throws IllegalArgumentException if arrayClass is not an array type
3969      * @jvms 6.5 {@code aastore} Instruction
3970      */
3971     public static MethodHandle arrayElementSetter(Class&lt;?&gt; arrayClass) throws IllegalArgumentException {
<span class="line-added">3972         if (arrayClass.isInlineClass()) {</span>
<span class="line-added">3973             throw new UnsupportedOperationException();</span>
<span class="line-added">3974         }</span>
3975         return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.SET);
3976     }
3977 
3978     /**
3979      * Produces a VarHandle giving access to elements of an array of type
3980      * {@code arrayClass}.  The VarHandle&#39;s variable type is the component type
3981      * of {@code arrayClass} and the list of coordinate types is
3982      * {@code (arrayClass, int)}, where the {@code int} coordinate type
3983      * corresponds to an argument that is an index into an array.
3984      * &lt;p&gt;
3985      * Certain access modes of the returned VarHandle are unsupported under
3986      * the following conditions:
3987      * &lt;ul&gt;
3988      * &lt;li&gt;if the component type is anything other than {@code byte},
3989      *     {@code short}, {@code char}, {@code int}, {@code long},
3990      *     {@code float}, or {@code double} then numeric atomic update access
3991      *     modes are unsupported.
3992      * &lt;li&gt;if the field type is anything other than {@code boolean},
3993      *     {@code byte}, {@code short}, {@code char}, {@code int} or
3994      *     {@code long} then bitwise atomic update access modes are
</pre>
<hr />
<pre>
4715     }
4716 
4717     /**
4718      * Produces a constant method handle of the requested return type which
4719      * returns the default value for that type every time it is invoked.
4720      * The resulting constant method handle will have no side effects.
4721      * &lt;p&gt;The returned method handle is equivalent to {@code empty(methodType(type))}.
4722      * It is also equivalent to {@code explicitCastArguments(constant(Object.class, null), methodType(type))},
4723      * since {@code explicitCastArguments} converts {@code null} to default values.
4724      * @param type the expected return type of the desired method handle
4725      * @return a constant method handle that takes no arguments
4726      *         and returns the default value of the given type (or void, if the type is void)
4727      * @throws NullPointerException if the argument is null
4728      * @see MethodHandles#constant
4729      * @see MethodHandles#empty
4730      * @see MethodHandles#explicitCastArguments
4731      * @since 9
4732      */
4733     public static MethodHandle zero(Class&lt;?&gt; type) {
4734         Objects.requireNonNull(type);
<span class="line-modified">4735         if (type.isPrimitive()) {</span>
<span class="line-added">4736             return zero(Wrapper.forPrimitiveType(type), type);</span>
<span class="line-added">4737         } else if (type.isInlineClass()) {</span>
<span class="line-added">4738             throw new UnsupportedOperationException();</span>
<span class="line-added">4739         } else {</span>
<span class="line-added">4740             return zero(Wrapper.OBJECT, type);</span>
<span class="line-added">4741         }</span>
4742     }
4743 
4744     private static MethodHandle identityOrVoid(Class&lt;?&gt; type) {
4745         return type == void.class ? zero(type) : identity(type);
4746     }
4747 
4748     /**
4749      * Produces a method handle of the requested type which ignores any arguments, does nothing,
4750      * and returns a suitable default depending on the return type.
4751      * That is, it returns a zero primitive value, a {@code null}, or {@code void}.
4752      * &lt;p&gt;The returned method handle is equivalent to
4753      * {@code dropArguments(zero(type.returnType()), 0, type.parameterList())}.
4754      *
4755      * @apiNote Given a predicate and target, a useful &quot;if-then&quot; construct can be produced as
4756      * {@code guardWithTest(pred, target, empty(target.type())}.
4757      * @param type the type of the desired method handle
4758      * @return a constant method handle of the given type, which returns a default value of the given return type
4759      * @throws NullPointerException if the argument is null
4760      * @see MethodHandles#zero
4761      * @see MethodHandles#constant
4762      * @since 9
4763      */
4764     public static  MethodHandle empty(MethodType type) {
4765         Objects.requireNonNull(type);
4766         return dropArguments(zero(type.returnType()), 0, type.parameterList());
4767     }
4768 
4769     private static final MethodHandle[] IDENTITY_MHS = new MethodHandle[Wrapper.COUNT];
4770     private static MethodHandle makeIdentity(Class&lt;?&gt; ptype) {
<span class="line-modified">4771         MethodType mtype = MethodType.methodType(ptype, ptype);</span>
4772         LambdaForm lform = LambdaForm.identityForm(BasicType.basicType(ptype));
4773         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.IDENTITY);
4774     }
4775 
4776     private static MethodHandle zero(Wrapper btw, Class&lt;?&gt; rtype) {
4777         int pos = btw.ordinal();
4778         MethodHandle zero = ZERO_MHS[pos];
4779         if (zero == null) {
4780             zero = setCachedMethodHandle(ZERO_MHS, pos, makeZero(btw.primitiveType()));
4781         }
4782         if (zero.type().returnType() == rtype)
4783             return zero;
4784         assert(btw == Wrapper.OBJECT);
4785         return makeZero(rtype);
4786     }
4787     private static final MethodHandle[] ZERO_MHS = new MethodHandle[Wrapper.COUNT];
4788     private static MethodHandle makeZero(Class&lt;?&gt; rtype) {
4789         MethodType mtype = methodType(rtype);
4790         LambdaForm lform = LambdaForm.zeroForm(BasicType.basicType(rtype));
4791         return MethodHandleImpl.makeIntrinsic(mtype, lform, Intrinsic.ZERO);
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandleNatives.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/AccessibleObject.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
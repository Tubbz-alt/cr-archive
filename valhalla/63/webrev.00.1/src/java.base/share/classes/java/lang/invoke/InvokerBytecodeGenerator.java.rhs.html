<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.org.objectweb.asm.ClassWriter;
  29 import jdk.internal.org.objectweb.asm.FieldVisitor;
  30 import jdk.internal.org.objectweb.asm.Label;
  31 import jdk.internal.org.objectweb.asm.MethodVisitor;
  32 import jdk.internal.org.objectweb.asm.Opcodes;
  33 import jdk.internal.org.objectweb.asm.Type;
  34 import sun.invoke.util.VerifyAccess;
  35 import sun.invoke.util.VerifyType;
  36 import sun.invoke.util.Wrapper;
  37 import sun.reflect.misc.ReflectUtil;
  38 
  39 import java.io.File;
  40 import java.io.FileOutputStream;
  41 import java.io.IOException;
  42 import java.lang.reflect.Modifier;
  43 import java.util.ArrayList;
  44 import java.util.Arrays;
  45 import java.util.HashMap;
  46 import java.util.List;
  47 import java.util.stream.Stream;
  48 
  49 import static java.lang.invoke.LambdaForm.BasicType;
  50 import static java.lang.invoke.LambdaForm.BasicType.*;
  51 import static java.lang.invoke.LambdaForm.*;
  52 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  53 import static java.lang.invoke.MethodHandleStatics.*;
  54 import static java.lang.invoke.MethodHandles.Lookup.*;
  55 
  56 /**
  57  * Code generation backend for LambdaForm.
  58  * &lt;p&gt;
  59  * @author John Rose, JSR 292 EG
  60  */
  61 class InvokerBytecodeGenerator {
  62     /** Define class names for convenience. */
  63     private static final String MH      = &quot;java/lang/invoke/MethodHandle&quot;;
  64     private static final String MHI     = &quot;java/lang/invoke/MethodHandleImpl&quot;;
  65     private static final String LF      = &quot;java/lang/invoke/LambdaForm&quot;;
  66     private static final String LFN     = &quot;java/lang/invoke/LambdaForm$Name&quot;;
  67     private static final String CLS     = &quot;java/lang/Class&quot;;
  68     private static final String OBJ     = &quot;java/lang/Object&quot;;
  69     private static final String OBJARY  = &quot;[Ljava/lang/Object;&quot;;
  70 
  71     private static final String LOOP_CLAUSES = MHI + &quot;$LoopClauses&quot;;
  72     private static final String MHARY2       = &quot;[[L&quot; + MH + &quot;;&quot;;
  73     private static final String MH_SIG       = &quot;L&quot; + MH + &quot;;&quot;;
  74 
  75 
  76     private static final String LF_SIG  = &quot;L&quot; + LF + &quot;;&quot;;
  77     private static final String LFN_SIG = &quot;L&quot; + LFN + &quot;;&quot;;
  78     private static final String LL_SIG  = &quot;(L&quot; + OBJ + &quot;;)L&quot; + OBJ + &quot;;&quot;;
  79     private static final String LLV_SIG = &quot;(L&quot; + OBJ + &quot;;L&quot; + OBJ + &quot;;)V&quot;;
  80     private static final String CLASS_PREFIX = LF + &quot;$&quot;;
  81     private static final String SOURCE_PREFIX = &quot;LambdaForm$&quot;;
  82 
  83     /** Name of its super class*/
  84     static final String INVOKER_SUPER_NAME = OBJ;
  85 
  86     /** Name of new class */
  87     private final String className;
  88 
  89     private final LambdaForm lambdaForm;
  90     private final String     invokerName;
  91     private final MethodType invokerType;
  92 
  93     /** Info about local variables in compiled lambda form */
  94     private int[]       localsMap;    // index
  95     private Class&lt;?&gt;[]  localClasses; // type
  96 
  97     /** ASM bytecode generation. */
  98     private ClassWriter cw;
  99     private MethodVisitor mv;
 100     private final List&lt;ClassData&gt; classData = new ArrayList&lt;&gt;();
 101 
 102     /** Single element internal class name lookup cache. */
 103     private Class&lt;?&gt; lastClass;
 104     private String lastInternalName;
 105 
 106     private static final MemberName.Factory MEMBERNAME_FACTORY = MemberName.getFactory();
 107     private static final Class&lt;?&gt; HOST_CLASS = LambdaForm.class;
 108     private static final MethodHandles.Lookup LOOKUP = lookup();
 109 
 110     private static MethodHandles.Lookup lookup() {
 111         try {
 112             return MethodHandles.privateLookupIn(HOST_CLASS, IMPL_LOOKUP);
 113         } catch (IllegalAccessException e) {
 114             throw newInternalError(e);
 115         }
 116     }
 117 
 118     /** Main constructor; other constructors delegate to this one. */
 119     private InvokerBytecodeGenerator(LambdaForm lambdaForm, int localsMapSize,
 120                                      String className, String invokerName, MethodType invokerType) {
 121         int p = invokerName.indexOf(&#39;.&#39;);
 122         if (p &gt; -1) {
 123             className = invokerName.substring(0, p);
 124             invokerName = invokerName.substring(p + 1);
 125         }
 126         if (DUMP_CLASS_FILES) {
 127             className = makeDumpableClassName(className);
 128         }
 129         this.className  = className;
 130         this.lambdaForm = lambdaForm;
 131         this.invokerName = invokerName;
 132         this.invokerType = invokerType;
 133         this.localsMap = new int[localsMapSize+1]; // last entry of localsMap is count of allocated local slots
 134         this.localClasses = new Class&lt;?&gt;[localsMapSize+1];
 135     }
 136 
 137     /** For generating LambdaForm interpreter entry points. */
 138     private InvokerBytecodeGenerator(String className, String invokerName, MethodType invokerType) {
 139         this(null, invokerType.parameterCount(),
 140              className, invokerName, invokerType);
 141         MethodType mt = invokerType.erase();
 142         // Create an array to map name indexes to locals indexes.
 143         localsMap[0] = 0; // localsMap has at least one element
 144         for (int i = 1, index = 0; i &lt; localsMap.length; i++) {
 145             Wrapper w = Wrapper.forBasicType(mt.parameterType(i - 1));
 146             index += w.stackSlots();
 147             localsMap[i] = index;
 148         }
 149     }
 150 
 151     /** For generating customized code for a single LambdaForm. */
 152     private InvokerBytecodeGenerator(String className, LambdaForm form, MethodType invokerType) {
 153         this(className, form.lambdaName(), form, invokerType);
 154     }
 155 
 156     /** For generating customized code for a single LambdaForm. */
 157     InvokerBytecodeGenerator(String className, String invokerName,
 158             LambdaForm form, MethodType invokerType) {
 159         this(form, form.names.length,
 160              className, invokerName, invokerType);
 161         // Create an array to map name indexes to locals indexes.
 162         Name[] names = form.names;
 163         for (int i = 0, index = 0; i &lt; localsMap.length; i++) {
 164             localsMap[i] = index;
 165             if (i &lt; names.length) {
 166                 BasicType type = names[i].type();
 167                 index += type.basicTypeSlots();
 168             }
 169         }
 170     }
 171 
 172     /** instance counters for dumped classes */
 173     private static final HashMap&lt;String,Integer&gt; DUMP_CLASS_FILES_COUNTERS;
 174     /** debugging flag for saving generated class files */
 175     private static final File DUMP_CLASS_FILES_DIR;
 176 
 177     static {
 178         if (DUMP_CLASS_FILES) {
 179             DUMP_CLASS_FILES_COUNTERS = new HashMap&lt;&gt;();
 180             try {
 181                 File dumpDir = new File(&quot;DUMP_CLASS_FILES&quot;);
 182                 if (!dumpDir.exists()) {
 183                     dumpDir.mkdirs();
 184                 }
 185                 DUMP_CLASS_FILES_DIR = dumpDir;
 186                 System.out.println(&quot;Dumping class files to &quot;+DUMP_CLASS_FILES_DIR+&quot;/...&quot;);
 187             } catch (Exception e) {
 188                 throw newInternalError(e);
 189             }
 190         } else {
 191             DUMP_CLASS_FILES_COUNTERS = null;
 192             DUMP_CLASS_FILES_DIR = null;
 193         }
 194     }
 195 
 196     private void maybeDump(final byte[] classFile) {
 197         if (DUMP_CLASS_FILES) {
 198             maybeDump(CLASS_PREFIX + className, classFile);
 199         }
 200     }
 201 
 202     // Also used from BoundMethodHandle
 203     static void maybeDump(final String className, final byte[] classFile) {
 204         if (DUMP_CLASS_FILES) {
 205             java.security.AccessController.doPrivileged(
 206             new java.security.PrivilegedAction&lt;&gt;() {
 207                 public Void run() {
 208                     try {
 209                         String dumpName = className.replace(&#39;.&#39;,&#39;/&#39;);
 210                         File dumpFile = new File(DUMP_CLASS_FILES_DIR, dumpName+&quot;.class&quot;);
 211                         System.out.println(&quot;dump: &quot; + dumpFile);
 212                         dumpFile.getParentFile().mkdirs();
 213                         FileOutputStream file = new FileOutputStream(dumpFile);
 214                         file.write(classFile);
 215                         file.close();
 216                         return null;
 217                     } catch (IOException ex) {
 218                         throw newInternalError(ex);
 219                     }
 220                 }
 221             });
 222         }
 223     }
 224 
 225     private static String makeDumpableClassName(String className) {
 226         Integer ctr;
 227         synchronized (DUMP_CLASS_FILES_COUNTERS) {
 228             ctr = DUMP_CLASS_FILES_COUNTERS.get(className);
 229             if (ctr == null)  ctr = 0;
 230             DUMP_CLASS_FILES_COUNTERS.put(className, ctr+1);
 231         }
 232         String sfx = ctr.toString();
 233         while (sfx.length() &lt; 3)
 234             sfx = &quot;0&quot;+sfx;
 235         className += sfx;
 236         return className;
 237     }
 238 
 239     public static class ClassData {
 240         final String name;
 241         final String desc;
 242         final Object value;
 243 
 244         ClassData(String name, String desc, Object value) {
 245             this.name = name;
 246             this.desc = desc;
 247             this.value = value;
 248         }
 249 
 250         public String name() { return name; }
 251         public String toString() {
 252             return name + &quot;,value=&quot;+value;
 253         }
 254     }
 255 
 256     String classData(Object arg) {
 257         String desc;
 258         if (arg instanceof Class) {
 259             desc = &quot;Ljava/lang/Class;&quot;;
 260         } else if (arg instanceof MethodHandle) {
 261             desc = MH_SIG;
 262         } else if (arg instanceof LambdaForm) {
 263             desc = LF_SIG;
 264         } else {
 265             desc = &quot;Ljava/lang/Object;&quot;;
 266         }
 267 
 268         Class&lt;?&gt; c = arg.getClass();
 269         while (c.isArray()) {
 270             c = c.getComponentType();
 271         }
 272         // unique static variable name
 273         String name = &quot;_DATA_&quot; + c.getSimpleName() + &quot;_&quot; + classData.size();
 274         ClassData cd = new ClassData(name, desc, arg);
 275         classData.add(cd);
 276         return cd.name();
 277     }
 278 
 279     List&lt;Object&gt; classDataValues() {
 280         Object[] data = new Object[classData.size()];
 281         for (int i = 0; i &lt; classData.size(); i++) {
 282             data[i] = classData.get(i).value;
 283         }
 284         return List.of(data);
 285     }
 286 
 287     private static String debugString(Object arg) {
 288         if (arg instanceof MethodHandle) {
 289             MethodHandle mh = (MethodHandle) arg;
 290             MemberName member = mh.internalMemberName();
 291             if (member != null)
 292                 return member.toString();
 293             return mh.debugString();
 294         }
 295         return arg.toString();
 296     }
 297 
 298     /**
 299      * Extract the number of constant pool entries from a given class file.
 300      *
 301      * @param classFile the bytes of the class file in question.
 302      * @return the number of entries in the constant pool.
 303      */
 304     private static int getConstantPoolSize(byte[] classFile) {
 305         // The first few bytes:
 306         // u4 magic;
 307         // u2 minor_version;
 308         // u2 major_version;
 309         // u2 constant_pool_count;
 310         return ((classFile[8] &amp; 0xFF) &lt;&lt; 8) | (classFile[9] &amp; 0xFF);
 311     }
 312 
 313     /**
 314      * Extract the MemberName of a newly-defined method.
 315      */
 316     private MemberName loadMethod(byte[] classFile) {
 317         Class&lt;?&gt; invokerClass = LOOKUP.makeHiddenClassDefiner(classFile)
 318                                       .defineClass(true, classDataValues());
 319         return resolveInvokerMember(invokerClass, invokerName, invokerType);
 320     }
 321 
 322     private static MemberName resolveInvokerMember(Class&lt;?&gt; invokerClass, String name, MethodType type) {
 323         MemberName member = new MemberName(invokerClass, name, type, REF_invokeStatic);
 324         try {
 325             member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);
 326         } catch (ReflectiveOperationException e) {
 327             throw newInternalError(e);
 328         }
 329         return member;
 330     }
 331 
 332     /**
 333      * Set up class file generation.
 334      */
 335     private ClassWriter classFilePrologue() {
 336         final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
 337         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
 338         setClassWriter(cw);
 339         cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
 340                 CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);
 341         cw.visitSource(SOURCE_PREFIX + className, null);
 342         return cw;
 343     }
 344 
 345     private void methodPrologue() {
 346         String invokerDesc = invokerType.toMethodDescriptorString();
 347         mv = cw.visitMethod(Opcodes.ACC_STATIC, invokerName, invokerDesc, null, null);
 348     }
 349 
 350     /**
 351      * Tear down class file generation.
 352      */
 353     private void methodEpilogue() {
 354         mv.visitMaxs(0, 0);
 355         mv.visitEnd();
 356     }
 357 
 358     private String className() {
 359         return CLASS_PREFIX + className;
 360     }
 361 
 362     private void clinit() {
 363         clinit(cw, className(), classData);
 364     }
 365 
 366     /*
 367      * &lt;clinit&gt; to initialize the static final fields with the live class data
 368      * LambdaForms can&#39;t use condy due to bootstrapping issue.
 369      */
 370     static void clinit(ClassWriter cw, String className, List&lt;ClassData&gt; classData) {
 371         if (classData.isEmpty())
 372             return;
 373 
 374         for (ClassData p : classData) {
 375             // add the static field
 376             FieldVisitor fv = cw.visitField(Opcodes.ACC_STATIC|Opcodes.ACC_FINAL, p.name, p.desc, null, null);
 377             fv.visitEnd();
 378         }
 379 
 380         MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);
 381         mv.visitCode();
 382         mv.visitLdcInsn(Type.getType(&quot;L&quot; + className + &quot;;&quot;));
 383         mv.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/invoke/MethodHandleNatives&quot;,
 384                            &quot;classData&quot;, &quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, false);
 385         // we should optimize one single element case that does not need to create a List
 386         mv.visitTypeInsn(Opcodes.CHECKCAST, &quot;java/util/List&quot;);
 387         mv.visitVarInsn(Opcodes.ASTORE, 0);
 388         int index = 0;
 389         for (ClassData p : classData) {
 390             // initialize the static field
 391             mv.visitVarInsn(Opcodes.ALOAD, 0);
 392             emitIconstInsn(mv, index++);
 393             mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, &quot;java/util/List&quot;,
 394                                &quot;get&quot;, &quot;(I)Ljava/lang/Object;&quot;, true);
 395             mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));
 396             mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);
 397         }
 398         mv.visitInsn(Opcodes.RETURN);
 399         mv.visitMaxs(2, 1);
 400         mv.visitEnd();
 401     }
 402 
 403     /*
 404      * Low-level emit helpers.
 405      */
 406     private void emitConst(Object con) {
 407         if (con == null) {
 408             mv.visitInsn(Opcodes.ACONST_NULL);
 409             return;
 410         }
 411         if (con instanceof Integer) {
 412             emitIconstInsn((int) con);
 413             return;
 414         }
 415         if (con instanceof Byte) {
 416             emitIconstInsn((byte)con);
 417             return;
 418         }
 419         if (con instanceof Short) {
 420             emitIconstInsn((short)con);
 421             return;
 422         }
 423         if (con instanceof Character) {
 424             emitIconstInsn((char)con);
 425             return;
 426         }
 427         if (con instanceof Long) {
 428             long x = (long) con;
 429             short sx = (short)x;
 430             if (x == sx) {
 431                 if (sx &gt;= 0 &amp;&amp; sx &lt;= 1) {
 432                     mv.visitInsn(Opcodes.LCONST_0 + (int) sx);
 433                 } else {
 434                     emitIconstInsn((int) x);
 435                     mv.visitInsn(Opcodes.I2L);
 436                 }
 437                 return;
 438             }
 439         }
 440         if (con instanceof Float) {
 441             float x = (float) con;
 442             short sx = (short)x;
 443             if (x == sx) {
 444                 if (sx &gt;= 0 &amp;&amp; sx &lt;= 2) {
 445                     mv.visitInsn(Opcodes.FCONST_0 + (int) sx);
 446                 } else {
 447                     emitIconstInsn((int) x);
 448                     mv.visitInsn(Opcodes.I2F);
 449                 }
 450                 return;
 451             }
 452         }
 453         if (con instanceof Double) {
 454             double x = (double) con;
 455             short sx = (short)x;
 456             if (x == sx) {
 457                 if (sx &gt;= 0 &amp;&amp; sx &lt;= 1) {
 458                     mv.visitInsn(Opcodes.DCONST_0 + (int) sx);
 459                 } else {
 460                     emitIconstInsn((int) x);
 461                     mv.visitInsn(Opcodes.I2D);
 462                 }
 463                 return;
 464             }
 465         }
 466         if (con instanceof Boolean) {
 467             emitIconstInsn((boolean) con ? 1 : 0);
 468             return;
 469         }
 470         // fall through:
 471         mv.visitLdcInsn(con);
 472     }
 473 
 474     private void emitIconstInsn(final int cst) {
 475         emitIconstInsn(mv, cst);
 476     }
 477 
 478     private static void emitIconstInsn(MethodVisitor mv, int cst) {
 479         if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {
 480             mv.visitInsn(Opcodes.ICONST_0 + cst);
 481         } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {
 482             mv.visitIntInsn(Opcodes.BIPUSH, cst);
 483         } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {
 484             mv.visitIntInsn(Opcodes.SIPUSH, cst);
 485         } else {
 486             mv.visitLdcInsn(cst);
 487         }
 488     }
 489 
 490     /*
 491      * NOTE: These load/store methods use the localsMap to find the correct index!
 492      */
 493     private void emitLoadInsn(BasicType type, int index) {
 494         int opcode = loadInsnOpcode(type);
 495         mv.visitVarInsn(opcode, localsMap[index]);
 496     }
 497 
 498     private int loadInsnOpcode(BasicType type) throws InternalError {
 499         switch (type) {
 500             case I_TYPE: return Opcodes.ILOAD;
 501             case J_TYPE: return Opcodes.LLOAD;
 502             case F_TYPE: return Opcodes.FLOAD;
 503             case D_TYPE: return Opcodes.DLOAD;
 504             case L_TYPE: return Opcodes.ALOAD;
 505             default:
 506                 throw new InternalError(&quot;unknown type: &quot; + type);
 507         }
 508     }
 509     private void emitAloadInsn(int index) {
 510         emitLoadInsn(L_TYPE, index);
 511     }
 512 
 513     private void emitStoreInsn(BasicType type, int index) {
 514         int opcode = storeInsnOpcode(type);
 515         mv.visitVarInsn(opcode, localsMap[index]);
 516     }
 517 
 518     private int storeInsnOpcode(BasicType type) throws InternalError {
 519         switch (type) {
 520             case I_TYPE: return Opcodes.ISTORE;
 521             case J_TYPE: return Opcodes.LSTORE;
 522             case F_TYPE: return Opcodes.FSTORE;
 523             case D_TYPE: return Opcodes.DSTORE;
 524             case L_TYPE: return Opcodes.ASTORE;
 525             default:
 526                 throw new InternalError(&quot;unknown type: &quot; + type);
 527         }
 528     }
 529     private void emitAstoreInsn(int index) {
 530         emitStoreInsn(L_TYPE, index);
 531     }
 532 
 533     private byte arrayTypeCode(Wrapper elementType) {
 534         switch (elementType) {
 535             case BOOLEAN: return Opcodes.T_BOOLEAN;
 536             case BYTE:    return Opcodes.T_BYTE;
 537             case CHAR:    return Opcodes.T_CHAR;
 538             case SHORT:   return Opcodes.T_SHORT;
 539             case INT:     return Opcodes.T_INT;
 540             case LONG:    return Opcodes.T_LONG;
 541             case FLOAT:   return Opcodes.T_FLOAT;
 542             case DOUBLE:  return Opcodes.T_DOUBLE;
 543             case OBJECT:  return 0; // in place of Opcodes.T_OBJECT
 544             default:      throw new InternalError();
 545         }
 546     }
 547 
 548     private int arrayInsnOpcode(byte tcode, int aaop) throws InternalError {
 549         assert(aaop == Opcodes.AASTORE || aaop == Opcodes.AALOAD);
 550         int xas;
 551         switch (tcode) {
 552             case Opcodes.T_BOOLEAN: xas = Opcodes.BASTORE; break;
 553             case Opcodes.T_BYTE:    xas = Opcodes.BASTORE; break;
 554             case Opcodes.T_CHAR:    xas = Opcodes.CASTORE; break;
 555             case Opcodes.T_SHORT:   xas = Opcodes.SASTORE; break;
 556             case Opcodes.T_INT:     xas = Opcodes.IASTORE; break;
 557             case Opcodes.T_LONG:    xas = Opcodes.LASTORE; break;
 558             case Opcodes.T_FLOAT:   xas = Opcodes.FASTORE; break;
 559             case Opcodes.T_DOUBLE:  xas = Opcodes.DASTORE; break;
 560             case 0:                 xas = Opcodes.AASTORE; break;
 561             default:      throw new InternalError();
 562         }
 563         return xas - Opcodes.AASTORE + aaop;
 564     }
 565 
 566     /**
 567      * Emit a boxing call.
 568      *
 569      * @param wrapper primitive type class to box.
 570      */
 571     private void emitBoxing(Wrapper wrapper) {
 572         String owner = &quot;java/lang/&quot; + wrapper.wrapperType().getSimpleName();
 573         String name  = &quot;valueOf&quot;;
 574         String desc  = &quot;(&quot; + wrapper.basicTypeChar() + &quot;)L&quot; + owner + &quot;;&quot;;
 575         mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, desc, false);
 576     }
 577 
 578     /**
 579      * Emit an unboxing call (plus preceding checkcast).
 580      *
 581      * @param wrapper wrapper type class to unbox.
 582      */
 583     private void emitUnboxing(Wrapper wrapper) {
 584         String owner = &quot;java/lang/&quot; + wrapper.wrapperType().getSimpleName();
 585         String name  = wrapper.primitiveSimpleName() + &quot;Value&quot;;
 586         String desc  = &quot;()&quot; + wrapper.basicTypeChar();
 587         emitReferenceCast(wrapper.wrapperType(), null);
 588         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, desc, false);
 589     }
 590 
 591     /**
 592      * Emit an implicit conversion for an argument which must be of the given pclass.
 593      * This is usually a no-op, except when pclass is a subword type or a reference other than Object or an interface.
 594      *
 595      * @param ptype type of value present on stack
 596      * @param pclass type of value required on stack
 597      * @param arg compile-time representation of value on stack (Node, constant) or null if none
 598      */
 599     private void emitImplicitConversion(BasicType ptype, Class&lt;?&gt; pclass, Object arg) {
 600         assert(basicType(pclass) == ptype);  // boxing/unboxing handled by caller
 601         if (pclass == ptype.basicTypeClass() &amp;&amp; ptype != L_TYPE)
 602             return;   // nothing to do
 603         switch (ptype) {
 604             case L_TYPE:
 605                 if (VerifyType.isNullConversion(Object.class, pclass, false)) {
 606                     if (PROFILE_LEVEL &gt; 0)
 607                         emitReferenceCast(Object.class, arg);
 608                     return;
 609                 }
 610                 emitReferenceCast(pclass, arg);
 611                 return;
 612             case I_TYPE:
 613                 if (!VerifyType.isNullConversion(int.class, pclass, false))
 614                     emitPrimCast(ptype.basicTypeWrapper(), Wrapper.forPrimitiveType(pclass));
 615                 return;
 616         }
 617         throw newInternalError(&quot;bad implicit conversion: tc=&quot;+ptype+&quot;: &quot;+pclass);
 618     }
 619 
 620     /** Update localClasses type map.  Return true if the information is already present. */
 621     private boolean assertStaticType(Class&lt;?&gt; cls, Name n) {
 622         int local = n.index();
 623         Class&lt;?&gt; aclass = localClasses[local];
 624         if (aclass != null &amp;&amp; (aclass == cls || cls.isAssignableFrom(aclass))) {
 625             return true;  // type info is already present
 626         } else if (aclass == null || aclass.isAssignableFrom(cls)) {
 627             localClasses[local] = cls;  // type info can be improved
 628         }
 629         return false;
 630     }
 631 
 632     private void emitReferenceCast(Class&lt;?&gt; cls, Object arg) {
 633         Name writeBack = null;  // local to write back result
 634         if (arg instanceof Name) {
 635             Name n = (Name) arg;
 636             if (lambdaForm.useCount(n) &gt; 1) {
 637                 // This guy gets used more than once.
 638                 writeBack = n;
 639                 if (assertStaticType(cls, n)) {
 640                     return; // this cast was already performed
 641                 }
 642             }
 643         }
 644         if (isStaticallyNameable(cls)) {
 645             String sig = getInternalName(cls);
 646             mv.visitTypeInsn(Opcodes.CHECKCAST, sig);
 647         } else {
 648             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(cls), &quot;Ljava/lang/Class;&quot;);
 649             mv.visitInsn(Opcodes.SWAP);
 650             mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, &quot;cast&quot;, LL_SIG, false);
 651             if (Object[].class.isAssignableFrom(cls))
 652                 mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);
 653             else if (PROFILE_LEVEL &gt; 0)
 654                 mv.visitTypeInsn(Opcodes.CHECKCAST, OBJ);
 655         }
 656         if (writeBack != null) {
 657             mv.visitInsn(Opcodes.DUP);
 658             emitAstoreInsn(writeBack.index());
 659         }
 660     }
 661 
 662     /**
 663      * Emits an actual return instruction conforming to the given return type.
 664      */
 665     private void emitReturnInsn(BasicType type) {
 666         int opcode;
 667         switch (type) {
 668         case I_TYPE:  opcode = Opcodes.IRETURN;  break;
 669         case J_TYPE:  opcode = Opcodes.LRETURN;  break;
 670         case F_TYPE:  opcode = Opcodes.FRETURN;  break;
 671         case D_TYPE:  opcode = Opcodes.DRETURN;  break;
 672         case L_TYPE:  opcode = Opcodes.ARETURN;  break;
 673         case V_TYPE:  opcode = Opcodes.RETURN;   break;
 674         default:
 675             throw new InternalError(&quot;unknown return type: &quot; + type);
 676         }
 677         mv.visitInsn(opcode);
 678     }
 679 
 680     private String getInternalName(Class&lt;?&gt; c) {
 681         if (c == Object.class)             return OBJ;
 682         else if (c == Object[].class)      return OBJARY;
 683         else if (c == Class.class)         return CLS;
 684         else if (c == MethodHandle.class)  return MH;
 685         assert(VerifyAccess.isTypeVisible(c, Object.class)) : c.getName();
 686 
 687         if (c == lastClass) {
 688             return lastInternalName;
 689         }
 690         lastClass = c;
 691         return lastInternalName = c.getName().replace(&#39;.&#39;, &#39;/&#39;);
 692     }
 693 
 694     private static MemberName resolveFrom(String name, MethodType type, Class&lt;?&gt; holder) {
 695         MemberName member = new MemberName(holder, name, type, REF_invokeStatic);
 696         MemberName resolvedMember = MemberName.getFactory().resolveOrNull(REF_invokeStatic, member, holder);
 697         if (TRACE_RESOLVE) {
 698             System.out.println(&quot;[LF_RESOLVE] &quot; + holder.getName() + &quot; &quot; + name + &quot; &quot; +
 699                     shortenSignature(basicTypeSignature(type)) + (resolvedMember != null ? &quot; (success)&quot; : &quot; (fail)&quot;) );
 700         }
 701         return resolvedMember;
 702     }
 703 
 704     private static MemberName lookupPregenerated(LambdaForm form, MethodType invokerType) {
 705         if (form.customized != null) {
 706             // No pre-generated version for customized LF
 707             return null;
 708         }
 709         String name = form.kind.methodName;
 710         switch (form.kind) {
 711             case BOUND_REINVOKER: {
 712                 name = name + &quot;_&quot; + BoundMethodHandle.speciesDataFor(form).key();
 713                 return resolveFrom(name, invokerType, DelegatingMethodHandle.Holder.class);
 714             }
 715             case DELEGATE:                  return resolveFrom(name, invokerType, DelegatingMethodHandle.Holder.class);
 716             case ZERO:                      // fall-through
 717             case IDENTITY: {
 718                 name = name + &quot;_&quot; + form.returnType().basicTypeChar();
 719                 return resolveFrom(name, invokerType, LambdaForm.Holder.class);
 720             }
 721             case EXACT_INVOKER:             // fall-through
 722             case EXACT_LINKER:              // fall-through
 723             case LINK_TO_CALL_SITE:         // fall-through
 724             case LINK_TO_TARGET_METHOD:     // fall-through
 725             case GENERIC_INVOKER:           // fall-through
 726             case GENERIC_LINKER:            return resolveFrom(name, invokerType.basicType(), Invokers.Holder.class);
 727             case GET_REFERENCE:             // fall-through
 728             case GET_BOOLEAN:               // fall-through
 729             case GET_BYTE:                  // fall-through
 730             case GET_CHAR:                  // fall-through
 731             case GET_SHORT:                 // fall-through
 732             case GET_INT:                   // fall-through
 733             case GET_LONG:                  // fall-through
 734             case GET_FLOAT:                 // fall-through
 735             case GET_DOUBLE:                // fall-through
 736             case PUT_REFERENCE:             // fall-through
 737             case PUT_BOOLEAN:               // fall-through
 738             case PUT_BYTE:                  // fall-through
 739             case PUT_CHAR:                  // fall-through
 740             case PUT_SHORT:                 // fall-through
 741             case PUT_INT:                   // fall-through
 742             case PUT_LONG:                  // fall-through
 743             case PUT_FLOAT:                 // fall-through
 744             case PUT_DOUBLE:                // fall-through
 745             case DIRECT_NEW_INVOKE_SPECIAL: // fall-through
 746             case DIRECT_INVOKE_INTERFACE:   // fall-through
 747             case DIRECT_INVOKE_SPECIAL:     // fall-through
 748             case DIRECT_INVOKE_SPECIAL_IFC: // fall-through
 749             case DIRECT_INVOKE_STATIC:      // fall-through
 750             case DIRECT_INVOKE_STATIC_INIT: // fall-through
 751             case DIRECT_INVOKE_VIRTUAL:     return resolveFrom(name, invokerType, DirectMethodHandle.Holder.class);
 752         }
 753         return null;
 754     }
 755 
 756     /**
 757      * Generate customized bytecode for a given LambdaForm.
 758      */
 759     static MemberName generateCustomizedCode(LambdaForm form, MethodType invokerType) {
 760         MemberName pregenerated = lookupPregenerated(form, invokerType);
 761         if (pregenerated != null)  return pregenerated; // pre-generated bytecode
 762 
 763         InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;MH&quot;, form, invokerType);
 764         return g.loadMethod(g.generateCustomizedCodeBytes());
 765     }
 766 
 767     /** Generates code to check that actual receiver and LambdaForm matches */
 768     private boolean checkActualReceiver() {
 769         // Expects MethodHandle on the stack and actual receiver MethodHandle in slot #0
 770         mv.visitInsn(Opcodes.DUP);
 771         mv.visitVarInsn(Opcodes.ALOAD, localsMap[0]);
 772         mv.visitMethodInsn(Opcodes.INVOKESTATIC, MHI, &quot;assertSame&quot;, LLV_SIG, false);
 773         return true;
 774     }
 775 
 776     static String className(String cn) {
 777         assert checkClassName(cn): &quot;Class not found: &quot; + cn;
 778         return cn;
 779     }
 780 
 781     static boolean checkClassName(String cn) {
 782         Type tp = Type.getType(cn);
 783         // additional sanity so only valid &quot;L;&quot; descriptors work
 784         if (tp.getSort() != Type.OBJECT) {
 785             return false;
 786         }
 787         try {
 788             Class&lt;?&gt; c = Class.forName(tp.getClassName(), false, null);
 789             return true;
 790         } catch (ClassNotFoundException e) {
 791             return false;
 792         }
 793     }
 794 
 795     static final String      DONTINLINE_SIG = className(&quot;Ljdk/internal/vm/annotation/DontInline;&quot;);
 796     static final String     FORCEINLINE_SIG = className(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;);
 797     static final String          HIDDEN_SIG = className(&quot;Ljdk/internal/vm/annotation/Hidden;&quot;);
 798     static final String INJECTEDPROFILE_SIG = className(&quot;Ljava/lang/invoke/InjectedProfile;&quot;);
 799     static final String     LF_COMPILED_SIG = className(&quot;Ljava/lang/invoke/LambdaForm$Compiled;&quot;);
 800 
 801     /**
 802      * Generate an invoker method for the passed {@link LambdaForm}.
 803      */
 804     private byte[] generateCustomizedCodeBytes() {
 805         classFilePrologue();
 806         addMethod();
 807         clinit();
 808         bogusMethod(lambdaForm);
 809 
 810         final byte[] classFile = toByteArray();
 811         maybeDump(classFile);
 812         return classFile;
 813     }
 814 
 815     void setClassWriter(ClassWriter cw) {
 816         this.cw = cw;
 817     }
 818 
 819     void addMethod() {
 820         methodPrologue();
 821 
 822         // Suppress this method in backtraces displayed to the user.
 823         mv.visitAnnotation(HIDDEN_SIG, true);
 824 
 825         // Mark this method as a compiled LambdaForm
 826         mv.visitAnnotation(LF_COMPILED_SIG, true);
 827 
 828         if (lambdaForm.forceInline) {
 829             // Force inlining of this invoker method.
 830             mv.visitAnnotation(FORCEINLINE_SIG, true);
 831         } else {
 832             mv.visitAnnotation(DONTINLINE_SIG, true);
 833         }
 834 
 835         classData(lambdaForm); // keep LambdaForm instance &amp; its compiled form lifetime tightly coupled.
 836 
 837         if (lambdaForm.customized != null) {
 838             // Since LambdaForm is customized for a particular MethodHandle, it&#39;s safe to substitute
 839             // receiver MethodHandle (at slot #0) with an embedded constant and use it instead.
 840             // It enables more efficient code generation in some situations, since embedded constants
 841             // are compile-time constants for JIT compiler.
 842             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(lambdaForm.customized), MH_SIG);
 843             mv.visitTypeInsn(Opcodes.CHECKCAST, MH);
 844             assert(checkActualReceiver()); // expects MethodHandle on top of the stack
 845             mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);
 846         }
 847 
 848         // iterate over the form&#39;s names, generating bytecode instructions for each
 849         // start iterating at the first name following the arguments
 850         Name onStack = null;
 851         for (int i = lambdaForm.arity; i &lt; lambdaForm.names.length; i++) {
 852             Name name = lambdaForm.names[i];
 853 
 854             emitStoreResult(onStack);
 855             onStack = name;  // unless otherwise modified below
 856             MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();
 857             switch (intr) {
 858                 case SELECT_ALTERNATIVE:
 859                     assert lambdaForm.isSelectAlternative(i);
 860                     if (PROFILE_GWT) {
 861                         assert(name.arguments[0] instanceof Name &amp;&amp;
 862                                 ((Name)name.arguments[0]).refersTo(MethodHandleImpl.class, &quot;profileBoolean&quot;));
 863                         mv.visitAnnotation(INJECTEDPROFILE_SIG, true);
 864                     }
 865                     onStack = emitSelectAlternative(name, lambdaForm.names[i+1]);
 866                     i++;  // skip MH.invokeBasic of the selectAlternative result
 867                     continue;
 868                 case GUARD_WITH_CATCH:
 869                     assert lambdaForm.isGuardWithCatch(i);
 870                     onStack = emitGuardWithCatch(i);
 871                     i += 2; // jump to the end of GWC idiom
 872                     continue;
 873                 case TRY_FINALLY:
 874                     assert lambdaForm.isTryFinally(i);
 875                     onStack = emitTryFinally(i);
 876                     i += 2; // jump to the end of the TF idiom
 877                     continue;
 878                 case LOOP:
 879                     assert lambdaForm.isLoop(i);
 880                     onStack = emitLoop(i);
 881                     i += 2; // jump to the end of the LOOP idiom
 882                     continue;
 883                 case NEW_ARRAY:
 884                     Class&lt;?&gt; rtype = name.function.methodType().returnType();
 885                     if (isStaticallyNameable(rtype)) {
 886                         emitNewArray(name);
 887                         continue;
 888                     }
 889                     break;
 890                 case ARRAY_LOAD:
 891                     emitArrayLoad(name);
 892                     continue;
 893                 case ARRAY_STORE:
 894                     emitArrayStore(name);
 895                     continue;
 896                 case ARRAY_LENGTH:
 897                     emitArrayLength(name);
 898                     continue;
 899                 case IDENTITY:
 900                     assert(name.arguments.length == 1);
 901                     emitPushArguments(name, 0);
 902                     continue;
 903                 case ZERO:
 904                     assert(name.arguments.length == 0);
 905                     emitConst(name.type.basicTypeWrapper().zero());
 906                     continue;
 907                 case NONE:
 908                     // no intrinsic associated
 909                     break;
 910                 default:
 911                     throw newInternalError(&quot;Unknown intrinsic: &quot;+intr);
 912             }
 913 
 914             MemberName member = name.function.member();
 915             if (isStaticallyInvocable(member)) {
 916                 emitStaticInvoke(member, name);
 917             } else {
 918                 emitInvoke(name);
 919             }
 920         }
 921 
 922         // return statement
 923         emitReturn(onStack);
 924 
 925         methodEpilogue();
 926     }
 927 
 928     /*
 929      * @throws BytecodeGenerationException if something goes wrong when
 930      *         generating the byte code
 931      */
 932     private byte[] toByteArray() {
 933         try {
 934             return cw.toByteArray();
 935         } catch (RuntimeException e) {
 936             throw new BytecodeGenerationException(e);
 937         }
 938     }
 939 
 940     @SuppressWarnings(&quot;serial&quot;)
 941     static final class BytecodeGenerationException extends RuntimeException {
 942         BytecodeGenerationException(Exception cause) {
 943             super(cause);
 944         }
 945     }
 946 
 947     void emitArrayLoad(Name name)   { emitArrayOp(name, Opcodes.AALOAD);      }
 948     void emitArrayStore(Name name)  { emitArrayOp(name, Opcodes.AASTORE);     }
 949     void emitArrayLength(Name name) { emitArrayOp(name, Opcodes.ARRAYLENGTH); }
 950 
 951     void emitArrayOp(Name name, int arrayOpcode) {
 952         assert arrayOpcode == Opcodes.AALOAD || arrayOpcode == Opcodes.AASTORE || arrayOpcode == Opcodes.ARRAYLENGTH;
 953         Class&lt;?&gt; elementType = name.function.methodType().parameterType(0).getComponentType();
 954         assert elementType != null;
 955         emitPushArguments(name, 0);
 956         if (arrayOpcode != Opcodes.ARRAYLENGTH &amp;&amp; elementType.isPrimitive()) {
 957             Wrapper w = Wrapper.forPrimitiveType(elementType);
 958             arrayOpcode = arrayInsnOpcode(arrayTypeCode(w), arrayOpcode);
 959         }
 960         mv.visitInsn(arrayOpcode);
 961     }
 962 
 963     /**
 964      * Emit an invoke for the given name.
 965      */
 966     void emitInvoke(Name name) {
 967         assert(!name.isLinkerMethodInvoke());  // should use the static path for these
 968         if (true) {
 969             // push receiver
 970             MethodHandle target = name.function.resolvedHandle();
 971             assert(target != null) : name.exprString();
 972             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(target), MH_SIG);
 973             emitReferenceCast(MethodHandle.class, target);
 974         } else {
 975             // load receiver
 976             emitAloadInsn(0);
 977             emitReferenceCast(MethodHandle.class, null);
 978             mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, LF_SIG);
 979             mv.visitFieldInsn(Opcodes.GETFIELD, LF, &quot;names&quot;, LFN_SIG);
 980             // TODO more to come
 981         }
 982 
 983         // push arguments
 984         emitPushArguments(name, 0);
 985 
 986         // invocation
 987         MethodType type = name.function.methodType();
 988         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
 989     }
 990 
 991     private static Class&lt;?&gt;[] STATICALLY_INVOCABLE_PACKAGES = {
 992         // Sample classes from each package we are willing to bind to statically:
 993         java.lang.Object.class,
 994         java.util.Arrays.class,
 995         jdk.internal.misc.Unsafe.class
 996         //MethodHandle.class already covered
 997     };
 998 
 999     static boolean isStaticallyInvocable(NamedFunction ... functions) {
1000         for (NamedFunction nf : functions) {
1001             if (!isStaticallyInvocable(nf.member())) {
1002                 return false;
1003             }
1004         }
1005         return true;
1006     }
1007 
1008     static boolean isStaticallyInvocable(Name name) {
1009         return isStaticallyInvocable(name.function.member());
1010     }
1011 
1012     static boolean isStaticallyInvocable(MemberName member) {
1013         if (member == null)  return false;
<a name="1" id="anc1"></a><span class="line-modified">1014         if (member.isObjectConstructorOrStaticInitMethod())  return false;</span>
<span class="line-added">1015 </span>
1016         Class&lt;?&gt; cls = member.getDeclaringClass();
1017         // Fast-path non-private members declared by MethodHandles, which is a common
1018         // case
1019         if (MethodHandle.class.isAssignableFrom(cls) &amp;&amp; !member.isPrivate()) {
1020             assert(isStaticallyInvocableType(member.getMethodOrFieldType()));
1021             return true;
1022         }
1023         if (cls.isArray() || cls.isPrimitive())
1024             return false;  // FIXME
1025         if (cls.isAnonymousClass() || cls.isLocalClass())
1026             return false;  // inner class of some sort
1027         if (cls.getClassLoader() != MethodHandle.class.getClassLoader())
1028             return false;  // not on BCP
1029         if (cls.isHidden())
1030             return false;
1031         if (ReflectUtil.isVMAnonymousClass(cls))   // FIXME: Unsafe::defineAnonymousClass to be removed
1032             return false;
1033         if (!isStaticallyInvocableType(member.getMethodOrFieldType()))
1034             return false;
1035         if (!member.isPrivate() &amp;&amp; VerifyAccess.isSamePackage(MethodHandle.class, cls))
1036             return true;   // in java.lang.invoke package
1037         if (member.isPublic() &amp;&amp; isStaticallyNameable(cls))
1038             return true;
1039         return false;
1040     }
1041 
1042     private static boolean isStaticallyInvocableType(MethodType mtype) {
1043         if (!isStaticallyNameable(mtype.returnType()))
1044             return false;
1045         for (Class&lt;?&gt; ptype : mtype.parameterArray())
1046             if (!isStaticallyNameable(ptype))
1047                 return false;
1048         return true;
1049     }
1050 
1051     static boolean isStaticallyNameable(Class&lt;?&gt; cls) {
1052         if (cls == Object.class)
1053             return true;
1054         if (MethodHandle.class.isAssignableFrom(cls)) {
1055             assert(!cls.isHidden());
1056             return true;
1057         }
1058         while (cls.isArray())
1059             cls = cls.getComponentType();
1060         if (cls.isPrimitive())
1061             return true;  // int[].class, for example
1062         if (cls.isHidden())
1063             return false;
1064         if (ReflectUtil.isVMAnonymousClass(cls))   // FIXME: Unsafe::defineAnonymousClass to be removed
1065             return false;
1066         // could use VerifyAccess.isClassAccessible but the following is a safe approximation
1067         if (cls.getClassLoader() != Object.class.getClassLoader())
1068             return false;
1069         if (VerifyAccess.isSamePackage(MethodHandle.class, cls))
1070             return true;
1071         if (!Modifier.isPublic(cls.getModifiers()))
1072             return false;
1073         for (Class&lt;?&gt; pkgcls : STATICALLY_INVOCABLE_PACKAGES) {
1074             if (VerifyAccess.isSamePackage(pkgcls, cls))
1075                 return true;
1076         }
1077         return false;
1078     }
1079 
1080     void emitStaticInvoke(Name name) {
1081         emitStaticInvoke(name.function.member(), name);
1082     }
1083 
1084     /**
1085      * Emit an invoke for the given name, using the MemberName directly.
1086      */
1087     void emitStaticInvoke(MemberName member, Name name) {
1088         assert(member.equals(name.function.member()));
1089         Class&lt;?&gt; defc = member.getDeclaringClass();
1090         String cname = getInternalName(defc);
1091         String mname = member.getName();
1092         String mtype;
1093         byte refKind = member.getReferenceKind();
1094         if (refKind == REF_invokeSpecial) {
1095             // in order to pass the verifier, we need to convert this to invokevirtual in all cases
1096             assert(member.canBeStaticallyBound()) : member;
1097             refKind = REF_invokeVirtual;
1098         }
1099 
1100         assert(!(member.getDeclaringClass().isInterface() &amp;&amp; refKind == REF_invokeVirtual));
1101 
1102         // push arguments
1103         emitPushArguments(name, 0);
1104 
1105         // invocation
1106         if (member.isMethod()) {
1107             mtype = member.getMethodType().toMethodDescriptorString();
1108             mv.visitMethodInsn(refKindOpcode(refKind), cname, mname, mtype,
1109                                member.getDeclaringClass().isInterface());
1110         } else {
1111             mtype = MethodType.toFieldDescriptorString(member.getFieldType());
1112             mv.visitFieldInsn(refKindOpcode(refKind), cname, mname, mtype);
1113         }
1114         // Issue a type assertion for the result, so we can avoid casts later.
1115         if (name.type == L_TYPE) {
1116             Class&lt;?&gt; rtype = member.getInvocationType().returnType();
1117             assert(!rtype.isPrimitive());
1118             if (rtype != Object.class &amp;&amp; !rtype.isInterface()) {
1119                 assertStaticType(rtype, name);
1120             }
1121         }
1122     }
1123 
1124     void emitNewArray(Name name) throws InternalError {
1125         Class&lt;?&gt; rtype = name.function.methodType().returnType();
1126         if (name.arguments.length == 0) {
1127             // The array will be a constant.
1128             Object emptyArray;
1129             try {
1130                 emptyArray = name.function.resolvedHandle().invoke();
1131             } catch (Throwable ex) {
1132                 throw uncaughtException(ex);
1133             }
1134             assert(java.lang.reflect.Array.getLength(emptyArray) == 0);
1135             assert(emptyArray.getClass() == rtype);  // exact typing
1136             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(emptyArray), &quot;Ljava/lang/Object;&quot;);
1137             emitReferenceCast(rtype, emptyArray);
1138             return;
1139         }
1140         Class&lt;?&gt; arrayElementType = rtype.getComponentType();
1141         assert(arrayElementType != null);
1142         emitIconstInsn(name.arguments.length);
1143         int xas = Opcodes.AASTORE;
1144         if (!arrayElementType.isPrimitive()) {
1145             mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(arrayElementType));
1146         } else {
1147             byte tc = arrayTypeCode(Wrapper.forPrimitiveType(arrayElementType));
1148             xas = arrayInsnOpcode(tc, xas);
1149             mv.visitIntInsn(Opcodes.NEWARRAY, tc);
1150         }
1151         // store arguments
1152         for (int i = 0; i &lt; name.arguments.length; i++) {
1153             mv.visitInsn(Opcodes.DUP);
1154             emitIconstInsn(i);
1155             emitPushArgument(name, i);
1156             mv.visitInsn(xas);
1157         }
1158         // the array is left on the stack
1159         assertStaticType(rtype, name);
1160     }
1161     int refKindOpcode(byte refKind) {
1162         switch (refKind) {
1163         case REF_invokeVirtual:      return Opcodes.INVOKEVIRTUAL;
1164         case REF_invokeStatic:       return Opcodes.INVOKESTATIC;
1165         case REF_invokeSpecial:      return Opcodes.INVOKESPECIAL;
1166         case REF_invokeInterface:    return Opcodes.INVOKEINTERFACE;
1167         case REF_getField:           return Opcodes.GETFIELD;
1168         case REF_putField:           return Opcodes.PUTFIELD;
1169         case REF_getStatic:          return Opcodes.GETSTATIC;
1170         case REF_putStatic:          return Opcodes.PUTSTATIC;
1171         }
1172         throw new InternalError(&quot;refKind=&quot;+refKind);
1173     }
1174 
1175     /**
1176      * Emit bytecode for the selectAlternative idiom.
1177      *
1178      * The pattern looks like (Cf. MethodHandleImpl.makeGuardWithTest):
1179      * &lt;blockquote&gt;&lt;pre&gt;{@code
1180      *   Lambda(a0:L,a1:I)=&gt;{
1181      *     t2:I=foo.test(a1:I);
1182      *     t3:L=MethodHandleImpl.selectAlternative(t2:I,(MethodHandle(int)int),(MethodHandle(int)int));
1183      *     t4:I=MethodHandle.invokeBasic(t3:L,a1:I);t4:I}
1184      * }&lt;/pre&gt;&lt;/blockquote&gt;
1185      */
1186     private Name emitSelectAlternative(Name selectAlternativeName, Name invokeBasicName) {
1187         assert isStaticallyInvocable(invokeBasicName);
1188 
1189         Name receiver = (Name) invokeBasicName.arguments[0];
1190 
1191         Label L_fallback = new Label();
1192         Label L_done     = new Label();
1193 
1194         // load test result
1195         emitPushArgument(selectAlternativeName, 0);
1196 
1197         // if_icmpne L_fallback
1198         mv.visitJumpInsn(Opcodes.IFEQ, L_fallback);
1199 
1200         // invoke selectAlternativeName.arguments[1]
1201         Class&lt;?&gt;[] preForkClasses = localClasses.clone();
1202         emitPushArgument(selectAlternativeName, 1);  // get 2nd argument of selectAlternative
1203         emitAstoreInsn(receiver.index());  // store the MH in the receiver slot
1204         emitStaticInvoke(invokeBasicName);
1205 
1206         // goto L_done
1207         mv.visitJumpInsn(Opcodes.GOTO, L_done);
1208 
1209         // L_fallback:
1210         mv.visitLabel(L_fallback);
1211 
1212         // invoke selectAlternativeName.arguments[2]
1213         System.arraycopy(preForkClasses, 0, localClasses, 0, preForkClasses.length);
1214         emitPushArgument(selectAlternativeName, 2);  // get 3rd argument of selectAlternative
1215         emitAstoreInsn(receiver.index());  // store the MH in the receiver slot
1216         emitStaticInvoke(invokeBasicName);
1217 
1218         // L_done:
1219         mv.visitLabel(L_done);
1220         // for now do not bother to merge typestate; just reset to the dominator state
1221         System.arraycopy(preForkClasses, 0, localClasses, 0, preForkClasses.length);
1222 
1223         return invokeBasicName;  // return what&#39;s on stack
1224     }
1225 
1226     /**
1227      * Emit bytecode for the guardWithCatch idiom.
1228      *
1229      * The pattern looks like (Cf. MethodHandleImpl.makeGuardWithCatch):
1230      * &lt;blockquote&gt;&lt;pre&gt;{@code
1231      *  guardWithCatch=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L,a5:L,a6:L,a7:L)=&gt;{
1232      *    t8:L=MethodHandle.invokeBasic(a4:L,a6:L,a7:L);
1233      *    t9:L=MethodHandleImpl.guardWithCatch(a1:L,a2:L,a3:L,t8:L);
1234      *   t10:I=MethodHandle.invokeBasic(a5:L,t9:L);t10:I}
1235      * }&lt;/pre&gt;&lt;/blockquote&gt;
1236      *
1237      * It is compiled into bytecode equivalent of the following code:
1238      * &lt;blockquote&gt;&lt;pre&gt;{@code
1239      *  try {
1240      *      return a1.invokeBasic(a6, a7);
1241      *  } catch (Throwable e) {
1242      *      if (!a2.isInstance(e)) throw e;
1243      *      return a3.invokeBasic(ex, a6, a7);
1244      *  }}&lt;/pre&gt;&lt;/blockquote&gt;
1245      */
1246     private Name emitGuardWithCatch(int pos) {
1247         Name args    = lambdaForm.names[pos];
1248         Name invoker = lambdaForm.names[pos+1];
1249         Name result  = lambdaForm.names[pos+2];
1250 
1251         Label L_startBlock = new Label();
1252         Label L_endBlock = new Label();
1253         Label L_handler = new Label();
1254         Label L_done = new Label();
1255 
1256         Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
1257         MethodType type = args.function.resolvedHandle().type()
1258                               .dropParameterTypes(0,1)
1259                               .changeReturnType(returnType);
1260 
1261         mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_handler, &quot;java/lang/Throwable&quot;);
1262 
1263         // Normal case
1264         mv.visitLabel(L_startBlock);
1265         // load target
1266         emitPushArgument(invoker, 0);
1267         emitPushArguments(args, 1); // skip 1st argument: method handle
1268         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
1269         mv.visitLabel(L_endBlock);
1270         mv.visitJumpInsn(Opcodes.GOTO, L_done);
1271 
1272         // Exceptional case
1273         mv.visitLabel(L_handler);
1274 
1275         // Check exception&#39;s type
1276         mv.visitInsn(Opcodes.DUP);
1277         // load exception class
1278         emitPushArgument(invoker, 1);
1279         mv.visitInsn(Opcodes.SWAP);
1280         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/Class&quot;, &quot;isInstance&quot;, &quot;(Ljava/lang/Object;)Z&quot;, false);
1281         Label L_rethrow = new Label();
1282         mv.visitJumpInsn(Opcodes.IFEQ, L_rethrow);
1283 
1284         // Invoke catcher
1285         // load catcher
1286         emitPushArgument(invoker, 2);
1287         mv.visitInsn(Opcodes.SWAP);
1288         emitPushArguments(args, 1); // skip 1st argument: method handle
1289         MethodType catcherType = type.insertParameterTypes(0, Throwable.class);
1290         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, catcherType.basicType().toMethodDescriptorString(), false);
1291         mv.visitJumpInsn(Opcodes.GOTO, L_done);
1292 
1293         mv.visitLabel(L_rethrow);
1294         mv.visitInsn(Opcodes.ATHROW);
1295 
1296         mv.visitLabel(L_done);
1297 
1298         return result;
1299     }
1300 
1301     /**
1302      * Emit bytecode for the tryFinally idiom.
1303      * &lt;p&gt;
1304      * The pattern looks like (Cf. MethodHandleImpl.makeTryFinally):
1305      * &lt;blockquote&gt;&lt;pre&gt;{@code
1306      * // a0: BMH
1307      * // a1: target, a2: cleanup
1308      * // a3: box, a4: unbox
1309      * // a5 (and following): arguments
1310      * tryFinally=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L,a5:L)=&gt;{
1311      *   t6:L=MethodHandle.invokeBasic(a3:L,a5:L);         // box the arguments into an Object[]
1312      *   t7:L=MethodHandleImpl.tryFinally(a1:L,a2:L,t6:L); // call the tryFinally executor
1313      *   t8:L=MethodHandle.invokeBasic(a4:L,t7:L);t8:L}    // unbox the result; return the result
1314      * }&lt;/pre&gt;&lt;/blockquote&gt;
1315      * &lt;p&gt;
1316      * It is compiled into bytecode equivalent to the following code:
1317      * &lt;blockquote&gt;&lt;pre&gt;{@code
1318      * Throwable t;
1319      * Object r;
1320      * try {
1321      *     r = a1.invokeBasic(a5);
1322      * } catch (Throwable thrown) {
1323      *     t = thrown;
1324      *     throw t;
1325      * } finally {
1326      *     r = a2.invokeBasic(t, r, a5);
1327      * }
1328      * return r;
1329      * }&lt;/pre&gt;&lt;/blockquote&gt;
1330      * &lt;p&gt;
1331      * Specifically, the bytecode will have the following form (the stack effects are given for the beginnings of
1332      * blocks, and for the situations after executing the given instruction - the code will have a slightly different
1333      * shape if the return type is {@code void}):
1334      * &lt;blockquote&gt;&lt;pre&gt;{@code
1335      * TRY:                 (--)
1336      *                      load target                             (-- target)
1337      *                      load args                               (-- args... target)
1338      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (depends)
1339      * FINALLY_NORMAL:      (-- r_2nd* r)
1340      *                      store returned value                    (--)
1341      *                      load cleanup                            (-- cleanup)
1342      *                      ACONST_NULL                             (-- t cleanup)
1343      *                      load returned value                     (-- r_2nd* r t cleanup)
1344      *                      load args                               (-- args... r_2nd* r t cleanup)
1345      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r_2nd* r)
1346      *                      GOTO DONE
1347      * CATCH:               (-- t)
1348      *                      DUP                                     (-- t t)
1349      * FINALLY_EXCEPTIONAL: (-- t t)
1350      *                      load cleanup                            (-- cleanup t t)
1351      *                      SWAP                                    (-- t cleanup t)
1352      *                      load default for r                      (-- r_2nd* r t cleanup t)
1353      *                      load args                               (-- args... r_2nd* r t cleanup t)
1354      *                      INVOKEVIRTUAL MethodHandle.invokeBasic  (-- r_2nd* r t)
1355      *                      POP/POP2*                               (-- t)
1356      *                      ATHROW
1357      * DONE:                (-- r)
1358      * }&lt;/pre&gt;&lt;/blockquote&gt;
1359      * * = depends on whether the return type takes up 2 stack slots.
1360      */
1361     private Name emitTryFinally(int pos) {
1362         Name args    = lambdaForm.names[pos];
1363         Name invoker = lambdaForm.names[pos+1];
1364         Name result  = lambdaForm.names[pos+2];
1365 
1366         Label lFrom = new Label();
1367         Label lTo = new Label();
1368         Label lCatch = new Label();
1369         Label lDone = new Label();
1370 
1371         Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
1372         BasicType basicReturnType = BasicType.basicType(returnType);
1373         boolean isNonVoid = returnType != void.class;
1374 
1375         MethodType type = args.function.resolvedHandle().type()
1376                 .dropParameterTypes(0,1)
1377                 .changeReturnType(returnType);
1378         MethodType cleanupType = type.insertParameterTypes(0, Throwable.class);
1379         if (isNonVoid) {
1380             cleanupType = cleanupType.insertParameterTypes(1, returnType);
1381         }
1382         String cleanupDesc = cleanupType.basicType().toMethodDescriptorString();
1383 
1384         // exception handler table
1385         mv.visitTryCatchBlock(lFrom, lTo, lCatch, &quot;java/lang/Throwable&quot;);
1386 
1387         // TRY:
1388         mv.visitLabel(lFrom);
1389         emitPushArgument(invoker, 0); // load target
1390         emitPushArguments(args, 1); // load args (skip 0: method handle)
1391         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
1392         mv.visitLabel(lTo);
1393 
1394         // FINALLY_NORMAL:
1395         int index = extendLocalsMap(new Class&lt;?&gt;[]{ returnType });
1396         if (isNonVoid) {
1397             emitStoreInsn(basicReturnType, index);
1398         }
1399         emitPushArgument(invoker, 1); // load cleanup
1400         mv.visitInsn(Opcodes.ACONST_NULL);
1401         if (isNonVoid) {
1402             emitLoadInsn(basicReturnType, index);
1403         }
1404         emitPushArguments(args, 1); // load args (skip 0: method handle)
1405         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
1406         mv.visitJumpInsn(Opcodes.GOTO, lDone);
1407 
1408         // CATCH:
1409         mv.visitLabel(lCatch);
1410         mv.visitInsn(Opcodes.DUP);
1411 
1412         // FINALLY_EXCEPTIONAL:
1413         emitPushArgument(invoker, 1); // load cleanup
1414         mv.visitInsn(Opcodes.SWAP);
1415         if (isNonVoid) {
1416             emitZero(BasicType.basicType(returnType)); // load default for result
1417         }
1418         emitPushArguments(args, 1); // load args (skip 0: method handle)
1419         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, cleanupDesc, false);
1420         if (isNonVoid) {
1421             emitPopInsn(basicReturnType);
1422         }
1423         mv.visitInsn(Opcodes.ATHROW);
1424 
1425         // DONE:
1426         mv.visitLabel(lDone);
1427 
1428         return result;
1429     }
1430 
1431     private void emitPopInsn(BasicType type) {
1432         mv.visitInsn(popInsnOpcode(type));
1433     }
1434 
1435     private static int popInsnOpcode(BasicType type) {
1436         switch (type) {
1437             case I_TYPE:
1438             case F_TYPE:
1439             case L_TYPE:
1440                 return Opcodes.POP;
1441             case J_TYPE:
1442             case D_TYPE:
1443                 return Opcodes.POP2;
1444             default:
1445                 throw new InternalError(&quot;unknown type: &quot; + type);
1446         }
1447     }
1448 
1449     /**
1450      * Emit bytecode for the loop idiom.
1451      * &lt;p&gt;
1452      * The pattern looks like (Cf. MethodHandleImpl.loop):
1453      * &lt;blockquote&gt;&lt;pre&gt;{@code
1454      * // a0: BMH
1455      * // a1: LoopClauses (containing an array of arrays: inits, steps, preds, finis)
1456      * // a2: box, a3: unbox
1457      * // a4 (and following): arguments
1458      * loop=Lambda(a0:L,a1:L,a2:L,a3:L,a4:L)=&gt;{
1459      *   t5:L=MethodHandle.invokeBasic(a2:L,a4:L);          // box the arguments into an Object[]
1460      *   t6:L=MethodHandleImpl.loop(bt:L,a1:L,t5:L);        // call the loop executor (with supplied types in bt)
1461      *   t7:L=MethodHandle.invokeBasic(a3:L,t6:L);t7:L}     // unbox the result; return the result
1462      * }&lt;/pre&gt;&lt;/blockquote&gt;
1463      * &lt;p&gt;
1464      * It is compiled into bytecode equivalent to the code seen in {@link MethodHandleImpl#loop(BasicType[],
1465      * MethodHandleImpl.LoopClauses, Object...)}, with the difference that no arrays
1466      * will be used for local state storage. Instead, the local state will be mapped to actual stack slots.
1467      * &lt;p&gt;
1468      * Bytecode generation applies an unrolling scheme to enable better bytecode generation regarding local state type
1469      * handling. The generated bytecode will have the following form ({@code void} types are ignored for convenience).
1470      * Assume there are {@code C} clauses in the loop.
1471      * &lt;blockquote&gt;&lt;pre&gt;{@code
1472      * PREINIT: ALOAD_1
1473      *          CHECKCAST LoopClauses
1474      *          GETFIELD LoopClauses.clauses
1475      *          ASTORE clauseDataIndex          // place the clauses 2-dimensional array on the stack
1476      * INIT:    (INIT_SEQ for clause 1)
1477      *          ...
1478      *          (INIT_SEQ for clause C)
1479      * LOOP:    (LOOP_SEQ for clause 1)
1480      *          ...
1481      *          (LOOP_SEQ for clause C)
1482      *          GOTO LOOP
1483      * DONE:    ...
1484      * }&lt;/pre&gt;&lt;/blockquote&gt;
1485      * &lt;p&gt;
1486      * The {@code INIT_SEQ_x} sequence for clause {@code x} (with {@code x} ranging from {@code 0} to {@code C-1}) has
1487      * the following shape. Assume slot {@code vx} is used to hold the state for clause {@code x}.
1488      * &lt;blockquote&gt;&lt;pre&gt;{@code
1489      * INIT_SEQ_x:  ALOAD clauseDataIndex
1490      *              ICONST_0
1491      *              AALOAD      // load the inits array
1492      *              ICONST x
1493      *              AALOAD      // load the init handle for clause x
1494      *              load args
1495      *              INVOKEVIRTUAL MethodHandle.invokeBasic
1496      *              store vx
1497      * }&lt;/pre&gt;&lt;/blockquote&gt;
1498      * &lt;p&gt;
1499      * The {@code LOOP_SEQ_x} sequence for clause {@code x} (with {@code x} ranging from {@code 0} to {@code C-1}) has
1500      * the following shape. Again, assume slot {@code vx} is used to hold the state for clause {@code x}.
1501      * &lt;blockquote&gt;&lt;pre&gt;{@code
1502      * LOOP_SEQ_x:  ALOAD clauseDataIndex
1503      *              ICONST_1
1504      *              AALOAD              // load the steps array
1505      *              ICONST x
1506      *              AALOAD              // load the step handle for clause x
1507      *              load locals
1508      *              load args
1509      *              INVOKEVIRTUAL MethodHandle.invokeBasic
1510      *              store vx
1511      *              ALOAD clauseDataIndex
1512      *              ICONST_2
1513      *              AALOAD              // load the preds array
1514      *              ICONST x
1515      *              AALOAD              // load the pred handle for clause x
1516      *              load locals
1517      *              load args
1518      *              INVOKEVIRTUAL MethodHandle.invokeBasic
1519      *              IFNE LOOP_SEQ_x+1   // predicate returned false -&gt; jump to next clause
1520      *              ALOAD clauseDataIndex
1521      *              ICONST_3
1522      *              AALOAD              // load the finis array
1523      *              ICONST x
1524      *              AALOAD              // load the fini handle for clause x
1525      *              load locals
1526      *              load args
1527      *              INVOKEVIRTUAL MethodHandle.invokeBasic
1528      *              GOTO DONE           // jump beyond end of clauses to return from loop
1529      * }&lt;/pre&gt;&lt;/blockquote&gt;
1530      */
1531     private Name emitLoop(int pos) {
1532         Name args    = lambdaForm.names[pos];
1533         Name invoker = lambdaForm.names[pos+1];
1534         Name result  = lambdaForm.names[pos+2];
1535 
1536         // extract clause and loop-local state types
1537         // find the type info in the loop invocation
1538         BasicType[] loopClauseTypes = (BasicType[]) invoker.arguments[0];
1539         Class&lt;?&gt;[] loopLocalStateTypes = Stream.of(loopClauseTypes).
1540                 filter(bt -&gt; bt != BasicType.V_TYPE).map(BasicType::basicTypeClass).toArray(Class&lt;?&gt;[]::new);
1541         Class&lt;?&gt;[] localTypes = new Class&lt;?&gt;[loopLocalStateTypes.length + 1];
1542         localTypes[0] = MethodHandleImpl.LoopClauses.class;
1543         System.arraycopy(loopLocalStateTypes, 0, localTypes, 1, loopLocalStateTypes.length);
1544 
1545         final int clauseDataIndex = extendLocalsMap(localTypes);
1546         final int firstLoopStateIndex = clauseDataIndex + 1;
1547 
1548         Class&lt;?&gt; returnType = result.function.resolvedHandle().type().returnType();
1549         MethodType loopType = args.function.resolvedHandle().type()
1550                 .dropParameterTypes(0,1)
1551                 .changeReturnType(returnType);
1552         MethodType loopHandleType = loopType.insertParameterTypes(0, loopLocalStateTypes);
1553         MethodType predType = loopHandleType.changeReturnType(boolean.class);
1554         MethodType finiType = loopHandleType;
1555 
1556         final int nClauses = loopClauseTypes.length;
1557 
1558         // indices to invoker arguments to load method handle arrays
1559         final int inits = 1;
1560         final int steps = 2;
1561         final int preds = 3;
1562         final int finis = 4;
1563 
1564         Label lLoop = new Label();
1565         Label lDone = new Label();
1566         Label lNext;
1567 
1568         // PREINIT:
1569         emitPushArgument(MethodHandleImpl.LoopClauses.class, invoker.arguments[1]);
1570         mv.visitFieldInsn(Opcodes.GETFIELD, LOOP_CLAUSES, &quot;clauses&quot;, MHARY2);
1571         emitAstoreInsn(clauseDataIndex);
1572 
1573         // INIT:
1574         for (int c = 0, state = 0; c &lt; nClauses; ++c) {
1575             MethodType cInitType = loopType.changeReturnType(loopClauseTypes[c].basicTypeClass());
1576             emitLoopHandleInvoke(invoker, inits, c, args, false, cInitType, loopLocalStateTypes, clauseDataIndex,
1577                     firstLoopStateIndex);
1578             if (cInitType.returnType() != void.class) {
1579                 emitStoreInsn(BasicType.basicType(cInitType.returnType()), firstLoopStateIndex + state);
1580                 ++state;
1581             }
1582         }
1583 
1584         // LOOP:
1585         mv.visitLabel(lLoop);
1586 
1587         for (int c = 0, state = 0; c &lt; nClauses; ++c) {
1588             lNext = new Label();
1589 
1590             MethodType stepType = loopHandleType.changeReturnType(loopClauseTypes[c].basicTypeClass());
1591             boolean isVoid = stepType.returnType() == void.class;
1592 
1593             // invoke loop step
1594             emitLoopHandleInvoke(invoker, steps, c, args, true, stepType, loopLocalStateTypes, clauseDataIndex,
1595                     firstLoopStateIndex);
1596             if (!isVoid) {
1597                 emitStoreInsn(BasicType.basicType(stepType.returnType()), firstLoopStateIndex + state);
1598                 ++state;
1599             }
1600 
1601             // invoke loop predicate
1602             emitLoopHandleInvoke(invoker, preds, c, args, true, predType, loopLocalStateTypes, clauseDataIndex,
1603                     firstLoopStateIndex);
1604             mv.visitJumpInsn(Opcodes.IFNE, lNext);
1605 
1606             // invoke fini
1607             emitLoopHandleInvoke(invoker, finis, c, args, true, finiType, loopLocalStateTypes, clauseDataIndex,
1608                     firstLoopStateIndex);
1609             mv.visitJumpInsn(Opcodes.GOTO, lDone);
1610 
1611             // this is the beginning of the next loop clause
1612             mv.visitLabel(lNext);
1613         }
1614 
1615         mv.visitJumpInsn(Opcodes.GOTO, lLoop);
1616 
1617         // DONE:
1618         mv.visitLabel(lDone);
1619 
1620         return result;
1621     }
1622 
1623     private int extendLocalsMap(Class&lt;?&gt;[] types) {
1624         int firstSlot = localsMap.length - 1;
1625         localsMap = Arrays.copyOf(localsMap, localsMap.length + types.length);
1626         localClasses = Arrays.copyOf(localClasses, localClasses.length + types.length);
1627         System.arraycopy(types, 0, localClasses, firstSlot, types.length);
1628         int index = localsMap[firstSlot - 1] + 1;
1629         int lastSlots = 0;
1630         for (int i = 0; i &lt; types.length; ++i) {
1631             localsMap[firstSlot + i] = index;
1632             lastSlots = BasicType.basicType(localClasses[firstSlot + i]).basicTypeSlots();
1633             index += lastSlots;
1634         }
1635         localsMap[localsMap.length - 1] = index - lastSlots;
1636         return firstSlot;
1637     }
1638 
1639     private void emitLoopHandleInvoke(Name holder, int handles, int clause, Name args, boolean pushLocalState,
1640                                       MethodType type, Class&lt;?&gt;[] loopLocalStateTypes, int clauseDataSlot,
1641                                       int firstLoopStateSlot) {
1642         // load handle for clause
1643         emitPushClauseArray(clauseDataSlot, handles);
1644         emitIconstInsn(clause);
1645         mv.visitInsn(Opcodes.AALOAD);
1646         // load loop state (preceding the other arguments)
1647         if (pushLocalState) {
1648             for (int s = 0; s &lt; loopLocalStateTypes.length; ++s) {
1649                 emitLoadInsn(BasicType.basicType(loopLocalStateTypes[s]), firstLoopStateSlot + s);
1650             }
1651         }
1652         // load loop args (skip 0: method handle)
1653         emitPushArguments(args, 1);
1654         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.toMethodDescriptorString(), false);
1655     }
1656 
1657     private void emitPushClauseArray(int clauseDataSlot, int which) {
1658         emitAloadInsn(clauseDataSlot);
1659         emitIconstInsn(which - 1);
1660         mv.visitInsn(Opcodes.AALOAD);
1661     }
1662 
1663     private void emitZero(BasicType type) {
1664         switch (type) {
1665             case I_TYPE: mv.visitInsn(Opcodes.ICONST_0); break;
1666             case J_TYPE: mv.visitInsn(Opcodes.LCONST_0); break;
1667             case F_TYPE: mv.visitInsn(Opcodes.FCONST_0); break;
1668             case D_TYPE: mv.visitInsn(Opcodes.DCONST_0); break;
1669             case L_TYPE: mv.visitInsn(Opcodes.ACONST_NULL); break;
1670             default: throw new InternalError(&quot;unknown type: &quot; + type);
1671         }
1672     }
1673 
1674     private void emitPushArguments(Name args, int start) {
1675         MethodType type = args.function.methodType();
1676         for (int i = start; i &lt; args.arguments.length; i++) {
1677             emitPushArgument(type.parameterType(i), args.arguments[i]);
1678         }
1679     }
1680 
1681     private void emitPushArgument(Name name, int paramIndex) {
1682         Object arg = name.arguments[paramIndex];
1683         Class&lt;?&gt; ptype = name.function.methodType().parameterType(paramIndex);
1684         emitPushArgument(ptype, arg);
1685     }
1686 
1687     private void emitPushArgument(Class&lt;?&gt; ptype, Object arg) {
1688         BasicType bptype = basicType(ptype);
1689         if (arg instanceof Name) {
1690             Name n = (Name) arg;
1691             emitLoadInsn(n.type, n.index());
1692             emitImplicitConversion(n.type, ptype, n);
1693         } else if ((arg == null || arg instanceof String) &amp;&amp; bptype == L_TYPE) {
1694             emitConst(arg);
1695         } else {
1696             if (Wrapper.isWrapperType(arg.getClass()) &amp;&amp; bptype != L_TYPE) {
1697                 emitConst(arg);
1698             } else {
1699                 mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(arg), &quot;Ljava/lang/Object;&quot;);
1700                 emitImplicitConversion(L_TYPE, ptype, arg);
1701             }
1702         }
1703     }
1704 
1705     /**
1706      * Store the name to its local, if necessary.
1707      */
1708     private void emitStoreResult(Name name) {
1709         if (name != null &amp;&amp; name.type != V_TYPE) {
1710             // non-void: actually assign
1711             emitStoreInsn(name.type, name.index());
1712         }
1713     }
1714 
1715     /**
1716      * Emits a return statement from a LF invoker. If required, the result type is cast to the correct return type.
1717      */
1718     private void emitReturn(Name onStack) {
1719         // return statement
1720         Class&lt;?&gt; rclass = invokerType.returnType();
1721         BasicType rtype = lambdaForm.returnType();
1722         assert(rtype == basicType(rclass));  // must agree
1723         if (rtype == V_TYPE) {
1724             // void
1725             mv.visitInsn(Opcodes.RETURN);
1726             // it doesn&#39;t matter what rclass is; the JVM will discard any value
1727         } else {
1728             LambdaForm.Name rn = lambdaForm.names[lambdaForm.result];
1729 
1730             // put return value on the stack if it is not already there
1731             if (rn != onStack) {
1732                 emitLoadInsn(rtype, lambdaForm.result);
1733             }
1734 
1735             emitImplicitConversion(rtype, rclass, rn);
1736 
1737             // generate actual return statement
1738             emitReturnInsn(rtype);
1739         }
1740     }
1741 
1742     /**
1743      * Emit a type conversion bytecode casting from &quot;from&quot; to &quot;to&quot;.
1744      */
1745     private void emitPrimCast(Wrapper from, Wrapper to) {
1746         // Here&#39;s how.
1747         // -   indicates forbidden
1748         // &lt;-&gt; indicates implicit
1749         //      to ----&gt; boolean  byte     short    char     int      long     float    double
1750         // from boolean    &lt;-&gt;        -        -        -        -        -        -        -
1751         //      byte        -       &lt;-&gt;       i2s      i2c      &lt;-&gt;      i2l      i2f      i2d
1752         //      short       -       i2b       &lt;-&gt;      i2c      &lt;-&gt;      i2l      i2f      i2d
1753         //      char        -       i2b       i2s      &lt;-&gt;      &lt;-&gt;      i2l      i2f      i2d
1754         //      int         -       i2b       i2s      i2c      &lt;-&gt;      i2l      i2f      i2d
1755         //      long        -     l2i,i2b   l2i,i2s  l2i,i2c    l2i      &lt;-&gt;      l2f      l2d
1756         //      float       -     f2i,i2b   f2i,i2s  f2i,i2c    f2i      f2l      &lt;-&gt;      f2d
1757         //      double      -     d2i,i2b   d2i,i2s  d2i,i2c    d2i      d2l      d2f      &lt;-&gt;
1758         if (from == to) {
1759             // no cast required, should be dead code anyway
1760             return;
1761         }
1762         if (from.isSubwordOrInt()) {
1763             // cast from {byte,short,char,int} to anything
1764             emitI2X(to);
1765         } else {
1766             // cast from {long,float,double} to anything
1767             if (to.isSubwordOrInt()) {
1768                 // cast to {byte,short,char,int}
1769                 emitX2I(from);
1770                 if (to.bitWidth() &lt; 32) {
1771                     // targets other than int require another conversion
1772                     emitI2X(to);
1773                 }
1774             } else {
1775                 // cast to {long,float,double} - this is verbose
1776                 boolean error = false;
1777                 switch (from) {
1778                 case LONG:
1779                     switch (to) {
1780                     case FLOAT:   mv.visitInsn(Opcodes.L2F);  break;
1781                     case DOUBLE:  mv.visitInsn(Opcodes.L2D);  break;
1782                     default:      error = true;               break;
1783                     }
1784                     break;
1785                 case FLOAT:
1786                     switch (to) {
1787                     case LONG :   mv.visitInsn(Opcodes.F2L);  break;
1788                     case DOUBLE:  mv.visitInsn(Opcodes.F2D);  break;
1789                     default:      error = true;               break;
1790                     }
1791                     break;
1792                 case DOUBLE:
1793                     switch (to) {
1794                     case LONG :   mv.visitInsn(Opcodes.D2L);  break;
1795                     case FLOAT:   mv.visitInsn(Opcodes.D2F);  break;
1796                     default:      error = true;               break;
1797                     }
1798                     break;
1799                 default:
1800                     error = true;
1801                     break;
1802                 }
1803                 if (error) {
1804                     throw new IllegalStateException(&quot;unhandled prim cast: &quot; + from + &quot;2&quot; + to);
1805                 }
1806             }
1807         }
1808     }
1809 
1810     private void emitI2X(Wrapper type) {
1811         switch (type) {
1812         case BYTE:    mv.visitInsn(Opcodes.I2B);  break;
1813         case SHORT:   mv.visitInsn(Opcodes.I2S);  break;
1814         case CHAR:    mv.visitInsn(Opcodes.I2C);  break;
1815         case INT:     /* naught */                break;
1816         case LONG:    mv.visitInsn(Opcodes.I2L);  break;
1817         case FLOAT:   mv.visitInsn(Opcodes.I2F);  break;
1818         case DOUBLE:  mv.visitInsn(Opcodes.I2D);  break;
1819         case BOOLEAN:
1820             // For compatibility with ValueConversions and explicitCastArguments:
1821             mv.visitInsn(Opcodes.ICONST_1);
1822             mv.visitInsn(Opcodes.IAND);
1823             break;
1824         default:   throw new InternalError(&quot;unknown type: &quot; + type);
1825         }
1826     }
1827 
1828     private void emitX2I(Wrapper type) {
1829         switch (type) {
1830         case LONG:    mv.visitInsn(Opcodes.L2I);  break;
1831         case FLOAT:   mv.visitInsn(Opcodes.F2I);  break;
1832         case DOUBLE:  mv.visitInsn(Opcodes.D2I);  break;
1833         default:      throw new InternalError(&quot;unknown type: &quot; + type);
1834         }
1835     }
1836 
1837     /**
1838      * Generate bytecode for a LambdaForm.vmentry which calls interpretWithArguments.
1839      */
1840     static MemberName generateLambdaFormInterpreterEntryPoint(MethodType mt) {
1841         assert(isValidSignature(basicTypeSignature(mt)));
1842         String name = &quot;interpret_&quot;+basicTypeChar(mt.returnType());
1843         MethodType type = mt;  // includes leading argument
1844         type = type.changeParameterType(0, MethodHandle.class);
1845         InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;LFI&quot;, name, type);
1846         return g.loadMethod(g.generateLambdaFormInterpreterEntryPointBytes());
1847     }
1848 
1849     private byte[] generateLambdaFormInterpreterEntryPointBytes() {
1850         classFilePrologue();
1851         methodPrologue();
1852 
1853         // Suppress this method in backtraces displayed to the user.
1854         mv.visitAnnotation(HIDDEN_SIG, true);
1855 
1856         // Don&#39;t inline the interpreter entry.
1857         mv.visitAnnotation(DONTINLINE_SIG, true);
1858 
1859         // create parameter array
1860         emitIconstInsn(invokerType.parameterCount());
1861         mv.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/Object&quot;);
1862 
1863         // fill parameter array
1864         for (int i = 0; i &lt; invokerType.parameterCount(); i++) {
1865             Class&lt;?&gt; ptype = invokerType.parameterType(i);
1866             mv.visitInsn(Opcodes.DUP);
1867             emitIconstInsn(i);
1868             emitLoadInsn(basicType(ptype), i);
1869             // box if primitive type
1870             if (ptype.isPrimitive()) {
1871                 emitBoxing(Wrapper.forPrimitiveType(ptype));
1872             }
1873             mv.visitInsn(Opcodes.AASTORE);
1874         }
1875         // invoke
1876         emitAloadInsn(0);
1877         mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, &quot;Ljava/lang/invoke/LambdaForm;&quot;);
1878         mv.visitInsn(Opcodes.SWAP);  // swap form and array; avoid local variable
1879         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, LF, &quot;interpretWithArguments&quot;, &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);
1880 
1881         // maybe unbox
1882         Class&lt;?&gt; rtype = invokerType.returnType();
1883         if (rtype.isPrimitive() &amp;&amp; rtype != void.class) {
1884             emitUnboxing(Wrapper.forPrimitiveType(rtype));
1885         }
1886 
1887         // return statement
1888         emitReturnInsn(basicType(rtype));
1889 
1890         methodEpilogue();
1891         clinit();
1892         bogusMethod(invokerType);
1893 
1894         final byte[] classFile = cw.toByteArray();
1895         maybeDump(classFile);
1896         return classFile;
1897     }
1898 
1899     /**
1900      * Generate bytecode for a NamedFunction invoker.
1901      */
1902     static MemberName generateNamedFunctionInvoker(MethodTypeForm typeForm) {
1903         MethodType invokerType = NamedFunction.INVOKER_METHOD_TYPE;
1904         String invokerName = &quot;invoke_&quot; + shortenSignature(basicTypeSignature(typeForm.erasedType()));
1905         InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;NFI&quot;, invokerName, invokerType);
1906         return g.loadMethod(g.generateNamedFunctionInvokerImpl(typeForm));
1907     }
1908 
1909     private byte[] generateNamedFunctionInvokerImpl(MethodTypeForm typeForm) {
1910         MethodType dstType = typeForm.erasedType();
1911         classFilePrologue();
1912         methodPrologue();
1913 
1914         // Suppress this method in backtraces displayed to the user.
1915         mv.visitAnnotation(HIDDEN_SIG, true);
1916 
1917         // Force inlining of this invoker method.
1918         mv.visitAnnotation(FORCEINLINE_SIG, true);
1919 
1920         // Load receiver
1921         emitAloadInsn(0);
1922 
1923         // Load arguments from array
1924         for (int i = 0; i &lt; dstType.parameterCount(); i++) {
1925             emitAloadInsn(1);
1926             emitIconstInsn(i);
1927             mv.visitInsn(Opcodes.AALOAD);
1928 
1929             // Maybe unbox
1930             Class&lt;?&gt; dptype = dstType.parameterType(i);
1931             if (dptype.isPrimitive()) {
1932                 Wrapper dstWrapper = Wrapper.forBasicType(dptype);
1933                 Wrapper srcWrapper = dstWrapper.isSubwordOrInt() ? Wrapper.INT : dstWrapper;  // narrow subword from int
1934                 emitUnboxing(srcWrapper);
1935                 emitPrimCast(srcWrapper, dstWrapper);
1936             }
1937         }
1938 
1939         // Invoke
1940         String targetDesc = dstType.basicType().toMethodDescriptorString();
1941         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, targetDesc, false);
1942 
1943         // Box primitive types
1944         Class&lt;?&gt; rtype = dstType.returnType();
1945         if (rtype != void.class &amp;&amp; rtype.isPrimitive()) {
1946             Wrapper srcWrapper = Wrapper.forBasicType(rtype);
1947             Wrapper dstWrapper = srcWrapper.isSubwordOrInt() ? Wrapper.INT : srcWrapper;  // widen subword to int
1948             // boolean casts not allowed
1949             emitPrimCast(srcWrapper, dstWrapper);
1950             emitBoxing(dstWrapper);
1951         }
1952 
1953         // If the return type is void we return a null reference.
1954         if (rtype == void.class) {
1955             mv.visitInsn(Opcodes.ACONST_NULL);
1956         }
1957         emitReturnInsn(L_TYPE);  // NOTE: NamedFunction invokers always return a reference value.
1958 
1959         methodEpilogue();
1960         clinit();
1961         bogusMethod(dstType);
1962 
1963         final byte[] classFile = cw.toByteArray();
1964         maybeDump(classFile);
1965         return classFile;
1966     }
1967 
1968     /**
1969      * Emit a bogus method that just loads some string constants. This is to get the constants into the constant pool
1970      * for debugging purposes.
1971      */
1972     private void bogusMethod(Object os) {
1973         if (DUMP_CLASS_FILES) {
1974             mv = cw.visitMethod(Opcodes.ACC_STATIC, &quot;dummy&quot;, &quot;()V&quot;, null, null);
1975             mv.visitLdcInsn(os.toString());
1976             mv.visitInsn(Opcodes.POP);
1977             mv.visitInsn(Opcodes.RETURN);
1978             mv.visitMaxs(0, 0);
1979             mv.visitEnd();
1980         }
1981     }
1982 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
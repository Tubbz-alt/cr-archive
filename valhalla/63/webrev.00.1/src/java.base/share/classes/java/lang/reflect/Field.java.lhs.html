<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/reflect/Field.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.reflect;
  27 
  28 import jdk.internal.access.SharedSecrets;
  29 import jdk.internal.reflect.CallerSensitive;
  30 import jdk.internal.reflect.FieldAccessor;
  31 import jdk.internal.reflect.Reflection;
  32 import jdk.internal.vm.annotation.ForceInline;
  33 import sun.reflect.generics.repository.FieldRepository;
  34 import sun.reflect.generics.factory.CoreReflectionFactory;
  35 import sun.reflect.generics.factory.GenericsFactory;
  36 import sun.reflect.generics.scope.ClassScope;
  37 import java.lang.annotation.Annotation;
  38 import java.util.Map;
  39 import java.util.Objects;
  40 import sun.reflect.annotation.AnnotationParser;
  41 import sun.reflect.annotation.AnnotationSupport;
  42 import sun.reflect.annotation.TypeAnnotation;
  43 import sun.reflect.annotation.TypeAnnotationParser;
  44 
  45 /**
  46  * A {@code Field} provides information about, and dynamic access to, a
  47  * single field of a class or an interface.  The reflected field may
  48  * be a class (static) field or an instance field.
  49  *
  50  * &lt;p&gt;A {@code Field} permits widening conversions to occur during a get or
  51  * set access operation, but throws an {@code IllegalArgumentException} if a
  52  * narrowing conversion would occur.
  53  *
  54  * @see Member
  55  * @see java.lang.Class
  56  * @see java.lang.Class#getFields()
  57  * @see java.lang.Class#getField(String)
  58  * @see java.lang.Class#getDeclaredFields()
  59  * @see java.lang.Class#getDeclaredField(String)
  60  *
  61  * @author Kenneth Russell
  62  * @author Nakul Saraiya
  63  * @since 1.1
  64  */
  65 public final
  66 class Field extends AccessibleObject implements Member {
  67 
  68     private Class&lt;?&gt;            clazz;
  69     private int                 slot;
  70     // This is guaranteed to be interned by the VM in the 1.4
  71     // reflection implementation
  72     private String              name;
  73     private Class&lt;?&gt;            type;
  74     private int                 modifiers;
  75     // Generics and annotations support
  76     private transient String    signature;
  77     // generic info repository; lazily initialized
  78     private transient FieldRepository genericInfo;
  79     private byte[]              annotations;
  80     // Cached field accessor created without override
  81     private FieldAccessor fieldAccessor;
  82     // Cached field accessor created with override
  83     private FieldAccessor overrideFieldAccessor;
  84     // For sharing of FieldAccessors. This branching structure is
  85     // currently only two levels deep (i.e., one root Field and
  86     // potentially many Field objects pointing to it.)
  87     //
  88     // If this branching structure would ever contain cycles, deadlocks can
  89     // occur in annotation code.
  90     private Field               root;
  91 
  92     // Generics infrastructure
  93 
  94     private String getGenericSignature() {return signature;}
  95 
  96     // Accessor for factory
  97     private GenericsFactory getFactory() {
  98         Class&lt;?&gt; c = getDeclaringClass();
  99         // create scope and factory
 100         return CoreReflectionFactory.make(c, ClassScope.make(c));
 101     }
 102 
 103     // Accessor for generic info repository
 104     private FieldRepository getGenericInfo() {
 105         // lazily initialize repository if necessary
 106         if (genericInfo == null) {
 107             // create and cache generic info repository
 108             genericInfo = FieldRepository.make(getGenericSignature(),
 109                                                getFactory());
 110         }
 111         return genericInfo; //return cached repository
 112     }
 113 
 114 
 115     /**
 116      * Package-private constructor
 117      */
 118     Field(Class&lt;?&gt; declaringClass,
 119           String name,
 120           Class&lt;?&gt; type,
 121           int modifiers,
 122           int slot,
 123           String signature,
 124           byte[] annotations)
 125     {
 126         this.clazz = declaringClass;
 127         this.name = name;
 128         this.type = type;
 129         this.modifiers = modifiers;
 130         this.slot = slot;
 131         this.signature = signature;
 132         this.annotations = annotations;
 133     }
 134 
 135     /**
 136      * Package-private routine (exposed to java.lang.Class via
 137      * ReflectAccess) which returns a copy of this Field. The copy&#39;s
 138      * &quot;root&quot; field points to this Field.
 139      */
 140     Field copy() {
 141         // This routine enables sharing of FieldAccessor objects
 142         // among Field objects which refer to the same underlying
 143         // method in the VM. (All of this contortion is only necessary
 144         // because of the &quot;accessibility&quot; bit in AccessibleObject,
 145         // which implicitly requires that new java.lang.reflect
 146         // objects be fabricated for each reflective call on Class
 147         // objects.)
 148         if (this.root != null)
 149             throw new IllegalArgumentException(&quot;Can not copy a non-root Field&quot;);
 150 
 151         Field res = new Field(clazz, name, type, modifiers, slot, signature, annotations);
 152         res.root = this;
 153         // Might as well eagerly propagate this if already present
 154         res.fieldAccessor = fieldAccessor;
 155         res.overrideFieldAccessor = overrideFieldAccessor;
 156 
 157         return res;
 158     }
 159 
 160     /**
 161      * @throws InaccessibleObjectException {@inheritDoc}
 162      * @throws SecurityException {@inheritDoc}
 163      */
 164     @Override
 165     @CallerSensitive
 166     public void setAccessible(boolean flag) {
 167         AccessibleObject.checkPermission();
<a name="1" id="anc1"></a><span class="line-modified"> 168         if (flag) checkCanSetAccessible(Reflection.getCallerClass());</span>







 169         setAccessible0(flag);
 170     }
 171 
 172     @Override
 173     void checkCanSetAccessible(Class&lt;?&gt; caller) {
 174         checkCanSetAccessible(caller, clazz);
 175     }
 176 
 177     /**
 178      * Returns the {@code Class} object representing the class or interface
 179      * that declares the field represented by this {@code Field} object.
 180      */
 181     @Override
 182     public Class&lt;?&gt; getDeclaringClass() {
 183         return clazz;
 184     }
 185 
 186     /**
 187      * Returns the name of the field represented by this {@code Field} object.
 188      */
 189     public String getName() {
 190         return name;
 191     }
 192 
 193     /**
 194      * Returns the Java language modifiers for the field represented
 195      * by this {@code Field} object, as an integer. The {@code Modifier} class should
 196      * be used to decode the modifiers.
 197      *
 198      * @see Modifier
 199      */
 200     public int getModifiers() {
 201         return modifiers;
 202     }
 203 
 204     /**
 205      * Returns {@code true} if this field represents an element of
 206      * an enumerated type; returns {@code false} otherwise.
 207      *
 208      * @return {@code true} if and only if this field represents an element of
 209      * an enumerated type.
 210      * @since 1.5
 211      */
 212     public boolean isEnumConstant() {
 213         return (getModifiers() &amp; Modifier.ENUM) != 0;
 214     }
 215 
 216     /**
 217      * Returns {@code true} if this field is a synthetic
 218      * field; returns {@code false} otherwise.
 219      *
 220      * @return true if and only if this field is a synthetic
 221      * field as defined by the Java Language Specification.
 222      * @since 1.5
 223      */
 224     public boolean isSynthetic() {
 225         return Modifier.isSynthetic(getModifiers());
 226     }
 227 
 228     /**
 229      * Returns a {@code Class} object that identifies the
 230      * declared type for the field represented by this
 231      * {@code Field} object.
 232      *
 233      * @return a {@code Class} object identifying the declared
 234      * type of the field represented by this object
 235      */
 236     public Class&lt;?&gt; getType() {
 237         return type;
 238     }
 239 
 240     /**
 241      * Returns a {@code Type} object that represents the declared type for
 242      * the field represented by this {@code Field} object.
 243      *
 244      * &lt;p&gt;If the declared type of the field is a parameterized type,
 245      * the {@code Type} object returned must accurately reflect the
 246      * actual type arguments used in the source code.
 247      *
 248      * &lt;p&gt;If the type of the underlying field is a type variable or a
 249      * parameterized type, it is created. Otherwise, it is resolved.
 250      *
 251      * @return a {@code Type} object that represents the declared type for
 252      *     the field represented by this {@code Field} object
 253      * @throws GenericSignatureFormatError if the generic field
 254      *     signature does not conform to the format specified in
 255      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
 256      * @throws TypeNotPresentException if the generic type
 257      *     signature of the underlying field refers to a non-existent
 258      *     type declaration
 259      * @throws MalformedParameterizedTypeException if the generic
 260      *     signature of the underlying field refers to a parameterized type
 261      *     that cannot be instantiated for any reason
 262      * @since 1.5
 263      */
 264     public Type getGenericType() {
 265         if (getGenericSignature() != null)
 266             return getGenericInfo().getGenericType();
 267         else
 268             return getType();
 269     }
 270 
 271 
 272     /**
 273      * Compares this {@code Field} against the specified object.  Returns
 274      * true if the objects are the same.  Two {@code Field} objects are the same if
 275      * they were declared by the same class and have the same name
 276      * and type.
 277      */
 278     public boolean equals(Object obj) {
 279         if (obj != null &amp;&amp; obj instanceof Field) {
 280             Field other = (Field)obj;
 281             return (getDeclaringClass() == other.getDeclaringClass())
 282                 &amp;&amp; (getName() == other.getName())
 283                 &amp;&amp; (getType() == other.getType());
 284         }
 285         return false;
 286     }
 287 
 288     /**
 289      * Returns a hashcode for this {@code Field}.  This is computed as the
 290      * exclusive-or of the hashcodes for the underlying field&#39;s
 291      * declaring class name and its name.
 292      */
 293     public int hashCode() {
 294         return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
 295     }
 296 
 297     /**
 298      * Returns a string describing this {@code Field}.  The format is
 299      * the access modifiers for the field, if any, followed
 300      * by the field type, followed by a space, followed by
 301      * the fully-qualified name of the class declaring the field,
 302      * followed by a period, followed by the name of the field.
 303      * For example:
 304      * &lt;pre&gt;
 305      *    public static final int java.lang.Thread.MIN_PRIORITY
 306      *    private int java.io.FileDescriptor.fd
 307      * &lt;/pre&gt;
 308      *
 309      * &lt;p&gt;The modifiers are placed in canonical order as specified by
 310      * &quot;The Java Language Specification&quot;.  This is {@code public},
 311      * {@code protected} or {@code private} first, and then other
 312      * modifiers in the following order: {@code static}, {@code final},
 313      * {@code transient}, {@code volatile}.
 314      *
 315      * @return a string describing this {@code Field}
 316      * @jls 8.3.1 Field Modifiers
 317      */
 318     public String toString() {
 319         int mod = getModifiers();
 320         return (((mod == 0) ? &quot;&quot; : (Modifier.toString(mod) + &quot; &quot;))
 321             + getType().getTypeName() + &quot; &quot;
 322             + getDeclaringClass().getTypeName() + &quot;.&quot;
 323             + getName());
 324     }
 325 
 326     @Override
 327     String toShortString() {
 328         return &quot;field &quot; + getDeclaringClass().getTypeName() + &quot;.&quot; + getName();
 329     }
 330 
 331     /**
 332      * Returns a string describing this {@code Field}, including
 333      * its generic type.  The format is the access modifiers for the
 334      * field, if any, followed by the generic field type, followed by
 335      * a space, followed by the fully-qualified name of the class
 336      * declaring the field, followed by a period, followed by the name
 337      * of the field.
 338      *
 339      * &lt;p&gt;The modifiers are placed in canonical order as specified by
 340      * &quot;The Java Language Specification&quot;.  This is {@code public},
 341      * {@code protected} or {@code private} first, and then other
 342      * modifiers in the following order: {@code static}, {@code final},
 343      * {@code transient}, {@code volatile}.
 344      *
 345      * @return a string describing this {@code Field}, including
 346      * its generic type
 347      *
 348      * @since 1.5
 349      * @jls 8.3.1 Field Modifiers
 350      */
 351     public String toGenericString() {
 352         int mod = getModifiers();
 353         Type fieldType = getGenericType();
 354         return (((mod == 0) ? &quot;&quot; : (Modifier.toString(mod) + &quot; &quot;))
 355             + fieldType.getTypeName() + &quot; &quot;
 356             + getDeclaringClass().getTypeName() + &quot;.&quot;
 357             + getName());
 358     }
 359 
 360     /**
 361      * Returns the value of the field represented by this {@code Field}, on
 362      * the specified object. The value is automatically wrapped in an
 363      * object if it has a primitive type.
 364      *
 365      * &lt;p&gt;The underlying field&#39;s value is obtained as follows:
 366      *
 367      * &lt;p&gt;If the underlying field is a static field, the {@code obj} argument
 368      * is ignored; it may be null.
 369      *
 370      * &lt;p&gt;Otherwise, the underlying field is an instance field.  If the
 371      * specified {@code obj} argument is null, the method throws a
 372      * {@code NullPointerException}. If the specified object is not an
 373      * instance of the class or interface declaring the underlying
 374      * field, the method throws an {@code IllegalArgumentException}.
 375      *
 376      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 377      * the underlying field is inaccessible, the method throws an
 378      * {@code IllegalAccessException}.
 379      * If the underlying field is static, the class that declared the
 380      * field is initialized if it has not already been initialized.
 381      *
 382      * &lt;p&gt;Otherwise, the value is retrieved from the underlying instance
 383      * or static field.  If the field has a primitive type, the value
 384      * is wrapped in an object before being returned, otherwise it is
 385      * returned as is.
 386      *
 387      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 388      * the field&#39;s value is obtained according to the preceding rules.
 389      *
 390      * @param obj object from which the represented field&#39;s value is
 391      * to be extracted
 392      * @return the value of the represented field in object
 393      * {@code obj}; primitive values are wrapped in an appropriate
 394      * object before being returned
 395      *
 396      * @throws    IllegalAccessException    if this {@code Field} object
 397      *              is enforcing Java language access control and the underlying
 398      *              field is inaccessible.
 399      * @throws    IllegalArgumentException  if the specified object is not an
 400      *              instance of the class or interface declaring the underlying
 401      *              field (or a subclass or implementor thereof).
 402      * @throws    NullPointerException      if the specified object is null
 403      *              and the field is an instance field.
 404      * @throws    ExceptionInInitializerError if the initialization provoked
 405      *              by this method fails.
 406      */
 407     @CallerSensitive
 408     @ForceInline // to ensure Reflection.getCallerClass optimization
 409     public Object get(Object obj)
 410         throws IllegalArgumentException, IllegalAccessException
 411     {
 412         if (!override) {
 413             Class&lt;?&gt; caller = Reflection.getCallerClass();
 414             checkAccess(caller, obj);
 415         }
 416         return getFieldAccessor(obj).get(obj);
 417     }
 418 
 419     /**
 420      * Gets the value of a static or instance {@code boolean} field.
 421      *
 422      * @param obj the object to extract the {@code boolean} value
 423      * from
 424      * @return the value of the {@code boolean} field
 425      *
 426      * @throws    IllegalAccessException    if this {@code Field} object
 427      *              is enforcing Java language access control and the underlying
 428      *              field is inaccessible.
 429      * @throws    IllegalArgumentException  if the specified object is not
 430      *              an instance of the class or interface declaring the
 431      *              underlying field (or a subclass or implementor
 432      *              thereof), or if the field value cannot be
 433      *              converted to the type {@code boolean} by a
 434      *              widening conversion.
 435      * @throws    NullPointerException      if the specified object is null
 436      *              and the field is an instance field.
 437      * @throws    ExceptionInInitializerError if the initialization provoked
 438      *              by this method fails.
 439      * @see       Field#get
 440      */
 441     @CallerSensitive
 442     @ForceInline // to ensure Reflection.getCallerClass optimization
 443     public boolean getBoolean(Object obj)
 444         throws IllegalArgumentException, IllegalAccessException
 445     {
 446         if (!override) {
 447             Class&lt;?&gt; caller = Reflection.getCallerClass();
 448             checkAccess(caller, obj);
 449         }
 450         return getFieldAccessor(obj).getBoolean(obj);
 451     }
 452 
 453     /**
 454      * Gets the value of a static or instance {@code byte} field.
 455      *
 456      * @param obj the object to extract the {@code byte} value
 457      * from
 458      * @return the value of the {@code byte} field
 459      *
 460      * @throws    IllegalAccessException    if this {@code Field} object
 461      *              is enforcing Java language access control and the underlying
 462      *              field is inaccessible.
 463      * @throws    IllegalArgumentException  if the specified object is not
 464      *              an instance of the class or interface declaring the
 465      *              underlying field (or a subclass or implementor
 466      *              thereof), or if the field value cannot be
 467      *              converted to the type {@code byte} by a
 468      *              widening conversion.
 469      * @throws    NullPointerException      if the specified object is null
 470      *              and the field is an instance field.
 471      * @throws    ExceptionInInitializerError if the initialization provoked
 472      *              by this method fails.
 473      * @see       Field#get
 474      */
 475     @CallerSensitive
 476     @ForceInline // to ensure Reflection.getCallerClass optimization
 477     public byte getByte(Object obj)
 478         throws IllegalArgumentException, IllegalAccessException
 479     {
 480         if (!override) {
 481             Class&lt;?&gt; caller = Reflection.getCallerClass();
 482             checkAccess(caller, obj);
 483         }
 484         return getFieldAccessor(obj).getByte(obj);
 485     }
 486 
 487     /**
 488      * Gets the value of a static or instance field of type
 489      * {@code char} or of another primitive type convertible to
 490      * type {@code char} via a widening conversion.
 491      *
 492      * @param obj the object to extract the {@code char} value
 493      * from
 494      * @return the value of the field converted to type {@code char}
 495      *
 496      * @throws    IllegalAccessException    if this {@code Field} object
 497      *              is enforcing Java language access control and the underlying
 498      *              field is inaccessible.
 499      * @throws    IllegalArgumentException  if the specified object is not
 500      *              an instance of the class or interface declaring the
 501      *              underlying field (or a subclass or implementor
 502      *              thereof), or if the field value cannot be
 503      *              converted to the type {@code char} by a
 504      *              widening conversion.
 505      * @throws    NullPointerException      if the specified object is null
 506      *              and the field is an instance field.
 507      * @throws    ExceptionInInitializerError if the initialization provoked
 508      *              by this method fails.
 509      * @see Field#get
 510      */
 511     @CallerSensitive
 512     @ForceInline // to ensure Reflection.getCallerClass optimization
 513     public char getChar(Object obj)
 514         throws IllegalArgumentException, IllegalAccessException
 515     {
 516         if (!override) {
 517             Class&lt;?&gt; caller = Reflection.getCallerClass();
 518             checkAccess(caller, obj);
 519         }
 520         return getFieldAccessor(obj).getChar(obj);
 521     }
 522 
 523     /**
 524      * Gets the value of a static or instance field of type
 525      * {@code short} or of another primitive type convertible to
 526      * type {@code short} via a widening conversion.
 527      *
 528      * @param obj the object to extract the {@code short} value
 529      * from
 530      * @return the value of the field converted to type {@code short}
 531      *
 532      * @throws    IllegalAccessException    if this {@code Field} object
 533      *              is enforcing Java language access control and the underlying
 534      *              field is inaccessible.
 535      * @throws    IllegalArgumentException  if the specified object is not
 536      *              an instance of the class or interface declaring the
 537      *              underlying field (or a subclass or implementor
 538      *              thereof), or if the field value cannot be
 539      *              converted to the type {@code short} by a
 540      *              widening conversion.
 541      * @throws    NullPointerException      if the specified object is null
 542      *              and the field is an instance field.
 543      * @throws    ExceptionInInitializerError if the initialization provoked
 544      *              by this method fails.
 545      * @see       Field#get
 546      */
 547     @CallerSensitive
 548     @ForceInline // to ensure Reflection.getCallerClass optimization
 549     public short getShort(Object obj)
 550         throws IllegalArgumentException, IllegalAccessException
 551     {
 552         if (!override) {
 553             Class&lt;?&gt; caller = Reflection.getCallerClass();
 554             checkAccess(caller, obj);
 555         }
 556         return getFieldAccessor(obj).getShort(obj);
 557     }
 558 
 559     /**
 560      * Gets the value of a static or instance field of type
 561      * {@code int} or of another primitive type convertible to
 562      * type {@code int} via a widening conversion.
 563      *
 564      * @param obj the object to extract the {@code int} value
 565      * from
 566      * @return the value of the field converted to type {@code int}
 567      *
 568      * @throws    IllegalAccessException    if this {@code Field} object
 569      *              is enforcing Java language access control and the underlying
 570      *              field is inaccessible.
 571      * @throws    IllegalArgumentException  if the specified object is not
 572      *              an instance of the class or interface declaring the
 573      *              underlying field (or a subclass or implementor
 574      *              thereof), or if the field value cannot be
 575      *              converted to the type {@code int} by a
 576      *              widening conversion.
 577      * @throws    NullPointerException      if the specified object is null
 578      *              and the field is an instance field.
 579      * @throws    ExceptionInInitializerError if the initialization provoked
 580      *              by this method fails.
 581      * @see       Field#get
 582      */
 583     @CallerSensitive
 584     @ForceInline // to ensure Reflection.getCallerClass optimization
 585     public int getInt(Object obj)
 586         throws IllegalArgumentException, IllegalAccessException
 587     {
 588         if (!override) {
 589             Class&lt;?&gt; caller = Reflection.getCallerClass();
 590             checkAccess(caller, obj);
 591         }
 592         return getFieldAccessor(obj).getInt(obj);
 593     }
 594 
 595     /**
 596      * Gets the value of a static or instance field of type
 597      * {@code long} or of another primitive type convertible to
 598      * type {@code long} via a widening conversion.
 599      *
 600      * @param obj the object to extract the {@code long} value
 601      * from
 602      * @return the value of the field converted to type {@code long}
 603      *
 604      * @throws    IllegalAccessException    if this {@code Field} object
 605      *              is enforcing Java language access control and the underlying
 606      *              field is inaccessible.
 607      * @throws    IllegalArgumentException  if the specified object is not
 608      *              an instance of the class or interface declaring the
 609      *              underlying field (or a subclass or implementor
 610      *              thereof), or if the field value cannot be
 611      *              converted to the type {@code long} by a
 612      *              widening conversion.
 613      * @throws    NullPointerException      if the specified object is null
 614      *              and the field is an instance field.
 615      * @throws    ExceptionInInitializerError if the initialization provoked
 616      *              by this method fails.
 617      * @see       Field#get
 618      */
 619     @CallerSensitive
 620     @ForceInline // to ensure Reflection.getCallerClass optimization
 621     public long getLong(Object obj)
 622         throws IllegalArgumentException, IllegalAccessException
 623     {
 624         if (!override) {
 625             Class&lt;?&gt; caller = Reflection.getCallerClass();
 626             checkAccess(caller, obj);
 627         }
 628         return getFieldAccessor(obj).getLong(obj);
 629     }
 630 
 631     /**
 632      * Gets the value of a static or instance field of type
 633      * {@code float} or of another primitive type convertible to
 634      * type {@code float} via a widening conversion.
 635      *
 636      * @param obj the object to extract the {@code float} value
 637      * from
 638      * @return the value of the field converted to type {@code float}
 639      *
 640      * @throws    IllegalAccessException    if this {@code Field} object
 641      *              is enforcing Java language access control and the underlying
 642      *              field is inaccessible.
 643      * @throws    IllegalArgumentException  if the specified object is not
 644      *              an instance of the class or interface declaring the
 645      *              underlying field (or a subclass or implementor
 646      *              thereof), or if the field value cannot be
 647      *              converted to the type {@code float} by a
 648      *              widening conversion.
 649      * @throws    NullPointerException      if the specified object is null
 650      *              and the field is an instance field.
 651      * @throws    ExceptionInInitializerError if the initialization provoked
 652      *              by this method fails.
 653      * @see Field#get
 654      */
 655     @CallerSensitive
 656     @ForceInline // to ensure Reflection.getCallerClass optimization
 657     public float getFloat(Object obj)
 658         throws IllegalArgumentException, IllegalAccessException
 659     {
 660         if (!override) {
 661             Class&lt;?&gt; caller = Reflection.getCallerClass();
 662             checkAccess(caller, obj);
 663         }
 664         return getFieldAccessor(obj).getFloat(obj);
 665     }
 666 
 667     /**
 668      * Gets the value of a static or instance field of type
 669      * {@code double} or of another primitive type convertible to
 670      * type {@code double} via a widening conversion.
 671      *
 672      * @param obj the object to extract the {@code double} value
 673      * from
 674      * @return the value of the field converted to type {@code double}
 675      *
 676      * @throws    IllegalAccessException    if this {@code Field} object
 677      *              is enforcing Java language access control and the underlying
 678      *              field is inaccessible.
 679      * @throws    IllegalArgumentException  if the specified object is not
 680      *              an instance of the class or interface declaring the
 681      *              underlying field (or a subclass or implementor
 682      *              thereof), or if the field value cannot be
 683      *              converted to the type {@code double} by a
 684      *              widening conversion.
 685      * @throws    NullPointerException      if the specified object is null
 686      *              and the field is an instance field.
 687      * @throws    ExceptionInInitializerError if the initialization provoked
 688      *              by this method fails.
 689      * @see       Field#get
 690      */
 691     @CallerSensitive
 692     @ForceInline // to ensure Reflection.getCallerClass optimization
 693     public double getDouble(Object obj)
 694         throws IllegalArgumentException, IllegalAccessException
 695     {
 696         if (!override) {
 697             Class&lt;?&gt; caller = Reflection.getCallerClass();
 698             checkAccess(caller, obj);
 699         }
 700         return getFieldAccessor(obj).getDouble(obj);
 701     }
 702 
 703     /**
 704      * Sets the field represented by this {@code Field} object on the
 705      * specified object argument to the specified new value. The new
 706      * value is automatically unwrapped if the underlying field has a
 707      * primitive type.
 708      *
 709      * &lt;p&gt;The operation proceeds as follows:
 710      *
 711      * &lt;p&gt;If the underlying field is static, the {@code obj} argument is
 712      * ignored; it may be null.
 713      *
 714      * &lt;p&gt;Otherwise the underlying field is an instance field.  If the
 715      * specified object argument is null, the method throws a
 716      * {@code NullPointerException}.  If the specified object argument is not
 717      * an instance of the class or interface declaring the underlying
 718      * field, the method throws an {@code IllegalArgumentException}.
 719      *
 720      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 721      * the underlying field is inaccessible, the method throws an
 722      * {@code IllegalAccessException}.
 723      *
 724      * &lt;p&gt;If the underlying field is final, this {@code Field} object has
 725      * &lt;em&gt;write&lt;/em&gt; access if and only if the following conditions are met:
 726      * &lt;ul&gt;
 727      * &lt;li&gt;{@link #setAccessible(boolean) setAccessible(true)} has succeeded for
 728      *     this {@code Field} object;&lt;/li&gt;
 729      * &lt;li&gt;the field is non-static; and&lt;/li&gt;
 730      * &lt;li&gt;the field&#39;s declaring class is not a {@linkplain Class#isHidden()
 731      *     hidden class}.&lt;/li&gt;
 732      * &lt;/ul&gt;
 733      * If any of the above checks is not met, this method throws an
 734      * {@code IllegalAccessException}.
 735      *
 736      * &lt;p&gt; Setting a final field in this way
 737      * is meaningful only during deserialization or reconstruction of
 738      * instances of classes with blank final fields, before they are
 739      * made available for access by other parts of a program. Use in
 740      * any other context may have unpredictable effects, including cases
 741      * in which other parts of a program continue to use the original
 742      * value of this field.
 743      *
 744      * &lt;p&gt;If the underlying field is of a primitive type, an unwrapping
 745      * conversion is attempted to convert the new value to a value of
 746      * a primitive type.  If this attempt fails, the method throws an
 747      * {@code IllegalArgumentException}.
 748      *
 749      * &lt;p&gt;If, after possible unwrapping, the new value cannot be
 750      * converted to the type of the underlying field by an identity or
 751      * widening conversion, the method throws an
 752      * {@code IllegalArgumentException}.
 753      *
 754      * &lt;p&gt;If the underlying field is static, the class that declared the
 755      * field is initialized if it has not already been initialized.
 756      *
 757      * &lt;p&gt;The field is set to the possibly unwrapped and widened new value.
 758      *
 759      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 760      * the field&#39;s value is set according to the preceding rules.
 761      *
 762      * @param obj the object whose field should be modified
 763      * @param value the new value for the field of {@code obj}
 764      * being modified
 765      *
 766      * @throws    IllegalAccessException    if this {@code Field} object
 767      *              is enforcing Java language access control and the underlying
 768      *              field is inaccessible or final;
 769      *              or if this {@code Field} object has no write access.
 770      * @throws    IllegalArgumentException  if the specified object is not an
 771      *              instance of the class or interface declaring the underlying
 772      *              field (or a subclass or implementor thereof),
 773      *              or if an unwrapping conversion fails.
 774      * @throws    NullPointerException      if the specified object is null
 775      *              and the field is an instance field.
 776      * @throws    ExceptionInInitializerError if the initialization provoked
 777      *              by this method fails.
 778      */
 779     @CallerSensitive
 780     @ForceInline // to ensure Reflection.getCallerClass optimization
 781     public void set(Object obj, Object value)
 782         throws IllegalArgumentException, IllegalAccessException
 783     {
 784         if (!override) {
 785             Class&lt;?&gt; caller = Reflection.getCallerClass();
 786             checkAccess(caller, obj);
 787         }
 788         getFieldAccessor(obj).set(obj, value);
 789     }
 790 
 791     /**
 792      * Sets the value of a field as a {@code boolean} on the specified object.
 793      * This method is equivalent to
 794      * {@code set(obj, zObj)},
 795      * where {@code zObj} is a {@code Boolean} object and
 796      * {@code zObj.booleanValue() == z}.
 797      *
 798      * @param obj the object whose field should be modified
 799      * @param z   the new value for the field of {@code obj}
 800      * being modified
 801      *
 802      * @throws    IllegalAccessException    if this {@code Field} object
 803      *              is enforcing Java language access control and the underlying
 804      *              field is either inaccessible or final;
 805      *              or if this {@code Field} object has no write access.
 806      * @throws    IllegalArgumentException  if the specified object is not an
 807      *              instance of the class or interface declaring the underlying
 808      *              field (or a subclass or implementor thereof),
 809      *              or if an unwrapping conversion fails.
 810      * @throws    NullPointerException      if the specified object is null
 811      *              and the field is an instance field.
 812      * @throws    ExceptionInInitializerError if the initialization provoked
 813      *              by this method fails.
 814      * @see       Field#set
 815      */
 816     @CallerSensitive
 817     @ForceInline // to ensure Reflection.getCallerClass optimization
 818     public void setBoolean(Object obj, boolean z)
 819         throws IllegalArgumentException, IllegalAccessException
 820     {
 821         if (!override) {
 822             Class&lt;?&gt; caller = Reflection.getCallerClass();
 823             checkAccess(caller, obj);
 824         }
 825         getFieldAccessor(obj).setBoolean(obj, z);
 826     }
 827 
 828     /**
 829      * Sets the value of a field as a {@code byte} on the specified object.
 830      * This method is equivalent to
 831      * {@code set(obj, bObj)},
 832      * where {@code bObj} is a {@code Byte} object and
 833      * {@code bObj.byteValue() == b}.
 834      *
 835      * @param obj the object whose field should be modified
 836      * @param b   the new value for the field of {@code obj}
 837      * being modified
 838      *
 839      * @throws    IllegalAccessException    if this {@code Field} object
 840      *              is enforcing Java language access control and the underlying
 841      *              field is either inaccessible or final;
 842      *              or if this {@code Field} object has no write access.
 843      * @throws    IllegalArgumentException  if the specified object is not an
 844      *              instance of the class or interface declaring the underlying
 845      *              field (or a subclass or implementor thereof),
 846      *              or if an unwrapping conversion fails.
 847      * @throws    NullPointerException      if the specified object is null
 848      *              and the field is an instance field.
 849      * @throws    ExceptionInInitializerError if the initialization provoked
 850      *              by this method fails.
 851      * @see       Field#set
 852      */
 853     @CallerSensitive
 854     @ForceInline // to ensure Reflection.getCallerClass optimization
 855     public void setByte(Object obj, byte b)
 856         throws IllegalArgumentException, IllegalAccessException
 857     {
 858         if (!override) {
 859             Class&lt;?&gt; caller = Reflection.getCallerClass();
 860             checkAccess(caller, obj);
 861         }
 862         getFieldAccessor(obj).setByte(obj, b);
 863     }
 864 
 865     /**
 866      * Sets the value of a field as a {@code char} on the specified object.
 867      * This method is equivalent to
 868      * {@code set(obj, cObj)},
 869      * where {@code cObj} is a {@code Character} object and
 870      * {@code cObj.charValue() == c}.
 871      *
 872      * @param obj the object whose field should be modified
 873      * @param c   the new value for the field of {@code obj}
 874      * being modified
 875      *
 876      * @throws    IllegalAccessException    if this {@code Field} object
 877      *              is enforcing Java language access control and the underlying
 878      *              field is either inaccessible or final;
 879      *              or if this {@code Field} object has no write access.
 880      * @throws    IllegalArgumentException  if the specified object is not an
 881      *              instance of the class or interface declaring the underlying
 882      *              field (or a subclass or implementor thereof),
 883      *              or if an unwrapping conversion fails.
 884      * @throws    NullPointerException      if the specified object is null
 885      *              and the field is an instance field.
 886      * @throws    ExceptionInInitializerError if the initialization provoked
 887      *              by this method fails.
 888      * @see       Field#set
 889      */
 890     @CallerSensitive
 891     @ForceInline // to ensure Reflection.getCallerClass optimization
 892     public void setChar(Object obj, char c)
 893         throws IllegalArgumentException, IllegalAccessException
 894     {
 895         if (!override) {
 896             Class&lt;?&gt; caller = Reflection.getCallerClass();
 897             checkAccess(caller, obj);
 898         }
 899         getFieldAccessor(obj).setChar(obj, c);
 900     }
 901 
 902     /**
 903      * Sets the value of a field as a {@code short} on the specified object.
 904      * This method is equivalent to
 905      * {@code set(obj, sObj)},
 906      * where {@code sObj} is a {@code Short} object and
 907      * {@code sObj.shortValue() == s}.
 908      *
 909      * @param obj the object whose field should be modified
 910      * @param s   the new value for the field of {@code obj}
 911      * being modified
 912      *
 913      * @throws    IllegalAccessException    if this {@code Field} object
 914      *              is enforcing Java language access control and the underlying
 915      *              field is either inaccessible or final;
 916      *              or if this {@code Field} object has no write access.
 917      * @throws    IllegalArgumentException  if the specified object is not an
 918      *              instance of the class or interface declaring the underlying
 919      *              field (or a subclass or implementor thereof),
 920      *              or if an unwrapping conversion fails.
 921      * @throws    NullPointerException      if the specified object is null
 922      *              and the field is an instance field.
 923      * @throws    ExceptionInInitializerError if the initialization provoked
 924      *              by this method fails.
 925      * @see       Field#set
 926      */
 927     @CallerSensitive
 928     @ForceInline // to ensure Reflection.getCallerClass optimization
 929     public void setShort(Object obj, short s)
 930         throws IllegalArgumentException, IllegalAccessException
 931     {
 932         if (!override) {
 933             Class&lt;?&gt; caller = Reflection.getCallerClass();
 934             checkAccess(caller, obj);
 935         }
 936         getFieldAccessor(obj).setShort(obj, s);
 937     }
 938 
 939     /**
 940      * Sets the value of a field as an {@code int} on the specified object.
 941      * This method is equivalent to
 942      * {@code set(obj, iObj)},
 943      * where {@code iObj} is an {@code Integer} object and
 944      * {@code iObj.intValue() == i}.
 945      *
 946      * @param obj the object whose field should be modified
 947      * @param i   the new value for the field of {@code obj}
 948      * being modified
 949      *
 950      * @throws    IllegalAccessException    if this {@code Field} object
 951      *              is enforcing Java language access control and the underlying
 952      *              field is either inaccessible or final;
 953      *              or if this {@code Field} object has no write access.
 954      * @throws    IllegalArgumentException  if the specified object is not an
 955      *              instance of the class or interface declaring the underlying
 956      *              field (or a subclass or implementor thereof),
 957      *              or if an unwrapping conversion fails.
 958      * @throws    NullPointerException      if the specified object is null
 959      *              and the field is an instance field.
 960      * @throws    ExceptionInInitializerError if the initialization provoked
 961      *              by this method fails.
 962      * @see       Field#set
 963      */
 964     @CallerSensitive
 965     @ForceInline // to ensure Reflection.getCallerClass optimization
 966     public void setInt(Object obj, int i)
 967         throws IllegalArgumentException, IllegalAccessException
 968     {
 969         if (!override) {
 970             Class&lt;?&gt; caller = Reflection.getCallerClass();
 971             checkAccess(caller, obj);
 972         }
 973         getFieldAccessor(obj).setInt(obj, i);
 974     }
 975 
 976     /**
 977      * Sets the value of a field as a {@code long} on the specified object.
 978      * This method is equivalent to
 979      * {@code set(obj, lObj)},
 980      * where {@code lObj} is a {@code Long} object and
 981      * {@code lObj.longValue() == l}.
 982      *
 983      * @param obj the object whose field should be modified
 984      * @param l   the new value for the field of {@code obj}
 985      * being modified
 986      *
 987      * @throws    IllegalAccessException    if this {@code Field} object
 988      *              is enforcing Java language access control and the underlying
 989      *              field is either inaccessible or final;
 990      *              or if this {@code Field} object has no write access.
 991      * @throws    IllegalArgumentException  if the specified object is not an
 992      *              instance of the class or interface declaring the underlying
 993      *              field (or a subclass or implementor thereof),
 994      *              or if an unwrapping conversion fails.
 995      * @throws    NullPointerException      if the specified object is null
 996      *              and the field is an instance field.
 997      * @throws    ExceptionInInitializerError if the initialization provoked
 998      *              by this method fails.
 999      * @see       Field#set
1000      */
1001     @CallerSensitive
1002     @ForceInline // to ensure Reflection.getCallerClass optimization
1003     public void setLong(Object obj, long l)
1004         throws IllegalArgumentException, IllegalAccessException
1005     {
1006         if (!override) {
1007             Class&lt;?&gt; caller = Reflection.getCallerClass();
1008             checkAccess(caller, obj);
1009         }
1010         getFieldAccessor(obj).setLong(obj, l);
1011     }
1012 
1013     /**
1014      * Sets the value of a field as a {@code float} on the specified object.
1015      * This method is equivalent to
1016      * {@code set(obj, fObj)},
1017      * where {@code fObj} is a {@code Float} object and
1018      * {@code fObj.floatValue() == f}.
1019      *
1020      * @param obj the object whose field should be modified
1021      * @param f   the new value for the field of {@code obj}
1022      * being modified
1023      *
1024      * @throws    IllegalAccessException    if this {@code Field} object
1025      *              is enforcing Java language access control and the underlying
1026      *              field is either inaccessible or final;
1027      *              or if this {@code Field} object has no write access.
1028      * @throws    IllegalArgumentException  if the specified object is not an
1029      *              instance of the class or interface declaring the underlying
1030      *              field (or a subclass or implementor thereof),
1031      *              or if an unwrapping conversion fails.
1032      * @throws    NullPointerException      if the specified object is null
1033      *              and the field is an instance field.
1034      * @throws    ExceptionInInitializerError if the initialization provoked
1035      *              by this method fails.
1036      * @see       Field#set
1037      */
1038     @CallerSensitive
1039     @ForceInline // to ensure Reflection.getCallerClass optimization
1040     public void setFloat(Object obj, float f)
1041         throws IllegalArgumentException, IllegalAccessException
1042     {
1043         if (!override) {
1044             Class&lt;?&gt; caller = Reflection.getCallerClass();
1045             checkAccess(caller, obj);
1046         }
1047         getFieldAccessor(obj).setFloat(obj, f);
1048     }
1049 
1050     /**
1051      * Sets the value of a field as a {@code double} on the specified object.
1052      * This method is equivalent to
1053      * {@code set(obj, dObj)},
1054      * where {@code dObj} is a {@code Double} object and
1055      * {@code dObj.doubleValue() == d}.
1056      *
1057      * @param obj the object whose field should be modified
1058      * @param d   the new value for the field of {@code obj}
1059      * being modified
1060      *
1061      * @throws    IllegalAccessException    if this {@code Field} object
1062      *              is enforcing Java language access control and the underlying
1063      *              field is either inaccessible or final;
1064      *              or if this {@code Field} object has no write access.
1065      * @throws    IllegalArgumentException  if the specified object is not an
1066      *              instance of the class or interface declaring the underlying
1067      *              field (or a subclass or implementor thereof),
1068      *              or if an unwrapping conversion fails.
1069      * @throws    NullPointerException      if the specified object is null
1070      *              and the field is an instance field.
1071      * @throws    ExceptionInInitializerError if the initialization provoked
1072      *              by this method fails.
1073      * @see       Field#set
1074      */
1075     @CallerSensitive
1076     @ForceInline // to ensure Reflection.getCallerClass optimization
1077     public void setDouble(Object obj, double d)
1078         throws IllegalArgumentException, IllegalAccessException
1079     {
1080         if (!override) {
1081             Class&lt;?&gt; caller = Reflection.getCallerClass();
1082             checkAccess(caller, obj);
1083         }
1084         getFieldAccessor(obj).setDouble(obj, d);
1085     }
1086 
1087     // check access to field
1088     private void checkAccess(Class&lt;?&gt; caller, Object obj)
1089         throws IllegalAccessException
1090     {
1091         checkAccess(caller, clazz,
1092                     Modifier.isStatic(modifiers) ? null : obj.getClass(),
1093                     modifiers);
1094     }
1095 
1096     // security check is done before calling this method
1097     private FieldAccessor getFieldAccessor(Object obj)
1098         throws IllegalAccessException
1099     {
1100         boolean ov = override;
1101         FieldAccessor a = (ov) ? overrideFieldAccessor : fieldAccessor;
1102         return (a != null) ? a : acquireFieldAccessor(ov);
1103     }
1104 
1105     // NOTE that there is no synchronization used here. It is correct
1106     // (though not efficient) to generate more than one FieldAccessor
1107     // for a given Field. However, avoiding synchronization will
1108     // probably make the implementation more scalable.
1109     private FieldAccessor acquireFieldAccessor(boolean overrideFinalCheck) {
1110         // First check to see if one has been created yet, and take it
1111         // if so
1112         FieldAccessor tmp = null;
1113         if (root != null) tmp = root.getFieldAccessor(overrideFinalCheck);
1114         if (tmp != null) {
1115             if (overrideFinalCheck)
1116                 overrideFieldAccessor = tmp;
1117             else
1118                 fieldAccessor = tmp;
1119         } else {
1120             // Otherwise fabricate one and propagate it up to the root
1121             tmp = reflectionFactory.newFieldAccessor(this, overrideFinalCheck);
1122             setFieldAccessor(tmp, overrideFinalCheck);
1123         }
1124 
1125         return tmp;
1126     }
1127 
1128     // Returns FieldAccessor for this Field object, not looking up
1129     // the chain to the root
1130     private FieldAccessor getFieldAccessor(boolean overrideFinalCheck) {
1131         return (overrideFinalCheck)? overrideFieldAccessor : fieldAccessor;
1132     }
1133 
1134     // Sets the FieldAccessor for this Field object and
1135     // (recursively) its root
1136     private void setFieldAccessor(FieldAccessor accessor, boolean overrideFinalCheck) {
1137         if (overrideFinalCheck)
1138             overrideFieldAccessor = accessor;
1139         else
1140             fieldAccessor = accessor;
1141         // Propagate up
1142         if (root != null) {
1143             root.setFieldAccessor(accessor, overrideFinalCheck);
1144         }
1145     }
1146 
1147     @Override
1148     Field getRoot() {
1149         return root;
1150     }
1151 
1152     /**
1153      * {@inheritDoc}
1154      *
1155      * @throws NullPointerException {@inheritDoc}
1156      * @since 1.5
1157      */
1158     @Override
1159     public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
1160         Objects.requireNonNull(annotationClass);
1161         return annotationClass.cast(declaredAnnotations().get(annotationClass));
1162     }
1163 
1164     /**
1165      * {@inheritDoc}
1166      *
1167      * @throws NullPointerException {@inheritDoc}
1168      * @since 1.8
1169      */
1170     @Override
1171     public &lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass) {
1172         Objects.requireNonNull(annotationClass);
1173 
1174         return AnnotationSupport.getDirectlyAndIndirectlyPresent(declaredAnnotations(), annotationClass);
1175     }
1176 
1177     /**
1178      * {@inheritDoc}
1179      */
1180     @Override
1181     public Annotation[] getDeclaredAnnotations()  {
1182         return AnnotationParser.toArray(declaredAnnotations());
1183     }
1184 
1185     private transient volatile Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
1186 
1187     private Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations() {
1188         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declAnnos;
1189         if ((declAnnos = declaredAnnotations) == null) {
1190             synchronized (this) {
1191                 if ((declAnnos = declaredAnnotations) == null) {
1192                     Field root = this.root;
1193                     if (root != null) {
1194                         declAnnos = root.declaredAnnotations();
1195                     } else {
1196                         declAnnos = AnnotationParser.parseAnnotations(
1197                                 annotations,
1198                                 SharedSecrets.getJavaLangAccess()
1199                                         .getConstantPool(getDeclaringClass()),
1200                                 getDeclaringClass());
1201                     }
1202                     declaredAnnotations = declAnnos;
1203                 }
1204             }
1205         }
1206         return declAnnos;
1207     }
1208 
1209     private native byte[] getTypeAnnotationBytes0();
1210 
1211     /**
1212      * Returns an AnnotatedType object that represents the use of a type to specify
1213      * the declared type of the field represented by this Field.
1214      * @return an object representing the declared type of the field
1215      * represented by this Field
1216      *
1217      * @since 1.8
1218      */
1219     public AnnotatedType getAnnotatedType() {
1220         return TypeAnnotationParser.buildAnnotatedType(getTypeAnnotationBytes0(),
1221                                                        SharedSecrets.getJavaLangAccess().
1222                                                            getConstantPool(getDeclaringClass()),
1223                                                        this,
1224                                                        getDeclaringClass(),
1225                                                        getGenericType(),
1226                                                        TypeAnnotation.TypeAnnotationTarget.FIELD);
1227 }
1228 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
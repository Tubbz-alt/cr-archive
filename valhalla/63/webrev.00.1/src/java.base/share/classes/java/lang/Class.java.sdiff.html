<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/utilities/exceptions.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 180  * the element type of an array. In all other respects, the fact that
 181  * a class or interface is hidden has no bearing on the characteristics
 182  * exposed by the methods of class {@code Class}.
 183  *
 184  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 185  * object.  For example, the type of {@code String.class} is {@code
 186  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 187  * unknown.
 188  *
 189  * @author  unascribed
 190  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 191  * @since   1.0
 192  * @jls 15.8.2 Class Literals
 193  */
 194 public final class Class&lt;T&gt; implements java.io.Serializable,
 195                               GenericDeclaration,
 196                               Type,
 197                               AnnotatedElement,
 198                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 199                               Constable {
<span class="line-modified"> 200     private static final int ANNOTATION= 0x00002000;</span>
<span class="line-modified"> 201     private static final int ENUM      = 0x00004000;</span>
<span class="line-modified"> 202     private static final int SYNTHETIC = 0x00001000;</span>

 203 
 204     private static native void registerNatives();
 205     static {
 206         registerNatives();
 207     }
 208 
 209     /*
 210      * Private constructor. Only the Java Virtual Machine creates Class objects.
 211      * This constructor is not used and prevents the default constructor being
 212      * generated.
 213      */
 214     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 215         // Initialize final field for classLoader.  The initialization value of non-null
 216         // prevents future JIT optimizations from assuming this final field is null.
 217         classLoader = loader;
 218         componentType = arrayComponentType;
 219     }
 220 
 221     /**
 222      * Converts the object to a string. The string representation is the
 223      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 224      * name of the class in the format returned by {@code getName}.
 225      * If this {@code Class} object represents a primitive type,
 226      * this method returns the name of the primitive type.  If
 227      * this {@code Class} object represents void this method returns
 228      * &quot;void&quot;. If this {@code Class} object represents an array type,
 229      * this method returns &quot;class &quot; followed by {@code getName}.
 230      *
 231      * @return a string representation of this {@code Class} object.
 232      */
 233     public String toString() {
<span class="line-modified"> 234         return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))</span>
<span class="line-modified"> 235             + getName();</span>

 236     }
 237 
 238     /**
 239      * Returns a string describing this {@code Class}, including
 240      * information about modifiers and type parameters.
 241      *
 242      * The string is formatted as a list of type modifiers, if any,
 243      * followed by the kind of type (empty string for primitive types
 244      * and {@code class}, {@code enum}, {@code interface},
 245      * {@code @interface}, or {@code record} as appropriate), followed
 246      * by the type&#39;s name, followed by an angle-bracketed
 247      * comma-separated list of the type&#39;s type parameters, if any,
 248      * including informative bounds on the type parameters, if any.
 249      *
 250      * A space is used to separate modifiers from one another and to
 251      * separate any modifiers from the kind of type. The modifiers
 252      * occur in canonical order. If there are no type parameters, the
 253      * type parameter list is elided.
 254      *
 255      * For an array type, the string starts with the type name,
</pre>
<hr />
<pre>
 277             Class&lt;?&gt; component = this;
 278             int arrayDepth = 0;
 279 
 280             if (isArray()) {
 281                 do {
 282                     arrayDepth++;
 283                     component = component.getComponentType();
 284                 } while (component.isArray());
 285                 sb.append(component.getName());
 286             } else {
 287                 // Class modifiers are a superset of interface modifiers
 288                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 289                 if (modifiers != 0) {
 290                     sb.append(Modifier.toString(modifiers));
 291                     sb.append(&#39; &#39;);
 292                 }
 293 
 294                 if (isAnnotation()) {
 295                     sb.append(&#39;@&#39;);
 296                 }




 297                 if (isInterface()) { // Note: all annotation types are interfaces
 298                     sb.append(&quot;interface&quot;);
 299                 } else {
 300                     if (isEnum())
 301                         sb.append(&quot;enum&quot;);
 302                     else if (isRecord())
 303                         sb.append(&quot;record&quot;);
 304                     else
 305                         sb.append(&quot;class&quot;);
 306                 }
 307                 sb.append(&#39; &#39;);
 308                 sb.append(getName());
 309             }
 310 
 311             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 312             if (typeparms.length &gt; 0) {
 313                 sb.append(Arrays.stream(typeparms)
 314                           .map(Class::typeVarBounds)
 315                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 316             }
</pre>
<hr />
<pre>
 451     {
 452         Class&lt;?&gt; caller = null;
 453         SecurityManager sm = System.getSecurityManager();
 454         if (sm != null) {
 455             // Reflective call to get caller class is only needed if a security manager
 456             // is present.  Avoid the overhead of making this call otherwise.
 457             caller = Reflection.getCallerClass();
 458             if (loader == null) {
 459                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 460                 if (ccl != null) {
 461                     sm.checkPermission(
 462                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 463                 }
 464             }
 465         }
 466         return forName0(name, initialize, loader, caller);
 467     }
 468 
 469     /** Called after security check for system loader access checks have been made. */
 470     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
<span class="line-modified"> 471                                             ClassLoader loader,</span>
<span class="line-modified"> 472                                             Class&lt;?&gt; caller)</span>
 473         throws ClassNotFoundException;
 474 
 475 
 476     /**
 477      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 478      * binary name&lt;/a&gt; in the given module.
 479      *
 480      * &lt;p&gt; This method attempts to locate and load the class or interface.
 481      * It does not link the class, and does not run the class initializer.
 482      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 483      *
 484      * &lt;p&gt; If the class loader of the given module defines other modules and
 485      * the given name is a class defined in a different module, this method
 486      * returns {@code null} after the class is loaded. &lt;/p&gt;
 487      *
 488      * &lt;p&gt; This method does not check whether the requested class is
 489      * accessible to its caller. &lt;/p&gt;
 490      *
 491      * @apiNote
 492      * This method returns {@code null} on failure rather than
</pre>
<hr />
<pre>
 530         if (sm != null) {
 531             Class&lt;?&gt; caller = Reflection.getCallerClass();
 532             if (caller != null &amp;&amp; caller.getModule() != module) {
 533                 // if caller is null, Class.forName is the last java frame on the stack.
 534                 // java.base has all permissions
 535                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 536             }
 537             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 538             cl = AccessController.doPrivileged(pa);
 539         } else {
 540             cl = module.getClassLoader();
 541         }
 542 
 543         if (cl != null) {
 544             return cl.loadClass(module, name);
 545         } else {
 546             return BootLoader.loadClass(module, name);
 547         }
 548     }
 549 















































 550     /**
 551      * Creates a new instance of the class represented by this {@code Class}
 552      * object.  The class is instantiated as if by a {@code new}
 553      * expression with an empty argument list.  The class is initialized if it
 554      * has not already been initialized.
 555      *
 556      * @deprecated This method propagates any exception thrown by the
 557      * nullary constructor, including a checked exception.  Use of
 558      * this method effectively bypasses the compile-time exception
 559      * checking that would otherwise be performed by the compiler.
 560      * The {@link
 561      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 562      * Constructor.newInstance} method avoids this problem by wrapping
 563      * any exception thrown by the constructor in a (checked) {@link
 564      * java.lang.reflect.InvocationTargetException}.
 565      *
 566      * &lt;p&gt;The call
 567      *
 568      * &lt;pre&gt;{@code
 569      * clazz.newInstance()
</pre>
<hr />
<pre>
 809      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 810      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
 811      * &lt;/ul&gt;
 812      *
 813      * &lt;p&gt; If this {@code Class} object represents an array class, then
 814      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
 815      * representing the depth of the array nesting, followed by the element
 816      * type as encoded using the following table:
 817      *
 818      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 819      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 820      * &lt;thead&gt;
 821      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 822      * &lt;/thead&gt;
 823      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 824      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}
 825      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}
 826      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}
 827      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;
 828      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}


 829      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}
 830      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}
 831      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}
 832      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}
 833      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}
 834      * &lt;/tbody&gt;
 835      * &lt;/table&gt;&lt;/blockquote&gt;
 836      *
 837      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},
 838      * then the result is a string with the same spelling as the Java language
 839      * keyword which corresponds to the primitive type or {@code void}.
 840      *
 841      * &lt;p&gt; Examples:
 842      * &lt;blockquote&gt;&lt;pre&gt;
 843      * String.class.getName()
 844      *     returns &quot;java.lang.String&quot;
 845      * byte.class.getName()
 846      *     returns &quot;byte&quot;


 847      * (new Object[3]).getClass().getName()
 848      *     returns &quot;[Ljava.lang.Object;&quot;




 849      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 850      *     returns &quot;[[[[[[[I&quot;
 851      * &lt;/pre&gt;&lt;/blockquote&gt;
 852      *
 853      * @return  the name of the class, interface, or other entity
 854      *          represented by this {@code Class} object.
 855      * @jls 13.1 The Form of a Binary
 856      */
 857     public String getName() {
 858         String name = this.name;
 859         return name != null ? name : initClassName();
 860     }
 861 
 862     // Cache the name to reduce the number of calls into the VM.
 863     // This field would be set by VM itself during initClassName call.
 864     private transient String name;
 865     private native String initClassName();
 866 
 867     /**
 868      * Returns the class loader for the class.  Some implementations may use
</pre>
<hr />
<pre>
1259      * modifiers are the same as those of its component type.  If this
1260      * {@code Class} object represents a primitive type or void, its
1261      * {@code public} modifier is always {@code true}, and its
1262      * {@code protected} and {@code private} modifiers are always
1263      * {@code false}. If this {@code Class} object represents an array class, a
1264      * primitive type or void, then its {@code final} modifier is always
1265      * {@code true} and its interface modifier is always
1266      * {@code false}. The values of its other modifiers are not determined
1267      * by this specification.
1268      *
1269      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1270      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1271      *
1272      * @return the {@code int} representing the modifiers for this class
1273      * @see     java.lang.reflect.Modifier
1274      * @since 1.1
1275      */
1276     @HotSpotIntrinsicCandidate
1277     public native int getModifiers();
1278 
<span class="line-removed">1279 </span>
1280     /**
1281      * Gets the signers of this class.
1282      *
1283      * @return  the signers of this class, or null if there are no signers.  In
1284      *          particular, this method returns null if this {@code Class} object represents
1285      *          a primitive type or void.
1286      * @since   1.1
1287      */
1288     public native Object[] getSigners();
1289 
<span class="line-removed">1290 </span>
1291     /**
1292      * Set the signers of this class.
1293      */
1294     native void setSigners(Object[] signers);
1295 
1296 
1297     /**
1298      * If this {@code Class} object represents a local or anonymous
1299      * class within a method, returns a {@link
1300      * java.lang.reflect.Method Method} object representing the
1301      * immediately enclosing method of the underlying class. Returns
1302      * {@code null} otherwise.
1303      *
1304      * In particular, this method returns {@code null} if the underlying
1305      * class is a local or anonymous class immediately enclosed by a type
1306      * declaration, instance initializer or static initializer.
1307      *
1308      * @return the immediately enclosing method of the underlying class, if
1309      *     that class is a local or anonymous class; otherwise {@code null}.
1310      *
</pre>
<hr />
<pre>
1651             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1652         }
1653         return simpleName;
1654     }
1655 
1656     /**
1657      * Return an informative string for the name of this type.
1658      *
1659      * @return an informative string for the name of this type
1660      * @since 1.8
1661      */
1662     public String getTypeName() {
1663         if (isArray()) {
1664             try {
1665                 Class&lt;?&gt; cl = this;
1666                 int dimensions = 0;
1667                 do {
1668                     dimensions++;
1669                     cl = cl.getComponentType();
1670                 } while (cl.isArray());
<span class="line-modified">1671                 return cl.getName() + &quot;[]&quot;.repeat(dimensions);</span>
1672             } catch (Throwable e) { /*FALLTHRU*/ }
1673         }
1674         return getName();
1675     }
1676 
1677     /**
1678      * Returns the canonical name of the underlying class as
1679      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
1680      * Returns {@code null} if the underlying class does not have a canonical
1681      * name. Classes without canonical names include:
1682      * &lt;ul&gt;
1683      * &lt;li&gt;a {@linkplain #isLocalClass() local class}
1684      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}
1685      * &lt;li&gt;a {@linkplain #isHidden() hidden class}
1686      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;
1687      * &lt;/ul&gt;
1688      *
1689      * @return the canonical name of the underlying class if it exists, and
1690      * {@code null} otherwise.
1691      * @since 1.5
</pre>
<hr />
<pre>
3786                 throw new IllegalArgumentException(
3787                     getName() + &quot; is not an enum type&quot;);
3788             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3789             for (T constant : universe) {
3790                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3791             }
3792             enumConstantDirectory = directory;
3793         }
3794         return directory;
3795     }
3796     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3797 
3798     /**
3799      * Casts an object to the class or interface represented
3800      * by this {@code Class} object.
3801      *
3802      * @param obj the object to be cast
3803      * @return the object after casting, or null if obj is null
3804      *
3805      * @throws ClassCastException if the object is not
<span class="line-modified">3806      * null and is not assignable to the type T.</span>


3807      *
3808      * @since 1.5
3809      */
3810     @SuppressWarnings(&quot;unchecked&quot;)
3811     @HotSpotIntrinsicCandidate
3812     public T cast(Object obj) {



3813         if (obj != null &amp;&amp; !isInstance(obj))
3814             throw new ClassCastException(cannotCastMsg(obj));
3815         return (T) obj;
3816     }
3817 
3818     private String cannotCastMsg(Object obj) {
3819         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3820     }
3821 
3822     /**
3823      * Casts this {@code Class} object to represent a subclass of the class
3824      * represented by the specified class object.  Checks that the cast
3825      * is valid, and throws a {@code ClassCastException} if it is not.  If
3826      * this method succeeds, it always returns a reference to this {@code Class} object.
3827      *
3828      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3829      * a {@code Class} object to pass it to an API that restricts the
3830      * {@code Class} objects that it is willing to accept.  A cast would
3831      * generate a compile-time warning, as the correctness of the cast
3832      * could not be checked at runtime (because generic types are implemented
</pre>
<hr />
<pre>
4088      *
4089      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4090      * value is an array containing objects representing the uses of interface
4091      * types to specify interfaces directly extended by the interface. The
4092      * order of the objects in the array corresponds to the order of the
4093      * interface types used in the &#39;extends&#39; clause of the declaration of this
4094      * {@code Class} object.
4095      *
4096      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4097      * declaration does not explicitly indicate any annotated superinterfaces,
4098      * the return value is an array of length 0.
4099      *
4100      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4101      * class, an array type, a primitive type, or void, the return value is an
4102      * array of length 0.
4103      *
4104      * @return an array representing the superinterfaces
4105      * @since 1.8
4106      */
4107     public AnnotatedType[] getAnnotatedInterfaces() {
<span class="line-modified">4108          return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);</span>
4109     }
4110 
4111     private native Class&lt;?&gt; getNestHost0();
4112 
4113     /**
4114      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4115      * or interface represented by this {@code Class} object belongs.
4116      * Every class and interface belongs to exactly one nest.
4117      *
4118      * If the nest host of this class or interface has previously
4119      * been determined, then this method returns the nest host.
4120      * If the nest host of this class or interface has
4121      * not previously been determined, then this method determines the nest
4122      * host using the algorithm of JVMS 5.4.4, and returns it.
4123      *
4124      * Often, a class or interface belongs to a nest consisting only of itself,
4125      * in which case this method returns {@code this} to indicate that the class
4126      * or interface is the nest host.
4127      *
4128      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
</pre>
<hr />
<pre>
4301      * {@code void}, then the result is a field descriptor string which
4302      * is a one-letter code corresponding to a primitive type or {@code void}
4303      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).
4304      *
4305      * @apiNote
4306      * This is not a strict inverse of {@link #forName};
4307      * distinct classes which share a common name but have different class loaders
4308      * will have identical descriptor strings.
4309      *
4310      * @return the descriptor string for this {@code Class} object
4311      * @jvms 4.3.2 Field Descriptors
4312      * @since 12
4313      */
4314     @Override
4315     public String descriptorString() {
4316         if (isPrimitive())
4317             return Wrapper.forPrimitiveType(this).basicTypeString();
4318 
4319         if (isArray()) {
4320             return &quot;[&quot; + componentType.descriptorString();
<span class="line-modified">4321         } else if (isHidden()) {</span>


4322             String name = getName();
4323             int index = name.indexOf(&#39;/&#39;);
<span class="line-modified">4324             return &quot;L&quot; + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)</span>
4325                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;
4326         } else {
<span class="line-modified">4327             return &quot;L&quot; + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
4328         }
4329     }
4330 
4331     /**
4332      * Returns the component type of this {@code Class}, if it describes
4333      * an array type, or {@code null} otherwise.
4334      *
4335      * @implSpec
4336      * Equivalent to {@link Class#getComponentType()}.
4337      *
4338      * @return a {@code Class} describing the component type, or {@code null}
4339      * if this {@code Class} does not describe an array type
4340      * @since 12
4341      */
4342     @Override
4343     public Class&lt;?&gt; componentType() {
4344         return isArray() ? componentType : null;
4345     }
4346 
4347     /**
</pre>
</td>
<td>
<hr />
<pre>
 180  * the element type of an array. In all other respects, the fact that
 181  * a class or interface is hidden has no bearing on the characteristics
 182  * exposed by the methods of class {@code Class}.
 183  *
 184  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 185  * object.  For example, the type of {@code String.class} is {@code
 186  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 187  * unknown.
 188  *
 189  * @author  unascribed
 190  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 191  * @since   1.0
 192  * @jls 15.8.2 Class Literals
 193  */
 194 public final class Class&lt;T&gt; implements java.io.Serializable,
 195                               GenericDeclaration,
 196                               Type,
 197                               AnnotatedElement,
 198                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 199                               Constable {
<span class="line-modified"> 200     private static final int ANNOTATION = 0x00002000;</span>
<span class="line-modified"> 201     private static final int ENUM       = 0x00004000;</span>
<span class="line-modified"> 202     private static final int SYNTHETIC  = 0x00001000;</span>
<span class="line-added"> 203     private static final int INLINE     = 0x00000100;</span>
 204 
 205     private static native void registerNatives();
 206     static {
 207         registerNatives();
 208     }
 209 
 210     /*
 211      * Private constructor. Only the Java Virtual Machine creates Class objects.
 212      * This constructor is not used and prevents the default constructor being
 213      * generated.
 214      */
 215     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 216         // Initialize final field for classLoader.  The initialization value of non-null
 217         // prevents future JIT optimizations from assuming this final field is null.
 218         classLoader = loader;
 219         componentType = arrayComponentType;
 220     }
 221 
 222     /**
 223      * Converts the object to a string. The string representation is the
 224      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 225      * name of the class in the format returned by {@code getName}.
 226      * If this {@code Class} object represents a primitive type,
 227      * this method returns the name of the primitive type.  If
 228      * this {@code Class} object represents void this method returns
 229      * &quot;void&quot;. If this {@code Class} object represents an array type,
 230      * this method returns &quot;class &quot; followed by {@code getName}.
 231      *
 232      * @return a string representation of this {@code Class} object.
 233      */
 234     public String toString() {
<span class="line-modified"> 235         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)</span>
<span class="line-modified"> 236                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))</span>
<span class="line-added"> 237                + getName();</span>
 238     }
 239 
 240     /**
 241      * Returns a string describing this {@code Class}, including
 242      * information about modifiers and type parameters.
 243      *
 244      * The string is formatted as a list of type modifiers, if any,
 245      * followed by the kind of type (empty string for primitive types
 246      * and {@code class}, {@code enum}, {@code interface},
 247      * {@code @interface}, or {@code record} as appropriate), followed
 248      * by the type&#39;s name, followed by an angle-bracketed
 249      * comma-separated list of the type&#39;s type parameters, if any,
 250      * including informative bounds on the type parameters, if any.
 251      *
 252      * A space is used to separate modifiers from one another and to
 253      * separate any modifiers from the kind of type. The modifiers
 254      * occur in canonical order. If there are no type parameters, the
 255      * type parameter list is elided.
 256      *
 257      * For an array type, the string starts with the type name,
</pre>
<hr />
<pre>
 279             Class&lt;?&gt; component = this;
 280             int arrayDepth = 0;
 281 
 282             if (isArray()) {
 283                 do {
 284                     arrayDepth++;
 285                     component = component.getComponentType();
 286                 } while (component.isArray());
 287                 sb.append(component.getName());
 288             } else {
 289                 // Class modifiers are a superset of interface modifiers
 290                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 291                 if (modifiers != 0) {
 292                     sb.append(Modifier.toString(modifiers));
 293                     sb.append(&#39; &#39;);
 294                 }
 295 
 296                 if (isAnnotation()) {
 297                     sb.append(&#39;@&#39;);
 298                 }
<span class="line-added"> 299                 if (isInlineClass()) {</span>
<span class="line-added"> 300                     sb.append(&quot;inline&quot;);</span>
<span class="line-added"> 301                     sb.append(&#39; &#39;);</span>
<span class="line-added"> 302                 }</span>
 303                 if (isInterface()) { // Note: all annotation types are interfaces
 304                     sb.append(&quot;interface&quot;);
 305                 } else {
 306                     if (isEnum())
 307                         sb.append(&quot;enum&quot;);
 308                     else if (isRecord())
 309                         sb.append(&quot;record&quot;);
 310                     else
 311                         sb.append(&quot;class&quot;);
 312                 }
 313                 sb.append(&#39; &#39;);
 314                 sb.append(getName());
 315             }
 316 
 317             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 318             if (typeparms.length &gt; 0) {
 319                 sb.append(Arrays.stream(typeparms)
 320                           .map(Class::typeVarBounds)
 321                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 322             }
</pre>
<hr />
<pre>
 457     {
 458         Class&lt;?&gt; caller = null;
 459         SecurityManager sm = System.getSecurityManager();
 460         if (sm != null) {
 461             // Reflective call to get caller class is only needed if a security manager
 462             // is present.  Avoid the overhead of making this call otherwise.
 463             caller = Reflection.getCallerClass();
 464             if (loader == null) {
 465                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 466                 if (ccl != null) {
 467                     sm.checkPermission(
 468                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 469                 }
 470             }
 471         }
 472         return forName0(name, initialize, loader, caller);
 473     }
 474 
 475     /** Called after security check for system loader access checks have been made. */
 476     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
<span class="line-modified"> 477                                     ClassLoader loader,</span>
<span class="line-modified"> 478                                     Class&lt;?&gt; caller)</span>
 479         throws ClassNotFoundException;
 480 
 481 
 482     /**
 483      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 484      * binary name&lt;/a&gt; in the given module.
 485      *
 486      * &lt;p&gt; This method attempts to locate and load the class or interface.
 487      * It does not link the class, and does not run the class initializer.
 488      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 489      *
 490      * &lt;p&gt; If the class loader of the given module defines other modules and
 491      * the given name is a class defined in a different module, this method
 492      * returns {@code null} after the class is loaded. &lt;/p&gt;
 493      *
 494      * &lt;p&gt; This method does not check whether the requested class is
 495      * accessible to its caller. &lt;/p&gt;
 496      *
 497      * @apiNote
 498      * This method returns {@code null} on failure rather than
</pre>
<hr />
<pre>
 536         if (sm != null) {
 537             Class&lt;?&gt; caller = Reflection.getCallerClass();
 538             if (caller != null &amp;&amp; caller.getModule() != module) {
 539                 // if caller is null, Class.forName is the last java frame on the stack.
 540                 // java.base has all permissions
 541                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 542             }
 543             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 544             cl = AccessController.doPrivileged(pa);
 545         } else {
 546             cl = module.getClassLoader();
 547         }
 548 
 549         if (cl != null) {
 550             return cl.loadClass(module, name);
 551         } else {
 552             return BootLoader.loadClass(module, name);
 553         }
 554     }
 555 
<span class="line-added"> 556     /**</span>
<span class="line-added"> 557      * Returns {@code true} if this class is an inline class.</span>
<span class="line-added"> 558      *</span>
<span class="line-added"> 559      * @return {@code true} if this class is an inline class</span>
<span class="line-added"> 560      * @since Valhalla</span>
<span class="line-added"> 561      */</span>
<span class="line-added"> 562     public boolean isInlineClass() {</span>
<span class="line-added"> 563         return (this.getModifiers() &amp; INLINE) != 0;</span>
<span class="line-added"> 564     }</span>
<span class="line-added"> 565 </span>
<span class="line-added"> 566     /**</span>
<span class="line-added"> 567      * Returns a {@code Class} object representing the &lt;em&gt;value projection&lt;/em&gt;</span>
<span class="line-added"> 568      * type of this class if this {@code Class} is the reference projection type</span>
<span class="line-added"> 569      * of an {@linkplain #isInlineClass() inline class}.  Otherwise an empty</span>
<span class="line-added"> 570      * {@link Optional} is returned.</span>
<span class="line-added"> 571      *</span>
<span class="line-added"> 572      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-added"> 573      *         this class if this class is the reference projection type of an</span>
<span class="line-added"> 574      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-added"> 575      * @since Valhalla</span>
<span class="line-added"> 576      */</span>
<span class="line-added"> 577     public Optional&lt;Class&lt;T&gt;&gt; valueType() {</span>
<span class="line-added"> 578         return Optional.ofNullable(valType);</span>
<span class="line-added"> 579     }</span>
<span class="line-added"> 580 </span>
<span class="line-added"> 581     /**</span>
<span class="line-added"> 582      * Returns a {@code Class} object representing the &lt;em&gt;reference projection&lt;/em&gt;</span>
<span class="line-added"> 583      * type of this class if this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-added"> 584      * with a reference projection.</span>
<span class="line-added"> 585      * If this class is an {@linkplain #isInlineClass() inline class}</span>
<span class="line-added"> 586      * without a reference projection or this class is not an inline class,</span>
<span class="line-added"> 587      * then this method returns an empty {@link Optional}.</span>
<span class="line-added"> 588      *</span>
<span class="line-added"> 589      * @return the {@code Class} object representing the value projection type of</span>
<span class="line-added"> 590      *         this class if this class is the reference projection type of an</span>
<span class="line-added"> 591      *         inline class; an empty {@link Optional} otherwise</span>
<span class="line-added"> 592      * @since Valhalla</span>
<span class="line-added"> 593      */</span>
<span class="line-added"> 594     public Optional&lt;Class&lt;T&gt;&gt; referenceType() {</span>
<span class="line-added"> 595         return valType != null ? Optional.ofNullable(refType) : Optional.of(this);</span>
<span class="line-added"> 596     }</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598     // set by VM if this class is an inline type</span>
<span class="line-added"> 599     // otherwise, these two fields are null</span>
<span class="line-added"> 600     private transient Class&lt;T&gt; valType;</span>
<span class="line-added"> 601     private transient Class&lt;T&gt; refType;</span>
<span class="line-added"> 602 </span>
 603     /**
 604      * Creates a new instance of the class represented by this {@code Class}
 605      * object.  The class is instantiated as if by a {@code new}
 606      * expression with an empty argument list.  The class is initialized if it
 607      * has not already been initialized.
 608      *
 609      * @deprecated This method propagates any exception thrown by the
 610      * nullary constructor, including a checked exception.  Use of
 611      * this method effectively bypasses the compile-time exception
 612      * checking that would otherwise be performed by the compiler.
 613      * The {@link
 614      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 615      * Constructor.newInstance} method avoids this problem by wrapping
 616      * any exception thrown by the constructor in a (checked) {@link
 617      * java.lang.reflect.InvocationTargetException}.
 618      *
 619      * &lt;p&gt;The call
 620      *
 621      * &lt;pre&gt;{@code
 622      * clazz.newInstance()
</pre>
<hr />
<pre>
 862      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
 863      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.
 864      * &lt;/ul&gt;
 865      *
 866      * &lt;p&gt; If this {@code Class} object represents an array class, then
 867      * the result is a string consisting of one or more &#39;{@code [}&#39; characters
 868      * representing the depth of the array nesting, followed by the element
 869      * type as encoded using the following table:
 870      *
 871      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 872      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 873      * &lt;thead&gt;
 874      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 875      * &lt;/thead&gt;
 876      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 877      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}
 878      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}
 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}
 880      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;
 881      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}
<span class="line-added"> 882      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class} with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-added"> 883      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code Q}&lt;em&gt;N&lt;/em&gt;{@code ;}</span>
 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}
 885      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}
 886      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}
 887      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}
 888      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}
 889      * &lt;/tbody&gt;
 890      * &lt;/table&gt;&lt;/blockquote&gt;
 891      *
 892      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},
 893      * then the result is a string with the same spelling as the Java language
 894      * keyword which corresponds to the primitive type or {@code void}.
 895      *
 896      * &lt;p&gt; Examples:
 897      * &lt;blockquote&gt;&lt;pre&gt;
 898      * String.class.getName()
 899      *     returns &quot;java.lang.String&quot;
 900      * byte.class.getName()
 901      *     returns &quot;byte&quot;
<span class="line-added"> 902      * Point.class.getName()</span>
<span class="line-added"> 903      *     returns &quot;Point&quot;</span>
 904      * (new Object[3]).getClass().getName()
 905      *     returns &quot;[Ljava.lang.Object;&quot;
<span class="line-added"> 906      * (new Point[3]).getClass().getName()</span>
<span class="line-added"> 907      *     returns &quot;[QPoint;&quot;</span>
<span class="line-added"> 908      * (new Point.ref[3][4]).getClass().getName()</span>
<span class="line-added"> 909      *     returns &quot;[[LPoint$ref;&quot;</span>
 910      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 911      *     returns &quot;[[[[[[[I&quot;
 912      * &lt;/pre&gt;&lt;/blockquote&gt;
 913      *
 914      * @return  the name of the class, interface, or other entity
 915      *          represented by this {@code Class} object.
 916      * @jls 13.1 The Form of a Binary
 917      */
 918     public String getName() {
 919         String name = this.name;
 920         return name != null ? name : initClassName();
 921     }
 922 
 923     // Cache the name to reduce the number of calls into the VM.
 924     // This field would be set by VM itself during initClassName call.
 925     private transient String name;
 926     private native String initClassName();
 927 
 928     /**
 929      * Returns the class loader for the class.  Some implementations may use
</pre>
<hr />
<pre>
1320      * modifiers are the same as those of its component type.  If this
1321      * {@code Class} object represents a primitive type or void, its
1322      * {@code public} modifier is always {@code true}, and its
1323      * {@code protected} and {@code private} modifiers are always
1324      * {@code false}. If this {@code Class} object represents an array class, a
1325      * primitive type or void, then its {@code final} modifier is always
1326      * {@code true} and its interface modifier is always
1327      * {@code false}. The values of its other modifiers are not determined
1328      * by this specification.
1329      *
1330      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1331      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1332      *
1333      * @return the {@code int} representing the modifiers for this class
1334      * @see     java.lang.reflect.Modifier
1335      * @since 1.1
1336      */
1337     @HotSpotIntrinsicCandidate
1338     public native int getModifiers();
1339 

1340     /**
1341      * Gets the signers of this class.
1342      *
1343      * @return  the signers of this class, or null if there are no signers.  In
1344      *          particular, this method returns null if this {@code Class} object represents
1345      *          a primitive type or void.
1346      * @since   1.1
1347      */
1348     public native Object[] getSigners();
1349 

1350     /**
1351      * Set the signers of this class.
1352      */
1353     native void setSigners(Object[] signers);
1354 
1355 
1356     /**
1357      * If this {@code Class} object represents a local or anonymous
1358      * class within a method, returns a {@link
1359      * java.lang.reflect.Method Method} object representing the
1360      * immediately enclosing method of the underlying class. Returns
1361      * {@code null} otherwise.
1362      *
1363      * In particular, this method returns {@code null} if the underlying
1364      * class is a local or anonymous class immediately enclosed by a type
1365      * declaration, instance initializer or static initializer.
1366      *
1367      * @return the immediately enclosing method of the underlying class, if
1368      *     that class is a local or anonymous class; otherwise {@code null}.
1369      *
</pre>
<hr />
<pre>
1710             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1711         }
1712         return simpleName;
1713     }
1714 
1715     /**
1716      * Return an informative string for the name of this type.
1717      *
1718      * @return an informative string for the name of this type
1719      * @since 1.8
1720      */
1721     public String getTypeName() {
1722         if (isArray()) {
1723             try {
1724                 Class&lt;?&gt; cl = this;
1725                 int dimensions = 0;
1726                 do {
1727                     dimensions++;
1728                     cl = cl.getComponentType();
1729                 } while (cl.isArray());
<span class="line-modified">1730                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);</span>
1731             } catch (Throwable e) { /*FALLTHRU*/ }
1732         }
1733         return getName();
1734     }
1735 
1736     /**
1737      * Returns the canonical name of the underlying class as
1738      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.
1739      * Returns {@code null} if the underlying class does not have a canonical
1740      * name. Classes without canonical names include:
1741      * &lt;ul&gt;
1742      * &lt;li&gt;a {@linkplain #isLocalClass() local class}
1743      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}
1744      * &lt;li&gt;a {@linkplain #isHidden() hidden class}
1745      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;
1746      * &lt;/ul&gt;
1747      *
1748      * @return the canonical name of the underlying class if it exists, and
1749      * {@code null} otherwise.
1750      * @since 1.5
</pre>
<hr />
<pre>
3845                 throw new IllegalArgumentException(
3846                     getName() + &quot; is not an enum type&quot;);
3847             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3848             for (T constant : universe) {
3849                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3850             }
3851             enumConstantDirectory = directory;
3852         }
3853         return directory;
3854     }
3855     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3856 
3857     /**
3858      * Casts an object to the class or interface represented
3859      * by this {@code Class} object.
3860      *
3861      * @param obj the object to be cast
3862      * @return the object after casting, or null if obj is null
3863      *
3864      * @throws ClassCastException if the object is not
<span class="line-modified">3865      * {@code null} and is not assignable to the type T.</span>
<span class="line-added">3866      * @throws NullPointerException if this is an {@linkplain #isInlineClass()</span>
<span class="line-added">3867      * inline type} and the object is {@code null}</span>
3868      *
3869      * @since 1.5
3870      */
3871     @SuppressWarnings(&quot;unchecked&quot;)
3872     @HotSpotIntrinsicCandidate
3873     public T cast(Object obj) {
<span class="line-added">3874         if (isInlineClass() &amp;&amp; obj == null)</span>
<span class="line-added">3875             throw new NullPointerException(getName() + &quot; is an inline class&quot;);</span>
<span class="line-added">3876 </span>
3877         if (obj != null &amp;&amp; !isInstance(obj))
3878             throw new ClassCastException(cannotCastMsg(obj));
3879         return (T) obj;
3880     }
3881 
3882     private String cannotCastMsg(Object obj) {
3883         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3884     }
3885 
3886     /**
3887      * Casts this {@code Class} object to represent a subclass of the class
3888      * represented by the specified class object.  Checks that the cast
3889      * is valid, and throws a {@code ClassCastException} if it is not.  If
3890      * this method succeeds, it always returns a reference to this {@code Class} object.
3891      *
3892      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3893      * a {@code Class} object to pass it to an API that restricts the
3894      * {@code Class} objects that it is willing to accept.  A cast would
3895      * generate a compile-time warning, as the correctness of the cast
3896      * could not be checked at runtime (because generic types are implemented
</pre>
<hr />
<pre>
4152      *
4153      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4154      * value is an array containing objects representing the uses of interface
4155      * types to specify interfaces directly extended by the interface. The
4156      * order of the objects in the array corresponds to the order of the
4157      * interface types used in the &#39;extends&#39; clause of the declaration of this
4158      * {@code Class} object.
4159      *
4160      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4161      * declaration does not explicitly indicate any annotated superinterfaces,
4162      * the return value is an array of length 0.
4163      *
4164      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4165      * class, an array type, a primitive type, or void, the return value is an
4166      * array of length 0.
4167      *
4168      * @return an array representing the superinterfaces
4169      * @since 1.8
4170      */
4171     public AnnotatedType[] getAnnotatedInterfaces() {
<span class="line-modified">4172         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);</span>
4173     }
4174 
4175     private native Class&lt;?&gt; getNestHost0();
4176 
4177     /**
4178      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4179      * or interface represented by this {@code Class} object belongs.
4180      * Every class and interface belongs to exactly one nest.
4181      *
4182      * If the nest host of this class or interface has previously
4183      * been determined, then this method returns the nest host.
4184      * If the nest host of this class or interface has
4185      * not previously been determined, then this method determines the nest
4186      * host using the algorithm of JVMS 5.4.4, and returns it.
4187      *
4188      * Often, a class or interface belongs to a nest consisting only of itself,
4189      * in which case this method returns {@code this} to indicate that the class
4190      * or interface is the nest host.
4191      *
4192      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,
</pre>
<hr />
<pre>
4365      * {@code void}, then the result is a field descriptor string which
4366      * is a one-letter code corresponding to a primitive type or {@code void}
4367      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).
4368      *
4369      * @apiNote
4370      * This is not a strict inverse of {@link #forName};
4371      * distinct classes which share a common name but have different class loaders
4372      * will have identical descriptor strings.
4373      *
4374      * @return the descriptor string for this {@code Class} object
4375      * @jvms 4.3.2 Field Descriptors
4376      * @since 12
4377      */
4378     @Override
4379     public String descriptorString() {
4380         if (isPrimitive())
4381             return Wrapper.forPrimitiveType(this).basicTypeString();
4382 
4383         if (isArray()) {
4384             return &quot;[&quot; + componentType.descriptorString();
<span class="line-modified">4385         }</span>
<span class="line-added">4386         String typeDesc = isInlineClass() ? &quot;Q&quot; : &quot;L&quot;;</span>
<span class="line-added">4387         if (isHidden()) {</span>
4388             String name = getName();
4389             int index = name.indexOf(&#39;/&#39;);
<span class="line-modified">4390             return typeDesc + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)</span>
4391                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;
4392         } else {
<span class="line-modified">4393             return typeDesc + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
4394         }
4395     }
4396 
4397     /**
4398      * Returns the component type of this {@code Class}, if it describes
4399      * an array type, or {@code null} otherwise.
4400      *
4401      * @implSpec
4402      * Equivalent to {@link Class#getComponentType()}.
4403      *
4404      * @return a {@code Class} describing the component type, or {@code null}
4405      * if this {@code Class} does not describe an array type
4406      * @since 12
4407      */
4408     @Override
4409     public Class&lt;?&gt; componentType() {
4410         return isArray() ? componentType : null;
4411     }
4412 
4413     /**
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../hotspot/share/utilities/exceptions.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -633,5 +633,6 @@
 bc54620a3848c26cff9766e5e2a6e5ddab98ed18 jdk-14-ga
 82b7c62cf4cc56828a8fb724f57087967232a2a7 jdk-15+15
 5c7ec21f5d13f6eb5cd32288c69b8be2f9cac256 jdk-15+16
 dd5198db2e5b1ebcafe065d987c03ba9fcb50fc3 jdk-15+17
 44aef192b488a48cce12422394691a6b1d16b98e jdk-15+18
+7cc27caabe6e342151e8baf549beb07a9c755ec2 jdk-15+19
diff a/make/conf/jib-profiles.js b/make/conf/jib-profiles.js
--- a/make/conf/jib-profiles.js
+++ b/make/conf/jib-profiles.js
@@ -379,12 +379,12 @@
                 },
             }
         };
     };
 
-    common.boot_jdk_version = "13";
-    common.boot_jdk_build_number = "33";
+    common.boot_jdk_version = "14";
+    common.boot_jdk_build_number = "36";
     common.boot_jdk_home = input.get("boot_jdk", "install_path") + "/jdk-"
         + common.boot_jdk_version
         + (input.build_os == "macosx" ? ".jdk/Contents/Home" : "");
 
     return common;
@@ -613,11 +613,17 @@
             profiles[bootcycleName] = clone(profiles[name]);
             profiles[bootcycleName].default_make_targets = [ "bootcycle-images" ];
             // The prebuilt bootcycle variant modifies the boot jdk argument
             var bootcyclePrebuiltBase = {
                 dependencies: [ name + ".jdk" ],
-                configure_args: "--with-boot-jdk=" + input.get(name + ".jdk", "home_path"),
+                configure_args: [
+                    "--with-boot-jdk=" + input.get(name + ".jdk", "home_path"),
+                    // Full docs do not currently work with bootcycle build
+                    // since Nashorn was removed. This negates the
+                    // --enable-full-docs from the main profile.
+                    "--enable-full-docs=auto",
+                ]
             }
             profiles[bootcyclePrebuiltName] = concatObjects(profiles[name],
                 bootcyclePrebuiltBase);
             var bootJdkIndex = profiles[bootcyclePrebuiltName].dependencies.indexOf("boot_jdk");
             delete profiles[bootcyclePrebuiltName].dependencies[bootJdkIndex];
@@ -1007,29 +1013,34 @@
     var makeBinDir = (input.build_os == "windows"
         ? input.get("gnumake", "install_path") + "/cygwin/bin"
         : input.get("gnumake", "install_path") + "/bin");
 
     if (input.build_cpu == 'aarch64') {
-	boot_jdk = {
+        boot_jdk = {
             organization: common.organization,
             ext: "tar.gz",
             module: "jdk-linux_aarch64",
             revision: "13+1.0",
             configure_args: "--with-boot-jdk=" + common.boot_jdk_home,
             environment_path: common.boot_jdk_home + "/bin"
-	}
+        }
     } else {
-	boot_jdk = {
+        boot_jdk = {
             server: "jpg",
             product: "jdk",
             version: common.boot_jdk_version,
             build_number: common.boot_jdk_build_number,
             file: "bundles/" + boot_jdk_platform + "/jdk-" + common.boot_jdk_version + "_"
                 + boot_jdk_platform + "_bin" + boot_jdk_ext,
             configure_args: "--with-boot-jdk=" + common.boot_jdk_home,
             environment_path: common.boot_jdk_home + "/bin"
-	}
+        }
+    }
+    if (input.build_cpu == 'sparcv9') {
+        boot_jdk.file = "bundles/openjdk/GPL/" + boot_jdk_platform
+            + "/openjdk-" + common.boot_jdk_version + "_"
+            + boot_jdk_platform + "_bin" + boot_jdk_ext;
     }
 
     var dependencies = {
         boot_jdk: boot_jdk,
 
diff a/make/data/jdwp/jdwp.spec b/make/data/jdwp/jdwp.spec
--- a/make/data/jdwp/jdwp.spec
+++ b/make/data/jdwp/jdwp.spec
@@ -68,11 +68,12 @@
             (Error VM_DEAD)
         )
     )
     (Command AllClasses=3
         "Returns reference types for all classes currently loaded by the "
-        "target VM."
+        "target VM. "
+        "See <a href=\"../jvmti.html#GetLoadedClasses\">JVM TI GetLoadedClasses</a>."
         (Out
         )
         (Reply
             (Repeat classes "Number of reference types that follow."
                 (Group ClassInfo
@@ -598,18 +599,13 @@
     )
 )
 
 (CommandSet ReferenceType=2
     (Command Signature=1
-        "Returns the JNI signature of a reference type. "
-        "JNI signature formats are described in the "
-        "<a href=\"../jni/index.html\">Java Native Interface Specification</a>"
-        "<p>
-        "For primitive classes "
-        "the returned signature is the signature of the corresponding primitive "
-        "type; for example, \"I\" is returned as the signature of the class "
-        "represented by java.lang.Integer.TYPE."
+        "Returns the type signature of a reference type. "
+        "Type signature formats are the same as specified in "
+        "<a href=\"../jvmti.html#GetClassSignature\">JVM TI GetClassSignature</a>."
         (Out
             (referenceType refType "The reference type ID.")
         )
         (Reply
             (string signature
@@ -2264,24 +2260,27 @@
         )
     )
 )
 (CommandSet ClassLoaderReference=14
     (Command VisibleClasses=1
-        "Returns a list of all classes which this class loader has "
-        "been requested to load. This class loader is considered to be "
-        "an <i>initiating</i> class loader for each class in the returned "
-        "list. The list contains each "
-        "reference type defined by this loader and any types for which "
+        "Returns a list of all classes which this class loader can find "
+        "by name via <code>ClassLoader::loadClass</code>, "
+        "<code>Class::forName</code> and bytecode linkage. That is, "
+        "all classes for which this class loader has been recorded as an "
+        "<i>initiating</i> loader. The list contains each "
+        "reference type created by this loader and any types for which "
         "loading was delegated by this class loader to another class loader. "
         "<p>"
         "The visible class list has useful properties with respect to "
         "the type namespace. A particular type name will occur at most "
         "once in the list. Each field or variable declared with that "
         "type name in a class defined by "
         "this class loader must be resolved to that single type. "
         "<p>"
         "No ordering of the returned list is guaranteed. "
+        "<p>"
+        "See <a href=\"../jvmti.html#GetClassLoaderClasses\">JVM TI GetClassLoaderClasses</a>. "
         (Out
             (classLoaderObject classLoaderObject "The class loader object ID. ")
         )
         (Reply
             (Repeat classes "The number of visible classes. "
diff a/make/test/BuildMicrobenchmark.gmk b/make/test/BuildMicrobenchmark.gmk
--- a/make/test/BuildMicrobenchmark.gmk
+++ b/make/test/BuildMicrobenchmark.gmk
@@ -75,11 +75,11 @@
 
 $(eval $(call SetupJavaCompilation, BUILD_INDIFY, \
     SETUP := GENERATE_OLDBYTECODE, \
     SRC := $(TOPDIR)/test/jdk/java/lang/invoke, \
     INCLUDE_FILES := indify/Indify.java, \
-    DISABLED_WARNINGS := rawtypes unchecked serial deprecation, \
+    DISABLED_WARNINGS := rawtypes serial, \
     BIN := $(MICROBENCHMARK_TOOLS_CLASSES), \
 ))
 
 #### Compile Targets
 
diff a/src/hotspot/cpu/aarch64/aarch64.ad b/src/hotspot/cpu/aarch64/aarch64.ad
--- a/src/hotspot/cpu/aarch64/aarch64.ad
+++ b/src/hotspot/cpu/aarch64/aarch64.ad
@@ -1095,13 +1095,13 @@
     _NO_SPECIAL_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);
 
     _NO_SPECIAL_PTR_REG_mask = _ALL_REG_mask;
     _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_NON_ALLOCATABLE_REG_mask);
 
-    // r27 is not allocatable when compressed oops is on, compressed klass
-    // pointers doesn't use r27 after JDK-8234794
-    if (UseCompressedOops) {
+    // r27 is not allocatable when compressed oops is on and heapbase is not
+    // zero, compressed klass pointers doesn't use r27 after JDK-8234794
+    if (UseCompressedOops && CompressedOops::ptrs_base() != NULL) {
       _NO_SPECIAL_REG32_mask.Remove(OptoReg::as_OptoReg(r27->as_VMReg()));
       _NO_SPECIAL_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);
       _NO_SPECIAL_PTR_REG_mask.SUBTRACT(_HEAPBASE_REG_mask);
     }
 
@@ -2182,19 +2182,10 @@
   }
   ShouldNotReachHere();
   return 0;
 }
 
-const uint Matcher::vector_shift_count_ideal_reg(int size) {
-  switch(size) {
-    case  8: return Op_VecD;
-    case 16: return Op_VecX;
-  }
-  ShouldNotReachHere();
-  return 0;
-}
-
 // AES support not yet implemented
 const bool Matcher::pass_original_key_for_aes() {
   return false;
 }
 
@@ -2225,11 +2216,11 @@
 const bool Matcher::need_masked_shift_count = false;
 
 // No support for generic vector operands.
 const bool Matcher::supports_generic_vector_operands  = false;
 
-MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
+MachOper* Matcher::pd_specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
   ShouldNotReachHere(); // generic vector operands not supported
   return NULL;
 }
 
 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
@@ -7497,23 +7488,21 @@
   ins_encode(aarch64_enc_strw(src, mem));
 
   ins_pipe(istore_reg_mem);
 %}
 
-instruct storeImmN0(iRegIHeapbase heapbase, immN0 zero, memory4 mem)
+instruct storeImmN0(immN0 zero, memory4 mem)
 %{
   match(Set mem (StoreN mem zero));
-  predicate(CompressedOops::base() == NULL &&
-            CompressedKlassPointers::base() == NULL &&
-            (!needs_releasing_store(n)));
+  predicate(!needs_releasing_store(n));
 
   ins_cost(INSN_COST);
-  format %{ "strw  rheapbase, $mem\t# compressed ptr (rheapbase==0)" %}
+  format %{ "strw  zr, $mem\t# compressed ptr" %}
 
-  ins_encode(aarch64_enc_strw(heapbase, mem));
+  ins_encode(aarch64_enc_strw0(mem));
 
-  ins_pipe(istore_reg_mem);
+  ins_pipe(istore_mem);
 %}
 
 // Store Float
 instruct storeF(vRegF src, memory4 mem)
 %{
@@ -8507,21 +8496,10 @@
   ins_encode(/* empty encoding */);
   ins_cost(0);
   ins_pipe(pipe_class_empty);
 %}
 
-instruct castLL(iRegL dst)
-%{
-  match(Set dst (CastLL dst));
-
-  size(0);
-  format %{ "# castLL of $dst" %}
-  ins_encode(/* empty encoding */);
-  ins_cost(0);
-  ins_pipe(pipe_class_empty);
-%}
-
 // ============================================================================
 // Atomic operation instructions
 //
 // Intel and SPARC both implement Ideal Node LoadPLocked and
 // Store{PIL}Conditional instructions using a normal load for the
@@ -16073,322 +16051,322 @@
   ins_pipe(vdup_reg_dreg128);
 %}
 
 // ====================REDUCTION ARITHMETIC====================================
 
-instruct reduce_add2I(iRegINoSp dst, iRegIorL2I src1, vecD src2, iRegINoSp tmp, iRegINoSp tmp2)
+instruct reduce_add2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp, iRegINoSp tmp2)
 %{
-  match(Set dst (AddReductionVI src1 src2));
+  match(Set dst (AddReductionVI isrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP tmp, TEMP tmp2);
-  format %{ "umov  $tmp, $src2, S, 0\n\t"
-            "umov  $tmp2, $src2, S, 1\n\t"
-            "addw  $tmp, $src1, $tmp\n\t"
+  format %{ "umov  $tmp, $vsrc, S, 0\n\t"
+            "umov  $tmp2, $vsrc, S, 1\n\t"
+            "addw  $tmp, $isrc, $tmp\n\t"
             "addw  $dst, $tmp, $tmp2\t# add reduction2I"
   %}
   ins_encode %{
-    __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 0);
-    __ umov($tmp2$$Register, as_FloatRegister($src2$$reg), __ S, 1);
-    __ addw($tmp$$Register, $src1$$Register, $tmp$$Register);
+    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);
+    __ umov($tmp2$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);
+    __ addw($tmp$$Register, $isrc$$Register, $tmp$$Register);
     __ addw($dst$$Register, $tmp$$Register, $tmp2$$Register);
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_add4I(iRegINoSp dst, iRegIorL2I src1, vecX src2, vecX tmp, iRegINoSp tmp2)
+instruct reduce_add4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)
 %{
-  match(Set dst (AddReductionVI src1 src2));
+  match(Set dst (AddReductionVI isrc vsrc));
   ins_cost(INSN_COST);
-  effect(TEMP tmp, TEMP tmp2);
-  format %{ "addv  $tmp, T4S, $src2\n\t"
-            "umov  $tmp2, $tmp, S, 0\n\t"
-            "addw  $dst, $tmp2, $src1\t# add reduction4I"
+  effect(TEMP vtmp, TEMP itmp);
+  format %{ "addv  $vtmp, T4S, $vsrc\n\t"
+            "umov  $itmp, $vtmp, S, 0\n\t"
+            "addw  $dst, $itmp, $isrc\t# add reduction4I"
   %}
   ins_encode %{
-    __ addv(as_FloatRegister($tmp$$reg), __ T4S,
-            as_FloatRegister($src2$$reg));
-    __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 0);
-    __ addw($dst$$Register, $tmp2$$Register, $src1$$Register);
+    __ addv(as_FloatRegister($vtmp$$reg), __ T4S,
+            as_FloatRegister($vsrc$$reg));
+    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);
+    __ addw($dst$$Register, $itmp$$Register, $isrc$$Register);
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_mul2I(iRegINoSp dst, iRegIorL2I src1, vecD src2, iRegINoSp tmp)
+instruct reduce_mul2I(iRegINoSp dst, iRegIorL2I isrc, vecD vsrc, iRegINoSp tmp)
 %{
-  match(Set dst (MulReductionVI src1 src2));
+  match(Set dst (MulReductionVI isrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP tmp, TEMP dst);
-  format %{ "umov  $tmp, $src2, S, 0\n\t"
-            "mul   $dst, $tmp, $src1\n\t"
-            "umov  $tmp, $src2, S, 1\n\t"
+  format %{ "umov  $tmp, $vsrc, S, 0\n\t"
+            "mul   $dst, $tmp, $isrc\n\t"
+            "umov  $tmp, $vsrc, S, 1\n\t"
             "mul   $dst, $tmp, $dst\t# mul reduction2I"
   %}
   ins_encode %{
-    __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 0);
-    __ mul($dst$$Register, $tmp$$Register, $src1$$Register);
-    __ umov($tmp$$Register, as_FloatRegister($src2$$reg), __ S, 1);
+    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 0);
+    __ mul($dst$$Register, $tmp$$Register, $isrc$$Register);
+    __ umov($tmp$$Register, as_FloatRegister($vsrc$$reg), __ S, 1);
     __ mul($dst$$Register, $tmp$$Register, $dst$$Register);
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_mul4I(iRegINoSp dst, iRegIorL2I src1, vecX src2, vecX tmp, iRegINoSp tmp2)
+instruct reduce_mul4I(iRegINoSp dst, iRegIorL2I isrc, vecX vsrc, vecX vtmp, iRegINoSp itmp)
 %{
-  match(Set dst (MulReductionVI src1 src2));
+  match(Set dst (MulReductionVI isrc vsrc));
   ins_cost(INSN_COST);
-  effect(TEMP tmp, TEMP tmp2, TEMP dst);
-  format %{ "ins   $tmp, $src2, 0, 1\n\t"
-            "mul   $tmp, $tmp, $src2\n\t"
-            "umov  $tmp2, $tmp, S, 0\n\t"
-            "mul   $dst, $tmp2, $src1\n\t"
-            "umov  $tmp2, $tmp, S, 1\n\t"
-            "mul   $dst, $tmp2, $dst\t# mul reduction4I"
+  effect(TEMP vtmp, TEMP itmp, TEMP dst);
+  format %{ "ins   $vtmp, D, $vsrc, 0, 1\n\t"
+            "mulv  $vtmp, T2S, $vtmp, $vsrc\n\t"
+            "umov  $itmp, $vtmp, S, 0\n\t"
+            "mul   $dst, $itmp, $isrc\n\t"
+            "umov  $itmp, $vtmp, S, 1\n\t"
+            "mul   $dst, $itmp, $dst\t# mul reduction4I"
   %}
   ins_encode %{
-    __ ins(as_FloatRegister($tmp$$reg), __ D,
-           as_FloatRegister($src2$$reg), 0, 1);
-    __ mulv(as_FloatRegister($tmp$$reg), __ T2S,
-           as_FloatRegister($tmp$$reg), as_FloatRegister($src2$$reg));
-    __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 0);
-    __ mul($dst$$Register, $tmp2$$Register, $src1$$Register);
-    __ umov($tmp2$$Register, as_FloatRegister($tmp$$reg), __ S, 1);
-    __ mul($dst$$Register, $tmp2$$Register, $dst$$Register);
+    __ ins(as_FloatRegister($vtmp$$reg), __ D,
+           as_FloatRegister($vsrc$$reg), 0, 1);
+    __ mulv(as_FloatRegister($vtmp$$reg), __ T2S,
+            as_FloatRegister($vtmp$$reg), as_FloatRegister($vsrc$$reg));
+    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 0);
+    __ mul($dst$$Register, $itmp$$Register, $isrc$$Register);
+    __ umov($itmp$$Register, as_FloatRegister($vtmp$$reg), __ S, 1);
+    __ mul($dst$$Register, $itmp$$Register, $dst$$Register);
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_add2F(vRegF dst, vRegF src1, vecD src2, vecD tmp)
+instruct reduce_add2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)
 %{
-  match(Set dst (AddReductionVF src1 src2));
+  match(Set dst (AddReductionVF fsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP tmp, TEMP dst);
-  format %{ "fadds $dst, $src1, $src2\n\t"
-            "ins   $tmp, S, $src2, 0, 1\n\t"
+  format %{ "fadds $dst, $fsrc, $vsrc\n\t"
+            "ins   $tmp, S, $vsrc, 0, 1\n\t"
             "fadds $dst, $dst, $tmp\t# add reduction2F"
   %}
   ins_encode %{
     __ fadds(as_FloatRegister($dst$$reg),
-             as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
+             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));
     __ ins(as_FloatRegister($tmp$$reg), __ S,
-           as_FloatRegister($src2$$reg), 0, 1);
+           as_FloatRegister($vsrc$$reg), 0, 1);
     __ fadds(as_FloatRegister($dst$$reg),
              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_add4F(vRegF dst, vRegF src1, vecX src2, vecX tmp)
+instruct reduce_add4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)
 %{
-  match(Set dst (AddReductionVF src1 src2));
+  match(Set dst (AddReductionVF fsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP tmp, TEMP dst);
-  format %{ "fadds $dst, $src1, $src2\n\t"
-            "ins   $tmp, S, $src2, 0, 1\n\t"
+  format %{ "fadds $dst, $fsrc, $vsrc\n\t"
+            "ins   $tmp, S, $vsrc, 0, 1\n\t"
             "fadds $dst, $dst, $tmp\n\t"
-            "ins   $tmp, S, $src2, 0, 2\n\t"
+            "ins   $tmp, S, $vsrc, 0, 2\n\t"
             "fadds $dst, $dst, $tmp\n\t"
-            "ins   $tmp, S, $src2, 0, 3\n\t"
+            "ins   $tmp, S, $vsrc, 0, 3\n\t"
             "fadds $dst, $dst, $tmp\t# add reduction4F"
   %}
   ins_encode %{
     __ fadds(as_FloatRegister($dst$$reg),
-             as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
+             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));
     __ ins(as_FloatRegister($tmp$$reg), __ S,
-           as_FloatRegister($src2$$reg), 0, 1);
+           as_FloatRegister($vsrc$$reg), 0, 1);
     __ fadds(as_FloatRegister($dst$$reg),
              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
     __ ins(as_FloatRegister($tmp$$reg), __ S,
-           as_FloatRegister($src2$$reg), 0, 2);
+           as_FloatRegister($vsrc$$reg), 0, 2);
     __ fadds(as_FloatRegister($dst$$reg),
              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
     __ ins(as_FloatRegister($tmp$$reg), __ S,
-           as_FloatRegister($src2$$reg), 0, 3);
+           as_FloatRegister($vsrc$$reg), 0, 3);
     __ fadds(as_FloatRegister($dst$$reg),
              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_mul2F(vRegF dst, vRegF src1, vecD src2, vecD tmp)
+instruct reduce_mul2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp)
 %{
-  match(Set dst (MulReductionVF src1 src2));
+  match(Set dst (MulReductionVF fsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP tmp, TEMP dst);
-  format %{ "fmuls $dst, $src1, $src2\n\t"
-            "ins   $tmp, S, $src2, 0, 1\n\t"
+  format %{ "fmuls $dst, $fsrc, $vsrc\n\t"
+            "ins   $tmp, S, $vsrc, 0, 1\n\t"
             "fmuls $dst, $dst, $tmp\t# mul reduction2F"
   %}
   ins_encode %{
     __ fmuls(as_FloatRegister($dst$$reg),
-             as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
+             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));
     __ ins(as_FloatRegister($tmp$$reg), __ S,
-           as_FloatRegister($src2$$reg), 0, 1);
+           as_FloatRegister($vsrc$$reg), 0, 1);
     __ fmuls(as_FloatRegister($dst$$reg),
              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_mul4F(vRegF dst, vRegF src1, vecX src2, vecX tmp)
+instruct reduce_mul4F(vRegF dst, vRegF fsrc, vecX vsrc, vecX tmp)
 %{
-  match(Set dst (MulReductionVF src1 src2));
+  match(Set dst (MulReductionVF fsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP tmp, TEMP dst);
-  format %{ "fmuls $dst, $src1, $src2\n\t"
-            "ins   $tmp, S, $src2, 0, 1\n\t"
+  format %{ "fmuls $dst, $fsrc, $vsrc\n\t"
+            "ins   $tmp, S, $vsrc, 0, 1\n\t"
             "fmuls $dst, $dst, $tmp\n\t"
-            "ins   $tmp, S, $src2, 0, 2\n\t"
+            "ins   $tmp, S, $vsrc, 0, 2\n\t"
             "fmuls $dst, $dst, $tmp\n\t"
-            "ins   $tmp, S, $src2, 0, 3\n\t"
+            "ins   $tmp, S, $vsrc, 0, 3\n\t"
             "fmuls $dst, $dst, $tmp\t# mul reduction4F"
   %}
   ins_encode %{
     __ fmuls(as_FloatRegister($dst$$reg),
-             as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
+             as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));
     __ ins(as_FloatRegister($tmp$$reg), __ S,
-           as_FloatRegister($src2$$reg), 0, 1);
+           as_FloatRegister($vsrc$$reg), 0, 1);
     __ fmuls(as_FloatRegister($dst$$reg),
              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
     __ ins(as_FloatRegister($tmp$$reg), __ S,
-           as_FloatRegister($src2$$reg), 0, 2);
+           as_FloatRegister($vsrc$$reg), 0, 2);
     __ fmuls(as_FloatRegister($dst$$reg),
              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
     __ ins(as_FloatRegister($tmp$$reg), __ S,
-           as_FloatRegister($src2$$reg), 0, 3);
+           as_FloatRegister($vsrc$$reg), 0, 3);
     __ fmuls(as_FloatRegister($dst$$reg),
              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_add2D(vRegD dst, vRegD src1, vecX src2, vecX tmp)
+instruct reduce_add2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)
 %{
-  match(Set dst (AddReductionVD src1 src2));
+  match(Set dst (AddReductionVD dsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP tmp, TEMP dst);
-  format %{ "faddd $dst, $src1, $src2\n\t"
-            "ins   $tmp, D, $src2, 0, 1\n\t"
+  format %{ "faddd $dst, $dsrc, $vsrc\n\t"
+            "ins   $tmp, D, $vsrc, 0, 1\n\t"
             "faddd $dst, $dst, $tmp\t# add reduction2D"
   %}
   ins_encode %{
     __ faddd(as_FloatRegister($dst$$reg),
-             as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
+             as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));
     __ ins(as_FloatRegister($tmp$$reg), __ D,
-           as_FloatRegister($src2$$reg), 0, 1);
+           as_FloatRegister($vsrc$$reg), 0, 1);
     __ faddd(as_FloatRegister($dst$$reg),
              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_mul2D(vRegD dst, vRegD src1, vecX src2, vecX tmp)
+instruct reduce_mul2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp)
 %{
-  match(Set dst (MulReductionVD src1 src2));
+  match(Set dst (MulReductionVD dsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP tmp, TEMP dst);
-  format %{ "fmuld $dst, $src1, $src2\n\t"
-            "ins   $tmp, D, $src2, 0, 1\n\t"
+  format %{ "fmuld $dst, $dsrc, $vsrc\n\t"
+            "ins   $tmp, D, $vsrc, 0, 1\n\t"
             "fmuld $dst, $dst, $tmp\t# mul reduction2D"
   %}
   ins_encode %{
     __ fmuld(as_FloatRegister($dst$$reg),
-             as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
+             as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));
     __ ins(as_FloatRegister($tmp$$reg), __ D,
-           as_FloatRegister($src2$$reg), 0, 1);
+           as_FloatRegister($vsrc$$reg), 0, 1);
     __ fmuld(as_FloatRegister($dst$$reg),
              as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_max2F(vRegF dst, vRegF src1, vecD src2, vecD tmp) %{
+instruct reduce_max2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp) %{
   predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
-  match(Set dst (MaxReductionV src1 src2));
+  match(Set dst (MaxReductionV fsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP_DEF dst, TEMP tmp);
-  format %{ "fmaxs $dst, $src1, $src2\n\t"
-            "ins   $tmp, S, $src2, 0, 1\n\t"
+  format %{ "fmaxs $dst, $fsrc, $vsrc\n\t"
+            "ins   $tmp, S, $vsrc, 0, 1\n\t"
             "fmaxs $dst, $dst, $tmp\t# max reduction2F" %}
   ins_encode %{
-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
-    __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($src2$$reg), 0, 1);
+    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));
+    __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($vsrc$$reg), 0, 1);
     __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_max4F(vRegF dst, vRegF src1, vecX src2) %{
+instruct reduce_max4F(vRegF dst, vRegF fsrc, vecX vsrc) %{
   predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
-  match(Set dst (MaxReductionV src1 src2));
+  match(Set dst (MaxReductionV fsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP_DEF dst);
-  format %{ "fmaxv $dst, T4S, $src2\n\t"
-            "fmaxs $dst, $dst, $src1\t# max reduction4F" %}
+  format %{ "fmaxv $dst, T4S, $vsrc\n\t"
+            "fmaxs $dst, $dst, $fsrc\t# max reduction4F" %}
   ins_encode %{
-    __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src2$$reg));
-    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
+    __ fmaxv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));
+    __ fmaxs(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_max2D(vRegD dst, vRegD src1, vecX src2, vecX tmp) %{
+instruct reduce_max2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp) %{
   predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
-  match(Set dst (MaxReductionV src1 src2));
+  match(Set dst (MaxReductionV dsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP_DEF dst, TEMP tmp);
-  format %{ "fmaxd $dst, $src1, $src2\n\t"
-            "ins   $tmp, D, $src2, 0, 1\n\t"
+  format %{ "fmaxd $dst, $dsrc, $vsrc\n\t"
+            "ins   $tmp, D, $vsrc, 0, 1\n\t"
             "fmaxd $dst, $dst, $tmp\t# max reduction2D" %}
   ins_encode %{
-    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
-    __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($src2$$reg), 0, 1);
+    __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));
+    __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($vsrc$$reg), 0, 1);
     __ fmaxd(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_min2F(vRegF dst, vRegF src1, vecD src2, vecD tmp) %{
+instruct reduce_min2F(vRegF dst, vRegF fsrc, vecD vsrc, vecD tmp) %{
   predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
-  match(Set dst (MinReductionV src1 src2));
+  match(Set dst (MinReductionV fsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP_DEF dst, TEMP tmp);
-  format %{ "fmins $dst, $src1, $src2\n\t"
-            "ins   $tmp, S, $src2, 0, 1\n\t"
+  format %{ "fmins $dst, $fsrc, $vsrc\n\t"
+            "ins   $tmp, S, $vsrc, 0, 1\n\t"
             "fmins $dst, $dst, $tmp\t# min reduction2F" %}
   ins_encode %{
-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
-    __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($src2$$reg), 0, 1);
+    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg), as_FloatRegister($vsrc$$reg));
+    __ ins(as_FloatRegister($tmp$$reg), __ S, as_FloatRegister($vsrc$$reg), 0, 1);
     __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_min4F(vRegF dst, vRegF src1, vecX src2) %{
+instruct reduce_min4F(vRegF dst, vRegF fsrc, vecX vsrc) %{
   predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);
-  match(Set dst (MinReductionV src1 src2));
+  match(Set dst (MinReductionV fsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP_DEF dst);
-  format %{ "fminv $dst, T4S, $src2\n\t"
-            "fmins $dst, $dst, $src1\t# min reduction4F" %}
+  format %{ "fminv $dst, T4S, $vsrc\n\t"
+            "fmins $dst, $dst, $fsrc\t# min reduction4F" %}
   ins_encode %{
-    __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($src2$$reg));
-    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg));
+    __ fminv(as_FloatRegister($dst$$reg), __ T4S, as_FloatRegister($vsrc$$reg));
+    __ fmins(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($fsrc$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
-instruct reduce_min2D(vRegD dst, vRegD src1, vecX src2, vecX tmp) %{
+instruct reduce_min2D(vRegD dst, vRegD dsrc, vecX vsrc, vecX tmp) %{
   predicate(n->in(2)->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);
-  match(Set dst (MinReductionV src1 src2));
+  match(Set dst (MinReductionV dsrc vsrc));
   ins_cost(INSN_COST);
   effect(TEMP_DEF dst, TEMP tmp);
-  format %{ "fmind $dst, $src1, $src2\n\t"
-            "ins   $tmp, D, $src2, 0, 1\n\t"
+  format %{ "fmind $dst, $dsrc, $vsrc\n\t"
+            "ins   $tmp, D, $vsrc, 0, 1\n\t"
             "fmind $dst, $dst, $tmp\t# min reduction2D" %}
   ins_encode %{
-    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));
-    __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($src2$$reg), 0, 1);
+    __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dsrc$$reg), as_FloatRegister($vsrc$$reg));
+    __ ins(as_FloatRegister($tmp$$reg), __ D, as_FloatRegister($vsrc$$reg), 0, 1);
     __ fmind(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), as_FloatRegister($tmp$$reg));
   %}
   ins_pipe(pipe_class_default);
 %}
 
@@ -17629,11 +17607,11 @@
 %}
 
 instruct vsra4S_imm(vecD dst, vecD src, immI shift) %{
   predicate(n->as_Vector()->length() == 2 ||
             n->as_Vector()->length() == 4);
-  match(Set dst (RShiftVS src (LShiftCntV shift)));
+  match(Set dst (RShiftVS src (RShiftCntV shift)));
   ins_cost(INSN_COST);
   format %{ "sshr    $dst, $src, $shift\t# vector (4H)" %}
   ins_encode %{
     int sh = (int)$shift$$constant;
     if (sh >= 16) sh = 15;
@@ -17643,11 +17621,11 @@
   ins_pipe(vshift64_imm);
 %}
 
 instruct vsra8S_imm(vecX dst, vecX src, immI shift) %{
   predicate(n->as_Vector()->length() == 8);
-  match(Set dst (RShiftVS src (LShiftCntV shift)));
+  match(Set dst (RShiftVS src (RShiftCntV shift)));
   ins_cost(INSN_COST);
   format %{ "sshr    $dst, $src, $shift\t# vector (8H)" %}
   ins_encode %{
     int sh = (int)$shift$$constant;
     if (sh >= 16) sh = 15;
diff a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
--- a/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
+++ b/src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp
@@ -2229,10 +2229,14 @@
 #ifdef ASSERT
 void MacroAssembler::verify_heapbase(const char* msg) {
 #if 0
   assert (UseCompressedOops || UseCompressedClassPointers, "should be compressed");
   assert (Universe::heap() != NULL, "java heap should be initialized");
+  if (!UseCompressedOops || Universe::ptr_base() == NULL) {
+    // rheapbase is allocated as general register
+    return;
+  }
   if (CheckCompressedOops) {
     Label ok;
     push(1 << rscratch1->encoding(), sp); // cmpptr trashes rscratch1
     cmpptr(rheapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
     br(Assembler::EQ, ok);
diff a/src/hotspot/cpu/ppc/globals_ppc.hpp b/src/hotspot/cpu/ppc/globals_ppc.hpp
--- a/src/hotspot/cpu/ppc/globals_ppc.hpp
+++ b/src/hotspot/cpu/ppc/globals_ppc.hpp
@@ -1,8 +1,8 @@
 /*
  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
+ * Copyright (c) 2012, 2020 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -113,10 +113,12 @@
                                                                             \
   product(bool, UseLoadInstructionsForStackBangingPPC64, false,             \
           "Use load instructions for stack banging.")                       \
                                                                             \
   /* special instructions */                                                \
+  product(bool, UseVectorByteReverseInstructionsPPC64, false,               \
+          "Use Power9 xxbr* vector byte reverse instructions.")             \
                                                                             \
   product(bool, UseCountLeadingZerosInstructionsPPC64, true,                \
           "Use count leading zeros instructions.")                          \
                                                                             \
   product(bool, UseCountTrailingZerosInstructionsPPC64, false,              \
diff a/src/hotspot/cpu/x86/methodHandles_x86.cpp b/src/hotspot/cpu/x86/methodHandles_x86.cpp
--- a/src/hotspot/cpu/x86/methodHandles_x86.cpp
+++ b/src/hotspot/cpu/x86/methodHandles_x86.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -27,10 +27,11 @@
 #include "asm/macroAssembler.hpp"
 #include "compiler/disassembler.hpp"
 #include "classfile/javaClasses.inline.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/interpreterRuntime.hpp"
+#include "logging/log.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/resourceArea.hpp"
 #include "prims/methodHandles.hpp"
 #include "runtime/flags/flagSetting.hpp"
 #include "runtime/frame.inline.hpp"
@@ -596,11 +597,11 @@
                            args->saved_regs,
                            args->entry_sp);
 }
 
 void MethodHandles::trace_method_handle(MacroAssembler* _masm, const char* adaptername) {
-  if (!TraceMethodHandles)  return;
+  if (!log_is_enabled(Info, methodhandles))  return;
   BLOCK_COMMENT(err_msg("trace_method_handle %s {", adaptername));
   __ enter();
   __ andptr(rsp, -16); // align stack if needed for FPU state
   __ pusha();
   __ mov(rbx, rsp); // for retreiving saved_regs
diff a/src/hotspot/cpu/x86/x86_32.ad b/src/hotspot/cpu/x86/x86_32.ad
--- a/src/hotspot/cpu/x86/x86_32.ad
+++ b/src/hotspot/cpu/x86/x86_32.ad
@@ -7232,19 +7232,10 @@
   ins_encode( /*empty encoding*/ );
   ins_cost(0);
   ins_pipe( empty );
 %}
 
-instruct castLL( eRegL dst ) %{
-  match(Set dst (CastLL dst));
-  format %{ "#castLL of $dst" %}
-  ins_encode( /*empty encoding*/ );
-  ins_cost(0);
-  ins_pipe( empty );
-%}
-
-
 // Load-locked - same as a regular pointer load when used with compare-swap
 instruct loadPLocked(eRegP dst, memory mem) %{
   match(Set dst (LoadPLocked mem));
 
   ins_cost(125);
diff a/src/hotspot/cpu/x86/x86_64.ad b/src/hotspot/cpu/x86/x86_64.ad
--- a/src/hotspot/cpu/x86/x86_64.ad
+++ b/src/hotspot/cpu/x86/x86_64.ad
@@ -7550,21 +7550,10 @@
   ins_encode(/* empty encoding */);
   ins_cost(0);
   ins_pipe(empty);
 %}
 
-instruct castLL(rRegL dst)
-%{
-  match(Set dst (CastLL dst));
-
-  size(0);
-  format %{ "# castLL of $dst" %}
-  ins_encode(/* empty encoding */);
-  ins_cost(0);
-  ins_pipe(empty);
-%}
-
 // LoadP-locked same as a regular LoadP when used with compare-swap
 instruct loadPLocked(rRegP dst, memory mem)
 %{
   match(Set dst (LoadPLocked mem));
 
diff a/src/hotspot/share/c1/c1_LinearScan.cpp b/src/hotspot/share/c1/c1_LinearScan.cpp
--- a/src/hotspot/share/c1/c1_LinearScan.cpp
+++ b/src/hotspot/share/c1/c1_LinearScan.cpp
@@ -235,15 +235,11 @@
     _max_spills++;
   }
 
   int result = spill_slot + LinearScan::nof_regs + frame_map()->argcount();
 
-  // the class OopMapValue uses only 11 bits for storing the name of the
-  // oop location. So a stack slot bigger than 2^11 leads to an overflow
-  // that is not reported in product builds. Prevent this by checking the
-  // spill slot here (altough this value and the later used location name
-  // are slightly different)
+  // if too many slots used, bailout compilation.
   if (result > 2000) {
     bailout("too many stack slots used");
   }
 
   return result;
diff a/src/hotspot/share/c1/c1_Runtime1.cpp b/src/hotspot/share/c1/c1_Runtime1.cpp
--- a/src/hotspot/share/c1/c1_Runtime1.cpp
+++ b/src/hotspot/share/c1/c1_Runtime1.cpp
@@ -812,34 +812,26 @@
   ResourceMark rm(thread);
   SharedRuntime::throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IllegalMonitorStateException());
 JRT_END
 
 
-JRT_ENTRY_NO_ASYNC(void, Runtime1::monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock))
+JRT_BLOCK_ENTRY(void, Runtime1::monitorenter(JavaThread* thread, oopDesc* obj, BasicObjectLock* lock))
   NOT_PRODUCT(_monitorenter_slowcase_cnt++;)
-  if (PrintBiasedLockingStatistics) {
-    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
-  }
-  Handle h_obj(thread, obj);
   if (!UseFastLocking) {
     lock->set_obj(obj);
   }
   assert(obj == lock->obj(), "must match");
-  ObjectSynchronizer::enter(h_obj, lock->lock(), THREAD);
+  SharedRuntime::monitor_enter_helper(obj, lock->lock(), thread);
 JRT_END
 
 
 JRT_LEAF(void, Runtime1::monitorexit(JavaThread* thread, BasicObjectLock* lock))
   NOT_PRODUCT(_monitorexit_slowcase_cnt++;)
-  assert(thread == JavaThread::current(), "threads must correspond");
-  assert(thread->last_Java_sp(), "last_Java_sp must be set");
-  // monitorexit is non-blocking (leaf routine) => no exceptions can be thrown
-  EXCEPTION_MARK;
 
   oop obj = lock->obj();
   assert(oopDesc::is_oop(obj), "must be NULL or an object");
-  ObjectSynchronizer::exit(obj, lock->lock(), THREAD);
+  SharedRuntime::monitor_exit_helper(obj, lock->lock(), thread);
 JRT_END
 
 // Cf. OptoRuntime::deoptimize_caller_frame
 JRT_ENTRY(void, Runtime1::deoptimize(JavaThread* thread, jint trap_request))
   // Called from within the owner thread, so no need for safepoint
diff a/src/hotspot/share/ci/bcEscapeAnalyzer.cpp b/src/hotspot/share/ci/bcEscapeAnalyzer.cpp
--- a/src/hotspot/share/ci/bcEscapeAnalyzer.cpp
+++ b/src/hotspot/share/ci/bcEscapeAnalyzer.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -78,11 +78,10 @@
   void add(uint var)                    { _bits |= int_to_bit(var); }
   void add_unknown()                    { _bits = UNKNOWN; }
   void add_allocated()                  { _bits = ALLOCATED; }
   void set_union(const ArgumentMap &am)     { _bits |= am._bits; }
   void set_difference(const ArgumentMap &am) { _bits &=  ~am._bits; }
-  void operator=(const ArgumentMap &am) { _bits = am._bits; }
   bool operator==(const ArgumentMap &am) { return _bits == am._bits; }
   bool operator!=(const ArgumentMap &am) { return _bits != am._bits; }
 };
 
 class BCEscapeAnalyzer::StateInfo {
diff a/src/hotspot/share/ci/ciField.cpp b/src/hotspot/share/ci/ciField.cpp
--- a/src/hotspot/share/ci/ciField.cpp
+++ b/src/hotspot/share/ci/ciField.cpp
@@ -247,13 +247,14 @@
   // Even if general trusting is disabled, trust system-built closures in these packages.
   if (holder->is_in_package("java/lang/invoke") || holder->is_in_package("sun/invoke") ||
       holder->is_in_package("jdk/internal/foreign") || holder->is_in_package("jdk/incubator/foreign") ||
       holder->is_in_package("java/lang"))
     return true;
-  // Trust VM unsafe anonymous classes. They are private API (jdk.internal.misc.Unsafe)
-  // and can't be serialized, so there is no hacking of finals going on with them.
-  if (holder->is_unsafe_anonymous())
+  // Trust hidden classes and VM unsafe anonymous classes. They are created via
+  // Lookup.defineHiddenClass or the private jdk.internal.misc.Unsafe API and
+  // can't be serialized, so there is no hacking of finals going on with them.
+  if (holder->is_hidden() || holder->is_unsafe_anonymous())
     return true;
   // Trust final fields in all boxed classes
   if (holder->is_box_klass())
     return true;
   // Trust final fields in String
diff a/src/hotspot/share/ci/ciInstanceKlass.cpp b/src/hotspot/share/ci/ciInstanceKlass.cpp
--- a/src/hotspot/share/ci/ciInstanceKlass.cpp
+++ b/src/hotspot/share/ci/ciInstanceKlass.cpp
@@ -63,27 +63,28 @@
   _init_state = ik->init_state();
   _nonstatic_field_size = ik->nonstatic_field_size();
   _has_nonstatic_fields = ik->has_nonstatic_fields();
   _has_nonstatic_concrete_methods = ik->has_nonstatic_concrete_methods();
   _is_unsafe_anonymous = ik->is_unsafe_anonymous();
-  _nonstatic_fields = NULL;            // initialized lazily by compute_nonstatic_fields
+  _is_hidden = ik->is_hidden();
+  _nonstatic_fields = NULL; // initialized lazily by compute_nonstatic_fields:
   _has_injected_fields = -1;
   _implementor = NULL; // we will fill these lazily
 
   // Ensure that the metadata wrapped by the ciMetadata is kept alive by GC.
   // This is primarily useful for metadata which is considered as weak roots
   // by the GC but need to be strong roots if reachable from a current compilation.
   // InstanceKlass are created for both weak and strong metadata.  Ensuring this metadata
   // alive covers the cases where there are weak roots without performance cost.
   oop holder = ik->klass_holder();
-  if (ik->is_unsafe_anonymous()) {
+  if (ik->class_loader_data()->has_class_mirror_holder()) {
     // Though ciInstanceKlass records class loader oop, it's not enough to keep
-    // VM unsafe anonymous classes alive (loader == NULL). Klass holder should
+    // non-strong hidden classes and VM unsafe anonymous classes alive (loader == NULL). Klass holder should
     // be used instead. It is enough to record a ciObject, since cached elements are never removed
     // during ciObjectFactory lifetime. ciObjectFactory itself is created for
     // every compilation and lives for the whole duration of the compilation.
-    assert(holder != NULL, "holder of unsafe anonymous class is the mirror which is never null");
+    assert(holder != NULL, "holder of hidden or unsafe anonymous class is the mirror which is never null");
     (void)CURRENT_ENV->get_object(holder);
   }
 
   Thread *thread = Thread::current();
   if (ciObjectFactory::is_initialized()) {
@@ -124,10 +125,11 @@
   _nonstatic_field_size = -1;
   _has_nonstatic_fields = false;
   _nonstatic_fields = NULL;            // initialized lazily by compute_nonstatic_fields
   _has_injected_fields = -1;
   _is_unsafe_anonymous = false;
+  _is_hidden = false;
   _loader = loader;
   _protection_domain = protection_domain;
   _is_shared = false;
   _super = NULL;
   _java_mirror = NULL;
diff a/src/hotspot/share/ci/ciInstanceKlass.hpp b/src/hotspot/share/ci/ciInstanceKlass.hpp
--- a/src/hotspot/share/ci/ciInstanceKlass.hpp
+++ b/src/hotspot/share/ci/ciInstanceKlass.hpp
@@ -54,10 +54,11 @@
   bool                   _has_finalizer;
   SubklassValue          _has_subklass;
   bool                   _has_nonstatic_fields;
   bool                   _has_nonstatic_concrete_methods;
   bool                   _is_unsafe_anonymous;
+  bool                   _is_hidden;
 
   ciFlags                _flags;
   jint                   _nonstatic_field_size;
   jint                   _nonstatic_oop_map_size;
 
@@ -190,14 +191,18 @@
   bool has_nonstatic_concrete_methods()  {
     assert(is_loaded(), "must be loaded");
     return _has_nonstatic_concrete_methods;
   }
 
-  bool is_unsafe_anonymous() {
+  bool is_unsafe_anonymous() const {
     return _is_unsafe_anonymous;
   }
 
+  bool is_hidden() const {
+    return _is_hidden;
+  }
+
   ciInstanceKlass* get_canonical_holder(int offset);
   ciField* get_field_by_offset(int field_offset, bool is_static);
   ciField* get_field_by_name(ciSymbol* name, ciSymbol* signature, bool is_static);
   // get field descriptor at field_offset ignoring flattening
   ciField* get_non_flattened_field_by_offset(int field_offset);
diff a/src/hotspot/share/classfile/classFileParser.cpp b/src/hotspot/share/classfile/classFileParser.cpp
--- a/src/hotspot/share/classfile/classFileParser.cpp
+++ b/src/hotspot/share/classfile/classFileParser.cpp
@@ -1139,11 +1139,11 @@
     : _location(location), _annotations_present(0)
   {
     assert((int)_annotation_LIMIT <= (int)sizeof(_annotations_present) * BitsPerByte, "");
   }
   // If this annotation name has an ID, report it (or _none).
-  ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name);
+  ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name, bool can_access_vm_annotations);
   // Set the annotation name:
   void set_annotation(ID id) {
     assert((int)id >= 0 && (int)id < (int)_annotation_LIMIT, "oob");
     _annotations_present |= nth_bit((int)id);
   }
@@ -1272,10 +1272,11 @@
 // Sift through annotations, looking for those significant to the VM:
 static void parse_annotations(const ConstantPool* const cp,
                               const u1* buffer, int limit,
                               AnnotationCollector* coll,
                               ClassLoaderData* loader_data,
+                              const bool can_access_vm_annotations,
                               TRAPS) {
 
   assert(cp != NULL, "invariant");
   assert(buffer != NULL, "invariant");
   assert(coll != NULL, "invariant");
@@ -1317,11 +1318,11 @@
       member = check_symbol_at(cp, member_index);
       if (member == NULL)  break;  // invalid member name
     }
 
     // Here is where parsing particular annotations will take place.
-    AnnotationCollector::ID id = coll->annotation_index(loader_data, aname);
+    AnnotationCollector::ID id = coll->annotation_index(loader_data, aname, can_access_vm_annotations);
     if (AnnotationCollector::_unknown == id)  continue;
     coll->set_annotation(id);
 
     if (AnnotationCollector::_jdk_internal_vm_annotation_Contended == id) {
       // @Contended can optionally specify the contention group.
@@ -1443,10 +1444,11 @@
         parse_annotations(cp,
                           runtime_visible_annotations,
                           runtime_visible_annotations_length,
                           parsed_annotations,
                           _loader_data,
+                          _can_access_vm_annotations,
                           CHECK);
         cfs->skip_u1_fast(runtime_visible_annotations_length);
       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
         if (runtime_invisible_annotations_exists) {
           classfile_parse_error(
@@ -2172,16 +2174,17 @@
       name->as_C_string(), _class_name->as_C_string(), class_note, sig->as_C_string());
 }
 
 AnnotationCollector::ID
 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
-                                      const Symbol* name) {
+                                      const Symbol* name,
+                                      const bool can_access_vm_annotations) {
   const vmSymbols::SID sid = vmSymbols::find_sid(name);
   // Privileged code can use all annotations.  Other code silently drops some.
-  const bool privileged = loader_data->is_the_null_class_loader_data() ||
+  const bool privileged = loader_data->is_boot_class_loader_data() ||
                           loader_data->is_platform_class_loader_data() ||
-                          loader_data->is_unsafe_anonymous();
+                          can_access_vm_annotations;
   switch (sid) {
     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
       if (_location != _in_method)  break;  // only allow for methods
       if (!privileged)              break;  // only allow in privileged code
       return _method_CallerSensitive;
@@ -2827,10 +2830,11 @@
         parse_annotations(cp,
                           runtime_visible_annotations,
                           runtime_visible_annotations_length,
                           &parsed_annotations,
                           _loader_data,
+                          _can_access_vm_annotations,
                           CHECK_NULL);
         cfs->skip_u1_fast(runtime_visible_annotations_length);
       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
         if (runtime_invisible_annotations_exists) {
           classfile_parse_error(
@@ -3021,10 +3025,14 @@
   }
 
   if (parsed_annotations.has_any_annotations())
     parsed_annotations.apply_to(methodHandle(THREAD, m));
 
+  if (is_hidden()) { // Mark methods in hidden classes as 'hidden'.
+    m->set_hidden(true);
+  }
+
   // Copy annotations
   copy_method_annotations(m->constMethod(),
                           runtime_visible_annotations,
                           runtime_visible_annotations_length,
                           runtime_invisible_annotations,
@@ -3760,10 +3768,11 @@
         parse_annotations(cp,
                           runtime_visible_annotations,
                           runtime_visible_annotations_length,
                           parsed_annotations,
                           _loader_data,
+                          _can_access_vm_annotations,
                           CHECK);
         cfs->skip_u1_fast(runtime_visible_annotations_length);
       } else if (tag == vmSymbols::tag_runtime_invisible_annotations()) {
         if (runtime_invisible_annotations_exists) {
           classfile_parse_error(
@@ -6042,20 +6051,26 @@
     } // CheckIntrinsics
 #endif // ASSERT
   }
 }
 
-// Called from a factory method in KlassFactory, not from this file.
-InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {
+InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook,
+                                                      const ClassInstanceInfo& cl_inst_info,
+                                                      TRAPS) {
   if (_klass != NULL) {
     return _klass;
   }
 
   InstanceKlass* const ik =
     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
 
-  fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);
+  if (is_hidden()) {
+    mangle_hidden_class_name(ik);
+  }
+
+  fill_instance_klass(ik, changed_by_loadhook, cl_inst_info, CHECK_NULL);
+
   assert(_klass == ik, "invariant");
 
 
   if (ik->should_store_fingerprint()) {
     ik->store_fingerprint(_stream->compute_fingerprint());
@@ -6116,11 +6131,14 @@
     }
   }
   return false;
 }
 
-void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {
+void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
+                                          bool changed_by_loadhook,
+                                          const ClassInstanceInfo& cl_inst_info,
+                                          TRAPS) {
   assert(ik != NULL, "invariant");
 
   // Set name and CLD before adding to CLD
   ik->set_class_loader_data(_loader_data);
   ik->set_name(_class_name);
@@ -6167,10 +6185,15 @@
 
   // this transfers ownership of a lot of arrays from
   // the parser onto the InstanceKlass*
   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
 
+  // can only set dynamic nest-host after static nest information is set
+  if (cl_inst_info.dynamic_nest_host() != NULL) {
+    ik->set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
+  }
+
   // note that is not safe to use the fields in the parser from this point on
   assert(NULL == _cp, "invariant");
   assert(NULL == _fields, "invariant");
   assert(NULL == _methods, "invariant");
   assert(NULL == _inner_classes, "invariant");
@@ -6191,15 +6214,15 @@
   // has to be changed accordingly.
   ik->set_initial_method_idnum(ik->methods()->length());
 
   ik->set_this_class_index(_this_class_index);
 
-  if (is_unsafe_anonymous()) {
+  if (_is_hidden || is_unsafe_anonymous()) {
     // _this_class_index is a CONSTANT_Class entry that refers to this
-    // anonymous class itself. If this class needs to refer to its own methods or
-    // fields, it would use a CONSTANT_MethodRef, etc, which would reference
-    // _this_class_index. However, because this class is anonymous (it's
+    // hidden or anonymous class itself. If this class needs to refer to its own
+    // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
+    // _this_class_index. However, because this class is hidden or anonymous (it's
     // not stored in SystemDictionary), _this_class_index cannot be resolved
     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
     // Therefore, we must eagerly resolve _this_class_index now.
     ik->constants()->klass_at_put(_this_class_index, ik);
   }
@@ -6214,10 +6237,13 @@
 
   if (_unsafe_anonymous_host != NULL) {
     assert (ik->is_unsafe_anonymous(), "should be the same");
     ik->set_unsafe_anonymous_host(_unsafe_anonymous_host);
   }
+  if (_is_hidden) {
+    ik->set_is_hidden();
+  }
 
   // Set PackageEntry for this_klass
   oop cl = ik->class_loader();
   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
@@ -6293,10 +6319,11 @@
   // The create_mirror() call will also call compute_modifiers()
   java_lang_Class::create_mirror(ik,
                                  Handle(THREAD, _loader_data->class_loader()),
                                  module_handle,
                                  _protection_domain,
+                                 cl_inst_info.class_data(),
                                  CHECK);
 
   assert(_all_mirandas != NULL, "invariant");
 
   // Generate any default methods - default methods are public interface methods
@@ -6415,11 +6442,10 @@
   // Now the ClassFileParser owns this name and will decrement in
   // the destructor.
   _class_name->increment_refcount();
 }
 
-
 // For an unsafe anonymous class that is in the unnamed package, move it to its host class's
 // package by prepending its host class's package name to its class name and setting
 // its _class_name field.
 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
   ResourceMark rm(THREAD);
@@ -6468,12 +6494,12 @@
     }
   }
 }
 
 static bool relax_format_check_for(ClassLoaderData* loader_data) {
-  bool trusted = (loader_data->is_the_null_class_loader_data() ||
-                  SystemDictionary::is_platform_class_loader(loader_data->class_loader()));
+  bool trusted = loader_data->is_boot_class_loader_data() ||
+                 loader_data->is_platform_class_loader_data();
   bool need_verify =
     // verifyAll
     (BytecodeVerificationLocal && BytecodeVerificationRemote) ||
     // verifyRemote
     (!BytecodeVerificationLocal && BytecodeVerificationRemote && !trusted);
@@ -6481,21 +6507,20 @@
 }
 
 ClassFileParser::ClassFileParser(ClassFileStream* stream,
                                  Symbol* name,
                                  ClassLoaderData* loader_data,
-                                 Handle protection_domain,
-                                 const InstanceKlass* unsafe_anonymous_host,
-                                 GrowableArray<Handle>* cp_patches,
+                                 const ClassLoadInfo* cl_info,
                                  Publicity pub_level,
                                  TRAPS) :
   _stream(stream),
-  _requested_name(name),
   _class_name(NULL),
   _loader_data(loader_data),
-  _unsafe_anonymous_host(unsafe_anonymous_host),
-  _cp_patches(cp_patches),
+  _unsafe_anonymous_host(cl_info->unsafe_anonymous_host()),
+  _cp_patches(cl_info->cp_patches()),
+  _is_hidden(cl_info->is_hidden()),
+  _can_access_vm_annotations(cl_info->can_access_vm_annotations()),
   _num_patched_klasses(0),
   _max_num_patched_klasses(0),
   _orig_cp_size(0),
   _first_patched_klass_resolved_index(0),
   _super_klass(),
@@ -6523,11 +6548,11 @@
   _all_mirandas(NULL),
   _vtable_size(0),
   _itable_size(0),
   _num_miranda_methods(0),
   _rt(REF_NONE),
-  _protection_domain(protection_domain),
+  _protection_domain(cl_info->protection_domain()),
   _access_flags(),
   _pub_level(pub_level),
   _bad_constant_seen(0),
   _synthetic_flag(false),
   _sde_length(false),
@@ -6735,14 +6760,19 @@
   guarantee_property(
     cp_size >= 1, "Illegal constant pool size %u in class file %s",
     cp_size, CHECK);
 
   _orig_cp_size = cp_size;
-  if (int(cp_size) + _max_num_patched_klasses > 0xffff) {
-    THROW_MSG(vmSymbols::java_lang_InternalError(), "not enough space for patched classes");
+  if (is_hidden()) { // Add a slot for hidden class name.
+    assert(_max_num_patched_klasses == 0, "Sanity check");
+    cp_size++;
+  } else {
+    if (int(cp_size) + _max_num_patched_klasses > 0xffff) {
+      THROW_MSG(vmSymbols::java_lang_InternalError(), "not enough space for patched classes");
+    }
+    cp_size += _max_num_patched_klasses;
   }
-  cp_size += _max_num_patched_klasses;
 
   _cp = ConstantPool::allocate(_loader_data,
                                cp_size,
                                CHECK);
 
@@ -6793,40 +6823,71 @@
     _this_class_index, CHECK);
 
   Symbol* const class_name_in_cp = cp->klass_name_at(_this_class_index);
   assert(class_name_in_cp != NULL, "class_name can't be null");
 
-  // Update _class_name to reflect the name in the constant pool
-  update_class_name(class_name_in_cp);
-
   // Don't need to check whether this class name is legal or not.
   // It has been checked when constant pool is parsed.
   // However, make sure it is not an array type.
   if (_need_verify) {
-    guarantee_property(_class_name->char_at(0) != JVM_SIGNATURE_ARRAY,
+    guarantee_property(class_name_in_cp->char_at(0) != JVM_SIGNATURE_ARRAY,
                        "Bad class name in class file %s",
                        CHECK);
   }
 
-  // Checks if name in class file matches requested name
-  if (_requested_name != NULL && _requested_name != _class_name) {
-    ResourceMark rm(THREAD);
-    Exceptions::fthrow(
-      THREAD_AND_LOCATION,
-      vmSymbols::java_lang_NoClassDefFoundError(),
-      "%s (wrong name: %s)",
-      _class_name->as_C_string(),
-      _requested_name != NULL ? _requested_name->as_C_string() : "NoName"
-    );
-    return;
+#ifdef ASSERT
+  // Basic sanity checks
+  assert(!(_is_hidden && (_unsafe_anonymous_host != NULL)), "mutually exclusive variants");
+
+  if (_unsafe_anonymous_host != NULL) {
+    assert(_class_name == vmSymbols::unknown_class_name(), "A named anonymous class???");
+  }
+  if (_is_hidden) {
+    assert(_class_name != vmSymbols::unknown_class_name(), "hidden classes should have a special name");
   }
+#endif
+
+  // Update the _class_name as needed depending on whether this is a named,
+  // un-named, hidden or unsafe-anonymous class.
+
+  if (_is_hidden) {
+    assert(_class_name != NULL, "Unexpected null _class_name");
+#ifdef ASSERT
+    if (_need_verify) {
+      verify_legal_class_name(_class_name, CHECK);
+    }
+#endif
+
+  // NOTE: !_is_hidden does not imply "findable" as it could be an old-style
+  //       "hidden" unsafe-anonymous class
 
-  // if this is an anonymous class fix up its name if it's in the unnamed
+  // If this is an anonymous class fix up its name if it is in the unnamed
   // package.  Otherwise, throw IAE if it is in a different package than
   // its host class.
-  if (_unsafe_anonymous_host != NULL) {
+  } else if (_unsafe_anonymous_host != NULL) {
+    update_class_name(class_name_in_cp);
     fix_unsafe_anonymous_class_name(CHECK);
+
+  } else {
+    // Check if name in class file matches given name
+    if (_class_name != class_name_in_cp) {
+      if (_class_name != vmSymbols::unknown_class_name()) {
+        ResourceMark rm(THREAD);
+        Exceptions::fthrow(THREAD_AND_LOCATION,
+                           vmSymbols::java_lang_NoClassDefFoundError(),
+                           "%s (wrong name: %s)",
+                           class_name_in_cp->as_C_string(),
+                           _class_name->as_C_string()
+                           );
+        return;
+      } else {
+        // The class name was not known by the caller so we set it from
+        // the value in the CP.
+        update_class_name(class_name_in_cp);
+      }
+      // else nothing to do: the expected class name matches what is in the CP
+    }
   }
 
   // Verification prevents us from creating names with dots in them, this
   // asserts that that's the case.
   assert(is_internal_format(_class_name), "external class name format used internally");
@@ -6847,13 +6908,14 @@
     if (DumpLoadedClassList != NULL && stream->source() != NULL && classlist_file->is_open()) {
       if (!ClassLoader::has_jrt_entry()) {
         warning("DumpLoadedClassList and CDS are not supported in exploded build");
         DumpLoadedClassList = NULL;
       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &&
+                 !_is_hidden &&
                  _unsafe_anonymous_host == NULL) {
         // Only dump the classes that can be stored into CDS archive.
-        // Unsafe anonymous classes such as generated LambdaForm classes are also not included.
+        // Hidden and unsafe anonymous classes such as generated LambdaForm classes are also not included.
         oop class_loader = _loader_data->class_loader();
         ResourceMark rm(THREAD);
         bool skip = false;
         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
           // For the boot and platform class loaders, skip classes that are not found in the
@@ -6948,10 +7010,39 @@
                      CHECK);
 
   // all bytes in stream read and parsed
 }
 
+void ClassFileParser::mangle_hidden_class_name(InstanceKlass* const ik) {
+  ResourceMark rm;
+  // Construct hidden name from _class_name, "+", and &ik. Note that we can't
+  // use a '/' because that confuses finding the class's package.  Also, can't
+  // use an illegal char such as ';' because that causes serialization issues
+  // and issues with hidden classes that create their own hidden classes.
+  char addr_buf[20];
+  jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));
+  size_t new_name_len = _class_name->utf8_length() + 2 + strlen(addr_buf);
+  char* new_name = NEW_RESOURCE_ARRAY(char, new_name_len);
+  jio_snprintf(new_name, new_name_len, "%s+%s",
+               _class_name->as_C_string(), addr_buf);
+  update_class_name(SymbolTable::new_symbol(new_name));
+
+  // Add a Utf8 entry containing the hidden name.
+  assert(_class_name != NULL, "Unexpected null _class_name");
+  int hidden_index = _orig_cp_size; // this is an extra slot we added
+  _cp->symbol_at_put(hidden_index, _class_name);
+
+  // Update this_class_index's slot in the constant pool with the new Utf8 entry.
+  // We have to update the resolved_klass_index and the name_index together
+  // so extract the existing resolved_klass_index first.
+  CPKlassSlot cp_klass_slot = _cp->klass_slot_at(_this_class_index);
+  int resolved_klass_index = cp_klass_slot.resolved_klass_index();
+  _cp->unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
+  assert(_cp->klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
+         "Bad name_index");
+}
+
 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
                                                  ConstantPool* cp,
                                                  TRAPS) {
   assert(stream != NULL, "invariant");
   assert(stream->at_eos(), "invariant");
diff a/src/hotspot/share/classfile/classFileParser.hpp b/src/hotspot/share/classfile/classFileParser.hpp
--- a/src/hotspot/share/classfile/classFileParser.hpp
+++ b/src/hotspot/share/classfile/classFileParser.hpp
@@ -35,10 +35,12 @@
 class Annotations;
 template <typename T>
 class Array;
 class ClassFileStream;
 class ClassLoaderData;
+class ClassLoadInfo;
+class ClassInstanceInfo;
 class CompressedLineNumberWriteStream;
 class ConstMethod;
 class FieldInfo;
 template <typename T>
 class GrowableArray;
@@ -108,15 +110,16 @@
  private:
   // Potentially unaligned pointer to various 16-bit entries in the class file
   typedef void unsafe_u2;
 
   const ClassFileStream* _stream; // Actual input stream
-  const Symbol* _requested_name;
   Symbol* _class_name;
   mutable ClassLoaderData* _loader_data;
   const InstanceKlass* _unsafe_anonymous_host;
   GrowableArray<Handle>* _cp_patches; // overrides for CP entries
+  const bool _is_hidden;
+  const bool _can_access_vm_annotations;
   int _num_patched_klasses;
   int _max_num_patched_klasses;
   int _orig_cp_size;
   int _first_patched_klass_resolved_index;
 
@@ -215,18 +218,22 @@
   bool _has_vanilla_constructor;
   int _max_bootstrap_specifier_index;  // detects BSS values
 
   void parse_stream(const ClassFileStream* const stream, TRAPS);
 
+  void mangle_hidden_class_name(InstanceKlass* const ik);
+
   void post_process_parsed_stream(const ClassFileStream* const stream,
                                   ConstantPool* cp,
                                   TRAPS);
 
   void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);
   void fix_unsafe_anonymous_class_name(TRAPS);
 
-  void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH, TRAPS);
+  void fill_instance_klass(InstanceKlass* ik, bool cf_changed_in_CFLH,
+                           const ClassInstanceInfo& cl_inst_info, TRAPS);
+
   void set_klass(InstanceKlass* instance);
 
   void set_class_bad_constant_seen(short bad_constant);
   short class_bad_constant_seen() { return  _bad_constant_seen; }
   void set_class_synthetic_flag(bool x)        { _synthetic_flag = x; }
@@ -555,28 +562,26 @@
                      const FieldAllocationCount* fac,
                      const ClassAnnotationCollector* parsed_annotations,
                      FieldLayoutInfo* info,
                      TRAPS);
 
-   void update_class_name(Symbol* new_name);
+  void update_class_name(Symbol* new_name);
 
   // Check if the class file supports inline types
   bool supports_inline_types() const;
 
  public:
   ClassFileParser(ClassFileStream* stream,
                   Symbol* name,
                   ClassLoaderData* loader_data,
-                  Handle protection_domain,
-                  const InstanceKlass* unsafe_anonymous_host,
-                  GrowableArray<Handle>* cp_patches,
+                  const ClassLoadInfo* cl_info,
                   Publicity pub_level,
                   TRAPS);
 
   ~ClassFileParser();
 
-  InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, TRAPS);
+  InstanceKlass* create_instance_klass(bool cf_changed_in_CFLH, const ClassInstanceInfo& cl_inst_info, TRAPS);
 
   const ClassFileStream* clone_stream() const;
 
   void set_klass_to_deallocate(InstanceKlass* klass);
 
@@ -588,10 +593,11 @@
   int itable_size() const { return _itable_size; }
 
   u2 this_class_index() const { return _this_class_index; }
 
   bool is_unsafe_anonymous() const { return _unsafe_anonymous_host != NULL; }
+  bool is_hidden() const { return _is_hidden; }
   bool is_interface() const { return _access_flags.is_interface(); }
   bool is_inline_type() const { return _access_flags.is_inline_type(); }
   bool is_value_capable_class() const;
   bool has_flattenable_fields() const { return _has_flattenable_fields; }
   bool invalid_inline_super() const { return _invalid_inline_super; }
diff a/src/hotspot/share/classfile/classLoader.cpp b/src/hotspot/share/classfile/classLoader.cpp
--- a/src/hotspot/share/classfile/classLoader.cpp
+++ b/src/hotspot/share/classfile/classLoader.cpp
@@ -1009,36 +1009,10 @@
 
 int ClassLoader::crc32(int crc, const char* buf, int len) {
   return (*Crc32)(crc, (const jbyte*)buf, len);
 }
 
-// Function add_package checks if the package of the InstanceKlass is in the
-// boot loader's package entry table.  If so, then it sets the classpath_index
-// in the package entry record.
-//
-// The classpath_index field is used to find the entry on the boot loader class
-// path for packages with classes loaded by the boot loader from -Xbootclasspath/a
-// in an unnamed module.  It is also used to indicate (for all packages whose
-// classes are loaded by the boot loader) that at least one of the package's
-// classes has been loaded.
-bool ClassLoader::add_package(const InstanceKlass* ik, s2 classpath_index, TRAPS) {
-  assert(ik != NULL, "just checking");
-
-  PackageEntry* ik_pkg = ik->package();
-  if (ik_pkg != NULL) {
-    PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()->packages();
-    PackageEntry* pkg_entry = pkg_entry_tbl->lookup_only(ik_pkg->name());
-    if (pkg_entry != NULL) {
-      assert(classpath_index != -1, "Unexpected classpath_index");
-      pkg_entry->set_classpath_index(classpath_index);
-    } else {
-      return false;
-    }
-  }
-  return true;
-}
-
 oop ClassLoader::get_system_package(const char* name, TRAPS) {
   // Look up the name in the boot loader's package entry table.
   if (name != NULL) {
     TempNewSymbol package_sym = SymbolTable::new_symbol(name);
     // Look for the package entry in the boot loader's package entry table.
@@ -1281,29 +1255,25 @@
 
   stream->set_verify(ClassLoaderExt::should_verify(classpath_index));
 
   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
   Handle protection_domain;
+  ClassLoadInfo cl_info(protection_domain);
 
   InstanceKlass* result = KlassFactory::create_from_stream(stream,
                                                            name,
                                                            loader_data,
-                                                           protection_domain,
-                                                           NULL, // unsafe_anonymous_host
-                                                           NULL, // cp_patches
+                                                           cl_info,
                                                            THREAD);
   if (HAS_PENDING_EXCEPTION) {
     if (DumpSharedSpaces) {
       log_error(cds)("Preload Error: Failed to load %s", class_name);
     }
     return NULL;
   }
 
-  if (!add_package(result, classpath_index, THREAD)) {
-    return NULL;
-  }
-
+  result->set_classpath_index(classpath_index, THREAD);
   return result;
 }
 
 #if INCLUDE_CDS
 char* ClassLoader::skip_uri_protocol(char* source) {
@@ -1329,12 +1299,12 @@
 // by the builtin loaders at dump time.
 void ClassLoader::record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS) {
   Arguments::assert_is_dumping_archive();
   assert(stream != NULL, "sanity");
 
-  if (ik->is_unsafe_anonymous()) {
-    // We do not archive unsafe anonymous classes.
+  if (ik->is_hidden() || ik->is_unsafe_anonymous()) {
+    // We do not archive hidden or unsafe anonymous classes.
     return;
   }
 
   oop loader = ik->class_loader();
   char* src = (char*)stream->source();
diff a/src/hotspot/share/classfile/classLoaderData.cpp b/src/hotspot/share/classfile/classLoaderData.cpp
--- a/src/hotspot/share/classfile/classLoaderData.cpp
+++ b/src/hotspot/share/classfile/classLoaderData.cpp
@@ -1,7 +1,7 @@
  /*
- * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -125,20 +125,20 @@
                                              java_lang_String::as_utf8_string(cl_name_and_id);
   assert(cl_instance_name_and_id != NULL && cl_instance_name_and_id[0] != '\0', "class loader has no name and id");
   _name_and_id = SymbolTable::new_symbol(cl_instance_name_and_id);
 }
 
-ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool is_unsafe_anonymous) :
+ClassLoaderData::ClassLoaderData(Handle h_class_loader, bool has_class_mirror_holder) :
   _metaspace(NULL),
   _metaspace_lock(new Mutex(Mutex::leaf+1, "Metaspace allocation lock", true,
                             Mutex::_safepoint_check_never)),
-  _unloading(false), _is_unsafe_anonymous(is_unsafe_anonymous),
+  _unloading(false), _has_class_mirror_holder(has_class_mirror_holder),
   _modified_oops(true), _accumulated_modified_oops(false),
   // An unsafe anonymous class loader data doesn't have anything to keep
   // it from being unloaded during parsing of the unsafe anonymous class.
   // The null-class-loader should always be kept alive.
-  _keep_alive((is_unsafe_anonymous || h_class_loader.is_null()) ? 1 : 0),
+  _keep_alive((has_class_mirror_holder || h_class_loader.is_null()) ? 1 : 0),
   _claim(0),
   _handles(),
   _klasses(NULL), _packages(NULL), _modules(NULL), _unnamed_module(NULL), _dictionary(NULL),
   _jmethod_ids(NULL),
   _deallocate_list(NULL),
@@ -149,17 +149,17 @@
     _class_loader = _handles.add(h_class_loader());
     _class_loader_klass = h_class_loader->klass();
     initialize_name(h_class_loader);
   }
 
-  if (!is_unsafe_anonymous) {
-    // The holder is initialized later for unsafe anonymous classes, and before calling anything
-    // that call class_loader().
+  if (!has_class_mirror_holder) {
+    // The holder is initialized later for non-strong hidden classes and unsafe anonymous classes,
+    // and before calling anything that call class_loader().
     initialize_holder(h_class_loader);
 
-    // A ClassLoaderData created solely for an unsafe anonymous class should never have a
-    // ModuleEntryTable or PackageEntryTable created for it. The defining package
+    // A ClassLoaderData created solely for a non-strong hidden class or unsafe anonymous class should
+    // never have a ModuleEntryTable or PackageEntryTable created for it. The defining package
     // and module for an unsafe anonymous class will be found in its host class.
     _packages = new PackageEntryTable(PackageEntryTable::_packagetable_entry_size);
     if (h_class_loader.is_null()) {
       // Create unnamed module for boot loader
       _unnamed_module = ModuleEntry::create_boot_unnamed_module(this);
@@ -290,24 +290,24 @@
       return true;
     }
   }
 }
 
-// Unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive
+// Weak hidden and unsafe anonymous classes have their own ClassLoaderData that is marked to keep alive
 // while the class is being parsed, and if the class appears on the module fixup list.
-// Due to the uniqueness that no other class shares the unsafe anonymous class' name or
-// ClassLoaderData, no other non-GC thread has knowledge of the unsafe anonymous class while
+// Due to the uniqueness that no other class shares the hidden or unsafe anonymous class' name or
+// ClassLoaderData, no other non-GC thread has knowledge of the hidden or unsafe anonymous class while
 // it is being defined, therefore _keep_alive is not volatile or atomic.
 void ClassLoaderData::inc_keep_alive() {
-  if (is_unsafe_anonymous()) {
+  if (has_class_mirror_holder()) {
     assert(_keep_alive > 0, "Invalid keep alive increment count");
     _keep_alive++;
   }
 }
 
 void ClassLoaderData::dec_keep_alive() {
-  if (is_unsafe_anonymous()) {
+  if (has_class_mirror_holder()) {
     assert(_keep_alive > 0, "Invalid keep alive decrement count");
     _keep_alive--;
   }
 }
 
@@ -419,25 +419,25 @@
   ClassLoaderData * const from_cld = this;
   ClassLoaderData * const to_cld = k->class_loader_data();
 
   // Do not need to record dependency if the dependency is to a class whose
   // class loader data is never freed.  (i.e. the dependency's class loader
-  // is one of the three builtin class loaders and the dependency is not
-  // unsafe anonymous.)
+  // is one of the three builtin class loaders and the dependency's class
+  // loader data has a ClassLoader holder, not a Class holder.)
   if (to_cld->is_permanent_class_loader_data()) {
     return;
   }
 
   oop to;
-  if (to_cld->is_unsafe_anonymous()) {
-    // Just return if an unsafe anonymous class is attempting to record a dependency
-    // to itself.  (Note that every unsafe anonymous class has its own unique class
+  if (to_cld->has_class_mirror_holder()) {
+    // Just return if a non-strong hidden class or unsafe anonymous class is attempting to record a dependency
+    // to itself.  (Note that every non-strong hidden class or unsafe anonymous class has its own unique class
     // loader data.)
     if (to_cld == from_cld) {
       return;
     }
-    // Unsafe anonymous class dependencies are through the mirror.
+    // Hidden and unsafe anonymous class dependencies are through the mirror.
     to = k->java_mirror();
   } else {
     to = to_cld->class_loader();
     oop from = from_cld->class_loader();
 
@@ -583,11 +583,11 @@
 
 const int _boot_loader_dictionary_size    = 1009;
 const int _default_loader_dictionary_size = 107;
 
 Dictionary* ClassLoaderData::create_dictionary() {
-  assert(!is_unsafe_anonymous(), "unsafe anonymous class loader data do not have a dictionary");
+  assert(!has_class_mirror_holder(), "class mirror holder cld does not have a dictionary");
   int size;
   bool resizable = false;
   if (_the_null_class_loader_data == NULL) {
     size = _boot_loader_dictionary_size;
     resizable = true;
@@ -629,11 +629,11 @@
   }
 }
 
 // Unloading support
 bool ClassLoaderData::is_alive() const {
-  bool alive = keep_alive()         // null class loader and incomplete unsafe anonymous klasses.
+  bool alive = keep_alive()         // null class loader and incomplete non-strong hidden class or unsafe anonymous class.
       || (_holder.peek() != NULL);  // and not cleaned by the GC weak handle processing.
 
   return alive;
 }
 
@@ -727,37 +727,37 @@
   }
 }
 
 // Returns true if this class loader data is for the app class loader
 // or a user defined system class loader.  (Note that the class loader
-// data may be unsafe anonymous.)
+// data may have a Class holder.)
 bool ClassLoaderData::is_system_class_loader_data() const {
   return SystemDictionary::is_system_class_loader(class_loader());
 }
 
 // Returns true if this class loader data is for the platform class loader.
-// (Note that the class loader data may be unsafe anonymous.)
+// (Note that the class loader data may have a Class holder.)
 bool ClassLoaderData::is_platform_class_loader_data() const {
   return SystemDictionary::is_platform_class_loader(class_loader());
 }
 
 // Returns true if the class loader for this class loader data is one of
 // the 3 builtin (boot application/system or platform) class loaders,
 // including a user-defined system class loader.  Note that if the class
-// loader data is for an unsafe anonymous class then it may get freed by a GC
-// even if its class loader is one of these loaders.
+// loader data is for a non-strong hidden class or unsafe anonymous class then it may
+// get freed by a GC even if its class loader is one of these loaders.
 bool ClassLoaderData::is_builtin_class_loader_data() const {
   return (is_boot_class_loader_data() ||
           SystemDictionary::is_system_class_loader(class_loader()) ||
           SystemDictionary::is_platform_class_loader(class_loader()));
 }
 
 // Returns true if this class loader data is a class loader data
 // that is not ever freed by a GC.  It must be the CLD for one of the builtin
-// class loaders and not the CLD for an unsafe anonymous class.
+// class loaders and not the CLD for a non-strong hidden class or unsafe anonymous class.
 bool ClassLoaderData::is_permanent_class_loader_data() const {
-  return is_builtin_class_loader_data() && !is_unsafe_anonymous();
+  return is_builtin_class_loader_data() && !has_class_mirror_holder();
 }
 
 ClassLoaderMetaspace* ClassLoaderData::metaspace_non_null() {
   // If the metaspace has not been allocated, create a new one.  Might want
   // to create smaller arena for Reflection class loaders also.
@@ -770,12 +770,12 @@
     // Check if _metaspace got allocated while we were waiting for this lock.
     if ((metaspace = _metaspace) == NULL) {
       if (this == the_null_class_loader_data()) {
         assert (class_loader() == NULL, "Must be");
         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::BootMetaspaceType);
-      } else if (is_unsafe_anonymous()) {
-        metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::UnsafeAnonymousMetaspaceType);
+      } else if (has_class_mirror_holder()) {
+        metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ClassMirrorHolderMetaspaceType);
       } else if (class_loader()->is_a(SystemDictionary::reflect_DelegatingClassLoader_klass())) {
         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::ReflectionMetaspaceType);
       } else {
         metaspace = new ClassLoaderMetaspace(_metaspace_lock, Metaspace::StandardMetaspaceType);
       }
@@ -892,12 +892,12 @@
       remove_class(ik);
     }
   }
 }
 
-// These CLDs are to contain unsafe anonymous classes used for JSR292
-ClassLoaderData* ClassLoaderData::unsafe_anonymous_class_loader_data(Handle loader) {
+// These CLDs are to contain non-strong hidden classes or unsafe anonymous classes used for JSR292
+ClassLoaderData* ClassLoaderData::has_class_mirror_holder_cld(Handle loader) {
   // Add a new class loader data to the graph.
   return ClassLoaderDataGraph::add(loader, true);
 }
 
 // Caller needs ResourceMark
@@ -935,22 +935,22 @@
     class_loader()->print_value_on(out);  // includes loader_name_and_id() and address of class loader instance
   } else {
     // loader data: 0xsomeaddr of 'bootstrap'
     out->print("loader data: " INTPTR_FORMAT " of %s", p2i(this), loader_name_and_id());
   }
-  if (is_unsafe_anonymous()) {
-    out->print(" unsafe anonymous");
+  if (_has_class_mirror_holder) {
+    out->print(" has a class holder");
   }
 }
 
 void ClassLoaderData::print_value() const { print_value_on(tty); }
 
 #ifndef PRODUCT
 void ClassLoaderData::print_on(outputStream* out) const {
   out->print("ClassLoaderData CLD: " PTR_FORMAT ", loader: " PTR_FORMAT ", loader_klass: %s {",
               p2i(this), p2i(_class_loader.ptr_raw()), loader_name_and_id());
-  if (is_unsafe_anonymous()) out->print(" unsafe anonymous");
+  if (has_class_mirror_holder()) out->print(" has a class holder");
   if (claimed()) out->print(" claimed");
   if (is_unloading()) out->print(" unloading");
   out->print(" metaspace: " INTPTR_FORMAT, p2i(metaspace_or_null()));
 
   if (_jmethod_ids != NULL) {
@@ -966,12 +966,12 @@
 
 void ClassLoaderData::verify() {
   assert_locked_or_safepoint(_metaspace_lock);
   oop cl = class_loader();
 
-  guarantee(this == class_loader_data(cl) || is_unsafe_anonymous(), "Must be the same");
-  guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || is_unsafe_anonymous(), "must be");
+  guarantee(this == class_loader_data(cl) || has_class_mirror_holder(), "Must be the same");
+  guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), "must be");
 
   // Verify the integrity of the allocated space.
   if (metaspace_or_null() != NULL) {
     metaspace_or_null()->verify();
   }
diff a/src/hotspot/share/classfile/classLoaderData.hpp b/src/hotspot/share/classfile/classLoaderData.hpp
--- a/src/hotspot/share/classfile/classLoaderData.hpp
+++ b/src/hotspot/share/classfile/classLoaderData.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -115,21 +115,24 @@
 
   ClassLoaderMetaspace * volatile _metaspace;  // Meta-space where meta-data defined by the
                                     // classes in the class loader are allocated.
   Mutex* _metaspace_lock;  // Locks the metaspace for allocations and setup.
   bool _unloading;         // true if this class loader goes away
-  bool _is_unsafe_anonymous; // CLD is dedicated to one class and that class determines the CLDs lifecycle.
-                             // For example, an unsafe anonymous class.
+  bool _has_class_mirror_holder; // If true, CLD is dedicated to one class and that class determines
+                                 // the CLDs lifecycle.  For example, a non-strong hidden class or an
+                                 // unsafe anonymous class.  Arrays of these classes are also assigned
+                                 // to these class loader datas.
 
   // Remembered sets support for the oops in the class loader data.
   bool _modified_oops;             // Card Table Equivalent (YC/CMS support)
   bool _accumulated_modified_oops; // Mod Union Equivalent (CMS support)
 
   int _keep_alive;         // if this CLD is kept alive.
-                           // Used for unsafe anonymous classes and the boot class
-                           // loader. _keep_alive does not need to be volatile or
-                           // atomic since there is one unique CLD per unsafe anonymous class.
+                           // Used for non-strong hidden classes, unsafe anonymous classes and the
+                           // boot class loader. _keep_alive does not need to be volatile or
+                           // atomic since there is one unique CLD per non-strong hidden class
+                           // or unsafe anonymous class.
 
   volatile int _claim; // non-zero if claimed, for example during GC traces.
                        // To avoid applying oop closure more than once.
   ChunkedHandleList _handles; // Handles to constant pool arrays, Modules, etc, which
                               // have the same life cycle of the corresponding ClassLoader.
@@ -160,11 +163,11 @@
   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
 
   void set_next(ClassLoaderData* next) { _next = next; }
   ClassLoaderData* next() const        { return Atomic::load(&_next); }
 
-  ClassLoaderData(Handle h_class_loader, bool is_unsafe_anonymous);
+  ClassLoaderData(Handle h_class_loader, bool has_class_mirror_holder);
   ~ClassLoaderData();
 
   // The CLD are not placed in the Heap, so the Card Table or
   // the Mod Union Table can't be used to mark when CLD have modified oops.
   // The CT and MUT bits saves this information for the whole class loader data.
@@ -230,28 +233,28 @@
     return _the_null_class_loader_data;
   }
 
   Mutex* metaspace_lock() const { return _metaspace_lock; }
 
-  bool is_unsafe_anonymous() const { return _is_unsafe_anonymous; }
+  bool has_class_mirror_holder() const { return _has_class_mirror_holder; }
 
   static void init_null_class_loader_data();
 
   bool is_the_null_class_loader_data() const {
     return this == _the_null_class_loader_data;
   }
 
   // Returns true if this class loader data is for the system class loader.
-  // (Note that the class loader data may be unsafe anonymous.)
+  // (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)
   bool is_system_class_loader_data() const;
 
   // Returns true if this class loader data is for the platform class loader.
-  // (Note that the class loader data may be unsafe anonymous.)
+  // (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)
   bool is_platform_class_loader_data() const;
 
   // Returns true if this class loader data is for the boot class loader.
-  // (Note that the class loader data may be unsafe anonymous.)
+  // (Note that the class loader data may be for a non-strong hidden class or unsafe anonymous class)
   inline bool is_boot_class_loader_data() const;
 
   bool is_builtin_class_loader_data() const;
   bool is_permanent_class_loader_data() const;
 
@@ -268,11 +271,11 @@
   bool is_unloading() const     {
     assert(!(is_the_null_class_loader_data() && _unloading), "The null class loader can never be unloaded");
     return _unloading;
   }
 
-  // Used to refcount an unsafe anonymous class's CLD in order to
+  // Used to refcount a non-strong hidden class's or unsafe anonymous class's CLD in order to
   // indicate their aliveness.
   void inc_keep_alive();
   void dec_keep_alive();
 
   void initialize_holder(Handle holder);
@@ -312,11 +315,11 @@
 
   void add_to_deallocate_list(Metadata* m);
 
   static ClassLoaderData* class_loader_data(oop loader);
   static ClassLoaderData* class_loader_data_or_null(oop loader);
-  static ClassLoaderData* unsafe_anonymous_class_loader_data(Handle loader);
+  static ClassLoaderData* has_class_mirror_holder_cld(Handle loader);
 
   // Returns Klass* of associated class loader, or NULL if associated loader is 'bootstrap'.
   // Also works if unloading.
   Klass* class_loader_klass() const { return _class_loader_klass; }
 
diff a/src/hotspot/share/classfile/javaClasses.cpp b/src/hotspot/share/classfile/javaClasses.cpp
--- a/src/hotspot/share/classfile/javaClasses.cpp
+++ b/src/hotspot/share/classfile/javaClasses.cpp
@@ -649,22 +649,50 @@
   typeArrayOop value = java_lang_String::value(java_string);
   return utf8_length(java_string, value);
 }
 
 char* java_lang_String::as_utf8_string(oop java_string) {
-  typeArrayOop value  = java_lang_String::value(java_string);
-  int          length = java_lang_String::length(java_string, value);
-  bool      is_latin1 = java_lang_String::is_latin1(java_string);
+  int length;
+  return as_utf8_string(java_string, length);
+}
+
+char* java_lang_String::as_utf8_string(oop java_string, int& length) {
+  typeArrayOop value = java_lang_String::value(java_string);
+  length             = java_lang_String::length(java_string, value);
+  bool     is_latin1 = java_lang_String::is_latin1(java_string);
   if (!is_latin1) {
     jchar* position = (length == 0) ? NULL : value->char_at_addr(0);
     return UNICODE::as_utf8(position, length);
   } else {
     jbyte* position = (length == 0) ? NULL : value->byte_at_addr(0);
     return UNICODE::as_utf8(position, length);
   }
 }
 
+// Uses a provided buffer if it's sufficiently large, otherwise allocates
+// a resource array to fit
+char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int& utf8_len) {
+  typeArrayOop value = java_lang_String::value(java_string);
+  int            len = java_lang_String::length(java_string, value);
+  bool     is_latin1 = java_lang_String::is_latin1(java_string);
+  if (!is_latin1) {
+    jchar *position = (len == 0) ? NULL : value->char_at_addr(0);
+    utf8_len = UNICODE::utf8_length(position, len);
+    if (utf8_len >= buflen) {
+      buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
+    }
+    return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
+  } else {
+    jbyte *position = (len == 0) ? NULL : value->byte_at_addr(0);
+    utf8_len = UNICODE::utf8_length(position, len);
+    if (utf8_len >= buflen) {
+      buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);
+    }
+    return UNICODE::as_utf8(position, len, buf, utf8_len + 1);
+  }
+}
+
 char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {
   assert(value_equals(value, java_lang_String::value(java_string)),
          "value must be same as java_lang_String::value(java_string)");
   int     length = java_lang_String::length(java_string, value);
   bool is_latin1 = java_lang_String::is_latin1(java_string);
@@ -852,16 +880,17 @@
     } else {
       k->set_java_mirror_handle(NULL);
       k->clear_has_raw_archived_mirror();
     }
   }
-  create_mirror(k, Handle(), Handle(), Handle(), CHECK);
+  create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);
 }
 
 void java_lang_Class::initialize_mirror_fields(Klass* k,
                                                Handle mirror,
                                                Handle protection_domain,
+                                               Handle classData,
                                                TRAPS) {
   // Allocate a simple java object for a lock.
   // This needs to be a java object because during class initialization
   // it can be held across a java call.
   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
@@ -870,10 +899,13 @@
   // Set protection domain also
   set_protection_domain(mirror(), protection_domain());
 
   // Initialize static fields
   InstanceKlass::cast(k)->do_local_static_fields(&initialize_static_field, mirror, CHECK);
+
+ // Set classData
+  set_class_data(mirror(), classData());
 }
 
 // Set the java.lang.Module module field in the java_lang_Class mirror
 void java_lang_Class::set_mirror_module_field(Klass* k, Handle mirror, Handle module, TRAPS) {
   if (module.is_null()) {
@@ -923,11 +955,12 @@
     new (ResourceObj::C_HEAP, mtModule) GrowableArray<Klass*>(500, true);
   set_fixup_module_field_list(module_list);
 }
 
 void java_lang_Class::create_mirror(Klass* k, Handle class_loader,
-                                    Handle module, Handle protection_domain, TRAPS) {
+                                    Handle module, Handle protection_domain,
+                                    Handle classData, TRAPS) {
   assert(k != NULL, "Use create_basic_type_mirror for primitive types");
   assert(k->java_mirror() == NULL, "should only assign mirror once");
 
   // Use this moment of initialization to cache modifier_flags also,
   // to support Class.getModifiers().  Instance classes recalculate
@@ -975,11 +1008,11 @@
       // See below for ordering dependencies between field array_klass in component mirror
       // and java_mirror in this klass.
     } else {
       assert(k->is_instance_klass(), "Must be");
 
-      initialize_mirror_fields(k, mirror, protection_domain, THREAD);
+      initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);
       if (HAS_PENDING_EXCEPTION) {
         // If any of the fields throws an exception like OOM remove the klass field
         // from the mirror so GC doesn't follow it after the klass has been deallocated.
         // This mirror looks like a primitive type, which logically it is because it
         // it represents no class.
@@ -1283,20 +1316,20 @@
     }
   }
 }
 
 void java_lang_Class::update_archived_mirror_native_pointers(oop archived_mirror) {
-  if (MetaspaceShared::relocation_delta() != 0) {
-    Klass* k = ((Klass*)archived_mirror->metadata_field(_klass_offset));
-    archived_mirror->metadata_field_put(_klass_offset,
-        (Klass*)(address(k) + MetaspaceShared::relocation_delta()));
+  assert(MetaspaceShared::relocation_delta() != 0, "must be");
 
-    Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));
-    if (ak != NULL) {
-      archived_mirror->metadata_field_put(_array_klass_offset,
-          (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
-    }
+  Klass* k = ((Klass*)archived_mirror->metadata_field(_klass_offset));
+  archived_mirror->metadata_field_put(_klass_offset,
+      (Klass*)(address(k) + MetaspaceShared::relocation_delta()));
+
+  Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));
+  if (ak != NULL) {
+    archived_mirror->metadata_field_put(_array_klass_offset,
+        (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));
   }
 }
 
 
 // Returns true if the mirror is updated, false if no archived mirror
@@ -1319,11 +1352,10 @@
   }
 
   // mirror is archived, restore
   log_debug(cds, mirror)("Archived mirror is: " PTR_FORMAT, p2i(m));
   assert(HeapShared::is_archived_object(m), "must be archived mirror object");
-  update_archived_mirror_native_pointers(m);
   assert(as_Klass(m) == k, "must be");
   Handle mirror(THREAD, m);
 
   if (!k->is_array_klass()) {
     // - local static final fields with initial values were initialized at dump time
@@ -1425,10 +1457,18 @@
 void java_lang_Class::set_signers(oop java_class, objArrayOop signers) {
   assert(_signers_offset != 0, "must be set");
   java_class->obj_field_put(_signers_offset, (oop)signers);
 }
 
+oop java_lang_Class::class_data(oop java_class) {
+  assert(_classData_offset != 0, "must be set");
+  return java_class->obj_field(_classData_offset);
+}
+void java_lang_Class::set_class_data(oop java_class, oop class_data) {
+  assert(_classData_offset != 0, "must be set");
+  java_class->obj_field_put(_classData_offset, class_data);
+}
 
 void java_lang_Class::set_class_loader(oop java_class, oop loader) {
   assert(_class_loader_offset != 0, "offsets should have been initialized");
   java_class->obj_field_put(_class_loader_offset, loader);
 }
@@ -1658,10 +1698,11 @@
   macro(_component_mirror_offset,   k, "componentType",       class_signature,       false); \
   macro(_module_offset,             k, "module",              module_signature,      false); \
   macro(_name_offset,               k, "name",                string_signature,      false); \
   macro(_val_type_mirror_offset,    k, "valType",             class_signature,       false); \
   macro(_ref_type_mirror_offset,    k, "refType",             class_signature,       false); \
+  macro(_classData_offset,          k, "classData",           object_signature,      false);
 
 void java_lang_Class::compute_offsets() {
   if (offsets_computed) {
     return;
   }
@@ -4328,10 +4369,11 @@
 int java_lang_Class::_ref_type_mirror_offset;
 int java_lang_Class::_init_lock_offset;
 int java_lang_Class::_signers_offset;
 int java_lang_Class::_name_offset;
 int java_lang_Class::_source_file_offset;
+int java_lang_Class::_classData_offset;
 GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = NULL;
 GrowableArray<Klass*>* java_lang_Class::_fixup_module_field_list = NULL;
 int java_lang_Throwable::backtrace_offset;
 int java_lang_Throwable::detailMessage_offset;
 int java_lang_Throwable::stackTrace_offset;
diff a/src/hotspot/share/classfile/javaClasses.hpp b/src/hotspot/share/classfile/javaClasses.hpp
--- a/src/hotspot/share/classfile/javaClasses.hpp
+++ b/src/hotspot/share/classfile/javaClasses.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -167,10 +167,12 @@
   static int utf8_length(oop java_string);
   static int utf8_length(oop java_string, typeArrayOop string_value);
 
   // String converters
   static char*  as_utf8_string(oop java_string);
+  static char*  as_utf8_string(oop java_string, int& length);
+  static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int& length);
   static char*  as_utf8_string(oop java_string, char* buf, int buflen);
   static char*  as_utf8_string(oop java_string, int start, int len);
   static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);
   static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);
   static char*  as_platform_dependent_str(Handle java_string, TRAPS);
@@ -264,10 +266,11 @@
   static int _component_mirror_offset;
   static int _name_offset;
   static int _source_file_offset;
   static int _val_type_mirror_offset;
   static int _ref_type_mirror_offset;
+  static int _classData_offset;
 
   static bool offsets_computed;
   static int classRedefinedCount_offset;
 
   static GrowableArray<Klass*>* _fixup_mirror_list;
@@ -275,19 +278,20 @@
 
   static void set_init_lock(oop java_class, oop init_lock);
   static void set_protection_domain(oop java_class, oop protection_domain);
   static void set_class_loader(oop java_class, oop class_loader);
   static void set_component_mirror(oop java_class, oop comp_mirror);
-  static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain, TRAPS);
+  static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,
+                                       Handle classData, TRAPS);
   static void set_mirror_module_field(Klass* K, Handle mirror, Handle module, TRAPS);
  public:
   static void allocate_fixup_lists();
   static void compute_offsets();
 
   // Instance creation
   static void create_mirror(Klass* k, Handle class_loader, Handle module,
-                            Handle protection_domain, TRAPS);
+                            Handle protection_domain, Handle classData, TRAPS);
   static void fixup_mirror(Klass* k, TRAPS);
   static oop  create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS);
   static void update_archived_primitive_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
   static void update_archived_mirror_native_pointers(oop archived_mirror) NOT_CDS_JAVA_HEAP_RETURN;
 
@@ -332,10 +336,12 @@
   static oop  protection_domain(oop java_class);
   static oop  init_lock(oop java_class);
   static oop  component_mirror(oop java_class);
   static objArrayOop  signers(oop java_class);
   static void set_signers(oop java_class, objArrayOop signers);
+  static oop  class_data(oop java_class);
+  static void set_class_data(oop java_class, oop classData);
 
   static oop class_loader(oop java_class);
   static void set_module(oop java_class, oop module);
   static oop module(oop java_class);
 
@@ -1150,20 +1156,24 @@
 
   static bool is_method(oop obj);
 
   // Relevant integer codes (keep these in synch. with MethodHandleNatives.Constants):
   enum {
-    MN_IS_METHOD             = 0x00010000, // method (not object constructor)
-    MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, // object constructor
+    MN_IS_METHOD             = 0x00010000, // method (not constructor)
+    MN_IS_OBJECT_CONSTRUCTOR = 0x00020000, // constructor
     MN_IS_FIELD              = 0x00040000, // field
     MN_IS_TYPE               = 0x00080000, // nested type
     MN_CALLER_SENSITIVE      = 0x00100000, // @CallerSensitive annotation detected
     MN_REFERENCE_KIND_SHIFT  = 24, // refKind
     MN_REFERENCE_KIND_MASK   = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,
     // The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:
     MN_SEARCH_SUPERCLASSES   = 0x00100000, // walk super classes
-    MN_SEARCH_INTERFACES     = 0x00200000  // walk implemented interfaces
+    MN_SEARCH_INTERFACES     = 0x00200000, // walk implemented interfaces
+    MN_NESTMATE_CLASS        = 0x00000001,
+    MN_HIDDEN_CLASS          = 0x00000002,
+    MN_STRONG_LOADER_LINK    = 0x00000004,
+    MN_ACCESS_VM_ANNOTATIONS = 0x00000008
   };
 
   // Accessors for code generation:
   static int clazz_offset_in_bytes()            { return _clazz_offset; }
   static int type_offset_in_bytes()             { return _type_offset; }
diff a/src/hotspot/share/classfile/systemDictionary.cpp b/src/hotspot/share/classfile/systemDictionary.cpp
--- a/src/hotspot/share/classfile/systemDictionary.cpp
+++ b/src/hotspot/share/classfile/systemDictionary.cpp
@@ -112,10 +112,50 @@
 
 // Default ProtectionDomainCacheSize value
 
 const int defaultProtectionDomainCacheSize = 1009;
 
+ClassLoadInfo::ClassLoadInfo() {
+  _protection_domain = Handle();
+  _unsafe_anonymous_host = NULL;
+  _cp_patches = NULL;
+  _class_hidden_info._dynamic_nest_host = NULL;
+  _class_hidden_info._class_data = Handle();
+  _is_hidden = false;
+  _is_strong_hidden = false;
+  _can_access_vm_annotations = false;
+}
+
+ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {
+  _protection_domain = protection_domain;
+  _unsafe_anonymous_host = NULL;
+  _cp_patches = NULL;
+  _class_hidden_info._dynamic_nest_host = NULL;
+  _class_hidden_info._class_data = Handle();
+  _is_hidden = false;
+  _is_strong_hidden = false;
+  _can_access_vm_annotations = false;
+}
+
+ClassLoadInfo::ClassLoadInfo(Handle protection_domain,
+                             const InstanceKlass* unsafe_anonymous_host,
+                             GrowableArray<Handle>* cp_patches,
+                             InstanceKlass* dynamic_nest_host,
+                             Handle class_data,
+                             bool is_hidden,
+                             bool is_strong_hidden,
+                             bool can_access_vm_annotations) {
+  _protection_domain = protection_domain;
+  _unsafe_anonymous_host = unsafe_anonymous_host;
+  _cp_patches = cp_patches;
+  _class_hidden_info._dynamic_nest_host = dynamic_nest_host;
+  _class_hidden_info._class_data = class_data;
+  _is_hidden = is_hidden;
+  _is_strong_hidden = is_strong_hidden;
+  _can_access_vm_annotations = can_access_vm_annotations;
+}
+
 // ----------------------------------------------------------------------------
 // Java-level SystemLoader and PlatformLoader
 
 oop SystemDictionary::java_system_loader() {
   return _java_system_loader;
@@ -867,11 +907,11 @@
         // i.e. now that we hold the LOAD_INSTANCE token on loading this class/CL
         // one final check if the load has already completed
         // class loaders holding the ObjectLock shouldn't find the class here
         InstanceKlass* check = find_class(d_hash, name, dictionary);
         if (check != NULL) {
-        // Klass is already loaded, so return it after checking/adding protection domain
+          // Klass is already loaded, so return it after checking/adding protection domain
           k = check;
           class_has_been_loaded = true;
         }
       }
     }
@@ -1027,28 +1067,40 @@
   return k;
 }
 
 // Note: this method is much like resolve_from_stream, but
 // does not publish the classes via the SystemDictionary.
-// Handles unsafe_DefineAnonymousClass and redefineclasses
-// RedefinedClasses do not add to the class hierarchy
+// Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
+// and redefineclasses. RedefinedClasses do not add to the class hierarchy.
 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
                                               Handle class_loader,
-                                              Handle protection_domain,
-                                              ClassFileStream* st,
-                                              const InstanceKlass* unsafe_anonymous_host,
+                                              ClassFileStream* st,
                                               GrowableArray<Handle>* cp_patches,
                                               TRAPS) {
 
   EventClassLoad class_load_start_event;
 
   ClassLoaderData* loader_data;
-  if (unsafe_anonymous_host != NULL) {
-    // Create a new CLD for an unsafe anonymous class, that uses the same class loader
-    // as the unsafe_anonymous_host
-    guarantee(unsafe_anonymous_host->class_loader() == class_loader(), "should be the same");
-    loader_data = ClassLoaderData::unsafe_anonymous_class_loader_data(class_loader);
+
+  bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;
+
+  if (is_unsafe_anon_class) {
+    // - for unsafe anonymous class: create a new CLD whith a class holder that uses
+    //                               the same class loader as the unsafe_anonymous_host.
+    guarantee(cl_info.unsafe_anonymous_host()->class_loader() == class_loader(),
+              "should be the same");
+    loader_data = ClassLoaderData::has_class_mirror_holder_cld(class_loader);
+  } else if (cl_info.is_hidden()) {
+    // - for hidden classes that are not strong: create a new CLD that has a class holder and
+    //                                           whose loader is the Lookup class' loader.
+    // - for hidden class: add the class to the Lookup class' loader's CLD.
+    if (!cl_info.is_strong_hidden()) {
+      loader_data = ClassLoaderData::has_class_mirror_holder_cld(class_loader);
+    } else {
+      // This hidden class goes into the regular CLD pool for this loader.
+      loader_data = register_loader(class_loader);
+    }
   } else {
     loader_data = ClassLoaderData::class_loader_data(class_loader());
   }
 
   assert(st != NULL, "invariant");
@@ -1060,19 +1112,20 @@
   // throw potential ClassFormatErrors.
 
   InstanceKlass* k = KlassFactory::create_from_stream(st,
                                                       class_name,
                                                       loader_data,
-                                                      protection_domain,
-                                                      unsafe_anonymous_host,
-                                                      cp_patches,
+                                                      cl_info,
                                                       CHECK_NULL);
 
-  if (unsafe_anonymous_host != NULL && k != NULL) {
-    // Unsafe anonymous classes must update ClassLoaderData holder (was unsafe_anonymous_host loader)
-    // so that they can be unloaded when the mirror is no longer referenced.
-    k->class_loader_data()->initialize_holder(Handle(THREAD, k->java_mirror()));
+  if ((cl_info.is_hidden() || is_unsafe_anon_class) && k != NULL) {
+    // Hidden classes that are not strong and unsafe anonymous classes must update
+    // ClassLoaderData holder so that they can be unloaded when the mirror is no
+    // longer referenced.
+    if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {
+      k->class_loader_data()->initialize_holder(Handle(THREAD, k->java_mirror()));
+    }
 
     {
       MutexLocker mu_r(THREAD, Compile_lock);
 
       // Add to class hierarchy, initialize vtables, and do possible
@@ -1081,27 +1134,29 @@
       // But, do not add to dictionary.
     }
 
     // Rewrite and patch constant pool here.
     k->link_class(CHECK_NULL);
-    if (cp_patches != NULL) {
-      k->constants()->patch_resolved_references(cp_patches);
+    if (cl_info.cp_patches() != NULL) {
+      k->constants()->patch_resolved_references(cl_info.cp_patches());
     }
 
     // If it's anonymous, initialize it now, since nobody else will.
-    k->eager_initialize(CHECK_NULL);
+    if (is_unsafe_anon_class) {
+      k->eager_initialize(CHECK_NULL);
+    }
 
     // notify jvmti
     if (JvmtiExport::should_post_class_load()) {
         assert(THREAD->is_Java_thread(), "thread->is_Java_thread()");
         JvmtiExport::post_class_load((JavaThread *) THREAD, k);
     }
     if (class_load_start_event.should_commit()) {
       post_class_load_event(&class_load_start_event, k, loader_data);
     }
   }
-  assert(unsafe_anonymous_host != NULL || NULL == cp_patches,
+  assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),
          "cp_patches only found with unsafe_anonymous_host");
 
   return k;
 }
 
@@ -1152,17 +1207,12 @@
 
   if (k == NULL) {
     if (st->buffer() == NULL) {
       return NULL;
     }
-    k = KlassFactory::create_from_stream(st,
-                                         class_name,
-                                         loader_data,
-                                         protection_domain,
-                                         NULL, // unsafe_anonymous_host
-                                         NULL, // cp_patches
-                                         CHECK_NULL);
+    ClassLoadInfo cl_info(protection_domain);
+    k = KlassFactory::create_from_stream(st, class_name, loader_data, cl_info, CHECK_NULL);
   }
 
   assert(k != NULL, "no klass created");
   Symbol* h_name = k->name();
   assert(class_name == NULL || class_name == h_name, "name mismatch");
@@ -1402,11 +1452,11 @@
 
   // For boot loader, ensure that GetSystemPackage knows that a class in this
   // package was loaded.
   if (loader_data->is_the_null_class_loader_data()) {
     int path_index = ik->shared_classpath_index();
-    ClassLoader::add_package(ik, path_index, THREAD);
+    ik->set_classpath_index(path_index, THREAD);
   }
 
   if (DumpLoadedClassList != NULL && classlist_file->is_open()) {
     // Only dump the classes that can be stored into CDS archive
     if (SystemDictionaryShared::is_sharing_possible(loader_data)) {
@@ -2372,10 +2422,46 @@
       return NULL;
     }
   }
 }
 
+// Add an entry to resolution error table to record an error in resolving or
+// validating a nest host. This is used to construct informative error
+// messages when IllegalAccessError's occur. If an entry already exists it will
+// be updated with the nest host error message.
+void SystemDictionary::add_nest_host_error(const constantPoolHandle& pool,
+                                           int which,
+                                           const char* message) {
+  unsigned int hash = resolution_errors()->compute_hash(pool, which);
+  int index = resolution_errors()->hash_to_index(hash);
+  {
+    MutexLocker ml(Thread::current(), SystemDictionary_lock);
+    ResolutionErrorEntry* entry = resolution_errors()->find_entry(index, hash, pool, which);
+    if (entry != NULL) {
+      assert(entry->nest_host_error() == NULL, "Nest host error message already set!");
+      entry->set_nest_host_error(message);
+    } else {
+      resolution_errors()->add_entry(index, hash, pool, which, message);
+    }
+  }
+}
+
+// Lookup any nest host error
+const char* SystemDictionary::find_nest_host_error(const constantPoolHandle& pool, int which) {
+  unsigned int hash = resolution_errors()->compute_hash(pool, which);
+  int index = resolution_errors()->hash_to_index(hash);
+  {
+    MutexLocker ml(Thread::current(), SystemDictionary_lock);
+    ResolutionErrorEntry* entry = resolution_errors()->find_entry(index, hash, pool, which);
+    if (entry != NULL) {
+      return entry->nest_host_error();
+    } else {
+      return NULL;
+    }
+  }
+}
+
 
 // Signature constraints ensure that callers and callees agree about
 // the meaning of type names in their signatures.  This routine is the
 // intake for constraints.  It collects them from several places:
 //
@@ -2501,19 +2587,20 @@
                                           TRAPS) {
   if (mname.not_null()) {
     Method* m = java_lang_invoke_MemberName::vmtarget(mname());
     if (m != NULL) {
       oop appendix = appendix_box->obj_at(0);
-      if (TraceMethodHandles) {
-    #ifndef PRODUCT
-        ttyLocker ttyl;
-        tty->print("Linked method=" INTPTR_FORMAT ": ", p2i(m));
-        m->print();
-        if (appendix != NULL) { tty->print("appendix = "); appendix->print(); }
-        tty->cr();
-    #endif //PRODUCT
+      LogTarget(Info, methodhandles) lt;
+      if (lt.develop_is_enabled()) {
+        ResourceMark rm(THREAD);
+        LogStream ls(lt);
+        ls.print("Linked method=" INTPTR_FORMAT ": ", p2i(m));
+        m->print_on(&ls);
+        if (appendix != NULL) { ls.print("appendix = "); appendix->print_on(&ls); }
+        ls.cr();
       }
+
       (*appendix_result) = Handle(THREAD, appendix);
       // the target is stored in the cpCache and if a reference to this
       // MemberName is dropped we need a way to make sure the
       // class_loader containing this method is kept alive.
       methodHandle mh(THREAD, m); // record_dependency can safepoint.
diff a/src/hotspot/share/classfile/systemDictionary.hpp b/src/hotspot/share/classfile/systemDictionary.hpp
--- a/src/hotspot/share/classfile/systemDictionary.hpp
+++ b/src/hotspot/share/classfile/systemDictionary.hpp
@@ -32,10 +32,57 @@
 #include "runtime/mutexLocker.hpp"
 #include "runtime/reflectionUtils.hpp"
 #include "runtime/signature.hpp"
 #include "utilities/hashtable.hpp"
 
+class ClassInstanceInfo : public StackObj {
+ private:
+  InstanceKlass* _dynamic_nest_host;
+  Handle _class_data;
+
+ public:
+  ClassInstanceInfo() {
+    _dynamic_nest_host = NULL;
+    _class_data = Handle();
+  }
+  ClassInstanceInfo(InstanceKlass* dynamic_nest_host, Handle class_data) {
+    _dynamic_nest_host = dynamic_nest_host;
+    _class_data = class_data;
+  }
+
+  InstanceKlass* dynamic_nest_host() const { return _dynamic_nest_host; }
+  Handle class_data() const { return _class_data; }
+  friend class ClassLoadInfo;
+};
+
+class ClassLoadInfo : public StackObj {
+ private:
+  Handle                 _protection_domain;
+  const InstanceKlass*   _unsafe_anonymous_host;
+  GrowableArray<Handle>* _cp_patches;
+  ClassInstanceInfo      _class_hidden_info;
+  bool                   _is_hidden;
+  bool                   _is_strong_hidden;
+  bool                   _can_access_vm_annotations;
+
+ public:
+  ClassLoadInfo();
+  ClassLoadInfo(Handle protection_domain);
+  ClassLoadInfo(Handle protection_domain, const InstanceKlass* unsafe_anonymous_host,
+                GrowableArray<Handle>* cp_patches, InstanceKlass* dynamic_nest_host,
+                Handle class_data, bool is_hidden, bool is_strong_hidden,
+                bool can_access_vm_annotations);
+
+  Handle protection_domain()             const { return _protection_domain; }
+  const InstanceKlass* unsafe_anonymous_host() const { return _unsafe_anonymous_host; }
+  GrowableArray<Handle>* cp_patches()    const { return _cp_patches; }
+  const ClassInstanceInfo* class_hidden_info_ptr() const { return &_class_hidden_info; }
+  bool is_hidden()                       const { return _is_hidden; }
+  bool is_strong_hidden()                const { return _is_strong_hidden; }
+  bool can_access_vm_annotations()       const { return _can_access_vm_annotations; }
+};
+
 // The dictionary in each ClassLoaderData stores all loaded classes, either
 // initiatied by its class loader or defined by its class loader:
 //
 //   class loader -> ClassLoaderData -> [class, protection domain set]
 //
@@ -279,31 +326,16 @@
                                                   Handle class_loader,
                                                   Handle protection_domain,
                                                   bool throw_error,
                                                   TRAPS);
 
-  // Parse new stream. This won't update the dictionary or
-  // class hierarchy, simply parse the stream. Used by JVMTI RedefineClasses.
-  // Also used by Unsafe_DefineAnonymousClass
-  static InstanceKlass* parse_stream(Symbol* class_name,
-                                     Handle class_loader,
-                                     Handle protection_domain,
-                                     ClassFileStream* st,
-                                     TRAPS) {
-    return parse_stream(class_name,
-                        class_loader,
-                        protection_domain,
-                        st,
-                        NULL, // unsafe_anonymous_host
-                        NULL, // cp_patches
-                        THREAD);
-  }
+  // Parse new stream. This won't update the dictionary or class
+  // hierarchy, simply parse the stream. Used by JVMTI RedefineClasses
+  // and by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.
   static InstanceKlass* parse_stream(Symbol* class_name,
                                      Handle class_loader,
-                                     Handle protection_domain,
-                                     ClassFileStream* st,
-                                     const InstanceKlass* unsafe_anonymous_host,
+                                     ClassFileStream* st,
                                      GrowableArray<Handle>* cp_patches,
                                      TRAPS);
 
   // Resolve from stream (called by jni_DefineClass and JVM_DefineClass)
   static InstanceKlass* resolve_from_stream(Symbol* class_name,
@@ -539,10 +571,15 @@
   static void delete_resolution_error(ConstantPool* pool);
   static Symbol* find_resolution_error(const constantPoolHandle& pool, int which,
                                        Symbol** message);
 
 
+  // Record a nest host resolution/validation error
+  static void add_nest_host_error(const constantPoolHandle& pool, int which,
+                                  const char* message);
+  static const char* find_nest_host_error(const constantPoolHandle& pool, int which);
+
   static ProtectionDomainCacheEntry* cache_get(Handle protection_domain);
 
  protected:
 
   enum Constants {
diff a/src/hotspot/share/classfile/verificationType.cpp b/src/hotspot/share/classfile/verificationType.cpp
--- a/src/hotspot/share/classfile/verificationType.cpp
+++ b/src/hotspot/share/classfile/verificationType.cpp
@@ -46,15 +46,20 @@
 }
 
 bool VerificationType::resolve_and_check_assignability(InstanceKlass* klass, Symbol* name,
          Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object, TRAPS) {
   HandleMark hm(THREAD);
-  Klass* this_class = SystemDictionary::resolve_or_fail(
+  Klass* this_class;
+  if (klass->is_hidden() && klass->name() == name) {
+    this_class = klass;
+  } else {
+    this_class = SystemDictionary::resolve_or_fail(
       name, Handle(THREAD, klass->class_loader()),
       Handle(THREAD, klass->protection_domain()), true, CHECK_false);
-  if (log_is_enabled(Debug, class, resolve)) {
-    Verifier::trace_class_resolution(this_class, klass);
+    if (log_is_enabled(Debug, class, resolve)) {
+      Verifier::trace_class_resolution(this_class, klass);
+    }
   }
 
   if (this_class->access_flags().is_inline_type()) return false;
   if (this_class->is_interface() && (!from_field_is_protected ||
       from_name != vmSymbols::java_lang_Object())) {
@@ -66,15 +71,20 @@
     return !from_is_array ||
       this_class == SystemDictionary::Cloneable_klass() ||
       this_class == SystemDictionary::Serializable_klass() ||
       this_class == SystemDictionary::IdentityObject_klass();
   } else if (from_is_object) {
-    Klass* from_class = SystemDictionary::resolve_or_fail(
+    Klass* from_class;
+    if (klass->is_hidden() && klass->name() == from_name) {
+      from_class = klass;
+    } else {
+      from_class = SystemDictionary::resolve_or_fail(
         from_name, Handle(THREAD, klass->class_loader()),
         Handle(THREAD, klass->protection_domain()), true, CHECK_false);
-    if (log_is_enabled(Debug, class, resolve)) {
-      Verifier::trace_class_resolution(from_class, klass);
+      if (log_is_enabled(Debug, class, resolve)) {
+        Verifier::trace_class_resolution(from_class, klass);
+      }
     }
     return from_class->is_subclass_of(this_class);
   }
 
   return false;
diff a/src/hotspot/share/classfile/verifier.cpp b/src/hotspot/share/classfile/verifier.cpp
--- a/src/hotspot/share/classfile/verifier.cpp
+++ b/src/hotspot/share/classfile/verifier.cpp
@@ -2126,10 +2126,12 @@
   HandleMark hm(THREAD);
   // Get current loader and protection domain first.
   oop loader = current_class()->class_loader();
   oop protection_domain = current_class()->protection_domain();
 
+  assert(name_in_supers(name, current_class()), "name should be a super class");
+
   Klass* kls = SystemDictionary::resolve_or_fail(
     name, Handle(THREAD, loader), Handle(THREAD, protection_domain),
     true, THREAD);
 
   if (kls != NULL) {
diff a/src/hotspot/share/classfile/vmSymbols.cpp b/src/hotspot/share/classfile/vmSymbols.cpp
--- a/src/hotspot/share/classfile/vmSymbols.cpp
+++ b/src/hotspot/share/classfile/vmSymbols.cpp
@@ -544,10 +544,11 @@
   case vmIntrinsics::_isAssignableFrom:
   case vmIntrinsics::_getModifiers:
   case vmIntrinsics::_isInterface:
   case vmIntrinsics::_isArray:
   case vmIntrinsics::_isPrimitive:
+  case vmIntrinsics::_isHidden:
   case vmIntrinsics::_getSuperclass:
   case vmIntrinsics::_Class_cast:
   case vmIntrinsics::_getLength:
   case vmIntrinsics::_newArray:
   case vmIntrinsics::_getClass:
diff a/src/hotspot/share/classfile/vmSymbols.hpp b/src/hotspot/share/classfile/vmSymbols.hpp
--- a/src/hotspot/share/classfile/vmSymbols.hpp
+++ b/src/hotspot/share/classfile/vmSymbols.hpp
@@ -892,10 +892,12 @@
    do_name(     isInterface_name,                                "isInterface")                                         \
   do_intrinsic(_isArray,                  java_lang_Class,        isArray_name, void_boolean_signature,          F_RN)  \
    do_name(     isArray_name,                                    "isArray")                                             \
   do_intrinsic(_isPrimitive,              java_lang_Class,        isPrimitive_name, void_boolean_signature,      F_RN)  \
    do_name(     isPrimitive_name,                                "isPrimitive")                                         \
+  do_intrinsic(_isHidden,                 java_lang_Class,        isHidden_name, void_boolean_signature,         F_RN)  \
+   do_name(     isHidden_name,                                   "isHidden")                                            \
   do_intrinsic(_getSuperclass,            java_lang_Class,        getSuperclass_name, void_class_signature,      F_RN)  \
    do_name(     getSuperclass_name,                              "getSuperclass")                                       \
   do_intrinsic(_Class_cast,               java_lang_Class,        Class_cast_name, object_object_signature,      F_R)   \
    do_name(     Class_cast_name,                                 "cast")                                                \
                                                                                                                         \
diff a/src/hotspot/share/compiler/compileBroker.cpp b/src/hotspot/share/compiler/compileBroker.cpp
--- a/src/hotspot/share/compiler/compileBroker.cpp
+++ b/src/hotspot/share/compiler/compileBroker.cpp
@@ -590,11 +590,11 @@
 CompilerCounters::CompilerCounters() {
   _current_method[0] = '\0';
   _compile_type = CompileBroker::no_compile;
 }
 
-#if INCLUDE_JFR
+#if INCLUDE_JFR && COMPILER2_OR_JVMCI
 // It appends new compiler phase names to growable array phase_names(a new CompilerPhaseType mapping
 // in compiler/compilerEvent.cpp) and registers it with its serializer.
 //
 // c2 uses explicit CompilerPhaseType idToPhase mapping in opto/phasetype.hpp,
 // so if c2 is used, it should be always registered first.
@@ -606,21 +606,23 @@
     // register serializer, phases will be added later lazily.
     GrowableArray<const char*>* jvmci_phase_names = new GrowableArray<const char*>(1);
     jvmci_phase_names->append("NOT_A_PHASE_NAME");
     CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);
     first_registration = false;
+#ifdef COMPILER2
   } else if (compiler_type == compiler_c2) {
     assert(first_registration, "invariant"); // c2 must be registered first.
     GrowableArray<const char*>* c2_phase_names = new GrowableArray<const char*>(PHASE_NUM_TYPES);
     for (int i = 0; i < PHASE_NUM_TYPES; i++) {
       c2_phase_names->append(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));
     }
     CompilerEvent::PhaseEvent::register_phases(c2_phase_names);
     first_registration = false;
+#endif // COMPILER2
   }
 }
-#endif // INCLUDE_JFR
+#endif // INCLUDE_JFR && COMPILER2_OR_JVMCI
 
 // ------------------------------------------------------------------
 // CompileBroker::compilation_init
 //
 // Initialize the Compilation object
diff a/src/hotspot/share/gc/parallel/psParallelCompact.cpp b/src/hotspot/share/gc/parallel/psParallelCompact.cpp
--- a/src/hotspot/share/gc/parallel/psParallelCompact.cpp
+++ b/src/hotspot/share/gc/parallel/psParallelCompact.cpp
@@ -1038,14 +1038,10 @@
   MutableSpace* const from_space = _space_info[from_space_id].space();
   MutableSpace* const to_space   = _space_info[to_space_id].space();
 
   ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();
   bool eden_empty = eden_space->is_empty();
-  if (!eden_empty) {
-    eden_empty = absorb_live_data_from_eden(heap->size_policy(),
-                                            heap->young_gen(), heap->old_gen());
-  }
 
   // Update heap occupancy information which is used as input to the soft ref
   // clearing policy at the next gc.
   Universe::update_heap_info_at_gc();
 
@@ -1981,99 +1977,10 @@
   _gc_tracer.report_gc_end(_gc_timer.gc_end(), _gc_timer.time_partitions());
 
   return true;
 }
 
-bool PSParallelCompact::absorb_live_data_from_eden(PSAdaptiveSizePolicy* size_policy,
-                                             PSYoungGen* young_gen,
-                                             PSOldGen* old_gen) {
-  MutableSpace* const eden_space = young_gen->eden_space();
-  assert(!eden_space->is_empty(), "eden must be non-empty");
-  assert(young_gen->virtual_space()->alignment() ==
-         old_gen->virtual_space()->alignment(), "alignments do not match");
-
-  // We also return false when it's a heterogeneous heap because old generation cannot absorb data from eden
-  // when it is allocated on different memory (example, nv-dimm) than young.
-  if (!(UseAdaptiveSizePolicy && UseAdaptiveGCBoundary) ||
-      ParallelArguments::is_heterogeneous_heap()) {
-    return false;
-  }
-
-  // Both generations must be completely committed.
-  if (young_gen->virtual_space()->uncommitted_size() != 0) {
-    return false;
-  }
-  if (old_gen->virtual_space()->uncommitted_size() != 0) {
-    return false;
-  }
-
-  // Figure out how much to take from eden.  Include the average amount promoted
-  // in the total; otherwise the next young gen GC will simply bail out to a
-  // full GC.
-  const size_t alignment = old_gen->virtual_space()->alignment();
-  const size_t eden_used = eden_space->used_in_bytes();
-  const size_t promoted = (size_t)size_policy->avg_promoted()->padded_average();
-  const size_t absorb_size = align_up(eden_used + promoted, alignment);
-  const size_t eden_capacity = eden_space->capacity_in_bytes();
-
-  if (absorb_size >= eden_capacity) {
-    return false; // Must leave some space in eden.
-  }
-
-  const size_t new_young_size = young_gen->capacity_in_bytes() - absorb_size;
-  if (new_young_size < young_gen->min_gen_size()) {
-    return false; // Respect young gen minimum size.
-  }
-
-  log_trace(gc, ergo, heap)(" absorbing " SIZE_FORMAT "K:  "
-                            "eden " SIZE_FORMAT "K->" SIZE_FORMAT "K "
-                            "from " SIZE_FORMAT "K, to " SIZE_FORMAT "K "
-                            "young_gen " SIZE_FORMAT "K->" SIZE_FORMAT "K ",
-                            absorb_size / K,
-                            eden_capacity / K, (eden_capacity - absorb_size) / K,
-                            young_gen->from_space()->used_in_bytes() / K,
-                            young_gen->to_space()->used_in_bytes() / K,
-                            young_gen->capacity_in_bytes() / K, new_young_size / K);
-
-  // Fill the unused part of the old gen.
-  MutableSpace* const old_space = old_gen->object_space();
-  HeapWord* const unused_start = old_space->top();
-  size_t const unused_words = pointer_delta(old_space->end(), unused_start);
-
-  if (unused_words > 0) {
-    if (unused_words < CollectedHeap::min_fill_size()) {
-      return false;  // If the old gen cannot be filled, must give up.
-    }
-    CollectedHeap::fill_with_objects(unused_start, unused_words);
-  }
-
-  // Take the live data from eden and set both top and end in the old gen to
-  // eden top.  (Need to set end because reset_after_change() mangles the region
-  // from end to virtual_space->high() in debug builds).
-  HeapWord* const new_top = eden_space->top();
-  old_gen->virtual_space()->expand_into(young_gen->virtual_space(),
-                                        absorb_size);
-  young_gen->reset_after_change();
-  old_space->set_top(new_top);
-  old_space->set_end(new_top);
-  old_gen->reset_after_change();
-
-  // Update the object start array for the filler object and the data from eden.
-  ObjectStartArray* const start_array = old_gen->start_array();
-  for (HeapWord* p = unused_start; p < new_top; p += oop(p)->size()) {
-    start_array->allocate_block(p);
-  }
-
-  // Could update the promoted average here, but it is not typically updated at
-  // full GCs and the value to use is unclear.  Something like
-  //
-  // cur_promoted_avg + absorb_size / number_of_scavenges_since_last_full_gc.
-
-  size_policy->set_bytes_absorbed_from_eden(absorb_size);
-  return true;
-}
-
 class PCAddThreadRootsMarkingTaskClosure : public ThreadClosure {
 private:
   uint _worker_id;
 
 public:
diff a/src/hotspot/share/interpreter/linkResolver.cpp b/src/hotspot/share/interpreter/linkResolver.cpp
--- a/src/hotspot/share/interpreter/linkResolver.cpp
+++ b/src/hotspot/share/interpreter/linkResolver.cpp
@@ -434,48 +434,44 @@
 }
 
 Method* LinkResolver::lookup_polymorphic_method(const LinkInfo& link_info,
                                                 Handle *appendix_result_or_null,
                                                 TRAPS) {
+  ResourceMark rm(THREAD);
   Klass* klass = link_info.resolved_klass();
   Symbol* name = link_info.name();
   Symbol* full_signature = link_info.signature();
+  LogTarget(Info, methodhandles) lt_mh;
 
   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
-  if (TraceMethodHandles) {
-    ResourceMark rm(THREAD);
-    tty->print_cr("lookup_polymorphic_method iid=%s %s.%s%s",
-                  vmIntrinsics::name_at(iid), klass->external_name(),
-                  name->as_C_string(), full_signature->as_C_string());
-  }
+  log_info(methodhandles)("lookup_polymorphic_method iid=%s %s.%s%s",
+                          vmIntrinsics::name_at(iid), klass->external_name(),
+                          name->as_C_string(), full_signature->as_C_string());
   if ((klass == SystemDictionary::MethodHandle_klass() ||
        klass == SystemDictionary::VarHandle_klass()) &&
       iid != vmIntrinsics::_none) {
     if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
       // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
       // Do not erase last argument type (MemberName) if it is a static linkTo method.
       bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
       TempNewSymbol basic_signature =
         MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
-      if (TraceMethodHandles) {
-        ResourceMark rm(THREAD);
-        tty->print_cr("lookup_polymorphic_method %s %s => basic %s",
-                      name->as_C_string(),
-                      full_signature->as_C_string(),
-                      basic_signature->as_C_string());
-      }
+      log_info(methodhandles)("lookup_polymorphic_method %s %s => basic %s",
+                              name->as_C_string(),
+                              full_signature->as_C_string(),
+                              basic_signature->as_C_string());
       Method* result = SystemDictionary::find_method_handle_intrinsic(iid,
                                                               basic_signature,
                                                               CHECK_NULL);
       if (result != NULL) {
         assert(result->is_method_handle_intrinsic(), "MH.invokeBasic or MH.linkTo* intrinsic");
         assert(result->intrinsic_id() != vmIntrinsics::_invokeGeneric, "wrong place to find this");
         assert(basic_signature == result->signature(), "predict the result signature");
-        if (TraceMethodHandles) {
-          ttyLocker ttyl;
-          tty->print("lookup_polymorphic_method => intrinsic ");
-          result->print_on(tty);
+        if (lt_mh.is_enabled()) {
+          LogStream ls(lt_mh);
+          ls.print("lookup_polymorphic_method => intrinsic ");
+          result->print_on(&ls);
         }
       }
       return result;
     } else if (iid == vmIntrinsics::_invokeGeneric
                && THREAD->can_call_java()
@@ -501,17 +497,16 @@
                                                             name,
                                                             full_signature,
                                                             link_info.current_klass(),
                                                             &appendix,
                                                             CHECK_NULL);
-      if (TraceMethodHandles) {
-        ttyLocker ttyl;
-        tty->print("lookup_polymorphic_method => (via Java) ");
-        result->print_on(tty);
-        tty->print("  lookup_polymorphic_method => appendix = ");
-        if (appendix.is_null())  tty->print_cr("(none)");
-        else                     appendix->print_on(tty);
+      if (lt_mh.is_enabled()) {
+        LogStream ls(lt_mh);
+        ls.print("lookup_polymorphic_method => (via Java) ");
+        result->print_on(&ls);
+        ls.print("  lookup_polymorphic_method => appendix = ");
+        appendix.is_null() ? ls.print_cr("(none)") : appendix->print_on(&ls);
       }
       if (result != NULL) {
 #ifdef ASSERT
         ResourceMark rm(THREAD);
 
@@ -538,10 +533,25 @@
     }
   }
   return NULL;
 }
 
+static void print_nest_host_error_on(stringStream* ss, Klass* ref_klass, Klass* sel_klass, TRAPS) {
+  assert(ref_klass->is_instance_klass(), "must be");
+  assert(sel_klass->is_instance_klass(), "must be");
+  InstanceKlass* ref_ik = InstanceKlass::cast(ref_klass);
+  InstanceKlass* sel_ik = InstanceKlass::cast(sel_klass);
+  const char* nest_host_error_1 = ref_ik->nest_host_error(THREAD);
+  const char* nest_host_error_2 = sel_ik->nest_host_error(THREAD);
+  if (nest_host_error_1 != NULL || nest_host_error_2 != NULL) {
+    ss->print(", (%s%s%s)",
+              (nest_host_error_1 != NULL) ? nest_host_error_1 : "",
+              (nest_host_error_1 != NULL && nest_host_error_2 != NULL) ? ", " : "",
+              (nest_host_error_2 != NULL) ? nest_host_error_2 : "");
+  }
+}
+
 void LinkResolver::check_method_accessability(Klass* ref_klass,
                                               Klass* resolved_klass,
                                               Klass* sel_klass,
                                               const methodHandle& sel_method,
                                               TRAPS) {
@@ -570,28 +580,38 @@
   bool can_access = Reflection::verify_member_access(ref_klass,
                                                      resolved_klass,
                                                      sel_klass,
                                                      flags,
                                                      true, false, CHECK);
-  // Any existing exceptions that may have been thrown, for example LinkageErrors
-  // from nest-host resolution, have been allowed to propagate.
+  // Any existing exceptions that may have been thrown
+  // have been allowed to propagate.
   if (!can_access) {
     ResourceMark rm(THREAD);
+    stringStream ss;
     bool same_module = (sel_klass->module() == ref_klass->module());
-    Exceptions::fthrow(
-      THREAD_AND_LOCATION,
-      vmSymbols::java_lang_IllegalAccessError(),
-      "class %s tried to access %s%s%smethod '%s' (%s%s%s)",
-      ref_klass->external_name(),
-      sel_method->is_abstract()  ? "abstract "  : "",
-      sel_method->is_protected() ? "protected " : "",
-      sel_method->is_private()   ? "private "   : "",
-      sel_method->external_name(),
-      (same_module) ? ref_klass->joint_in_module_of_loader(sel_klass) : ref_klass->class_in_module_of_loader(),
-      (same_module) ? "" : "; ",
-      (same_module) ? "" : sel_klass->class_in_module_of_loader()
-    );
+    ss.print("class %s tried to access %s%s%smethod '%s' (%s%s%s)",
+             ref_klass->external_name(),
+             sel_method->is_abstract()  ? "abstract "  : "",
+             sel_method->is_protected() ? "protected " : "",
+             sel_method->is_private()   ? "private "   : "",
+             sel_method->external_name(),
+             (same_module) ? ref_klass->joint_in_module_of_loader(sel_klass) : ref_klass->class_in_module_of_loader(),
+             (same_module) ? "" : "; ",
+             (same_module) ? "" : sel_klass->class_in_module_of_loader()
+             );
+
+    // For private access see if there was a problem with nest host
+    // resolution, and if so report that as part of the message.
+    if (sel_method->is_private()) {
+      print_nest_host_error_on(&ss, ref_klass, sel_klass, THREAD);
+    }
+
+    Exceptions::fthrow(THREAD_AND_LOCATION,
+                       vmSymbols::java_lang_IllegalAccessError(),
+                       "%s",
+                       ss.as_string()
+                       );
     return;
   }
 }
 
 Method* LinkResolver::resolve_method_statically(Bytecodes::Code code,
@@ -906,23 +926,31 @@
   // Any existing exceptions that may have been thrown, for example LinkageErrors
   // from nest-host resolution, have been allowed to propagate.
   if (!can_access) {
     bool same_module = (sel_klass->module() == ref_klass->module());
     ResourceMark rm(THREAD);
-    Exceptions::fthrow(
-      THREAD_AND_LOCATION,
-      vmSymbols::java_lang_IllegalAccessError(),
-      "class %s tried to access %s%sfield %s.%s (%s%s%s)",
-      ref_klass->external_name(),
-      fd.is_protected() ? "protected " : "",
-      fd.is_private()   ? "private "   : "",
-      sel_klass->external_name(),
-      fd.name()->as_C_string(),
-      (same_module) ? ref_klass->joint_in_module_of_loader(sel_klass) : ref_klass->class_in_module_of_loader(),
-      (same_module) ? "" : "; ",
-      (same_module) ? "" : sel_klass->class_in_module_of_loader()
-    );
+    stringStream ss;
+    ss.print("class %s tried to access %s%sfield %s.%s (%s%s%s)",
+             ref_klass->external_name(),
+             fd.is_protected() ? "protected " : "",
+             fd.is_private()   ? "private "   : "",
+             sel_klass->external_name(),
+             fd.name()->as_C_string(),
+             (same_module) ? ref_klass->joint_in_module_of_loader(sel_klass) : ref_klass->class_in_module_of_loader(),
+             (same_module) ? "" : "; ",
+             (same_module) ? "" : sel_klass->class_in_module_of_loader()
+             );
+    // For private access see if there was a problem with nest host
+    // resolution, and if so report that as part of the message.
+    if (fd.is_private()) {
+      print_nest_host_error_on(&ss, ref_klass, sel_klass, THREAD);
+    }
+    Exceptions::fthrow(THREAD_AND_LOCATION,
+                       vmSymbols::java_lang_IllegalAccessError(),
+                       "%s",
+                       ss.as_string()
+                       );
     return;
   }
 }
 
 void LinkResolver::resolve_field_access(fieldDescriptor& fd, const constantPoolHandle& pool, int index, const methodHandle& method, Bytecodes::Code byte, TRAPS) {
@@ -1684,14 +1712,14 @@
 
 
 void LinkResolver::resolve_invokehandle(CallInfo& result, const constantPoolHandle& pool, int index, TRAPS) {
   // This guy is reached from InterpreterRuntime::resolve_invokehandle.
   LinkInfo link_info(pool, index, CHECK);
-  if (TraceMethodHandles) {
+  if (log_is_enabled(Info, methodhandles)) {
     ResourceMark rm(THREAD);
-    tty->print_cr("resolve_invokehandle %s %s", link_info.name()->as_C_string(),
-                  link_info.signature()->as_C_string());
+    log_info(methodhandles)("resolve_invokehandle %s %s", link_info.name()->as_C_string(),
+                            link_info.signature()->as_C_string());
   }
   resolve_handle_call(result, link_info, CHECK);
 }
 
 void LinkResolver::resolve_handle_call(CallInfo& result,
@@ -1728,12 +1756,14 @@
   // set the indy_rf flag since any subsequent invokedynamic instruction which shares
   // this bootstrap method will encounter the resolution of MethodHandleInError.
 
   resolve_dynamic_call(result, bootstrap_specifier, CHECK);
 
-  if (TraceMethodHandles) {
-    bootstrap_specifier.print_msg_on(tty, "resolve_invokedynamic");
+  LogTarget(Debug, methodhandles, indy) lt_indy;
+  if (lt_indy.is_enabled()) {
+    LogStream ls(lt_indy);
+    bootstrap_specifier.print_msg_on(&ls, "resolve_invokedynamic");
   }
 
   // The returned linkage result is provisional up to the moment
   // the interpreter or runtime performs a serialized check of
   // the relevant CPCE::f1 field.  This is done by the caller
@@ -1750,11 +1780,11 @@
   // The appendix argument is likely to be a freshly-created CallSite.
   // It may also be a MethodHandle from an unwrapped ConstantCallSite,
   // or any other reference.  The resolved_method as well as the appendix
   // are both recorded together via CallInfo::set_handle.
   SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
-  Exceptions::wrap_dynamic_exception(THREAD);
+  Exceptions::wrap_dynamic_exception(/* is_indy */ true, THREAD);
 
   if (HAS_PENDING_EXCEPTION) {
     if (!PENDING_EXCEPTION->is_a(SystemDictionary::LinkageError_klass())) {
       // Let any random low-level IE or SOE or OOME just bleed through.
       // Basically we pretend that the bootstrap method was never called,
diff a/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp b/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
--- a/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
+++ b/src/hotspot/share/jvmci/jvmciCodeInstaller.cpp
@@ -42,10 +42,11 @@
 ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(-1);
 ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue((jint)0);
 ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(1);
 ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(2);
 LocationValue*         CodeInstaller::_illegal_value = new (ResourceObj::C_HEAP, mtJVMCI) LocationValue(Location());
+MarkerValue*           CodeInstaller::_virtual_byte_array_marker = new (ResourceObj::C_HEAP, mtJVMCI) MarkerValue();
 
 VMReg CodeInstaller::getVMRegFromLocation(JVMCIObject location, int total_frame_size, JVMCI_TRAPS) {
   if (location.is_null()) {
     JVMCI_THROW_NULL(NullPointerException);
   }
@@ -418,25 +419,49 @@
 void CodeInstaller::record_object_value(ObjectValue* sv, JVMCIObject value, GrowableArray<ScopeValue*>* objects, JVMCI_TRAPS) {
   JVMCIObject type = jvmci_env()->get_VirtualObject_type(value);
   int id = jvmci_env()->get_VirtualObject_id(value);
   Klass* klass = JVMCIENV->asKlass(type);
   bool isLongArray = klass == Universe::longArrayKlassObj();
+  bool isByteArray = klass == Universe::byteArrayKlassObj();
 
   JVMCIObjectArray values = jvmci_env()->get_VirtualObject_values(value);
   JVMCIObjectArray slotKinds = jvmci_env()->get_VirtualObject_slotKinds(value);
   for (jint i = 0; i < JVMCIENV->get_length(values); i++) {
     ScopeValue* cur_second = NULL;
     JVMCIObject object = JVMCIENV->get_object_at(values, i);
     BasicType type = jvmci_env()->kindToBasicType(JVMCIENV->get_object_at(slotKinds, i), JVMCI_CHECK);
-    ScopeValue* value = get_scope_value(object, type, objects, cur_second, JVMCI_CHECK);
+    ScopeValue* value;
+    if (JVMCIENV->equals(object, jvmci_env()->get_Value_ILLEGAL())) {
+      if (isByteArray && type == T_ILLEGAL) {
+        /*
+         * The difference between a virtualized large access and a deferred write is the kind stored in the slotKinds
+         * of the virtual object: in the virtualization case, the kind is illegal, in the deferred write case, the kind
+         * is access stack kind (an int).
+         */
+        value = _virtual_byte_array_marker;
+      } else {
+        value = _illegal_value;
+        if (type == T_DOUBLE || type == T_LONG) {
+            cur_second = _illegal_value;
+        }
+      }
+    } else {
+      value = get_scope_value(object, type, objects, cur_second, JVMCI_CHECK);
+    }
 
     if (isLongArray && cur_second == NULL) {
       // we're trying to put ints into a long array... this isn't really valid, but it's used for some optimizations.
       // add an int 0 constant
       cur_second = _int_0_scope_value;
     }
 
+    if (isByteArray && cur_second != NULL && (type == T_DOUBLE || type == T_LONG)) {
+      // we are trying to write a long in a byte Array. We will need to count the illegals to restore the type of
+      // the thing we put inside.
+      cur_second = NULL;
+    }
+
     if (cur_second != NULL) {
       sv->field_values()->append(cur_second);
     }
     assert(value != NULL, "missing value");
     sv->field_values()->append(value);
diff a/src/hotspot/share/jvmci/vmStructs_jvmci.cpp b/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
--- a/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
+++ b/src/hotspot/share/jvmci/vmStructs_jvmci.cpp
@@ -540,10 +540,11 @@
   declare_constant(Deoptimization::Reason_transfer_to_interpreter)        \
   declare_constant(Deoptimization::Reason_not_compiled_exception_handler) \
   declare_constant(Deoptimization::Reason_unresolved)                     \
   declare_constant(Deoptimization::Reason_jsr_mismatch)                   \
   declare_constant(Deoptimization::Reason_LIMIT)                          \
+  declare_constant(Deoptimization::_support_large_access_byte_array_virtualization)               \
                                                                           \
   declare_constant(FieldInfo::access_flags_offset)                        \
   declare_constant(FieldInfo::name_index_offset)                          \
   declare_constant(FieldInfo::signature_index_offset)                     \
   declare_constant(FieldInfo::initval_index_offset)                       \
diff a/src/hotspot/share/logging/logTag.hpp b/src/hotspot/share/logging/logTag.hpp
--- a/src/hotspot/share/logging/logTag.hpp
+++ b/src/hotspot/share/logging/logTag.hpp
@@ -50,10 +50,11 @@
   LOG_TAG(classhisto) \
   LOG_TAG(cleanup) \
   LOG_TAG(codecache) \
   LOG_TAG(compaction) \
   LOG_TAG(compilation) \
+  LOG_TAG(condy) \
   LOG_TAG(constraints) \
   LOG_TAG(constantpool) \
   LOG_TAG(container) \
   LOG_TAG(coops) \
   LOG_TAG(cpu) \
@@ -78,10 +79,11 @@
   LOG_TAG(hashtables) \
   LOG_TAG(heap) \
   LOG_TAG(humongous) \
   LOG_TAG(ihop) \
   LOG_TAG(iklass) \
+  LOG_TAG(indy) \
   LOG_TAG(init) \
   LOG_TAG(inlining) \
   LOG_TAG(install) \
   LOG_TAG(interpreter) \
   LOG_TAG(itables) \
@@ -100,10 +102,11 @@
   LOG_TAG(membername) \
   LOG_TAG(memops) \
   LOG_TAG(methodcomparator) \
   LOG_TAG(metadata) \
   LOG_TAG(metaspace) \
+  LOG_TAG(methodhandles) \
   LOG_TAG(mmu) \
   LOG_TAG(module) \
   LOG_TAG(monitorinflation) \
   LOG_TAG(monitormismatch) \
   LOG_TAG(nestmates) \
diff a/src/hotspot/share/memory/metaspace.cpp b/src/hotspot/share/memory/metaspace.cpp
--- a/src/hotspot/share/memory/metaspace.cpp
+++ b/src/hotspot/share/memory/metaspace.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -62,11 +62,11 @@
 static const char* space_type_name(Metaspace::MetaspaceType t) {
   const char* s = NULL;
   switch (t) {
     case Metaspace::StandardMetaspaceType: s = "Standard"; break;
     case Metaspace::BootMetaspaceType: s = "Boot"; break;
-    case Metaspace::UnsafeAnonymousMetaspaceType: s = "UnsafeAnonymous"; break;
+    case Metaspace::ClassMirrorHolderMetaspaceType: s = "ClassMirrorHolder"; break;
     case Metaspace::ReflectionMetaspaceType: s = "Reflection"; break;
     default: ShouldNotReachHere();
   }
   return s;
 }
diff a/src/hotspot/share/oops/arrayKlass.cpp b/src/hotspot/share/oops/arrayKlass.cpp
--- a/src/hotspot/share/oops/arrayKlass.cpp
+++ b/src/hotspot/share/oops/arrayKlass.cpp
@@ -144,11 +144,11 @@
   // These classes will be put on a fixup list and their module fields will be patched once
   // java.base is defined.
   assert((module_entry != NULL) || ((module_entry == NULL) && !ModuleEntryTable::javabase_defined()),
          "module entry not available post " JAVA_BASE_NAME " definition");
   oop module = (module_entry != NULL) ? module_entry->module() : (oop)NULL;
-  java_lang_Class::create_mirror(k, Handle(THREAD, k->class_loader()), Handle(THREAD, module), Handle(), CHECK);
+  java_lang_Class::create_mirror(k, Handle(THREAD, k->class_loader()), Handle(THREAD, module), Handle(), Handle(), CHECK);
 }
 
 GrowableArray<Klass*>* ArrayKlass::compute_secondary_supers(int num_extra_slots,
                                                             Array<InstanceKlass*>* transitive_interfaces) {
   // interfaces = { cloneable_klass, serializable_klass };
diff a/src/hotspot/share/oops/constantPool.cpp b/src/hotspot/share/oops/constantPool.cpp
--- a/src/hotspot/share/oops/constantPool.cpp
+++ b/src/hotspot/share/oops/constantPool.cpp
@@ -30,10 +30,12 @@
 #include "classfile/stringTable.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/vmSymbols.hpp"
 #include "interpreter/bootstrapInfo.hpp"
 #include "interpreter/linkResolver.hpp"
+#include "logging/log.hpp"
+#include "logging/logStream.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/heapShared.hpp"
 #include "memory/metadataFactory.hpp"
 #include "memory/metaspaceClosure.hpp"
 #include "memory/metaspaceShared.hpp"
@@ -976,11 +978,11 @@
       // bootstrap method will encounter the resolution of MethodHandleInError.
       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,
       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()
       // for the bootstrap_specifier created above.
       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
-      Exceptions::wrap_dynamic_exception(THREAD);
+      Exceptions::wrap_dynamic_exception(/* is_indy */ false, THREAD);
       if (HAS_PENDING_EXCEPTION) {
         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
         // will check for a LinkageError and store a DynamicConstantInError.
         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
       }
@@ -1004,12 +1006,14 @@
           // See section 5.4.3 of the VM spec.
           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
         }
       }
 
-      if (TraceMethodHandles) {
-        bootstrap_specifier.print_msg_on(tty, "resolve_constant_at_impl");
+      LogTarget(Debug, methodhandles, condy) lt_condy;
+      if (lt_condy.is_enabled()) {
+        LogStream ls(lt_condy);
+        bootstrap_specifier.print_msg_on(&ls, "resolve_constant_at_impl");
       }
       break;
     }
 
   case JVM_CONSTANT_String:
diff a/src/hotspot/share/oops/cpCache.cpp b/src/hotspot/share/oops/cpCache.cpp
--- a/src/hotspot/share/oops/cpCache.cpp
+++ b/src/hotspot/share/oops/cpCache.cpp
@@ -28,10 +28,11 @@
 #include "interpreter/bytecodes.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/linkResolver.hpp"
 #include "interpreter/rewriter.hpp"
 #include "logging/log.hpp"
+#include "logging/logStream.hpp"
 #include "memory/heapShared.hpp"
 #include "memory/metadataFactory.hpp"
 #include "memory/metaspaceClosure.hpp"
 #include "memory/metaspaceShared.hpp"
 #include "memory/resourceArea.hpp"
@@ -416,19 +417,22 @@
                    ((has_appendix    ? 1 : 0) << has_appendix_shift        ) |
                    (                   1      << has_local_signature_shift ) |
                    (                   1      << is_final_shift            ),
                    adapter->size_of_parameters());
 
-  if (TraceInvokeDynamic) {
-    ttyLocker ttyl;
-    tty->print_cr("set_method_handle bc=%d appendix=" PTR_FORMAT "%s method=" PTR_FORMAT " (local signature) ",
-                  invoke_code,
-                  p2i(appendix()),
-                  (has_appendix ? "" : " (unused)"),
-                  p2i(adapter));
-    adapter->print();
-    if (has_appendix)  appendix()->print();
+  LogStream* log_stream = NULL;
+  LogStreamHandle(Debug, methodhandles, indy) lsh_indy;
+  if (lsh_indy.is_enabled()) {
+    ResourceMark rm;
+    log_stream = &lsh_indy;
+    log_stream->print_cr("set_method_handle bc=%d appendix=" PTR_FORMAT "%s method=" PTR_FORMAT " (local signature) ",
+                         invoke_code,
+                         p2i(appendix()),
+                         (has_appendix ? "" : " (unused)"),
+                         p2i(adapter));
+    adapter->print_on(log_stream);
+    if (has_appendix)  appendix()->print_on(log_stream);
   }
 
   // Method handle invokes and invokedynamic sites use both cp cache words.
   // refs[f2], if not null, contains a value passed as a trailing argument to the adapter.
   // In the general case, this could be the call site's MethodType,
@@ -460,13 +464,13 @@
 
   // The interpreter assembly code does not check byte_2,
   // but it is used by is_resolved, method_if_resolved, etc.
   set_bytecode_1(invoke_code);
   NOT_PRODUCT(verify(tty));
-  if (TraceInvokeDynamic) {
-    ttyLocker ttyl;
-    this->print(tty, 0);
+
+  if (log_stream != NULL) {
+    this->print(log_stream, 0);
   }
 
   assert(has_appendix == this->has_appendix(), "proper storage of appendix flag");
   assert(this->has_local_signature(), "proper storage of signature flag");
 }
diff a/src/hotspot/share/oops/instanceKlass.cpp b/src/hotspot/share/oops/instanceKlass.cpp
--- a/src/hotspot/share/oops/instanceKlass.cpp
+++ b/src/hotspot/share/oops/instanceKlass.cpp
@@ -29,10 +29,11 @@
 #include "classfile/classFileStream.hpp"
 #include "classfile/classLoader.hpp"
 #include "classfile/classLoaderData.inline.hpp"
 #include "classfile/javaClasses.hpp"
 #include "classfile/moduleEntry.hpp"
+#include "classfile/resolutionErrors.hpp"
 #include "classfile/symbolTable.hpp"
 #include "classfile/systemDictionary.hpp"
 #include "classfile/systemDictionaryShared.hpp"
 #include "classfile/verifier.hpp"
 #include "classfile/vmSymbols.hpp"
@@ -133,10 +134,11 @@
 #define DTRACE_CLASSINIT_PROBE(type, thread_type)
 #define DTRACE_CLASSINIT_PROBE_WAIT(type, thread_type, wait)
 
 #endif //  ndef DTRACE_ENABLED
 
+
 static inline bool is_class_loader(const Symbol* class_name,
                                    const ClassFileParser& parser) {
   assert(class_name != NULL, "invariant");
 
   if (class_name == vmSymbols::java_lang_ClassLoader()) {
@@ -152,12 +154,15 @@
     }
   }
   return false;
 }
 
-// called to verify that k is a member of this nest
+// private: called to verify that k is a static member of this nest.
+// We know that k is an instance class in the same package and hence the
+// same classloader.
 bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {
+  assert(!is_hidden(), "unexpected hidden class");
   if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {
     if (log_is_enabled(Trace, class, nestmates)) {
       ResourceMark rm(THREAD);
       log_trace(class, nestmates)("Checked nest membership of %s in non-nest-host class %s",
                                   k->external_name(), this->external_name());
@@ -174,30 +179,31 @@
   // Check for a resolved cp entry , else fall back to a name check.
   // We don't want to resolve any class other than the one being checked.
   for (int i = 0; i < _nest_members->length(); i++) {
     int cp_index = _nest_members->at(i);
     if (_constants->tag_at(cp_index).is_klass()) {
-      Klass* k2 = _constants->klass_at(cp_index, CHECK_false);
+      Klass* k2 = _constants->klass_at(cp_index, THREAD);
+      assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass()),
+             "Exceptions should not be possible here");
       if (k2 == k) {
         log_trace(class, nestmates)("- class is listed at nest_members[%d] => cp[%d]", i, cp_index);
         return true;
       }
     }
     else {
       Symbol* name = _constants->klass_name_at(cp_index);
       if (name == k->name()) {
         log_trace(class, nestmates)("- Found it at nest_members[%d] => cp[%d]", i, cp_index);
 
-        // Names match so check actual klass - this may trigger class loading if
-        // it doesn't match (though that should be impossible). But to be safe we
-        // have to check for a compiler thread executing here.
-        if (!THREAD->can_call_java() && !_constants->tag_at(cp_index).is_klass()) {
-          log_trace(class, nestmates)("- validation required resolution in an unsuitable thread");
-          return false;
-        }
-
-        Klass* k2 = _constants->klass_at(cp_index, CHECK_false);
+        // Names match so check actual klass. This may trigger class loading if
+        // it doesn't match though that should be impossible as it means one classloader
+        // has defined two different classes with the same name! A compiler thread won't be
+        // able to perform that loading but we can't exclude the compiler threads from
+        // executing this logic. But it should actually be impossible to trigger loading here.
+        Klass* k2 = _constants->klass_at(cp_index, THREAD);
+        assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass()),
+               "Exceptions should not be possible here");
         if (k2 == k) {
           log_trace(class, nestmates)("- class is listed as a nest member");
           return true;
         }
         else {
@@ -212,171 +218,214 @@
   log_trace(class, nestmates)("- class is NOT a nest member!");
   return false;
 }
 
 // Return nest-host class, resolving, validating and saving it if needed.
-// In cases where this is called from a thread that can not do classloading
+// In cases where this is called from a thread that cannot do classloading
 // (such as a native JIT thread) then we simply return NULL, which in turn
 // causes the access check to return false. Such code will retry the access
-// from a more suitable environment later.
-InstanceKlass* InstanceKlass::nest_host(Symbol* validationException, TRAPS) {
+// from a more suitable environment later. Otherwise the _nest_host is always
+// set once this method returns.
+// Any errors from nest-host resolution must be preserved so they can be queried
+// from higher-level access checking code, and reported as part of access checking
+// exceptions.
+// VirtualMachineErrors are propagated with a NULL return.
+// Under any conditions where the _nest_host can be set to non-NULL the resulting
+// value of it and, if applicable, the nest host resolution/validation error,
+// are idempotent.
+InstanceKlass* InstanceKlass::nest_host(TRAPS) {
   InstanceKlass* nest_host_k = _nest_host;
-  if (nest_host_k == NULL) {
-    // need to resolve and save our nest-host class. This could be attempted
-    // concurrently but as the result is idempotent and we don't use the class
-    // then we do not need any synchronization beyond what is implicitly used
-    // during class loading.
-    if (_nest_host_index != 0) { // we have a real nest_host
-      // Before trying to resolve check if we're in a suitable context
-      if (!THREAD->can_call_java() && !_constants->tag_at(_nest_host_index).is_klass()) {
-        if (log_is_enabled(Trace, class, nestmates)) {
-          ResourceMark rm(THREAD);
-          log_trace(class, nestmates)("Rejected resolution of nest-host of %s in unsuitable thread",
-                                      this->external_name());
-        }
-        return NULL;
-      }
+  if (nest_host_k != NULL) {
+    return nest_host_k;
+  }
 
-      if (log_is_enabled(Trace, class, nestmates)) {
-        ResourceMark rm(THREAD);
-        log_trace(class, nestmates)("Resolving nest-host of %s using cp entry for %s",
-                                    this->external_name(),
-                                    _constants->klass_name_at(_nest_host_index)->as_C_string());
-      }
+  ResourceMark rm(THREAD);
 
-      Klass* k = _constants->klass_at(_nest_host_index, THREAD);
-      if (HAS_PENDING_EXCEPTION) {
-        Handle exc_h = Handle(THREAD, PENDING_EXCEPTION);
-        if (exc_h->is_a(SystemDictionary::NoClassDefFoundError_klass())) {
-          // throw a new CDNFE with the original as its cause, and a clear msg
-          ResourceMark rm(THREAD);
-          char buf[200];
-          CLEAR_PENDING_EXCEPTION;
-          jio_snprintf(buf, sizeof(buf),
-                       "Unable to load nest-host class (%s) of %s",
-                       _constants->klass_name_at(_nest_host_index)->as_C_string(),
-                       this->external_name());
-          log_trace(class, nestmates)("%s - NoClassDefFoundError", buf);
-          THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), buf, exc_h);
-        }
-        // All other exceptions pass through (OOME, StackOverflowError, LinkageErrors etc).
-        return NULL;
+  // need to resolve and save our nest-host class.
+  if (_nest_host_index != 0) { // we have a real nest_host
+    // Before trying to resolve check if we're in a suitable context
+    if (!THREAD->can_call_java() && !_constants->tag_at(_nest_host_index).is_klass()) {
+      log_trace(class, nestmates)("Rejected resolution of nest-host of %s in unsuitable thread",
+                                  this->external_name());
+      return NULL; // sentinel to say "try again from a different context"
+    }
+
+    log_trace(class, nestmates)("Resolving nest-host of %s using cp entry for %s",
+                                this->external_name(),
+                                _constants->klass_name_at(_nest_host_index)->as_C_string());
+
+    Klass* k = _constants->klass_at(_nest_host_index, THREAD);
+    if (HAS_PENDING_EXCEPTION) {
+      if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {
+        return NULL; // propagate VMEs
       }
+      stringStream ss;
+      char* target_host_class = _constants->klass_name_at(_nest_host_index)->as_C_string();
+      ss.print("Nest host resolution of %s with host %s failed: ",
+               this->external_name(), target_host_class);
+      java_lang_Throwable::print(PENDING_EXCEPTION, &ss);
+      const char* msg = ss.as_string(true /* on C-heap */);
+      constantPoolHandle cph(THREAD, constants());
+      SystemDictionary::add_nest_host_error(cph, _nest_host_index, msg);
+      CLEAR_PENDING_EXCEPTION;
 
+      log_trace(class, nestmates)("%s", msg);
+    } else {
       // A valid nest-host is an instance class in the current package that lists this
-      // class as a nest member. If any of these conditions are not met we post the
-      // requested exception type (if any) and return NULL
-
+      // class as a nest member. If any of these conditions are not met the class is
+      // its own nest-host.
       const char* error = NULL;
 
       // JVMS 5.4.4 indicates package check comes first
       if (is_same_class_package(k)) {
-
         // Now check actual membership. We can't be a member if our "host" is
         // not an instance class.
         if (k->is_instance_klass()) {
           nest_host_k = InstanceKlass::cast(k);
+          bool is_member = nest_host_k->has_nest_member(this, THREAD);
+          // exception is rare, perhaps impossible
+          if (!HAS_PENDING_EXCEPTION) {
+            if (is_member) {
+              _nest_host = nest_host_k; // save resolved nest-host value
 
-          bool is_member = nest_host_k->has_nest_member(this, CHECK_NULL);
-          if (is_member) {
-            // save resolved nest-host value
-            _nest_host = nest_host_k;
-
-            if (log_is_enabled(Trace, class, nestmates)) {
-              ResourceMark rm(THREAD);
               log_trace(class, nestmates)("Resolved nest-host of %s to %s",
                                           this->external_name(), k->external_name());
+              return nest_host_k;
+            } else {
+              error = "current type is not listed as a nest member";
+            }
+          } else {
+            if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {
+              return NULL; // propagate VMEs
             }
-            return nest_host_k;
+            stringStream ss;
+            ss.print("exception on member check: ");
+            java_lang_Throwable::print(PENDING_EXCEPTION, &ss);
+            error = ss.as_string();
           }
+        } else {
+          error = "host is not an instance class";
         }
-        error = "current type is not listed as a nest member";
       } else {
         error = "types are in different packages";
       }
 
-      if (log_is_enabled(Trace, class, nestmates)) {
-        ResourceMark rm(THREAD);
-        log_trace(class, nestmates)
-          ("Type %s (loader: %s) is not a nest member of "
-           "resolved type %s (loader: %s): %s",
-           this->external_name(),
-           this->class_loader_data()->loader_name_and_id(),
-           k->external_name(),
-           k->class_loader_data()->loader_name_and_id(),
-           error);
-      }
-
-      if (validationException != NULL && THREAD->can_call_java()) {
-        ResourceMark rm(THREAD);
-        Exceptions::fthrow(THREAD_AND_LOCATION,
-                           validationException,
-                           "Type %s (loader: %s) is not a nest member of %s (loader: %s): %s",
-                           this->external_name(),
-                           this->class_loader_data()->loader_name_and_id(),
-                           k->external_name(),
-                           k->class_loader_data()->loader_name_and_id(),
-                           error
-                           );
-      }
-      return NULL;
-    } else {
-      if (log_is_enabled(Trace, class, nestmates)) {
-        ResourceMark rm(THREAD);
-        log_trace(class, nestmates)("Type %s is not part of a nest: setting nest-host to self",
-                                    this->external_name());
+      // something went wrong, so record what and log it
+      {
+        stringStream ss;
+        ss.print("Type %s (loader: %s) is not a nest member of type %s (loader: %s): %s",
+                 this->external_name(),
+                 this->class_loader_data()->loader_name_and_id(),
+                 k->external_name(),
+                 k->class_loader_data()->loader_name_and_id(),
+                 error);
+        const char* msg = ss.as_string(true /* on C-heap */);
+        constantPoolHandle cph(THREAD, constants());
+        SystemDictionary::add_nest_host_error(cph, _nest_host_index, msg);
+        log_trace(class, nestmates)("%s", msg);
       }
-      // save resolved nest-host value
-      return (_nest_host = this);
+    }
+  } else {
+    log_trace(class, nestmates)("Type %s is not part of a nest: setting nest-host to self",
+                                this->external_name());
+  }
+
+  // Either not in an explicit nest, or else an error occurred, so
+  // the nest-host is set to `this`. Any thread that sees this assignment
+  // will also see any setting of nest_host_error(), if applicable.
+  return (_nest_host = this);
+}
+
+// Dynamic nest member support: set this class's nest host to the given class.
+// This occurs as part of the class definition, as soon as the instanceKlass
+// has been created and doesn't require further resolution. The code:
+//    lookup().defineHiddenClass(bytes_for_X, NESTMATE);
+// results in:
+//    class_of_X.set_nest_host(lookup().lookupClass().getNestHost())
+// If it has an explicit _nest_host_index or _nest_members, these will be ignored.
+// We also know the "host" is a valid nest-host in the same package so we can
+// assert some of those facts.
+void InstanceKlass::set_nest_host(InstanceKlass* host, TRAPS) {
+  assert(is_hidden(), "must be a hidden class");
+  assert(host != NULL, "NULL nest host specified");
+  assert(_nest_host == NULL, "current class has resolved nest-host");
+  assert(nest_host_error(THREAD) == NULL, "unexpected nest host resolution error exists: %s",
+         nest_host_error(THREAD));
+  assert((host->_nest_host == NULL && host->_nest_host_index == 0) ||
+         (host->_nest_host == host), "proposed host is not a valid nest-host");
+  // Can't assert this as package is not set yet:
+  // assert(is_same_class_package(host), "proposed host is in wrong package");
+
+  if (log_is_enabled(Trace, class, nestmates)) {
+    ResourceMark rm(THREAD);
+    const char* msg = "";
+    // a hidden class does not expect a statically defined nest-host
+    if (_nest_host_index > 0) {
+      msg = "(the NestHost attribute in the current class is ignored)";
+    } else if (_nest_members != NULL && _nest_members != Universe::the_empty_short_array()) {
+      msg = "(the NestMembers attribute in the current class is ignored)";
+    }
+    log_trace(class, nestmates)("Injected type %s into the nest of %s %s",
+                                this->external_name(),
+                                host->external_name(),
     }
   }
-  return nest_host_k;
+  // set dynamic nest host
+  _nest_host = host;
+  // Record dependency to keep nest host from being unloaded before this class.
+  ClassLoaderData* this_key = class_loader_data();
+  this_key->record_dependency(host);
 }
 
 // check if 'this' and k are nestmates (same nest_host), or k is our nest_host,
 // or we are k's nest_host - all of which is covered by comparing the two
-// resolved_nest_hosts
+// resolved_nest_hosts.
+// Any exceptions (i.e. VMEs) are propagated.
 bool InstanceKlass::has_nestmate_access_to(InstanceKlass* k, TRAPS) {
 
   assert(this != k, "this should be handled by higher-level code");
 
   // Per JVMS 5.4.4 we first resolve and validate the current class, then
-  // the target class k. Resolution exceptions will be passed on by upper
-  // layers. IncompatibleClassChangeErrors from membership validation failures
-  // will also be passed through.
+  // the target class k.
 
-  Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();
-  InstanceKlass* cur_host = nest_host(icce, CHECK_false);
+  InstanceKlass* cur_host = nest_host(CHECK_false);
   if (cur_host == NULL) {
     return false;
   }
 
-  Klass* k_nest_host = k->nest_host(icce, CHECK_false);
+  Klass* k_nest_host = k->nest_host(CHECK_false);
   if (k_nest_host == NULL) {
     return false;
   }
 
   bool access = (cur_host == k_nest_host);
 
-  if (log_is_enabled(Trace, class, nestmates)) {
-    ResourceMark rm(THREAD);
-    log_trace(class, nestmates)("Class %s does %shave nestmate access to %s",
-                                this->external_name(),
-                                access ? "" : "NOT ",
-                                k->external_name());
-  }
-
+  ResourceMark rm(THREAD);
+  log_trace(class, nestmates)("Class %s does %shave nestmate access to %s",
+                              this->external_name(),
+                              access ? "" : "NOT ",
+                              k->external_name());
   return access;
 }
 
+const char* InstanceKlass::nest_host_error(TRAPS) {
+  if (_nest_host_index == 0) {
+    return NULL;
+  } else {
+    constantPoolHandle cph(THREAD, constants());
+    return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);
+  }
+}
+
 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser& parser, TRAPS) {
+  bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();
   const int size = InstanceKlass::size(parser.vtable_size(),
                                        parser.itable_size(),
                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
                                        parser.is_interface(),
                                        parser.is_unsafe_anonymous(),
-                                       should_store_fingerprint(parser.is_unsafe_anonymous()),
+                                       should_store_fingerprint(is_hidden_or_anonymous),
                                        parser.has_flattenable_fields() ? parser.java_fields_count() : 0,
                                        parser.is_inline_type());
 
   const Symbol* const class_name = parser.class_name();
   assert(class_name != NULL, "invariant");
@@ -482,10 +531,11 @@
   _adr_valueklass_fixed_block(NULL)
 {
   set_vtable_length(parser.vtable_size());
   set_kind(kind);
   set_access_flags(parser.access_flags());
+  if (parser.is_hidden()) set_is_hidden();
   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
                                                     false));
     if (parser.has_flattenable_fields()) {
       set_has_inline_fields();
@@ -2410,23 +2460,23 @@
   }
 
   return true;
 }
 
-bool InstanceKlass::should_store_fingerprint(bool is_unsafe_anonymous) {
+bool InstanceKlass::should_store_fingerprint(bool is_hidden_or_anonymous) {
 #if INCLUDE_AOT
   // We store the fingerprint into the InstanceKlass only in the following 2 cases:
   if (CalculateClassFingerprint) {
     // (1) We are running AOT to generate a shared library.
     return true;
   }
   if (Arguments::is_dumping_archive()) {
     // (2) We are running -Xshare:dump or -XX:ArchiveClassesAtExit to create a shared archive
     return true;
   }
-  if (UseAOT && is_unsafe_anonymous) {
-    // (3) We are using AOT code from a shared library and see an unsafe anonymous class
+  if (UseAOT && is_hidden_or_anonymous) {
+    // (3) We are using AOT code from a shared library and see a hidden or unsafe anonymous class
     return true;
   }
 #endif
 
   // In all other cases we might set the _misc_has_passed_fingerprint_check bit,
@@ -2719,10 +2769,11 @@
   }
 #endif
 
   // Decrement symbol reference counts associated with the unloaded class.
   if (_name != NULL) _name->decrement_refcount();
+
   // unreference array name derived from this class name (arrays of an unloaded
   // class can't be referenced anymore).
   if (_array_name != NULL)  _array_name->decrement_refcount();
   if (_inline_types != NULL) {
     for (int i = 0; i < _inline_types->length(); i++) {
@@ -2777,10 +2828,19 @@
   // Add the actual class name
   for (int src_index = 0; src_index < src_length; ) {
     dest[dest_index++] = src[src_index++];
   }
 
+  if (is_hidden()) { // Replace the last '+' with a '.'.
+    for (int index = (int)src_length; index > 0; index--) {
+      if (dest[index] == '+') {
+        dest[index] = JVM_SIGNATURE_DOT;
+        break;
+      }
+    }
+  }
+
   // If we have a hash, append it
   for (int hash_index = 0; hash_index < hash_len; ) {
     dest[dest_index++] = hash_buf[hash_index++];
   }
 
@@ -2795,10 +2855,29 @@
   if (is_unsafe_anonymous()) {
     assert(unsafe_anonymous_host() != NULL, "unsafe anonymous class must have a host class");
     return unsafe_anonymous_host()->module();
   }
 
+  if (is_hidden() &&
+      in_unnamed_package() &&
+      class_loader_data()->has_class_mirror_holder()) {
+    // For a non-strong hidden class defined to an unnamed package,
+    // its (class held) CLD will not have an unnamed module created for it.
+    // Two choices to find the correct ModuleEntry:
+    // 1. If hidden class is within a nest, use nest host's module
+    // 2. Find the unnamed module off from the class loader
+    // For now option #2 is used since a nest host is not set until
+    // after the instance class is created in jvm_lookup_define_class().
+    if (class_loader_data()->is_boot_class_loader_data()) {
+      return ClassLoaderData::the_null_class_loader_data()->unnamed_module();
+    } else {
+      oop module = java_lang_ClassLoader::unnamedModule(class_loader_data()->class_loader());
+      assert(java_lang_Module::is_instance(module), "Not an instance of java.lang.Module");
+      return java_lang_Module::module_entry(module);
+    }
+  }
+
   // Class is in a named package
   if (!in_unnamed_package()) {
     return _package_entry->module();
   }
 
@@ -2807,11 +2886,14 @@
 }
 
 void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {
 
   // ensure java/ packages only loaded by boot or platform builtin loaders
-  check_prohibited_package(name(), loader_data, CHECK);
+  // not needed for shared class since CDS does not archive prohibited classes.
+  if (!is_shared()) {
+    check_prohibited_package(name(), loader_data, CHECK);
+  }
 
   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry->name() : ClassLoader::package_from_class_name(name());
 
   if (pkg_name != NULL && loader_data != NULL) {
 
@@ -2858,10 +2940,27 @@
                       (loader_data != NULL) ? loader_data->loader_name_and_id() : "NULL",
                       UNNAMED_MODULE);
   }
 }
 
+// Function set_classpath_index checks if the package of the InstanceKlass is in the
+// boot loader's package entry table.  If so, then it sets the classpath_index
+// in the package entry record.
+//
+// The classpath_index field is used to find the entry on the boot loader class
+// path for packages with classes loaded by the boot loader from -Xbootclasspath/a
+// in an unnamed module.  It is also used to indicate (for all packages whose
+// classes are loaded by the boot loader) that at least one of the package's
+// classes has been loaded.
+void InstanceKlass::set_classpath_index(s2 path_index, TRAPS) {
+  if (_package_entry != NULL) {
+    DEBUG_ONLY(PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()->packages();)
+    assert(pkg_entry_tbl->lookup_only(_package_entry->name()) == _package_entry, "Should be same");
+    assert(path_index != -1, "Unexpected classpath_index");
+    _package_entry->set_classpath_index(path_index);
+  }
+}
 
 // different versions of is_same_class_package
 
 bool InstanceKlass::is_same_class_package(const Klass* class2) const {
   oop classloader1 = this->class_loader();
@@ -3005,11 +3104,11 @@
       Klass* ok = i_cp->klass_at(ooff, CHECK_NULL);
       outer_klass = InstanceKlass::cast(ok);
       *inner_is_member = true;
     }
     if (NULL == outer_klass) {
-      // It may be unsafe anonymous; try for that.
+      // It may be a local or anonymous class; try for that.
       int encl_method_class_idx = enclosing_method_class_index();
       if (encl_method_class_idx != 0) {
         Klass* ok = i_cp->klass_at(encl_method_class_idx, CHECK_NULL);
         outer_klass = InstanceKlass::cast(ok);
         *inner_is_member = false;
diff a/src/hotspot/share/oops/instanceKlass.hpp b/src/hotspot/share/oops/instanceKlass.hpp
--- a/src/hotspot/share/oops/instanceKlass.hpp
+++ b/src/hotspot/share/oops/instanceKlass.hpp
@@ -220,11 +220,14 @@
 
   // The NestHost attribute. The class info index for the class
   // that is the nest-host of this class. This data has not been validated.
   jushort _nest_host_index;
 
-  // Resolved nest-host klass: either true nest-host or self if we are not nested.
+  // Resolved nest-host klass: either true nest-host or self if we are not
+  // nested, or an error occurred resolving or validating the nominated
+  // nest-host. Can also be set directly by JDK API's that establish nest
+  // relationships.
   // By always being set it makes nest-member access checks simpler.
   InstanceKlass* _nest_host;
 
   Array<InlineTypes>* _inline_types;
 
@@ -574,10 +577,12 @@
   void set_nest_members(Array<u2>* m) { _nest_members = m; }
 
   // nest-host index
   jushort nest_host_index() const { return _nest_host_index; }
   void set_nest_host_index(u2 i)  { _nest_host_index = i; }
+  // dynamic nest member support
+  void set_nest_host(InstanceKlass* host, TRAPS);
 
   // record components
   Array<RecordComponent*>* record_components() const { return _record_components; }
   void set_record_components(Array<RecordComponent*>* record_components) {
     _record_components = record_components;
@@ -587,13 +592,17 @@
 private:
   // Called to verify that k is a member of this nest - does not look at k's nest-host
   bool has_nest_member(InstanceKlass* k, TRAPS) const;
 
 public:
-  // Returns nest-host class, resolving and validating it if needed
-  // Returns NULL if an exception occurs during loading, or validation fails
-  InstanceKlass* nest_host(Symbol* validationException, TRAPS);
+  // Used to construct informative IllegalAccessError messages at a higher level,
+  // if there was an issue resolving or validating the nest host.
+  // Returns NULL if there was no error.
+  const char* nest_host_error(TRAPS);
+  // Returns nest-host class, resolving and validating it if needed.
+  // Returns NULL if resolution is not possible from the calling context.
+  InstanceKlass* nest_host(TRAPS);
   // Check if this klass is a nestmate of k - resolves this nest-host and k's
   bool has_nestmate_access_to(InstanceKlass* k, TRAPS);
 
   enum InnerClassAttributeOffset {
     // From http://mirror.eng/products/jdk/1.1/docs/guide/innerclasses/spec/innerclasses.doc10.html#18814
@@ -615,11 +624,18 @@
 
   // package
   PackageEntry* package() const     { return _package_entry; }
   ModuleEntry* module() const;
   bool in_unnamed_package() const   { return (_package_entry == NULL); }
-  void set_package(PackageEntry* p) { _package_entry = p; }
+  void set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS);
+  // If the package for the InstanceKlass is in the boot loader's package entry
+  // table then sets the classpath_index field so that
+  // get_system_package() will know to return a non-null value for the
+  // package's location.  And, so that the package will be added to the list of
+  // packages returned by get_system_packages().
+  // For packages whose classes are loaded from the boot loader class path, the
+  // classpath_index indicates which entry on the boot loader class path.
   void set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS);
   bool is_same_class_package(const Klass* class2) const;
   bool is_same_class_package(oop other_class_loader, const Symbol* other_class_name) const;
 
   // find an enclosing class
@@ -921,12 +937,12 @@
       _misc_flags &= ~_misc_has_passed_fingerprint_check;
     }
   }
   bool supers_have_passed_fingerprint_checks();
 
-  static bool should_store_fingerprint(bool is_unsafe_anonymous);
-  bool should_store_fingerprint() const { return should_store_fingerprint(is_unsafe_anonymous()); }
+  static bool should_store_fingerprint(bool is_hidden_or_anonymous);
+  bool should_store_fingerprint() const { return should_store_fingerprint(is_hidden() || is_unsafe_anonymous()); }
   bool has_stored_fingerprint() const;
   uint64_t get_stored_fingerprint() const;
   void store_fingerprint(uint64_t fingerprint);
 
   bool is_scratch_class() const {
diff a/src/hotspot/share/oops/klass.cpp b/src/hotspot/share/oops/klass.cpp
--- a/src/hotspot/share/oops/klass.cpp
+++ b/src/hotspot/share/oops/klass.cpp
@@ -606,11 +606,11 @@
 
   // Only recreate it if not present.  A previous attempt to restore may have
   // gotten an OOM later but keep the mirror if it was created.
   if (java_mirror() == NULL) {
     log_trace(cds, mirror)("Recreate mirror for %s", external_name());
-    java_lang_Class::create_mirror(this, loader, module_handle, protection_domain, CHECK);
+    java_lang_Class::create_mirror(this, loader, module_handle, protection_domain, Handle(), CHECK);
   }
 }
 
 #if INCLUDE_CDS_JAVA_HEAP
 // Used at CDS dump time to access the archived mirror. No GC barrier.
@@ -670,10 +670,24 @@
   } else if (length < 0) {
     THROW_MSG(vmSymbols::java_lang_NegativeArraySizeException(), err_msg("%d", length));
   }
 }
 
+// Replace the last '+' char with '/'.
+static char* convert_hidden_name_to_java(Symbol* name) {
+  size_t name_len = name->utf8_length();
+  char* result = NEW_RESOURCE_ARRAY(char, name_len + 1);
+  name->as_klass_external_name(result, (int)name_len + 1);
+  for (int index = (int)name_len; index > 0; index--) {
+    if (result[index] == '+') {
+      result[index] = JVM_SIGNATURE_SLASH;
+      break;
+    }
+  }
+  return result;
+}
+
 // In product mode, this function doesn't have virtual function calls so
 // there might be some performance advantage to handling InstanceKlass here.
 const char* Klass::external_name() const {
   if (is_instance_klass()) {
     const InstanceKlass* ik = static_cast<const InstanceKlass*>(this);
@@ -686,18 +700,37 @@
       name()->as_klass_external_name(result, (int) name_len + 1);
       assert(strlen(result) == name_len, "");
       strcpy(result + name_len, addr_buf);
       assert(strlen(result) == name_len + addr_len, "");
       return result;
+
+    } else if (ik->is_hidden()) {
+      char* result = convert_hidden_name_to_java(name());
+      return result;
     }
+  } else if (is_objArray_klass() && ObjArrayKlass::cast(this)->bottom_klass()->is_hidden()) {
+    char* result = convert_hidden_name_to_java(name());
+    return result;
   }
   if (name() == NULL)  return "<unknown>";
   return name()->as_klass_external_name();
 }
 
 const char* Klass::signature_name() const {
   if (name() == NULL)  return "<unknown>";
+  if (is_objArray_klass() && ObjArrayKlass::cast(this)->bottom_klass()->is_hidden()) {
+    size_t name_len = name()->utf8_length();
+    char* result = NEW_RESOURCE_ARRAY(char, name_len + 1);
+    name()->as_C_string(result, (int)name_len + 1);
+    for (int index = (int)name_len; index > 0; index--) {
+      if (result[index] == '+') {
+        result[index] = JVM_SIGNATURE_DOT;
+        break;
+      }
+    }
+    return result;
+  }
   return name()->as_C_string();
 }
 
 const char* Klass::external_kind() const {
   if (is_interface()) return "interface";
diff a/src/hotspot/share/oops/klass.hpp b/src/hotspot/share/oops/klass.hpp
--- a/src/hotspot/share/oops/klass.hpp
+++ b/src/hotspot/share/oops/klass.hpp
@@ -645,10 +645,14 @@
   void set_has_vanilla_constructor()    { _access_flags.set_has_vanilla_constructor(); }
   bool has_miranda_methods () const     { return access_flags().has_miranda_methods(); }
   void set_has_miranda_methods()        { _access_flags.set_has_miranda_methods(); }
   bool is_shared() const                { return access_flags().is_shared_class(); } // shadows MetaspaceObj::is_shared)()
   void set_is_shared()                  { _access_flags.set_is_shared_class(); }
+  bool is_hidden() const                { return access_flags().is_hidden_class(); }
+  void set_is_hidden()                  { _access_flags.set_is_hidden_class(); }
+  bool is_non_strong_hidden() const     { return access_flags().is_hidden_class() &&
+                                          class_loader_data()->has_class_mirror_holder(); }
 
   bool is_cloneable() const;
   void set_is_cloneable();
 
   // Biased locking support
diff a/src/hotspot/share/oops/method.cpp b/src/hotspot/share/oops/method.cpp
--- a/src/hotspot/share/oops/method.cpp
+++ b/src/hotspot/share/oops/method.cpp
@@ -36,10 +36,11 @@
 #include "interpreter/bytecodes.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/oopMapCache.hpp"
 #include "logging/log.hpp"
 #include "logging/logTag.hpp"
+#include "logging/logStream.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/metadataFactory.hpp"
 #include "memory/metaspaceClosure.hpp"
 #include "memory/metaspaceShared.hpp"
 #include "memory/oopFactory.hpp"
@@ -1504,13 +1505,12 @@
   methodHandle empty;
 
   InstanceKlass* holder = SystemDictionary::MethodHandle_klass();
   Symbol* name = MethodHandles::signature_polymorphic_intrinsic_name(iid);
   assert(iid == MethodHandles::signature_polymorphic_name_id(name), "");
-  if (TraceMethodHandles) {
-    tty->print_cr("make_method_handle_intrinsic MH.%s%s", name->as_C_string(), signature->as_C_string());
-  }
+
+  log_info(methodhandles)("make_method_handle_intrinsic MH.%s%s", name->as_C_string(), signature->as_C_string());
 
   // invariant:   cp->symbol_at_put is preceded by a refcount increment (more usually a lookup)
   name->increment_refcount();
   signature->increment_refcount();
 
@@ -1557,13 +1557,14 @@
   // Finally, set up its entry points.
   assert(m->can_be_statically_bound(), "");
   m->set_vtable_index(Method::nonvirtual_vtable_index);
   m->link_method(m, CHECK_(empty));
 
-  if (TraceMethodHandles && (Verbose || WizardMode)) {
-    ttyLocker ttyl;
-    m->print_on(tty);
+  if (log_is_enabled(Info, methodhandles) && (Verbose || WizardMode)) {
+    LogTarget(Info, methodhandles) lt;
+    LogStream ls(lt);
+    m->print_on(&ls);
   }
 
   return m;
 }
 
diff a/src/hotspot/share/oops/method.hpp b/src/hotspot/share/oops/method.hpp
--- a/src/hotspot/share/oops/method.hpp
+++ b/src/hotspot/share/oops/method.hpp
@@ -914,13 +914,14 @@
   }
   void set_dont_inline(bool x) {
     _flags = x ? (_flags | _dont_inline) : (_flags & ~_dont_inline);
   }
 
-  bool is_hidden() {
+  bool is_hidden() const {
     return (_flags & _hidden) != 0;
   }
+
   void set_hidden(bool x) {
     _flags = x ? (_flags | _hidden) : (_flags & ~_hidden);
   }
 
   bool intrinsic_candidate() {
diff a/src/hotspot/share/oops/oopsHierarchy.hpp b/src/hotspot/share/oops/oopsHierarchy.hpp
--- a/src/hotspot/share/oops/oopsHierarchy.hpp
+++ b/src/hotspot/share/oops/oopsHierarchy.hpp
@@ -125,10 +125,11 @@
 #define DEF_OOP(type)                                                      \
    class type##OopDesc;                                                    \
    class type##Oop : public oop {                                          \
      public:                                                               \
        type##Oop() : oop() {}                                              \
+       type##Oop(const type##Oop& o) : oop(o) {}                           \
        type##Oop(const oop& o) : oop(o) {}                                 \
        type##Oop(const volatile oop& o) : oop(o) {}                        \
        type##Oop(const void* p) : oop(p) {}                                \
        operator type##OopDesc* () const { return (type##OopDesc*)obj(); }  \
        type##OopDesc* operator->() const {                                 \
diff a/src/hotspot/share/opto/c2compiler.cpp b/src/hotspot/share/opto/c2compiler.cpp
--- a/src/hotspot/share/opto/c2compiler.cpp
+++ b/src/hotspot/share/opto/c2compiler.cpp
@@ -604,10 +604,11 @@
   case vmIntrinsics::_isInstance:
   case vmIntrinsics::_getModifiers:
   case vmIntrinsics::_isInterface:
   case vmIntrinsics::_isArray:
   case vmIntrinsics::_isPrimitive:
+  case vmIntrinsics::_isHidden:
   case vmIntrinsics::_getSuperclass:
   case vmIntrinsics::_getClassAccessFlags:
   case vmIntrinsics::_floatToRawIntBits:
   case vmIntrinsics::_floatToIntBits:
   case vmIntrinsics::_intBitsToFloat:
diff a/src/hotspot/share/opto/castnode.cpp b/src/hotspot/share/opto/castnode.cpp
--- a/src/hotspot/share/opto/castnode.cpp
+++ b/src/hotspot/share/opto/castnode.cpp
@@ -64,18 +64,10 @@
       if( t1 == Type::TOP )  assert(ft == Type::TOP, "special case #1");
       const Type* rt = t1->join_speculative(_type);
       if (rt->empty())       assert(ft == Type::TOP, "special case #2");
       break;
     }
-    case Op_CastLL:
-    {
-      const Type* t1 = phase->type(in(1));
-      if (t1 == Type::TOP)   assert(ft == Type::TOP, "special case #1");
-      const Type* rt = t1->join_speculative(_type);
-      if (rt->empty())       assert(ft == Type::TOP, "special case #2");
-      break;
-    }
     case Op_CastPP:
     if (phase->type(in(1)) == TypePtr::NULL_PTR &&
         _type->isa_ptr() && _type->is_ptr()->_ptr == TypePtr::NotNull)
     assert(ft == Type::TOP, "special case #3");
     break;
@@ -105,15 +97,10 @@
   case Op_CastII: {
     Node* cast = new CastIINode(n, t, carry_dependency);
     cast->set_req(0, c);
     return cast;
   }
-  case Op_CastLL: {
-    Node* cast = new CastLLNode(n, t, carry_dependency);
-    cast->set_req(0, c);
-    return cast;
-  }
   case Op_CastPP: {
     Node* cast = new CastPPNode(n, t, carry_dependency);
     cast->set_req(0, c);
     return cast;
   }
@@ -293,49 +280,10 @@
     st->print(" range check dependency");
   }
 }
 #endif
 
-Node* CastLLNode::Ideal(PhaseGVN* phase, bool can_reshape) {
-  Node* progress = ConstraintCastNode::Ideal(phase, can_reshape);
-  if (progress != NULL) {
-    return progress;
-  }
-
-  // Same as in CastIINode::Ideal but for TypeLong instead of TypeInt
-  if (can_reshape && !phase->C->major_progress()) {
-    const TypeLong* this_type = this->type()->is_long();
-    const TypeLong* in_type = phase->type(in(1))->isa_long();
-    if (in_type != NULL && this_type != NULL &&
-        (in_type->_lo != this_type->_lo ||
-         in_type->_hi != this_type->_hi)) {
-      jlong lo1 = this_type->_lo;
-      jlong hi1 = this_type->_hi;
-      int w1  = this_type->_widen;
-
-      if (lo1 >= 0) {
-        // Keep a range assertion of >=0.
-        lo1 = 0;         hi1 = max_jlong;
-      } else if (hi1 < 0) {
-        // Keep a range assertion of <0.
-        lo1 = min_jlong; hi1 = -1;
-      } else {
-        lo1 = min_jlong; hi1 = max_jlong;
-      }
-      const TypeLong* wtype = TypeLong::make(MAX2(in_type->_lo, lo1),
-                                             MIN2(in_type->_hi, hi1),
-                                             MAX2((int)in_type->_widen, w1));
-      if (wtype != type()) {
-        set_type(wtype);
-        return this;
-      }
-    }
-  }
-  return NULL;
-}
-
-
 //=============================================================================
 //------------------------------Identity---------------------------------------
 // If input is already higher or equal to cast type, then this is an identity.
 Node* CheckCastPPNode::Identity(PhaseGVN* phase) {
   if (in(1)->is_ValueTypeBase() && _type->isa_oopptr() && phase->type(in(1))->value_klass()->is_subtype_of(_type->is_oopptr()->klass())) {
diff a/src/hotspot/share/opto/castnode.hpp b/src/hotspot/share/opto/castnode.hpp
--- a/src/hotspot/share/opto/castnode.hpp
+++ b/src/hotspot/share/opto/castnode.hpp
@@ -89,23 +89,10 @@
 #ifndef PRODUCT
   virtual void dump_spec(outputStream* st) const;
 #endif
 };
 
-//------------------------------CastLLNode-------------------------------------
-// cast long to long (different range)
-class CastLLNode: public ConstraintCastNode {
-  public:
-  CastLLNode(Node* n, const Type* t, bool carry_dependency = false)
-    : ConstraintCastNode(n, t, carry_dependency) {
-    init_class_id(Class_CastLL);
-  }
-  virtual int Opcode() const;
-  virtual uint ideal_reg() const { return Op_RegL; }
-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);
-};
-
 //------------------------------CastPPNode-------------------------------------
 // cast pointer to pointer (different type)
 class CastPPNode: public ConstraintCastNode {
   public:
   CastPPNode (Node *n, const Type *t, bool carry_dependency = false)
diff a/src/hotspot/share/opto/cfgnode.cpp b/src/hotspot/share/opto/cfgnode.cpp
--- a/src/hotspot/share/opto/cfgnode.cpp
+++ b/src/hotspot/share/opto/cfgnode.cpp
@@ -1941,17 +1941,16 @@
     if (uncasted) {
       // Add cast nodes between the phi to be removed and its unique input.
       // Wait until after parsing for the type information to propagate from the casts.
       assert(can_reshape, "Invalid during parsing");
       const Type* phi_type = bottom_type();
-      assert(phi_type->isa_int() || phi_type->isa_long() || phi_type->isa_ptr(), "bad phi type");
-      // Add casts to carry the control dependency of the Phi that is going away
+      assert(phi_type->isa_int() || phi_type->isa_ptr(), "bad phi type");
+      // Add casts to carry the control dependency of the Phi that is
+      // going away
       Node* cast = NULL;
       if (phi_type->isa_int()) {
         cast = ConstraintCastNode::make_cast(Op_CastII, r, uin, phi_type, true);
-      } else if (phi_type->isa_long()) {
-        cast = ConstraintCastNode::make_cast(Op_CastLL, r, uin, phi_type, true);
       } else {
         const Type* uin_type = phase->type(uin);
         if (!phi_type->isa_oopptr() && !uin_type->isa_oopptr()) {
           cast = ConstraintCastNode::make_cast(Op_CastPP, r, uin, phi_type, true);
         } else {
diff a/src/hotspot/share/opto/classes.hpp b/src/hotspot/share/opto/classes.hpp
--- a/src/hotspot/share/opto/classes.hpp
+++ b/src/hotspot/share/opto/classes.hpp
@@ -59,11 +59,10 @@
 macro(CallLeaf)
 macro(CallLeafNoFP)
 macro(CallRuntime)
 macro(CallStaticJava)
 macro(CastII)
-macro(CastLL)
 macro(CastX2P)
 macro(CastP2X)
 macro(CastI2N)
 macro(CastN2I)
 macro(CastPP)
diff a/src/hotspot/share/opto/graphKit.cpp b/src/hotspot/share/opto/graphKit.cpp
--- a/src/hotspot/share/opto/graphKit.cpp
+++ b/src/hotspot/share/opto/graphKit.cpp
@@ -1385,11 +1385,18 @@
     return zerocon(type);
   }
 
   // Cast obj to not-null on this path, if there is no null_control.
   // (If there is a null_control, a non-null value may come back to haunt us.)
-  return cast_not_null(value, (null_control == NULL || (*null_control) == top()));
+  if (type == T_OBJECT) {
+    Node* cast = cast_not_null(value, false);
+    if (null_control == NULL || (*null_control) == top())
+      replace_in_map(value, cast);
+    value = cast;
+  }
+
+  return value;
 }
 
 Node* GraphKit::null2default(Node* value, ciValueKlass* vk) {
   Node* null_ctl = top();
   value = null_check_oop(value, &null_ctl);
@@ -1410,34 +1417,25 @@
 // Cast obj to not-null on this path
 Node* GraphKit::cast_not_null(Node* obj, bool do_replace_in_map) {
   if (obj->is_ValueType()) {
     return obj;
   }
-  Node* cast = NULL;
-  const Type* t = _gvn.type(obj);
-  if (t->make_ptr() != NULL) {
-    const Type* t_not_null = t->join_speculative(TypePtr::NOTNULL);
-    // Object is already not-null?
-    if (t == t_not_null) {
-      return obj;
-    }
-    cast = ConstraintCastNode::make_cast(Op_CastPP, control(), obj, t_not_null, false);
-  } else if (t->isa_int() != NULL) {
-    cast = ConstraintCastNode::make_cast(Op_CastII, control(), obj, TypeInt::INT, true);
-  } else if (t->isa_long() != NULL) {
-    cast = ConstraintCastNode::make_cast(Op_CastLL, control(), obj, TypeLong::LONG, true);
-  } else {
-    fatal("unexpected type: %s", type2name(t->basic_type()));
-  }
-  cast = _gvn.transform(cast);
+  const Type *t = _gvn.type(obj);
+  const Type *t_not_null = t->join_speculative(TypePtr::NOTNULL);
+  // Object is already not-null?
+  if( t == t_not_null ) return obj;
+
+  Node *cast = new CastPPNode(obj,t_not_null);
+  cast->init_req(0, control());
+  cast = _gvn.transform( cast );
 
   // Scan for instances of 'obj' in the current JVM mapping.
   // These instances are known to be not-null after the test.
-  if (do_replace_in_map) {
+  if (do_replace_in_map)
     replace_in_map(obj, cast);
-  }
-  return cast;
+
+  return cast;                  // Return casted value
 }
 
 // Sometimes in intrinsics, we implicitly know an object is not null
 // (there's no actual null check) so we can cast it to not null. In
 // the course of optimizations, the input to the cast can become null.
diff a/src/hotspot/share/opto/library_call.cpp b/src/hotspot/share/opto/library_call.cpp
--- a/src/hotspot/share/opto/library_call.cpp
+++ b/src/hotspot/share/opto/library_call.cpp
@@ -203,10 +203,12 @@
     NonObjectArray,
     TypeArray,
     ValueArray
   };
 
+  Node* generate_hidden_class_guard(Node* kls, RegionNode* region);
+
   Node* generate_array_guard(Node* kls, RegionNode* region) {
     return generate_array_guard_common(kls, region, AnyArray);
   }
   Node* generate_non_array_guard(Node* kls, RegionNode* region) {
     return generate_array_guard_common(kls, region, NonArray);
@@ -812,10 +814,11 @@
   case vmIntrinsics::_isInstance:
   case vmIntrinsics::_getModifiers:
   case vmIntrinsics::_isInterface:
   case vmIntrinsics::_isArray:
   case vmIntrinsics::_isPrimitive:
+  case vmIntrinsics::_isHidden:
   case vmIntrinsics::_getSuperclass:
   case vmIntrinsics::_getClassAccessFlags:      return inline_native_Class_query(intrinsic_id());
 
   case vmIntrinsics::_floatToRawIntBits:
   case vmIntrinsics::_floatToIntBits:
@@ -3288,10 +3291,13 @@
 }
 
 Node* LibraryCallKit::generate_interface_guard(Node* kls, RegionNode* region) {
   return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);
 }
+Node* LibraryCallKit::generate_hidden_class_guard(Node* kls, RegionNode* region) {
+  return generate_access_flags_guard(kls, JVM_ACC_IS_HIDDEN_CLASS, 0, region);
+}
 
 Node* LibraryCallKit::generate_value_guard(Node* kls, RegionNode* region) {
   return generate_access_flags_guard(kls, JVM_ACC_VALUE, 0, region);
 }
 
@@ -3327,10 +3333,13 @@
     break;
   case vmIntrinsics::_isPrimitive:
     prim_return_value = intcon(1);
     expect_prim = true;  // obviously
     break;
+  case vmIntrinsics::_isHidden:
+    prim_return_value = intcon(0);
+    break;
   case vmIntrinsics::_getSuperclass:
     prim_return_value = null();
     return_type = TypeInstPtr::MIRROR->cast_to_ptr_type(TypePtr::BotPTR);
     break;
   case vmIntrinsics::_getClassAccessFlags:
@@ -3419,10 +3428,20 @@
 
   case vmIntrinsics::_isPrimitive:
     query_value = intcon(0); // "normal" path produces false
     break;
 
+  case vmIntrinsics::_isHidden:
+    // (To verify this code sequence, check the asserts in JVM_IsHiddenClass.)
+    if (generate_hidden_class_guard(kls, region) != NULL)
+      // A guard was added.  If the guard is taken, it was an hidden class.
+      phi->add_req(intcon(1));
+    // If we fall through, it's a plain class.
+    query_value = intcon(0);
+    break;
+
+
   case vmIntrinsics::_getSuperclass:
     // The rules here are somewhat unfortunate, but we can still do better
     // with random logic than with a JNI call.
     // Interfaces store null or Object as _super, but must report null.
     // Arrays store an intermediate super as _super, but must report Object.
diff a/src/hotspot/share/opto/matcher.cpp b/src/hotspot/share/opto/matcher.cpp
--- a/src/hotspot/share/opto/matcher.cpp
+++ b/src/hotspot/share/opto/matcher.cpp
@@ -2517,35 +2517,20 @@
 
 //----------------------------------------------------------------------
 // Generic machine operands elision.
 //----------------------------------------------------------------------
 
-// Convert (leg)Vec to (leg)Vec[SDXYZ].
-MachOper* Matcher::specialize_vector_operand_helper(MachNode* m, uint opnd_idx, const TypeVect* vt) {
-  MachOper* original_opnd = m->_opnds[opnd_idx];
-  uint ideal_reg = vt->ideal_reg();
-  // Handle special cases.
-  // LShiftCntV/RShiftCntV report wide vector type, but Matcher::vector_shift_count_ideal_reg() as ideal register (see vectornode.hpp).
-  // Look for shift count use sites as well (at vector shift nodes).
-  int opc = m->ideal_Opcode();
-  if ((VectorNode::is_vector_shift_count(opc)  && opnd_idx == 0) || // DEF operand of LShiftCntV/RShiftCntV
-      (VectorNode::is_vector_shift(opc)        && opnd_idx == 2)) { // shift operand of a vector shift node
-    ideal_reg = Matcher::vector_shift_count_ideal_reg(vt->length_in_bytes());
-  }
-  return Matcher::specialize_generic_vector_operand(original_opnd, ideal_reg, false);
-}
-
 // Compute concrete vector operand for a generic TEMP vector mach node based on its user info.
 void Matcher::specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx) {
   assert(use->in(idx) == tmp, "not a user");
   assert(!Matcher::is_generic_vector(use->_opnds[0]), "use not processed yet");
 
   if ((uint)idx == use->two_adr()) { // DEF_TEMP case
     tmp->_opnds[0] = use->_opnds[0]->clone();
   } else {
     uint ideal_vreg = vector_ideal_reg(C->max_vector_size());
-    tmp->_opnds[0] = specialize_generic_vector_operand(tmp->_opnds[0], ideal_vreg, true);
+    tmp->_opnds[0] = Matcher::pd_specialize_generic_vector_operand(tmp->_opnds[0], ideal_vreg, true /*is_temp*/);
   }
 }
 
 // Compute concrete vector operand for a generic DEF/USE vector operand (of mach node m at index idx).
 MachOper* Matcher::specialize_vector_operand(MachNode* m, uint opnd_idx) {
@@ -2562,11 +2547,13 @@
       } else if (is_generic_reg2reg_move(def->as_Mach())) {
         def = def->in(1); // skip over generic reg-to-reg moves
       }
     }
   }
-  return specialize_vector_operand_helper(m, opnd_idx, def->bottom_type()->is_vect());
+  assert(def->bottom_type()->isa_vect(), "not a vector");
+  uint ideal_vreg = def->bottom_type()->ideal_reg();
+  return Matcher::pd_specialize_generic_vector_operand(m->_opnds[opnd_idx], ideal_vreg, false /*is_temp*/);
 }
 
 void Matcher::specialize_mach_node(MachNode* m) {
   assert(!m->is_MachTemp(), "processed along with its user");
   // For generic use operands pull specific register class operands from
diff a/src/hotspot/share/opto/matcher.hpp b/src/hotspot/share/opto/matcher.hpp
--- a/src/hotspot/share/opto/matcher.hpp
+++ b/src/hotspot/share/opto/matcher.hpp
@@ -336,11 +336,10 @@
             Matcher::min_vector_size(bt) <= size);
   }
 
   // Vector ideal reg
   static const uint vector_ideal_reg(int len);
-  static const uint vector_shift_count_ideal_reg(int len);
 
   // CPU supports misaligned vectors store/load.
   static const bool misaligned_vectors_ok();
 
   // Should original key array reference be passed to AES stubs
@@ -520,13 +519,11 @@
 
   void specialize_generic_vector_operands();
   void specialize_mach_node(MachNode* m);
   void specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx);
   MachOper* specialize_vector_operand(MachNode* m, uint opnd_idx);
-  MachOper* specialize_vector_operand_helper(MachNode* m, uint opnd_idx, const TypeVect* vt);
-
-  static MachOper* specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp);
+
 
   static bool is_generic_reg2reg_move(MachNode* m);
   static bool is_generic_vector(MachOper* opnd);
 
   const RegMask* regmask_for_ideal_register(uint ideal_reg, Node* ret);
diff a/src/hotspot/share/opto/node.hpp b/src/hotspot/share/opto/node.hpp
--- a/src/hotspot/share/opto/node.hpp
+++ b/src/hotspot/share/opto/node.hpp
@@ -50,11 +50,10 @@
 class CallLeafNode;
 class CallNode;
 class CallRuntimeNode;
 class CallStaticJavaNode;
 class CastIINode;
-class CastLLNode;
 class CatchNode;
 class CatchProjNode;
 class CheckCastPPNode;
 class ClearArrayNode;
 class CmpNode;
@@ -672,12 +671,11 @@
 
     DEFINE_CLASS_ID(Type,  Node, 2)
       DEFINE_CLASS_ID(Phi,   Type, 0)
       DEFINE_CLASS_ID(ConstraintCast, Type, 1)
         DEFINE_CLASS_ID(CastII, ConstraintCast, 0)
-        DEFINE_CLASS_ID(CastLL, ConstraintCast, 1)
-        DEFINE_CLASS_ID(CheckCastPP, ConstraintCast, 2)
+        DEFINE_CLASS_ID(CheckCastPP, ConstraintCast, 1)
       DEFINE_CLASS_ID(CMove, Type, 3)
       DEFINE_CLASS_ID(SafePointScalarObject, Type, 4)
       DEFINE_CLASS_ID(DecodeNarrowPtr, Type, 5)
         DEFINE_CLASS_ID(DecodeN, DecodeNarrowPtr, 0)
         DEFINE_CLASS_ID(DecodeNKlass, DecodeNarrowPtr, 1)
@@ -819,11 +817,10 @@
   DEFINE_CLASS_QUERY(CallStaticJava)
   DEFINE_CLASS_QUERY(Catch)
   DEFINE_CLASS_QUERY(CatchProj)
   DEFINE_CLASS_QUERY(CheckCastPP)
   DEFINE_CLASS_QUERY(CastII)
-  DEFINE_CLASS_QUERY(CastLL)
   DEFINE_CLASS_QUERY(ConstraintCast)
   DEFINE_CLASS_QUERY(ClearArray)
   DEFINE_CLASS_QUERY(CMove)
   DEFINE_CLASS_QUERY(Cmp)
   DEFINE_CLASS_QUERY(CountedLoop)
diff a/src/hotspot/share/prims/jvm.cpp b/src/hotspot/share/prims/jvm.cpp
--- a/src/hotspot/share/prims/jvm.cpp
+++ b/src/hotspot/share/prims/jvm.cpp
@@ -989,17 +989,188 @@
   }
 
   return (jclass) JNIHandles::make_local(env, k->java_mirror());
 }
 
+enum {
+  NESTMATE              = java_lang_invoke_MemberName::MN_NESTMATE_CLASS,
+  HIDDEN_CLASS          = java_lang_invoke_MemberName::MN_HIDDEN_CLASS,
+  STRONG_LOADER_LINK    = java_lang_invoke_MemberName::MN_STRONG_LOADER_LINK,
+  ACCESS_VM_ANNOTATIONS = java_lang_invoke_MemberName::MN_ACCESS_VM_ANNOTATIONS
+};
+
+/*
+ * Define a class with the specified flags that indicates if it's a nestmate,
+ * hidden, or strongly referenced from class loader.
+ */
+static jclass jvm_lookup_define_class(JNIEnv *env, jclass lookup, const char *name,
+                                      const jbyte *buf, jsize len, jobject pd,
+                                      jboolean init, int flags, jobject classData, TRAPS) {
+  assert(THREAD->is_Java_thread(), "must be a JavaThread");
+  JavaThread* jt = (JavaThread*) THREAD;
+  ResourceMark rm(THREAD);
+
+  Klass* lookup_k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(lookup));
+  // Lookup class must be a non-null instance
+  if (lookup_k == NULL) {
+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Lookup class is null");
+  }
+  assert(lookup_k->is_instance_klass(), "Lookup class must be an instance klass");
+
+  Handle class_loader (THREAD, lookup_k->class_loader());
+
+  bool is_nestmate = (flags & NESTMATE) == NESTMATE;
+  bool is_hidden = (flags & HIDDEN_CLASS) == HIDDEN_CLASS;
+  bool is_strong = (flags & STRONG_LOADER_LINK) == STRONG_LOADER_LINK;
+  bool vm_annotations = (flags & ACCESS_VM_ANNOTATIONS) == ACCESS_VM_ANNOTATIONS;
+
+  InstanceKlass* host_class = NULL;
+  if (is_nestmate) {
+    host_class = InstanceKlass::cast(lookup_k)->nest_host(CHECK_NULL);
+  }
+
+  log_info(class, nestmates)("LookupDefineClass: %s - %s%s, %s, %s, %s",
+                             name,
+                             is_nestmate ? "with dynamic nest-host " : "non-nestmate",
+                             is_nestmate ? host_class->external_name() : "",
+                             is_hidden ? "hidden" : "not hidden",
+                             is_strong ? "strong" : "weak",
+                             vm_annotations ? "with vm annotations" : "without vm annotation");
+
+  if (!is_hidden) {
+    // classData is only applicable for hidden classes
+    if (classData != NULL) {
+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "classData is only applicable for hidden classes");
+    }
+    if (is_nestmate) {
+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "dynamic nestmate is only applicable for hidden classes");
+    }
+    if (!is_strong) {
+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "an ordinary class must be strongly referenced by its defining loader");
+    }
+    if (vm_annotations) {
+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "vm annotations only allowed for hidden classes");
+    }
+    if (flags != STRONG_LOADER_LINK) {
+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
+                  err_msg("invalid flag 0x%x", flags));
+    }
+  }
+
+
+  // Since exceptions can be thrown, class initialization can take place
+  // if name is NULL no check for class name in .class stream has to be made.
+  TempNewSymbol class_name = NULL;
+  if (name != NULL) {
+    const int str_len = (int)strlen(name);
+    if (str_len > Symbol::max_length()) {
+      // It's impossible to create this class;  the name cannot fit
+      // into the constant pool.
+      Exceptions::fthrow(THREAD_AND_LOCATION,
+                         vmSymbols::java_lang_NoClassDefFoundError(),
+                         "Class name exceeds maximum length of %d: %s",
+                         Symbol::max_length(),
+                         name);
+      return 0;
+    }
+    class_name = SymbolTable::new_symbol(name, str_len);
+  }
+
+  Handle protection_domain (THREAD, JNIHandles::resolve(pd));
+  const char* source = is_nestmate ? host_class->external_name() : "__JVM_LookupDefineClass__";
+  ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
+
+  Klass* defined_k;
+  InstanceKlass* ik = NULL;
+  if (!is_hidden) {
+    defined_k = SystemDictionary::resolve_from_stream(class_name,
+                                                      class_loader,
+                                                      protection_domain,
+                                                      &st,
+                                                      CHECK_NULL);
+
+    if (log_is_enabled(Debug, class, resolve) && defined_k != NULL) {
+      trace_class_resolution(defined_k);
+    }
+    ik = InstanceKlass::cast(defined_k);
+  } else { // hidden
+    Handle classData_h(THREAD, JNIHandles::resolve(classData));
+    ClassLoadInfo cl_info(protection_domain,
+                          NULL, // unsafe_anonymous_host
+                          NULL, // cp_patches
+                          host_class,
+                          classData_h,
+                          is_hidden,
+                          is_strong,
+                          vm_annotations);
+    defined_k = SystemDictionary::parse_stream(class_name,
+                                               class_loader,
+                                               &st,
+                                               cl_info,
+                                               CHECK_NULL);
+    if (defined_k == NULL) {
+      THROW_MSG_0(vmSymbols::java_lang_Error(), "Failure to define a hidden class");
+    }
+
+    ik = InstanceKlass::cast(defined_k);
+
+    // The hidden class loader data has been artificially been kept alive to
+    // this point. The mirror and any instances of this class have to keep
+    // it alive afterwards.
+    ik->class_loader_data()->dec_keep_alive();
+
+    if (is_nestmate && log_is_enabled(Debug, class, nestmates)) {
+      ModuleEntry* module = ik->module();
+      const char * module_name = module->is_named() ? module->name()->as_C_string() : UNNAMED_MODULE;
+      log_debug(class, nestmates)("Dynamic nestmate: %s/%s, nest_host %s, %s",
+                                  module_name,
+                                  ik->external_name(),
+                                  host_class->external_name(),
+                                  ik->is_hidden() ? "is hidden" : "is not hidden");
+    }
+  }
+  assert(Reflection::is_same_class_package(lookup_k, defined_k),
+         "lookup class and defined class are in different packages");
+
+  if (init) {
+    ik->initialize(CHECK_NULL);
+  } else {
+    ik->link_class(CHECK_NULL);
+  }
+
+  return (jclass) JNIHandles::make_local(env, defined_k->java_mirror());
+}
 
 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
   JVMWrapper("JVM_DefineClass");
 
   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
 JVM_END
 
+/*
+ * Define a class with the specified lookup class.
+ *  lookup:  Lookup class
+ *  name:    the name of the class
+ *  buf:     class bytes
+ *  len:     length of class bytes
+ *  pd:      protection domain
+ *  init:    initialize the class
+ *  flags:   properties of the class
+ *  classData: private static pre-initialized field
+ */
+JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
+          jsize len, jobject pd, jboolean initialize, int flags, jobject classData))
+  JVMWrapper("JVM_LookupDefineClass");
+
+  if (lookup == NULL) {
+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), "Lookup class is null");
+  }
+
+  assert(buf != NULL, "buf must not be NULL");
+
+  return jvm_lookup_define_class(env, lookup, name, buf, len, pd, initialize, flags, classData, THREAD);
+JVM_END
 
 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
   JVMWrapper("JVM_DefineClassWithSource");
 
   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
@@ -1058,31 +1229,31 @@
 JVM_END
 
 // Module support //////////////////////////////////////////////////////////////////////////////
 
 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
-                                 jstring location, const char* const* packages, jsize num_packages))
+                                 jstring location, jobjectArray packages))
   JVMWrapper("JVM_DefineModule");
-  Modules::define_module(module, is_open, version, location, packages, num_packages, CHECK);
+  Modules::define_module(module, is_open, version, location, packages, CHECK);
 JVM_END
 
 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
   JVMWrapper("JVM_SetBootLoaderUnnamedModule");
   Modules::set_bootloader_unnamed_module(module, CHECK);
 JVM_END
 
-JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module))
+JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module))
   JVMWrapper("JVM_AddModuleExports");
   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
 JVM_END
 
-JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package))
+JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package))
   JVMWrapper("JVM_AddModuleExportsToAllUnnamed");
   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
 JVM_END
 
-JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package))
+JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package))
   JVMWrapper("JVM_AddModuleExportsToAll");
   Modules::add_module_exports(from_module, package, NULL, CHECK);
 JVM_END
 
 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
@@ -1167,10 +1338,19 @@
   // The compiler intrinsic for isInterface tests the
   // Klass::_access_flags bits in the same way.
   return result;
 JVM_END
 
+JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))
+  JVMWrapper("JVM_IsHiddenClass");
+  oop mirror = JNIHandles::resolve_non_null(cls);
+  if (java_lang_Class::is_primitive(mirror)) {
+    return JNI_FALSE;
+  }
+  Klass* k = java_lang_Class::as_Klass(mirror);
+  return k->is_hidden();
+JVM_END
 
 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
   JVMWrapper("JVM_GetClassSigners");
   JvmtiVMObjectAllocEventCollector oam;
   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
@@ -1434,11 +1614,11 @@
   bool inner_is_member = false;
   Klass* outer_klass
     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
                           )->compute_enclosing_class(&inner_is_member, CHECK_NULL);
   if (outer_klass == NULL)  return NULL;  // already a top-level class
-  if (!inner_is_member)  return NULL;     // an anonymous class (inside a method)
+  if (!inner_is_member)  return NULL;     // a hidden or unsafe anonymous class (inside a method)
   return (jclass) JNIHandles::make_local(env, outer_klass->java_mirror());
 }
 JVM_END
 
 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
@@ -1890,77 +2070,91 @@
   // current is not a primitive or array class
   JVMWrapper("JVM_GetNestHost");
   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
   assert(c->is_instance_klass(), "must be");
   InstanceKlass* ck = InstanceKlass::cast(c);
-  // Don't post exceptions if validation fails
-  InstanceKlass* host = ck->nest_host(NULL, THREAD);
+  InstanceKlass* host = ck->nest_host(THREAD);
   return (jclass) (host == NULL ? NULL :
                    JNIHandles::make_local(THREAD, host->java_mirror()));
 }
 JVM_END
 
 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
 {
   // current is not a primitive or array class
   JVMWrapper("JVM_GetNestMembers");
+  ResourceMark rm(THREAD);
   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
   assert(c->is_instance_klass(), "must be");
   InstanceKlass* ck = InstanceKlass::cast(c);
-  // Get the nest host for this nest - throw ICCE if validation fails
-  Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();
-  InstanceKlass* host = ck->nest_host(icce, CHECK_NULL);
+  InstanceKlass* host = ck->nest_host(THREAD);
 
+  log_trace(class, nestmates)("Calling GetNestMembers for type %s with nest-host %s",
+                              ck->external_name(), host->external_name());
   {
     JvmtiVMObjectAllocEventCollector oam;
     Array<u2>* members = host->nest_members();
     int length = members == NULL ? 0 : members->length();
+
+    log_trace(class, nestmates)(" - host has %d listed nest members", length);
+
     // nest host is first in the array so make it one bigger
     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
                                              length + 1, CHECK_NULL);
-    objArrayHandle result (THREAD, r);
+    objArrayHandle result(THREAD, r);
     result->obj_at_put(0, host->java_mirror());
     if (length != 0) {
-      int i;
-      for (i = 0; i < length; i++) {
-         int cp_index = members->at(i);
-         Klass* k = host->constants()->klass_at(cp_index, CHECK_NULL);
-         if (k->is_instance_klass()) {
-           InstanceKlass* nest_host_k =
-             InstanceKlass::cast(k)->nest_host(icce, CHECK_NULL);
-           if (nest_host_k == host) {
-             result->obj_at_put(i+1, k->java_mirror());
-           }
-           else {
-             // k's nest host is legal but it isn't our host so
-             // throw ICCE
-             ResourceMark rm(THREAD);
-             Exceptions::fthrow(THREAD_AND_LOCATION,
-                                icce,
-                                "Nest member %s in %s declares a different nest host of %s",
-                                k->external_name(),
-                                host->external_name(),
-                                nest_host_k->external_name()
-                           );
-             return NULL;
-           }
-         }
-         else {
-           // we have a bad nest member entry - throw ICCE
-           ResourceMark rm(THREAD);
-           Exceptions::fthrow(THREAD_AND_LOCATION,
-                              icce,
-                              "Class %s can not be a nest member of %s",
-                              k->external_name(),
-                              host->external_name()
-                              );
-           return NULL;
-         }
+      int count = 0;
+      for (int i = 0; i < length; i++) {
+        int cp_index = members->at(i);
+        Klass* k = host->constants()->klass_at(cp_index, THREAD);
+        if (HAS_PENDING_EXCEPTION) {
+          if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {
+            return NULL; // propagate VMEs
+          }
+          if (log_is_enabled(Trace, class, nestmates)) {
+            stringStream ss;
+            char* target_member_class = host->constants()->klass_name_at(cp_index)->as_C_string();
+            ss.print(" - resolution of nest member %s failed: ", target_member_class);
+            java_lang_Throwable::print(PENDING_EXCEPTION, &ss);
+            log_trace(class, nestmates)("%s", ss.as_string());
+          }
+          CLEAR_PENDING_EXCEPTION;
+          continue;
+        }
+        if (k->is_instance_klass()) {
+          InstanceKlass* ik = InstanceKlass::cast(k);
+          InstanceKlass* nest_host_k = ik->nest_host(CHECK_NULL);
+          if (nest_host_k == host) {
+            result->obj_at_put(count+1, k->java_mirror());
+            count++;
+            log_trace(class, nestmates)(" - [%d] = %s", count, ik->external_name());
+          } else {
+            log_trace(class, nestmates)(" - skipping member %s with different host %s",
+                                        ik->external_name(), nest_host_k->external_name());
+          }
+        } else {
+          log_trace(class, nestmates)(" - skipping member %s that is not an instance class",
+                                      k->external_name());
+        }
+      }
+      if (count < length) {
+        // we had invalid entries so we need to compact the array
+        log_trace(class, nestmates)(" - compacting array from length %d to %d",
+                                    length + 1, count + 1);
+
+        objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),
+                                                  count + 1, CHECK_NULL);
+        objArrayHandle result2(THREAD, r2);
+        for (int i = 0; i < count + 1; i++) {
+          result2->obj_at_put(i, result->obj_at(i));
+        }
+        return (jobjectArray)JNIHandles::make_local(THREAD, result2());
       }
     }
     else {
-      assert(host == ck, "must be singleton nest");
+      assert(host == ck || ck->is_hidden(), "must be singleton nest or dynamic nestmate");
     }
     return (jobjectArray)JNIHandles::make_local(THREAD, result());
   }
 }
 JVM_END
diff a/src/hotspot/share/prims/jvmtiEnv.cpp b/src/hotspot/share/prims/jvmtiEnv.cpp
--- a/src/hotspot/share/prims/jvmtiEnv.cpp
+++ b/src/hotspot/share/prims/jvmtiEnv.cpp
@@ -212,11 +212,10 @@
 // module_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetNamedModule(jobject class_loader, const char* package_name, jobject* module_ptr) {
   JavaThread* THREAD = JavaThread::current(); // pass to macros
   ResourceMark rm(THREAD);
-
   Handle h_loader (THREAD, JNIHandles::resolve(class_loader));
   // Check that loader is a subclass of java.lang.ClassLoader.
   if (h_loader.not_null() && !java_lang_ClassLoader::is_subclass(h_loader->klass())) {
     return JVMTI_ERROR_ILLEGAL_ARGUMENT;
   }
@@ -1199,25 +1198,23 @@
 // owned_monitor_count_ptr - pre-checked for NULL
 // owned_monitors_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetOwnedMonitorInfo(JavaThread* java_thread, jint* owned_monitor_count_ptr, jobject** owned_monitors_ptr) {
   jvmtiError err = JVMTI_ERROR_NONE;
-  JavaThread* calling_thread = JavaThread::current();
 
   // growable array of jvmti monitors info on the C-heap
   GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =
       new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, true);
 
   // It is only safe to perform the direct operation on the current
-  // thread. All other usage needs to use a vm-safepoint-op for safety.
-  if (java_thread == calling_thread) {
-    err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);
+  // thread. All other usage needs to use a direct handshake for safety.
+  if (java_thread == JavaThread::current()) {
+    err = get_owned_monitors(java_thread, owned_monitors_list);
   } else {
-    // JVMTI get monitors info at safepoint. Do not require target thread to
-    // be suspended.
-    VM_GetOwnedMonitorInfo op(this, calling_thread, java_thread, owned_monitors_list);
-    VMThread::execute(&op);
+    // get owned monitors info with handshake
+    GetOwnedMonitorInfoClosure op(this, owned_monitors_list);
+    Handshake::execute_direct(&op, java_thread);
     err = op.result();
   }
   jint owned_monitor_count = owned_monitors_list->length();
   if (err == JVMTI_ERROR_NONE) {
     if ((err = allocate(owned_monitor_count * sizeof(jobject *),
@@ -1245,25 +1242,23 @@
 // monitor_info_count_ptr - pre-checked for NULL
 // monitor_info_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetOwnedMonitorStackDepthInfo(JavaThread* java_thread, jint* monitor_info_count_ptr, jvmtiMonitorStackDepthInfo** monitor_info_ptr) {
   jvmtiError err = JVMTI_ERROR_NONE;
-  JavaThread* calling_thread  = JavaThread::current();
 
   // growable array of jvmti monitors info on the C-heap
   GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =
          new (ResourceObj::C_HEAP, mtInternal) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, true);
 
   // It is only safe to perform the direct operation on the current
-  // thread. All other usage needs to use a vm-safepoint-op for safety.
-  if (java_thread == calling_thread) {
-    err = get_owned_monitors(calling_thread, java_thread, owned_monitors_list);
+  // thread. All other usage needs to use a direct handshake for safety.
+  if (java_thread == JavaThread::current()) {
+    err = get_owned_monitors(java_thread, owned_monitors_list);
   } else {
-    // JVMTI get owned monitors info at safepoint. Do not require target thread to
-    // be suspended.
-    VM_GetOwnedMonitorInfo op(this, calling_thread, java_thread, owned_monitors_list);
-    VMThread::execute(&op);
+    // get owned monitors info with handshake
+    GetOwnedMonitorInfoClosure op(this, owned_monitors_list);
+    Handshake::execute_direct(&op, java_thread);
     err = op.result();
   }
 
   jint owned_monitor_count = owned_monitors_list->length();
   if (err == JVMTI_ERROR_NONE) {
@@ -1294,20 +1289,19 @@
 // java_thread - pre-checked
 // monitor_ptr - pre-checked for NULL
 jvmtiError
 JvmtiEnv::GetCurrentContendedMonitor(JavaThread* java_thread, jobject* monitor_ptr) {
   jvmtiError err = JVMTI_ERROR_NONE;
-  JavaThread* calling_thread  = JavaThread::current();
 
   // It is only safe to perform the direct operation on the current
-  // thread. All other usage needs to use a vm-safepoint-op for safety.
-  if (java_thread == calling_thread) {
-    err = get_current_contended_monitor(calling_thread, java_thread, monitor_ptr);
+  // thread. All other usage needs to use a direct handshake for safety.
+  if (java_thread == JavaThread::current()) {
+    err = get_current_contended_monitor(java_thread, monitor_ptr);
   } else {
-    // get contended monitor information at safepoint.
-    VM_GetCurrentContendedMonitor op(this, calling_thread, java_thread, monitor_ptr);
-    VMThread::execute(&op);
+    // get contended monitor information with handshake
+    GetCurrentContendedMonitorClosure op(this, monitor_ptr);
+    Handshake::execute_direct(&op, java_thread);
     err = op.result();
   }
   return err;
 } /* end GetCurrentContendedMonitor */
 
diff a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
--- a/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
+++ b/src/hotspot/share/prims/jvmtiRedefineClasses.cpp
@@ -148,12 +148,12 @@
       _res = JVMTI_ERROR_NULL_POINTER;
       return false;
     }
 
     oop mirror = JNIHandles::resolve_non_null(_class_defs[i].klass);
-    // classes for primitives and arrays and vm unsafe anonymous classes cannot be redefined
-    // check here so following code can assume these classes are InstanceKlass
+    // classes for primitives, arrays, hidden and vm unsafe anonymous classes
+    // cannot be redefined.
     if (!is_modifiable_class(mirror)) {
       _res = JVMTI_ERROR_UNMODIFIABLE_CLASS;
       return false;
     }
   }
@@ -291,12 +291,13 @@
   // classes for arrays cannot be redefined
   if (k == NULL || !k->is_instance_klass()) {
     return false;
   }
 
-  // Cannot redefine or retransform an unsafe anonymous class.
-  if (InstanceKlass::cast(k)->is_unsafe_anonymous()) {
+  // Cannot redefine or retransform a hidden or an unsafe anonymous class.
+  if (InstanceKlass::cast(k)->is_hidden() ||
+      InstanceKlass::cast(k)->is_unsafe_anonymous()) {
     return false;
   }
   return true;
 }
 
@@ -1236,14 +1237,15 @@
     // Set redefined class handle in JvmtiThreadState class.
     // This redefined class is sent to agent event handler for class file
     // load hook event.
     state->set_class_being_redefined(the_class, _class_load_kind);
 
+    ClassLoadInfo cl_info(protection_domain);
     InstanceKlass* scratch_class = SystemDictionary::parse_stream(
                                                       the_class_sym,
                                                       the_class_loader,
-                                                      protection_domain,
+                                                      &st,
                                                       &st,
                                                       THREAD);
     // Clear class_being_redefined just to be sure.
     state->clear_class_being_redefined();
 
diff a/src/hotspot/share/prims/methodHandles.cpp b/src/hotspot/share/prims/methodHandles.cpp
--- a/src/hotspot/share/prims/methodHandles.cpp
+++ b/src/hotspot/share/prims/methodHandles.cpp
@@ -30,10 +30,12 @@
 #include "code/dependencyContext.hpp"
 #include "compiler/compileBroker.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/oopMapCache.hpp"
 #include "interpreter/linkResolver.hpp"
+#include "logging/log.hpp"
+#include "logging/logStream.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/oopFactory.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
 #include "oops/objArrayKlass.hpp"
@@ -226,33 +228,34 @@
   assert(m.not_null(), "null method handle");
   InstanceKlass* m_klass = m->method_holder();
   assert(m_klass != NULL, "null holder for method handle");
   int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );
   int vmindex = Method::invalid_vtable_index;
+  LogTarget(Debug, methodhandles, indy) lt_indy;
 
   switch (info.call_kind()) {
   case CallInfo::itable_call:
     vmindex = info.itable_index();
     // More importantly, the itable index only works with the method holder.
     assert(m_klass->verify_itable_index(vmindex), "");
     flags |= IS_METHOD | (JVM_REF_invokeInterface << REFERENCE_KIND_SHIFT);
-    if (TraceInvokeDynamic) {
-      ttyLocker ttyl;
+    if (lt_indy.is_enabled()) {
       ResourceMark rm;
-      tty->print_cr("memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:",
-            Method::name_and_sig_as_C_string(m->method_holder(), m->name(), m->signature()),
-            vmindex);
-       m->access_flags().print_on(tty);
+      LogStream ls(lt_indy);
+      ls.print_cr("memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:",
+                  Method::name_and_sig_as_C_string(m->method_holder(), m->name(), m->signature()),
+                  vmindex);
+       m->access_flags().print_on(&ls);
        if (!m->is_abstract()) {
          if (!m->is_private()) {
-           tty->print("default");
+           ls.print("default");
          }
          else {
-           tty->print("private-intf");
+           ls.print("private-intf");
          }
        }
-       tty->cr();
+       ls.cr();
     }
     break;
 
   case CallInfo::vtable_call:
     vmindex = info.vtable_index();
@@ -280,21 +283,21 @@
         return NULL;  // elicit an error later in product build
       }
       assert(info.resolved_klass()->is_subtype_of(m_klass_non_interface), "virtual call must be type-safe");
       m_klass = m_klass_non_interface;
     }
-    if (TraceInvokeDynamic) {
-      ttyLocker ttyl;
+    if (lt_indy.is_enabled()) {
       ResourceMark rm;
-      tty->print_cr("memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:",
-            Method::name_and_sig_as_C_string(m->method_holder(), m->name(), m->signature()),
-            m_klass->internal_name(), vmindex);
-       m->access_flags().print_on(tty);
+      LogStream ls(lt_indy);
+      ls.print_cr("memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:",
+                  Method::name_and_sig_as_C_string(m->method_holder(), m->name(), m->signature()),
+                  m_klass->internal_name(), vmindex);
+       m->access_flags().print_on(&ls);
        if (m->is_default_method()) {
-         tty->print("default");
+         ls.print("default");
        }
-       tty->cr();
+       ls.cr();
     }
     break;
 
   case CallInfo::direct_call:
     vmindex = Method::nonvirtual_vtable_index;
@@ -1076,11 +1079,11 @@
     Deoptimization::deoptimize_all_marked();
   }
 }
 
 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
-  if (TraceMethodHandles) {
+  if (log_is_enabled(Info, methodhandles)) {
     const char* name = vmIntrinsics::name_at(iid);
     if (*name == '_')  name += 1;
     const size_t len = strlen(name) + 50;
     char* qname = NEW_C_HEAP_ARRAY(char, len, mtInternal);
     const char* suffix = "";
@@ -1115,10 +1118,14 @@
     template(java_lang_invoke_MemberName,MN_CALLER_SENSITIVE) \
     template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \
     template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \
     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_SHIFT) \
     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_MASK) \
+    template(java_lang_invoke_MemberName,MN_NESTMATE_CLASS) \
+    template(java_lang_invoke_MemberName,MN_HIDDEN_CLASS) \
+    template(java_lang_invoke_MemberName,MN_STRONG_LOADER_LINK) \
+    template(java_lang_invoke_MemberName,MN_ACCESS_VM_ANNOTATIONS) \
     /*end*/
 
 #define IGNORE_REQ(req_expr) /* req_expr */
 #define ONE_PLUS(scope,value) 1+
 static const int con_value_count = EACH_NAMED_CON(ONE_PLUS, IGNORE_REQ) 0;
@@ -1531,11 +1538,11 @@
   {CC "setCallSiteTargetVolatile", CC "(" CS "" MH ")V",                     FN_PTR(MHN_setCallSiteTargetVolatile)},
   {CC "copyOutBootstrapArguments", CC "(" CLS "[III[" OBJ "IZ" OBJ ")V",     FN_PTR(MHN_copyOutBootstrapArguments)},
   {CC "clearCallSiteContext",      CC "(" CTX ")V",                          FN_PTR(MHN_clearCallSiteContext)},
   {CC "staticFieldOffset",         CC "(" MEM ")J",                          FN_PTR(MHN_staticFieldOffset)},
   {CC "staticFieldBase",           CC "(" MEM ")" OBJ,                        FN_PTR(MHN_staticFieldBase)},
-  {CC "getMemberVMInfo",           CC "(" MEM ")" OBJ,                        FN_PTR(MHN_getMemberVMInfo)}
+  {CC "getMemberVMInfo",           CC "(" MEM ")" OBJ,                       FN_PTR(MHN_getMemberVMInfo)}
 };
 
 static JNINativeMethod MH_methods[] = {
   // UnsupportedOperationException throwers
   {CC "invoke",                    CC "([" OBJ ")" OBJ,                       FN_PTR(MH_invoke_UOE)},
@@ -1562,12 +1569,10 @@
     status = env->RegisterNatives(MH_class, MH_methods, sizeof(MH_methods)/sizeof(JNINativeMethod));
     guarantee(status == JNI_OK && !env->ExceptionOccurred(),
               "register java.lang.invoke.MethodHandle natives");
   }
 
-  if (TraceInvokeDynamic) {
-    tty->print_cr("MethodHandle support loaded (using LambdaForms)");
-  }
+  log_debug(methodhandles, indy)("MethodHandle support loaded (using LambdaForms)");
 
   MethodHandles::set_enabled(true);
 }
 JVM_END
diff a/src/hotspot/share/prims/unsafe.cpp b/src/hotspot/share/prims/unsafe.cpp
--- a/src/hotspot/share/prims/unsafe.cpp
+++ b/src/hotspot/share/prims/unsafe.cpp
@@ -985,15 +985,22 @@
   }
 
   ClassFileStream st(class_bytes, class_bytes_length, host_source, ClassFileStream::verify);
 
   Symbol* no_class_name = NULL;
+  ClassLoadInfo cl_info(host_domain,
+                        InstanceKlass::cast(host_klass),
+                        cp_patches,
+                        NULL,     // dynamic_nest_host
+                        Handle(), // classData
+                        false,    // is_hidden
+                        false,    // is_strong_hidden
+                        true);    // can_access_vm_annotations
+
   Klass* anonk = SystemDictionary::parse_stream(no_class_name,
                                                 host_loader,
-                                                host_domain,
-                                                &st,
-                                                InstanceKlass::cast(host_klass),
+                                                &st,
                                                 cp_patches,
                                                 CHECK_NULL);
   if (anonk == NULL) {
     return NULL;
   }
diff a/src/hotspot/share/prims/whitebox.cpp b/src/hotspot/share/prims/whitebox.cpp
--- a/src/hotspot/share/prims/whitebox.cpp
+++ b/src/hotspot/share/prims/whitebox.cpp
@@ -94,11 +94,10 @@
 #include "gc/g1/heapRegionRemSet.hpp"
 #include "gc/g1/heterogeneousHeapRegionManager.hpp"
 #endif // INCLUDE_G1GC
 #if INCLUDE_PARALLELGC
 #include "gc/parallel/parallelScavengeHeap.inline.hpp"
-#include "gc/parallel/adjoiningGenerations.hpp"
 #endif // INCLUDE_PARALLELGC
 #if INCLUDE_NMT
 #include "services/mallocSiteTable.hpp"
 #include "services/memTracker.hpp"
 #include "utilities/nativeCallStack.hpp"
@@ -607,11 +606,11 @@
 
 #if INCLUDE_PARALLELGC
 
 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
   if (UseParallelGC) {
-    return ParallelScavengeHeap::heap()->gens()->virtual_spaces()->alignment();
+    return GenAlignment;
   }
   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), "WB_PSVirtualSpaceAlignment: Parallel GC is not enabled");
 WB_END
 
 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
@@ -1716,56 +1715,23 @@
   MetadataFactory::free_array(cld, (Array<u1>*)(uintptr_t)addr);
 WB_END
 
 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
                                 jstring version, jstring location, jobjectArray packages))
-  ResourceMark rm(THREAD);
-
-  objArrayOop packages_oop = objArrayOop(JNIHandles::resolve(packages));
-  objArrayHandle packages_h(THREAD, packages_oop);
-  int num_packages = (packages_h == NULL ? 0 : packages_h->length());
-
-  char** pkgs = NULL;
-  if (num_packages > 0) {
-    pkgs = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char*, num_packages);
-    for (int x = 0; x < num_packages; x++) {
-      oop pkg_str = packages_h->obj_at(x);
-      if (pkg_str == NULL || !pkg_str->is_a(SystemDictionary::String_klass())) {
-        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
-                  err_msg("Bad package name"));
-      }
-      pkgs[x] = java_lang_String::as_utf8_string(pkg_str);
-    }
-  }
-  Modules::define_module(module, is_open, version, location, (const char* const*)pkgs, num_packages, CHECK);
+  Modules::define_module(module, is_open, version, location, packages, CHECK);
 WB_END
 
 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
-  ResourceMark rm(THREAD);
-  char* package_name = NULL;
-  if (package != NULL) {
-      package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
-  }
-  Modules::add_module_exports_qualified(from_module, package_name, to_module, CHECK);
+  Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
 WB_END
 
 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
-  ResourceMark rm(THREAD);
-  char* package_name = NULL;
-  if (package != NULL) {
-      package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
-  }
-  Modules::add_module_exports_to_all_unnamed(module, package_name, CHECK);
+  Modules::add_module_exports_to_all_unnamed(module, package, CHECK);
 WB_END
 
 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
-  ResourceMark rm(THREAD);
-  char* package_name = NULL;
-  if (package != NULL) {
-      package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
-  }
-  Modules::add_module_exports(module, package_name, NULL, CHECK);
+  Modules::add_module_exports(module, package, NULL, CHECK);
 WB_END
 
 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
   Modules::add_reads_module(from_module, source_module, CHECK);
 WB_END
diff a/src/hotspot/share/runtime/arguments.cpp b/src/hotspot/share/runtime/arguments.cpp
--- a/src/hotspot/share/runtime/arguments.cpp
+++ b/src/hotspot/share/runtime/arguments.cpp
@@ -546,10 +546,11 @@
   { "CompactFields",                 JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
   { "FieldsAllocationStyle",         JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },
 #ifndef X86
   { "UseSSE",                        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 #endif // !X86
+  { "UseAdaptiveGCBoundary",         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },
 
 #ifdef TEST_VERIFY_SPECIAL_JVM_FLAGS
   // These entries will generate build errors.  Their purpose is to test the macros.
   { "dep > obs",                    JDK_Version::jdk(9), JDK_Version::jdk(8), JDK_Version::undefined() },
   { "dep > exp ",                   JDK_Version::jdk(9), JDK_Version::undefined(), JDK_Version::jdk(8) },
@@ -584,11 +585,13 @@
   { "TraceClassLoadingPreorder", LogLevel::Debug, true,  LOG_TAGS(class, preorder) },
   { "TraceClassPaths",           LogLevel::Info,  true,  LOG_TAGS(class, path) },
   { "TraceClassResolution",      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },
   { "TraceClassUnloading",       LogLevel::Info,  true,  LOG_TAGS(class, unload) },
   { "TraceExceptions",           LogLevel::Info,  true,  LOG_TAGS(exceptions) },
+  { "TraceInvokeDynamic",        LogLevel::Debug, true,  LOG_TAGS(methodhandles, indy) },
   { "TraceLoaderConstraints",    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },
+  { "TraceMethodHandles",        LogLevel::Info,  true,  LOG_TAGS(methodhandles) },
   { "TraceMonitorInflation",     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },
   { "TraceSafepointCleanupTime", LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },
   { "TraceJVMTIObjectTagging",   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },
   { "TraceRedefineClasses",      LogLevel::Info,  false, LOG_TAGS(redefine, class) },
   { "PrintJNIResolving",         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },
@@ -716,17 +719,17 @@
 // version is first updated, without needing to update all the impacted flags at
 // the same time. In practice we can't issue the warning immediately when the version
 // is updated as it occurs for every test and some tests are not prepared to handle
 // unexpected output - see 8196739. Instead we only check if the table is up-to-date
 // if the check_globals flag is true, and in addition allow a grace period and only
-// check for stale flags when we hit build 20 (which is far enough into the 6 month
+// check for stale flags when we hit build 25 (which is far enough into the 6 month
 // release cycle that all flag updates should have been processed, whilst still
 // leaving time to make the change before RDP2).
 // We use a gtest to call this, passing true, so that we can detect stale flags before
 // the end of the release cycle.
 
-static const int SPECIAL_FLAG_VALIDATION_BUILD = 20;
+static const int SPECIAL_FLAG_VALIDATION_BUILD = 25;
 
 bool Arguments::verify_special_jvm_flags(bool check_globals) {
   bool success = true;
   for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {
     const SpecialFlag& flag = special_jvm_flags[i];
diff a/src/hotspot/share/runtime/deoptimization.cpp b/src/hotspot/share/runtime/deoptimization.cpp
--- a/src/hotspot/share/runtime/deoptimization.cpp
+++ b/src/hotspot/share/runtime/deoptimization.cpp
@@ -1074,10 +1074,84 @@
   return_oops.clear();
   return_oops.push(Handle(THREAD, new_vt));
   return false;
 }
 
+#if INCLUDE_JVMCI
+/**
+ * For primitive types whose kind gets "erased" at runtime (shorts become stack ints),
+ * we need to somehow be able to recover the actual kind to be able to write the correct
+ * amount of bytes.
+ * For that purpose, this method assumes that, for an entry spanning n bytes at index i,
+ * the entries at index n + 1 to n + i are 'markers'.
+ * For example, if we were writing a short at index 4 of a byte array of size 8, the
+ * expected form of the array would be:
+ *
+ * {b0, b1, b2, b3, INT, marker, b6, b7}
+ *
+ * Thus, in order to get back the size of the entry, we simply need to count the number
+ * of marked entries
+ *
+ * @param virtualArray the virtualized byte array
+ * @param i index of the virtual entry we are recovering
+ * @return The number of bytes the entry spans
+ */
+static int count_number_of_bytes_for_entry(ObjectValue *virtualArray, int i) {
+  int index = i;
+  while (++index < virtualArray->field_size() &&
+           virtualArray->field_at(index)->is_marker()) {}
+  return index - i;
+}
+
+/**
+ * If there was a guarantee for byte array to always start aligned to a long, we could
+ * do a simple check on the parity of the index. Unfortunately, that is not always the
+ * case. Thus, we check alignment of the actual address we are writing to.
+ * In the unlikely case index 0 is 5-aligned for example, it would then be possible to
+ * write a long to index 3.
+ */
+static jbyte* check_alignment_get_addr(typeArrayOop obj, int index, int expected_alignment) {
+    jbyte* res = obj->byte_at_addr(index);
+    assert((((intptr_t) res) % expected_alignment) == 0, "Non-aligned write");
+    return res;
+}
+
+static void byte_array_put(typeArrayOop obj, intptr_t val, int index, int byte_count) {
+  switch (byte_count) {
+    case 1:
+      obj->byte_at_put(index, (jbyte) *((jint *) &val));
+      break;
+    case 2:
+      *((jshort *) check_alignment_get_addr(obj, index, 2)) = (jshort) *((jint *) &val);
+      break;
+    case 4:
+      *((jint *) check_alignment_get_addr(obj, index, 4)) = (jint) *((jint *) &val);
+      break;
+    case 8: {
+#ifdef _LP64
+        jlong res = (jlong) *((jlong *) &val);
+#else
+#ifdef SPARC
+      // For SPARC we have to swap high and low words.
+      jlong v = (jlong) *((jlong *) &val);
+      jlong res = 0;
+      res |= ((v & (jlong) 0xffffffff) << 32);
+      res |= ((v >> 32) & (jlong) 0xffffffff);
+#else
+      jlong res = (jlong) *((jlong *) &val);
+#endif // SPARC
+#endif
+      *((jlong *) check_alignment_get_addr(obj, index, 8)) = res;
+      break;
+  }
+    default:
+      ShouldNotReachHere();
+  }
+}
+#endif // INCLUDE_JVMCI
+
+
 // restore elements of an eliminated type array
 void Deoptimization::reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, typeArrayOop obj, BasicType type) {
   int index = 0;
   intptr_t val;
 
@@ -1151,30 +1225,42 @@
       assert(value->type() == T_INT, "Agreement.");
       val = value->get_int();
       obj->char_at_put(index, (jchar)*((jint*)&val));
       break;
 
-    case T_BYTE:
+    case T_BYTE: {
       assert(value->type() == T_INT, "Agreement.");
+      // The value we get is erased as a regular int. We will need to find its actual byte count 'by hand'.
       val = value->get_int();
+#if INCLUDE_JVMCI
+      int byte_count = count_number_of_bytes_for_entry(sv, i);
+      byte_array_put(obj, val, index, byte_count);
+      // According to byte_count contract, the values from i + 1 to i + byte_count are illegal values. Skip.
+      i += byte_count - 1; // Balance the loop counter.
+      index += byte_count;
+      // index has been updated so continue at top of loop
+      continue;
+#else
       obj->byte_at_put(index, (jbyte)*((jint*)&val));
       break;
+#endif // INCLUDE_JVMCI
+    }
 
-    case T_BOOLEAN:
+    case T_BOOLEAN: {
       assert(value->type() == T_INT, "Agreement.");
       val = value->get_int();
       obj->bool_at_put(index, (jboolean)*((jint*)&val));
       break;
+    }
 
       default:
         ShouldNotReachHere();
     }
     index++;
   }
 }
 
-
 // restore fields of an eliminated object array
 void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj) {
   for (int i = 0; i < sv->field_size(); i++) {
     StackValue* value = StackValue::create_stack_value(fr, reg_map, sv->field_at(i));
     assert(value->type() == T_OBJECT, "object element expected");
diff a/src/hotspot/share/runtime/deoptimization.hpp b/src/hotspot/share/runtime/deoptimization.hpp
--- a/src/hotspot/share/runtime/deoptimization.hpp
+++ b/src/hotspot/share/runtime/deoptimization.hpp
@@ -135,10 +135,15 @@
     Unpack_uncommon_trap        = 2, // redo last byte code (C2 only)
     Unpack_reexecute            = 3, // reexecute bytecode (C1 only)
     Unpack_LIMIT                = 4
   };
 
+#if INCLUDE_JVMCI
+  // Can reconstruct virtualized unsafe large accesses to byte arrays.
+  static const int _support_large_access_byte_array_virtualization = 1;
+#endif
+
   // Make all nmethods that are marked_for_deoptimization not_entrant and deoptimize any live
   // activations using those nmethods.  If an nmethod is passed as an argument then it is
   // marked_for_deoptimization and made not_entrant.  Otherwise a scan of the code cache is done to
   // find all marked nmethods and they are made not_entrant.
   static void deoptimize_all_marked(nmethod* nmethod_only = NULL);
diff a/src/hotspot/share/runtime/globals.hpp b/src/hotspot/share/runtime/globals.hpp
--- a/src/hotspot/share/runtime/globals.hpp
+++ b/src/hotspot/share/runtime/globals.hpp
@@ -2314,13 +2314,10 @@
           "Allow Java agent to be run with CDS dumping")                    \
                                                                             \
   diagnostic(bool, PrintMethodHandleStubs, false,                           \
           "Print generated stub code for method handles")                   \
                                                                             \
-  develop(bool, TraceMethodHandles, false,                                  \
-          "trace internal method handle operations")                        \
-                                                                            \
   diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \
           "perform extra checks when constructing method handles")          \
                                                                             \
   diagnostic(bool, ShowHiddenFrames, false,                                 \
           "show method handle implementation frames (usually hidden)")      \
@@ -2329,13 +2326,10 @@
           "trust final non-static declarations for constant folding")       \
                                                                             \
   diagnostic(bool, FoldStableValues, true,                                  \
           "Optimize loads from stable fields (marked w/ @Stable)")          \
                                                                             \
-  develop(bool, TraceInvokeDynamic, false,                                  \
-          "trace internal invoke dynamic operations")                       \
-                                                                            \
   diagnostic(int, UseBootstrapCallInfo, 1,                                  \
           "0: when resolving InDy or ConDy, force all BSM arguments to be " \
           "resolved before the bootstrap method is called; 1: when a BSM "  \
           "that may accept a BootstrapCallInfo is detected, use that API "  \
           "to pass BSM arguments, which allows the BSM to delay their "     \
diff a/src/hotspot/share/runtime/reflection.cpp b/src/hotspot/share/runtime/reflection.cpp
--- a/src/hotspot/share/runtime/reflection.cpp
+++ b/src/hotspot/share/runtime/reflection.cpp
@@ -715,11 +715,11 @@
 }
 
 // Checks that the 'outer' klass has declared 'inner' as being an inner klass. If not,
 // throw an incompatible class change exception
 // If inner_is_member, require the inner to be a member of the outer.
-// If !inner_is_member, require the inner to be unsafe anonymous (a non-member).
+// If !inner_is_member, require the inner to be hidden or unsafe anonymous (non-members).
 // Caller is responsible for figuring out in advance which case must be true.
 void Reflection::check_for_inner_class(const InstanceKlass* outer, const InstanceKlass* inner,
                                        bool inner_is_member, TRAPS) {
   InnerClassesIterator iter(outer);
   constantPoolHandle cp   (THREAD, outer->constants());
diff a/src/hotspot/share/runtime/safepoint.cpp b/src/hotspot/share/runtime/safepoint.cpp
--- a/src/hotspot/share/runtime/safepoint.cpp
+++ b/src/hotspot/share/runtime/safepoint.cpp
@@ -531,11 +531,11 @@
   uint _num_workers;
   DeflateMonitorCounters* _counters;
 public:
   ParallelSPCleanupTask(uint num_workers, DeflateMonitorCounters* counters) :
     AbstractGangTask("Parallel Safepoint Cleanup"),
-    _subtasks(SubTasksDone(SafepointSynchronize::SAFEPOINT_CLEANUP_NUM_TASKS)),
+    _subtasks(SafepointSynchronize::SAFEPOINT_CLEANUP_NUM_TASKS),
     _cleanup_threads_cl(ParallelSPCleanupThreadClosure(counters)),
     _num_workers(num_workers),
     _counters(counters) {}
 
   void work(uint worker_id) {
diff a/src/hotspot/share/runtime/sharedRuntime.cpp b/src/hotspot/share/runtime/sharedRuntime.cpp
--- a/src/hotspot/share/runtime/sharedRuntime.cpp
+++ b/src/hotspot/share/runtime/sharedRuntime.cpp
@@ -2138,67 +2138,45 @@
 
 JRT_LEAF(void, SharedRuntime::reguard_yellow_pages())
   (void) JavaThread::current()->reguard_stack();
 JRT_END
 
-
-// Handles the uncommon case in locking, i.e., contention or an inflated lock.
-JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* _obj, BasicLock* lock, JavaThread* thread))
+void SharedRuntime::monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {
   if (!SafepointSynchronize::is_synchronizing()) {
     // Only try quick_enter() if we're not trying to reach a safepoint
     // so that the calling thread reaches the safepoint more quickly.
-    if (ObjectSynchronizer::quick_enter(_obj, thread, lock)) return;
+    if (ObjectSynchronizer::quick_enter(obj, thread, lock)) return;
   }
   // NO_ASYNC required because an async exception on the state transition destructor
   // would leave you with the lock held and it would never be released.
   // The normal monitorenter NullPointerException is thrown without acquiring a lock
   // and the model is that an exception implies the method failed.
   JRT_BLOCK_NO_ASYNC
-  oop obj(_obj);
   if (PrintBiasedLockingStatistics) {
     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
   }
   Handle h_obj(THREAD, obj);
   ObjectSynchronizer::enter(h_obj, lock, CHECK);
   assert(!HAS_PENDING_EXCEPTION, "Should have no exception here");
   JRT_BLOCK_END
-JRT_END
+}
 
-// Handles the uncommon cases of monitor unlocking in compiled code
-JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* _obj, BasicLock* lock, JavaThread * THREAD))
-   oop obj(_obj);
-  assert(JavaThread::current() == THREAD, "invariant");
-  // I'm not convinced we need the code contained by MIGHT_HAVE_PENDING anymore
-  // testing was unable to ever fire the assert that guarded it so I have removed it.
-  assert(!HAS_PENDING_EXCEPTION, "Do we need code below anymore?");
-#undef MIGHT_HAVE_PENDING
-#ifdef MIGHT_HAVE_PENDING
-  // Save and restore any pending_exception around the exception mark.
-  // While the slow_exit must not throw an exception, we could come into
-  // this routine with one set.
-  oop pending_excep = NULL;
-  const char* pending_file;
-  int pending_line;
-  if (HAS_PENDING_EXCEPTION) {
-    pending_excep = PENDING_EXCEPTION;
-    pending_file  = THREAD->exception_file();
-    pending_line  = THREAD->exception_line();
-    CLEAR_PENDING_EXCEPTION;
-  }
-#endif /* MIGHT_HAVE_PENDING */
+// Handles the uncommon case in locking, i.e., contention or an inflated lock.
+JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))
+  SharedRuntime::monitor_enter_helper(obj, lock, thread);
+JRT_END
 
-  {
-    // Exit must be non-blocking, and therefore no exceptions can be thrown.
-    EXCEPTION_MARK;
-    ObjectSynchronizer::exit(obj, lock, THREAD);
-  }
+void SharedRuntime::monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {
+  assert(JavaThread::current() == thread, "invariant");
+  // Exit must be non-blocking, and therefore no exceptions can be thrown.
+  EXCEPTION_MARK;
+  ObjectSynchronizer::exit(obj, lock, THREAD);
+}
 
-#ifdef MIGHT_HAVE_PENDING
-  if (pending_excep != NULL) {
-    THREAD->set_pending_exception(pending_excep, pending_file, pending_line);
-  }
-#endif /* MIGHT_HAVE_PENDING */
+// Handles the uncommon cases of monitor unlocking in compiled code
+JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))
+  SharedRuntime::monitor_exit_helper(obj, lock, thread);
 JRT_END
 
 #ifndef PRODUCT
 
 void SharedRuntime::print_statistics() {
diff a/src/hotspot/share/runtime/sharedRuntime.hpp b/src/hotspot/share/runtime/sharedRuntime.hpp
--- a/src/hotspot/share/runtime/sharedRuntime.hpp
+++ b/src/hotspot/share/runtime/sharedRuntime.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -342,10 +342,13 @@
   static methodHandle handle_ic_miss_helper(JavaThread* thread, bool& is_optimized, bool& caller_is_c1, TRAPS);
 
   // Find the method that called us.
   static methodHandle find_callee_method(JavaThread* thread, TRAPS);
 
+  static void monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);
+
+  static void monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);
 
   static address entry_for_handle_wrong_method(methodHandle callee_method, bool is_static_call, bool is_optimized, bool caller_is_c1) {
     assert(callee_method->verified_code_entry() != NULL, "Jump to zero!");
     assert(callee_method->verified_value_code_entry() != NULL, "Jump to zero!");
     assert(callee_method->verified_value_ro_code_entry() != NULL, "Jump to zero!");
diff a/src/hotspot/share/runtime/thread.cpp b/src/hotspot/share/runtime/thread.cpp
--- a/src/hotspot/share/runtime/thread.cpp
+++ b/src/hotspot/share/runtime/thread.cpp
@@ -4430,10 +4430,20 @@
 
   before_exit(thread);
 
   thread->exit(true);
 
+  // We are no longer on the main thread list but could still be in a
+  // secondary list where another thread may try to interact with us.
+  // So wait until all such interactions are complete before we bring
+  // the VM to the termination safepoint. Normally this would be done
+  // using thread->smr_delete() below where we delete the thread, but
+  // we can't call that after the termination safepoint is active as
+  // we will deadlock on the Threads_lock. Once all interactions are
+  // complete it is safe to directly delete the thread at any time.
+  ThreadsSMRSupport::wait_until_not_protected(thread);
+
   // Stop VM thread.
   {
     // 4945125 The vm thread comes to a safepoint during exit.
     // GC vm_operations can get caught at the safepoint, and the
     // heap is unparseable if they are caught. Grab the Heap_lock
@@ -4469,25 +4479,13 @@
   notify_vm_shutdown();
 
   // exit_globals() will delete tty
   exit_globals();
 
-  // We are here after VM_Exit::set_vm_exited() so we can't call
-  // thread->smr_delete() or we will block on the Threads_lock. We
-  // must check that there are no active references to this thread
-  // before attempting to delete it. A thread could be waiting on
-  // _handshake_turn_sem trying to execute a direct handshake with
-  // this thread.
-  if (!ThreadsSMRSupport::is_a_protected_JavaThread(thread)) {
-    delete thread;
-  } else {
-    // Clear value for _thread_key in TLS to prevent, depending
-    // on pthreads implementation, possible execution of
-    // thread-specific destructor in infinite loop at thread
-    // exit.
-    Thread::clear_thread_current();
-  }
+  // Deleting the shutdown thread here is safe. See comment on
+  // wait_until_not_protected() above.
+  delete thread;
 
 #if INCLUDE_JVMCI
   if (JVMCICounterSize > 0) {
     FREE_C_HEAP_ARRAY(jlong, JavaThread::_jvmci_old_thread_counters);
   }
diff a/src/hotspot/share/runtime/vmOperations.hpp b/src/hotspot/share/runtime/vmOperations.hpp
--- a/src/hotspot/share/runtime/vmOperations.hpp
+++ b/src/hotspot/share/runtime/vmOperations.hpp
@@ -78,12 +78,10 @@
   template(PopulateDumpSharedSpace)               \
   template(JNIFunctionTableCopier)                \
   template(RedefineClasses)                       \
   template(UpdateForPopTopFrame)                  \
   template(SetFramePop)                           \
-  template(GetOwnedMonitorInfo)                   \
-  template(GetObjectMonitorUsage)                 \
   template(GetCurrentContendedMonitor)            \
   template(GetStackTrace)                         \
   template(GetMultipleStackTraces)                \
   template(GetAllStackTraces)                     \
   template(GetThreadListStackTraces)              \
diff a/src/hotspot/share/runtime/vmStructs.cpp b/src/hotspot/share/runtime/vmStructs.cpp
--- a/src/hotspot/share/runtime/vmStructs.cpp
+++ b/src/hotspot/share/runtime/vmStructs.cpp
@@ -515,10 +515,11 @@
   /* ClassLoaderData */                                                                                                              \
   /*******************/                                                                                                              \
   nonstatic_field(ClassLoaderData,             _class_loader,                                 OopHandle)                             \
   nonstatic_field(ClassLoaderData,             _next,                                         ClassLoaderData*)                      \
   volatile_nonstatic_field(ClassLoaderData,    _klasses,                                      Klass*)                                \
+  nonstatic_field(ClassLoaderData,             _has_class_mirror_holder,                      bool)                                  \
   volatile_nonstatic_field(ClassLoaderData,    _dictionary,                                   Dictionary*)                           \
                                                                                                                                      \
   static_ptr_volatile_field(ClassLoaderDataGraph, _head,                                      ClassLoaderData*)                      \
                                                                                                                                      \
   /**********/                                                                                                                       \
@@ -1580,11 +1581,10 @@
   declare_c2_type(DecodeNNode, TypeNode)                                  \
   declare_c2_type(EncodePKlassNode, TypeNode)                             \
   declare_c2_type(DecodeNKlassNode, TypeNode)                             \
   declare_c2_type(ConstraintCastNode, TypeNode)                           \
   declare_c2_type(CastIINode, ConstraintCastNode)                         \
-  declare_c2_type(CastLLNode, ConstraintCastNode)                         \
   declare_c2_type(CastPPNode, ConstraintCastNode)                         \
   declare_c2_type(CheckCastPPNode, TypeNode)                              \
   declare_c2_type(Conv2BNode, Node)                                       \
   declare_c2_type(ConvD2FNode, Node)                                      \
   declare_c2_type(ConvD2INode, Node)                                      \
diff a/src/hotspot/share/utilities/accessFlags.hpp b/src/hotspot/share/utilities/accessFlags.hpp
--- a/src/hotspot/share/utilities/accessFlags.hpp
+++ b/src/hotspot/share/utilities/accessFlags.hpp
@@ -64,10 +64,11 @@
   JVM_ACC_HAS_VANILLA_CONSTRUCTOR = 0x20000000,     // True if klass has a vanilla default constructor
   JVM_ACC_HAS_FINALIZER           = 0x40000000,     // True if klass has a non-empty finalize() method
   JVM_ACC_IS_CLONEABLE_FAST       = (int)0x80000000,// True if klass implements the Cloneable interface and can be optimized in generated code
   JVM_ACC_HAS_FINAL_METHOD        = 0x01000000,     // True if klass has final method
   JVM_ACC_IS_SHARED_CLASS         = 0x02000000,     // True if klass is shared
+  JVM_ACC_IS_HIDDEN_CLASS         = 0x04000000,     // True if klass is hidden
 
   // Klass* and Method* flags
   JVM_ACC_HAS_LOCAL_VARIABLE_TABLE= 0x00200000,
 
   JVM_ACC_PROMOTED_FLAGS          = 0x00200000,     // flags promoted from methods to the holding klass
@@ -154,10 +155,11 @@
   bool has_vanilla_constructor () const { return (_flags & JVM_ACC_HAS_VANILLA_CONSTRUCTOR) != 0; }
   bool has_finalizer           () const { return (_flags & JVM_ACC_HAS_FINALIZER          ) != 0; }
   bool has_final_method        () const { return (_flags & JVM_ACC_HAS_FINAL_METHOD       ) != 0; }
   bool is_cloneable_fast       () const { return (_flags & JVM_ACC_IS_CLONEABLE_FAST      ) != 0; }
   bool is_shared_class         () const { return (_flags & JVM_ACC_IS_SHARED_CLASS        ) != 0; }
+  bool is_hidden_class         () const { return (_flags & JVM_ACC_IS_HIDDEN_CLASS        ) != 0; }
 
   // Klass* and Method* flags
   bool has_localvariable_table () const { return (_flags & JVM_ACC_HAS_LOCAL_VARIABLE_TABLE) != 0; }
   void set_has_localvariable_table()    { atomic_set_bits(JVM_ACC_HAS_LOCAL_VARIABLE_TABLE); }
   void clear_has_localvariable_table()  { atomic_clear_bits(JVM_ACC_HAS_LOCAL_VARIABLE_TABLE); }
@@ -227,10 +229,11 @@
   void set_has_finalizer()             { atomic_set_bits(JVM_ACC_HAS_FINALIZER);           }
   void set_has_final_method()          { atomic_set_bits(JVM_ACC_HAS_FINAL_METHOD);        }
   void set_is_cloneable_fast()         { atomic_set_bits(JVM_ACC_IS_CLONEABLE_FAST);       }
   void set_has_miranda_methods()       { atomic_set_bits(JVM_ACC_HAS_MIRANDA_METHODS);     }
   void set_is_shared_class()           { atomic_set_bits(JVM_ACC_IS_SHARED_CLASS);         }
+  void set_is_hidden_class()           { atomic_set_bits(JVM_ACC_IS_HIDDEN_CLASS);         }
 
  public:
   // field flags
   void set_is_field_access_watched(const bool value)
                                        {
diff a/src/hotspot/share/utilities/exceptions.hpp b/src/hotspot/share/utilities/exceptions.hpp
--- a/src/hotspot/share/utilities/exceptions.hpp
+++ b/src/hotspot/share/utilities/exceptions.hpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -168,11 +168,11 @@
                               const char* message,
                               ExceptionMsgToUtf8Mode to_utf8_safe = safe_to_utf8);
 
   static void throw_stack_overflow_exception(Thread* thread, const char* file, int line, const methodHandle& method);
 
-  static void wrap_dynamic_exception(Thread* thread);
+  static void wrap_dynamic_exception(bool is_indy, Thread* thread);
 
   // Exception counting for error files of interesting exceptions that may have
   // caused a problem for the jvm
   static volatile int _stack_overflow_errors;
 
diff a/src/java.base/share/classes/java/lang/Class.java b/src/java.base/share/classes/java/lang/Class.java
--- a/src/java.base/share/classes/java/lang/Class.java
+++ b/src/java.base/share/classes/java/lang/Class.java
@@ -26,10 +26,11 @@
 package java.lang;
 
 import java.lang.annotation.Annotation;
 import java.lang.constant.ClassDesc;
 import java.lang.invoke.TypeDescriptor;
+import java.lang.invoke.MethodHandles;
 import java.lang.module.ModuleReader;
 import java.lang.ref.SoftReference;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectStreamField;
@@ -96,20 +97,46 @@
  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  * int}, {@code long}, {@code float}, and {@code double}), and the
  * keyword {@code void} are also represented as {@code Class} objects.
  *
  * <p> {@code Class} has no public constructor. Instead a {@code Class}
- * object is constructed automatically by the Java Virtual Machine
- * when a class loader invokes one of the
- * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods
- * and passes the bytes of a {@code class} file.
+ * object is constructed automatically by the Java Virtual Machine when
+ * a class is derived from the bytes of a {@code class} file through
+ * the invocation of one of the following methods:
+ * <ul>
+ * <li> {@link ClassLoader#defineClass(String, byte[], int, int) ClassLoader::defineClass}
+ * <li> {@link java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])
+ *      java.lang.invoke.MethodHandles.Lookup::defineClass}
+ * <li> {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
+ *      java.lang.invoke.MethodHandles.Lookup::defineHiddenClass}
+ * </ul>
  *
  * <p> The methods of class {@code Class} expose many characteristics of a
  * class or interface. Most characteristics are derived from the {@code class}
- * file that the class loader passed to the Java Virtual Machine. A few
- * characteristics are determined by the class loading environment at run time,
- * such as the module returned by {@link #getModule() getModule()}.
+ * file that the class loader passed to the Java Virtual Machine or
+ * from the {@code class} file passed to {@code Lookup::defineClass}
+ * or {@code Lookup::defineHiddenClass}.
+ * A few characteristics are determined by the class loading environment
+ * at run time, such as the module returned by {@link #getModule() getModule()}.
+ *
+ * <p> The following example uses a {@code Class} object to print the
+ * class name of an object:
+ *
+ * <blockquote><pre>
+ *     void printClassName(Object obj) {
+ *         System.out.println("The class of " + obj +
+ *                            " is " + obj.getClass().getName());
+ *     }
+ * </pre></blockquote>
+ *
+ * It is also possible to get the {@code Class} object for a named
+ * type (or for {@code void}) using a <i>class literal</i>.
+ * For example:
+ *
+ * <blockquote>
+ *     {@code System.out.println("The name of class Foo is: "+Foo.class.getName());}
+ * </blockquote>
  *
  * <p> Some methods of class {@code Class} expose whether the declaration of
  * a class or interface in Java source code was <em>enclosed</em> within
  * another declaration. Other methods describe how a class or interface
  * is situated in a <em>nest</em>. A <a id="nest">nest</a> is a set of
@@ -124,37 +151,47 @@
  * {@code class} files are generated, for example, a Java compiler
  * will typically record a top-level class as the host of a nest where the
  * other members are the classes and interfaces whose declarations are
  * enclosed within the top-level class declaration.
  *
- * <p> The following example uses a {@code Class} object to print the
- * class name of an object:
- *
- * <blockquote><pre>
- *     void printClassName(Object obj) {
- *         System.out.println("The class of " + obj +
- *                            " is " + obj.getClass().getName());
- *     }
- * </pre></blockquote>
+ * <p> A class or interface created by the invocation of
+ * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
+ * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() <em>hidden</em>}
+ * class or interface.
+ * All kinds of class, including enum types and record types, may be
+ * hidden classes; all kinds of interface, including annotation types,
+ * may be hidden interfaces.
  *
- * <p> It is also possible to get the {@code Class} object for a named
- * type (or for void) using a class literal.  See Section {@jls
- * 15.8.2} of <cite>The Java&trade; Language Specification</cite>.
- * For example:
+ * The {@linkplain #getName() name of a hidden class or interface} is
+ * not a <a href="ClassLoader.html#binary-name">binary name</a>,
+ * which means the following:
+ * <ul>
+ * <li>A hidden class or interface cannot be referenced by the constant pools
+ *     of other classes and interfaces.
+ * <li>A hidden class or interface cannot be described in
+ *     {@linkplain java.lang.constant.ConstantDesc <em>nominal form</em>} by
+ *     {@link #describeConstable() Class::describeConstable},
+ *     {@link ClassDesc#of(String) ClassDesc::of}, or
+ *     {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}.
+ * <li>A hidden class or interface cannot be discovered by {@link #forName Class::forName}
+ *     or {@link ClassLoader#loadClass(String, boolean) ClassLoader::loadClass}.
+ * </ul>
  *
- * <blockquote>
- *     {@code System.out.println("The name of class Foo is: " + Foo.class.getName());}
- * </blockquote>
+ * A hidden class or interface is never an array class, but may be
+ * the element type of an array. In all other respects, the fact that
+ * a class or interface is hidden has no bearing on the characteristics
+ * exposed by the methods of class {@code Class}.
  *
  * @param <T> the type of the class modeled by this {@code Class}
  * object.  For example, the type of {@code String.class} is {@code
  * Class<String>}.  Use {@code Class<?>} if the class being modeled is
  * unknown.
  *
  * @author  unascribed
  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
  * @since   1.0
+ * @jls 15.8.2 Class Literals
  */
 public final class Class<T> implements java.io.Serializable,
                               GenericDeclaration,
                               Type,
                               AnnotatedElement,
@@ -183,13 +220,13 @@
     }
 
     /**
      * Converts the object to a string. The string representation is the
      * string "class" or "interface", followed by a space, and then by the
-     * fully qualified name of the class in the format returned by
-     * {@code getName}.  If this {@code Class} object represents a
-     * primitive type, this method returns the name of the primitive type.  If
+     * name of the class in the format returned by {@code getName}.
+     * If this {@code Class} object represents a primitive type,
+     * this method returns the name of the primitive type.  If
      * this {@code Class} object represents void this method returns
      * "void". If this {@code Class} object represents an array type,
      * this method returns "class " followed by {@code getName}.
      *
      * @return a string representation of this {@code Class} object.
@@ -794,63 +831,69 @@
     public boolean isAnnotation() {
         return (getModifiers() & ANNOTATION) != 0;
     }
 
     /**
-     * Returns {@code true} if this class is a synthetic class;
-     * returns {@code false} otherwise.
-     * @return {@code true} if and only if this class is a synthetic class as
-     *         defined by <cite>The Java&trade; Language Specification</cite>.
+     * Returns {@code true} if and only if this class has the synthetic modifier
+     * bit set.
+     *
+     * @return {@code true} if and only if this class has the synthetic modifier bit set
      * @jls 13.1 The Form of a Binary
+     * @jvms 4.1 The {@code ClassFile} Structure
      * @since 1.5
      */
     public boolean isSynthetic() {
         return (getModifiers() & SYNTHETIC) != 0;
     }
 
     /**
      * Returns the  name of the entity (class, interface, array class,
-     * primitive type, or void) represented by this {@code Class} object,
-     * as a {@code String}.
-     *
-     * <p> If this {@code Class} object represents a reference type that is
-     * not an array type then the binary name of the class is
-     * returned, as specified by <cite>The Java&trade; Language
-     * Specification</cite>.
+     * primitive type, or void) represented by this {@code Class} object.
      *
-     * <p> If this {@code Class} object represents a primitive type or void, then the
-     * name returned is a {@code String} equal to the Java language
-     * keyword corresponding to the primitive type or void.
+     * <p> If this {@code Class} object represents a class or interface,
+     * not an array class, then:
+     * <ul>
+     * <li> If the class or interface is not {@linkplain #isHidden() hidden},
+     *      then the <a href="ClassLoader.html#binary-name">binary name</a>
+     *      of the class or interface is returned.
+     * <li> If the class or interface is hidden, then the result is a string
+     *      of the form: {@code N + '/' + <suffix>}
+     *      where {@code N} is the <a href="ClassLoader.html#binary-name">binary name</a>
+     *      indicated by the {@code class} file passed to
+     *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
+     *      Lookup::defineHiddenClass}, and {@code <suffix>} is an unqualified name.
+     * </ul>
      *
-     * <p> If this {@code Class} object represents a class of arrays, then the internal
-     * form of the name consists of the name of the element type preceded by
-     * one or more '{@code [}' characters representing the depth of the array
-     * nesting.  The encoding of element type names is as follows:
+     * <p> If this {@code Class} object represents an array class, then
+     * the result is a string consisting of one or more '{@code [}' characters
+     * representing the depth of the array nesting, followed by the element
+     * type as encoded using the following table:
      *
      * <blockquote><table class="striped">
      * <caption style="display:none">Element types and encodings</caption>
      * <thead>
      * <tr><th scope="col"> Element Type <th scope="col"> Encoding
      * </thead>
      * <tbody style="text-align:left">
-     * <tr><th scope="row"> boolean      <td style="text-align:center"> Z
-     * <tr><th scope="row"> byte         <td style="text-align:center"> B
-     * <tr><th scope="row"> char         <td style="text-align:center"> C
-     * <tr><th scope="row"> class or interface
-     *                                   <td style="text-align:center"> L<i>classname</i>;
-     * <tr><th scope="row"> {@linkplain #isInlineClass() inline class}
-     *                                   <td style="text-align:center"> Q<i>classname</i>;
-     * <tr><th scope="row"> double       <td style="text-align:center"> D
-     * <tr><th scope="row"> float        <td style="text-align:center"> F
-     * <tr><th scope="row"> int          <td style="text-align:center"> I
-     * <tr><th scope="row"> long         <td style="text-align:center"> J
-     * <tr><th scope="row"> short        <td style="text-align:center"> S
+     * <tr><th scope="row"> {@code boolean} <td style="text-align:center"> {@code Z}
+     * <tr><th scope="row"> {@code byte}    <td style="text-align:center"> {@code B}
+     * <tr><th scope="row"> {@code char}    <td style="text-align:center"> {@code C}
+     * <tr><th scope="row"> class or interface with <a href="ClassLoader.html#binary-name">binary name</a> <i>N</i>
+     *                                      <td style="text-align:center"> {@code L}<em>N</em>{@code ;}
+     * <tr><th scope="row"> {@linkplain #isInlineClass() inline class} with <a href="ClassLoader.html#binary-name">binary name</a> <i>N</i>
+     *                                      <td style="text-align:center"> {@code Q}<em>N</em>{@code ;}
+     * <tr><th scope="row"> {@code double}  <td style="text-align:center"> {@code D}
+     * <tr><th scope="row"> {@code float}   <td style="text-align:center"> {@code F}
+     * <tr><th scope="row"> {@code int}     <td style="text-align:center"> {@code I}
+     * <tr><th scope="row"> {@code long}    <td style="text-align:center"> {@code J}
+     * <tr><th scope="row"> {@code short}   <td style="text-align:center"> {@code S}
      * </tbody>
      * </table></blockquote>
      *
-     * <p> The class or interface name <i>classname</i> is the binary name of
-     * the class specified above.
+     * <p> If this {@code Class} object represents a primitive type or {@code void},
+     * then the result is a string with the same spelling as the Java language
+     * keyword which corresponds to the primitive type or {@code void}.
      *
      * <p> Examples:
      * <blockquote><pre>
      * String.class.getName()
      *     returns "java.lang.String"
@@ -866,12 +909,13 @@
      *     returns "[[LPoint$ref;"
      * (new int[3][4][5][6][7][8][9]).getClass().getName()
      *     returns "[[[[[[[I"
      * </pre></blockquote>
      *
-     * @return  the name of the class or interface
+     * @return  the name of the class, interface, or other entity
      *          represented by this {@code Class} object.
+     * @jls 13.1 The Form of a Binary
      */
     public String getName() {
         String name = this.name;
         return name != null ? name : initClassName();
     }
@@ -945,10 +989,18 @@
     // Initialized in JVM not by private constructor
     // This field is filtered from reflection access, i.e. getDeclaredField
     // will throw NoSuchFieldException
     private final ClassLoader classLoader;
 
+    // Set by VM
+    private transient Object classData;
+
+    // package-private
+    Object getClassData() {
+        return classData;
+    }
+
     /**
      * Returns an array of {@code TypeVariable} objects that represent the
      * type variables declared by the generic declaration represented by this
      * {@code GenericDeclaration} object, in declaration order.  Returns an
      * array of length 0 if the underlying generic declaration declares no type
@@ -957,11 +1009,11 @@
      * @return an array of {@code TypeVariable} objects that represent
      *     the type variables declared by this generic declaration
      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
      *     signature of this generic declaration does not conform to
      *     the format specified in section {@jvms 4.7.9} of
-     *     <cite>The Java&trade; Virtual Machine Specification</cite>,
+     *     <cite>The Java&trade; Virtual Machine Specification</cite>
      * @since 1.5
      */
     @SuppressWarnings("unchecked")
     public TypeVariable<Class<T>>[] getTypeParameters() {
         ClassRepository info = getGenericInfo();
@@ -1080,14 +1132,11 @@
      * @jls 6.7 Fully Qualified Names
      */
     public String getPackageName() {
         String pn = this.packageName;
         if (pn == null) {
-            Class<?> c = this;
-            while (c.isArray()) {
-                c = c.getComponentType();
-            }
+            Class<?> c = isArray() ? elementType() : this;
             if (c.isPrimitive()) {
                 pn = "java.lang";
             } else {
                 String cn = c.getName();
                 int dot = cn.lastIndexOf('.');
@@ -1241,10 +1290,24 @@
         }
     }
 
     private final Class<?> componentType;
 
+    /*
+     * Returns the {@code Class} representing the element type of an array class.
+     * If this class does not represent an array class, then this method returns
+     * {@code null}.
+     */
+    private Class<?> elementType() {
+        if (!isArray()) return null;
+
+        Class<?> c = this;
+        while (c.isArray()) {
+            c = c.getComponentType();
+        }
+        return c;
+    }
 
     /**
      * Returns the Java language modifiers for this class or interface, encoded
      * in an integer. The modifiers consist of the Java Virtual Machine's
      * constants for {@code public}, {@code protected},
@@ -1669,15 +1732,21 @@
         }
         return getName();
     }
 
     /**
-     * Returns the canonical name of the underlying class as defined
-     * by <cite>The Java&trade; Language Specification</cite>, section
-     * {@jls 6.7}.  Returns null if the underlying class does not have
-     * a canonical name (i.e., if it is a local or anonymous class or
-     * an array whose component type does not have a canonical name).
+     * Returns the canonical name of the underlying class as
+     * defined by <cite>The Java&trade; Language Specification</cite>.
+     * Returns {@code null} if the underlying class does not have a canonical
+     * name. Classes without canonical names include:
+     * <ul>
+     * <li>a {@linkplain #isLocalClass() local class}
+     * <li>a {@linkplain #isAnonymousClass() anonymous class}
+     * <li>a {@linkplain #isHidden() hidden class}
+     * <li>an array whose component type does not have a canonical name</li>
+     * </ul>
+     *
      * @return the canonical name of the underlying class if it exists, and
      * {@code null} otherwise.
      * @since 1.5
      */
     public String getCanonicalName() {
@@ -1695,11 +1764,11 @@
             if (canonicalName != null)
                 return canonicalName + "[]";
             else
                 return ReflectionData.NULL_SENTINEL;
         }
-        if (isLocalOrAnonymousClass())
+        if (isHidden() || isLocalOrAnonymousClass())
             return ReflectionData.NULL_SENTINEL;
         Class<?> enclosingClass = getEnclosingClass();
         if (enclosingClass == null) { // top level class
             return getName();
         } else {
@@ -1712,10 +1781,13 @@
 
     /**
      * Returns {@code true} if and only if the underlying class
      * is an anonymous class.
      *
+     * @apiNote
+     * An anonymous class is not a {@linkplain #isHidden() hidden class}.
+     *
      * @return {@code true} if and only if this class is an anonymous class.
      * @since 1.5
      */
     public boolean isAnonymousClass() {
         return !isArray() && isLocalOrAnonymousClass() &&
@@ -2937,10 +3009,15 @@
     public java.security.ProtectionDomain getProtectionDomain() {
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
         }
+        return protectionDomain();
+    }
+
+    // package-private
+    java.security.ProtectionDomain protectionDomain() {
         java.security.ProtectionDomain pd = getProtectionDomain0();
         if (pd == null) {
             if (allPermDomain == null) {
                 java.security.Permissions perms =
                     new java.security.Permissions();
@@ -2951,11 +3028,10 @@
             pd = allPermDomain;
         }
         return pd;
     }
 
-
     /**
      * Returns the ProtectionDomain of this class.
      */
     private native java.security.ProtectionDomain getProtectionDomain0();
 
@@ -3023,14 +3099,11 @@
      * Add a package name prefix if the name is not absolute Remove leading "/"
      * if name is absolute
      */
     private String resolveName(String name) {
         if (!name.startsWith("/")) {
-            Class<?> c = this;
-            while (c.isArray()) {
-                c = c.getComponentType();
-            }
+            Class<?> c = isArray() ? elementType() : this;
             String baseName = c.getPackageName();
             if (baseName != null && !baseName.isEmpty()) {
                 name = baseName.replace('.', '/') + "/" + name;
             }
         } else {
@@ -4102,33 +4175,26 @@
     private native Class<?> getNestHost0();
 
     /**
      * Returns the nest host of the <a href=#nest>nest</a> to which the class
      * or interface represented by this {@code Class} object belongs.
-     * Every class and interface is a member of exactly one nest.
-     * A class or interface that is not recorded as belonging to a nest
-     * belongs to the nest consisting only of itself, and is the nest
-     * host.
-     *
-     * <p>Each of the {@code Class} objects representing array types,
-     * primitive types, and {@code void} returns {@code this} to indicate
-     * that the represented entity belongs to the nest consisting only of
-     * itself, and is the nest host.
+     * Every class and interface belongs to exactly one nest.
      *
-     * <p>If there is a {@linkplain LinkageError linkage error} accessing
-     * the nest host, or if this class or interface is not enumerated as
-     * a member of the nest by the nest host, then it is considered to belong
-     * to its own nest and {@code this} is returned as the host.
+     * If the nest host of this class or interface has previously
+     * been determined, then this method returns the nest host.
+     * If the nest host of this class or interface has
+     * not previously been determined, then this method determines the nest
+     * host using the algorithm of JVMS 5.4.4, and returns it.
      *
-     * @apiNote A {@code class} file of version 55.0 or greater may record the
-     * host of the nest to which it belongs by using the {@code NestHost}
-     * attribute (JVMS {@jvms 4.7.28}). Alternatively, a {@code class} file of
-     * version 55.0 or greater may act as a nest host by enumerating the nest's
-     * other members with the
-     * {@code NestMembers} attribute (JVMS {@jvms 4.7.29}).
-     * A {@code class} file of version 54.0 or lower does not use these
-     * attributes.
+     * Often, a class or interface belongs to a nest consisting only of itself,
+     * in which case this method returns {@code this} to indicate that the class
+     * or interface is the nest host.
+     *
+     * <p>If this {@code Class} object represents a primitive type, an array type,
+     * or {@code void}, then this method returns {@code this},
+     * indicating that the represented entity belongs to the nest consisting only of
+     * itself, and is the nest host.
      *
      * @return the nest host of this class or interface
      *
      * @throws SecurityException
      *         If the returned class is not the current class, and
@@ -4145,21 +4211,13 @@
     @CallerSensitive
     public Class<?> getNestHost() {
         if (isPrimitive() || isArray()) {
             return this;
         }
-        Class<?> host;
-        try {
-            host = getNestHost0();
-        } catch (LinkageError e) {
-            // if we couldn't load our nest-host then we
-            // act as-if we have no nest-host attribute
-            return this;
-        }
-        // if null then nest membership validation failed, so we
-        // act as-if we have no nest-host attribute
-        if (host == null || host == this) {
+
+        Class<?> host = getNestHost0();
+        if (host == this) {
             return this;
         }
         // returning a different class requires a security check
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) {
@@ -4187,56 +4245,61 @@
         }
         if (isPrimitive() || isArray() ||
             c.isPrimitive() || c.isArray()) {
             return false;
         }
-        try {
-            return getNestHost0() == c.getNestHost0();
-        } catch (LinkageError e) {
-            return false;
-        }
+
+        return getNestHost() == c.getNestHost();
     }
 
     private native Class<?>[] getNestMembers0();
 
     /**
      * Returns an array containing {@code Class} objects representing all the
      * classes and interfaces that are members of the nest to which the class
      * or interface represented by this {@code Class} object belongs.
-     * The {@linkplain #getNestHost() nest host} of that nest is the zeroth
-     * element of the array. Subsequent elements represent any classes or
-     * interfaces that are recorded by the nest host as being members of
-     * the nest; the order of such elements is unspecified. Duplicates are
-     * permitted.
-     * If the nest host of that nest does not enumerate any members, then the
-     * array has a single element containing {@code this}.
-     *
-     * <p>Each of the {@code Class} objects representing array types,
-     * primitive types, and {@code void} returns an array containing only
+     *
+     * First, this method obtains the {@linkplain #getNestHost() nest host},
+     * {@code H}, of the nest to which the class or interface represented by
+     * this {@code Class} object belongs. The zeroth element of the returned
+     * array is {@code H}.
+     *
+     * Then, for each class or interface {@code C} which is recorded by {@code H}
+     * as being a member of its nest, this method attempts to obtain the {@code Class}
+     * object for {@code C} (using {@linkplain #getClassLoader() the defining class
+     * loader} of the current {@code Class} object), and then obtains the
+     * {@linkplain #getNestHost() nest host} of the nest to which {@code C} belongs.
+     * The classes and interfaces which are recorded by {@code H} as being members
+     * of its nest, and for which {@code H} can be determined as their nest host,
+     * are indicated by subsequent elements of the returned array. The order of
+     * such elements is unspecified. Duplicates are permitted.
+     *
+     * <p>If this {@code Class} object represents a primitive type, an array type,
+     * or {@code void}, then this method returns a single-element array containing
      * {@code this}.
      *
-     * <p>This method validates that, for each class or interface which is
-     * recorded as a member of the nest by the nest host, that class or
-     * interface records itself as a member of that same nest. Any exceptions
-     * that occur during this validation are rethrown by this method.
+     * @apiNote
+     * The returned array includes only the nest members recorded in the {@code NestMembers}
+     * attribute, and not any hidden classes that were added to the nest via
+     * {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
+     * Lookup::defineHiddenClass}.
      *
      * @return an array of all classes and interfaces in the same nest as
-     * this class
+     * this class or interface
      *
-     * @throws LinkageError
-     *         If there is any problem loading or validating a nest member or
-     *         its nest host
-     * @throws SecurityException
-     *         If any returned class is not the current class, and
-     *         if a security manager, <i>s</i>, is present and the caller's
-     *         class loader is not the same as or an ancestor of the class
-     *         loader for that returned class and invocation of {@link
-     *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
+     * @throws SecurityException
+     * If any returned class is not the current class, and
+     * if a security manager, <i>s</i>, is present and the caller's
+     * class loader is not the same as or an ancestor of the class
+     * loader for that returned class and invocation of {@link
+     * SecurityManager#checkPackageAccess s.checkPackageAccess()}
      *         denies access to the package of that returned class
      *
      * @since 11
      * @see #getNestHost()
+     * @jvms 4.7.28 The {@code NestHost} Attribute
+     * @jvms 4.7.29 The {@code NestMembers} Attribute
      */
     @CallerSensitive
     public Class<?>[] getNestMembers() {
         if (isPrimitive() || isArray()) {
             return new Class<?>[] { this };
@@ -4256,30 +4319,80 @@
         }
         return members;
     }
 
     /**
-     * Returns the type descriptor string for this class.
-     * <p>
-     * Note that this is not a strict inverse of {@link #forName};
+     * Returns the descriptor string of the entity (class, interface, array class,
+     * primitive type, or {@code void}) represented by this {@code Class} object.
+     *
+     * <p> If this {@code Class} object represents a class or interface,
+     * not an array class, then:
+     * <ul>
+     * <li> If the class or interface is not {@linkplain Class#isHidden() hidden},
+     *      then the result is a field descriptor (JVMS {@jvms 4.3.2})
+     *      for the class or interface. Calling
+     *      {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}
+     *      with the result descriptor string produces a {@link ClassDesc ClassDesc}
+     *      describing this class or interface.
+     * <li> If the class or interface is {@linkplain Class#isHidden() hidden},
+     *      then the result is a string of the form:
+     *      <blockquote>
+     *      {@code "L" +} <em>N</em> {@code + "." + <suffix> + ";"}
+     *      </blockquote>
+     *      where <em>N</em> is the <a href="ClassLoader.html#binary-name">binary name</a>
+     *      encoded in internal form indicated by the {@code class} file passed to
+     *      {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)
+     *      Lookup::defineHiddenClass}, and {@code <suffix>} is an unqualified name.
+     *      A hidden class or interface has no {@linkplain ClassDesc nominal descriptor}.
+     *      The result string is not a type descriptor.
+     * </ul>
+     *
+     * <p> If this {@code Class} object represents an array class, then
+     * the result is a string consisting of one or more '{@code [}' characters
+     * representing the depth of the array nesting, followed by the
+     * descriptor string of the element type.
+     * <ul>
+     * <li> If the element type is not a {@linkplain Class#isHidden() hidden} class
+     * or interface, then this array class can be described nominally.
+     * Calling {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}
+     * with the result descriptor string produces a {@link ClassDesc ClassDesc}
+     * describing this array class.
+     * <li> If the element type is a {@linkplain Class#isHidden() hidden} class or
+     * interface, then this array class cannot be described nominally.
+     * The result string is not a type descriptor.
+     * </ul>
+     *
+     * <p> If this {@code Class} object represents a primitive type or
+     * {@code void}, then the result is a field descriptor string which
+     * is a one-letter code corresponding to a primitive type or {@code void}
+     * ({@code "B", "C", "D", "F", "I", "J", "S", "Z", "V"}) (JVMS {@jvms 4.3.2}).
+     *
+     * @apiNote
+     * This is not a strict inverse of {@link #forName};
      * distinct classes which share a common name but have different class loaders
      * will have identical descriptor strings.
      *
-     * @return the type descriptor representation
+     * @return the descriptor string for this {@code Class} object
      * @jvms 4.3.2 Field Descriptors
      * @since 12
      */
     @Override
     public String descriptorString() {
         if (isPrimitive())
             return Wrapper.forPrimitiveType(this).basicTypeString();
-        else if (isArray()) {
+
+        if (isArray()) {
             return "[" + componentType.descriptorString();
         }
-        else {
-            return (isInlineClass() ? "Q" : "L")
-                    + getName().replace('.', '/') + ";";
+        String typeDesc = isInlineClass() ? "Q" : "L";
+        if (isHidden()) {
+            String name = getName();
+            int index = name.indexOf('/');
+            return typeDesc + name.substring(0, index).replace('.', '/')
+                       + "." + name.substring(index+1) + ";";
+        } else {
+            return typeDesc + getName().replace('.', '/') + ";";
         }
     }
 
     /**
      * Returns the component type of this {@code Class}, if it describes
@@ -4317,8 +4430,22 @@
      * or an empty {@link Optional} if one cannot be constructed.
      * @since 12
      */
     @Override
     public Optional<ClassDesc> describeConstable() {
-        return Optional.of(ClassDesc.ofDescriptor(descriptorString()));
-    }
+        Class<?> c = isArray() ? elementType() : this;
+        return c.isHidden() ? Optional.empty()
+                            : Optional.of(ClassDesc.ofDescriptor(descriptorString()));
+   }
+
+    /**
+     * Returns {@code true} if and only if the underlying class is a hidden class.
+     *
+     * @return {@code true} if and only if this class is a hidden class.
+     *
+     * @since 15
+     * @see MethodHandles.Lookup#defineHiddenClass
+     */
+    @HotSpotIntrinsicCandidate
+    public native boolean isHidden();
+
 }
diff a/src/java.base/share/classes/java/lang/System.java b/src/java.base/share/classes/java/lang/System.java
--- a/src/java.base/share/classes/java/lang/System.java
+++ b/src/java.base/share/classes/java/lang/System.java
@@ -33,10 +33,12 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.PrintStream;
 import java.io.UnsupportedEncodingException;
 import java.lang.annotation.Annotation;
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodType;
 import java.lang.module.ModuleDescriptor;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Executable;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
@@ -2173,10 +2175,14 @@
                 return cl.createOrGetClassLoaderValueMap();
             }
             public Class<?> defineClass(ClassLoader loader, String name, byte[] b, ProtectionDomain pd, String source) {
                 return ClassLoader.defineClass1(loader, name, b, 0, b.length, pd, source);
             }
+            public Class<?> defineClass(ClassLoader loader, Class<?> lookup, String name, byte[] b, ProtectionDomain pd,
+                                        boolean initialize, int flags, Object classData) {
+                return ClassLoader.defineClass0(loader, lookup, name, b, 0, b.length, pd, initialize, flags, classData);
+            }
             public Class<?> findBootstrapClassOrNull(ClassLoader cl, String name) {
                 return cl.findBootstrapClassOrNull(name);
             }
             public Package definePackage(ClassLoader cl, String name, Module module) {
                 return cl.definePackage(name, module);
@@ -2254,8 +2260,20 @@
                 return StringCoding.getBytesUTF8NoRepl(s);
             }
             public void setCause(Throwable t, Throwable cause) {
                 t.setCause(cause);
             }
+
+            public ProtectionDomain protectionDomain(Class<?> c) {
+                return c.protectionDomain();
+            }
+
+            public MethodHandle stringConcatHelper(String name, MethodType methodType) {
+                return StringConcatHelper.lookupStatic(name, methodType);
+            }
+
+            public Object classData(Class<?> c) {
+                return c.getClassData();
+            }
         });
     }
 }
diff a/src/java.base/share/classes/java/lang/invoke/GenerateJLIClassesHelper.java b/src/java.base/share/classes/java/lang/invoke/GenerateJLIClassesHelper.java
--- a/src/java.base/share/classes/java/lang/invoke/GenerateJLIClassesHelper.java
+++ b/src/java.base/share/classes/java/lang/invoke/GenerateJLIClassesHelper.java
@@ -194,27 +194,23 @@
      * a class with a specified name.
      */
     private static byte[] generateCodeBytesForLFs(String className,
             String[] names, LambdaForm[] forms) {
 
+
         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
         cw.visit(Opcodes.V1_8, Opcodes.ACC_PRIVATE + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
                 className, null, InvokerBytecodeGenerator.INVOKER_SUPER_NAME, null);
         cw.visitSource(className.substring(className.lastIndexOf('/') + 1), null);
 
         for (int i = 0; i < forms.length; i++) {
-            addMethod(className, names[i], forms[i],
-                    forms[i].methodType(), cw);
+            InvokerBytecodeGenerator g
+                = new InvokerBytecodeGenerator(className, names[i], forms[i], forms[i].methodType());
+            g.setClassWriter(cw);
+            g.addMethod();
         }
-        return cw.toByteArray();
-    }
-
-    private static void addMethod(String className, String methodName, LambdaForm form,
-            MethodType type, ClassWriter cw) {
-        InvokerBytecodeGenerator g
-                = new InvokerBytecodeGenerator(className, methodName, form, type);
-        g.setClassWriter(cw);
+
         g.addMethod();
     }
 
     private static LambdaForm makeReinvokerFor(MethodType type) {
         MethodHandle emptyHandle = MethodHandles.empty(type);
diff a/src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java b/src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java
--- a/src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java
+++ b/src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java
@@ -27,63 +27,65 @@
 
 import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
 import jdk.internal.org.objectweb.asm.*;
 import sun.invoke.util.BytecodeDescriptor;
-import jdk.internal.misc.Unsafe;
 import sun.security.action.GetPropertyAction;
 import sun.security.action.GetBooleanAction;
 
 import java.io.FilePermission;
 import java.io.Serializable;
+import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Constructor;
+import java.lang.reflect.Modifier;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.LinkedHashSet;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.PropertyPermission;
 import java.util.Set;
 
+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;
+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;
 import static jdk.internal.org.objectweb.asm.Opcodes.*;
 
 /**
  * Lambda metafactory implementation which dynamically creates an
  * inner-class-like class per lambda callsite.
  *
  * @see LambdaMetafactory
  */
 /* package */ final class InnerClassLambdaMetafactory extends AbstractValidatingLambdaMetafactory {
-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();
-
-    private static final int CLASSFILE_VERSION = V15;
+    private static final int CLASSFILE_VERSION = 52;
     private static final String METHOD_DESCRIPTOR_VOID = Type.getMethodDescriptor(Type.VOID_TYPE);
     private static final String JAVA_LANG_OBJECT = "java/lang/Object";
     private static final String NAME_CTOR = "<init>";
-    private static final String NAME_FACTORY = "get$Lambda";
 
     //Serialization support
     private static final String NAME_SERIALIZED_LAMBDA = "java/lang/invoke/SerializedLambda";
     private static final String NAME_NOT_SERIALIZABLE_EXCEPTION = "java/io/NotSerializableException";
     private static final String DESCR_METHOD_WRITE_REPLACE = "()Ljava/lang/Object;";
     private static final String DESCR_METHOD_WRITE_OBJECT = "(Ljava/io/ObjectOutputStream;)V";
     private static final String DESCR_METHOD_READ_OBJECT = "(Ljava/io/ObjectInputStream;)V";
+    private static final String DESCR_SET_IMPL_METHOD = "(Ljava/lang/invoke/MethodHandle;)V";
+
     private static final String NAME_METHOD_WRITE_REPLACE = "writeReplace";
     private static final String NAME_METHOD_READ_OBJECT = "readObject";
     private static final String NAME_METHOD_WRITE_OBJECT = "writeObject";
+    private static final String NAME_FIELD_IMPL_METHOD = "protectedImplMethod";
 
     private static final String DESCR_CLASS = "Ljava/lang/Class;";
     private static final String DESCR_STRING = "Ljava/lang/String;";
     private static final String DESCR_OBJECT = "Ljava/lang/Object;";
+    private static final String DESCR_METHOD_HANDLE = "Ljava/lang/invoke/MethodHandle;";
     private static final String DESCR_CTOR_SERIALIZED_LAMBDA
             = "(" + DESCR_CLASS + DESCR_STRING + DESCR_STRING + DESCR_STRING + "I"
             + DESCR_STRING + DESCR_STRING + DESCR_STRING + DESCR_STRING + "[" + DESCR_OBJECT + ")V";
 
     private static final String DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION = "(Ljava/lang/String;)V";
     private static final String[] SER_HOSTILE_EXCEPTIONS = new String[] {NAME_NOT_SERIALIZABLE_EXCEPTION};
 
-    private static final String DESCR_HIDDEN = "Ljdk/internal/vm/annotation/Hidden;";
-
     private static final String[] EMPTY_STRING_ARRAY = new String[0];
 
     // Used to ensure that each spun class name is unique
     private static final AtomicInteger counter = new AtomicInteger(0);
 
@@ -108,10 +110,11 @@
     private final MethodType constructorType;        // Generated class constructor type "(CC)void"
     private final ClassWriter cw;                    // ASM class writer
     private final String[] argNames;                 // Generated names for the constructor arguments
     private final String[] argDescs;                 // Type descriptors for the constructor arguments
     private final String lambdaClassName;            // Generated name for the generated class "X$$Lambda$1"
+    private final boolean useImplMethodHandle;       // use MethodHandle invocation instead of symbolic bytecode invocation
 
     /**
      * General meta-factory constructor, supporting both standard cases and
      * allowing for uncommon options such as serialization or bridging.
      *
@@ -163,11 +166,13 @@
               isSerializable, markerInterfaces, additionalBridges);
         implMethodClassName = implClass.getName().replace('.', '/');
         implMethodName = implInfo.getName();
         implMethodDesc = implInfo.getMethodType().toMethodDescriptorString();
         constructorType = invokedType.changeReturnType(Void.TYPE);
-        lambdaClassName = targetClass.getName().replace('.', '/') + "$$Lambda$" + counter.incrementAndGet();
+        lambdaClassName = lambdaClassName(targetClass);
+        useImplMethodHandle = !implClass.getPackageName().equals(implInfo.getDeclaringClass().getPackageName())
+                                && !Modifier.isPublic(implInfo.getModifiers());
         cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
         int parameterCount = invokedType.parameterCount();
         if (parameterCount > 0) {
             argNames = new String[parameterCount];
             argDescs = new String[parameterCount];
@@ -178,10 +183,19 @@
         } else {
             argNames = argDescs = EMPTY_STRING_ARRAY;
         }
     }
 
+    private static String lambdaClassName(Class<?> targetClass) {
+        String name = targetClass.getName();
+        if (targetClass.isHidden()) {
+            // use the original class name
+            name = name.replace('/', '_');
+        }
+        return name.replace('.', '/') + "$$Lambda$" + counter.incrementAndGet();
+    }
+
     /**
      * Build the CallSite. Generate a class file which implements the functional
      * interface, define the class, if there are no parameters create an instance
      * of the class which the CallSite will return, otherwise, generate handles
      * which will call the class' constructor.
@@ -217,24 +231,18 @@
             }
 
             try {
                 Object inst = ctrs[0].newInstance();
                 return new ConstantCallSite(MethodHandles.constant(samBase, inst));
-            }
-            catch (ReflectiveOperationException e) {
+            } catch (ReflectiveOperationException e) {
                 throw new LambdaConversionException("Exception instantiating lambda object", e);
             }
         } else {
             try {
-                if (!disableEagerInitialization) {
-                    UNSAFE.ensureClassInitialized(innerClass);
-                }
-                return new ConstantCallSite(
-                        MethodHandles.Lookup.IMPL_LOOKUP
-                             .findStatic(innerClass, NAME_FACTORY, invokedType));
-            }
-            catch (ReflectiveOperationException e) {
+                MethodHandle mh = caller.findConstructor(innerClass, invokedType.changeReturnType(void.class));
+                return new ConstantCallSite(mh.asType(invokedType));
+            } catch (ReflectiveOperationException e) {
                 throw new LambdaConversionException("Exception finding constructor", e);
             }
         }
     }
 
@@ -283,41 +291,42 @@
             fv.visitEnd();
         }
 
         generateConstructor();
 
-        if (invokedType.parameterCount() != 0 || disableEagerInitialization) {
-            generateFactory();
-        }
-
         // Forward the SAM method
         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, samMethodName,
                                           samMethodType.toMethodDescriptorString(), null, null);
-        mv.visitAnnotation(DESCR_HIDDEN, true);
         new ForwardingMethodGenerator(mv).generate(samMethodType);
 
         // Forward the bridges
         if (additionalBridges != null) {
             for (MethodType mt : additionalBridges) {
                 mv = cw.visitMethod(ACC_PUBLIC|ACC_BRIDGE, samMethodName,
                                     mt.toMethodDescriptorString(), null, null);
-                mv.visitAnnotation(DESCR_HIDDEN, true);
                 new ForwardingMethodGenerator(mv).generate(mt);
             }
         }
 
+        if (useImplMethodHandle) {
+            FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_STATIC,
+                                            NAME_FIELD_IMPL_METHOD,
+                                            DESCR_METHOD_HANDLE,
+                                            null, null);
+            fv.visitEnd();
+        }
+
         if (isSerializable)
             generateSerializationFriendlyMethods();
         else if (accidentallySerializable)
             generateSerializationHostileMethods();
 
         cw.visitEnd();
 
         // Define the generated class in this VM.
 
         final byte[] classBytes = cw.toByteArray();
-
         // If requested, dump out to a file for debugging purposes
         if (dumper != null) {
             AccessController.doPrivileged(new PrivilegedAction<>() {
                 @Override
                 public Void run() {
@@ -327,32 +336,30 @@
             }, null,
             new FilePermission("<<ALL FILES>>", "read, write"),
             // createDirectories may need it
             new PropertyPermission("user.dir", "read"));
         }
-
-        return UNSAFE.defineAnonymousClass(targetClass, classBytes, null);
-    }
-
-    /**
-     * Generate the factory method for the class
-     */
-    private void generateFactory() {
-        MethodVisitor m = cw.visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_FACTORY, invokedType.toMethodDescriptorString(), null, null);
-        m.visitCode();
-        m.visitTypeInsn(NEW, lambdaClassName);
-        m.visitInsn(Opcodes.DUP);
-        int parameterCount = invokedType.parameterCount();
-        for (int typeIndex = 0, varIndex = 0; typeIndex < parameterCount; typeIndex++) {
-            Class<?> argType = invokedType.parameterType(typeIndex);
-            m.visitVarInsn(getLoadOpcode(argType), varIndex);
-            varIndex += getParameterSize(argType);
+        try {
+            // this class is linked at the indy callsite; so define a hidden nestmate
+            Lookup lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);
+            if (useImplMethodHandle) {
+                // If the target class invokes a method reference this::m which is
+                // resolved to a protected method inherited from a superclass in a different
+                // package, the target class does not have a bridge and this method reference
+                // has been changed from public to protected after the target class was compiled.
+                // This lambda proxy class has no access to the resolved method.
+                // So this workaround by passing the live implMethod method handle
+                // to the proxy class to invoke directly.
+                MethodHandle mh = lookup.findStaticSetter(lookup.lookupClass(), NAME_FIELD_IMPL_METHOD, MethodHandle.class);
+                mh.invokeExact(implMethod);
+            }
+            return lookup.lookupClass();
+        } catch (IllegalAccessException e) {
+            throw new LambdaConversionException("Exception defining lambda proxy class", e);
+        } catch (Throwable t) {
+            throw new InternalError(t);
         }
-        m.visitMethodInsn(INVOKESPECIAL, lambdaClassName, NAME_CTOR, constructorType.toMethodDescriptorString(), false);
-        m.visitInsn(ARETURN);
-        m.visitMaxs(-1, -1);
-        m.visitEnd();
     }
 
     /**
      * Generate the constructor for the class
      */
@@ -464,22 +471,31 @@
 
             if (implKind == MethodHandleInfo.REF_newInvokeSpecial) {
                 visitTypeInsn(NEW, implMethodClassName);
                 visitInsn(DUP);
             }
+            if (useImplMethodHandle) {
+                visitVarInsn(ALOAD, 0);
+                visitFieldInsn(GETSTATIC, lambdaClassName, NAME_FIELD_IMPL_METHOD, DESCR_METHOD_HANDLE);
+            }
             for (int i = 0; i < argNames.length; i++) {
                 visitVarInsn(ALOAD, 0);
                 visitFieldInsn(GETFIELD, lambdaClassName, argNames[i], argDescs[i]);
             }
 
             convertArgumentTypes(methodType);
 
-            // Invoke the method we want to forward to
-            visitMethodInsn(invocationOpcode(), implMethodClassName,
-                            implMethodName, implMethodDesc,
-                            implClass.isInterface());
-
+            if (useImplMethodHandle) {
+                MethodType mtype = implInfo.getMethodType().insertParameterTypes(0, implClass);
+                visitMethodInsn(INVOKEVIRTUAL, "java/lang/invoke/MethodHandle",
+                                "invokeExact", mtype.descriptorString(), false);
+            } else {
+                // Invoke the method we want to forward to
+                visitMethodInsn(invocationOpcode(), implMethodClassName,
+                                implMethodName, implMethodDesc,
+                                implClass.isInterface());
+            }
             // Convert the return value (if any) and return it
             // Note: if adapting from non-void to void, the 'return'
             // instruction will pop the unneeded result
             Class<?> implReturnClass = implMethodType.returnType();
             Class<?> samReturnClass = methodType.returnType();
diff a/src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java b/src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java
--- a/src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java
+++ b/src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java
@@ -24,10 +24,11 @@
  */
 
 package java.lang.invoke;
 
 import jdk.internal.org.objectweb.asm.ClassWriter;
+import jdk.internal.org.objectweb.asm.FieldVisitor;
 import jdk.internal.org.objectweb.asm.Label;
 import jdk.internal.org.objectweb.asm.MethodVisitor;
 import jdk.internal.org.objectweb.asm.Opcodes;
 import jdk.internal.org.objectweb.asm.Type;
 import sun.invoke.util.VerifyAccess;
@@ -40,17 +41,19 @@
 import java.io.IOException;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
+import java.util.List;
 import java.util.stream.Stream;
 
 import static java.lang.invoke.LambdaForm.BasicType;
 import static java.lang.invoke.LambdaForm.BasicType.*;
 import static java.lang.invoke.LambdaForm.*;
 import static java.lang.invoke.MethodHandleNatives.Constants.*;
 import static java.lang.invoke.MethodHandleStatics.*;
+import static java.lang.invoke.MethodHandles.Lookup.*;
 
 /**
  * Code generation backend for LambdaForm.
  * <p>
  * @author John Rose, JSR 292 EG
@@ -65,10 +68,12 @@
     private static final String OBJ     = "java/lang/Object";
     private static final String OBJARY  = "[Ljava/lang/Object;";
 
     private static final String LOOP_CLAUSES = MHI + "$LoopClauses";
     private static final String MHARY2       = "[[L" + MH + ";";
+    private static final String MH_SIG       = "L" + MH + ";";
+
 
     private static final String LF_SIG  = "L" + LF + ";";
     private static final String LFN_SIG = "L" + LFN + ";";
     private static final String LL_SIG  = "(L" + OBJ + ";)L" + OBJ + ";";
     private static final String LLV_SIG = "(L" + OBJ + ";L" + OBJ + ";)V";
@@ -90,17 +95,27 @@
     private Class<?>[]  localClasses; // type
 
     /** ASM bytecode generation. */
     private ClassWriter cw;
     private MethodVisitor mv;
+    private final List<ClassData> classData = new ArrayList<>();
 
     /** Single element internal class name lookup cache. */
     private Class<?> lastClass;
     private String lastInternalName;
 
     private static final MemberName.Factory MEMBERNAME_FACTORY = MemberName.getFactory();
     private static final Class<?> HOST_CLASS = LambdaForm.class;
+    private static final MethodHandles.Lookup LOOKUP = lookup();
+
+    private static MethodHandles.Lookup lookup() {
+        try {
+            return MethodHandles.privateLookupIn(HOST_CLASS, IMPL_LOOKUP);
+        } catch (IllegalAccessException e) {
+            throw newInternalError(e);
+        }
+    }
 
     /** Main constructor; other constructors delegate to this one. */
     private InvokerBytecodeGenerator(LambdaForm lambdaForm, int localsMapSize,
                                      String className, String invokerName, MethodType invokerType) {
         int p = invokerName.indexOf('.');
@@ -219,45 +234,56 @@
             sfx = "0"+sfx;
         className += sfx;
         return className;
     }
 
-    class CpPatch {
-        final int index;
+    public static class ClassData {
+        final String name;
+        final String desc;
         final Object value;
-        CpPatch(int index, Object value) {
-            this.index = index;
+
+        ClassData(String name, String desc, Object value) {
+            this.name = name;
+            this.desc = desc;
             this.value = value;
         }
+
+        public String name() { return name; }
         public String toString() {
-            return "CpPatch/index="+index+",value="+value;
+            return name + ",value="+value;
         }
     }
 
-    private final ArrayList<CpPatch> cpPatches = new ArrayList<>();
-
-    private int cph = 0;  // for counting constant placeholders
+    String classData(Object arg) {
+        String desc;
+        if (arg instanceof Class) {
+            desc = "Ljava/lang/Class;";
+        } else if (arg instanceof MethodHandle) {
+            desc = MH_SIG;
+        } else if (arg instanceof LambdaForm) {
+            desc = LF_SIG;
+        } else {
+            desc = "Ljava/lang/Object;";
+        }
 
-    String constantPlaceholder(Object arg) {
-        String cpPlaceholder = "CONSTANT_PLACEHOLDER_" + cph++;
-        if (DUMP_CLASS_FILES) cpPlaceholder += " <<" + debugString(arg) + ">>";
-        // TODO check if arg is already in the constant pool
-        // insert placeholder in CP and remember the patch
-        int index = cw.newConst((Object) cpPlaceholder);
-        cpPatches.add(new CpPatch(index, arg));
-        return cpPlaceholder;
+        Class<?> c = arg.getClass();
+        while (c.isArray()) {
+            c = c.getComponentType();
+        }
+        // unique static variable name
+        String name = "_DATA_" + c.getSimpleName() + "_" + classData.size();
+        ClassData cd = new ClassData(name, desc, arg);
+        classData.add(cd);
+        return cd.name();
     }
 
-    Object[] cpPatches(byte[] classFile) {
-        int size = getConstantPoolSize(classFile);
-        Object[] res = new Object[size];
-        for (CpPatch p : cpPatches) {
-            if (p.index >= size)
-                throw new InternalError("in cpool["+size+"]: "+p+"\n"+Arrays.toString(Arrays.copyOf(classFile, 20)));
-            res[p.index] = p.value;
+    List<Object> classDataValues() {
+        Object[] data = new Object[classData.size()];
+        for (int i = 0; i < classData.size(); i++) {
+            data[i] = classData.get(i).value;
         }
-        return res;
+        return List.of(data);
     }
 
     private static String debugString(Object arg) {
         if (arg instanceof MethodHandle) {
             MethodHandle mh = (MethodHandle) arg;
@@ -286,24 +312,16 @@
 
     /**
      * Extract the MemberName of a newly-defined method.
      */
     private MemberName loadMethod(byte[] classFile) {
-        Class<?> invokerClass = loadAndInitializeInvokerClass(classFile, cpPatches(classFile));
+        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(classFile)
+                                      .defineClass(true, classDataValues());
         return resolveInvokerMember(invokerClass, invokerName, invokerType);
     }
 
-    /**
-     * Define a given class as anonymous class in the runtime system.
-     */
-    private static Class<?> loadAndInitializeInvokerClass(byte[] classBytes, Object[] patches) {
-        Class<?> invokerClass = UNSAFE.defineAnonymousClass(HOST_CLASS, classBytes, patches);
-        UNSAFE.ensureClassInitialized(invokerClass);  // Make sure the class is initialized; VM might complain.
-        return invokerClass;
-    }
-
-    static MemberName resolveInvokerMember(Class<?> invokerClass, String name, MethodType type) {
+    private static MemberName resolveInvokerMember(Class<?> invokerClass, String name, MethodType type) {
         MemberName member = new MemberName(invokerClass, name, type, REF_invokeStatic);
         try {
             member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);
         } catch (ReflectiveOperationException e) {
             throw newInternalError(e);
@@ -314,11 +332,12 @@
     /**
      * Set up class file generation.
      */
     private ClassWriter classFilePrologue() {
         final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
-        cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
+        setClassWriter(cw);
         cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
                 CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);
         cw.visitSource(SOURCE_PREFIX + className, null);
         return cw;
     }
@@ -334,10 +353,55 @@
     private void methodEpilogue() {
         mv.visitMaxs(0, 0);
         mv.visitEnd();
     }
 
+    private String className() {
+        return CLASS_PREFIX + className;
+    }
+
+    private void clinit() {
+        clinit(cw, className(), classData);
+    }
+
+    /*
+     * <clinit> to initialize the static final fields with the live class data
+     * LambdaForms can't use condy due to bootstrapping issue.
+     */
+    static void clinit(ClassWriter cw, String className, List<ClassData> classData) {
+        if (classData.isEmpty())
+            return;
+
+        for (ClassData p : classData) {
+            // add the static field
+            FieldVisitor fv = cw.visitField(Opcodes.ACC_STATIC|Opcodes.ACC_FINAL, p.name, p.desc, null, null);
+            fv.visitEnd();
+        }
+
+        MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, "<clinit>", "()V", null, null);
+        mv.visitCode();
+        mv.visitLdcInsn(Type.getType("L" + className + ";"));
+        mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/invoke/MethodHandleNatives",
+                           "classData", "(Ljava/lang/Class;)Ljava/lang/Object;", false);
+        // we should optimize one single element case that does not need to create a List
+        mv.visitTypeInsn(Opcodes.CHECKCAST, "java/util/List");
+        mv.visitVarInsn(Opcodes.ASTORE, 0);
+        int index = 0;
+        for (ClassData p : classData) {
+            // initialize the static field
+            mv.visitVarInsn(Opcodes.ALOAD, 0);
+            emitIconstInsn(mv, index++);
+            mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, "java/util/List",
+                               "get", "(I)Ljava/lang/Object;", true);
+            mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));
+            mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);
+        }
+        mv.visitInsn(Opcodes.RETURN);
+        mv.visitMaxs(2, 1);
+        mv.visitEnd();
+    }
+
     /*
      * Low-level emit helpers.
      */
     private void emitConst(Object con) {
         if (con == null) {
@@ -406,10 +470,14 @@
         // fall through:
         mv.visitLdcInsn(con);
     }
 
     private void emitIconstInsn(final int cst) {
+        emitIconstInsn(mv, cst);
+    }
+
+    private static void emitIconstInsn(MethodVisitor mv, int cst) {
         if (cst >= -1 && cst <= 5) {
             mv.visitInsn(Opcodes.ICONST_0 + cst);
         } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {
             mv.visitIntInsn(Opcodes.BIPUSH, cst);
         } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {
@@ -575,12 +643,11 @@
         }
         if (isStaticallyNameable(cls)) {
             String sig = getInternalName(cls);
             mv.visitTypeInsn(Opcodes.CHECKCAST, sig);
         } else {
-            mv.visitLdcInsn(constantPlaceholder(cls));
-            mv.visitTypeInsn(Opcodes.CHECKCAST, CLS);
+            mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(cls), "Ljava/lang/Class;");
             mv.visitInsn(Opcodes.SWAP);
             mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, "cast", LL_SIG, false);
             if (Object[].class.isAssignableFrom(cls))
                 mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);
             else if (PROFILE_LEVEL > 0)
@@ -735,10 +802,11 @@
      * Generate an invoker method for the passed {@link LambdaForm}.
      */
     private byte[] generateCustomizedCodeBytes() {
         classFilePrologue();
         addMethod();
+        clinit();
         bogusMethod(lambdaForm);
 
         final byte[] classFile = toByteArray();
         maybeDump(classFile);
         return classFile;
@@ -762,18 +830,18 @@
             mv.visitAnnotation(FORCEINLINE_SIG, true);
         } else {
             mv.visitAnnotation(DONTINLINE_SIG, true);
         }
 
-        constantPlaceholder(lambdaForm); // keep LambdaForm instance & its compiled form lifetime tightly coupled.
+        classData(lambdaForm); // keep LambdaForm instance & its compiled form lifetime tightly coupled.
 
         if (lambdaForm.customized != null) {
             // Since LambdaForm is customized for a particular MethodHandle, it's safe to substitute
             // receiver MethodHandle (at slot #0) with an embedded constant and use it instead.
             // It enables more efficient code generation in some situations, since embedded constants
             // are compile-time constants for JIT compiler.
-            mv.visitLdcInsn(constantPlaceholder(lambdaForm.customized));
+            mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(lambdaForm.customized), MH_SIG);
             mv.visitTypeInsn(Opcodes.CHECKCAST, MH);
             assert(checkActualReceiver()); // expects MethodHandle on top of the stack
             mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);
         }
 
@@ -899,11 +967,11 @@
         assert(!name.isLinkerMethodInvoke());  // should use the static path for these
         if (true) {
             // push receiver
             MethodHandle target = name.function.resolvedHandle();
             assert(target != null) : name.exprString();
-            mv.visitLdcInsn(constantPlaceholder(target));
+            mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(target), MH_SIG);
             emitReferenceCast(MethodHandle.class, target);
         } else {
             // load receiver
             emitAloadInsn(0);
             emitReferenceCast(MethodHandle.class, null);
@@ -956,11 +1024,13 @@
             return false;  // FIXME
         if (cls.isAnonymousClass() || cls.isLocalClass())
             return false;  // inner class of some sort
         if (cls.getClassLoader() != MethodHandle.class.getClassLoader())
             return false;  // not on BCP
-        if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added
+        if (cls.isHidden())
+            return false;
+        if (ReflectUtil.isVMAnonymousClass(cls))   // FIXME: Unsafe::defineAnonymousClass to be removed
             return false;
         if (!isStaticallyInvocableType(member.getMethodOrFieldType()))
             return false;
         if (!member.isPrivate() && VerifyAccess.isSamePackage(MethodHandle.class, cls))
             return true;   // in java.lang.invoke package
@@ -980,18 +1050,20 @@
 
     static boolean isStaticallyNameable(Class<?> cls) {
         if (cls == Object.class)
             return true;
         if (MethodHandle.class.isAssignableFrom(cls)) {
-            assert(!ReflectUtil.isVMAnonymousClass(cls));
+            assert(!cls.isHidden());
             return true;
         }
         while (cls.isArray())
             cls = cls.getComponentType();
         if (cls.isPrimitive())
             return true;  // int[].class, for example
-        if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added
+        if (cls.isHidden())
+            return false;
+        if (ReflectUtil.isVMAnonymousClass(cls))   // FIXME: Unsafe::defineAnonymousClass to be removed
             return false;
         // could use VerifyAccess.isClassAccessible but the following is a safe approximation
         if (cls.getClassLoader() != Object.class.getClassLoader())
             return false;
         if (VerifyAccess.isSamePackage(MethodHandle.class, cls))
@@ -1059,11 +1131,11 @@
             } catch (Throwable ex) {
                 throw uncaughtException(ex);
             }
             assert(java.lang.reflect.Array.getLength(emptyArray) == 0);
             assert(emptyArray.getClass() == rtype);  // exact typing
-            mv.visitLdcInsn(constantPlaceholder(emptyArray));
+            mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(emptyArray), "Ljava/lang/Object;");
             emitReferenceCast(rtype, emptyArray);
             return;
         }
         Class<?> arrayElementType = rtype.getComponentType();
         assert(arrayElementType != null);
@@ -1622,11 +1694,11 @@
             emitConst(arg);
         } else {
             if (Wrapper.isWrapperType(arg.getClass()) && bptype != L_TYPE) {
                 emitConst(arg);
             } else {
-                mv.visitLdcInsn(constantPlaceholder(arg));
+                mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(arg), "Ljava/lang/Object;");
                 emitImplicitConversion(L_TYPE, ptype, arg);
             }
         }
     }
 
@@ -1814,10 +1886,11 @@
 
         // return statement
         emitReturnInsn(basicType(rtype));
 
         methodEpilogue();
+        clinit();
         bogusMethod(invokerType);
 
         final byte[] classFile = cw.toByteArray();
         maybeDump(classFile);
         return classFile;
@@ -1882,10 +1955,11 @@
             mv.visitInsn(Opcodes.ACONST_NULL);
         }
         emitReturnInsn(L_TYPE);  // NOTE: NamedFunction invokers always return a reference value.
 
         methodEpilogue();
+        clinit();
         bogusMethod(dstType);
 
         final byte[] classFile = cw.toByteArray();
         maybeDump(classFile);
         return classFile;
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java
@@ -23,10 +23,12 @@
  * questions.
  */
 
 package java.lang.invoke;
 
+import jdk.internal.access.JavaLangAccess;
+import jdk.internal.access.SharedSecrets;
 import jdk.internal.ref.CleanerFactory;
 import sun.invoke.util.Wrapper;
 
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Field;
@@ -135,10 +137,19 @@
             REF_invokeStatic            = 6,
             REF_invokeSpecial           = 7,
             REF_newInvokeSpecial        = 8,
             REF_invokeInterface         = 9,
             REF_LIMIT                  = 10;
+
+        /**
+         * Flags for Lookup.ClassOptions
+         */
+        static final int
+            NESTMATE_CLASS            = 0x00000001,
+            HIDDEN_CLASS              = 0x00000002,
+            STRONG_LOADER_LINK        = 0x00000004,
+            ACCESS_VM_ANNOTATIONS     = 0x00000008;
     }
 
     static boolean refKindIsValid(int refKind) {
         return (refKind > REF_NONE && refKind < REF_LIMIT);
     }
@@ -657,6 +668,15 @@
         if (symbolicRefClass == definingClass)  return true;
         if (symbolicRef.isStatic() || symbolicRef.isPrivate())  return false;
         return (definingClass.isAssignableFrom(symbolicRefClass) ||  // Msym overrides Mdef
                 symbolicRefClass.isInterface());                     // Mdef implements Msym
     }
+
+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    /*
+     * A convenient method for LambdaForms to get the class data of a given class.
+     * LambdaForms cannot use condy via MethodHandles.classData
+     */
+    static Object classData(Class<?> c) {
+        return JLA.classData(c);
+    }
 }
diff a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandles.java
@@ -23,13 +23,16 @@
  * questions.
  */
 
 package java.lang.invoke;
 
+import jdk.internal.access.JavaLangAccess;
 import jdk.internal.access.SharedSecrets;
+import jdk.internal.misc.VM;
 import jdk.internal.module.IllegalAccessLogger;
 import jdk.internal.org.objectweb.asm.ClassReader;
+import jdk.internal.org.objectweb.asm.Opcodes;
 import jdk.internal.reflect.CallerSensitive;
 import jdk.internal.reflect.Reflection;
 import jdk.internal.vm.annotation.ForceInline;
 import sun.invoke.util.ValueConversions;
 import sun.invoke.util.VerifyAccess;
@@ -43,12 +46,10 @@
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.ReflectPermission;
 import java.nio.ByteOrder;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.security.ProtectionDomain;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.BitSet;
 import java.util.Iterator;
@@ -217,10 +218,14 @@
      * @spec JPMS
      * @see Lookup#dropLookupMode
      * @see <a href="MethodHandles.Lookup.html#cross-module-lookup">Cross-module lookups</a>
      */
     public static Lookup privateLookupIn(Class<?> targetClass, Lookup caller) throws IllegalAccessException {
+        if (caller.allowedModes == Lookup.TRUSTED) {
+            return new Lookup(targetClass);
+        }
+
         SecurityManager sm = System.getSecurityManager();
         if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
         if (targetClass.isPrimitive())
             throw new IllegalArgumentException(targetClass + " is a primitive class");
         if (targetClass.isArray())
@@ -260,10 +265,61 @@
             }
         }
         return Lookup.newLookup(targetClass, newPreviousClass, newModes);
     }
 
+    /**
+     * Returns the <em>class data</em> associated with the lookup class
+     * of the specified {@code Lookup} object, or {@code null}.
+     *
+     * <p> Classes can be created with class data by calling
+     * {@link Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)
+     * Lookup::defineHiddenClassWithClassData}.
+     * A hidden class with a class data behaves as if the hidden class
+     * has a private static final unnamed field pre-initialized with
+     * the class data and this method is equivalent as if calling
+     * {@link ConstantBootstraps#getStaticFinal(Lookup, String, Class)} to
+     * obtain the value of such field corresponding to the class data.
+     *
+     * <p> The {@linkplain Lookup#lookupModes() lookup modes} for this lookup
+     * must have {@link Lookup#ORIGINAL ORIGINAL} access in order to retrieve
+     * the class data.
+     *
+     * @apiNote
+     * This method can be called as a bootstrap method for a dynamically computed
+     * constant.  A framework can create a hidden class with class data, for
+     * example that can be {@code List.of(o1, o2, o3....)} containing more than
+     * one live object.  The class data is accessible only to the lookup object
+     * created by the original caller but inaccessible to other members
+     * in the same nest.  If a framework passes security sensitive live objects
+     * to a hidden class via class data, it is recommended to load the value
+     * of class data as a dynamically computed constant instead of storing
+     * the live objects in private fields which are accessible to other
+     * nestmates.
+     *
+     * @param <T> the type to cast the class data object to
+     * @param caller the lookup context describing the class performing the
+     * operation (normally stacked by the JVM)
+     * @param name ignored
+     * @param type the type of the class data
+     * @return the value of the class data if present in the lookup class;
+     * otherwise {@code null}
+     * @throws IllegalAccessException if the lookup context does not have
+     * original caller access
+     * @throws ClassCastException if the class data cannot be converted to
+     * the specified {@code type}
+     * @see Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)
+     * @since 15
+     */
+    static <T> T classData(Lookup caller, String name, Class<T> type) throws IllegalAccessException {
+        if (!caller.hasFullPrivilegeAccess()) {
+            throw new IllegalAccessException(caller + " does not have full privilege access");
+        }
+        Object classData = MethodHandleNatives.classData(caller.lookupClass);
+        return type.cast(classData);
+    }
+
     /**
      * Performs an unchecked "crack" of a
      * <a href="MethodHandleInfo.html#directmh">direct method handle</a>.
      * The result is as if the user had obtained a lookup object capable enough
      * to crack the target method handle, called
@@ -515,11 +571,11 @@
      * <p>
      * The JVM imposes a similar requirement on {@code invokespecial} instruction,
      * that the receiver argument must match both the resolved method <em>and</em>
      * the current class.  Again, this requirement is enforced by narrowing the
      * type of the leading parameter to the resulting method handle.
-     * (See the Java Virtual Machine Specification, section {@jmvs 4.10.1.9}.)
+     * (See the Java Virtual Machine Specification, section {@jvms 4.10.1.9}.)
      * <p>
      * The JVM represents constructors and static initializer blocks as internal methods
      * with special names ({@code "<init>"} and {@code "<clinit>"}).
      * The internal syntax of invocation instructions allows them to refer to such internal
      * methods as if they were normal methods, but the JVM bytecode verifier rejects them.
@@ -1398,12 +1454,10 @@
          * Must be called by from a method in this package,
          * which in turn is called by a method not in this package.
          */
         Lookup(Class<?> lookupClass) {
             this(lookupClass, null, FULL_POWER_MODES);
-            // make sure we haven't accidentally picked up a privileged class:
-            checkUnprivilegedlookupClass(lookupClass);
         }
 
         private Lookup(Class<?> lookupClass, Class<?> prevLookupClass, int allowedModes) {
             assert prevLookupClass == null || ((allowedModes & MODULE) == 0
                     && prevLookupClass.getModule() != lookupClass.getModule());
@@ -1506,11 +1560,11 @@
                 && !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
                 newModes &= ~(PACKAGE|PRIVATE|PROTECTED);
             }
             // Allow nestmate lookups to be created without special privilege:
             if ((newModes & PRIVATE) != 0
-                && !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {
+                    && !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {
                 newModes &= ~(PRIVATE|PROTECTED);
             }
             if ((newModes & (PUBLIC|UNCONDITIONAL)) != 0
                 && !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, this.prevLookupClass, allowedModes)) {
                 // The requested class it not accessible from the lookup class.
@@ -1575,13 +1629,16 @@
             if (newModes == oldModes) return this;  // return self if no change
             return newLookup(lookupClass(), previousLookupClass(), newModes);
         }
 
         /**
-         * Defines a class to the same class loader and in the same runtime package and
+         * Creates and links a class or interface from {@code bytes}
+         * with the same class loader and in the same runtime package and
          * {@linkplain java.security.ProtectionDomain protection domain} as this lookup's
-         * {@linkplain #lookupClass() lookup class}.
+         * {@linkplain #lookupClass() lookup class} as if calling
+         * {@link ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
+         * ClassLoader::defineClass}.
          *
          * <p> The {@linkplain #lookupModes() lookup modes} for this lookup must include
          * {@link #PACKAGE PACKAGE} access as default (package) members will be
          * accessible to the class. The {@code PACKAGE} lookup mode serves to authenticate
          * that the lookup object was created by a caller in the runtime package (or derived
@@ -1600,85 +1657,557 @@
          * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method
          * is first called to check {@code RuntimePermission("defineClass")}. </p>
          *
          * @param bytes the class bytes
          * @return the {@code Class} object for the class
+         * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access
+         * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
          * @throws IllegalArgumentException the bytes are for a class in a different package
          * to the lookup class
-         * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access
-         * @throws LinkageError if the class is malformed ({@code ClassFormatError}), cannot be
-         * verified ({@code VerifyError}), is already defined, or another linkage error occurs
+         * @throws VerifyError if the newly created class cannot be verified
+         * @throws LinkageError if the newly created class cannot be linked for any other reason
          * @throws SecurityException if a security manager is present and it
          *                           <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
          * @throws NullPointerException if {@code bytes} is {@code null}
          * @since 9
          * @spec JPMS
          * @see Lookup#privateLookupIn
          * @see Lookup#dropLookupMode
          * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
          */
         public Class<?> defineClass(byte[] bytes) throws IllegalAccessException {
+            ensureDefineClassPermission();
+            if ((lookupModes() & PACKAGE) == 0)
+                throw new IllegalAccessException("Lookup does not have PACKAGE access");
+            return makeClassDefiner(bytes.clone()).defineClass(false);
+        }
+
+        private void ensureDefineClassPermission() {
+            if (allowedModes == TRUSTED)  return;
+
             if (!hasFullPrivilegeAccess()) {
                 SecurityManager sm = System.getSecurityManager();
                 if (sm != null)
                     sm.checkPermission(new RuntimePermission("defineClass"));
             }
-            if ((lookupModes() & PACKAGE) == 0)
-                throw new IllegalAccessException("Lookup does not have PACKAGE access");
+        }
+
+        /**
+         * The set of class options that specify whether a hidden class created by
+         * {@link Lookup#defineHiddenClass(byte[], boolean, ClassOption...)
+         * Lookup::defineHiddenClass} method is dynamically added as a new member
+         * to the nest of a lookup class and/or whether a hidden class has
+         * a strong relationship with the class loader marked as its defining loader.
+         *
+         * @since 15
+         */
+        public enum ClassOption {
+            /**
+             * Specifies that a hidden class be added to {@linkplain Class#getNestHost nest}
+             * of a lookup class as a nestmate.
+             *
+             * <p> A hidden nestmate class has access to the private members of all
+             * classes and interfaces in the same nest.
+             *
+             * @see Class#getNestHost()
+             */
+            NESTMATE(NESTMATE_CLASS),
+
+            /**
+             * Specifies that a hidden class has a <em>strong</em>
+             * relationship with the class loader marked as its defining loader,
+             * as a normal class or interface has with its own defining loader.
+             * This means that the hidden class may be unloaded if and only if
+             * its defining loader is not reachable and thus may be reclaimed
+             * by a garbage collector (JLS 12.7).
+             *
+             * <p> By default, a hidden class or interface may be unloaded
+             * even if the class loader that is marked as its defining loader is
+             * <a href="../ref/package.html#reachability">reachable</a>.
+
+             *
+             * @jls 12.7 Unloading of Classes and Interfaces
+             */
+            STRONG(STRONG_LOADER_LINK);
+
+            /* the flag value is used by VM at define class time */
+            private final int flag;
+            ClassOption(int flag) {
+                this.flag = flag;
+            }
+
+            static int optionsToFlag(Set<ClassOption> options) {
+                int flags = 0;
+                for (ClassOption cp : options) {
+                    flags |= cp.flag;
+                }
+                return flags;
+            }
+        }
 
-            // parse class bytes to get class name (in internal form)
-            bytes = bytes.clone();
-            String name;
+        /**
+         * Creates a <em>hidden</em> class or interface from {@code bytes},
+         * returning a {@code Lookup} on the newly created class or interface.
+         *
+         * <p> Ordinarily, a class or interface {@code C} is created by a class loader,
+         * which either defines {@code C} directly or delegates to another class loader.
+         * A class loader defines {@code C} directly by invoking
+         * {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)
+         * ClassLoader::defineClass}, which causes the Java Virtual Machine
+         * to derive {@code C} from a purported representation in {@code class} file format.
+         * In situations where use of a class loader is undesirable, a class or interface
+         * {@code C} can be created by this method instead. This method is capable of
+         * defining {@code C}, and thereby creating it, without invoking
+         * {@code ClassLoader::defineClass}.
+         * Instead, this method defines {@code C} as if by arranging for
+         * the Java Virtual Machine to derive a nonarray class or interface {@code C}
+         * from a purported representation in {@code class} file format
+         * using the following rules:
+         *
+         * <ol>
+         * <li> The {@linkplain #lookupModes() lookup modes} for this {@code Lookup}
+         * must include {@linkplain #hasFullPrivilegeAccess() full privilege} access.
+         * This level of access is needed to create {@code C} in the module
+         * of the lookup class of this {@code Lookup}.</li>
+         *
+         * <li> The purported representation in {@code bytes} must be a {@code ClassFile}
+         * structure of a supported major and minor version. The major and minor version
+         * may differ from the {@code class} file version of the lookup class of this
+         * {@code Lookup}.</li>
+         *
+         * <li> The value of {@code this_class} must be a valid index in the
+         * {@code constant_pool} table, and the entry at that index must be a valid
+         * {@code CONSTANT_Class_info} structure. Let {@code N} be the binary name
+         * encoded in internal form that is specified by this structure. {@code N} must
+         * denote a class or interface in the same package as the lookup class.</li>
+         *
+         * <li> Let {@code CN} be the string {@code N + "." + <suffix>},
+         * where {@code <suffix>} is an unqualified name.
+         *
+         * <p> Let {@code newBytes} be the {@code ClassFile} structure given by
+         * {@code bytes} with an additional entry in the {@code constant_pool} table,
+         * indicating a {@code CONSTANT_Utf8_info} structure for {@code CN}, and
+         * where the {@code CONSTANT_Class_info} structure indicated by {@code this_class}
+         * refers to the new {@code CONSTANT_Utf8_info} structure.
+         *
+         * <p> Let {@code L} be the defining class loader of the lookup class of this {@code Lookup}.
+         *
+         * <p> {@code C} is derived with name {@code CN}, class loader {@code L}, and
+         * purported representation {@code newBytes} as if by the rules of JVMS {@jvms 5.3.5},
+         * with the following adjustments:
+         * <ul>
+         * <li> The constant indicated by {@code this_class} is permitted to specify a name
+         * that includes a single {@code "."} character, even though this is not a valid
+         * binary class or interface name in internal form.</li>
+         *
+         * <li> The Java Virtual Machine marks {@code L} as the defining class loader of {@code C},
+         * but no class loader is recorded as an initiating class loader of {@code C}.</li>
+         *
+         * <li> {@code C} is considered to have the same runtime
+         * {@linkplain Class#getPackage() package}, {@linkplain Class#getModule() module}
+         * and {@linkplain java.security.ProtectionDomain protection domain}
+         * as the lookup class of this {@code Lookup}.
+         * <li> Let {@code GN} be the binary name obtained by taking {@code N}
+         * (a binary name encoded in internal form) and replacing ASCII forward slashes with
+         * ASCII periods. For the instance of {@link java.lang.Class} representing {@code C}:
+         * <ul>
+         * <li> {@link Class#getName()} returns the string {@code GN + "/" + <suffix>},
+         *      even though this is not a valid binary class or interface name.</li>
+         * <li> {@link Class#descriptorString()} returns the string
+         *      {@code "L" + N + "." + <suffix> + ";"},
+         *      even though this is not a valid type descriptor name.</li>
+         * <li> {@link Class#describeConstable()} returns an empty optional as {@code C}
+         *      cannot be described in {@linkplain java.lang.constant.ClassDesc nominal form}.</li>
+         * </ul>
+         * </ul>
+         * </li>
+         * </ol>
+         *
+         * <p> After {@code C} is derived, it is linked by the Java Virtual Machine.
+         * Linkage occurs as specified in JVMS {@jvms 5.4.3}, with the following adjustments:
+         * <ul>
+         * <li> During verification, whenever it is necessary to load the class named
+         * {@code CN}, the attempt succeeds, producing class {@code C}. No request is
+         * made of any class loader.</li>
+         *
+         * <li> On any attempt to resolve the entry in the run-time constant pool indicated
+         * by {@code this_class}, the symbolic reference is considered to be resolved to
+         * {@code C} and resolution always succeeds immediately.</li>
+         * </ul>
+         *
+         * <p> If the {@code initialize} parameter is {@code true},
+         * then {@code C} is initialized by the Java Virtual Machine.
+         *
+         * <p> The newly created class or interface {@code C} serves as the
+         * {@linkplain #lookupClass() lookup class} of the {@code Lookup} object
+         * returned by this method. {@code C} is <em>hidden</em> in the sense that
+         * no other class or interface can refer to {@code C} via a constant pool entry.
+         * That is, a hidden class or interface cannot be named as a supertype, a field type,
+         * a method parameter type, or a method return type by any other class.
+         * This is because a hidden class or interface does not have a binary name, so
+         * there is no internal form available to record in any class's constant pool.
+         * A hidden class or interface is not discoverable by {@link Class#forName(String, boolean, ClassLoader)},
+         * {@link ClassLoader#loadClass(String, boolean)}, or {@link #findClass(String)}, and
+         * is not {@linkplain java.lang.instrument.Instrumentation#isModifiableClass(Class)
+         * modifiable} by Java agents or tool agents using the <a href="{@docRoot}/../specs/jvmti.html">
+         * JVM Tool Interface</a>.
+         *
+         * <p> A class or interface created by
+         * {@linkplain ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)
+         * a class loader} has a strong relationship with that class loader.
+         * That is, every {@code Class} object contains a reference to the {@code ClassLoader}
+         * that {@linkplain Class#getClassLoader() defined it}.
+         * This means that a class created by a class loader may be unloaded if and
+         * only if its defining loader is not reachable and thus may be reclaimed
+         * by a garbage collector (JLS 12.7).
+         *
+         * By default, however, a hidden class or interface may be unloaded even if
+         * the class loader that is marked as its defining loader is
+         * <a href="../ref/package.html#reachability">reachable</a>.
+         * This behavior is useful when a hidden class or interface serves multiple
+         * classes defined by arbitrary class loaders.  In other cases, a hidden
+         * class or interface may be linked to a single class (or a small number of classes)
+         * with the same defining loader as the hidden class or interface.
+         * In such cases, where the hidden class or interface must be coterminous
+         * with a normal class or interface, the {@link ClassOption#STRONG STRONG}
+         * option may be passed in {@code options}.
+         * This arranges for a hidden class to have the same strong relationship
+         * with the class loader marked as its defining loader,
+         * as a normal class or interface has with its own defining loader.
+         *
+         * If {@code STRONG} is not used, then the invoker of {@code defineHiddenClass}
+         * may still prevent a hidden class or interface from being
+         * unloaded by ensuring that the {@code Class} object is reachable.
+         *
+         * <p> The unloading characteristics are set for each hidden class when it is
+         * defined, and cannot be changed later.  An advantage of allowing hidden classes
+         * to be unloaded independently of the class loader marked as their defining loader
+         * is that a very large number of hidden classes may be created by an application.
+         * In contrast, if {@code STRONG} is used, then the JVM may run out of memory,
+         * just as if normal classes were created by class loaders.
+         *
+         * <p> Classes and interfaces in a nest are allowed to have mutual access to
+         * their private members.  The nest relationship is determined by
+         * the {@code NestHost} attribute (JVMS {@jvms 4.7.28}) and
+         * the {@code NestMembers} attribute (JVMS {@jvms 4.7.29}) in a {@code class} file.
+         * By default, a hidden class belongs to a nest consisting only of itself
+         * because a hidden class has no binary name.
+         * The {@link ClassOption#NESTMATE NESTMATE} option can be passed in {@code options}
+         * to create a hidden class or interface {@code C} as a member of a nest.
+         * The nest to which {@code C} belongs is not based on any {@code NestHost} attribute
+         * in the {@code ClassFile} structure from which {@code C} was derived.
+         * Instead, the following rules determine the nest host of {@code C}:
+         * <ul>
+         * <li>If the nest host of the lookup class of this {@code Lookup} has previously
+         *     been determined, then let {@code H} be the nest host of the lookup class.
+         *     Otherwise, the nest host of the lookup class is determined using the
+         *     algorithm in JVMS {@jvms 5.4.4}, yielding {@code H}.</li>
+         * <li>The nest host of {@code C} is determined to be {@code H},
+         *     the nest host of the lookup class.</li>
+         * </ul>
+         *
+         * <p> A hidden class or interface may be serializable, but this requires a custom
+         * serialization mechanism in order to ensure that instances are properly serialized
+         * and deserialized. The default serialization mechanism supports only classes and
+         * interfaces that are discoverable by their class name.
+         *
+         * @param bytes the bytes that make up the class data,
+         * in the format of a valid {@code class} file as defined by
+         * <cite>The Java Virtual Machine Specification</cite>.
+         * @param initialize if {@code true} the class will be initialized.
+         * @param options {@linkplain ClassOption class options}
+         * @return the {@code Lookup} object on the hidden class
+         *
+         * @throws IllegalAccessException if this {@code Lookup} does not have
+         * {@linkplain #hasFullPrivilegeAccess() full privilege} access
+         * @throws SecurityException if a security manager is present and it
+         * <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
+         * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
+         * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version
+         * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
+         * {@bytes} denotes a class in a different package than the lookup class
+         * @throws IncompatibleClassChangeError if the class or interface named as
+         * the direct superclass of {@code C} is in fact an interface, or if any of the classes
+         * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces
+         * @throws ClassCircularityError if any of the superclasses or superinterfaces of
+         * {@code C} is {@code C} itself
+         * @throws VerifyError if the newly created class cannot be verified
+         * @throws LinkageError if the newly created class cannot be linked for any other reason
+         * @throws NullPointerException if any parameter is {@code null}
+         *
+         * @since 15
+         * @see Class#isHidden()
+         * @jvms 4.2.1 Binary Class and Interface Names
+         * @jvms 4.2.2 Unqualified Names
+         * @jvms 4.7.28 The {@code NestHost} Attribute
+         * @jvms 4.7.29 The {@code NestMembers} Attribute
+         * @jvms 5.4.3.1 Class and Interface Resolution
+         * @jvms 5.4.4 Access Control
+         * @jvms 5.3.5 Deriving a {@code Class} from a {@code class} File Representation
+         * @jvms 5.4 Linking
+         * @jvms 5.5 Initialization
+         * @jls 12.7 Unloading of Classes and Interfaces
+         */
+        public Lookup defineHiddenClass(byte[] bytes, boolean initialize, ClassOption... options)
+                throws IllegalAccessException
+        {
+            Objects.requireNonNull(bytes);
+            Objects.requireNonNull(options);
+
+            ensureDefineClassPermission();
+            if (!hasFullPrivilegeAccess()) {
+                throw new IllegalAccessException(this + " does not have full privilege access");
+            }
+
+            return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false).defineClassAsLookup(initialize);
+        }
+
+        /**
+         * Creates a <em>hidden</em> class or interface from {@code bytes} with associated
+         * {@linkplain MethodHandles#classData(Lookup, String, Class) class data},
+         * returning a {@code Lookup} on the newly created class or interface.
+         *
+         * <p> This method is equivalent to calling
+         * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass(bytes, true, options)}
+         * as if the hidden class has a private static final unnamed field whose value
+         * is initialized to {@code classData} right before the class initializer is
+         * executed.  The newly created class is linked and initialized by the Java
+         * Virtual Machine.
+         *
+         * <p> The {@link MethodHandles#classData(Lookup, String, Class) MethodHandles::classData}
+         * method can be used to retrieve the {@code classData}.
+         *
+         * @param bytes     the class bytes
+         * @param classData pre-initialized class data
+         * @param options   {@linkplain ClassOption class options}
+         * @return the {@code Lookup} object on the hidden class
+         *
+         * @throws IllegalAccessException if this {@code Lookup} does not have
+         * {@linkplain #hasFullPrivilegeAccess() full privilege} access
+         * @throws SecurityException if a security manager is present and it
+         * <a href="MethodHandles.Lookup.html#secmgr">refuses access</a>
+         * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure
+         * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version
+         * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
+         * {@bytes} denotes a class in a different package than the lookup class
+         * @throws IncompatibleClassChangeError if the class or interface named as
+         * the direct superclass of {@code C} is in fact an interface, or if any of the classes
+         * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces
+         * @throws ClassCircularityError if any of the superclasses or superinterfaces of
+         * {@code C} is {@code C} itself
+         * @throws VerifyError if the newly created class cannot be verified
+         * @throws LinkageError if the newly created class cannot be linked for any other reason
+         * @throws NullPointerException if any parameter is {@code null}
+         *
+         * @since 15
+         * @see Lookup#defineHiddenClass(byte[], boolean, ClassOption...)
+         * @see Class#isHidden()
+         */
+        /* package-private */ Lookup defineHiddenClassWithClassData(byte[] bytes, Object classData, ClassOption... options)
+                throws IllegalAccessException
+        {
+            Objects.requireNonNull(bytes);
+            Objects.requireNonNull(classData);
+            Objects.requireNonNull(options);
+
+            ensureDefineClassPermission();
+            if (!hasFullPrivilegeAccess()) {
+                throw new IllegalAccessException(this + " does not have full privilege access");
+            }
+
+            return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false)
+                       .defineClassAsLookup(true, classData);
+        }
+
+        /*
+         * Validates the given bytes to be a class or interface and the class name
+         * is in the same package as the lookup class.
+         *
+         * This method returns the class name.
+         */
+        private String validateAndGetClassName(byte[] bytes) {
             try {
                 ClassReader reader = new ClassReader(bytes);
-                name = reader.getClassName();
+                if ((reader.getAccess() & Opcodes.ACC_MODULE) != 0) {
+                    throw newIllegalArgumentException("Not a class or interface: ACC_MODULE flag is set");
+                }
+                String name = reader.getClassName().replace('/', '.');
+                int index = name.lastIndexOf('.');
+                String pn = (index == -1) ? "" : name.substring(0, index);
+                if (!pn.equals(lookupClass.getPackageName())) {
+                    throw newIllegalArgumentException(name + " not in same package as lookup class: " +
+                            lookupClass.getName());
+                }
+                return name;
+            } catch (IllegalArgumentException e) {
+                throw e;
             } catch (RuntimeException e) {
                 // ASM exceptions are poorly specified
                 ClassFormatError cfe = new ClassFormatError();
                 cfe.initCause(e);
                 throw cfe;
             }
+        }
 
-            // get package and class name in binary form
-            String cn, pn;
-            int index = name.lastIndexOf('/');
-            if (index == -1) {
-                cn = name;
-                pn = "";
-            } else {
-                cn = name.replace('/', '.');
-                pn = cn.substring(0, index);
+
+        /*
+         * Returns a ClassDefiner that creates a {@code Class} object of a normal class
+         * from the given bytes.
+         *
+         * Caller should make a defensive copy of the arguments if needed
+         * before calling this factory method.
+         *
+         * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
+         * {@bytes} denotes a class in a different package than the lookup class
+         */
+        private ClassDefiner makeClassDefiner(byte[] bytes) {
+            return new ClassDefiner(this, validateAndGetClassName(bytes), bytes, STRONG_LOADER_LINK);
+        }
+
+        /**
+         * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
+         * from the given bytes.  The name must be in the same package as the lookup class.
+         *
+         * Caller should make a defensive copy of the arguments if needed
+         * before calling this factory method.
+         *
+         * @param bytes   class bytes
+         * @return ClassDefiner that defines a hidden class of the given bytes.
+         *
+         * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
+         * {@bytes} denotes a class in a different package than the lookup class
+         */
+        ClassDefiner makeHiddenClassDefiner(byte[] bytes) {
+            return makeHiddenClassDefiner(validateAndGetClassName(bytes), bytes, Set.of(), false);
+        }
+
+        /**
+         * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
+         * from the given bytes and options.
+         * The name must be in the same package as the lookup class.
+         *
+         * Caller should make a defensive copy of the arguments if needed
+         * before calling this factory method.
+         *
+         * @param bytes   class bytes
+         * @param options class options
+         * @param accessVmAnnotations true to give the hidden class access to VM annotations
+         * @return ClassDefiner that defines a hidden class of the given bytes and options
+         *
+         * @throws IllegalArgumentException if {@code bytes} is not a class or interface or
+         * {@bytes} denotes a class in a different package than the lookup class
+         */
+        ClassDefiner makeHiddenClassDefiner(byte[] bytes,
+                                            Set<ClassOption> options,
+                                            boolean accessVmAnnotations) {
+            return makeHiddenClassDefiner(validateAndGetClassName(bytes), bytes, options, accessVmAnnotations);
+        }
+
+        /**
+         * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
+         * from the given bytes.  No package name check on the given name.
+         *
+         * @param name    fully-qualified name that specifies the prefix of the hidden class
+         * @param bytes   class bytes
+         * @return ClassDefiner that defines a hidden class of the given bytes.
+         */
+        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes) {
+            return makeHiddenClassDefiner(name, bytes, Set.of(), false);
+        }
+
+        /**
+         * Returns a ClassDefiner that creates a {@code Class} object of a hidden class
+         * from the given bytes and options.  No package name check on the given name.
+         *
+         * @param name the name of the class and the name in the class bytes is ignored.
+         * @param bytes class bytes
+         * @param options class options
+         * @param accessVmAnnotations true to give the hidden class access to VM annotations
+         */
+        ClassDefiner makeHiddenClassDefiner(String name,
+                                            byte[] bytes,
+                                            Set<ClassOption> options,
+                                            boolean accessVmAnnotations) {
+            int flags = HIDDEN_CLASS | ClassOption.optionsToFlag(options);
+            if (accessVmAnnotations | VM.isSystemDomainLoader(lookupClass.getClassLoader())) {
+                // jdk.internal.vm.annotations are permitted for classes
+                // defined to boot loader and platform loader
+                flags |= ACCESS_VM_ANNOTATIONS;
+            }
+
+            return new ClassDefiner(this, name, bytes, flags);
+        }
+
+        static class ClassDefiner {
+            private final Lookup lookup;
+            private final String name;
+            private final byte[] bytes;
+            private final int classFlags;
+
+            private ClassDefiner(Lookup lookup, String name, byte[] bytes, int flags) {
+                assert ((flags & HIDDEN_CLASS) != 0 || (flags & STRONG_LOADER_LINK) == STRONG_LOADER_LINK);
+                this.lookup = lookup;
+                this.bytes = bytes;
+                this.classFlags = flags;
+                this.name = name;
+            }
+
+            String className() {
+                return name;
+            }
+
+            Class<?> defineClass(boolean initialize) {
+                return defineClass(initialize, null);
+            }
+
+            Lookup defineClassAsLookup(boolean initialize) {
+                Class<?> c = defineClass(initialize, null);
+                return new Lookup(c, null, FULL_POWER_MODES);
+            }
+
+            /**
+             * Defines the class of the given bytes and the given classData.
+             * If {@code initialize} parameter is true, then the class will be initialized.
+             *
+             * @param initialize true if the class to be initialized
+             * @param classData classData or null
+             * @return the class
+             *
+             * @throws LinkageError linkage error
+             */
+            Class<?> defineClass(boolean initialize, Object classData) {
+                Class<?> lookupClass = lookup.lookupClass();
+                ClassLoader loader = lookupClass.getClassLoader();
+                ProtectionDomain pd = (loader != null) ? lookup.lookupClassProtectionDomain() : null;
+                Class<?> c = JLA.defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);
+                assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();
+                return c;
             }
-            if (!pn.equals(lookupClass.getPackageName())) {
-                throw new IllegalArgumentException("Class not in same package as lookup class");
+
+            Lookup defineClassAsLookup(boolean initialize, Object classData) {
+                // initialize must be true if classData is non-null
+                assert classData == null || initialize == true;
+                Class<?> c = defineClass(initialize, classData);
+                return new Lookup(c, null, FULL_POWER_MODES);
             }
 
-            // invoke the class loader's defineClass method
-            ClassLoader loader = lookupClass.getClassLoader();
-            ProtectionDomain pd = (loader != null) ? lookupClassProtectionDomain() : null;
-            String source = "__Lookup_defineClass__";
-            Class<?> clazz = SharedSecrets.getJavaLangAccess().defineClass(loader, cn, bytes, pd, source);
-            return clazz;
+            private boolean isNestmate() {
+                return (classFlags & NESTMATE_CLASS) != 0;
+            }
         }
 
         private ProtectionDomain lookupClassProtectionDomain() {
             ProtectionDomain pd = cachedProtectionDomain;
             if (pd == null) {
-                cachedProtectionDomain = pd = protectionDomain(lookupClass);
+                cachedProtectionDomain = pd = JLA.protectionDomain(lookupClass);
             }
             return pd;
         }
 
-        private ProtectionDomain protectionDomain(Class<?> clazz) {
-            PrivilegedAction<ProtectionDomain> pa = clazz::getProtectionDomain;
-            return AccessController.doPrivileged(pa);
-        }
-
         // cached protection domain
         private volatile ProtectionDomain cachedProtectionDomain;
 
-
         // Make sure outer class is initialized first.
         static { IMPL_NAMES.getClass(); }
 
         /** Package-private version of lookup which is trusted. */
         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, null, TRUSTED);
@@ -1687,10 +2216,12 @@
          *  It can only be used to create method handles to publicly accessible
          *  members in packages that are exported unconditionally.
          */
         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, null, UNCONDITIONAL);
 
+        static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+
         private static void checkUnprivilegedlookupClass(Class<?> lookupClass) {
             String name = lookupClass.getName();
             if (name.startsWith("java.lang.invoke."))
                 throw newIllegalArgumentException("illegal lookupClass: "+lookupClass);
         }
@@ -1747,11 +2278,11 @@
             case PUBLIC|PACKAGE:
             case PUBLIC|MODULE|PACKAGE:
                 return cname + "/package";
             case FULL_POWER_MODES & (~PROTECTED):
             case FULL_POWER_MODES & ~(PROTECTED|MODULE):
-                    return cname + "/private";
+                return cname + "/private";
             case FULL_POWER_MODES:
             case FULL_POWER_MODES & (~MODULE):
                 return cname;
             case TRUSTED:
                 return "/trusted";  // internal only; not exported
@@ -2661,12 +3192,17 @@
             return unreflectField(f, true);
         }
 
         private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {
             MemberName field = new MemberName(f, isSetter);
-            if (isSetter && field.isStatic() && field.isFinal())
-                throw field.makeAccessException("static final field has no write access", this);
+            if (isSetter && field.isFinal()) {
+                if (field.isStatic()) {
+                    throw field.makeAccessException("static final field has no write access", this);
+                } else if (field.getDeclaringClass().isHidden()){
+                    throw field.makeAccessException("final field in a hidden class has no write access", this);
+                }
+            }
             assert(isSetter
                     ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())
                     : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));
             @SuppressWarnings("deprecation")
             Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;
@@ -3225,12 +3761,12 @@
                 if (!getField.getDeclaringClass().isAssignableFrom(lookupClass())) {
                     throw getField.makeAccessException("caller class must be a subclass below the method", lookupClass());
                 }
                 refc = lookupClass();
             }
-            boolean isWriteAllowedOnFinalFields = this.allowedModes == TRUSTED;
-            return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(), isWriteAllowedOnFinalFields);
+            return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),
+                                             this.allowedModes == TRUSTED && !getField.getDeclaringClass().isHidden());
         }
         /** Check access and get the requested constructor. */
         private MethodHandle getDirectConstructor(Class<?> refc, MemberName ctor) throws IllegalAccessException {
             final boolean checkSecurity = true;
             return getDirectConstructorCommon(refc, ctor, checkSecurity);
diff a/src/java.base/share/classes/java/lang/reflect/AccessibleObject.java b/src/java.base/share/classes/java/lang/reflect/AccessibleObject.java
--- a/src/java.base/share/classes/java/lang/reflect/AccessibleObject.java
+++ b/src/java.base/share/classes/java/lang/reflect/AccessibleObject.java
@@ -174,10 +174,16 @@
      * members with default (package) access, protected instance members, or
      * protected constructors when the declaring class is in a different module
      * to the caller and the package containing the declaring class is not open
      * to the caller's module. </p>
      *
+     * <p> This method cannot be used to enable {@linkplain Field#set <em>write</em>}
+     * access to a final field declared in a {@linkplain Class#isHidden() hidden class},
+     * since such fields are not modifiable.  The {@code accessible} flag when
+     * {@code true} suppresses Java language access control checks to only
+     * enable {@linkplain Field#get <em>read</em>} access to such fields.
+     *
      * <p> If there is a security manager, its
      * {@code checkPermission} method is first called with a
      * {@code ReflectPermission("suppressAccessChecks")} permission.
      *
      * @param flag the new value for the {@code accessible} flag
diff a/src/java.base/share/classes/java/lang/reflect/Field.java b/src/java.base/share/classes/java/lang/reflect/Field.java
--- a/src/java.base/share/classes/java/lang/reflect/Field.java
+++ b/src/java.base/share/classes/java/lang/reflect/Field.java
@@ -726,14 +726,23 @@
      *
      * <p>If this {@code Field} object is enforcing Java language access control, and
      * the underlying field is inaccessible, the method throws an
      * {@code IllegalAccessException}.
      *
-     * <p>If the underlying field is final, the method throws an
-     * {@code IllegalAccessException} unless {@code setAccessible(true)}
-     * has succeeded for this {@code Field} object
-     * and the field is non-static. Setting a final field in this way
+     * <p>If the underlying field is final, this {@code Field} object has
+     * <em>write</em> access if and only if the following conditions are met:
+     * <ul>
+     * <li>{@link #setAccessible(boolean) setAccessible(true)} has succeeded for
+     *     this {@code Field} object;</li>
+     * <li>the field is non-static; and</li>
+     * <li>the field's declaring class is not a {@linkplain Class#isHidden()
+     *     hidden class}.</li>
+     * </ul>
+     * If any of the above checks is not met, this method throws an
+     * {@code IllegalAccessException}.
+     *
+     * <p> Setting a final field in this way
      * is meaningful only during deserialization or reconstruction of
      * instances of classes with blank final fields, before they are
      * made available for access by other parts of a program. Use in
      * any other context may have unpredictable effects, including cases
      * in which other parts of a program continue to use the original
@@ -761,11 +770,12 @@
      * @param value the new value for the field of {@code obj}
      * being modified
      *
      * @throws    IllegalAccessException    if this {@code Field} object
      *              is enforcing Java language access control and the underlying
-     *              field is either inaccessible or final.
+     *              field is inaccessible or final;
+     *              or if this {@code Field} object has no write access.
      * @throws    IllegalArgumentException  if the specified object is not an
      *              instance of the class or interface declaring the underlying
      *              field (or a subclass or implementor thereof),
      *              or if an unwrapping conversion fails.
      * @throws    NullPointerException      if the specified object is null
@@ -796,11 +806,12 @@
      * @param z   the new value for the field of {@code obj}
      * being modified
      *
      * @throws    IllegalAccessException    if this {@code Field} object
      *              is enforcing Java language access control and the underlying
-     *              field is either inaccessible or final.
+     *              field is either inaccessible or final;
+     *              or if this {@code Field} object has no write access.
      * @throws    IllegalArgumentException  if the specified object is not an
      *              instance of the class or interface declaring the underlying
      *              field (or a subclass or implementor thereof),
      *              or if an unwrapping conversion fails.
      * @throws    NullPointerException      if the specified object is null
@@ -832,11 +843,12 @@
      * @param b   the new value for the field of {@code obj}
      * being modified
      *
      * @throws    IllegalAccessException    if this {@code Field} object
      *              is enforcing Java language access control and the underlying
-     *              field is either inaccessible or final.
+     *              field is either inaccessible or final;
+     *              or if this {@code Field} object has no write access.
      * @throws    IllegalArgumentException  if the specified object is not an
      *              instance of the class or interface declaring the underlying
      *              field (or a subclass or implementor thereof),
      *              or if an unwrapping conversion fails.
      * @throws    NullPointerException      if the specified object is null
@@ -868,11 +880,12 @@
      * @param c   the new value for the field of {@code obj}
      * being modified
      *
      * @throws    IllegalAccessException    if this {@code Field} object
      *              is enforcing Java language access control and the underlying
-     *              field is either inaccessible or final.
+     *              field is either inaccessible or final;
+     *              or if this {@code Field} object has no write access.
      * @throws    IllegalArgumentException  if the specified object is not an
      *              instance of the class or interface declaring the underlying
      *              field (or a subclass or implementor thereof),
      *              or if an unwrapping conversion fails.
      * @throws    NullPointerException      if the specified object is null
@@ -904,11 +917,12 @@
      * @param s   the new value for the field of {@code obj}
      * being modified
      *
      * @throws    IllegalAccessException    if this {@code Field} object
      *              is enforcing Java language access control and the underlying
-     *              field is either inaccessible or final.
+     *              field is either inaccessible or final;
+     *              or if this {@code Field} object has no write access.
      * @throws    IllegalArgumentException  if the specified object is not an
      *              instance of the class or interface declaring the underlying
      *              field (or a subclass or implementor thereof),
      *              or if an unwrapping conversion fails.
      * @throws    NullPointerException      if the specified object is null
@@ -940,11 +954,12 @@
      * @param i   the new value for the field of {@code obj}
      * being modified
      *
      * @throws    IllegalAccessException    if this {@code Field} object
      *              is enforcing Java language access control and the underlying
-     *              field is either inaccessible or final.
+     *              field is either inaccessible or final;
+     *              or if this {@code Field} object has no write access.
      * @throws    IllegalArgumentException  if the specified object is not an
      *              instance of the class or interface declaring the underlying
      *              field (or a subclass or implementor thereof),
      *              or if an unwrapping conversion fails.
      * @throws    NullPointerException      if the specified object is null
@@ -976,11 +991,12 @@
      * @param l   the new value for the field of {@code obj}
      * being modified
      *
      * @throws    IllegalAccessException    if this {@code Field} object
      *              is enforcing Java language access control and the underlying
-     *              field is either inaccessible or final.
+     *              field is either inaccessible or final;
+     *              or if this {@code Field} object has no write access.
      * @throws    IllegalArgumentException  if the specified object is not an
      *              instance of the class or interface declaring the underlying
      *              field (or a subclass or implementor thereof),
      *              or if an unwrapping conversion fails.
      * @throws    NullPointerException      if the specified object is null
@@ -1012,11 +1028,12 @@
      * @param f   the new value for the field of {@code obj}
      * being modified
      *
      * @throws    IllegalAccessException    if this {@code Field} object
      *              is enforcing Java language access control and the underlying
-     *              field is either inaccessible or final.
+     *              field is either inaccessible or final;
+     *              or if this {@code Field} object has no write access.
      * @throws    IllegalArgumentException  if the specified object is not an
      *              instance of the class or interface declaring the underlying
      *              field (or a subclass or implementor thereof),
      *              or if an unwrapping conversion fails.
      * @throws    NullPointerException      if the specified object is null
@@ -1048,11 +1065,12 @@
      * @param d   the new value for the field of {@code obj}
      * being modified
      *
      * @throws    IllegalAccessException    if this {@code Field} object
      *              is enforcing Java language access control and the underlying
-     *              field is either inaccessible or final.
+     *              field is either inaccessible or final;
+     *              or if this {@code Field} object has no write access.
      * @throws    IllegalArgumentException  if the specified object is not an
      *              instance of the class or interface declaring the underlying
      *              field (or a subclass or implementor thereof),
      *              or if an unwrapping conversion fails.
      * @throws    NullPointerException      if the specified object is null
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
@@ -79,14 +79,15 @@
       * nor visited.
       */
     public static final int SKIP_CODE = 1;
 
     /**
-      * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable
-      * and LineNumberTable attributes. If this flag is set these attributes are neither parsed nor
-      * visited (i.e. {@link ClassVisitor#visitSource}, {@link MethodVisitor#visitLocalVariable} and
-      * {@link MethodVisitor#visitLineNumber} are not called).
+      * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,
+      * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set
+      * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link
+      * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link
+      * MethodVisitor#visitParameter} are not called).
       */
     public static final int SKIP_DEBUG = 2;
 
     /**
       * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes
@@ -119,26 +120,36 @@
     static final int EXPAND_ASM_INSNS = 256;
 
     /** The size of the temporary byte array used to read class input streams chunk by chunk. */
     private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;
 
+    /**
+      * A byte array containing the JVMS ClassFile structure to be parsed.
+      *
+      * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will
+      *     eventually be deleted.
+      */
+    @Deprecated
+    // DontCheck(MemberName): can't be renamed (for backward binary compatibility).
+    public final byte[] b;
+
     /**
       * A byte array containing the JVMS ClassFile structure to be parsed. <i>The content of this array
       * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally
       * not needed by class visitors.</i>
       *
       * <p>NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not
       * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct
       * ClassFile element offsets within this byte array.
       */
-    // DontCheck(MemberName): can't be renamed (for backward binary compatibility).
-    public final byte[] b;
+    final byte[] classFileBuffer;
 
     /**
-      * The offset in bytes, in {@link #b}, of each cp_info entry of the ClassFile's constant_pool
-      * array, <i>plus one</i>. In other words, the offset of constant pool entry i is given by
-      * cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] - 1].
+      * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile's
+      * constant_pool array, <i>plus one</i>. In other words, the offset of constant pool entry i is
+      * given by cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] -
+      * 1].
       */
     private final int[] cpInfoOffsets;
 
     /**
       * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids
@@ -151,12 +162,12 @@
       * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.
       */
     private final ConstantDynamic[] constantDynamicValues;
 
     /**
-      * The start offsets in {@link #b} of each element of the bootstrap_methods array (in the
-      * BootstrapMethods attribute).
+      * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array
+      * (in the BootstrapMethods attribute).
       *
       * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23">JVMS
       *     4.7.23</a>
       */
     private final int[] bootstrapMethodOffsets;
@@ -165,11 +176,11 @@
       * A conservative estimate of the maximum length of the strings contained in the constant pool of
       * the class.
       */
     private final int maxStringLength;
 
-    /** The offset in bytes, in {@link #b}, of the ClassFile's access_flags field. */
+    /** The offset in bytes of the ClassFile's access_flags field. */
     public final int header;
 
     // -----------------------------------------------------------------------------------------------
     // Constructors
     // -----------------------------------------------------------------------------------------------
@@ -205,11 +216,12 @@
       * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
       * @param checkClassVersion whether to check the class version or not.
       */
     ClassReader(
             final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
-        b = classFileBuffer;
+        this.classFileBuffer = classFileBuffer;
+        this.b = classFileBuffer;
         // Check the class' major_version. This field is after the magic and minor_version fields, which
         // use 4 and 2 bytes respectively.
         if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V15) {
             throw new IllegalArgumentException(
                     "Unsupported class file major version " + readShort(classFileOffset + 6));
@@ -224,12 +236,12 @@
         // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2
         // bytes respectively.
         int currentCpInfoIndex = 1;
         int currentCpInfoOffset = classFileOffset + 10;
         int currentMaxStringLength = 0;
+        boolean hasBootstrapMethods = false;
         boolean hasConstantDynamic = false;
-        boolean hasConstantInvokeDynamic = false;
         // The offset of the other entries depend on the total size of all the previous entries.
         while (currentCpInfoIndex < constantPoolCount) {
             cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;
             int cpInfoSize;
             switch (classFileBuffer[currentCpInfoOffset]) {
@@ -241,15 +253,16 @@
                 case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
                     cpInfoSize = 5;
                     break;
                 case Symbol.CONSTANT_DYNAMIC_TAG:
                     cpInfoSize = 5;
+                    hasBootstrapMethods = true;
                     hasConstantDynamic = true;
                     break;
                 case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
                     cpInfoSize = 5;
-                    hasConstantInvokeDynamic = true;
+                    hasBootstrapMethods = true;
                     break;
                 case Symbol.CONSTANT_LONG_TAG:
                 case Symbol.CONSTANT_DOUBLE_TAG:
                     cpInfoSize = 9;
                     currentCpInfoIndex++;
@@ -285,13 +298,11 @@
         // Allocate the cache of ConstantDynamic values, if there is at least one.
         constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;
 
         // Read the BootstrapMethods attribute, if any (only get the offset of each method).
         bootstrapMethodOffsets =
-                (hasConstantDynamic | hasConstantInvokeDynamic)
-                        ? readBootstrapMethodsAttribute(currentMaxStringLength)
-                        : null;
+                hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;
     }
 
     /**
       * Constructs a new {@link ClassReader} object.
       *
@@ -328,12 +339,11 @@
     private static byte[] readStream(final InputStream inputStream, final boolean close)
             throws IOException {
         if (inputStream == null) {
             throw new IOException("Class not found");
         }
-        try {
-            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
             byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];
             int bytesRead;
             while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {
                 outputStream.write(data, 0, bytesRead);
             }
@@ -434,10 +444,11 @@
       *     semantic links with a class element that has been transformed by a class adapter between
       *     the reader and the writer</i>.
       * @param parsingOptions the options to use to parse this class. One or more of {@link
       *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
       */
+    @SuppressWarnings("deprecation")
     public void accept(
             final ClassVisitor classVisitor,
             final Attribute[] attributePrototypes,
             final int parsingOptions) {
         Context context = new Context();
@@ -486,10 +497,14 @@
         String moduleMainClass = null;
         // - The string corresponding to the NestHost attribute, or null.
         String nestHostClass = null;
         // - The offset of the NestMembers attribute, or 0.
         int nestMembersOffset = 0;
+        // - The offset of the PermittedSubtypes attribute, or 0
+        int permittedSubtypesOffset = 0;
+        // - The offset of the Record attribute, or 0.
+        int recordOffset = 0;
         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
         //   This list in the <i>reverse order</i> or their order in the ClassFile structure.
         Attribute attributes = null;
 
         int currentAttributeOffset = getFirstAttributeOffset();
@@ -508,10 +523,12 @@
                 enclosingMethodOffset = currentAttributeOffset;
             } else if (Constants.NEST_HOST.equals(attributeName)) {
                 nestHostClass = readClass(currentAttributeOffset, charBuffer);
             } else if (Constants.NEST_MEMBERS.equals(attributeName)) {
                 nestMembersOffset = currentAttributeOffset;
+            } else if (Constants.PERMITTED_SUBTYPES.equals(attributeName)) {
+                permittedSubtypesOffset = currentAttributeOffset;
             } else if (Constants.SIGNATURE.equals(attributeName)) {
                 signature = readUTF8(currentAttributeOffset, charBuffer);
             } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
                 runtimeVisibleAnnotationsOffset = currentAttributeOffset;
             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
@@ -525,10 +542,13 @@
                         readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);
             } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
                 runtimeInvisibleAnnotationsOffset = currentAttributeOffset;
             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
                 runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;
+            } else if (Constants.RECORD.equals(attributeName)) {
+                recordOffset = currentAttributeOffset;
+                accessFlags |= Opcodes.ACC_RECORD;
             } else if (Constants.MODULE.equals(attributeName)) {
                 moduleOffset = currentAttributeOffset;
             } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {
                 moduleMainClass = readClass(currentAttributeOffset, charBuffer);
             } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {
@@ -682,10 +702,21 @@
                 classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));
                 currentNestMemberOffset += 2;
             }
         }
 
+        // Visit the PermittedSubtypes attribute.
+        if (permittedSubtypesOffset != 0) {
+            int numberOfPermittedSubtypes = readUnsignedShort(permittedSubtypesOffset);
+            int currentPermittedSubtypeOffset = permittedSubtypesOffset + 2;
+            while (numberOfPermittedSubtypes-- > 0) {
+                classVisitor.visitPermittedSubtypeExperimental(
+                        readClass(currentPermittedSubtypeOffset, charBuffer));
+                currentPermittedSubtypeOffset += 2;
+            }
+        }
+
         // Visit the InnerClasses attribute.
         if (innerClassesOffset != 0) {
             int numberOfClasses = readUnsignedShort(innerClassesOffset);
             int currentClassesOffset = innerClassesOffset + 2;
             while (numberOfClasses-- > 0) {
@@ -696,10 +727,19 @@
                         readUnsignedShort(currentClassesOffset + 6));
                 currentClassesOffset += 8;
             }
         }
 
+        // Visit Record components.
+        if (recordOffset != 0) {
+            int recordComponentsCount = readUnsignedShort(recordOffset);
+            recordOffset += 2;
+            while (recordComponentsCount-- > 0) {
+                recordOffset = readRecordComponent(classVisitor, context, recordOffset);
+            }
+        }
+
         // Visit the fields and methods.
         int fieldsCount = readUnsignedShort(currentOffset);
         currentOffset += 2;
         while (fieldsCount-- > 0) {
             currentOffset = readField(classVisitor, context, currentOffset);
@@ -725,11 +765,12 @@
       * @param context information about the class being parsed.
       * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's
       *     attribute_name_index and attribute_length fields).
       * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the
       *     attribute_info's attribute_name_index and attribute_length fields), or 0.
-      * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or null.
+      * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal
+      *     null}.
       */
     private void readModuleAttributes(
             final ClassVisitor classVisitor,
             final Context context,
             final int moduleOffset,
@@ -842,10 +883,184 @@
 
         // Visit the end of the module attributes.
         moduleVisitor.visitEnd();
     }
 
+    /**
+      * Reads a record component and visit it.
+      *
+      * @param classVisitor the current class visitor
+      * @param context information about the class being parsed.
+      * @param recordComponentOffset the offset of the current record component.
+      * @return the offset of the first byte following the record component.
+      */
+    private int readRecordComponent(
+            final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {
+        char[] charBuffer = context.charBuffer;
+
+        int currentOffset = recordComponentOffset;
+        String name = readUTF8(currentOffset, charBuffer);
+        String descriptor = readUTF8(currentOffset + 2, charBuffer);
+        currentOffset += 4;
+
+        // Read the record component attributes (the variables are ordered as in Section 4.7 of the
+        // JVMS).
+
+        // Attribute offsets exclude the attribute_name_index and attribute_length fields.
+        // - The string corresponding to the Signature attribute, or null.
+        String signature = null;
+        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
+        int runtimeVisibleAnnotationsOffset = 0;
+        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
+        int runtimeInvisibleAnnotationsOffset = 0;
+        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
+        int runtimeVisibleTypeAnnotationsOffset = 0;
+        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
+        int runtimeInvisibleTypeAnnotationsOffset = 0;
+        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
+        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.
+        Attribute attributes = null;
+
+        int attributesCount = readUnsignedShort(currentOffset);
+        currentOffset += 2;
+        while (attributesCount-- > 0) {
+            // Read the attribute_info's attribute_name and attribute_length fields.
+            String attributeName = readUTF8(currentOffset, charBuffer);
+            int attributeLength = readInt(currentOffset + 2);
+            currentOffset += 6;
+            // The tests are sorted in decreasing frequency order (based on frequencies observed on
+            // typical classes).
+            if (Constants.SIGNATURE.equals(attributeName)) {
+                signature = readUTF8(currentOffset, charBuffer);
+            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
+                runtimeVisibleAnnotationsOffset = currentOffset;
+            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
+                runtimeVisibleTypeAnnotationsOffset = currentOffset;
+            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
+                runtimeInvisibleAnnotationsOffset = currentOffset;
+            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
+                runtimeInvisibleTypeAnnotationsOffset = currentOffset;
+            } else {
+                Attribute attribute =
+                        readAttribute(
+                                context.attributePrototypes,
+                                attributeName,
+                                currentOffset,
+                                attributeLength,
+                                charBuffer,
+                                -1,
+                                null);
+                attribute.nextAttribute = attributes;
+                attributes = attribute;
+            }
+            currentOffset += attributeLength;
+        }
+
+        RecordComponentVisitor recordComponentVisitor =
+                classVisitor.visitRecordComponent(name, descriptor, signature);
+        if (recordComponentVisitor == null) {
+            return currentOffset;
+        }
+
+        // Visit the RuntimeVisibleAnnotations attribute.
+        if (runtimeVisibleAnnotationsOffset != 0) {
+            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);
+            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;
+            while (numAnnotations-- > 0) {
+                // Parse the type_index field.
+                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
+                currentAnnotationOffset += 2;
+                // Parse num_element_value_pairs and element_value_pairs and visit these values.
+                currentAnnotationOffset =
+                        readElementValues(
+                                recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),
+                                currentAnnotationOffset,
+                                /* named = */ true,
+                                charBuffer);
+            }
+        }
+
+        // Visit the RuntimeInvisibleAnnotations attribute.
+        if (runtimeInvisibleAnnotationsOffset != 0) {
+            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);
+            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;
+            while (numAnnotations-- > 0) {
+                // Parse the type_index field.
+                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
+                currentAnnotationOffset += 2;
+                // Parse num_element_value_pairs and element_value_pairs and visit these values.
+                currentAnnotationOffset =
+                        readElementValues(
+                                recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),
+                                currentAnnotationOffset,
+                                /* named = */ true,
+                                charBuffer);
+            }
+        }
+
+        // Visit the RuntimeVisibleTypeAnnotations attribute.
+        if (runtimeVisibleTypeAnnotationsOffset != 0) {
+            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);
+            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;
+            while (numAnnotations-- > 0) {
+                // Parse the target_type, target_info and target_path fields.
+                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
+                // Parse the type_index field.
+                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
+                currentAnnotationOffset += 2;
+                // Parse num_element_value_pairs and element_value_pairs and visit these values.
+                currentAnnotationOffset =
+                        readElementValues(
+                                recordComponentVisitor.visitTypeAnnotation(
+                                        context.currentTypeAnnotationTarget,
+                                        context.currentTypeAnnotationTargetPath,
+                                        annotationDescriptor,
+                                        /* visible = */ true),
+                                currentAnnotationOffset,
+                                /* named = */ true,
+                                charBuffer);
+            }
+        }
+
+        // Visit the RuntimeInvisibleTypeAnnotations attribute.
+        if (runtimeInvisibleTypeAnnotationsOffset != 0) {
+            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);
+            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;
+            while (numAnnotations-- > 0) {
+                // Parse the target_type, target_info and target_path fields.
+                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
+                // Parse the type_index field.
+                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
+                currentAnnotationOffset += 2;
+                // Parse num_element_value_pairs and element_value_pairs and visit these values.
+                currentAnnotationOffset =
+                        readElementValues(
+                                recordComponentVisitor.visitTypeAnnotation(
+                                        context.currentTypeAnnotationTarget,
+                                        context.currentTypeAnnotationTargetPath,
+                                        annotationDescriptor,
+                                        /* visible = */ false),
+                                currentAnnotationOffset,
+                                /* named = */ true,
+                                charBuffer);
+            }
+        }
+
+        // Visit the non standard attributes.
+        while (attributes != null) {
+            // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.
+            Attribute nextAttribute = attributes.nextAttribute;
+            attributes.nextAttribute = null;
+            recordComponentVisitor.visitAttribute(attributes);
+            attributes = nextAttribute;
+        }
+
+        // Visit the end of the field.
+        recordComponentVisitor.visitEnd();
+        return currentOffset;
+    }
+
     /**
       * Reads a JVMS field_info structure and makes the given visitor visit it.
       *
       * @param classVisitor the visitor that must visit the field.
       * @param context information about the class being parsed.
@@ -1157,23 +1372,22 @@
         // the content of these attributes.
         if (methodVisitor instanceof MethodWriter) {
             MethodWriter methodWriter = (MethodWriter) methodVisitor;
             if (methodWriter.canCopyMethodAttributes(
                     this,
-                    methodInfoOffset,
-                    currentOffset - methodInfoOffset,
                     synthetic,
                     (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0,
                     readUnsignedShort(methodInfoOffset + 4),
                     signatureIndex,
                     exceptionsOffset)) {
+                methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);
                 return currentOffset;
             }
         }
 
         // Visit the MethodParameters attribute.
-        if (methodParametersOffset != 0) {
+        if (methodParametersOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {
             int parametersCount = readByte(methodParametersOffset);
             int currentParameterOffset = methodParametersOffset + 1;
             while (parametersCount-- > 0) {
                 // Read the name_index and access_flags fields and visit them.
                 methodVisitor.visitParameter(
@@ -1318,19 +1532,19 @@
     /**
       * Reads a JVMS 'Code' attribute and makes the given visitor visit it.
       *
       * @param methodVisitor the visitor that must visit the Code attribute.
       * @param context information about the class being parsed.
-      * @param codeOffset the start offset in {@link #b} of the Code attribute, excluding its
-      *     attribute_name_index and attribute_length fields.
+      * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding
+      *     its attribute_name_index and attribute_length fields.
       */
     private void readCode(
             final MethodVisitor methodVisitor, final Context context, final int codeOffset) {
         int currentOffset = codeOffset;
 
         // Read the max_stack, max_locals and code_length fields.
-        final byte[] classFileBuffer = b;
+        final byte[] classBuffer = classFileBuffer;
         final char[] charBuffer = context.charBuffer;
         final int maxStack = readUnsignedShort(currentOffset);
         final int maxLocals = readUnsignedShort(currentOffset + 2);
         final int codeLength = readInt(currentOffset + 4);
         currentOffset += 8;
@@ -1339,119 +1553,119 @@
         final int bytecodeStartOffset = currentOffset;
         final int bytecodeEndOffset = currentOffset + codeLength;
         final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];
         while (currentOffset < bytecodeEndOffset) {
             final int bytecodeOffset = currentOffset - bytecodeStartOffset;
-            final int opcode = classFileBuffer[currentOffset] & 0xFF;
+            final int opcode = classBuffer[currentOffset] & 0xFF;
             switch (opcode) {
-                case Constants.NOP:
-                case Constants.ACONST_NULL:
-                case Constants.ICONST_M1:
-                case Constants.ICONST_0:
-                case Constants.ICONST_1:
-                case Constants.ICONST_2:
-                case Constants.ICONST_3:
-                case Constants.ICONST_4:
-                case Constants.ICONST_5:
-                case Constants.LCONST_0:
-                case Constants.LCONST_1:
-                case Constants.FCONST_0:
-                case Constants.FCONST_1:
-                case Constants.FCONST_2:
-                case Constants.DCONST_0:
-                case Constants.DCONST_1:
-                case Constants.IALOAD:
-                case Constants.LALOAD:
-                case Constants.FALOAD:
-                case Constants.DALOAD:
-                case Constants.AALOAD:
-                case Constants.BALOAD:
-                case Constants.CALOAD:
-                case Constants.SALOAD:
-                case Constants.IASTORE:
-                case Constants.LASTORE:
-                case Constants.FASTORE:
-                case Constants.DASTORE:
-                case Constants.AASTORE:
-                case Constants.BASTORE:
-                case Constants.CASTORE:
-                case Constants.SASTORE:
-                case Constants.POP:
-                case Constants.POP2:
-                case Constants.DUP:
-                case Constants.DUP_X1:
-                case Constants.DUP_X2:
-                case Constants.DUP2:
-                case Constants.DUP2_X1:
-                case Constants.DUP2_X2:
-                case Constants.SWAP:
-                case Constants.IADD:
-                case Constants.LADD:
-                case Constants.FADD:
-                case Constants.DADD:
-                case Constants.ISUB:
-                case Constants.LSUB:
-                case Constants.FSUB:
-                case Constants.DSUB:
-                case Constants.IMUL:
-                case Constants.LMUL:
-                case Constants.FMUL:
-                case Constants.DMUL:
-                case Constants.IDIV:
-                case Constants.LDIV:
-                case Constants.FDIV:
-                case Constants.DDIV:
-                case Constants.IREM:
-                case Constants.LREM:
-                case Constants.FREM:
-                case Constants.DREM:
-                case Constants.INEG:
-                case Constants.LNEG:
-                case Constants.FNEG:
-                case Constants.DNEG:
-                case Constants.ISHL:
-                case Constants.LSHL:
-                case Constants.ISHR:
-                case Constants.LSHR:
-                case Constants.IUSHR:
-                case Constants.LUSHR:
-                case Constants.IAND:
-                case Constants.LAND:
-                case Constants.IOR:
-                case Constants.LOR:
-                case Constants.IXOR:
-                case Constants.LXOR:
-                case Constants.I2L:
-                case Constants.I2F:
-                case Constants.I2D:
-                case Constants.L2I:
-                case Constants.L2F:
-                case Constants.L2D:
-                case Constants.F2I:
-                case Constants.F2L:
-                case Constants.F2D:
-                case Constants.D2I:
-                case Constants.D2L:
-                case Constants.D2F:
-                case Constants.I2B:
-                case Constants.I2C:
-                case Constants.I2S:
-                case Constants.LCMP:
-                case Constants.FCMPL:
-                case Constants.FCMPG:
-                case Constants.DCMPL:
-                case Constants.DCMPG:
-                case Constants.IRETURN:
-                case Constants.LRETURN:
-                case Constants.FRETURN:
-                case Constants.DRETURN:
-                case Constants.ARETURN:
-                case Constants.RETURN:
-                case Constants.ARRAYLENGTH:
-                case Constants.ATHROW:
-                case Constants.MONITORENTER:
-                case Constants.MONITOREXIT:
+                case Opcodes.NOP:
+                case Opcodes.ACONST_NULL:
+                case Opcodes.ICONST_M1:
+                case Opcodes.ICONST_0:
+                case Opcodes.ICONST_1:
+                case Opcodes.ICONST_2:
+                case Opcodes.ICONST_3:
+                case Opcodes.ICONST_4:
+                case Opcodes.ICONST_5:
+                case Opcodes.LCONST_0:
+                case Opcodes.LCONST_1:
+                case Opcodes.FCONST_0:
+                case Opcodes.FCONST_1:
+                case Opcodes.FCONST_2:
+                case Opcodes.DCONST_0:
+                case Opcodes.DCONST_1:
+                case Opcodes.IALOAD:
+                case Opcodes.LALOAD:
+                case Opcodes.FALOAD:
+                case Opcodes.DALOAD:
+                case Opcodes.AALOAD:
+                case Opcodes.BALOAD:
+                case Opcodes.CALOAD:
+                case Opcodes.SALOAD:
+                case Opcodes.IASTORE:
+                case Opcodes.LASTORE:
+                case Opcodes.FASTORE:
+                case Opcodes.DASTORE:
+                case Opcodes.AASTORE:
+                case Opcodes.BASTORE:
+                case Opcodes.CASTORE:
+                case Opcodes.SASTORE:
+                case Opcodes.POP:
+                case Opcodes.POP2:
+                case Opcodes.DUP:
+                case Opcodes.DUP_X1:
+                case Opcodes.DUP_X2:
+                case Opcodes.DUP2:
+                case Opcodes.DUP2_X1:
+                case Opcodes.DUP2_X2:
+                case Opcodes.SWAP:
+                case Opcodes.IADD:
+                case Opcodes.LADD:
+                case Opcodes.FADD:
+                case Opcodes.DADD:
+                case Opcodes.ISUB:
+                case Opcodes.LSUB:
+                case Opcodes.FSUB:
+                case Opcodes.DSUB:
+                case Opcodes.IMUL:
+                case Opcodes.LMUL:
+                case Opcodes.FMUL:
+                case Opcodes.DMUL:
+                case Opcodes.IDIV:
+                case Opcodes.LDIV:
+                case Opcodes.FDIV:
+                case Opcodes.DDIV:
+                case Opcodes.IREM:
+                case Opcodes.LREM:
+                case Opcodes.FREM:
+                case Opcodes.DREM:
+                case Opcodes.INEG:
+                case Opcodes.LNEG:
+                case Opcodes.FNEG:
+                case Opcodes.DNEG:
+                case Opcodes.ISHL:
+                case Opcodes.LSHL:
+                case Opcodes.ISHR:
+                case Opcodes.LSHR:
+                case Opcodes.IUSHR:
+                case Opcodes.LUSHR:
+                case Opcodes.IAND:
+                case Opcodes.LAND:
+                case Opcodes.IOR:
+                case Opcodes.LOR:
+                case Opcodes.IXOR:
+                case Opcodes.LXOR:
+                case Opcodes.I2L:
+                case Opcodes.I2F:
+                case Opcodes.I2D:
+                case Opcodes.L2I:
+                case Opcodes.L2F:
+                case Opcodes.L2D:
+                case Opcodes.F2I:
+                case Opcodes.F2L:
+                case Opcodes.F2D:
+                case Opcodes.D2I:
+                case Opcodes.D2L:
+                case Opcodes.D2F:
+                case Opcodes.I2B:
+                case Opcodes.I2C:
+                case Opcodes.I2S:
+                case Opcodes.LCMP:
+                case Opcodes.FCMPL:
+                case Opcodes.FCMPG:
+                case Opcodes.DCMPL:
+                case Opcodes.DCMPG:
+                case Opcodes.IRETURN:
+                case Opcodes.LRETURN:
+                case Opcodes.FRETURN:
+                case Opcodes.DRETURN:
+                case Opcodes.ARETURN:
+                case Opcodes.RETURN:
+                case Opcodes.ARRAYLENGTH:
+                case Opcodes.ATHROW:
+                case Opcodes.MONITORENTER:
+                case Opcodes.MONITOREXIT:
                 case Constants.ILOAD_0:
                 case Constants.ILOAD_1:
                 case Constants.ILOAD_2:
                 case Constants.ILOAD_3:
                 case Constants.LLOAD_0:
@@ -1490,28 +1704,28 @@
                 case Constants.ASTORE_1:
                 case Constants.ASTORE_2:
                 case Constants.ASTORE_3:
                     currentOffset += 1;
                     break;
-                case Constants.IFEQ:
-                case Constants.IFNE:
-                case Constants.IFLT:
-                case Constants.IFGE:
-                case Constants.IFGT:
-                case Constants.IFLE:
-                case Constants.IF_ICMPEQ:
-                case Constants.IF_ICMPNE:
-                case Constants.IF_ICMPLT:
-                case Constants.IF_ICMPGE:
-                case Constants.IF_ICMPGT:
-                case Constants.IF_ICMPLE:
-                case Constants.IF_ACMPEQ:
-                case Constants.IF_ACMPNE:
-                case Constants.GOTO:
-                case Constants.JSR:
-                case Constants.IFNULL:
-                case Constants.IFNONNULL:
+                case Opcodes.IFEQ:
+                case Opcodes.IFNE:
+                case Opcodes.IFLT:
+                case Opcodes.IFGE:
+                case Opcodes.IFGT:
+                case Opcodes.IFLE:
+                case Opcodes.IF_ICMPEQ:
+                case Opcodes.IF_ICMPNE:
+                case Opcodes.IF_ICMPLT:
+                case Opcodes.IF_ICMPGE:
+                case Opcodes.IF_ICMPGT:
+                case Opcodes.IF_ICMPLE:
+                case Opcodes.IF_ACMPEQ:
+                case Opcodes.IF_ACMPNE:
+                case Opcodes.GOTO:
+                case Opcodes.JSR:
+                case Opcodes.IFNULL:
+                case Opcodes.IFNONNULL:
                     createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);
                     currentOffset += 3;
                     break;
                 case Constants.ASM_IFEQ:
                 case Constants.ASM_IFNE:
@@ -1539,32 +1753,32 @@
                 case Constants.ASM_GOTO_W:
                     createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);
                     currentOffset += 5;
                     break;
                 case Constants.WIDE:
-                    switch (classFileBuffer[currentOffset + 1] & 0xFF) {
-                        case Constants.ILOAD:
-                        case Constants.FLOAD:
-                        case Constants.ALOAD:
-                        case Constants.LLOAD:
-                        case Constants.DLOAD:
-                        case Constants.ISTORE:
-                        case Constants.FSTORE:
-                        case Constants.ASTORE:
-                        case Constants.LSTORE:
-                        case Constants.DSTORE:
-                        case Constants.RET:
+                    switch (classBuffer[currentOffset + 1] & 0xFF) {
+                        case Opcodes.ILOAD:
+                        case Opcodes.FLOAD:
+                        case Opcodes.ALOAD:
+                        case Opcodes.LLOAD:
+                        case Opcodes.DLOAD:
+                        case Opcodes.ISTORE:
+                        case Opcodes.FSTORE:
+                        case Opcodes.ASTORE:
+                        case Opcodes.LSTORE:
+                        case Opcodes.DSTORE:
+                        case Opcodes.RET:
                             currentOffset += 4;
                             break;
-                        case Constants.IINC:
+                        case Opcodes.IINC:
                             currentOffset += 6;
                             break;
                         default:
                             throw new IllegalArgumentException();
                     }
                     break;
-                case Constants.TABLESWITCH:
+                case Opcodes.TABLESWITCH:
                     // Skip 0 to 3 padding bytes.
                     currentOffset += 4 - (bytecodeOffset & 3);
                     // Read the default label and the number of table entries.
                     createLabel(bytecodeOffset + readInt(currentOffset), labels);
                     int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;
@@ -1573,11 +1787,11 @@
                     while (numTableEntries-- > 0) {
                         createLabel(bytecodeOffset + readInt(currentOffset), labels);
                         currentOffset += 4;
                     }
                     break;
-                case Constants.LOOKUPSWITCH:
+                case Opcodes.LOOKUPSWITCH:
                     // Skip 0 to 3 padding bytes.
                     currentOffset += 4 - (bytecodeOffset & 3);
                     // Read the default label and the number of switch cases.
                     createLabel(bytecodeOffset + readInt(currentOffset), labels);
                     int numSwitchCases = readInt(currentOffset + 4);
@@ -1586,50 +1800,50 @@
                     while (numSwitchCases-- > 0) {
                         createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);
                         currentOffset += 8;
                     }
                     break;
-                case Constants.ILOAD:
-                case Constants.LLOAD:
-                case Constants.FLOAD:
-                case Constants.DLOAD:
-                case Constants.ALOAD:
-                case Constants.ISTORE:
-                case Constants.LSTORE:
-                case Constants.FSTORE:
-                case Constants.DSTORE:
-                case Constants.ASTORE:
-                case Constants.RET:
-                case Constants.BIPUSH:
-                case Constants.NEWARRAY:
-                case Constants.LDC:
+                case Opcodes.ILOAD:
+                case Opcodes.LLOAD:
+                case Opcodes.FLOAD:
+                case Opcodes.DLOAD:
+                case Opcodes.ALOAD:
+                case Opcodes.ISTORE:
+                case Opcodes.LSTORE:
+                case Opcodes.FSTORE:
+                case Opcodes.DSTORE:
+                case Opcodes.ASTORE:
+                case Opcodes.RET:
+                case Opcodes.BIPUSH:
+                case Opcodes.NEWARRAY:
+                case Opcodes.LDC:
                     currentOffset += 2;
                     break;
-                case Constants.SIPUSH:
+                case Opcodes.SIPUSH:
                 case Constants.LDC_W:
                 case Constants.LDC2_W:
-                case Constants.GETSTATIC:
-                case Constants.PUTSTATIC:
-                case Constants.GETFIELD:
-                case Constants.PUTFIELD:
-                case Constants.DEFAULT:
-                case Constants.WITHFIELD:
-                case Constants.INVOKEVIRTUAL:
-                case Constants.INVOKESPECIAL:
-                case Constants.INVOKESTATIC:
-                case Constants.NEW:
-                case Constants.ANEWARRAY:
-                case Constants.CHECKCAST:
-                case Constants.INSTANCEOF:
-                case Constants.IINC:
+                case Opcodes.GETSTATIC:
+                case Opcodes.PUTSTATIC:
+                case Opcodes.GETFIELD:
+                case Opcodes.PUTFIELD:
+                case Opcodes.DEFAULT:
+                case Opcodes.WITHFIELD:
+                case Opcodes.INVOKEVIRTUAL:
+                case Opcodes.INVOKESPECIAL:
+                case Opcodes.INVOKESTATIC:
+                case Opcodes.NEW:
+                case Opcodes.ANEWARRAY:
+                case Opcodes.CHECKCAST:
+                case Opcodes.INSTANCEOF:
+                case Opcodes.IINC:
                     currentOffset += 3;
                     break;
-                case Constants.INVOKEINTERFACE:
-                case Constants.INVOKEDYNAMIC:
+                case Opcodes.INVOKEINTERFACE:
+                case Opcodes.INVOKEDYNAMIC:
                     currentOffset += 5;
                     break;
-                case Constants.MULTIANEWARRAY:
+                case Opcodes.MULTIANEWARRAY:
                     currentOffset += 4;
                     break;
                 default:
                     throw new IllegalArgumentException();
             }
@@ -1790,15 +2004,15 @@
             // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,
             // and the only consequence will be the creation of an unneeded label. This is better than
             // creating a label for each NEW instruction, and faster than fully decoding the whole stack
             // map table.
             for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {
-                if (classFileBuffer[offset] == Frame.ITEM_UNINITIALIZED) {
+                if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {
                     int potentialBytecodeOffset = readUnsignedShort(offset + 1);
                     if (potentialBytecodeOffset >= 0
                             && potentialBytecodeOffset < codeLength
-                            && (classFileBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF)
+                            && (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF)
                                     == Opcodes.NEW) {
                         createLabel(potentialBytecodeOffset, labels);
                     }
                 }
             }
@@ -1890,119 +2104,119 @@
                 }
                 insertFrame = false;
             }
 
             // Visit the instruction at this bytecode offset.
-            int opcode = classFileBuffer[currentOffset] & 0xFF;
+            int opcode = classBuffer[currentOffset] & 0xFF;
             switch (opcode) {
-                case Constants.NOP:
-                case Constants.ACONST_NULL:
-                case Constants.ICONST_M1:
-                case Constants.ICONST_0:
-                case Constants.ICONST_1:
-                case Constants.ICONST_2:
-                case Constants.ICONST_3:
-                case Constants.ICONST_4:
-                case Constants.ICONST_5:
-                case Constants.LCONST_0:
-                case Constants.LCONST_1:
-                case Constants.FCONST_0:
-                case Constants.FCONST_1:
-                case Constants.FCONST_2:
-                case Constants.DCONST_0:
-                case Constants.DCONST_1:
-                case Constants.IALOAD:
-                case Constants.LALOAD:
-                case Constants.FALOAD:
-                case Constants.DALOAD:
-                case Constants.AALOAD:
-                case Constants.BALOAD:
-                case Constants.CALOAD:
-                case Constants.SALOAD:
-                case Constants.IASTORE:
-                case Constants.LASTORE:
-                case Constants.FASTORE:
-                case Constants.DASTORE:
-                case Constants.AASTORE:
-                case Constants.BASTORE:
-                case Constants.CASTORE:
-                case Constants.SASTORE:
-                case Constants.POP:
-                case Constants.POP2:
-                case Constants.DUP:
-                case Constants.DUP_X1:
-                case Constants.DUP_X2:
-                case Constants.DUP2:
-                case Constants.DUP2_X1:
-                case Constants.DUP2_X2:
-                case Constants.SWAP:
-                case Constants.IADD:
-                case Constants.LADD:
-                case Constants.FADD:
-                case Constants.DADD:
-                case Constants.ISUB:
-                case Constants.LSUB:
-                case Constants.FSUB:
-                case Constants.DSUB:
-                case Constants.IMUL:
-                case Constants.LMUL:
-                case Constants.FMUL:
-                case Constants.DMUL:
-                case Constants.IDIV:
-                case Constants.LDIV:
-                case Constants.FDIV:
-                case Constants.DDIV:
-                case Constants.IREM:
-                case Constants.LREM:
-                case Constants.FREM:
-                case Constants.DREM:
-                case Constants.INEG:
-                case Constants.LNEG:
-                case Constants.FNEG:
-                case Constants.DNEG:
-                case Constants.ISHL:
-                case Constants.LSHL:
-                case Constants.ISHR:
-                case Constants.LSHR:
-                case Constants.IUSHR:
-                case Constants.LUSHR:
-                case Constants.IAND:
-                case Constants.LAND:
-                case Constants.IOR:
-                case Constants.LOR:
-                case Constants.IXOR:
-                case Constants.LXOR:
-                case Constants.I2L:
-                case Constants.I2F:
-                case Constants.I2D:
-                case Constants.L2I:
-                case Constants.L2F:
-                case Constants.L2D:
-                case Constants.F2I:
-                case Constants.F2L:
-                case Constants.F2D:
-                case Constants.D2I:
-                case Constants.D2L:
-                case Constants.D2F:
-                case Constants.I2B:
-                case Constants.I2C:
-                case Constants.I2S:
-                case Constants.LCMP:
-                case Constants.FCMPL:
-                case Constants.FCMPG:
-                case Constants.DCMPL:
-                case Constants.DCMPG:
-                case Constants.IRETURN:
-                case Constants.LRETURN:
-                case Constants.FRETURN:
-                case Constants.DRETURN:
-                case Constants.ARETURN:
-                case Constants.RETURN:
-                case Constants.ARRAYLENGTH:
-                case Constants.ATHROW:
-                case Constants.MONITORENTER:
-                case Constants.MONITOREXIT:
+                case Opcodes.NOP:
+                case Opcodes.ACONST_NULL:
+                case Opcodes.ICONST_M1:
+                case Opcodes.ICONST_0:
+                case Opcodes.ICONST_1:
+                case Opcodes.ICONST_2:
+                case Opcodes.ICONST_3:
+                case Opcodes.ICONST_4:
+                case Opcodes.ICONST_5:
+                case Opcodes.LCONST_0:
+                case Opcodes.LCONST_1:
+                case Opcodes.FCONST_0:
+                case Opcodes.FCONST_1:
+                case Opcodes.FCONST_2:
+                case Opcodes.DCONST_0:
+                case Opcodes.DCONST_1:
+                case Opcodes.IALOAD:
+                case Opcodes.LALOAD:
+                case Opcodes.FALOAD:
+                case Opcodes.DALOAD:
+                case Opcodes.AALOAD:
+                case Opcodes.BALOAD:
+                case Opcodes.CALOAD:
+                case Opcodes.SALOAD:
+                case Opcodes.IASTORE:
+                case Opcodes.LASTORE:
+                case Opcodes.FASTORE:
+                case Opcodes.DASTORE:
+                case Opcodes.AASTORE:
+                case Opcodes.BASTORE:
+                case Opcodes.CASTORE:
+                case Opcodes.SASTORE:
+                case Opcodes.POP:
+                case Opcodes.POP2:
+                case Opcodes.DUP:
+                case Opcodes.DUP_X1:
+                case Opcodes.DUP_X2:
+                case Opcodes.DUP2:
+                case Opcodes.DUP2_X1:
+                case Opcodes.DUP2_X2:
+                case Opcodes.SWAP:
+                case Opcodes.IADD:
+                case Opcodes.LADD:
+                case Opcodes.FADD:
+                case Opcodes.DADD:
+                case Opcodes.ISUB:
+                case Opcodes.LSUB:
+                case Opcodes.FSUB:
+                case Opcodes.DSUB:
+                case Opcodes.IMUL:
+                case Opcodes.LMUL:
+                case Opcodes.FMUL:
+                case Opcodes.DMUL:
+                case Opcodes.IDIV:
+                case Opcodes.LDIV:
+                case Opcodes.FDIV:
+                case Opcodes.DDIV:
+                case Opcodes.IREM:
+                case Opcodes.LREM:
+                case Opcodes.FREM:
+                case Opcodes.DREM:
+                case Opcodes.INEG:
+                case Opcodes.LNEG:
+                case Opcodes.FNEG:
+                case Opcodes.DNEG:
+                case Opcodes.ISHL:
+                case Opcodes.LSHL:
+                case Opcodes.ISHR:
+                case Opcodes.LSHR:
+                case Opcodes.IUSHR:
+                case Opcodes.LUSHR:
+                case Opcodes.IAND:
+                case Opcodes.LAND:
+                case Opcodes.IOR:
+                case Opcodes.LOR:
+                case Opcodes.IXOR:
+                case Opcodes.LXOR:
+                case Opcodes.I2L:
+                case Opcodes.I2F:
+                case Opcodes.I2D:
+                case Opcodes.L2I:
+                case Opcodes.L2F:
+                case Opcodes.L2D:
+                case Opcodes.F2I:
+                case Opcodes.F2L:
+                case Opcodes.F2D:
+                case Opcodes.D2I:
+                case Opcodes.D2L:
+                case Opcodes.D2F:
+                case Opcodes.I2B:
+                case Opcodes.I2C:
+                case Opcodes.I2S:
+                case Opcodes.LCMP:
+                case Opcodes.FCMPL:
+                case Opcodes.FCMPG:
+                case Opcodes.DCMPL:
+                case Opcodes.DCMPG:
+                case Opcodes.IRETURN:
+                case Opcodes.LRETURN:
+                case Opcodes.FRETURN:
+                case Opcodes.DRETURN:
+                case Opcodes.ARETURN:
+                case Opcodes.RETURN:
+                case Opcodes.ARRAYLENGTH:
+                case Opcodes.ATHROW:
+                case Opcodes.MONITORENTER:
+                case Opcodes.MONITOREXIT:
                     methodVisitor.visitInsn(opcode);
                     currentOffset += 1;
                     break;
                 case Constants.ILOAD_0:
                 case Constants.ILOAD_1:
@@ -2050,28 +2264,28 @@
                 case Constants.ASTORE_3:
                     opcode -= Constants.ISTORE_0;
                     methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);
                     currentOffset += 1;
                     break;
-                case Constants.IFEQ:
-                case Constants.IFNE:
-                case Constants.IFLT:
-                case Constants.IFGE:
-                case Constants.IFGT:
-                case Constants.IFLE:
-                case Constants.IF_ICMPEQ:
-                case Constants.IF_ICMPNE:
-                case Constants.IF_ICMPLT:
-                case Constants.IF_ICMPGE:
-                case Constants.IF_ICMPGT:
-                case Constants.IF_ICMPLE:
-                case Constants.IF_ACMPEQ:
-                case Constants.IF_ACMPNE:
-                case Constants.GOTO:
-                case Constants.JSR:
-                case Constants.IFNULL:
-                case Constants.IFNONNULL:
+                case Opcodes.IFEQ:
+                case Opcodes.IFNE:
+                case Opcodes.IFLT:
+                case Opcodes.IFGE:
+                case Opcodes.IFGT:
+                case Opcodes.IFLE:
+                case Opcodes.IF_ICMPEQ:
+                case Opcodes.IF_ICMPNE:
+                case Opcodes.IF_ICMPLT:
+                case Opcodes.IF_ICMPGE:
+                case Opcodes.IF_ICMPGT:
+                case Opcodes.IF_ICMPLE:
+                case Opcodes.IF_ACMPEQ:
+                case Opcodes.IF_ACMPNE:
+                case Opcodes.GOTO:
+                case Opcodes.JSR:
+                case Opcodes.IFNULL:
+                case Opcodes.IFNONNULL:
                     methodVisitor.visitJumpInsn(
                             opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);
                     currentOffset += 3;
                     break;
                 case Constants.GOTO_W:
@@ -2128,33 +2342,31 @@
                         }
                         currentOffset += 3;
                         break;
                     }
                 case Constants.ASM_GOTO_W:
-                    {
-                        // Replace ASM_GOTO_W with GOTO_W.
-                        methodVisitor.visitJumpInsn(
-                                Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);
-                        // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns
-                        // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame
-                        // here.
-                        insertFrame = true;
-                        currentOffset += 5;
-                        break;
-                    }
+                    // Replace ASM_GOTO_W with GOTO_W.
+                    methodVisitor.visitJumpInsn(
+                            Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);
+                    // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns
+                    // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame
+                    // here.
+                    insertFrame = true;
+                    currentOffset += 5;
+                    break;
                 case Constants.WIDE:
-                    opcode = classFileBuffer[currentOffset + 1] & 0xFF;
+                    opcode = classBuffer[currentOffset + 1] & 0xFF;
                     if (opcode == Opcodes.IINC) {
                         methodVisitor.visitIincInsn(
                                 readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));
                         currentOffset += 6;
                     } else {
                         methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));
                         currentOffset += 4;
                     }
                     break;
-                case Constants.TABLESWITCH:
+                case Opcodes.TABLESWITCH:
                     {
                         // Skip 0 to 3 padding bytes.
                         currentOffset += 4 - (currentBytecodeOffset & 3);
                         // Read the instruction.
                         Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
@@ -2167,11 +2379,11 @@
                             currentOffset += 4;
                         }
                         methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);
                         break;
                     }
-                case Constants.LOOKUPSWITCH:
+                case Opcodes.LOOKUPSWITCH:
                     {
                         // Skip 0 to 3 padding bytes.
                         currentOffset += 4 - (currentBytecodeOffset & 3);
                         // Read the instruction.
                         Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
@@ -2185,61 +2397,60 @@
                             currentOffset += 8;
                         }
                         methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);
                         break;
                     }
-                case Constants.ILOAD:
-                case Constants.LLOAD:
-                case Constants.FLOAD:
-                case Constants.DLOAD:
-                case Constants.ALOAD:
-                case Constants.ISTORE:
-                case Constants.LSTORE:
-                case Constants.FSTORE:
-                case Constants.DSTORE:
-                case Constants.ASTORE:
-                case Constants.RET:
-                    methodVisitor.visitVarInsn(opcode, classFileBuffer[currentOffset + 1] & 0xFF);
+                case Opcodes.ILOAD:
+                case Opcodes.LLOAD:
+                case Opcodes.FLOAD:
+                case Opcodes.DLOAD:
+                case Opcodes.ALOAD:
+                case Opcodes.ISTORE:
+                case Opcodes.LSTORE:
+                case Opcodes.FSTORE:
+                case Opcodes.DSTORE:
+                case Opcodes.ASTORE:
+                case Opcodes.RET:
+                    methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] & 0xFF);
                     currentOffset += 2;
                     break;
-                case Constants.BIPUSH:
-                case Constants.NEWARRAY:
-                    methodVisitor.visitIntInsn(opcode, classFileBuffer[currentOffset + 1]);
+                case Opcodes.BIPUSH:
+                case Opcodes.NEWARRAY:
+                    methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);
                     currentOffset += 2;
                     break;
-                case Constants.SIPUSH:
+                case Opcodes.SIPUSH:
                     methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));
                     currentOffset += 3;
                     break;
-                case Constants.LDC:
-                    methodVisitor.visitLdcInsn(
-                            readConst(classFileBuffer[currentOffset + 1] & 0xFF, charBuffer));
+                case Opcodes.LDC:
+                    methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] & 0xFF, charBuffer));
                     currentOffset += 2;
                     break;
                 case Constants.LDC_W:
                 case Constants.LDC2_W:
                     methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));
                     currentOffset += 3;
                     break;
-                case Constants.GETSTATIC:
-                case Constants.PUTSTATIC:
-                case Constants.GETFIELD:
-                case Constants.PUTFIELD:
-                case Constants.INVOKEVIRTUAL:
-                case Constants.INVOKESPECIAL:
-                case Constants.INVOKESTATIC:
-                case Constants.INVOKEINTERFACE:
-                case Constants.WITHFIELD:
+                case Opcodes.GETSTATIC:
+                case Opcodes.PUTSTATIC:
+                case Opcodes.GETFIELD:
+                case Opcodes.PUTFIELD:
+                case Opcodes.INVOKEVIRTUAL:
+                case Opcodes.INVOKESPECIAL:
+                case Opcodes.INVOKESTATIC:
+                case Opcodes.INVOKEINTERFACE:
+                case Opcodes.WITHFIELD:
                     {
                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
                         String owner = readClass(cpInfoOffset, charBuffer);
                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
                         if (opcode >= Opcodes.INVOKEVIRTUAL && opcode <= Opcodes.INVOKEINTERFACE) {
                             boolean isInterface =
-                                    classFileBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
+                                    classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
                             methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
                         } else {
                             methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);
                         }
                         if (opcode == Opcodes.INVOKEINTERFACE) {
@@ -2247,11 +2458,11 @@
                         } else {
                             currentOffset += 3;
                         }
                         break;
                     }
-                case Constants.INVOKEDYNAMIC:
+                case Opcodes.INVOKEDYNAMIC:
                     {
                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
@@ -2269,26 +2480,26 @@
                         methodVisitor.visitInvokeDynamicInsn(
                                 name, descriptor, handle, bootstrapMethodArguments);
                         currentOffset += 5;
                         break;
                     }
-                case Constants.NEW:
-                case Constants.ANEWARRAY:
-                case Constants.CHECKCAST:
-                case Constants.INSTANCEOF:
-                case Constants.DEFAULT:
+                case Opcodes.NEW:
+                case Opcodes.ANEWARRAY:
+                case Opcodes.CHECKCAST:
+                case Opcodes.INSTANCEOF:
+                case Opcodes.DEFAULT:
                     methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));
                     currentOffset += 3;
                     break;
-                case Constants.IINC:
+                case Opcodes.IINC:
                     methodVisitor.visitIincInsn(
-                            classFileBuffer[currentOffset + 1] & 0xFF, classFileBuffer[currentOffset + 2]);
+                            classBuffer[currentOffset + 1] & 0xFF, classBuffer[currentOffset + 2]);
                     currentOffset += 3;
                     break;
-                case Constants.MULTIANEWARRAY:
+                case Opcodes.MULTIANEWARRAY:
                     methodVisitor.visitMultiANewArrayInsn(
-                            readClass(currentOffset + 1, charBuffer), classFileBuffer[currentOffset + 3] & 0xFF);
+                            readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] & 0xFF);
                     currentOffset += 4;
                     break;
                 default:
                     throw new AssertionError();
             }
@@ -2588,11 +2799,11 @@
             // Parse the rest of the type_annotation structure, starting with the target_path structure
             // (whose size depends on its path_length field).
             int pathLength = readByte(currentOffset);
             if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {
                 // Parse the target_path structure and create a corresponding TypePath.
-                TypePath path = pathLength == 0 ? null : new TypePath(b, currentOffset);
+                TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);
                 currentOffset += 1 + 2 * pathLength;
                 // Parse the type_index field.
                 String annotationDescriptor = readUTF8(currentOffset, charBuffer);
                 currentOffset += 2;
                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
@@ -2621,11 +2832,11 @@
     /**
       * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or
       * -1 if there is no such type_annotation of if it does not have a bytecode offset.
       *
       * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a
-      *     Runtime[In]VisibleTypeAnnotations attribute, or null.
+      *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.
       * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.
       * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1
       *     if there is no such type_annotation of if it does not have a bytecode offset.
       */
     private int getTypeAnnotationBytecodeOffset(
@@ -2713,11 +2924,11 @@
         }
         context.currentTypeAnnotationTarget = targetType;
         // Parse and store the target_path structure.
         int pathLength = readByte(currentOffset);
         context.currentTypeAnnotationTargetPath =
-                pathLength == 0 ? null : new TypePath(b, currentOffset);
+                pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);
         // Return the start offset of the rest of the type_annotation structure.
         return currentOffset + 1 + 2 * pathLength;
     }
 
     /**
@@ -2735,11 +2946,11 @@
             final MethodVisitor methodVisitor,
             final Context context,
             final int runtimeParameterAnnotationsOffset,
             final boolean visible) {
         int currentOffset = runtimeParameterAnnotationsOffset;
-        int numParameters = b[currentOffset++] & 0xFF;
+        int numParameters = classFileBuffer[currentOffset++] & 0xFF;
         methodVisitor.visitAnnotableParameterCount(numParameters, visible);
         char[] charBuffer = context.charBuffer;
         for (int i = 0; i < numParameters; ++i) {
             int numAnnotations = readUnsignedShort(currentOffset);
             currentOffset += 2;
@@ -2803,12 +3014,12 @@
 
     /**
       * Reads a JVMS 'element_value' structure and makes the given visitor visit it.
       *
       * @param annotationVisitor the visitor that must visit the element_value structure.
-      * @param elementValueOffset the start offset in {@link #b} of the element_value structure to be
-      *     read.
+      * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value
+      *     structure to be read.
       * @param elementName the name of the element_value structure to be read, or {@literal null}.
       * @param charBuffer the buffer used to read strings in the constant pool.
       * @return the end offset of the JVMS 'element_value' structure.
       */
     private int readElementValue(
@@ -2816,22 +3027,22 @@
             final int elementValueOffset,
             final String elementName,
             final char[] charBuffer) {
         int currentOffset = elementValueOffset;
         if (annotationVisitor == null) {
-            switch (b[currentOffset] & 0xFF) {
+            switch (classFileBuffer[currentOffset] & 0xFF) {
                 case 'e': // enum_const_value
                     return currentOffset + 5;
                 case '@': // annotation_value
                     return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);
                 case '[': // array_value
                     return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);
                 default:
                     return currentOffset + 3;
             }
         }
-        switch (b[currentOffset++] & 0xFF) {
+        switch (classFileBuffer[currentOffset++] & 0xFF) {
             case 'B': // const_value_index, CONSTANT_Integer
                 annotationVisitor.visit(
                         elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
                 currentOffset += 2;
                 break;
@@ -2893,11 +3104,11 @@
                             annotationVisitor.visitArray(elementName),
                             currentOffset - 2,
                             /* named = */ false,
                             charBuffer);
                 }
-                switch (b[currentOffset] & 0xFF) {
+                switch (classFileBuffer[currentOffset] & 0xFF) {
                     case 'B':
                         byte[] byteValues = new byte[numValues];
                         for (int i = 0; i < numValues; i++) {
                             byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
                             currentOffset += 3;
@@ -3056,13 +3267,13 @@
     /**
       * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}
       * object. This method can also be used to read a full_frame structure, excluding its frame_type
       * field (this is used to parse the legacy StackMap attributes).
       *
-      * @param stackMapFrameOffset the start offset in {@link #b} of the stack_map_frame_value
-      *     structure to be read, or the start offset of a full_frame structure (excluding its
-      *     frame_type field).
+      * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the
+      *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure
+      *     (excluding its frame_type field).
       * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'
       *     structure without its frame_type field.
       * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.
       * @param context where the parsed stack map frame must be stored.
       * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.
@@ -3076,11 +3287,11 @@
         final char[] charBuffer = context.charBuffer;
         final Label[] labels = context.currentMethodLabels;
         int frameType;
         if (compressed) {
             // Read the frame_type field.
-            frameType = b[currentOffset++] & 0xFF;
+            frameType = classFileBuffer[currentOffset++] & 0xFF;
         } else {
             frameType = Frame.FULL_FRAME;
             context.currentFrameOffset = -1;
         }
         int offsetDelta;
@@ -3171,11 +3382,11 @@
             final Object[] frame,
             final int index,
             final char[] charBuffer,
             final Label[] labels) {
         int currentOffset = verificationTypeInfoOffset;
-        int tag = b[currentOffset++] & 0xFF;
+        int tag = classFileBuffer[currentOffset++] & 0xFF;
         switch (tag) {
             case Frame.ITEM_TOP:
                 frame[index] = Opcodes.TOP;
                 break;
             case Frame.ITEM_INTEGER:
@@ -3213,13 +3424,15 @@
     // ----------------------------------------------------------------------------------------------
     // Methods to parse attributes
     // ----------------------------------------------------------------------------------------------
 
     /**
-      * Returns the offset in {@link #b} of the first ClassFile's 'attributes' array field entry.
+      * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array
+      * field entry.
       *
-      * @return the offset in {@link #b} of the first ClassFile's 'attributes' array field entry.
+      * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array
+      *     field entry.
       */
     final int getFirstAttributeOffset() {
         // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes
         // each), as well as the interfaces array field (2 bytes per interface).
         int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;
@@ -3262,11 +3475,11 @@
     /**
       * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
       *
       * @param maxStringLength a conservative estimate of the maximum length of the strings contained
       *     in the constant pool of the class.
-      * @return the offsets of the bootstrap methods or null.
+      * @return the offsets of the bootstrap methods.
       */
     private int[] readBootstrapMethodsAttribute(final int maxStringLength) {
         char[] charBuffer = new char[maxStringLength];
         int currentAttributeOffset = getFirstAttributeOffset();
         int[] currentBootstrapMethodOffsets = null;
@@ -3289,27 +3502,29 @@
                 }
                 return currentBootstrapMethodOffsets;
             }
             currentAttributeOffset += attributeLength;
         }
-        return null;
+        throw new IllegalArgumentException();
     }
 
     /**
-      * Reads a non standard JVMS 'attribute' structure in {@link #b}.
+      * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.
       *
       * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
       *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
       *     be parsed: its byte array value will be passed unchanged to the ClassWriter.
       * @param type the type of the attribute.
-      * @param offset the start offset of the JVMS 'attribute' structure in {@link #b}. The 6 attribute
-      *     header bytes (attribute_name_index and attribute_length) are not taken into account here.
+      * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.
+      *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into
+      *     account here.
       * @param length the length of the attribute's content (excluding the 6 attribute header bytes).
       * @param charBuffer the buffer to be used to read strings in the constant pool.
-      * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link #b}, or
-      *     -1 if the attribute to be read is not a code attribute. The 6 attribute header bytes
-      *     (attribute_name_index and attribute_length) are not taken into account here.
+      * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link
+      *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6
+      *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
+      *     account here.
       * @param labels the labels of the method's code, or {@literal null} if the attribute to be read
       *     is not a code attribute.
       * @return the attribute that has been read.
       */
     private Attribute readAttribute(
@@ -3341,17 +3556,18 @@
     public int getItemCount() {
         return cpInfoOffsets.length;
     }
 
     /**
-      * Returns the start offset in {@link #b} of a JVMS 'cp_info' structure (i.e. a constant pool
-      * entry), plus one. <i>This method is intended for {@link Attribute} sub classes, and is normally
-      * not needed by class generators or adapters.</i>
+      * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a
+      * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,
+      * and is normally not needed by class generators or adapters.</i>
       *
       * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool
       *     table.
-      * @return the start offset in {@link #b} of the corresponding JVMS 'cp_info' structure, plus one.
+      * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'
+      *     structure, plus one.
       */
     public int getItem(final int constantPoolEntryIndex) {
         return cpInfoOffsets[constantPoolEntryIndex];
     }
 
@@ -3365,78 +3581,79 @@
     public int getMaxStringLength() {
         return maxStringLength;
     }
 
     /**
-      * Reads a byte value in {@link #b}. <i>This method is intended for {@link Attribute} sub classes,
-      * and is normally not needed by class generators or adapters.</i>
+      * Reads a byte value in this {@link ClassReader}. <i>This method is intended for {@link
+      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
       *
-      * @param offset the start offset of the value to be read in {@link #b}.
+      * @param offset the start offset of the value to be read in this {@link ClassReader}.
       * @return the read value.
       */
     public int readByte(final int offset) {
-        return b[offset] & 0xFF;
+        return classFileBuffer[offset] & 0xFF;
     }
 
     /**
-      * Reads an unsigned short value in {@link #b}. <i>This method is intended for {@link Attribute}
-      * sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads an unsigned short value in this {@link ClassReader}. <i>This method is intended for
+      * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
       *
-      * @param offset the start index of the value to be read in {@link #b}.
+      * @param offset the start index of the value to be read in this {@link ClassReader}.
       * @return the read value.
       */
     public int readUnsignedShort(final int offset) {
-        byte[] classFileBuffer = b;
-        return ((classFileBuffer[offset] & 0xFF) << 8) | (classFileBuffer[offset + 1] & 0xFF);
+        byte[] classBuffer = classFileBuffer;
+        return ((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF);
     }
 
     /**
-      * Reads a signed short value in {@link #b}. <i>This method is intended for {@link Attribute} sub
-      * classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a signed short value in this {@link ClassReader}. <i>This method is intended for {@link
+      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
       *
-      * @param offset the start offset of the value to be read in {@link #b}.
+      * @param offset the start offset of the value to be read in this {@link ClassReader}.
       * @return the read value.
       */
     public short readShort(final int offset) {
-        byte[] classFileBuffer = b;
-        return (short) (((classFileBuffer[offset] & 0xFF) << 8) | (classFileBuffer[offset + 1] & 0xFF));
+        byte[] classBuffer = classFileBuffer;
+        return (short) (((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));
     }
 
     /**
-      * Reads a signed int value in {@link #b}. <i>This method is intended for {@link Attribute} sub
-      * classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a signed int value in this {@link ClassReader}. <i>This method is intended for {@link
+      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
       *
-      * @param offset the start offset of the value to be read in {@link #b}.
+      * @param offset the start offset of the value to be read in this {@link ClassReader}.
       * @return the read value.
       */
     public int readInt(final int offset) {
-        byte[] classFileBuffer = b;
-        return ((classFileBuffer[offset] & 0xFF) << 24)
-                | ((classFileBuffer[offset + 1] & 0xFF) << 16)
-                | ((classFileBuffer[offset + 2] & 0xFF) << 8)
-                | (classFileBuffer[offset + 3] & 0xFF);
+        byte[] classBuffer = classFileBuffer;
+        return ((classBuffer[offset] & 0xFF) << 24)
+                | ((classBuffer[offset + 1] & 0xFF) << 16)
+                | ((classBuffer[offset + 2] & 0xFF) << 8)
+                | (classBuffer[offset + 3] & 0xFF);
     }
 
     /**
-      * Reads a signed long value in {@link #b}. <i>This method is intended for {@link Attribute} sub
-      * classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a signed long value in this {@link ClassReader}. <i>This method is intended for {@link
+      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
       *
-      * @param offset the start offset of the value to be read in {@link #b}.
+      * @param offset the start offset of the value to be read in this {@link ClassReader}.
       * @return the read value.
       */
     public long readLong(final int offset) {
         long l1 = readInt(offset);
         long l0 = readInt(offset + 4) & 0xFFFFFFFFL;
         return (l1 << 32) | l0;
     }
 
     /**
-      * Reads a CONSTANT_Utf8 constant pool entry in {@link #b}. <i>This method is intended for {@link
-      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. <i>This method is
+      * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
-      * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
-      *     index of a CONSTANT_Utf8 entry in the class's constant pool table.
+      * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
+      *     value is the index of a CONSTANT_Utf8 entry in the class's constant pool table.
       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
       *     large. It is not automatically resized.
       * @return the String corresponding to the specified CONSTANT_Utf8 entry.
       */
     // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
@@ -3447,11 +3664,11 @@
         }
         return readUtf(constantPoolEntryIndex, charBuffer);
     }
 
     /**
-      * Reads a CONSTANT_Utf8 constant pool entry in {@link #b}.
+      * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.
       *
       * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool
       *     table.
       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
       *     large. It is not automatically resized.
@@ -3466,11 +3683,11 @@
         return constantUtf8Values[constantPoolEntryIndex] =
                 readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);
     }
 
     /**
-      * Reads an UTF8 string in {@link #b}.
+      * Reads an UTF8 string in {@link #classFileBuffer}.
       *
       * @param utfOffset the start offset of the UTF8 string to be read.
       * @param utfLength the length of the UTF8 string to be read.
       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
       *     large. It is not automatically resized.
@@ -3478,37 +3695,38 @@
       */
     private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {
         int currentOffset = utfOffset;
         int endOffset = currentOffset + utfLength;
         int strLength = 0;
-        byte[] classFileBuffer = b;
+        byte[] classBuffer = classFileBuffer;
         while (currentOffset < endOffset) {
-            int currentByte = classFileBuffer[currentOffset++];
+            int currentByte = classBuffer[currentOffset++];
             if ((currentByte & 0x80) == 0) {
                 charBuffer[strLength++] = (char) (currentByte & 0x7F);
             } else if ((currentByte & 0xE0) == 0xC0) {
                 charBuffer[strLength++] =
-                        (char) (((currentByte & 0x1F) << 6) + (classFileBuffer[currentOffset++] & 0x3F));
+                        (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));
             } else {
                 charBuffer[strLength++] =
                         (char)
                                 (((currentByte & 0xF) << 12)
-                                        + ((classFileBuffer[currentOffset++] & 0x3F) << 6)
-                                        + (classFileBuffer[currentOffset++] & 0x3F));
+                                        + ((classBuffer[currentOffset++] & 0x3F) << 6)
+                                        + (classBuffer[currentOffset++] & 0x3F));
             }
         }
         return new String(charBuffer, 0, strLength);
     }
 
     /**
       * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
-      * CONSTANT_Package constant pool entry in {@link #b}. <i>This method is intended for {@link
-      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended
+      * for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
-      * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
-      *     index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
-      *     CONSTANT_Package entry in class's constant pool table.
+      * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose
+      *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
+      *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.
       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
       *     large. It is not automatically resized.
       * @return the String corresponding to the specified constant pool entry.
       */
     private String readStringish(final int offset, final char[] charBuffer) {
@@ -3516,53 +3734,56 @@
         // designated by the first two bytes of this cp_info.
         return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);
     }
 
     /**
-      * Reads a CONSTANT_Class constant pool entry in {@link #b}. <i>This method is intended for {@link
-      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is
+      * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
-      * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
-      *     index of a CONSTANT_Class entry in class's constant pool table.
+      * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
+      *     value is the index of a CONSTANT_Class entry in class's constant pool table.
       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
       *     large. It is not automatically resized.
       * @return the String corresponding to the specified CONSTANT_Class entry.
       */
     public String readClass(final int offset, final char[] charBuffer) {
         return readStringish(offset, charBuffer);
     }
 
     /**
-      * Reads a CONSTANT_Module constant pool entry in {@link #b}. <i>This method is intended for
-      * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is
+      * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
-      * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
-      *     index of a CONSTANT_Module entry in class's constant pool table.
+      * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
+      *     value is the index of a CONSTANT_Module entry in class's constant pool table.
       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
       *     large. It is not automatically resized.
       * @return the String corresponding to the specified CONSTANT_Module entry.
       */
     public String readModule(final int offset, final char[] charBuffer) {
         return readStringish(offset, charBuffer);
     }
 
     /**
-      * Reads a CONSTANT_Package constant pool entry in {@link #b}. <i>This method is intended for
-      * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is
+      * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
-      * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
-      *     index of a CONSTANT_Package entry in class's constant pool table.
+      * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
+      *     value is the index of a CONSTANT_Package entry in class's constant pool table.
       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
       *     large. It is not automatically resized.
       * @return the String corresponding to the specified CONSTANT_Package entry.
       */
     public String readPackage(final int offset, final char[] charBuffer) {
         return readStringish(offset, charBuffer);
     }
 
     /**
-      * Reads a CONSTANT_Dynamic constant pool entry in {@link #b}.
+      * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.
       *
       * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant
       *     pool table.
       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
       *     large. It is not automatically resized.
@@ -3589,12 +3810,13 @@
         return constantDynamicValues[constantPoolEntryIndex] =
                 new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);
     }
 
     /**
-      * Reads a numeric or string constant pool entry in {@link #b}. <i>This method is intended for
-      * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is
+      * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
       * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,
       *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
       *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.
       * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently
@@ -3603,11 +3825,11 @@
       *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified
       *     constant pool entry.
       */
     public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {
         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
-        switch (b[cpInfoOffset - 1]) {
+        switch (classFileBuffer[cpInfoOffset - 1]) {
             case Symbol.CONSTANT_INTEGER_TAG:
                 return readInt(cpInfoOffset);
             case Symbol.CONSTANT_FLOAT_TAG:
                 return Float.intBitsToFloat(readInt(cpInfoOffset));
             case Symbol.CONSTANT_LONG_TAG:
@@ -3626,11 +3848,11 @@
                 int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];
                 String owner = readClass(referenceCpInfoOffset, charBuffer);
                 String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                 String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
                 boolean isInterface =
-                        b[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
+                        classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
                 return new Handle(referenceKind, owner, name, descriptor, isInterface);
             case Symbol.CONSTANT_DYNAMIC_TAG:
                 return readConstantDynamic(constantPoolEntryIndex, charBuffer);
             default:
                 throw new IllegalArgumentException();
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Constants.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Constants.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Constants.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Constants.java
@@ -56,18 +56,23 @@
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 package jdk.internal.org.objectweb.asm;
 
+import java.io.DataInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.regex.Pattern;
+
 /**
  * Defines additional JVM opcodes, access flags and constants which are not part of the ASM public
  * API.
  *
  * @see <a href="https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html">JVMS 6</a>
  * @author Eric Bruneton
  */
-final class Constants implements Opcodes {
+final class Constants {
 
     // The ClassFile attribute names, in the order they are defined in
     // https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.7-300.
 
     static final String CONSTANT_VALUE = "ConstantValue";
@@ -97,10 +102,12 @@
     static final String MODULE = "Module";
     static final String MODULE_PACKAGES = "ModulePackages";
     static final String MODULE_MAIN_CLASS = "ModuleMainClass";
     static final String NEST_HOST = "NestHost";
     static final String NEST_MEMBERS = "NestMembers";
+    static final String PERMITTED_SUBTYPES = "PermittedSubtypes";
+    static final String RECORD = "Record";
 
     // ASM specific access flags.
     // WARNING: the 16 least significant bits must NOT be used, to avoid conflicts with standard
     // access flags, and also to make sure that these flags are automatically filtered out when
     // written in class files (because access flags are stored using 16 bits only).
@@ -169,43 +176,80 @@
     static final int JSR_W = 201;
 
     // Constants to convert between normal and wide jump instructions.
 
     // The delta between the GOTO_W and JSR_W opcodes and GOTO and JUMP.
-    static final int WIDE_JUMP_OPCODE_DELTA = GOTO_W - GOTO;
+    static final int WIDE_JUMP_OPCODE_DELTA = GOTO_W - Opcodes.GOTO;
 
     // Constants to convert JVM opcodes to the equivalent ASM specific opcodes, and vice versa.
 
     // The delta between the ASM_IFEQ, ..., ASM_IF_ACMPNE, ASM_GOTO and ASM_JSR opcodes
     // and IFEQ, ..., IF_ACMPNE, GOTO and JSR.
     // Offset to next available opcode after WITHFIELD from IFEQ
-    static final int ASM_OPCODE_DELTA = (WITHFIELD + 1) - IFEQ;
+    static final int ASM_OPCODE_DELTA = (Opcodes.WITHFIELD + 1) - Opcodes.IFEQ;
 
     // ASM specific opcodes, used for long forward jump instructions.
 
-    static final int ASM_IFEQ = IFEQ + ASM_OPCODE_DELTA;
-    static final int ASM_IFNE = IFNE + ASM_OPCODE_DELTA;
-    static final int ASM_IFLT = IFLT + ASM_OPCODE_DELTA;
-    static final int ASM_IFGE = IFGE + ASM_OPCODE_DELTA;
-    static final int ASM_IFGT = IFGT + ASM_OPCODE_DELTA;
-    static final int ASM_IFLE = IFLE + ASM_OPCODE_DELTA;
-    static final int ASM_IF_ICMPEQ = IF_ICMPEQ + ASM_OPCODE_DELTA;
-    static final int ASM_IF_ICMPNE = IF_ICMPNE + ASM_OPCODE_DELTA;
-    static final int ASM_IF_ICMPLT = IF_ICMPLT + ASM_OPCODE_DELTA;
-    static final int ASM_IF_ICMPGE = IF_ICMPGE + ASM_OPCODE_DELTA;
-    static final int ASM_IF_ICMPGT = IF_ICMPGT + ASM_OPCODE_DELTA;
-    static final int ASM_IF_ICMPLE = IF_ICMPLE + ASM_OPCODE_DELTA;
-    static final int ASM_IF_ACMPEQ = IF_ACMPEQ + ASM_OPCODE_DELTA;
-    static final int ASM_IF_ACMPNE = IF_ACMPNE + ASM_OPCODE_DELTA;
-    static final int ASM_GOTO = GOTO + ASM_OPCODE_DELTA;
-    static final int ASM_JSR = JSR + ASM_OPCODE_DELTA;
+    static final int ASM_IFEQ = Opcodes.IFEQ + ASM_OPCODE_DELTA;
+    static final int ASM_IFNE = Opcodes.IFNE + ASM_OPCODE_DELTA;
+    static final int ASM_IFLT = Opcodes.IFLT + ASM_OPCODE_DELTA;
+    static final int ASM_IFGE = Opcodes.IFGE + ASM_OPCODE_DELTA;
+    static final int ASM_IFGT = Opcodes.IFGT + ASM_OPCODE_DELTA;
+    static final int ASM_IFLE = Opcodes.IFLE + ASM_OPCODE_DELTA;
+    static final int ASM_IF_ICMPEQ = Opcodes.IF_ICMPEQ + ASM_OPCODE_DELTA;
+    static final int ASM_IF_ICMPNE = Opcodes.IF_ICMPNE + ASM_OPCODE_DELTA;
+    static final int ASM_IF_ICMPLT = Opcodes.IF_ICMPLT + ASM_OPCODE_DELTA;
+    static final int ASM_IF_ICMPGE = Opcodes.IF_ICMPGE + ASM_OPCODE_DELTA;
+    static final int ASM_IF_ICMPGT = Opcodes.IF_ICMPGT + ASM_OPCODE_DELTA;
+    static final int ASM_IF_ICMPLE = Opcodes.IF_ICMPLE + ASM_OPCODE_DELTA;
+    static final int ASM_IF_ACMPEQ = Opcodes.IF_ACMPEQ + ASM_OPCODE_DELTA;
+    static final int ASM_IF_ACMPNE = Opcodes.IF_ACMPNE + ASM_OPCODE_DELTA;
+    static final int ASM_GOTO = Opcodes.GOTO + ASM_OPCODE_DELTA;
+    static final int ASM_JSR = Opcodes.JSR + ASM_OPCODE_DELTA;
 
     // The delta between the ASM_IFNULL and ASM_IFNONNULL opcodes and IFNULL and IFNONNULL.
     // Offset to next available opcode after ASM_JSR from IFNULL.
-    static final int ASM_IFNULL_OPCODE_DELTA = (ASM_JSR + 1) - IFNULL;
+    static final int ASM_IFNULL_OPCODE_DELTA = (ASM_JSR + 1) - Opcodes.IFNULL;
 
-    static final int ASM_IFNULL = IFNULL + ASM_IFNULL_OPCODE_DELTA;
-    static final int ASM_IFNONNULL = IFNONNULL + ASM_IFNULL_OPCODE_DELTA;
+    static final int ASM_IFNULL = Opcodes.IFNULL + ASM_IFNULL_OPCODE_DELTA;
+    static final int ASM_IFNONNULL = Opcodes.IFNONNULL + ASM_IFNULL_OPCODE_DELTA;
     static final int ASM_GOTO_W = GOTO_W + ASM_IFNULL_OPCODE_DELTA;
 
     private Constants() {}
+
+    static void checkAsmExperimental(final Object caller) {
+        Class<?> callerClass = caller.getClass();
+        String internalName = callerClass.getName().replace('.', '/');
+        if (!isWhitelisted(internalName)) {
+            checkIsPreview(callerClass.getClassLoader().getResourceAsStream(internalName + ".class"));
+        }
+    }
+
+    static boolean isWhitelisted(final String internalName) {
+        if (!internalName.startsWith("jdk/internal/org/objectweb/asm/")) {
+            return false;
+        }
+        String member = "(Annotation|Class|Field|Method|Module|RecordComponent|Signature)";
+        return internalName.contains("Test$")
+                || Pattern.matches(
+                        "jdk/internal/org/objectweb/asm/util/Trace" + member + "Visitor(\\$.*)?", internalName)
+                || Pattern.matches(
+                        "jdk/internal/org/objectweb/asm/util/Check" + member + "Adapter(\\$.*)?", internalName);
+    }
+
+    static void checkIsPreview(final InputStream classInputStream) {
+        if (classInputStream == null) {
+            throw new IllegalStateException("Bytecode not available, can't check class version");
+        }
+        int minorVersion;
+        try (DataInputStream callerClassStream = new DataInputStream(classInputStream); ) {
+            callerClassStream.readInt();
+            minorVersion = callerClassStream.readUnsignedShort();
+        } catch (IOException ioe) {
+            throw new IllegalStateException("I/O error, can't check class version", ioe);
+        }
+        if (minorVersion != 0xFFFF) {
+            throw new IllegalStateException(
+                    "ASM9_EXPERIMENTAL can only be used by classes compiled with --enable-preview");
+        }
+    }
 }
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java
@@ -83,23 +83,23 @@
  * "abstract types" hereafter. An abstract type is represented with 4 fields named DIM, KIND, FLAGS
  * and VALUE, packed in a single int value for better performance and memory efficiency:
  *
  * <pre>
  *   =====================================
- *   |.DIM|KIND|FLAG|...............VALUE|
+ *   |...DIM|KIND|.F|...............VALUE|
  *   =====================================
  * </pre>
  *
  * <ul>
- *   <li>the DIM field, stored in the 4 most significant bits, is a signed number of array
- *       dimensions (from -8 to 7, included). It can be retrieved with {@link #DIM_MASK} and a right
- *       shift of {@link #DIM_SHIFT}.
+ *   <li>the DIM field, stored in the 6 most significant bits, is a signed number of array
+ *       dimensions (from -32 to 31, included). It can be retrieved with {@link #DIM_MASK} and a
+ *       right shift of {@link #DIM_SHIFT}.
  *   <li>the KIND field, stored in 4 bits, indicates the kind of VALUE used. These 4 bits can be
  *       retrieved with {@link #KIND_MASK} and, without any shift, must be equal to {@link
  *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link #LOCAL_KIND}
  *       or {@link #STACK_KIND}.
- *   <li>the FLAGS field, stored in 4 bits, contains up to 4 boolean flags. Currently only one flag
+ *   <li>the FLAGS field, stored in 2 bits, contains up to 2 boolean flags. Currently only one flag
  *       is defined, namely {@link #TOP_IF_LONG_OR_DOUBLE_FLAG}.
  *   <li>the VALUE field, stored in the remaining 20 bits, contains either
  *       <ul>
  *         <li>one of the constants {@link #ITEM_TOP}, {@link #ITEM_ASM_BOOLEAN}, {@link
  *             #ITEM_ASM_BYTE}, {@link #ITEM_ASM_CHAR} or {@link #ITEM_ASM_SHORT}, {@link
@@ -118,13 +118,13 @@
  * </ul>
  *
  * <p>Output frames can contain abstract types of any kind and with a positive or negative array
  * dimension (and even unassigned types, represented by 0 - which does not correspond to any valid
  * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND or
- * UNINITIALIZED_KIND abstract types of positive or null array dimension. In all cases the type
- * table contains only internal type names (array type descriptors are forbidden - array dimensions
- * must be represented through the DIM field).
+ * UNINITIALIZED_KIND abstract types of positive or {@literal null} array dimension. In all cases
+ * the type table contains only internal type names (array type descriptors are forbidden - array
+ * dimensions must be represented through the DIM field).
  *
  * <p>The LONG and DOUBLE types are always represented by using two slots (LONG + TOP or DOUBLE +
  * TOP), for local variables as well as in the operand stack. This is necessary to be able to
  * simulate DUPx_y instructions, whose effect would be dependent on the concrete types represented
  * by the abstract types in the stack (which are not always known).
@@ -158,44 +158,51 @@
     private static final int ITEM_ASM_BOOLEAN = 9;
     private static final int ITEM_ASM_BYTE = 10;
     private static final int ITEM_ASM_CHAR = 11;
     private static final int ITEM_ASM_SHORT = 12;
 
+    // The size and offset in bits of each field of an abstract type.
+
+    private static final int DIM_SIZE = 6;
+    private static final int KIND_SIZE = 4;
+    private static final int FLAGS_SIZE = 2;
+    private static final int VALUE_SIZE = 32 - DIM_SIZE - KIND_SIZE - FLAGS_SIZE;
+
+    private static final int DIM_SHIFT = KIND_SIZE + FLAGS_SIZE + VALUE_SIZE;
+    private static final int KIND_SHIFT = FLAGS_SIZE + VALUE_SIZE;
+    private static final int FLAGS_SHIFT = VALUE_SIZE;
+
     // Bitmasks to get each field of an abstract type.
 
-    private static final int DIM_MASK = 0xF0000000;
-    private static final int KIND_MASK = 0x0F000000;
-    private static final int FLAGS_MASK = 0x00F00000;
-    private static final int VALUE_MASK = 0x000FFFFF;
+    private static final int DIM_MASK = ((1 << DIM_SIZE) - 1) << DIM_SHIFT;
+    private static final int KIND_MASK = ((1 << KIND_SIZE) - 1) << KIND_SHIFT;
+    private static final int VALUE_MASK = (1 << VALUE_SIZE) - 1;
 
     // Constants to manipulate the DIM field of an abstract type.
 
-    /** The number of right shift bits to use to get the array dimensions of an abstract type. */
-    private static final int DIM_SHIFT = 28;
-
     /** The constant to be added to an abstract type to get one with one more array dimension. */
     private static final int ARRAY_OF = +1 << DIM_SHIFT;
 
     /** The constant to be added to an abstract type to get one with one less array dimension. */
     private static final int ELEMENT_OF = -1 << DIM_SHIFT;
 
     // Possible values for the KIND field of an abstract type.
 
-    private static final int CONSTANT_KIND = 0x01000000;
-    private static final int REFERENCE_KIND = 0x02000000;
-    private static final int UNINITIALIZED_KIND = 0x03000000;
-    private static final int LOCAL_KIND = 0x04000000;
-    private static final int STACK_KIND = 0x05000000;
+    private static final int CONSTANT_KIND = 1 << KIND_SHIFT;
+    private static final int REFERENCE_KIND = 2 << KIND_SHIFT;
+    private static final int UNINITIALIZED_KIND = 3 << KIND_SHIFT;
+    private static final int LOCAL_KIND = 4 << KIND_SHIFT;
+    private static final int STACK_KIND = 5 << KIND_SHIFT;
 
     // Possible flags for the FLAGS field of an abstract type.
 
     /**
       * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,
       * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been
       * partially overridden with an xSTORE instruction).
       */
-    private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 0x00100000 & FLAGS_MASK;
+    private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 1 << FLAGS_SHIFT;
 
     // Useful predefined abstract types (all the possible CONSTANT_KIND types).
 
     private static final int TOP = CONSTANT_KIND | ITEM_TOP;
     private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;
@@ -571,11 +578,12 @@
       *
       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
       * @param descriptor a type or method descriptor (in which case its return type is pushed).
       */
     private void push(final SymbolTable symbolTable, final String descriptor) {
-        int typeDescriptorOffset = descriptor.charAt(0) == '(' ? descriptor.indexOf(')') + 1 : 0;
+        int typeDescriptorOffset =
+                descriptor.charAt(0) == '(' ? Type.getReturnTypeOffset(descriptor) : 0;
         int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);
         if (abstractType != 0) {
             push(abstractType);
             if (abstractType == LONG || abstractType == DOUBLE) {
                 push(TOP);
@@ -1134,10 +1142,46 @@
 
     // -----------------------------------------------------------------------------------------------
     // Frame merging methods, used in the second step of the stack map frame computation algorithm
     // -----------------------------------------------------------------------------------------------
 
+    /**
+      * Computes the concrete output type corresponding to a given abstract output type.
+      *
+      * @param abstractOutputType an abstract output type.
+      * @param numStack the size of the input stack, used to resolve abstract output types of
+      *     STACK_KIND kind.
+      * @return the concrete output type corresponding to 'abstractOutputType'.
+      */
+    private int getConcreteOutputType(final int abstractOutputType, final int numStack) {
+        int dim = abstractOutputType & DIM_MASK;
+        int kind = abstractOutputType & KIND_MASK;
+        if (kind == LOCAL_KIND) {
+            // By definition, a LOCAL_KIND type designates the concrete type of a local variable at
+            // the beginning of the basic block corresponding to this frame (which is known when
+            // this method is called, but was not when the abstract type was computed).
+            int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];
+            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
+                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
+                concreteOutputType = TOP;
+            }
+            return concreteOutputType;
+        } else if (kind == STACK_KIND) {
+            // By definition, a STACK_KIND type designates the concrete type of a local variable at
+            // the beginning of the basic block corresponding to this frame (which is known when
+            // this method is called, but was not when the abstract type was computed).
+            int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];
+            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
+                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
+                concreteOutputType = TOP;
+            }
+            return concreteOutputType;
+        } else {
+            return abstractOutputType;
+        }
+    }
+
     /**
       * Merges the input frame of the given {@link Frame} with the input and output frames of this
       * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation
       * (the input and output frames of this {@link Frame} are never changed).
       *
@@ -1168,33 +1212,11 @@
                 if (abstractOutputType == 0) {
                     // If the local variable has never been assigned in this basic block, it is equal to its
                     // value at the beginning of the block.
                     concreteOutputType = inputLocals[i];
                 } else {
-                    int dim = abstractOutputType & DIM_MASK;
-                    int kind = abstractOutputType & KIND_MASK;
-                    if (kind == LOCAL_KIND) {
-                        // By definition, a LOCAL_KIND type designates the concrete type of a local variable at
-                        // the beginning of the basic block corresponding to this frame (which is known when
-                        // this method is called, but was not when the abstract type was computed).
-                        concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];
-                        if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
-                                && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
-                            concreteOutputType = TOP;
-                        }
-                    } else if (kind == STACK_KIND) {
-                        // By definition, a STACK_KIND type designates the concrete type of a local variable at
-                        // the beginning of the basic block corresponding to this frame (which is known when
-                        // this method is called, but was not when the abstract type was computed).
-                        concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];
-                        if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
-                                && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
-                            concreteOutputType = TOP;
-                        }
-                    } else {
-                        concreteOutputType = abstractOutputType;
-                    }
+                    concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);
                 }
             } else {
                 // If the local variable has never been assigned in this basic block, it is equal to its
                 // value at the beginning of the block.
                 concreteOutputType = inputLocals[i];
@@ -1244,28 +1266,11 @@
             frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);
         }
         // Then, do this for the stack operands that have pushed in the basic block (this code is the
         // same as the one above for local variables).
         for (int i = 0; i < outputStackTop; ++i) {
-            int concreteOutputType;
-            int abstractOutputType = outputStack[i];
-            int dim = abstractOutputType & DIM_MASK;
-            int kind = abstractOutputType & KIND_MASK;
-            if (kind == LOCAL_KIND) {
-                concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];
-                if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
-                        && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
-                    concreteOutputType = TOP;
-                }
-            } else if (kind == STACK_KIND) {
-                concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];
-                if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
-                        && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
-                    concreteOutputType = TOP;
-                }
-            } else {
-                concreteOutputType = abstractOutputType;
+            int abstractOutputType = outputStack[i];
             }
             if (initializations != null) {
                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
             }
             frameChanged |=
@@ -1279,14 +1284,14 @@
       * Returns {@literal true} if the type array has been modified by this operation.
       *
       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
       * @param sourceType the abstract type with which the abstract type array element must be merged.
       *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link
-      *     #UNINITIALIZED_KIND} kind, with positive or null array dimensions.
+      *     #UNINITIALIZED_KIND} kind, with positive or {@literal null} array dimensions.
       * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},
-      *     {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or null array
-      *     dimensions.
+      *     {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or {@literal
+      *     null} array dimensions.
       * @param dstIndex the index of the type that must be merged in dstTypes.
       * @return {@literal true} if the type array has been modified by this operation.
       */
     private static boolean merge(
             final SymbolTable symbolTable,
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java
@@ -76,13 +76,226 @@
 
     int ASM4 = 4 << 16 | 0 << 8;
     int ASM5 = 5 << 16 | 0 << 8;
     int ASM6 = 6 << 16 | 0 << 8;
     int ASM7 = 7 << 16 | 0 << 8;
+    int ASM8 = 8 << 16 | 0 << 8;
 
-    // Java ClassFile versions (the minor version is stored in the 16 most
-    // significant bits, and the
+    /**
+      * <i>Experimental, use at your own risk. This field will be renamed when it becomes stable, this
+      * will break existing code using it. Only code compiled with --enable-preview can use this.</i>
+      *
+      * @deprecated This API is experimental.
+      */
+    @Deprecated int ASM9_EXPERIMENTAL = 1 << 24 | 9 << 16 | 0 << 8;
+
+    /*
+      * Internal flags used to redirect calls to deprecated methods. For instance, if a visitOldStuff
+      * method in API_OLD is deprecated and replaced with visitNewStuff in API_NEW, then the
+      * redirection should be done as follows:
+      *
+      * <pre>
+      * public class StuffVisitor {
+      *   ...
+      *
+      *   &#64;Deprecated public void visitOldStuff(int arg, ...) {
+      *     // SOURCE_DEPRECATED means "a call from a deprecated method using the old 'api' value".
+      *     visitNewStuf(arg | (api &#60; API_NEW ? SOURCE_DEPRECATED : 0), ...);
+      *   }
+      *
+      *   public void visitNewStuff(int argAndSource, ...) {
+      *     if (api &#60; API_NEW &#38;&#38; (argAndSource &#38; SOURCE_DEPRECATED) == 0) {
+      *       visitOldStuff(argAndSource, ...);
+      *     } else {
+      *       int arg = argAndSource &#38; ~SOURCE_MASK;
+      *       [ do stuff ]
+      *     }
+      *   }
+      * }
+      * </pre>
+      *
+      * <p>If 'api' is equal to API_NEW, there are two cases:
+      *
+      * <ul>
+      *   <li>call visitNewStuff: the redirection test is skipped and 'do stuff' is executed directly.
+      *   <li>call visitOldSuff: the source is not set to SOURCE_DEPRECATED before calling
+      *       visitNewStuff, but the redirection test is skipped anyway in visitNewStuff, which
+      *       directly executes 'do stuff'.
+      * </ul>
+      *
+      * <p>If 'api' is equal to API_OLD, there are two cases:
+      *
+      * <ul>
+      *   <li>call visitOldSuff: the source is set to SOURCE_DEPRECATED before calling visitNewStuff.
+      *       Because of this visitNewStuff does not redirect back to visitOldStuff, and instead
+      *       executes 'do stuff'.
+      *   <li>call visitNewStuff: the call is redirected to visitOldStuff because the source is 0.
+      *       visitOldStuff now sets the source to SOURCE_DEPRECATED and calls visitNewStuff back. This
+      *       time visitNewStuff does not redirect the call, and instead executes 'do stuff'.
+      * </ul>
+      *
+      * <h1>User subclasses</h1>
+      *
+      * <p>If a user subclass overrides one of these methods, there are only two cases: either 'api' is
+      * API_OLD and visitOldStuff is overridden (and visitNewStuff is not), or 'api' is API_NEW or
+      * more, and visitNewStuff is overridden (and visitOldStuff is not). Any other case is a user
+      * programming error.
+      *
+      * <p>If 'api' is equal to API_NEW, the class hierarchy is equivalent to
+      *
+      * <pre>
+      * public class StuffVisitor {
+      *   &#64;Deprecated public void visitOldStuff(int arg, ...) { visitNewStuf(arg, ...); }
+      *   public void visitNewStuff(int arg, ...) { [ do stuff ] }
+      * }
+      * class UserStuffVisitor extends StuffVisitor {
+      *   &#64;Override public void visitNewStuff(int arg, ...) {
+      *     super.visitNewStuff(int arg, ...); // optional
+      *     [ do user stuff ]
+      *   }
+      * }
+      * </pre>
+      *
+      * <p>It is then obvious that whether visitNewStuff or visitOldStuff is called, 'do stuff' and 'do
+      * user stuff' will be executed, in this order.
+      *
+      * <p>If 'api' is equal to API_OLD, the class hierarchy is equivalent to
+      *
+      * <pre>
+      * public class StuffVisitor {
+      *   &#64;Deprecated public void visitOldStuff(int arg, ...) {
+      *     visitNewStuf(arg | SOURCE_DEPRECATED, ...);
+      *   }
+      *   public void visitNewStuff(int argAndSource...) {
+      *     if ((argAndSource & SOURCE_DEPRECATED) == 0) {
+      *       visitOldStuff(argAndSource, ...);
+      *     } else {
+      *       int arg = argAndSource &#38; ~SOURCE_MASK;
+      *       [ do stuff ]
+      *     }
+      *   }
+      * }
+      * class UserStuffVisitor extends StuffVisitor {
+      *   &#64;Override public void visitOldStuff(int arg, ...) {
+      *     super.visitOldStuff(int arg, ...); // optional
+      *     [ do user stuff ]
+      *   }
+      * }
+      * </pre>
+      *
+      * <p>and there are two cases:
+      *
+      * <ul>
+      *   <li>call visitOldSuff: in the call to super.visitOldStuff, the source is set to
+      *       SOURCE_DEPRECATED and visitNewStuff is called. Here 'do stuff' is run because the source
+      *       was previously set to SOURCE_DEPRECATED, and execution eventually returns to
+      *       UserStuffVisitor.visitOldStuff, where 'do user stuff' is run.
+      *   <li>call visitNewStuff: the call is redirected to UserStuffVisitor.visitOldStuff because the
+      *       source is 0. Execution continues as in the previous case, resulting in 'do stuff' and 'do
+      *       user stuff' being executed, in this order.
+      * </ul>
+      *
+      * <h1>ASM subclasses</h1>
+      *
+      * <p>In ASM packages, subclasses of StuffVisitor can typically be sub classed again by the user,
+      * and can be used with API_OLD or API_NEW. Because of this, if such a subclass must override
+      * visitNewStuff, it must do so in the following way (and must not override visitOldStuff):
+      *
+      * <pre>
+      * public class AsmStuffVisitor extends StuffVisitor {
+      *   &#64;Override public void visitNewStuff(int argAndSource, ...) {
+      *     if (api &#60; API_NEW &#38;&#38; (argAndSource &#38; SOURCE_DEPRECATED) == 0) {
+      *       super.visitNewStuff(argAndSource, ...);
+      *       return;
+      *     }
+      *     super.visitNewStuff(argAndSource, ...); // optional
+      *     int arg = argAndSource &#38; ~SOURCE_MASK;
+      *     [ do other stuff ]
+      *   }
+      * }
+      * </pre>
+      *
+      * <p>If a user class extends this with 'api' equal to API_NEW, the class hierarchy is equivalent
+      * to
+      *
+      * <pre>
+      * public class StuffVisitor {
+      *   &#64;Deprecated public void visitOldStuff(int arg, ...) { visitNewStuf(arg, ...); }
+      *   public void visitNewStuff(int arg, ...) { [ do stuff ] }
+      * }
+      * public class AsmStuffVisitor extends StuffVisitor {
+      *   &#64;Override public void visitNewStuff(int arg, ...) {
+      *     super.visitNewStuff(arg, ...);
+      *     [ do other stuff ]
+      *   }
+      * }
+      * class UserStuffVisitor extends StuffVisitor {
+      *   &#64;Override public void visitNewStuff(int arg, ...) {
+      *     super.visitNewStuff(int arg, ...);
+      *     [ do user stuff ]
+      *   }
+      * }
+      * </pre>
+      *
+      * <p>It is then obvious that whether visitNewStuff or visitOldStuff is called, 'do stuff', 'do
+      * other stuff' and 'do user stuff' will be executed, in this order. If, on the other hand, a user
+      * class extends AsmStuffVisitor with 'api' equal to API_OLD, the class hierarchy is equivalent to
+      *
+      * <pre>
+      * public class StuffVisitor {
+      *   &#64;Deprecated public void visitOldStuff(int arg, ...) {
+      *     visitNewStuf(arg | SOURCE_DEPRECATED, ...);
+      *   }
+      *   public void visitNewStuff(int argAndSource, ...) {
+      *     if ((argAndSource & SOURCE_DEPRECATED) == 0) {
+      *       visitOldStuff(argAndSource, ...);
+      *     } else {
+      *       int arg = argAndSource &#38; ~SOURCE_MASK;
+      *       [ do stuff ]
+      *     }
+      *   }
+      * }
+      * public class AsmStuffVisitor extends StuffVisitor {
+      *   &#64;Override public void visitNewStuff(int argAndSource, ...) {
+      *     if ((argAndSource &#38; SOURCE_DEPRECATED) == 0) {
+      *       super.visitNewStuff(argAndSource, ...);
+      *       return;
+      *     }
+      *     super.visitNewStuff(argAndSource, ...); // optional
+      *     int arg = argAndSource &#38; ~SOURCE_MASK;
+      *     [ do other stuff ]
+      *   }
+      * }
+      * class UserStuffVisitor extends StuffVisitor {
+      *   &#64;Override public void visitOldStuff(int arg, ...) {
+      *     super.visitOldStuff(arg, ...);
+      *     [ do user stuff ]
+      *   }
+      * }
+      * </pre>
+      *
+      * <p>and, here again, whether visitNewStuff or visitOldStuff is called, 'do stuff', 'do other
+      * stuff' and 'do user stuff' will be executed, in this order (exercise left to the reader).
+      *
+      * <h1>Notes</h1>
+      *
+      * <ul>
+      *   <li>the SOURCE_DEPRECATED flag is set only if 'api' is API_OLD, just before calling
+      *       visitNewStuff. By hypothesis, this method is not overridden by the user. Therefore, user
+      *       classes can never see this flag. Only ASM subclasses must take care of extracting the
+      *       actual argument value by clearing the source flags.
+      *   <li>because the SOURCE_DEPRECATED flag is immediately cleared in the caller, the caller can
+      *       call visitOldStuff or visitNewStuff (in 'do stuff' and 'do user stuff') on a delegate
+      *       visitor without any risks (breaking the redirection logic, "leaking" the flag, etc).
+      *   <li>all the scenarios discussed above are unit tested in MethodVisitorTest.
+      * </ul>
+      */
+
+    int SOURCE_DEPRECATED = 0x100;
+    int SOURCE_MASK = SOURCE_DEPRECATED;
+
+    // Java ClassFile versions (the minor version is stored in the 16 most significant bits, and the
     // major version in the 16 least significant bits).
 
     int V1_1 = 3 << 16 | 45;
     int V1_2 = 0 << 16 | 46;
     int V1_3 = 0 << 16 | 47;
@@ -132,18 +345,19 @@
     int ACC_ABSTRACT = 0x0400; // class, method
     int ACC_STRICT = 0x0800; // method
     int ACC_SYNTHETIC = 0x1000; // class, field, method, parameter, module *
     int ACC_ANNOTATION = 0x2000; // class
     int ACC_ENUM = 0x4000; // class(?) field inner
-    int ACC_MANDATED = 0x8000; // parameter, module, module *
+    int ACC_MANDATED = 0x8000; // field, method, parameter, module, module *
     int ACC_MODULE = 0x8000; // class
 
     // ASM specific access flags.
     // WARNING: the 16 least significant bits must NOT be used, to avoid conflicts with standard
     // access flags, and also to make sure that these flags are automatically filtered out when
     // written in class files (because access flags are stored using 16 bits only).
 
+    int ACC_RECORD = 0x10000; // class
     int ACC_DEPRECATED = 0x20000; // class, field, method
 
     // Possible values for the type operand of the NEWARRAY instruction.
     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html#jvms-6.5.newarray.
 
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Type.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Type.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Type.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Type.java
@@ -336,11 +336,12 @@
                 currentOffset++;
             }
             char c = methodDescriptor.charAt(currentOffset++);
             if (c == 'L' || c == 'Q') {
                 // Skip the argument descriptor content.
-                currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;
+                int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);
+                currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
             }
             ++numArgumentTypes;
         }
 
         // Second step: create a Type instance for each argument type.
@@ -355,11 +356,12 @@
                 currentOffset++;
             }
             char c = methodDescriptor.charAt(currentOffset++);
             if (c == 'L' || c == 'Q') {
                 // Skip the argument descriptor content.
-                currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;
+                int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);
+                currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
             }
             argumentTypes[currentArgumentTypeIndex++] =
                     getTypeInternal(methodDescriptor, currentArgumentTypeOffset, currentOffset);
         }
         return argumentTypes;
@@ -395,34 +397,46 @@
       *
       * @param methodDescriptor a method descriptor.
       * @return the {@link Type} corresponding to the return type of the given method descriptor.
       */
     public static Type getReturnType(final String methodDescriptor) {
+        return getTypeInternal(
+                methodDescriptor, getReturnTypeOffset(methodDescriptor), methodDescriptor.length());
+    }
+
+    /**
+      * Returns the {@link Type} corresponding to the return type of the given method.
+      *
+      * @param method a method.
+      * @return the {@link Type} corresponding to the return type of the given method.
+      */
+    public static Type getReturnType(final Method method) {
+        return getType(method.getReturnType());
+    }
+
+    /**
+      * Returns the start index of the return type of the given method descriptor.
+      *
+      * @param methodDescriptor a method descriptor.
+      * @return the start index of the return type of the given method descriptor.
+      */
+    static int getReturnTypeOffset(final String methodDescriptor) {
         // Skip the first character, which is always a '('.
         int currentOffset = 1;
         // Skip the argument types, one at a each loop iteration.
         while (methodDescriptor.charAt(currentOffset) != ')') {
             while (methodDescriptor.charAt(currentOffset) == '[') {
                 currentOffset++;
             }
             char c = methodDescriptor.charAt(currentOffset++);
             if (c == 'L' || c == 'Q') {
                 // Skip the argument descriptor content.
-                currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;
+                int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);
+                currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
             }
         }
-        return getTypeInternal(methodDescriptor, currentOffset + 1, methodDescriptor.length());
-    }
-
-    /**
-      * Returns the {@link Type} corresponding to the return type of the given method.
-      *
-      * @param method a method.
-      * @return the {@link Type} corresponding to the return type of the given method.
-      */
-    public static Type getReturnType(final Method method) {
-        return getType(method.getReturnType());
+        return currentOffset + 1;
     }
 
     /**
       * Returns the {@link Type} corresponding to the given field or method descriptor.
       *
@@ -539,15 +553,11 @@
       */
     public String getDescriptor() {
         if (sort == OBJECT) {
             return valueBuffer.substring(valueBegin - 1, valueEnd + 1);
         } else if (sort == INTERNAL) {
-            return new StringBuilder()
-                    .append('L')
-                    .append(valueBuffer, valueBegin, valueEnd)
-                    .append(';')
-                    .toString();
+            return 'L' + valueBuffer.substring(valueBegin, valueEnd) + ';';
         } else {
             return valueBuffer.substring(valueBegin, valueEnd);
         }
     }
 
@@ -665,18 +675,11 @@
             } else {
                 throw new AssertionError();
             }
             stringBuilder.append(descriptor);
         } else {
-            stringBuilder.append(isInlineClass(currentClass) ? 'Q' : 'L');
-            String name = currentClass.getName();
-            int nameLength = name.length();
-            for (int i = 0; i < nameLength; ++i) {
-                char car = name.charAt(i);
-                stringBuilder.append(car == '.' ? '/' : car);
-            }
-            stringBuilder.append(';');
+            stringBuilder.append(isInlineClass(currentClass) ? 'Q' : 'L').append(getInternalName(currentClass)).append(';');
         }
     }
 
     static boolean isInlineClass(Class<?> clazz) {
         int mods = clazz.getModifiers();
@@ -777,11 +780,12 @@
                     currentOffset++;
                 }
                 char c = methodDescriptor.charAt(currentOffset++);
                 if (c == 'L' || c == 'Q') {
                     // Skip the argument descriptor content.
-                    currentOffset = methodDescriptor.indexOf(';', currentOffset) + 1;
+                    int semiColumnOffset = methodDescriptor.indexOf(';', currentOffset);
+                    currentOffset = Math.max(currentOffset, semiColumnOffset + 1);
                 }
                 argumentsSize += 1;
             }
             currentChar = methodDescriptor.charAt(currentOffset);
         }
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/AnalyzerAdapter.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/AnalyzerAdapter.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/AnalyzerAdapter.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/AnalyzerAdapter.java
@@ -145,21 +145,22 @@
             final String owner,
             final int access,
             final String name,
             final String descriptor,
             final MethodVisitor methodVisitor) {
-        this(Opcodes.ASM7, owner, access, name, descriptor, methodVisitor);
+        this(/* latest api = */ Opcodes.ASM8, owner, access, name, descriptor, methodVisitor);
         if (getClass() != AnalyzerAdapter.class) {
             throw new IllegalStateException();
         }
     }
 
     /**
       * Constructs a new {@link AnalyzerAdapter}.
       *
       * @param api the ASM API version implemented by this visitor. Must be one of {@link
-      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
+      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link
+      *     Opcodes#ASM8}.
       * @param owner the owner's class name.
       * @param access the method's access flags (see {@link Opcodes}).
       * @param name the method's name.
       * @param descriptor the method's descriptor (see {@link Type}).
       * @param methodVisitor the method visitor to which this adapter delegates calls. May be {@literal
@@ -172,13 +173,13 @@
             final String name,
             final String descriptor,
             final MethodVisitor methodVisitor) {
         super(api, methodVisitor);
         this.owner = owner;
-        locals = new ArrayList<Object>();
-        stack = new ArrayList<Object>();
-        uninitializedTypes = new HashMap<Object, Object>();
+        locals = new ArrayList<>();
+        stack = new ArrayList<>();
+        uninitializedTypes = new HashMap<>();
 
         if ((access & Opcodes.ACC_STATIC) == 0) {
             if ("<init>".equals(name)) {
                 locals.add(Opcodes.UNINITIALIZED_THIS);
             } else {
@@ -234,12 +235,12 @@
 
         if (this.locals != null) {
             this.locals.clear();
             this.stack.clear();
         } else {
-            this.locals = new ArrayList<Object>();
-            this.stack = new ArrayList<Object>();
+            this.locals = new ArrayList<>();
+            this.stack = new ArrayList<>();
         }
         visitFrameTypes(numLocal, local, this.locals);
         visitFrameTypes(numStack, stack, this.stack);
         maxLocals = Math.max(maxLocals, this.locals.size());
         maxStack = Math.max(maxStack, this.stack.size());
@@ -287,11 +288,11 @@
     @Override
     public void visitTypeInsn(final int opcode, final String type) {
         if (opcode == Opcodes.NEW) {
             if (labels == null) {
                 Label label = new Label();
-                labels = new ArrayList<Label>(3);
+                labels = new ArrayList<>(3);
                 labels.add(label);
                 if (mv != null) {
                     mv.visitLabel(label);
                 }
             }
@@ -308,49 +309,25 @@
             final int opcode, final String owner, final String name, final String descriptor) {
         super.visitFieldInsn(opcode, owner, name, descriptor);
         execute(opcode, 0, descriptor);
     }
 
-    /**
-      * Deprecated.
-      *
-      * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.
-      */
-    @Deprecated
     @Override
     public void visitMethodInsn(
-            final int opcode, final String owner, final String name, final String descriptor) {
-        if (api >= Opcodes.ASM5) {
-            super.visitMethodInsn(opcode, owner, name, descriptor);
-            return;
-        }
-        doVisitMethodInsn(opcode, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);
-    }
-
-    @Override
-    public void visitMethodInsn(
-            final int opcode,
+            final int opcodeAndSource,
             final String owner,
             final String name,
             final String descriptor,
             final boolean isInterface) {
-        if (api < Opcodes.ASM5) {
-            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
+        if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
+            // Redirect the call to the deprecated version of this method.
+            super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
             return;
         }
-        doVisitMethodInsn(opcode, owner, name, descriptor, isInterface);
-    }
+        super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
+        int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;
 
-    private void doVisitMethodInsn(
-            final int opcode,
-            final String owner,
-            final String name,
-            final String descriptor,
-            final boolean isInterface) {
-        if (mv != null) {
-            mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
-        }
         if (this.locals == null) {
             labels = null;
             return;
         }
         pop(descriptor);
@@ -407,11 +384,11 @@
 
     @Override
     public void visitLabel(final Label label) {
         super.visitLabel(label);
         if (labels == null) {
-            labels = new ArrayList<Label>(3);
+            labels = new ArrayList<>(3);
         }
         labels.add(label);
     }
 
     @Override
@@ -524,13 +501,16 @@
     private void push(final Object type) {
         stack.add(type);
         maxStack = Math.max(maxStack, stack.size());
     }
 
-    private void pushDescriptor(final String descriptor) {
-        int index = descriptor.charAt(0) == '(' ? descriptor.indexOf(')') + 1 : 0;
-        switch (descriptor.charAt(index)) {
+    private void pushDescriptor(final String fieldOrMethodDescriptor) {
+        String descriptor =
+                fieldOrMethodDescriptor.charAt(0) == '('
+                        ? Type.getReturnType(fieldOrMethodDescriptor).getDescriptor()
+                        : fieldOrMethodDescriptor;
+        switch (descriptor.charAt(0)) {
             case 'V':
                 return;
             case 'Z':
             case 'C':
             case 'B':
@@ -548,23 +528,15 @@
             case 'D':
                 push(Opcodes.DOUBLE);
                 push(Opcodes.TOP);
                 return;
             case '[':
-                if (index == 0) {
-                    push(descriptor);
-                } else {
-                    push(descriptor.substring(index, descriptor.length()));
-                }
+                push(descriptor);
                 break;
             case 'L':
-        // case 'Q':
-                if (index == 0) {
-                    push(descriptor.substring(1, descriptor.length() - 1));
-                } else {
-                    push(descriptor.substring(index + 1, descriptor.length() - 1));
-                }
+            case 'Q':
+                push(descriptor.substring(1, descriptor.length() - 1));
                 break;
             default:
                 throw new AssertionError();
         }
     }
@@ -596,10 +568,13 @@
             pop(1);
         }
     }
 
     private void execute(final int opcode, final int intArg, final String stringArg) {
+        if (opcode == Opcodes.JSR || opcode == Opcodes.RET) {
+            throw new IllegalArgumentException("JSR/RET are not supported");
+        }
         if (this.locals == null) {
             labels = null;
             return;
         }
         Object value1;
@@ -896,13 +871,10 @@
             case Opcodes.DCMPL:
             case Opcodes.DCMPG:
                 pop(4);
                 push(Opcodes.INTEGER);
                 break;
-            case Opcodes.JSR:
-            case Opcodes.RET:
-                throw new IllegalArgumentException("JSR/RET are not supported");
             case Opcodes.GETSTATIC:
                 pushDescriptor(stringArg);
                 break;
             case Opcodes.PUTSTATIC:
                 pop(stringArg);
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/Method.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/Method.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/Method.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/Method.java
@@ -79,11 +79,11 @@
 
     /** The descriptors of the primitive Java types (plus void). */
     private static final Map<String, String> PRIMITIVE_TYPE_DESCRIPTORS;
 
     static {
-        HashMap<String, String> descriptors = new HashMap<String, String>();
+        HashMap<String, String> descriptors = new HashMap<>();
         descriptors.put("void", "V");
         descriptors.put("byte", "B");
         descriptors.put("char", "C");
         descriptors.put("double", "D");
         descriptors.put("float", "F");
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/Remapper.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/Remapper.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/Remapper.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/Remapper.java
@@ -139,12 +139,11 @@
         for (int i = 0; i < internalNames.length; ++i) {
             String internalName = internalNames[i];
             String remappedInternalName = mapType(internalName);
             if (remappedInternalName != null) {
                 if (remappedInternalNames == null) {
-                    remappedInternalNames = new String[internalNames.length];
-                    System.arraycopy(internalNames, 0, remappedInternalNames, 0, internalNames.length);
+                    remappedInternalNames = internalNames.clone();
                 }
                 remappedInternalNames[i] = remappedInternalName;
             }
         }
         return remappedInternalNames != null ? remappedInternalNames : internalNames;
@@ -280,11 +279,16 @@
       */
     public String mapInnerClassName(
             final String name, final String ownerName, final String innerName) {
         final String remappedInnerName = this.mapType(name);
         if (remappedInnerName.contains("$")) {
-            return remappedInnerName.substring(remappedInnerName.lastIndexOf('$') + 1);
+            int index = remappedInnerName.lastIndexOf('$') + 1;
+            while (index < remappedInnerName.length()
+                    && Character.isDigit(remappedInnerName.charAt(index))) {
+                index++;
+            }
+            return remappedInnerName.substring(index);
         } else {
             return innerName;
         }
     }
 
@@ -311,10 +315,24 @@
       */
     public String mapInvokeDynamicMethodName(final String name, final String descriptor) {
         return name;
     }
 
+    /**
+      * Maps a record component name to its new name. The default implementation of this method returns
+      * the given name, unchanged. Subclasses can override.
+      *
+      * @param owner the internal name of the owner class of the field.
+      * @param name the name of the field.
+      * @param descriptor the descriptor of the field.
+      * @return the new name of the field.
+      */
+    public String mapRecordComponentName(
+            final String owner, final String name, final String descriptor) {
+        return name;
+    }
+
     /**
       * Maps a field name to its new name. The default implementation of this method returns the given
       * name, unchanged. Subclasses can override.
       *
       * @param owner the internal name of the owner class of the field.
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java
@@ -73,10 +73,11 @@
 import jdk.internal.org.objectweb.asm.FieldVisitor;
 import jdk.internal.org.objectweb.asm.Label;
 import jdk.internal.org.objectweb.asm.MethodVisitor;
 import jdk.internal.org.objectweb.asm.ModuleVisitor;
 import jdk.internal.org.objectweb.asm.Opcodes;
+import jdk.internal.org.objectweb.asm.RecordComponentVisitor;
 import jdk.internal.org.objectweb.asm.Type;
 import jdk.internal.org.objectweb.asm.TypePath;
 import jdk.internal.org.objectweb.asm.TypeReference;
 import jdk.internal.org.objectweb.asm.tree.ClassNode;
 import jdk.internal.org.objectweb.asm.tree.MethodNode;
@@ -138,10 +139,15 @@
  *
  * @author Eric Bruneton
  */
 public class CheckClassAdapter extends ClassVisitor {
 
+    /** The help message shown when command line arguments are incorrect. */
+    private static final String USAGE =
+            "Verifies the given class.\n"
+                    + "Usage: CheckClassAdapter <fully qualified class name or class file name>";
+
     private static final String ERROR_AT = ": error at index ";
 
     /** Whether the bytecode must be checked with a BasicVerifier. */
     private boolean checkDataFlow;
 
@@ -197,30 +203,31 @@
       * @param checkDataFlow whether to perform basic data flow checks. This option requires valid
       *     maxLocals and maxStack values.
       * @throws IllegalStateException If a subclass calls this constructor.
       */
     public CheckClassAdapter(final ClassVisitor classVisitor, final boolean checkDataFlow) {
-        this(Opcodes.ASM7, classVisitor, checkDataFlow);
+        this(/* latest api = */ Opcodes.ASM8, classVisitor, checkDataFlow);
         if (getClass() != CheckClassAdapter.class) {
             throw new IllegalStateException();
         }
     }
 
     /**
       * Constructs a new {@link CheckClassAdapter}.
       *
       * @param api the ASM API version implemented by this visitor. Must be one of {@link
-      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
+      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link
+      *     Opcodes#ASM8}.
       * @param classVisitor the class visitor to which this adapter must delegate calls.
       * @param checkDataFlow {@literal true} to perform basic data flow checks, or {@literal false} to
       *     not perform any data flow check (see {@link CheckMethodAdapter}). This option requires
       *     valid maxLocals and maxStack values.
       */
     protected CheckClassAdapter(
             final int api, final ClassVisitor classVisitor, final boolean checkDataFlow) {
         super(api, classVisitor);
-        this.labelInsnIndices = new HashMap<Label, Integer>();
+        this.labelInsnIndices = new HashMap<>();
         this.checkDataFlow = checkDataFlow;
     }
 
     // -----------------------------------------------------------------------------------------------
     // Implementation of the ClassVisitor interface
@@ -248,10 +255,11 @@
                         | Opcodes.ACC_ABSTRACT
                         | Opcodes.ACC_SYNTHETIC
                         | Opcodes.ACC_ANNOTATION
                         | Opcodes.ACC_ENUM
                         | Opcodes.ACC_DEPRECATED
+                        | Opcodes.ACC_RECORD
                         | Opcodes.ACC_MODULE);
         if (name == null) {
             throw new IllegalArgumentException("Illegal class name (null)");
         }
         if (!name.endsWith("package-info") && !name.endsWith("module-info")) {
@@ -343,10 +351,24 @@
                     "nest member " + nestMember + " should be in the package " + nestMemberPackageName);
         }
         super.visitNestMember(nestMember);
     }
 
+    /**
+      * <b>Experimental, use at your own risk.</b>.
+      *
+      * @param permittedSubtype the internal name of a permitted subtype.
+      * @deprecated this API is experimental.
+      */
+    @Override
+    @Deprecated
+    public void visitPermittedSubtypeExperimental(final String permittedSubtype) {
+        checkState();
+        CheckMethodAdapter.checkInternalName(version, permittedSubtype, "permittedSubtype");
+        super.visitPermittedSubtypeExperimental(permittedSubtype);
+    }
+
     @Override
     public void visitOuterClass(final String owner, final String name, final String descriptor) {
         checkState();
         if (visitOuterClassCalled) {
             throw new IllegalStateException("visitOuterClass can be called only once.");
@@ -391,10 +413,23 @@
                         | Opcodes.ACC_ANNOTATION
                         | Opcodes.ACC_ENUM);
         super.visitInnerClass(name, outerName, innerName, access);
     }
 
+    @Override
+    public RecordComponentVisitor visitRecordComponent(
+            final String name, final String descriptor, final String signature) {
+        checkState();
+        CheckMethodAdapter.checkUnqualifiedName(version, name, "record component name");
+        CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid = */ false);
+        if (signature != null) {
+            checkFieldSignature(signature);
+        }
+        return new CheckRecordComponentAdapter(
+                api, super.visitRecordComponent(name, descriptor, signature));
+    }
+
     @Override
     public FieldVisitor visitField(
             final int access,
             final String name,
             final String descriptor,
@@ -410,10 +445,11 @@
                         | Opcodes.ACC_FINAL
                         | Opcodes.ACC_VOLATILE
                         | Opcodes.ACC_TRANSIENT
                         | Opcodes.ACC_SYNTHETIC
                         | Opcodes.ACC_ENUM
+                        | Opcodes.ACC_MANDATED
                         | Opcodes.ACC_DEPRECATED);
         CheckMethodAdapter.checkUnqualifiedName(version, name, "field name");
         CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid = */ false);
         if (signature != null) {
             checkFieldSignature(signature);
@@ -444,10 +480,11 @@
                         | Opcodes.ACC_VARARGS
                         | Opcodes.ACC_NATIVE
                         | Opcodes.ACC_ABSTRACT
                         | Opcodes.ACC_STRICT
                         | Opcodes.ACC_SYNTHETIC
+                        | Opcodes.ACC_MANDATED
                         | Opcodes.ACC_DEPRECATED);
         if (!"<init>".equals(name) && !"<clinit>".equals(name)) {
             CheckMethodAdapter.checkMethodIdentifier(version, name, "method name");
         }
         CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
@@ -982,14 +1019,23 @@
       *
       * @param args the command line arguments.
       * @throws IOException if the class cannot be found, or if an IO exception occurs.
       */
     public static void main(final String[] args) throws IOException {
+        main(args, new PrintWriter(System.err, true));
+    }
+
+    /**
+      * Checks the given class.
+      *
+      * @param args the command line arguments.
+      * @param logger where to log errors.
+      * @throws IOException if the class cannot be found, or if an IO exception occurs.
+      */
+    static void main(final String[] args, final PrintWriter logger) throws IOException {
         if (args.length != 1) {
-            System.err.println(
-                    "Verifies the given class.\n"
-                            + "Usage: CheckClassAdapter <fully qualified class name or class file name>");
+            logger.println(USAGE);
             return;
         }
 
         ClassReader classReader;
         if (args[0].endsWith(".class")) {
@@ -998,11 +1044,11 @@
             classReader = new ClassReader(inputStream);
         } else {
             classReader = new ClassReader(args[0]);
         }
 
-        verify(classReader, false, new PrintWriter(System.err));
+        verify(classReader, false, logger);
     }
 
     /**
       * Checks the given class.
       *
@@ -1022,23 +1068,25 @@
       * @param loader a <code>ClassLoader</code> which will be used to load referenced classes. May be
       *     {@literal null}.
       * @param printResults whether to print the results of the bytecode verification.
       * @param printWriter where the results (or the stack trace in case of error) must be printed.
       */
+    @SuppressWarnings("deprecation")
     public static void verify(
             final ClassReader classReader,
             final ClassLoader loader,
             final boolean printResults,
             final PrintWriter printWriter) {
         ClassNode classNode = new ClassNode();
         classReader.accept(
-                new CheckClassAdapter(Opcodes.ASM7, classNode, false) {}, ClassReader.SKIP_DEBUG);
+                new CheckClassAdapter(Opcodes.ASM9_EXPERIMENTAL, classNode, false) {},
+                ClassReader.SKIP_DEBUG);
 
         Type syperType = classNode.superName == null ? null : Type.getObjectType(classNode.superName);
         List<MethodNode> methods = classNode.methods;
 
-        List<Type> interfaces = new ArrayList<Type>();
+        List<Type> interfaces = new ArrayList<>();
         for (String interfaceName : classNode.interfaces) {
             interfaces.add(Type.getObjectType(interfaceName));
         }
 
         for (MethodNode method : methods) {
@@ -1046,11 +1094,11 @@
                     new SimpleVerifier(
                             Type.getObjectType(classNode.name),
                             syperType,
                             interfaces,
                             (classNode.access & Opcodes.ACC_INTERFACE) != 0);
-            Analyzer<BasicValue> analyzer = new Analyzer<BasicValue>(verifier);
+            Analyzer<BasicValue> analyzer = new Analyzer<>(verifier);
             if (loader != null) {
                 verifier.setClassLoader(loader);
             }
             try {
                 analyzer.analyze(classNode.name, method);
diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckMethodAdapter.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckMethodAdapter.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckMethodAdapter.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckMethodAdapter.java
@@ -59,10 +59,11 @@
 package jdk.internal.org.objectweb.asm.util;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -395,34 +396,35 @@
       *     (in other methods). This map is updated with the labels from the visited method.
       * @throws IllegalStateException If a subclass calls this constructor.
       */
     public CheckMethodAdapter(
             final MethodVisitor methodVisitor, final Map<Label, Integer> labelInsnIndices) {
-        this(Opcodes.ASM7, methodVisitor, labelInsnIndices);
+        this(/* latest api = */ Opcodes.ASM8, methodVisitor, labelInsnIndices);
         if (getClass() != CheckMethodAdapter.class) {
             throw new IllegalStateException();
         }
     }
 
     /**
       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will not perform any
       * data flow check (see {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
       *
       * @param api the ASM API version implemented by this CheckMethodAdapter. Must be one of {@link
-      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
+      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link
+      *     Opcodes#ASM8}.
       * @param methodVisitor the method visitor to which this adapter must delegate calls.
       * @param labelInsnIndices the index of the instruction designated by each visited label so far
       *     (in other methods). This map is updated with the labels from the visited method.
       */
     protected CheckMethodAdapter(
             final int api,
             final MethodVisitor methodVisitor,
             final Map<Label, Integer> labelInsnIndices) {
         super(api, methodVisitor);
         this.labelInsnIndices = labelInsnIndices;
-        this.referencedLabels = new HashSet<Label>();
-        this.handlers = new ArrayList<Label>();
+        this.referencedLabels = new HashSet<>();
+        this.handlers = new ArrayList<>();
     }
 
     /**
       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will perform basic data
       * flow checks. For instance in a method whose signature is {@code void m ()}, the invalid
@@ -441,11 +443,12 @@
             final int access,
             final String name,
             final String descriptor,
             final MethodVisitor methodVisitor,
             final Map<Label, Integer> labelInsnIndices) {
-        this(Opcodes.ASM7, access, name, descriptor, methodVisitor, labelInsnIndices);
+        this(
+                /* latest api = */ Opcodes.ASM8, access, name, descriptor, methodVisitor, labelInsnIndices);
         if (getClass() != CheckMethodAdapter.class) {
             throw new IllegalStateException();
         }
     }
 
@@ -453,11 +456,12 @@
       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will perform basic data
       * flow checks. For instance in a method whose signature is {@code void m ()}, the invalid
       * instruction IRETURN, or the invalid sequence IADD L2I will be detected.
       *
       * @param api the ASM API version implemented by this CheckMethodAdapter. Must be one of {@link
-      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
+      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link
+      *     Opcodes#ASM8}.
       * @param access the method's access flags.
       * @param name the method's name.
       * @param descriptor the method's descriptor (see {@link Type}).
       * @param methodVisitor the method visitor to which this adapter must delegate calls.
       * @param labelInsnIndices the index of the instruction designated by each visited label so far
@@ -473,11 +477,11 @@
         this(
                 api,
                 new MethodNode(api, access, name, descriptor, null, null) {
                     @Override
                     public void visitEnd() {
-                        Analyzer<BasicValue> analyzer = new Analyzer<BasicValue>(new BasicVerifier());
+                        Analyzer<BasicValue> analyzer = new Analyzer<>(new BasicVerifier());
                         try {
                             analyzer.analyze("dummy", this);
                         } catch (IndexOutOfBoundsException e) {
                             if (maxLocals == 0 && maxStack == 0) {
                                 throw new IllegalArgumentException(
@@ -486,11 +490,13 @@
                             }
                             throwError(analyzer, e);
                         } catch (AnalyzerException e) {
                             throwError(analyzer, e);
                         }
-                        accept(methodVisitor);
+                        if (methodVisitor != null) {
+                            accept(methodVisitor);
+                        }
                     }
 
                     private void throwError(final Analyzer<BasicValue> analyzer, final Exception e) {
                         StringWriter stringWriter = new StringWriter();
                         PrintWriter printWriter = new PrintWriter(stringWriter, true);
@@ -733,46 +739,24 @@
         checkDescriptor(version, descriptor, false);
         super.visitFieldInsn(opcode, owner, name, descriptor);
         ++insnCount;
     }
 
-    /**
-      * Deprecated.
-      *
-      * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.
-      */
-    @Deprecated
-    @Override
-    public void visitMethodInsn(
-            final int opcode, final String owner, final String name, final String descriptor) {
-        if (api >= Opcodes.ASM5) {
-            super.visitMethodInsn(opcode, owner, name, descriptor);
-            return;
-        }
-        doVisitMethodInsn(opcode, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);
-    }
-
     @Override
     public void visitMethodInsn(
-            final int opcode,
+            final int opcodeAndSource,
             final String owner,
             final String name,
             final String descriptor,
             final boolean isInterface) {
-        if (api < Opcodes.ASM5) {
-            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
+        if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
+            // Redirect the call to the deprecated version of this method.
+            super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
             return;
         }
-        doVisitMethodInsn(opcode, owner, name, descriptor, isInterface);
-    }
+        int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;
 
-    private void doVisitMethodInsn(
-            final int opcode,
-            final String owner,
-            final String name,
-            final String descriptor,
-            final boolean isInterface) {
         checkVisitCodeCalled();
         checkVisitMaxsNotCalled();
         checkOpcodeMethod(opcode, Method.VISIT_METHOD_INSN);
         if (opcode != Opcodes.INVOKESPECIAL || !"<init>".equals(name)) {
             checkMethodIdentifier(version, name, "name");
@@ -787,17 +771,11 @@
         }
         if (opcode == Opcodes.INVOKESPECIAL && isInterface && (version & 0xFFFF) < Opcodes.V1_8) {
             throw new IllegalArgumentException(
                     "INVOKESPECIAL can't be used with interfaces prior to Java 8");
         }
-
-        // Calling super.visitMethodInsn requires to call the correct version depending on this.api
-        // (otherwise infinite loops can occur). To simplify and to make it easier to automatically
-        // remove the backward compatibility code, we inline the code of the overridden method here.
-        if (mv != null) {
-            mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
-        }
+        super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
         ++insnCount;
     }
 
     @Override
     public void visitInvokeDynamicInsn(
@@ -877,13 +855,11 @@
         }
         for (int i = 0; i < labels.length; ++i) {
             checkLabel(labels[i], false, "label at index " + i);
         }
         super.visitTableSwitchInsn(min, max, dflt, labels);
-        for (Label label : labels) {
-            referencedLabels.add(label);
-        }
+        Collections.addAll(referencedLabels, labels);
         ++insnCount;
     }
 
     @Override
     public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
@@ -896,13 +872,11 @@
         for (int i = 0; i < labels.length; ++i) {
             checkLabel(labels[i], false, "label at index " + i);
         }
         super.visitLookupSwitchInsn(dflt, keys, labels);
         referencedLabels.add(dflt);
-        for (Label label : labels) {
-            referencedLabels.add(label);
-        }
+        Collections.addAll(referencedLabels, labels);
         ++insnCount;
     }
 
     @Override
     public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
@@ -995,10 +969,13 @@
             final int index) {
         checkVisitCodeCalled();
         checkVisitMaxsNotCalled();
         checkUnqualifiedName(version, name, "name");
         checkDescriptor(version, descriptor, false);
+        if (signature != null) {
+            CheckClassAdapter.checkFieldSignature(signature);
+        }
         checkLabel(start, true, START_LABEL);
         checkLabel(end, true, END_LABEL);
         checkUnsignedShort(index, INVALID_LOCAL_VARIABLE_INDEX);
         int startInsnIndex = labelInsnIndices.get(start).intValue();
         int endInsnIndex = labelInsnIndices.get(end).intValue();
@@ -1128,11 +1105,12 @@
                 || value == Opcodes.LONG
                 || value == Opcodes.DOUBLE
                 || value == Opcodes.NULL
                 || value == Opcodes.UNINITIALIZED_THIS) {
             return;
-        } else if (value instanceof String) {
+        }
+        if (value instanceof String) {
             checkInternalName(version, (String) value, "Invalid stack frame value");
         } else if (value instanceof Label) {
             referencedLabels.add((Label) value);
         } else {
             throw new IllegalArgumentException("Invalid stack frame value: " + value);
@@ -1312,11 +1290,11 @@
       * @param version the class version.
       * @param name the string to be checked.
       * @param message the message to use in case of error.
       */
     static void checkMethodIdentifier(final int version, final String name, final String message) {
-        if (name == null || name.isEmpty()) {
+        if (name == null || name.length() == 0) {
             throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
         }
         if ((version & 0xFFFF) >= Opcodes.V1_5) {
             for (int i = 0; i < name.length(); i = name.offsetByCodePoints(i, 1)) {
                 if (".;[/<>".indexOf(name.codePointAt(i)) != -1) {
@@ -1345,11 +1323,11 @@
       * @param version the class version.
       * @param name the string to be checked.
       * @param message the message to use in case of error.
       */
     static void checkInternalName(final int version, final String name, final String message) {
-        if (name == null || name.isEmpty()) {
+        if (name == null || name.length() == 0) {
             throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
         }
         if (name.charAt(0) == '[') {
             checkDescriptor(version, name, false);
         } else {
@@ -1368,14 +1346,14 @@
             final int version, final String name, final String message) {
         try {
             int startIndex = 0;
             int slashIndex;
             while ((slashIndex = name.indexOf('/', startIndex + 1)) != -1) {
-                CheckMethodAdapter.checkIdentifier(version, name, startIndex, slashIndex, null);
+                checkIdentifier(version, name, startIndex, slashIndex, null);
                 startIndex = slashIndex + 1;
             }
-            CheckMethodAdapter.checkIdentifier(version, name, startIndex, name.length(), null);
+            checkIdentifier(version, name, startIndex, name.length(), null);
         } catch (IllegalArgumentException e) {
             throw new IllegalArgumentException(
                     INVALID + message + " (must be an internal class name): " + name, e);
         }
     }
@@ -1456,11 +1434,11 @@
       *
       * @param version the class version.
       * @param descriptor the string to be checked.
       */
     static void checkMethodDescriptor(final int version, final String descriptor) {
-        if (descriptor == null || descriptor.isEmpty()) {
+        if (descriptor == null || descriptor.length() == 0) {
             throw new IllegalArgumentException("Invalid method descriptor (must not be null or empty)");
         }
         if (descriptor.charAt(0) != '(' || descriptor.length() < 3) {
             throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
         }
diff a/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorFactory.java b/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorFactory.java
--- a/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorFactory.java
+++ b/src/java.base/share/classes/jdk/internal/reflect/UnsafeFieldAccessorFactory.java
@@ -33,11 +33,13 @@
         Class<?> type = field.getType();
         boolean isStatic = Modifier.isStatic(field.getModifiers());
         boolean isFinal = Modifier.isFinal(field.getModifiers());
         boolean isVolatile = Modifier.isVolatile(field.getModifiers());
         boolean isQualified = isFinal || isVolatile;
-        boolean isReadOnly = isFinal && (isStatic || !override || field.getDeclaringClass().isInlineClass());
+        boolean isReadOnly = isFinal && (isStatic || !override ||
+                                         field.getDeclaringClass().isHidden() ||
+                                         field.getDeclaringClass().isInlineClass());
         if (isStatic) {
             // This code path does not guarantee that the field's
             // declaring class has been initialized, but it must be
             // before performing reflective operations.
             UnsafeFieldAccessorImpl.unsafe.ensureClassInitialized(field.getDeclaringClass());
diff a/src/java.base/share/classes/module-info.java b/src/java.base/share/classes/module-info.java
--- a/src/java.base/share/classes/module-info.java
+++ b/src/java.base/share/classes/module-info.java
@@ -169,23 +169,18 @@
     exports jdk.internal.logger to
         java.logging;
     exports jdk.internal.org.objectweb.asm to
         jdk.jartool,
         jdk.jfr,
-        jdk.jlink,
-        jdk.scripting.nashorn;
+        jdk.jlink;
     exports jdk.internal.org.objectweb.asm.tree to
         jdk.jfr,
         jdk.jlink;
     exports jdk.internal.org.objectweb.asm.util to
-        jdk.jfr,
-        jdk.scripting.nashorn;
+        jdk.jfr;
     exports jdk.internal.org.objectweb.asm.commons to
-        jdk.jfr,
-        jdk.scripting.nashorn;
-    exports jdk.internal.org.objectweb.asm.signature to
-        jdk.scripting.nashorn;
+        jdk.jfr;
     exports jdk.internal.org.xml.sax to
         jdk.jfr;
     exports jdk.internal.org.xml.sax.helpers to
         jdk.jfr;
     exports jdk.internal.misc to
@@ -201,12 +196,10 @@
         jdk.charsets,
         jdk.compiler,
         jdk.jfr,
         jdk.jshell,
         jdk.nio.mapmode,
-        jdk.scripting.nashorn,
-        jdk.scripting.nashorn.shell,
         jdk.unsupported,
         jdk.internal.vm.ci,
         jdk.incubator.foreign;
     exports jdk.internal.module to
         java.instrument,
@@ -227,11 +220,10 @@
         java.logging,
         java.sql,
         java.sql.rowset,
         jdk.dynalink,
         jdk.internal.vm.ci,
-        jdk.scripting.nashorn,
         jdk.unsupported;
     exports jdk.internal.vm to
         jdk.internal.jvmstat,
         jdk.management.agent;
     exports jdk.internal.vm.annotation to
diff a/src/java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java b/src/java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java
--- a/src/java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java
+++ b/src/java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java
@@ -152,13 +152,9 @@
         if (c != 'L') {
             sb.append(c);
         } else if (t == Object.class) {
             sb.append("Ljava/lang/Object;");
         } else {
-            boolean lsemi = (!t.isArray());
-            if (lsemi)  sb.append(t.isInlineClass() ? 'Q' : 'L');
-            sb.append(t.getName().replace('.', '/'));
-            if (lsemi)  sb.append(';');
+            sb.append(t.descriptorString());
         }
     }
-
 }
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java
@@ -1264,14 +1264,18 @@
 
     }
 
     public static class RootPackageSymbol extends PackageSymbol {
         public final MissingInfoHandler missingInfoHandler;
+        public final boolean allowPrivateInvokeVirtual;
 
-        public RootPackageSymbol(Name name, Symbol owner, MissingInfoHandler missingInfoHandler) {
+        public RootPackageSymbol(Name name, Symbol owner,
+                                 MissingInfoHandler missingInfoHandler,
+                                 boolean allowPrivateInvokeVirtual) {
             super(name, owner);
             this.missingInfoHandler = missingInfoHandler;
+            this.allowPrivateInvokeVirtual = allowPrivateInvokeVirtual;
         }
 
     }
 
     /** A class for class symbols
@@ -2460,21 +2464,28 @@
                 if (refSym.isConstructor()) {
                     return ClassFile.REF_newInvokeSpecial;
                 } else {
                     if (refSym.isStatic()) {
                         return ClassFile.REF_invokeStatic;
-                    } else if ((refSym.flags() & PRIVATE) != 0) {
+                    } else if ((refSym.flags() & PRIVATE) != 0 && !allowPrivateInvokeVirtual()) {
                         return ClassFile.REF_invokeSpecial;
                     } else if (refSym.enclClass().isInterface()) {
                         return ClassFile.REF_invokeInterface;
                     } else {
                         return ClassFile.REF_invokeVirtual;
                     }
                 }
             }
         }
 
+        private boolean allowPrivateInvokeVirtual() {
+            Symbol rootPack = this;
+            while (rootPack != null && !(rootPack instanceof RootPackageSymbol)) {
+                rootPack = rootPack.owner;
+            }
+            return rootPack != null && ((RootPackageSymbol) rootPack).allowPrivateInvokeVirtual;
+        }
         @Override
         public int poolTag() {
             return ClassFile.CONSTANT_MethodHandle;
         }
 
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symtab.java
@@ -402,11 +402,14 @@
 
         messages = JavacMessages.instance(context);
 
         MissingInfoHandler missingInfoHandler = MissingInfoHandler.instance(context);
 
-        rootPackage = new RootPackageSymbol(names.empty, null, missingInfoHandler);
+        Target target = Target.instance(context);
+        rootPackage = new RootPackageSymbol(names.empty, null,
+                                            missingInfoHandler,
+                                            target.runtimeUseNestAccess());
 
         // create the basic builtin symbols
         unnamedModule = new ModuleSymbol(names.empty, null) {
                 {
                     directives = List.nil();
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
@@ -2361,87 +2361,86 @@
 
         ListBuffer<Type> argtypesBuf = new ListBuffer<>();
         if (isConstructorCall) {
             // We are seeing a ...this(...) or ...super(...) call.
             // Check that this is the first statement in a constructor.
-            if (checkFirstConstructorStat(tree, env.enclMethod, true)) {
-
-                // Record the fact
-                // that this is a constructor call (using isSelfCall).
-                localEnv.info.isSelfCall = true;
-
-                // Attribute arguments, yielding list of argument types.
-                KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
-                argtypes = argtypesBuf.toList();
-                typeargtypes = attribTypes(tree.typeargs, localEnv);
-
-                // Variable `site' points to the class in which the called
-                // constructor is defined.
-                Type site = env.enclClass.sym.type;
-                if (methName == names._super) {
-                    if (site == syms.objectType) {
-                        log.error(tree.meth.pos(), Errors.NoSuperclass(site));
-                        site = types.createErrorType(syms.objectType);
-                    } else {
-                        site = types.supertype(site);
-                    }
+            checkFirstConstructorStat(tree, env.enclMethod, true);
+
+            // Record the fact
+            // that this is a constructor call (using isSelfCall).
+            localEnv.info.isSelfCall = true;
+
+            // Attribute arguments, yielding list of argument types.
+            KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
+            argtypes = argtypesBuf.toList();
+            typeargtypes = attribTypes(tree.typeargs, localEnv);
+
+            // Variable `site' points to the class in which the called
+            // constructor is defined.
+            Type site = env.enclClass.sym.type;
+            if (methName == names._super) {
+                if (site == syms.objectType) {
+                    log.error(tree.meth.pos(), Errors.NoSuperclass(site));
+                    site = types.createErrorType(syms.objectType);
+                } else {
+                    site = types.supertype(site);
                 }
+            }
 
-                if (site.hasTag(CLASS)) {
-                    Type encl = site.getEnclosingType();
-                    while (encl != null && encl.hasTag(TYPEVAR))
-                        encl = encl.getUpperBound();
-                    if (encl.hasTag(CLASS)) {
-                        // we are calling a nested class
-
-                        if (tree.meth.hasTag(SELECT)) {
-                            JCTree qualifier = ((JCFieldAccess) tree.meth).selected;
-
-                            // We are seeing a prefixed call, of the form
-                            //     <expr>.super(...).
-                            // Check that the prefix expression conforms
-                            // to the outer instance type of the class.
-                            chk.checkRefType(qualifier.pos(),
-                                             attribExpr(qualifier, localEnv,
-                                                        encl));
-                        } else if (methName == names._super) {
-                            // qualifier omitted; check for existence
-                            // of an appropriate implicit qualifier.
-                            rs.resolveImplicitThis(tree.meth.pos(),
-                                                   localEnv, site, true);
-                        }
-                    } else if (tree.meth.hasTag(SELECT)) {
-                        log.error(tree.meth.pos(),
-                                  Errors.IllegalQualNotIcls(site.tsym));
+            if (site.hasTag(CLASS)) {
+                Type encl = site.getEnclosingType();
+                while (encl != null && encl.hasTag(TYPEVAR))
+                    encl = encl.getUpperBound();
+                if (encl.hasTag(CLASS)) {
+                    // we are calling a nested class
+
+                    if (tree.meth.hasTag(SELECT)) {
+                        JCTree qualifier = ((JCFieldAccess) tree.meth).selected;
+
+                        // We are seeing a prefixed call, of the form
+                        //     <expr>.super(...).
+                        // Check that the prefix expression conforms
+                        // to the outer instance type of the class.
+                        chk.checkRefType(qualifier.pos(),
+                                         attribExpr(qualifier, localEnv,
+                                                    encl));
+                    } else if (methName == names._super) {
+                        // qualifier omitted; check for existence
+                        // of an appropriate implicit qualifier.
+                        rs.resolveImplicitThis(tree.meth.pos(),
+                                               localEnv, site, true);
                     }
-
-                    // if we're calling a java.lang.Enum constructor,
-                    // prefix the implicit String and int parameters
-                    if (site.tsym == syms.enumSym)
-                        argtypes = argtypes.prepend(syms.intType).prepend(syms.stringType);
-
-                    // Resolve the called constructor under the assumption
-                    // that we are referring to a superclass instance of the
-                    // current instance (JLS ???).
-                    boolean selectSuperPrev = localEnv.info.selectSuper;
-                    localEnv.info.selectSuper = true;
-                    localEnv.info.pendingResolutionPhase = null;
-                    Symbol sym = rs.resolveConstructor(
-                        tree.meth.pos(), localEnv, site, argtypes, typeargtypes);
-                    localEnv.info.selectSuper = selectSuperPrev;
-
-                    // Set method symbol to resolved constructor...
-                    TreeInfo.setSymbol(tree.meth, sym);
-
-                    // ...and check that it is legal in the current context.
-                    // (this will also set the tree's type)
-                    Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
-                    checkId(tree.meth, site, sym, localEnv,
-                            new ResultInfo(kind, mpt));
+                } else if (tree.meth.hasTag(SELECT)) {
+                    log.error(tree.meth.pos(),
+                              Errors.IllegalQualNotIcls(site.tsym));
                 }
-                // Otherwise, `site' is an error type and we do nothing
+
+                // if we're calling a java.lang.Enum constructor,
+                // prefix the implicit String and int parameters
+                if (site.tsym == syms.enumSym)
+                    argtypes = argtypes.prepend(syms.intType).prepend(syms.stringType);
+
+                // Resolve the called constructor under the assumption
+                // that we are referring to a superclass instance of the
+                // current instance (JLS ???).
+                boolean selectSuperPrev = localEnv.info.selectSuper;
+                localEnv.info.selectSuper = true;
+                localEnv.info.pendingResolutionPhase = null;
+                Symbol sym = rs.resolveConstructor(
+                    tree.meth.pos(), localEnv, site, argtypes, typeargtypes);
+                localEnv.info.selectSuper = selectSuperPrev;
+
+                // Set method symbol to resolved constructor...
+                TreeInfo.setSymbol(tree.meth, sym);
+
+                // ...and check that it is legal in the current context.
+                // (this will also set the tree's type)
+                Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
+                checkId(tree.meth, site, sym, localEnv,
+                        new ResultInfo(kind, mpt));
             }
+            // Otherwise, `site' is an error type and we do nothing
             result = tree.type = syms.voidType;
         } else {
             // Otherwise, we are seeing a regular method call.
             // Attribute the arguments, yielding list of argument types, ...
             KindSelector kind = attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Check.java
@@ -2316,12 +2316,14 @@
         if (lint.isEnabled(LintCategory.OVERRIDES)) {
             MethodSymbol equalsAtObject = (MethodSymbol)syms.objectType
                     .tsym.members().findFirst(names.equals);
             MethodSymbol hashCodeAtObject = (MethodSymbol)syms.objectType
                     .tsym.members().findFirst(names.hashCode);
-            boolean overridesEquals = types.implementation(equalsAtObject,
-                someClass, false, equalsHasCodeFilter).owner == someClass;
+            MethodSymbol equalsImpl = types.implementation(equalsAtObject,
+                    someClass, false, equalsHasCodeFilter);
+            boolean overridesEquals = equalsImpl != null &&
+                                      equalsImpl.owner == someClass;
             boolean overridesHashCode = types.implementation(hashCodeAtObject,
                 someClass, false, equalsHasCodeFilter) != hashCodeAtObject;
 
             if (overridesEquals && !overridesHashCode) {
                 log.warning(LintCategory.OVERRIDES, pos,
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java
@@ -526,18 +526,20 @@
                 // process all the static initializers
                 for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
                     if (!l.head.hasTag(METHODDEF) &&
                         (TreeInfo.flags(l.head) & STATIC) != 0) {
                         scanDef(l.head);
+                        clearPendingExits(false);
                     }
                 }
 
                 // process all the instance initializers
                 for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
                     if (!l.head.hasTag(METHODDEF) &&
                         (TreeInfo.flags(l.head) & STATIC) == 0) {
                         scanDef(l.head);
+                        clearPendingExits(false);
                     }
                 }
 
                 // process all the methods
                 for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
@@ -566,23 +568,27 @@
                 tree.completesNormally = alive != Liveness.DEAD;
 
                 if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))
                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 
-                List<PendingExit> exits = pendingExits.toList();
-                pendingExits = new ListBuffer<>();
-                while (exits.nonEmpty()) {
-                    PendingExit exit = exits.head;
-                    exits = exits.tail;
-                    Assert.check(exit.tree.hasTag(RETURN) ||
-                                    log.hasErrorOn(exit.tree.pos()));
-                }
+                clearPendingExits(true);
             } finally {
                 lint = lintPrev;
             }
         }
 
+        private void clearPendingExits(boolean inMethod) {
+            List<PendingExit> exits = pendingExits.toList();
+            pendingExits = new ListBuffer<>();
+            while (exits.nonEmpty()) {
+                PendingExit exit = exits.head;
+                exits = exits.tail;
+                Assert.check((inMethod && exit.tree.hasTag(RETURN)) ||
+                                log.hasErrorOn(exit.tree.pos()));
+            }
+        }
+
         public void visitVarDef(JCVariableDecl tree) {
             if (tree.init != null) {
                 Lint lintPrev = lint;
                 lint = lint.augment(tree.sym);
                 try{
@@ -933,24 +939,27 @@
          */
         void errorUncaught() {
             for (PendingExit exit = pendingExits.next();
                  exit != null;
                  exit = pendingExits.next()) {
-                Assert.check(exit instanceof ThrownPendingExit);
-                ThrownPendingExit thrownExit = (ThrownPendingExit) exit;
-                if (classDef != null &&
-                    classDef.pos == exit.tree.pos) {
-                    log.error(exit.tree.pos(),
-                              Errors.UnreportedExceptionDefaultConstructor(thrownExit.thrown));
-                } else if (exit.tree.hasTag(VARDEF) &&
-                        ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {
-                    log.error(exit.tree.pos(),
-                              Errors.UnreportedExceptionImplicitClose(thrownExit.thrown,
-                                                                      ((JCVariableDecl)exit.tree).sym.name));
+                if (exit instanceof ThrownPendingExit) {
+                    ThrownPendingExit thrownExit = (ThrownPendingExit) exit;
+                    if (classDef != null &&
+                        classDef.pos == exit.tree.pos) {
+                        log.error(exit.tree.pos(),
+                                  Errors.UnreportedExceptionDefaultConstructor(thrownExit.thrown));
+                    } else if (exit.tree.hasTag(VARDEF) &&
+                            ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {
+                        log.error(exit.tree.pos(),
+                                  Errors.UnreportedExceptionImplicitClose(thrownExit.thrown,
+                                                                          ((JCVariableDecl)exit.tree).sym.name));
+                    } else {
+                        log.error(exit.tree.pos(),
+                                  Errors.UnreportedExceptionNeedToCatchOrThrow(thrownExit.thrown));
+                    }
                 } else {
-                    log.error(exit.tree.pos(),
-                              Errors.UnreportedExceptionNeedToCatchOrThrow(thrownExit.thrown));
+                    Assert.check(log.hasErrorOn(exit.tree.pos()));
                 }
             }
         }
 
         /** Record that exception is potentially thrown and check that it
@@ -2029,10 +2038,11 @@
                     // process all the static initializers
                     for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
                         if (!l.head.hasTag(METHODDEF) &&
                             (TreeInfo.flags(l.head) & STATIC) != 0) {
                             scan(l.head);
+                            clearPendingExits(false);
                         }
                     }
 
                     // define all the instance fields
                     for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
@@ -2050,10 +2060,11 @@
                     // process all the instance initializers
                     for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
                         if (!l.head.hasTag(METHODDEF) &&
                             (TreeInfo.flags(l.head) & STATIC) == 0) {
                             scan(l.head);
+                            clearPendingExits(false);
                         }
                     }
 
                     // process all the methods
                     for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {
@@ -2166,26 +2177,11 @@
                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
                                 }
                             }
                         }
                     }
-                    List<PendingExit> exits = pendingExits.toList();
-                    pendingExits = new ListBuffer<>();
-                    while (exits.nonEmpty()) {
-                        PendingExit exit = exits.head;
-                        exits = exits.tail;
-                        Assert.check(exit.tree.hasTag(RETURN) ||
-                                         log.hasErrorOn(exit.tree.pos()),
-                                     exit.tree);
-                        if (isInitialConstructor) {
-                            Assert.check(exit instanceof AssignPendingExit);
-                            inits.assign(((AssignPendingExit) exit).exit_inits);
-                            for (int i = firstadr; i < nextadr; i++) {
-                                checkInit(exit.tree.pos(), vardecls[i].sym);
-                            }
-                        }
-                    }
+                    clearPendingExits(true);
                 } finally {
                     inits.assign(initsPrev);
                     uninits.assign(uninitsPrev);
                     nextadr = nextadrPrev;
                     firstadr = firstadrPrev;
@@ -2196,10 +2192,28 @@
                 lint = lintPrev;
                 this.thisExposability = priorThisExposability;
             }
         }
 
+        private void clearPendingExits(boolean inMethod) {
+            List<PendingExit> exits = pendingExits.toList();
+            pendingExits = new ListBuffer<>();
+            while (exits.nonEmpty()) {
+                PendingExit exit = exits.head;
+                exits = exits.tail;
+                Assert.check((inMethod && exit.tree.hasTag(RETURN)) ||
+                                 log.hasErrorOn(exit.tree.pos()),
+                             exit.tree);
+                if (inMethod && isInitialConstructor) {
+                    Assert.check(exit instanceof AssignPendingExit);
+                    inits.assign(((AssignPendingExit) exit).exit_inits);
+                    for (int i = firstadr; i < nextadr; i++) {
+                        checkInit(exit.tree.pos(), vardecls[i].sym);
+                    }
+                }
+            }
+        }
         protected void initParam(JCVariableDecl def) {
             inits.incl(def.sym.adr);
             uninits.excl(def.sym.adr);
         }
 
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/LambdaToMethod.java
@@ -34,11 +34,10 @@
 import com.sun.tools.javac.tree.JCTree.*;
 import com.sun.tools.javac.tree.JCTree.JCMemberReference.ReferenceKind;
 import com.sun.tools.javac.tree.TreeMaker;
 import com.sun.tools.javac.tree.TreeTranslator;
 import com.sun.tools.javac.code.Attribute;
-import com.sun.tools.javac.code.Scope.WriteableScope;
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Symbol.ClassSymbol;
 import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;
 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 import com.sun.tools.javac.code.Symbol.TypeSymbol;
@@ -125,10 +124,13 @@
     private final boolean verboseDeduplication;
 
     /** deduplicate lambda implementation methods */
     private final boolean deduplicateLambdas;
 
+    /** lambda proxy is a dynamic nestmate */
+    private final boolean nestmateLambdas;
+
     /** Flag for alternate metafactories indicating the lambda object is intended to be serializable */
     public static final int FLAG_SERIALIZABLE = 1 << 0;
 
     /** Flag for alternate metafactories indicating the lambda object has multiple targets */
     public static final int FLAG_MARKERS = 1 << 1;
@@ -166,10 +168,11 @@
         debugLinesOrVars = options.isSet(Option.G)
                 || options.isSet(Option.G_CUSTOM, "lines")
                 || options.isSet(Option.G_CUSTOM, "vars");
         verboseDeduplication = options.isSet("debug.dumpLambdaToMethodDeduplication");
         deduplicateLambdas = options.getBoolean("deduplicateLambdas", true);
+        nestmateLambdas = Target.instance(context).runtimeUseNestAccess();
     }
     // </editor-fold>
 
     class DedupedLambda {
         private final MethodSymbol symbol;
@@ -2261,14 +2264,17 @@
             boolean receiverIsReferenceProjection() {
                 return tree.sym.kind == MTH && tree.sym.owner.isReferenceProjection();
             }
 
             /**
-             * The VM does not support access across nested classes (8010319).
-             * Were that ever to change, this should be removed.
+             * This method should be called only when target release <= 14
+             * where LambdaMetaFactory does not spin nestmate classes.
+             *
+             * This method should be removed when --release 14 is not supported.
              */
             boolean isPrivateInOtherClass() {
+                assert !nestmateLambdas;
                 return  (tree.sym.flags() & PRIVATE) != 0 &&
                         !types.isSameType(
                               types.erasure(tree.sym.enclClass().asType()),
                               types.erasure(owner.enclClass().asType()));
             }
@@ -2311,11 +2317,11 @@
             final boolean needsConversionToLambda() {
                 return interfaceParameterIsIntersectionOrUnionType() ||
                         isSuper ||
                         needsVarArgsConversion() ||
                         isArrayOp() ||
-                        isPrivateInOtherClass() ||
+                        (!nestmateLambdas && isPrivateInOtherClass()) ||
                         isProtectedInSuperClassOfEnclosingClassInOtherPackage() ||
                         !receiverAccessible() ||
                         receiverIsReferenceProjection() ||
                         (tree.getMode() == ReferenceMode.NEW &&
                           tree.kind != ReferenceKind.ARRAY_CTOR &&
diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/jvm/Target.java
@@ -167,10 +167,18 @@
      */
     public boolean hasNestmateAccess() {
         return compareTo(JDK1_11) >= 0;
     }
 
+    /** language runtime uses nest-based access.
+     *  e.g. lambda and string concat spin dynamic proxy class as a nestmate
+     *  of the target class
+     */
+    public boolean runtimeUseNestAccess() {
+        return compareTo(JDK1_15) >= 0;
+    }
+
     /** Does the target VM support virtual private invocations?
      */
     public boolean hasVirtualPrivateInvoke() {
         return compareTo(JDK1_11) >= 0;
     }
diff a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/jcore/ClassWriter.java b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/jcore/ClassWriter.java
--- a/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/jcore/ClassWriter.java
+++ b/src/jdk.hotspot.agent/share/classes/sun/jvm/hotspot/tools/jcore/ClassWriter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -120,11 +120,11 @@
 
         for (ci = 1; ci < len; ci++) {
             int cpConstType = tags.at(ci);
             if(cpConstType == JVM_CONSTANT_Utf8) {
                 Symbol sym = cpool.getSymbolAt(ci);
-                utf8ToIndex.put(sym.asString(), new Short((short) ci));
+                utf8ToIndex.put(sym.asString(), (short) ci);
             }
             else if(cpConstType == JVM_CONSTANT_Long ||
                       cpConstType == JVM_CONSTANT_Double) {
                 ci++;
             }
@@ -231,11 +231,11 @@
                 case JVM_CONSTANT_UnresolvedClass:
                 case JVM_CONSTANT_UnresolvedClassInError: {
                      dos.writeByte(JVM_CONSTANT_Class);
                      String klassName = cpool.getKlassNameAt(ci).asString();
                      Short s = (Short) utf8ToIndex.get(klassName);
-                     classToIndex.put(klassName, new Short((short)ci));
+                     classToIndex.put(klassName, (short) ci);
                      dos.writeShort(s.shortValue());
                      if (DEBUG) debugMessage("CP[" + ci  + "] = class " + s);
                      break;
                 }
 
diff a/src/jdk.jdi/share/classes/com/sun/tools/jdi/JNITypeParser.java b/src/jdk.jdi/share/classes/com/sun/tools/jdi/JNITypeParser.java
--- a/src/jdk.jdi/share/classes/com/sun/tools/jdi/JNITypeParser.java
+++ b/src/jdk.jdi/share/classes/com/sun/tools/jdi/JNITypeParser.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -41,66 +41,49 @@
 
     JNITypeParser(String signature) {
         this.signature = signature;
     }
 
-    static String inlineTypeNameToSignature(String signature) {
+    static String typeNameToSignature(String typeName) {
         StringBuilder sb = new StringBuilder();
-        int firstIndex = signature.indexOf('[');
+        int firstIndex = typeName.indexOf('[');
         int index = firstIndex;
         while (index != -1) {
             sb.append('[');
-            index = signature.indexOf('[', index + 1);
-        }
-
-        if (signature.equals("boolean") || signature.equals("byte")
-                || signature.equals("char") || signature.equals("short")
-                || signature.equals("int") ||signature.equals("long")
-                || signature.equals("float") || signature.equals("double")) {
-            throw new IllegalArgumentException("Not an inline type signature '" +
-                    signature + "'");
-        } else {
-            sb.append('Q');
-            sb.append(signature.replace('.', '/'));
-            sb.append(';');
-        }
-
-        return sb.toString();
-    }
-
-    static String typeNameToSignature(String signature) {
-        StringBuilder sb = new StringBuilder();
-        int firstIndex = signature.indexOf('[');
-        int index = firstIndex;
-        while (index != -1) {
-            sb.append('[');
-            index = signature.indexOf('[', index + 1);
+            index = typeName.indexOf('[', index + 1);
         }
 
         if (firstIndex != -1) {
-            signature = signature.substring(0, firstIndex);
+            typeName = typeName.substring(0, firstIndex);
         }
 
-        if (signature.equals("boolean")) {
+        if (typeName.equals("boolean")) {
             sb.append('Z');
-        } else if (signature.equals("byte")) {
+        } else if (typeName.equals("byte")) {
             sb.append('B');
-        } else if (signature.equals("char")) {
+        } else if (typeName.equals("char")) {
             sb.append('C');
-        } else if (signature.equals("short")) {
+        } else if (typeName.equals("short")) {
             sb.append('S');
-        } else if (signature.equals("int")) {
+        } else if (typeName.equals("int")) {
             sb.append('I');
-        } else if (signature.equals("long")) {
+        } else if (typeName.equals("long")) {
             sb.append('J');
-        } else if (signature.equals("float")) {
+        } else if (typeName.equals("float")) {
             sb.append('F');
-        } else if (signature.equals("double")) {
+        } else if (typeName.equals("double")) {
             sb.append('D');
         } else {
             sb.append('L');
-            sb.append(signature.replace('.', '/'));
+            index = typeName.indexOf("/");   // check if it's a hidden class
+            if (index < 0) {
+                sb.append(typeName.replace('.', '/'));
+            } else {
+                sb.append(typeName.substring(0, index).replace('.', '/'));
+                sb.append(".");
+                sb.append(typeName.substring(index + 1));
+            }
             sb.append(';');
         }
 
         return sb.toString();
     }
@@ -222,16 +205,23 @@
 
             case (JDWP.Tag.CHAR):
                 return "char";
 
             case (JDWP.Tag.OBJECT):
-	        case (JDWP.Tag.INLINE_OBJECT):
+            case (JDWP.Tag.INLINE_OBJECT):
                 int endClass = signature.indexOf(SIGNATURE_ENDCLASS,
                                                  currentIndex);
                 String retVal = signature.substring(currentIndex,
                                                     endClass);
-                retVal = retVal.replace('/','.');
+                int index = retVal.indexOf(".");
+                if (index < 0) {
+                    retVal = retVal.replace('/', '.');
+                } else {
+                    // hidden class
+                    retVal = retVal.substring(0, index).replace('/', '.')
+                                + "/" + retVal.substring(index + 1);
+                }
                 currentIndex = endClass + 1;
                 return retVal;
 
             case (JDWP.Tag.FLOAT):
                 return "float";
diff a/src/jdk.jdwp.agent/share/native/libjdwp/util.c b/src/jdk.jdwp.agent/share/native/libjdwp/util.c
--- a/src/jdk.jdwp.agent/share/native/libjdwp/util.c
+++ b/src/jdk.jdwp.agent/share/native/libjdwp/util.c
@@ -993,10 +993,14 @@
     p = convert + 1;
     while ((*p != ';') && (*p != '\0')) {
         char c = *p;
         if (c == '/') {
             *(p-1) = '.';
+        } else if (c == '.') {
+            // class signature of a hidden class is "Ljava/lang/Foo.1234;"
+            // map to "java.lang.Foo/1234"
+            *(p-1) = '/';
         } else {
             *(p-1) = c;
         }
         p++;
     }
diff a/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java b/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java
--- a/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java
+++ b/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java
@@ -28,10 +28,11 @@
 import jdk.internal.vm.annotation.ForceInline;
 import jdk.internal.misc.VM;
 import jdk.internal.reflect.CallerSensitive;
 import jdk.internal.reflect.Reflection;
 
+import java.lang.invoke.MethodHandles;
 import java.lang.reflect.Field;
 import java.util.Set;
 
 
 /**
@@ -637,10 +638,13 @@
     @ForceInline
     public long objectFieldOffset(Field f) {
         if (f == null) {
             throw new NullPointerException();
         }
+        if (f.getDeclaringClass().isHidden()) {
+            throw new UnsupportedOperationException("can't get field offset on a hidden class: " + f);
+        }
         if (f.getDeclaringClass().isInlineClass()) {
             throw new UnsupportedOperationException("can't get field offset on an inline class: " + f);
         }
         return theInternalUnsafe.objectFieldOffset(f);
     }
@@ -665,10 +669,13 @@
     @ForceInline
     public long staticFieldOffset(Field f) {
         if (f == null) {
             throw new NullPointerException();
         }
+        if (f.getDeclaringClass().isHidden()) {
+            throw new UnsupportedOperationException("can't get field offset on a hidden class: " + f);
+        }
         if (f.getDeclaringClass().isInlineClass()) {
             throw new UnsupportedOperationException("can't get static field offset on an inline class: " + f);
         }
         return theInternalUnsafe.staticFieldOffset(f);
     }
@@ -686,10 +693,13 @@
     @ForceInline
     public Object staticFieldBase(Field f) {
         if (f == null) {
             throw new NullPointerException();
         }
+        if (f.getDeclaringClass().isHidden()) {
+            throw new UnsupportedOperationException("can't get base address on a hidden class: " + f);
+        }
         if (f.getDeclaringClass().isInlineClass()) {
             throw new UnsupportedOperationException("can't get base address on an inline class: " + f);
         }
         return theInternalUnsafe.staticFieldBase(f);
     }
@@ -836,15 +846,20 @@
      * <li>Utf8: a string (must have suitable syntax if used as signature or name)
      * <li>Class: any java.lang.Class object
      * <li>String: any object (not just a java.lang.String)
      * <li>InterfaceMethodRef: (NYI) a method handle to invoke on that call site's arguments
      * </ul>
+     *
+     * @deprecated Use the {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)}
+     * method.
+     *
      * @param hostClass context for linkage, access control, protection domain, and class loader
      * @param data      bytes of a class file
      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
      */
     @ForceInline
+    @Deprecated(since = "15", forRemoval = false)
     public Class<?> defineAnonymousClass(Class<?> hostClass, byte[] data, Object[] cpPatches) {
         return theInternalUnsafe.defineAnonymousClass(hostClass, data, cpPatches);
     }
 
     /**
diff a/test/hotspot/jtreg/ProblemList.txt b/test/hotspot/jtreg/ProblemList.txt
--- a/test/hotspot/jtreg/ProblemList.txt
+++ b/test/hotspot/jtreg/ProblemList.txt
@@ -148,10 +148,12 @@
 compiler/aot/fingerprint/SelfChangedCDS.java 8226295 generic-all
 compiler/aot/fingerprint/SuperChanged.java 8226295 generic-all
 
 compiler/c2/Test8004741.java 8235801 generic-all
 
+compiler/jsr292/CreatesInterfaceDotEqualsCallInfo.java 8242923 generic-all
+
 #############################################################################
 
 # :hotspot_gc
 
 gc/epsilon/TestMemoryMXBeans.java 8206434 generic-all
@@ -168,10 +170,11 @@
 
 # :hotspot_runtime
 
 runtime/jni/terminatedThread/TestTerminatedThread.java 8219652 aix-ppc64
 runtime/ReservedStack/ReservedStackTest.java 8231031 generic-all
+runtime/CompactStrings/TestMethodNames.java 8242921 generic-all
 
 # Valhalla TODO:
 runtime/CompressedOops/CompressedClassPointers.java 8210258 generic-all
 runtime/RedefineTests/RedefineLeak.java 8205032 generic-all
 runtime/SharedArchiveFile/BootAppendTests.java 8210258 generic-all
@@ -195,14 +198,10 @@
 
 #############################################################################
 
 # :hotspot_serviceability
 
-serviceability/sa/ClhsdbDumpheap.java 8241158 macosx-x64
-serviceability/sa/ClhsdbScanOops.java#id0 8241158,8230731 macosx-x64,windows-x64
-serviceability/sa/ClhsdbScanOops.java#id1 8241158,8230731 macosx-x64,windows-x64
-serviceability/sa/sadebugd/DebugdConnectTest.java 8239062 macosx-x64
 serviceability/sa/TestHeapDumpForInvokeDynamic.java 8241158 macosx-x64
 serviceability/sa/TestInstanceKlassSize.java 8230664 linux-ppc64le,linux-ppc64
 serviceability/sa/TestInstanceKlassSizeForInterface.java 8230664 linux-ppc64le,linux-ppc64
 serviceability/sa/TestRevPtrsForInvokeDynamic.java 8241235 generic-all
 
diff a/test/hotspot/jtreg/TEST.groups b/test/hotspot/jtreg/TEST.groups
--- a/test/hotspot/jtreg/TEST.groups
+++ b/test/hotspot/jtreg/TEST.groups
@@ -190,12 +190,11 @@
 ctw_3 = \
   applications/ctw/modules/java_xml.java \
   applications/ctw/modules/jdk_compiler.java \
   applications/ctw/modules/jdk_internal_vm_compiler.java \
   applications/ctw/modules/jdk_localedata.java \
-  applications/ctw/modules/jdk_localedata_2.java \
-  applications/ctw/modules/jdk_scripting_nashorn.java \
+  applications/ctw/modules/jdk_localedata_2.java
 
 tier1_gc = \
   :tier1_gc_1 \
   :tier1_gc_2 \
   :tier1_gc_gcold \
diff a/test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestResolvedJavaType.java b/test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestResolvedJavaType.java
--- a/test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestResolvedJavaType.java
+++ b/test/hotspot/jtreg/compiler/jvmci/jdk.vm.ci.runtime.test/src/jdk/vm/ci/runtime/test/TestResolvedJavaType.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -23,11 +23,12 @@
 
 /**
  * @test
  * @requires vm.jvmci
  * @library ../../../../../
- * @modules java.base/jdk.internal.reflect
+ * @modules java.base/jdk.internal.org.objectweb.asm
+ *          java.base/jdk.internal.reflect
  *          jdk.internal.vm.ci/jdk.vm.ci.meta
  *          jdk.internal.vm.ci/jdk.vm.ci.runtime
  *          jdk.internal.vm.ci/jdk.vm.ci.common
  *          java.base/jdk.internal.misc
  * @run junit/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler jdk.vm.ci.runtime.test.TestResolvedJavaType
@@ -63,10 +64,11 @@
 import java.util.Map;
 import java.util.Set;
 
 import org.junit.Test;
 
+import jdk.internal.org.objectweb.asm.*;
 import jdk.internal.reflect.ConstantPool;
 import jdk.vm.ci.common.JVMCIError;
 import jdk.vm.ci.meta.Assumptions.AssumptionResult;
 import jdk.vm.ci.meta.JavaConstant;
 import jdk.vm.ci.meta.JavaKind;
@@ -154,19 +156,30 @@
             boolean actual = type.isArray();
             assertEquals(expected, actual);
         }
     }
 
+    private static Class<?> anonClass() throws Exception {
+        ClassWriter cw = new ClassWriter(0);
+        cw.visit(Opcodes.V1_8, Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, "Anon", null, "java/lang/Object", null);
+        FieldVisitor intField = cw.visitField(Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, "intField", "I", null, 0);
+        intField.visitEnd();
+        cw.visitEnd();
+        return unsafe.defineAnonymousClass(TypeUniverse.class, cw.toByteArray(), null);
+    }
+
     @Test
-    public void getHostClassTest() {
+    public void getHostClassTest() throws Exception {
+        ResolvedJavaType type = metaAccess.lookupJavaType(anonClass());
+        ResolvedJavaType host = type.getHostClass();
+        assertNotNull(host);
         for (Class<?> c : classes) {
-            ResolvedJavaType type = metaAccess.lookupJavaType(c);
-            ResolvedJavaType host = type.getHostClass();
-            if (!type.equals(predicateType)) {
-                assertNull(host);
-            } else {
-                assertNotNull(host);
+            type = metaAccess.lookupJavaType(c);
+            host = type.getHostClass();
+            assertNull(host);
+            if (type.equals(predicateType)) {
+                assertTrue(c.isHidden());
             }
         }
 
         class LocalClass {}
         Cloneable clone = new Cloneable() {};
@@ -174,13 +187,14 @@
         assertNull(metaAccess.lookupJavaType(clone.getClass()).getHostClass());
 
         Supplier<Runnable> lambda = () -> () -> System.out.println("run");
         ResolvedJavaType lambdaType = metaAccess.lookupJavaType(lambda.getClass());
         ResolvedJavaType nestedLambdaType = metaAccess.lookupJavaType(lambda.get().getClass());
-        assertNotNull(lambdaType.getHostClass());
-        assertNotNull(nestedLambdaType.getHostClass());
-        assertEquals(lambdaType.getHostClass(), nestedLambdaType.getHostClass());
+        assertNull(lambdaType.getHostClass());
+        assertTrue(lambda.getClass().isHidden());
+        assertNull(nestedLambdaType.getHostClass());
+        assertTrue(lambda.get().getClass().isHidden());
     }
 
     @Test
     public void getModifiersTest() {
         for (Class<?> c : classes) {
@@ -766,12 +780,12 @@
             return true;
         }
         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(ConstantPool.class)) && f.getName().equals("constantPoolOop")) {
             return true;
         }
-        if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Class.class)) && f.getName().equals("classLoader")) {
-            return true;
+        if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Class.class))) {
+            return f.getName().equals("classLoader") || f.getName().equals("classData");
         }
         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Lookup.class))) {
             return f.getName().equals("allowedModes") || f.getName().equals("lookupClass");
         }
         if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(ClassLoader.class)) ||
diff a/test/jdk/TEST.groups b/test/jdk/TEST.groups
--- a/test/jdk/TEST.groups
+++ b/test/jdk/TEST.groups
@@ -74,11 +74,12 @@
     :build \
     :jdk_rmi \
     :jdk_beans \
     :jdk_imageio \
     :jdk_sound \
-    :jdk_client_sanity
+    :jdk_client_sanity \
+    :jdk_jfr_tier3
 
 ###############################################################################
 #
 # Other test definitions; generally smaller granularity than tiers
 #
@@ -284,10 +285,13 @@
     :svc_tools
 
 jdk_jfr = \
     jdk/jfr
 
+jdk_jfr_tier3 = \
+    jdk/jfr/event/metadata/TestLookForUntestedEvents.java
+
 #
 # Catch-all for other areas with a small number of tests
 #
 jdk_other = \
     java/sql \

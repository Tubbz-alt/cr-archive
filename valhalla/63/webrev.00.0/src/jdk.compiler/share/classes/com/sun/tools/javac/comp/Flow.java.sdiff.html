<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LambdaToMethod.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 511                     scanStat(l.head);
 512         }
 513 
 514         /* ------------ Visitor methods for various sorts of trees -------------*/
 515 
 516         public void visitClassDef(JCClassDecl tree) {
 517             if (tree.sym == null) return;
 518             Liveness alivePrev = alive;
 519             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 520             Lint lintPrev = lint;
 521 
 522             pendingExits = new ListBuffer&lt;&gt;();
 523             lint = lint.augment(tree.sym);
 524 
 525             try {
 526                 // process all the static initializers
 527                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 528                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 529                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
 530                         scanDef(l.head);

 531                     }
 532                 }
 533 
 534                 // process all the instance initializers
 535                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 536                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 537                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
 538                         scanDef(l.head);

 539                     }
 540                 }
 541 
 542                 // process all the methods
 543                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 544                     if (l.head.hasTag(METHODDEF)) {
 545                         scan(l.head);
 546                     }
 547                 }
 548             } finally {
 549                 pendingExits = pendingExitsPrev;
 550                 alive = alivePrev;
 551                 lint = lintPrev;
 552             }
 553         }
 554 
 555         public void visitMethodDef(JCMethodDecl tree) {
 556             if (tree.body == null) return;
 557             Lint lintPrev = lint;
 558 
 559             lint = lint.augment(tree.sym);
 560 
 561             Assert.check(pendingExits.isEmpty());
 562 
 563             try {
 564                 alive = Liveness.ALIVE;
 565                 scanStat(tree.body);
 566                 tree.completesNormally = alive != Liveness.DEAD;
 567 
 568                 if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
 569                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 570 
<span class="line-modified"> 571                 List&lt;PendingExit&gt; exits = pendingExits.toList();</span>
<span class="line-removed"> 572                 pendingExits = new ListBuffer&lt;&gt;();</span>
<span class="line-removed"> 573                 while (exits.nonEmpty()) {</span>
<span class="line-removed"> 574                     PendingExit exit = exits.head;</span>
<span class="line-removed"> 575                     exits = exits.tail;</span>
<span class="line-removed"> 576                     Assert.check(exit.tree.hasTag(RETURN) ||</span>
<span class="line-removed"> 577                                     log.hasErrorOn(exit.tree.pos()));</span>
<span class="line-removed"> 578                 }</span>
 579             } finally {
 580                 lint = lintPrev;
 581             }
 582         }
 583 











 584         public void visitVarDef(JCVariableDecl tree) {
 585             if (tree.init != null) {
 586                 Lint lintPrev = lint;
 587                 lint = lint.augment(tree.sym);
 588                 try{
 589                     scan(tree.init);
 590                 } finally {
 591                     lint = lintPrev;
 592                 }
 593             }
 594         }
 595 
 596         public void visitBlock(JCBlock tree) {
 597             scanStats(tree.stats);
 598         }
 599 
 600         public void visitDoLoop(JCDoWhileLoop tree) {
 601             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 602             pendingExits = new ListBuffer&lt;&gt;();
 603             scanStat(tree.body);
</pre>
<hr />
<pre>
 918 
 919             ThrownPendingExit(JCTree tree, Type thrown) {
 920                 super(tree);
 921                 this.thrown = thrown;
 922             }
 923         }
 924 
 925         @Override
 926         void markDead() {
 927             //do nothing
 928         }
 929 
 930         /*-------------------- Exceptions ----------------------*/
 931 
 932         /** Complain that pending exceptions are not caught.
 933          */
 934         void errorUncaught() {
 935             for (PendingExit exit = pendingExits.next();
 936                  exit != null;
 937                  exit = pendingExits.next()) {
<span class="line-modified"> 938                 Assert.check(exit instanceof ThrownPendingExit);</span>
<span class="line-modified"> 939                 ThrownPendingExit thrownExit = (ThrownPendingExit) exit;</span>
<span class="line-modified"> 940                 if (classDef != null &amp;&amp;</span>
<span class="line-modified"> 941                     classDef.pos == exit.tree.pos) {</span>
<span class="line-modified"> 942                     log.error(exit.tree.pos(),</span>
<span class="line-modified"> 943                               Errors.UnreportedExceptionDefaultConstructor(thrownExit.thrown));</span>
<span class="line-modified"> 944                 } else if (exit.tree.hasTag(VARDEF) &amp;&amp;</span>
<span class="line-modified"> 945                         ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {</span>
<span class="line-modified"> 946                     log.error(exit.tree.pos(),</span>
<span class="line-modified"> 947                               Errors.UnreportedExceptionImplicitClose(thrownExit.thrown,</span>
<span class="line-modified"> 948                                                                       ((JCVariableDecl)exit.tree).sym.name));</span>




 949                 } else {
<span class="line-modified"> 950                     log.error(exit.tree.pos(),</span>
<span class="line-removed"> 951                               Errors.UnreportedExceptionNeedToCatchOrThrow(thrownExit.thrown));</span>
 952                 }
 953             }
 954         }
 955 
 956         /** Record that exception is potentially thrown and check that it
 957          *  is caught.
 958          */
 959         void markThrown(JCTree tree, Type exc) {
 960             if (!chk.isUnchecked(tree.pos(), exc)) {
 961                 if (!chk.isHandled(exc, caught)) {
 962                     pendingExits.append(new ThrownPendingExit(tree, exc));
 963                 }
 964                 thrown = chk.incl(exc, thrown);
 965             }
 966         }
 967 
 968     /*************************************************************************
 969      * Visitor methods for statements and definitions
 970      *************************************************************************/
 971 
</pre>
<hr />
<pre>
2014                 classDef = tree;
2015                 try {
2016                     // define all the static fields
2017                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2018                         if (l.head.hasTag(VARDEF)) {
2019                             JCVariableDecl def = (JCVariableDecl)l.head;
2020                             if ((def.mods.flags &amp; STATIC) != 0) {
2021                                 VarSymbol sym = def.sym;
2022                                 if (trackable(sym)) {
2023                                     newVar(def);
2024                                 }
2025                             }
2026                         }
2027                     }
2028 
2029                     // process all the static initializers
2030                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2031                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2032                             (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
2033                             scan(l.head);

2034                         }
2035                     }
2036 
2037                     // define all the instance fields
2038                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2039                         if (l.head.hasTag(VARDEF)) {
2040                             JCVariableDecl def = (JCVariableDecl)l.head;
2041                             if ((def.mods.flags &amp; STATIC) == 0) {
2042                                 VarSymbol sym = def.sym;
2043                                 if (trackable(sym)) {
2044                                     newVar(def);
2045                                 }
2046                             }
2047                         }
2048                     }
2049 
2050                     // process all the instance initializers
2051                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2052                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2053                             (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
2054                             scan(l.head);

2055                         }
2056                     }
2057 
2058                     // process all the methods
2059                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2060                         if (l.head.hasTag(METHODDEF)) {
2061                             scan(l.head);
2062                         }
2063                     }
2064                 } finally {
2065                     pendingExits = pendingExitsPrev;
2066                     nextadr = nextadrPrev;
2067                     firstadr = firstadrPrev;
2068                     classDef = classDefPrev;
2069                 }
2070             } finally {
2071                 lint = lintPrev;
2072             }
2073         }
2074 
</pre>
<hr />
<pre>
2151                                             var.owner.kind == TYP;
2152                                     if (isInstanceRecordField) {
2153                                         boolean notInitialized = !inits.isMember(var.adr);
2154                                         if (notInitialized &amp;&amp; uninits.isMember(var.adr) &amp;&amp; tree.completesNormally) {
2155                                         /*  this way we indicate Lower that it should generate an initialization for this field
2156                                          *  in the compact constructor
2157                                          */
2158                                             var.flags_field |= UNINITIALIZED_FIELD;
2159                                         } else {
2160                                             checkInit(TreeInfo.diagEndPos(tree.body), var);
2161                                         }
2162                                     } else {
2163                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2164                                     }
2165                                 } else {
2166                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2167                                 }
2168                             }
2169                         }
2170                     }
<span class="line-modified">2171                     List&lt;PendingExit&gt; exits = pendingExits.toList();</span>
<span class="line-removed">2172                     pendingExits = new ListBuffer&lt;&gt;();</span>
<span class="line-removed">2173                     while (exits.nonEmpty()) {</span>
<span class="line-removed">2174                         PendingExit exit = exits.head;</span>
<span class="line-removed">2175                         exits = exits.tail;</span>
<span class="line-removed">2176                         Assert.check(exit.tree.hasTag(RETURN) ||</span>
<span class="line-removed">2177                                          log.hasErrorOn(exit.tree.pos()),</span>
<span class="line-removed">2178                                      exit.tree);</span>
<span class="line-removed">2179                         if (isInitialConstructor) {</span>
<span class="line-removed">2180                             Assert.check(exit instanceof AssignPendingExit);</span>
<span class="line-removed">2181                             inits.assign(((AssignPendingExit) exit).exit_inits);</span>
<span class="line-removed">2182                             for (int i = firstadr; i &lt; nextadr; i++) {</span>
<span class="line-removed">2183                                 checkInit(exit.tree.pos(), vardecls[i].sym);</span>
<span class="line-removed">2184                             }</span>
<span class="line-removed">2185                         }</span>
<span class="line-removed">2186                     }</span>
2187                 } finally {
2188                     inits.assign(initsPrev);
2189                     uninits.assign(uninitsPrev);
2190                     nextadr = nextadrPrev;
2191                     firstadr = firstadrPrev;
2192                     returnadr = returnadrPrev;
2193                     isInitialConstructor = lastInitialConstructor;
2194                 }
2195             } finally {
2196                 lint = lintPrev;
2197                 this.thisExposability = priorThisExposability;
2198             }
2199         }
2200 


















2201         protected void initParam(JCVariableDecl def) {
2202             inits.incl(def.sym.adr);
2203             uninits.excl(def.sym.adr);
2204         }
2205 
2206         public void visitVarDef(JCVariableDecl tree) {
2207             Lint lintPrev = lint;
2208             lint = lint.augment(tree.sym);
2209             try{
2210                 boolean track = trackable(tree.sym);
2211                 if (track &amp;&amp; (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {
2212                     newVar(tree);
2213                 }
2214                 if (tree.init != null) {
2215                     scanExpr(tree.init);
2216                     if (track) {
2217                         letInit(tree.pos(), tree.sym);
2218                     }
2219                 }
2220             } finally {
</pre>
</td>
<td>
<hr />
<pre>
 511                     scanStat(l.head);
 512         }
 513 
 514         /* ------------ Visitor methods for various sorts of trees -------------*/
 515 
 516         public void visitClassDef(JCClassDecl tree) {
 517             if (tree.sym == null) return;
 518             Liveness alivePrev = alive;
 519             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 520             Lint lintPrev = lint;
 521 
 522             pendingExits = new ListBuffer&lt;&gt;();
 523             lint = lint.augment(tree.sym);
 524 
 525             try {
 526                 // process all the static initializers
 527                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 528                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 529                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
 530                         scanDef(l.head);
<span class="line-added"> 531                         clearPendingExits(false);</span>
 532                     }
 533                 }
 534 
 535                 // process all the instance initializers
 536                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 537                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 538                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
 539                         scanDef(l.head);
<span class="line-added"> 540                         clearPendingExits(false);</span>
 541                     }
 542                 }
 543 
 544                 // process all the methods
 545                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 546                     if (l.head.hasTag(METHODDEF)) {
 547                         scan(l.head);
 548                     }
 549                 }
 550             } finally {
 551                 pendingExits = pendingExitsPrev;
 552                 alive = alivePrev;
 553                 lint = lintPrev;
 554             }
 555         }
 556 
 557         public void visitMethodDef(JCMethodDecl tree) {
 558             if (tree.body == null) return;
 559             Lint lintPrev = lint;
 560 
 561             lint = lint.augment(tree.sym);
 562 
 563             Assert.check(pendingExits.isEmpty());
 564 
 565             try {
 566                 alive = Liveness.ALIVE;
 567                 scanStat(tree.body);
 568                 tree.completesNormally = alive != Liveness.DEAD;
 569 
 570                 if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
 571                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 572 
<span class="line-modified"> 573                 clearPendingExits(true);</span>







 574             } finally {
 575                 lint = lintPrev;
 576             }
 577         }
 578 
<span class="line-added"> 579         private void clearPendingExits(boolean inMethod) {</span>
<span class="line-added"> 580             List&lt;PendingExit&gt; exits = pendingExits.toList();</span>
<span class="line-added"> 581             pendingExits = new ListBuffer&lt;&gt;();</span>
<span class="line-added"> 582             while (exits.nonEmpty()) {</span>
<span class="line-added"> 583                 PendingExit exit = exits.head;</span>
<span class="line-added"> 584                 exits = exits.tail;</span>
<span class="line-added"> 585                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||</span>
<span class="line-added"> 586                                 log.hasErrorOn(exit.tree.pos()));</span>
<span class="line-added"> 587             }</span>
<span class="line-added"> 588         }</span>
<span class="line-added"> 589 </span>
 590         public void visitVarDef(JCVariableDecl tree) {
 591             if (tree.init != null) {
 592                 Lint lintPrev = lint;
 593                 lint = lint.augment(tree.sym);
 594                 try{
 595                     scan(tree.init);
 596                 } finally {
 597                     lint = lintPrev;
 598                 }
 599             }
 600         }
 601 
 602         public void visitBlock(JCBlock tree) {
 603             scanStats(tree.stats);
 604         }
 605 
 606         public void visitDoLoop(JCDoWhileLoop tree) {
 607             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 608             pendingExits = new ListBuffer&lt;&gt;();
 609             scanStat(tree.body);
</pre>
<hr />
<pre>
 924 
 925             ThrownPendingExit(JCTree tree, Type thrown) {
 926                 super(tree);
 927                 this.thrown = thrown;
 928             }
 929         }
 930 
 931         @Override
 932         void markDead() {
 933             //do nothing
 934         }
 935 
 936         /*-------------------- Exceptions ----------------------*/
 937 
 938         /** Complain that pending exceptions are not caught.
 939          */
 940         void errorUncaught() {
 941             for (PendingExit exit = pendingExits.next();
 942                  exit != null;
 943                  exit = pendingExits.next()) {
<span class="line-modified"> 944                 if (exit instanceof ThrownPendingExit) {</span>
<span class="line-modified"> 945                     ThrownPendingExit thrownExit = (ThrownPendingExit) exit;</span>
<span class="line-modified"> 946                     if (classDef != null &amp;&amp;</span>
<span class="line-modified"> 947                         classDef.pos == exit.tree.pos) {</span>
<span class="line-modified"> 948                         log.error(exit.tree.pos(),</span>
<span class="line-modified"> 949                                   Errors.UnreportedExceptionDefaultConstructor(thrownExit.thrown));</span>
<span class="line-modified"> 950                     } else if (exit.tree.hasTag(VARDEF) &amp;&amp;</span>
<span class="line-modified"> 951                             ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {</span>
<span class="line-modified"> 952                         log.error(exit.tree.pos(),</span>
<span class="line-modified"> 953                                   Errors.UnreportedExceptionImplicitClose(thrownExit.thrown,</span>
<span class="line-modified"> 954                                                                           ((JCVariableDecl)exit.tree).sym.name));</span>
<span class="line-added"> 955                     } else {</span>
<span class="line-added"> 956                         log.error(exit.tree.pos(),</span>
<span class="line-added"> 957                                   Errors.UnreportedExceptionNeedToCatchOrThrow(thrownExit.thrown));</span>
<span class="line-added"> 958                     }</span>
 959                 } else {
<span class="line-modified"> 960                     Assert.check(log.hasErrorOn(exit.tree.pos()));</span>

 961                 }
 962             }
 963         }
 964 
 965         /** Record that exception is potentially thrown and check that it
 966          *  is caught.
 967          */
 968         void markThrown(JCTree tree, Type exc) {
 969             if (!chk.isUnchecked(tree.pos(), exc)) {
 970                 if (!chk.isHandled(exc, caught)) {
 971                     pendingExits.append(new ThrownPendingExit(tree, exc));
 972                 }
 973                 thrown = chk.incl(exc, thrown);
 974             }
 975         }
 976 
 977     /*************************************************************************
 978      * Visitor methods for statements and definitions
 979      *************************************************************************/
 980 
</pre>
<hr />
<pre>
2023                 classDef = tree;
2024                 try {
2025                     // define all the static fields
2026                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2027                         if (l.head.hasTag(VARDEF)) {
2028                             JCVariableDecl def = (JCVariableDecl)l.head;
2029                             if ((def.mods.flags &amp; STATIC) != 0) {
2030                                 VarSymbol sym = def.sym;
2031                                 if (trackable(sym)) {
2032                                     newVar(def);
2033                                 }
2034                             }
2035                         }
2036                     }
2037 
2038                     // process all the static initializers
2039                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2040                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2041                             (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
2042                             scan(l.head);
<span class="line-added">2043                             clearPendingExits(false);</span>
2044                         }
2045                     }
2046 
2047                     // define all the instance fields
2048                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2049                         if (l.head.hasTag(VARDEF)) {
2050                             JCVariableDecl def = (JCVariableDecl)l.head;
2051                             if ((def.mods.flags &amp; STATIC) == 0) {
2052                                 VarSymbol sym = def.sym;
2053                                 if (trackable(sym)) {
2054                                     newVar(def);
2055                                 }
2056                             }
2057                         }
2058                     }
2059 
2060                     // process all the instance initializers
2061                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2062                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2063                             (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
2064                             scan(l.head);
<span class="line-added">2065                             clearPendingExits(false);</span>
2066                         }
2067                     }
2068 
2069                     // process all the methods
2070                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2071                         if (l.head.hasTag(METHODDEF)) {
2072                             scan(l.head);
2073                         }
2074                     }
2075                 } finally {
2076                     pendingExits = pendingExitsPrev;
2077                     nextadr = nextadrPrev;
2078                     firstadr = firstadrPrev;
2079                     classDef = classDefPrev;
2080                 }
2081             } finally {
2082                 lint = lintPrev;
2083             }
2084         }
2085 
</pre>
<hr />
<pre>
2162                                             var.owner.kind == TYP;
2163                                     if (isInstanceRecordField) {
2164                                         boolean notInitialized = !inits.isMember(var.adr);
2165                                         if (notInitialized &amp;&amp; uninits.isMember(var.adr) &amp;&amp; tree.completesNormally) {
2166                                         /*  this way we indicate Lower that it should generate an initialization for this field
2167                                          *  in the compact constructor
2168                                          */
2169                                             var.flags_field |= UNINITIALIZED_FIELD;
2170                                         } else {
2171                                             checkInit(TreeInfo.diagEndPos(tree.body), var);
2172                                         }
2173                                     } else {
2174                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2175                                     }
2176                                 } else {
2177                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2178                                 }
2179                             }
2180                         }
2181                     }
<span class="line-modified">2182                     clearPendingExits(true);</span>















2183                 } finally {
2184                     inits.assign(initsPrev);
2185                     uninits.assign(uninitsPrev);
2186                     nextadr = nextadrPrev;
2187                     firstadr = firstadrPrev;
2188                     returnadr = returnadrPrev;
2189                     isInitialConstructor = lastInitialConstructor;
2190                 }
2191             } finally {
2192                 lint = lintPrev;
2193                 this.thisExposability = priorThisExposability;
2194             }
2195         }
2196 
<span class="line-added">2197         private void clearPendingExits(boolean inMethod) {</span>
<span class="line-added">2198             List&lt;PendingExit&gt; exits = pendingExits.toList();</span>
<span class="line-added">2199             pendingExits = new ListBuffer&lt;&gt;();</span>
<span class="line-added">2200             while (exits.nonEmpty()) {</span>
<span class="line-added">2201                 PendingExit exit = exits.head;</span>
<span class="line-added">2202                 exits = exits.tail;</span>
<span class="line-added">2203                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||</span>
<span class="line-added">2204                                  log.hasErrorOn(exit.tree.pos()),</span>
<span class="line-added">2205                              exit.tree);</span>
<span class="line-added">2206                 if (inMethod &amp;&amp; isInitialConstructor) {</span>
<span class="line-added">2207                     Assert.check(exit instanceof AssignPendingExit);</span>
<span class="line-added">2208                     inits.assign(((AssignPendingExit) exit).exit_inits);</span>
<span class="line-added">2209                     for (int i = firstadr; i &lt; nextadr; i++) {</span>
<span class="line-added">2210                         checkInit(exit.tree.pos(), vardecls[i].sym);</span>
<span class="line-added">2211                     }</span>
<span class="line-added">2212                 }</span>
<span class="line-added">2213             }</span>
<span class="line-added">2214         }</span>
2215         protected void initParam(JCVariableDecl def) {
2216             inits.incl(def.sym.adr);
2217             uninits.excl(def.sym.adr);
2218         }
2219 
2220         public void visitVarDef(JCVariableDecl tree) {
2221             Lint lintPrev = lint;
2222             lint = lint.augment(tree.sym);
2223             try{
2224                 boolean track = trackable(tree.sym);
2225                 if (track &amp;&amp; (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {
2226                     newVar(tree);
2227                 }
2228                 if (tree.init != null) {
2229                     scanExpr(tree.init);
2230                     if (track) {
2231                         letInit(tree.pos(), tree.sym);
2232                     }
2233                 }
2234             } finally {
</pre>
</td>
</tr>
</table>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LambdaToMethod.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //todo: one might eliminate uninits.andSets when monotonic
  27 
  28 package com.sun.tools.javac.comp;
  29 
  30 import java.util.HashMap;
  31 import java.util.HashSet;
  32 import java.util.Set;
  33 import java.util.stream.Collectors;
  34 
  35 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Scope.WriteableScope;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  40 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  41 import com.sun.tools.javac.tree.*;
  42 import com.sun.tools.javac.util.*;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.JCDiagnostic.Error;
  45 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  46 
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;
  55 import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;
  56 import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;
  57 import static com.sun.tools.javac.comp.Flow.ThisExposability.DISCOURAGED;
  58 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  59 
  60 /** This pass implements dataflow analysis for Java programs though
  61  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  62  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  63  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  64  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  65  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  66  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
  67  *  determines that local variables accessed within the scope of an inner class/lambda
  68  *  are either final or effectively-final.
  69  *
  70  *  &lt;p&gt;The JLS has a number of problems in the
  71  *  specification of these flow analysis problems. This implementation
  72  *  attempts to address those issues.
  73  *
  74  *  &lt;p&gt;First, there is no accommodation for a finally clause that cannot
  75  *  complete normally. For liveness analysis, an intervening finally
  76  *  clause can cause a break, continue, or return not to reach its
  77  *  target.  For exception analysis, an intervening finally clause can
  78  *  cause any exception to be &quot;caught&quot;.  For DA/DU analysis, the finally
  79  *  clause can prevent a transfer of control from propagating DA/DU
  80  *  state to the target.  In addition, code in the finally clause can
  81  *  affect the DA/DU status of variables.
  82  *
  83  *  &lt;p&gt;For try statements, we introduce the idea of a variable being
  84  *  definitely unassigned &quot;everywhere&quot; in a block.  A variable V is
  85  *  &quot;unassigned everywhere&quot; in a block iff it is unassigned at the
  86  *  beginning of the block and there is no reachable assignment to V
  87  *  in the block.  An assignment V=e is reachable iff V is not DA
  88  *  after e.  Then we can say that V is DU at the beginning of the
  89  *  catch block iff V is DU everywhere in the try block.  Similarly, V
  90  *  is DU at the beginning of the finally block iff V is DU everywhere
  91  *  in the try block and in every catch block.  Specifically, the
  92  *  following bullet is added to 16.2.2
  93  *  &lt;pre&gt;
  94  *      V is &lt;em&gt;unassigned everywhere&lt;/em&gt; in a block if it is
  95  *      unassigned before the block and there is no reachable
  96  *      assignment to V within the block.
  97  *  &lt;/pre&gt;
  98  *  &lt;p&gt;In 16.2.15, the third bullet (and all of its sub-bullets) for all
  99  *  try blocks is changed to
 100  *  &lt;pre&gt;
 101  *      V is definitely unassigned before a catch block iff V is
 102  *      definitely unassigned everywhere in the try block.
 103  *  &lt;/pre&gt;
 104  *  &lt;p&gt;The last bullet (and all of its sub-bullets) for try blocks that
 105  *  have a finally block is changed to
 106  *  &lt;pre&gt;
 107  *      V is definitely unassigned before the finally block iff
 108  *      V is definitely unassigned everywhere in the try block
 109  *      and everywhere in each catch block of the try statement.
 110  *  &lt;/pre&gt;
 111  *  &lt;p&gt;In addition,
 112  *  &lt;pre&gt;
 113  *      V is definitely assigned at the end of a constructor iff
 114  *      V is definitely assigned after the block that is the body
 115  *      of the constructor and V is definitely assigned at every
 116  *      return that can return from the constructor.
 117  *  &lt;/pre&gt;
 118  *  &lt;p&gt;In addition, each continue statement with the loop as its target
 119  *  is treated as a jump to the end of the loop body, and &quot;intervening&quot;
 120  *  finally clauses are treated as follows: V is DA &quot;due to the
 121  *  continue&quot; iff V is DA before the continue statement or V is DA at
 122  *  the end of any intervening finally block.  V is DU &quot;due to the
 123  *  continue&quot; iff any intervening finally cannot complete normally or V
 124  *  is DU at the end of every intervening finally block.  This &quot;due to
 125  *  the continue&quot; concept is then used in the spec for the loops.
 126  *
 127  *  &lt;p&gt;Similarly, break statements must consider intervening finally
 128  *  blocks.  For liveness analysis, a break statement for which any
 129  *  intervening finally cannot complete normally is not considered to
 130  *  cause the target statement to be able to complete normally. Then
 131  *  we say V is DA &quot;due to the break&quot; iff V is DA before the break or
 132  *  V is DA at the end of any intervening finally block.  V is DU &quot;due
 133  *  to the break&quot; iff any intervening finally cannot complete normally
 134  *  or V is DU at the break and at the end of every intervening
 135  *  finally block.  (I suspect this latter condition can be
 136  *  simplified.)  This &quot;due to the break&quot; is then used in the spec for
 137  *  all statements that can be &quot;broken&quot;.
 138  *
 139  *  &lt;p&gt;The return statement is treated similarly.  V is DA &quot;due to a
 140  *  return statement&quot; iff V is DA before the return statement or V is
 141  *  DA at the end of any intervening finally block.  Note that we
 142  *  don&#39;t have to worry about the return expression because this
 143  *  concept is only used for constructors.
 144  *
 145  *  &lt;p&gt;There is no spec in the JLS for when a variable is definitely
 146  *  assigned at the end of a constructor, which is needed for final
 147  *  fields (8.3.1.2).  We implement the rule that V is DA at the end
 148  *  of the constructor iff it is DA and the end of the body of the
 149  *  constructor and V is DA &quot;due to&quot; every return of the constructor.
 150  *
 151  *  &lt;p&gt;Intervening finally blocks similarly affect exception analysis.  An
 152  *  intervening finally that cannot complete normally allows us to ignore
 153  *  an otherwise uncaught exception.
 154  *
 155  *  &lt;p&gt;To implement the semantics of intervening finally clauses, all
 156  *  nonlocal transfers (break, continue, return, throw, method call that
 157  *  can throw a checked exception, and a constructor invocation that can
 158  *  thrown a checked exception) are recorded in a queue, and removed
 159  *  from the queue when we complete processing the target of the
 160  *  nonlocal transfer.  This allows us to modify the queue in accordance
 161  *  with the above rules when we encounter a finally clause.  The only
 162  *  exception to this [no pun intended] is that checked exceptions that
 163  *  are known to be caught or declared to be caught in the enclosing
 164  *  method are not recorded in the queue, but instead are recorded in a
 165  *  global variable &quot;{@code Set&lt;Type&gt; thrown}&quot; that records the type of all
 166  *  exceptions that can be thrown.
 167  *
 168  *  &lt;p&gt;Other minor issues the treatment of members of other classes
 169  *  (always considered DA except that within an anonymous class
 170  *  constructor, where DA status from the enclosing scope is
 171  *  preserved), treatment of the case expression (V is DA before the
 172  *  case expression iff V is DA after the switch expression),
 173  *  treatment of variables declared in a switch block (the implied
 174  *  DA/DU status after the switch expression is DU and not DA for
 175  *  variables defined in a switch block), the treatment of boolean ?:
 176  *  expressions (The JLS rules only handle b and c non-boolean; the
 177  *  new rule is that if b and c are boolean valued, then V is
 178  *  (un)assigned after a?b:c when true/false iff V is (un)assigned
 179  *  after b when true/false and V is (un)assigned after c when
 180  *  true/false).
 181  *
 182  *  &lt;p&gt;There is the remaining question of what syntactic forms constitute a
 183  *  reference to a variable.  It is conventional to allow this.x on the
 184  *  left-hand-side to initialize a final instance field named x, yet
 185  *  this.x isn&#39;t considered a &quot;use&quot; when appearing on a right-hand-side
 186  *  in most implementations.  Should parentheses affect what is
 187  *  considered a variable reference?  The simplest rule would be to
 188  *  allow unqualified forms only, parentheses optional, and phase out
 189  *  support for assigning to a final field via this.x.
 190  *
 191  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 192  *  If you write code that depends on this, you do so at your own risk.
 193  *  This code and its internal interfaces are subject to change or
 194  *  deletion without notice.&lt;/b&gt;
 195  */
 196 public class Flow {
 197     protected static final Context.Key&lt;Flow&gt; flowKey = new Context.Key&lt;&gt;();
 198 
 199     private final Names names;
 200     private final Log log;
 201     private final Symtab syms;
 202     private final Types types;
 203     private final Check chk;
 204     private       TreeMaker make;
 205     private final Resolve rs;
 206     private final JCDiagnostic.Factory diags;
 207     private Env&lt;AttrContext&gt; attrEnv;
 208     private       Lint lint;
 209     private final boolean allowEffectivelyFinalInInnerClasses;
 210 
 211     public static Flow instance(Context context) {
 212         Flow instance = context.get(flowKey);
 213         if (instance == null)
 214             instance = new Flow(context);
 215         return instance;
 216     }
 217 
 218     public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 219         new AliveAnalyzer().analyzeTree(env, make);
 220         new AssignAnalyzer().analyzeTree(env, make);
 221         new FlowAnalyzer().analyzeTree(env, make);
 222         new CaptureAnalyzer().analyzeTree(env, make);
 223     }
 224 
 225     public void analyzeLambda(Env&lt;AttrContext&gt; env, JCLambda that, TreeMaker make, boolean speculative) {
 226         Log.DiagnosticHandler diagHandler = null;
 227         //we need to disable diagnostics temporarily; the problem is that if
 228         //a lambda expression contains e.g. an unreachable statement, an error
 229         //message will be reported and will cause compilation to skip the flow analysis
 230         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 231         //related errors, which will allow for more errors to be detected
 232         if (!speculative) {
 233             diagHandler = new Log.DiscardDiagnosticHandler(log);
 234         }
 235         try {
 236             new LambdaAliveAnalyzer().analyzeTree(env, that, make);
 237         } finally {
 238             if (!speculative) {
 239                 log.popDiagnosticHandler(diagHandler);
 240             }
 241         }
 242     }
 243 
 244     public List&lt;Type&gt; analyzeLambdaThrownTypes(final Env&lt;AttrContext&gt; env,
 245             JCLambda that, TreeMaker make) {
 246         //we need to disable diagnostics temporarily; the problem is that if
 247         //a lambda expression contains e.g. an unreachable statement, an error
 248         //message will be reported and will cause compilation to skip the flow analysis
 249         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 250         //related errors, which will allow for more errors to be detected
 251         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 252         try {
 253             new LambdaAssignAnalyzer(env).analyzeTree(env, that, make);
 254             LambdaFlowAnalyzer flowAnalyzer = new LambdaFlowAnalyzer();
 255             flowAnalyzer.analyzeTree(env, that, make);
 256             return flowAnalyzer.inferredThrownTypes;
 257         } finally {
 258             log.popDiagnosticHandler(diagHandler);
 259         }
 260     }
 261 
 262     public boolean aliveAfter(Env&lt;AttrContext&gt; env, JCTree that, TreeMaker make) {
 263         //we need to disable diagnostics temporarily; the problem is that if
 264         //&quot;that&quot; contains e.g. an unreachable statement, an error
 265         //message will be reported and will cause compilation to skip the flow analysis
 266         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 267         //related errors, which will allow for more errors to be detected
 268         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 269         try {
 270             SnippetAliveAnalyzer analyzer = new SnippetAliveAnalyzer();
 271 
 272             analyzer.analyzeTree(env, that, make);
 273             return analyzer.isAlive();
 274         } finally {
 275             log.popDiagnosticHandler(diagHandler);
 276         }
 277     }
 278 
 279     public boolean breaksOutOf(Env&lt;AttrContext&gt; env, JCTree loop, JCTree body, TreeMaker make) {
 280         //we need to disable diagnostics temporarily; the problem is that if
 281         //&quot;that&quot; contains e.g. an unreachable statement, an error
 282         //message will be reported and will cause compilation to skip the flow analysis
 283         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 284         //related errors, which will allow for more errors to be detected
 285         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 286         try {
 287             SnippetBreakAnalyzer analyzer = new SnippetBreakAnalyzer();
 288 
 289             analyzer.analyzeTree(env, body, make);
 290             return analyzer.breaksOut();
 291         } finally {
 292             log.popDiagnosticHandler(diagHandler);
 293         }
 294     }
 295 
 296     /**
 297      * Definite assignment scan mode
 298      */
 299     enum FlowKind {
 300         /**
 301          * This is the normal DA/DU analysis mode
 302          */
 303         NORMAL(&quot;var.might.already.be.assigned&quot;, false),
 304         /**
 305          * This is the speculative DA/DU analysis mode used to speculatively
 306          * derive assertions within loop bodies
 307          */
 308         SPECULATIVE_LOOP(&quot;var.might.be.assigned.in.loop&quot;, true);
 309 
 310         final String errKey;
 311         final boolean isFinal;
 312 
 313         FlowKind(String errKey, boolean isFinal) {
 314             this.errKey = errKey;
 315             this.isFinal = isFinal;
 316         }
 317 
 318         boolean isFinal() {
 319             return isFinal;
 320         }
 321     }
 322 
 323     protected Flow(Context context) {
 324         context.put(flowKey, this);
 325         names = Names.instance(context);
 326         log = Log.instance(context);
 327         syms = Symtab.instance(context);
 328         types = Types.instance(context);
 329         chk = Check.instance(context);
 330         lint = Lint.instance(context);
 331         rs = Resolve.instance(context);
 332         diags = JCDiagnostic.Factory.instance(context);
 333         Source source = Source.instance(context);
 334         allowEffectivelyFinalInInnerClasses = Feature.EFFECTIVELY_FINAL_IN_INNER_CLASSES.allowedInSource(source);
 335     }
 336 
 337     /**
 338      * Base visitor class for all visitors implementing dataflow analysis logic.
 339      * This class define the shared logic for handling jumps (break/continue statements).
 340      */
 341     static abstract class BaseAnalyzer extends TreeScanner {
 342 
 343         enum JumpKind {
 344             BREAK(JCTree.Tag.BREAK) {
 345                 @Override
 346                 JCTree getTarget(JCTree tree) {
 347                     return ((JCBreak)tree).target;
 348                 }
 349             },
 350             CONTINUE(JCTree.Tag.CONTINUE) {
 351                 @Override
 352                 JCTree getTarget(JCTree tree) {
 353                     return ((JCContinue)tree).target;
 354                 }
 355             },
 356             YIELD(JCTree.Tag.YIELD) {
 357                 @Override
 358                 JCTree getTarget(JCTree tree) {
 359                     return ((JCYield)tree).target;
 360                 }
 361             };
 362 
 363             final JCTree.Tag treeTag;
 364 
 365             private JumpKind(Tag treeTag) {
 366                 this.treeTag = treeTag;
 367             }
 368 
 369             abstract JCTree getTarget(JCTree tree);
 370         }
 371 
 372         /** The currently pending exits that go from current inner blocks
 373          *  to an enclosing block, in source order.
 374          */
 375         ListBuffer&lt;PendingExit&gt; pendingExits;
 376 
 377         /** A pending exit.  These are the statements return, break, and
 378          *  continue.  In addition, exception-throwing expressions or
 379          *  statements are put here when not known to be caught.  This
 380          *  will typically result in an error unless it is within a
 381          *  try-finally whose finally block cannot complete normally.
 382          */
 383         static class PendingExit {
 384             JCTree tree;
 385 
 386             PendingExit(JCTree tree) {
 387                 this.tree = tree;
 388             }
 389 
 390             void resolveJump() {
 391                 //do nothing
 392             }
 393         }
 394 
 395         abstract void markDead();
 396 
 397         /** Record an outward transfer of control. */
 398         void recordExit(PendingExit pe) {
 399             pendingExits.append(pe);
 400             markDead();
 401         }
 402 
 403         /** Resolve all jumps of this statement. */
 404         private Liveness resolveJump(JCTree tree,
 405                          ListBuffer&lt;PendingExit&gt; oldPendingExits,
 406                          JumpKind jk) {
 407             boolean resolved = false;
 408             List&lt;PendingExit&gt; exits = pendingExits.toList();
 409             pendingExits = oldPendingExits;
 410             for (; exits.nonEmpty(); exits = exits.tail) {
 411                 PendingExit exit = exits.head;
 412                 if (exit.tree.hasTag(jk.treeTag) &amp;&amp;
 413                         jk.getTarget(exit.tree) == tree) {
 414                     exit.resolveJump();
 415                     resolved = true;
 416                 } else {
 417                     pendingExits.append(exit);
 418                 }
 419             }
 420             return Liveness.from(resolved);
 421         }
 422 
 423         /** Resolve all continues of this statement. */
 424         Liveness resolveContinues(JCTree tree) {
 425             return resolveJump(tree, new ListBuffer&lt;PendingExit&gt;(), JumpKind.CONTINUE);
 426         }
 427 
 428         /** Resolve all breaks of this statement. */
 429         Liveness resolveBreaks(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 430             return resolveJump(tree, oldPendingExits, JumpKind.BREAK);
 431         }
 432 
 433         /** Resolve all yields of this statement. */
 434         Liveness resolveYields(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 435             return resolveJump(tree, oldPendingExits, JumpKind.YIELD);
 436         }
 437 
 438         @Override
 439         public void scan(JCTree tree) {
 440             if (tree != null &amp;&amp; (
 441                     tree.type == null ||
 442                     tree.type != Type.stuckType)) {
 443                 super.scan(tree);
 444             }
 445         }
 446 
 447         public void visitPackageDef(JCPackageDecl tree) {
 448             // Do nothing for PackageDecl
 449         }
 450 
 451         protected void scanSyntheticBreak(TreeMaker make, JCTree swtch) {
 452             if (swtch.hasTag(SWITCH_EXPRESSION)) {
 453                 JCYield brk = make.at(Position.NOPOS).Yield(null);
 454                 brk.target = swtch;
 455                 scan(brk);
 456             } else {
 457                 JCBreak brk = make.at(Position.NOPOS).Break(null);
 458                 brk.target = swtch;
 459                 scan(brk);
 460             }
 461         }
 462     }
 463 
 464     /**
 465      * This pass implements the first step of the dataflow analysis, namely
 466      * the liveness analysis check. This checks that every statement is reachable.
 467      * The output of this analysis pass are used by other analyzers. This analyzer
 468      * sets the &#39;finallyCanCompleteNormally&#39; field in the JCTry class.
 469      */
 470     class AliveAnalyzer extends BaseAnalyzer {
 471 
 472         /** A flag that indicates whether the last statement could
 473          *  complete normally.
 474          */
 475         private Liveness alive;
 476 
 477         @Override
 478         void markDead() {
 479             alive = Liveness.DEAD;
 480         }
 481 
 482     /*************************************************************************
 483      * Visitor methods for statements and definitions
 484      *************************************************************************/
 485 
 486         /** Analyze a definition.
 487          */
 488         void scanDef(JCTree tree) {
 489             scanStat(tree);
 490             if (tree != null &amp;&amp; tree.hasTag(JCTree.Tag.BLOCK) &amp;&amp; alive == Liveness.DEAD) {
 491                 log.error(tree.pos(),
 492                           Errors.InitializerMustBeAbleToCompleteNormally);
 493             }
 494         }
 495 
 496         /** Analyze a statement. Check that statement is reachable.
 497          */
 498         void scanStat(JCTree tree) {
 499             if (alive == Liveness.DEAD &amp;&amp; tree != null) {
 500                 log.error(tree.pos(), Errors.UnreachableStmt);
 501                 if (!tree.hasTag(SKIP)) alive = Liveness.RECOVERY;
 502             }
 503             scan(tree);
 504         }
 505 
 506         /** Analyze list of statements.
 507          */
 508         void scanStats(List&lt;? extends JCStatement&gt; trees) {
 509             if (trees != null)
 510                 for (List&lt;? extends JCStatement&gt; l = trees; l.nonEmpty(); l = l.tail)
 511                     scanStat(l.head);
 512         }
 513 
 514         /* ------------ Visitor methods for various sorts of trees -------------*/
 515 
 516         public void visitClassDef(JCClassDecl tree) {
 517             if (tree.sym == null) return;
 518             Liveness alivePrev = alive;
 519             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 520             Lint lintPrev = lint;
 521 
 522             pendingExits = new ListBuffer&lt;&gt;();
 523             lint = lint.augment(tree.sym);
 524 
 525             try {
 526                 // process all the static initializers
 527                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 528                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 529                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
 530                         scanDef(l.head);
 531                         clearPendingExits(false);
 532                     }
 533                 }
 534 
 535                 // process all the instance initializers
 536                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 537                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 538                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
 539                         scanDef(l.head);
 540                         clearPendingExits(false);
 541                     }
 542                 }
 543 
 544                 // process all the methods
 545                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 546                     if (l.head.hasTag(METHODDEF)) {
 547                         scan(l.head);
 548                     }
 549                 }
 550             } finally {
 551                 pendingExits = pendingExitsPrev;
 552                 alive = alivePrev;
 553                 lint = lintPrev;
 554             }
 555         }
 556 
 557         public void visitMethodDef(JCMethodDecl tree) {
 558             if (tree.body == null) return;
 559             Lint lintPrev = lint;
 560 
 561             lint = lint.augment(tree.sym);
 562 
 563             Assert.check(pendingExits.isEmpty());
 564 
 565             try {
 566                 alive = Liveness.ALIVE;
 567                 scanStat(tree.body);
 568                 tree.completesNormally = alive != Liveness.DEAD;
 569 
 570                 if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
 571                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 572 
 573                 clearPendingExits(true);
 574             } finally {
 575                 lint = lintPrev;
 576             }
 577         }
 578 
 579         private void clearPendingExits(boolean inMethod) {
 580             List&lt;PendingExit&gt; exits = pendingExits.toList();
 581             pendingExits = new ListBuffer&lt;&gt;();
 582             while (exits.nonEmpty()) {
 583                 PendingExit exit = exits.head;
 584                 exits = exits.tail;
 585                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
 586                                 log.hasErrorOn(exit.tree.pos()));
 587             }
 588         }
 589 
 590         public void visitVarDef(JCVariableDecl tree) {
 591             if (tree.init != null) {
 592                 Lint lintPrev = lint;
 593                 lint = lint.augment(tree.sym);
 594                 try{
 595                     scan(tree.init);
 596                 } finally {
 597                     lint = lintPrev;
 598                 }
 599             }
 600         }
 601 
 602         public void visitBlock(JCBlock tree) {
 603             scanStats(tree.stats);
 604         }
 605 
 606         public void visitDoLoop(JCDoWhileLoop tree) {
 607             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 608             pendingExits = new ListBuffer&lt;&gt;();
 609             scanStat(tree.body);
 610             alive = alive.or(resolveContinues(tree));
 611             scan(tree.cond);
 612             alive = alive.and(!tree.cond.type.isTrue());
 613             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 614         }
 615 
 616         public void visitWhileLoop(JCWhileLoop tree) {
 617             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 618             pendingExits = new ListBuffer&lt;&gt;();
 619             scan(tree.cond);
 620             alive = Liveness.from(!tree.cond.type.isFalse());
 621             scanStat(tree.body);
 622             alive = alive.or(resolveContinues(tree));
 623             alive = resolveBreaks(tree, prevPendingExits).or(
 624                 !tree.cond.type.isTrue());
 625         }
 626 
 627         public void visitForLoop(JCForLoop tree) {
 628             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 629             scanStats(tree.init);
 630             pendingExits = new ListBuffer&lt;&gt;();
 631             if (tree.cond != null) {
 632                 scan(tree.cond);
 633                 alive = Liveness.from(!tree.cond.type.isFalse());
 634             } else {
 635                 alive = Liveness.ALIVE;
 636             }
 637             scanStat(tree.body);
 638             alive = alive.or(resolveContinues(tree));
 639             scan(tree.step);
 640             alive = resolveBreaks(tree, prevPendingExits).or(
 641                 tree.cond != null &amp;&amp; !tree.cond.type.isTrue());
 642         }
 643 
 644         public void visitForeachLoop(JCEnhancedForLoop tree) {
 645             visitVarDef(tree.var);
 646             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 647             scan(tree.expr);
 648             pendingExits = new ListBuffer&lt;&gt;();
 649             scanStat(tree.body);
 650             alive = alive.or(resolveContinues(tree));
 651             resolveBreaks(tree, prevPendingExits);
 652             alive = Liveness.ALIVE;
 653         }
 654 
 655         public void visitLabelled(JCLabeledStatement tree) {
 656             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 657             pendingExits = new ListBuffer&lt;&gt;();
 658             scanStat(tree.body);
 659             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 660         }
 661 
 662         public void visitSwitch(JCSwitch tree) {
 663             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 664             pendingExits = new ListBuffer&lt;&gt;();
 665             scan(tree.selector);
 666             boolean hasDefault = false;
 667             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 668                 alive = Liveness.ALIVE;
 669                 JCCase c = l.head;
 670                 if (c.pats.isEmpty())
 671                     hasDefault = true;
 672                 else {
 673                     for (JCExpression pat : c.pats) {
 674                         scan(pat);
 675                     }
 676                 }
 677                 scanStats(c.stats);
 678                 c.completesNormally = alive != Liveness.DEAD;
 679                 if (alive != Liveness.DEAD &amp;&amp; c.caseKind == JCCase.RULE) {
 680                     scanSyntheticBreak(make, tree);
 681                     alive = Liveness.DEAD;
 682                 }
 683                 // Warn about fall-through if lint switch fallthrough enabled.
 684                 if (alive == Liveness.ALIVE &amp;&amp;
 685                     lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &amp;&amp;
 686                     c.stats.nonEmpty() &amp;&amp; l.tail.nonEmpty())
 687                     log.warning(Lint.LintCategory.FALLTHROUGH,
 688                                 l.tail.head.pos(),
 689                                 Warnings.PossibleFallThroughIntoCase);
 690             }
 691             if (!hasDefault) {
 692                 alive = Liveness.ALIVE;
 693             }
 694             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 695         }
 696 
 697         @Override
 698         public void visitSwitchExpression(JCSwitchExpression tree) {
 699             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 700             pendingExits = new ListBuffer&lt;&gt;();
 701             scan(tree.selector);
 702             Set&lt;Object&gt; constants = null;
 703             if ((tree.selector.type.tsym.flags() &amp; ENUM) != 0) {
 704                 constants = new HashSet&lt;&gt;();
 705                 for (Symbol s : tree.selector.type.tsym.members().getSymbols(s -&gt; (s.flags() &amp; ENUM) != 0)) {
 706                     constants.add(s.name);
 707                 }
 708             }
 709             boolean hasDefault = false;
 710             Liveness prevAlive = alive;
 711             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 712                 alive = Liveness.ALIVE;
 713                 JCCase c = l.head;
 714                 if (c.pats.isEmpty())
 715                     hasDefault = true;
 716                 else {
 717                     for (JCExpression pat : c.pats) {
 718                         scan(pat);
 719                         if (constants != null) {
 720                             if (pat.hasTag(IDENT))
 721                                 constants.remove(((JCIdent) pat).name);
 722                             if (pat.type != null)
 723                                 constants.remove(pat.type.constValue());
 724                         }
 725                     }
 726                 }
 727                 scanStats(c.stats);
 728                 if (alive == Liveness.ALIVE) {
 729                     if (c.caseKind == JCCase.RULE) {
 730                         log.error(TreeInfo.diagEndPos(c.body),
 731                                   Errors.RuleCompletesNormally);
 732                     } else if (l.tail.isEmpty()) {
 733                         log.error(TreeInfo.diagEndPos(tree),
 734                                   Errors.SwitchExpressionCompletesNormally);
 735                     }
 736                 }
 737                 c.completesNormally = alive != Liveness.DEAD;
 738             }
 739             if ((constants == null || !constants.isEmpty()) &amp;&amp; !hasDefault) {
 740                 log.error(tree, Errors.NotExhaustive);
 741             }
 742             alive = prevAlive;
 743             alive = alive.or(resolveYields(tree, prevPendingExits));
 744         }
 745 
 746         public void visitTry(JCTry tree) {
 747             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 748             pendingExits = new ListBuffer&lt;&gt;();
 749             for (JCTree resource : tree.resources) {
 750                 if (resource instanceof JCVariableDecl) {
 751                     JCVariableDecl vdecl = (JCVariableDecl) resource;
 752                     visitVarDef(vdecl);
 753                 } else if (resource instanceof JCExpression) {
 754                     scan((JCExpression) resource);
 755                 } else {
 756                     throw new AssertionError(tree);  // parser error
 757                 }
 758             }
 759 
 760             scanStat(tree.body);
 761             Liveness aliveEnd = alive;
 762 
 763             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
 764                 alive = Liveness.ALIVE;
 765                 JCVariableDecl param = l.head.param;
 766                 scan(param);
 767                 scanStat(l.head.body);
 768                 aliveEnd = aliveEnd.or(alive);
 769             }
 770             if (tree.finalizer != null) {
 771                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 772                 pendingExits = prevPendingExits;
 773                 alive = Liveness.ALIVE;
 774                 scanStat(tree.finalizer);
 775                 tree.finallyCanCompleteNormally = alive != Liveness.DEAD;
 776                 if (alive == Liveness.DEAD) {
 777                     if (lint.isEnabled(Lint.LintCategory.FINALLY)) {
 778                         log.warning(Lint.LintCategory.FINALLY,
 779                                 TreeInfo.diagEndPos(tree.finalizer),
 780                                 Warnings.FinallyCannotComplete);
 781                     }
 782                 } else {
 783                     while (exits.nonEmpty()) {
 784                         pendingExits.append(exits.next());
 785                     }
 786                     alive = aliveEnd;
 787                 }
 788             } else {
 789                 alive = aliveEnd;
 790                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 791                 pendingExits = prevPendingExits;
 792                 while (exits.nonEmpty()) pendingExits.append(exits.next());
 793             }
 794         }
 795 
 796         @Override
 797         public void visitIf(JCIf tree) {
 798             scan(tree.cond);
 799             scanStat(tree.thenpart);
 800             if (tree.elsepart != null) {
 801                 Liveness aliveAfterThen = alive;
 802                 alive = Liveness.ALIVE;
 803                 scanStat(tree.elsepart);
 804                 alive = alive.or(aliveAfterThen);
 805             } else {
 806                 alive = Liveness.ALIVE;
 807             }
 808         }
 809 
 810         public void visitBreak(JCBreak tree) {
 811             recordExit(new PendingExit(tree));
 812         }
 813 
 814         @Override
 815         public void visitYield(JCYield tree) {
 816             scan(tree.value);
 817             recordExit(new PendingExit(tree));
 818         }
 819 
 820         public void visitContinue(JCContinue tree) {
 821             recordExit(new PendingExit(tree));
 822         }
 823 
 824         public void visitReturn(JCReturn tree) {
 825             scan(tree.expr);
 826             recordExit(new PendingExit(tree));
 827         }
 828 
 829         public void visitThrow(JCThrow tree) {
 830             scan(tree.expr);
 831             markDead();
 832         }
 833 
 834         public void visitApply(JCMethodInvocation tree) {
 835             scan(tree.meth);
 836             scan(tree.args);
 837         }
 838 
 839         public void visitNewClass(JCNewClass tree) {
 840             scan(tree.encl);
 841             scan(tree.args);
 842             if (tree.def != null) {
 843                 scan(tree.def);
 844             }
 845         }
 846 
 847         @Override
 848         public void visitLambda(JCLambda tree) {
 849             if (tree.type != null &amp;&amp;
 850                     tree.type.isErroneous()) {
 851                 return;
 852             }
 853 
 854             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
 855             Liveness prevAlive = alive;
 856             try {
 857                 pendingExits = new ListBuffer&lt;&gt;();
 858                 alive = Liveness.ALIVE;
 859                 scanStat(tree.body);
 860                 tree.canCompleteNormally = alive != Liveness.DEAD;
 861             }
 862             finally {
 863                 pendingExits = prevPending;
 864                 alive = prevAlive;
 865             }
 866         }
 867 
 868         public void visitModuleDef(JCModuleDecl tree) {
 869             // Do nothing for modules
 870         }
 871 
 872     /**************************************************************************
 873      * main method
 874      *************************************************************************/
 875 
 876         /** Perform definite assignment/unassignment analysis on a tree.
 877          */
 878         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 879             analyzeTree(env, env.tree, make);
 880         }
 881         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
 882             try {
 883                 attrEnv = env;
 884                 Flow.this.make = make;
 885                 pendingExits = new ListBuffer&lt;&gt;();
 886                 alive = Liveness.ALIVE;
 887                 scan(tree);
 888             } finally {
 889                 pendingExits = null;
 890                 Flow.this.make = null;
 891             }
 892         }
 893     }
 894 
 895     /**
 896      * This pass implements the second step of the dataflow analysis, namely
 897      * the exception analysis. This is to ensure that every checked exception that is
 898      * thrown is declared or caught. The analyzer uses some info that has been set by
 899      * the liveliness analyzer.
 900      */
 901     class FlowAnalyzer extends BaseAnalyzer {
 902 
 903         /** A flag that indicates whether the last statement could
 904          *  complete normally.
 905          */
 906         HashMap&lt;Symbol, List&lt;Type&gt;&gt; preciseRethrowTypes;
 907 
 908         /** The current class being defined.
 909          */
 910         JCClassDecl classDef;
 911 
 912         /** The list of possibly thrown declarable exceptions.
 913          */
 914         List&lt;Type&gt; thrown;
 915 
 916         /** The list of exceptions that are either caught or declared to be
 917          *  thrown.
 918          */
 919         List&lt;Type&gt; caught;
 920 
 921         class ThrownPendingExit extends BaseAnalyzer.PendingExit {
 922 
 923             Type thrown;
 924 
 925             ThrownPendingExit(JCTree tree, Type thrown) {
 926                 super(tree);
 927                 this.thrown = thrown;
 928             }
 929         }
 930 
 931         @Override
 932         void markDead() {
 933             //do nothing
 934         }
 935 
 936         /*-------------------- Exceptions ----------------------*/
 937 
 938         /** Complain that pending exceptions are not caught.
 939          */
 940         void errorUncaught() {
 941             for (PendingExit exit = pendingExits.next();
 942                  exit != null;
 943                  exit = pendingExits.next()) {
 944                 if (exit instanceof ThrownPendingExit) {
 945                     ThrownPendingExit thrownExit = (ThrownPendingExit) exit;
 946                     if (classDef != null &amp;&amp;
 947                         classDef.pos == exit.tree.pos) {
 948                         log.error(exit.tree.pos(),
 949                                   Errors.UnreportedExceptionDefaultConstructor(thrownExit.thrown));
 950                     } else if (exit.tree.hasTag(VARDEF) &amp;&amp;
 951                             ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {
 952                         log.error(exit.tree.pos(),
 953                                   Errors.UnreportedExceptionImplicitClose(thrownExit.thrown,
 954                                                                           ((JCVariableDecl)exit.tree).sym.name));
 955                     } else {
 956                         log.error(exit.tree.pos(),
 957                                   Errors.UnreportedExceptionNeedToCatchOrThrow(thrownExit.thrown));
 958                     }
 959                 } else {
 960                     Assert.check(log.hasErrorOn(exit.tree.pos()));
 961                 }
 962             }
 963         }
 964 
 965         /** Record that exception is potentially thrown and check that it
 966          *  is caught.
 967          */
 968         void markThrown(JCTree tree, Type exc) {
 969             if (!chk.isUnchecked(tree.pos(), exc)) {
 970                 if (!chk.isHandled(exc, caught)) {
 971                     pendingExits.append(new ThrownPendingExit(tree, exc));
 972                 }
 973                 thrown = chk.incl(exc, thrown);
 974             }
 975         }
 976 
 977     /*************************************************************************
 978      * Visitor methods for statements and definitions
 979      *************************************************************************/
 980 
 981         /* ------------ Visitor methods for various sorts of trees -------------*/
 982 
 983         public void visitClassDef(JCClassDecl tree) {
 984             if (tree.sym == null) return;
 985 
 986             JCClassDecl classDefPrev = classDef;
 987             List&lt;Type&gt; thrownPrev = thrown;
 988             List&lt;Type&gt; caughtPrev = caught;
 989             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 990             Lint lintPrev = lint;
 991             boolean anonymousClass = tree.name == names.empty;
 992             pendingExits = new ListBuffer&lt;&gt;();
 993             if (!anonymousClass) {
 994                 caught = List.nil();
 995             }
 996             classDef = tree;
 997             thrown = List.nil();
 998             lint = lint.augment(tree.sym);
 999 
1000             try {
1001                 // process all the static initializers
1002                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1003                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
1004                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
1005                         scan(l.head);
1006                         errorUncaught();
1007                     }
1008                 }
1009 
1010                 // add intersection of all thrown clauses of initial constructors
1011                 // to set of caught exceptions, unless class is anonymous.
1012                 if (!anonymousClass) {
1013                     boolean firstConstructor = true;
1014                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1015                         if (TreeInfo.isInitialConstructor(l.head)) {
1016                             List&lt;Type&gt; mthrown =
1017                                 ((JCMethodDecl) l.head).sym.type.getThrownTypes();
1018                             if (firstConstructor) {
1019                                 caught = mthrown;
1020                                 firstConstructor = false;
1021                             } else {
1022                                 caught = chk.intersect(mthrown, caught);
1023                             }
1024                         }
1025                     }
1026                 }
1027 
1028                 // process all the instance initializers
1029                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1030                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
1031                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
1032                         scan(l.head);
1033                         errorUncaught();
1034                     }
1035                 }
1036 
1037                 // in an anonymous class, add the set of thrown exceptions to
1038                 // the throws clause of the synthetic constructor and propagate
1039                 // outwards.
1040                 // Changing the throws clause on the fly is okay here because
1041                 // the anonymous constructor can&#39;t be invoked anywhere else,
1042                 // and its type hasn&#39;t been cached.
1043                 if (anonymousClass) {
1044                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1045                         if (TreeInfo.isConstructor(l.head)) {
1046                             JCMethodDecl mdef = (JCMethodDecl)l.head;
1047                             scan(mdef);
1048                             mdef.thrown = make.Types(thrown);
1049                             mdef.sym.type = types.createMethodTypeWithThrown(mdef.sym.type, thrown);
1050                         }
1051                     }
1052                     thrownPrev = chk.union(thrown, thrownPrev);
1053                 }
1054 
1055                 // process all the methods
1056                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1057                     if (anonymousClass &amp;&amp; TreeInfo.isConstructor(l.head))
1058                         continue; // there can never be an uncaught exception.
1059                     if (l.head.hasTag(METHODDEF)) {
1060                         scan(l.head);
1061                         errorUncaught();
1062                     }
1063                 }
1064 
1065                 thrown = thrownPrev;
1066             } finally {
1067                 pendingExits = pendingExitsPrev;
1068                 caught = caughtPrev;
1069                 classDef = classDefPrev;
1070                 lint = lintPrev;
1071             }
1072         }
1073 
1074         public void visitMethodDef(JCMethodDecl tree) {
1075             if (tree.body == null) return;
1076 
1077             List&lt;Type&gt; caughtPrev = caught;
1078             List&lt;Type&gt; mthrown = tree.sym.type.getThrownTypes();
1079             Lint lintPrev = lint;
1080 
1081             lint = lint.augment(tree.sym);
1082 
1083             Assert.check(pendingExits.isEmpty());
1084 
1085             try {
1086                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1087                     JCVariableDecl def = l.head;
1088                     scan(def);
1089                 }
1090                 if (TreeInfo.isInitialConstructor(tree))
1091                     caught = chk.union(caught, mthrown);
1092                 else if ((tree.sym.flags() &amp; (BLOCK | STATIC)) != BLOCK)
1093                     caught = mthrown;
1094                 // else we are in an instance initializer block;
1095                 // leave caught unchanged.
1096 
1097                 scan(tree.body);
1098 
1099                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1100                 pendingExits = new ListBuffer&lt;&gt;();
1101                 while (exits.nonEmpty()) {
1102                     PendingExit exit = exits.head;
1103                     exits = exits.tail;
1104                     if (!(exit instanceof ThrownPendingExit)) {
1105                         Assert.check(exit.tree.hasTag(RETURN) ||
1106                                          log.hasErrorOn(exit.tree.pos()));
1107                     } else {
1108                         // uncaught throws will be reported later
1109                         pendingExits.append(exit);
1110                     }
1111                 }
1112             } finally {
1113                 caught = caughtPrev;
1114                 lint = lintPrev;
1115             }
1116         }
1117 
1118         public void visitVarDef(JCVariableDecl tree) {
1119             if (tree.init != null) {
1120                 Lint lintPrev = lint;
1121                 lint = lint.augment(tree.sym);
1122                 try{
1123                     scan(tree.init);
1124                 } finally {
1125                     lint = lintPrev;
1126                 }
1127             }
1128         }
1129 
1130         public void visitBlock(JCBlock tree) {
1131             scan(tree.stats);
1132         }
1133 
1134         public void visitDoLoop(JCDoWhileLoop tree) {
1135             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1136             pendingExits = new ListBuffer&lt;&gt;();
1137             scan(tree.body);
1138             resolveContinues(tree);
1139             scan(tree.cond);
1140             resolveBreaks(tree, prevPendingExits);
1141         }
1142 
1143         public void visitWhileLoop(JCWhileLoop tree) {
1144             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1145             pendingExits = new ListBuffer&lt;&gt;();
1146             scan(tree.cond);
1147             scan(tree.body);
1148             resolveContinues(tree);
1149             resolveBreaks(tree, prevPendingExits);
1150         }
1151 
1152         public void visitForLoop(JCForLoop tree) {
1153             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1154             scan(tree.init);
1155             pendingExits = new ListBuffer&lt;&gt;();
1156             if (tree.cond != null) {
1157                 scan(tree.cond);
1158             }
1159             scan(tree.body);
1160             resolveContinues(tree);
1161             scan(tree.step);
1162             resolveBreaks(tree, prevPendingExits);
1163         }
1164 
1165         public void visitForeachLoop(JCEnhancedForLoop tree) {
1166             visitVarDef(tree.var);
1167             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1168             scan(tree.expr);
1169             pendingExits = new ListBuffer&lt;&gt;();
1170             scan(tree.body);
1171             resolveContinues(tree);
1172             resolveBreaks(tree, prevPendingExits);
1173         }
1174 
1175         public void visitLabelled(JCLabeledStatement tree) {
1176             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1177             pendingExits = new ListBuffer&lt;&gt;();
1178             scan(tree.body);
1179             resolveBreaks(tree, prevPendingExits);
1180         }
1181 
1182         public void visitSwitch(JCSwitch tree) {
1183             handleSwitch(tree, tree.selector, tree.cases);
1184         }
1185 
1186         @Override
1187         public void visitSwitchExpression(JCSwitchExpression tree) {
1188             handleSwitch(tree, tree.selector, tree.cases);
1189         }
1190 
1191         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
1192             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1193             pendingExits = new ListBuffer&lt;&gt;();
1194             scan(selector);
1195             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1196                 JCCase c = l.head;
1197                 scan(c.pats);
1198                 scan(c.stats);
1199             }
1200             if (tree.hasTag(SWITCH_EXPRESSION)) {
1201                 resolveYields(tree, prevPendingExits);
1202             } else {
1203                 resolveBreaks(tree, prevPendingExits);
1204             }
1205         }
1206 
1207         public void visitTry(JCTry tree) {
1208             List&lt;Type&gt; caughtPrev = caught;
1209             List&lt;Type&gt; thrownPrev = thrown;
1210             thrown = List.nil();
1211             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1212                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1213                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1214                         List.of(l.head.param.vartype);
1215                 for (JCExpression ct : subClauses) {
1216                     caught = chk.incl(ct.type, caught);
1217                 }
1218             }
1219 
1220             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1221             pendingExits = new ListBuffer&lt;&gt;();
1222             for (JCTree resource : tree.resources) {
1223                 if (resource instanceof JCVariableDecl) {
1224                     JCVariableDecl vdecl = (JCVariableDecl) resource;
1225                     visitVarDef(vdecl);
1226                 } else if (resource instanceof JCExpression) {
1227                     scan((JCExpression) resource);
1228                 } else {
1229                     throw new AssertionError(tree);  // parser error
1230                 }
1231             }
1232             for (JCTree resource : tree.resources) {
1233                 List&lt;Type&gt; closeableSupertypes = resource.type.isCompound() ?
1234                     types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
1235                     List.of(resource.type);
1236                 for (Type sup : closeableSupertypes) {
1237                     if (types.asSuper(sup, syms.autoCloseableType.tsym, true) != null) {
1238                         Symbol closeMethod = rs.resolveQualifiedMethod(tree,
1239                                 attrEnv,
1240                                 types.skipTypeVars(sup, false),
1241                                 names.close,
1242                                 List.nil(),
1243                                 List.nil());
1244                         Type mt = types.memberType(resource.type, closeMethod);
1245                         if (closeMethod.kind == MTH) {
1246                             for (Type t : mt.getThrownTypes()) {
1247                                 markThrown(resource, t);
1248                             }
1249                         }
1250                     }
1251                 }
1252             }
1253             scan(tree.body);
1254             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1255             thrown = thrownPrev;
1256             caught = caughtPrev;
1257 
1258             List&lt;Type&gt; caughtInTry = List.nil();
1259             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1260                 JCVariableDecl param = l.head.param;
1261                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1262                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1263                         List.of(l.head.param.vartype);
1264                 List&lt;Type&gt; ctypes = List.nil();
1265                 List&lt;Type&gt; rethrownTypes = chk.diff(thrownInTry, caughtInTry);
1266                 for (JCExpression ct : subClauses) {
1267                     Type exc = ct.type;
1268                     if (exc != syms.unknownType) {
1269                         ctypes = ctypes.append(exc);
1270                         if (types.isSameType(exc, syms.objectType))
1271                             continue;
1272                         checkCaughtType(l.head.pos(), exc, thrownInTry, caughtInTry);
1273                         caughtInTry = chk.incl(exc, caughtInTry);
1274                     }
1275                 }
1276                 scan(param);
1277                 preciseRethrowTypes.put(param.sym, chk.intersect(ctypes, rethrownTypes));
1278                 scan(l.head.body);
1279                 preciseRethrowTypes.remove(param.sym);
1280             }
1281             if (tree.finalizer != null) {
1282                 List&lt;Type&gt; savedThrown = thrown;
1283                 thrown = List.nil();
1284                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1285                 pendingExits = prevPendingExits;
1286                 scan(tree.finalizer);
1287                 if (!tree.finallyCanCompleteNormally) {
1288                     // discard exits and exceptions from try and finally
1289                     thrown = chk.union(thrown, thrownPrev);
1290                 } else {
1291                     thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1292                     thrown = chk.union(thrown, savedThrown);
1293                     // FIX: this doesn&#39;t preserve source order of exits in catch
1294                     // versus finally!
1295                     while (exits.nonEmpty()) {
1296                         pendingExits.append(exits.next());
1297                     }
1298                 }
1299             } else {
1300                 thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1301                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1302                 pendingExits = prevPendingExits;
1303                 while (exits.nonEmpty()) pendingExits.append(exits.next());
1304             }
1305         }
1306 
1307         @Override
1308         public void visitIf(JCIf tree) {
1309             scan(tree.cond);
1310             scan(tree.thenpart);
1311             if (tree.elsepart != null) {
1312                 scan(tree.elsepart);
1313             }
1314         }
1315 
1316         void checkCaughtType(DiagnosticPosition pos, Type exc, List&lt;Type&gt; thrownInTry, List&lt;Type&gt; caughtInTry) {
1317             if (chk.subset(exc, caughtInTry)) {
1318                 log.error(pos, Errors.ExceptAlreadyCaught(exc));
1319             } else if (!chk.isUnchecked(pos, exc) &amp;&amp;
1320                     !isExceptionOrThrowable(exc) &amp;&amp;
1321                     !chk.intersects(exc, thrownInTry)) {
1322                 log.error(pos, Errors.ExceptNeverThrownInTry(exc));
1323             } else {
1324                 List&lt;Type&gt; catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
1325                 // &#39;catchableThrownTypes&#39; cannot possibly be empty - if &#39;exc&#39; was an
1326                 // unchecked exception, the result list would not be empty, as the augmented
1327                 // thrown set includes { RuntimeException, Error }; if &#39;exc&#39; was a checked
1328                 // exception, that would have been covered in the branch above
1329                 if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &amp;&amp;
1330                         !isExceptionOrThrowable(exc)) {
1331                     Warning key = catchableThrownTypes.length() == 1 ?
1332                             Warnings.UnreachableCatch(catchableThrownTypes) :
1333                             Warnings.UnreachableCatch1(catchableThrownTypes);
1334                     log.warning(pos, key);
1335                 }
1336             }
1337         }
1338         //where
1339             private boolean isExceptionOrThrowable(Type exc) {
1340                 return exc.tsym == syms.throwableType.tsym ||
1341                     exc.tsym == syms.exceptionType.tsym;
1342             }
1343 
1344         public void visitBreak(JCBreak tree) {
1345             recordExit(new PendingExit(tree));
1346         }
1347 
1348         public void visitYield(JCYield tree) {
1349             scan(tree.value);
1350             recordExit(new PendingExit(tree));
1351         }
1352 
1353         public void visitContinue(JCContinue tree) {
1354             recordExit(new PendingExit(tree));
1355         }
1356 
1357         public void visitReturn(JCReturn tree) {
1358             scan(tree.expr);
1359             recordExit(new PendingExit(tree));
1360         }
1361 
1362         public void visitThrow(JCThrow tree) {
1363             scan(tree.expr);
1364             Symbol sym = TreeInfo.symbol(tree.expr);
1365             if (sym != null &amp;&amp;
1366                 sym.kind == VAR &amp;&amp;
1367                 (sym.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) != 0 &amp;&amp;
1368                 preciseRethrowTypes.get(sym) != null) {
1369                 for (Type t : preciseRethrowTypes.get(sym)) {
1370                     markThrown(tree, t);
1371                 }
1372             }
1373             else {
1374                 markThrown(tree, tree.expr.type);
1375             }
1376             markDead();
1377         }
1378 
1379         public void visitApply(JCMethodInvocation tree) {
1380             scan(tree.meth);
1381             scan(tree.args);
1382             for (List&lt;Type&gt; l = tree.meth.type.getThrownTypes(); l.nonEmpty(); l = l.tail)
1383                 markThrown(tree, l.head);
1384         }
1385 
1386         public void visitNewClass(JCNewClass tree) {
1387             scan(tree.encl);
1388             scan(tree.args);
1389            // scan(tree.def);
1390             for (List&lt;Type&gt; l = tree.constructorType.getThrownTypes();
1391                  l.nonEmpty();
1392                  l = l.tail) {
1393                 markThrown(tree, l.head);
1394             }
1395             List&lt;Type&gt; caughtPrev = caught;
1396             try {
1397                 // If the new class expression defines an anonymous class,
1398                 // analysis of the anonymous constructor may encounter thrown
1399                 // types which are unsubstituted type variables.
1400                 // However, since the constructor&#39;s actual thrown types have
1401                 // already been marked as thrown, it is safe to simply include
1402                 // each of the constructor&#39;s formal thrown types in the set of
1403                 // &#39;caught/declared to be thrown&#39; types, for the duration of
1404                 // the class def analysis.
1405                 if (tree.def != null)
1406                     for (List&lt;Type&gt; l = tree.constructor.type.getThrownTypes();
1407                          l.nonEmpty();
1408                          l = l.tail) {
1409                         caught = chk.incl(l.head, caught);
1410                     }
1411                 scan(tree.def);
1412             }
1413             finally {
1414                 caught = caughtPrev;
1415             }
1416         }
1417 
1418         @Override
1419         public void visitLambda(JCLambda tree) {
1420             if (tree.type != null &amp;&amp;
1421                     tree.type.isErroneous()) {
1422                 return;
1423             }
1424             List&lt;Type&gt; prevCaught = caught;
1425             List&lt;Type&gt; prevThrown = thrown;
1426             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1427             try {
1428                 pendingExits = new ListBuffer&lt;&gt;();
1429                 caught = tree.getDescriptorType(types).getThrownTypes();
1430                 thrown = List.nil();
1431                 scan(tree.body);
1432                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1433                 pendingExits = new ListBuffer&lt;&gt;();
1434                 while (exits.nonEmpty()) {
1435                     PendingExit exit = exits.head;
1436                     exits = exits.tail;
1437                     if (!(exit instanceof ThrownPendingExit)) {
1438                         Assert.check(exit.tree.hasTag(RETURN) ||
1439                                         log.hasErrorOn(exit.tree.pos()));
1440                     } else {
1441                         // uncaught throws will be reported later
1442                         pendingExits.append(exit);
1443                     }
1444                 }
1445 
1446                 errorUncaught();
1447             } finally {
1448                 pendingExits = prevPending;
1449                 caught = prevCaught;
1450                 thrown = prevThrown;
1451             }
1452         }
1453 
1454         public void visitModuleDef(JCModuleDecl tree) {
1455             // Do nothing for modules
1456         }
1457 
1458     /**************************************************************************
1459      * main method
1460      *************************************************************************/
1461 
1462         /** Perform definite assignment/unassignment analysis on a tree.
1463          */
1464         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
1465             analyzeTree(env, env.tree, make);
1466         }
1467         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
1468             try {
1469                 attrEnv = env;
1470                 Flow.this.make = make;
1471                 pendingExits = new ListBuffer&lt;&gt;();
1472                 preciseRethrowTypes = new HashMap&lt;&gt;();
1473                 this.thrown = this.caught = null;
1474                 this.classDef = null;
1475                 scan(tree);
1476             } finally {
1477                 pendingExits = null;
1478                 Flow.this.make = null;
1479                 this.thrown = this.caught = null;
1480                 this.classDef = null;
1481             }
1482         }
1483     }
1484 
1485     /**
1486      * Specialized pass that performs reachability analysis on a lambda
1487      */
1488     class LambdaAliveAnalyzer extends AliveAnalyzer {
1489 
1490         boolean inLambda;
1491 
1492         @Override
1493         public void visitReturn(JCReturn tree) {
1494             //ignore lambda return expression (which might not even be attributed)
1495             recordExit(new PendingExit(tree));
1496         }
1497 
1498         @Override
1499         public void visitLambda(JCLambda tree) {
1500             if (inLambda || tree.getBodyKind() == BodyKind.EXPRESSION) {
1501                 return;
1502             }
1503             inLambda = true;
1504             try {
1505                 super.visitLambda(tree);
1506             } finally {
1507                 inLambda = false;
1508             }
1509         }
1510 
1511         @Override
1512         public void visitClassDef(JCClassDecl tree) {
1513             //skip
1514         }
1515     }
1516 
1517     /**
1518      * Determine if alive after the given tree.
1519      */
1520     class SnippetAliveAnalyzer extends AliveAnalyzer {
1521         @Override
1522         public void visitClassDef(JCClassDecl tree) {
1523             //skip
1524         }
1525         public boolean isAlive() {
1526             return super.alive != Liveness.DEAD;
1527         }
1528     }
1529 
1530     class SnippetBreakAnalyzer extends AliveAnalyzer {
1531         private final Set&lt;JCTree&gt; seenTrees = new HashSet&lt;&gt;();
1532         private boolean breaksOut;
1533 
1534         public SnippetBreakAnalyzer() {
1535         }
1536 
1537         @Override
1538         public void visitLabelled(JCTree.JCLabeledStatement tree) {
1539             seenTrees.add(tree);
1540             super.visitLabelled(tree);
1541         }
1542 
1543         @Override
1544         public void visitWhileLoop(JCTree.JCWhileLoop tree) {
1545             seenTrees.add(tree);
1546             super.visitWhileLoop(tree);
1547         }
1548 
1549         @Override
1550         public void visitForLoop(JCTree.JCForLoop tree) {
1551             seenTrees.add(tree);
1552             super.visitForLoop(tree);
1553         }
1554 
1555         @Override
1556         public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {
1557             seenTrees.add(tree);
1558             super.visitForeachLoop(tree);
1559         }
1560 
1561         @Override
1562         public void visitDoLoop(JCTree.JCDoWhileLoop tree) {
1563             seenTrees.add(tree);
1564             super.visitDoLoop(tree);
1565         }
1566 
1567         @Override
1568         public void visitBreak(JCBreak tree) {
1569             breaksOut |= (super.alive == Liveness.ALIVE &amp;&amp;
1570                           !seenTrees.contains(tree.target));
1571             super.visitBreak(tree);
1572         }
1573 
1574         public boolean breaksOut() {
1575             return breaksOut;
1576         }
1577     }
1578 
1579     /**
1580      * Specialized pass that performs DA/DU on a lambda
1581      */
1582     class LambdaAssignAnalyzer extends AssignAnalyzer {
1583         WriteableScope enclosedSymbols;
1584         boolean inLambda;
1585 
1586         LambdaAssignAnalyzer(Env&lt;AttrContext&gt; env) {
1587             enclosedSymbols = WriteableScope.create(env.enclClass.sym);
1588         }
1589 
1590         @Override
1591         public void visitLambda(JCLambda tree) {
1592             if (inLambda) {
1593                 return;
1594             }
1595             inLambda = true;
1596             try {
1597                 super.visitLambda(tree);
1598             } finally {
1599                 inLambda = false;
1600             }
1601         }
1602 
1603         @Override
1604         public void visitVarDef(JCVariableDecl tree) {
1605             enclosedSymbols.enter(tree.sym);
1606             super.visitVarDef(tree);
1607         }
1608         @Override
1609         protected boolean trackable(VarSymbol sym) {
1610             return enclosedSymbols.includes(sym) &amp;&amp;
1611                    sym.owner.kind == MTH;
1612         }
1613 
1614         @Override
1615         public void visitClassDef(JCClassDecl tree) {
1616             //skip
1617         }
1618     }
1619 
1620     /**
1621      * Specialized pass that performs inference of thrown types for lambdas.
1622      */
1623     class LambdaFlowAnalyzer extends FlowAnalyzer {
1624         List&lt;Type&gt; inferredThrownTypes;
1625         boolean inLambda;
1626         @Override
1627         public void visitLambda(JCLambda tree) {
1628             if ((tree.type != null &amp;&amp;
1629                     tree.type.isErroneous()) || inLambda) {
1630                 return;
1631             }
1632             List&lt;Type&gt; prevCaught = caught;
1633             List&lt;Type&gt; prevThrown = thrown;
1634             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1635             inLambda = true;
1636             try {
1637                 pendingExits = new ListBuffer&lt;&gt;();
1638                 caught = List.of(syms.throwableType);
1639                 thrown = List.nil();
1640                 scan(tree.body);
1641                 inferredThrownTypes = thrown;
1642             } finally {
1643                 pendingExits = prevPending;
1644                 caught = prevCaught;
1645                 thrown = prevThrown;
1646                 inLambda = false;
1647             }
1648         }
1649         @Override
1650         public void visitClassDef(JCClassDecl tree) {
1651             //skip
1652         }
1653     }
1654 
1655     /** Enum to model whether constructors allowed to &quot;leak&quot; this reference before
1656         all instance fields are DA.
1657      */
1658     enum ThisExposability {
1659         ALLOWED,     // Normal Object classes - NOP
1660         BANNED,      // Value types           - Error
1661         DISCOURAGED  // Value based types     - Warning
1662     }
1663 
1664     /**
1665      * This pass implements (i) definite assignment analysis, which ensures that
1666      * each variable is assigned when used and (ii) definite unassignment analysis,
1667      * which ensures that no final variable is assigned more than once. This visitor
1668      * depends on the results of the liveliness analyzer. This pass is also used to mark
1669      * effectively-final local variables/parameters.
1670      */
1671 
1672     public class AssignAnalyzer extends BaseAnalyzer {
1673 
1674         /** The set of definitely assigned variables.
1675          */
1676         final Bits inits;
1677 
1678         /** The set of definitely unassigned variables.
1679          */
1680         final Bits uninits;
1681 
1682         /** The set of variables that are definitely unassigned everywhere
1683          *  in current try block. This variable is maintained lazily; it is
1684          *  updated only when something gets removed from uninits,
1685          *  typically by being assigned in reachable code.  To obtain the
1686          *  correct set of variables which are definitely unassigned
1687          *  anywhere in current try block, intersect uninitsTry and
1688          *  uninits.
1689          */
1690         final Bits uninitsTry;
1691 
1692         /** When analyzing a condition, inits and uninits are null.
1693          *  Instead we have:
1694          */
1695         final Bits initsWhenTrue;
1696         final Bits initsWhenFalse;
1697         final Bits uninitsWhenTrue;
1698         final Bits uninitsWhenFalse;
1699 
1700         /** A mapping from addresses to variable symbols.
1701          */
1702         protected JCVariableDecl[] vardecls;
1703 
1704         /** The current class being defined.
1705          */
1706         JCClassDecl classDef;
1707 
1708         /** The first variable sequence number in this class definition.
1709          */
1710         int firstadr;
1711 
1712         /** The next available variable sequence number.
1713          */
1714         protected int nextadr;
1715 
1716         /** The first variable sequence number in a block that can return.
1717          */
1718         protected int returnadr;
1719 
1720         /** The list of unreferenced automatic resources.
1721          */
1722         WriteableScope unrefdResources;
1723 
1724         /** Modified when processing a loop body the second time for DU analysis. */
1725         FlowKind flowKind = FlowKind.NORMAL;
1726 
1727         /** The starting position of the analyzed tree */
1728         int startPos;
1729 
1730         public class AssignPendingExit extends BaseAnalyzer.PendingExit {
1731 
1732             final Bits inits;
1733             final Bits uninits;
1734             final Bits exit_inits = new Bits(true);
1735             final Bits exit_uninits = new Bits(true);
1736 
1737             public AssignPendingExit(JCTree tree, final Bits inits, final Bits uninits) {
1738                 super(tree);
1739                 this.inits = inits;
1740                 this.uninits = uninits;
1741                 this.exit_inits.assign(inits);
1742                 this.exit_uninits.assign(uninits);
1743             }
1744 
1745             @Override
1746             public void resolveJump() {
1747                 inits.andSet(exit_inits);
1748                 uninits.andSet(exit_uninits);
1749             }
1750         }
1751 
1752         // Are constructors allowed to leak this reference ?
1753         ThisExposability thisExposability = ALLOWED;
1754 
1755         public AssignAnalyzer() {
1756             this.inits = new Bits();
1757             uninits = new Bits();
1758             uninitsTry = new Bits();
1759             initsWhenTrue = new Bits(true);
1760             initsWhenFalse = new Bits(true);
1761             uninitsWhenTrue = new Bits(true);
1762             uninitsWhenFalse = new Bits(true);
1763         }
1764 
1765         private boolean isInitialConstructor = false;
1766 
1767         @Override
1768         protected void markDead() {
1769             if (!isInitialConstructor) {
1770                 inits.inclRange(returnadr, nextadr);
1771             } else {
1772                 for (int address = returnadr; address &lt; nextadr; address++) {
1773                     if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {
1774                         inits.incl(address);
1775                     }
1776                 }
1777             }
1778             uninits.inclRange(returnadr, nextadr);
1779         }
1780 
1781         /*-------------- Processing variables ----------------------*/
1782 
1783         /** Do we need to track init/uninit state of this symbol?
1784          *  I.e. is symbol either a local or a blank final variable?
1785          */
1786         protected boolean trackable(VarSymbol sym) {
1787             return
1788                 sym.pos &gt;= startPos &amp;&amp;
1789                 ((sym.owner.kind == MTH || sym.owner.kind == VAR ||
1790                 isFinalUninitializedField(sym)));
1791         }
1792 
1793         boolean isFinalUninitializedField(VarSymbol sym) {
1794             return sym.owner.kind == TYP &amp;&amp;
1795                    ((sym.flags() &amp; (FINAL | HASINIT | PARAMETER)) == FINAL &amp;&amp;
1796                    classDef.sym.isEnclosedBy((ClassSymbol)sym.owner));
1797         }
1798 
1799         boolean isFinalUninitializedStaticField(VarSymbol sym) {
1800             return isFinalUninitializedField(sym) &amp;&amp; sym.isStatic();
1801         }
1802 
1803         /** Initialize new trackable variable by setting its address field
1804          *  to the next available sequence number and entering it under that
1805          *  index into the vars array.
1806          */
1807         void newVar(JCVariableDecl varDecl) {
1808             VarSymbol sym = varDecl.sym;
1809             vardecls = ArrayUtils.ensureCapacity(vardecls, nextadr);
1810             if ((sym.flags() &amp; FINAL) == 0) {
1811                 sym.flags_field |= EFFECTIVELY_FINAL;
1812             }
1813             sym.adr = nextadr;
1814             vardecls[nextadr] = varDecl;
1815             inits.excl(nextadr);
1816             uninits.incl(nextadr);
1817             nextadr++;
1818         }
1819 
1820         /** Record an initialization of a trackable variable.
1821          */
1822         void letInit(DiagnosticPosition pos, VarSymbol sym) {
1823             if (sym.adr &gt;= firstadr &amp;&amp; trackable(sym)) {
1824                 if ((sym.flags() &amp; EFFECTIVELY_FINAL) != 0) {
1825                     if (!uninits.isMember(sym.adr)) {
1826                         //assignment targeting an effectively final variable
1827                         //makes the variable lose its status of effectively final
1828                         //if the variable is _not_ definitively unassigned
1829                         sym.flags_field &amp;= ~EFFECTIVELY_FINAL;
1830                     } else {
1831                         uninit(sym);
1832                     }
1833                 }
1834                 else if ((sym.flags() &amp; FINAL) != 0) {
1835                     if ((sym.flags() &amp; PARAMETER) != 0) {
1836                         if ((sym.flags() &amp; UNION) != 0) { //multi-catch parameter
1837                             log.error(pos, Errors.MulticatchParameterMayNotBeAssigned(sym));
1838                         }
1839                         else {
1840                             log.error(pos,
1841                                       Errors.FinalParameterMayNotBeAssigned(sym));
1842                         }
1843                     } else if (!uninits.isMember(sym.adr)) {
1844                         log.error(pos, diags.errorKey(flowKind.errKey, sym));
1845                     } else {
1846                         uninit(sym);
1847                     }
1848                 }
1849                 inits.incl(sym.adr);
1850             } else if ((sym.flags() &amp; FINAL) != 0) {
1851                 log.error(pos, Errors.VarMightAlreadyBeAssigned(sym));
1852             }
1853         }
1854         //where
1855             void uninit(VarSymbol sym) {
1856                 if (!inits.isMember(sym.adr)) {
1857                     // reachable assignment
1858                     uninits.excl(sym.adr);
1859                     uninitsTry.excl(sym.adr);
1860                 } else {
1861                     //log.rawWarning(pos, &quot;unreachable assignment&quot;);//DEBUG
1862                     uninits.excl(sym.adr);
1863                 }
1864             }
1865 
1866         /** If tree is either a simple name or of the form this.name or
1867          *  C.this.name, and tree represents a trackable variable,
1868          *  record an initialization of the variable.
1869          */
1870         void letInit(JCTree tree) {
1871             tree = TreeInfo.skipParens(tree);
1872             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1873                 Symbol sym = TreeInfo.symbol(tree);
1874                 if (sym.kind == VAR) {
1875                     letInit(tree.pos(), (VarSymbol)sym);
1876                 }
1877             }
1878         }
1879 
1880         void checkEmbryonicThisExposure(JCTree node) {
1881             if (this.thisExposability == ALLOWED || classDef == null)
1882                 return;
1883 
1884             // Note: for non-initial constructors, firstadr is post all instance fields.
1885             for (int i = firstadr; i &lt; nextadr; i++) {
1886                 VarSymbol sym = vardecls[i].sym;
1887                 if (sym.owner != classDef.sym)
1888                     continue;
1889                 if ((sym.flags() &amp; (FINAL | HASINIT | STATIC | PARAMETER)) != FINAL)
1890                     continue;
1891                 if (sym.pos &lt; startPos || sym.adr &lt; firstadr)
1892                     continue;
1893                 if (!inits.isMember(sym.adr)) {
1894                     if (this.thisExposability == BANNED) {
1895                         log.error(node, Errors.ThisExposedPrematurely);
1896                     } else {
1897                         log.warning(node, Warnings.ThisExposedPrematurely);
1898                     }
1899                     return; // don&#39;t flog a dead horse.
1900                 }
1901             }
1902         }
1903 
1904         /** Check that trackable variable is initialized.
1905          */
1906         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1907             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1908         }
1909 
1910         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1911             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1912                 trackable(sym) &amp;&amp;
1913                 !inits.isMember(sym.adr)) {
1914                     log.error(pos, errkey);
1915                 inits.incl(sym.adr);
1916             }
1917         }
1918 
1919         /** Utility method to reset several Bits instances.
1920          */
1921         private void resetBits(Bits... bits) {
1922             for (Bits b : bits) {
1923                 b.reset();
1924             }
1925         }
1926 
1927         /** Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
1928          */
1929         void split(boolean setToNull) {
1930             initsWhenFalse.assign(inits);
1931             uninitsWhenFalse.assign(uninits);
1932             initsWhenTrue.assign(inits);
1933             uninitsWhenTrue.assign(uninits);
1934             if (setToNull) {
1935                 resetBits(inits, uninits);
1936             }
1937         }
1938 
1939         /** Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.
1940          */
1941         protected void merge() {
1942             inits.assign(initsWhenFalse.andSet(initsWhenTrue));
1943             uninits.assign(uninitsWhenFalse.andSet(uninitsWhenTrue));
1944         }
1945 
1946     /* ************************************************************************
1947      * Visitor methods for statements and definitions
1948      *************************************************************************/
1949 
1950         /** Analyze an expression. Make sure to set (un)inits rather than
1951          *  (un)initsWhenTrue(WhenFalse) on exit.
1952          */
1953         void scanExpr(JCTree tree) {
1954             if (tree != null) {
1955                 scan(tree);
1956                 if (inits.isReset()) {
1957                     merge();
1958                 }
1959             }
1960         }
1961 
1962         /** Analyze a list of expressions.
1963          */
1964         void scanExprs(List&lt;? extends JCExpression&gt; trees) {
1965             if (trees != null)
1966                 for (List&lt;? extends JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
1967                     scanExpr(l.head);
1968         }
1969 
1970         /** Analyze a condition. Make sure to set (un)initsWhenTrue(WhenFalse)
1971          *  rather than (un)inits on exit.
1972          */
1973         void scanCond(JCTree tree) {
1974             if (tree.type.isFalse()) {
1975                 if (inits.isReset()) merge();
1976                 initsWhenTrue.assign(inits);
1977                 initsWhenTrue.inclRange(firstadr, nextadr);
1978                 uninitsWhenTrue.assign(uninits);
1979                 uninitsWhenTrue.inclRange(firstadr, nextadr);
1980                 initsWhenFalse.assign(inits);
1981                 uninitsWhenFalse.assign(uninits);
1982             } else if (tree.type.isTrue()) {
1983                 if (inits.isReset()) merge();
1984                 initsWhenFalse.assign(inits);
1985                 initsWhenFalse.inclRange(firstadr, nextadr);
1986                 uninitsWhenFalse.assign(uninits);
1987                 uninitsWhenFalse.inclRange(firstadr, nextadr);
1988                 initsWhenTrue.assign(inits);
1989                 uninitsWhenTrue.assign(uninits);
1990             } else {
1991                 scan(tree);
1992                 if (!inits.isReset())
1993                     split(tree.type != syms.unknownType);
1994             }
1995             if (tree.type != syms.unknownType) {
1996                 resetBits(inits, uninits);
1997             }
1998         }
1999 
2000         /* ------------ Visitor methods for various sorts of trees -------------*/
2001 
2002         public void visitClassDef(JCClassDecl tree) {
2003             if (tree.sym == null) {
2004                 return;
2005             }
2006 
2007             Lint lintPrev = lint;
2008             lint = lint.augment(tree.sym);
2009             try {
2010                 if (tree.sym == null) {
2011                     return;
2012                 }
2013 
2014                 JCClassDecl classDefPrev = classDef;
2015                 int firstadrPrev = firstadr;
2016                 int nextadrPrev = nextadr;
2017                 ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
2018 
2019                 pendingExits = new ListBuffer&lt;&gt;();
2020                 if (tree.name != names.empty) {
2021                     firstadr = nextadr;
2022                 }
2023                 classDef = tree;
2024                 try {
2025                     // define all the static fields
2026                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2027                         if (l.head.hasTag(VARDEF)) {
2028                             JCVariableDecl def = (JCVariableDecl)l.head;
2029                             if ((def.mods.flags &amp; STATIC) != 0) {
2030                                 VarSymbol sym = def.sym;
2031                                 if (trackable(sym)) {
2032                                     newVar(def);
2033                                 }
2034                             }
2035                         }
2036                     }
2037 
2038                     // process all the static initializers
2039                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2040                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2041                             (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
2042                             scan(l.head);
2043                             clearPendingExits(false);
2044                         }
2045                     }
2046 
2047                     // define all the instance fields
2048                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2049                         if (l.head.hasTag(VARDEF)) {
2050                             JCVariableDecl def = (JCVariableDecl)l.head;
2051                             if ((def.mods.flags &amp; STATIC) == 0) {
2052                                 VarSymbol sym = def.sym;
2053                                 if (trackable(sym)) {
2054                                     newVar(def);
2055                                 }
2056                             }
2057                         }
2058                     }
2059 
2060                     // process all the instance initializers
2061                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2062                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2063                             (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
2064                             scan(l.head);
2065                             clearPendingExits(false);
2066                         }
2067                     }
2068 
2069                     // process all the methods
2070                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2071                         if (l.head.hasTag(METHODDEF)) {
2072                             scan(l.head);
2073                         }
2074                     }
2075                 } finally {
2076                     pendingExits = pendingExitsPrev;
2077                     nextadr = nextadrPrev;
2078                     firstadr = firstadrPrev;
2079                     classDef = classDefPrev;
2080                 }
2081             } finally {
2082                 lint = lintPrev;
2083             }
2084         }
2085 
2086         public void visitMethodDef(JCMethodDecl tree) {
2087             if (tree.body == null) {
2088                 return;
2089             }
2090 
2091             /*  MemberEnter can generate synthetic methods ignore them
2092              */
2093             if ((tree.sym.flags() &amp; SYNTHETIC) != 0) {
2094                 return;
2095             }
2096 
2097             Lint lintPrev = lint;
2098             lint = lint.augment(tree.sym);
2099             ThisExposability priorThisExposability = this.thisExposability;
2100             try {
2101                 if (tree.body == null) {
2102                     return;
2103                 }
2104                 /*  Ignore synthetic methods, except for translated lambda methods.
2105                  */
2106                 if ((tree.sym.flags() &amp; (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {
2107                     return;
2108                 }
2109 
2110                 final Bits initsPrev = new Bits(inits);
2111                 final Bits uninitsPrev = new Bits(uninits);
2112                 int nextadrPrev = nextadr;
2113                 int firstadrPrev = firstadr;
2114                 int returnadrPrev = returnadr;
2115 
2116                 Assert.check(pendingExits.isEmpty());
2117                 boolean lastInitialConstructor = isInitialConstructor;
2118                 try {
2119                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2120 
2121                     if (!isInitialConstructor) {
2122                         firstadr = nextadr;
2123                         this.thisExposability = ALLOWED;
2124                     } else {
2125                         if (types.isValueBased(tree.sym.owner.type))
2126                             this.thisExposability = DISCOURAGED;
2127                         else if (types.isValue(tree.sym.owner.type))
2128                             this.thisExposability = BANNED;
2129                         else
2130                             this.thisExposability = ALLOWED;
2131                     }
2132                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2133                         JCVariableDecl def = l.head;
2134                         scan(def);
2135                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2136                         /*  If we are executing the code from Gen, then there can be
2137                          *  synthetic or mandated variables, ignore them.
2138                          */
2139                         initParam(def);
2140                     }
2141                     // else we are in an instance initializer block;
2142                     // leave caught unchanged.
2143                     scan(tree.body);
2144 
2145                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;
2146                     if (isInitialConstructor) {
2147                         boolean isSynthesized = (tree.sym.flags() &amp;
2148                                                  GENERATEDCONSTR) != 0;
2149                         for (int i = firstadr; i &lt; nextadr; i++) {
2150                             JCVariableDecl vardecl = vardecls[i];
2151                             VarSymbol var = vardecl.sym;
2152                             if (var.owner == classDef.sym) {
2153                                 // choose the diagnostic position based on whether
2154                                 // the ctor is default(synthesized) or not
2155                                 if (isSynthesized &amp;&amp; !isCompactConstructor) {
2156                                     checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),
2157                                             var, Errors.VarNotInitializedInDefaultConstructor(var));
2158                                 } else if (isCompactConstructor) {
2159                                     boolean isInstanceRecordField = var.enclClass().isRecord() &amp;&amp;
2160                                             (var.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
2161                                             !var.isStatic() &amp;&amp;
2162                                             var.owner.kind == TYP;
2163                                     if (isInstanceRecordField) {
2164                                         boolean notInitialized = !inits.isMember(var.adr);
2165                                         if (notInitialized &amp;&amp; uninits.isMember(var.adr) &amp;&amp; tree.completesNormally) {
2166                                         /*  this way we indicate Lower that it should generate an initialization for this field
2167                                          *  in the compact constructor
2168                                          */
2169                                             var.flags_field |= UNINITIALIZED_FIELD;
2170                                         } else {
2171                                             checkInit(TreeInfo.diagEndPos(tree.body), var);
2172                                         }
2173                                     } else {
2174                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2175                                     }
2176                                 } else {
2177                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2178                                 }
2179                             }
2180                         }
2181                     }
2182                     clearPendingExits(true);
2183                 } finally {
2184                     inits.assign(initsPrev);
2185                     uninits.assign(uninitsPrev);
2186                     nextadr = nextadrPrev;
2187                     firstadr = firstadrPrev;
2188                     returnadr = returnadrPrev;
2189                     isInitialConstructor = lastInitialConstructor;
2190                 }
2191             } finally {
2192                 lint = lintPrev;
2193                 this.thisExposability = priorThisExposability;
2194             }
2195         }
2196 
2197         private void clearPendingExits(boolean inMethod) {
2198             List&lt;PendingExit&gt; exits = pendingExits.toList();
2199             pendingExits = new ListBuffer&lt;&gt;();
2200             while (exits.nonEmpty()) {
2201                 PendingExit exit = exits.head;
2202                 exits = exits.tail;
2203                 Assert.check((inMethod &amp;&amp; exit.tree.hasTag(RETURN)) ||
2204                                  log.hasErrorOn(exit.tree.pos()),
2205                              exit.tree);
2206                 if (inMethod &amp;&amp; isInitialConstructor) {
2207                     Assert.check(exit instanceof AssignPendingExit);
2208                     inits.assign(((AssignPendingExit) exit).exit_inits);
2209                     for (int i = firstadr; i &lt; nextadr; i++) {
2210                         checkInit(exit.tree.pos(), vardecls[i].sym);
2211                     }
2212                 }
2213             }
2214         }
2215         protected void initParam(JCVariableDecl def) {
2216             inits.incl(def.sym.adr);
2217             uninits.excl(def.sym.adr);
2218         }
2219 
2220         public void visitVarDef(JCVariableDecl tree) {
2221             Lint lintPrev = lint;
2222             lint = lint.augment(tree.sym);
2223             try{
2224                 boolean track = trackable(tree.sym);
2225                 if (track &amp;&amp; (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {
2226                     newVar(tree);
2227                 }
2228                 if (tree.init != null) {
2229                     scanExpr(tree.init);
2230                     if (track) {
2231                         letInit(tree.pos(), tree.sym);
2232                     }
2233                 }
2234             } finally {
2235                 lint = lintPrev;
2236             }
2237         }
2238 
2239         public void visitBlock(JCBlock tree) {
2240             int nextadrPrev = nextadr;
2241             scan(tree.stats);
2242             nextadr = nextadrPrev;
2243         }
2244 
2245         public void visitDoLoop(JCDoWhileLoop tree) {
2246             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2247             FlowKind prevFlowKind = flowKind;
2248             flowKind = FlowKind.NORMAL;
2249             final Bits initsSkip = new Bits(true);
2250             final Bits uninitsSkip = new Bits(true);
2251             pendingExits = new ListBuffer&lt;&gt;();
2252             int prevErrors = log.nerrors;
2253             do {
2254                 final Bits uninitsEntry = new Bits(uninits);
2255                 uninitsEntry.excludeFrom(nextadr);
2256                 scan(tree.body);
2257                 resolveContinues(tree);
2258                 scanCond(tree.cond);
2259                 if (!flowKind.isFinal()) {
2260                     initsSkip.assign(initsWhenFalse);
2261                     uninitsSkip.assign(uninitsWhenFalse);
2262                 }
2263                 if (log.nerrors !=  prevErrors ||
2264                     flowKind.isFinal() ||
2265                     new Bits(uninitsEntry).diffSet(uninitsWhenTrue).nextBit(firstadr)==-1)
2266                     break;
2267                 inits.assign(initsWhenTrue);
2268                 uninits.assign(uninitsEntry.andSet(uninitsWhenTrue));
2269                 flowKind = FlowKind.SPECULATIVE_LOOP;
2270             } while (true);
2271             flowKind = prevFlowKind;
2272             inits.assign(initsSkip);
2273             uninits.assign(uninitsSkip);
2274             resolveBreaks(tree, prevPendingExits);
2275         }
2276 
2277         public void visitWhileLoop(JCWhileLoop tree) {
2278             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2279             FlowKind prevFlowKind = flowKind;
2280             flowKind = FlowKind.NORMAL;
2281             final Bits initsSkip = new Bits(true);
2282             final Bits uninitsSkip = new Bits(true);
2283             pendingExits = new ListBuffer&lt;&gt;();
2284             int prevErrors = log.nerrors;
2285             final Bits uninitsEntry = new Bits(uninits);
2286             uninitsEntry.excludeFrom(nextadr);
2287             do {
2288                 scanCond(tree.cond);
2289                 if (!flowKind.isFinal()) {
2290                     initsSkip.assign(initsWhenFalse) ;
2291                     uninitsSkip.assign(uninitsWhenFalse);
2292                 }
2293                 inits.assign(initsWhenTrue);
2294                 uninits.assign(uninitsWhenTrue);
2295                 scan(tree.body);
2296                 resolveContinues(tree);
2297                 if (log.nerrors != prevErrors ||
2298                     flowKind.isFinal() ||
2299                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1) {
2300                     break;
2301                 }
2302                 uninits.assign(uninitsEntry.andSet(uninits));
2303                 flowKind = FlowKind.SPECULATIVE_LOOP;
2304             } while (true);
2305             flowKind = prevFlowKind;
2306             //a variable is DA/DU after the while statement, if it&#39;s DA/DU assuming the
2307             //branch is not taken AND if it&#39;s DA/DU before any break statement
2308             inits.assign(initsSkip);
2309             uninits.assign(uninitsSkip);
2310             resolveBreaks(tree, prevPendingExits);
2311         }
2312 
2313         public void visitForLoop(JCForLoop tree) {
2314             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2315             FlowKind prevFlowKind = flowKind;
2316             flowKind = FlowKind.NORMAL;
2317             int nextadrPrev = nextadr;
2318             scan(tree.init);
2319             final Bits initsSkip = new Bits(true);
2320             final Bits uninitsSkip = new Bits(true);
2321             pendingExits = new ListBuffer&lt;&gt;();
2322             int prevErrors = log.nerrors;
2323             do {
2324                 final Bits uninitsEntry = new Bits(uninits);
2325                 uninitsEntry.excludeFrom(nextadr);
2326                 if (tree.cond != null) {
2327                     scanCond(tree.cond);
2328                     if (!flowKind.isFinal()) {
2329                         initsSkip.assign(initsWhenFalse);
2330                         uninitsSkip.assign(uninitsWhenFalse);
2331                     }
2332                     inits.assign(initsWhenTrue);
2333                     uninits.assign(uninitsWhenTrue);
2334                 } else if (!flowKind.isFinal()) {
2335                     initsSkip.assign(inits);
2336                     initsSkip.inclRange(firstadr, nextadr);
2337                     uninitsSkip.assign(uninits);
2338                     uninitsSkip.inclRange(firstadr, nextadr);
2339                 }
2340                 scan(tree.body);
2341                 resolveContinues(tree);
2342                 scan(tree.step);
2343                 if (log.nerrors != prevErrors ||
2344                     flowKind.isFinal() ||
2345                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2346                     break;
2347                 uninits.assign(uninitsEntry.andSet(uninits));
2348                 flowKind = FlowKind.SPECULATIVE_LOOP;
2349             } while (true);
2350             flowKind = prevFlowKind;
2351             //a variable is DA/DU after a for loop, if it&#39;s DA/DU assuming the
2352             //branch is not taken AND if it&#39;s DA/DU before any break statement
2353             inits.assign(initsSkip);
2354             uninits.assign(uninitsSkip);
2355             resolveBreaks(tree, prevPendingExits);
2356             nextadr = nextadrPrev;
2357         }
2358 
2359         public void visitForeachLoop(JCEnhancedForLoop tree) {
2360             visitVarDef(tree.var);
2361 
2362             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2363             FlowKind prevFlowKind = flowKind;
2364             flowKind = FlowKind.NORMAL;
2365             int nextadrPrev = nextadr;
2366             scan(tree.expr);
2367             final Bits initsStart = new Bits(inits);
2368             final Bits uninitsStart = new Bits(uninits);
2369 
2370             letInit(tree.pos(), tree.var.sym);
2371             pendingExits = new ListBuffer&lt;&gt;();
2372             int prevErrors = log.nerrors;
2373             do {
2374                 final Bits uninitsEntry = new Bits(uninits);
2375                 uninitsEntry.excludeFrom(nextadr);
2376                 scan(tree.body);
2377                 resolveContinues(tree);
2378                 if (log.nerrors != prevErrors ||
2379                     flowKind.isFinal() ||
2380                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2381                     break;
2382                 uninits.assign(uninitsEntry.andSet(uninits));
2383                 flowKind = FlowKind.SPECULATIVE_LOOP;
2384             } while (true);
2385             flowKind = prevFlowKind;
2386             inits.assign(initsStart);
2387             uninits.assign(uninitsStart.andSet(uninits));
2388             resolveBreaks(tree, prevPendingExits);
2389             nextadr = nextadrPrev;
2390         }
2391 
2392         public void visitLabelled(JCLabeledStatement tree) {
2393             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2394             pendingExits = new ListBuffer&lt;&gt;();
2395             scan(tree.body);
2396             resolveBreaks(tree, prevPendingExits);
2397         }
2398 
2399         public void visitSwitch(JCSwitch tree) {
2400             handleSwitch(tree, tree.selector, tree.cases);
2401         }
2402 
2403         public void visitSwitchExpression(JCSwitchExpression tree) {
2404             handleSwitch(tree, tree.selector, tree.cases);
2405         }
2406 
2407         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
2408             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2409             pendingExits = new ListBuffer&lt;&gt;();
2410             int nextadrPrev = nextadr;
2411             scanExpr(selector);
2412             final Bits initsSwitch = new Bits(inits);
2413             final Bits uninitsSwitch = new Bits(uninits);
2414             boolean hasDefault = false;
2415             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
2416                 inits.assign(initsSwitch);
2417                 uninits.assign(uninits.andSet(uninitsSwitch));
2418                 JCCase c = l.head;
2419                 if (c.pats.isEmpty()) {
2420                     hasDefault = true;
2421                 } else {
2422                     for (JCExpression pat : c.pats) {
2423                         scanExpr(pat);
2424                     }
2425                 }
2426                 if (hasDefault) {
2427                     inits.assign(initsSwitch);
2428                     uninits.assign(uninits.andSet(uninitsSwitch));
2429                 }
2430                 scan(c.stats);
2431                 if (c.completesNormally &amp;&amp; c.caseKind == JCCase.RULE) {
2432                     scanSyntheticBreak(make, tree);
2433                 }
2434                 addVars(c.stats, initsSwitch, uninitsSwitch);
2435                 if (!hasDefault) {
2436                     inits.assign(initsSwitch);
2437                     uninits.assign(uninits.andSet(uninitsSwitch));
2438                 }
2439                 // Warn about fall-through if lint switch fallthrough enabled.
2440             }
2441             if (!hasDefault) {
2442                 if (tree.hasTag(SWITCH_EXPRESSION)) {
2443                     markDead();
2444                 } else {
2445                     inits.andSet(initsSwitch);
2446                 }
2447             }
2448             if (tree.hasTag(SWITCH_EXPRESSION)) {
2449                 resolveYields(tree, prevPendingExits);
2450             } else {
2451                 resolveBreaks(tree, prevPendingExits);
2452             }
2453             nextadr = nextadrPrev;
2454         }
2455         // where
2456             /** Add any variables defined in stats to inits and uninits. */
2457             private void addVars(List&lt;JCStatement&gt; stats, final Bits inits,
2458                                         final Bits uninits) {
2459                 for (;stats.nonEmpty(); stats = stats.tail) {
2460                     JCTree stat = stats.head;
2461                     if (stat.hasTag(VARDEF)) {
2462                         int adr = ((JCVariableDecl) stat).sym.adr;
2463                         inits.excl(adr);
2464                         uninits.incl(adr);
2465                     }
2466                 }
2467             }
2468 
2469         public void visitTry(JCTry tree) {
2470             ListBuffer&lt;JCVariableDecl&gt; resourceVarDecls = new ListBuffer&lt;&gt;();
2471             final Bits uninitsTryPrev = new Bits(uninitsTry);
2472             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2473             pendingExits = new ListBuffer&lt;&gt;();
2474             final Bits initsTry = new Bits(inits);
2475             uninitsTry.assign(uninits);
2476             for (JCTree resource : tree.resources) {
2477                 if (resource instanceof JCVariableDecl) {
2478                     JCVariableDecl vdecl = (JCVariableDecl) resource;
2479                     visitVarDef(vdecl);
2480                     unrefdResources.enter(vdecl.sym);
2481                     resourceVarDecls.append(vdecl);
2482                 } else if (resource instanceof JCExpression) {
2483                     scanExpr((JCExpression) resource);
2484                 } else {
2485                     throw new AssertionError(tree);  // parser error
2486                 }
2487             }
2488             scan(tree.body);
2489             uninitsTry.andSet(uninits);
2490             final Bits initsEnd = new Bits(inits);
2491             final Bits uninitsEnd = new Bits(uninits);
2492             int nextadrCatch = nextadr;
2493 
2494             if (!resourceVarDecls.isEmpty() &amp;&amp;
2495                     lint.isEnabled(Lint.LintCategory.TRY)) {
2496                 for (JCVariableDecl resVar : resourceVarDecls) {
2497                     if (unrefdResources.includes(resVar.sym)) {
2498                         log.warning(Lint.LintCategory.TRY, resVar.pos(),
2499                                     Warnings.TryResourceNotReferenced(resVar.sym));
2500                         unrefdResources.remove(resVar.sym);
2501                     }
2502                 }
2503             }
2504 
2505             /*  The analysis of each catch should be independent.
2506              *  Each one should have the same initial values of inits and
2507              *  uninits.
2508              */
2509             final Bits initsCatchPrev = new Bits(initsTry);
2510             final Bits uninitsCatchPrev = new Bits(uninitsTry);
2511 
2512             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
2513                 JCVariableDecl param = l.head.param;
2514                 inits.assign(initsCatchPrev);
2515                 uninits.assign(uninitsCatchPrev);
2516                 scan(param);
2517                 /* If this is a TWR and we are executing the code from Gen,
2518                  * then there can be synthetic variables, ignore them.
2519                  */
2520                 initParam(param);
2521                 scan(l.head.body);
2522                 initsEnd.andSet(inits);
2523                 uninitsEnd.andSet(uninits);
2524                 nextadr = nextadrCatch;
2525             }
2526             if (tree.finalizer != null) {
2527                 inits.assign(initsTry);
2528                 uninits.assign(uninitsTry);
2529                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2530                 pendingExits = prevPendingExits;
2531                 scan(tree.finalizer);
2532                 if (!tree.finallyCanCompleteNormally) {
2533                     // discard exits and exceptions from try and finally
2534                 } else {
2535                     uninits.andSet(uninitsEnd);
2536                     // FIX: this doesn&#39;t preserve source order of exits in catch
2537                     // versus finally!
2538                     while (exits.nonEmpty()) {
2539                         PendingExit exit = exits.next();
2540                         if (exit instanceof AssignPendingExit) {
2541                             ((AssignPendingExit) exit).exit_inits.orSet(inits);
2542                             ((AssignPendingExit) exit).exit_uninits.andSet(uninits);
2543                         }
2544                         pendingExits.append(exit);
2545                     }
2546                     inits.orSet(initsEnd);
2547                 }
2548             } else {
2549                 inits.assign(initsEnd);
2550                 uninits.assign(uninitsEnd);
2551                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2552                 pendingExits = prevPendingExits;
2553                 while (exits.nonEmpty()) pendingExits.append(exits.next());
2554             }
2555             uninitsTry.andSet(uninitsTryPrev).andSet(uninits);
2556         }
2557 
2558         public void visitConditional(JCConditional tree) {
2559             scanCond(tree.cond);
2560             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2561             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2562             inits.assign(initsWhenTrue);
2563             uninits.assign(uninitsWhenTrue);
2564             if (tree.truepart.type.hasTag(BOOLEAN) &amp;&amp;
2565                 tree.falsepart.type.hasTag(BOOLEAN)) {
2566                 // if b and c are boolean valued, then
2567                 // v is (un)assigned after a?b:c when true iff
2568                 //    v is (un)assigned after b when true and
2569                 //    v is (un)assigned after c when true
2570                 scanCond(tree.truepart);
2571                 final Bits initsAfterThenWhenTrue = new Bits(initsWhenTrue);
2572                 final Bits initsAfterThenWhenFalse = new Bits(initsWhenFalse);
2573                 final Bits uninitsAfterThenWhenTrue = new Bits(uninitsWhenTrue);
2574                 final Bits uninitsAfterThenWhenFalse = new Bits(uninitsWhenFalse);
2575                 inits.assign(initsBeforeElse);
2576                 uninits.assign(uninitsBeforeElse);
2577                 scanCond(tree.falsepart);
2578                 initsWhenTrue.andSet(initsAfterThenWhenTrue);
2579                 initsWhenFalse.andSet(initsAfterThenWhenFalse);
2580                 uninitsWhenTrue.andSet(uninitsAfterThenWhenTrue);
2581                 uninitsWhenFalse.andSet(uninitsAfterThenWhenFalse);
2582             } else {
2583                 scanExpr(tree.truepart);
2584                 final Bits initsAfterThen = new Bits(inits);
2585                 final Bits uninitsAfterThen = new Bits(uninits);
2586                 inits.assign(initsBeforeElse);
2587                 uninits.assign(uninitsBeforeElse);
2588                 scanExpr(tree.falsepart);
2589                 inits.andSet(initsAfterThen);
2590                 uninits.andSet(uninitsAfterThen);
2591             }
2592         }
2593 
2594         public void visitIf(JCIf tree) {
2595             scanCond(tree.cond);
2596             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2597             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2598             inits.assign(initsWhenTrue);
2599             uninits.assign(uninitsWhenTrue);
2600             scan(tree.thenpart);
2601             if (tree.elsepart != null) {
2602                 final Bits initsAfterThen = new Bits(inits);
2603                 final Bits uninitsAfterThen = new Bits(uninits);
2604                 inits.assign(initsBeforeElse);
2605                 uninits.assign(uninitsBeforeElse);
2606                 scan(tree.elsepart);
2607                 inits.andSet(initsAfterThen);
2608                 uninits.andSet(uninitsAfterThen);
2609             } else {
2610                 inits.andSet(initsBeforeElse);
2611                 uninits.andSet(uninitsBeforeElse);
2612             }
2613         }
2614 
2615         @Override
2616         public void visitBreak(JCBreak tree) {
2617             recordExit(new AssignPendingExit(tree, inits, uninits));
2618         }
2619 
2620         @Override
2621         public void visitYield(JCYield tree) {
2622             JCSwitchExpression expr = (JCSwitchExpression) tree.target;
2623             if (expr != null &amp;&amp; expr.type.hasTag(BOOLEAN)) {
2624                 scanCond(tree.value);
2625                 Bits initsAfterBreakWhenTrue = new Bits(initsWhenTrue);
2626                 Bits initsAfterBreakWhenFalse = new Bits(initsWhenFalse);
2627                 Bits uninitsAfterBreakWhenTrue = new Bits(uninitsWhenTrue);
2628                 Bits uninitsAfterBreakWhenFalse = new Bits(uninitsWhenFalse);
2629                 PendingExit exit = new PendingExit(tree) {
2630                     @Override
2631                     void resolveJump() {
2632                         if (!inits.isReset()) {
2633                             split(true);
2634                         }
2635                         initsWhenTrue.andSet(initsAfterBreakWhenTrue);
2636                         initsWhenFalse.andSet(initsAfterBreakWhenFalse);
2637                         uninitsWhenTrue.andSet(uninitsAfterBreakWhenTrue);
2638                         uninitsWhenFalse.andSet(uninitsAfterBreakWhenFalse);
2639                     }
2640                 };
2641                 merge();
2642                 recordExit(exit);
2643                 return ;
2644             } else {
2645                 scanExpr(tree.value);
2646                 recordExit(new AssignPendingExit(tree, inits, uninits));
2647             }
2648         }
2649 
2650         @Override
2651         public void visitContinue(JCContinue tree) {
2652             recordExit(new AssignPendingExit(tree, inits, uninits));
2653         }
2654 
2655         @Override
2656         public void visitReturn(JCReturn tree) {
2657             scanExpr(tree.expr);
2658             recordExit(new AssignPendingExit(tree, inits, uninits));
2659         }
2660 
2661         public void visitThrow(JCThrow tree) {
2662             scanExpr(tree.expr);
2663             markDead();
2664         }
2665 
2666         public void visitApply(JCMethodInvocation tree) {
2667             scanExpr(tree.meth);
2668             scanExprs(tree.args);
2669             if (tree.meth.hasTag(IDENT)) {
2670                 JCIdent ident = (JCIdent) tree.meth;
2671                 if (ident.name != names._super &amp;&amp; !ident.sym.isStatic())
2672                     checkEmbryonicThisExposure(tree);
2673             }
2674         }
2675 
2676         public void visitNewClass(JCNewClass tree) {
2677             scanExpr(tree.encl);
2678             scanExprs(tree.args);
2679             scan(tree.def);
2680             if (classDef != null &amp;&amp; tree.encl == null &amp;&amp; tree.clazz.hasTag(IDENT)) {
2681                 JCIdent clazz = (JCIdent) tree.clazz;
2682                 if (!clazz.sym.isStatic() &amp;&amp; clazz.type.getEnclosingType().tsym == classDef.sym) {
2683                     checkEmbryonicThisExposure(tree);
2684                 }
2685             }
2686         }
2687 
2688         @Override
2689         public void visitLambda(JCLambda tree) {
2690             final Bits prevUninits = new Bits(uninits);
2691             final Bits prevInits = new Bits(inits);
2692             int returnadrPrev = returnadr;
2693             int nextadrPrev = nextadr;
2694             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
2695             try {
2696                 returnadr = nextadr;
2697                 pendingExits = new ListBuffer&lt;&gt;();
2698                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2699                     JCVariableDecl def = l.head;
2700                     scan(def);
2701                     inits.incl(def.sym.adr);
2702                     uninits.excl(def.sym.adr);
2703                 }
2704                 if (tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2705                     scanExpr(tree.body);
2706                 } else {
2707                     scan(tree.body);
2708                 }
2709             }
2710             finally {
2711                 returnadr = returnadrPrev;
2712                 uninits.assign(prevUninits);
2713                 inits.assign(prevInits);
2714                 pendingExits = prevPending;
2715                 nextadr = nextadrPrev;
2716             }
2717         }
2718 
2719         public void visitNewArray(JCNewArray tree) {
2720             scanExprs(tree.dims);
2721             scanExprs(tree.elems);
2722         }
2723 
2724         public void visitAssert(JCAssert tree) {
2725             final Bits initsExit = new Bits(inits);
2726             final Bits uninitsExit = new Bits(uninits);
2727             scanCond(tree.cond);
2728             uninitsExit.andSet(uninitsWhenTrue);
2729             if (tree.detail != null) {
2730                 inits.assign(initsWhenFalse);
2731                 uninits.assign(uninitsWhenFalse);
2732                 scanExpr(tree.detail);
2733             }
2734             inits.assign(initsExit);
2735             uninits.assign(uninitsExit);
2736         }
2737 
2738         public void visitAssign(JCAssign tree) {
2739             if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))
2740                 scanExpr(tree.lhs);
2741             scanExpr(tree.rhs);
2742             letInit(tree.lhs);
2743         }
2744 
2745         // check fields accessed through this.&lt;field&gt; are definitely
2746         // assigned before reading their value
2747         public void visitSelect(JCFieldAccess tree) {
2748             ThisExposability priorThisExposability = this.thisExposability;
2749             try {
2750                 if (tree.name == names._this &amp;&amp; classDef != null &amp;&amp; tree.sym.owner == classDef.sym) {
2751                     checkEmbryonicThisExposure(tree);
2752                 } else if (tree.sym.kind == VAR || tree.sym.isStatic()) {
2753                     this.thisExposability = ALLOWED;
2754                 }
2755                 super.visitSelect(tree);
2756             if (TreeInfo.isThisQualifier(tree.selected) &amp;&amp;
2757                 tree.sym.kind == VAR) {
2758                     checkInit(tree.pos(), (VarSymbol)tree.sym);
2759                 }
2760             } finally {
2761                  this.thisExposability = priorThisExposability;
2762             }
2763         }
2764 
2765         public void visitAssignop(JCAssignOp tree) {
2766             scanExpr(tree.lhs);
2767             scanExpr(tree.rhs);
2768             letInit(tree.lhs);
2769         }
2770 
2771         public void visitUnary(JCUnary tree) {
2772             switch (tree.getTag()) {
2773             case NOT:
2774                 scanCond(tree.arg);
2775                 final Bits t = new Bits(initsWhenFalse);
2776                 initsWhenFalse.assign(initsWhenTrue);
2777                 initsWhenTrue.assign(t);
2778                 t.assign(uninitsWhenFalse);
2779                 uninitsWhenFalse.assign(uninitsWhenTrue);
2780                 uninitsWhenTrue.assign(t);
2781                 break;
2782             case PREINC: case POSTINC:
2783             case PREDEC: case POSTDEC:
2784                 scanExpr(tree.arg);
2785                 letInit(tree.arg);
2786                 break;
2787             default:
2788                 scanExpr(tree.arg);
2789             }
2790         }
2791 
2792         public void visitBinary(JCBinary tree) {
2793             switch (tree.getTag()) {
2794             case AND:
2795                 scanCond(tree.lhs);
2796                 final Bits initsWhenFalseLeft = new Bits(initsWhenFalse);
2797                 final Bits uninitsWhenFalseLeft = new Bits(uninitsWhenFalse);
2798                 inits.assign(initsWhenTrue);
2799                 uninits.assign(uninitsWhenTrue);
2800                 scanCond(tree.rhs);
2801                 initsWhenFalse.andSet(initsWhenFalseLeft);
2802                 uninitsWhenFalse.andSet(uninitsWhenFalseLeft);
2803                 break;
2804             case OR:
2805                 scanCond(tree.lhs);
2806                 final Bits initsWhenTrueLeft = new Bits(initsWhenTrue);
2807                 final Bits uninitsWhenTrueLeft = new Bits(uninitsWhenTrue);
2808                 inits.assign(initsWhenFalse);
2809                 uninits.assign(uninitsWhenFalse);
2810                 scanCond(tree.rhs);
2811                 initsWhenTrue.andSet(initsWhenTrueLeft);
2812                 uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
2813                 break;
2814             default:
2815                 scanExpr(tree.lhs);
2816                 scanExpr(tree.rhs);
2817             }
2818         }
2819 
2820         public void visitIdent(JCIdent tree) {
2821             if (tree.sym.kind == VAR) {
2822                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2823                 referenced(tree.sym);
2824             }
2825             if (tree.name == names._this) {
2826                 checkEmbryonicThisExposure(tree);
2827             }
2828         }
2829 
2830         void referenced(Symbol sym) {
2831             unrefdResources.remove(sym);
2832         }
2833 
2834         public void visitAnnotatedType(JCAnnotatedType tree) {
2835             // annotations don&#39;t get scanned
2836             tree.underlyingType.accept(this);
2837         }
2838 
2839         public void visitModuleDef(JCModuleDecl tree) {
2840             // Do nothing for modules
2841         }
2842 
2843     /**************************************************************************
2844      * main method
2845      *************************************************************************/
2846 
2847         /** Perform definite assignment/unassignment analysis on a tree.
2848          */
2849         public void analyzeTree(Env&lt;?&gt; env, TreeMaker make) {
2850             analyzeTree(env, env.tree, make);
2851          }
2852 
2853         public void analyzeTree(Env&lt;?&gt; env, JCTree tree, TreeMaker make) {
2854             try {
2855                 startPos = tree.pos().getStartPosition();
2856 
2857                 if (vardecls == null)
2858                     vardecls = new JCVariableDecl[32];
2859                 else
2860                     for (int i=0; i&lt;vardecls.length; i++)
2861                         vardecls[i] = null;
2862                 firstadr = 0;
2863                 nextadr = 0;
2864                 Flow.this.make = make;
2865                 pendingExits = new ListBuffer&lt;&gt;();
2866                 this.classDef = null;
2867                 unrefdResources = WriteableScope.create(env.enclClass.sym);
2868                 scan(tree);
2869             } finally {
2870                 // note that recursive invocations of this method fail hard
2871                 startPos = -1;
2872                 resetBits(inits, uninits, uninitsTry, initsWhenTrue,
2873                         initsWhenFalse, uninitsWhenTrue, uninitsWhenFalse);
2874                 if (vardecls != null) {
2875                     for (int i=0; i&lt;vardecls.length; i++)
2876                         vardecls[i] = null;
2877                 }
2878                 firstadr = 0;
2879                 nextadr = 0;
2880                 Flow.this.make = null;
2881                 pendingExits = null;
2882                 this.classDef = null;
2883                 unrefdResources = null;
2884             }
2885         }
2886     }
2887 
2888     /**
2889      * This pass implements the last step of the dataflow analysis, namely
2890      * the effectively-final analysis check. This checks that every local variable
2891      * reference from a lambda body/local inner class is either final or effectively final.
2892      * Additional this also checks that every variable that is used as an operand to
2893      * try-with-resources is final or effectively final.
2894      * As effectively final variables are marked as such during DA/DU, this pass must run after
2895      * AssignAnalyzer.
2896      */
2897     class CaptureAnalyzer extends BaseAnalyzer {
2898 
2899         JCTree currentTree; //local class or lambda
2900 
2901         @Override
2902         void markDead() {
2903             //do nothing
2904         }
2905 
2906         @SuppressWarnings(&quot;fallthrough&quot;)
2907         void checkEffectivelyFinal(DiagnosticPosition pos, VarSymbol sym) {
2908             if (currentTree != null &amp;&amp;
2909                     sym.owner.kind == MTH &amp;&amp;
2910                     sym.pos &lt; currentTree.getStartPosition()) {
2911                 switch (currentTree.getTag()) {
2912                     case CLASSDEF:
2913                         if (!allowEffectivelyFinalInInnerClasses) {
2914                             if ((sym.flags() &amp; FINAL) == 0) {
2915                                 reportInnerClsNeedsFinalError(pos, sym);
2916                             }
2917                             break;
2918                         }
2919                     case LAMBDA:
2920                         if ((sym.flags() &amp; (EFFECTIVELY_FINAL | FINAL)) == 0) {
2921                            reportEffectivelyFinalError(pos, sym);
2922                         }
2923                 }
2924             }
2925         }
2926 
2927         @SuppressWarnings(&quot;fallthrough&quot;)
2928         void letInit(JCTree tree) {
2929             tree = TreeInfo.skipParens(tree);
2930             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
2931                 Symbol sym = TreeInfo.symbol(tree);
2932                 if (currentTree != null &amp;&amp;
2933                         sym.kind == VAR &amp;&amp;
2934                         sym.owner.kind == MTH &amp;&amp;
2935                         ((VarSymbol)sym).pos &lt; currentTree.getStartPosition()) {
2936                     switch (currentTree.getTag()) {
2937                         case CLASSDEF:
2938                             if (!allowEffectivelyFinalInInnerClasses) {
2939                                 reportInnerClsNeedsFinalError(tree, sym);
2940                                 break;
2941                             }
2942                         case LAMBDA:
2943                             reportEffectivelyFinalError(tree, sym);
2944                     }
2945                 }
2946             }
2947         }
2948 
2949         void reportEffectivelyFinalError(DiagnosticPosition pos, Symbol sym) {
2950             String subKey = currentTree.hasTag(LAMBDA) ?
2951                   &quot;lambda&quot;  : &quot;inner.cls&quot;;
2952             log.error(pos, Errors.CantRefNonEffectivelyFinalVar(sym, diags.fragment(subKey)));
2953         }
2954 
2955         void reportInnerClsNeedsFinalError(DiagnosticPosition pos, Symbol sym) {
2956             log.error(pos,
2957                       Errors.LocalVarAccessedFromIclsNeedsFinal(sym));
2958         }
2959 
2960     /*************************************************************************
2961      * Visitor methods for statements and definitions
2962      *************************************************************************/
2963 
2964         /* ------------ Visitor methods for various sorts of trees -------------*/
2965 
2966         public void visitClassDef(JCClassDecl tree) {
2967             JCTree prevTree = currentTree;
2968             try {
2969                 currentTree = tree.sym.isLocal() ? tree : null;
2970                 super.visitClassDef(tree);
2971             } finally {
2972                 currentTree = prevTree;
2973             }
2974         }
2975 
2976         @Override
2977         public void visitLambda(JCLambda tree) {
2978             JCTree prevTree = currentTree;
2979             try {
2980                 currentTree = tree;
2981                 super.visitLambda(tree);
2982             } finally {
2983                 currentTree = prevTree;
2984             }
2985         }
2986 
2987         @Override
2988         public void visitIdent(JCIdent tree) {
2989             if (tree.sym.kind == VAR) {
2990                 checkEffectivelyFinal(tree, (VarSymbol)tree.sym);
2991             }
2992         }
2993 
2994         public void visitAssign(JCAssign tree) {
2995             JCTree lhs = TreeInfo.skipParens(tree.lhs);
2996             if (!(lhs instanceof JCIdent)) {
2997                 scan(lhs);
2998             }
2999             scan(tree.rhs);
3000             letInit(lhs);
3001         }
3002 
3003         public void visitAssignop(JCAssignOp tree) {
3004             scan(tree.lhs);
3005             scan(tree.rhs);
3006             letInit(tree.lhs);
3007         }
3008 
3009         public void visitUnary(JCUnary tree) {
3010             switch (tree.getTag()) {
3011                 case PREINC: case POSTINC:
3012                 case PREDEC: case POSTDEC:
3013                     scan(tree.arg);
3014                     letInit(tree.arg);
3015                     break;
3016                 default:
3017                     scan(tree.arg);
3018             }
3019         }
3020 
3021         public void visitTry(JCTry tree) {
3022             for (JCTree resource : tree.resources) {
3023                 if (!resource.hasTag(VARDEF)) {
3024                     Symbol var = TreeInfo.symbol(resource);
3025                     if (var != null &amp;&amp; (var.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) == 0) {
3026                         log.error(resource.pos(), Errors.TryWithResourcesExprEffectivelyFinalVar(var));
3027                     }
3028                 }
3029             }
3030             super.visitTry(tree);
3031         }
3032 
3033         @Override
3034         public void visitYield(JCYield tree) {
3035             scan(tree.value);
3036         }
3037 
3038         public void visitModuleDef(JCModuleDecl tree) {
3039             // Do nothing for modules
3040         }
3041 
3042     /**************************************************************************
3043      * main method
3044      *************************************************************************/
3045 
3046         /** Perform definite assignment/unassignment analysis on a tree.
3047          */
3048         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
3049             analyzeTree(env, env.tree, make);
3050         }
3051         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
3052             try {
3053                 attrEnv = env;
3054                 Flow.this.make = make;
3055                 pendingExits = new ListBuffer&lt;&gt;();
3056                 scan(tree);
3057             } finally {
3058                 pendingExits = null;
3059                 Flow.this.make = null;
3060             }
3061         }
3062     }
3063 
3064     enum Liveness {
3065         ALIVE {
3066             @Override
3067             public Liveness or(Liveness other) {
3068                 return this;
3069             }
3070             @Override
3071             public Liveness and(Liveness other) {
3072                 return other;
3073             }
3074         },
3075         DEAD {
3076             @Override
3077             public Liveness or(Liveness other) {
3078                 return other;
3079             }
3080             @Override
3081             public Liveness and(Liveness other) {
3082                 return this;
3083             }
3084         },
3085         RECOVERY {
3086             @Override
3087             public Liveness or(Liveness other) {
3088                 if (other == ALIVE) {
3089                     return ALIVE;
3090                 } else {
3091                     return this;
3092                 }
3093             }
3094             @Override
3095             public Liveness and(Liveness other) {
3096                 if (other == DEAD) {
3097                     return DEAD;
3098                 } else {
3099                     return this;
3100                 }
3101             }
3102         };
3103 
3104         public abstract Liveness or(Liveness other);
3105         public abstract Liveness and(Liveness other);
3106         public Liveness or(boolean value) {
3107             return or(from(value));
3108         }
3109         public Liveness and(boolean value) {
3110             return and(from(value));
3111         }
3112         public static Liveness from(boolean value) {
3113             return value ? ALIVE : DEAD;
3114         }
3115     }
3116 
3117 }
    </pre>
  </body>
</html>
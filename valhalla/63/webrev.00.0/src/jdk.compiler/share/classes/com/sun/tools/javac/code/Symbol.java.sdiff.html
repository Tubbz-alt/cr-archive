<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../../../java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Symtab.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Symbol.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1249         }
1250 
1251         @DefinedBy(Api.LANGUAGE_MODEL)
1252         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1253             return v.visitPackage(this, p);
1254         }
1255 
1256         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1257             return v.visitPackageSymbol(this, p);
1258         }
1259 
1260         /**Resets the Symbol into the state good for next round of annotation processing.*/
1261         public void reset() {
1262             metadata = null;
1263         }
1264 
1265     }
1266 
1267     public static class RootPackageSymbol extends PackageSymbol {
1268         public final MissingInfoHandler missingInfoHandler;

1269 
<span class="line-modified">1270         public RootPackageSymbol(Name name, Symbol owner, MissingInfoHandler missingInfoHandler) {</span>


1271             super(name, owner);
1272             this.missingInfoHandler = missingInfoHandler;

1273         }
1274 
1275     }
1276 
1277     /** A class for class symbols
1278      */
1279     public static class ClassSymbol extends TypeSymbol implements TypeElement {
1280 
1281         /** a scope for all class members; variables, methods and inner classes
1282          *  type parameters are not part of this scope
1283          */
1284         public WriteableScope members_field;
1285 
1286         /** the fully qualified name of the class, i.e. pck.outer.inner.
1287          *  null for anonymous classes
1288          */
1289         public Name fullname;
1290 
1291         /** the fully qualified name of the class after converting to flat
1292          *  representation, i.e. pck.outer$inner,
</pre>
<hr />
<pre>
2445         public MethodHandleSymbol(Symbol msym, boolean getter) {
2446             super(msym.flags_field, msym.name, msym.type, msym.owner);
2447             this.refSym = msym;
2448             this.getter = getter;
2449         }
2450 
2451         /**
2452          * Returns the kind associated with this method handle.
2453          */
2454         public int referenceKind() {
2455             if (refSym.kind == VAR) {
2456                 return getter ?
2457                         refSym.isStatic() ? ClassFile.REF_getStatic : ClassFile.REF_getField :
2458                         refSym.isStatic() ? ClassFile.REF_putStatic : ClassFile.REF_putField;
2459             } else {
2460                 if (refSym.isConstructor()) {
2461                     return ClassFile.REF_newInvokeSpecial;
2462                 } else {
2463                     if (refSym.isStatic()) {
2464                         return ClassFile.REF_invokeStatic;
<span class="line-modified">2465                     } else if ((refSym.flags() &amp; PRIVATE) != 0) {</span>
2466                         return ClassFile.REF_invokeSpecial;
2467                     } else if (refSym.enclClass().isInterface()) {
2468                         return ClassFile.REF_invokeInterface;
2469                     } else {
2470                         return ClassFile.REF_invokeVirtual;
2471                     }
2472                 }
2473             }
2474         }
2475 







2476         @Override
2477         public int poolTag() {
2478             return ClassFile.CONSTANT_MethodHandle;
2479         }
2480 
2481         @Override
2482         public Object poolKey(Types types) {
2483             return new Pair&lt;&gt;(baseSymbol(), referenceKind());
2484         }
2485 
2486         @Override
2487         public MethodHandleSymbol asHandle() {
2488             return this;
2489         }
2490 
2491         @Override
2492         public Symbol baseSymbol() {
2493             return refSym;
2494         }
2495 
</pre>
</td>
<td>
<hr />
<pre>
1249         }
1250 
1251         @DefinedBy(Api.LANGUAGE_MODEL)
1252         public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
1253             return v.visitPackage(this, p);
1254         }
1255 
1256         public &lt;R, P&gt; R accept(Symbol.Visitor&lt;R, P&gt; v, P p) {
1257             return v.visitPackageSymbol(this, p);
1258         }
1259 
1260         /**Resets the Symbol into the state good for next round of annotation processing.*/
1261         public void reset() {
1262             metadata = null;
1263         }
1264 
1265     }
1266 
1267     public static class RootPackageSymbol extends PackageSymbol {
1268         public final MissingInfoHandler missingInfoHandler;
<span class="line-added">1269         public final boolean allowPrivateInvokeVirtual;</span>
1270 
<span class="line-modified">1271         public RootPackageSymbol(Name name, Symbol owner,</span>
<span class="line-added">1272                                  MissingInfoHandler missingInfoHandler,</span>
<span class="line-added">1273                                  boolean allowPrivateInvokeVirtual) {</span>
1274             super(name, owner);
1275             this.missingInfoHandler = missingInfoHandler;
<span class="line-added">1276             this.allowPrivateInvokeVirtual = allowPrivateInvokeVirtual;</span>
1277         }
1278 
1279     }
1280 
1281     /** A class for class symbols
1282      */
1283     public static class ClassSymbol extends TypeSymbol implements TypeElement {
1284 
1285         /** a scope for all class members; variables, methods and inner classes
1286          *  type parameters are not part of this scope
1287          */
1288         public WriteableScope members_field;
1289 
1290         /** the fully qualified name of the class, i.e. pck.outer.inner.
1291          *  null for anonymous classes
1292          */
1293         public Name fullname;
1294 
1295         /** the fully qualified name of the class after converting to flat
1296          *  representation, i.e. pck.outer$inner,
</pre>
<hr />
<pre>
2449         public MethodHandleSymbol(Symbol msym, boolean getter) {
2450             super(msym.flags_field, msym.name, msym.type, msym.owner);
2451             this.refSym = msym;
2452             this.getter = getter;
2453         }
2454 
2455         /**
2456          * Returns the kind associated with this method handle.
2457          */
2458         public int referenceKind() {
2459             if (refSym.kind == VAR) {
2460                 return getter ?
2461                         refSym.isStatic() ? ClassFile.REF_getStatic : ClassFile.REF_getField :
2462                         refSym.isStatic() ? ClassFile.REF_putStatic : ClassFile.REF_putField;
2463             } else {
2464                 if (refSym.isConstructor()) {
2465                     return ClassFile.REF_newInvokeSpecial;
2466                 } else {
2467                     if (refSym.isStatic()) {
2468                         return ClassFile.REF_invokeStatic;
<span class="line-modified">2469                     } else if ((refSym.flags() &amp; PRIVATE) != 0 &amp;&amp; !allowPrivateInvokeVirtual()) {</span>
2470                         return ClassFile.REF_invokeSpecial;
2471                     } else if (refSym.enclClass().isInterface()) {
2472                         return ClassFile.REF_invokeInterface;
2473                     } else {
2474                         return ClassFile.REF_invokeVirtual;
2475                     }
2476                 }
2477             }
2478         }
2479 
<span class="line-added">2480         private boolean allowPrivateInvokeVirtual() {</span>
<span class="line-added">2481             Symbol rootPack = this;</span>
<span class="line-added">2482             while (rootPack != null &amp;&amp; !(rootPack instanceof RootPackageSymbol)) {</span>
<span class="line-added">2483                 rootPack = rootPack.owner;</span>
<span class="line-added">2484             }</span>
<span class="line-added">2485             return rootPack != null &amp;&amp; ((RootPackageSymbol) rootPack).allowPrivateInvokeVirtual;</span>
<span class="line-added">2486         }</span>
2487         @Override
2488         public int poolTag() {
2489             return ClassFile.CONSTANT_MethodHandle;
2490         }
2491 
2492         @Override
2493         public Object poolKey(Types types) {
2494             return new Pair&lt;&gt;(baseSymbol(), referenceKind());
2495         }
2496 
2497         @Override
2498         public MethodHandleSymbol asHandle() {
2499             return this;
2500         }
2501 
2502         @Override
2503         public Symbol baseSymbol() {
2504             return refSym;
2505         }
2506 
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../../../java.base/share/classes/sun/invoke/util/BytecodeDescriptor.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Symtab.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
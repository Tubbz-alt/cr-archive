<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Flow.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 //todo: one might eliminate uninits.andSets when monotonic
  27 
  28 package com.sun.tools.javac.comp;
  29 
  30 import java.util.HashMap;
  31 import java.util.HashSet;
  32 import java.util.Set;
  33 import java.util.stream.Collectors;
  34 
  35 import com.sun.source.tree.LambdaExpressionTree.BodyKind;
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Scope.WriteableScope;
  38 import com.sun.tools.javac.code.Source.Feature;
  39 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  40 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  41 import com.sun.tools.javac.tree.*;
  42 import com.sun.tools.javac.util.*;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.JCDiagnostic.Error;
  45 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  46 
  47 import com.sun.tools.javac.code.Symbol.*;
  48 import com.sun.tools.javac.tree.JCTree.*;
  49 
  50 import static com.sun.tools.javac.code.Flags.*;
  51 import static com.sun.tools.javac.code.Flags.BLOCK;
  52 import static com.sun.tools.javac.code.Kinds.Kind.*;
  53 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
  54 import static com.sun.tools.javac.code.TypeTag.VOID;
  55 import static com.sun.tools.javac.comp.Flow.ThisExposability.ALLOWED;
  56 import static com.sun.tools.javac.comp.Flow.ThisExposability.BANNED;
  57 import static com.sun.tools.javac.comp.Flow.ThisExposability.DISCOURAGED;
  58 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  59 
  60 /** This pass implements dataflow analysis for Java programs though
  61  *  different AST visitor steps. Liveness analysis (see AliveAnalyzer) checks that
  62  *  every statement is reachable. Exception analysis (see FlowAnalyzer) ensures that
  63  *  every checked exception that is thrown is declared or caught.  Definite assignment analysis
  64  *  (see AssignAnalyzer) ensures that each variable is assigned when used.  Definite
  65  *  unassignment analysis (see AssignAnalyzer) in ensures that no final variable
  66  *  is assigned more than once. Finally, local variable capture analysis (see CaptureAnalyzer)
  67  *  determines that local variables accessed within the scope of an inner class/lambda
  68  *  are either final or effectively-final.
  69  *
  70  *  &lt;p&gt;The JLS has a number of problems in the
  71  *  specification of these flow analysis problems. This implementation
  72  *  attempts to address those issues.
  73  *
  74  *  &lt;p&gt;First, there is no accommodation for a finally clause that cannot
  75  *  complete normally. For liveness analysis, an intervening finally
  76  *  clause can cause a break, continue, or return not to reach its
  77  *  target.  For exception analysis, an intervening finally clause can
  78  *  cause any exception to be &quot;caught&quot;.  For DA/DU analysis, the finally
  79  *  clause can prevent a transfer of control from propagating DA/DU
  80  *  state to the target.  In addition, code in the finally clause can
  81  *  affect the DA/DU status of variables.
  82  *
  83  *  &lt;p&gt;For try statements, we introduce the idea of a variable being
  84  *  definitely unassigned &quot;everywhere&quot; in a block.  A variable V is
  85  *  &quot;unassigned everywhere&quot; in a block iff it is unassigned at the
  86  *  beginning of the block and there is no reachable assignment to V
  87  *  in the block.  An assignment V=e is reachable iff V is not DA
  88  *  after e.  Then we can say that V is DU at the beginning of the
  89  *  catch block iff V is DU everywhere in the try block.  Similarly, V
  90  *  is DU at the beginning of the finally block iff V is DU everywhere
  91  *  in the try block and in every catch block.  Specifically, the
  92  *  following bullet is added to 16.2.2
  93  *  &lt;pre&gt;
  94  *      V is &lt;em&gt;unassigned everywhere&lt;/em&gt; in a block if it is
  95  *      unassigned before the block and there is no reachable
  96  *      assignment to V within the block.
  97  *  &lt;/pre&gt;
  98  *  &lt;p&gt;In 16.2.15, the third bullet (and all of its sub-bullets) for all
  99  *  try blocks is changed to
 100  *  &lt;pre&gt;
 101  *      V is definitely unassigned before a catch block iff V is
 102  *      definitely unassigned everywhere in the try block.
 103  *  &lt;/pre&gt;
 104  *  &lt;p&gt;The last bullet (and all of its sub-bullets) for try blocks that
 105  *  have a finally block is changed to
 106  *  &lt;pre&gt;
 107  *      V is definitely unassigned before the finally block iff
 108  *      V is definitely unassigned everywhere in the try block
 109  *      and everywhere in each catch block of the try statement.
 110  *  &lt;/pre&gt;
 111  *  &lt;p&gt;In addition,
 112  *  &lt;pre&gt;
 113  *      V is definitely assigned at the end of a constructor iff
 114  *      V is definitely assigned after the block that is the body
 115  *      of the constructor and V is definitely assigned at every
 116  *      return that can return from the constructor.
 117  *  &lt;/pre&gt;
 118  *  &lt;p&gt;In addition, each continue statement with the loop as its target
 119  *  is treated as a jump to the end of the loop body, and &quot;intervening&quot;
 120  *  finally clauses are treated as follows: V is DA &quot;due to the
 121  *  continue&quot; iff V is DA before the continue statement or V is DA at
 122  *  the end of any intervening finally block.  V is DU &quot;due to the
 123  *  continue&quot; iff any intervening finally cannot complete normally or V
 124  *  is DU at the end of every intervening finally block.  This &quot;due to
 125  *  the continue&quot; concept is then used in the spec for the loops.
 126  *
 127  *  &lt;p&gt;Similarly, break statements must consider intervening finally
 128  *  blocks.  For liveness analysis, a break statement for which any
 129  *  intervening finally cannot complete normally is not considered to
 130  *  cause the target statement to be able to complete normally. Then
 131  *  we say V is DA &quot;due to the break&quot; iff V is DA before the break or
 132  *  V is DA at the end of any intervening finally block.  V is DU &quot;due
 133  *  to the break&quot; iff any intervening finally cannot complete normally
 134  *  or V is DU at the break and at the end of every intervening
 135  *  finally block.  (I suspect this latter condition can be
 136  *  simplified.)  This &quot;due to the break&quot; is then used in the spec for
 137  *  all statements that can be &quot;broken&quot;.
 138  *
 139  *  &lt;p&gt;The return statement is treated similarly.  V is DA &quot;due to a
 140  *  return statement&quot; iff V is DA before the return statement or V is
 141  *  DA at the end of any intervening finally block.  Note that we
 142  *  don&#39;t have to worry about the return expression because this
 143  *  concept is only used for constructors.
 144  *
 145  *  &lt;p&gt;There is no spec in the JLS for when a variable is definitely
 146  *  assigned at the end of a constructor, which is needed for final
 147  *  fields (8.3.1.2).  We implement the rule that V is DA at the end
 148  *  of the constructor iff it is DA and the end of the body of the
 149  *  constructor and V is DA &quot;due to&quot; every return of the constructor.
 150  *
 151  *  &lt;p&gt;Intervening finally blocks similarly affect exception analysis.  An
 152  *  intervening finally that cannot complete normally allows us to ignore
 153  *  an otherwise uncaught exception.
 154  *
 155  *  &lt;p&gt;To implement the semantics of intervening finally clauses, all
 156  *  nonlocal transfers (break, continue, return, throw, method call that
 157  *  can throw a checked exception, and a constructor invocation that can
 158  *  thrown a checked exception) are recorded in a queue, and removed
 159  *  from the queue when we complete processing the target of the
 160  *  nonlocal transfer.  This allows us to modify the queue in accordance
 161  *  with the above rules when we encounter a finally clause.  The only
 162  *  exception to this [no pun intended] is that checked exceptions that
 163  *  are known to be caught or declared to be caught in the enclosing
 164  *  method are not recorded in the queue, but instead are recorded in a
 165  *  global variable &quot;{@code Set&lt;Type&gt; thrown}&quot; that records the type of all
 166  *  exceptions that can be thrown.
 167  *
 168  *  &lt;p&gt;Other minor issues the treatment of members of other classes
 169  *  (always considered DA except that within an anonymous class
 170  *  constructor, where DA status from the enclosing scope is
 171  *  preserved), treatment of the case expression (V is DA before the
 172  *  case expression iff V is DA after the switch expression),
 173  *  treatment of variables declared in a switch block (the implied
 174  *  DA/DU status after the switch expression is DU and not DA for
 175  *  variables defined in a switch block), the treatment of boolean ?:
 176  *  expressions (The JLS rules only handle b and c non-boolean; the
 177  *  new rule is that if b and c are boolean valued, then V is
 178  *  (un)assigned after a?b:c when true/false iff V is (un)assigned
 179  *  after b when true/false and V is (un)assigned after c when
 180  *  true/false).
 181  *
 182  *  &lt;p&gt;There is the remaining question of what syntactic forms constitute a
 183  *  reference to a variable.  It is conventional to allow this.x on the
 184  *  left-hand-side to initialize a final instance field named x, yet
 185  *  this.x isn&#39;t considered a &quot;use&quot; when appearing on a right-hand-side
 186  *  in most implementations.  Should parentheses affect what is
 187  *  considered a variable reference?  The simplest rule would be to
 188  *  allow unqualified forms only, parentheses optional, and phase out
 189  *  support for assigning to a final field via this.x.
 190  *
 191  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 192  *  If you write code that depends on this, you do so at your own risk.
 193  *  This code and its internal interfaces are subject to change or
 194  *  deletion without notice.&lt;/b&gt;
 195  */
 196 public class Flow {
 197     protected static final Context.Key&lt;Flow&gt; flowKey = new Context.Key&lt;&gt;();
 198 
 199     private final Names names;
 200     private final Log log;
 201     private final Symtab syms;
 202     private final Types types;
 203     private final Check chk;
 204     private       TreeMaker make;
 205     private final Resolve rs;
 206     private final JCDiagnostic.Factory diags;
 207     private Env&lt;AttrContext&gt; attrEnv;
 208     private       Lint lint;
 209     private final boolean allowEffectivelyFinalInInnerClasses;
 210 
 211     public static Flow instance(Context context) {
 212         Flow instance = context.get(flowKey);
 213         if (instance == null)
 214             instance = new Flow(context);
 215         return instance;
 216     }
 217 
 218     public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 219         new AliveAnalyzer().analyzeTree(env, make);
 220         new AssignAnalyzer().analyzeTree(env, make);
 221         new FlowAnalyzer().analyzeTree(env, make);
 222         new CaptureAnalyzer().analyzeTree(env, make);
 223     }
 224 
 225     public void analyzeLambda(Env&lt;AttrContext&gt; env, JCLambda that, TreeMaker make, boolean speculative) {
 226         Log.DiagnosticHandler diagHandler = null;
 227         //we need to disable diagnostics temporarily; the problem is that if
 228         //a lambda expression contains e.g. an unreachable statement, an error
 229         //message will be reported and will cause compilation to skip the flow analysis
 230         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 231         //related errors, which will allow for more errors to be detected
 232         if (!speculative) {
 233             diagHandler = new Log.DiscardDiagnosticHandler(log);
 234         }
 235         try {
 236             new LambdaAliveAnalyzer().analyzeTree(env, that, make);
 237         } finally {
 238             if (!speculative) {
 239                 log.popDiagnosticHandler(diagHandler);
 240             }
 241         }
 242     }
 243 
 244     public List&lt;Type&gt; analyzeLambdaThrownTypes(final Env&lt;AttrContext&gt; env,
 245             JCLambda that, TreeMaker make) {
 246         //we need to disable diagnostics temporarily; the problem is that if
 247         //a lambda expression contains e.g. an unreachable statement, an error
 248         //message will be reported and will cause compilation to skip the flow analysis
 249         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 250         //related errors, which will allow for more errors to be detected
 251         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 252         try {
 253             new LambdaAssignAnalyzer(env).analyzeTree(env, that, make);
 254             LambdaFlowAnalyzer flowAnalyzer = new LambdaFlowAnalyzer();
 255             flowAnalyzer.analyzeTree(env, that, make);
 256             return flowAnalyzer.inferredThrownTypes;
 257         } finally {
 258             log.popDiagnosticHandler(diagHandler);
 259         }
 260     }
 261 
 262     public boolean aliveAfter(Env&lt;AttrContext&gt; env, JCTree that, TreeMaker make) {
 263         //we need to disable diagnostics temporarily; the problem is that if
 264         //&quot;that&quot; contains e.g. an unreachable statement, an error
 265         //message will be reported and will cause compilation to skip the flow analysis
 266         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 267         //related errors, which will allow for more errors to be detected
 268         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 269         try {
 270             SnippetAliveAnalyzer analyzer = new SnippetAliveAnalyzer();
 271 
 272             analyzer.analyzeTree(env, that, make);
 273             return analyzer.isAlive();
 274         } finally {
 275             log.popDiagnosticHandler(diagHandler);
 276         }
 277     }
 278 
 279     public boolean breaksOutOf(Env&lt;AttrContext&gt; env, JCTree loop, JCTree body, TreeMaker make) {
 280         //we need to disable diagnostics temporarily; the problem is that if
 281         //&quot;that&quot; contains e.g. an unreachable statement, an error
 282         //message will be reported and will cause compilation to skip the flow analysis
 283         //step - if we suppress diagnostics, we won&#39;t stop at Attr for flow-analysis
 284         //related errors, which will allow for more errors to be detected
 285         Log.DiagnosticHandler diagHandler = new Log.DiscardDiagnosticHandler(log);
 286         try {
 287             SnippetBreakAnalyzer analyzer = new SnippetBreakAnalyzer();
 288 
 289             analyzer.analyzeTree(env, body, make);
 290             return analyzer.breaksOut();
 291         } finally {
 292             log.popDiagnosticHandler(diagHandler);
 293         }
 294     }
 295 
 296     /**
 297      * Definite assignment scan mode
 298      */
 299     enum FlowKind {
 300         /**
 301          * This is the normal DA/DU analysis mode
 302          */
 303         NORMAL(&quot;var.might.already.be.assigned&quot;, false),
 304         /**
 305          * This is the speculative DA/DU analysis mode used to speculatively
 306          * derive assertions within loop bodies
 307          */
 308         SPECULATIVE_LOOP(&quot;var.might.be.assigned.in.loop&quot;, true);
 309 
 310         final String errKey;
 311         final boolean isFinal;
 312 
 313         FlowKind(String errKey, boolean isFinal) {
 314             this.errKey = errKey;
 315             this.isFinal = isFinal;
 316         }
 317 
 318         boolean isFinal() {
 319             return isFinal;
 320         }
 321     }
 322 
 323     protected Flow(Context context) {
 324         context.put(flowKey, this);
 325         names = Names.instance(context);
 326         log = Log.instance(context);
 327         syms = Symtab.instance(context);
 328         types = Types.instance(context);
 329         chk = Check.instance(context);
 330         lint = Lint.instance(context);
 331         rs = Resolve.instance(context);
 332         diags = JCDiagnostic.Factory.instance(context);
 333         Source source = Source.instance(context);
 334         allowEffectivelyFinalInInnerClasses = Feature.EFFECTIVELY_FINAL_IN_INNER_CLASSES.allowedInSource(source);
 335     }
 336 
 337     /**
 338      * Base visitor class for all visitors implementing dataflow analysis logic.
 339      * This class define the shared logic for handling jumps (break/continue statements).
 340      */
 341     static abstract class BaseAnalyzer extends TreeScanner {
 342 
 343         enum JumpKind {
 344             BREAK(JCTree.Tag.BREAK) {
 345                 @Override
 346                 JCTree getTarget(JCTree tree) {
 347                     return ((JCBreak)tree).target;
 348                 }
 349             },
 350             CONTINUE(JCTree.Tag.CONTINUE) {
 351                 @Override
 352                 JCTree getTarget(JCTree tree) {
 353                     return ((JCContinue)tree).target;
 354                 }
 355             },
 356             YIELD(JCTree.Tag.YIELD) {
 357                 @Override
 358                 JCTree getTarget(JCTree tree) {
 359                     return ((JCYield)tree).target;
 360                 }
 361             };
 362 
 363             final JCTree.Tag treeTag;
 364 
 365             private JumpKind(Tag treeTag) {
 366                 this.treeTag = treeTag;
 367             }
 368 
 369             abstract JCTree getTarget(JCTree tree);
 370         }
 371 
 372         /** The currently pending exits that go from current inner blocks
 373          *  to an enclosing block, in source order.
 374          */
 375         ListBuffer&lt;PendingExit&gt; pendingExits;
 376 
 377         /** A pending exit.  These are the statements return, break, and
 378          *  continue.  In addition, exception-throwing expressions or
 379          *  statements are put here when not known to be caught.  This
 380          *  will typically result in an error unless it is within a
 381          *  try-finally whose finally block cannot complete normally.
 382          */
 383         static class PendingExit {
 384             JCTree tree;
 385 
 386             PendingExit(JCTree tree) {
 387                 this.tree = tree;
 388             }
 389 
 390             void resolveJump() {
 391                 //do nothing
 392             }
 393         }
 394 
 395         abstract void markDead();
 396 
 397         /** Record an outward transfer of control. */
 398         void recordExit(PendingExit pe) {
 399             pendingExits.append(pe);
 400             markDead();
 401         }
 402 
 403         /** Resolve all jumps of this statement. */
 404         private Liveness resolveJump(JCTree tree,
 405                          ListBuffer&lt;PendingExit&gt; oldPendingExits,
 406                          JumpKind jk) {
 407             boolean resolved = false;
 408             List&lt;PendingExit&gt; exits = pendingExits.toList();
 409             pendingExits = oldPendingExits;
 410             for (; exits.nonEmpty(); exits = exits.tail) {
 411                 PendingExit exit = exits.head;
 412                 if (exit.tree.hasTag(jk.treeTag) &amp;&amp;
 413                         jk.getTarget(exit.tree) == tree) {
 414                     exit.resolveJump();
 415                     resolved = true;
 416                 } else {
 417                     pendingExits.append(exit);
 418                 }
 419             }
 420             return Liveness.from(resolved);
 421         }
 422 
 423         /** Resolve all continues of this statement. */
 424         Liveness resolveContinues(JCTree tree) {
 425             return resolveJump(tree, new ListBuffer&lt;PendingExit&gt;(), JumpKind.CONTINUE);
 426         }
 427 
 428         /** Resolve all breaks of this statement. */
 429         Liveness resolveBreaks(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 430             return resolveJump(tree, oldPendingExits, JumpKind.BREAK);
 431         }
 432 
 433         /** Resolve all yields of this statement. */
 434         Liveness resolveYields(JCTree tree, ListBuffer&lt;PendingExit&gt; oldPendingExits) {
 435             return resolveJump(tree, oldPendingExits, JumpKind.YIELD);
 436         }
 437 
 438         @Override
 439         public void scan(JCTree tree) {
 440             if (tree != null &amp;&amp; (
 441                     tree.type == null ||
 442                     tree.type != Type.stuckType)) {
 443                 super.scan(tree);
 444             }
 445         }
 446 
 447         public void visitPackageDef(JCPackageDecl tree) {
 448             // Do nothing for PackageDecl
 449         }
 450 
 451         protected void scanSyntheticBreak(TreeMaker make, JCTree swtch) {
 452             if (swtch.hasTag(SWITCH_EXPRESSION)) {
 453                 JCYield brk = make.at(Position.NOPOS).Yield(null);
 454                 brk.target = swtch;
 455                 scan(brk);
 456             } else {
 457                 JCBreak brk = make.at(Position.NOPOS).Break(null);
 458                 brk.target = swtch;
 459                 scan(brk);
 460             }
 461         }
 462     }
 463 
 464     /**
 465      * This pass implements the first step of the dataflow analysis, namely
 466      * the liveness analysis check. This checks that every statement is reachable.
 467      * The output of this analysis pass are used by other analyzers. This analyzer
 468      * sets the &#39;finallyCanCompleteNormally&#39; field in the JCTry class.
 469      */
 470     class AliveAnalyzer extends BaseAnalyzer {
 471 
 472         /** A flag that indicates whether the last statement could
 473          *  complete normally.
 474          */
 475         private Liveness alive;
 476 
 477         @Override
 478         void markDead() {
 479             alive = Liveness.DEAD;
 480         }
 481 
 482     /*************************************************************************
 483      * Visitor methods for statements and definitions
 484      *************************************************************************/
 485 
 486         /** Analyze a definition.
 487          */
 488         void scanDef(JCTree tree) {
 489             scanStat(tree);
 490             if (tree != null &amp;&amp; tree.hasTag(JCTree.Tag.BLOCK) &amp;&amp; alive == Liveness.DEAD) {
 491                 log.error(tree.pos(),
 492                           Errors.InitializerMustBeAbleToCompleteNormally);
 493             }
 494         }
 495 
 496         /** Analyze a statement. Check that statement is reachable.
 497          */
 498         void scanStat(JCTree tree) {
 499             if (alive == Liveness.DEAD &amp;&amp; tree != null) {
 500                 log.error(tree.pos(), Errors.UnreachableStmt);
 501                 if (!tree.hasTag(SKIP)) alive = Liveness.RECOVERY;
 502             }
 503             scan(tree);
 504         }
 505 
 506         /** Analyze list of statements.
 507          */
 508         void scanStats(List&lt;? extends JCStatement&gt; trees) {
 509             if (trees != null)
 510                 for (List&lt;? extends JCStatement&gt; l = trees; l.nonEmpty(); l = l.tail)
 511                     scanStat(l.head);
 512         }
 513 
 514         /* ------------ Visitor methods for various sorts of trees -------------*/
 515 
 516         public void visitClassDef(JCClassDecl tree) {
 517             if (tree.sym == null) return;
 518             Liveness alivePrev = alive;
 519             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 520             Lint lintPrev = lint;
 521 
 522             pendingExits = new ListBuffer&lt;&gt;();
 523             lint = lint.augment(tree.sym);
 524 
 525             try {
 526                 // process all the static initializers
 527                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 528                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 529                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
 530                         scanDef(l.head);
 531                     }
 532                 }
 533 
 534                 // process all the instance initializers
 535                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 536                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 537                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
 538                         scanDef(l.head);
 539                     }
 540                 }
 541 
 542                 // process all the methods
 543                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 544                     if (l.head.hasTag(METHODDEF)) {
 545                         scan(l.head);
 546                     }
 547                 }
 548             } finally {
 549                 pendingExits = pendingExitsPrev;
 550                 alive = alivePrev;
 551                 lint = lintPrev;
 552             }
 553         }
 554 
 555         public void visitMethodDef(JCMethodDecl tree) {
 556             if (tree.body == null) return;
 557             Lint lintPrev = lint;
 558 
 559             lint = lint.augment(tree.sym);
 560 
 561             Assert.check(pendingExits.isEmpty());
 562 
 563             try {
 564                 alive = Liveness.ALIVE;
 565                 scanStat(tree.body);
 566                 tree.completesNormally = alive != Liveness.DEAD;
 567 
 568                 if (alive == Liveness.ALIVE &amp;&amp; !tree.sym.type.getReturnType().hasTag(VOID))
 569                     log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);
 570 
 571                 List&lt;PendingExit&gt; exits = pendingExits.toList();
 572                 pendingExits = new ListBuffer&lt;&gt;();
 573                 while (exits.nonEmpty()) {
 574                     PendingExit exit = exits.head;
 575                     exits = exits.tail;
 576                     Assert.check(exit.tree.hasTag(RETURN) ||
 577                                     log.hasErrorOn(exit.tree.pos()));
 578                 }
 579             } finally {
 580                 lint = lintPrev;
 581             }
 582         }
 583 
 584         public void visitVarDef(JCVariableDecl tree) {
 585             if (tree.init != null) {
 586                 Lint lintPrev = lint;
 587                 lint = lint.augment(tree.sym);
 588                 try{
 589                     scan(tree.init);
 590                 } finally {
 591                     lint = lintPrev;
 592                 }
 593             }
 594         }
 595 
 596         public void visitBlock(JCBlock tree) {
 597             scanStats(tree.stats);
 598         }
 599 
 600         public void visitDoLoop(JCDoWhileLoop tree) {
 601             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 602             pendingExits = new ListBuffer&lt;&gt;();
 603             scanStat(tree.body);
 604             alive = alive.or(resolveContinues(tree));
 605             scan(tree.cond);
 606             alive = alive.and(!tree.cond.type.isTrue());
 607             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 608         }
 609 
 610         public void visitWhileLoop(JCWhileLoop tree) {
 611             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 612             pendingExits = new ListBuffer&lt;&gt;();
 613             scan(tree.cond);
 614             alive = Liveness.from(!tree.cond.type.isFalse());
 615             scanStat(tree.body);
 616             alive = alive.or(resolveContinues(tree));
 617             alive = resolveBreaks(tree, prevPendingExits).or(
 618                 !tree.cond.type.isTrue());
 619         }
 620 
 621         public void visitForLoop(JCForLoop tree) {
 622             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 623             scanStats(tree.init);
 624             pendingExits = new ListBuffer&lt;&gt;();
 625             if (tree.cond != null) {
 626                 scan(tree.cond);
 627                 alive = Liveness.from(!tree.cond.type.isFalse());
 628             } else {
 629                 alive = Liveness.ALIVE;
 630             }
 631             scanStat(tree.body);
 632             alive = alive.or(resolveContinues(tree));
 633             scan(tree.step);
 634             alive = resolveBreaks(tree, prevPendingExits).or(
 635                 tree.cond != null &amp;&amp; !tree.cond.type.isTrue());
 636         }
 637 
 638         public void visitForeachLoop(JCEnhancedForLoop tree) {
 639             visitVarDef(tree.var);
 640             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 641             scan(tree.expr);
 642             pendingExits = new ListBuffer&lt;&gt;();
 643             scanStat(tree.body);
 644             alive = alive.or(resolveContinues(tree));
 645             resolveBreaks(tree, prevPendingExits);
 646             alive = Liveness.ALIVE;
 647         }
 648 
 649         public void visitLabelled(JCLabeledStatement tree) {
 650             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 651             pendingExits = new ListBuffer&lt;&gt;();
 652             scanStat(tree.body);
 653             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 654         }
 655 
 656         public void visitSwitch(JCSwitch tree) {
 657             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 658             pendingExits = new ListBuffer&lt;&gt;();
 659             scan(tree.selector);
 660             boolean hasDefault = false;
 661             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 662                 alive = Liveness.ALIVE;
 663                 JCCase c = l.head;
 664                 if (c.pats.isEmpty())
 665                     hasDefault = true;
 666                 else {
 667                     for (JCExpression pat : c.pats) {
 668                         scan(pat);
 669                     }
 670                 }
 671                 scanStats(c.stats);
 672                 c.completesNormally = alive != Liveness.DEAD;
 673                 if (alive != Liveness.DEAD &amp;&amp; c.caseKind == JCCase.RULE) {
 674                     scanSyntheticBreak(make, tree);
 675                     alive = Liveness.DEAD;
 676                 }
 677                 // Warn about fall-through if lint switch fallthrough enabled.
 678                 if (alive == Liveness.ALIVE &amp;&amp;
 679                     lint.isEnabled(Lint.LintCategory.FALLTHROUGH) &amp;&amp;
 680                     c.stats.nonEmpty() &amp;&amp; l.tail.nonEmpty())
 681                     log.warning(Lint.LintCategory.FALLTHROUGH,
 682                                 l.tail.head.pos(),
 683                                 Warnings.PossibleFallThroughIntoCase);
 684             }
 685             if (!hasDefault) {
 686                 alive = Liveness.ALIVE;
 687             }
 688             alive = alive.or(resolveBreaks(tree, prevPendingExits));
 689         }
 690 
 691         @Override
 692         public void visitSwitchExpression(JCSwitchExpression tree) {
 693             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 694             pendingExits = new ListBuffer&lt;&gt;();
 695             scan(tree.selector);
 696             Set&lt;Object&gt; constants = null;
 697             if ((tree.selector.type.tsym.flags() &amp; ENUM) != 0) {
 698                 constants = new HashSet&lt;&gt;();
 699                 for (Symbol s : tree.selector.type.tsym.members().getSymbols(s -&gt; (s.flags() &amp; ENUM) != 0)) {
 700                     constants.add(s.name);
 701                 }
 702             }
 703             boolean hasDefault = false;
 704             Liveness prevAlive = alive;
 705             for (List&lt;JCCase&gt; l = tree.cases; l.nonEmpty(); l = l.tail) {
 706                 alive = Liveness.ALIVE;
 707                 JCCase c = l.head;
 708                 if (c.pats.isEmpty())
 709                     hasDefault = true;
 710                 else {
 711                     for (JCExpression pat : c.pats) {
 712                         scan(pat);
 713                         if (constants != null) {
 714                             if (pat.hasTag(IDENT))
 715                                 constants.remove(((JCIdent) pat).name);
 716                             if (pat.type != null)
 717                                 constants.remove(pat.type.constValue());
 718                         }
 719                     }
 720                 }
 721                 scanStats(c.stats);
 722                 if (alive == Liveness.ALIVE) {
 723                     if (c.caseKind == JCCase.RULE) {
 724                         log.error(TreeInfo.diagEndPos(c.body),
 725                                   Errors.RuleCompletesNormally);
 726                     } else if (l.tail.isEmpty()) {
 727                         log.error(TreeInfo.diagEndPos(tree),
 728                                   Errors.SwitchExpressionCompletesNormally);
 729                     }
 730                 }
 731                 c.completesNormally = alive != Liveness.DEAD;
 732             }
 733             if ((constants == null || !constants.isEmpty()) &amp;&amp; !hasDefault) {
 734                 log.error(tree, Errors.NotExhaustive);
 735             }
 736             alive = prevAlive;
 737             alive = alive.or(resolveYields(tree, prevPendingExits));
 738         }
 739 
 740         public void visitTry(JCTry tree) {
 741             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
 742             pendingExits = new ListBuffer&lt;&gt;();
 743             for (JCTree resource : tree.resources) {
 744                 if (resource instanceof JCVariableDecl) {
 745                     JCVariableDecl vdecl = (JCVariableDecl) resource;
 746                     visitVarDef(vdecl);
 747                 } else if (resource instanceof JCExpression) {
 748                     scan((JCExpression) resource);
 749                 } else {
 750                     throw new AssertionError(tree);  // parser error
 751                 }
 752             }
 753 
 754             scanStat(tree.body);
 755             Liveness aliveEnd = alive;
 756 
 757             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
 758                 alive = Liveness.ALIVE;
 759                 JCVariableDecl param = l.head.param;
 760                 scan(param);
 761                 scanStat(l.head.body);
 762                 aliveEnd = aliveEnd.or(alive);
 763             }
 764             if (tree.finalizer != null) {
 765                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 766                 pendingExits = prevPendingExits;
 767                 alive = Liveness.ALIVE;
 768                 scanStat(tree.finalizer);
 769                 tree.finallyCanCompleteNormally = alive != Liveness.DEAD;
 770                 if (alive == Liveness.DEAD) {
 771                     if (lint.isEnabled(Lint.LintCategory.FINALLY)) {
 772                         log.warning(Lint.LintCategory.FINALLY,
 773                                 TreeInfo.diagEndPos(tree.finalizer),
 774                                 Warnings.FinallyCannotComplete);
 775                     }
 776                 } else {
 777                     while (exits.nonEmpty()) {
 778                         pendingExits.append(exits.next());
 779                     }
 780                     alive = aliveEnd;
 781                 }
 782             } else {
 783                 alive = aliveEnd;
 784                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
 785                 pendingExits = prevPendingExits;
 786                 while (exits.nonEmpty()) pendingExits.append(exits.next());
 787             }
 788         }
 789 
 790         @Override
 791         public void visitIf(JCIf tree) {
 792             scan(tree.cond);
 793             scanStat(tree.thenpart);
 794             if (tree.elsepart != null) {
 795                 Liveness aliveAfterThen = alive;
 796                 alive = Liveness.ALIVE;
 797                 scanStat(tree.elsepart);
 798                 alive = alive.or(aliveAfterThen);
 799             } else {
 800                 alive = Liveness.ALIVE;
 801             }
 802         }
 803 
 804         public void visitBreak(JCBreak tree) {
 805             recordExit(new PendingExit(tree));
 806         }
 807 
 808         @Override
 809         public void visitYield(JCYield tree) {
 810             scan(tree.value);
 811             recordExit(new PendingExit(tree));
 812         }
 813 
 814         public void visitContinue(JCContinue tree) {
 815             recordExit(new PendingExit(tree));
 816         }
 817 
 818         public void visitReturn(JCReturn tree) {
 819             scan(tree.expr);
 820             recordExit(new PendingExit(tree));
 821         }
 822 
 823         public void visitThrow(JCThrow tree) {
 824             scan(tree.expr);
 825             markDead();
 826         }
 827 
 828         public void visitApply(JCMethodInvocation tree) {
 829             scan(tree.meth);
 830             scan(tree.args);
 831         }
 832 
 833         public void visitNewClass(JCNewClass tree) {
 834             scan(tree.encl);
 835             scan(tree.args);
 836             if (tree.def != null) {
 837                 scan(tree.def);
 838             }
 839         }
 840 
 841         @Override
 842         public void visitLambda(JCLambda tree) {
 843             if (tree.type != null &amp;&amp;
 844                     tree.type.isErroneous()) {
 845                 return;
 846             }
 847 
 848             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
 849             Liveness prevAlive = alive;
 850             try {
 851                 pendingExits = new ListBuffer&lt;&gt;();
 852                 alive = Liveness.ALIVE;
 853                 scanStat(tree.body);
 854                 tree.canCompleteNormally = alive != Liveness.DEAD;
 855             }
 856             finally {
 857                 pendingExits = prevPending;
 858                 alive = prevAlive;
 859             }
 860         }
 861 
 862         public void visitModuleDef(JCModuleDecl tree) {
 863             // Do nothing for modules
 864         }
 865 
 866     /**************************************************************************
 867      * main method
 868      *************************************************************************/
 869 
 870         /** Perform definite assignment/unassignment analysis on a tree.
 871          */
 872         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
 873             analyzeTree(env, env.tree, make);
 874         }
 875         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
 876             try {
 877                 attrEnv = env;
 878                 Flow.this.make = make;
 879                 pendingExits = new ListBuffer&lt;&gt;();
 880                 alive = Liveness.ALIVE;
 881                 scan(tree);
 882             } finally {
 883                 pendingExits = null;
 884                 Flow.this.make = null;
 885             }
 886         }
 887     }
 888 
 889     /**
 890      * This pass implements the second step of the dataflow analysis, namely
 891      * the exception analysis. This is to ensure that every checked exception that is
 892      * thrown is declared or caught. The analyzer uses some info that has been set by
 893      * the liveliness analyzer.
 894      */
 895     class FlowAnalyzer extends BaseAnalyzer {
 896 
 897         /** A flag that indicates whether the last statement could
 898          *  complete normally.
 899          */
 900         HashMap&lt;Symbol, List&lt;Type&gt;&gt; preciseRethrowTypes;
 901 
 902         /** The current class being defined.
 903          */
 904         JCClassDecl classDef;
 905 
 906         /** The list of possibly thrown declarable exceptions.
 907          */
 908         List&lt;Type&gt; thrown;
 909 
 910         /** The list of exceptions that are either caught or declared to be
 911          *  thrown.
 912          */
 913         List&lt;Type&gt; caught;
 914 
 915         class ThrownPendingExit extends BaseAnalyzer.PendingExit {
 916 
 917             Type thrown;
 918 
 919             ThrownPendingExit(JCTree tree, Type thrown) {
 920                 super(tree);
 921                 this.thrown = thrown;
 922             }
 923         }
 924 
 925         @Override
 926         void markDead() {
 927             //do nothing
 928         }
 929 
 930         /*-------------------- Exceptions ----------------------*/
 931 
 932         /** Complain that pending exceptions are not caught.
 933          */
 934         void errorUncaught() {
 935             for (PendingExit exit = pendingExits.next();
 936                  exit != null;
 937                  exit = pendingExits.next()) {
 938                 Assert.check(exit instanceof ThrownPendingExit);
 939                 ThrownPendingExit thrownExit = (ThrownPendingExit) exit;
 940                 if (classDef != null &amp;&amp;
 941                     classDef.pos == exit.tree.pos) {
 942                     log.error(exit.tree.pos(),
 943                               Errors.UnreportedExceptionDefaultConstructor(thrownExit.thrown));
 944                 } else if (exit.tree.hasTag(VARDEF) &amp;&amp;
 945                         ((JCVariableDecl)exit.tree).sym.isResourceVariable()) {
 946                     log.error(exit.tree.pos(),
 947                               Errors.UnreportedExceptionImplicitClose(thrownExit.thrown,
 948                                                                       ((JCVariableDecl)exit.tree).sym.name));
 949                 } else {
 950                     log.error(exit.tree.pos(),
 951                               Errors.UnreportedExceptionNeedToCatchOrThrow(thrownExit.thrown));
 952                 }
 953             }
 954         }
 955 
 956         /** Record that exception is potentially thrown and check that it
 957          *  is caught.
 958          */
 959         void markThrown(JCTree tree, Type exc) {
 960             if (!chk.isUnchecked(tree.pos(), exc)) {
 961                 if (!chk.isHandled(exc, caught)) {
 962                     pendingExits.append(new ThrownPendingExit(tree, exc));
 963                 }
 964                 thrown = chk.incl(exc, thrown);
 965             }
 966         }
 967 
 968     /*************************************************************************
 969      * Visitor methods for statements and definitions
 970      *************************************************************************/
 971 
 972         /* ------------ Visitor methods for various sorts of trees -------------*/
 973 
 974         public void visitClassDef(JCClassDecl tree) {
 975             if (tree.sym == null) return;
 976 
 977             JCClassDecl classDefPrev = classDef;
 978             List&lt;Type&gt; thrownPrev = thrown;
 979             List&lt;Type&gt; caughtPrev = caught;
 980             ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
 981             Lint lintPrev = lint;
 982             boolean anonymousClass = tree.name == names.empty;
 983             pendingExits = new ListBuffer&lt;&gt;();
 984             if (!anonymousClass) {
 985                 caught = List.nil();
 986             }
 987             classDef = tree;
 988             thrown = List.nil();
 989             lint = lint.augment(tree.sym);
 990 
 991             try {
 992                 // process all the static initializers
 993                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
 994                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
 995                         (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
 996                         scan(l.head);
 997                         errorUncaught();
 998                     }
 999                 }
1000 
1001                 // add intersection of all thrown clauses of initial constructors
1002                 // to set of caught exceptions, unless class is anonymous.
1003                 if (!anonymousClass) {
1004                     boolean firstConstructor = true;
1005                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1006                         if (TreeInfo.isInitialConstructor(l.head)) {
1007                             List&lt;Type&gt; mthrown =
1008                                 ((JCMethodDecl) l.head).sym.type.getThrownTypes();
1009                             if (firstConstructor) {
1010                                 caught = mthrown;
1011                                 firstConstructor = false;
1012                             } else {
1013                                 caught = chk.intersect(mthrown, caught);
1014                             }
1015                         }
1016                     }
1017                 }
1018 
1019                 // process all the instance initializers
1020                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1021                     if (!l.head.hasTag(METHODDEF) &amp;&amp;
1022                         (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
1023                         scan(l.head);
1024                         errorUncaught();
1025                     }
1026                 }
1027 
1028                 // in an anonymous class, add the set of thrown exceptions to
1029                 // the throws clause of the synthetic constructor and propagate
1030                 // outwards.
1031                 // Changing the throws clause on the fly is okay here because
1032                 // the anonymous constructor can&#39;t be invoked anywhere else,
1033                 // and its type hasn&#39;t been cached.
1034                 if (anonymousClass) {
1035                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1036                         if (TreeInfo.isConstructor(l.head)) {
1037                             JCMethodDecl mdef = (JCMethodDecl)l.head;
1038                             scan(mdef);
1039                             mdef.thrown = make.Types(thrown);
1040                             mdef.sym.type = types.createMethodTypeWithThrown(mdef.sym.type, thrown);
1041                         }
1042                     }
1043                     thrownPrev = chk.union(thrown, thrownPrev);
1044                 }
1045 
1046                 // process all the methods
1047                 for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
1048                     if (anonymousClass &amp;&amp; TreeInfo.isConstructor(l.head))
1049                         continue; // there can never be an uncaught exception.
1050                     if (l.head.hasTag(METHODDEF)) {
1051                         scan(l.head);
1052                         errorUncaught();
1053                     }
1054                 }
1055 
1056                 thrown = thrownPrev;
1057             } finally {
1058                 pendingExits = pendingExitsPrev;
1059                 caught = caughtPrev;
1060                 classDef = classDefPrev;
1061                 lint = lintPrev;
1062             }
1063         }
1064 
1065         public void visitMethodDef(JCMethodDecl tree) {
1066             if (tree.body == null) return;
1067 
1068             List&lt;Type&gt; caughtPrev = caught;
1069             List&lt;Type&gt; mthrown = tree.sym.type.getThrownTypes();
1070             Lint lintPrev = lint;
1071 
1072             lint = lint.augment(tree.sym);
1073 
1074             Assert.check(pendingExits.isEmpty());
1075 
1076             try {
1077                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1078                     JCVariableDecl def = l.head;
1079                     scan(def);
1080                 }
1081                 if (TreeInfo.isInitialConstructor(tree))
1082                     caught = chk.union(caught, mthrown);
1083                 else if ((tree.sym.flags() &amp; (BLOCK | STATIC)) != BLOCK)
1084                     caught = mthrown;
1085                 // else we are in an instance initializer block;
1086                 // leave caught unchanged.
1087 
1088                 scan(tree.body);
1089 
1090                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1091                 pendingExits = new ListBuffer&lt;&gt;();
1092                 while (exits.nonEmpty()) {
1093                     PendingExit exit = exits.head;
1094                     exits = exits.tail;
1095                     if (!(exit instanceof ThrownPendingExit)) {
1096                         Assert.check(exit.tree.hasTag(RETURN) ||
1097                                          log.hasErrorOn(exit.tree.pos()));
1098                     } else {
1099                         // uncaught throws will be reported later
1100                         pendingExits.append(exit);
1101                     }
1102                 }
1103             } finally {
1104                 caught = caughtPrev;
1105                 lint = lintPrev;
1106             }
1107         }
1108 
1109         public void visitVarDef(JCVariableDecl tree) {
1110             if (tree.init != null) {
1111                 Lint lintPrev = lint;
1112                 lint = lint.augment(tree.sym);
1113                 try{
1114                     scan(tree.init);
1115                 } finally {
1116                     lint = lintPrev;
1117                 }
1118             }
1119         }
1120 
1121         public void visitBlock(JCBlock tree) {
1122             scan(tree.stats);
1123         }
1124 
1125         public void visitDoLoop(JCDoWhileLoop tree) {
1126             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1127             pendingExits = new ListBuffer&lt;&gt;();
1128             scan(tree.body);
1129             resolveContinues(tree);
1130             scan(tree.cond);
1131             resolveBreaks(tree, prevPendingExits);
1132         }
1133 
1134         public void visitWhileLoop(JCWhileLoop tree) {
1135             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1136             pendingExits = new ListBuffer&lt;&gt;();
1137             scan(tree.cond);
1138             scan(tree.body);
1139             resolveContinues(tree);
1140             resolveBreaks(tree, prevPendingExits);
1141         }
1142 
1143         public void visitForLoop(JCForLoop tree) {
1144             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1145             scan(tree.init);
1146             pendingExits = new ListBuffer&lt;&gt;();
1147             if (tree.cond != null) {
1148                 scan(tree.cond);
1149             }
1150             scan(tree.body);
1151             resolveContinues(tree);
1152             scan(tree.step);
1153             resolveBreaks(tree, prevPendingExits);
1154         }
1155 
1156         public void visitForeachLoop(JCEnhancedForLoop tree) {
1157             visitVarDef(tree.var);
1158             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1159             scan(tree.expr);
1160             pendingExits = new ListBuffer&lt;&gt;();
1161             scan(tree.body);
1162             resolveContinues(tree);
1163             resolveBreaks(tree, prevPendingExits);
1164         }
1165 
1166         public void visitLabelled(JCLabeledStatement tree) {
1167             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1168             pendingExits = new ListBuffer&lt;&gt;();
1169             scan(tree.body);
1170             resolveBreaks(tree, prevPendingExits);
1171         }
1172 
1173         public void visitSwitch(JCSwitch tree) {
1174             handleSwitch(tree, tree.selector, tree.cases);
1175         }
1176 
1177         @Override
1178         public void visitSwitchExpression(JCSwitchExpression tree) {
1179             handleSwitch(tree, tree.selector, tree.cases);
1180         }
1181 
1182         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
1183             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1184             pendingExits = new ListBuffer&lt;&gt;();
1185             scan(selector);
1186             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1187                 JCCase c = l.head;
1188                 scan(c.pats);
1189                 scan(c.stats);
1190             }
1191             if (tree.hasTag(SWITCH_EXPRESSION)) {
1192                 resolveYields(tree, prevPendingExits);
1193             } else {
1194                 resolveBreaks(tree, prevPendingExits);
1195             }
1196         }
1197 
1198         public void visitTry(JCTry tree) {
1199             List&lt;Type&gt; caughtPrev = caught;
1200             List&lt;Type&gt; thrownPrev = thrown;
1201             thrown = List.nil();
1202             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1203                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1204                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1205                         List.of(l.head.param.vartype);
1206                 for (JCExpression ct : subClauses) {
1207                     caught = chk.incl(ct.type, caught);
1208                 }
1209             }
1210 
1211             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
1212             pendingExits = new ListBuffer&lt;&gt;();
1213             for (JCTree resource : tree.resources) {
1214                 if (resource instanceof JCVariableDecl) {
1215                     JCVariableDecl vdecl = (JCVariableDecl) resource;
1216                     visitVarDef(vdecl);
1217                 } else if (resource instanceof JCExpression) {
1218                     scan((JCExpression) resource);
1219                 } else {
1220                     throw new AssertionError(tree);  // parser error
1221                 }
1222             }
1223             for (JCTree resource : tree.resources) {
1224                 List&lt;Type&gt; closeableSupertypes = resource.type.isCompound() ?
1225                     types.interfaces(resource.type).prepend(types.supertype(resource.type)) :
1226                     List.of(resource.type);
1227                 for (Type sup : closeableSupertypes) {
1228                     if (types.asSuper(sup, syms.autoCloseableType.tsym, true) != null) {
1229                         Symbol closeMethod = rs.resolveQualifiedMethod(tree,
1230                                 attrEnv,
1231                                 types.skipTypeVars(sup, false),
1232                                 names.close,
1233                                 List.nil(),
1234                                 List.nil());
1235                         Type mt = types.memberType(resource.type, closeMethod);
1236                         if (closeMethod.kind == MTH) {
1237                             for (Type t : mt.getThrownTypes()) {
1238                                 markThrown(resource, t);
1239                             }
1240                         }
1241                     }
1242                 }
1243             }
1244             scan(tree.body);
1245             List&lt;Type&gt; thrownInTry = chk.union(thrown, List.of(syms.runtimeExceptionType, syms.errorType));
1246             thrown = thrownPrev;
1247             caught = caughtPrev;
1248 
1249             List&lt;Type&gt; caughtInTry = List.nil();
1250             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1251                 JCVariableDecl param = l.head.param;
1252                 List&lt;JCExpression&gt; subClauses = TreeInfo.isMultiCatch(l.head) ?
1253                         ((JCTypeUnion)l.head.param.vartype).alternatives :
1254                         List.of(l.head.param.vartype);
1255                 List&lt;Type&gt; ctypes = List.nil();
1256                 List&lt;Type&gt; rethrownTypes = chk.diff(thrownInTry, caughtInTry);
1257                 for (JCExpression ct : subClauses) {
1258                     Type exc = ct.type;
1259                     if (exc != syms.unknownType) {
1260                         ctypes = ctypes.append(exc);
1261                         if (types.isSameType(exc, syms.objectType))
1262                             continue;
1263                         checkCaughtType(l.head.pos(), exc, thrownInTry, caughtInTry);
1264                         caughtInTry = chk.incl(exc, caughtInTry);
1265                     }
1266                 }
1267                 scan(param);
1268                 preciseRethrowTypes.put(param.sym, chk.intersect(ctypes, rethrownTypes));
1269                 scan(l.head.body);
1270                 preciseRethrowTypes.remove(param.sym);
1271             }
1272             if (tree.finalizer != null) {
1273                 List&lt;Type&gt; savedThrown = thrown;
1274                 thrown = List.nil();
1275                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1276                 pendingExits = prevPendingExits;
1277                 scan(tree.finalizer);
1278                 if (!tree.finallyCanCompleteNormally) {
1279                     // discard exits and exceptions from try and finally
1280                     thrown = chk.union(thrown, thrownPrev);
1281                 } else {
1282                     thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1283                     thrown = chk.union(thrown, savedThrown);
1284                     // FIX: this doesn&#39;t preserve source order of exits in catch
1285                     // versus finally!
1286                     while (exits.nonEmpty()) {
1287                         pendingExits.append(exits.next());
1288                     }
1289                 }
1290             } else {
1291                 thrown = chk.union(thrown, chk.diff(thrownInTry, caughtInTry));
1292                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
1293                 pendingExits = prevPendingExits;
1294                 while (exits.nonEmpty()) pendingExits.append(exits.next());
1295             }
1296         }
1297 
1298         @Override
1299         public void visitIf(JCIf tree) {
1300             scan(tree.cond);
1301             scan(tree.thenpart);
1302             if (tree.elsepart != null) {
1303                 scan(tree.elsepart);
1304             }
1305         }
1306 
1307         void checkCaughtType(DiagnosticPosition pos, Type exc, List&lt;Type&gt; thrownInTry, List&lt;Type&gt; caughtInTry) {
1308             if (chk.subset(exc, caughtInTry)) {
1309                 log.error(pos, Errors.ExceptAlreadyCaught(exc));
1310             } else if (!chk.isUnchecked(pos, exc) &amp;&amp;
1311                     !isExceptionOrThrowable(exc) &amp;&amp;
1312                     !chk.intersects(exc, thrownInTry)) {
1313                 log.error(pos, Errors.ExceptNeverThrownInTry(exc));
1314             } else {
1315                 List&lt;Type&gt; catchableThrownTypes = chk.intersect(List.of(exc), thrownInTry);
1316                 // &#39;catchableThrownTypes&#39; cannot possibly be empty - if &#39;exc&#39; was an
1317                 // unchecked exception, the result list would not be empty, as the augmented
1318                 // thrown set includes { RuntimeException, Error }; if &#39;exc&#39; was a checked
1319                 // exception, that would have been covered in the branch above
1320                 if (chk.diff(catchableThrownTypes, caughtInTry).isEmpty() &amp;&amp;
1321                         !isExceptionOrThrowable(exc)) {
1322                     Warning key = catchableThrownTypes.length() == 1 ?
1323                             Warnings.UnreachableCatch(catchableThrownTypes) :
1324                             Warnings.UnreachableCatch1(catchableThrownTypes);
1325                     log.warning(pos, key);
1326                 }
1327             }
1328         }
1329         //where
1330             private boolean isExceptionOrThrowable(Type exc) {
1331                 return exc.tsym == syms.throwableType.tsym ||
1332                     exc.tsym == syms.exceptionType.tsym;
1333             }
1334 
1335         public void visitBreak(JCBreak tree) {
1336             recordExit(new PendingExit(tree));
1337         }
1338 
1339         public void visitYield(JCYield tree) {
1340             scan(tree.value);
1341             recordExit(new PendingExit(tree));
1342         }
1343 
1344         public void visitContinue(JCContinue tree) {
1345             recordExit(new PendingExit(tree));
1346         }
1347 
1348         public void visitReturn(JCReturn tree) {
1349             scan(tree.expr);
1350             recordExit(new PendingExit(tree));
1351         }
1352 
1353         public void visitThrow(JCThrow tree) {
1354             scan(tree.expr);
1355             Symbol sym = TreeInfo.symbol(tree.expr);
1356             if (sym != null &amp;&amp;
1357                 sym.kind == VAR &amp;&amp;
1358                 (sym.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) != 0 &amp;&amp;
1359                 preciseRethrowTypes.get(sym) != null) {
1360                 for (Type t : preciseRethrowTypes.get(sym)) {
1361                     markThrown(tree, t);
1362                 }
1363             }
1364             else {
1365                 markThrown(tree, tree.expr.type);
1366             }
1367             markDead();
1368         }
1369 
1370         public void visitApply(JCMethodInvocation tree) {
1371             scan(tree.meth);
1372             scan(tree.args);
1373             for (List&lt;Type&gt; l = tree.meth.type.getThrownTypes(); l.nonEmpty(); l = l.tail)
1374                 markThrown(tree, l.head);
1375         }
1376 
1377         public void visitNewClass(JCNewClass tree) {
1378             scan(tree.encl);
1379             scan(tree.args);
1380            // scan(tree.def);
1381             for (List&lt;Type&gt; l = tree.constructorType.getThrownTypes();
1382                  l.nonEmpty();
1383                  l = l.tail) {
1384                 markThrown(tree, l.head);
1385             }
1386             List&lt;Type&gt; caughtPrev = caught;
1387             try {
1388                 // If the new class expression defines an anonymous class,
1389                 // analysis of the anonymous constructor may encounter thrown
1390                 // types which are unsubstituted type variables.
1391                 // However, since the constructor&#39;s actual thrown types have
1392                 // already been marked as thrown, it is safe to simply include
1393                 // each of the constructor&#39;s formal thrown types in the set of
1394                 // &#39;caught/declared to be thrown&#39; types, for the duration of
1395                 // the class def analysis.
1396                 if (tree.def != null)
1397                     for (List&lt;Type&gt; l = tree.constructor.type.getThrownTypes();
1398                          l.nonEmpty();
1399                          l = l.tail) {
1400                         caught = chk.incl(l.head, caught);
1401                     }
1402                 scan(tree.def);
1403             }
1404             finally {
1405                 caught = caughtPrev;
1406             }
1407         }
1408 
1409         @Override
1410         public void visitLambda(JCLambda tree) {
1411             if (tree.type != null &amp;&amp;
1412                     tree.type.isErroneous()) {
1413                 return;
1414             }
1415             List&lt;Type&gt; prevCaught = caught;
1416             List&lt;Type&gt; prevThrown = thrown;
1417             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1418             try {
1419                 pendingExits = new ListBuffer&lt;&gt;();
1420                 caught = tree.getDescriptorType(types).getThrownTypes();
1421                 thrown = List.nil();
1422                 scan(tree.body);
1423                 List&lt;PendingExit&gt; exits = pendingExits.toList();
1424                 pendingExits = new ListBuffer&lt;&gt;();
1425                 while (exits.nonEmpty()) {
1426                     PendingExit exit = exits.head;
1427                     exits = exits.tail;
1428                     if (!(exit instanceof ThrownPendingExit)) {
1429                         Assert.check(exit.tree.hasTag(RETURN) ||
1430                                         log.hasErrorOn(exit.tree.pos()));
1431                     } else {
1432                         // uncaught throws will be reported later
1433                         pendingExits.append(exit);
1434                     }
1435                 }
1436 
1437                 errorUncaught();
1438             } finally {
1439                 pendingExits = prevPending;
1440                 caught = prevCaught;
1441                 thrown = prevThrown;
1442             }
1443         }
1444 
1445         public void visitModuleDef(JCModuleDecl tree) {
1446             // Do nothing for modules
1447         }
1448 
1449     /**************************************************************************
1450      * main method
1451      *************************************************************************/
1452 
1453         /** Perform definite assignment/unassignment analysis on a tree.
1454          */
1455         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
1456             analyzeTree(env, env.tree, make);
1457         }
1458         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
1459             try {
1460                 attrEnv = env;
1461                 Flow.this.make = make;
1462                 pendingExits = new ListBuffer&lt;&gt;();
1463                 preciseRethrowTypes = new HashMap&lt;&gt;();
1464                 this.thrown = this.caught = null;
1465                 this.classDef = null;
1466                 scan(tree);
1467             } finally {
1468                 pendingExits = null;
1469                 Flow.this.make = null;
1470                 this.thrown = this.caught = null;
1471                 this.classDef = null;
1472             }
1473         }
1474     }
1475 
1476     /**
1477      * Specialized pass that performs reachability analysis on a lambda
1478      */
1479     class LambdaAliveAnalyzer extends AliveAnalyzer {
1480 
1481         boolean inLambda;
1482 
1483         @Override
1484         public void visitReturn(JCReturn tree) {
1485             //ignore lambda return expression (which might not even be attributed)
1486             recordExit(new PendingExit(tree));
1487         }
1488 
1489         @Override
1490         public void visitLambda(JCLambda tree) {
1491             if (inLambda || tree.getBodyKind() == BodyKind.EXPRESSION) {
1492                 return;
1493             }
1494             inLambda = true;
1495             try {
1496                 super.visitLambda(tree);
1497             } finally {
1498                 inLambda = false;
1499             }
1500         }
1501 
1502         @Override
1503         public void visitClassDef(JCClassDecl tree) {
1504             //skip
1505         }
1506     }
1507 
1508     /**
1509      * Determine if alive after the given tree.
1510      */
1511     class SnippetAliveAnalyzer extends AliveAnalyzer {
1512         @Override
1513         public void visitClassDef(JCClassDecl tree) {
1514             //skip
1515         }
1516         public boolean isAlive() {
1517             return super.alive != Liveness.DEAD;
1518         }
1519     }
1520 
1521     class SnippetBreakAnalyzer extends AliveAnalyzer {
1522         private final Set&lt;JCTree&gt; seenTrees = new HashSet&lt;&gt;();
1523         private boolean breaksOut;
1524 
1525         public SnippetBreakAnalyzer() {
1526         }
1527 
1528         @Override
1529         public void visitLabelled(JCTree.JCLabeledStatement tree) {
1530             seenTrees.add(tree);
1531             super.visitLabelled(tree);
1532         }
1533 
1534         @Override
1535         public void visitWhileLoop(JCTree.JCWhileLoop tree) {
1536             seenTrees.add(tree);
1537             super.visitWhileLoop(tree);
1538         }
1539 
1540         @Override
1541         public void visitForLoop(JCTree.JCForLoop tree) {
1542             seenTrees.add(tree);
1543             super.visitForLoop(tree);
1544         }
1545 
1546         @Override
1547         public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {
1548             seenTrees.add(tree);
1549             super.visitForeachLoop(tree);
1550         }
1551 
1552         @Override
1553         public void visitDoLoop(JCTree.JCDoWhileLoop tree) {
1554             seenTrees.add(tree);
1555             super.visitDoLoop(tree);
1556         }
1557 
1558         @Override
1559         public void visitBreak(JCBreak tree) {
1560             breaksOut |= (super.alive == Liveness.ALIVE &amp;&amp;
1561                           !seenTrees.contains(tree.target));
1562             super.visitBreak(tree);
1563         }
1564 
1565         public boolean breaksOut() {
1566             return breaksOut;
1567         }
1568     }
1569 
1570     /**
1571      * Specialized pass that performs DA/DU on a lambda
1572      */
1573     class LambdaAssignAnalyzer extends AssignAnalyzer {
1574         WriteableScope enclosedSymbols;
1575         boolean inLambda;
1576 
1577         LambdaAssignAnalyzer(Env&lt;AttrContext&gt; env) {
1578             enclosedSymbols = WriteableScope.create(env.enclClass.sym);
1579         }
1580 
1581         @Override
1582         public void visitLambda(JCLambda tree) {
1583             if (inLambda) {
1584                 return;
1585             }
1586             inLambda = true;
1587             try {
1588                 super.visitLambda(tree);
1589             } finally {
1590                 inLambda = false;
1591             }
1592         }
1593 
1594         @Override
1595         public void visitVarDef(JCVariableDecl tree) {
1596             enclosedSymbols.enter(tree.sym);
1597             super.visitVarDef(tree);
1598         }
1599         @Override
1600         protected boolean trackable(VarSymbol sym) {
1601             return enclosedSymbols.includes(sym) &amp;&amp;
1602                    sym.owner.kind == MTH;
1603         }
1604 
1605         @Override
1606         public void visitClassDef(JCClassDecl tree) {
1607             //skip
1608         }
1609     }
1610 
1611     /**
1612      * Specialized pass that performs inference of thrown types for lambdas.
1613      */
1614     class LambdaFlowAnalyzer extends FlowAnalyzer {
1615         List&lt;Type&gt; inferredThrownTypes;
1616         boolean inLambda;
1617         @Override
1618         public void visitLambda(JCLambda tree) {
1619             if ((tree.type != null &amp;&amp;
1620                     tree.type.isErroneous()) || inLambda) {
1621                 return;
1622             }
1623             List&lt;Type&gt; prevCaught = caught;
1624             List&lt;Type&gt; prevThrown = thrown;
1625             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
1626             inLambda = true;
1627             try {
1628                 pendingExits = new ListBuffer&lt;&gt;();
1629                 caught = List.of(syms.throwableType);
1630                 thrown = List.nil();
1631                 scan(tree.body);
1632                 inferredThrownTypes = thrown;
1633             } finally {
1634                 pendingExits = prevPending;
1635                 caught = prevCaught;
1636                 thrown = prevThrown;
1637                 inLambda = false;
1638             }
1639         }
1640         @Override
1641         public void visitClassDef(JCClassDecl tree) {
1642             //skip
1643         }
1644     }
1645 
1646     /** Enum to model whether constructors allowed to &quot;leak&quot; this reference before
1647         all instance fields are DA.
1648      */
1649     enum ThisExposability {
1650         ALLOWED,     // Normal Object classes - NOP
1651         BANNED,      // Value types           - Error
1652         DISCOURAGED  // Value based types     - Warning
1653     }
1654 
1655     /**
1656      * This pass implements (i) definite assignment analysis, which ensures that
1657      * each variable is assigned when used and (ii) definite unassignment analysis,
1658      * which ensures that no final variable is assigned more than once. This visitor
1659      * depends on the results of the liveliness analyzer. This pass is also used to mark
1660      * effectively-final local variables/parameters.
1661      */
1662 
1663     public class AssignAnalyzer extends BaseAnalyzer {
1664 
1665         /** The set of definitely assigned variables.
1666          */
1667         final Bits inits;
1668 
1669         /** The set of definitely unassigned variables.
1670          */
1671         final Bits uninits;
1672 
1673         /** The set of variables that are definitely unassigned everywhere
1674          *  in current try block. This variable is maintained lazily; it is
1675          *  updated only when something gets removed from uninits,
1676          *  typically by being assigned in reachable code.  To obtain the
1677          *  correct set of variables which are definitely unassigned
1678          *  anywhere in current try block, intersect uninitsTry and
1679          *  uninits.
1680          */
1681         final Bits uninitsTry;
1682 
1683         /** When analyzing a condition, inits and uninits are null.
1684          *  Instead we have:
1685          */
1686         final Bits initsWhenTrue;
1687         final Bits initsWhenFalse;
1688         final Bits uninitsWhenTrue;
1689         final Bits uninitsWhenFalse;
1690 
1691         /** A mapping from addresses to variable symbols.
1692          */
1693         protected JCVariableDecl[] vardecls;
1694 
1695         /** The current class being defined.
1696          */
1697         JCClassDecl classDef;
1698 
1699         /** The first variable sequence number in this class definition.
1700          */
1701         int firstadr;
1702 
1703         /** The next available variable sequence number.
1704          */
1705         protected int nextadr;
1706 
1707         /** The first variable sequence number in a block that can return.
1708          */
1709         protected int returnadr;
1710 
1711         /** The list of unreferenced automatic resources.
1712          */
1713         WriteableScope unrefdResources;
1714 
1715         /** Modified when processing a loop body the second time for DU analysis. */
1716         FlowKind flowKind = FlowKind.NORMAL;
1717 
1718         /** The starting position of the analyzed tree */
1719         int startPos;
1720 
1721         public class AssignPendingExit extends BaseAnalyzer.PendingExit {
1722 
1723             final Bits inits;
1724             final Bits uninits;
1725             final Bits exit_inits = new Bits(true);
1726             final Bits exit_uninits = new Bits(true);
1727 
1728             public AssignPendingExit(JCTree tree, final Bits inits, final Bits uninits) {
1729                 super(tree);
1730                 this.inits = inits;
1731                 this.uninits = uninits;
1732                 this.exit_inits.assign(inits);
1733                 this.exit_uninits.assign(uninits);
1734             }
1735 
1736             @Override
1737             public void resolveJump() {
1738                 inits.andSet(exit_inits);
1739                 uninits.andSet(exit_uninits);
1740             }
1741         }
1742 
1743         // Are constructors allowed to leak this reference ?
1744         ThisExposability thisExposability = ALLOWED;
1745 
1746         public AssignAnalyzer() {
1747             this.inits = new Bits();
1748             uninits = new Bits();
1749             uninitsTry = new Bits();
1750             initsWhenTrue = new Bits(true);
1751             initsWhenFalse = new Bits(true);
1752             uninitsWhenTrue = new Bits(true);
1753             uninitsWhenFalse = new Bits(true);
1754         }
1755 
1756         private boolean isInitialConstructor = false;
1757 
1758         @Override
1759         protected void markDead() {
1760             if (!isInitialConstructor) {
1761                 inits.inclRange(returnadr, nextadr);
1762             } else {
1763                 for (int address = returnadr; address &lt; nextadr; address++) {
1764                     if (!(isFinalUninitializedStaticField(vardecls[address].sym))) {
1765                         inits.incl(address);
1766                     }
1767                 }
1768             }
1769             uninits.inclRange(returnadr, nextadr);
1770         }
1771 
1772         /*-------------- Processing variables ----------------------*/
1773 
1774         /** Do we need to track init/uninit state of this symbol?
1775          *  I.e. is symbol either a local or a blank final variable?
1776          */
1777         protected boolean trackable(VarSymbol sym) {
1778             return
1779                 sym.pos &gt;= startPos &amp;&amp;
1780                 ((sym.owner.kind == MTH || sym.owner.kind == VAR ||
1781                 isFinalUninitializedField(sym)));
1782         }
1783 
1784         boolean isFinalUninitializedField(VarSymbol sym) {
1785             return sym.owner.kind == TYP &amp;&amp;
1786                    ((sym.flags() &amp; (FINAL | HASINIT | PARAMETER)) == FINAL &amp;&amp;
1787                    classDef.sym.isEnclosedBy((ClassSymbol)sym.owner));
1788         }
1789 
1790         boolean isFinalUninitializedStaticField(VarSymbol sym) {
1791             return isFinalUninitializedField(sym) &amp;&amp; sym.isStatic();
1792         }
1793 
1794         /** Initialize new trackable variable by setting its address field
1795          *  to the next available sequence number and entering it under that
1796          *  index into the vars array.
1797          */
1798         void newVar(JCVariableDecl varDecl) {
1799             VarSymbol sym = varDecl.sym;
1800             vardecls = ArrayUtils.ensureCapacity(vardecls, nextadr);
1801             if ((sym.flags() &amp; FINAL) == 0) {
1802                 sym.flags_field |= EFFECTIVELY_FINAL;
1803             }
1804             sym.adr = nextadr;
1805             vardecls[nextadr] = varDecl;
1806             inits.excl(nextadr);
1807             uninits.incl(nextadr);
1808             nextadr++;
1809         }
1810 
1811         /** Record an initialization of a trackable variable.
1812          */
1813         void letInit(DiagnosticPosition pos, VarSymbol sym) {
1814             if (sym.adr &gt;= firstadr &amp;&amp; trackable(sym)) {
1815                 if ((sym.flags() &amp; EFFECTIVELY_FINAL) != 0) {
1816                     if (!uninits.isMember(sym.adr)) {
1817                         //assignment targeting an effectively final variable
1818                         //makes the variable lose its status of effectively final
1819                         //if the variable is _not_ definitively unassigned
1820                         sym.flags_field &amp;= ~EFFECTIVELY_FINAL;
1821                     } else {
1822                         uninit(sym);
1823                     }
1824                 }
1825                 else if ((sym.flags() &amp; FINAL) != 0) {
1826                     if ((sym.flags() &amp; PARAMETER) != 0) {
1827                         if ((sym.flags() &amp; UNION) != 0) { //multi-catch parameter
1828                             log.error(pos, Errors.MulticatchParameterMayNotBeAssigned(sym));
1829                         }
1830                         else {
1831                             log.error(pos,
1832                                       Errors.FinalParameterMayNotBeAssigned(sym));
1833                         }
1834                     } else if (!uninits.isMember(sym.adr)) {
1835                         log.error(pos, diags.errorKey(flowKind.errKey, sym));
1836                     } else {
1837                         uninit(sym);
1838                     }
1839                 }
1840                 inits.incl(sym.adr);
1841             } else if ((sym.flags() &amp; FINAL) != 0) {
1842                 log.error(pos, Errors.VarMightAlreadyBeAssigned(sym));
1843             }
1844         }
1845         //where
1846             void uninit(VarSymbol sym) {
1847                 if (!inits.isMember(sym.adr)) {
1848                     // reachable assignment
1849                     uninits.excl(sym.adr);
1850                     uninitsTry.excl(sym.adr);
1851                 } else {
1852                     //log.rawWarning(pos, &quot;unreachable assignment&quot;);//DEBUG
1853                     uninits.excl(sym.adr);
1854                 }
1855             }
1856 
1857         /** If tree is either a simple name or of the form this.name or
1858          *  C.this.name, and tree represents a trackable variable,
1859          *  record an initialization of the variable.
1860          */
1861         void letInit(JCTree tree) {
1862             tree = TreeInfo.skipParens(tree);
1863             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
1864                 Symbol sym = TreeInfo.symbol(tree);
1865                 if (sym.kind == VAR) {
1866                     letInit(tree.pos(), (VarSymbol)sym);
1867                 }
1868             }
1869         }
1870 
1871         void checkEmbryonicThisExposure(JCTree node) {
1872             if (this.thisExposability == ALLOWED || classDef == null)
1873                 return;
1874 
1875             // Note: for non-initial constructors, firstadr is post all instance fields.
1876             for (int i = firstadr; i &lt; nextadr; i++) {
1877                 VarSymbol sym = vardecls[i].sym;
1878                 if (sym.owner != classDef.sym)
1879                     continue;
1880                 if ((sym.flags() &amp; (FINAL | HASINIT | STATIC | PARAMETER)) != FINAL)
1881                     continue;
1882                 if (sym.pos &lt; startPos || sym.adr &lt; firstadr)
1883                     continue;
1884                 if (!inits.isMember(sym.adr)) {
1885                     if (this.thisExposability == BANNED) {
1886                         log.error(node, Errors.ThisExposedPrematurely);
1887                     } else {
1888                         log.warning(node, Warnings.ThisExposedPrematurely);
1889                     }
1890                     return; // don&#39;t flog a dead horse.
1891                 }
1892             }
1893         }
1894 
1895         /** Check that trackable variable is initialized.
1896          */
1897         void checkInit(DiagnosticPosition pos, VarSymbol sym) {
1898             checkInit(pos, sym, Errors.VarMightNotHaveBeenInitialized(sym));
1899         }
1900 
1901         void checkInit(DiagnosticPosition pos, VarSymbol sym, Error errkey) {
1902             if ((sym.adr &gt;= firstadr || sym.owner.kind != TYP) &amp;&amp;
1903                 trackable(sym) &amp;&amp;
1904                 !inits.isMember(sym.adr)) {
1905                     log.error(pos, errkey);
1906                 inits.incl(sym.adr);
1907             }
1908         }
1909 
1910         /** Utility method to reset several Bits instances.
1911          */
1912         private void resetBits(Bits... bits) {
1913             for (Bits b : bits) {
1914                 b.reset();
1915             }
1916         }
1917 
1918         /** Split (duplicate) inits/uninits into WhenTrue/WhenFalse sets
1919          */
1920         void split(boolean setToNull) {
1921             initsWhenFalse.assign(inits);
1922             uninitsWhenFalse.assign(uninits);
1923             initsWhenTrue.assign(inits);
1924             uninitsWhenTrue.assign(uninits);
1925             if (setToNull) {
1926                 resetBits(inits, uninits);
1927             }
1928         }
1929 
1930         /** Merge (intersect) inits/uninits from WhenTrue/WhenFalse sets.
1931          */
1932         protected void merge() {
1933             inits.assign(initsWhenFalse.andSet(initsWhenTrue));
1934             uninits.assign(uninitsWhenFalse.andSet(uninitsWhenTrue));
1935         }
1936 
1937     /* ************************************************************************
1938      * Visitor methods for statements and definitions
1939      *************************************************************************/
1940 
1941         /** Analyze an expression. Make sure to set (un)inits rather than
1942          *  (un)initsWhenTrue(WhenFalse) on exit.
1943          */
1944         void scanExpr(JCTree tree) {
1945             if (tree != null) {
1946                 scan(tree);
1947                 if (inits.isReset()) {
1948                     merge();
1949                 }
1950             }
1951         }
1952 
1953         /** Analyze a list of expressions.
1954          */
1955         void scanExprs(List&lt;? extends JCExpression&gt; trees) {
1956             if (trees != null)
1957                 for (List&lt;? extends JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
1958                     scanExpr(l.head);
1959         }
1960 
1961         /** Analyze a condition. Make sure to set (un)initsWhenTrue(WhenFalse)
1962          *  rather than (un)inits on exit.
1963          */
1964         void scanCond(JCTree tree) {
1965             if (tree.type.isFalse()) {
1966                 if (inits.isReset()) merge();
1967                 initsWhenTrue.assign(inits);
1968                 initsWhenTrue.inclRange(firstadr, nextadr);
1969                 uninitsWhenTrue.assign(uninits);
1970                 uninitsWhenTrue.inclRange(firstadr, nextadr);
1971                 initsWhenFalse.assign(inits);
1972                 uninitsWhenFalse.assign(uninits);
1973             } else if (tree.type.isTrue()) {
1974                 if (inits.isReset()) merge();
1975                 initsWhenFalse.assign(inits);
1976                 initsWhenFalse.inclRange(firstadr, nextadr);
1977                 uninitsWhenFalse.assign(uninits);
1978                 uninitsWhenFalse.inclRange(firstadr, nextadr);
1979                 initsWhenTrue.assign(inits);
1980                 uninitsWhenTrue.assign(uninits);
1981             } else {
1982                 scan(tree);
1983                 if (!inits.isReset())
1984                     split(tree.type != syms.unknownType);
1985             }
1986             if (tree.type != syms.unknownType) {
1987                 resetBits(inits, uninits);
1988             }
1989         }
1990 
1991         /* ------------ Visitor methods for various sorts of trees -------------*/
1992 
1993         public void visitClassDef(JCClassDecl tree) {
1994             if (tree.sym == null) {
1995                 return;
1996             }
1997 
1998             Lint lintPrev = lint;
1999             lint = lint.augment(tree.sym);
2000             try {
2001                 if (tree.sym == null) {
2002                     return;
2003                 }
2004 
2005                 JCClassDecl classDefPrev = classDef;
2006                 int firstadrPrev = firstadr;
2007                 int nextadrPrev = nextadr;
2008                 ListBuffer&lt;PendingExit&gt; pendingExitsPrev = pendingExits;
2009 
2010                 pendingExits = new ListBuffer&lt;&gt;();
2011                 if (tree.name != names.empty) {
2012                     firstadr = nextadr;
2013                 }
2014                 classDef = tree;
2015                 try {
2016                     // define all the static fields
2017                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2018                         if (l.head.hasTag(VARDEF)) {
2019                             JCVariableDecl def = (JCVariableDecl)l.head;
2020                             if ((def.mods.flags &amp; STATIC) != 0) {
2021                                 VarSymbol sym = def.sym;
2022                                 if (trackable(sym)) {
2023                                     newVar(def);
2024                                 }
2025                             }
2026                         }
2027                     }
2028 
2029                     // process all the static initializers
2030                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2031                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2032                             (TreeInfo.flags(l.head) &amp; STATIC) != 0) {
2033                             scan(l.head);
2034                         }
2035                     }
2036 
2037                     // define all the instance fields
2038                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2039                         if (l.head.hasTag(VARDEF)) {
2040                             JCVariableDecl def = (JCVariableDecl)l.head;
2041                             if ((def.mods.flags &amp; STATIC) == 0) {
2042                                 VarSymbol sym = def.sym;
2043                                 if (trackable(sym)) {
2044                                     newVar(def);
2045                                 }
2046                             }
2047                         }
2048                     }
2049 
2050                     // process all the instance initializers
2051                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2052                         if (!l.head.hasTag(METHODDEF) &amp;&amp;
2053                             (TreeInfo.flags(l.head) &amp; STATIC) == 0) {
2054                             scan(l.head);
2055                         }
2056                     }
2057 
2058                     // process all the methods
2059                     for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
2060                         if (l.head.hasTag(METHODDEF)) {
2061                             scan(l.head);
2062                         }
2063                     }
2064                 } finally {
2065                     pendingExits = pendingExitsPrev;
2066                     nextadr = nextadrPrev;
2067                     firstadr = firstadrPrev;
2068                     classDef = classDefPrev;
2069                 }
2070             } finally {
2071                 lint = lintPrev;
2072             }
2073         }
2074 
2075         public void visitMethodDef(JCMethodDecl tree) {
2076             if (tree.body == null) {
2077                 return;
2078             }
2079 
2080             /*  MemberEnter can generate synthetic methods ignore them
2081              */
2082             if ((tree.sym.flags() &amp; SYNTHETIC) != 0) {
2083                 return;
2084             }
2085 
2086             Lint lintPrev = lint;
2087             lint = lint.augment(tree.sym);
2088             ThisExposability priorThisExposability = this.thisExposability;
2089             try {
2090                 if (tree.body == null) {
2091                     return;
2092                 }
2093                 /*  Ignore synthetic methods, except for translated lambda methods.
2094                  */
2095                 if ((tree.sym.flags() &amp; (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {
2096                     return;
2097                 }
2098 
2099                 final Bits initsPrev = new Bits(inits);
2100                 final Bits uninitsPrev = new Bits(uninits);
2101                 int nextadrPrev = nextadr;
2102                 int firstadrPrev = firstadr;
2103                 int returnadrPrev = returnadr;
2104 
2105                 Assert.check(pendingExits.isEmpty());
2106                 boolean lastInitialConstructor = isInitialConstructor;
2107                 try {
2108                     isInitialConstructor = TreeInfo.isInitialConstructor(tree);
2109 
2110                     if (!isInitialConstructor) {
2111                         firstadr = nextadr;
2112                         this.thisExposability = ALLOWED;
2113                     } else {
2114                         if (types.isValueBased(tree.sym.owner.type))
2115                             this.thisExposability = DISCOURAGED;
2116                         else if (types.isValue(tree.sym.owner.type))
2117                             this.thisExposability = BANNED;
2118                         else
2119                             this.thisExposability = ALLOWED;
2120                     }
2121                     for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2122                         JCVariableDecl def = l.head;
2123                         scan(def);
2124                         Assert.check((def.sym.flags() &amp; PARAMETER) != 0, &quot;Method parameter without PARAMETER flag&quot;);
2125                         /*  If we are executing the code from Gen, then there can be
2126                          *  synthetic or mandated variables, ignore them.
2127                          */
2128                         initParam(def);
2129                     }
2130                     // else we are in an instance initializer block;
2131                     // leave caught unchanged.
2132                     scan(tree.body);
2133 
2134                     boolean isCompactConstructor = (tree.sym.flags() &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0;
2135                     if (isInitialConstructor) {
2136                         boolean isSynthesized = (tree.sym.flags() &amp;
2137                                                  GENERATEDCONSTR) != 0;
2138                         for (int i = firstadr; i &lt; nextadr; i++) {
2139                             JCVariableDecl vardecl = vardecls[i];
2140                             VarSymbol var = vardecl.sym;
2141                             if (var.owner == classDef.sym) {
2142                                 // choose the diagnostic position based on whether
2143                                 // the ctor is default(synthesized) or not
2144                                 if (isSynthesized &amp;&amp; !isCompactConstructor) {
2145                                     checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),
2146                                             var, Errors.VarNotInitializedInDefaultConstructor(var));
2147                                 } else if (isCompactConstructor) {
2148                                     boolean isInstanceRecordField = var.enclClass().isRecord() &amp;&amp;
2149                                             (var.flags_field &amp; (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &amp;&amp;
2150                                             !var.isStatic() &amp;&amp;
2151                                             var.owner.kind == TYP;
2152                                     if (isInstanceRecordField) {
2153                                         boolean notInitialized = !inits.isMember(var.adr);
2154                                         if (notInitialized &amp;&amp; uninits.isMember(var.adr) &amp;&amp; tree.completesNormally) {
2155                                         /*  this way we indicate Lower that it should generate an initialization for this field
2156                                          *  in the compact constructor
2157                                          */
2158                                             var.flags_field |= UNINITIALIZED_FIELD;
2159                                         } else {
2160                                             checkInit(TreeInfo.diagEndPos(tree.body), var);
2161                                         }
2162                                     } else {
2163                                         checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);
2164                                     }
2165                                 } else {
2166                                     checkInit(TreeInfo.diagEndPos(tree.body), var);
2167                                 }
2168                             }
2169                         }
2170                     }
2171                     List&lt;PendingExit&gt; exits = pendingExits.toList();
2172                     pendingExits = new ListBuffer&lt;&gt;();
2173                     while (exits.nonEmpty()) {
2174                         PendingExit exit = exits.head;
2175                         exits = exits.tail;
2176                         Assert.check(exit.tree.hasTag(RETURN) ||
2177                                          log.hasErrorOn(exit.tree.pos()),
2178                                      exit.tree);
2179                         if (isInitialConstructor) {
2180                             Assert.check(exit instanceof AssignPendingExit);
2181                             inits.assign(((AssignPendingExit) exit).exit_inits);
2182                             for (int i = firstadr; i &lt; nextadr; i++) {
2183                                 checkInit(exit.tree.pos(), vardecls[i].sym);
2184                             }
2185                         }
2186                     }
2187                 } finally {
2188                     inits.assign(initsPrev);
2189                     uninits.assign(uninitsPrev);
2190                     nextadr = nextadrPrev;
2191                     firstadr = firstadrPrev;
2192                     returnadr = returnadrPrev;
2193                     isInitialConstructor = lastInitialConstructor;
2194                 }
2195             } finally {
2196                 lint = lintPrev;
2197                 this.thisExposability = priorThisExposability;
2198             }
2199         }
2200 
2201         protected void initParam(JCVariableDecl def) {
2202             inits.incl(def.sym.adr);
2203             uninits.excl(def.sym.adr);
2204         }
2205 
2206         public void visitVarDef(JCVariableDecl tree) {
2207             Lint lintPrev = lint;
2208             lint = lint.augment(tree.sym);
2209             try{
2210                 boolean track = trackable(tree.sym);
2211                 if (track &amp;&amp; (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {
2212                     newVar(tree);
2213                 }
2214                 if (tree.init != null) {
2215                     scanExpr(tree.init);
2216                     if (track) {
2217                         letInit(tree.pos(), tree.sym);
2218                     }
2219                 }
2220             } finally {
2221                 lint = lintPrev;
2222             }
2223         }
2224 
2225         public void visitBlock(JCBlock tree) {
2226             int nextadrPrev = nextadr;
2227             scan(tree.stats);
2228             nextadr = nextadrPrev;
2229         }
2230 
2231         public void visitDoLoop(JCDoWhileLoop tree) {
2232             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2233             FlowKind prevFlowKind = flowKind;
2234             flowKind = FlowKind.NORMAL;
2235             final Bits initsSkip = new Bits(true);
2236             final Bits uninitsSkip = new Bits(true);
2237             pendingExits = new ListBuffer&lt;&gt;();
2238             int prevErrors = log.nerrors;
2239             do {
2240                 final Bits uninitsEntry = new Bits(uninits);
2241                 uninitsEntry.excludeFrom(nextadr);
2242                 scan(tree.body);
2243                 resolveContinues(tree);
2244                 scanCond(tree.cond);
2245                 if (!flowKind.isFinal()) {
2246                     initsSkip.assign(initsWhenFalse);
2247                     uninitsSkip.assign(uninitsWhenFalse);
2248                 }
2249                 if (log.nerrors !=  prevErrors ||
2250                     flowKind.isFinal() ||
2251                     new Bits(uninitsEntry).diffSet(uninitsWhenTrue).nextBit(firstadr)==-1)
2252                     break;
2253                 inits.assign(initsWhenTrue);
2254                 uninits.assign(uninitsEntry.andSet(uninitsWhenTrue));
2255                 flowKind = FlowKind.SPECULATIVE_LOOP;
2256             } while (true);
2257             flowKind = prevFlowKind;
2258             inits.assign(initsSkip);
2259             uninits.assign(uninitsSkip);
2260             resolveBreaks(tree, prevPendingExits);
2261         }
2262 
2263         public void visitWhileLoop(JCWhileLoop tree) {
2264             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2265             FlowKind prevFlowKind = flowKind;
2266             flowKind = FlowKind.NORMAL;
2267             final Bits initsSkip = new Bits(true);
2268             final Bits uninitsSkip = new Bits(true);
2269             pendingExits = new ListBuffer&lt;&gt;();
2270             int prevErrors = log.nerrors;
2271             final Bits uninitsEntry = new Bits(uninits);
2272             uninitsEntry.excludeFrom(nextadr);
2273             do {
2274                 scanCond(tree.cond);
2275                 if (!flowKind.isFinal()) {
2276                     initsSkip.assign(initsWhenFalse) ;
2277                     uninitsSkip.assign(uninitsWhenFalse);
2278                 }
2279                 inits.assign(initsWhenTrue);
2280                 uninits.assign(uninitsWhenTrue);
2281                 scan(tree.body);
2282                 resolveContinues(tree);
2283                 if (log.nerrors != prevErrors ||
2284                     flowKind.isFinal() ||
2285                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1) {
2286                     break;
2287                 }
2288                 uninits.assign(uninitsEntry.andSet(uninits));
2289                 flowKind = FlowKind.SPECULATIVE_LOOP;
2290             } while (true);
2291             flowKind = prevFlowKind;
2292             //a variable is DA/DU after the while statement, if it&#39;s DA/DU assuming the
2293             //branch is not taken AND if it&#39;s DA/DU before any break statement
2294             inits.assign(initsSkip);
2295             uninits.assign(uninitsSkip);
2296             resolveBreaks(tree, prevPendingExits);
2297         }
2298 
2299         public void visitForLoop(JCForLoop tree) {
2300             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2301             FlowKind prevFlowKind = flowKind;
2302             flowKind = FlowKind.NORMAL;
2303             int nextadrPrev = nextadr;
2304             scan(tree.init);
2305             final Bits initsSkip = new Bits(true);
2306             final Bits uninitsSkip = new Bits(true);
2307             pendingExits = new ListBuffer&lt;&gt;();
2308             int prevErrors = log.nerrors;
2309             do {
2310                 final Bits uninitsEntry = new Bits(uninits);
2311                 uninitsEntry.excludeFrom(nextadr);
2312                 if (tree.cond != null) {
2313                     scanCond(tree.cond);
2314                     if (!flowKind.isFinal()) {
2315                         initsSkip.assign(initsWhenFalse);
2316                         uninitsSkip.assign(uninitsWhenFalse);
2317                     }
2318                     inits.assign(initsWhenTrue);
2319                     uninits.assign(uninitsWhenTrue);
2320                 } else if (!flowKind.isFinal()) {
2321                     initsSkip.assign(inits);
2322                     initsSkip.inclRange(firstadr, nextadr);
2323                     uninitsSkip.assign(uninits);
2324                     uninitsSkip.inclRange(firstadr, nextadr);
2325                 }
2326                 scan(tree.body);
2327                 resolveContinues(tree);
2328                 scan(tree.step);
2329                 if (log.nerrors != prevErrors ||
2330                     flowKind.isFinal() ||
2331                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2332                     break;
2333                 uninits.assign(uninitsEntry.andSet(uninits));
2334                 flowKind = FlowKind.SPECULATIVE_LOOP;
2335             } while (true);
2336             flowKind = prevFlowKind;
2337             //a variable is DA/DU after a for loop, if it&#39;s DA/DU assuming the
2338             //branch is not taken AND if it&#39;s DA/DU before any break statement
2339             inits.assign(initsSkip);
2340             uninits.assign(uninitsSkip);
2341             resolveBreaks(tree, prevPendingExits);
2342             nextadr = nextadrPrev;
2343         }
2344 
2345         public void visitForeachLoop(JCEnhancedForLoop tree) {
2346             visitVarDef(tree.var);
2347 
2348             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2349             FlowKind prevFlowKind = flowKind;
2350             flowKind = FlowKind.NORMAL;
2351             int nextadrPrev = nextadr;
2352             scan(tree.expr);
2353             final Bits initsStart = new Bits(inits);
2354             final Bits uninitsStart = new Bits(uninits);
2355 
2356             letInit(tree.pos(), tree.var.sym);
2357             pendingExits = new ListBuffer&lt;&gt;();
2358             int prevErrors = log.nerrors;
2359             do {
2360                 final Bits uninitsEntry = new Bits(uninits);
2361                 uninitsEntry.excludeFrom(nextadr);
2362                 scan(tree.body);
2363                 resolveContinues(tree);
2364                 if (log.nerrors != prevErrors ||
2365                     flowKind.isFinal() ||
2366                     new Bits(uninitsEntry).diffSet(uninits).nextBit(firstadr) == -1)
2367                     break;
2368                 uninits.assign(uninitsEntry.andSet(uninits));
2369                 flowKind = FlowKind.SPECULATIVE_LOOP;
2370             } while (true);
2371             flowKind = prevFlowKind;
2372             inits.assign(initsStart);
2373             uninits.assign(uninitsStart.andSet(uninits));
2374             resolveBreaks(tree, prevPendingExits);
2375             nextadr = nextadrPrev;
2376         }
2377 
2378         public void visitLabelled(JCLabeledStatement tree) {
2379             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2380             pendingExits = new ListBuffer&lt;&gt;();
2381             scan(tree.body);
2382             resolveBreaks(tree, prevPendingExits);
2383         }
2384 
2385         public void visitSwitch(JCSwitch tree) {
2386             handleSwitch(tree, tree.selector, tree.cases);
2387         }
2388 
2389         public void visitSwitchExpression(JCSwitchExpression tree) {
2390             handleSwitch(tree, tree.selector, tree.cases);
2391         }
2392 
2393         private void handleSwitch(JCTree tree, JCExpression selector, List&lt;JCCase&gt; cases) {
2394             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2395             pendingExits = new ListBuffer&lt;&gt;();
2396             int nextadrPrev = nextadr;
2397             scanExpr(selector);
2398             final Bits initsSwitch = new Bits(inits);
2399             final Bits uninitsSwitch = new Bits(uninits);
2400             boolean hasDefault = false;
2401             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
2402                 inits.assign(initsSwitch);
2403                 uninits.assign(uninits.andSet(uninitsSwitch));
2404                 JCCase c = l.head;
2405                 if (c.pats.isEmpty()) {
2406                     hasDefault = true;
2407                 } else {
2408                     for (JCExpression pat : c.pats) {
2409                         scanExpr(pat);
2410                     }
2411                 }
2412                 if (hasDefault) {
2413                     inits.assign(initsSwitch);
2414                     uninits.assign(uninits.andSet(uninitsSwitch));
2415                 }
2416                 scan(c.stats);
2417                 if (c.completesNormally &amp;&amp; c.caseKind == JCCase.RULE) {
2418                     scanSyntheticBreak(make, tree);
2419                 }
2420                 addVars(c.stats, initsSwitch, uninitsSwitch);
2421                 if (!hasDefault) {
2422                     inits.assign(initsSwitch);
2423                     uninits.assign(uninits.andSet(uninitsSwitch));
2424                 }
2425                 // Warn about fall-through if lint switch fallthrough enabled.
2426             }
2427             if (!hasDefault) {
2428                 if (tree.hasTag(SWITCH_EXPRESSION)) {
2429                     markDead();
2430                 } else {
2431                     inits.andSet(initsSwitch);
2432                 }
2433             }
2434             if (tree.hasTag(SWITCH_EXPRESSION)) {
2435                 resolveYields(tree, prevPendingExits);
2436             } else {
2437                 resolveBreaks(tree, prevPendingExits);
2438             }
2439             nextadr = nextadrPrev;
2440         }
2441         // where
2442             /** Add any variables defined in stats to inits and uninits. */
2443             private void addVars(List&lt;JCStatement&gt; stats, final Bits inits,
2444                                         final Bits uninits) {
2445                 for (;stats.nonEmpty(); stats = stats.tail) {
2446                     JCTree stat = stats.head;
2447                     if (stat.hasTag(VARDEF)) {
2448                         int adr = ((JCVariableDecl) stat).sym.adr;
2449                         inits.excl(adr);
2450                         uninits.incl(adr);
2451                     }
2452                 }
2453             }
2454 
2455         public void visitTry(JCTry tree) {
2456             ListBuffer&lt;JCVariableDecl&gt; resourceVarDecls = new ListBuffer&lt;&gt;();
2457             final Bits uninitsTryPrev = new Bits(uninitsTry);
2458             ListBuffer&lt;PendingExit&gt; prevPendingExits = pendingExits;
2459             pendingExits = new ListBuffer&lt;&gt;();
2460             final Bits initsTry = new Bits(inits);
2461             uninitsTry.assign(uninits);
2462             for (JCTree resource : tree.resources) {
2463                 if (resource instanceof JCVariableDecl) {
2464                     JCVariableDecl vdecl = (JCVariableDecl) resource;
2465                     visitVarDef(vdecl);
2466                     unrefdResources.enter(vdecl.sym);
2467                     resourceVarDecls.append(vdecl);
2468                 } else if (resource instanceof JCExpression) {
2469                     scanExpr((JCExpression) resource);
2470                 } else {
2471                     throw new AssertionError(tree);  // parser error
2472                 }
2473             }
2474             scan(tree.body);
2475             uninitsTry.andSet(uninits);
2476             final Bits initsEnd = new Bits(inits);
2477             final Bits uninitsEnd = new Bits(uninits);
2478             int nextadrCatch = nextadr;
2479 
2480             if (!resourceVarDecls.isEmpty() &amp;&amp;
2481                     lint.isEnabled(Lint.LintCategory.TRY)) {
2482                 for (JCVariableDecl resVar : resourceVarDecls) {
2483                     if (unrefdResources.includes(resVar.sym)) {
2484                         log.warning(Lint.LintCategory.TRY, resVar.pos(),
2485                                     Warnings.TryResourceNotReferenced(resVar.sym));
2486                         unrefdResources.remove(resVar.sym);
2487                     }
2488                 }
2489             }
2490 
2491             /*  The analysis of each catch should be independent.
2492              *  Each one should have the same initial values of inits and
2493              *  uninits.
2494              */
2495             final Bits initsCatchPrev = new Bits(initsTry);
2496             final Bits uninitsCatchPrev = new Bits(uninitsTry);
2497 
2498             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
2499                 JCVariableDecl param = l.head.param;
2500                 inits.assign(initsCatchPrev);
2501                 uninits.assign(uninitsCatchPrev);
2502                 scan(param);
2503                 /* If this is a TWR and we are executing the code from Gen,
2504                  * then there can be synthetic variables, ignore them.
2505                  */
2506                 initParam(param);
2507                 scan(l.head.body);
2508                 initsEnd.andSet(inits);
2509                 uninitsEnd.andSet(uninits);
2510                 nextadr = nextadrCatch;
2511             }
2512             if (tree.finalizer != null) {
2513                 inits.assign(initsTry);
2514                 uninits.assign(uninitsTry);
2515                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2516                 pendingExits = prevPendingExits;
2517                 scan(tree.finalizer);
2518                 if (!tree.finallyCanCompleteNormally) {
2519                     // discard exits and exceptions from try and finally
2520                 } else {
2521                     uninits.andSet(uninitsEnd);
2522                     // FIX: this doesn&#39;t preserve source order of exits in catch
2523                     // versus finally!
2524                     while (exits.nonEmpty()) {
2525                         PendingExit exit = exits.next();
2526                         if (exit instanceof AssignPendingExit) {
2527                             ((AssignPendingExit) exit).exit_inits.orSet(inits);
2528                             ((AssignPendingExit) exit).exit_uninits.andSet(uninits);
2529                         }
2530                         pendingExits.append(exit);
2531                     }
2532                     inits.orSet(initsEnd);
2533                 }
2534             } else {
2535                 inits.assign(initsEnd);
2536                 uninits.assign(uninitsEnd);
2537                 ListBuffer&lt;PendingExit&gt; exits = pendingExits;
2538                 pendingExits = prevPendingExits;
2539                 while (exits.nonEmpty()) pendingExits.append(exits.next());
2540             }
2541             uninitsTry.andSet(uninitsTryPrev).andSet(uninits);
2542         }
2543 
2544         public void visitConditional(JCConditional tree) {
2545             scanCond(tree.cond);
2546             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2547             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2548             inits.assign(initsWhenTrue);
2549             uninits.assign(uninitsWhenTrue);
2550             if (tree.truepart.type.hasTag(BOOLEAN) &amp;&amp;
2551                 tree.falsepart.type.hasTag(BOOLEAN)) {
2552                 // if b and c are boolean valued, then
2553                 // v is (un)assigned after a?b:c when true iff
2554                 //    v is (un)assigned after b when true and
2555                 //    v is (un)assigned after c when true
2556                 scanCond(tree.truepart);
2557                 final Bits initsAfterThenWhenTrue = new Bits(initsWhenTrue);
2558                 final Bits initsAfterThenWhenFalse = new Bits(initsWhenFalse);
2559                 final Bits uninitsAfterThenWhenTrue = new Bits(uninitsWhenTrue);
2560                 final Bits uninitsAfterThenWhenFalse = new Bits(uninitsWhenFalse);
2561                 inits.assign(initsBeforeElse);
2562                 uninits.assign(uninitsBeforeElse);
2563                 scanCond(tree.falsepart);
2564                 initsWhenTrue.andSet(initsAfterThenWhenTrue);
2565                 initsWhenFalse.andSet(initsAfterThenWhenFalse);
2566                 uninitsWhenTrue.andSet(uninitsAfterThenWhenTrue);
2567                 uninitsWhenFalse.andSet(uninitsAfterThenWhenFalse);
2568             } else {
2569                 scanExpr(tree.truepart);
2570                 final Bits initsAfterThen = new Bits(inits);
2571                 final Bits uninitsAfterThen = new Bits(uninits);
2572                 inits.assign(initsBeforeElse);
2573                 uninits.assign(uninitsBeforeElse);
2574                 scanExpr(tree.falsepart);
2575                 inits.andSet(initsAfterThen);
2576                 uninits.andSet(uninitsAfterThen);
2577             }
2578         }
2579 
2580         public void visitIf(JCIf tree) {
2581             scanCond(tree.cond);
2582             final Bits initsBeforeElse = new Bits(initsWhenFalse);
2583             final Bits uninitsBeforeElse = new Bits(uninitsWhenFalse);
2584             inits.assign(initsWhenTrue);
2585             uninits.assign(uninitsWhenTrue);
2586             scan(tree.thenpart);
2587             if (tree.elsepart != null) {
2588                 final Bits initsAfterThen = new Bits(inits);
2589                 final Bits uninitsAfterThen = new Bits(uninits);
2590                 inits.assign(initsBeforeElse);
2591                 uninits.assign(uninitsBeforeElse);
2592                 scan(tree.elsepart);
2593                 inits.andSet(initsAfterThen);
2594                 uninits.andSet(uninitsAfterThen);
2595             } else {
2596                 inits.andSet(initsBeforeElse);
2597                 uninits.andSet(uninitsBeforeElse);
2598             }
2599         }
2600 
2601         @Override
2602         public void visitBreak(JCBreak tree) {
2603             recordExit(new AssignPendingExit(tree, inits, uninits));
2604         }
2605 
2606         @Override
2607         public void visitYield(JCYield tree) {
2608             JCSwitchExpression expr = (JCSwitchExpression) tree.target;
2609             if (expr != null &amp;&amp; expr.type.hasTag(BOOLEAN)) {
2610                 scanCond(tree.value);
2611                 Bits initsAfterBreakWhenTrue = new Bits(initsWhenTrue);
2612                 Bits initsAfterBreakWhenFalse = new Bits(initsWhenFalse);
2613                 Bits uninitsAfterBreakWhenTrue = new Bits(uninitsWhenTrue);
2614                 Bits uninitsAfterBreakWhenFalse = new Bits(uninitsWhenFalse);
2615                 PendingExit exit = new PendingExit(tree) {
2616                     @Override
2617                     void resolveJump() {
2618                         if (!inits.isReset()) {
2619                             split(true);
2620                         }
2621                         initsWhenTrue.andSet(initsAfterBreakWhenTrue);
2622                         initsWhenFalse.andSet(initsAfterBreakWhenFalse);
2623                         uninitsWhenTrue.andSet(uninitsAfterBreakWhenTrue);
2624                         uninitsWhenFalse.andSet(uninitsAfterBreakWhenFalse);
2625                     }
2626                 };
2627                 merge();
2628                 recordExit(exit);
2629                 return ;
2630             } else {
2631                 scanExpr(tree.value);
2632                 recordExit(new AssignPendingExit(tree, inits, uninits));
2633             }
2634         }
2635 
2636         @Override
2637         public void visitContinue(JCContinue tree) {
2638             recordExit(new AssignPendingExit(tree, inits, uninits));
2639         }
2640 
2641         @Override
2642         public void visitReturn(JCReturn tree) {
2643             scanExpr(tree.expr);
2644             recordExit(new AssignPendingExit(tree, inits, uninits));
2645         }
2646 
2647         public void visitThrow(JCThrow tree) {
2648             scanExpr(tree.expr);
2649             markDead();
2650         }
2651 
2652         public void visitApply(JCMethodInvocation tree) {
2653             scanExpr(tree.meth);
2654             scanExprs(tree.args);
2655             if (tree.meth.hasTag(IDENT)) {
2656                 JCIdent ident = (JCIdent) tree.meth;
2657                 if (ident.name != names._super &amp;&amp; !ident.sym.isStatic())
2658                     checkEmbryonicThisExposure(tree);
2659             }
2660         }
2661 
2662         public void visitNewClass(JCNewClass tree) {
2663             scanExpr(tree.encl);
2664             scanExprs(tree.args);
2665             scan(tree.def);
2666             if (classDef != null &amp;&amp; tree.encl == null &amp;&amp; tree.clazz.hasTag(IDENT)) {
2667                 JCIdent clazz = (JCIdent) tree.clazz;
2668                 if (!clazz.sym.isStatic() &amp;&amp; clazz.type.getEnclosingType().tsym == classDef.sym) {
2669                     checkEmbryonicThisExposure(tree);
2670                 }
2671             }
2672         }
2673 
2674         @Override
2675         public void visitLambda(JCLambda tree) {
2676             final Bits prevUninits = new Bits(uninits);
2677             final Bits prevInits = new Bits(inits);
2678             int returnadrPrev = returnadr;
2679             int nextadrPrev = nextadr;
2680             ListBuffer&lt;PendingExit&gt; prevPending = pendingExits;
2681             try {
2682                 returnadr = nextadr;
2683                 pendingExits = new ListBuffer&lt;&gt;();
2684                 for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
2685                     JCVariableDecl def = l.head;
2686                     scan(def);
2687                     inits.incl(def.sym.adr);
2688                     uninits.excl(def.sym.adr);
2689                 }
2690                 if (tree.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
2691                     scanExpr(tree.body);
2692                 } else {
2693                     scan(tree.body);
2694                 }
2695             }
2696             finally {
2697                 returnadr = returnadrPrev;
2698                 uninits.assign(prevUninits);
2699                 inits.assign(prevInits);
2700                 pendingExits = prevPending;
2701                 nextadr = nextadrPrev;
2702             }
2703         }
2704 
2705         public void visitNewArray(JCNewArray tree) {
2706             scanExprs(tree.dims);
2707             scanExprs(tree.elems);
2708         }
2709 
2710         public void visitAssert(JCAssert tree) {
2711             final Bits initsExit = new Bits(inits);
2712             final Bits uninitsExit = new Bits(uninits);
2713             scanCond(tree.cond);
2714             uninitsExit.andSet(uninitsWhenTrue);
2715             if (tree.detail != null) {
2716                 inits.assign(initsWhenFalse);
2717                 uninits.assign(uninitsWhenFalse);
2718                 scanExpr(tree.detail);
2719             }
2720             inits.assign(initsExit);
2721             uninits.assign(uninitsExit);
2722         }
2723 
2724         public void visitAssign(JCAssign tree) {
2725             if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))
2726                 scanExpr(tree.lhs);
2727             scanExpr(tree.rhs);
2728             letInit(tree.lhs);
2729         }
2730 
2731         // check fields accessed through this.&lt;field&gt; are definitely
2732         // assigned before reading their value
2733         public void visitSelect(JCFieldAccess tree) {
2734             ThisExposability priorThisExposability = this.thisExposability;
2735             try {
2736                 if (tree.name == names._this &amp;&amp; classDef != null &amp;&amp; tree.sym.owner == classDef.sym) {
2737                     checkEmbryonicThisExposure(tree);
2738                 } else if (tree.sym.kind == VAR || tree.sym.isStatic()) {
2739                     this.thisExposability = ALLOWED;
2740                 }
2741                 super.visitSelect(tree);
2742             if (TreeInfo.isThisQualifier(tree.selected) &amp;&amp;
2743                 tree.sym.kind == VAR) {
2744                     checkInit(tree.pos(), (VarSymbol)tree.sym);
2745                 }
2746             } finally {
2747                  this.thisExposability = priorThisExposability;
2748             }
2749         }
2750 
2751         public void visitAssignop(JCAssignOp tree) {
2752             scanExpr(tree.lhs);
2753             scanExpr(tree.rhs);
2754             letInit(tree.lhs);
2755         }
2756 
2757         public void visitUnary(JCUnary tree) {
2758             switch (tree.getTag()) {
2759             case NOT:
2760                 scanCond(tree.arg);
2761                 final Bits t = new Bits(initsWhenFalse);
2762                 initsWhenFalse.assign(initsWhenTrue);
2763                 initsWhenTrue.assign(t);
2764                 t.assign(uninitsWhenFalse);
2765                 uninitsWhenFalse.assign(uninitsWhenTrue);
2766                 uninitsWhenTrue.assign(t);
2767                 break;
2768             case PREINC: case POSTINC:
2769             case PREDEC: case POSTDEC:
2770                 scanExpr(tree.arg);
2771                 letInit(tree.arg);
2772                 break;
2773             default:
2774                 scanExpr(tree.arg);
2775             }
2776         }
2777 
2778         public void visitBinary(JCBinary tree) {
2779             switch (tree.getTag()) {
2780             case AND:
2781                 scanCond(tree.lhs);
2782                 final Bits initsWhenFalseLeft = new Bits(initsWhenFalse);
2783                 final Bits uninitsWhenFalseLeft = new Bits(uninitsWhenFalse);
2784                 inits.assign(initsWhenTrue);
2785                 uninits.assign(uninitsWhenTrue);
2786                 scanCond(tree.rhs);
2787                 initsWhenFalse.andSet(initsWhenFalseLeft);
2788                 uninitsWhenFalse.andSet(uninitsWhenFalseLeft);
2789                 break;
2790             case OR:
2791                 scanCond(tree.lhs);
2792                 final Bits initsWhenTrueLeft = new Bits(initsWhenTrue);
2793                 final Bits uninitsWhenTrueLeft = new Bits(uninitsWhenTrue);
2794                 inits.assign(initsWhenFalse);
2795                 uninits.assign(uninitsWhenFalse);
2796                 scanCond(tree.rhs);
2797                 initsWhenTrue.andSet(initsWhenTrueLeft);
2798                 uninitsWhenTrue.andSet(uninitsWhenTrueLeft);
2799                 break;
2800             default:
2801                 scanExpr(tree.lhs);
2802                 scanExpr(tree.rhs);
2803             }
2804         }
2805 
2806         public void visitIdent(JCIdent tree) {
2807             if (tree.sym.kind == VAR) {
2808                 checkInit(tree.pos(), (VarSymbol)tree.sym);
2809                 referenced(tree.sym);
2810             }
2811             if (tree.name == names._this) {
2812                 checkEmbryonicThisExposure(tree);
2813             }
2814         }
2815 
2816         void referenced(Symbol sym) {
2817             unrefdResources.remove(sym);
2818         }
2819 
2820         public void visitAnnotatedType(JCAnnotatedType tree) {
2821             // annotations don&#39;t get scanned
2822             tree.underlyingType.accept(this);
2823         }
2824 
2825         public void visitModuleDef(JCModuleDecl tree) {
2826             // Do nothing for modules
2827         }
2828 
2829     /**************************************************************************
2830      * main method
2831      *************************************************************************/
2832 
2833         /** Perform definite assignment/unassignment analysis on a tree.
2834          */
2835         public void analyzeTree(Env&lt;?&gt; env, TreeMaker make) {
2836             analyzeTree(env, env.tree, make);
2837          }
2838 
2839         public void analyzeTree(Env&lt;?&gt; env, JCTree tree, TreeMaker make) {
2840             try {
2841                 startPos = tree.pos().getStartPosition();
2842 
2843                 if (vardecls == null)
2844                     vardecls = new JCVariableDecl[32];
2845                 else
2846                     for (int i=0; i&lt;vardecls.length; i++)
2847                         vardecls[i] = null;
2848                 firstadr = 0;
2849                 nextadr = 0;
2850                 Flow.this.make = make;
2851                 pendingExits = new ListBuffer&lt;&gt;();
2852                 this.classDef = null;
2853                 unrefdResources = WriteableScope.create(env.enclClass.sym);
2854                 scan(tree);
2855             } finally {
2856                 // note that recursive invocations of this method fail hard
2857                 startPos = -1;
2858                 resetBits(inits, uninits, uninitsTry, initsWhenTrue,
2859                         initsWhenFalse, uninitsWhenTrue, uninitsWhenFalse);
2860                 if (vardecls != null) {
2861                     for (int i=0; i&lt;vardecls.length; i++)
2862                         vardecls[i] = null;
2863                 }
2864                 firstadr = 0;
2865                 nextadr = 0;
2866                 Flow.this.make = null;
2867                 pendingExits = null;
2868                 this.classDef = null;
2869                 unrefdResources = null;
2870             }
2871         }
2872     }
2873 
2874     /**
2875      * This pass implements the last step of the dataflow analysis, namely
2876      * the effectively-final analysis check. This checks that every local variable
2877      * reference from a lambda body/local inner class is either final or effectively final.
2878      * Additional this also checks that every variable that is used as an operand to
2879      * try-with-resources is final or effectively final.
2880      * As effectively final variables are marked as such during DA/DU, this pass must run after
2881      * AssignAnalyzer.
2882      */
2883     class CaptureAnalyzer extends BaseAnalyzer {
2884 
2885         JCTree currentTree; //local class or lambda
2886 
2887         @Override
2888         void markDead() {
2889             //do nothing
2890         }
2891 
2892         @SuppressWarnings(&quot;fallthrough&quot;)
2893         void checkEffectivelyFinal(DiagnosticPosition pos, VarSymbol sym) {
2894             if (currentTree != null &amp;&amp;
2895                     sym.owner.kind == MTH &amp;&amp;
2896                     sym.pos &lt; currentTree.getStartPosition()) {
2897                 switch (currentTree.getTag()) {
2898                     case CLASSDEF:
2899                         if (!allowEffectivelyFinalInInnerClasses) {
2900                             if ((sym.flags() &amp; FINAL) == 0) {
2901                                 reportInnerClsNeedsFinalError(pos, sym);
2902                             }
2903                             break;
2904                         }
2905                     case LAMBDA:
2906                         if ((sym.flags() &amp; (EFFECTIVELY_FINAL | FINAL)) == 0) {
2907                            reportEffectivelyFinalError(pos, sym);
2908                         }
2909                 }
2910             }
2911         }
2912 
2913         @SuppressWarnings(&quot;fallthrough&quot;)
2914         void letInit(JCTree tree) {
2915             tree = TreeInfo.skipParens(tree);
2916             if (tree.hasTag(IDENT) || tree.hasTag(SELECT)) {
2917                 Symbol sym = TreeInfo.symbol(tree);
2918                 if (currentTree != null &amp;&amp;
2919                         sym.kind == VAR &amp;&amp;
2920                         sym.owner.kind == MTH &amp;&amp;
2921                         ((VarSymbol)sym).pos &lt; currentTree.getStartPosition()) {
2922                     switch (currentTree.getTag()) {
2923                         case CLASSDEF:
2924                             if (!allowEffectivelyFinalInInnerClasses) {
2925                                 reportInnerClsNeedsFinalError(tree, sym);
2926                                 break;
2927                             }
2928                         case LAMBDA:
2929                             reportEffectivelyFinalError(tree, sym);
2930                     }
2931                 }
2932             }
2933         }
2934 
2935         void reportEffectivelyFinalError(DiagnosticPosition pos, Symbol sym) {
2936             String subKey = currentTree.hasTag(LAMBDA) ?
2937                   &quot;lambda&quot;  : &quot;inner.cls&quot;;
2938             log.error(pos, Errors.CantRefNonEffectivelyFinalVar(sym, diags.fragment(subKey)));
2939         }
2940 
2941         void reportInnerClsNeedsFinalError(DiagnosticPosition pos, Symbol sym) {
2942             log.error(pos,
2943                       Errors.LocalVarAccessedFromIclsNeedsFinal(sym));
2944         }
2945 
2946     /*************************************************************************
2947      * Visitor methods for statements and definitions
2948      *************************************************************************/
2949 
2950         /* ------------ Visitor methods for various sorts of trees -------------*/
2951 
2952         public void visitClassDef(JCClassDecl tree) {
2953             JCTree prevTree = currentTree;
2954             try {
2955                 currentTree = tree.sym.isLocal() ? tree : null;
2956                 super.visitClassDef(tree);
2957             } finally {
2958                 currentTree = prevTree;
2959             }
2960         }
2961 
2962         @Override
2963         public void visitLambda(JCLambda tree) {
2964             JCTree prevTree = currentTree;
2965             try {
2966                 currentTree = tree;
2967                 super.visitLambda(tree);
2968             } finally {
2969                 currentTree = prevTree;
2970             }
2971         }
2972 
2973         @Override
2974         public void visitIdent(JCIdent tree) {
2975             if (tree.sym.kind == VAR) {
2976                 checkEffectivelyFinal(tree, (VarSymbol)tree.sym);
2977             }
2978         }
2979 
2980         public void visitAssign(JCAssign tree) {
2981             JCTree lhs = TreeInfo.skipParens(tree.lhs);
2982             if (!(lhs instanceof JCIdent)) {
2983                 scan(lhs);
2984             }
2985             scan(tree.rhs);
2986             letInit(lhs);
2987         }
2988 
2989         public void visitAssignop(JCAssignOp tree) {
2990             scan(tree.lhs);
2991             scan(tree.rhs);
2992             letInit(tree.lhs);
2993         }
2994 
2995         public void visitUnary(JCUnary tree) {
2996             switch (tree.getTag()) {
2997                 case PREINC: case POSTINC:
2998                 case PREDEC: case POSTDEC:
2999                     scan(tree.arg);
3000                     letInit(tree.arg);
3001                     break;
3002                 default:
3003                     scan(tree.arg);
3004             }
3005         }
3006 
3007         public void visitTry(JCTry tree) {
3008             for (JCTree resource : tree.resources) {
3009                 if (!resource.hasTag(VARDEF)) {
3010                     Symbol var = TreeInfo.symbol(resource);
3011                     if (var != null &amp;&amp; (var.flags() &amp; (FINAL | EFFECTIVELY_FINAL)) == 0) {
3012                         log.error(resource.pos(), Errors.TryWithResourcesExprEffectivelyFinalVar(var));
3013                     }
3014                 }
3015             }
3016             super.visitTry(tree);
3017         }
3018 
3019         @Override
3020         public void visitYield(JCYield tree) {
3021             scan(tree.value);
3022         }
3023 
3024         public void visitModuleDef(JCModuleDecl tree) {
3025             // Do nothing for modules
3026         }
3027 
3028     /**************************************************************************
3029      * main method
3030      *************************************************************************/
3031 
3032         /** Perform definite assignment/unassignment analysis on a tree.
3033          */
3034         public void analyzeTree(Env&lt;AttrContext&gt; env, TreeMaker make) {
3035             analyzeTree(env, env.tree, make);
3036         }
3037         public void analyzeTree(Env&lt;AttrContext&gt; env, JCTree tree, TreeMaker make) {
3038             try {
3039                 attrEnv = env;
3040                 Flow.this.make = make;
3041                 pendingExits = new ListBuffer&lt;&gt;();
3042                 scan(tree);
3043             } finally {
3044                 pendingExits = null;
3045                 Flow.this.make = null;
3046             }
3047         }
3048     }
3049 
3050     enum Liveness {
3051         ALIVE {
3052             @Override
3053             public Liveness or(Liveness other) {
3054                 return this;
3055             }
3056             @Override
3057             public Liveness and(Liveness other) {
3058                 return other;
3059             }
3060         },
3061         DEAD {
3062             @Override
3063             public Liveness or(Liveness other) {
3064                 return other;
3065             }
3066             @Override
3067             public Liveness and(Liveness other) {
3068                 return this;
3069             }
3070         },
3071         RECOVERY {
3072             @Override
3073             public Liveness or(Liveness other) {
3074                 if (other == ALIVE) {
3075                     return ALIVE;
3076                 } else {
3077                     return this;
3078                 }
3079             }
3080             @Override
3081             public Liveness and(Liveness other) {
3082                 if (other == DEAD) {
3083                     return DEAD;
3084                 } else {
3085                     return this;
3086                 }
3087             }
3088         };
3089 
3090         public abstract Liveness or(Liveness other);
3091         public abstract Liveness and(Liveness other);
3092         public Liveness or(boolean value) {
3093             return or(from(value));
3094         }
3095         public Liveness and(boolean value) {
3096             return and(from(value));
3097         }
3098         public static Liveness from(boolean value) {
3099             return value ? ALIVE : DEAD;
3100         }
3101     }
3102 
3103 }
    </pre>
  </body>
</html>
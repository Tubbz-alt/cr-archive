<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * ASM: a very small and fast Java bytecode manipulation framework
  32  * Copyright (c) 2000-2011 INRIA, France Telecom
  33  * All rights reserved.
  34  *
  35  * Redistribution and use in source and binary forms, with or without
  36  * modification, are permitted provided that the following conditions
  37  * are met:
  38  * 1. Redistributions of source code must retain the above copyright
  39  *    notice, this list of conditions and the following disclaimer.
  40  * 2. Redistributions in binary form must reproduce the above copyright
  41  *    notice, this list of conditions and the following disclaimer in the
  42  *    documentation and/or other materials provided with the distribution.
  43  * 3. Neither the name of the copyright holders nor the names of its
  44  *    contributors may be used to endorse or promote products derived from
  45  *    this software without specific prior written permission.
  46  *
  47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  57  * THE POSSIBILITY OF SUCH DAMAGE.
  58  */
  59 package jdk.internal.org.objectweb.asm.util;
  60 
  61 import java.io.FileInputStream;
  62 import java.io.IOException;
  63 import java.io.InputStream;
  64 import java.io.PrintWriter;
  65 import java.util.ArrayList;
  66 import java.util.HashMap;
  67 import java.util.List;
  68 import java.util.Map;
  69 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  70 import jdk.internal.org.objectweb.asm.Attribute;
  71 import jdk.internal.org.objectweb.asm.ClassReader;
  72 import jdk.internal.org.objectweb.asm.ClassVisitor;
  73 import jdk.internal.org.objectweb.asm.FieldVisitor;
  74 import jdk.internal.org.objectweb.asm.Label;
  75 import jdk.internal.org.objectweb.asm.MethodVisitor;
  76 import jdk.internal.org.objectweb.asm.ModuleVisitor;
  77 import jdk.internal.org.objectweb.asm.Opcodes;
  78 import jdk.internal.org.objectweb.asm.Type;
  79 import jdk.internal.org.objectweb.asm.TypePath;
  80 import jdk.internal.org.objectweb.asm.TypeReference;
  81 import jdk.internal.org.objectweb.asm.tree.ClassNode;
  82 import jdk.internal.org.objectweb.asm.tree.MethodNode;
  83 import jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode;
  84 import jdk.internal.org.objectweb.asm.tree.analysis.Analyzer;
  85 import jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException;
  86 import jdk.internal.org.objectweb.asm.tree.analysis.BasicValue;
  87 import jdk.internal.org.objectweb.asm.tree.analysis.Frame;
  88 import jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier;
  89 
  90 /**
  91  * A {@link ClassVisitor} that checks that its methods are properly used. More precisely this class
  92  * adapter checks each method call individually, based &lt;i&gt;only&lt;/i&gt; on its arguments, but does
  93  * &lt;i&gt;not&lt;/i&gt; check the &lt;i&gt;sequence&lt;/i&gt; of method calls. For example, the invalid sequence {@code
  94  * visitField(ACC_PUBLIC, &quot;i&quot;, &quot;I&quot;, null)} {@code visitField(ACC_PUBLIC, &quot;i&quot;, &quot;D&quot;, null)} will
  95  * &lt;i&gt;not&lt;/i&gt; be detected by this class adapter.
  96  *
  97  * &lt;p&gt;&lt;code&gt;CheckClassAdapter&lt;/code&gt; can be also used to verify bytecode transformations in order to
  98  * make sure that the transformed bytecode is sane. For example:
  99  *
 100  * &lt;pre&gt;
 101  * InputStream inputStream = ...; // get bytes for the source class
 102  * ClassReader classReader = new ClassReader(inputStream);
 103  * ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);
 104  * ClassVisitor classVisitor = new &lt;b&gt;MyClassAdapter&lt;/b&gt;(new CheckClassAdapter(classWriter, true));
 105  * classReader.accept(classVisitor, 0);
 106  *
 107  * StringWriter stringWriter = new StringWriter();
 108  * PrintWriter printWriter = new PrintWriter(stringWriter);
 109  * CheckClassAdapter.verify(new ClassReader(classWriter.toByteArray()), false, printWriter);
 110  * assertTrue(stringWriter.toString().isEmpty());
 111  * &lt;/pre&gt;
 112  *
 113  * &lt;p&gt;The above code pass the transformed bytecode through a &lt;code&gt;CheckClassAdapter&lt;/code&gt;, with
 114  * data flow checks enabled. These checks are not exactly the same as the JVM verification, but
 115  * provide some basic type checking for each method instruction. If the bytecode has errors, the
 116  * output text shows the erroneous instruction number, and a dump of the failed method with
 117  * information about the type of the local variables and of the operand stack slots for each
 118  * instruction. For example (format is - insnNumber locals : stack):
 119  *
 120  * &lt;pre&gt;
 121  * jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 71: Expected I, but found .
 122  *   at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:...)
 123  *   at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:...)
 124  * ...
 125  * remove()V
 126  * 00000 LinkedBlockingQueue$Itr . . . . . . . .  : ICONST_0
 127  * 00001 LinkedBlockingQueue$Itr . . . . . . . .  : I ISTORE 2
 128  * 00001 LinkedBlockingQueue$Itr &lt;b&gt;.&lt;/b&gt; I . . . . . .  :
 129  * ...
 130  * 00071 LinkedBlockingQueue$Itr &lt;b&gt;.&lt;/b&gt; I . . . . . .  : ILOAD 1
 131  * 00072 &lt;b&gt;?&lt;/b&gt; INVOKESPECIAL java/lang/Integer.&amp;lt;init&amp;gt; (I)V
 132  * ...
 133  * &lt;/pre&gt;
 134  *
 135  * &lt;p&gt;The above output shows that the local variable 1, loaded by the &lt;code&gt;ILOAD 1&lt;/code&gt;
 136  * instruction at position &lt;code&gt;00071&lt;/code&gt; is not initialized, whereas the local variable 2 is
 137  * initialized and contains an int value.
 138  *
 139  * @author Eric Bruneton
 140  */
 141 public class CheckClassAdapter extends ClassVisitor {
 142 
 143     private static final String ERROR_AT = &quot;: error at index &quot;;
 144 
 145     /** Whether the bytecode must be checked with a BasicVerifier. */
 146     private boolean checkDataFlow;
 147 
 148     /** The class version number. */
 149     private int version;
 150 
 151     /** Whether the {@link #visit} method has been called. */
 152     private boolean visitCalled;
 153 
 154     /** Whether the {@link #visitModule} method has been called. */
 155     private boolean visitModuleCalled;
 156 
 157     /** Whether the {@link #visitSource} method has been called. */
 158     private boolean visitSourceCalled;
 159 
 160     /** Whether the {@link #visitOuterClass} method has been called. */
 161     private boolean visitOuterClassCalled;
 162 
 163     /** Whether the {@link #visitNestHost} method has been called. */
 164     private boolean visitNestHostCalled;
 165 
 166     /**
 167       * The common package of all the nest members. Not {@literal null} if the visitNestMember method
 168       * has been called.
 169       */
 170     private String nestMemberPackageName;
 171 
 172     /** Whether the {@link #visitEnd} method has been called. */
 173     private boolean visitEndCalled;
 174 
 175     /** The index of the instruction designated by each visited label so far. */
 176     private Map&lt;Label, Integer&gt; labelInsnIndices;
 177 
 178     // -----------------------------------------------------------------------------------------------
 179     // Constructors
 180     // -----------------------------------------------------------------------------------------------
 181 
 182     /**
 183       * Constructs a new {@link CheckClassAdapter}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;.
 184       * Instead, they must use the {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
 185       *
 186       * @param classVisitor the class visitor to which this adapter must delegate calls.
 187       */
 188     public CheckClassAdapter(final ClassVisitor classVisitor) {
 189         this(classVisitor, true);
 190     }
 191 
 192     /**
 193       * Constructs a new {@link CheckClassAdapter}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;.
 194       * Instead, they must use the {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
 195       *
 196       * @param classVisitor the class visitor to which this adapter must delegate calls.
 197       * @param checkDataFlow whether to perform basic data flow checks. This option requires valid
 198       *     maxLocals and maxStack values.
 199       * @throws IllegalStateException If a subclass calls this constructor.
 200       */
 201     public CheckClassAdapter(final ClassVisitor classVisitor, final boolean checkDataFlow) {
 202         this(Opcodes.ASM7, classVisitor, checkDataFlow);
 203         if (getClass() != CheckClassAdapter.class) {
 204             throw new IllegalStateException();
 205         }
 206     }
 207 
 208     /**
 209       * Constructs a new {@link CheckClassAdapter}.
 210       *
 211       * @param api the ASM API version implemented by this visitor. Must be one of {@link
 212       *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
 213       * @param classVisitor the class visitor to which this adapter must delegate calls.
 214       * @param checkDataFlow {@literal true} to perform basic data flow checks, or {@literal false} to
 215       *     not perform any data flow check (see {@link CheckMethodAdapter}). This option requires
 216       *     valid maxLocals and maxStack values.
 217       */
 218     protected CheckClassAdapter(
 219             final int api, final ClassVisitor classVisitor, final boolean checkDataFlow) {
 220         super(api, classVisitor);
 221         this.labelInsnIndices = new HashMap&lt;Label, Integer&gt;();
 222         this.checkDataFlow = checkDataFlow;
 223     }
 224 
 225     // -----------------------------------------------------------------------------------------------
 226     // Implementation of the ClassVisitor interface
 227     // -----------------------------------------------------------------------------------------------
 228 
 229     @Override
 230     public void visit(
 231             final int version,
 232             final int access,
 233             final String name,
 234             final String signature,
 235             final String superName,
 236             final String[] interfaces) {
 237         if (visitCalled) {
 238             throw new IllegalStateException(&quot;visit must be called only once&quot;);
 239         }
 240         visitCalled = true;
 241         checkState();
 242         checkAccess(
 243                 access,
 244                 Opcodes.ACC_PUBLIC
 245                         | Opcodes.ACC_FINAL
 246                         | Opcodes.ACC_SUPER
 247                         | Opcodes.ACC_INTERFACE
 248                         | Opcodes.ACC_ABSTRACT
 249                         | Opcodes.ACC_SYNTHETIC
 250                         | Opcodes.ACC_ANNOTATION
 251                         | Opcodes.ACC_ENUM
 252                         | Opcodes.ACC_DEPRECATED
 253                         | Opcodes.ACC_MODULE);
 254         if (name == null) {
 255             throw new IllegalArgumentException(&quot;Illegal class name (null)&quot;);
 256         }
 257         if (!name.endsWith(&quot;package-info&quot;) &amp;&amp; !name.endsWith(&quot;module-info&quot;)) {
 258             CheckMethodAdapter.checkInternalName(version, name, &quot;class name&quot;);
 259         }
 260         if (&quot;java/lang/Object&quot;.equals(name)) {
 261             if (superName != null) {
 262                 throw new IllegalArgumentException(
 263                         &quot;The super class name of the Object class must be &#39;null&#39;&quot;);
 264             }
 265         } else if (name.endsWith(&quot;module-info&quot;)) {
 266             if (superName != null) {
 267                 throw new IllegalArgumentException(
 268                         &quot;The super class name of a module-info class must be &#39;null&#39;&quot;);
 269             }
 270         } else {
 271             CheckMethodAdapter.checkInternalName(version, superName, &quot;super class name&quot;);
 272         }
 273         if (signature != null) {
 274             checkClassSignature(signature);
 275         }
 276         if ((access &amp; Opcodes.ACC_INTERFACE) != 0 &amp;&amp; !&quot;java/lang/Object&quot;.equals(superName)) {
 277             throw new IllegalArgumentException(
 278                     &quot;The super class name of interfaces must be &#39;java/lang/Object&#39;&quot;);
 279         }
 280         if (interfaces != null) {
 281             for (int i = 0; i &lt; interfaces.length; ++i) {
 282                 CheckMethodAdapter.checkInternalName(
 283                         version, interfaces[i], &quot;interface name at index &quot; + i);
 284             }
 285         }
 286         this.version = version;
 287         super.visit(version, access, name, signature, superName, interfaces);
 288     }
 289 
 290     @Override
 291     public void visitSource(final String file, final String debug) {
 292         checkState();
 293         if (visitSourceCalled) {
 294             throw new IllegalStateException(&quot;visitSource can be called only once.&quot;);
 295         }
 296         visitSourceCalled = true;
 297         super.visitSource(file, debug);
 298     }
 299 
 300     @Override
 301     public ModuleVisitor visitModule(final String name, final int access, final String version) {
 302         checkState();
 303         if (visitModuleCalled) {
 304             throw new IllegalStateException(&quot;visitModule can be called only once.&quot;);
 305         }
 306         visitModuleCalled = true;
 307         checkFullyQualifiedName(this.version, name, &quot;module name&quot;);
 308         checkAccess(access, Opcodes.ACC_OPEN | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_MANDATED);
 309         CheckModuleAdapter checkModuleAdapter =
 310                 new CheckModuleAdapter(
 311                         api, super.visitModule(name, access, version), (access &amp; Opcodes.ACC_OPEN) != 0);
 312         checkModuleAdapter.classVersion = this.version;
 313         return checkModuleAdapter;
 314     }
 315 
 316     @Override
 317     public void visitNestHost(final String nestHost) {
 318         checkState();
 319         CheckMethodAdapter.checkInternalName(version, nestHost, &quot;nestHost&quot;);
 320         if (visitNestHostCalled) {
 321             throw new IllegalStateException(&quot;visitNestHost can be called only once.&quot;);
 322         }
 323         if (nestMemberPackageName != null) {
 324             throw new IllegalStateException(&quot;visitNestHost and visitNestMember are mutually exclusive.&quot;);
 325         }
 326         visitNestHostCalled = true;
 327         super.visitNestHost(nestHost);
 328     }
 329 
 330     @Override
 331     public void visitNestMember(final String nestMember) {
 332         checkState();
 333         CheckMethodAdapter.checkInternalName(version, nestMember, &quot;nestMember&quot;);
 334         if (visitNestHostCalled) {
 335             throw new IllegalStateException(
 336                     &quot;visitMemberOfNest and visitNestHost are mutually exclusive.&quot;);
 337         }
 338         String packageName = packageName(nestMember);
 339         if (nestMemberPackageName == null) {
 340             nestMemberPackageName = packageName;
 341         } else if (!nestMemberPackageName.equals(packageName)) {
 342             throw new IllegalStateException(
 343                     &quot;nest member &quot; + nestMember + &quot; should be in the package &quot; + nestMemberPackageName);
 344         }
 345         super.visitNestMember(nestMember);
 346     }
 347 
 348     @Override
 349     public void visitOuterClass(final String owner, final String name, final String descriptor) {
 350         checkState();
 351         if (visitOuterClassCalled) {
 352             throw new IllegalStateException(&quot;visitOuterClass can be called only once.&quot;);
 353         }
 354         visitOuterClassCalled = true;
 355         if (owner == null) {
 356             throw new IllegalArgumentException(&quot;Illegal outer class owner&quot;);
 357         }
 358         if (descriptor != null) {
 359             CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
 360         }
 361         super.visitOuterClass(owner, name, descriptor);
 362     }
 363 
 364     @Override
 365     public void visitInnerClass(
 366             final String name, final String outerName, final String innerName, final int access) {
 367         checkState();
 368         CheckMethodAdapter.checkInternalName(version, name, &quot;class name&quot;);
 369         if (outerName != null) {
 370             CheckMethodAdapter.checkInternalName(version, outerName, &quot;outer class name&quot;);
 371         }
 372         if (innerName != null) {
 373             int startIndex = 0;
 374             while (startIndex &lt; innerName.length() &amp;&amp; Character.isDigit(innerName.charAt(startIndex))) {
 375                 startIndex++;
 376             }
 377             if (startIndex == 0 || startIndex &lt; innerName.length()) {
 378                 CheckMethodAdapter.checkIdentifier(version, innerName, startIndex, -1, &quot;inner class name&quot;);
 379             }
 380         }
 381         checkAccess(
 382                 access,
 383                 Opcodes.ACC_PUBLIC
 384                         | Opcodes.ACC_PRIVATE
 385                         | Opcodes.ACC_PROTECTED
 386                         | Opcodes.ACC_STATIC
 387                         | Opcodes.ACC_FINAL
 388                         | Opcodes.ACC_INTERFACE
 389                         | Opcodes.ACC_ABSTRACT
 390                         | Opcodes.ACC_SYNTHETIC
 391                         | Opcodes.ACC_ANNOTATION
 392                         | Opcodes.ACC_ENUM);
 393         super.visitInnerClass(name, outerName, innerName, access);
 394     }
 395 
 396     @Override
 397     public FieldVisitor visitField(
 398             final int access,
 399             final String name,
 400             final String descriptor,
 401             final String signature,
 402             final Object value) {
 403         checkState();
 404         checkAccess(
 405                 access,
 406                 Opcodes.ACC_PUBLIC
 407                         | Opcodes.ACC_PRIVATE
 408                         | Opcodes.ACC_PROTECTED
 409                         | Opcodes.ACC_STATIC
 410                         | Opcodes.ACC_FINAL
 411                         | Opcodes.ACC_VOLATILE
 412                         | Opcodes.ACC_TRANSIENT
 413                         | Opcodes.ACC_SYNTHETIC
 414                         | Opcodes.ACC_ENUM
 415                         | Opcodes.ACC_DEPRECATED);
 416         CheckMethodAdapter.checkUnqualifiedName(version, name, &quot;field name&quot;);
 417         CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid = */ false);
 418         if (signature != null) {
 419             checkFieldSignature(signature);
 420         }
 421         if (value != null) {
 422             CheckMethodAdapter.checkConstant(value);
 423         }
 424         return new CheckFieldAdapter(api, super.visitField(access, name, descriptor, signature, value));
 425     }
 426 
 427     @Override
 428     public MethodVisitor visitMethod(
 429             final int access,
 430             final String name,
 431             final String descriptor,
 432             final String signature,
 433             final String[] exceptions) {
 434         checkState();
 435         checkAccess(
 436                 access,
 437                 Opcodes.ACC_PUBLIC
 438                         | Opcodes.ACC_PRIVATE
 439                         | Opcodes.ACC_PROTECTED
 440                         | Opcodes.ACC_STATIC
 441                         | Opcodes.ACC_FINAL
 442                         | Opcodes.ACC_SYNCHRONIZED
 443                         | Opcodes.ACC_BRIDGE
 444                         | Opcodes.ACC_VARARGS
 445                         | Opcodes.ACC_NATIVE
 446                         | Opcodes.ACC_ABSTRACT
 447                         | Opcodes.ACC_STRICT
 448                         | Opcodes.ACC_SYNTHETIC
 449                         | Opcodes.ACC_DEPRECATED);
 450         if (!&quot;&lt;init&gt;&quot;.equals(name) &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name)) {
 451             CheckMethodAdapter.checkMethodIdentifier(version, name, &quot;method name&quot;);
 452         }
 453         CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
 454         if (signature != null) {
 455             checkMethodSignature(signature);
 456         }
 457         if (exceptions != null) {
 458             for (int i = 0; i &lt; exceptions.length; ++i) {
 459                 CheckMethodAdapter.checkInternalName(
 460                         version, exceptions[i], &quot;exception name at index &quot; + i);
 461             }
 462         }
 463         CheckMethodAdapter checkMethodAdapter;
 464         if (checkDataFlow) {
 465             checkMethodAdapter =
 466                     new CheckMethodAdapter(
 467                             api,
 468                             access,
 469                             name,
 470                             descriptor,
 471                             super.visitMethod(access, name, descriptor, signature, exceptions),
 472                             labelInsnIndices);
 473         } else {
 474             checkMethodAdapter =
 475                     new CheckMethodAdapter(
 476                             api,
 477                             super.visitMethod(access, name, descriptor, signature, exceptions),
 478                             labelInsnIndices);
 479         }
 480         checkMethodAdapter.version = version;
 481         return checkMethodAdapter;
 482     }
 483 
 484     @Override
 485     public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
 486         checkState();
 487         CheckMethodAdapter.checkDescriptor(version, descriptor, false);
 488         return new CheckAnnotationAdapter(super.visitAnnotation(descriptor, visible));
 489     }
 490 
 491     @Override
 492     public AnnotationVisitor visitTypeAnnotation(
 493             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 494         checkState();
 495         int sort = new TypeReference(typeRef).getSort();
 496         if (sort != TypeReference.CLASS_TYPE_PARAMETER
 497                 &amp;&amp; sort != TypeReference.CLASS_TYPE_PARAMETER_BOUND
 498                 &amp;&amp; sort != TypeReference.CLASS_EXTENDS) {
 499             throw new IllegalArgumentException(
 500                     &quot;Invalid type reference sort 0x&quot; + Integer.toHexString(sort));
 501         }
 502         checkTypeRef(typeRef);
 503         CheckMethodAdapter.checkDescriptor(version, descriptor, false);
 504         return new CheckAnnotationAdapter(
 505                 super.visitTypeAnnotation(typeRef, typePath, descriptor, visible));
 506     }
 507 
 508     @Override
 509     public void visitAttribute(final Attribute attribute) {
 510         checkState();
 511         if (attribute == null) {
 512             throw new IllegalArgumentException(&quot;Invalid attribute (must not be null)&quot;);
 513         }
 514         super.visitAttribute(attribute);
 515     }
 516 
 517     @Override
 518     public void visitEnd() {
 519         checkState();
 520         visitEndCalled = true;
 521         super.visitEnd();
 522     }
 523 
 524     // -----------------------------------------------------------------------------------------------
 525     // Utility methods
 526     // -----------------------------------------------------------------------------------------------
 527 
 528     /** Checks that the visit method has been called and that visitEnd has not been called. */
 529     private void checkState() {
 530         if (!visitCalled) {
 531             throw new IllegalStateException(&quot;Cannot visit member before visit has been called.&quot;);
 532         }
 533         if (visitEndCalled) {
 534             throw new IllegalStateException(&quot;Cannot visit member after visitEnd has been called.&quot;);
 535         }
 536     }
 537 
 538     /**
 539       * Checks that the given access flags do not contain invalid flags. This method also checks that
 540       * mutually incompatible flags are not set simultaneously.
 541       *
 542       * @param access the access flags to be checked.
 543       * @param possibleAccess the valid access flags.
 544       */
 545     static void checkAccess(final int access, final int possibleAccess) {
 546         if ((access &amp; ~possibleAccess) != 0) {
 547             throw new IllegalArgumentException(&quot;Invalid access flags: &quot; + access);
 548         }
 549         int publicProtectedPrivate = Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE;
 550         if (Integer.bitCount(access &amp; publicProtectedPrivate) &gt; 1) {
 551             throw new IllegalArgumentException(
 552                     &quot;public, protected and private are mutually exclusive: &quot; + access);
 553         }
 554         if (Integer.bitCount(access &amp; (Opcodes.ACC_FINAL | Opcodes.ACC_ABSTRACT)) &gt; 1) {
 555             throw new IllegalArgumentException(&quot;final and abstract are mutually exclusive: &quot; + access);
 556         }
 557     }
 558 
 559     /**
 560       * Checks that the given name is a fully qualified name, using dots.
 561       *
 562       * @param version the class version.
 563       * @param name the name to be checked.
 564       * @param source the source of &#39;name&#39; (e.g &#39;module&#39; for a module name).
 565       */
 566     static void checkFullyQualifiedName(final int version, final String name, final String source) {
 567         try {
 568             int startIndex = 0;
 569             int dotIndex;
 570             while ((dotIndex = name.indexOf(&#39;.&#39;, startIndex + 1)) != -1) {
 571                 CheckMethodAdapter.checkIdentifier(version, name, startIndex, dotIndex, null);
 572                 startIndex = dotIndex + 1;
 573             }
 574             CheckMethodAdapter.checkIdentifier(version, name, startIndex, name.length(), null);
 575         } catch (IllegalArgumentException e) {
 576             throw new IllegalArgumentException(
 577                     &quot;Invalid &quot; + source + &quot; (must be a fully qualified name): &quot; + name, e);
 578         }
 579     }
 580 
 581     /**
 582       * Checks a class signature.
 583       *
 584       * @param signature a string containing the signature that must be checked.
 585       */
 586     public static void checkClassSignature(final String signature) {
 587         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 588         // ClassSignature:
 589         //   [TypeParameters] SuperclassSignature SuperinterfaceSignature*
 590         // SuperclassSignature:
 591         //   ClassTypeSignature
 592         // SuperinterfaceSignature:
 593         //   ClassTypeSignature
 594         int pos = 0;
 595         if (getChar(signature, 0) == &#39;&lt;&#39;) {
 596             pos = checkTypeParameters(signature, pos);
 597         }
 598         pos = checkClassTypeSignature(signature, pos);
 599         while (getChar(signature, pos) == &#39;L&#39; || getChar(signature, pos) == &#39;Q&#39;) {
 600             pos = checkClassTypeSignature(signature, pos);
 601         }
 602         if (pos != signature.length()) {
 603             throw new IllegalArgumentException(signature + ERROR_AT + pos);
 604         }
 605     }
 606 
 607     /**
 608       * Checks a method signature.
 609       *
 610       * @param signature a string containing the signature that must be checked.
 611       */
 612     public static void checkMethodSignature(final String signature) {
 613         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 614         // MethodSignature:
 615         //   [TypeParameters] ( JavaTypeSignature* ) Result ThrowsSignature*
 616         // Result:
 617         //   JavaTypeSignature
 618         //   VoidDescriptor
 619         // ThrowsSignature:
 620         //   ^ ClassTypeSignature
 621         //   ^ TypeVariableSignature
 622         int pos = 0;
 623         if (getChar(signature, 0) == &#39;&lt;&#39;) {
 624             pos = checkTypeParameters(signature, pos);
 625         }
 626         pos = checkChar(&#39;(&#39;, signature, pos);
 627         while (&quot;ZCBSIFJDLQ[T&quot;.indexOf(getChar(signature, pos)) != -1) {
 628             pos = checkJavaTypeSignature(signature, pos);
 629         }
 630         pos = checkChar(&#39;)&#39;, signature, pos);
 631         if (getChar(signature, pos) == &#39;V&#39;) {
 632             ++pos;
 633         } else {
 634             pos = checkJavaTypeSignature(signature, pos);
 635         }
 636         while (getChar(signature, pos) == &#39;^&#39;) {
 637             ++pos;
 638             if (getChar(signature, pos) == &#39;L&#39; || getChar(signature, pos) == &#39;Q&#39;) {
 639                 pos = checkClassTypeSignature(signature, pos);
 640             } else {
 641                 pos = checkTypeVariableSignature(signature, pos);
 642             }
 643         }
 644         if (pos != signature.length()) {
 645             throw new IllegalArgumentException(signature + ERROR_AT + pos);
 646         }
 647     }
 648 
 649     /**
 650       * Checks a field signature.
 651       *
 652       * @param signature a string containing the signature that must be checked.
 653       */
 654     public static void checkFieldSignature(final String signature) {
 655         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 656         // FieldSignature:
 657         //   ReferenceTypeSignature
 658         int pos = checkReferenceTypeSignature(signature, 0);
 659         if (pos != signature.length()) {
 660             throw new IllegalArgumentException(signature + ERROR_AT + pos);
 661         }
 662     }
 663 
 664     /**
 665       * Checks the type parameters of a class or method signature.
 666       *
 667       * @param signature a string containing the signature that must be checked.
 668       * @param startPos index of first character to be checked.
 669       * @return the index of the first character after the checked part.
 670       */
 671     private static int checkTypeParameters(final String signature, final int startPos) {
 672         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 673         // TypeParameters:
 674         //   &lt; TypeParameter TypeParameter* &gt;
 675         int pos = startPos;
 676         pos = checkChar(&#39;&lt;&#39;, signature, pos);
 677         pos = checkTypeParameter(signature, pos);
 678         while (getChar(signature, pos) != &#39;&gt;&#39;) {
 679             pos = checkTypeParameter(signature, pos);
 680         }
 681         return pos + 1;
 682     }
 683 
 684     /**
 685       * Checks a type parameter of a class or method signature.
 686       *
 687       * @param signature a string containing the signature that must be checked.
 688       * @param startPos index of first character to be checked.
 689       * @return the index of the first character after the checked part.
 690       */
 691     private static int checkTypeParameter(final String signature, final int startPos) {
 692         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 693         // TypeParameter:
 694         //   Identifier ClassBound InterfaceBound*
 695         // ClassBound:
 696         //   : [ReferenceTypeSignature]
 697         // InterfaceBound:
 698         //   : ReferenceTypeSignature
 699         int pos = startPos;
 700         pos = checkSignatureIdentifier(signature, pos);
 701         pos = checkChar(&#39;:&#39;, signature, pos);
 702         if (&quot;L[T&quot;.indexOf(getChar(signature, pos)) != -1) {
 703             pos = checkReferenceTypeSignature(signature, pos);
 704         }
 705         while (getChar(signature, pos) == &#39;:&#39;) {
 706             pos = checkReferenceTypeSignature(signature, pos + 1);
 707         }
 708         return pos;
 709     }
 710 
 711     /**
 712       * Checks a reference type signature.
 713       *
 714       * @param signature a string containing the signature that must be checked.
 715       * @param pos index of first character to be checked.
 716       * @return the index of the first character after the checked part.
 717       */
 718     private static int checkReferenceTypeSignature(final String signature, final int pos) {
 719         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 720         // ReferenceTypeSignature:
 721         //   ClassTypeSignature
 722         //   TypeVariableSignature
 723         //   ArrayTypeSignature
 724         // ArrayTypeSignature:
 725         //   [ JavaTypeSignature
 726         switch (getChar(signature, pos)) {
 727             case &#39;L&#39;:
 728                 return checkClassTypeSignature(signature, pos);
 729             case &#39;[&#39;:
 730                 return checkJavaTypeSignature(signature, pos + 1);
 731             default:
 732                 return checkTypeVariableSignature(signature, pos);
 733         }
 734     }
 735 
 736     /**
 737       * Checks a class type signature.
 738       *
 739       * @param signature a string containing the signature that must be checked.
 740       * @param startPos index of first character to be checked.
 741       * @return the index of the first character after the checked part.
 742       */
 743     private static int checkClassTypeSignature(final String signature, final int startPos) {
 744         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 745         // ClassTypeSignature:
 746         //   L [PackageSpecifier] SimpleClassTypeSignature ClassTypeSignatureSuffix* ;
 747         // PackageSpecifier:
 748         //   Identifier / PackageSpecifier*
 749         // SimpleClassTypeSignature:
 750         //   Identifier [TypeArguments]
 751         // ClassTypeSignatureSuffix:
 752         //   . SimpleClassTypeSignature
 753         int pos = startPos;
 754         if (getChar(signature, pos) == &#39;L&#39; || getChar(signature, pos) == &#39;Q&#39;) {
 755             pos = pos + 1;
 756         } else {
 757             throw new IllegalArgumentException(signature + &quot;: &#39;L&#39; or &#39;Q&#39; expected at index &quot; + pos);
 758         }
 759 
 760         pos = checkSignatureIdentifier(signature, pos);
 761         while (getChar(signature, pos) == &#39;/&#39;) {
 762             pos = checkSignatureIdentifier(signature, pos + 1);
 763         }
 764         if (getChar(signature, pos) == &#39;&lt;&#39;) {
 765             pos = checkTypeArguments(signature, pos);
 766         }
 767         while (getChar(signature, pos) == &#39;.&#39;) {
 768             pos = checkSignatureIdentifier(signature, pos + 1);
 769             if (getChar(signature, pos) == &#39;&lt;&#39;) {
 770                 pos = checkTypeArguments(signature, pos);
 771             }
 772         }
 773         return checkChar(&#39;;&#39;, signature, pos);
 774     }
 775 
 776     /**
 777       * Checks the type arguments in a class type signature.
 778       *
 779       * @param signature a string containing the signature that must be checked.
 780       * @param startPos index of first character to be checked.
 781       * @return the index of the first character after the checked part.
 782       */
 783     private static int checkTypeArguments(final String signature, final int startPos) {
 784         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 785         // TypeArguments:
 786         //   &lt; TypeArgument TypeArgument* &gt;
 787         int pos = startPos;
 788         pos = checkChar(&#39;&lt;&#39;, signature, pos);
 789         pos = checkTypeArgument(signature, pos);
 790         while (getChar(signature, pos) != &#39;&gt;&#39;) {
 791             pos = checkTypeArgument(signature, pos);
 792         }
 793         return pos + 1;
 794     }
 795 
 796     /**
 797       * Checks a type argument in a class type signature.
 798       *
 799       * @param signature a string containing the signature that must be checked.
 800       * @param startPos index of first character to be checked.
 801       * @return the index of the first character after the checked part.
 802       */
 803     private static int checkTypeArgument(final String signature, final int startPos) {
 804         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 805         // TypeArgument:
 806         //   [WildcardIndicator] ReferenceTypeSignature
 807         //   *
 808         // WildcardIndicator:
 809         //   +
 810         //   -
 811         int pos = startPos;
 812         char c = getChar(signature, pos);
 813         if (c == &#39;*&#39;) {
 814             return pos + 1;
 815         } else if (c == &#39;+&#39; || c == &#39;-&#39;) {
 816             pos++;
 817         }
 818         return checkReferenceTypeSignature(signature, pos);
 819     }
 820 
 821     /**
 822       * Checks a type variable signature.
 823       *
 824       * @param signature a string containing the signature that must be checked.
 825       * @param startPos index of first character to be checked.
 826       * @return the index of the first character after the checked part.
 827       */
 828     private static int checkTypeVariableSignature(final String signature, final int startPos) {
 829         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 830         // TypeVariableSignature:
 831         //  T Identifier ;
 832         int pos = startPos;
 833         pos = checkChar(&#39;T&#39;, signature, pos);
 834         pos = checkSignatureIdentifier(signature, pos);
 835         return checkChar(&#39;;&#39;, signature, pos);
 836     }
 837 
 838     /**
 839       * Checks a Java type signature.
 840       *
 841       * @param signature a string containing the signature that must be checked.
 842       * @param startPos index of first character to be checked.
 843       * @return the index of the first character after the checked part.
 844       */
 845     private static int checkJavaTypeSignature(final String signature, final int startPos) {
 846         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 847         // JavaTypeSignature:
 848         //   ReferenceTypeSignature
 849         //   BaseType
 850         // BaseType:
 851         //   (one of)
 852         //   B C D F I J S Z
 853         int pos = startPos;
 854         switch (getChar(signature, pos)) {
 855             case &#39;B&#39;:
 856             case &#39;C&#39;:
 857             case &#39;D&#39;:
 858             case &#39;F&#39;:
 859             case &#39;I&#39;:
 860             case &#39;J&#39;:
 861             case &#39;S&#39;:
 862             case &#39;Z&#39;:
 863                 return pos + 1;
 864             default:
 865                 return checkReferenceTypeSignature(signature, pos);
 866         }
 867     }
 868 
 869     /**
 870       * Checks an identifier.
 871       *
 872       * @param signature a string containing the signature that must be checked.
 873       * @param startPos index of first character to be checked.
 874       * @return the index of the first character after the checked part.
 875       */
 876     private static int checkSignatureIdentifier(final String signature, final int startPos) {
 877         int pos = startPos;
 878         while (pos &lt; signature.length() &amp;&amp; &quot;.;[/&lt;&gt;:&quot;.indexOf(signature.codePointAt(pos)) == -1) {
 879             pos = signature.offsetByCodePoints(pos, 1);
 880         }
 881         if (pos == startPos) {
 882             throw new IllegalArgumentException(signature + &quot;: identifier expected at index &quot; + startPos);
 883         }
 884         return pos;
 885     }
 886 
 887     /**
 888       * Checks a single character.
 889       *
 890       * @param c a character.
 891       * @param signature a string containing the signature that must be checked.
 892       * @param pos index of first character to be checked.
 893       * @return the index of the first character after the checked part.
 894       */
 895     private static int checkChar(final char c, final String signature, final int pos) {
 896         if (getChar(signature, pos) == c) {
 897             return pos + 1;
 898         }
 899         throw new IllegalArgumentException(signature + &quot;: &#39;&quot; + c + &quot;&#39; expected at index &quot; + pos);
 900     }
 901 
 902     /**
 903       * Returns the string character at the given index, or 0.
 904       *
 905       * @param string a string.
 906       * @param pos an index in &#39;string&#39;.
 907       * @return the character at the given index, or 0 if there is no such character.
 908       */
 909     private static char getChar(final String string, final int pos) {
 910         return pos &lt; string.length() ? string.charAt(pos) : (char) 0;
 911     }
 912 
 913     /**
 914       * Checks the reference to a type in a type annotation.
 915       *
 916       * @param typeRef a reference to an annotated type.
 917       */
 918     static void checkTypeRef(final int typeRef) {
 919         int mask = 0;
 920         switch (typeRef &gt;&gt;&gt; 24) {
 921             case TypeReference.CLASS_TYPE_PARAMETER:
 922             case TypeReference.METHOD_TYPE_PARAMETER:
 923             case TypeReference.METHOD_FORMAL_PARAMETER:
 924                 mask = 0xFFFF0000;
 925                 break;
 926             case TypeReference.FIELD:
 927             case TypeReference.METHOD_RETURN:
 928             case TypeReference.METHOD_RECEIVER:
 929             case TypeReference.LOCAL_VARIABLE:
 930             case TypeReference.RESOURCE_VARIABLE:
 931             case TypeReference.INSTANCEOF:
 932             case TypeReference.NEW:
 933             case TypeReference.CONSTRUCTOR_REFERENCE:
 934             case TypeReference.METHOD_REFERENCE:
 935                 mask = 0xFF000000;
 936                 break;
 937             case TypeReference.CLASS_EXTENDS:
 938             case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
 939             case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
 940             case TypeReference.THROWS:
 941             case TypeReference.EXCEPTION_PARAMETER:
 942                 mask = 0xFFFFFF00;
 943                 break;
 944             case TypeReference.CAST:
 945             case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
 946             case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
 947             case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
 948             case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
 949                 mask = 0xFF0000FF;
 950                 break;
 951             default:
 952                 throw new AssertionError();
 953         }
 954         if ((typeRef &amp; ~mask) != 0) {
 955             throw new IllegalArgumentException(
 956                     &quot;Invalid type reference 0x&quot; + Integer.toHexString(typeRef));
 957         }
 958     }
 959 
 960     /**
 961       * Returns the package name of an internal name.
 962       *
 963       * @param name an internal name.
 964       * @return the package name or &quot;&quot; if there is no package.
 965       */
 966     private static String packageName(final String name) {
 967         int index = name.lastIndexOf(&#39;/&#39;);
 968         if (index == -1) {
 969             return &quot;&quot;;
 970         }
 971         return name.substring(0, index);
 972     }
 973 
 974     // -----------------------------------------------------------------------------------------------
 975     // Static verification methods
 976     // -----------------------------------------------------------------------------------------------
 977 
 978     /**
 979       * Checks the given class.
 980       *
 981       * &lt;p&gt;Usage: CheckClassAdapter &amp;lt;binary class name or class file name&amp;gt;
 982       *
 983       * @param args the command line arguments.
 984       * @throws IOException if the class cannot be found, or if an IO exception occurs.
 985       */
 986     public static void main(final String[] args) throws IOException {
 987         if (args.length != 1) {
 988             System.err.println(
 989                     &quot;Verifies the given class.\n&quot;
 990                             + &quot;Usage: CheckClassAdapter &lt;fully qualified class name or class file name&gt;&quot;);
 991             return;
 992         }
 993 
 994         ClassReader classReader;
 995         if (args[0].endsWith(&quot;.class&quot;)) {
 996             InputStream inputStream =
 997                     new FileInputStream(args[0]); // NOPMD(AvoidFileStream): can&#39;t fix for 1.5 compatibility
 998             classReader = new ClassReader(inputStream);
 999         } else {
1000             classReader = new ClassReader(args[0]);
1001         }
1002 
1003         verify(classReader, false, new PrintWriter(System.err));
1004     }
1005 
1006     /**
1007       * Checks the given class.
1008       *
1009       * @param classReader the class to be checked.
1010       * @param printResults whether to print the results of the bytecode verification.
1011       * @param printWriter where the results (or the stack trace in case of error) must be printed.
1012       */
1013     public static void verify(
1014             final ClassReader classReader, final boolean printResults, final PrintWriter printWriter) {
1015         verify(classReader, null, printResults, printWriter);
1016     }
1017 
1018     /**
1019       * Checks the given class.
1020       *
1021       * @param classReader the class to be checked.
1022       * @param loader a &lt;code&gt;ClassLoader&lt;/code&gt; which will be used to load referenced classes. May be
1023       *     {@literal null}.
1024       * @param printResults whether to print the results of the bytecode verification.
1025       * @param printWriter where the results (or the stack trace in case of error) must be printed.
1026       */
1027     public static void verify(
1028             final ClassReader classReader,
1029             final ClassLoader loader,
1030             final boolean printResults,
1031             final PrintWriter printWriter) {
1032         ClassNode classNode = new ClassNode();
1033         classReader.accept(
1034                 new CheckClassAdapter(Opcodes.ASM7, classNode, false) {}, ClassReader.SKIP_DEBUG);
1035 
1036         Type syperType = classNode.superName == null ? null : Type.getObjectType(classNode.superName);
1037         List&lt;MethodNode&gt; methods = classNode.methods;
1038 
1039         List&lt;Type&gt; interfaces = new ArrayList&lt;Type&gt;();
1040         for (String interfaceName : classNode.interfaces) {
1041             interfaces.add(Type.getObjectType(interfaceName));
1042         }
1043 
1044         for (MethodNode method : methods) {
1045             SimpleVerifier verifier =
1046                     new SimpleVerifier(
1047                             Type.getObjectType(classNode.name),
1048                             syperType,
1049                             interfaces,
1050                             (classNode.access &amp; Opcodes.ACC_INTERFACE) != 0);
1051             Analyzer&lt;BasicValue&gt; analyzer = new Analyzer&lt;BasicValue&gt;(verifier);
1052             if (loader != null) {
1053                 verifier.setClassLoader(loader);
1054             }
1055             try {
1056                 analyzer.analyze(classNode.name, method);
1057             } catch (AnalyzerException e) {
1058                 e.printStackTrace(printWriter);
1059             }
1060             if (printResults) {
1061                 printAnalyzerResult(method, analyzer, printWriter);
1062             }
1063         }
1064         printWriter.flush();
1065     }
1066 
1067     static void printAnalyzerResult(
1068             final MethodNode method, final Analyzer&lt;BasicValue&gt; analyzer, final PrintWriter printWriter) {
1069         Textifier textifier = new Textifier();
1070         TraceMethodVisitor traceMethodVisitor = new TraceMethodVisitor(textifier);
1071 
1072         printWriter.println(method.name + method.desc);
1073         for (int i = 0; i &lt; method.instructions.size(); ++i) {
1074             method.instructions.get(i).accept(traceMethodVisitor);
1075 
1076             StringBuilder stringBuilder = new StringBuilder();
1077             Frame&lt;BasicValue&gt; frame = analyzer.getFrames()[i];
1078             if (frame == null) {
1079                 stringBuilder.append(&#39;?&#39;);
1080             } else {
1081                 for (int j = 0; j &lt; frame.getLocals(); ++j) {
1082                     stringBuilder.append(getUnqualifiedName(frame.getLocal(j).toString())).append(&#39; &#39;);
1083                 }
1084                 stringBuilder.append(&quot; : &quot;);
1085                 for (int j = 0; j &lt; frame.getStackSize(); ++j) {
1086                     stringBuilder.append(getUnqualifiedName(frame.getStack(j).toString())).append(&#39; &#39;);
1087                 }
1088             }
1089             while (stringBuilder.length() &lt; method.maxStack + method.maxLocals + 1) {
1090                 stringBuilder.append(&#39; &#39;);
1091             }
1092             printWriter.print(Integer.toString(i + 100000).substring(1));
1093             printWriter.print(
1094                     &quot; &quot; + stringBuilder + &quot; : &quot; + textifier.text.get(textifier.text.size() - 1));
1095         }
1096         for (TryCatchBlockNode tryCatchBlock : method.tryCatchBlocks) {
1097             tryCatchBlock.accept(traceMethodVisitor);
1098             printWriter.print(&quot; &quot; + textifier.text.get(textifier.text.size() - 1));
1099         }
1100         printWriter.println();
1101     }
1102 
1103     private static String getUnqualifiedName(final String name) {
1104         int lastSlashIndex = name.lastIndexOf(&#39;/&#39;);
1105         if (lastSlashIndex == -1) {
1106             return name;
1107         } else {
1108             int endIndex = name.length();
1109             if (name.charAt(endIndex - 1) == &#39;;&#39;) {
1110                 endIndex--;
1111             }
1112             return name.substring(lastSlashIndex + 1, endIndex);
1113         }
1114     }
1115 }
    </pre>
  </body>
</html>
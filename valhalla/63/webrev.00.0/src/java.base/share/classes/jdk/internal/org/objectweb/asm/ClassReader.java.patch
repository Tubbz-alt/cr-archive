diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java
@@ -79,14 +79,15 @@
       * nor visited.
       */
     public static final int SKIP_CODE = 1;
 
     /**
-      * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable
-      * and LineNumberTable attributes. If this flag is set these attributes are neither parsed nor
-      * visited (i.e. {@link ClassVisitor#visitSource}, {@link MethodVisitor#visitLocalVariable} and
-      * {@link MethodVisitor#visitLineNumber} are not called).
+      * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,
+      * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set
+      * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link
+      * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link
+      * MethodVisitor#visitParameter} are not called).
       */
     public static final int SKIP_DEBUG = 2;
 
     /**
       * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes
@@ -119,26 +120,36 @@
     static final int EXPAND_ASM_INSNS = 256;
 
     /** The size of the temporary byte array used to read class input streams chunk by chunk. */
     private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;
 
+    /**
+      * A byte array containing the JVMS ClassFile structure to be parsed.
+      *
+      * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will
+      *     eventually be deleted.
+      */
+    @Deprecated
+    // DontCheck(MemberName): can't be renamed (for backward binary compatibility).
+    public final byte[] b;
+
     /**
       * A byte array containing the JVMS ClassFile structure to be parsed. <i>The content of this array
       * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally
       * not needed by class visitors.</i>
       *
       * <p>NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not
       * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct
       * ClassFile element offsets within this byte array.
       */
-    // DontCheck(MemberName): can't be renamed (for backward binary compatibility).
-    public final byte[] b;
+    final byte[] classFileBuffer;
 
     /**
-      * The offset in bytes, in {@link #b}, of each cp_info entry of the ClassFile's constant_pool
-      * array, <i>plus one</i>. In other words, the offset of constant pool entry i is given by
-      * cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] - 1].
+      * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile's
+      * constant_pool array, <i>plus one</i>. In other words, the offset of constant pool entry i is
+      * given by cpInfoOffsets[i] - 1, i.e. its cp_info's tag field is given by b[cpInfoOffsets[i] -
+      * 1].
       */
     private final int[] cpInfoOffsets;
 
     /**
       * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids
@@ -151,12 +162,12 @@
       * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.
       */
     private final ConstantDynamic[] constantDynamicValues;
 
     /**
-      * The start offsets in {@link #b} of each element of the bootstrap_methods array (in the
-      * BootstrapMethods attribute).
+      * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array
+      * (in the BootstrapMethods attribute).
       *
       * @see <a href="https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23">JVMS
       *     4.7.23</a>
       */
     private final int[] bootstrapMethodOffsets;
@@ -165,11 +176,11 @@
       * A conservative estimate of the maximum length of the strings contained in the constant pool of
       * the class.
       */
     private final int maxStringLength;
 
-    /** The offset in bytes, in {@link #b}, of the ClassFile's access_flags field. */
+    /** The offset in bytes of the ClassFile's access_flags field. */
     public final int header;
 
     // -----------------------------------------------------------------------------------------------
     // Constructors
     // -----------------------------------------------------------------------------------------------
@@ -205,11 +216,12 @@
       * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
       * @param checkClassVersion whether to check the class version or not.
       */
     ClassReader(
             final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
-        b = classFileBuffer;
+        this.classFileBuffer = classFileBuffer;
+        this.b = classFileBuffer;
         // Check the class' major_version. This field is after the magic and minor_version fields, which
         // use 4 and 2 bytes respectively.
         if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V15) {
             throw new IllegalArgumentException(
                     "Unsupported class file major version " + readShort(classFileOffset + 6));
@@ -224,12 +236,12 @@
         // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2
         // bytes respectively.
         int currentCpInfoIndex = 1;
         int currentCpInfoOffset = classFileOffset + 10;
         int currentMaxStringLength = 0;
+        boolean hasBootstrapMethods = false;
         boolean hasConstantDynamic = false;
-        boolean hasConstantInvokeDynamic = false;
         // The offset of the other entries depend on the total size of all the previous entries.
         while (currentCpInfoIndex < constantPoolCount) {
             cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;
             int cpInfoSize;
             switch (classFileBuffer[currentCpInfoOffset]) {
@@ -241,15 +253,16 @@
                 case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
                     cpInfoSize = 5;
                     break;
                 case Symbol.CONSTANT_DYNAMIC_TAG:
                     cpInfoSize = 5;
+                    hasBootstrapMethods = true;
                     hasConstantDynamic = true;
                     break;
                 case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
                     cpInfoSize = 5;
-                    hasConstantInvokeDynamic = true;
+                    hasBootstrapMethods = true;
                     break;
                 case Symbol.CONSTANT_LONG_TAG:
                 case Symbol.CONSTANT_DOUBLE_TAG:
                     cpInfoSize = 9;
                     currentCpInfoIndex++;
@@ -285,13 +298,11 @@
         // Allocate the cache of ConstantDynamic values, if there is at least one.
         constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;
 
         // Read the BootstrapMethods attribute, if any (only get the offset of each method).
         bootstrapMethodOffsets =
-                (hasConstantDynamic | hasConstantInvokeDynamic)
-                        ? readBootstrapMethodsAttribute(currentMaxStringLength)
-                        : null;
+                hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;
     }
 
     /**
       * Constructs a new {@link ClassReader} object.
       *
@@ -328,12 +339,11 @@
     private static byte[] readStream(final InputStream inputStream, final boolean close)
             throws IOException {
         if (inputStream == null) {
             throw new IOException("Class not found");
         }
-        try {
-            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
             byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];
             int bytesRead;
             while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {
                 outputStream.write(data, 0, bytesRead);
             }
@@ -434,10 +444,11 @@
       *     semantic links with a class element that has been transformed by a class adapter between
       *     the reader and the writer</i>.
       * @param parsingOptions the options to use to parse this class. One or more of {@link
       *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
       */
+    @SuppressWarnings("deprecation")
     public void accept(
             final ClassVisitor classVisitor,
             final Attribute[] attributePrototypes,
             final int parsingOptions) {
         Context context = new Context();
@@ -486,10 +497,14 @@
         String moduleMainClass = null;
         // - The string corresponding to the NestHost attribute, or null.
         String nestHostClass = null;
         // - The offset of the NestMembers attribute, or 0.
         int nestMembersOffset = 0;
+        // - The offset of the PermittedSubtypes attribute, or 0
+        int permittedSubtypesOffset = 0;
+        // - The offset of the Record attribute, or 0.
+        int recordOffset = 0;
         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
         //   This list in the <i>reverse order</i> or their order in the ClassFile structure.
         Attribute attributes = null;
 
         int currentAttributeOffset = getFirstAttributeOffset();
@@ -508,10 +523,12 @@
                 enclosingMethodOffset = currentAttributeOffset;
             } else if (Constants.NEST_HOST.equals(attributeName)) {
                 nestHostClass = readClass(currentAttributeOffset, charBuffer);
             } else if (Constants.NEST_MEMBERS.equals(attributeName)) {
                 nestMembersOffset = currentAttributeOffset;
+            } else if (Constants.PERMITTED_SUBTYPES.equals(attributeName)) {
+                permittedSubtypesOffset = currentAttributeOffset;
             } else if (Constants.SIGNATURE.equals(attributeName)) {
                 signature = readUTF8(currentAttributeOffset, charBuffer);
             } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
                 runtimeVisibleAnnotationsOffset = currentAttributeOffset;
             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
@@ -525,10 +542,13 @@
                         readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);
             } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
                 runtimeInvisibleAnnotationsOffset = currentAttributeOffset;
             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
                 runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;
+            } else if (Constants.RECORD.equals(attributeName)) {
+                recordOffset = currentAttributeOffset;
+                accessFlags |= Opcodes.ACC_RECORD;
             } else if (Constants.MODULE.equals(attributeName)) {
                 moduleOffset = currentAttributeOffset;
             } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {
                 moduleMainClass = readClass(currentAttributeOffset, charBuffer);
             } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {
@@ -682,10 +702,21 @@
                 classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));
                 currentNestMemberOffset += 2;
             }
         }
 
+        // Visit the PermittedSubtypes attribute.
+        if (permittedSubtypesOffset != 0) {
+            int numberOfPermittedSubtypes = readUnsignedShort(permittedSubtypesOffset);
+            int currentPermittedSubtypeOffset = permittedSubtypesOffset + 2;
+            while (numberOfPermittedSubtypes-- > 0) {
+                classVisitor.visitPermittedSubtypeExperimental(
+                        readClass(currentPermittedSubtypeOffset, charBuffer));
+                currentPermittedSubtypeOffset += 2;
+            }
+        }
+
         // Visit the InnerClasses attribute.
         if (innerClassesOffset != 0) {
             int numberOfClasses = readUnsignedShort(innerClassesOffset);
             int currentClassesOffset = innerClassesOffset + 2;
             while (numberOfClasses-- > 0) {
@@ -696,10 +727,19 @@
                         readUnsignedShort(currentClassesOffset + 6));
                 currentClassesOffset += 8;
             }
         }
 
+        // Visit Record components.
+        if (recordOffset != 0) {
+            int recordComponentsCount = readUnsignedShort(recordOffset);
+            recordOffset += 2;
+            while (recordComponentsCount-- > 0) {
+                recordOffset = readRecordComponent(classVisitor, context, recordOffset);
+            }
+        }
+
         // Visit the fields and methods.
         int fieldsCount = readUnsignedShort(currentOffset);
         currentOffset += 2;
         while (fieldsCount-- > 0) {
             currentOffset = readField(classVisitor, context, currentOffset);
@@ -725,11 +765,12 @@
       * @param context information about the class being parsed.
       * @param moduleOffset the offset of the Module attribute (excluding the attribute_info's
       *     attribute_name_index and attribute_length fields).
       * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the
       *     attribute_info's attribute_name_index and attribute_length fields), or 0.
-      * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or null.
+      * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal
+      *     null}.
       */
     private void readModuleAttributes(
             final ClassVisitor classVisitor,
             final Context context,
             final int moduleOffset,
@@ -842,10 +883,184 @@
 
         // Visit the end of the module attributes.
         moduleVisitor.visitEnd();
     }
 
+    /**
+      * Reads a record component and visit it.
+      *
+      * @param classVisitor the current class visitor
+      * @param context information about the class being parsed.
+      * @param recordComponentOffset the offset of the current record component.
+      * @return the offset of the first byte following the record component.
+      */
+    private int readRecordComponent(
+            final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {
+        char[] charBuffer = context.charBuffer;
+
+        int currentOffset = recordComponentOffset;
+        String name = readUTF8(currentOffset, charBuffer);
+        String descriptor = readUTF8(currentOffset + 2, charBuffer);
+        currentOffset += 4;
+
+        // Read the record component attributes (the variables are ordered as in Section 4.7 of the
+        // JVMS).
+
+        // Attribute offsets exclude the attribute_name_index and attribute_length fields.
+        // - The string corresponding to the Signature attribute, or null.
+        String signature = null;
+        // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
+        int runtimeVisibleAnnotationsOffset = 0;
+        // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
+        int runtimeInvisibleAnnotationsOffset = 0;
+        // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
+        int runtimeVisibleTypeAnnotationsOffset = 0;
+        // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
+        int runtimeInvisibleTypeAnnotationsOffset = 0;
+        // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
+        //   This list in the <i>reverse order</i> or their order in the ClassFile structure.
+        Attribute attributes = null;
+
+        int attributesCount = readUnsignedShort(currentOffset);
+        currentOffset += 2;
+        while (attributesCount-- > 0) {
+            // Read the attribute_info's attribute_name and attribute_length fields.
+            String attributeName = readUTF8(currentOffset, charBuffer);
+            int attributeLength = readInt(currentOffset + 2);
+            currentOffset += 6;
+            // The tests are sorted in decreasing frequency order (based on frequencies observed on
+            // typical classes).
+            if (Constants.SIGNATURE.equals(attributeName)) {
+                signature = readUTF8(currentOffset, charBuffer);
+            } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
+                runtimeVisibleAnnotationsOffset = currentOffset;
+            } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
+                runtimeVisibleTypeAnnotationsOffset = currentOffset;
+            } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
+                runtimeInvisibleAnnotationsOffset = currentOffset;
+            } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
+                runtimeInvisibleTypeAnnotationsOffset = currentOffset;
+            } else {
+                Attribute attribute =
+                        readAttribute(
+                                context.attributePrototypes,
+                                attributeName,
+                                currentOffset,
+                                attributeLength,
+                                charBuffer,
+                                -1,
+                                null);
+                attribute.nextAttribute = attributes;
+                attributes = attribute;
+            }
+            currentOffset += attributeLength;
+        }
+
+        RecordComponentVisitor recordComponentVisitor =
+                classVisitor.visitRecordComponent(name, descriptor, signature);
+        if (recordComponentVisitor == null) {
+            return currentOffset;
+        }
+
+        // Visit the RuntimeVisibleAnnotations attribute.
+        if (runtimeVisibleAnnotationsOffset != 0) {
+            int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);
+            int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;
+            while (numAnnotations-- > 0) {
+                // Parse the type_index field.
+                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
+                currentAnnotationOffset += 2;
+                // Parse num_element_value_pairs and element_value_pairs and visit these values.
+                currentAnnotationOffset =
+                        readElementValues(
+                                recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),
+                                currentAnnotationOffset,
+                                /* named = */ true,
+                                charBuffer);
+            }
+        }
+
+        // Visit the RuntimeInvisibleAnnotations attribute.
+        if (runtimeInvisibleAnnotationsOffset != 0) {
+            int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);
+            int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;
+            while (numAnnotations-- > 0) {
+                // Parse the type_index field.
+                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
+                currentAnnotationOffset += 2;
+                // Parse num_element_value_pairs and element_value_pairs and visit these values.
+                currentAnnotationOffset =
+                        readElementValues(
+                                recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),
+                                currentAnnotationOffset,
+                                /* named = */ true,
+                                charBuffer);
+            }
+        }
+
+        // Visit the RuntimeVisibleTypeAnnotations attribute.
+        if (runtimeVisibleTypeAnnotationsOffset != 0) {
+            int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);
+            int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;
+            while (numAnnotations-- > 0) {
+                // Parse the target_type, target_info and target_path fields.
+                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
+                // Parse the type_index field.
+                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
+                currentAnnotationOffset += 2;
+                // Parse num_element_value_pairs and element_value_pairs and visit these values.
+                currentAnnotationOffset =
+                        readElementValues(
+                                recordComponentVisitor.visitTypeAnnotation(
+                                        context.currentTypeAnnotationTarget,
+                                        context.currentTypeAnnotationTargetPath,
+                                        annotationDescriptor,
+                                        /* visible = */ true),
+                                currentAnnotationOffset,
+                                /* named = */ true,
+                                charBuffer);
+            }
+        }
+
+        // Visit the RuntimeInvisibleTypeAnnotations attribute.
+        if (runtimeInvisibleTypeAnnotationsOffset != 0) {
+            int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);
+            int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;
+            while (numAnnotations-- > 0) {
+                // Parse the target_type, target_info and target_path fields.
+                currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);
+                // Parse the type_index field.
+                String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
+                currentAnnotationOffset += 2;
+                // Parse num_element_value_pairs and element_value_pairs and visit these values.
+                currentAnnotationOffset =
+                        readElementValues(
+                                recordComponentVisitor.visitTypeAnnotation(
+                                        context.currentTypeAnnotationTarget,
+                                        context.currentTypeAnnotationTargetPath,
+                                        annotationDescriptor,
+                                        /* visible = */ false),
+                                currentAnnotationOffset,
+                                /* named = */ true,
+                                charBuffer);
+            }
+        }
+
+        // Visit the non standard attributes.
+        while (attributes != null) {
+            // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.
+            Attribute nextAttribute = attributes.nextAttribute;
+            attributes.nextAttribute = null;
+            recordComponentVisitor.visitAttribute(attributes);
+            attributes = nextAttribute;
+        }
+
+        // Visit the end of the field.
+        recordComponentVisitor.visitEnd();
+        return currentOffset;
+    }
+
     /**
       * Reads a JVMS field_info structure and makes the given visitor visit it.
       *
       * @param classVisitor the visitor that must visit the field.
       * @param context information about the class being parsed.
@@ -1157,23 +1372,22 @@
         // the content of these attributes.
         if (methodVisitor instanceof MethodWriter) {
             MethodWriter methodWriter = (MethodWriter) methodVisitor;
             if (methodWriter.canCopyMethodAttributes(
                     this,
-                    methodInfoOffset,
-                    currentOffset - methodInfoOffset,
                     synthetic,
                     (context.currentMethodAccessFlags & Opcodes.ACC_DEPRECATED) != 0,
                     readUnsignedShort(methodInfoOffset + 4),
                     signatureIndex,
                     exceptionsOffset)) {
+                methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);
                 return currentOffset;
             }
         }
 
         // Visit the MethodParameters attribute.
-        if (methodParametersOffset != 0) {
+        if (methodParametersOffset != 0 && (context.parsingOptions & SKIP_DEBUG) == 0) {
             int parametersCount = readByte(methodParametersOffset);
             int currentParameterOffset = methodParametersOffset + 1;
             while (parametersCount-- > 0) {
                 // Read the name_index and access_flags fields and visit them.
                 methodVisitor.visitParameter(
@@ -1318,19 +1532,19 @@
     /**
       * Reads a JVMS 'Code' attribute and makes the given visitor visit it.
       *
       * @param methodVisitor the visitor that must visit the Code attribute.
       * @param context information about the class being parsed.
-      * @param codeOffset the start offset in {@link #b} of the Code attribute, excluding its
-      *     attribute_name_index and attribute_length fields.
+      * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding
+      *     its attribute_name_index and attribute_length fields.
       */
     private void readCode(
             final MethodVisitor methodVisitor, final Context context, final int codeOffset) {
         int currentOffset = codeOffset;
 
         // Read the max_stack, max_locals and code_length fields.
-        final byte[] classFileBuffer = b;
+        final byte[] classBuffer = classFileBuffer;
         final char[] charBuffer = context.charBuffer;
         final int maxStack = readUnsignedShort(currentOffset);
         final int maxLocals = readUnsignedShort(currentOffset + 2);
         final int codeLength = readInt(currentOffset + 4);
         currentOffset += 8;
@@ -1339,119 +1553,119 @@
         final int bytecodeStartOffset = currentOffset;
         final int bytecodeEndOffset = currentOffset + codeLength;
         final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];
         while (currentOffset < bytecodeEndOffset) {
             final int bytecodeOffset = currentOffset - bytecodeStartOffset;
-            final int opcode = classFileBuffer[currentOffset] & 0xFF;
+            final int opcode = classBuffer[currentOffset] & 0xFF;
             switch (opcode) {
-                case Constants.NOP:
-                case Constants.ACONST_NULL:
-                case Constants.ICONST_M1:
-                case Constants.ICONST_0:
-                case Constants.ICONST_1:
-                case Constants.ICONST_2:
-                case Constants.ICONST_3:
-                case Constants.ICONST_4:
-                case Constants.ICONST_5:
-                case Constants.LCONST_0:
-                case Constants.LCONST_1:
-                case Constants.FCONST_0:
-                case Constants.FCONST_1:
-                case Constants.FCONST_2:
-                case Constants.DCONST_0:
-                case Constants.DCONST_1:
-                case Constants.IALOAD:
-                case Constants.LALOAD:
-                case Constants.FALOAD:
-                case Constants.DALOAD:
-                case Constants.AALOAD:
-                case Constants.BALOAD:
-                case Constants.CALOAD:
-                case Constants.SALOAD:
-                case Constants.IASTORE:
-                case Constants.LASTORE:
-                case Constants.FASTORE:
-                case Constants.DASTORE:
-                case Constants.AASTORE:
-                case Constants.BASTORE:
-                case Constants.CASTORE:
-                case Constants.SASTORE:
-                case Constants.POP:
-                case Constants.POP2:
-                case Constants.DUP:
-                case Constants.DUP_X1:
-                case Constants.DUP_X2:
-                case Constants.DUP2:
-                case Constants.DUP2_X1:
-                case Constants.DUP2_X2:
-                case Constants.SWAP:
-                case Constants.IADD:
-                case Constants.LADD:
-                case Constants.FADD:
-                case Constants.DADD:
-                case Constants.ISUB:
-                case Constants.LSUB:
-                case Constants.FSUB:
-                case Constants.DSUB:
-                case Constants.IMUL:
-                case Constants.LMUL:
-                case Constants.FMUL:
-                case Constants.DMUL:
-                case Constants.IDIV:
-                case Constants.LDIV:
-                case Constants.FDIV:
-                case Constants.DDIV:
-                case Constants.IREM:
-                case Constants.LREM:
-                case Constants.FREM:
-                case Constants.DREM:
-                case Constants.INEG:
-                case Constants.LNEG:
-                case Constants.FNEG:
-                case Constants.DNEG:
-                case Constants.ISHL:
-                case Constants.LSHL:
-                case Constants.ISHR:
-                case Constants.LSHR:
-                case Constants.IUSHR:
-                case Constants.LUSHR:
-                case Constants.IAND:
-                case Constants.LAND:
-                case Constants.IOR:
-                case Constants.LOR:
-                case Constants.IXOR:
-                case Constants.LXOR:
-                case Constants.I2L:
-                case Constants.I2F:
-                case Constants.I2D:
-                case Constants.L2I:
-                case Constants.L2F:
-                case Constants.L2D:
-                case Constants.F2I:
-                case Constants.F2L:
-                case Constants.F2D:
-                case Constants.D2I:
-                case Constants.D2L:
-                case Constants.D2F:
-                case Constants.I2B:
-                case Constants.I2C:
-                case Constants.I2S:
-                case Constants.LCMP:
-                case Constants.FCMPL:
-                case Constants.FCMPG:
-                case Constants.DCMPL:
-                case Constants.DCMPG:
-                case Constants.IRETURN:
-                case Constants.LRETURN:
-                case Constants.FRETURN:
-                case Constants.DRETURN:
-                case Constants.ARETURN:
-                case Constants.RETURN:
-                case Constants.ARRAYLENGTH:
-                case Constants.ATHROW:
-                case Constants.MONITORENTER:
-                case Constants.MONITOREXIT:
+                case Opcodes.NOP:
+                case Opcodes.ACONST_NULL:
+                case Opcodes.ICONST_M1:
+                case Opcodes.ICONST_0:
+                case Opcodes.ICONST_1:
+                case Opcodes.ICONST_2:
+                case Opcodes.ICONST_3:
+                case Opcodes.ICONST_4:
+                case Opcodes.ICONST_5:
+                case Opcodes.LCONST_0:
+                case Opcodes.LCONST_1:
+                case Opcodes.FCONST_0:
+                case Opcodes.FCONST_1:
+                case Opcodes.FCONST_2:
+                case Opcodes.DCONST_0:
+                case Opcodes.DCONST_1:
+                case Opcodes.IALOAD:
+                case Opcodes.LALOAD:
+                case Opcodes.FALOAD:
+                case Opcodes.DALOAD:
+                case Opcodes.AALOAD:
+                case Opcodes.BALOAD:
+                case Opcodes.CALOAD:
+                case Opcodes.SALOAD:
+                case Opcodes.IASTORE:
+                case Opcodes.LASTORE:
+                case Opcodes.FASTORE:
+                case Opcodes.DASTORE:
+                case Opcodes.AASTORE:
+                case Opcodes.BASTORE:
+                case Opcodes.CASTORE:
+                case Opcodes.SASTORE:
+                case Opcodes.POP:
+                case Opcodes.POP2:
+                case Opcodes.DUP:
+                case Opcodes.DUP_X1:
+                case Opcodes.DUP_X2:
+                case Opcodes.DUP2:
+                case Opcodes.DUP2_X1:
+                case Opcodes.DUP2_X2:
+                case Opcodes.SWAP:
+                case Opcodes.IADD:
+                case Opcodes.LADD:
+                case Opcodes.FADD:
+                case Opcodes.DADD:
+                case Opcodes.ISUB:
+                case Opcodes.LSUB:
+                case Opcodes.FSUB:
+                case Opcodes.DSUB:
+                case Opcodes.IMUL:
+                case Opcodes.LMUL:
+                case Opcodes.FMUL:
+                case Opcodes.DMUL:
+                case Opcodes.IDIV:
+                case Opcodes.LDIV:
+                case Opcodes.FDIV:
+                case Opcodes.DDIV:
+                case Opcodes.IREM:
+                case Opcodes.LREM:
+                case Opcodes.FREM:
+                case Opcodes.DREM:
+                case Opcodes.INEG:
+                case Opcodes.LNEG:
+                case Opcodes.FNEG:
+                case Opcodes.DNEG:
+                case Opcodes.ISHL:
+                case Opcodes.LSHL:
+                case Opcodes.ISHR:
+                case Opcodes.LSHR:
+                case Opcodes.IUSHR:
+                case Opcodes.LUSHR:
+                case Opcodes.IAND:
+                case Opcodes.LAND:
+                case Opcodes.IOR:
+                case Opcodes.LOR:
+                case Opcodes.IXOR:
+                case Opcodes.LXOR:
+                case Opcodes.I2L:
+                case Opcodes.I2F:
+                case Opcodes.I2D:
+                case Opcodes.L2I:
+                case Opcodes.L2F:
+                case Opcodes.L2D:
+                case Opcodes.F2I:
+                case Opcodes.F2L:
+                case Opcodes.F2D:
+                case Opcodes.D2I:
+                case Opcodes.D2L:
+                case Opcodes.D2F:
+                case Opcodes.I2B:
+                case Opcodes.I2C:
+                case Opcodes.I2S:
+                case Opcodes.LCMP:
+                case Opcodes.FCMPL:
+                case Opcodes.FCMPG:
+                case Opcodes.DCMPL:
+                case Opcodes.DCMPG:
+                case Opcodes.IRETURN:
+                case Opcodes.LRETURN:
+                case Opcodes.FRETURN:
+                case Opcodes.DRETURN:
+                case Opcodes.ARETURN:
+                case Opcodes.RETURN:
+                case Opcodes.ARRAYLENGTH:
+                case Opcodes.ATHROW:
+                case Opcodes.MONITORENTER:
+                case Opcodes.MONITOREXIT:
                 case Constants.ILOAD_0:
                 case Constants.ILOAD_1:
                 case Constants.ILOAD_2:
                 case Constants.ILOAD_3:
                 case Constants.LLOAD_0:
@@ -1490,28 +1704,28 @@
                 case Constants.ASTORE_1:
                 case Constants.ASTORE_2:
                 case Constants.ASTORE_3:
                     currentOffset += 1;
                     break;
-                case Constants.IFEQ:
-                case Constants.IFNE:
-                case Constants.IFLT:
-                case Constants.IFGE:
-                case Constants.IFGT:
-                case Constants.IFLE:
-                case Constants.IF_ICMPEQ:
-                case Constants.IF_ICMPNE:
-                case Constants.IF_ICMPLT:
-                case Constants.IF_ICMPGE:
-                case Constants.IF_ICMPGT:
-                case Constants.IF_ICMPLE:
-                case Constants.IF_ACMPEQ:
-                case Constants.IF_ACMPNE:
-                case Constants.GOTO:
-                case Constants.JSR:
-                case Constants.IFNULL:
-                case Constants.IFNONNULL:
+                case Opcodes.IFEQ:
+                case Opcodes.IFNE:
+                case Opcodes.IFLT:
+                case Opcodes.IFGE:
+                case Opcodes.IFGT:
+                case Opcodes.IFLE:
+                case Opcodes.IF_ICMPEQ:
+                case Opcodes.IF_ICMPNE:
+                case Opcodes.IF_ICMPLT:
+                case Opcodes.IF_ICMPGE:
+                case Opcodes.IF_ICMPGT:
+                case Opcodes.IF_ICMPLE:
+                case Opcodes.IF_ACMPEQ:
+                case Opcodes.IF_ACMPNE:
+                case Opcodes.GOTO:
+                case Opcodes.JSR:
+                case Opcodes.IFNULL:
+                case Opcodes.IFNONNULL:
                     createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);
                     currentOffset += 3;
                     break;
                 case Constants.ASM_IFEQ:
                 case Constants.ASM_IFNE:
@@ -1539,32 +1753,32 @@
                 case Constants.ASM_GOTO_W:
                     createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);
                     currentOffset += 5;
                     break;
                 case Constants.WIDE:
-                    switch (classFileBuffer[currentOffset + 1] & 0xFF) {
-                        case Constants.ILOAD:
-                        case Constants.FLOAD:
-                        case Constants.ALOAD:
-                        case Constants.LLOAD:
-                        case Constants.DLOAD:
-                        case Constants.ISTORE:
-                        case Constants.FSTORE:
-                        case Constants.ASTORE:
-                        case Constants.LSTORE:
-                        case Constants.DSTORE:
-                        case Constants.RET:
+                    switch (classBuffer[currentOffset + 1] & 0xFF) {
+                        case Opcodes.ILOAD:
+                        case Opcodes.FLOAD:
+                        case Opcodes.ALOAD:
+                        case Opcodes.LLOAD:
+                        case Opcodes.DLOAD:
+                        case Opcodes.ISTORE:
+                        case Opcodes.FSTORE:
+                        case Opcodes.ASTORE:
+                        case Opcodes.LSTORE:
+                        case Opcodes.DSTORE:
+                        case Opcodes.RET:
                             currentOffset += 4;
                             break;
-                        case Constants.IINC:
+                        case Opcodes.IINC:
                             currentOffset += 6;
                             break;
                         default:
                             throw new IllegalArgumentException();
                     }
                     break;
-                case Constants.TABLESWITCH:
+                case Opcodes.TABLESWITCH:
                     // Skip 0 to 3 padding bytes.
                     currentOffset += 4 - (bytecodeOffset & 3);
                     // Read the default label and the number of table entries.
                     createLabel(bytecodeOffset + readInt(currentOffset), labels);
                     int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;
@@ -1573,11 +1787,11 @@
                     while (numTableEntries-- > 0) {
                         createLabel(bytecodeOffset + readInt(currentOffset), labels);
                         currentOffset += 4;
                     }
                     break;
-                case Constants.LOOKUPSWITCH:
+                case Opcodes.LOOKUPSWITCH:
                     // Skip 0 to 3 padding bytes.
                     currentOffset += 4 - (bytecodeOffset & 3);
                     // Read the default label and the number of switch cases.
                     createLabel(bytecodeOffset + readInt(currentOffset), labels);
                     int numSwitchCases = readInt(currentOffset + 4);
@@ -1586,50 +1800,50 @@
                     while (numSwitchCases-- > 0) {
                         createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);
                         currentOffset += 8;
                     }
                     break;
-                case Constants.ILOAD:
-                case Constants.LLOAD:
-                case Constants.FLOAD:
-                case Constants.DLOAD:
-                case Constants.ALOAD:
-                case Constants.ISTORE:
-                case Constants.LSTORE:
-                case Constants.FSTORE:
-                case Constants.DSTORE:
-                case Constants.ASTORE:
-                case Constants.RET:
-                case Constants.BIPUSH:
-                case Constants.NEWARRAY:
-                case Constants.LDC:
+                case Opcodes.ILOAD:
+                case Opcodes.LLOAD:
+                case Opcodes.FLOAD:
+                case Opcodes.DLOAD:
+                case Opcodes.ALOAD:
+                case Opcodes.ISTORE:
+                case Opcodes.LSTORE:
+                case Opcodes.FSTORE:
+                case Opcodes.DSTORE:
+                case Opcodes.ASTORE:
+                case Opcodes.RET:
+                case Opcodes.BIPUSH:
+                case Opcodes.NEWARRAY:
+                case Opcodes.LDC:
                     currentOffset += 2;
                     break;
-                case Constants.SIPUSH:
+                case Opcodes.SIPUSH:
                 case Constants.LDC_W:
                 case Constants.LDC2_W:
-                case Constants.GETSTATIC:
-                case Constants.PUTSTATIC:
-                case Constants.GETFIELD:
-                case Constants.PUTFIELD:
-                case Constants.DEFAULT:
-                case Constants.WITHFIELD:
-                case Constants.INVOKEVIRTUAL:
-                case Constants.INVOKESPECIAL:
-                case Constants.INVOKESTATIC:
-                case Constants.NEW:
-                case Constants.ANEWARRAY:
-                case Constants.CHECKCAST:
-                case Constants.INSTANCEOF:
-                case Constants.IINC:
+                case Opcodes.GETSTATIC:
+                case Opcodes.PUTSTATIC:
+                case Opcodes.GETFIELD:
+                case Opcodes.PUTFIELD:
+                case Opcodes.DEFAULT:
+                case Opcodes.WITHFIELD:
+                case Opcodes.INVOKEVIRTUAL:
+                case Opcodes.INVOKESPECIAL:
+                case Opcodes.INVOKESTATIC:
+                case Opcodes.NEW:
+                case Opcodes.ANEWARRAY:
+                case Opcodes.CHECKCAST:
+                case Opcodes.INSTANCEOF:
+                case Opcodes.IINC:
                     currentOffset += 3;
                     break;
-                case Constants.INVOKEINTERFACE:
-                case Constants.INVOKEDYNAMIC:
+                case Opcodes.INVOKEINTERFACE:
+                case Opcodes.INVOKEDYNAMIC:
                     currentOffset += 5;
                     break;
-                case Constants.MULTIANEWARRAY:
+                case Opcodes.MULTIANEWARRAY:
                     currentOffset += 4;
                     break;
                 default:
                     throw new IllegalArgumentException();
             }
@@ -1790,15 +2004,15 @@
             // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,
             // and the only consequence will be the creation of an unneeded label. This is better than
             // creating a label for each NEW instruction, and faster than fully decoding the whole stack
             // map table.
             for (int offset = stackMapFrameOffset; offset < stackMapTableEndOffset - 2; ++offset) {
-                if (classFileBuffer[offset] == Frame.ITEM_UNINITIALIZED) {
+                if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {
                     int potentialBytecodeOffset = readUnsignedShort(offset + 1);
                     if (potentialBytecodeOffset >= 0
                             && potentialBytecodeOffset < codeLength
-                            && (classFileBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF)
+                            && (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] & 0xFF)
                                     == Opcodes.NEW) {
                         createLabel(potentialBytecodeOffset, labels);
                     }
                 }
             }
@@ -1890,119 +2104,119 @@
                 }
                 insertFrame = false;
             }
 
             // Visit the instruction at this bytecode offset.
-            int opcode = classFileBuffer[currentOffset] & 0xFF;
+            int opcode = classBuffer[currentOffset] & 0xFF;
             switch (opcode) {
-                case Constants.NOP:
-                case Constants.ACONST_NULL:
-                case Constants.ICONST_M1:
-                case Constants.ICONST_0:
-                case Constants.ICONST_1:
-                case Constants.ICONST_2:
-                case Constants.ICONST_3:
-                case Constants.ICONST_4:
-                case Constants.ICONST_5:
-                case Constants.LCONST_0:
-                case Constants.LCONST_1:
-                case Constants.FCONST_0:
-                case Constants.FCONST_1:
-                case Constants.FCONST_2:
-                case Constants.DCONST_0:
-                case Constants.DCONST_1:
-                case Constants.IALOAD:
-                case Constants.LALOAD:
-                case Constants.FALOAD:
-                case Constants.DALOAD:
-                case Constants.AALOAD:
-                case Constants.BALOAD:
-                case Constants.CALOAD:
-                case Constants.SALOAD:
-                case Constants.IASTORE:
-                case Constants.LASTORE:
-                case Constants.FASTORE:
-                case Constants.DASTORE:
-                case Constants.AASTORE:
-                case Constants.BASTORE:
-                case Constants.CASTORE:
-                case Constants.SASTORE:
-                case Constants.POP:
-                case Constants.POP2:
-                case Constants.DUP:
-                case Constants.DUP_X1:
-                case Constants.DUP_X2:
-                case Constants.DUP2:
-                case Constants.DUP2_X1:
-                case Constants.DUP2_X2:
-                case Constants.SWAP:
-                case Constants.IADD:
-                case Constants.LADD:
-                case Constants.FADD:
-                case Constants.DADD:
-                case Constants.ISUB:
-                case Constants.LSUB:
-                case Constants.FSUB:
-                case Constants.DSUB:
-                case Constants.IMUL:
-                case Constants.LMUL:
-                case Constants.FMUL:
-                case Constants.DMUL:
-                case Constants.IDIV:
-                case Constants.LDIV:
-                case Constants.FDIV:
-                case Constants.DDIV:
-                case Constants.IREM:
-                case Constants.LREM:
-                case Constants.FREM:
-                case Constants.DREM:
-                case Constants.INEG:
-                case Constants.LNEG:
-                case Constants.FNEG:
-                case Constants.DNEG:
-                case Constants.ISHL:
-                case Constants.LSHL:
-                case Constants.ISHR:
-                case Constants.LSHR:
-                case Constants.IUSHR:
-                case Constants.LUSHR:
-                case Constants.IAND:
-                case Constants.LAND:
-                case Constants.IOR:
-                case Constants.LOR:
-                case Constants.IXOR:
-                case Constants.LXOR:
-                case Constants.I2L:
-                case Constants.I2F:
-                case Constants.I2D:
-                case Constants.L2I:
-                case Constants.L2F:
-                case Constants.L2D:
-                case Constants.F2I:
-                case Constants.F2L:
-                case Constants.F2D:
-                case Constants.D2I:
-                case Constants.D2L:
-                case Constants.D2F:
-                case Constants.I2B:
-                case Constants.I2C:
-                case Constants.I2S:
-                case Constants.LCMP:
-                case Constants.FCMPL:
-                case Constants.FCMPG:
-                case Constants.DCMPL:
-                case Constants.DCMPG:
-                case Constants.IRETURN:
-                case Constants.LRETURN:
-                case Constants.FRETURN:
-                case Constants.DRETURN:
-                case Constants.ARETURN:
-                case Constants.RETURN:
-                case Constants.ARRAYLENGTH:
-                case Constants.ATHROW:
-                case Constants.MONITORENTER:
-                case Constants.MONITOREXIT:
+                case Opcodes.NOP:
+                case Opcodes.ACONST_NULL:
+                case Opcodes.ICONST_M1:
+                case Opcodes.ICONST_0:
+                case Opcodes.ICONST_1:
+                case Opcodes.ICONST_2:
+                case Opcodes.ICONST_3:
+                case Opcodes.ICONST_4:
+                case Opcodes.ICONST_5:
+                case Opcodes.LCONST_0:
+                case Opcodes.LCONST_1:
+                case Opcodes.FCONST_0:
+                case Opcodes.FCONST_1:
+                case Opcodes.FCONST_2:
+                case Opcodes.DCONST_0:
+                case Opcodes.DCONST_1:
+                case Opcodes.IALOAD:
+                case Opcodes.LALOAD:
+                case Opcodes.FALOAD:
+                case Opcodes.DALOAD:
+                case Opcodes.AALOAD:
+                case Opcodes.BALOAD:
+                case Opcodes.CALOAD:
+                case Opcodes.SALOAD:
+                case Opcodes.IASTORE:
+                case Opcodes.LASTORE:
+                case Opcodes.FASTORE:
+                case Opcodes.DASTORE:
+                case Opcodes.AASTORE:
+                case Opcodes.BASTORE:
+                case Opcodes.CASTORE:
+                case Opcodes.SASTORE:
+                case Opcodes.POP:
+                case Opcodes.POP2:
+                case Opcodes.DUP:
+                case Opcodes.DUP_X1:
+                case Opcodes.DUP_X2:
+                case Opcodes.DUP2:
+                case Opcodes.DUP2_X1:
+                case Opcodes.DUP2_X2:
+                case Opcodes.SWAP:
+                case Opcodes.IADD:
+                case Opcodes.LADD:
+                case Opcodes.FADD:
+                case Opcodes.DADD:
+                case Opcodes.ISUB:
+                case Opcodes.LSUB:
+                case Opcodes.FSUB:
+                case Opcodes.DSUB:
+                case Opcodes.IMUL:
+                case Opcodes.LMUL:
+                case Opcodes.FMUL:
+                case Opcodes.DMUL:
+                case Opcodes.IDIV:
+                case Opcodes.LDIV:
+                case Opcodes.FDIV:
+                case Opcodes.DDIV:
+                case Opcodes.IREM:
+                case Opcodes.LREM:
+                case Opcodes.FREM:
+                case Opcodes.DREM:
+                case Opcodes.INEG:
+                case Opcodes.LNEG:
+                case Opcodes.FNEG:
+                case Opcodes.DNEG:
+                case Opcodes.ISHL:
+                case Opcodes.LSHL:
+                case Opcodes.ISHR:
+                case Opcodes.LSHR:
+                case Opcodes.IUSHR:
+                case Opcodes.LUSHR:
+                case Opcodes.IAND:
+                case Opcodes.LAND:
+                case Opcodes.IOR:
+                case Opcodes.LOR:
+                case Opcodes.IXOR:
+                case Opcodes.LXOR:
+                case Opcodes.I2L:
+                case Opcodes.I2F:
+                case Opcodes.I2D:
+                case Opcodes.L2I:
+                case Opcodes.L2F:
+                case Opcodes.L2D:
+                case Opcodes.F2I:
+                case Opcodes.F2L:
+                case Opcodes.F2D:
+                case Opcodes.D2I:
+                case Opcodes.D2L:
+                case Opcodes.D2F:
+                case Opcodes.I2B:
+                case Opcodes.I2C:
+                case Opcodes.I2S:
+                case Opcodes.LCMP:
+                case Opcodes.FCMPL:
+                case Opcodes.FCMPG:
+                case Opcodes.DCMPL:
+                case Opcodes.DCMPG:
+                case Opcodes.IRETURN:
+                case Opcodes.LRETURN:
+                case Opcodes.FRETURN:
+                case Opcodes.DRETURN:
+                case Opcodes.ARETURN:
+                case Opcodes.RETURN:
+                case Opcodes.ARRAYLENGTH:
+                case Opcodes.ATHROW:
+                case Opcodes.MONITORENTER:
+                case Opcodes.MONITOREXIT:
                     methodVisitor.visitInsn(opcode);
                     currentOffset += 1;
                     break;
                 case Constants.ILOAD_0:
                 case Constants.ILOAD_1:
@@ -2050,28 +2264,28 @@
                 case Constants.ASTORE_3:
                     opcode -= Constants.ISTORE_0;
                     methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 0x3);
                     currentOffset += 1;
                     break;
-                case Constants.IFEQ:
-                case Constants.IFNE:
-                case Constants.IFLT:
-                case Constants.IFGE:
-                case Constants.IFGT:
-                case Constants.IFLE:
-                case Constants.IF_ICMPEQ:
-                case Constants.IF_ICMPNE:
-                case Constants.IF_ICMPLT:
-                case Constants.IF_ICMPGE:
-                case Constants.IF_ICMPGT:
-                case Constants.IF_ICMPLE:
-                case Constants.IF_ACMPEQ:
-                case Constants.IF_ACMPNE:
-                case Constants.GOTO:
-                case Constants.JSR:
-                case Constants.IFNULL:
-                case Constants.IFNONNULL:
+                case Opcodes.IFEQ:
+                case Opcodes.IFNE:
+                case Opcodes.IFLT:
+                case Opcodes.IFGE:
+                case Opcodes.IFGT:
+                case Opcodes.IFLE:
+                case Opcodes.IF_ICMPEQ:
+                case Opcodes.IF_ICMPNE:
+                case Opcodes.IF_ICMPLT:
+                case Opcodes.IF_ICMPGE:
+                case Opcodes.IF_ICMPGT:
+                case Opcodes.IF_ICMPLE:
+                case Opcodes.IF_ACMPEQ:
+                case Opcodes.IF_ACMPNE:
+                case Opcodes.GOTO:
+                case Opcodes.JSR:
+                case Opcodes.IFNULL:
+                case Opcodes.IFNONNULL:
                     methodVisitor.visitJumpInsn(
                             opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);
                     currentOffset += 3;
                     break;
                 case Constants.GOTO_W:
@@ -2128,33 +2342,31 @@
                         }
                         currentOffset += 3;
                         break;
                     }
                 case Constants.ASM_GOTO_W:
-                    {
-                        // Replace ASM_GOTO_W with GOTO_W.
-                        methodVisitor.visitJumpInsn(
-                                Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);
-                        // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns
-                        // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame
-                        // here.
-                        insertFrame = true;
-                        currentOffset += 5;
-                        break;
-                    }
+                    // Replace ASM_GOTO_W with GOTO_W.
+                    methodVisitor.visitJumpInsn(
+                            Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);
+                    // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns
+                    // IFNOTxxx <L> ASM_GOTO_W <l> L:..., see MethodWriter), so we need to insert a frame
+                    // here.
+                    insertFrame = true;
+                    currentOffset += 5;
+                    break;
                 case Constants.WIDE:
-                    opcode = classFileBuffer[currentOffset + 1] & 0xFF;
+                    opcode = classBuffer[currentOffset + 1] & 0xFF;
                     if (opcode == Opcodes.IINC) {
                         methodVisitor.visitIincInsn(
                                 readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));
                         currentOffset += 6;
                     } else {
                         methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));
                         currentOffset += 4;
                     }
                     break;
-                case Constants.TABLESWITCH:
+                case Opcodes.TABLESWITCH:
                     {
                         // Skip 0 to 3 padding bytes.
                         currentOffset += 4 - (currentBytecodeOffset & 3);
                         // Read the instruction.
                         Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
@@ -2167,11 +2379,11 @@
                             currentOffset += 4;
                         }
                         methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);
                         break;
                     }
-                case Constants.LOOKUPSWITCH:
+                case Opcodes.LOOKUPSWITCH:
                     {
                         // Skip 0 to 3 padding bytes.
                         currentOffset += 4 - (currentBytecodeOffset & 3);
                         // Read the instruction.
                         Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
@@ -2185,61 +2397,60 @@
                             currentOffset += 8;
                         }
                         methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);
                         break;
                     }
-                case Constants.ILOAD:
-                case Constants.LLOAD:
-                case Constants.FLOAD:
-                case Constants.DLOAD:
-                case Constants.ALOAD:
-                case Constants.ISTORE:
-                case Constants.LSTORE:
-                case Constants.FSTORE:
-                case Constants.DSTORE:
-                case Constants.ASTORE:
-                case Constants.RET:
-                    methodVisitor.visitVarInsn(opcode, classFileBuffer[currentOffset + 1] & 0xFF);
+                case Opcodes.ILOAD:
+                case Opcodes.LLOAD:
+                case Opcodes.FLOAD:
+                case Opcodes.DLOAD:
+                case Opcodes.ALOAD:
+                case Opcodes.ISTORE:
+                case Opcodes.LSTORE:
+                case Opcodes.FSTORE:
+                case Opcodes.DSTORE:
+                case Opcodes.ASTORE:
+                case Opcodes.RET:
+                    methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] & 0xFF);
                     currentOffset += 2;
                     break;
-                case Constants.BIPUSH:
-                case Constants.NEWARRAY:
-                    methodVisitor.visitIntInsn(opcode, classFileBuffer[currentOffset + 1]);
+                case Opcodes.BIPUSH:
+                case Opcodes.NEWARRAY:
+                    methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);
                     currentOffset += 2;
                     break;
-                case Constants.SIPUSH:
+                case Opcodes.SIPUSH:
                     methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));
                     currentOffset += 3;
                     break;
-                case Constants.LDC:
-                    methodVisitor.visitLdcInsn(
-                            readConst(classFileBuffer[currentOffset + 1] & 0xFF, charBuffer));
+                case Opcodes.LDC:
+                    methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] & 0xFF, charBuffer));
                     currentOffset += 2;
                     break;
                 case Constants.LDC_W:
                 case Constants.LDC2_W:
                     methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));
                     currentOffset += 3;
                     break;
-                case Constants.GETSTATIC:
-                case Constants.PUTSTATIC:
-                case Constants.GETFIELD:
-                case Constants.PUTFIELD:
-                case Constants.INVOKEVIRTUAL:
-                case Constants.INVOKESPECIAL:
-                case Constants.INVOKESTATIC:
-                case Constants.INVOKEINTERFACE:
-                case Constants.WITHFIELD:
+                case Opcodes.GETSTATIC:
+                case Opcodes.PUTSTATIC:
+                case Opcodes.GETFIELD:
+                case Opcodes.PUTFIELD:
+                case Opcodes.INVOKEVIRTUAL:
+                case Opcodes.INVOKESPECIAL:
+                case Opcodes.INVOKESTATIC:
+                case Opcodes.INVOKEINTERFACE:
+                case Opcodes.WITHFIELD:
                     {
                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
                         String owner = readClass(cpInfoOffset, charBuffer);
                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
                         if (opcode >= Opcodes.INVOKEVIRTUAL && opcode <= Opcodes.INVOKEINTERFACE) {
                             boolean isInterface =
-                                    classFileBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
+                                    classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
                             methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
                         } else {
                             methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);
                         }
                         if (opcode == Opcodes.INVOKEINTERFACE) {
@@ -2247,11 +2458,11 @@
                         } else {
                             currentOffset += 3;
                         }
                         break;
                     }
-                case Constants.INVOKEDYNAMIC:
+                case Opcodes.INVOKEDYNAMIC:
                     {
                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
@@ -2269,26 +2480,26 @@
                         methodVisitor.visitInvokeDynamicInsn(
                                 name, descriptor, handle, bootstrapMethodArguments);
                         currentOffset += 5;
                         break;
                     }
-                case Constants.NEW:
-                case Constants.ANEWARRAY:
-                case Constants.CHECKCAST:
-                case Constants.INSTANCEOF:
-                case Constants.DEFAULT:
+                case Opcodes.NEW:
+                case Opcodes.ANEWARRAY:
+                case Opcodes.CHECKCAST:
+                case Opcodes.INSTANCEOF:
+                case Opcodes.DEFAULT:
                     methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));
                     currentOffset += 3;
                     break;
-                case Constants.IINC:
+                case Opcodes.IINC:
                     methodVisitor.visitIincInsn(
-                            classFileBuffer[currentOffset + 1] & 0xFF, classFileBuffer[currentOffset + 2]);
+                            classBuffer[currentOffset + 1] & 0xFF, classBuffer[currentOffset + 2]);
                     currentOffset += 3;
                     break;
-                case Constants.MULTIANEWARRAY:
+                case Opcodes.MULTIANEWARRAY:
                     methodVisitor.visitMultiANewArrayInsn(
-                            readClass(currentOffset + 1, charBuffer), classFileBuffer[currentOffset + 3] & 0xFF);
+                            readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] & 0xFF);
                     currentOffset += 4;
                     break;
                 default:
                     throw new AssertionError();
             }
@@ -2588,11 +2799,11 @@
             // Parse the rest of the type_annotation structure, starting with the target_path structure
             // (whose size depends on its path_length field).
             int pathLength = readByte(currentOffset);
             if ((targetType >>> 24) == TypeReference.EXCEPTION_PARAMETER) {
                 // Parse the target_path structure and create a corresponding TypePath.
-                TypePath path = pathLength == 0 ? null : new TypePath(b, currentOffset);
+                TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);
                 currentOffset += 1 + 2 * pathLength;
                 // Parse the type_index field.
                 String annotationDescriptor = readUTF8(currentOffset, charBuffer);
                 currentOffset += 2;
                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
@@ -2621,11 +2832,11 @@
     /**
       * Returns the bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or
       * -1 if there is no such type_annotation of if it does not have a bytecode offset.
       *
       * @param typeAnnotationOffsets the offset of each 'type_annotation' entry in a
-      *     Runtime[In]VisibleTypeAnnotations attribute, or null.
+      *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.
       * @param typeAnnotationIndex the index a 'type_annotation' entry in typeAnnotationOffsets.
       * @return bytecode offset corresponding to the specified JVMS 'type_annotation' structure, or -1
       *     if there is no such type_annotation of if it does not have a bytecode offset.
       */
     private int getTypeAnnotationBytecodeOffset(
@@ -2713,11 +2924,11 @@
         }
         context.currentTypeAnnotationTarget = targetType;
         // Parse and store the target_path structure.
         int pathLength = readByte(currentOffset);
         context.currentTypeAnnotationTargetPath =
-                pathLength == 0 ? null : new TypePath(b, currentOffset);
+                pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);
         // Return the start offset of the rest of the type_annotation structure.
         return currentOffset + 1 + 2 * pathLength;
     }
 
     /**
@@ -2735,11 +2946,11 @@
             final MethodVisitor methodVisitor,
             final Context context,
             final int runtimeParameterAnnotationsOffset,
             final boolean visible) {
         int currentOffset = runtimeParameterAnnotationsOffset;
-        int numParameters = b[currentOffset++] & 0xFF;
+        int numParameters = classFileBuffer[currentOffset++] & 0xFF;
         methodVisitor.visitAnnotableParameterCount(numParameters, visible);
         char[] charBuffer = context.charBuffer;
         for (int i = 0; i < numParameters; ++i) {
             int numAnnotations = readUnsignedShort(currentOffset);
             currentOffset += 2;
@@ -2803,12 +3014,12 @@
 
     /**
       * Reads a JVMS 'element_value' structure and makes the given visitor visit it.
       *
       * @param annotationVisitor the visitor that must visit the element_value structure.
-      * @param elementValueOffset the start offset in {@link #b} of the element_value structure to be
-      *     read.
+      * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value
+      *     structure to be read.
       * @param elementName the name of the element_value structure to be read, or {@literal null}.
       * @param charBuffer the buffer used to read strings in the constant pool.
       * @return the end offset of the JVMS 'element_value' structure.
       */
     private int readElementValue(
@@ -2816,22 +3027,22 @@
             final int elementValueOffset,
             final String elementName,
             final char[] charBuffer) {
         int currentOffset = elementValueOffset;
         if (annotationVisitor == null) {
-            switch (b[currentOffset] & 0xFF) {
+            switch (classFileBuffer[currentOffset] & 0xFF) {
                 case 'e': // enum_const_value
                     return currentOffset + 5;
                 case '@': // annotation_value
                     return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);
                 case '[': // array_value
                     return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);
                 default:
                     return currentOffset + 3;
             }
         }
-        switch (b[currentOffset++] & 0xFF) {
+        switch (classFileBuffer[currentOffset++] & 0xFF) {
             case 'B': // const_value_index, CONSTANT_Integer
                 annotationVisitor.visit(
                         elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
                 currentOffset += 2;
                 break;
@@ -2893,11 +3104,11 @@
                             annotationVisitor.visitArray(elementName),
                             currentOffset - 2,
                             /* named = */ false,
                             charBuffer);
                 }
-                switch (b[currentOffset] & 0xFF) {
+                switch (classFileBuffer[currentOffset] & 0xFF) {
                     case 'B':
                         byte[] byteValues = new byte[numValues];
                         for (int i = 0; i < numValues; i++) {
                             byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
                             currentOffset += 3;
@@ -3056,13 +3267,13 @@
     /**
       * Reads a JVMS 'stack_map_frame' structure and stores the result in the given {@link Context}
       * object. This method can also be used to read a full_frame structure, excluding its frame_type
       * field (this is used to parse the legacy StackMap attributes).
       *
-      * @param stackMapFrameOffset the start offset in {@link #b} of the stack_map_frame_value
-      *     structure to be read, or the start offset of a full_frame structure (excluding its
-      *     frame_type field).
+      * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the
+      *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure
+      *     (excluding its frame_type field).
       * @param compressed true to read a 'stack_map_frame' structure, false to read a 'full_frame'
       *     structure without its frame_type field.
       * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.
       * @param context where the parsed stack map frame must be stored.
       * @return the end offset of the JVMS 'stack_map_frame' or 'full_frame' structure.
@@ -3076,11 +3287,11 @@
         final char[] charBuffer = context.charBuffer;
         final Label[] labels = context.currentMethodLabels;
         int frameType;
         if (compressed) {
             // Read the frame_type field.
-            frameType = b[currentOffset++] & 0xFF;
+            frameType = classFileBuffer[currentOffset++] & 0xFF;
         } else {
             frameType = Frame.FULL_FRAME;
             context.currentFrameOffset = -1;
         }
         int offsetDelta;
@@ -3171,11 +3382,11 @@
             final Object[] frame,
             final int index,
             final char[] charBuffer,
             final Label[] labels) {
         int currentOffset = verificationTypeInfoOffset;
-        int tag = b[currentOffset++] & 0xFF;
+        int tag = classFileBuffer[currentOffset++] & 0xFF;
         switch (tag) {
             case Frame.ITEM_TOP:
                 frame[index] = Opcodes.TOP;
                 break;
             case Frame.ITEM_INTEGER:
@@ -3213,13 +3424,15 @@
     // ----------------------------------------------------------------------------------------------
     // Methods to parse attributes
     // ----------------------------------------------------------------------------------------------
 
     /**
-      * Returns the offset in {@link #b} of the first ClassFile's 'attributes' array field entry.
+      * Returns the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array
+      * field entry.
       *
-      * @return the offset in {@link #b} of the first ClassFile's 'attributes' array field entry.
+      * @return the offset in {@link #classFileBuffer} of the first ClassFile's 'attributes' array
+      *     field entry.
       */
     final int getFirstAttributeOffset() {
         // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes
         // each), as well as the interfaces array field (2 bytes per interface).
         int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;
@@ -3262,11 +3475,11 @@
     /**
       * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
       *
       * @param maxStringLength a conservative estimate of the maximum length of the strings contained
       *     in the constant pool of the class.
-      * @return the offsets of the bootstrap methods or null.
+      * @return the offsets of the bootstrap methods.
       */
     private int[] readBootstrapMethodsAttribute(final int maxStringLength) {
         char[] charBuffer = new char[maxStringLength];
         int currentAttributeOffset = getFirstAttributeOffset();
         int[] currentBootstrapMethodOffsets = null;
@@ -3289,27 +3502,29 @@
                 }
                 return currentBootstrapMethodOffsets;
             }
             currentAttributeOffset += attributeLength;
         }
-        return null;
+        throw new IllegalArgumentException();
     }
 
     /**
-      * Reads a non standard JVMS 'attribute' structure in {@link #b}.
+      * Reads a non standard JVMS 'attribute' structure in {@link #classFileBuffer}.
       *
       * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
       *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
       *     be parsed: its byte array value will be passed unchanged to the ClassWriter.
       * @param type the type of the attribute.
-      * @param offset the start offset of the JVMS 'attribute' structure in {@link #b}. The 6 attribute
-      *     header bytes (attribute_name_index and attribute_length) are not taken into account here.
+      * @param offset the start offset of the JVMS 'attribute' structure in {@link #classFileBuffer}.
+      *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into
+      *     account here.
       * @param length the length of the attribute's content (excluding the 6 attribute header bytes).
       * @param charBuffer the buffer to be used to read strings in the constant pool.
-      * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link #b}, or
-      *     -1 if the attribute to be read is not a code attribute. The 6 attribute header bytes
-      *     (attribute_name_index and attribute_length) are not taken into account here.
+      * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link
+      *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6
+      *     attribute header bytes (attribute_name_index and attribute_length) are not taken into
+      *     account here.
       * @param labels the labels of the method's code, or {@literal null} if the attribute to be read
       *     is not a code attribute.
       * @return the attribute that has been read.
       */
     private Attribute readAttribute(
@@ -3341,17 +3556,18 @@
     public int getItemCount() {
         return cpInfoOffsets.length;
     }
 
     /**
-      * Returns the start offset in {@link #b} of a JVMS 'cp_info' structure (i.e. a constant pool
-      * entry), plus one. <i>This method is intended for {@link Attribute} sub classes, and is normally
-      * not needed by class generators or adapters.</i>
+      * Returns the start offset in this {@link ClassReader} of a JVMS 'cp_info' structure (i.e. a
+      * constant pool entry), plus one. <i>This method is intended for {@link Attribute} sub classes,
+      * and is normally not needed by class generators or adapters.</i>
       *
       * @param constantPoolEntryIndex the index a constant pool entry in the class's constant pool
       *     table.
-      * @return the start offset in {@link #b} of the corresponding JVMS 'cp_info' structure, plus one.
+      * @return the start offset in this {@link ClassReader} of the corresponding JVMS 'cp_info'
+      *     structure, plus one.
       */
     public int getItem(final int constantPoolEntryIndex) {
         return cpInfoOffsets[constantPoolEntryIndex];
     }
 
@@ -3365,78 +3581,79 @@
     public int getMaxStringLength() {
         return maxStringLength;
     }
 
     /**
-      * Reads a byte value in {@link #b}. <i>This method is intended for {@link Attribute} sub classes,
-      * and is normally not needed by class generators or adapters.</i>
+      * Reads a byte value in this {@link ClassReader}. <i>This method is intended for {@link
+      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
       *
-      * @param offset the start offset of the value to be read in {@link #b}.
+      * @param offset the start offset of the value to be read in this {@link ClassReader}.
       * @return the read value.
       */
     public int readByte(final int offset) {
-        return b[offset] & 0xFF;
+        return classFileBuffer[offset] & 0xFF;
     }
 
     /**
-      * Reads an unsigned short value in {@link #b}. <i>This method is intended for {@link Attribute}
-      * sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads an unsigned short value in this {@link ClassReader}. <i>This method is intended for
+      * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
       *
-      * @param offset the start index of the value to be read in {@link #b}.
+      * @param offset the start index of the value to be read in this {@link ClassReader}.
       * @return the read value.
       */
     public int readUnsignedShort(final int offset) {
-        byte[] classFileBuffer = b;
-        return ((classFileBuffer[offset] & 0xFF) << 8) | (classFileBuffer[offset + 1] & 0xFF);
+        byte[] classBuffer = classFileBuffer;
+        return ((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF);
     }
 
     /**
-      * Reads a signed short value in {@link #b}. <i>This method is intended for {@link Attribute} sub
-      * classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a signed short value in this {@link ClassReader}. <i>This method is intended for {@link
+      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
       *
-      * @param offset the start offset of the value to be read in {@link #b}.
+      * @param offset the start offset of the value to be read in this {@link ClassReader}.
       * @return the read value.
       */
     public short readShort(final int offset) {
-        byte[] classFileBuffer = b;
-        return (short) (((classFileBuffer[offset] & 0xFF) << 8) | (classFileBuffer[offset + 1] & 0xFF));
+        byte[] classBuffer = classFileBuffer;
+        return (short) (((classBuffer[offset] & 0xFF) << 8) | (classBuffer[offset + 1] & 0xFF));
     }
 
     /**
-      * Reads a signed int value in {@link #b}. <i>This method is intended for {@link Attribute} sub
-      * classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a signed int value in this {@link ClassReader}. <i>This method is intended for {@link
+      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
       *
-      * @param offset the start offset of the value to be read in {@link #b}.
+      * @param offset the start offset of the value to be read in this {@link ClassReader}.
       * @return the read value.
       */
     public int readInt(final int offset) {
-        byte[] classFileBuffer = b;
-        return ((classFileBuffer[offset] & 0xFF) << 24)
-                | ((classFileBuffer[offset + 1] & 0xFF) << 16)
-                | ((classFileBuffer[offset + 2] & 0xFF) << 8)
-                | (classFileBuffer[offset + 3] & 0xFF);
+        byte[] classBuffer = classFileBuffer;
+        return ((classBuffer[offset] & 0xFF) << 24)
+                | ((classBuffer[offset + 1] & 0xFF) << 16)
+                | ((classBuffer[offset + 2] & 0xFF) << 8)
+                | (classBuffer[offset + 3] & 0xFF);
     }
 
     /**
-      * Reads a signed long value in {@link #b}. <i>This method is intended for {@link Attribute} sub
-      * classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a signed long value in this {@link ClassReader}. <i>This method is intended for {@link
+      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
       *
-      * @param offset the start offset of the value to be read in {@link #b}.
+      * @param offset the start offset of the value to be read in this {@link ClassReader}.
       * @return the read value.
       */
     public long readLong(final int offset) {
         long l1 = readInt(offset);
         long l0 = readInt(offset + 4) & 0xFFFFFFFFL;
         return (l1 << 32) | l0;
     }
 
     /**
-      * Reads a CONSTANT_Utf8 constant pool entry in {@link #b}. <i>This method is intended for {@link
-      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. <i>This method is
+      * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
-      * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
-      *     index of a CONSTANT_Utf8 entry in the class's constant pool table.
+      * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
+      *     value is the index of a CONSTANT_Utf8 entry in the class's constant pool table.
       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
       *     large. It is not automatically resized.
       * @return the String corresponding to the specified CONSTANT_Utf8 entry.
       */
     // DontCheck(AbbreviationAsWordInName): can't be renamed (for backward binary compatibility).
@@ -3447,11 +3664,11 @@
         }
         return readUtf(constantPoolEntryIndex, charBuffer);
     }
 
     /**
-      * Reads a CONSTANT_Utf8 constant pool entry in {@link #b}.
+      * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.
       *
       * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class's constant pool
       *     table.
       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
       *     large. It is not automatically resized.
@@ -3466,11 +3683,11 @@
         return constantUtf8Values[constantPoolEntryIndex] =
                 readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);
     }
 
     /**
-      * Reads an UTF8 string in {@link #b}.
+      * Reads an UTF8 string in {@link #classFileBuffer}.
       *
       * @param utfOffset the start offset of the UTF8 string to be read.
       * @param utfLength the length of the UTF8 string to be read.
       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
       *     large. It is not automatically resized.
@@ -3478,37 +3695,38 @@
       */
     private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {
         int currentOffset = utfOffset;
         int endOffset = currentOffset + utfLength;
         int strLength = 0;
-        byte[] classFileBuffer = b;
+        byte[] classBuffer = classFileBuffer;
         while (currentOffset < endOffset) {
-            int currentByte = classFileBuffer[currentOffset++];
+            int currentByte = classBuffer[currentOffset++];
             if ((currentByte & 0x80) == 0) {
                 charBuffer[strLength++] = (char) (currentByte & 0x7F);
             } else if ((currentByte & 0xE0) == 0xC0) {
                 charBuffer[strLength++] =
-                        (char) (((currentByte & 0x1F) << 6) + (classFileBuffer[currentOffset++] & 0x3F));
+                        (char) (((currentByte & 0x1F) << 6) + (classBuffer[currentOffset++] & 0x3F));
             } else {
                 charBuffer[strLength++] =
                         (char)
                                 (((currentByte & 0xF) << 12)
-                                        + ((classFileBuffer[currentOffset++] & 0x3F) << 6)
-                                        + (classFileBuffer[currentOffset++] & 0x3F));
+                                        + ((classBuffer[currentOffset++] & 0x3F) << 6)
+                                        + (classBuffer[currentOffset++] & 0x3F));
             }
         }
         return new String(charBuffer, 0, strLength);
     }
 
     /**
       * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
-      * CONSTANT_Package constant pool entry in {@link #b}. <i>This method is intended for {@link
-      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. <i>This method is intended
+      * for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
-      * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
-      *     index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
-      *     CONSTANT_Package entry in class's constant pool table.
+      * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose
+      *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
+      *     CONSTANT_Module or CONSTANT_Package entry in class's constant pool table.
       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
       *     large. It is not automatically resized.
       * @return the String corresponding to the specified constant pool entry.
       */
     private String readStringish(final int offset, final char[] charBuffer) {
@@ -3516,53 +3734,56 @@
         // designated by the first two bytes of this cp_info.
         return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);
     }
 
     /**
-      * Reads a CONSTANT_Class constant pool entry in {@link #b}. <i>This method is intended for {@link
-      * Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. <i>This method is
+      * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
-      * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
-      *     index of a CONSTANT_Class entry in class's constant pool table.
+      * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
+      *     value is the index of a CONSTANT_Class entry in class's constant pool table.
       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
       *     large. It is not automatically resized.
       * @return the String corresponding to the specified CONSTANT_Class entry.
       */
     public String readClass(final int offset, final char[] charBuffer) {
         return readStringish(offset, charBuffer);
     }
 
     /**
-      * Reads a CONSTANT_Module constant pool entry in {@link #b}. <i>This method is intended for
-      * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. <i>This method is
+      * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
-      * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
-      *     index of a CONSTANT_Module entry in class's constant pool table.
+      * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
+      *     value is the index of a CONSTANT_Module entry in class's constant pool table.
       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
       *     large. It is not automatically resized.
       * @return the String corresponding to the specified CONSTANT_Module entry.
       */
     public String readModule(final int offset, final char[] charBuffer) {
         return readStringish(offset, charBuffer);
     }
 
     /**
-      * Reads a CONSTANT_Package constant pool entry in {@link #b}. <i>This method is intended for
-      * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. <i>This method is
+      * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
-      * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the
-      *     index of a CONSTANT_Package entry in class's constant pool table.
+      * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose
+      *     value is the index of a CONSTANT_Package entry in class's constant pool table.
       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
       *     large. It is not automatically resized.
       * @return the String corresponding to the specified CONSTANT_Package entry.
       */
     public String readPackage(final int offset, final char[] charBuffer) {
         return readStringish(offset, charBuffer);
     }
 
     /**
-      * Reads a CONSTANT_Dynamic constant pool entry in {@link #b}.
+      * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.
       *
       * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class's constant
       *     pool table.
       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
       *     large. It is not automatically resized.
@@ -3589,12 +3810,13 @@
         return constantDynamicValues[constantPoolEntryIndex] =
                 new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);
     }
 
     /**
-      * Reads a numeric or string constant pool entry in {@link #b}. <i>This method is intended for
-      * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.</i>
+      * Reads a numeric or string constant pool entry in this {@link ClassReader}. <i>This method is
+      * intended for {@link Attribute} sub classes, and is normally not needed by class generators or
+      * adapters.</i>
       *
       * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,
       *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
       *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class's constant pool.
       * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently
@@ -3603,11 +3825,11 @@
       *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified
       *     constant pool entry.
       */
     public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {
         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
-        switch (b[cpInfoOffset - 1]) {
+        switch (classFileBuffer[cpInfoOffset - 1]) {
             case Symbol.CONSTANT_INTEGER_TAG:
                 return readInt(cpInfoOffset);
             case Symbol.CONSTANT_FLOAT_TAG:
                 return Float.intBitsToFloat(readInt(cpInfoOffset));
             case Symbol.CONSTANT_LONG_TAG:
@@ -3626,11 +3848,11 @@
                 int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];
                 String owner = readClass(referenceCpInfoOffset, charBuffer);
                 String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                 String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
                 boolean isInterface =
-                        b[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
+                        classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;
                 return new Handle(referenceKind, owner, name, descriptor, isInterface);
             case Symbol.CONSTANT_DYNAMIC_TAG:
                 return readConstantDynamic(constantPoolEntryIndex, charBuffer);
             default:
                 throw new IllegalArgumentException();

diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java
@@ -83,23 +83,23 @@
  * "abstract types" hereafter. An abstract type is represented with 4 fields named DIM, KIND, FLAGS
  * and VALUE, packed in a single int value for better performance and memory efficiency:
  *
  * <pre>
  *   =====================================
- *   |.DIM|KIND|FLAG|...............VALUE|
+ *   |...DIM|KIND|.F|...............VALUE|
  *   =====================================
  * </pre>
  *
  * <ul>
- *   <li>the DIM field, stored in the 4 most significant bits, is a signed number of array
- *       dimensions (from -8 to 7, included). It can be retrieved with {@link #DIM_MASK} and a right
- *       shift of {@link #DIM_SHIFT}.
+ *   <li>the DIM field, stored in the 6 most significant bits, is a signed number of array
+ *       dimensions (from -32 to 31, included). It can be retrieved with {@link #DIM_MASK} and a
+ *       right shift of {@link #DIM_SHIFT}.
  *   <li>the KIND field, stored in 4 bits, indicates the kind of VALUE used. These 4 bits can be
  *       retrieved with {@link #KIND_MASK} and, without any shift, must be equal to {@link
  *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link #LOCAL_KIND}
  *       or {@link #STACK_KIND}.
- *   <li>the FLAGS field, stored in 4 bits, contains up to 4 boolean flags. Currently only one flag
+ *   <li>the FLAGS field, stored in 2 bits, contains up to 2 boolean flags. Currently only one flag
  *       is defined, namely {@link #TOP_IF_LONG_OR_DOUBLE_FLAG}.
  *   <li>the VALUE field, stored in the remaining 20 bits, contains either
  *       <ul>
  *         <li>one of the constants {@link #ITEM_TOP}, {@link #ITEM_ASM_BOOLEAN}, {@link
  *             #ITEM_ASM_BYTE}, {@link #ITEM_ASM_CHAR} or {@link #ITEM_ASM_SHORT}, {@link
@@ -118,13 +118,13 @@
  * </ul>
  *
  * <p>Output frames can contain abstract types of any kind and with a positive or negative array
  * dimension (and even unassigned types, represented by 0 - which does not correspond to any valid
  * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND or
- * UNINITIALIZED_KIND abstract types of positive or null array dimension. In all cases the type
- * table contains only internal type names (array type descriptors are forbidden - array dimensions
- * must be represented through the DIM field).
+ * UNINITIALIZED_KIND abstract types of positive or {@literal null} array dimension. In all cases
+ * the type table contains only internal type names (array type descriptors are forbidden - array
+ * dimensions must be represented through the DIM field).
  *
  * <p>The LONG and DOUBLE types are always represented by using two slots (LONG + TOP or DOUBLE +
  * TOP), for local variables as well as in the operand stack. This is necessary to be able to
  * simulate DUPx_y instructions, whose effect would be dependent on the concrete types represented
  * by the abstract types in the stack (which are not always known).
@@ -158,44 +158,51 @@
     private static final int ITEM_ASM_BOOLEAN = 9;
     private static final int ITEM_ASM_BYTE = 10;
     private static final int ITEM_ASM_CHAR = 11;
     private static final int ITEM_ASM_SHORT = 12;
 
+    // The size and offset in bits of each field of an abstract type.
+
+    private static final int DIM_SIZE = 6;
+    private static final int KIND_SIZE = 4;
+    private static final int FLAGS_SIZE = 2;
+    private static final int VALUE_SIZE = 32 - DIM_SIZE - KIND_SIZE - FLAGS_SIZE;
+
+    private static final int DIM_SHIFT = KIND_SIZE + FLAGS_SIZE + VALUE_SIZE;
+    private static final int KIND_SHIFT = FLAGS_SIZE + VALUE_SIZE;
+    private static final int FLAGS_SHIFT = VALUE_SIZE;
+
     // Bitmasks to get each field of an abstract type.
 
-    private static final int DIM_MASK = 0xF0000000;
-    private static final int KIND_MASK = 0x0F000000;
-    private static final int FLAGS_MASK = 0x00F00000;
-    private static final int VALUE_MASK = 0x000FFFFF;
+    private static final int DIM_MASK = ((1 << DIM_SIZE) - 1) << DIM_SHIFT;
+    private static final int KIND_MASK = ((1 << KIND_SIZE) - 1) << KIND_SHIFT;
+    private static final int VALUE_MASK = (1 << VALUE_SIZE) - 1;
 
     // Constants to manipulate the DIM field of an abstract type.
 
-    /** The number of right shift bits to use to get the array dimensions of an abstract type. */
-    private static final int DIM_SHIFT = 28;
-
     /** The constant to be added to an abstract type to get one with one more array dimension. */
     private static final int ARRAY_OF = +1 << DIM_SHIFT;
 
     /** The constant to be added to an abstract type to get one with one less array dimension. */
     private static final int ELEMENT_OF = -1 << DIM_SHIFT;
 
     // Possible values for the KIND field of an abstract type.
 
-    private static final int CONSTANT_KIND = 0x01000000;
-    private static final int REFERENCE_KIND = 0x02000000;
-    private static final int UNINITIALIZED_KIND = 0x03000000;
-    private static final int LOCAL_KIND = 0x04000000;
-    private static final int STACK_KIND = 0x05000000;
+    private static final int CONSTANT_KIND = 1 << KIND_SHIFT;
+    private static final int REFERENCE_KIND = 2 << KIND_SHIFT;
+    private static final int UNINITIALIZED_KIND = 3 << KIND_SHIFT;
+    private static final int LOCAL_KIND = 4 << KIND_SHIFT;
+    private static final int STACK_KIND = 5 << KIND_SHIFT;
 
     // Possible flags for the FLAGS field of an abstract type.
 
     /**
       * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,
       * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been
       * partially overridden with an xSTORE instruction).
       */
-    private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 0x00100000 & FLAGS_MASK;
+    private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 1 << FLAGS_SHIFT;
 
     // Useful predefined abstract types (all the possible CONSTANT_KIND types).
 
     private static final int TOP = CONSTANT_KIND | ITEM_TOP;
     private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;
@@ -571,11 +578,12 @@
       *
       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
       * @param descriptor a type or method descriptor (in which case its return type is pushed).
       */
     private void push(final SymbolTable symbolTable, final String descriptor) {
-        int typeDescriptorOffset = descriptor.charAt(0) == '(' ? descriptor.indexOf(')') + 1 : 0;
+        int typeDescriptorOffset =
+                descriptor.charAt(0) == '(' ? Type.getReturnTypeOffset(descriptor) : 0;
         int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);
         if (abstractType != 0) {
             push(abstractType);
             if (abstractType == LONG || abstractType == DOUBLE) {
                 push(TOP);
@@ -1134,10 +1142,46 @@
 
     // -----------------------------------------------------------------------------------------------
     // Frame merging methods, used in the second step of the stack map frame computation algorithm
     // -----------------------------------------------------------------------------------------------
 
+    /**
+      * Computes the concrete output type corresponding to a given abstract output type.
+      *
+      * @param abstractOutputType an abstract output type.
+      * @param numStack the size of the input stack, used to resolve abstract output types of
+      *     STACK_KIND kind.
+      * @return the concrete output type corresponding to 'abstractOutputType'.
+      */
+    private int getConcreteOutputType(final int abstractOutputType, final int numStack) {
+        int dim = abstractOutputType & DIM_MASK;
+        int kind = abstractOutputType & KIND_MASK;
+        if (kind == LOCAL_KIND) {
+            // By definition, a LOCAL_KIND type designates the concrete type of a local variable at
+            // the beginning of the basic block corresponding to this frame (which is known when
+            // this method is called, but was not when the abstract type was computed).
+            int concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];
+            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
+                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
+                concreteOutputType = TOP;
+            }
+            return concreteOutputType;
+        } else if (kind == STACK_KIND) {
+            // By definition, a STACK_KIND type designates the concrete type of a local variable at
+            // the beginning of the basic block corresponding to this frame (which is known when
+            // this method is called, but was not when the abstract type was computed).
+            int concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];
+            if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
+                    && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
+                concreteOutputType = TOP;
+            }
+            return concreteOutputType;
+        } else {
+            return abstractOutputType;
+        }
+    }
+
     /**
       * Merges the input frame of the given {@link Frame} with the input and output frames of this
       * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation
       * (the input and output frames of this {@link Frame} are never changed).
       *
@@ -1168,33 +1212,11 @@
                 if (abstractOutputType == 0) {
                     // If the local variable has never been assigned in this basic block, it is equal to its
                     // value at the beginning of the block.
                     concreteOutputType = inputLocals[i];
                 } else {
-                    int dim = abstractOutputType & DIM_MASK;
-                    int kind = abstractOutputType & KIND_MASK;
-                    if (kind == LOCAL_KIND) {
-                        // By definition, a LOCAL_KIND type designates the concrete type of a local variable at
-                        // the beginning of the basic block corresponding to this frame (which is known when
-                        // this method is called, but was not when the abstract type was computed).
-                        concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];
-                        if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
-                                && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
-                            concreteOutputType = TOP;
-                        }
-                    } else if (kind == STACK_KIND) {
-                        // By definition, a STACK_KIND type designates the concrete type of a local variable at
-                        // the beginning of the basic block corresponding to this frame (which is known when
-                        // this method is called, but was not when the abstract type was computed).
-                        concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];
-                        if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
-                                && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
-                            concreteOutputType = TOP;
-                        }
-                    } else {
-                        concreteOutputType = abstractOutputType;
-                    }
+                    concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);
                 }
             } else {
                 // If the local variable has never been assigned in this basic block, it is equal to its
                 // value at the beginning of the block.
                 concreteOutputType = inputLocals[i];
@@ -1244,28 +1266,11 @@
             frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);
         }
         // Then, do this for the stack operands that have pushed in the basic block (this code is the
         // same as the one above for local variables).
         for (int i = 0; i < outputStackTop; ++i) {
-            int concreteOutputType;
-            int abstractOutputType = outputStack[i];
-            int dim = abstractOutputType & DIM_MASK;
-            int kind = abstractOutputType & KIND_MASK;
-            if (kind == LOCAL_KIND) {
-                concreteOutputType = dim + inputLocals[abstractOutputType & VALUE_MASK];
-                if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
-                        && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
-                    concreteOutputType = TOP;
-                }
-            } else if (kind == STACK_KIND) {
-                concreteOutputType = dim + inputStack[numStack - (abstractOutputType & VALUE_MASK)];
-                if ((abstractOutputType & TOP_IF_LONG_OR_DOUBLE_FLAG) != 0
-                        && (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {
-                    concreteOutputType = TOP;
-                }
-            } else {
-                concreteOutputType = abstractOutputType;
+            int abstractOutputType = outputStack[i];
             }
             if (initializations != null) {
                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
             }
             frameChanged |=
@@ -1279,14 +1284,14 @@
       * Returns {@literal true} if the type array has been modified by this operation.
       *
       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
       * @param sourceType the abstract type with which the abstract type array element must be merged.
       *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link
-      *     #UNINITIALIZED_KIND} kind, with positive or null array dimensions.
+      *     #UNINITIALIZED_KIND} kind, with positive or {@literal null} array dimensions.
       * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},
-      *     {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or null array
-      *     dimensions.
+      *     {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or {@literal
+      *     null} array dimensions.
       * @param dstIndex the index of the type that must be merged in dstTypes.
       * @return {@literal true} if the type array has been modified by this operation.
       */
     private static boolean merge(
             final SymbolTable symbolTable,

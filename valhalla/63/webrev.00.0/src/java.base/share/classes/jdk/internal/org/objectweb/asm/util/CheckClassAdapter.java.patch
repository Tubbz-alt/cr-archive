diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java
@@ -73,10 +73,11 @@
 import jdk.internal.org.objectweb.asm.FieldVisitor;
 import jdk.internal.org.objectweb.asm.Label;
 import jdk.internal.org.objectweb.asm.MethodVisitor;
 import jdk.internal.org.objectweb.asm.ModuleVisitor;
 import jdk.internal.org.objectweb.asm.Opcodes;
+import jdk.internal.org.objectweb.asm.RecordComponentVisitor;
 import jdk.internal.org.objectweb.asm.Type;
 import jdk.internal.org.objectweb.asm.TypePath;
 import jdk.internal.org.objectweb.asm.TypeReference;
 import jdk.internal.org.objectweb.asm.tree.ClassNode;
 import jdk.internal.org.objectweb.asm.tree.MethodNode;
@@ -138,10 +139,15 @@
  *
  * @author Eric Bruneton
  */
 public class CheckClassAdapter extends ClassVisitor {
 
+    /** The help message shown when command line arguments are incorrect. */
+    private static final String USAGE =
+            "Verifies the given class.\n"
+                    + "Usage: CheckClassAdapter <fully qualified class name or class file name>";
+
     private static final String ERROR_AT = ": error at index ";
 
     /** Whether the bytecode must be checked with a BasicVerifier. */
     private boolean checkDataFlow;
 
@@ -197,30 +203,31 @@
       * @param checkDataFlow whether to perform basic data flow checks. This option requires valid
       *     maxLocals and maxStack values.
       * @throws IllegalStateException If a subclass calls this constructor.
       */
     public CheckClassAdapter(final ClassVisitor classVisitor, final boolean checkDataFlow) {
-        this(Opcodes.ASM7, classVisitor, checkDataFlow);
+        this(/* latest api = */ Opcodes.ASM8, classVisitor, checkDataFlow);
         if (getClass() != CheckClassAdapter.class) {
             throw new IllegalStateException();
         }
     }
 
     /**
       * Constructs a new {@link CheckClassAdapter}.
       *
       * @param api the ASM API version implemented by this visitor. Must be one of {@link
-      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
+      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link
+      *     Opcodes#ASM8}.
       * @param classVisitor the class visitor to which this adapter must delegate calls.
       * @param checkDataFlow {@literal true} to perform basic data flow checks, or {@literal false} to
       *     not perform any data flow check (see {@link CheckMethodAdapter}). This option requires
       *     valid maxLocals and maxStack values.
       */
     protected CheckClassAdapter(
             final int api, final ClassVisitor classVisitor, final boolean checkDataFlow) {
         super(api, classVisitor);
-        this.labelInsnIndices = new HashMap<Label, Integer>();
+        this.labelInsnIndices = new HashMap<>();
         this.checkDataFlow = checkDataFlow;
     }
 
     // -----------------------------------------------------------------------------------------------
     // Implementation of the ClassVisitor interface
@@ -248,10 +255,11 @@
                         | Opcodes.ACC_ABSTRACT
                         | Opcodes.ACC_SYNTHETIC
                         | Opcodes.ACC_ANNOTATION
                         | Opcodes.ACC_ENUM
                         | Opcodes.ACC_DEPRECATED
+                        | Opcodes.ACC_RECORD
                         | Opcodes.ACC_MODULE);
         if (name == null) {
             throw new IllegalArgumentException("Illegal class name (null)");
         }
         if (!name.endsWith("package-info") && !name.endsWith("module-info")) {
@@ -343,10 +351,24 @@
                     "nest member " + nestMember + " should be in the package " + nestMemberPackageName);
         }
         super.visitNestMember(nestMember);
     }
 
+    /**
+      * <b>Experimental, use at your own risk.</b>.
+      *
+      * @param permittedSubtype the internal name of a permitted subtype.
+      * @deprecated this API is experimental.
+      */
+    @Override
+    @Deprecated
+    public void visitPermittedSubtypeExperimental(final String permittedSubtype) {
+        checkState();
+        CheckMethodAdapter.checkInternalName(version, permittedSubtype, "permittedSubtype");
+        super.visitPermittedSubtypeExperimental(permittedSubtype);
+    }
+
     @Override
     public void visitOuterClass(final String owner, final String name, final String descriptor) {
         checkState();
         if (visitOuterClassCalled) {
             throw new IllegalStateException("visitOuterClass can be called only once.");
@@ -391,10 +413,23 @@
                         | Opcodes.ACC_ANNOTATION
                         | Opcodes.ACC_ENUM);
         super.visitInnerClass(name, outerName, innerName, access);
     }
 
+    @Override
+    public RecordComponentVisitor visitRecordComponent(
+            final String name, final String descriptor, final String signature) {
+        checkState();
+        CheckMethodAdapter.checkUnqualifiedName(version, name, "record component name");
+        CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid = */ false);
+        if (signature != null) {
+            checkFieldSignature(signature);
+        }
+        return new CheckRecordComponentAdapter(
+                api, super.visitRecordComponent(name, descriptor, signature));
+    }
+
     @Override
     public FieldVisitor visitField(
             final int access,
             final String name,
             final String descriptor,
@@ -410,10 +445,11 @@
                         | Opcodes.ACC_FINAL
                         | Opcodes.ACC_VOLATILE
                         | Opcodes.ACC_TRANSIENT
                         | Opcodes.ACC_SYNTHETIC
                         | Opcodes.ACC_ENUM
+                        | Opcodes.ACC_MANDATED
                         | Opcodes.ACC_DEPRECATED);
         CheckMethodAdapter.checkUnqualifiedName(version, name, "field name");
         CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid = */ false);
         if (signature != null) {
             checkFieldSignature(signature);
@@ -444,10 +480,11 @@
                         | Opcodes.ACC_VARARGS
                         | Opcodes.ACC_NATIVE
                         | Opcodes.ACC_ABSTRACT
                         | Opcodes.ACC_STRICT
                         | Opcodes.ACC_SYNTHETIC
+                        | Opcodes.ACC_MANDATED
                         | Opcodes.ACC_DEPRECATED);
         if (!"<init>".equals(name) && !"<clinit>".equals(name)) {
             CheckMethodAdapter.checkMethodIdentifier(version, name, "method name");
         }
         CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
@@ -982,14 +1019,23 @@
       *
       * @param args the command line arguments.
       * @throws IOException if the class cannot be found, or if an IO exception occurs.
       */
     public static void main(final String[] args) throws IOException {
+        main(args, new PrintWriter(System.err, true));
+    }
+
+    /**
+      * Checks the given class.
+      *
+      * @param args the command line arguments.
+      * @param logger where to log errors.
+      * @throws IOException if the class cannot be found, or if an IO exception occurs.
+      */
+    static void main(final String[] args, final PrintWriter logger) throws IOException {
         if (args.length != 1) {
-            System.err.println(
-                    "Verifies the given class.\n"
-                            + "Usage: CheckClassAdapter <fully qualified class name or class file name>");
+            logger.println(USAGE);
             return;
         }
 
         ClassReader classReader;
         if (args[0].endsWith(".class")) {
@@ -998,11 +1044,11 @@
             classReader = new ClassReader(inputStream);
         } else {
             classReader = new ClassReader(args[0]);
         }
 
-        verify(classReader, false, new PrintWriter(System.err));
+        verify(classReader, false, logger);
     }
 
     /**
       * Checks the given class.
       *
@@ -1022,23 +1068,25 @@
       * @param loader a <code>ClassLoader</code> which will be used to load referenced classes. May be
       *     {@literal null}.
       * @param printResults whether to print the results of the bytecode verification.
       * @param printWriter where the results (or the stack trace in case of error) must be printed.
       */
+    @SuppressWarnings("deprecation")
     public static void verify(
             final ClassReader classReader,
             final ClassLoader loader,
             final boolean printResults,
             final PrintWriter printWriter) {
         ClassNode classNode = new ClassNode();
         classReader.accept(
-                new CheckClassAdapter(Opcodes.ASM7, classNode, false) {}, ClassReader.SKIP_DEBUG);
+                new CheckClassAdapter(Opcodes.ASM9_EXPERIMENTAL, classNode, false) {},
+                ClassReader.SKIP_DEBUG);
 
         Type syperType = classNode.superName == null ? null : Type.getObjectType(classNode.superName);
         List<MethodNode> methods = classNode.methods;
 
-        List<Type> interfaces = new ArrayList<Type>();
+        List<Type> interfaces = new ArrayList<>();
         for (String interfaceName : classNode.interfaces) {
             interfaces.add(Type.getObjectType(interfaceName));
         }
 
         for (MethodNode method : methods) {
@@ -1046,11 +1094,11 @@
                     new SimpleVerifier(
                             Type.getObjectType(classNode.name),
                             syperType,
                             interfaces,
                             (classNode.access & Opcodes.ACC_INTERFACE) != 0);
-            Analyzer<BasicValue> analyzer = new Analyzer<BasicValue>(verifier);
+            Analyzer<BasicValue> analyzer = new Analyzer<>(verifier);
             if (loader != null) {
                 verifier.setClassLoader(loader);
             }
             try {
                 analyzer.analyze(classNode.name, method);

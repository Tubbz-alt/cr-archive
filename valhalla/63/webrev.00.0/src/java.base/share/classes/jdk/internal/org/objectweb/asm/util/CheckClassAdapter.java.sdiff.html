<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../commons/Remapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CheckMethodAdapter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  58  */
  59 package jdk.internal.org.objectweb.asm.util;
  60 
  61 import java.io.FileInputStream;
  62 import java.io.IOException;
  63 import java.io.InputStream;
  64 import java.io.PrintWriter;
  65 import java.util.ArrayList;
  66 import java.util.HashMap;
  67 import java.util.List;
  68 import java.util.Map;
  69 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  70 import jdk.internal.org.objectweb.asm.Attribute;
  71 import jdk.internal.org.objectweb.asm.ClassReader;
  72 import jdk.internal.org.objectweb.asm.ClassVisitor;
  73 import jdk.internal.org.objectweb.asm.FieldVisitor;
  74 import jdk.internal.org.objectweb.asm.Label;
  75 import jdk.internal.org.objectweb.asm.MethodVisitor;
  76 import jdk.internal.org.objectweb.asm.ModuleVisitor;
  77 import jdk.internal.org.objectweb.asm.Opcodes;

  78 import jdk.internal.org.objectweb.asm.Type;
  79 import jdk.internal.org.objectweb.asm.TypePath;
  80 import jdk.internal.org.objectweb.asm.TypeReference;
  81 import jdk.internal.org.objectweb.asm.tree.ClassNode;
  82 import jdk.internal.org.objectweb.asm.tree.MethodNode;
  83 import jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode;
  84 import jdk.internal.org.objectweb.asm.tree.analysis.Analyzer;
  85 import jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException;
  86 import jdk.internal.org.objectweb.asm.tree.analysis.BasicValue;
  87 import jdk.internal.org.objectweb.asm.tree.analysis.Frame;
  88 import jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier;
  89 
  90 /**
  91  * A {@link ClassVisitor} that checks that its methods are properly used. More precisely this class
  92  * adapter checks each method call individually, based &lt;i&gt;only&lt;/i&gt; on its arguments, but does
  93  * &lt;i&gt;not&lt;/i&gt; check the &lt;i&gt;sequence&lt;/i&gt; of method calls. For example, the invalid sequence {@code
  94  * visitField(ACC_PUBLIC, &quot;i&quot;, &quot;I&quot;, null)} {@code visitField(ACC_PUBLIC, &quot;i&quot;, &quot;D&quot;, null)} will
  95  * &lt;i&gt;not&lt;/i&gt; be detected by this class adapter.
  96  *
  97  * &lt;p&gt;&lt;code&gt;CheckClassAdapter&lt;/code&gt; can be also used to verify bytecode transformations in order to
</pre>
<hr />
<pre>
 123  *   at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:...)
 124  * ...
 125  * remove()V
 126  * 00000 LinkedBlockingQueue$Itr . . . . . . . .  : ICONST_0
 127  * 00001 LinkedBlockingQueue$Itr . . . . . . . .  : I ISTORE 2
 128  * 00001 LinkedBlockingQueue$Itr &lt;b&gt;.&lt;/b&gt; I . . . . . .  :
 129  * ...
 130  * 00071 LinkedBlockingQueue$Itr &lt;b&gt;.&lt;/b&gt; I . . . . . .  : ILOAD 1
 131  * 00072 &lt;b&gt;?&lt;/b&gt; INVOKESPECIAL java/lang/Integer.&amp;lt;init&amp;gt; (I)V
 132  * ...
 133  * &lt;/pre&gt;
 134  *
 135  * &lt;p&gt;The above output shows that the local variable 1, loaded by the &lt;code&gt;ILOAD 1&lt;/code&gt;
 136  * instruction at position &lt;code&gt;00071&lt;/code&gt; is not initialized, whereas the local variable 2 is
 137  * initialized and contains an int value.
 138  *
 139  * @author Eric Bruneton
 140  */
 141 public class CheckClassAdapter extends ClassVisitor {
 142 





 143     private static final String ERROR_AT = &quot;: error at index &quot;;
 144 
 145     /** Whether the bytecode must be checked with a BasicVerifier. */
 146     private boolean checkDataFlow;
 147 
 148     /** The class version number. */
 149     private int version;
 150 
 151     /** Whether the {@link #visit} method has been called. */
 152     private boolean visitCalled;
 153 
 154     /** Whether the {@link #visitModule} method has been called. */
 155     private boolean visitModuleCalled;
 156 
 157     /** Whether the {@link #visitSource} method has been called. */
 158     private boolean visitSourceCalled;
 159 
 160     /** Whether the {@link #visitOuterClass} method has been called. */
 161     private boolean visitOuterClassCalled;
 162 
</pre>
<hr />
<pre>
 182     /**
 183       * Constructs a new {@link CheckClassAdapter}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;.
 184       * Instead, they must use the {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
 185       *
 186       * @param classVisitor the class visitor to which this adapter must delegate calls.
 187       */
 188     public CheckClassAdapter(final ClassVisitor classVisitor) {
 189         this(classVisitor, true);
 190     }
 191 
 192     /**
 193       * Constructs a new {@link CheckClassAdapter}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;.
 194       * Instead, they must use the {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
 195       *
 196       * @param classVisitor the class visitor to which this adapter must delegate calls.
 197       * @param checkDataFlow whether to perform basic data flow checks. This option requires valid
 198       *     maxLocals and maxStack values.
 199       * @throws IllegalStateException If a subclass calls this constructor.
 200       */
 201     public CheckClassAdapter(final ClassVisitor classVisitor, final boolean checkDataFlow) {
<span class="line-modified"> 202         this(Opcodes.ASM7, classVisitor, checkDataFlow);</span>
 203         if (getClass() != CheckClassAdapter.class) {
 204             throw new IllegalStateException();
 205         }
 206     }
 207 
 208     /**
 209       * Constructs a new {@link CheckClassAdapter}.
 210       *
 211       * @param api the ASM API version implemented by this visitor. Must be one of {@link
<span class="line-modified"> 212       *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.</span>

 213       * @param classVisitor the class visitor to which this adapter must delegate calls.
 214       * @param checkDataFlow {@literal true} to perform basic data flow checks, or {@literal false} to
 215       *     not perform any data flow check (see {@link CheckMethodAdapter}). This option requires
 216       *     valid maxLocals and maxStack values.
 217       */
 218     protected CheckClassAdapter(
 219             final int api, final ClassVisitor classVisitor, final boolean checkDataFlow) {
 220         super(api, classVisitor);
<span class="line-modified"> 221         this.labelInsnIndices = new HashMap&lt;Label, Integer&gt;();</span>
 222         this.checkDataFlow = checkDataFlow;
 223     }
 224 
 225     // -----------------------------------------------------------------------------------------------
 226     // Implementation of the ClassVisitor interface
 227     // -----------------------------------------------------------------------------------------------
 228 
 229     @Override
 230     public void visit(
 231             final int version,
 232             final int access,
 233             final String name,
 234             final String signature,
 235             final String superName,
 236             final String[] interfaces) {
 237         if (visitCalled) {
 238             throw new IllegalStateException(&quot;visit must be called only once&quot;);
 239         }
 240         visitCalled = true;
 241         checkState();
 242         checkAccess(
 243                 access,
 244                 Opcodes.ACC_PUBLIC
 245                         | Opcodes.ACC_FINAL
 246                         | Opcodes.ACC_SUPER
 247                         | Opcodes.ACC_INTERFACE
 248                         | Opcodes.ACC_ABSTRACT
 249                         | Opcodes.ACC_SYNTHETIC
 250                         | Opcodes.ACC_ANNOTATION
 251                         | Opcodes.ACC_ENUM
 252                         | Opcodes.ACC_DEPRECATED

 253                         | Opcodes.ACC_MODULE);
 254         if (name == null) {
 255             throw new IllegalArgumentException(&quot;Illegal class name (null)&quot;);
 256         }
 257         if (!name.endsWith(&quot;package-info&quot;) &amp;&amp; !name.endsWith(&quot;module-info&quot;)) {
 258             CheckMethodAdapter.checkInternalName(version, name, &quot;class name&quot;);
 259         }
 260         if (&quot;java/lang/Object&quot;.equals(name)) {
 261             if (superName != null) {
 262                 throw new IllegalArgumentException(
 263                         &quot;The super class name of the Object class must be &#39;null&#39;&quot;);
 264             }
 265         } else if (name.endsWith(&quot;module-info&quot;)) {
 266             if (superName != null) {
 267                 throw new IllegalArgumentException(
 268                         &quot;The super class name of a module-info class must be &#39;null&#39;&quot;);
 269             }
 270         } else {
 271             CheckMethodAdapter.checkInternalName(version, superName, &quot;super class name&quot;);
 272         }
</pre>
<hr />
<pre>
 328     }
 329 
 330     @Override
 331     public void visitNestMember(final String nestMember) {
 332         checkState();
 333         CheckMethodAdapter.checkInternalName(version, nestMember, &quot;nestMember&quot;);
 334         if (visitNestHostCalled) {
 335             throw new IllegalStateException(
 336                     &quot;visitMemberOfNest and visitNestHost are mutually exclusive.&quot;);
 337         }
 338         String packageName = packageName(nestMember);
 339         if (nestMemberPackageName == null) {
 340             nestMemberPackageName = packageName;
 341         } else if (!nestMemberPackageName.equals(packageName)) {
 342             throw new IllegalStateException(
 343                     &quot;nest member &quot; + nestMember + &quot; should be in the package &quot; + nestMemberPackageName);
 344         }
 345         super.visitNestMember(nestMember);
 346     }
 347 














 348     @Override
 349     public void visitOuterClass(final String owner, final String name, final String descriptor) {
 350         checkState();
 351         if (visitOuterClassCalled) {
 352             throw new IllegalStateException(&quot;visitOuterClass can be called only once.&quot;);
 353         }
 354         visitOuterClassCalled = true;
 355         if (owner == null) {
 356             throw new IllegalArgumentException(&quot;Illegal outer class owner&quot;);
 357         }
 358         if (descriptor != null) {
 359             CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
 360         }
 361         super.visitOuterClass(owner, name, descriptor);
 362     }
 363 
 364     @Override
 365     public void visitInnerClass(
 366             final String name, final String outerName, final String innerName, final int access) {
 367         checkState();
</pre>
<hr />
<pre>
 376             }
 377             if (startIndex == 0 || startIndex &lt; innerName.length()) {
 378                 CheckMethodAdapter.checkIdentifier(version, innerName, startIndex, -1, &quot;inner class name&quot;);
 379             }
 380         }
 381         checkAccess(
 382                 access,
 383                 Opcodes.ACC_PUBLIC
 384                         | Opcodes.ACC_PRIVATE
 385                         | Opcodes.ACC_PROTECTED
 386                         | Opcodes.ACC_STATIC
 387                         | Opcodes.ACC_FINAL
 388                         | Opcodes.ACC_INTERFACE
 389                         | Opcodes.ACC_ABSTRACT
 390                         | Opcodes.ACC_SYNTHETIC
 391                         | Opcodes.ACC_ANNOTATION
 392                         | Opcodes.ACC_ENUM);
 393         super.visitInnerClass(name, outerName, innerName, access);
 394     }
 395 













 396     @Override
 397     public FieldVisitor visitField(
 398             final int access,
 399             final String name,
 400             final String descriptor,
 401             final String signature,
 402             final Object value) {
 403         checkState();
 404         checkAccess(
 405                 access,
 406                 Opcodes.ACC_PUBLIC
 407                         | Opcodes.ACC_PRIVATE
 408                         | Opcodes.ACC_PROTECTED
 409                         | Opcodes.ACC_STATIC
 410                         | Opcodes.ACC_FINAL
 411                         | Opcodes.ACC_VOLATILE
 412                         | Opcodes.ACC_TRANSIENT
 413                         | Opcodes.ACC_SYNTHETIC
 414                         | Opcodes.ACC_ENUM

 415                         | Opcodes.ACC_DEPRECATED);
 416         CheckMethodAdapter.checkUnqualifiedName(version, name, &quot;field name&quot;);
 417         CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid = */ false);
 418         if (signature != null) {
 419             checkFieldSignature(signature);
 420         }
 421         if (value != null) {
 422             CheckMethodAdapter.checkConstant(value);
 423         }
 424         return new CheckFieldAdapter(api, super.visitField(access, name, descriptor, signature, value));
 425     }
 426 
 427     @Override
 428     public MethodVisitor visitMethod(
 429             final int access,
 430             final String name,
 431             final String descriptor,
 432             final String signature,
 433             final String[] exceptions) {
 434         checkState();
 435         checkAccess(
 436                 access,
 437                 Opcodes.ACC_PUBLIC
 438                         | Opcodes.ACC_PRIVATE
 439                         | Opcodes.ACC_PROTECTED
 440                         | Opcodes.ACC_STATIC
 441                         | Opcodes.ACC_FINAL
 442                         | Opcodes.ACC_SYNCHRONIZED
 443                         | Opcodes.ACC_BRIDGE
 444                         | Opcodes.ACC_VARARGS
 445                         | Opcodes.ACC_NATIVE
 446                         | Opcodes.ACC_ABSTRACT
 447                         | Opcodes.ACC_STRICT
 448                         | Opcodes.ACC_SYNTHETIC

 449                         | Opcodes.ACC_DEPRECATED);
 450         if (!&quot;&lt;init&gt;&quot;.equals(name) &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name)) {
 451             CheckMethodAdapter.checkMethodIdentifier(version, name, &quot;method name&quot;);
 452         }
 453         CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
 454         if (signature != null) {
 455             checkMethodSignature(signature);
 456         }
 457         if (exceptions != null) {
 458             for (int i = 0; i &lt; exceptions.length; ++i) {
 459                 CheckMethodAdapter.checkInternalName(
 460                         version, exceptions[i], &quot;exception name at index &quot; + i);
 461             }
 462         }
 463         CheckMethodAdapter checkMethodAdapter;
 464         if (checkDataFlow) {
 465             checkMethodAdapter =
 466                     new CheckMethodAdapter(
 467                             api,
 468                             access,
</pre>
<hr />
<pre>
 967         int index = name.lastIndexOf(&#39;/&#39;);
 968         if (index == -1) {
 969             return &quot;&quot;;
 970         }
 971         return name.substring(0, index);
 972     }
 973 
 974     // -----------------------------------------------------------------------------------------------
 975     // Static verification methods
 976     // -----------------------------------------------------------------------------------------------
 977 
 978     /**
 979       * Checks the given class.
 980       *
 981       * &lt;p&gt;Usage: CheckClassAdapter &amp;lt;binary class name or class file name&amp;gt;
 982       *
 983       * @param args the command line arguments.
 984       * @throws IOException if the class cannot be found, or if an IO exception occurs.
 985       */
 986     public static void main(final String[] args) throws IOException {











 987         if (args.length != 1) {
<span class="line-modified"> 988             System.err.println(</span>
<span class="line-removed"> 989                     &quot;Verifies the given class.\n&quot;</span>
<span class="line-removed"> 990                             + &quot;Usage: CheckClassAdapter &lt;fully qualified class name or class file name&gt;&quot;);</span>
 991             return;
 992         }
 993 
 994         ClassReader classReader;
 995         if (args[0].endsWith(&quot;.class&quot;)) {
 996             InputStream inputStream =
 997                     new FileInputStream(args[0]); // NOPMD(AvoidFileStream): can&#39;t fix for 1.5 compatibility
 998             classReader = new ClassReader(inputStream);
 999         } else {
1000             classReader = new ClassReader(args[0]);
1001         }
1002 
<span class="line-modified">1003         verify(classReader, false, new PrintWriter(System.err));</span>
1004     }
1005 
1006     /**
1007       * Checks the given class.
1008       *
1009       * @param classReader the class to be checked.
1010       * @param printResults whether to print the results of the bytecode verification.
1011       * @param printWriter where the results (or the stack trace in case of error) must be printed.
1012       */
1013     public static void verify(
1014             final ClassReader classReader, final boolean printResults, final PrintWriter printWriter) {
1015         verify(classReader, null, printResults, printWriter);
1016     }
1017 
1018     /**
1019       * Checks the given class.
1020       *
1021       * @param classReader the class to be checked.
1022       * @param loader a &lt;code&gt;ClassLoader&lt;/code&gt; which will be used to load referenced classes. May be
1023       *     {@literal null}.
1024       * @param printResults whether to print the results of the bytecode verification.
1025       * @param printWriter where the results (or the stack trace in case of error) must be printed.
1026       */

1027     public static void verify(
1028             final ClassReader classReader,
1029             final ClassLoader loader,
1030             final boolean printResults,
1031             final PrintWriter printWriter) {
1032         ClassNode classNode = new ClassNode();
1033         classReader.accept(
<span class="line-modified">1034                 new CheckClassAdapter(Opcodes.ASM7, classNode, false) {}, ClassReader.SKIP_DEBUG);</span>

1035 
1036         Type syperType = classNode.superName == null ? null : Type.getObjectType(classNode.superName);
1037         List&lt;MethodNode&gt; methods = classNode.methods;
1038 
<span class="line-modified">1039         List&lt;Type&gt; interfaces = new ArrayList&lt;Type&gt;();</span>
1040         for (String interfaceName : classNode.interfaces) {
1041             interfaces.add(Type.getObjectType(interfaceName));
1042         }
1043 
1044         for (MethodNode method : methods) {
1045             SimpleVerifier verifier =
1046                     new SimpleVerifier(
1047                             Type.getObjectType(classNode.name),
1048                             syperType,
1049                             interfaces,
1050                             (classNode.access &amp; Opcodes.ACC_INTERFACE) != 0);
<span class="line-modified">1051             Analyzer&lt;BasicValue&gt; analyzer = new Analyzer&lt;BasicValue&gt;(verifier);</span>
1052             if (loader != null) {
1053                 verifier.setClassLoader(loader);
1054             }
1055             try {
1056                 analyzer.analyze(classNode.name, method);
1057             } catch (AnalyzerException e) {
1058                 e.printStackTrace(printWriter);
1059             }
1060             if (printResults) {
1061                 printAnalyzerResult(method, analyzer, printWriter);
1062             }
1063         }
1064         printWriter.flush();
1065     }
1066 
1067     static void printAnalyzerResult(
1068             final MethodNode method, final Analyzer&lt;BasicValue&gt; analyzer, final PrintWriter printWriter) {
1069         Textifier textifier = new Textifier();
1070         TraceMethodVisitor traceMethodVisitor = new TraceMethodVisitor(textifier);
1071 
</pre>
</td>
<td>
<hr />
<pre>
  58  */
  59 package jdk.internal.org.objectweb.asm.util;
  60 
  61 import java.io.FileInputStream;
  62 import java.io.IOException;
  63 import java.io.InputStream;
  64 import java.io.PrintWriter;
  65 import java.util.ArrayList;
  66 import java.util.HashMap;
  67 import java.util.List;
  68 import java.util.Map;
  69 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  70 import jdk.internal.org.objectweb.asm.Attribute;
  71 import jdk.internal.org.objectweb.asm.ClassReader;
  72 import jdk.internal.org.objectweb.asm.ClassVisitor;
  73 import jdk.internal.org.objectweb.asm.FieldVisitor;
  74 import jdk.internal.org.objectweb.asm.Label;
  75 import jdk.internal.org.objectweb.asm.MethodVisitor;
  76 import jdk.internal.org.objectweb.asm.ModuleVisitor;
  77 import jdk.internal.org.objectweb.asm.Opcodes;
<span class="line-added">  78 import jdk.internal.org.objectweb.asm.RecordComponentVisitor;</span>
  79 import jdk.internal.org.objectweb.asm.Type;
  80 import jdk.internal.org.objectweb.asm.TypePath;
  81 import jdk.internal.org.objectweb.asm.TypeReference;
  82 import jdk.internal.org.objectweb.asm.tree.ClassNode;
  83 import jdk.internal.org.objectweb.asm.tree.MethodNode;
  84 import jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode;
  85 import jdk.internal.org.objectweb.asm.tree.analysis.Analyzer;
  86 import jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException;
  87 import jdk.internal.org.objectweb.asm.tree.analysis.BasicValue;
  88 import jdk.internal.org.objectweb.asm.tree.analysis.Frame;
  89 import jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier;
  90 
  91 /**
  92  * A {@link ClassVisitor} that checks that its methods are properly used. More precisely this class
  93  * adapter checks each method call individually, based &lt;i&gt;only&lt;/i&gt; on its arguments, but does
  94  * &lt;i&gt;not&lt;/i&gt; check the &lt;i&gt;sequence&lt;/i&gt; of method calls. For example, the invalid sequence {@code
  95  * visitField(ACC_PUBLIC, &quot;i&quot;, &quot;I&quot;, null)} {@code visitField(ACC_PUBLIC, &quot;i&quot;, &quot;D&quot;, null)} will
  96  * &lt;i&gt;not&lt;/i&gt; be detected by this class adapter.
  97  *
  98  * &lt;p&gt;&lt;code&gt;CheckClassAdapter&lt;/code&gt; can be also used to verify bytecode transformations in order to
</pre>
<hr />
<pre>
 124  *   at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:...)
 125  * ...
 126  * remove()V
 127  * 00000 LinkedBlockingQueue$Itr . . . . . . . .  : ICONST_0
 128  * 00001 LinkedBlockingQueue$Itr . . . . . . . .  : I ISTORE 2
 129  * 00001 LinkedBlockingQueue$Itr &lt;b&gt;.&lt;/b&gt; I . . . . . .  :
 130  * ...
 131  * 00071 LinkedBlockingQueue$Itr &lt;b&gt;.&lt;/b&gt; I . . . . . .  : ILOAD 1
 132  * 00072 &lt;b&gt;?&lt;/b&gt; INVOKESPECIAL java/lang/Integer.&amp;lt;init&amp;gt; (I)V
 133  * ...
 134  * &lt;/pre&gt;
 135  *
 136  * &lt;p&gt;The above output shows that the local variable 1, loaded by the &lt;code&gt;ILOAD 1&lt;/code&gt;
 137  * instruction at position &lt;code&gt;00071&lt;/code&gt; is not initialized, whereas the local variable 2 is
 138  * initialized and contains an int value.
 139  *
 140  * @author Eric Bruneton
 141  */
 142 public class CheckClassAdapter extends ClassVisitor {
 143 
<span class="line-added"> 144     /** The help message shown when command line arguments are incorrect. */</span>
<span class="line-added"> 145     private static final String USAGE =</span>
<span class="line-added"> 146             &quot;Verifies the given class.\n&quot;</span>
<span class="line-added"> 147                     + &quot;Usage: CheckClassAdapter &lt;fully qualified class name or class file name&gt;&quot;;</span>
<span class="line-added"> 148 </span>
 149     private static final String ERROR_AT = &quot;: error at index &quot;;
 150 
 151     /** Whether the bytecode must be checked with a BasicVerifier. */
 152     private boolean checkDataFlow;
 153 
 154     /** The class version number. */
 155     private int version;
 156 
 157     /** Whether the {@link #visit} method has been called. */
 158     private boolean visitCalled;
 159 
 160     /** Whether the {@link #visitModule} method has been called. */
 161     private boolean visitModuleCalled;
 162 
 163     /** Whether the {@link #visitSource} method has been called. */
 164     private boolean visitSourceCalled;
 165 
 166     /** Whether the {@link #visitOuterClass} method has been called. */
 167     private boolean visitOuterClassCalled;
 168 
</pre>
<hr />
<pre>
 188     /**
 189       * Constructs a new {@link CheckClassAdapter}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;.
 190       * Instead, they must use the {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
 191       *
 192       * @param classVisitor the class visitor to which this adapter must delegate calls.
 193       */
 194     public CheckClassAdapter(final ClassVisitor classVisitor) {
 195         this(classVisitor, true);
 196     }
 197 
 198     /**
 199       * Constructs a new {@link CheckClassAdapter}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;.
 200       * Instead, they must use the {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
 201       *
 202       * @param classVisitor the class visitor to which this adapter must delegate calls.
 203       * @param checkDataFlow whether to perform basic data flow checks. This option requires valid
 204       *     maxLocals and maxStack values.
 205       * @throws IllegalStateException If a subclass calls this constructor.
 206       */
 207     public CheckClassAdapter(final ClassVisitor classVisitor, final boolean checkDataFlow) {
<span class="line-modified"> 208         this(/* latest api = */ Opcodes.ASM8, classVisitor, checkDataFlow);</span>
 209         if (getClass() != CheckClassAdapter.class) {
 210             throw new IllegalStateException();
 211         }
 212     }
 213 
 214     /**
 215       * Constructs a new {@link CheckClassAdapter}.
 216       *
 217       * @param api the ASM API version implemented by this visitor. Must be one of {@link
<span class="line-modified"> 218       *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link</span>
<span class="line-added"> 219       *     Opcodes#ASM8}.</span>
 220       * @param classVisitor the class visitor to which this adapter must delegate calls.
 221       * @param checkDataFlow {@literal true} to perform basic data flow checks, or {@literal false} to
 222       *     not perform any data flow check (see {@link CheckMethodAdapter}). This option requires
 223       *     valid maxLocals and maxStack values.
 224       */
 225     protected CheckClassAdapter(
 226             final int api, final ClassVisitor classVisitor, final boolean checkDataFlow) {
 227         super(api, classVisitor);
<span class="line-modified"> 228         this.labelInsnIndices = new HashMap&lt;&gt;();</span>
 229         this.checkDataFlow = checkDataFlow;
 230     }
 231 
 232     // -----------------------------------------------------------------------------------------------
 233     // Implementation of the ClassVisitor interface
 234     // -----------------------------------------------------------------------------------------------
 235 
 236     @Override
 237     public void visit(
 238             final int version,
 239             final int access,
 240             final String name,
 241             final String signature,
 242             final String superName,
 243             final String[] interfaces) {
 244         if (visitCalled) {
 245             throw new IllegalStateException(&quot;visit must be called only once&quot;);
 246         }
 247         visitCalled = true;
 248         checkState();
 249         checkAccess(
 250                 access,
 251                 Opcodes.ACC_PUBLIC
 252                         | Opcodes.ACC_FINAL
 253                         | Opcodes.ACC_SUPER
 254                         | Opcodes.ACC_INTERFACE
 255                         | Opcodes.ACC_ABSTRACT
 256                         | Opcodes.ACC_SYNTHETIC
 257                         | Opcodes.ACC_ANNOTATION
 258                         | Opcodes.ACC_ENUM
 259                         | Opcodes.ACC_DEPRECATED
<span class="line-added"> 260                         | Opcodes.ACC_RECORD</span>
 261                         | Opcodes.ACC_MODULE);
 262         if (name == null) {
 263             throw new IllegalArgumentException(&quot;Illegal class name (null)&quot;);
 264         }
 265         if (!name.endsWith(&quot;package-info&quot;) &amp;&amp; !name.endsWith(&quot;module-info&quot;)) {
 266             CheckMethodAdapter.checkInternalName(version, name, &quot;class name&quot;);
 267         }
 268         if (&quot;java/lang/Object&quot;.equals(name)) {
 269             if (superName != null) {
 270                 throw new IllegalArgumentException(
 271                         &quot;The super class name of the Object class must be &#39;null&#39;&quot;);
 272             }
 273         } else if (name.endsWith(&quot;module-info&quot;)) {
 274             if (superName != null) {
 275                 throw new IllegalArgumentException(
 276                         &quot;The super class name of a module-info class must be &#39;null&#39;&quot;);
 277             }
 278         } else {
 279             CheckMethodAdapter.checkInternalName(version, superName, &quot;super class name&quot;);
 280         }
</pre>
<hr />
<pre>
 336     }
 337 
 338     @Override
 339     public void visitNestMember(final String nestMember) {
 340         checkState();
 341         CheckMethodAdapter.checkInternalName(version, nestMember, &quot;nestMember&quot;);
 342         if (visitNestHostCalled) {
 343             throw new IllegalStateException(
 344                     &quot;visitMemberOfNest and visitNestHost are mutually exclusive.&quot;);
 345         }
 346         String packageName = packageName(nestMember);
 347         if (nestMemberPackageName == null) {
 348             nestMemberPackageName = packageName;
 349         } else if (!nestMemberPackageName.equals(packageName)) {
 350             throw new IllegalStateException(
 351                     &quot;nest member &quot; + nestMember + &quot; should be in the package &quot; + nestMemberPackageName);
 352         }
 353         super.visitNestMember(nestMember);
 354     }
 355 
<span class="line-added"> 356     /**</span>
<span class="line-added"> 357       * &lt;b&gt;Experimental, use at your own risk.&lt;/b&gt;.</span>
<span class="line-added"> 358       *</span>
<span class="line-added"> 359       * @param permittedSubtype the internal name of a permitted subtype.</span>
<span class="line-added"> 360       * @deprecated this API is experimental.</span>
<span class="line-added"> 361       */</span>
<span class="line-added"> 362     @Override</span>
<span class="line-added"> 363     @Deprecated</span>
<span class="line-added"> 364     public void visitPermittedSubtypeExperimental(final String permittedSubtype) {</span>
<span class="line-added"> 365         checkState();</span>
<span class="line-added"> 366         CheckMethodAdapter.checkInternalName(version, permittedSubtype, &quot;permittedSubtype&quot;);</span>
<span class="line-added"> 367         super.visitPermittedSubtypeExperimental(permittedSubtype);</span>
<span class="line-added"> 368     }</span>
<span class="line-added"> 369 </span>
 370     @Override
 371     public void visitOuterClass(final String owner, final String name, final String descriptor) {
 372         checkState();
 373         if (visitOuterClassCalled) {
 374             throw new IllegalStateException(&quot;visitOuterClass can be called only once.&quot;);
 375         }
 376         visitOuterClassCalled = true;
 377         if (owner == null) {
 378             throw new IllegalArgumentException(&quot;Illegal outer class owner&quot;);
 379         }
 380         if (descriptor != null) {
 381             CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
 382         }
 383         super.visitOuterClass(owner, name, descriptor);
 384     }
 385 
 386     @Override
 387     public void visitInnerClass(
 388             final String name, final String outerName, final String innerName, final int access) {
 389         checkState();
</pre>
<hr />
<pre>
 398             }
 399             if (startIndex == 0 || startIndex &lt; innerName.length()) {
 400                 CheckMethodAdapter.checkIdentifier(version, innerName, startIndex, -1, &quot;inner class name&quot;);
 401             }
 402         }
 403         checkAccess(
 404                 access,
 405                 Opcodes.ACC_PUBLIC
 406                         | Opcodes.ACC_PRIVATE
 407                         | Opcodes.ACC_PROTECTED
 408                         | Opcodes.ACC_STATIC
 409                         | Opcodes.ACC_FINAL
 410                         | Opcodes.ACC_INTERFACE
 411                         | Opcodes.ACC_ABSTRACT
 412                         | Opcodes.ACC_SYNTHETIC
 413                         | Opcodes.ACC_ANNOTATION
 414                         | Opcodes.ACC_ENUM);
 415         super.visitInnerClass(name, outerName, innerName, access);
 416     }
 417 
<span class="line-added"> 418     @Override</span>
<span class="line-added"> 419     public RecordComponentVisitor visitRecordComponent(</span>
<span class="line-added"> 420             final String name, final String descriptor, final String signature) {</span>
<span class="line-added"> 421         checkState();</span>
<span class="line-added"> 422         CheckMethodAdapter.checkUnqualifiedName(version, name, &quot;record component name&quot;);</span>
<span class="line-added"> 423         CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid = */ false);</span>
<span class="line-added"> 424         if (signature != null) {</span>
<span class="line-added"> 425             checkFieldSignature(signature);</span>
<span class="line-added"> 426         }</span>
<span class="line-added"> 427         return new CheckRecordComponentAdapter(</span>
<span class="line-added"> 428                 api, super.visitRecordComponent(name, descriptor, signature));</span>
<span class="line-added"> 429     }</span>
<span class="line-added"> 430 </span>
 431     @Override
 432     public FieldVisitor visitField(
 433             final int access,
 434             final String name,
 435             final String descriptor,
 436             final String signature,
 437             final Object value) {
 438         checkState();
 439         checkAccess(
 440                 access,
 441                 Opcodes.ACC_PUBLIC
 442                         | Opcodes.ACC_PRIVATE
 443                         | Opcodes.ACC_PROTECTED
 444                         | Opcodes.ACC_STATIC
 445                         | Opcodes.ACC_FINAL
 446                         | Opcodes.ACC_VOLATILE
 447                         | Opcodes.ACC_TRANSIENT
 448                         | Opcodes.ACC_SYNTHETIC
 449                         | Opcodes.ACC_ENUM
<span class="line-added"> 450                         | Opcodes.ACC_MANDATED</span>
 451                         | Opcodes.ACC_DEPRECATED);
 452         CheckMethodAdapter.checkUnqualifiedName(version, name, &quot;field name&quot;);
 453         CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid = */ false);
 454         if (signature != null) {
 455             checkFieldSignature(signature);
 456         }
 457         if (value != null) {
 458             CheckMethodAdapter.checkConstant(value);
 459         }
 460         return new CheckFieldAdapter(api, super.visitField(access, name, descriptor, signature, value));
 461     }
 462 
 463     @Override
 464     public MethodVisitor visitMethod(
 465             final int access,
 466             final String name,
 467             final String descriptor,
 468             final String signature,
 469             final String[] exceptions) {
 470         checkState();
 471         checkAccess(
 472                 access,
 473                 Opcodes.ACC_PUBLIC
 474                         | Opcodes.ACC_PRIVATE
 475                         | Opcodes.ACC_PROTECTED
 476                         | Opcodes.ACC_STATIC
 477                         | Opcodes.ACC_FINAL
 478                         | Opcodes.ACC_SYNCHRONIZED
 479                         | Opcodes.ACC_BRIDGE
 480                         | Opcodes.ACC_VARARGS
 481                         | Opcodes.ACC_NATIVE
 482                         | Opcodes.ACC_ABSTRACT
 483                         | Opcodes.ACC_STRICT
 484                         | Opcodes.ACC_SYNTHETIC
<span class="line-added"> 485                         | Opcodes.ACC_MANDATED</span>
 486                         | Opcodes.ACC_DEPRECATED);
 487         if (!&quot;&lt;init&gt;&quot;.equals(name) &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name)) {
 488             CheckMethodAdapter.checkMethodIdentifier(version, name, &quot;method name&quot;);
 489         }
 490         CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
 491         if (signature != null) {
 492             checkMethodSignature(signature);
 493         }
 494         if (exceptions != null) {
 495             for (int i = 0; i &lt; exceptions.length; ++i) {
 496                 CheckMethodAdapter.checkInternalName(
 497                         version, exceptions[i], &quot;exception name at index &quot; + i);
 498             }
 499         }
 500         CheckMethodAdapter checkMethodAdapter;
 501         if (checkDataFlow) {
 502             checkMethodAdapter =
 503                     new CheckMethodAdapter(
 504                             api,
 505                             access,
</pre>
<hr />
<pre>
1004         int index = name.lastIndexOf(&#39;/&#39;);
1005         if (index == -1) {
1006             return &quot;&quot;;
1007         }
1008         return name.substring(0, index);
1009     }
1010 
1011     // -----------------------------------------------------------------------------------------------
1012     // Static verification methods
1013     // -----------------------------------------------------------------------------------------------
1014 
1015     /**
1016       * Checks the given class.
1017       *
1018       * &lt;p&gt;Usage: CheckClassAdapter &amp;lt;binary class name or class file name&amp;gt;
1019       *
1020       * @param args the command line arguments.
1021       * @throws IOException if the class cannot be found, or if an IO exception occurs.
1022       */
1023     public static void main(final String[] args) throws IOException {
<span class="line-added">1024         main(args, new PrintWriter(System.err, true));</span>
<span class="line-added">1025     }</span>
<span class="line-added">1026 </span>
<span class="line-added">1027     /**</span>
<span class="line-added">1028       * Checks the given class.</span>
<span class="line-added">1029       *</span>
<span class="line-added">1030       * @param args the command line arguments.</span>
<span class="line-added">1031       * @param logger where to log errors.</span>
<span class="line-added">1032       * @throws IOException if the class cannot be found, or if an IO exception occurs.</span>
<span class="line-added">1033       */</span>
<span class="line-added">1034     static void main(final String[] args, final PrintWriter logger) throws IOException {</span>
1035         if (args.length != 1) {
<span class="line-modified">1036             logger.println(USAGE);</span>


1037             return;
1038         }
1039 
1040         ClassReader classReader;
1041         if (args[0].endsWith(&quot;.class&quot;)) {
1042             InputStream inputStream =
1043                     new FileInputStream(args[0]); // NOPMD(AvoidFileStream): can&#39;t fix for 1.5 compatibility
1044             classReader = new ClassReader(inputStream);
1045         } else {
1046             classReader = new ClassReader(args[0]);
1047         }
1048 
<span class="line-modified">1049         verify(classReader, false, logger);</span>
1050     }
1051 
1052     /**
1053       * Checks the given class.
1054       *
1055       * @param classReader the class to be checked.
1056       * @param printResults whether to print the results of the bytecode verification.
1057       * @param printWriter where the results (or the stack trace in case of error) must be printed.
1058       */
1059     public static void verify(
1060             final ClassReader classReader, final boolean printResults, final PrintWriter printWriter) {
1061         verify(classReader, null, printResults, printWriter);
1062     }
1063 
1064     /**
1065       * Checks the given class.
1066       *
1067       * @param classReader the class to be checked.
1068       * @param loader a &lt;code&gt;ClassLoader&lt;/code&gt; which will be used to load referenced classes. May be
1069       *     {@literal null}.
1070       * @param printResults whether to print the results of the bytecode verification.
1071       * @param printWriter where the results (or the stack trace in case of error) must be printed.
1072       */
<span class="line-added">1073     @SuppressWarnings(&quot;deprecation&quot;)</span>
1074     public static void verify(
1075             final ClassReader classReader,
1076             final ClassLoader loader,
1077             final boolean printResults,
1078             final PrintWriter printWriter) {
1079         ClassNode classNode = new ClassNode();
1080         classReader.accept(
<span class="line-modified">1081                 new CheckClassAdapter(Opcodes.ASM9_EXPERIMENTAL, classNode, false) {},</span>
<span class="line-added">1082                 ClassReader.SKIP_DEBUG);</span>
1083 
1084         Type syperType = classNode.superName == null ? null : Type.getObjectType(classNode.superName);
1085         List&lt;MethodNode&gt; methods = classNode.methods;
1086 
<span class="line-modified">1087         List&lt;Type&gt; interfaces = new ArrayList&lt;&gt;();</span>
1088         for (String interfaceName : classNode.interfaces) {
1089             interfaces.add(Type.getObjectType(interfaceName));
1090         }
1091 
1092         for (MethodNode method : methods) {
1093             SimpleVerifier verifier =
1094                     new SimpleVerifier(
1095                             Type.getObjectType(classNode.name),
1096                             syperType,
1097                             interfaces,
1098                             (classNode.access &amp; Opcodes.ACC_INTERFACE) != 0);
<span class="line-modified">1099             Analyzer&lt;BasicValue&gt; analyzer = new Analyzer&lt;&gt;(verifier);</span>
1100             if (loader != null) {
1101                 verifier.setClassLoader(loader);
1102             }
1103             try {
1104                 analyzer.analyze(classNode.name, method);
1105             } catch (AnalyzerException e) {
1106                 e.printStackTrace(printWriter);
1107             }
1108             if (printResults) {
1109                 printAnalyzerResult(method, analyzer, printWriter);
1110             }
1111         }
1112         printWriter.flush();
1113     }
1114 
1115     static void printAnalyzerResult(
1116             final MethodNode method, final Analyzer&lt;BasicValue&gt; analyzer, final PrintWriter printWriter) {
1117         Textifier textifier = new Textifier();
1118         TraceMethodVisitor traceMethodVisitor = new TraceMethodVisitor(textifier);
1119 
</pre>
</td>
</tr>
</table>
<center><a href="../commons/Remapper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="CheckMethodAdapter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
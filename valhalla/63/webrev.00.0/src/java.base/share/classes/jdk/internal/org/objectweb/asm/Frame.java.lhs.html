<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * ASM: a very small and fast Java bytecode manipulation framework
  32  * Copyright (c) 2000-2011 INRIA, France Telecom
  33  * All rights reserved.
  34  *
  35  * Redistribution and use in source and binary forms, with or without
  36  * modification, are permitted provided that the following conditions
  37  * are met:
  38  * 1. Redistributions of source code must retain the above copyright
  39  *    notice, this list of conditions and the following disclaimer.
  40  * 2. Redistributions in binary form must reproduce the above copyright
  41  *    notice, this list of conditions and the following disclaimer in the
  42  *    documentation and/or other materials provided with the distribution.
  43  * 3. Neither the name of the copyright holders nor the names of its
  44  *    contributors may be used to endorse or promote products derived from
  45  *    this software without specific prior written permission.
  46  *
  47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  57  * THE POSSIBILITY OF SUCH DAMAGE.
  58  */
  59 package jdk.internal.org.objectweb.asm;
  60 
  61 /**
  62  * The input and output stack map frames of a basic block.
  63  *
  64  * &lt;p&gt;Stack map frames are computed in two steps:
  65  *
  66  * &lt;ul&gt;
  67  *   &lt;li&gt;During the visit of each instruction in MethodWriter, the state of the frame at the end of
  68  *       the current basic block is updated by simulating the action of the instruction on the
  69  *       previous state of this so called &quot;output frame&quot;.
  70  *   &lt;li&gt;After all instructions have been visited, a fix point algorithm is used in MethodWriter to
  71  *       compute the &quot;input frame&quot; of each basic block (i.e. the stack map frame at the beginning of
  72  *       the basic block). See {@link MethodWriter#computeAllFrames}.
  73  * &lt;/ul&gt;
  74  *
  75  * &lt;p&gt;Output stack map frames are computed relatively to the input frame of the basic block, which
  76  * is not yet known when output frames are computed. It is therefore necessary to be able to
  77  * represent abstract types such as &quot;the type at position x in the input frame locals&quot; or &quot;the type
  78  * at position x from the top of the input frame stack&quot; or even &quot;the type at position x in the input
  79  * frame, with y more (or less) array dimensions&quot;. This explains the rather complicated type format
  80  * used in this class, explained below.
  81  *
  82  * &lt;p&gt;The local variables and the operand stack of input and output frames contain values called
  83  * &quot;abstract types&quot; hereafter. An abstract type is represented with 4 fields named DIM, KIND, FLAGS
  84  * and VALUE, packed in a single int value for better performance and memory efficiency:
  85  *
  86  * &lt;pre&gt;
  87  *   =====================================
<a name="1" id="anc1"></a><span class="line-modified">  88  *   |.DIM|KIND|FLAG|...............VALUE|</span>
  89  *   =====================================
  90  * &lt;/pre&gt;
  91  *
  92  * &lt;ul&gt;
<a name="2" id="anc2"></a><span class="line-modified">  93  *   &lt;li&gt;the DIM field, stored in the 4 most significant bits, is a signed number of array</span>
<span class="line-modified">  94  *       dimensions (from -8 to 7, included). It can be retrieved with {@link #DIM_MASK} and a right</span>
<span class="line-modified">  95  *       shift of {@link #DIM_SHIFT}.</span>
  96  *   &lt;li&gt;the KIND field, stored in 4 bits, indicates the kind of VALUE used. These 4 bits can be
  97  *       retrieved with {@link #KIND_MASK} and, without any shift, must be equal to {@link
  98  *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link #LOCAL_KIND}
  99  *       or {@link #STACK_KIND}.
<a name="3" id="anc3"></a><span class="line-modified"> 100  *   &lt;li&gt;the FLAGS field, stored in 4 bits, contains up to 4 boolean flags. Currently only one flag</span>
 101  *       is defined, namely {@link #TOP_IF_LONG_OR_DOUBLE_FLAG}.
 102  *   &lt;li&gt;the VALUE field, stored in the remaining 20 bits, contains either
 103  *       &lt;ul&gt;
 104  *         &lt;li&gt;one of the constants {@link #ITEM_TOP}, {@link #ITEM_ASM_BOOLEAN}, {@link
 105  *             #ITEM_ASM_BYTE}, {@link #ITEM_ASM_CHAR} or {@link #ITEM_ASM_SHORT}, {@link
 106  *             #ITEM_INTEGER}, {@link #ITEM_FLOAT}, {@link #ITEM_LONG}, {@link #ITEM_DOUBLE}, {@link
 107  *             #ITEM_NULL} or {@link #ITEM_UNINITIALIZED_THIS}, if KIND is equal to {@link
 108  *             #CONSTANT_KIND}.
 109  *         &lt;li&gt;the index of a {@link Symbol#TYPE_TAG} {@link Symbol} in the type table of a {@link
 110  *             SymbolTable}, if KIND is equal to {@link #REFERENCE_KIND}.
 111  *         &lt;li&gt;the index of an {@link Symbol#UNINITIALIZED_TYPE_TAG} {@link Symbol} in the type
 112  *             table of a SymbolTable, if KIND is equal to {@link #UNINITIALIZED_KIND}.
 113  *         &lt;li&gt;the index of a local variable in the input stack frame, if KIND is equal to {@link
 114  *             #LOCAL_KIND}.
 115  *         &lt;li&gt;a position relatively to the top of the stack of the input stack frame, if KIND is
 116  *             equal to {@link #STACK_KIND},
 117  *       &lt;/ul&gt;
 118  * &lt;/ul&gt;
 119  *
 120  * &lt;p&gt;Output frames can contain abstract types of any kind and with a positive or negative array
 121  * dimension (and even unassigned types, represented by 0 - which does not correspond to any valid
 122  * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND or
<a name="4" id="anc4"></a><span class="line-modified"> 123  * UNINITIALIZED_KIND abstract types of positive or null array dimension. In all cases the type</span>
<span class="line-modified"> 124  * table contains only internal type names (array type descriptors are forbidden - array dimensions</span>
<span class="line-modified"> 125  * must be represented through the DIM field).</span>
 126  *
 127  * &lt;p&gt;The LONG and DOUBLE types are always represented by using two slots (LONG + TOP or DOUBLE +
 128  * TOP), for local variables as well as in the operand stack. This is necessary to be able to
 129  * simulate DUPx_y instructions, whose effect would be dependent on the concrete types represented
 130  * by the abstract types in the stack (which are not always known).
 131  *
 132  * @author Eric Bruneton
 133  */
 134 class Frame {
 135 
 136     // Constants used in the StackMapTable attribute.
 137     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.
 138 
 139     static final int SAME_FRAME = 0;
 140     static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;
 141     static final int RESERVED = 128;
 142     static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;
 143     static final int CHOP_FRAME = 248;
 144     static final int SAME_FRAME_EXTENDED = 251;
 145     static final int APPEND_FRAME = 252;
 146     static final int FULL_FRAME = 255;
 147 
 148     static final int ITEM_TOP = 0;
 149     static final int ITEM_INTEGER = 1;
 150     static final int ITEM_FLOAT = 2;
 151     static final int ITEM_DOUBLE = 3;
 152     static final int ITEM_LONG = 4;
 153     static final int ITEM_NULL = 5;
 154     static final int ITEM_UNINITIALIZED_THIS = 6;
 155     static final int ITEM_OBJECT = 7;
 156     static final int ITEM_UNINITIALIZED = 8;
 157     // Additional, ASM specific constants used in abstract types below.
 158     private static final int ITEM_ASM_BOOLEAN = 9;
 159     private static final int ITEM_ASM_BYTE = 10;
 160     private static final int ITEM_ASM_CHAR = 11;
 161     private static final int ITEM_ASM_SHORT = 12;
 162 
<a name="5" id="anc5"></a>










 163     // Bitmasks to get each field of an abstract type.
 164 
<a name="6" id="anc6"></a><span class="line-modified"> 165     private static final int DIM_MASK = 0xF0000000;</span>
<span class="line-modified"> 166     private static final int KIND_MASK = 0x0F000000;</span>
<span class="line-modified"> 167     private static final int FLAGS_MASK = 0x00F00000;</span>
<span class="line-removed"> 168     private static final int VALUE_MASK = 0x000FFFFF;</span>
 169 
 170     // Constants to manipulate the DIM field of an abstract type.
 171 
<a name="7" id="anc7"></a><span class="line-removed"> 172     /** The number of right shift bits to use to get the array dimensions of an abstract type. */</span>
<span class="line-removed"> 173     private static final int DIM_SHIFT = 28;</span>
<span class="line-removed"> 174 </span>
 175     /** The constant to be added to an abstract type to get one with one more array dimension. */
 176     private static final int ARRAY_OF = +1 &lt;&lt; DIM_SHIFT;
 177 
 178     /** The constant to be added to an abstract type to get one with one less array dimension. */
 179     private static final int ELEMENT_OF = -1 &lt;&lt; DIM_SHIFT;
 180 
 181     // Possible values for the KIND field of an abstract type.
 182 
<a name="8" id="anc8"></a><span class="line-modified"> 183     private static final int CONSTANT_KIND = 0x01000000;</span>
<span class="line-modified"> 184     private static final int REFERENCE_KIND = 0x02000000;</span>
<span class="line-modified"> 185     private static final int UNINITIALIZED_KIND = 0x03000000;</span>
<span class="line-modified"> 186     private static final int LOCAL_KIND = 0x04000000;</span>
<span class="line-modified"> 187     private static final int STACK_KIND = 0x05000000;</span>
 188 
 189     // Possible flags for the FLAGS field of an abstract type.
 190 
 191     /**
 192       * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,
 193       * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been
 194       * partially overridden with an xSTORE instruction).
 195       */
<a name="9" id="anc9"></a><span class="line-modified"> 196     private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 0x00100000 &amp; FLAGS_MASK;</span>
 197 
 198     // Useful predefined abstract types (all the possible CONSTANT_KIND types).
 199 
 200     private static final int TOP = CONSTANT_KIND | ITEM_TOP;
 201     private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;
 202     private static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;
 203     private static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;
 204     private static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;
 205     private static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;
 206     private static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;
 207     private static final int LONG = CONSTANT_KIND | ITEM_LONG;
 208     private static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;
 209     private static final int NULL = CONSTANT_KIND | ITEM_NULL;
 210     private static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;
 211 
 212     // -----------------------------------------------------------------------------------------------
 213     // Instance fields
 214     // -----------------------------------------------------------------------------------------------
 215 
 216     /** The basic block to which these input and output stack map frames correspond. */
 217     Label owner;
 218 
 219     /** The input stack map frame locals. This is an array of abstract types. */
 220     private int[] inputLocals;
 221 
 222     /** The input stack map frame stack. This is an array of abstract types. */
 223     private int[] inputStack;
 224 
 225     /** The output stack map frame locals. This is an array of abstract types. */
 226     private int[] outputLocals;
 227 
 228     /** The output stack map frame stack. This is an array of abstract types. */
 229     private int[] outputStack;
 230 
 231     /**
 232       * The start of the output stack, relatively to the input stack. This offset is always negative or
 233       * null. A null offset means that the output stack must be appended to the input stack. A -n
 234       * offset means that the first n output stack elements must replace the top n input stack
 235       * elements, and that the other elements must be appended to the input stack.
 236       */
 237     private short outputStackStart;
 238 
 239     /** The index of the top stack element in {@link #outputStack}. */
 240     private short outputStackTop;
 241 
 242     /** The number of types that are initialized in the basic block. See {@link #initializations}. */
 243     private int initializationCount;
 244 
 245     /**
 246       * The abstract types that are initialized in the basic block. A constructor invocation on an
 247       * UNINITIALIZED or UNINITIALIZED_THIS abstract type must replace &lt;i&gt;every occurrence&lt;/i&gt; of this
 248       * type in the local variables and in the operand stack. This cannot be done during the first step
 249       * of the algorithm since, during this step, the local variables and the operand stack types are
 250       * still abstract. It is therefore necessary to store the abstract types of the constructors which
 251       * are invoked in the basic block, in order to do this replacement during the second step of the
 252       * algorithm, where the frames are fully computed. Note that this array can contain abstract types
 253       * that are relative to the input locals or to the input stack.
 254       */
 255     private int[] initializations;
 256 
 257     // -----------------------------------------------------------------------------------------------
 258     // Constructor
 259     // -----------------------------------------------------------------------------------------------
 260 
 261     /**
 262       * Constructs a new Frame.
 263       *
 264       * @param owner the basic block to which these input and output stack map frames correspond.
 265       */
 266     Frame(final Label owner) {
 267         this.owner = owner;
 268     }
 269 
 270     /**
 271       * Sets this frame to the value of the given frame.
 272       *
 273       * &lt;p&gt;WARNING: after this method is called the two frames share the same data structures. It is
 274       * recommended to discard the given frame to avoid unexpected side effects.
 275       *
 276       * @param frame The new frame value.
 277       */
 278     final void copyFrom(final Frame frame) {
 279         inputLocals = frame.inputLocals;
 280         inputStack = frame.inputStack;
 281         outputStackStart = 0;
 282         outputLocals = frame.outputLocals;
 283         outputStack = frame.outputStack;
 284         outputStackTop = frame.outputStackTop;
 285         initializationCount = frame.initializationCount;
 286         initializations = frame.initializations;
 287     }
 288 
 289     // -----------------------------------------------------------------------------------------------
 290     // Static methods to get abstract types from other type formats
 291     // -----------------------------------------------------------------------------------------------
 292 
 293     /**
 294       * Returns the abstract type corresponding to the given public API frame element type.
 295       *
 296       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
 297       * @param type a frame element type described using the same format as in {@link
 298       *     MethodVisitor#visitFrame}, i.e. either {@link Opcodes#TOP}, {@link Opcodes#INTEGER}, {@link
 299       *     Opcodes#FLOAT}, {@link Opcodes#LONG}, {@link Opcodes#DOUBLE}, {@link Opcodes#NULL}, or
 300       *     {@link Opcodes#UNINITIALIZED_THIS}, or the internal name of a class, or a Label designating
 301       *     a NEW instruction (for uninitialized types).
 302       * @return the abstract type corresponding to the given frame element type.
 303       */
 304     static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) {
 305         if (type instanceof Integer) {
 306             return CONSTANT_KIND | ((Integer) type).intValue();
 307         } else if (type instanceof String) {
 308             String descriptor = Type.getObjectType((String) type).getDescriptor();
 309             return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0);
 310         } else {
 311             return UNINITIALIZED_KIND
 312                     | symbolTable.addUninitializedType(&quot;&quot;, ((Label) type).bytecodeOffset);
 313         }
 314     }
 315 
 316     /**
 317       * Returns the abstract type corresponding to the internal name of a class.
 318       *
 319       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
 320       * @param internalName the internal name of a class. This must &lt;i&gt;not&lt;/i&gt; be an array type
 321       *     descriptor.
 322       * @return the abstract type value corresponding to the given internal name.
 323       */
 324     static int getAbstractTypeFromInternalName(
 325             final SymbolTable symbolTable, final String internalName) {
 326         return REFERENCE_KIND | symbolTable.addType(internalName);
 327     }
 328 
 329     /**
 330       * Returns the abstract type corresponding to the given type descriptor.
 331       *
 332       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
 333       * @param buffer a string ending with a type descriptor.
 334       * @param offset the start offset of the type descriptor in buffer.
 335       * @return the abstract type corresponding to the given type descriptor.
 336       */
 337     private static int getAbstractTypeFromDescriptor(
 338             final SymbolTable symbolTable, final String buffer, final int offset) {
 339         String internalName;
 340         switch (buffer.charAt(offset)) {
 341             case &#39;V&#39;:
 342                 return 0;
 343             case &#39;Z&#39;:
 344             case &#39;C&#39;:
 345             case &#39;B&#39;:
 346             case &#39;S&#39;:
 347             case &#39;I&#39;:
 348                 return INTEGER;
 349             case &#39;F&#39;:
 350                 return FLOAT;
 351             case &#39;J&#39;:
 352                 return LONG;
 353             case &#39;D&#39;:
 354                 return DOUBLE;
 355             case &#39;L&#39;:
 356             case &#39;Q&#39;:
 357                 internalName = buffer.substring(offset + 1, buffer.length() - 1);
 358                 return REFERENCE_KIND | symbolTable.addType(internalName);
 359             case &#39;[&#39;:
 360                 int elementDescriptorOffset = offset + 1;
 361                 while (buffer.charAt(elementDescriptorOffset) == &#39;[&#39;) {
 362                     ++elementDescriptorOffset;
 363                 }
 364                 int typeValue;
 365                 switch (buffer.charAt(elementDescriptorOffset)) {
 366                     case &#39;Z&#39;:
 367                         typeValue = BOOLEAN;
 368                         break;
 369                     case &#39;C&#39;:
 370                         typeValue = CHAR;
 371                         break;
 372                     case &#39;B&#39;:
 373                         typeValue = BYTE;
 374                         break;
 375                     case &#39;S&#39;:
 376                         typeValue = SHORT;
 377                         break;
 378                     case &#39;I&#39;:
 379                         typeValue = INTEGER;
 380                         break;
 381                     case &#39;F&#39;:
 382                         typeValue = FLOAT;
 383                         break;
 384                     case &#39;J&#39;:
 385                         typeValue = LONG;
 386                         break;
 387                     case &#39;D&#39;:
 388                         typeValue = DOUBLE;
 389                         break;
 390                     case &#39;L&#39;:
 391                     case &#39;Q&#39;:
 392                         internalName = buffer.substring(elementDescriptorOffset + 1, buffer.length() - 1);
 393                         typeValue = REFERENCE_KIND | symbolTable.addType(internalName);
 394                         break;
 395                     default:
 396                         throw new IllegalArgumentException();
 397                 }
 398                 return ((elementDescriptorOffset - offset) &lt;&lt; DIM_SHIFT) | typeValue;
 399             default:
 400                 throw new IllegalArgumentException();
 401         }
 402     }
 403 
 404     // -----------------------------------------------------------------------------------------------
 405     // Methods related to the input frame
 406     // -----------------------------------------------------------------------------------------------
 407 
 408     /**
 409       * Sets the input frame from the given method description. This method is used to initialize the
 410       * first frame of a method, which is implicit (i.e. not stored explicitly in the StackMapTable
 411       * attribute).
 412       *
 413       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
 414       * @param access the method&#39;s access flags.
 415       * @param descriptor the method descriptor.
 416       * @param maxLocals the maximum number of local variables of the method.
 417       */
 418     final void setInputFrameFromDescriptor(
 419             final SymbolTable symbolTable,
 420             final int access,
 421             final String descriptor,
 422             final int maxLocals) {
 423         inputLocals = new int[maxLocals];
 424         inputStack = new int[0];
 425         int inputLocalIndex = 0;
 426         if ((access &amp; Opcodes.ACC_STATIC) == 0) {
 427             if ((access &amp; Constants.ACC_CONSTRUCTOR) == 0) {
 428                 inputLocals[inputLocalIndex++] =
 429                         REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());
 430             } else {
 431                 inputLocals[inputLocalIndex++] = UNINITIALIZED_THIS;
 432             }
 433         }
 434         for (Type argumentType : Type.getArgumentTypes(descriptor)) {
 435             int abstractType =
 436                     getAbstractTypeFromDescriptor(symbolTable, argumentType.getDescriptor(), 0);
 437             inputLocals[inputLocalIndex++] = abstractType;
 438             if (abstractType == LONG || abstractType == DOUBLE) {
 439                 inputLocals[inputLocalIndex++] = TOP;
 440             }
 441         }
 442         while (inputLocalIndex &lt; maxLocals) {
 443             inputLocals[inputLocalIndex++] = TOP;
 444         }
 445     }
 446 
 447     /**
 448       * Sets the input frame from the given public API frame description.
 449       *
 450       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
 451       * @param numLocal the number of local variables.
 452       * @param local the local variable types, described using the same format as in {@link
 453       *     MethodVisitor#visitFrame}.
 454       * @param numStack the number of operand stack elements.
 455       * @param stack the operand stack types, described using the same format as in {@link
 456       *     MethodVisitor#visitFrame}.
 457       */
 458     final void setInputFrameFromApiFormat(
 459             final SymbolTable symbolTable,
 460             final int numLocal,
 461             final Object[] local,
 462             final int numStack,
 463             final Object[] stack) {
 464         int inputLocalIndex = 0;
 465         for (int i = 0; i &lt; numLocal; ++i) {
 466             inputLocals[inputLocalIndex++] = getAbstractTypeFromApiFormat(symbolTable, local[i]);
 467             if (local[i] == Opcodes.LONG || local[i] == Opcodes.DOUBLE) {
 468                 inputLocals[inputLocalIndex++] = TOP;
 469             }
 470         }
 471         while (inputLocalIndex &lt; inputLocals.length) {
 472             inputLocals[inputLocalIndex++] = TOP;
 473         }
 474         int numStackTop = 0;
 475         for (int i = 0; i &lt; numStack; ++i) {
 476             if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {
 477                 ++numStackTop;
 478             }
 479         }
 480         inputStack = new int[numStack + numStackTop];
 481         int inputStackIndex = 0;
 482         for (int i = 0; i &lt; numStack; ++i) {
 483             inputStack[inputStackIndex++] = getAbstractTypeFromApiFormat(symbolTable, stack[i]);
 484             if (stack[i] == Opcodes.LONG || stack[i] == Opcodes.DOUBLE) {
 485                 inputStack[inputStackIndex++] = TOP;
 486             }
 487         }
 488         outputStackTop = 0;
 489         initializationCount = 0;
 490     }
 491 
 492     final int getInputStackSize() {
 493         return inputStack.length;
 494     }
 495 
 496     // -----------------------------------------------------------------------------------------------
 497     // Methods related to the output frame
 498     // -----------------------------------------------------------------------------------------------
 499 
 500     /**
 501       * Returns the abstract type stored at the given local variable index in the output frame.
 502       *
 503       * @param localIndex the index of the local variable whose value must be returned.
 504       * @return the abstract type stored at the given local variable index in the output frame.
 505       */
 506     private int getLocal(final int localIndex) {
 507         if (outputLocals == null || localIndex &gt;= outputLocals.length) {
 508             // If this local has never been assigned in this basic block, it is still equal to its value
 509             // in the input frame.
 510             return LOCAL_KIND | localIndex;
 511         } else {
 512             int abstractType = outputLocals[localIndex];
 513             if (abstractType == 0) {
 514                 // If this local has never been assigned in this basic block, so it is still equal to its
 515                 // value in the input frame.
 516                 abstractType = outputLocals[localIndex] = LOCAL_KIND | localIndex;
 517             }
 518             return abstractType;
 519         }
 520     }
 521 
 522     /**
 523       * Replaces the abstract type stored at the given local variable index in the output frame.
 524       *
 525       * @param localIndex the index of the output frame local variable that must be set.
 526       * @param abstractType the value that must be set.
 527       */
 528     private void setLocal(final int localIndex, final int abstractType) {
 529         // Create and/or resize the output local variables array if necessary.
 530         if (outputLocals == null) {
 531             outputLocals = new int[10];
 532         }
 533         int outputLocalsLength = outputLocals.length;
 534         if (localIndex &gt;= outputLocalsLength) {
 535             int[] newOutputLocals = new int[Math.max(localIndex + 1, 2 * outputLocalsLength)];
 536             System.arraycopy(outputLocals, 0, newOutputLocals, 0, outputLocalsLength);
 537             outputLocals = newOutputLocals;
 538         }
 539         // Set the local variable.
 540         outputLocals[localIndex] = abstractType;
 541     }
 542 
 543     /**
 544       * Pushes the given abstract type on the output frame stack.
 545       *
 546       * @param abstractType an abstract type.
 547       */
 548     private void push(final int abstractType) {
 549         // Create and/or resize the output stack array if necessary.
 550         if (outputStack == null) {
 551             outputStack = new int[10];
 552         }
 553         int outputStackLength = outputStack.length;
 554         if (outputStackTop &gt;= outputStackLength) {
 555             int[] newOutputStack = new int[Math.max(outputStackTop + 1, 2 * outputStackLength)];
 556             System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);
 557             outputStack = newOutputStack;
 558         }
 559         // Pushes the abstract type on the output stack.
 560         outputStack[outputStackTop++] = abstractType;
 561         // Updates the maximum size reached by the output stack, if needed (note that this size is
 562         // relative to the input stack size, which is not known yet).
 563         short outputStackSize = (short) (outputStackStart + outputStackTop);
 564         if (outputStackSize &gt; owner.outputStackMax) {
 565             owner.outputStackMax = outputStackSize;
 566         }
 567     }
 568 
 569     /**
 570       * Pushes the abstract type corresponding to the given descriptor on the output frame stack.
 571       *
 572       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
 573       * @param descriptor a type or method descriptor (in which case its return type is pushed).
 574       */
 575     private void push(final SymbolTable symbolTable, final String descriptor) {
<a name="10" id="anc10"></a><span class="line-modified"> 576         int typeDescriptorOffset = descriptor.charAt(0) == &#39;(&#39; ? descriptor.indexOf(&#39;)&#39;) + 1 : 0;</span>

 577         int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);
 578         if (abstractType != 0) {
 579             push(abstractType);
 580             if (abstractType == LONG || abstractType == DOUBLE) {
 581                 push(TOP);
 582             }
 583         }
 584     }
 585 
 586     /**
 587       * Pops an abstract type from the output frame stack and returns its value.
 588       *
 589       * @return the abstract type that has been popped from the output frame stack.
 590       */
 591     private int pop() {
 592         if (outputStackTop &gt; 0) {
 593             return outputStack[--outputStackTop];
 594         } else {
 595             // If the output frame stack is empty, pop from the input stack.
 596             return STACK_KIND | -(--outputStackStart);
 597         }
 598     }
 599 
 600     /**
 601       * Pops the given number of abstract types from the output frame stack.
 602       *
 603       * @param elements the number of abstract types that must be popped.
 604       */
 605     private void pop(final int elements) {
 606         if (outputStackTop &gt;= elements) {
 607             outputStackTop -= elements;
 608         } else {
 609             // If the number of elements to be popped is greater than the number of elements in the output
 610             // stack, clear it, and pop the remaining elements from the input stack.
 611             outputStackStart -= elements - outputStackTop;
 612             outputStackTop = 0;
 613         }
 614     }
 615 
 616     /**
 617       * Pops as many abstract types from the output frame stack as described by the given descriptor.
 618       *
 619       * @param descriptor a type or method descriptor (in which case its argument types are popped).
 620       */
 621     private void pop(final String descriptor) {
 622         char firstDescriptorChar = descriptor.charAt(0);
 623         if (firstDescriptorChar == &#39;(&#39;) {
 624             pop((Type.getArgumentsAndReturnSizes(descriptor) &gt;&gt; 2) - 1);
 625         } else if (firstDescriptorChar == &#39;J&#39; || firstDescriptorChar == &#39;D&#39;) {
 626             pop(2);
 627         } else {
 628             pop(1);
 629         }
 630     }
 631 
 632     // -----------------------------------------------------------------------------------------------
 633     // Methods to handle uninitialized types
 634     // -----------------------------------------------------------------------------------------------
 635 
 636     /**
 637       * Adds an abstract type to the list of types on which a constructor is invoked in the basic
 638       * block.
 639       *
 640       * @param abstractType an abstract type on a which a constructor is invoked.
 641       */
 642     private void addInitializedType(final int abstractType) {
 643         // Create and/or resize the initializations array if necessary.
 644         if (initializations == null) {
 645             initializations = new int[2];
 646         }
 647         int initializationsLength = initializations.length;
 648         if (initializationCount &gt;= initializationsLength) {
 649             int[] newInitializations =
 650                     new int[Math.max(initializationCount + 1, 2 * initializationsLength)];
 651             System.arraycopy(initializations, 0, newInitializations, 0, initializationsLength);
 652             initializations = newInitializations;
 653         }
 654         // Store the abstract type.
 655         initializations[initializationCount++] = abstractType;
 656     }
 657 
 658     /**
 659       * Returns the &quot;initialized&quot; abstract type corresponding to the given abstract type.
 660       *
 661       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
 662       * @param abstractType an abstract type.
 663       * @return the REFERENCE_KIND abstract type corresponding to abstractType if it is
 664       *     UNINITIALIZED_THIS or an UNINITIALIZED_KIND abstract type for one of the types on which a
 665       *     constructor is invoked in the basic block. Otherwise returns abstractType.
 666       */
 667     private int getInitializedType(final SymbolTable symbolTable, final int abstractType) {
 668         if (abstractType == UNINITIALIZED_THIS
 669                 || (abstractType &amp; (DIM_MASK | KIND_MASK)) == UNINITIALIZED_KIND) {
 670             for (int i = 0; i &lt; initializationCount; ++i) {
 671                 int initializedType = initializations[i];
 672                 int dim = initializedType &amp; DIM_MASK;
 673                 int kind = initializedType &amp; KIND_MASK;
 674                 int value = initializedType &amp; VALUE_MASK;
 675                 if (kind == LOCAL_KIND) {
 676                     initializedType = dim + inputLocals[value];
 677                 } else if (kind == STACK_KIND) {
 678                     initializedType = dim + inputStack[inputStack.length - value];
 679                 }
 680                 if (abstractType == initializedType) {
 681                     if (abstractType == UNINITIALIZED_THIS) {
 682                         return REFERENCE_KIND | symbolTable.addType(symbolTable.getClassName());
 683                     } else {
 684                         return REFERENCE_KIND
 685                                 | symbolTable.addType(symbolTable.getType(abstractType &amp; VALUE_MASK).value);
 686                     }
 687                 }
 688             }
 689         }
 690         return abstractType;
 691     }
 692 
 693     // -----------------------------------------------------------------------------------------------
 694     // Main method, to simulate the execution of each instruction on the output frame
 695     // -----------------------------------------------------------------------------------------------
 696 
 697     /**
 698       * Simulates the action of the given instruction on the output stack frame.
 699       *
 700       * @param opcode the opcode of the instruction.
 701       * @param arg the numeric operand of the instruction, if any.
 702       * @param argSymbol the Symbol operand of the instruction, if any.
 703       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
 704       */
 705     void execute(
 706             final int opcode, final int arg, final Symbol argSymbol, final SymbolTable symbolTable) {
 707         // Abstract types popped from the stack or read from local variables.
 708         int abstractType1;
 709         int abstractType2;
 710         int abstractType3;
 711         int abstractType4;
 712         switch (opcode) {
 713             case Opcodes.NOP:
 714             case Opcodes.INEG:
 715             case Opcodes.LNEG:
 716             case Opcodes.FNEG:
 717             case Opcodes.DNEG:
 718             case Opcodes.I2B:
 719             case Opcodes.I2C:
 720             case Opcodes.I2S:
 721             case Opcodes.GOTO:
 722             case Opcodes.RETURN:
 723                 break;
 724             case Opcodes.ACONST_NULL:
 725                 push(NULL);
 726                 break;
 727             case Opcodes.ICONST_M1:
 728             case Opcodes.ICONST_0:
 729             case Opcodes.ICONST_1:
 730             case Opcodes.ICONST_2:
 731             case Opcodes.ICONST_3:
 732             case Opcodes.ICONST_4:
 733             case Opcodes.ICONST_5:
 734             case Opcodes.BIPUSH:
 735             case Opcodes.SIPUSH:
 736             case Opcodes.ILOAD:
 737                 push(INTEGER);
 738                 break;
 739             case Opcodes.LCONST_0:
 740             case Opcodes.LCONST_1:
 741             case Opcodes.LLOAD:
 742                 push(LONG);
 743                 push(TOP);
 744                 break;
 745             case Opcodes.FCONST_0:
 746             case Opcodes.FCONST_1:
 747             case Opcodes.FCONST_2:
 748             case Opcodes.FLOAD:
 749                 push(FLOAT);
 750                 break;
 751             case Opcodes.DCONST_0:
 752             case Opcodes.DCONST_1:
 753             case Opcodes.DLOAD:
 754                 push(DOUBLE);
 755                 push(TOP);
 756                 break;
 757             case Opcodes.LDC:
 758                 switch (argSymbol.tag) {
 759                     case Symbol.CONSTANT_INTEGER_TAG:
 760                         push(INTEGER);
 761                         break;
 762                     case Symbol.CONSTANT_LONG_TAG:
 763                         push(LONG);
 764                         push(TOP);
 765                         break;
 766                     case Symbol.CONSTANT_FLOAT_TAG:
 767                         push(FLOAT);
 768                         break;
 769                     case Symbol.CONSTANT_DOUBLE_TAG:
 770                         push(DOUBLE);
 771                         push(TOP);
 772                         break;
 773                     case Symbol.CONSTANT_CLASS_TAG:
 774                         push(REFERENCE_KIND | symbolTable.addType(&quot;java/lang/Class&quot;));
 775                         break;
 776                     case Symbol.CONSTANT_STRING_TAG:
 777                         push(REFERENCE_KIND | symbolTable.addType(&quot;java/lang/String&quot;));
 778                         break;
 779                     case Symbol.CONSTANT_METHOD_TYPE_TAG:
 780                         push(REFERENCE_KIND | symbolTable.addType(&quot;java/lang/invoke/MethodType&quot;));
 781                         break;
 782                     case Symbol.CONSTANT_METHOD_HANDLE_TAG:
 783                         push(REFERENCE_KIND | symbolTable.addType(&quot;java/lang/invoke/MethodHandle&quot;));
 784                         break;
 785                     case Symbol.CONSTANT_DYNAMIC_TAG:
 786                         push(symbolTable, argSymbol.value);
 787                         break;
 788                     default:
 789                         throw new AssertionError();
 790                 }
 791                 break;
 792             case Opcodes.ALOAD:
 793                 push(getLocal(arg));
 794                 break;
 795             case Opcodes.LALOAD:
 796             case Opcodes.D2L:
 797                 pop(2);
 798                 push(LONG);
 799                 push(TOP);
 800                 break;
 801             case Opcodes.DALOAD:
 802             case Opcodes.L2D:
 803                 pop(2);
 804                 push(DOUBLE);
 805                 push(TOP);
 806                 break;
 807             case Opcodes.AALOAD:
 808                 pop(1);
 809                 abstractType1 = pop();
 810                 push(abstractType1 == NULL ? abstractType1 : ELEMENT_OF + abstractType1);
 811                 break;
 812             case Opcodes.ISTORE:
 813             case Opcodes.FSTORE:
 814             case Opcodes.ASTORE:
 815                 abstractType1 = pop();
 816                 setLocal(arg, abstractType1);
 817                 if (arg &gt; 0) {
 818                     int previousLocalType = getLocal(arg - 1);
 819                     if (previousLocalType == LONG || previousLocalType == DOUBLE) {
 820                         setLocal(arg - 1, TOP);
 821                     } else if ((previousLocalType &amp; KIND_MASK) == LOCAL_KIND
 822                             || (previousLocalType &amp; KIND_MASK) == STACK_KIND) {
 823                         // The type of the previous local variable is not known yet, but if it later appears
 824                         // to be LONG or DOUBLE, we should then use TOP instead.
 825                         setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);
 826                     }
 827                 }
 828                 break;
 829             case Opcodes.LSTORE:
 830             case Opcodes.DSTORE:
 831                 pop(1);
 832                 abstractType1 = pop();
 833                 setLocal(arg, abstractType1);
 834                 setLocal(arg + 1, TOP);
 835                 if (arg &gt; 0) {
 836                     int previousLocalType = getLocal(arg - 1);
 837                     if (previousLocalType == LONG || previousLocalType == DOUBLE) {
 838                         setLocal(arg - 1, TOP);
 839                     } else if ((previousLocalType &amp; KIND_MASK) == LOCAL_KIND
 840                             || (previousLocalType &amp; KIND_MASK) == STACK_KIND) {
 841                         // The type of the previous local variable is not known yet, but if it later appears
 842                         // to be LONG or DOUBLE, we should then use TOP instead.
 843                         setLocal(arg - 1, previousLocalType | TOP_IF_LONG_OR_DOUBLE_FLAG);
 844                     }
 845                 }
 846                 break;
 847             case Opcodes.IASTORE:
 848             case Opcodes.BASTORE:
 849             case Opcodes.CASTORE:
 850             case Opcodes.SASTORE:
 851             case Opcodes.FASTORE:
 852             case Opcodes.AASTORE:
 853                 pop(3);
 854                 break;
 855             case Opcodes.LASTORE:
 856             case Opcodes.DASTORE:
 857                 pop(4);
 858                 break;
 859             case Opcodes.POP:
 860             case Opcodes.IFEQ:
 861             case Opcodes.IFNE:
 862             case Opcodes.IFLT:
 863             case Opcodes.IFGE:
 864             case Opcodes.IFGT:
 865             case Opcodes.IFLE:
 866             case Opcodes.IRETURN:
 867             case Opcodes.FRETURN:
 868             case Opcodes.ARETURN:
 869             case Opcodes.TABLESWITCH:
 870             case Opcodes.LOOKUPSWITCH:
 871             case Opcodes.ATHROW:
 872             case Opcodes.MONITORENTER:
 873             case Opcodes.MONITOREXIT:
 874             case Opcodes.IFNULL:
 875             case Opcodes.IFNONNULL:
 876                 pop(1);
 877                 break;
 878             case Opcodes.POP2:
 879             case Opcodes.IF_ICMPEQ:
 880             case Opcodes.IF_ICMPNE:
 881             case Opcodes.IF_ICMPLT:
 882             case Opcodes.IF_ICMPGE:
 883             case Opcodes.IF_ICMPGT:
 884             case Opcodes.IF_ICMPLE:
 885             case Opcodes.IF_ACMPEQ:
 886             case Opcodes.IF_ACMPNE:
 887             case Opcodes.LRETURN:
 888             case Opcodes.DRETURN:
 889                 pop(2);
 890                 break;
 891             case Opcodes.DUP:
 892                 abstractType1 = pop();
 893                 push(abstractType1);
 894                 push(abstractType1);
 895                 break;
 896             case Opcodes.DUP_X1:
 897                 abstractType1 = pop();
 898                 abstractType2 = pop();
 899                 push(abstractType1);
 900                 push(abstractType2);
 901                 push(abstractType1);
 902                 break;
 903             case Opcodes.DUP_X2:
 904                 abstractType1 = pop();
 905                 abstractType2 = pop();
 906                 abstractType3 = pop();
 907                 push(abstractType1);
 908                 push(abstractType3);
 909                 push(abstractType2);
 910                 push(abstractType1);
 911                 break;
 912             case Opcodes.DUP2:
 913                 abstractType1 = pop();
 914                 abstractType2 = pop();
 915                 push(abstractType2);
 916                 push(abstractType1);
 917                 push(abstractType2);
 918                 push(abstractType1);
 919                 break;
 920             case Opcodes.DUP2_X1:
 921                 abstractType1 = pop();
 922                 abstractType2 = pop();
 923                 abstractType3 = pop();
 924                 push(abstractType2);
 925                 push(abstractType1);
 926                 push(abstractType3);
 927                 push(abstractType2);
 928                 push(abstractType1);
 929                 break;
 930             case Opcodes.DUP2_X2:
 931                 abstractType1 = pop();
 932                 abstractType2 = pop();
 933                 abstractType3 = pop();
 934                 abstractType4 = pop();
 935                 push(abstractType2);
 936                 push(abstractType1);
 937                 push(abstractType4);
 938                 push(abstractType3);
 939                 push(abstractType2);
 940                 push(abstractType1);
 941                 break;
 942             case Opcodes.SWAP:
 943                 abstractType1 = pop();
 944                 abstractType2 = pop();
 945                 push(abstractType1);
 946                 push(abstractType2);
 947                 break;
 948             case Opcodes.IALOAD:
 949             case Opcodes.BALOAD:
 950             case Opcodes.CALOAD:
 951             case Opcodes.SALOAD:
 952             case Opcodes.IADD:
 953             case Opcodes.ISUB:
 954             case Opcodes.IMUL:
 955             case Opcodes.IDIV:
 956             case Opcodes.IREM:
 957             case Opcodes.IAND:
 958             case Opcodes.IOR:
 959             case Opcodes.IXOR:
 960             case Opcodes.ISHL:
 961             case Opcodes.ISHR:
 962             case Opcodes.IUSHR:
 963             case Opcodes.L2I:
 964             case Opcodes.D2I:
 965             case Opcodes.FCMPL:
 966             case Opcodes.FCMPG:
 967                 pop(2);
 968                 push(INTEGER);
 969                 break;
 970             case Opcodes.LADD:
 971             case Opcodes.LSUB:
 972             case Opcodes.LMUL:
 973             case Opcodes.LDIV:
 974             case Opcodes.LREM:
 975             case Opcodes.LAND:
 976             case Opcodes.LOR:
 977             case Opcodes.LXOR:
 978                 pop(4);
 979                 push(LONG);
 980                 push(TOP);
 981                 break;
 982             case Opcodes.FALOAD:
 983             case Opcodes.FADD:
 984             case Opcodes.FSUB:
 985             case Opcodes.FMUL:
 986             case Opcodes.FDIV:
 987             case Opcodes.FREM:
 988             case Opcodes.L2F:
 989             case Opcodes.D2F:
 990                 pop(2);
 991                 push(FLOAT);
 992                 break;
 993             case Opcodes.DADD:
 994             case Opcodes.DSUB:
 995             case Opcodes.DMUL:
 996             case Opcodes.DDIV:
 997             case Opcodes.DREM:
 998                 pop(4);
 999                 push(DOUBLE);
1000                 push(TOP);
1001                 break;
1002             case Opcodes.LSHL:
1003             case Opcodes.LSHR:
1004             case Opcodes.LUSHR:
1005                 pop(3);
1006                 push(LONG);
1007                 push(TOP);
1008                 break;
1009             case Opcodes.IINC:
1010                 setLocal(arg, INTEGER);
1011                 break;
1012             case Opcodes.I2L:
1013             case Opcodes.F2L:
1014                 pop(1);
1015                 push(LONG);
1016                 push(TOP);
1017                 break;
1018             case Opcodes.I2F:
1019                 pop(1);
1020                 push(FLOAT);
1021                 break;
1022             case Opcodes.I2D:
1023             case Opcodes.F2D:
1024                 pop(1);
1025                 push(DOUBLE);
1026                 push(TOP);
1027                 break;
1028             case Opcodes.F2I:
1029             case Opcodes.ARRAYLENGTH:
1030             case Opcodes.INSTANCEOF:
1031                 pop(1);
1032                 push(INTEGER);
1033                 break;
1034             case Opcodes.LCMP:
1035             case Opcodes.DCMPL:
1036             case Opcodes.DCMPG:
1037                 pop(4);
1038                 push(INTEGER);
1039                 break;
1040             case Opcodes.JSR:
1041             case Opcodes.RET:
1042                 throw new IllegalArgumentException(&quot;JSR/RET are not supported with computeFrames option&quot;);
1043             case Opcodes.GETSTATIC:
1044                 push(symbolTable, argSymbol.value);
1045                 break;
1046             case Opcodes.PUTSTATIC:
1047                 pop(argSymbol.value);
1048                 break;
1049             case Opcodes.GETFIELD:
1050                 pop(1);
1051                 push(symbolTable, argSymbol.value);
1052                 break;
1053             case Opcodes.PUTFIELD:
1054                 pop(argSymbol.value);
1055                 pop();
1056                 break;
1057             case Opcodes.INVOKEVIRTUAL:
1058             case Opcodes.INVOKESPECIAL:
1059             case Opcodes.INVOKESTATIC:
1060             case Opcodes.INVOKEINTERFACE:
1061                 pop(argSymbol.value);
1062                 if (opcode != Opcodes.INVOKESTATIC) {
1063                     abstractType1 = pop();
1064                     if (opcode == Opcodes.INVOKESPECIAL &amp;&amp; argSymbol.name.charAt(0) == &#39;&lt;&#39;) {
1065                         addInitializedType(abstractType1);
1066                     }
1067                 }
1068                 push(symbolTable, argSymbol.value);
1069                 break;
1070             case Opcodes.INVOKEDYNAMIC:
1071                 pop(argSymbol.value);
1072                 push(symbolTable, argSymbol.value);
1073                 break;
1074             case Opcodes.NEW:
1075                 push(UNINITIALIZED_KIND | symbolTable.addUninitializedType(argSymbol.value, arg));
1076                 break;
1077             case Opcodes.NEWARRAY:
1078                 pop();
1079                 switch (arg) {
1080                     case Opcodes.T_BOOLEAN:
1081                         push(ARRAY_OF | BOOLEAN);
1082                         break;
1083                     case Opcodes.T_CHAR:
1084                         push(ARRAY_OF | CHAR);
1085                         break;
1086                     case Opcodes.T_BYTE:
1087                         push(ARRAY_OF | BYTE);
1088                         break;
1089                     case Opcodes.T_SHORT:
1090                         push(ARRAY_OF | SHORT);
1091                         break;
1092                     case Opcodes.T_INT:
1093                         push(ARRAY_OF | INTEGER);
1094                         break;
1095                     case Opcodes.T_FLOAT:
1096                         push(ARRAY_OF | FLOAT);
1097                         break;
1098                     case Opcodes.T_DOUBLE:
1099                         push(ARRAY_OF | DOUBLE);
1100                         break;
1101                     case Opcodes.T_LONG:
1102                         push(ARRAY_OF | LONG);
1103                         break;
1104                     default:
1105                         throw new IllegalArgumentException();
1106                 }
1107                 break;
1108             case Opcodes.ANEWARRAY:
1109                 String arrayElementType = argSymbol.value;
1110                 pop();
1111                 if (arrayElementType.charAt(0) == &#39;[&#39;) {
1112                     push(symbolTable, &#39;[&#39; + arrayElementType);
1113                 } else {
1114                     push(ARRAY_OF | REFERENCE_KIND | symbolTable.addType(arrayElementType));
1115                 }
1116                 break;
1117             case Opcodes.CHECKCAST:
1118                 String castType = argSymbol.value;
1119                 pop();
1120                 if (castType.charAt(0) == &#39;[&#39;) {
1121                     push(symbolTable, castType);
1122                 } else {
1123                     push(REFERENCE_KIND | symbolTable.addType(castType));
1124                 }
1125                 break;
1126             case Opcodes.MULTIANEWARRAY:
1127                 pop(arg);
1128                 push(symbolTable, argSymbol.value);
1129                 break;
1130             default:
1131                 throw new IllegalArgumentException();
1132         }
1133     }
1134 
1135     // -----------------------------------------------------------------------------------------------
1136     // Frame merging methods, used in the second step of the stack map frame computation algorithm
1137     // -----------------------------------------------------------------------------------------------
1138 
<a name="11" id="anc11"></a>



































1139     /**
1140       * Merges the input frame of the given {@link Frame} with the input and output frames of this
1141       * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation
1142       * (the input and output frames of this {@link Frame} are never changed).
1143       *
1144       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
1145       * @param dstFrame the {@link Frame} whose input frame must be updated. This should be the frame
1146       *     of a successor, in the control flow graph, of the basic block corresponding to this frame.
1147       * @param catchTypeIndex if &#39;frame&#39; corresponds to an exception handler basic block, the type
1148       *     table index of the caught exception type, otherwise 0.
1149       * @return {@literal true} if the input frame of &#39;frame&#39; has been changed by this operation.
1150       */
1151     final boolean merge(
1152             final SymbolTable symbolTable, final Frame dstFrame, final int catchTypeIndex) {
1153         boolean frameChanged = false;
1154 
1155         // Compute the concrete types of the local variables at the end of the basic block corresponding
1156         // to this frame, by resolving its abstract output types, and merge these concrete types with
1157         // those of the local variables in the input frame of dstFrame.
1158         int numLocal = inputLocals.length;
1159         int numStack = inputStack.length;
1160         if (dstFrame.inputLocals == null) {
1161             dstFrame.inputLocals = new int[numLocal];
1162             frameChanged = true;
1163         }
1164         for (int i = 0; i &lt; numLocal; ++i) {
1165             int concreteOutputType;
1166             if (outputLocals != null &amp;&amp; i &lt; outputLocals.length) {
1167                 int abstractOutputType = outputLocals[i];
1168                 if (abstractOutputType == 0) {
1169                     // If the local variable has never been assigned in this basic block, it is equal to its
1170                     // value at the beginning of the block.
1171                     concreteOutputType = inputLocals[i];
1172                 } else {
<a name="12" id="anc12"></a><span class="line-modified">1173                     int dim = abstractOutputType &amp; DIM_MASK;</span>
<span class="line-removed">1174                     int kind = abstractOutputType &amp; KIND_MASK;</span>
<span class="line-removed">1175                     if (kind == LOCAL_KIND) {</span>
<span class="line-removed">1176                         // By definition, a LOCAL_KIND type designates the concrete type of a local variable at</span>
<span class="line-removed">1177                         // the beginning of the basic block corresponding to this frame (which is known when</span>
<span class="line-removed">1178                         // this method is called, but was not when the abstract type was computed).</span>
<span class="line-removed">1179                         concreteOutputType = dim + inputLocals[abstractOutputType &amp; VALUE_MASK];</span>
<span class="line-removed">1180                         if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</span>
<span class="line-removed">1181                                 &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {</span>
<span class="line-removed">1182                             concreteOutputType = TOP;</span>
<span class="line-removed">1183                         }</span>
<span class="line-removed">1184                     } else if (kind == STACK_KIND) {</span>
<span class="line-removed">1185                         // By definition, a STACK_KIND type designates the concrete type of a local variable at</span>
<span class="line-removed">1186                         // the beginning of the basic block corresponding to this frame (which is known when</span>
<span class="line-removed">1187                         // this method is called, but was not when the abstract type was computed).</span>
<span class="line-removed">1188                         concreteOutputType = dim + inputStack[numStack - (abstractOutputType &amp; VALUE_MASK)];</span>
<span class="line-removed">1189                         if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</span>
<span class="line-removed">1190                                 &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {</span>
<span class="line-removed">1191                             concreteOutputType = TOP;</span>
<span class="line-removed">1192                         }</span>
<span class="line-removed">1193                     } else {</span>
<span class="line-removed">1194                         concreteOutputType = abstractOutputType;</span>
<span class="line-removed">1195                     }</span>
1196                 }
1197             } else {
1198                 // If the local variable has never been assigned in this basic block, it is equal to its
1199                 // value at the beginning of the block.
1200                 concreteOutputType = inputLocals[i];
1201             }
1202             // concreteOutputType might be an uninitialized type from the input locals or from the input
1203             // stack. However, if a constructor has been called for this class type in the basic block,
1204             // then this type is no longer uninitialized at the end of basic block.
1205             if (initializations != null) {
1206                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
1207             }
1208             frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);
1209         }
1210 
1211         // If dstFrame is an exception handler block, it can be reached from any instruction of the
1212         // basic block corresponding to this frame, in particular from the first one. Therefore, the
1213         // input locals of dstFrame should be compatible (i.e. merged) with the input locals of this
1214         // frame (and the input stack of dstFrame should be compatible, i.e. merged, with a one
1215         // element stack containing the caught exception type).
1216         if (catchTypeIndex &gt; 0) {
1217             for (int i = 0; i &lt; numLocal; ++i) {
1218                 frameChanged |= merge(symbolTable, inputLocals[i], dstFrame.inputLocals, i);
1219             }
1220             if (dstFrame.inputStack == null) {
1221                 dstFrame.inputStack = new int[1];
1222                 frameChanged = true;
1223             }
1224             frameChanged |= merge(symbolTable, catchTypeIndex, dstFrame.inputStack, 0);
1225             return frameChanged;
1226         }
1227 
1228         // Compute the concrete types of the stack operands at the end of the basic block corresponding
1229         // to this frame, by resolving its abstract output types, and merge these concrete types with
1230         // those of the stack operands in the input frame of dstFrame.
1231         int numInputStack = inputStack.length + outputStackStart;
1232         if (dstFrame.inputStack == null) {
1233             dstFrame.inputStack = new int[numInputStack + outputStackTop];
1234             frameChanged = true;
1235         }
1236         // First, do this for the stack operands that have not been popped in the basic block
1237         // corresponding to this frame, and which are therefore equal to their value in the input
1238         // frame (except for uninitialized types, which may have been initialized).
1239         for (int i = 0; i &lt; numInputStack; ++i) {
1240             int concreteOutputType = inputStack[i];
1241             if (initializations != null) {
1242                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
1243             }
1244             frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);
1245         }
1246         // Then, do this for the stack operands that have pushed in the basic block (this code is the
1247         // same as the one above for local variables).
1248         for (int i = 0; i &lt; outputStackTop; ++i) {
<a name="13" id="anc13"></a><span class="line-modified">1249             int concreteOutputType;</span>
<span class="line-removed">1250             int abstractOutputType = outputStack[i];</span>
<span class="line-removed">1251             int dim = abstractOutputType &amp; DIM_MASK;</span>
<span class="line-removed">1252             int kind = abstractOutputType &amp; KIND_MASK;</span>
<span class="line-removed">1253             if (kind == LOCAL_KIND) {</span>
<span class="line-removed">1254                 concreteOutputType = dim + inputLocals[abstractOutputType &amp; VALUE_MASK];</span>
<span class="line-removed">1255                 if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</span>
<span class="line-removed">1256                         &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {</span>
<span class="line-removed">1257                     concreteOutputType = TOP;</span>
<span class="line-removed">1258                 }</span>
<span class="line-removed">1259             } else if (kind == STACK_KIND) {</span>
<span class="line-removed">1260                 concreteOutputType = dim + inputStack[numStack - (abstractOutputType &amp; VALUE_MASK)];</span>
<span class="line-removed">1261                 if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</span>
<span class="line-removed">1262                         &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {</span>
<span class="line-removed">1263                     concreteOutputType = TOP;</span>
<span class="line-removed">1264                 }</span>
<span class="line-removed">1265             } else {</span>
<span class="line-removed">1266                 concreteOutputType = abstractOutputType;</span>
1267             }
1268             if (initializations != null) {
1269                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
1270             }
1271             frameChanged |=
1272                     merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);
1273         }
1274         return frameChanged;
1275     }
1276 
1277     /**
1278       * Merges the type at the given index in the given abstract type array with the given type.
1279       * Returns {@literal true} if the type array has been modified by this operation.
1280       *
1281       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
1282       * @param sourceType the abstract type with which the abstract type array element must be merged.
1283       *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link
<a name="14" id="anc14"></a><span class="line-modified">1284       *     #UNINITIALIZED_KIND} kind, with positive or null array dimensions.</span>
1285       * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},
<a name="15" id="anc15"></a><span class="line-modified">1286       *     {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or null array</span>
<span class="line-modified">1287       *     dimensions.</span>
1288       * @param dstIndex the index of the type that must be merged in dstTypes.
1289       * @return {@literal true} if the type array has been modified by this operation.
1290       */
1291     private static boolean merge(
1292             final SymbolTable symbolTable,
1293             final int sourceType,
1294             final int[] dstTypes,
1295             final int dstIndex) {
1296         int dstType = dstTypes[dstIndex];
1297         if (dstType == sourceType) {
1298             // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.
1299             return false;
1300         }
1301         int srcType = sourceType;
1302         if ((sourceType &amp; ~DIM_MASK) == NULL) {
1303             if (dstType == NULL) {
1304                 return false;
1305             }
1306             srcType = NULL;
1307         }
1308         if (dstType == 0) {
1309             // If dstTypes[dstIndex] has never been assigned, merge(srcType, dstType) = srcType.
1310             dstTypes[dstIndex] = srcType;
1311             return true;
1312         }
1313         int mergedType;
1314         if ((dstType &amp; DIM_MASK) != 0 || (dstType &amp; KIND_MASK) == REFERENCE_KIND) {
1315             // If dstType is a reference type of any array dimension.
1316             if (srcType == NULL) {
1317                 // If srcType is the NULL type, merge(srcType, dstType) = dstType, so there is no change.
1318                 return false;
1319             } else if ((srcType &amp; (DIM_MASK | KIND_MASK)) == (dstType &amp; (DIM_MASK | KIND_MASK))) {
1320                 // If srcType has the same array dimension and the same kind as dstType.
1321                 if ((dstType &amp; KIND_MASK) == REFERENCE_KIND) {
1322                     // If srcType and dstType are reference types with the same array dimension,
1323                     // merge(srcType, dstType) = dim(srcType) | common super class of srcType and dstType.
1324                     mergedType =
1325                             (srcType &amp; DIM_MASK)
1326                                     | REFERENCE_KIND
1327                                     | symbolTable.addMergedType(srcType &amp; VALUE_MASK, dstType &amp; VALUE_MASK);
1328                 } else {
1329                     // If srcType and dstType are array types of equal dimension but different element types,
1330                     // merge(srcType, dstType) = dim(srcType) - 1 | java/lang/Object.
1331                     int mergedDim = ELEMENT_OF + (srcType &amp; DIM_MASK);
1332                     mergedType = mergedDim | REFERENCE_KIND | symbolTable.addType(&quot;java/lang/Object&quot;);
1333                 }
1334             } else if ((srcType &amp; DIM_MASK) != 0 || (srcType &amp; KIND_MASK) == REFERENCE_KIND) {
1335                 // If srcType is any other reference or array type,
1336                 // merge(srcType, dstType) = min(srcDdim, dstDim) | java/lang/Object
1337                 // where srcDim is the array dimension of srcType, minus 1 if srcType is an array type
1338                 // with a non reference element type (and similarly for dstDim).
1339                 int srcDim = srcType &amp; DIM_MASK;
1340                 if (srcDim != 0 &amp;&amp; (srcType &amp; KIND_MASK) != REFERENCE_KIND) {
1341                     srcDim = ELEMENT_OF + srcDim;
1342                 }
1343                 int dstDim = dstType &amp; DIM_MASK;
1344                 if (dstDim != 0 &amp;&amp; (dstType &amp; KIND_MASK) != REFERENCE_KIND) {
1345                     dstDim = ELEMENT_OF + dstDim;
1346                 }
1347                 mergedType =
1348                         Math.min(srcDim, dstDim) | REFERENCE_KIND | symbolTable.addType(&quot;java/lang/Object&quot;);
1349             } else {
1350                 // If srcType is any other type, merge(srcType, dstType) = TOP.
1351                 mergedType = TOP;
1352             }
1353         } else if (dstType == NULL) {
1354             // If dstType is the NULL type, merge(srcType, dstType) = srcType, or TOP if srcType is not a
1355             // an array type or a reference type.
1356             mergedType =
1357                     (srcType &amp; DIM_MASK) != 0 || (srcType &amp; KIND_MASK) == REFERENCE_KIND ? srcType : TOP;
1358         } else {
1359             // If dstType is any other type, merge(srcType, dstType) = TOP whatever srcType.
1360             mergedType = TOP;
1361         }
1362         if (mergedType != dstType) {
1363             dstTypes[dstIndex] = mergedType;
1364             return true;
1365         }
1366         return false;
1367     }
1368 
1369     // -----------------------------------------------------------------------------------------------
1370     // Frame output methods, to generate StackMapFrame attributes
1371     // -----------------------------------------------------------------------------------------------
1372 
1373     /**
1374       * Makes the given {@link MethodWriter} visit the input frame of this {@link Frame}. The visit is
1375       * done with the {@link MethodWriter#visitFrameStart}, {@link MethodWriter#visitAbstractType} and
1376       * {@link MethodWriter#visitFrameEnd} methods.
1377       *
1378       * @param methodWriter the {@link MethodWriter} that should visit the input frame of this {@link
1379       *     Frame}.
1380       */
1381     final void accept(final MethodWriter methodWriter) {
1382         // Compute the number of locals, ignoring TOP types that are just after a LONG or a DOUBLE, and
1383         // all trailing TOP types.
1384         int[] localTypes = inputLocals;
1385         int numLocal = 0;
1386         int numTrailingTop = 0;
1387         int i = 0;
1388         while (i &lt; localTypes.length) {
1389             int localType = localTypes[i];
1390             i += (localType == LONG || localType == DOUBLE) ? 2 : 1;
1391             if (localType == TOP) {
1392                 numTrailingTop++;
1393             } else {
1394                 numLocal += numTrailingTop + 1;
1395                 numTrailingTop = 0;
1396             }
1397         }
1398         // Compute the stack size, ignoring TOP types that are just after a LONG or a DOUBLE.
1399         int[] stackTypes = inputStack;
1400         int numStack = 0;
1401         i = 0;
1402         while (i &lt; stackTypes.length) {
1403             int stackType = stackTypes[i];
1404             i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;
1405             numStack++;
1406         }
1407         // Visit the frame and its content.
1408         int frameIndex = methodWriter.visitFrameStart(owner.bytecodeOffset, numLocal, numStack);
1409         i = 0;
1410         while (numLocal-- &gt; 0) {
1411             int localType = localTypes[i];
1412             i += (localType == LONG || localType == DOUBLE) ? 2 : 1;
1413             methodWriter.visitAbstractType(frameIndex++, localType);
1414         }
1415         i = 0;
1416         while (numStack-- &gt; 0) {
1417             int stackType = stackTypes[i];
1418             i += (stackType == LONG || stackType == DOUBLE) ? 2 : 1;
1419             methodWriter.visitAbstractType(frameIndex++, stackType);
1420         }
1421         methodWriter.visitFrameEnd();
1422     }
1423 
1424     /**
1425       * Put the given abstract type in the given ByteVector, using the JVMS verification_type_info
1426       * format used in StackMapTable attributes.
1427       *
1428       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
1429       * @param abstractType an abstract type, restricted to {@link Frame#CONSTANT_KIND}, {@link
1430       *     Frame#REFERENCE_KIND} or {@link Frame#UNINITIALIZED_KIND} types.
1431       * @param output where the abstract type must be put.
1432       * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4&quot;&gt;JVMS
1433       *     4.7.4&lt;/a&gt;
1434       */
1435     static void putAbstractType(
1436             final SymbolTable symbolTable, final int abstractType, final ByteVector output) {
1437         int arrayDimensions = (abstractType &amp; Frame.DIM_MASK) &gt;&gt; DIM_SHIFT;
1438         if (arrayDimensions == 0) {
1439             int typeValue = abstractType &amp; VALUE_MASK;
1440             switch (abstractType &amp; KIND_MASK) {
1441                 case CONSTANT_KIND:
1442                     output.putByte(typeValue);
1443                     break;
1444                 case REFERENCE_KIND:
1445                     output
1446                             .putByte(ITEM_OBJECT)
1447                             .putShort(symbolTable.addConstantClass(symbolTable.getType(typeValue).value).index);
1448                     break;
1449                 case UNINITIALIZED_KIND:
1450                     output.putByte(ITEM_UNINITIALIZED).putShort((int) symbolTable.getType(typeValue).data);
1451                     break;
1452                 default:
1453                     throw new AssertionError();
1454             }
1455         } else {
1456             // Case of an array type, we need to build its descriptor first.
1457             StringBuilder typeDescriptor = new StringBuilder();
1458             while (arrayDimensions-- &gt; 0) {
1459                 typeDescriptor.append(&#39;[&#39;);
1460             }
1461             if ((abstractType &amp; KIND_MASK) == REFERENCE_KIND) {
1462                 typeDescriptor
1463                         .append(&#39;L&#39;)
1464                         .append(symbolTable.getType(abstractType &amp; VALUE_MASK).value)
1465                         .append(&#39;;&#39;);
1466             } else {
1467                 switch (abstractType &amp; VALUE_MASK) {
1468                     case Frame.ITEM_ASM_BOOLEAN:
1469                         typeDescriptor.append(&#39;Z&#39;);
1470                         break;
1471                     case Frame.ITEM_ASM_BYTE:
1472                         typeDescriptor.append(&#39;B&#39;);
1473                         break;
1474                     case Frame.ITEM_ASM_CHAR:
1475                         typeDescriptor.append(&#39;C&#39;);
1476                         break;
1477                     case Frame.ITEM_ASM_SHORT:
1478                         typeDescriptor.append(&#39;S&#39;);
1479                         break;
1480                     case Frame.ITEM_INTEGER:
1481                         typeDescriptor.append(&#39;I&#39;);
1482                         break;
1483                     case Frame.ITEM_FLOAT:
1484                         typeDescriptor.append(&#39;F&#39;);
1485                         break;
1486                     case Frame.ITEM_LONG:
1487                         typeDescriptor.append(&#39;J&#39;);
1488                         break;
1489                     case Frame.ITEM_DOUBLE:
1490                         typeDescriptor.append(&#39;D&#39;);
1491                         break;
1492                     default:
1493                         throw new AssertionError();
1494                 }
1495             }
1496             output
1497                     .putByte(ITEM_OBJECT)
1498                     .putShort(symbolTable.addConstantClass(typeDescriptor.toString()).index);
1499         }
1500     }
1501 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
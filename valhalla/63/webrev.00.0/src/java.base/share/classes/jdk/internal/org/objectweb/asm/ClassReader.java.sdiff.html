<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../java/lang/reflect/Field.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Constants.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  64 
  65 /**
  66  * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java
  67  * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the
  68  * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode
  69  * instruction encountered.
  70  *
  71  * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html&quot;&gt;JVMS 4&lt;/a&gt;
  72  * @author Eric Bruneton
  73  * @author Eugene Kuleshov
  74  */
  75 public class ClassReader {
  76 
  77     /**
  78       * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed
  79       * nor visited.
  80       */
  81     public static final int SKIP_CODE = 1;
  82 
  83     /**
<span class="line-modified">  84       * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable</span>
<span class="line-modified">  85       * and LineNumberTable attributes. If this flag is set these attributes are neither parsed nor</span>
<span class="line-modified">  86       * visited (i.e. {@link ClassVisitor#visitSource}, {@link MethodVisitor#visitLocalVariable} and</span>
<span class="line-modified">  87       * {@link MethodVisitor#visitLineNumber} are not called).</span>

  88       */
  89     public static final int SKIP_DEBUG = 2;
  90 
  91     /**
  92       * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes
  93       * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag
  94       * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames
  95       * that will be ignored and recomputed from scratch.
  96       */
  97     public static final int SKIP_FRAMES = 4;
  98 
  99     /**
 100       * A flag to expand the stack map frames. By default stack map frames are visited in their
 101       * original format (i.e. &quot;expanded&quot; for classes whose version is less than V1_6, and &quot;compressed&quot;
 102       * for the other classes). If this flag is set, stack map frames are always visited in expanded
 103       * format (this option adds a decompression/compression step in ClassReader and ClassWriter which
 104       * degrades performance quite a lot).
 105       */
 106     public static final int EXPAND_FRAMES = 8;
 107 
 108     /**
 109       * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode
 110       * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset
 111       * reserved for it is not sufficient to store the bytecode offset. In this case the jump
 112       * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes
 113       * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing
 114       * such instructions, in order to replace them with standard instructions. In addition, when this
 115       * flag is used, goto_w and jsr_w are &lt;i&gt;not&lt;/i&gt; converted into goto and jsr, to make sure that
 116       * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a
 117       * goto_w in ClassWriter cannot occur.
 118       */
 119     static final int EXPAND_ASM_INSNS = 256;
 120 
 121     /** The size of the temporary byte array used to read class input streams chunk by chunk. */
 122     private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;
 123 










 124     /**
 125       * A byte array containing the JVMS ClassFile structure to be parsed. &lt;i&gt;The content of this array
 126       * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally
 127       * not needed by class visitors.&lt;/i&gt;
 128       *
 129       * &lt;p&gt;NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not
 130       * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct
 131       * ClassFile element offsets within this byte array.
 132       */
<span class="line-modified"> 133     // DontCheck(MemberName): can&#39;t be renamed (for backward binary compatibility).</span>
<span class="line-removed"> 134     public final byte[] b;</span>
 135 
 136     /**
<span class="line-modified"> 137       * The offset in bytes, in {@link #b}, of each cp_info entry of the ClassFile&#39;s constant_pool</span>
<span class="line-modified"> 138       * array, &lt;i&gt;plus one&lt;/i&gt;. In other words, the offset of constant pool entry i is given by</span>
<span class="line-modified"> 139       * cpInfoOffsets[i] - 1, i.e. its cp_info&#39;s tag field is given by b[cpInfoOffsets[i] - 1].</span>

 140       */
 141     private final int[] cpInfoOffsets;
 142 
 143     /**
 144       * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids
 145       * multiple parsing of a given CONSTANT_Utf8 constant pool item.
 146       */
 147     private final String[] constantUtf8Values;
 148 
 149     /**
 150       * The ConstantDynamic objects corresponding to the CONSTANT_Dynamic constant pool items. This
 151       * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.
 152       */
 153     private final ConstantDynamic[] constantDynamicValues;
 154 
 155     /**
<span class="line-modified"> 156       * The start offsets in {@link #b} of each element of the bootstrap_methods array (in the</span>
<span class="line-modified"> 157       * BootstrapMethods attribute).</span>
 158       *
 159       * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23&quot;&gt;JVMS
 160       *     4.7.23&lt;/a&gt;
 161       */
 162     private final int[] bootstrapMethodOffsets;
 163 
 164     /**
 165       * A conservative estimate of the maximum length of the strings contained in the constant pool of
 166       * the class.
 167       */
 168     private final int maxStringLength;
 169 
<span class="line-modified"> 170     /** The offset in bytes, in {@link #b}, of the ClassFile&#39;s access_flags field. */</span>
 171     public final int header;
 172 
 173     // -----------------------------------------------------------------------------------------------
 174     // Constructors
 175     // -----------------------------------------------------------------------------------------------
 176 
 177     /**
 178       * Constructs a new {@link ClassReader} object.
 179       *
 180       * @param classFile the JVMS ClassFile structure to be read.
 181       */
 182     public ClassReader(final byte[] classFile) {
 183         this(classFile, 0, classFile.length);
 184     }
 185 
 186     /**
 187       * Constructs a new {@link ClassReader} object.
 188       *
 189       * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
 190       * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
 191       * @param classFileLength the length in bytes of the ClassFile to be read.
 192       */
 193     public ClassReader(
 194             final byte[] classFileBuffer,
 195             final int classFileOffset,
 196             final int classFileLength) { // NOPMD(UnusedFormalParameter) used for backward compatibility.
 197         this(classFileBuffer, classFileOffset, /* checkClassVersion = */ true);
 198     }
 199 
 200     /**
 201       * Constructs a new {@link ClassReader} object. &lt;i&gt;This internal constructor must not be exposed
 202       * as a public API&lt;/i&gt;.
 203       *
 204       * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
 205       * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
 206       * @param checkClassVersion whether to check the class version or not.
 207       */
 208     ClassReader(
 209             final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
<span class="line-modified"> 210         b = classFileBuffer;</span>

 211         // Check the class&#39; major_version. This field is after the magic and minor_version fields, which
 212         // use 4 and 2 bytes respectively.
 213         if (checkClassVersion &amp;&amp; readShort(classFileOffset + 6) &gt; Opcodes.V15) {
 214             throw new IllegalArgumentException(
 215                     &quot;Unsupported class file major version &quot; + readShort(classFileOffset + 6));
 216         }
 217         // Create the constant pool arrays. The constant_pool_count field is after the magic,
 218         // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.
 219         int constantPoolCount = readUnsignedShort(classFileOffset + 8);
 220         cpInfoOffsets = new int[constantPoolCount];
 221         constantUtf8Values = new String[constantPoolCount];
 222         // Compute the offset of each constant pool entry, as well as a conservative estimate of the
 223         // maximum length of the constant pool strings. The first constant pool entry is after the
 224         // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2
 225         // bytes respectively.
 226         int currentCpInfoIndex = 1;
 227         int currentCpInfoOffset = classFileOffset + 10;
 228         int currentMaxStringLength = 0;

 229         boolean hasConstantDynamic = false;
<span class="line-removed"> 230         boolean hasConstantInvokeDynamic = false;</span>
 231         // The offset of the other entries depend on the total size of all the previous entries.
 232         while (currentCpInfoIndex &lt; constantPoolCount) {
 233             cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;
 234             int cpInfoSize;
 235             switch (classFileBuffer[currentCpInfoOffset]) {
 236                 case Symbol.CONSTANT_FIELDREF_TAG:
 237                 case Symbol.CONSTANT_METHODREF_TAG:
 238                 case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:
 239                 case Symbol.CONSTANT_INTEGER_TAG:
 240                 case Symbol.CONSTANT_FLOAT_TAG:
 241                 case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
 242                     cpInfoSize = 5;
 243                     break;
 244                 case Symbol.CONSTANT_DYNAMIC_TAG:
 245                     cpInfoSize = 5;

 246                     hasConstantDynamic = true;
 247                     break;
 248                 case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
 249                     cpInfoSize = 5;
<span class="line-modified"> 250                     hasConstantInvokeDynamic = true;</span>
 251                     break;
 252                 case Symbol.CONSTANT_LONG_TAG:
 253                 case Symbol.CONSTANT_DOUBLE_TAG:
 254                     cpInfoSize = 9;
 255                     currentCpInfoIndex++;
 256                     break;
 257                 case Symbol.CONSTANT_UTF8_TAG:
 258                     cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);
 259                     if (cpInfoSize &gt; currentMaxStringLength) {
 260                         // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate
 261                         // of the length in characters of the corresponding string, and is much cheaper to
 262                         // compute than this exact length.
 263                         currentMaxStringLength = cpInfoSize;
 264                     }
 265                     break;
 266                 case Symbol.CONSTANT_METHOD_HANDLE_TAG:
 267                     cpInfoSize = 4;
 268                     break;
 269                 case Symbol.CONSTANT_CLASS_TAG:
 270                 case Symbol.CONSTANT_STRING_TAG:
 271                 case Symbol.CONSTANT_METHOD_TYPE_TAG:
 272                 case Symbol.CONSTANT_PACKAGE_TAG:
 273                 case Symbol.CONSTANT_MODULE_TAG:
 274                     cpInfoSize = 3;
 275                     break;
 276                 default:
 277                     throw new IllegalArgumentException();
 278             }
 279             currentCpInfoOffset += cpInfoSize;
 280         }
 281         maxStringLength = currentMaxStringLength;
 282         // The Classfile&#39;s access_flags field is just after the last constant pool entry.
 283         header = currentCpInfoOffset;
 284 
 285         // Allocate the cache of ConstantDynamic values, if there is at least one.
 286         constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;
 287 
 288         // Read the BootstrapMethods attribute, if any (only get the offset of each method).
 289         bootstrapMethodOffsets =
<span class="line-modified"> 290                 (hasConstantDynamic | hasConstantInvokeDynamic)</span>
<span class="line-removed"> 291                         ? readBootstrapMethodsAttribute(currentMaxStringLength)</span>
<span class="line-removed"> 292                         : null;</span>
 293     }
 294 
 295     /**
 296       * Constructs a new {@link ClassReader} object.
 297       *
 298       * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input
 299       *     stream must contain nothing more than the ClassFile structure itself. It is read from its
 300       *     current position to its end.
 301       * @throws IOException if a problem occurs during reading.
 302       */
 303     public ClassReader(final InputStream inputStream) throws IOException {
 304         this(readStream(inputStream, false));
 305     }
 306 
 307     /**
 308       * Constructs a new {@link ClassReader} object.
 309       *
 310       * @param className the fully qualified name of the class to be read. The ClassFile structure is
 311       *     retrieved with the current class loader&#39;s {@link ClassLoader#getSystemResourceAsStream}.
 312       * @throws IOException if an exception occurs during reading.
 313       */
 314     public ClassReader(final String className) throws IOException {
 315         this(
 316                 readStream(
 317                         ClassLoader.getSystemResourceAsStream(className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;), true));
 318     }
 319 
 320     /**
 321       * Reads the given input stream and returns its content as a byte array.
 322       *
 323       * @param inputStream an input stream.
 324       * @param close true to close the input stream after reading.
 325       * @return the content of the given input stream.
 326       * @throws IOException if a problem occurs during reading.
 327       */
 328     private static byte[] readStream(final InputStream inputStream, final boolean close)
 329             throws IOException {
 330         if (inputStream == null) {
 331             throw new IOException(&quot;Class not found&quot;);
 332         }
<span class="line-modified"> 333         try {</span>
<span class="line-removed"> 334             ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span>
 335             byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];
 336             int bytesRead;
 337             while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {
 338                 outputStream.write(data, 0, bytesRead);
 339             }
 340             outputStream.flush();
 341             return outputStream.toByteArray();
 342         } finally {
 343             if (close) {
 344                 inputStream.close();
 345             }
 346         }
 347     }
 348 
 349     // -----------------------------------------------------------------------------------------------
 350     // Accessors
 351     // -----------------------------------------------------------------------------------------------
 352 
 353     /**
 354       * Returns the class&#39;s access flags (see {@link Opcodes}). This value may not reflect Deprecated
</pre>
<hr />
<pre>
 419       *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
 420       */
 421     public void accept(final ClassVisitor classVisitor, final int parsingOptions) {
 422         accept(classVisitor, new Attribute[0], parsingOptions);
 423     }
 424 
 425     /**
 426       * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this
 427       * {@link ClassReader}.
 428       *
 429       * @param classVisitor the visitor that must visit this class.
 430       * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
 431       *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
 432       *     be parsed: its byte array value will be passed unchanged to the ClassWriter. &lt;i&gt;This may
 433       *     corrupt it if this value contains references to the constant pool, or has syntactic or
 434       *     semantic links with a class element that has been transformed by a class adapter between
 435       *     the reader and the writer&lt;/i&gt;.
 436       * @param parsingOptions the options to use to parse this class. One or more of {@link
 437       *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
 438       */

 439     public void accept(
 440             final ClassVisitor classVisitor,
 441             final Attribute[] attributePrototypes,
 442             final int parsingOptions) {
 443         Context context = new Context();
 444         context.attributePrototypes = attributePrototypes;
 445         context.parsingOptions = parsingOptions;
 446         context.charBuffer = new char[maxStringLength];
 447 
 448         // Read the access_flags, this_class, super_class, interface_count and interfaces fields.
 449         char[] charBuffer = context.charBuffer;
 450         int currentOffset = header;
 451         int accessFlags = readUnsignedShort(currentOffset);
 452         String thisClass = readClass(currentOffset + 2, charBuffer);
 453         String superClass = readClass(currentOffset + 4, charBuffer);
 454         String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];
 455         currentOffset += 8;
 456         for (int i = 0; i &lt; interfaces.length; ++i) {
 457             interfaces[i] = readClass(currentOffset, charBuffer);
 458             currentOffset += 2;
</pre>
<hr />
<pre>
 471         // - The string corresponding to the SourceDebugExtension attribute, or null.
 472         String sourceDebugExtension = null;
 473         // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
 474         int runtimeVisibleAnnotationsOffset = 0;
 475         // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
 476         int runtimeInvisibleAnnotationsOffset = 0;
 477         // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
 478         int runtimeVisibleTypeAnnotationsOffset = 0;
 479         // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
 480         int runtimeInvisibleTypeAnnotationsOffset = 0;
 481         // - The offset of the Module attribute, or 0.
 482         int moduleOffset = 0;
 483         // - The offset of the ModulePackages attribute, or 0.
 484         int modulePackagesOffset = 0;
 485         // - The string corresponding to the ModuleMainClass attribute, or null.
 486         String moduleMainClass = null;
 487         // - The string corresponding to the NestHost attribute, or null.
 488         String nestHostClass = null;
 489         // - The offset of the NestMembers attribute, or 0.
 490         int nestMembersOffset = 0;




 491         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
 492         //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
 493         Attribute attributes = null;
 494 
 495         int currentAttributeOffset = getFirstAttributeOffset();
 496         for (int i = readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {
 497             // Read the attribute_info&#39;s attribute_name and attribute_length fields.
 498             String attributeName = readUTF8(currentAttributeOffset, charBuffer);
 499             int attributeLength = readInt(currentAttributeOffset + 2);
 500             currentAttributeOffset += 6;
 501             // The tests are sorted in decreasing frequency order (based on frequencies observed on
 502             // typical classes).
 503             if (Constants.SOURCE_FILE.equals(attributeName)) {
 504                 sourceFile = readUTF8(currentAttributeOffset, charBuffer);
 505             } else if (Constants.INNER_CLASSES.equals(attributeName)) {
 506                 innerClassesOffset = currentAttributeOffset;
 507             } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {
 508                 enclosingMethodOffset = currentAttributeOffset;
 509             } else if (Constants.NEST_HOST.equals(attributeName)) {
 510                 nestHostClass = readClass(currentAttributeOffset, charBuffer);
 511             } else if (Constants.NEST_MEMBERS.equals(attributeName)) {
 512                 nestMembersOffset = currentAttributeOffset;


 513             } else if (Constants.SIGNATURE.equals(attributeName)) {
 514                 signature = readUTF8(currentAttributeOffset, charBuffer);
 515             } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
 516                 runtimeVisibleAnnotationsOffset = currentAttributeOffset;
 517             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
 518                 runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;
 519             } else if (Constants.DEPRECATED.equals(attributeName)) {
 520                 accessFlags |= Opcodes.ACC_DEPRECATED;
 521             } else if (Constants.SYNTHETIC.equals(attributeName)) {
 522                 accessFlags |= Opcodes.ACC_SYNTHETIC;
 523             } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {
 524                 sourceDebugExtension =
 525                         readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);
 526             } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
 527                 runtimeInvisibleAnnotationsOffset = currentAttributeOffset;
 528             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
 529                 runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;



 530             } else if (Constants.MODULE.equals(attributeName)) {
 531                 moduleOffset = currentAttributeOffset;
 532             } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {
 533                 moduleMainClass = readClass(currentAttributeOffset, charBuffer);
 534             } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {
 535                 modulePackagesOffset = currentAttributeOffset;
 536             } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {
 537                 // The BootstrapMethods attribute is read in the constructor.
 538                 Attribute attribute =
 539                         readAttribute(
 540                                 attributePrototypes,
 541                                 attributeName,
 542                                 currentAttributeOffset,
 543                                 attributeLength,
 544                                 charBuffer,
 545                                 -1,
 546                                 null);
 547                 attribute.nextAttribute = attributes;
 548                 attributes = attribute;
 549             }
</pre>
<hr />
<pre>
 667 
 668         // Visit the non standard attributes.
 669         while (attributes != null) {
 670             // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.
 671             Attribute nextAttribute = attributes.nextAttribute;
 672             attributes.nextAttribute = null;
 673             classVisitor.visitAttribute(attributes);
 674             attributes = nextAttribute;
 675         }
 676 
 677         // Visit the NestedMembers attribute.
 678         if (nestMembersOffset != 0) {
 679             int numberOfNestMembers = readUnsignedShort(nestMembersOffset);
 680             int currentNestMemberOffset = nestMembersOffset + 2;
 681             while (numberOfNestMembers-- &gt; 0) {
 682                 classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));
 683                 currentNestMemberOffset += 2;
 684             }
 685         }
 686 











 687         // Visit the InnerClasses attribute.
 688         if (innerClassesOffset != 0) {
 689             int numberOfClasses = readUnsignedShort(innerClassesOffset);
 690             int currentClassesOffset = innerClassesOffset + 2;
 691             while (numberOfClasses-- &gt; 0) {
 692                 classVisitor.visitInnerClass(
 693                         readClass(currentClassesOffset, charBuffer),
 694                         readClass(currentClassesOffset + 2, charBuffer),
 695                         readUTF8(currentClassesOffset + 4, charBuffer),
 696                         readUnsignedShort(currentClassesOffset + 6));
 697                 currentClassesOffset += 8;
 698             }
 699         }
 700 









 701         // Visit the fields and methods.
 702         int fieldsCount = readUnsignedShort(currentOffset);
 703         currentOffset += 2;
 704         while (fieldsCount-- &gt; 0) {
 705             currentOffset = readField(classVisitor, context, currentOffset);
 706         }
 707         int methodsCount = readUnsignedShort(currentOffset);
 708         currentOffset += 2;
 709         while (methodsCount-- &gt; 0) {
 710             currentOffset = readMethod(classVisitor, context, currentOffset);
 711         }
 712 
 713         // Visit the end of the class.
 714         classVisitor.visitEnd();
 715     }
 716 
 717     // ----------------------------------------------------------------------------------------------
 718     // Methods to parse modules, fields and methods
 719     // ----------------------------------------------------------------------------------------------
 720 
 721     /**
 722       * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.
 723       *
 724       * @param classVisitor the current class visitor
 725       * @param context information about the class being parsed.
 726       * @param moduleOffset the offset of the Module attribute (excluding the attribute_info&#39;s
 727       *     attribute_name_index and attribute_length fields).
 728       * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the
 729       *     attribute_info&#39;s attribute_name_index and attribute_length fields), or 0.
<span class="line-modified"> 730       * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or null.</span>

 731       */
 732     private void readModuleAttributes(
 733             final ClassVisitor classVisitor,
 734             final Context context,
 735             final int moduleOffset,
 736             final int modulePackagesOffset,
 737             final String moduleMainClass) {
 738         char[] buffer = context.charBuffer;
 739 
 740         // Read the module_name_index, module_flags and module_version_index fields and visit them.
 741         int currentOffset = moduleOffset;
 742         String moduleName = readModule(currentOffset, buffer);
 743         int moduleFlags = readUnsignedShort(currentOffset + 2);
 744         String moduleVersion = readUTF8(currentOffset + 4, buffer);
 745         currentOffset += 6;
 746         ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);
 747         if (moduleVisitor == null) {
 748             return;
 749         }
 750 
</pre>
<hr />
<pre>
 827         // Read the  &#39;provides_count&#39; and &#39;provides&#39; fields.
 828         int providesCount = readUnsignedShort(currentOffset);
 829         currentOffset += 2;
 830         while (providesCount-- &gt; 0) {
 831             // Read the provides_index, provides_with_count and provides_with_index fields and visit them.
 832             String provides = readClass(currentOffset, buffer);
 833             int providesWithCount = readUnsignedShort(currentOffset + 2);
 834             currentOffset += 4;
 835             String[] providesWith = new String[providesWithCount];
 836             for (int i = 0; i &lt; providesWithCount; ++i) {
 837                 providesWith[i] = readClass(currentOffset, buffer);
 838                 currentOffset += 2;
 839             }
 840             moduleVisitor.visitProvide(provides, providesWith);
 841         }
 842 
 843         // Visit the end of the module attributes.
 844         moduleVisitor.visitEnd();
 845     }
 846 














































































































































































 847     /**
 848       * Reads a JVMS field_info structure and makes the given visitor visit it.
 849       *
 850       * @param classVisitor the visitor that must visit the field.
 851       * @param context information about the class being parsed.
 852       * @param fieldInfoOffset the start offset of the field_info structure.
 853       * @return the offset of the first byte following the field_info structure.
 854       */
 855     private int readField(
 856             final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {
 857         char[] charBuffer = context.charBuffer;
 858 
 859         // Read the access_flags, name_index and descriptor_index fields.
 860         int currentOffset = fieldInfoOffset;
 861         int accessFlags = readUnsignedShort(currentOffset);
 862         String name = readUTF8(currentOffset + 2, charBuffer);
 863         String descriptor = readUTF8(currentOffset + 4, charBuffer);
 864         currentOffset += 6;
 865 
 866         // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).
</pre>
<hr />
<pre>
1142         // Visit the method declaration.
1143         MethodVisitor methodVisitor =
1144                 classVisitor.visitMethod(
1145                         context.currentMethodAccessFlags,
1146                         context.currentMethodName,
1147                         context.currentMethodDescriptor,
1148                         signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer),
1149                         exceptions);
1150         if (methodVisitor == null) {
1151             return currentOffset;
1152         }
1153 
1154         // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method
1155         // adapter between the reader and the writer. In this case, it might be possible to copy
1156         // the method attributes directly into the writer. If so, return early without visiting
1157         // the content of these attributes.
1158         if (methodVisitor instanceof MethodWriter) {
1159             MethodWriter methodWriter = (MethodWriter) methodVisitor;
1160             if (methodWriter.canCopyMethodAttributes(
1161                     this,
<span class="line-removed">1162                     methodInfoOffset,</span>
<span class="line-removed">1163                     currentOffset - methodInfoOffset,</span>
1164                     synthetic,
1165                     (context.currentMethodAccessFlags &amp; Opcodes.ACC_DEPRECATED) != 0,
1166                     readUnsignedShort(methodInfoOffset + 4),
1167                     signatureIndex,
1168                     exceptionsOffset)) {

1169                 return currentOffset;
1170             }
1171         }
1172 
1173         // Visit the MethodParameters attribute.
<span class="line-modified">1174         if (methodParametersOffset != 0) {</span>
1175             int parametersCount = readByte(methodParametersOffset);
1176             int currentParameterOffset = methodParametersOffset + 1;
1177             while (parametersCount-- &gt; 0) {
1178                 // Read the name_index and access_flags fields and visit them.
1179                 methodVisitor.visitParameter(
1180                         readUTF8(currentParameterOffset, charBuffer),
1181                         readUnsignedShort(currentParameterOffset + 2));
1182                 currentParameterOffset += 4;
1183             }
1184         }
1185 
1186         // Visit the AnnotationDefault attribute.
1187         if (annotationDefaultOffset != 0) {
1188             AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();
1189             readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);
1190             if (annotationVisitor != null) {
1191                 annotationVisitor.visitEnd();
1192             }
1193         }
1194 
</pre>
<hr />
<pre>
1303         // Visit the Code attribute.
1304         if (codeOffset != 0) {
1305             methodVisitor.visitCode();
1306             readCode(methodVisitor, context, codeOffset);
1307         }
1308 
1309         // Visit the end of the method.
1310         methodVisitor.visitEnd();
1311         return currentOffset;
1312     }
1313 
1314     // ----------------------------------------------------------------------------------------------
1315     // Methods to parse a Code attribute
1316     // ----------------------------------------------------------------------------------------------
1317 
1318     /**
1319       * Reads a JVMS &#39;Code&#39; attribute and makes the given visitor visit it.
1320       *
1321       * @param methodVisitor the visitor that must visit the Code attribute.
1322       * @param context information about the class being parsed.
<span class="line-modified">1323       * @param codeOffset the start offset in {@link #b} of the Code attribute, excluding its</span>
<span class="line-modified">1324       *     attribute_name_index and attribute_length fields.</span>
1325       */
1326     private void readCode(
1327             final MethodVisitor methodVisitor, final Context context, final int codeOffset) {
1328         int currentOffset = codeOffset;
1329 
1330         // Read the max_stack, max_locals and code_length fields.
<span class="line-modified">1331         final byte[] classFileBuffer = b;</span>
1332         final char[] charBuffer = context.charBuffer;
1333         final int maxStack = readUnsignedShort(currentOffset);
1334         final int maxLocals = readUnsignedShort(currentOffset + 2);
1335         final int codeLength = readInt(currentOffset + 4);
1336         currentOffset += 8;
1337 
1338         // Read the bytecode &#39;code&#39; array to create a label for each referenced instruction.
1339         final int bytecodeStartOffset = currentOffset;
1340         final int bytecodeEndOffset = currentOffset + codeLength;
1341         final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];
1342         while (currentOffset &lt; bytecodeEndOffset) {
1343             final int bytecodeOffset = currentOffset - bytecodeStartOffset;
<span class="line-modified">1344             final int opcode = classFileBuffer[currentOffset] &amp; 0xFF;</span>
1345             switch (opcode) {
<span class="line-modified">1346                 case Constants.NOP:</span>
<span class="line-modified">1347                 case Constants.ACONST_NULL:</span>
<span class="line-modified">1348                 case Constants.ICONST_M1:</span>
<span class="line-modified">1349                 case Constants.ICONST_0:</span>
<span class="line-modified">1350                 case Constants.ICONST_1:</span>
<span class="line-modified">1351                 case Constants.ICONST_2:</span>
<span class="line-modified">1352                 case Constants.ICONST_3:</span>
<span class="line-modified">1353                 case Constants.ICONST_4:</span>
<span class="line-modified">1354                 case Constants.ICONST_5:</span>
<span class="line-modified">1355                 case Constants.LCONST_0:</span>
<span class="line-modified">1356                 case Constants.LCONST_1:</span>
<span class="line-modified">1357                 case Constants.FCONST_0:</span>
<span class="line-modified">1358                 case Constants.FCONST_1:</span>
<span class="line-modified">1359                 case Constants.FCONST_2:</span>
<span class="line-modified">1360                 case Constants.DCONST_0:</span>
<span class="line-modified">1361                 case Constants.DCONST_1:</span>
<span class="line-modified">1362                 case Constants.IALOAD:</span>
<span class="line-modified">1363                 case Constants.LALOAD:</span>
<span class="line-modified">1364                 case Constants.FALOAD:</span>
<span class="line-modified">1365                 case Constants.DALOAD:</span>
<span class="line-modified">1366                 case Constants.AALOAD:</span>
<span class="line-modified">1367                 case Constants.BALOAD:</span>
<span class="line-modified">1368                 case Constants.CALOAD:</span>
<span class="line-modified">1369                 case Constants.SALOAD:</span>
<span class="line-modified">1370                 case Constants.IASTORE:</span>
<span class="line-modified">1371                 case Constants.LASTORE:</span>
<span class="line-modified">1372                 case Constants.FASTORE:</span>
<span class="line-modified">1373                 case Constants.DASTORE:</span>
<span class="line-modified">1374                 case Constants.AASTORE:</span>
<span class="line-modified">1375                 case Constants.BASTORE:</span>
<span class="line-modified">1376                 case Constants.CASTORE:</span>
<span class="line-modified">1377                 case Constants.SASTORE:</span>
<span class="line-modified">1378                 case Constants.POP:</span>
<span class="line-modified">1379                 case Constants.POP2:</span>
<span class="line-modified">1380                 case Constants.DUP:</span>
<span class="line-modified">1381                 case Constants.DUP_X1:</span>
<span class="line-modified">1382                 case Constants.DUP_X2:</span>
<span class="line-modified">1383                 case Constants.DUP2:</span>
<span class="line-modified">1384                 case Constants.DUP2_X1:</span>
<span class="line-modified">1385                 case Constants.DUP2_X2:</span>
<span class="line-modified">1386                 case Constants.SWAP:</span>
<span class="line-modified">1387                 case Constants.IADD:</span>
<span class="line-modified">1388                 case Constants.LADD:</span>
<span class="line-modified">1389                 case Constants.FADD:</span>
<span class="line-modified">1390                 case Constants.DADD:</span>
<span class="line-modified">1391                 case Constants.ISUB:</span>
<span class="line-modified">1392                 case Constants.LSUB:</span>
<span class="line-modified">1393                 case Constants.FSUB:</span>
<span class="line-modified">1394                 case Constants.DSUB:</span>
<span class="line-modified">1395                 case Constants.IMUL:</span>
<span class="line-modified">1396                 case Constants.LMUL:</span>
<span class="line-modified">1397                 case Constants.FMUL:</span>
<span class="line-modified">1398                 case Constants.DMUL:</span>
<span class="line-modified">1399                 case Constants.IDIV:</span>
<span class="line-modified">1400                 case Constants.LDIV:</span>
<span class="line-modified">1401                 case Constants.FDIV:</span>
<span class="line-modified">1402                 case Constants.DDIV:</span>
<span class="line-modified">1403                 case Constants.IREM:</span>
<span class="line-modified">1404                 case Constants.LREM:</span>
<span class="line-modified">1405                 case Constants.FREM:</span>
<span class="line-modified">1406                 case Constants.DREM:</span>
<span class="line-modified">1407                 case Constants.INEG:</span>
<span class="line-modified">1408                 case Constants.LNEG:</span>
<span class="line-modified">1409                 case Constants.FNEG:</span>
<span class="line-modified">1410                 case Constants.DNEG:</span>
<span class="line-modified">1411                 case Constants.ISHL:</span>
<span class="line-modified">1412                 case Constants.LSHL:</span>
<span class="line-modified">1413                 case Constants.ISHR:</span>
<span class="line-modified">1414                 case Constants.LSHR:</span>
<span class="line-modified">1415                 case Constants.IUSHR:</span>
<span class="line-modified">1416                 case Constants.LUSHR:</span>
<span class="line-modified">1417                 case Constants.IAND:</span>
<span class="line-modified">1418                 case Constants.LAND:</span>
<span class="line-modified">1419                 case Constants.IOR:</span>
<span class="line-modified">1420                 case Constants.LOR:</span>
<span class="line-modified">1421                 case Constants.IXOR:</span>
<span class="line-modified">1422                 case Constants.LXOR:</span>
<span class="line-modified">1423                 case Constants.I2L:</span>
<span class="line-modified">1424                 case Constants.I2F:</span>
<span class="line-modified">1425                 case Constants.I2D:</span>
<span class="line-modified">1426                 case Constants.L2I:</span>
<span class="line-modified">1427                 case Constants.L2F:</span>
<span class="line-modified">1428                 case Constants.L2D:</span>
<span class="line-modified">1429                 case Constants.F2I:</span>
<span class="line-modified">1430                 case Constants.F2L:</span>
<span class="line-modified">1431                 case Constants.F2D:</span>
<span class="line-modified">1432                 case Constants.D2I:</span>
<span class="line-modified">1433                 case Constants.D2L:</span>
<span class="line-modified">1434                 case Constants.D2F:</span>
<span class="line-modified">1435                 case Constants.I2B:</span>
<span class="line-modified">1436                 case Constants.I2C:</span>
<span class="line-modified">1437                 case Constants.I2S:</span>
<span class="line-modified">1438                 case Constants.LCMP:</span>
<span class="line-modified">1439                 case Constants.FCMPL:</span>
<span class="line-modified">1440                 case Constants.FCMPG:</span>
<span class="line-modified">1441                 case Constants.DCMPL:</span>
<span class="line-modified">1442                 case Constants.DCMPG:</span>
<span class="line-modified">1443                 case Constants.IRETURN:</span>
<span class="line-modified">1444                 case Constants.LRETURN:</span>
<span class="line-modified">1445                 case Constants.FRETURN:</span>
<span class="line-modified">1446                 case Constants.DRETURN:</span>
<span class="line-modified">1447                 case Constants.ARETURN:</span>
<span class="line-modified">1448                 case Constants.RETURN:</span>
<span class="line-modified">1449                 case Constants.ARRAYLENGTH:</span>
<span class="line-modified">1450                 case Constants.ATHROW:</span>
<span class="line-modified">1451                 case Constants.MONITORENTER:</span>
<span class="line-modified">1452                 case Constants.MONITOREXIT:</span>
1453                 case Constants.ILOAD_0:
1454                 case Constants.ILOAD_1:
1455                 case Constants.ILOAD_2:
1456                 case Constants.ILOAD_3:
1457                 case Constants.LLOAD_0:
1458                 case Constants.LLOAD_1:
1459                 case Constants.LLOAD_2:
1460                 case Constants.LLOAD_3:
1461                 case Constants.FLOAD_0:
1462                 case Constants.FLOAD_1:
1463                 case Constants.FLOAD_2:
1464                 case Constants.FLOAD_3:
1465                 case Constants.DLOAD_0:
1466                 case Constants.DLOAD_1:
1467                 case Constants.DLOAD_2:
1468                 case Constants.DLOAD_3:
1469                 case Constants.ALOAD_0:
1470                 case Constants.ALOAD_1:
1471                 case Constants.ALOAD_2:
1472                 case Constants.ALOAD_3:
</pre>
<hr />
<pre>
1475                 case Constants.ISTORE_2:
1476                 case Constants.ISTORE_3:
1477                 case Constants.LSTORE_0:
1478                 case Constants.LSTORE_1:
1479                 case Constants.LSTORE_2:
1480                 case Constants.LSTORE_3:
1481                 case Constants.FSTORE_0:
1482                 case Constants.FSTORE_1:
1483                 case Constants.FSTORE_2:
1484                 case Constants.FSTORE_3:
1485                 case Constants.DSTORE_0:
1486                 case Constants.DSTORE_1:
1487                 case Constants.DSTORE_2:
1488                 case Constants.DSTORE_3:
1489                 case Constants.ASTORE_0:
1490                 case Constants.ASTORE_1:
1491                 case Constants.ASTORE_2:
1492                 case Constants.ASTORE_3:
1493                     currentOffset += 1;
1494                     break;
<span class="line-modified">1495                 case Constants.IFEQ:</span>
<span class="line-modified">1496                 case Constants.IFNE:</span>
<span class="line-modified">1497                 case Constants.IFLT:</span>
<span class="line-modified">1498                 case Constants.IFGE:</span>
<span class="line-modified">1499                 case Constants.IFGT:</span>
<span class="line-modified">1500                 case Constants.IFLE:</span>
<span class="line-modified">1501                 case Constants.IF_ICMPEQ:</span>
<span class="line-modified">1502                 case Constants.IF_ICMPNE:</span>
<span class="line-modified">1503                 case Constants.IF_ICMPLT:</span>
<span class="line-modified">1504                 case Constants.IF_ICMPGE:</span>
<span class="line-modified">1505                 case Constants.IF_ICMPGT:</span>
<span class="line-modified">1506                 case Constants.IF_ICMPLE:</span>
<span class="line-modified">1507                 case Constants.IF_ACMPEQ:</span>
<span class="line-modified">1508                 case Constants.IF_ACMPNE:</span>
<span class="line-modified">1509                 case Constants.GOTO:</span>
<span class="line-modified">1510                 case Constants.JSR:</span>
<span class="line-modified">1511                 case Constants.IFNULL:</span>
<span class="line-modified">1512                 case Constants.IFNONNULL:</span>
1513                     createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);
1514                     currentOffset += 3;
1515                     break;
1516                 case Constants.ASM_IFEQ:
1517                 case Constants.ASM_IFNE:
1518                 case Constants.ASM_IFLT:
1519                 case Constants.ASM_IFGE:
1520                 case Constants.ASM_IFGT:
1521                 case Constants.ASM_IFLE:
1522                 case Constants.ASM_IF_ICMPEQ:
1523                 case Constants.ASM_IF_ICMPNE:
1524                 case Constants.ASM_IF_ICMPLT:
1525                 case Constants.ASM_IF_ICMPGE:
1526                 case Constants.ASM_IF_ICMPGT:
1527                 case Constants.ASM_IF_ICMPLE:
1528                 case Constants.ASM_IF_ACMPEQ:
1529                 case Constants.ASM_IF_ACMPNE:
1530                 case Constants.ASM_GOTO:
1531                 case Constants.ASM_JSR:
1532                 case Constants.ASM_IFNULL:
1533                 case Constants.ASM_IFNONNULL:
1534                     createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);
1535                     currentOffset += 3;
1536                     break;
1537                 case Constants.GOTO_W:
1538                 case Constants.JSR_W:
1539                 case Constants.ASM_GOTO_W:
1540                     createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);
1541                     currentOffset += 5;
1542                     break;
1543                 case Constants.WIDE:
<span class="line-modified">1544                     switch (classFileBuffer[currentOffset + 1] &amp; 0xFF) {</span>
<span class="line-modified">1545                         case Constants.ILOAD:</span>
<span class="line-modified">1546                         case Constants.FLOAD:</span>
<span class="line-modified">1547                         case Constants.ALOAD:</span>
<span class="line-modified">1548                         case Constants.LLOAD:</span>
<span class="line-modified">1549                         case Constants.DLOAD:</span>
<span class="line-modified">1550                         case Constants.ISTORE:</span>
<span class="line-modified">1551                         case Constants.FSTORE:</span>
<span class="line-modified">1552                         case Constants.ASTORE:</span>
<span class="line-modified">1553                         case Constants.LSTORE:</span>
<span class="line-modified">1554                         case Constants.DSTORE:</span>
<span class="line-modified">1555                         case Constants.RET:</span>
1556                             currentOffset += 4;
1557                             break;
<span class="line-modified">1558                         case Constants.IINC:</span>
1559                             currentOffset += 6;
1560                             break;
1561                         default:
1562                             throw new IllegalArgumentException();
1563                     }
1564                     break;
<span class="line-modified">1565                 case Constants.TABLESWITCH:</span>
1566                     // Skip 0 to 3 padding bytes.
1567                     currentOffset += 4 - (bytecodeOffset &amp; 3);
1568                     // Read the default label and the number of table entries.
1569                     createLabel(bytecodeOffset + readInt(currentOffset), labels);
1570                     int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;
1571                     currentOffset += 12;
1572                     // Read the table labels.
1573                     while (numTableEntries-- &gt; 0) {
1574                         createLabel(bytecodeOffset + readInt(currentOffset), labels);
1575                         currentOffset += 4;
1576                     }
1577                     break;
<span class="line-modified">1578                 case Constants.LOOKUPSWITCH:</span>
1579                     // Skip 0 to 3 padding bytes.
1580                     currentOffset += 4 - (bytecodeOffset &amp; 3);
1581                     // Read the default label and the number of switch cases.
1582                     createLabel(bytecodeOffset + readInt(currentOffset), labels);
1583                     int numSwitchCases = readInt(currentOffset + 4);
1584                     currentOffset += 8;
1585                     // Read the switch labels.
1586                     while (numSwitchCases-- &gt; 0) {
1587                         createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);
1588                         currentOffset += 8;
1589                     }
1590                     break;
<span class="line-modified">1591                 case Constants.ILOAD:</span>
<span class="line-modified">1592                 case Constants.LLOAD:</span>
<span class="line-modified">1593                 case Constants.FLOAD:</span>
<span class="line-modified">1594                 case Constants.DLOAD:</span>
<span class="line-modified">1595                 case Constants.ALOAD:</span>
<span class="line-modified">1596                 case Constants.ISTORE:</span>
<span class="line-modified">1597                 case Constants.LSTORE:</span>
<span class="line-modified">1598                 case Constants.FSTORE:</span>
<span class="line-modified">1599                 case Constants.DSTORE:</span>
<span class="line-modified">1600                 case Constants.ASTORE:</span>
<span class="line-modified">1601                 case Constants.RET:</span>
<span class="line-modified">1602                 case Constants.BIPUSH:</span>
<span class="line-modified">1603                 case Constants.NEWARRAY:</span>
<span class="line-modified">1604                 case Constants.LDC:</span>
1605                     currentOffset += 2;
1606                     break;
<span class="line-modified">1607                 case Constants.SIPUSH:</span>
1608                 case Constants.LDC_W:
1609                 case Constants.LDC2_W:
<span class="line-modified">1610                 case Constants.GETSTATIC:</span>
<span class="line-modified">1611                 case Constants.PUTSTATIC:</span>
<span class="line-modified">1612                 case Constants.GETFIELD:</span>
<span class="line-modified">1613                 case Constants.PUTFIELD:</span>
<span class="line-modified">1614                 case Constants.DEFAULT:</span>
<span class="line-modified">1615                 case Constants.WITHFIELD:</span>
<span class="line-modified">1616                 case Constants.INVOKEVIRTUAL:</span>
<span class="line-modified">1617                 case Constants.INVOKESPECIAL:</span>
<span class="line-modified">1618                 case Constants.INVOKESTATIC:</span>
<span class="line-modified">1619                 case Constants.NEW:</span>
<span class="line-modified">1620                 case Constants.ANEWARRAY:</span>
<span class="line-modified">1621                 case Constants.CHECKCAST:</span>
<span class="line-modified">1622                 case Constants.INSTANCEOF:</span>
<span class="line-modified">1623                 case Constants.IINC:</span>
1624                     currentOffset += 3;
1625                     break;
<span class="line-modified">1626                 case Constants.INVOKEINTERFACE:</span>
<span class="line-modified">1627                 case Constants.INVOKEDYNAMIC:</span>
1628                     currentOffset += 5;
1629                     break;
<span class="line-modified">1630                 case Constants.MULTIANEWARRAY:</span>
1631                     currentOffset += 4;
1632                     break;
1633                 default:
1634                     throw new IllegalArgumentException();
1635             }
1636         }
1637 
1638         // Read the &#39;exception_table_length&#39; and &#39;exception_table&#39; field to create a label for each
1639         // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.
1640         int exceptionTableLength = readUnsignedShort(currentOffset);
1641         currentOffset += 2;
1642         while (exceptionTableLength-- &gt; 0) {
1643             Label start = createLabel(readUnsignedShort(currentOffset), labels);
1644             Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);
1645             Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);
1646             String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);
1647             currentOffset += 8;
1648             methodVisitor.visitTryCatchBlock(start, end, handler, catchType);
1649         }
1650 
</pre>
<hr />
<pre>
1775             // offset_delta. Setting the implicit frame offset to -1 allows us to use of the
1776             // &quot;offset_delta + 1&quot; rule in all cases.
1777             context.currentFrameOffset = -1;
1778             context.currentFrameType = 0;
1779             context.currentFrameLocalCount = 0;
1780             context.currentFrameLocalCountDelta = 0;
1781             context.currentFrameLocalTypes = new Object[maxLocals];
1782             context.currentFrameStackCount = 0;
1783             context.currentFrameStackTypes = new Object[maxStack];
1784             if (expandFrames) {
1785                 computeImplicitFrame(context);
1786             }
1787             // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the
1788             // stack map table, we look for 3 consecutive bytes that &quot;look like&quot; an UNINITIALIZED type
1789             // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).
1790             // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,
1791             // and the only consequence will be the creation of an unneeded label. This is better than
1792             // creating a label for each NEW instruction, and faster than fully decoding the whole stack
1793             // map table.
1794             for (int offset = stackMapFrameOffset; offset &lt; stackMapTableEndOffset - 2; ++offset) {
<span class="line-modified">1795                 if (classFileBuffer[offset] == Frame.ITEM_UNINITIALIZED) {</span>
1796                     int potentialBytecodeOffset = readUnsignedShort(offset + 1);
1797                     if (potentialBytecodeOffset &gt;= 0
1798                             &amp;&amp; potentialBytecodeOffset &lt; codeLength
<span class="line-modified">1799                             &amp;&amp; (classFileBuffer[bytecodeStartOffset + potentialBytecodeOffset] &amp; 0xFF)</span>
1800                                     == Opcodes.NEW) {
1801                         createLabel(potentialBytecodeOffset, labels);
1802                     }
1803                 }
1804             }
1805         }
1806         if (expandFrames &amp;&amp; (context.parsingOptions &amp; EXPAND_ASM_INSNS) != 0) {
1807             // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method
1808             // does not currently have any frame. These inserted frames must be computed by simulating the
1809             // effect of the bytecode instructions, one by one, starting from the implicit first frame.
1810             // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To
1811             // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is
1812             // computed in MethodWriter).
1813             methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);
1814         }
1815 
1816         // Visit the bytecode instructions. First, introduce state variables for the incremental parsing
1817         // of the type annotations.
1818 
1819         // Index of the next runtime visible type annotation to read (in the
</pre>
<hr />
<pre>
1875                     insertFrame = false;
1876                 }
1877                 if (stackMapFrameOffset &lt; stackMapTableEndOffset) {
1878                     stackMapFrameOffset =
1879                             readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);
1880                 } else {
1881                     stackMapFrameOffset = 0;
1882                 }
1883             }
1884 
1885             // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to
1886             // true during the previous iteration. The actual frame content is computed in MethodWriter.
1887             if (insertFrame) {
1888                 if ((context.parsingOptions &amp; EXPAND_FRAMES) != 0) {
1889                     methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);
1890                 }
1891                 insertFrame = false;
1892             }
1893 
1894             // Visit the instruction at this bytecode offset.
<span class="line-modified">1895             int opcode = classFileBuffer[currentOffset] &amp; 0xFF;</span>
1896             switch (opcode) {
<span class="line-modified">1897                 case Constants.NOP:</span>
<span class="line-modified">1898                 case Constants.ACONST_NULL:</span>
<span class="line-modified">1899                 case Constants.ICONST_M1:</span>
<span class="line-modified">1900                 case Constants.ICONST_0:</span>
<span class="line-modified">1901                 case Constants.ICONST_1:</span>
<span class="line-modified">1902                 case Constants.ICONST_2:</span>
<span class="line-modified">1903                 case Constants.ICONST_3:</span>
<span class="line-modified">1904                 case Constants.ICONST_4:</span>
<span class="line-modified">1905                 case Constants.ICONST_5:</span>
<span class="line-modified">1906                 case Constants.LCONST_0:</span>
<span class="line-modified">1907                 case Constants.LCONST_1:</span>
<span class="line-modified">1908                 case Constants.FCONST_0:</span>
<span class="line-modified">1909                 case Constants.FCONST_1:</span>
<span class="line-modified">1910                 case Constants.FCONST_2:</span>
<span class="line-modified">1911                 case Constants.DCONST_0:</span>
<span class="line-modified">1912                 case Constants.DCONST_1:</span>
<span class="line-modified">1913                 case Constants.IALOAD:</span>
<span class="line-modified">1914                 case Constants.LALOAD:</span>
<span class="line-modified">1915                 case Constants.FALOAD:</span>
<span class="line-modified">1916                 case Constants.DALOAD:</span>
<span class="line-modified">1917                 case Constants.AALOAD:</span>
<span class="line-modified">1918                 case Constants.BALOAD:</span>
<span class="line-modified">1919                 case Constants.CALOAD:</span>
<span class="line-modified">1920                 case Constants.SALOAD:</span>
<span class="line-modified">1921                 case Constants.IASTORE:</span>
<span class="line-modified">1922                 case Constants.LASTORE:</span>
<span class="line-modified">1923                 case Constants.FASTORE:</span>
<span class="line-modified">1924                 case Constants.DASTORE:</span>
<span class="line-modified">1925                 case Constants.AASTORE:</span>
<span class="line-modified">1926                 case Constants.BASTORE:</span>
<span class="line-modified">1927                 case Constants.CASTORE:</span>
<span class="line-modified">1928                 case Constants.SASTORE:</span>
<span class="line-modified">1929                 case Constants.POP:</span>
<span class="line-modified">1930                 case Constants.POP2:</span>
<span class="line-modified">1931                 case Constants.DUP:</span>
<span class="line-modified">1932                 case Constants.DUP_X1:</span>
<span class="line-modified">1933                 case Constants.DUP_X2:</span>
<span class="line-modified">1934                 case Constants.DUP2:</span>
<span class="line-modified">1935                 case Constants.DUP2_X1:</span>
<span class="line-modified">1936                 case Constants.DUP2_X2:</span>
<span class="line-modified">1937                 case Constants.SWAP:</span>
<span class="line-modified">1938                 case Constants.IADD:</span>
<span class="line-modified">1939                 case Constants.LADD:</span>
<span class="line-modified">1940                 case Constants.FADD:</span>
<span class="line-modified">1941                 case Constants.DADD:</span>
<span class="line-modified">1942                 case Constants.ISUB:</span>
<span class="line-modified">1943                 case Constants.LSUB:</span>
<span class="line-modified">1944                 case Constants.FSUB:</span>
<span class="line-modified">1945                 case Constants.DSUB:</span>
<span class="line-modified">1946                 case Constants.IMUL:</span>
<span class="line-modified">1947                 case Constants.LMUL:</span>
<span class="line-modified">1948                 case Constants.FMUL:</span>
<span class="line-modified">1949                 case Constants.DMUL:</span>
<span class="line-modified">1950                 case Constants.IDIV:</span>
<span class="line-modified">1951                 case Constants.LDIV:</span>
<span class="line-modified">1952                 case Constants.FDIV:</span>
<span class="line-modified">1953                 case Constants.DDIV:</span>
<span class="line-modified">1954                 case Constants.IREM:</span>
<span class="line-modified">1955                 case Constants.LREM:</span>
<span class="line-modified">1956                 case Constants.FREM:</span>
<span class="line-modified">1957                 case Constants.DREM:</span>
<span class="line-modified">1958                 case Constants.INEG:</span>
<span class="line-modified">1959                 case Constants.LNEG:</span>
<span class="line-modified">1960                 case Constants.FNEG:</span>
<span class="line-modified">1961                 case Constants.DNEG:</span>
<span class="line-modified">1962                 case Constants.ISHL:</span>
<span class="line-modified">1963                 case Constants.LSHL:</span>
<span class="line-modified">1964                 case Constants.ISHR:</span>
<span class="line-modified">1965                 case Constants.LSHR:</span>
<span class="line-modified">1966                 case Constants.IUSHR:</span>
<span class="line-modified">1967                 case Constants.LUSHR:</span>
<span class="line-modified">1968                 case Constants.IAND:</span>
<span class="line-modified">1969                 case Constants.LAND:</span>
<span class="line-modified">1970                 case Constants.IOR:</span>
<span class="line-modified">1971                 case Constants.LOR:</span>
<span class="line-modified">1972                 case Constants.IXOR:</span>
<span class="line-modified">1973                 case Constants.LXOR:</span>
<span class="line-modified">1974                 case Constants.I2L:</span>
<span class="line-modified">1975                 case Constants.I2F:</span>
<span class="line-modified">1976                 case Constants.I2D:</span>
<span class="line-modified">1977                 case Constants.L2I:</span>
<span class="line-modified">1978                 case Constants.L2F:</span>
<span class="line-modified">1979                 case Constants.L2D:</span>
<span class="line-modified">1980                 case Constants.F2I:</span>
<span class="line-modified">1981                 case Constants.F2L:</span>
<span class="line-modified">1982                 case Constants.F2D:</span>
<span class="line-modified">1983                 case Constants.D2I:</span>
<span class="line-modified">1984                 case Constants.D2L:</span>
<span class="line-modified">1985                 case Constants.D2F:</span>
<span class="line-modified">1986                 case Constants.I2B:</span>
<span class="line-modified">1987                 case Constants.I2C:</span>
<span class="line-modified">1988                 case Constants.I2S:</span>
<span class="line-modified">1989                 case Constants.LCMP:</span>
<span class="line-modified">1990                 case Constants.FCMPL:</span>
<span class="line-modified">1991                 case Constants.FCMPG:</span>
<span class="line-modified">1992                 case Constants.DCMPL:</span>
<span class="line-modified">1993                 case Constants.DCMPG:</span>
<span class="line-modified">1994                 case Constants.IRETURN:</span>
<span class="line-modified">1995                 case Constants.LRETURN:</span>
<span class="line-modified">1996                 case Constants.FRETURN:</span>
<span class="line-modified">1997                 case Constants.DRETURN:</span>
<span class="line-modified">1998                 case Constants.ARETURN:</span>
<span class="line-modified">1999                 case Constants.RETURN:</span>
<span class="line-modified">2000                 case Constants.ARRAYLENGTH:</span>
<span class="line-modified">2001                 case Constants.ATHROW:</span>
<span class="line-modified">2002                 case Constants.MONITORENTER:</span>
<span class="line-modified">2003                 case Constants.MONITOREXIT:</span>
2004                     methodVisitor.visitInsn(opcode);
2005                     currentOffset += 1;
2006                     break;
2007                 case Constants.ILOAD_0:
2008                 case Constants.ILOAD_1:
2009                 case Constants.ILOAD_2:
2010                 case Constants.ILOAD_3:
2011                 case Constants.LLOAD_0:
2012                 case Constants.LLOAD_1:
2013                 case Constants.LLOAD_2:
2014                 case Constants.LLOAD_3:
2015                 case Constants.FLOAD_0:
2016                 case Constants.FLOAD_1:
2017                 case Constants.FLOAD_2:
2018                 case Constants.FLOAD_3:
2019                 case Constants.DLOAD_0:
2020                 case Constants.DLOAD_1:
2021                 case Constants.DLOAD_2:
2022                 case Constants.DLOAD_3:
2023                 case Constants.ALOAD_0:
</pre>
<hr />
<pre>
2035                 case Constants.LSTORE_0:
2036                 case Constants.LSTORE_1:
2037                 case Constants.LSTORE_2:
2038                 case Constants.LSTORE_3:
2039                 case Constants.FSTORE_0:
2040                 case Constants.FSTORE_1:
2041                 case Constants.FSTORE_2:
2042                 case Constants.FSTORE_3:
2043                 case Constants.DSTORE_0:
2044                 case Constants.DSTORE_1:
2045                 case Constants.DSTORE_2:
2046                 case Constants.DSTORE_3:
2047                 case Constants.ASTORE_0:
2048                 case Constants.ASTORE_1:
2049                 case Constants.ASTORE_2:
2050                 case Constants.ASTORE_3:
2051                     opcode -= Constants.ISTORE_0;
2052                     methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode &gt;&gt; 2), opcode &amp; 0x3);
2053                     currentOffset += 1;
2054                     break;
<span class="line-modified">2055                 case Constants.IFEQ:</span>
<span class="line-modified">2056                 case Constants.IFNE:</span>
<span class="line-modified">2057                 case Constants.IFLT:</span>
<span class="line-modified">2058                 case Constants.IFGE:</span>
<span class="line-modified">2059                 case Constants.IFGT:</span>
<span class="line-modified">2060                 case Constants.IFLE:</span>
<span class="line-modified">2061                 case Constants.IF_ICMPEQ:</span>
<span class="line-modified">2062                 case Constants.IF_ICMPNE:</span>
<span class="line-modified">2063                 case Constants.IF_ICMPLT:</span>
<span class="line-modified">2064                 case Constants.IF_ICMPGE:</span>
<span class="line-modified">2065                 case Constants.IF_ICMPGT:</span>
<span class="line-modified">2066                 case Constants.IF_ICMPLE:</span>
<span class="line-modified">2067                 case Constants.IF_ACMPEQ:</span>
<span class="line-modified">2068                 case Constants.IF_ACMPNE:</span>
<span class="line-modified">2069                 case Constants.GOTO:</span>
<span class="line-modified">2070                 case Constants.JSR:</span>
<span class="line-modified">2071                 case Constants.IFNULL:</span>
<span class="line-modified">2072                 case Constants.IFNONNULL:</span>
2073                     methodVisitor.visitJumpInsn(
2074                             opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);
2075                     currentOffset += 3;
2076                     break;
2077                 case Constants.GOTO_W:
2078                 case Constants.JSR_W:
2079                     methodVisitor.visitJumpInsn(
2080                             opcode - wideJumpOpcodeDelta,
2081                             labels[currentBytecodeOffset + readInt(currentOffset + 1)]);
2082                     currentOffset += 5;
2083                     break;
2084                 case Constants.ASM_IFEQ:
2085                 case Constants.ASM_IFNE:
2086                 case Constants.ASM_IFLT:
2087                 case Constants.ASM_IFGE:
2088                 case Constants.ASM_IFGT:
2089                 case Constants.ASM_IFLE:
2090                 case Constants.ASM_IF_ICMPEQ:
2091                 case Constants.ASM_IF_ICMPNE:
2092                 case Constants.ASM_IF_ICMPLT:
</pre>
<hr />
<pre>
2113                         Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];
2114                         if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {
2115                             // Replace GOTO with GOTO_W and JSR with JSR_W.
2116                             methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);
2117                         } else {
2118                             // Compute the &quot;opposite&quot; of opcode. This can be done by flipping the least
2119                             // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ
2120                             // (with a pre and post offset by 1).
2121                             opcode = opcode &lt; Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;
2122                             Label endif = createLabel(currentBytecodeOffset + 3, labels);
2123                             methodVisitor.visitJumpInsn(opcode, endif);
2124                             methodVisitor.visitJumpInsn(Constants.GOTO_W, target);
2125                             // endif designates the instruction just after GOTO_W, and is visited as part of the
2126                             // next instruction. Since it is a jump target, we need to insert a frame here.
2127                             insertFrame = true;
2128                         }
2129                         currentOffset += 3;
2130                         break;
2131                     }
2132                 case Constants.ASM_GOTO_W:
<span class="line-modified">2133                     {</span>
<span class="line-modified">2134                         // Replace ASM_GOTO_W with GOTO_W.</span>
<span class="line-modified">2135                         methodVisitor.visitJumpInsn(</span>
<span class="line-modified">2136                                 Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);</span>
<span class="line-modified">2137                         // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns</span>
<span class="line-modified">2138                         // IFNOTxxx &lt;L&gt; ASM_GOTO_W &lt;l&gt; L:..., see MethodWriter), so we need to insert a frame</span>
<span class="line-modified">2139                         // here.</span>
<span class="line-modified">2140                         insertFrame = true;</span>
<span class="line-modified">2141                         currentOffset += 5;</span>
<span class="line-removed">2142                         break;</span>
<span class="line-removed">2143                     }</span>
2144                 case Constants.WIDE:
<span class="line-modified">2145                     opcode = classFileBuffer[currentOffset + 1] &amp; 0xFF;</span>
2146                     if (opcode == Opcodes.IINC) {
2147                         methodVisitor.visitIincInsn(
2148                                 readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));
2149                         currentOffset += 6;
2150                     } else {
2151                         methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));
2152                         currentOffset += 4;
2153                     }
2154                     break;
<span class="line-modified">2155                 case Constants.TABLESWITCH:</span>
2156                     {
2157                         // Skip 0 to 3 padding bytes.
2158                         currentOffset += 4 - (currentBytecodeOffset &amp; 3);
2159                         // Read the instruction.
2160                         Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
2161                         int low = readInt(currentOffset + 4);
2162                         int high = readInt(currentOffset + 8);
2163                         currentOffset += 12;
2164                         Label[] table = new Label[high - low + 1];
2165                         for (int i = 0; i &lt; table.length; ++i) {
2166                             table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];
2167                             currentOffset += 4;
2168                         }
2169                         methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);
2170                         break;
2171                     }
<span class="line-modified">2172                 case Constants.LOOKUPSWITCH:</span>
2173                     {
2174                         // Skip 0 to 3 padding bytes.
2175                         currentOffset += 4 - (currentBytecodeOffset &amp; 3);
2176                         // Read the instruction.
2177                         Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
2178                         int numPairs = readInt(currentOffset + 4);
2179                         currentOffset += 8;
2180                         int[] keys = new int[numPairs];
2181                         Label[] values = new Label[numPairs];
2182                         for (int i = 0; i &lt; numPairs; ++i) {
2183                             keys[i] = readInt(currentOffset);
2184                             values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];
2185                             currentOffset += 8;
2186                         }
2187                         methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);
2188                         break;
2189                     }
<span class="line-modified">2190                 case Constants.ILOAD:</span>
<span class="line-modified">2191                 case Constants.LLOAD:</span>
<span class="line-modified">2192                 case Constants.FLOAD:</span>
<span class="line-modified">2193                 case Constants.DLOAD:</span>
<span class="line-modified">2194                 case Constants.ALOAD:</span>
<span class="line-modified">2195                 case Constants.ISTORE:</span>
<span class="line-modified">2196                 case Constants.LSTORE:</span>
<span class="line-modified">2197                 case Constants.FSTORE:</span>
<span class="line-modified">2198                 case Constants.DSTORE:</span>
<span class="line-modified">2199                 case Constants.ASTORE:</span>
<span class="line-modified">2200                 case Constants.RET:</span>
<span class="line-modified">2201                     methodVisitor.visitVarInsn(opcode, classFileBuffer[currentOffset + 1] &amp; 0xFF);</span>
2202                     currentOffset += 2;
2203                     break;
<span class="line-modified">2204                 case Constants.BIPUSH:</span>
<span class="line-modified">2205                 case Constants.NEWARRAY:</span>
<span class="line-modified">2206                     methodVisitor.visitIntInsn(opcode, classFileBuffer[currentOffset + 1]);</span>
2207                     currentOffset += 2;
2208                     break;
<span class="line-modified">2209                 case Constants.SIPUSH:</span>
2210                     methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));
2211                     currentOffset += 3;
2212                     break;
<span class="line-modified">2213                 case Constants.LDC:</span>
<span class="line-modified">2214                     methodVisitor.visitLdcInsn(</span>
<span class="line-removed">2215                             readConst(classFileBuffer[currentOffset + 1] &amp; 0xFF, charBuffer));</span>
2216                     currentOffset += 2;
2217                     break;
2218                 case Constants.LDC_W:
2219                 case Constants.LDC2_W:
2220                     methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));
2221                     currentOffset += 3;
2222                     break;
<span class="line-modified">2223                 case Constants.GETSTATIC:</span>
<span class="line-modified">2224                 case Constants.PUTSTATIC:</span>
<span class="line-modified">2225                 case Constants.GETFIELD:</span>
<span class="line-modified">2226                 case Constants.PUTFIELD:</span>
<span class="line-modified">2227                 case Constants.INVOKEVIRTUAL:</span>
<span class="line-modified">2228                 case Constants.INVOKESPECIAL:</span>
<span class="line-modified">2229                 case Constants.INVOKESTATIC:</span>
<span class="line-modified">2230                 case Constants.INVOKEINTERFACE:</span>
<span class="line-modified">2231                 case Constants.WITHFIELD:</span>
2232                     {
2233                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
2234                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
2235                         String owner = readClass(cpInfoOffset, charBuffer);
2236                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
2237                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
2238                         if (opcode &gt;= Opcodes.INVOKEVIRTUAL &amp;&amp; opcode &lt;= Opcodes.INVOKEINTERFACE) {
2239                             boolean isInterface =
<span class="line-modified">2240                                     classFileBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;</span>
2241                             methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
2242                         } else {
2243                             methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);
2244                         }
2245                         if (opcode == Opcodes.INVOKEINTERFACE) {
2246                             currentOffset += 5;
2247                         } else {
2248                             currentOffset += 3;
2249                         }
2250                         break;
2251                     }
<span class="line-modified">2252                 case Constants.INVOKEDYNAMIC:</span>
2253                     {
2254                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
2255                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
2256                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
2257                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
2258                         int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];
2259                         Handle handle =
2260                                 (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
2261                         Object[] bootstrapMethodArguments =
2262                                 new Object[readUnsignedShort(bootstrapMethodOffset + 2)];
2263                         bootstrapMethodOffset += 4;
2264                         for (int i = 0; i &lt; bootstrapMethodArguments.length; i++) {
2265                             bootstrapMethodArguments[i] =
2266                                     readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
2267                             bootstrapMethodOffset += 2;
2268                         }
2269                         methodVisitor.visitInvokeDynamicInsn(
2270                                 name, descriptor, handle, bootstrapMethodArguments);
2271                         currentOffset += 5;
2272                         break;
2273                     }
<span class="line-modified">2274                 case Constants.NEW:</span>
<span class="line-modified">2275                 case Constants.ANEWARRAY:</span>
<span class="line-modified">2276                 case Constants.CHECKCAST:</span>
<span class="line-modified">2277                 case Constants.INSTANCEOF:</span>
<span class="line-modified">2278                 case Constants.DEFAULT:</span>
2279                     methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));
2280                     currentOffset += 3;
2281                     break;
<span class="line-modified">2282                 case Constants.IINC:</span>
2283                     methodVisitor.visitIincInsn(
<span class="line-modified">2284                             classFileBuffer[currentOffset + 1] &amp; 0xFF, classFileBuffer[currentOffset + 2]);</span>
2285                     currentOffset += 3;
2286                     break;
<span class="line-modified">2287                 case Constants.MULTIANEWARRAY:</span>
2288                     methodVisitor.visitMultiANewArrayInsn(
<span class="line-modified">2289                             readClass(currentOffset + 1, charBuffer), classFileBuffer[currentOffset + 3] &amp; 0xFF);</span>
2290                     currentOffset += 4;
2291                     break;
2292                 default:
2293                     throw new AssertionError();
2294             }
2295 
2296             // Visit the runtime visible instruction annotations, if any.
2297             while (visibleTypeAnnotationOffsets != null
2298                     &amp;&amp; currentVisibleTypeAnnotationIndex &lt; visibleTypeAnnotationOffsets.length
2299                     &amp;&amp; currentVisibleTypeAnnotationBytecodeOffset &lt;= currentBytecodeOffset) {
2300                 if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {
2301                     // Parse the target_type, target_info and target_path fields.
2302                     int currentAnnotationOffset =
2303                             readTypeAnnotationTarget(
2304                                     context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);
2305                     // Parse the type_index field.
2306                     String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
2307                     currentAnnotationOffset += 2;
2308                     // Parse num_element_value_pairs and element_value_pairs and visit these values.
2309                     readElementValues(
</pre>
<hr />
<pre>
2573                 case TypeReference.NEW:
2574                 case TypeReference.CONSTRUCTOR_REFERENCE:
2575                 case TypeReference.METHOD_REFERENCE:
2576                     currentOffset += 3;
2577                     break;
2578                 case TypeReference.CLASS_TYPE_PARAMETER:
2579                 case TypeReference.METHOD_TYPE_PARAMETER:
2580                 case TypeReference.METHOD_FORMAL_PARAMETER:
2581                 case TypeReference.FIELD:
2582                 case TypeReference.METHOD_RETURN:
2583                 case TypeReference.METHOD_RECEIVER:
2584                 default:
2585                     // TypeReference type which can&#39;t be used in Code attribute, or which is unknown.
2586                     throw new IllegalArgumentException();
2587             }
2588             // Parse the rest of the type_annotation structure, starting with the target_path structure
2589             // (whose size depends on its path_length field).
2590             int pathLength = readByte(currentOffset);
2591             if ((targetType &gt;&gt;&gt; 24) == TypeReference.EXCEPTION_PARAMETER) {
2592                 // Parse the target_path structure and create a corresponding TypePath.
<span class="line-modified">2593                 TypePath path = pathLength == 0 ? null : new TypePath(b, currentOffset);</span>
2594                 currentOffset += 1 + 2 * pathLength;
2595                 // Parse the type_index field.
2596                 String annotationDescriptor = readUTF8(currentOffset, charBuffer);
2597                 currentOffset += 2;
2598                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
2599                 currentOffset =
2600                         readElementValues(
2601                                 methodVisitor.visitTryCatchAnnotation(
2602                                         targetType &amp; 0xFFFFFF00, path, annotationDescriptor, visible),
2603                                 currentOffset,
2604                                 /* named = */ true,
2605                                 charBuffer);
2606             } else {
2607                 // We don&#39;t want to visit the other target_type annotations, so we just skip them (which
2608                 // requires some parsing because the element_value_pairs array has a variable size). First,
2609                 // skip the target_path structure:
2610                 currentOffset += 3 + 2 * pathLength;
2611                 // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them
2612                 // with a null AnnotationVisitor).
2613                 currentOffset =
2614                         readElementValues(
2615                                 /* annotationVisitor = */ null, currentOffset, /* named = */ true, charBuffer);
2616             }
2617         }
2618         return typeAnnotationsOffsets;
2619     }
2620 
2621     /**
2622       * Returns the bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or
2623       * -1 if there is no such type_annotation of if it does not have a bytecode offset.
2624       *
2625       * @param typeAnnotationOffsets the offset of each &#39;type_annotation&#39; entry in a
<span class="line-modified">2626       *     Runtime[In]VisibleTypeAnnotations attribute, or null.</span>
2627       * @param typeAnnotationIndex the index a &#39;type_annotation&#39; entry in typeAnnotationOffsets.
2628       * @return bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or -1
2629       *     if there is no such type_annotation of if it does not have a bytecode offset.
2630       */
2631     private int getTypeAnnotationBytecodeOffset(
2632             final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {
2633         if (typeAnnotationOffsets == null
2634                 || typeAnnotationIndex &gt;= typeAnnotationOffsets.length
2635                 || readByte(typeAnnotationOffsets[typeAnnotationIndex]) &lt; TypeReference.INSTANCEOF) {
2636             return -1;
2637         }
2638         return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);
2639     }
2640 
2641     /**
2642       * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info
2643       * and target_path (the result is stored in the given context), and returns the start offset of
2644       * the rest of the type_annotation structure.
2645       *
2646       * @param context information about the class being parsed. This is where the extracted
</pre>
<hr />
<pre>
2698             case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
2699             case TypeReference.THROWS:
2700             case TypeReference.EXCEPTION_PARAMETER:
2701                 targetType &amp;= 0xFFFFFF00;
2702                 currentOffset += 3;
2703                 break;
2704             case TypeReference.INSTANCEOF:
2705             case TypeReference.NEW:
2706             case TypeReference.CONSTRUCTOR_REFERENCE:
2707             case TypeReference.METHOD_REFERENCE:
2708                 targetType &amp;= 0xFF000000;
2709                 currentOffset += 3;
2710                 break;
2711             default:
2712                 throw new IllegalArgumentException();
2713         }
2714         context.currentTypeAnnotationTarget = targetType;
2715         // Parse and store the target_path structure.
2716         int pathLength = readByte(currentOffset);
2717         context.currentTypeAnnotationTargetPath =
<span class="line-modified">2718                 pathLength == 0 ? null : new TypePath(b, currentOffset);</span>
2719         // Return the start offset of the rest of the type_annotation structure.
2720         return currentOffset + 1 + 2 * pathLength;
2721     }
2722 
2723     /**
2724       * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.
2725       *
2726       * @param methodVisitor the visitor that must visit the parameter annotations.
2727       * @param context information about the class being parsed.
2728       * @param runtimeParameterAnnotationsOffset the start offset of a
2729       *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info&#39;s
2730       *     attribute_name_index and attribute_length fields.
2731       * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations
2732       *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.
2733       */
2734     private void readParameterAnnotations(
2735             final MethodVisitor methodVisitor,
2736             final Context context,
2737             final int runtimeParameterAnnotationsOffset,
2738             final boolean visible) {
2739         int currentOffset = runtimeParameterAnnotationsOffset;
<span class="line-modified">2740         int numParameters = b[currentOffset++] &amp; 0xFF;</span>
2741         methodVisitor.visitAnnotableParameterCount(numParameters, visible);
2742         char[] charBuffer = context.charBuffer;
2743         for (int i = 0; i &lt; numParameters; ++i) {
2744             int numAnnotations = readUnsignedShort(currentOffset);
2745             currentOffset += 2;
2746             while (numAnnotations-- &gt; 0) {
2747                 // Parse the type_index field.
2748                 String annotationDescriptor = readUTF8(currentOffset, charBuffer);
2749                 currentOffset += 2;
2750                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
2751                 currentOffset =
2752                         readElementValues(
2753                                 methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible),
2754                                 currentOffset,
2755                                 /* named = */ true,
2756                                 charBuffer);
2757             }
2758         }
2759     }
2760 
</pre>
<hr />
<pre>
2788                 currentOffset =
2789                         readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);
2790             }
2791         } else {
2792             // Parse the array_value array.
2793             while (numElementValuePairs-- &gt; 0) {
2794                 currentOffset =
2795                         readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer);
2796             }
2797         }
2798         if (annotationVisitor != null) {
2799             annotationVisitor.visitEnd();
2800         }
2801         return currentOffset;
2802     }
2803 
2804     /**
2805       * Reads a JVMS &#39;element_value&#39; structure and makes the given visitor visit it.
2806       *
2807       * @param annotationVisitor the visitor that must visit the element_value structure.
<span class="line-modified">2808       * @param elementValueOffset the start offset in {@link #b} of the element_value structure to be</span>
<span class="line-modified">2809       *     read.</span>
2810       * @param elementName the name of the element_value structure to be read, or {@literal null}.
2811       * @param charBuffer the buffer used to read strings in the constant pool.
2812       * @return the end offset of the JVMS &#39;element_value&#39; structure.
2813       */
2814     private int readElementValue(
2815             final AnnotationVisitor annotationVisitor,
2816             final int elementValueOffset,
2817             final String elementName,
2818             final char[] charBuffer) {
2819         int currentOffset = elementValueOffset;
2820         if (annotationVisitor == null) {
<span class="line-modified">2821             switch (b[currentOffset] &amp; 0xFF) {</span>
2822                 case &#39;e&#39;: // enum_const_value
2823                     return currentOffset + 5;
2824                 case &#39;@&#39;: // annotation_value
2825                     return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);
2826                 case &#39;[&#39;: // array_value
2827                     return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);
2828                 default:
2829                     return currentOffset + 3;
2830             }
2831         }
<span class="line-modified">2832         switch (b[currentOffset++] &amp; 0xFF) {</span>
2833             case &#39;B&#39;: // const_value_index, CONSTANT_Integer
2834                 annotationVisitor.visit(
2835                         elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
2836                 currentOffset += 2;
2837                 break;
2838             case &#39;C&#39;: // const_value_index, CONSTANT_Integer
2839                 annotationVisitor.visit(
2840                         elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
2841                 currentOffset += 2;
2842                 break;
2843             case &#39;D&#39;: // const_value_index, CONSTANT_Double
2844             case &#39;F&#39;: // const_value_index, CONSTANT_Float
2845             case &#39;I&#39;: // const_value_index, CONSTANT_Integer
2846             case &#39;J&#39;: // const_value_index, CONSTANT_Long
2847                 annotationVisitor.visit(
2848                         elementName, readConst(readUnsignedShort(currentOffset), charBuffer));
2849                 currentOffset += 2;
2850                 break;
2851             case &#39;S&#39;: // const_value_index, CONSTANT_Integer
2852                 annotationVisitor.visit(
</pre>
<hr />
<pre>
2878                 currentOffset += 2;
2879                 break;
2880             case &#39;@&#39;: // annotation_value
2881                 currentOffset =
2882                         readElementValues(
2883                                 annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)),
2884                                 currentOffset + 2,
2885                                 true,
2886                                 charBuffer);
2887                 break;
2888             case &#39;[&#39;: // array_value
2889                 int numValues = readUnsignedShort(currentOffset);
2890                 currentOffset += 2;
2891                 if (numValues == 0) {
2892                     return readElementValues(
2893                             annotationVisitor.visitArray(elementName),
2894                             currentOffset - 2,
2895                             /* named = */ false,
2896                             charBuffer);
2897                 }
<span class="line-modified">2898                 switch (b[currentOffset] &amp; 0xFF) {</span>
2899                     case &#39;B&#39;:
2900                         byte[] byteValues = new byte[numValues];
2901                         for (int i = 0; i &lt; numValues; i++) {
2902                             byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
2903                             currentOffset += 3;
2904                         }
2905                         annotationVisitor.visit(elementName, byteValues);
2906                         break;
2907                     case &#39;Z&#39;:
2908                         boolean[] booleanValues = new boolean[numValues];
2909                         for (int i = 0; i &lt; numValues; i++) {
2910                             booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;
2911                             currentOffset += 3;
2912                         }
2913                         annotationVisitor.visit(elementName, booleanValues);
2914                         break;
2915                     case &#39;S&#39;:
2916                         short[] shortValues = new short[numValues];
2917                         for (int i = 0; i &lt; numValues; i++) {
2918                             shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
</pre>
<hr />
<pre>
3041                 case &#39;L&#39;:
3042                     while (methodDescriptor.charAt(currentMethodDescritorOffset) != &#39;;&#39;) {
3043                         ++currentMethodDescritorOffset;
3044                     }
3045                     locals[numLocal++] =
3046                             methodDescriptor.substring(
3047                                     currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);
3048                     break;
3049                 default:
3050                     context.currentFrameLocalCount = numLocal;
3051                     return;
3052             }
3053         }
3054     }
3055 
3056     /**
3057       * Reads a JVMS &#39;stack_map_frame&#39; structure and stores the result in the given {@link Context}
3058       * object. This method can also be used to read a full_frame structure, excluding its frame_type
3059       * field (this is used to parse the legacy StackMap attributes).
3060       *
<span class="line-modified">3061       * @param stackMapFrameOffset the start offset in {@link #b} of the stack_map_frame_value</span>
<span class="line-modified">3062       *     structure to be read, or the start offset of a full_frame structure (excluding its</span>
<span class="line-modified">3063       *     frame_type field).</span>
3064       * @param compressed true to read a &#39;stack_map_frame&#39; structure, false to read a &#39;full_frame&#39;
3065       *     structure without its frame_type field.
3066       * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.
3067       * @param context where the parsed stack map frame must be stored.
3068       * @return the end offset of the JVMS &#39;stack_map_frame&#39; or &#39;full_frame&#39; structure.
3069       */
3070     private int readStackMapFrame(
3071             final int stackMapFrameOffset,
3072             final boolean compressed,
3073             final boolean expand,
3074             final Context context) {
3075         int currentOffset = stackMapFrameOffset;
3076         final char[] charBuffer = context.charBuffer;
3077         final Label[] labels = context.currentMethodLabels;
3078         int frameType;
3079         if (compressed) {
3080             // Read the frame_type field.
<span class="line-modified">3081             frameType = b[currentOffset++] &amp; 0xFF;</span>
3082         } else {
3083             frameType = Frame.FULL_FRAME;
3084             context.currentFrameOffset = -1;
3085         }
3086         int offsetDelta;
3087         context.currentFrameLocalCountDelta = 0;
3088         if (frameType &lt; Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {
3089             offsetDelta = frameType;
3090             context.currentFrameType = Opcodes.F_SAME;
3091             context.currentFrameStackCount = 0;
3092         } else if (frameType &lt; Frame.RESERVED) {
3093             offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;
3094             currentOffset =
3095                     readVerificationTypeInfo(
3096                             currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);
3097             context.currentFrameType = Opcodes.F_SAME1;
3098             context.currentFrameStackCount = 1;
3099         } else if (frameType &gt;= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
3100             offsetDelta = readUnsignedShort(currentOffset);
3101             currentOffset += 2;
</pre>
<hr />
<pre>
3156       * Reads a JVMS &#39;verification_type_info&#39; structure and stores it at the given index in the given
3157       * array.
3158       *
3159       * @param verificationTypeInfoOffset the start offset of the &#39;verification_type_info&#39; structure to
3160       *     read.
3161       * @param frame the array where the parsed type must be stored.
3162       * @param index the index in &#39;frame&#39; where the parsed type must be stored.
3163       * @param charBuffer the buffer used to read strings in the constant pool.
3164       * @param labels the labels of the method currently being parsed, indexed by their offset. If the
3165       *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is
3166       *     stored in this array if it does not already exist.
3167       * @return the end offset of the JVMS &#39;verification_type_info&#39; structure.
3168       */
3169     private int readVerificationTypeInfo(
3170             final int verificationTypeInfoOffset,
3171             final Object[] frame,
3172             final int index,
3173             final char[] charBuffer,
3174             final Label[] labels) {
3175         int currentOffset = verificationTypeInfoOffset;
<span class="line-modified">3176         int tag = b[currentOffset++] &amp; 0xFF;</span>
3177         switch (tag) {
3178             case Frame.ITEM_TOP:
3179                 frame[index] = Opcodes.TOP;
3180                 break;
3181             case Frame.ITEM_INTEGER:
3182                 frame[index] = Opcodes.INTEGER;
3183                 break;
3184             case Frame.ITEM_FLOAT:
3185                 frame[index] = Opcodes.FLOAT;
3186                 break;
3187             case Frame.ITEM_DOUBLE:
3188                 frame[index] = Opcodes.DOUBLE;
3189                 break;
3190             case Frame.ITEM_LONG:
3191                 frame[index] = Opcodes.LONG;
3192                 break;
3193             case Frame.ITEM_NULL:
3194                 frame[index] = Opcodes.NULL;
3195                 break;
3196             case Frame.ITEM_UNINITIALIZED_THIS:
</pre>
<hr />
<pre>
3198                 break;
3199             case Frame.ITEM_OBJECT:
3200                 frame[index] = readClass(currentOffset, charBuffer);
3201                 currentOffset += 2;
3202                 break;
3203             case Frame.ITEM_UNINITIALIZED:
3204                 frame[index] = createLabel(readUnsignedShort(currentOffset), labels);
3205                 currentOffset += 2;
3206                 break;
3207             default:
3208                 throw new IllegalArgumentException();
3209         }
3210         return currentOffset;
3211     }
3212 
3213     // ----------------------------------------------------------------------------------------------
3214     // Methods to parse attributes
3215     // ----------------------------------------------------------------------------------------------
3216 
3217     /**
<span class="line-modified">3218       * Returns the offset in {@link #b} of the first ClassFile&#39;s &#39;attributes&#39; array field entry.</span>

3219       *
<span class="line-modified">3220       * @return the offset in {@link #b} of the first ClassFile&#39;s &#39;attributes&#39; array field entry.</span>

3221       */
3222     final int getFirstAttributeOffset() {
3223         // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes
3224         // each), as well as the interfaces array field (2 bytes per interface).
3225         int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;
3226 
3227         // Read the fields_count field.
3228         int fieldsCount = readUnsignedShort(currentOffset);
3229         currentOffset += 2;
3230         // Skip the &#39;fields&#39; array field.
3231         while (fieldsCount-- &gt; 0) {
3232             // Invariant: currentOffset is the offset of a field_info structure.
3233             // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the
3234             // attributes_count field.
3235             int attributesCount = readUnsignedShort(currentOffset + 6);
3236             currentOffset += 8;
3237             // Skip the &#39;attributes&#39; array field.
3238             while (attributesCount-- &gt; 0) {
3239                 // Invariant: currentOffset is the offset of an attribute_info structure.
3240                 // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip
</pre>
<hr />
<pre>
3247         // Skip the methods_count and &#39;methods&#39; fields, using the same method as above.
3248         int methodsCount = readUnsignedShort(currentOffset);
3249         currentOffset += 2;
3250         while (methodsCount-- &gt; 0) {
3251             int attributesCount = readUnsignedShort(currentOffset + 6);
3252             currentOffset += 8;
3253             while (attributesCount-- &gt; 0) {
3254                 currentOffset += 6 + readInt(currentOffset + 2);
3255             }
3256         }
3257 
3258         // Skip the ClassFile&#39;s attributes_count field.
3259         return currentOffset + 2;
3260     }
3261 
3262     /**
3263       * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
3264       *
3265       * @param maxStringLength a conservative estimate of the maximum length of the strings contained
3266       *     in the constant pool of the class.
<span class="line-modified">3267       * @return the offsets of the bootstrap methods or null.</span>
3268       */
3269     private int[] readBootstrapMethodsAttribute(final int maxStringLength) {
3270         char[] charBuffer = new char[maxStringLength];
3271         int currentAttributeOffset = getFirstAttributeOffset();
3272         int[] currentBootstrapMethodOffsets = null;
3273         for (int i = readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {
3274             // Read the attribute_info&#39;s attribute_name and attribute_length fields.
3275             String attributeName = readUTF8(currentAttributeOffset, charBuffer);
3276             int attributeLength = readInt(currentAttributeOffset + 2);
3277             currentAttributeOffset += 6;
3278             if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {
3279                 // Read the num_bootstrap_methods field and create an array of this size.
3280                 currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];
3281                 // Compute and store the offset of each &#39;bootstrap_methods&#39; array field entry.
3282                 int currentBootstrapMethodOffset = currentAttributeOffset + 2;
3283                 for (int j = 0; j &lt; currentBootstrapMethodOffsets.length; ++j) {
3284                     currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;
3285                     // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),
3286                     // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).
3287                     currentBootstrapMethodOffset +=
3288                             4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;
3289                 }
3290                 return currentBootstrapMethodOffsets;
3291             }
3292             currentAttributeOffset += attributeLength;
3293         }
<span class="line-modified">3294         return null;</span>
3295     }
3296 
3297     /**
<span class="line-modified">3298       * Reads a non standard JVMS &#39;attribute&#39; structure in {@link #b}.</span>
3299       *
3300       * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
3301       *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
3302       *     be parsed: its byte array value will be passed unchanged to the ClassWriter.
3303       * @param type the type of the attribute.
<span class="line-modified">3304       * @param offset the start offset of the JVMS &#39;attribute&#39; structure in {@link #b}. The 6 attribute</span>
<span class="line-modified">3305       *     header bytes (attribute_name_index and attribute_length) are not taken into account here.</span>

3306       * @param length the length of the attribute&#39;s content (excluding the 6 attribute header bytes).
3307       * @param charBuffer the buffer to be used to read strings in the constant pool.
<span class="line-modified">3308       * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link #b}, or</span>
<span class="line-modified">3309       *     -1 if the attribute to be read is not a code attribute. The 6 attribute header bytes</span>
<span class="line-modified">3310       *     (attribute_name_index and attribute_length) are not taken into account here.</span>

3311       * @param labels the labels of the method&#39;s code, or {@literal null} if the attribute to be read
3312       *     is not a code attribute.
3313       * @return the attribute that has been read.
3314       */
3315     private Attribute readAttribute(
3316             final Attribute[] attributePrototypes,
3317             final String type,
3318             final int offset,
3319             final int length,
3320             final char[] charBuffer,
3321             final int codeAttributeOffset,
3322             final Label[] labels) {
3323         for (Attribute attributePrototype : attributePrototypes) {
3324             if (attributePrototype.type.equals(type)) {
3325                 return attributePrototype.read(
3326                         this, offset, length, charBuffer, codeAttributeOffset, labels);
3327             }
3328         }
3329         return new Attribute(type).read(this, offset, length, null, -1, null);
3330     }
3331 
3332     // -----------------------------------------------------------------------------------------------
3333     // Utility methods: low level parsing
3334     // -----------------------------------------------------------------------------------------------
3335 
3336     /**
3337       * Returns the number of entries in the class&#39;s constant pool table.
3338       *
3339       * @return the number of entries in the class&#39;s constant pool table.
3340       */
3341     public int getItemCount() {
3342         return cpInfoOffsets.length;
3343     }
3344 
3345     /**
<span class="line-modified">3346       * Returns the start offset in {@link #b} of a JVMS &#39;cp_info&#39; structure (i.e. a constant pool</span>
<span class="line-modified">3347       * entry), plus one. &lt;i&gt;This method is intended for {@link Attribute} sub classes, and is normally</span>
<span class="line-modified">3348       * not needed by class generators or adapters.&lt;/i&gt;</span>
3349       *
3350       * @param constantPoolEntryIndex the index a constant pool entry in the class&#39;s constant pool
3351       *     table.
<span class="line-modified">3352       * @return the start offset in {@link #b} of the corresponding JVMS &#39;cp_info&#39; structure, plus one.</span>

3353       */
3354     public int getItem(final int constantPoolEntryIndex) {
3355         return cpInfoOffsets[constantPoolEntryIndex];
3356     }
3357 
3358     /**
3359       * Returns a conservative estimate of the maximum length of the strings contained in the class&#39;s
3360       * constant pool table.
3361       *
3362       * @return a conservative estimate of the maximum length of the strings contained in the class&#39;s
3363       *     constant pool table.
3364       */
3365     public int getMaxStringLength() {
3366         return maxStringLength;
3367     }
3368 
3369     /**
<span class="line-modified">3370       * Reads a byte value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub classes,</span>
<span class="line-modified">3371       * and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3372       *
<span class="line-modified">3373       * @param offset the start offset of the value to be read in {@link #b}.</span>
3374       * @return the read value.
3375       */
3376     public int readByte(final int offset) {
<span class="line-modified">3377         return b[offset] &amp; 0xFF;</span>
3378     }
3379 
3380     /**
<span class="line-modified">3381       * Reads an unsigned short value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute}</span>
<span class="line-modified">3382       * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3383       *
<span class="line-modified">3384       * @param offset the start index of the value to be read in {@link #b}.</span>
3385       * @return the read value.
3386       */
3387     public int readUnsignedShort(final int offset) {
<span class="line-modified">3388         byte[] classFileBuffer = b;</span>
<span class="line-modified">3389         return ((classFileBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classFileBuffer[offset + 1] &amp; 0xFF);</span>
3390     }
3391 
3392     /**
<span class="line-modified">3393       * Reads a signed short value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub</span>
<span class="line-modified">3394       * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3395       *
<span class="line-modified">3396       * @param offset the start offset of the value to be read in {@link #b}.</span>
3397       * @return the read value.
3398       */
3399     public short readShort(final int offset) {
<span class="line-modified">3400         byte[] classFileBuffer = b;</span>
<span class="line-modified">3401         return (short) (((classFileBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classFileBuffer[offset + 1] &amp; 0xFF));</span>
3402     }
3403 
3404     /**
<span class="line-modified">3405       * Reads a signed int value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub</span>
<span class="line-modified">3406       * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3407       *
<span class="line-modified">3408       * @param offset the start offset of the value to be read in {@link #b}.</span>
3409       * @return the read value.
3410       */
3411     public int readInt(final int offset) {
<span class="line-modified">3412         byte[] classFileBuffer = b;</span>
<span class="line-modified">3413         return ((classFileBuffer[offset] &amp; 0xFF) &lt;&lt; 24)</span>
<span class="line-modified">3414                 | ((classFileBuffer[offset + 1] &amp; 0xFF) &lt;&lt; 16)</span>
<span class="line-modified">3415                 | ((classFileBuffer[offset + 2] &amp; 0xFF) &lt;&lt; 8)</span>
<span class="line-modified">3416                 | (classFileBuffer[offset + 3] &amp; 0xFF);</span>
3417     }
3418 
3419     /**
<span class="line-modified">3420       * Reads a signed long value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub</span>
<span class="line-modified">3421       * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3422       *
<span class="line-modified">3423       * @param offset the start offset of the value to be read in {@link #b}.</span>
3424       * @return the read value.
3425       */
3426     public long readLong(final int offset) {
3427         long l1 = readInt(offset);
3428         long l0 = readInt(offset + 4) &amp; 0xFFFFFFFFL;
3429         return (l1 &lt;&lt; 32) | l0;
3430     }
3431 
3432     /**
<span class="line-modified">3433       * Reads a CONSTANT_Utf8 constant pool entry in {@link #b}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">3434       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>

3435       *
<span class="line-modified">3436       * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the</span>
<span class="line-modified">3437       *     index of a CONSTANT_Utf8 entry in the class&#39;s constant pool table.</span>
3438       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3439       *     large. It is not automatically resized.
3440       * @return the String corresponding to the specified CONSTANT_Utf8 entry.
3441       */
3442     // DontCheck(AbbreviationAsWordInName): can&#39;t be renamed (for backward binary compatibility).
3443     public String readUTF8(final int offset, final char[] charBuffer) {
3444         int constantPoolEntryIndex = readUnsignedShort(offset);
3445         if (offset == 0 || constantPoolEntryIndex == 0) {
3446             return null;
3447         }
3448         return readUtf(constantPoolEntryIndex, charBuffer);
3449     }
3450 
3451     /**
<span class="line-modified">3452       * Reads a CONSTANT_Utf8 constant pool entry in {@link #b}.</span>
3453       *
3454       * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class&#39;s constant pool
3455       *     table.
3456       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3457       *     large. It is not automatically resized.
3458       * @return the String corresponding to the specified CONSTANT_Utf8 entry.
3459       */
3460     final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {
3461         String value = constantUtf8Values[constantPoolEntryIndex];
3462         if (value != null) {
3463             return value;
3464         }
3465         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
3466         return constantUtf8Values[constantPoolEntryIndex] =
3467                 readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);
3468     }
3469 
3470     /**
<span class="line-modified">3471       * Reads an UTF8 string in {@link #b}.</span>
3472       *
3473       * @param utfOffset the start offset of the UTF8 string to be read.
3474       * @param utfLength the length of the UTF8 string to be read.
3475       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3476       *     large. It is not automatically resized.
3477       * @return the String corresponding to the specified UTF8 string.
3478       */
3479     private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {
3480         int currentOffset = utfOffset;
3481         int endOffset = currentOffset + utfLength;
3482         int strLength = 0;
<span class="line-modified">3483         byte[] classFileBuffer = b;</span>
3484         while (currentOffset &lt; endOffset) {
<span class="line-modified">3485             int currentByte = classFileBuffer[currentOffset++];</span>
3486             if ((currentByte &amp; 0x80) == 0) {
3487                 charBuffer[strLength++] = (char) (currentByte &amp; 0x7F);
3488             } else if ((currentByte &amp; 0xE0) == 0xC0) {
3489                 charBuffer[strLength++] =
<span class="line-modified">3490                         (char) (((currentByte &amp; 0x1F) &lt;&lt; 6) + (classFileBuffer[currentOffset++] &amp; 0x3F));</span>
3491             } else {
3492                 charBuffer[strLength++] =
3493                         (char)
3494                                 (((currentByte &amp; 0xF) &lt;&lt; 12)
<span class="line-modified">3495                                         + ((classFileBuffer[currentOffset++] &amp; 0x3F) &lt;&lt; 6)</span>
<span class="line-modified">3496                                         + (classFileBuffer[currentOffset++] &amp; 0x3F));</span>
3497             }
3498         }
3499         return new String(charBuffer, 0, strLength);
3500     }
3501 
3502     /**
3503       * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
<span class="line-modified">3504       * CONSTANT_Package constant pool entry in {@link #b}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">3505       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>

3506       *
<span class="line-modified">3507       * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the</span>
<span class="line-modified">3508       *     index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or</span>
<span class="line-modified">3509       *     CONSTANT_Package entry in class&#39;s constant pool table.</span>
3510       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3511       *     large. It is not automatically resized.
3512       * @return the String corresponding to the specified constant pool entry.
3513       */
3514     private String readStringish(final int offset, final char[] charBuffer) {
3515         // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry
3516         // designated by the first two bytes of this cp_info.
3517         return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);
3518     }
3519 
3520     /**
<span class="line-modified">3521       * Reads a CONSTANT_Class constant pool entry in {@link #b}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">3522       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>

3523       *
<span class="line-modified">3524       * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the</span>
<span class="line-modified">3525       *     index of a CONSTANT_Class entry in class&#39;s constant pool table.</span>
3526       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3527       *     large. It is not automatically resized.
3528       * @return the String corresponding to the specified CONSTANT_Class entry.
3529       */
3530     public String readClass(final int offset, final char[] charBuffer) {
3531         return readStringish(offset, charBuffer);
3532     }
3533 
3534     /**
<span class="line-modified">3535       * Reads a CONSTANT_Module constant pool entry in {@link #b}. &lt;i&gt;This method is intended for</span>
<span class="line-modified">3536       * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>

3537       *
<span class="line-modified">3538       * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the</span>
<span class="line-modified">3539       *     index of a CONSTANT_Module entry in class&#39;s constant pool table.</span>
3540       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3541       *     large. It is not automatically resized.
3542       * @return the String corresponding to the specified CONSTANT_Module entry.
3543       */
3544     public String readModule(final int offset, final char[] charBuffer) {
3545         return readStringish(offset, charBuffer);
3546     }
3547 
3548     /**
<span class="line-modified">3549       * Reads a CONSTANT_Package constant pool entry in {@link #b}. &lt;i&gt;This method is intended for</span>
<span class="line-modified">3550       * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>

3551       *
<span class="line-modified">3552       * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the</span>
<span class="line-modified">3553       *     index of a CONSTANT_Package entry in class&#39;s constant pool table.</span>
3554       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3555       *     large. It is not automatically resized.
3556       * @return the String corresponding to the specified CONSTANT_Package entry.
3557       */
3558     public String readPackage(final int offset, final char[] charBuffer) {
3559         return readStringish(offset, charBuffer);
3560     }
3561 
3562     /**
<span class="line-modified">3563       * Reads a CONSTANT_Dynamic constant pool entry in {@link #b}.</span>
3564       *
3565       * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class&#39;s constant
3566       *     pool table.
3567       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3568       *     large. It is not automatically resized.
3569       * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.
3570       */
3571     private ConstantDynamic readConstantDynamic(
3572             final int constantPoolEntryIndex, final char[] charBuffer) {
3573         ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];
3574         if (constantDynamic != null) {
3575             return constantDynamic;
3576         }
3577         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
3578         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
3579         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
3580         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
3581         int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];
3582         Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
3583         Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];
3584         bootstrapMethodOffset += 4;
3585         for (int i = 0; i &lt; bootstrapMethodArguments.length; i++) {
3586             bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
3587             bootstrapMethodOffset += 2;
3588         }
3589         return constantDynamicValues[constantPoolEntryIndex] =
3590                 new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);
3591     }
3592 
3593     /**
<span class="line-modified">3594       * Reads a numeric or string constant pool entry in {@link #b}. &lt;i&gt;This method is intended for</span>
<span class="line-modified">3595       * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>

3596       *
3597       * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,
3598       *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
3599       *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class&#39;s constant pool.
3600       * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently
3601       *     large. It is not automatically resized.
3602       * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},
3603       *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified
3604       *     constant pool entry.
3605       */
3606     public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {
3607         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
<span class="line-modified">3608         switch (b[cpInfoOffset - 1]) {</span>
3609             case Symbol.CONSTANT_INTEGER_TAG:
3610                 return readInt(cpInfoOffset);
3611             case Symbol.CONSTANT_FLOAT_TAG:
3612                 return Float.intBitsToFloat(readInt(cpInfoOffset));
3613             case Symbol.CONSTANT_LONG_TAG:
3614                 return readLong(cpInfoOffset);
3615             case Symbol.CONSTANT_DOUBLE_TAG:
3616                 return Double.longBitsToDouble(readLong(cpInfoOffset));
3617             case Symbol.CONSTANT_CLASS_TAG:
3618                 return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));
3619             case Symbol.CONSTANT_STRING_TAG:
3620                 return readUTF8(cpInfoOffset, charBuffer);
3621             case Symbol.CONSTANT_METHOD_TYPE_TAG:
3622                 return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));
3623             case Symbol.CONSTANT_METHOD_HANDLE_TAG:
3624                 int referenceKind = readByte(cpInfoOffset);
3625                 int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];
3626                 int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];
3627                 String owner = readClass(referenceCpInfoOffset, charBuffer);
3628                 String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
3629                 String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
3630                 boolean isInterface =
<span class="line-modified">3631                         b[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;</span>
3632                 return new Handle(referenceKind, owner, name, descriptor, isInterface);
3633             case Symbol.CONSTANT_DYNAMIC_TAG:
3634                 return readConstantDynamic(constantPoolEntryIndex, charBuffer);
3635             default:
3636                 throw new IllegalArgumentException();
3637         }
3638     }
3639 }
</pre>
</td>
<td>
<hr />
<pre>
  64 
  65 /**
  66  * A parser to make a {@link ClassVisitor} visit a ClassFile structure, as defined in the Java
  67  * Virtual Machine Specification (JVMS). This class parses the ClassFile content and calls the
  68  * appropriate visit methods of a given {@link ClassVisitor} for each field, method and bytecode
  69  * instruction encountered.
  70  *
  71  * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html&quot;&gt;JVMS 4&lt;/a&gt;
  72  * @author Eric Bruneton
  73  * @author Eugene Kuleshov
  74  */
  75 public class ClassReader {
  76 
  77     /**
  78       * A flag to skip the Code attributes. If this flag is set the Code attributes are neither parsed
  79       * nor visited.
  80       */
  81     public static final int SKIP_CODE = 1;
  82 
  83     /**
<span class="line-modified">  84       * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,</span>
<span class="line-modified">  85       * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set</span>
<span class="line-modified">  86       * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link</span>
<span class="line-modified">  87       * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link</span>
<span class="line-added">  88       * MethodVisitor#visitParameter} are not called).</span>
  89       */
  90     public static final int SKIP_DEBUG = 2;
  91 
  92     /**
  93       * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes
  94       * are neither parsed nor visited (i.e. {@link MethodVisitor#visitFrame} is not called). This flag
  95       * is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is used: it avoids visiting frames
  96       * that will be ignored and recomputed from scratch.
  97       */
  98     public static final int SKIP_FRAMES = 4;
  99 
 100     /**
 101       * A flag to expand the stack map frames. By default stack map frames are visited in their
 102       * original format (i.e. &quot;expanded&quot; for classes whose version is less than V1_6, and &quot;compressed&quot;
 103       * for the other classes). If this flag is set, stack map frames are always visited in expanded
 104       * format (this option adds a decompression/compression step in ClassReader and ClassWriter which
 105       * degrades performance quite a lot).
 106       */
 107     public static final int EXPAND_FRAMES = 8;
 108 
 109     /**
 110       * A flag to expand the ASM specific instructions into an equivalent sequence of standard bytecode
 111       * instructions. When resolving a forward jump it may happen that the signed 2 bytes offset
 112       * reserved for it is not sufficient to store the bytecode offset. In this case the jump
 113       * instruction is replaced with a temporary ASM specific instruction using an unsigned 2 bytes
 114       * offset (see {@link Label#resolve}). This internal flag is used to re-read classes containing
 115       * such instructions, in order to replace them with standard instructions. In addition, when this
 116       * flag is used, goto_w and jsr_w are &lt;i&gt;not&lt;/i&gt; converted into goto and jsr, to make sure that
 117       * infinite loops where a goto_w is replaced with a goto in ClassReader and converted back to a
 118       * goto_w in ClassWriter cannot occur.
 119       */
 120     static final int EXPAND_ASM_INSNS = 256;
 121 
 122     /** The size of the temporary byte array used to read class input streams chunk by chunk. */
 123     private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;
 124 
<span class="line-added"> 125     /**</span>
<span class="line-added"> 126       * A byte array containing the JVMS ClassFile structure to be parsed.</span>
<span class="line-added"> 127       *</span>
<span class="line-added"> 128       * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will</span>
<span class="line-added"> 129       *     eventually be deleted.</span>
<span class="line-added"> 130       */</span>
<span class="line-added"> 131     @Deprecated</span>
<span class="line-added"> 132     // DontCheck(MemberName): can&#39;t be renamed (for backward binary compatibility).</span>
<span class="line-added"> 133     public final byte[] b;</span>
<span class="line-added"> 134 </span>
 135     /**
 136       * A byte array containing the JVMS ClassFile structure to be parsed. &lt;i&gt;The content of this array
 137       * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally
 138       * not needed by class visitors.&lt;/i&gt;
 139       *
 140       * &lt;p&gt;NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not
 141       * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct
 142       * ClassFile element offsets within this byte array.
 143       */
<span class="line-modified"> 144     final byte[] classFileBuffer;</span>

 145 
 146     /**
<span class="line-modified"> 147       * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile&#39;s</span>
<span class="line-modified"> 148       * constant_pool array, &lt;i&gt;plus one&lt;/i&gt;. In other words, the offset of constant pool entry i is</span>
<span class="line-modified"> 149       * given by cpInfoOffsets[i] - 1, i.e. its cp_info&#39;s tag field is given by b[cpInfoOffsets[i] -</span>
<span class="line-added"> 150       * 1].</span>
 151       */
 152     private final int[] cpInfoOffsets;
 153 
 154     /**
 155       * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids
 156       * multiple parsing of a given CONSTANT_Utf8 constant pool item.
 157       */
 158     private final String[] constantUtf8Values;
 159 
 160     /**
 161       * The ConstantDynamic objects corresponding to the CONSTANT_Dynamic constant pool items. This
 162       * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.
 163       */
 164     private final ConstantDynamic[] constantDynamicValues;
 165 
 166     /**
<span class="line-modified"> 167       * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array</span>
<span class="line-modified"> 168       * (in the BootstrapMethods attribute).</span>
 169       *
 170       * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23&quot;&gt;JVMS
 171       *     4.7.23&lt;/a&gt;
 172       */
 173     private final int[] bootstrapMethodOffsets;
 174 
 175     /**
 176       * A conservative estimate of the maximum length of the strings contained in the constant pool of
 177       * the class.
 178       */
 179     private final int maxStringLength;
 180 
<span class="line-modified"> 181     /** The offset in bytes of the ClassFile&#39;s access_flags field. */</span>
 182     public final int header;
 183 
 184     // -----------------------------------------------------------------------------------------------
 185     // Constructors
 186     // -----------------------------------------------------------------------------------------------
 187 
 188     /**
 189       * Constructs a new {@link ClassReader} object.
 190       *
 191       * @param classFile the JVMS ClassFile structure to be read.
 192       */
 193     public ClassReader(final byte[] classFile) {
 194         this(classFile, 0, classFile.length);
 195     }
 196 
 197     /**
 198       * Constructs a new {@link ClassReader} object.
 199       *
 200       * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
 201       * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
 202       * @param classFileLength the length in bytes of the ClassFile to be read.
 203       */
 204     public ClassReader(
 205             final byte[] classFileBuffer,
 206             final int classFileOffset,
 207             final int classFileLength) { // NOPMD(UnusedFormalParameter) used for backward compatibility.
 208         this(classFileBuffer, classFileOffset, /* checkClassVersion = */ true);
 209     }
 210 
 211     /**
 212       * Constructs a new {@link ClassReader} object. &lt;i&gt;This internal constructor must not be exposed
 213       * as a public API&lt;/i&gt;.
 214       *
 215       * @param classFileBuffer a byte array containing the JVMS ClassFile structure to be read.
 216       * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
 217       * @param checkClassVersion whether to check the class version or not.
 218       */
 219     ClassReader(
 220             final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
<span class="line-modified"> 221         this.classFileBuffer = classFileBuffer;</span>
<span class="line-added"> 222         this.b = classFileBuffer;</span>
 223         // Check the class&#39; major_version. This field is after the magic and minor_version fields, which
 224         // use 4 and 2 bytes respectively.
 225         if (checkClassVersion &amp;&amp; readShort(classFileOffset + 6) &gt; Opcodes.V15) {
 226             throw new IllegalArgumentException(
 227                     &quot;Unsupported class file major version &quot; + readShort(classFileOffset + 6));
 228         }
 229         // Create the constant pool arrays. The constant_pool_count field is after the magic,
 230         // minor_version and major_version fields, which use 4, 2 and 2 bytes respectively.
 231         int constantPoolCount = readUnsignedShort(classFileOffset + 8);
 232         cpInfoOffsets = new int[constantPoolCount];
 233         constantUtf8Values = new String[constantPoolCount];
 234         // Compute the offset of each constant pool entry, as well as a conservative estimate of the
 235         // maximum length of the constant pool strings. The first constant pool entry is after the
 236         // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2
 237         // bytes respectively.
 238         int currentCpInfoIndex = 1;
 239         int currentCpInfoOffset = classFileOffset + 10;
 240         int currentMaxStringLength = 0;
<span class="line-added"> 241         boolean hasBootstrapMethods = false;</span>
 242         boolean hasConstantDynamic = false;

 243         // The offset of the other entries depend on the total size of all the previous entries.
 244         while (currentCpInfoIndex &lt; constantPoolCount) {
 245             cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;
 246             int cpInfoSize;
 247             switch (classFileBuffer[currentCpInfoOffset]) {
 248                 case Symbol.CONSTANT_FIELDREF_TAG:
 249                 case Symbol.CONSTANT_METHODREF_TAG:
 250                 case Symbol.CONSTANT_INTERFACE_METHODREF_TAG:
 251                 case Symbol.CONSTANT_INTEGER_TAG:
 252                 case Symbol.CONSTANT_FLOAT_TAG:
 253                 case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
 254                     cpInfoSize = 5;
 255                     break;
 256                 case Symbol.CONSTANT_DYNAMIC_TAG:
 257                     cpInfoSize = 5;
<span class="line-added"> 258                     hasBootstrapMethods = true;</span>
 259                     hasConstantDynamic = true;
 260                     break;
 261                 case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
 262                     cpInfoSize = 5;
<span class="line-modified"> 263                     hasBootstrapMethods = true;</span>
 264                     break;
 265                 case Symbol.CONSTANT_LONG_TAG:
 266                 case Symbol.CONSTANT_DOUBLE_TAG:
 267                     cpInfoSize = 9;
 268                     currentCpInfoIndex++;
 269                     break;
 270                 case Symbol.CONSTANT_UTF8_TAG:
 271                     cpInfoSize = 3 + readUnsignedShort(currentCpInfoOffset + 1);
 272                     if (cpInfoSize &gt; currentMaxStringLength) {
 273                         // The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate
 274                         // of the length in characters of the corresponding string, and is much cheaper to
 275                         // compute than this exact length.
 276                         currentMaxStringLength = cpInfoSize;
 277                     }
 278                     break;
 279                 case Symbol.CONSTANT_METHOD_HANDLE_TAG:
 280                     cpInfoSize = 4;
 281                     break;
 282                 case Symbol.CONSTANT_CLASS_TAG:
 283                 case Symbol.CONSTANT_STRING_TAG:
 284                 case Symbol.CONSTANT_METHOD_TYPE_TAG:
 285                 case Symbol.CONSTANT_PACKAGE_TAG:
 286                 case Symbol.CONSTANT_MODULE_TAG:
 287                     cpInfoSize = 3;
 288                     break;
 289                 default:
 290                     throw new IllegalArgumentException();
 291             }
 292             currentCpInfoOffset += cpInfoSize;
 293         }
 294         maxStringLength = currentMaxStringLength;
 295         // The Classfile&#39;s access_flags field is just after the last constant pool entry.
 296         header = currentCpInfoOffset;
 297 
 298         // Allocate the cache of ConstantDynamic values, if there is at least one.
 299         constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;
 300 
 301         // Read the BootstrapMethods attribute, if any (only get the offset of each method).
 302         bootstrapMethodOffsets =
<span class="line-modified"> 303                 hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;</span>


 304     }
 305 
 306     /**
 307       * Constructs a new {@link ClassReader} object.
 308       *
 309       * @param inputStream an input stream of the JVMS ClassFile structure to be read. This input
 310       *     stream must contain nothing more than the ClassFile structure itself. It is read from its
 311       *     current position to its end.
 312       * @throws IOException if a problem occurs during reading.
 313       */
 314     public ClassReader(final InputStream inputStream) throws IOException {
 315         this(readStream(inputStream, false));
 316     }
 317 
 318     /**
 319       * Constructs a new {@link ClassReader} object.
 320       *
 321       * @param className the fully qualified name of the class to be read. The ClassFile structure is
 322       *     retrieved with the current class loader&#39;s {@link ClassLoader#getSystemResourceAsStream}.
 323       * @throws IOException if an exception occurs during reading.
 324       */
 325     public ClassReader(final String className) throws IOException {
 326         this(
 327                 readStream(
 328                         ClassLoader.getSystemResourceAsStream(className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;), true));
 329     }
 330 
 331     /**
 332       * Reads the given input stream and returns its content as a byte array.
 333       *
 334       * @param inputStream an input stream.
 335       * @param close true to close the input stream after reading.
 336       * @return the content of the given input stream.
 337       * @throws IOException if a problem occurs during reading.
 338       */
 339     private static byte[] readStream(final InputStream inputStream, final boolean close)
 340             throws IOException {
 341         if (inputStream == null) {
 342             throw new IOException(&quot;Class not found&quot;);
 343         }
<span class="line-modified"> 344         try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {</span>

 345             byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];
 346             int bytesRead;
 347             while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {
 348                 outputStream.write(data, 0, bytesRead);
 349             }
 350             outputStream.flush();
 351             return outputStream.toByteArray();
 352         } finally {
 353             if (close) {
 354                 inputStream.close();
 355             }
 356         }
 357     }
 358 
 359     // -----------------------------------------------------------------------------------------------
 360     // Accessors
 361     // -----------------------------------------------------------------------------------------------
 362 
 363     /**
 364       * Returns the class&#39;s access flags (see {@link Opcodes}). This value may not reflect Deprecated
</pre>
<hr />
<pre>
 429       *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
 430       */
 431     public void accept(final ClassVisitor classVisitor, final int parsingOptions) {
 432         accept(classVisitor, new Attribute[0], parsingOptions);
 433     }
 434 
 435     /**
 436       * Makes the given visitor visit the JVMS ClassFile structure passed to the constructor of this
 437       * {@link ClassReader}.
 438       *
 439       * @param classVisitor the visitor that must visit this class.
 440       * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
 441       *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
 442       *     be parsed: its byte array value will be passed unchanged to the ClassWriter. &lt;i&gt;This may
 443       *     corrupt it if this value contains references to the constant pool, or has syntactic or
 444       *     semantic links with a class element that has been transformed by a class adapter between
 445       *     the reader and the writer&lt;/i&gt;.
 446       * @param parsingOptions the options to use to parse this class. One or more of {@link
 447       *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
 448       */
<span class="line-added"> 449     @SuppressWarnings(&quot;deprecation&quot;)</span>
 450     public void accept(
 451             final ClassVisitor classVisitor,
 452             final Attribute[] attributePrototypes,
 453             final int parsingOptions) {
 454         Context context = new Context();
 455         context.attributePrototypes = attributePrototypes;
 456         context.parsingOptions = parsingOptions;
 457         context.charBuffer = new char[maxStringLength];
 458 
 459         // Read the access_flags, this_class, super_class, interface_count and interfaces fields.
 460         char[] charBuffer = context.charBuffer;
 461         int currentOffset = header;
 462         int accessFlags = readUnsignedShort(currentOffset);
 463         String thisClass = readClass(currentOffset + 2, charBuffer);
 464         String superClass = readClass(currentOffset + 4, charBuffer);
 465         String[] interfaces = new String[readUnsignedShort(currentOffset + 6)];
 466         currentOffset += 8;
 467         for (int i = 0; i &lt; interfaces.length; ++i) {
 468             interfaces[i] = readClass(currentOffset, charBuffer);
 469             currentOffset += 2;
</pre>
<hr />
<pre>
 482         // - The string corresponding to the SourceDebugExtension attribute, or null.
 483         String sourceDebugExtension = null;
 484         // - The offset of the RuntimeVisibleAnnotations attribute, or 0.
 485         int runtimeVisibleAnnotationsOffset = 0;
 486         // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.
 487         int runtimeInvisibleAnnotationsOffset = 0;
 488         // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.
 489         int runtimeVisibleTypeAnnotationsOffset = 0;
 490         // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.
 491         int runtimeInvisibleTypeAnnotationsOffset = 0;
 492         // - The offset of the Module attribute, or 0.
 493         int moduleOffset = 0;
 494         // - The offset of the ModulePackages attribute, or 0.
 495         int modulePackagesOffset = 0;
 496         // - The string corresponding to the ModuleMainClass attribute, or null.
 497         String moduleMainClass = null;
 498         // - The string corresponding to the NestHost attribute, or null.
 499         String nestHostClass = null;
 500         // - The offset of the NestMembers attribute, or 0.
 501         int nestMembersOffset = 0;
<span class="line-added"> 502         // - The offset of the PermittedSubtypes attribute, or 0</span>
<span class="line-added"> 503         int permittedSubtypesOffset = 0;</span>
<span class="line-added"> 504         // - The offset of the Record attribute, or 0.</span>
<span class="line-added"> 505         int recordOffset = 0;</span>
 506         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
 507         //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
 508         Attribute attributes = null;
 509 
 510         int currentAttributeOffset = getFirstAttributeOffset();
 511         for (int i = readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {
 512             // Read the attribute_info&#39;s attribute_name and attribute_length fields.
 513             String attributeName = readUTF8(currentAttributeOffset, charBuffer);
 514             int attributeLength = readInt(currentAttributeOffset + 2);
 515             currentAttributeOffset += 6;
 516             // The tests are sorted in decreasing frequency order (based on frequencies observed on
 517             // typical classes).
 518             if (Constants.SOURCE_FILE.equals(attributeName)) {
 519                 sourceFile = readUTF8(currentAttributeOffset, charBuffer);
 520             } else if (Constants.INNER_CLASSES.equals(attributeName)) {
 521                 innerClassesOffset = currentAttributeOffset;
 522             } else if (Constants.ENCLOSING_METHOD.equals(attributeName)) {
 523                 enclosingMethodOffset = currentAttributeOffset;
 524             } else if (Constants.NEST_HOST.equals(attributeName)) {
 525                 nestHostClass = readClass(currentAttributeOffset, charBuffer);
 526             } else if (Constants.NEST_MEMBERS.equals(attributeName)) {
 527                 nestMembersOffset = currentAttributeOffset;
<span class="line-added"> 528             } else if (Constants.PERMITTED_SUBTYPES.equals(attributeName)) {</span>
<span class="line-added"> 529                 permittedSubtypesOffset = currentAttributeOffset;</span>
 530             } else if (Constants.SIGNATURE.equals(attributeName)) {
 531                 signature = readUTF8(currentAttributeOffset, charBuffer);
 532             } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
 533                 runtimeVisibleAnnotationsOffset = currentAttributeOffset;
 534             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
 535                 runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;
 536             } else if (Constants.DEPRECATED.equals(attributeName)) {
 537                 accessFlags |= Opcodes.ACC_DEPRECATED;
 538             } else if (Constants.SYNTHETIC.equals(attributeName)) {
 539                 accessFlags |= Opcodes.ACC_SYNTHETIC;
 540             } else if (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) {
 541                 sourceDebugExtension =
 542                         readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);
 543             } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
 544                 runtimeInvisibleAnnotationsOffset = currentAttributeOffset;
 545             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
 546                 runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;
<span class="line-added"> 547             } else if (Constants.RECORD.equals(attributeName)) {</span>
<span class="line-added"> 548                 recordOffset = currentAttributeOffset;</span>
<span class="line-added"> 549                 accessFlags |= Opcodes.ACC_RECORD;</span>
 550             } else if (Constants.MODULE.equals(attributeName)) {
 551                 moduleOffset = currentAttributeOffset;
 552             } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {
 553                 moduleMainClass = readClass(currentAttributeOffset, charBuffer);
 554             } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {
 555                 modulePackagesOffset = currentAttributeOffset;
 556             } else if (!Constants.BOOTSTRAP_METHODS.equals(attributeName)) {
 557                 // The BootstrapMethods attribute is read in the constructor.
 558                 Attribute attribute =
 559                         readAttribute(
 560                                 attributePrototypes,
 561                                 attributeName,
 562                                 currentAttributeOffset,
 563                                 attributeLength,
 564                                 charBuffer,
 565                                 -1,
 566                                 null);
 567                 attribute.nextAttribute = attributes;
 568                 attributes = attribute;
 569             }
</pre>
<hr />
<pre>
 687 
 688         // Visit the non standard attributes.
 689         while (attributes != null) {
 690             // Copy and reset the nextAttribute field so that it can also be used in ClassWriter.
 691             Attribute nextAttribute = attributes.nextAttribute;
 692             attributes.nextAttribute = null;
 693             classVisitor.visitAttribute(attributes);
 694             attributes = nextAttribute;
 695         }
 696 
 697         // Visit the NestedMembers attribute.
 698         if (nestMembersOffset != 0) {
 699             int numberOfNestMembers = readUnsignedShort(nestMembersOffset);
 700             int currentNestMemberOffset = nestMembersOffset + 2;
 701             while (numberOfNestMembers-- &gt; 0) {
 702                 classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));
 703                 currentNestMemberOffset += 2;
 704             }
 705         }
 706 
<span class="line-added"> 707         // Visit the PermittedSubtypes attribute.</span>
<span class="line-added"> 708         if (permittedSubtypesOffset != 0) {</span>
<span class="line-added"> 709             int numberOfPermittedSubtypes = readUnsignedShort(permittedSubtypesOffset);</span>
<span class="line-added"> 710             int currentPermittedSubtypeOffset = permittedSubtypesOffset + 2;</span>
<span class="line-added"> 711             while (numberOfPermittedSubtypes-- &gt; 0) {</span>
<span class="line-added"> 712                 classVisitor.visitPermittedSubtypeExperimental(</span>
<span class="line-added"> 713                         readClass(currentPermittedSubtypeOffset, charBuffer));</span>
<span class="line-added"> 714                 currentPermittedSubtypeOffset += 2;</span>
<span class="line-added"> 715             }</span>
<span class="line-added"> 716         }</span>
<span class="line-added"> 717 </span>
 718         // Visit the InnerClasses attribute.
 719         if (innerClassesOffset != 0) {
 720             int numberOfClasses = readUnsignedShort(innerClassesOffset);
 721             int currentClassesOffset = innerClassesOffset + 2;
 722             while (numberOfClasses-- &gt; 0) {
 723                 classVisitor.visitInnerClass(
 724                         readClass(currentClassesOffset, charBuffer),
 725                         readClass(currentClassesOffset + 2, charBuffer),
 726                         readUTF8(currentClassesOffset + 4, charBuffer),
 727                         readUnsignedShort(currentClassesOffset + 6));
 728                 currentClassesOffset += 8;
 729             }
 730         }
 731 
<span class="line-added"> 732         // Visit Record components.</span>
<span class="line-added"> 733         if (recordOffset != 0) {</span>
<span class="line-added"> 734             int recordComponentsCount = readUnsignedShort(recordOffset);</span>
<span class="line-added"> 735             recordOffset += 2;</span>
<span class="line-added"> 736             while (recordComponentsCount-- &gt; 0) {</span>
<span class="line-added"> 737                 recordOffset = readRecordComponent(classVisitor, context, recordOffset);</span>
<span class="line-added"> 738             }</span>
<span class="line-added"> 739         }</span>
<span class="line-added"> 740 </span>
 741         // Visit the fields and methods.
 742         int fieldsCount = readUnsignedShort(currentOffset);
 743         currentOffset += 2;
 744         while (fieldsCount-- &gt; 0) {
 745             currentOffset = readField(classVisitor, context, currentOffset);
 746         }
 747         int methodsCount = readUnsignedShort(currentOffset);
 748         currentOffset += 2;
 749         while (methodsCount-- &gt; 0) {
 750             currentOffset = readMethod(classVisitor, context, currentOffset);
 751         }
 752 
 753         // Visit the end of the class.
 754         classVisitor.visitEnd();
 755     }
 756 
 757     // ----------------------------------------------------------------------------------------------
 758     // Methods to parse modules, fields and methods
 759     // ----------------------------------------------------------------------------------------------
 760 
 761     /**
 762       * Reads the Module, ModulePackages and ModuleMainClass attributes and visit them.
 763       *
 764       * @param classVisitor the current class visitor
 765       * @param context information about the class being parsed.
 766       * @param moduleOffset the offset of the Module attribute (excluding the attribute_info&#39;s
 767       *     attribute_name_index and attribute_length fields).
 768       * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the
 769       *     attribute_info&#39;s attribute_name_index and attribute_length fields), or 0.
<span class="line-modified"> 770       * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal</span>
<span class="line-added"> 771       *     null}.</span>
 772       */
 773     private void readModuleAttributes(
 774             final ClassVisitor classVisitor,
 775             final Context context,
 776             final int moduleOffset,
 777             final int modulePackagesOffset,
 778             final String moduleMainClass) {
 779         char[] buffer = context.charBuffer;
 780 
 781         // Read the module_name_index, module_flags and module_version_index fields and visit them.
 782         int currentOffset = moduleOffset;
 783         String moduleName = readModule(currentOffset, buffer);
 784         int moduleFlags = readUnsignedShort(currentOffset + 2);
 785         String moduleVersion = readUTF8(currentOffset + 4, buffer);
 786         currentOffset += 6;
 787         ModuleVisitor moduleVisitor = classVisitor.visitModule(moduleName, moduleFlags, moduleVersion);
 788         if (moduleVisitor == null) {
 789             return;
 790         }
 791 
</pre>
<hr />
<pre>
 868         // Read the  &#39;provides_count&#39; and &#39;provides&#39; fields.
 869         int providesCount = readUnsignedShort(currentOffset);
 870         currentOffset += 2;
 871         while (providesCount-- &gt; 0) {
 872             // Read the provides_index, provides_with_count and provides_with_index fields and visit them.
 873             String provides = readClass(currentOffset, buffer);
 874             int providesWithCount = readUnsignedShort(currentOffset + 2);
 875             currentOffset += 4;
 876             String[] providesWith = new String[providesWithCount];
 877             for (int i = 0; i &lt; providesWithCount; ++i) {
 878                 providesWith[i] = readClass(currentOffset, buffer);
 879                 currentOffset += 2;
 880             }
 881             moduleVisitor.visitProvide(provides, providesWith);
 882         }
 883 
 884         // Visit the end of the module attributes.
 885         moduleVisitor.visitEnd();
 886     }
 887 
<span class="line-added"> 888     /**</span>
<span class="line-added"> 889       * Reads a record component and visit it.</span>
<span class="line-added"> 890       *</span>
<span class="line-added"> 891       * @param classVisitor the current class visitor</span>
<span class="line-added"> 892       * @param context information about the class being parsed.</span>
<span class="line-added"> 893       * @param recordComponentOffset the offset of the current record component.</span>
<span class="line-added"> 894       * @return the offset of the first byte following the record component.</span>
<span class="line-added"> 895       */</span>
<span class="line-added"> 896     private int readRecordComponent(</span>
<span class="line-added"> 897             final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {</span>
<span class="line-added"> 898         char[] charBuffer = context.charBuffer;</span>
<span class="line-added"> 899 </span>
<span class="line-added"> 900         int currentOffset = recordComponentOffset;</span>
<span class="line-added"> 901         String name = readUTF8(currentOffset, charBuffer);</span>
<span class="line-added"> 902         String descriptor = readUTF8(currentOffset + 2, charBuffer);</span>
<span class="line-added"> 903         currentOffset += 4;</span>
<span class="line-added"> 904 </span>
<span class="line-added"> 905         // Read the record component attributes (the variables are ordered as in Section 4.7 of the</span>
<span class="line-added"> 906         // JVMS).</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908         // Attribute offsets exclude the attribute_name_index and attribute_length fields.</span>
<span class="line-added"> 909         // - The string corresponding to the Signature attribute, or null.</span>
<span class="line-added"> 910         String signature = null;</span>
<span class="line-added"> 911         // - The offset of the RuntimeVisibleAnnotations attribute, or 0.</span>
<span class="line-added"> 912         int runtimeVisibleAnnotationsOffset = 0;</span>
<span class="line-added"> 913         // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.</span>
<span class="line-added"> 914         int runtimeInvisibleAnnotationsOffset = 0;</span>
<span class="line-added"> 915         // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.</span>
<span class="line-added"> 916         int runtimeVisibleTypeAnnotationsOffset = 0;</span>
<span class="line-added"> 917         // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.</span>
<span class="line-added"> 918         int runtimeInvisibleTypeAnnotationsOffset = 0;</span>
<span class="line-added"> 919         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).</span>
<span class="line-added"> 920         //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.</span>
<span class="line-added"> 921         Attribute attributes = null;</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923         int attributesCount = readUnsignedShort(currentOffset);</span>
<span class="line-added"> 924         currentOffset += 2;</span>
<span class="line-added"> 925         while (attributesCount-- &gt; 0) {</span>
<span class="line-added"> 926             // Read the attribute_info&#39;s attribute_name and attribute_length fields.</span>
<span class="line-added"> 927             String attributeName = readUTF8(currentOffset, charBuffer);</span>
<span class="line-added"> 928             int attributeLength = readInt(currentOffset + 2);</span>
<span class="line-added"> 929             currentOffset += 6;</span>
<span class="line-added"> 930             // The tests are sorted in decreasing frequency order (based on frequencies observed on</span>
<span class="line-added"> 931             // typical classes).</span>
<span class="line-added"> 932             if (Constants.SIGNATURE.equals(attributeName)) {</span>
<span class="line-added"> 933                 signature = readUTF8(currentOffset, charBuffer);</span>
<span class="line-added"> 934             } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="line-added"> 935                 runtimeVisibleAnnotationsOffset = currentOffset;</span>
<span class="line-added"> 936             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="line-added"> 937                 runtimeVisibleTypeAnnotationsOffset = currentOffset;</span>
<span class="line-added"> 938             } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="line-added"> 939                 runtimeInvisibleAnnotationsOffset = currentOffset;</span>
<span class="line-added"> 940             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="line-added"> 941                 runtimeInvisibleTypeAnnotationsOffset = currentOffset;</span>
<span class="line-added"> 942             } else {</span>
<span class="line-added"> 943                 Attribute attribute =</span>
<span class="line-added"> 944                         readAttribute(</span>
<span class="line-added"> 945                                 context.attributePrototypes,</span>
<span class="line-added"> 946                                 attributeName,</span>
<span class="line-added"> 947                                 currentOffset,</span>
<span class="line-added"> 948                                 attributeLength,</span>
<span class="line-added"> 949                                 charBuffer,</span>
<span class="line-added"> 950                                 -1,</span>
<span class="line-added"> 951                                 null);</span>
<span class="line-added"> 952                 attribute.nextAttribute = attributes;</span>
<span class="line-added"> 953                 attributes = attribute;</span>
<span class="line-added"> 954             }</span>
<span class="line-added"> 955             currentOffset += attributeLength;</span>
<span class="line-added"> 956         }</span>
<span class="line-added"> 957 </span>
<span class="line-added"> 958         RecordComponentVisitor recordComponentVisitor =</span>
<span class="line-added"> 959                 classVisitor.visitRecordComponent(name, descriptor, signature);</span>
<span class="line-added"> 960         if (recordComponentVisitor == null) {</span>
<span class="line-added"> 961             return currentOffset;</span>
<span class="line-added"> 962         }</span>
<span class="line-added"> 963 </span>
<span class="line-added"> 964         // Visit the RuntimeVisibleAnnotations attribute.</span>
<span class="line-added"> 965         if (runtimeVisibleAnnotationsOffset != 0) {</span>
<span class="line-added"> 966             int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</span>
<span class="line-added"> 967             int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;</span>
<span class="line-added"> 968             while (numAnnotations-- &gt; 0) {</span>
<span class="line-added"> 969                 // Parse the type_index field.</span>
<span class="line-added"> 970                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="line-added"> 971                 currentAnnotationOffset += 2;</span>
<span class="line-added"> 972                 // Parse num_element_value_pairs and element_value_pairs and visit these values.</span>
<span class="line-added"> 973                 currentAnnotationOffset =</span>
<span class="line-added"> 974                         readElementValues(</span>
<span class="line-added"> 975                                 recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),</span>
<span class="line-added"> 976                                 currentAnnotationOffset,</span>
<span class="line-added"> 977                                 /* named = */ true,</span>
<span class="line-added"> 978                                 charBuffer);</span>
<span class="line-added"> 979             }</span>
<span class="line-added"> 980         }</span>
<span class="line-added"> 981 </span>
<span class="line-added"> 982         // Visit the RuntimeInvisibleAnnotations attribute.</span>
<span class="line-added"> 983         if (runtimeInvisibleAnnotationsOffset != 0) {</span>
<span class="line-added"> 984             int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</span>
<span class="line-added"> 985             int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;</span>
<span class="line-added"> 986             while (numAnnotations-- &gt; 0) {</span>
<span class="line-added"> 987                 // Parse the type_index field.</span>
<span class="line-added"> 988                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="line-added"> 989                 currentAnnotationOffset += 2;</span>
<span class="line-added"> 990                 // Parse num_element_value_pairs and element_value_pairs and visit these values.</span>
<span class="line-added"> 991                 currentAnnotationOffset =</span>
<span class="line-added"> 992                         readElementValues(</span>
<span class="line-added"> 993                                 recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),</span>
<span class="line-added"> 994                                 currentAnnotationOffset,</span>
<span class="line-added"> 995                                 /* named = */ true,</span>
<span class="line-added"> 996                                 charBuffer);</span>
<span class="line-added"> 997             }</span>
<span class="line-added"> 998         }</span>
<span class="line-added"> 999 </span>
<span class="line-added">1000         // Visit the RuntimeVisibleTypeAnnotations attribute.</span>
<span class="line-added">1001         if (runtimeVisibleTypeAnnotationsOffset != 0) {</span>
<span class="line-added">1002             int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</span>
<span class="line-added">1003             int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;</span>
<span class="line-added">1004             while (numAnnotations-- &gt; 0) {</span>
<span class="line-added">1005                 // Parse the target_type, target_info and target_path fields.</span>
<span class="line-added">1006                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span>
<span class="line-added">1007                 // Parse the type_index field.</span>
<span class="line-added">1008                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="line-added">1009                 currentAnnotationOffset += 2;</span>
<span class="line-added">1010                 // Parse num_element_value_pairs and element_value_pairs and visit these values.</span>
<span class="line-added">1011                 currentAnnotationOffset =</span>
<span class="line-added">1012                         readElementValues(</span>
<span class="line-added">1013                                 recordComponentVisitor.visitTypeAnnotation(</span>
<span class="line-added">1014                                         context.currentTypeAnnotationTarget,</span>
<span class="line-added">1015                                         context.currentTypeAnnotationTargetPath,</span>
<span class="line-added">1016                                         annotationDescriptor,</span>
<span class="line-added">1017                                         /* visible = */ true),</span>
<span class="line-added">1018                                 currentAnnotationOffset,</span>
<span class="line-added">1019                                 /* named = */ true,</span>
<span class="line-added">1020                                 charBuffer);</span>
<span class="line-added">1021             }</span>
<span class="line-added">1022         }</span>
<span class="line-added">1023 </span>
<span class="line-added">1024         // Visit the RuntimeInvisibleTypeAnnotations attribute.</span>
<span class="line-added">1025         if (runtimeInvisibleTypeAnnotationsOffset != 0) {</span>
<span class="line-added">1026             int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</span>
<span class="line-added">1027             int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;</span>
<span class="line-added">1028             while (numAnnotations-- &gt; 0) {</span>
<span class="line-added">1029                 // Parse the target_type, target_info and target_path fields.</span>
<span class="line-added">1030                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span>
<span class="line-added">1031                 // Parse the type_index field.</span>
<span class="line-added">1032                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="line-added">1033                 currentAnnotationOffset += 2;</span>
<span class="line-added">1034                 // Parse num_element_value_pairs and element_value_pairs and visit these values.</span>
<span class="line-added">1035                 currentAnnotationOffset =</span>
<span class="line-added">1036                         readElementValues(</span>
<span class="line-added">1037                                 recordComponentVisitor.visitTypeAnnotation(</span>
<span class="line-added">1038                                         context.currentTypeAnnotationTarget,</span>
<span class="line-added">1039                                         context.currentTypeAnnotationTargetPath,</span>
<span class="line-added">1040                                         annotationDescriptor,</span>
<span class="line-added">1041                                         /* visible = */ false),</span>
<span class="line-added">1042                                 currentAnnotationOffset,</span>
<span class="line-added">1043                                 /* named = */ true,</span>
<span class="line-added">1044                                 charBuffer);</span>
<span class="line-added">1045             }</span>
<span class="line-added">1046         }</span>
<span class="line-added">1047 </span>
<span class="line-added">1048         // Visit the non standard attributes.</span>
<span class="line-added">1049         while (attributes != null) {</span>
<span class="line-added">1050             // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.</span>
<span class="line-added">1051             Attribute nextAttribute = attributes.nextAttribute;</span>
<span class="line-added">1052             attributes.nextAttribute = null;</span>
<span class="line-added">1053             recordComponentVisitor.visitAttribute(attributes);</span>
<span class="line-added">1054             attributes = nextAttribute;</span>
<span class="line-added">1055         }</span>
<span class="line-added">1056 </span>
<span class="line-added">1057         // Visit the end of the field.</span>
<span class="line-added">1058         recordComponentVisitor.visitEnd();</span>
<span class="line-added">1059         return currentOffset;</span>
<span class="line-added">1060     }</span>
<span class="line-added">1061 </span>
1062     /**
1063       * Reads a JVMS field_info structure and makes the given visitor visit it.
1064       *
1065       * @param classVisitor the visitor that must visit the field.
1066       * @param context information about the class being parsed.
1067       * @param fieldInfoOffset the start offset of the field_info structure.
1068       * @return the offset of the first byte following the field_info structure.
1069       */
1070     private int readField(
1071             final ClassVisitor classVisitor, final Context context, final int fieldInfoOffset) {
1072         char[] charBuffer = context.charBuffer;
1073 
1074         // Read the access_flags, name_index and descriptor_index fields.
1075         int currentOffset = fieldInfoOffset;
1076         int accessFlags = readUnsignedShort(currentOffset);
1077         String name = readUTF8(currentOffset + 2, charBuffer);
1078         String descriptor = readUTF8(currentOffset + 4, charBuffer);
1079         currentOffset += 6;
1080 
1081         // Read the field attributes (the variables are ordered as in Section 4.7 of the JVMS).
</pre>
<hr />
<pre>
1357         // Visit the method declaration.
1358         MethodVisitor methodVisitor =
1359                 classVisitor.visitMethod(
1360                         context.currentMethodAccessFlags,
1361                         context.currentMethodName,
1362                         context.currentMethodDescriptor,
1363                         signatureIndex == 0 ? null : readUtf(signatureIndex, charBuffer),
1364                         exceptions);
1365         if (methodVisitor == null) {
1366             return currentOffset;
1367         }
1368 
1369         // If the returned MethodVisitor is in fact a MethodWriter, it means there is no method
1370         // adapter between the reader and the writer. In this case, it might be possible to copy
1371         // the method attributes directly into the writer. If so, return early without visiting
1372         // the content of these attributes.
1373         if (methodVisitor instanceof MethodWriter) {
1374             MethodWriter methodWriter = (MethodWriter) methodVisitor;
1375             if (methodWriter.canCopyMethodAttributes(
1376                     this,


1377                     synthetic,
1378                     (context.currentMethodAccessFlags &amp; Opcodes.ACC_DEPRECATED) != 0,
1379                     readUnsignedShort(methodInfoOffset + 4),
1380                     signatureIndex,
1381                     exceptionsOffset)) {
<span class="line-added">1382                 methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);</span>
1383                 return currentOffset;
1384             }
1385         }
1386 
1387         // Visit the MethodParameters attribute.
<span class="line-modified">1388         if (methodParametersOffset != 0 &amp;&amp; (context.parsingOptions &amp; SKIP_DEBUG) == 0) {</span>
1389             int parametersCount = readByte(methodParametersOffset);
1390             int currentParameterOffset = methodParametersOffset + 1;
1391             while (parametersCount-- &gt; 0) {
1392                 // Read the name_index and access_flags fields and visit them.
1393                 methodVisitor.visitParameter(
1394                         readUTF8(currentParameterOffset, charBuffer),
1395                         readUnsignedShort(currentParameterOffset + 2));
1396                 currentParameterOffset += 4;
1397             }
1398         }
1399 
1400         // Visit the AnnotationDefault attribute.
1401         if (annotationDefaultOffset != 0) {
1402             AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();
1403             readElementValue(annotationVisitor, annotationDefaultOffset, null, charBuffer);
1404             if (annotationVisitor != null) {
1405                 annotationVisitor.visitEnd();
1406             }
1407         }
1408 
</pre>
<hr />
<pre>
1517         // Visit the Code attribute.
1518         if (codeOffset != 0) {
1519             methodVisitor.visitCode();
1520             readCode(methodVisitor, context, codeOffset);
1521         }
1522 
1523         // Visit the end of the method.
1524         methodVisitor.visitEnd();
1525         return currentOffset;
1526     }
1527 
1528     // ----------------------------------------------------------------------------------------------
1529     // Methods to parse a Code attribute
1530     // ----------------------------------------------------------------------------------------------
1531 
1532     /**
1533       * Reads a JVMS &#39;Code&#39; attribute and makes the given visitor visit it.
1534       *
1535       * @param methodVisitor the visitor that must visit the Code attribute.
1536       * @param context information about the class being parsed.
<span class="line-modified">1537       * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding</span>
<span class="line-modified">1538       *     its attribute_name_index and attribute_length fields.</span>
1539       */
1540     private void readCode(
1541             final MethodVisitor methodVisitor, final Context context, final int codeOffset) {
1542         int currentOffset = codeOffset;
1543 
1544         // Read the max_stack, max_locals and code_length fields.
<span class="line-modified">1545         final byte[] classBuffer = classFileBuffer;</span>
1546         final char[] charBuffer = context.charBuffer;
1547         final int maxStack = readUnsignedShort(currentOffset);
1548         final int maxLocals = readUnsignedShort(currentOffset + 2);
1549         final int codeLength = readInt(currentOffset + 4);
1550         currentOffset += 8;
1551 
1552         // Read the bytecode &#39;code&#39; array to create a label for each referenced instruction.
1553         final int bytecodeStartOffset = currentOffset;
1554         final int bytecodeEndOffset = currentOffset + codeLength;
1555         final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];
1556         while (currentOffset &lt; bytecodeEndOffset) {
1557             final int bytecodeOffset = currentOffset - bytecodeStartOffset;
<span class="line-modified">1558             final int opcode = classBuffer[currentOffset] &amp; 0xFF;</span>
1559             switch (opcode) {
<span class="line-modified">1560                 case Opcodes.NOP:</span>
<span class="line-modified">1561                 case Opcodes.ACONST_NULL:</span>
<span class="line-modified">1562                 case Opcodes.ICONST_M1:</span>
<span class="line-modified">1563                 case Opcodes.ICONST_0:</span>
<span class="line-modified">1564                 case Opcodes.ICONST_1:</span>
<span class="line-modified">1565                 case Opcodes.ICONST_2:</span>
<span class="line-modified">1566                 case Opcodes.ICONST_3:</span>
<span class="line-modified">1567                 case Opcodes.ICONST_4:</span>
<span class="line-modified">1568                 case Opcodes.ICONST_5:</span>
<span class="line-modified">1569                 case Opcodes.LCONST_0:</span>
<span class="line-modified">1570                 case Opcodes.LCONST_1:</span>
<span class="line-modified">1571                 case Opcodes.FCONST_0:</span>
<span class="line-modified">1572                 case Opcodes.FCONST_1:</span>
<span class="line-modified">1573                 case Opcodes.FCONST_2:</span>
<span class="line-modified">1574                 case Opcodes.DCONST_0:</span>
<span class="line-modified">1575                 case Opcodes.DCONST_1:</span>
<span class="line-modified">1576                 case Opcodes.IALOAD:</span>
<span class="line-modified">1577                 case Opcodes.LALOAD:</span>
<span class="line-modified">1578                 case Opcodes.FALOAD:</span>
<span class="line-modified">1579                 case Opcodes.DALOAD:</span>
<span class="line-modified">1580                 case Opcodes.AALOAD:</span>
<span class="line-modified">1581                 case Opcodes.BALOAD:</span>
<span class="line-modified">1582                 case Opcodes.CALOAD:</span>
<span class="line-modified">1583                 case Opcodes.SALOAD:</span>
<span class="line-modified">1584                 case Opcodes.IASTORE:</span>
<span class="line-modified">1585                 case Opcodes.LASTORE:</span>
<span class="line-modified">1586                 case Opcodes.FASTORE:</span>
<span class="line-modified">1587                 case Opcodes.DASTORE:</span>
<span class="line-modified">1588                 case Opcodes.AASTORE:</span>
<span class="line-modified">1589                 case Opcodes.BASTORE:</span>
<span class="line-modified">1590                 case Opcodes.CASTORE:</span>
<span class="line-modified">1591                 case Opcodes.SASTORE:</span>
<span class="line-modified">1592                 case Opcodes.POP:</span>
<span class="line-modified">1593                 case Opcodes.POP2:</span>
<span class="line-modified">1594                 case Opcodes.DUP:</span>
<span class="line-modified">1595                 case Opcodes.DUP_X1:</span>
<span class="line-modified">1596                 case Opcodes.DUP_X2:</span>
<span class="line-modified">1597                 case Opcodes.DUP2:</span>
<span class="line-modified">1598                 case Opcodes.DUP2_X1:</span>
<span class="line-modified">1599                 case Opcodes.DUP2_X2:</span>
<span class="line-modified">1600                 case Opcodes.SWAP:</span>
<span class="line-modified">1601                 case Opcodes.IADD:</span>
<span class="line-modified">1602                 case Opcodes.LADD:</span>
<span class="line-modified">1603                 case Opcodes.FADD:</span>
<span class="line-modified">1604                 case Opcodes.DADD:</span>
<span class="line-modified">1605                 case Opcodes.ISUB:</span>
<span class="line-modified">1606                 case Opcodes.LSUB:</span>
<span class="line-modified">1607                 case Opcodes.FSUB:</span>
<span class="line-modified">1608                 case Opcodes.DSUB:</span>
<span class="line-modified">1609                 case Opcodes.IMUL:</span>
<span class="line-modified">1610                 case Opcodes.LMUL:</span>
<span class="line-modified">1611                 case Opcodes.FMUL:</span>
<span class="line-modified">1612                 case Opcodes.DMUL:</span>
<span class="line-modified">1613                 case Opcodes.IDIV:</span>
<span class="line-modified">1614                 case Opcodes.LDIV:</span>
<span class="line-modified">1615                 case Opcodes.FDIV:</span>
<span class="line-modified">1616                 case Opcodes.DDIV:</span>
<span class="line-modified">1617                 case Opcodes.IREM:</span>
<span class="line-modified">1618                 case Opcodes.LREM:</span>
<span class="line-modified">1619                 case Opcodes.FREM:</span>
<span class="line-modified">1620                 case Opcodes.DREM:</span>
<span class="line-modified">1621                 case Opcodes.INEG:</span>
<span class="line-modified">1622                 case Opcodes.LNEG:</span>
<span class="line-modified">1623                 case Opcodes.FNEG:</span>
<span class="line-modified">1624                 case Opcodes.DNEG:</span>
<span class="line-modified">1625                 case Opcodes.ISHL:</span>
<span class="line-modified">1626                 case Opcodes.LSHL:</span>
<span class="line-modified">1627                 case Opcodes.ISHR:</span>
<span class="line-modified">1628                 case Opcodes.LSHR:</span>
<span class="line-modified">1629                 case Opcodes.IUSHR:</span>
<span class="line-modified">1630                 case Opcodes.LUSHR:</span>
<span class="line-modified">1631                 case Opcodes.IAND:</span>
<span class="line-modified">1632                 case Opcodes.LAND:</span>
<span class="line-modified">1633                 case Opcodes.IOR:</span>
<span class="line-modified">1634                 case Opcodes.LOR:</span>
<span class="line-modified">1635                 case Opcodes.IXOR:</span>
<span class="line-modified">1636                 case Opcodes.LXOR:</span>
<span class="line-modified">1637                 case Opcodes.I2L:</span>
<span class="line-modified">1638                 case Opcodes.I2F:</span>
<span class="line-modified">1639                 case Opcodes.I2D:</span>
<span class="line-modified">1640                 case Opcodes.L2I:</span>
<span class="line-modified">1641                 case Opcodes.L2F:</span>
<span class="line-modified">1642                 case Opcodes.L2D:</span>
<span class="line-modified">1643                 case Opcodes.F2I:</span>
<span class="line-modified">1644                 case Opcodes.F2L:</span>
<span class="line-modified">1645                 case Opcodes.F2D:</span>
<span class="line-modified">1646                 case Opcodes.D2I:</span>
<span class="line-modified">1647                 case Opcodes.D2L:</span>
<span class="line-modified">1648                 case Opcodes.D2F:</span>
<span class="line-modified">1649                 case Opcodes.I2B:</span>
<span class="line-modified">1650                 case Opcodes.I2C:</span>
<span class="line-modified">1651                 case Opcodes.I2S:</span>
<span class="line-modified">1652                 case Opcodes.LCMP:</span>
<span class="line-modified">1653                 case Opcodes.FCMPL:</span>
<span class="line-modified">1654                 case Opcodes.FCMPG:</span>
<span class="line-modified">1655                 case Opcodes.DCMPL:</span>
<span class="line-modified">1656                 case Opcodes.DCMPG:</span>
<span class="line-modified">1657                 case Opcodes.IRETURN:</span>
<span class="line-modified">1658                 case Opcodes.LRETURN:</span>
<span class="line-modified">1659                 case Opcodes.FRETURN:</span>
<span class="line-modified">1660                 case Opcodes.DRETURN:</span>
<span class="line-modified">1661                 case Opcodes.ARETURN:</span>
<span class="line-modified">1662                 case Opcodes.RETURN:</span>
<span class="line-modified">1663                 case Opcodes.ARRAYLENGTH:</span>
<span class="line-modified">1664                 case Opcodes.ATHROW:</span>
<span class="line-modified">1665                 case Opcodes.MONITORENTER:</span>
<span class="line-modified">1666                 case Opcodes.MONITOREXIT:</span>
1667                 case Constants.ILOAD_0:
1668                 case Constants.ILOAD_1:
1669                 case Constants.ILOAD_2:
1670                 case Constants.ILOAD_3:
1671                 case Constants.LLOAD_0:
1672                 case Constants.LLOAD_1:
1673                 case Constants.LLOAD_2:
1674                 case Constants.LLOAD_3:
1675                 case Constants.FLOAD_0:
1676                 case Constants.FLOAD_1:
1677                 case Constants.FLOAD_2:
1678                 case Constants.FLOAD_3:
1679                 case Constants.DLOAD_0:
1680                 case Constants.DLOAD_1:
1681                 case Constants.DLOAD_2:
1682                 case Constants.DLOAD_3:
1683                 case Constants.ALOAD_0:
1684                 case Constants.ALOAD_1:
1685                 case Constants.ALOAD_2:
1686                 case Constants.ALOAD_3:
</pre>
<hr />
<pre>
1689                 case Constants.ISTORE_2:
1690                 case Constants.ISTORE_3:
1691                 case Constants.LSTORE_0:
1692                 case Constants.LSTORE_1:
1693                 case Constants.LSTORE_2:
1694                 case Constants.LSTORE_3:
1695                 case Constants.FSTORE_0:
1696                 case Constants.FSTORE_1:
1697                 case Constants.FSTORE_2:
1698                 case Constants.FSTORE_3:
1699                 case Constants.DSTORE_0:
1700                 case Constants.DSTORE_1:
1701                 case Constants.DSTORE_2:
1702                 case Constants.DSTORE_3:
1703                 case Constants.ASTORE_0:
1704                 case Constants.ASTORE_1:
1705                 case Constants.ASTORE_2:
1706                 case Constants.ASTORE_3:
1707                     currentOffset += 1;
1708                     break;
<span class="line-modified">1709                 case Opcodes.IFEQ:</span>
<span class="line-modified">1710                 case Opcodes.IFNE:</span>
<span class="line-modified">1711                 case Opcodes.IFLT:</span>
<span class="line-modified">1712                 case Opcodes.IFGE:</span>
<span class="line-modified">1713                 case Opcodes.IFGT:</span>
<span class="line-modified">1714                 case Opcodes.IFLE:</span>
<span class="line-modified">1715                 case Opcodes.IF_ICMPEQ:</span>
<span class="line-modified">1716                 case Opcodes.IF_ICMPNE:</span>
<span class="line-modified">1717                 case Opcodes.IF_ICMPLT:</span>
<span class="line-modified">1718                 case Opcodes.IF_ICMPGE:</span>
<span class="line-modified">1719                 case Opcodes.IF_ICMPGT:</span>
<span class="line-modified">1720                 case Opcodes.IF_ICMPLE:</span>
<span class="line-modified">1721                 case Opcodes.IF_ACMPEQ:</span>
<span class="line-modified">1722                 case Opcodes.IF_ACMPNE:</span>
<span class="line-modified">1723                 case Opcodes.GOTO:</span>
<span class="line-modified">1724                 case Opcodes.JSR:</span>
<span class="line-modified">1725                 case Opcodes.IFNULL:</span>
<span class="line-modified">1726                 case Opcodes.IFNONNULL:</span>
1727                     createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);
1728                     currentOffset += 3;
1729                     break;
1730                 case Constants.ASM_IFEQ:
1731                 case Constants.ASM_IFNE:
1732                 case Constants.ASM_IFLT:
1733                 case Constants.ASM_IFGE:
1734                 case Constants.ASM_IFGT:
1735                 case Constants.ASM_IFLE:
1736                 case Constants.ASM_IF_ICMPEQ:
1737                 case Constants.ASM_IF_ICMPNE:
1738                 case Constants.ASM_IF_ICMPLT:
1739                 case Constants.ASM_IF_ICMPGE:
1740                 case Constants.ASM_IF_ICMPGT:
1741                 case Constants.ASM_IF_ICMPLE:
1742                 case Constants.ASM_IF_ACMPEQ:
1743                 case Constants.ASM_IF_ACMPNE:
1744                 case Constants.ASM_GOTO:
1745                 case Constants.ASM_JSR:
1746                 case Constants.ASM_IFNULL:
1747                 case Constants.ASM_IFNONNULL:
1748                     createLabel(bytecodeOffset + readUnsignedShort(currentOffset + 1), labels);
1749                     currentOffset += 3;
1750                     break;
1751                 case Constants.GOTO_W:
1752                 case Constants.JSR_W:
1753                 case Constants.ASM_GOTO_W:
1754                     createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);
1755                     currentOffset += 5;
1756                     break;
1757                 case Constants.WIDE:
<span class="line-modified">1758                     switch (classBuffer[currentOffset + 1] &amp; 0xFF) {</span>
<span class="line-modified">1759                         case Opcodes.ILOAD:</span>
<span class="line-modified">1760                         case Opcodes.FLOAD:</span>
<span class="line-modified">1761                         case Opcodes.ALOAD:</span>
<span class="line-modified">1762                         case Opcodes.LLOAD:</span>
<span class="line-modified">1763                         case Opcodes.DLOAD:</span>
<span class="line-modified">1764                         case Opcodes.ISTORE:</span>
<span class="line-modified">1765                         case Opcodes.FSTORE:</span>
<span class="line-modified">1766                         case Opcodes.ASTORE:</span>
<span class="line-modified">1767                         case Opcodes.LSTORE:</span>
<span class="line-modified">1768                         case Opcodes.DSTORE:</span>
<span class="line-modified">1769                         case Opcodes.RET:</span>
1770                             currentOffset += 4;
1771                             break;
<span class="line-modified">1772                         case Opcodes.IINC:</span>
1773                             currentOffset += 6;
1774                             break;
1775                         default:
1776                             throw new IllegalArgumentException();
1777                     }
1778                     break;
<span class="line-modified">1779                 case Opcodes.TABLESWITCH:</span>
1780                     // Skip 0 to 3 padding bytes.
1781                     currentOffset += 4 - (bytecodeOffset &amp; 3);
1782                     // Read the default label and the number of table entries.
1783                     createLabel(bytecodeOffset + readInt(currentOffset), labels);
1784                     int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;
1785                     currentOffset += 12;
1786                     // Read the table labels.
1787                     while (numTableEntries-- &gt; 0) {
1788                         createLabel(bytecodeOffset + readInt(currentOffset), labels);
1789                         currentOffset += 4;
1790                     }
1791                     break;
<span class="line-modified">1792                 case Opcodes.LOOKUPSWITCH:</span>
1793                     // Skip 0 to 3 padding bytes.
1794                     currentOffset += 4 - (bytecodeOffset &amp; 3);
1795                     // Read the default label and the number of switch cases.
1796                     createLabel(bytecodeOffset + readInt(currentOffset), labels);
1797                     int numSwitchCases = readInt(currentOffset + 4);
1798                     currentOffset += 8;
1799                     // Read the switch labels.
1800                     while (numSwitchCases-- &gt; 0) {
1801                         createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);
1802                         currentOffset += 8;
1803                     }
1804                     break;
<span class="line-modified">1805                 case Opcodes.ILOAD:</span>
<span class="line-modified">1806                 case Opcodes.LLOAD:</span>
<span class="line-modified">1807                 case Opcodes.FLOAD:</span>
<span class="line-modified">1808                 case Opcodes.DLOAD:</span>
<span class="line-modified">1809                 case Opcodes.ALOAD:</span>
<span class="line-modified">1810                 case Opcodes.ISTORE:</span>
<span class="line-modified">1811                 case Opcodes.LSTORE:</span>
<span class="line-modified">1812                 case Opcodes.FSTORE:</span>
<span class="line-modified">1813                 case Opcodes.DSTORE:</span>
<span class="line-modified">1814                 case Opcodes.ASTORE:</span>
<span class="line-modified">1815                 case Opcodes.RET:</span>
<span class="line-modified">1816                 case Opcodes.BIPUSH:</span>
<span class="line-modified">1817                 case Opcodes.NEWARRAY:</span>
<span class="line-modified">1818                 case Opcodes.LDC:</span>
1819                     currentOffset += 2;
1820                     break;
<span class="line-modified">1821                 case Opcodes.SIPUSH:</span>
1822                 case Constants.LDC_W:
1823                 case Constants.LDC2_W:
<span class="line-modified">1824                 case Opcodes.GETSTATIC:</span>
<span class="line-modified">1825                 case Opcodes.PUTSTATIC:</span>
<span class="line-modified">1826                 case Opcodes.GETFIELD:</span>
<span class="line-modified">1827                 case Opcodes.PUTFIELD:</span>
<span class="line-modified">1828                 case Opcodes.DEFAULT:</span>
<span class="line-modified">1829                 case Opcodes.WITHFIELD:</span>
<span class="line-modified">1830                 case Opcodes.INVOKEVIRTUAL:</span>
<span class="line-modified">1831                 case Opcodes.INVOKESPECIAL:</span>
<span class="line-modified">1832                 case Opcodes.INVOKESTATIC:</span>
<span class="line-modified">1833                 case Opcodes.NEW:</span>
<span class="line-modified">1834                 case Opcodes.ANEWARRAY:</span>
<span class="line-modified">1835                 case Opcodes.CHECKCAST:</span>
<span class="line-modified">1836                 case Opcodes.INSTANCEOF:</span>
<span class="line-modified">1837                 case Opcodes.IINC:</span>
1838                     currentOffset += 3;
1839                     break;
<span class="line-modified">1840                 case Opcodes.INVOKEINTERFACE:</span>
<span class="line-modified">1841                 case Opcodes.INVOKEDYNAMIC:</span>
1842                     currentOffset += 5;
1843                     break;
<span class="line-modified">1844                 case Opcodes.MULTIANEWARRAY:</span>
1845                     currentOffset += 4;
1846                     break;
1847                 default:
1848                     throw new IllegalArgumentException();
1849             }
1850         }
1851 
1852         // Read the &#39;exception_table_length&#39; and &#39;exception_table&#39; field to create a label for each
1853         // referenced instruction, and to make methodVisitor visit the corresponding try catch blocks.
1854         int exceptionTableLength = readUnsignedShort(currentOffset);
1855         currentOffset += 2;
1856         while (exceptionTableLength-- &gt; 0) {
1857             Label start = createLabel(readUnsignedShort(currentOffset), labels);
1858             Label end = createLabel(readUnsignedShort(currentOffset + 2), labels);
1859             Label handler = createLabel(readUnsignedShort(currentOffset + 4), labels);
1860             String catchType = readUTF8(cpInfoOffsets[readUnsignedShort(currentOffset + 6)], charBuffer);
1861             currentOffset += 8;
1862             methodVisitor.visitTryCatchBlock(start, end, handler, catchType);
1863         }
1864 
</pre>
<hr />
<pre>
1989             // offset_delta. Setting the implicit frame offset to -1 allows us to use of the
1990             // &quot;offset_delta + 1&quot; rule in all cases.
1991             context.currentFrameOffset = -1;
1992             context.currentFrameType = 0;
1993             context.currentFrameLocalCount = 0;
1994             context.currentFrameLocalCountDelta = 0;
1995             context.currentFrameLocalTypes = new Object[maxLocals];
1996             context.currentFrameStackCount = 0;
1997             context.currentFrameStackTypes = new Object[maxStack];
1998             if (expandFrames) {
1999                 computeImplicitFrame(context);
2000             }
2001             // Find the labels for UNINITIALIZED frame types. Instead of decoding each element of the
2002             // stack map table, we look for 3 consecutive bytes that &quot;look like&quot; an UNINITIALIZED type
2003             // (tag ITEM_Uninitialized, offset within bytecode bounds, NEW instruction at this offset).
2004             // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,
2005             // and the only consequence will be the creation of an unneeded label. This is better than
2006             // creating a label for each NEW instruction, and faster than fully decoding the whole stack
2007             // map table.
2008             for (int offset = stackMapFrameOffset; offset &lt; stackMapTableEndOffset - 2; ++offset) {
<span class="line-modified">2009                 if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {</span>
2010                     int potentialBytecodeOffset = readUnsignedShort(offset + 1);
2011                     if (potentialBytecodeOffset &gt;= 0
2012                             &amp;&amp; potentialBytecodeOffset &lt; codeLength
<span class="line-modified">2013                             &amp;&amp; (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] &amp; 0xFF)</span>
2014                                     == Opcodes.NEW) {
2015                         createLabel(potentialBytecodeOffset, labels);
2016                     }
2017                 }
2018             }
2019         }
2020         if (expandFrames &amp;&amp; (context.parsingOptions &amp; EXPAND_ASM_INSNS) != 0) {
2021             // Expanding the ASM specific instructions can introduce F_INSERT frames, even if the method
2022             // does not currently have any frame. These inserted frames must be computed by simulating the
2023             // effect of the bytecode instructions, one by one, starting from the implicit first frame.
2024             // For this, MethodWriter needs to know maxLocals before the first instruction is visited. To
2025             // ensure this, we visit the implicit first frame here (passing only maxLocals - the rest is
2026             // computed in MethodWriter).
2027             methodVisitor.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);
2028         }
2029 
2030         // Visit the bytecode instructions. First, introduce state variables for the incremental parsing
2031         // of the type annotations.
2032 
2033         // Index of the next runtime visible type annotation to read (in the
</pre>
<hr />
<pre>
2089                     insertFrame = false;
2090                 }
2091                 if (stackMapFrameOffset &lt; stackMapTableEndOffset) {
2092                     stackMapFrameOffset =
2093                             readStackMapFrame(stackMapFrameOffset, compressedFrames, expandFrames, context);
2094                 } else {
2095                     stackMapFrameOffset = 0;
2096                 }
2097             }
2098 
2099             // Insert a stack map frame for this bytecode offset, if requested by setting insertFrame to
2100             // true during the previous iteration. The actual frame content is computed in MethodWriter.
2101             if (insertFrame) {
2102                 if ((context.parsingOptions &amp; EXPAND_FRAMES) != 0) {
2103                     methodVisitor.visitFrame(Constants.F_INSERT, 0, null, 0, null);
2104                 }
2105                 insertFrame = false;
2106             }
2107 
2108             // Visit the instruction at this bytecode offset.
<span class="line-modified">2109             int opcode = classBuffer[currentOffset] &amp; 0xFF;</span>
2110             switch (opcode) {
<span class="line-modified">2111                 case Opcodes.NOP:</span>
<span class="line-modified">2112                 case Opcodes.ACONST_NULL:</span>
<span class="line-modified">2113                 case Opcodes.ICONST_M1:</span>
<span class="line-modified">2114                 case Opcodes.ICONST_0:</span>
<span class="line-modified">2115                 case Opcodes.ICONST_1:</span>
<span class="line-modified">2116                 case Opcodes.ICONST_2:</span>
<span class="line-modified">2117                 case Opcodes.ICONST_3:</span>
<span class="line-modified">2118                 case Opcodes.ICONST_4:</span>
<span class="line-modified">2119                 case Opcodes.ICONST_5:</span>
<span class="line-modified">2120                 case Opcodes.LCONST_0:</span>
<span class="line-modified">2121                 case Opcodes.LCONST_1:</span>
<span class="line-modified">2122                 case Opcodes.FCONST_0:</span>
<span class="line-modified">2123                 case Opcodes.FCONST_1:</span>
<span class="line-modified">2124                 case Opcodes.FCONST_2:</span>
<span class="line-modified">2125                 case Opcodes.DCONST_0:</span>
<span class="line-modified">2126                 case Opcodes.DCONST_1:</span>
<span class="line-modified">2127                 case Opcodes.IALOAD:</span>
<span class="line-modified">2128                 case Opcodes.LALOAD:</span>
<span class="line-modified">2129                 case Opcodes.FALOAD:</span>
<span class="line-modified">2130                 case Opcodes.DALOAD:</span>
<span class="line-modified">2131                 case Opcodes.AALOAD:</span>
<span class="line-modified">2132                 case Opcodes.BALOAD:</span>
<span class="line-modified">2133                 case Opcodes.CALOAD:</span>
<span class="line-modified">2134                 case Opcodes.SALOAD:</span>
<span class="line-modified">2135                 case Opcodes.IASTORE:</span>
<span class="line-modified">2136                 case Opcodes.LASTORE:</span>
<span class="line-modified">2137                 case Opcodes.FASTORE:</span>
<span class="line-modified">2138                 case Opcodes.DASTORE:</span>
<span class="line-modified">2139                 case Opcodes.AASTORE:</span>
<span class="line-modified">2140                 case Opcodes.BASTORE:</span>
<span class="line-modified">2141                 case Opcodes.CASTORE:</span>
<span class="line-modified">2142                 case Opcodes.SASTORE:</span>
<span class="line-modified">2143                 case Opcodes.POP:</span>
<span class="line-modified">2144                 case Opcodes.POP2:</span>
<span class="line-modified">2145                 case Opcodes.DUP:</span>
<span class="line-modified">2146                 case Opcodes.DUP_X1:</span>
<span class="line-modified">2147                 case Opcodes.DUP_X2:</span>
<span class="line-modified">2148                 case Opcodes.DUP2:</span>
<span class="line-modified">2149                 case Opcodes.DUP2_X1:</span>
<span class="line-modified">2150                 case Opcodes.DUP2_X2:</span>
<span class="line-modified">2151                 case Opcodes.SWAP:</span>
<span class="line-modified">2152                 case Opcodes.IADD:</span>
<span class="line-modified">2153                 case Opcodes.LADD:</span>
<span class="line-modified">2154                 case Opcodes.FADD:</span>
<span class="line-modified">2155                 case Opcodes.DADD:</span>
<span class="line-modified">2156                 case Opcodes.ISUB:</span>
<span class="line-modified">2157                 case Opcodes.LSUB:</span>
<span class="line-modified">2158                 case Opcodes.FSUB:</span>
<span class="line-modified">2159                 case Opcodes.DSUB:</span>
<span class="line-modified">2160                 case Opcodes.IMUL:</span>
<span class="line-modified">2161                 case Opcodes.LMUL:</span>
<span class="line-modified">2162                 case Opcodes.FMUL:</span>
<span class="line-modified">2163                 case Opcodes.DMUL:</span>
<span class="line-modified">2164                 case Opcodes.IDIV:</span>
<span class="line-modified">2165                 case Opcodes.LDIV:</span>
<span class="line-modified">2166                 case Opcodes.FDIV:</span>
<span class="line-modified">2167                 case Opcodes.DDIV:</span>
<span class="line-modified">2168                 case Opcodes.IREM:</span>
<span class="line-modified">2169                 case Opcodes.LREM:</span>
<span class="line-modified">2170                 case Opcodes.FREM:</span>
<span class="line-modified">2171                 case Opcodes.DREM:</span>
<span class="line-modified">2172                 case Opcodes.INEG:</span>
<span class="line-modified">2173                 case Opcodes.LNEG:</span>
<span class="line-modified">2174                 case Opcodes.FNEG:</span>
<span class="line-modified">2175                 case Opcodes.DNEG:</span>
<span class="line-modified">2176                 case Opcodes.ISHL:</span>
<span class="line-modified">2177                 case Opcodes.LSHL:</span>
<span class="line-modified">2178                 case Opcodes.ISHR:</span>
<span class="line-modified">2179                 case Opcodes.LSHR:</span>
<span class="line-modified">2180                 case Opcodes.IUSHR:</span>
<span class="line-modified">2181                 case Opcodes.LUSHR:</span>
<span class="line-modified">2182                 case Opcodes.IAND:</span>
<span class="line-modified">2183                 case Opcodes.LAND:</span>
<span class="line-modified">2184                 case Opcodes.IOR:</span>
<span class="line-modified">2185                 case Opcodes.LOR:</span>
<span class="line-modified">2186                 case Opcodes.IXOR:</span>
<span class="line-modified">2187                 case Opcodes.LXOR:</span>
<span class="line-modified">2188                 case Opcodes.I2L:</span>
<span class="line-modified">2189                 case Opcodes.I2F:</span>
<span class="line-modified">2190                 case Opcodes.I2D:</span>
<span class="line-modified">2191                 case Opcodes.L2I:</span>
<span class="line-modified">2192                 case Opcodes.L2F:</span>
<span class="line-modified">2193                 case Opcodes.L2D:</span>
<span class="line-modified">2194                 case Opcodes.F2I:</span>
<span class="line-modified">2195                 case Opcodes.F2L:</span>
<span class="line-modified">2196                 case Opcodes.F2D:</span>
<span class="line-modified">2197                 case Opcodes.D2I:</span>
<span class="line-modified">2198                 case Opcodes.D2L:</span>
<span class="line-modified">2199                 case Opcodes.D2F:</span>
<span class="line-modified">2200                 case Opcodes.I2B:</span>
<span class="line-modified">2201                 case Opcodes.I2C:</span>
<span class="line-modified">2202                 case Opcodes.I2S:</span>
<span class="line-modified">2203                 case Opcodes.LCMP:</span>
<span class="line-modified">2204                 case Opcodes.FCMPL:</span>
<span class="line-modified">2205                 case Opcodes.FCMPG:</span>
<span class="line-modified">2206                 case Opcodes.DCMPL:</span>
<span class="line-modified">2207                 case Opcodes.DCMPG:</span>
<span class="line-modified">2208                 case Opcodes.IRETURN:</span>
<span class="line-modified">2209                 case Opcodes.LRETURN:</span>
<span class="line-modified">2210                 case Opcodes.FRETURN:</span>
<span class="line-modified">2211                 case Opcodes.DRETURN:</span>
<span class="line-modified">2212                 case Opcodes.ARETURN:</span>
<span class="line-modified">2213                 case Opcodes.RETURN:</span>
<span class="line-modified">2214                 case Opcodes.ARRAYLENGTH:</span>
<span class="line-modified">2215                 case Opcodes.ATHROW:</span>
<span class="line-modified">2216                 case Opcodes.MONITORENTER:</span>
<span class="line-modified">2217                 case Opcodes.MONITOREXIT:</span>
2218                     methodVisitor.visitInsn(opcode);
2219                     currentOffset += 1;
2220                     break;
2221                 case Constants.ILOAD_0:
2222                 case Constants.ILOAD_1:
2223                 case Constants.ILOAD_2:
2224                 case Constants.ILOAD_3:
2225                 case Constants.LLOAD_0:
2226                 case Constants.LLOAD_1:
2227                 case Constants.LLOAD_2:
2228                 case Constants.LLOAD_3:
2229                 case Constants.FLOAD_0:
2230                 case Constants.FLOAD_1:
2231                 case Constants.FLOAD_2:
2232                 case Constants.FLOAD_3:
2233                 case Constants.DLOAD_0:
2234                 case Constants.DLOAD_1:
2235                 case Constants.DLOAD_2:
2236                 case Constants.DLOAD_3:
2237                 case Constants.ALOAD_0:
</pre>
<hr />
<pre>
2249                 case Constants.LSTORE_0:
2250                 case Constants.LSTORE_1:
2251                 case Constants.LSTORE_2:
2252                 case Constants.LSTORE_3:
2253                 case Constants.FSTORE_0:
2254                 case Constants.FSTORE_1:
2255                 case Constants.FSTORE_2:
2256                 case Constants.FSTORE_3:
2257                 case Constants.DSTORE_0:
2258                 case Constants.DSTORE_1:
2259                 case Constants.DSTORE_2:
2260                 case Constants.DSTORE_3:
2261                 case Constants.ASTORE_0:
2262                 case Constants.ASTORE_1:
2263                 case Constants.ASTORE_2:
2264                 case Constants.ASTORE_3:
2265                     opcode -= Constants.ISTORE_0;
2266                     methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode &gt;&gt; 2), opcode &amp; 0x3);
2267                     currentOffset += 1;
2268                     break;
<span class="line-modified">2269                 case Opcodes.IFEQ:</span>
<span class="line-modified">2270                 case Opcodes.IFNE:</span>
<span class="line-modified">2271                 case Opcodes.IFLT:</span>
<span class="line-modified">2272                 case Opcodes.IFGE:</span>
<span class="line-modified">2273                 case Opcodes.IFGT:</span>
<span class="line-modified">2274                 case Opcodes.IFLE:</span>
<span class="line-modified">2275                 case Opcodes.IF_ICMPEQ:</span>
<span class="line-modified">2276                 case Opcodes.IF_ICMPNE:</span>
<span class="line-modified">2277                 case Opcodes.IF_ICMPLT:</span>
<span class="line-modified">2278                 case Opcodes.IF_ICMPGE:</span>
<span class="line-modified">2279                 case Opcodes.IF_ICMPGT:</span>
<span class="line-modified">2280                 case Opcodes.IF_ICMPLE:</span>
<span class="line-modified">2281                 case Opcodes.IF_ACMPEQ:</span>
<span class="line-modified">2282                 case Opcodes.IF_ACMPNE:</span>
<span class="line-modified">2283                 case Opcodes.GOTO:</span>
<span class="line-modified">2284                 case Opcodes.JSR:</span>
<span class="line-modified">2285                 case Opcodes.IFNULL:</span>
<span class="line-modified">2286                 case Opcodes.IFNONNULL:</span>
2287                     methodVisitor.visitJumpInsn(
2288                             opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);
2289                     currentOffset += 3;
2290                     break;
2291                 case Constants.GOTO_W:
2292                 case Constants.JSR_W:
2293                     methodVisitor.visitJumpInsn(
2294                             opcode - wideJumpOpcodeDelta,
2295                             labels[currentBytecodeOffset + readInt(currentOffset + 1)]);
2296                     currentOffset += 5;
2297                     break;
2298                 case Constants.ASM_IFEQ:
2299                 case Constants.ASM_IFNE:
2300                 case Constants.ASM_IFLT:
2301                 case Constants.ASM_IFGE:
2302                 case Constants.ASM_IFGT:
2303                 case Constants.ASM_IFLE:
2304                 case Constants.ASM_IF_ICMPEQ:
2305                 case Constants.ASM_IF_ICMPNE:
2306                 case Constants.ASM_IF_ICMPLT:
</pre>
<hr />
<pre>
2327                         Label target = labels[currentBytecodeOffset + readUnsignedShort(currentOffset + 1)];
2328                         if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {
2329                             // Replace GOTO with GOTO_W and JSR with JSR_W.
2330                             methodVisitor.visitJumpInsn(opcode + Constants.WIDE_JUMP_OPCODE_DELTA, target);
2331                         } else {
2332                             // Compute the &quot;opposite&quot; of opcode. This can be done by flipping the least
2333                             // significant bit for IFNULL and IFNONNULL, and similarly for IFEQ ... IF_ACMPEQ
2334                             // (with a pre and post offset by 1).
2335                             opcode = opcode &lt; Opcodes.GOTO ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;
2336                             Label endif = createLabel(currentBytecodeOffset + 3, labels);
2337                             methodVisitor.visitJumpInsn(opcode, endif);
2338                             methodVisitor.visitJumpInsn(Constants.GOTO_W, target);
2339                             // endif designates the instruction just after GOTO_W, and is visited as part of the
2340                             // next instruction. Since it is a jump target, we need to insert a frame here.
2341                             insertFrame = true;
2342                         }
2343                         currentOffset += 3;
2344                         break;
2345                     }
2346                 case Constants.ASM_GOTO_W:
<span class="line-modified">2347                     // Replace ASM_GOTO_W with GOTO_W.</span>
<span class="line-modified">2348                     methodVisitor.visitJumpInsn(</span>
<span class="line-modified">2349                             Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);</span>
<span class="line-modified">2350                     // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns</span>
<span class="line-modified">2351                     // IFNOTxxx &lt;L&gt; ASM_GOTO_W &lt;l&gt; L:..., see MethodWriter), so we need to insert a frame</span>
<span class="line-modified">2352                     // here.</span>
<span class="line-modified">2353                     insertFrame = true;</span>
<span class="line-modified">2354                     currentOffset += 5;</span>
<span class="line-modified">2355                     break;</span>


2356                 case Constants.WIDE:
<span class="line-modified">2357                     opcode = classBuffer[currentOffset + 1] &amp; 0xFF;</span>
2358                     if (opcode == Opcodes.IINC) {
2359                         methodVisitor.visitIincInsn(
2360                                 readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));
2361                         currentOffset += 6;
2362                     } else {
2363                         methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));
2364                         currentOffset += 4;
2365                     }
2366                     break;
<span class="line-modified">2367                 case Opcodes.TABLESWITCH:</span>
2368                     {
2369                         // Skip 0 to 3 padding bytes.
2370                         currentOffset += 4 - (currentBytecodeOffset &amp; 3);
2371                         // Read the instruction.
2372                         Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
2373                         int low = readInt(currentOffset + 4);
2374                         int high = readInt(currentOffset + 8);
2375                         currentOffset += 12;
2376                         Label[] table = new Label[high - low + 1];
2377                         for (int i = 0; i &lt; table.length; ++i) {
2378                             table[i] = labels[currentBytecodeOffset + readInt(currentOffset)];
2379                             currentOffset += 4;
2380                         }
2381                         methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);
2382                         break;
2383                     }
<span class="line-modified">2384                 case Opcodes.LOOKUPSWITCH:</span>
2385                     {
2386                         // Skip 0 to 3 padding bytes.
2387                         currentOffset += 4 - (currentBytecodeOffset &amp; 3);
2388                         // Read the instruction.
2389                         Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
2390                         int numPairs = readInt(currentOffset + 4);
2391                         currentOffset += 8;
2392                         int[] keys = new int[numPairs];
2393                         Label[] values = new Label[numPairs];
2394                         for (int i = 0; i &lt; numPairs; ++i) {
2395                             keys[i] = readInt(currentOffset);
2396                             values[i] = labels[currentBytecodeOffset + readInt(currentOffset + 4)];
2397                             currentOffset += 8;
2398                         }
2399                         methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);
2400                         break;
2401                     }
<span class="line-modified">2402                 case Opcodes.ILOAD:</span>
<span class="line-modified">2403                 case Opcodes.LLOAD:</span>
<span class="line-modified">2404                 case Opcodes.FLOAD:</span>
<span class="line-modified">2405                 case Opcodes.DLOAD:</span>
<span class="line-modified">2406                 case Opcodes.ALOAD:</span>
<span class="line-modified">2407                 case Opcodes.ISTORE:</span>
<span class="line-modified">2408                 case Opcodes.LSTORE:</span>
<span class="line-modified">2409                 case Opcodes.FSTORE:</span>
<span class="line-modified">2410                 case Opcodes.DSTORE:</span>
<span class="line-modified">2411                 case Opcodes.ASTORE:</span>
<span class="line-modified">2412                 case Opcodes.RET:</span>
<span class="line-modified">2413                     methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] &amp; 0xFF);</span>
2414                     currentOffset += 2;
2415                     break;
<span class="line-modified">2416                 case Opcodes.BIPUSH:</span>
<span class="line-modified">2417                 case Opcodes.NEWARRAY:</span>
<span class="line-modified">2418                     methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);</span>
2419                     currentOffset += 2;
2420                     break;
<span class="line-modified">2421                 case Opcodes.SIPUSH:</span>
2422                     methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));
2423                     currentOffset += 3;
2424                     break;
<span class="line-modified">2425                 case Opcodes.LDC:</span>
<span class="line-modified">2426                     methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] &amp; 0xFF, charBuffer));</span>

2427                     currentOffset += 2;
2428                     break;
2429                 case Constants.LDC_W:
2430                 case Constants.LDC2_W:
2431                     methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));
2432                     currentOffset += 3;
2433                     break;
<span class="line-modified">2434                 case Opcodes.GETSTATIC:</span>
<span class="line-modified">2435                 case Opcodes.PUTSTATIC:</span>
<span class="line-modified">2436                 case Opcodes.GETFIELD:</span>
<span class="line-modified">2437                 case Opcodes.PUTFIELD:</span>
<span class="line-modified">2438                 case Opcodes.INVOKEVIRTUAL:</span>
<span class="line-modified">2439                 case Opcodes.INVOKESPECIAL:</span>
<span class="line-modified">2440                 case Opcodes.INVOKESTATIC:</span>
<span class="line-modified">2441                 case Opcodes.INVOKEINTERFACE:</span>
<span class="line-modified">2442                 case Opcodes.WITHFIELD:</span>
2443                     {
2444                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
2445                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
2446                         String owner = readClass(cpInfoOffset, charBuffer);
2447                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
2448                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
2449                         if (opcode &gt;= Opcodes.INVOKEVIRTUAL &amp;&amp; opcode &lt;= Opcodes.INVOKEINTERFACE) {
2450                             boolean isInterface =
<span class="line-modified">2451                                     classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;</span>
2452                             methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
2453                         } else {
2454                             methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);
2455                         }
2456                         if (opcode == Opcodes.INVOKEINTERFACE) {
2457                             currentOffset += 5;
2458                         } else {
2459                             currentOffset += 3;
2460                         }
2461                         break;
2462                     }
<span class="line-modified">2463                 case Opcodes.INVOKEDYNAMIC:</span>
2464                     {
2465                         int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
2466                         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
2467                         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
2468                         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
2469                         int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];
2470                         Handle handle =
2471                                 (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
2472                         Object[] bootstrapMethodArguments =
2473                                 new Object[readUnsignedShort(bootstrapMethodOffset + 2)];
2474                         bootstrapMethodOffset += 4;
2475                         for (int i = 0; i &lt; bootstrapMethodArguments.length; i++) {
2476                             bootstrapMethodArguments[i] =
2477                                     readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
2478                             bootstrapMethodOffset += 2;
2479                         }
2480                         methodVisitor.visitInvokeDynamicInsn(
2481                                 name, descriptor, handle, bootstrapMethodArguments);
2482                         currentOffset += 5;
2483                         break;
2484                     }
<span class="line-modified">2485                 case Opcodes.NEW:</span>
<span class="line-modified">2486                 case Opcodes.ANEWARRAY:</span>
<span class="line-modified">2487                 case Opcodes.CHECKCAST:</span>
<span class="line-modified">2488                 case Opcodes.INSTANCEOF:</span>
<span class="line-modified">2489                 case Opcodes.DEFAULT:</span>
2490                     methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));
2491                     currentOffset += 3;
2492                     break;
<span class="line-modified">2493                 case Opcodes.IINC:</span>
2494                     methodVisitor.visitIincInsn(
<span class="line-modified">2495                             classBuffer[currentOffset + 1] &amp; 0xFF, classBuffer[currentOffset + 2]);</span>
2496                     currentOffset += 3;
2497                     break;
<span class="line-modified">2498                 case Opcodes.MULTIANEWARRAY:</span>
2499                     methodVisitor.visitMultiANewArrayInsn(
<span class="line-modified">2500                             readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] &amp; 0xFF);</span>
2501                     currentOffset += 4;
2502                     break;
2503                 default:
2504                     throw new AssertionError();
2505             }
2506 
2507             // Visit the runtime visible instruction annotations, if any.
2508             while (visibleTypeAnnotationOffsets != null
2509                     &amp;&amp; currentVisibleTypeAnnotationIndex &lt; visibleTypeAnnotationOffsets.length
2510                     &amp;&amp; currentVisibleTypeAnnotationBytecodeOffset &lt;= currentBytecodeOffset) {
2511                 if (currentVisibleTypeAnnotationBytecodeOffset == currentBytecodeOffset) {
2512                     // Parse the target_type, target_info and target_path fields.
2513                     int currentAnnotationOffset =
2514                             readTypeAnnotationTarget(
2515                                     context, visibleTypeAnnotationOffsets[currentVisibleTypeAnnotationIndex]);
2516                     // Parse the type_index field.
2517                     String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);
2518                     currentAnnotationOffset += 2;
2519                     // Parse num_element_value_pairs and element_value_pairs and visit these values.
2520                     readElementValues(
</pre>
<hr />
<pre>
2784                 case TypeReference.NEW:
2785                 case TypeReference.CONSTRUCTOR_REFERENCE:
2786                 case TypeReference.METHOD_REFERENCE:
2787                     currentOffset += 3;
2788                     break;
2789                 case TypeReference.CLASS_TYPE_PARAMETER:
2790                 case TypeReference.METHOD_TYPE_PARAMETER:
2791                 case TypeReference.METHOD_FORMAL_PARAMETER:
2792                 case TypeReference.FIELD:
2793                 case TypeReference.METHOD_RETURN:
2794                 case TypeReference.METHOD_RECEIVER:
2795                 default:
2796                     // TypeReference type which can&#39;t be used in Code attribute, or which is unknown.
2797                     throw new IllegalArgumentException();
2798             }
2799             // Parse the rest of the type_annotation structure, starting with the target_path structure
2800             // (whose size depends on its path_length field).
2801             int pathLength = readByte(currentOffset);
2802             if ((targetType &gt;&gt;&gt; 24) == TypeReference.EXCEPTION_PARAMETER) {
2803                 // Parse the target_path structure and create a corresponding TypePath.
<span class="line-modified">2804                 TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);</span>
2805                 currentOffset += 1 + 2 * pathLength;
2806                 // Parse the type_index field.
2807                 String annotationDescriptor = readUTF8(currentOffset, charBuffer);
2808                 currentOffset += 2;
2809                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
2810                 currentOffset =
2811                         readElementValues(
2812                                 methodVisitor.visitTryCatchAnnotation(
2813                                         targetType &amp; 0xFFFFFF00, path, annotationDescriptor, visible),
2814                                 currentOffset,
2815                                 /* named = */ true,
2816                                 charBuffer);
2817             } else {
2818                 // We don&#39;t want to visit the other target_type annotations, so we just skip them (which
2819                 // requires some parsing because the element_value_pairs array has a variable size). First,
2820                 // skip the target_path structure:
2821                 currentOffset += 3 + 2 * pathLength;
2822                 // Then skip the num_element_value_pairs and element_value_pairs fields (by reading them
2823                 // with a null AnnotationVisitor).
2824                 currentOffset =
2825                         readElementValues(
2826                                 /* annotationVisitor = */ null, currentOffset, /* named = */ true, charBuffer);
2827             }
2828         }
2829         return typeAnnotationsOffsets;
2830     }
2831 
2832     /**
2833       * Returns the bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or
2834       * -1 if there is no such type_annotation of if it does not have a bytecode offset.
2835       *
2836       * @param typeAnnotationOffsets the offset of each &#39;type_annotation&#39; entry in a
<span class="line-modified">2837       *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.</span>
2838       * @param typeAnnotationIndex the index a &#39;type_annotation&#39; entry in typeAnnotationOffsets.
2839       * @return bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or -1
2840       *     if there is no such type_annotation of if it does not have a bytecode offset.
2841       */
2842     private int getTypeAnnotationBytecodeOffset(
2843             final int[] typeAnnotationOffsets, final int typeAnnotationIndex) {
2844         if (typeAnnotationOffsets == null
2845                 || typeAnnotationIndex &gt;= typeAnnotationOffsets.length
2846                 || readByte(typeAnnotationOffsets[typeAnnotationIndex]) &lt; TypeReference.INSTANCEOF) {
2847             return -1;
2848         }
2849         return readUnsignedShort(typeAnnotationOffsets[typeAnnotationIndex] + 1);
2850     }
2851 
2852     /**
2853       * Parses the header of a JVMS type_annotation structure to extract its target_type, target_info
2854       * and target_path (the result is stored in the given context), and returns the start offset of
2855       * the rest of the type_annotation structure.
2856       *
2857       * @param context information about the class being parsed. This is where the extracted
</pre>
<hr />
<pre>
2909             case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
2910             case TypeReference.THROWS:
2911             case TypeReference.EXCEPTION_PARAMETER:
2912                 targetType &amp;= 0xFFFFFF00;
2913                 currentOffset += 3;
2914                 break;
2915             case TypeReference.INSTANCEOF:
2916             case TypeReference.NEW:
2917             case TypeReference.CONSTRUCTOR_REFERENCE:
2918             case TypeReference.METHOD_REFERENCE:
2919                 targetType &amp;= 0xFF000000;
2920                 currentOffset += 3;
2921                 break;
2922             default:
2923                 throw new IllegalArgumentException();
2924         }
2925         context.currentTypeAnnotationTarget = targetType;
2926         // Parse and store the target_path structure.
2927         int pathLength = readByte(currentOffset);
2928         context.currentTypeAnnotationTargetPath =
<span class="line-modified">2929                 pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);</span>
2930         // Return the start offset of the rest of the type_annotation structure.
2931         return currentOffset + 1 + 2 * pathLength;
2932     }
2933 
2934     /**
2935       * Reads a Runtime[In]VisibleParameterAnnotations attribute and makes the given visitor visit it.
2936       *
2937       * @param methodVisitor the visitor that must visit the parameter annotations.
2938       * @param context information about the class being parsed.
2939       * @param runtimeParameterAnnotationsOffset the start offset of a
2940       *     Runtime[In]VisibleParameterAnnotations attribute, excluding the attribute_info&#39;s
2941       *     attribute_name_index and attribute_length fields.
2942       * @param visible true if the attribute to parse is a RuntimeVisibleParameterAnnotations
2943       *     attribute, false it is a RuntimeInvisibleParameterAnnotations attribute.
2944       */
2945     private void readParameterAnnotations(
2946             final MethodVisitor methodVisitor,
2947             final Context context,
2948             final int runtimeParameterAnnotationsOffset,
2949             final boolean visible) {
2950         int currentOffset = runtimeParameterAnnotationsOffset;
<span class="line-modified">2951         int numParameters = classFileBuffer[currentOffset++] &amp; 0xFF;</span>
2952         methodVisitor.visitAnnotableParameterCount(numParameters, visible);
2953         char[] charBuffer = context.charBuffer;
2954         for (int i = 0; i &lt; numParameters; ++i) {
2955             int numAnnotations = readUnsignedShort(currentOffset);
2956             currentOffset += 2;
2957             while (numAnnotations-- &gt; 0) {
2958                 // Parse the type_index field.
2959                 String annotationDescriptor = readUTF8(currentOffset, charBuffer);
2960                 currentOffset += 2;
2961                 // Parse num_element_value_pairs and element_value_pairs and visit these values.
2962                 currentOffset =
2963                         readElementValues(
2964                                 methodVisitor.visitParameterAnnotation(i, annotationDescriptor, visible),
2965                                 currentOffset,
2966                                 /* named = */ true,
2967                                 charBuffer);
2968             }
2969         }
2970     }
2971 
</pre>
<hr />
<pre>
2999                 currentOffset =
3000                         readElementValue(annotationVisitor, currentOffset + 2, elementName, charBuffer);
3001             }
3002         } else {
3003             // Parse the array_value array.
3004             while (numElementValuePairs-- &gt; 0) {
3005                 currentOffset =
3006                         readElementValue(annotationVisitor, currentOffset, /* named = */ null, charBuffer);
3007             }
3008         }
3009         if (annotationVisitor != null) {
3010             annotationVisitor.visitEnd();
3011         }
3012         return currentOffset;
3013     }
3014 
3015     /**
3016       * Reads a JVMS &#39;element_value&#39; structure and makes the given visitor visit it.
3017       *
3018       * @param annotationVisitor the visitor that must visit the element_value structure.
<span class="line-modified">3019       * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value</span>
<span class="line-modified">3020       *     structure to be read.</span>
3021       * @param elementName the name of the element_value structure to be read, or {@literal null}.
3022       * @param charBuffer the buffer used to read strings in the constant pool.
3023       * @return the end offset of the JVMS &#39;element_value&#39; structure.
3024       */
3025     private int readElementValue(
3026             final AnnotationVisitor annotationVisitor,
3027             final int elementValueOffset,
3028             final String elementName,
3029             final char[] charBuffer) {
3030         int currentOffset = elementValueOffset;
3031         if (annotationVisitor == null) {
<span class="line-modified">3032             switch (classFileBuffer[currentOffset] &amp; 0xFF) {</span>
3033                 case &#39;e&#39;: // enum_const_value
3034                     return currentOffset + 5;
3035                 case &#39;@&#39;: // annotation_value
3036                     return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);
3037                 case &#39;[&#39;: // array_value
3038                     return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);
3039                 default:
3040                     return currentOffset + 3;
3041             }
3042         }
<span class="line-modified">3043         switch (classFileBuffer[currentOffset++] &amp; 0xFF) {</span>
3044             case &#39;B&#39;: // const_value_index, CONSTANT_Integer
3045                 annotationVisitor.visit(
3046                         elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
3047                 currentOffset += 2;
3048                 break;
3049             case &#39;C&#39;: // const_value_index, CONSTANT_Integer
3050                 annotationVisitor.visit(
3051                         elementName, (char) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
3052                 currentOffset += 2;
3053                 break;
3054             case &#39;D&#39;: // const_value_index, CONSTANT_Double
3055             case &#39;F&#39;: // const_value_index, CONSTANT_Float
3056             case &#39;I&#39;: // const_value_index, CONSTANT_Integer
3057             case &#39;J&#39;: // const_value_index, CONSTANT_Long
3058                 annotationVisitor.visit(
3059                         elementName, readConst(readUnsignedShort(currentOffset), charBuffer));
3060                 currentOffset += 2;
3061                 break;
3062             case &#39;S&#39;: // const_value_index, CONSTANT_Integer
3063                 annotationVisitor.visit(
</pre>
<hr />
<pre>
3089                 currentOffset += 2;
3090                 break;
3091             case &#39;@&#39;: // annotation_value
3092                 currentOffset =
3093                         readElementValues(
3094                                 annotationVisitor.visitAnnotation(elementName, readUTF8(currentOffset, charBuffer)),
3095                                 currentOffset + 2,
3096                                 true,
3097                                 charBuffer);
3098                 break;
3099             case &#39;[&#39;: // array_value
3100                 int numValues = readUnsignedShort(currentOffset);
3101                 currentOffset += 2;
3102                 if (numValues == 0) {
3103                     return readElementValues(
3104                             annotationVisitor.visitArray(elementName),
3105                             currentOffset - 2,
3106                             /* named = */ false,
3107                             charBuffer);
3108                 }
<span class="line-modified">3109                 switch (classFileBuffer[currentOffset] &amp; 0xFF) {</span>
3110                     case &#39;B&#39;:
3111                         byte[] byteValues = new byte[numValues];
3112                         for (int i = 0; i &lt; numValues; i++) {
3113                             byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
3114                             currentOffset += 3;
3115                         }
3116                         annotationVisitor.visit(elementName, byteValues);
3117                         break;
3118                     case &#39;Z&#39;:
3119                         boolean[] booleanValues = new boolean[numValues];
3120                         for (int i = 0; i &lt; numValues; i++) {
3121                             booleanValues[i] = readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]) != 0;
3122                             currentOffset += 3;
3123                         }
3124                         annotationVisitor.visit(elementName, booleanValues);
3125                         break;
3126                     case &#39;S&#39;:
3127                         short[] shortValues = new short[numValues];
3128                         for (int i = 0; i &lt; numValues; i++) {
3129                             shortValues[i] = (short) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
</pre>
<hr />
<pre>
3252                 case &#39;L&#39;:
3253                     while (methodDescriptor.charAt(currentMethodDescritorOffset) != &#39;;&#39;) {
3254                         ++currentMethodDescritorOffset;
3255                     }
3256                     locals[numLocal++] =
3257                             methodDescriptor.substring(
3258                                     currentArgumentDescriptorStartOffset + 1, currentMethodDescritorOffset++);
3259                     break;
3260                 default:
3261                     context.currentFrameLocalCount = numLocal;
3262                     return;
3263             }
3264         }
3265     }
3266 
3267     /**
3268       * Reads a JVMS &#39;stack_map_frame&#39; structure and stores the result in the given {@link Context}
3269       * object. This method can also be used to read a full_frame structure, excluding its frame_type
3270       * field (this is used to parse the legacy StackMap attributes).
3271       *
<span class="line-modified">3272       * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the</span>
<span class="line-modified">3273       *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure</span>
<span class="line-modified">3274       *     (excluding its frame_type field).</span>
3275       * @param compressed true to read a &#39;stack_map_frame&#39; structure, false to read a &#39;full_frame&#39;
3276       *     structure without its frame_type field.
3277       * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.
3278       * @param context where the parsed stack map frame must be stored.
3279       * @return the end offset of the JVMS &#39;stack_map_frame&#39; or &#39;full_frame&#39; structure.
3280       */
3281     private int readStackMapFrame(
3282             final int stackMapFrameOffset,
3283             final boolean compressed,
3284             final boolean expand,
3285             final Context context) {
3286         int currentOffset = stackMapFrameOffset;
3287         final char[] charBuffer = context.charBuffer;
3288         final Label[] labels = context.currentMethodLabels;
3289         int frameType;
3290         if (compressed) {
3291             // Read the frame_type field.
<span class="line-modified">3292             frameType = classFileBuffer[currentOffset++] &amp; 0xFF;</span>
3293         } else {
3294             frameType = Frame.FULL_FRAME;
3295             context.currentFrameOffset = -1;
3296         }
3297         int offsetDelta;
3298         context.currentFrameLocalCountDelta = 0;
3299         if (frameType &lt; Frame.SAME_LOCALS_1_STACK_ITEM_FRAME) {
3300             offsetDelta = frameType;
3301             context.currentFrameType = Opcodes.F_SAME;
3302             context.currentFrameStackCount = 0;
3303         } else if (frameType &lt; Frame.RESERVED) {
3304             offsetDelta = frameType - Frame.SAME_LOCALS_1_STACK_ITEM_FRAME;
3305             currentOffset =
3306                     readVerificationTypeInfo(
3307                             currentOffset, context.currentFrameStackTypes, 0, charBuffer, labels);
3308             context.currentFrameType = Opcodes.F_SAME1;
3309             context.currentFrameStackCount = 1;
3310         } else if (frameType &gt;= Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
3311             offsetDelta = readUnsignedShort(currentOffset);
3312             currentOffset += 2;
</pre>
<hr />
<pre>
3367       * Reads a JVMS &#39;verification_type_info&#39; structure and stores it at the given index in the given
3368       * array.
3369       *
3370       * @param verificationTypeInfoOffset the start offset of the &#39;verification_type_info&#39; structure to
3371       *     read.
3372       * @param frame the array where the parsed type must be stored.
3373       * @param index the index in &#39;frame&#39; where the parsed type must be stored.
3374       * @param charBuffer the buffer used to read strings in the constant pool.
3375       * @param labels the labels of the method currently being parsed, indexed by their offset. If the
3376       *     parsed type is an ITEM_Uninitialized, a new label for the corresponding NEW instruction is
3377       *     stored in this array if it does not already exist.
3378       * @return the end offset of the JVMS &#39;verification_type_info&#39; structure.
3379       */
3380     private int readVerificationTypeInfo(
3381             final int verificationTypeInfoOffset,
3382             final Object[] frame,
3383             final int index,
3384             final char[] charBuffer,
3385             final Label[] labels) {
3386         int currentOffset = verificationTypeInfoOffset;
<span class="line-modified">3387         int tag = classFileBuffer[currentOffset++] &amp; 0xFF;</span>
3388         switch (tag) {
3389             case Frame.ITEM_TOP:
3390                 frame[index] = Opcodes.TOP;
3391                 break;
3392             case Frame.ITEM_INTEGER:
3393                 frame[index] = Opcodes.INTEGER;
3394                 break;
3395             case Frame.ITEM_FLOAT:
3396                 frame[index] = Opcodes.FLOAT;
3397                 break;
3398             case Frame.ITEM_DOUBLE:
3399                 frame[index] = Opcodes.DOUBLE;
3400                 break;
3401             case Frame.ITEM_LONG:
3402                 frame[index] = Opcodes.LONG;
3403                 break;
3404             case Frame.ITEM_NULL:
3405                 frame[index] = Opcodes.NULL;
3406                 break;
3407             case Frame.ITEM_UNINITIALIZED_THIS:
</pre>
<hr />
<pre>
3409                 break;
3410             case Frame.ITEM_OBJECT:
3411                 frame[index] = readClass(currentOffset, charBuffer);
3412                 currentOffset += 2;
3413                 break;
3414             case Frame.ITEM_UNINITIALIZED:
3415                 frame[index] = createLabel(readUnsignedShort(currentOffset), labels);
3416                 currentOffset += 2;
3417                 break;
3418             default:
3419                 throw new IllegalArgumentException();
3420         }
3421         return currentOffset;
3422     }
3423 
3424     // ----------------------------------------------------------------------------------------------
3425     // Methods to parse attributes
3426     // ----------------------------------------------------------------------------------------------
3427 
3428     /**
<span class="line-modified">3429       * Returns the offset in {@link #classFileBuffer} of the first ClassFile&#39;s &#39;attributes&#39; array</span>
<span class="line-added">3430       * field entry.</span>
3431       *
<span class="line-modified">3432       * @return the offset in {@link #classFileBuffer} of the first ClassFile&#39;s &#39;attributes&#39; array</span>
<span class="line-added">3433       *     field entry.</span>
3434       */
3435     final int getFirstAttributeOffset() {
3436         // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes
3437         // each), as well as the interfaces array field (2 bytes per interface).
3438         int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;
3439 
3440         // Read the fields_count field.
3441         int fieldsCount = readUnsignedShort(currentOffset);
3442         currentOffset += 2;
3443         // Skip the &#39;fields&#39; array field.
3444         while (fieldsCount-- &gt; 0) {
3445             // Invariant: currentOffset is the offset of a field_info structure.
3446             // Skip the access_flags, name_index and descriptor_index fields (2 bytes each), and read the
3447             // attributes_count field.
3448             int attributesCount = readUnsignedShort(currentOffset + 6);
3449             currentOffset += 8;
3450             // Skip the &#39;attributes&#39; array field.
3451             while (attributesCount-- &gt; 0) {
3452                 // Invariant: currentOffset is the offset of an attribute_info structure.
3453                 // Read the attribute_length field (2 bytes after the start of the attribute_info) and skip
</pre>
<hr />
<pre>
3460         // Skip the methods_count and &#39;methods&#39; fields, using the same method as above.
3461         int methodsCount = readUnsignedShort(currentOffset);
3462         currentOffset += 2;
3463         while (methodsCount-- &gt; 0) {
3464             int attributesCount = readUnsignedShort(currentOffset + 6);
3465             currentOffset += 8;
3466             while (attributesCount-- &gt; 0) {
3467                 currentOffset += 6 + readInt(currentOffset + 2);
3468             }
3469         }
3470 
3471         // Skip the ClassFile&#39;s attributes_count field.
3472         return currentOffset + 2;
3473     }
3474 
3475     /**
3476       * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
3477       *
3478       * @param maxStringLength a conservative estimate of the maximum length of the strings contained
3479       *     in the constant pool of the class.
<span class="line-modified">3480       * @return the offsets of the bootstrap methods.</span>
3481       */
3482     private int[] readBootstrapMethodsAttribute(final int maxStringLength) {
3483         char[] charBuffer = new char[maxStringLength];
3484         int currentAttributeOffset = getFirstAttributeOffset();
3485         int[] currentBootstrapMethodOffsets = null;
3486         for (int i = readUnsignedShort(currentAttributeOffset - 2); i &gt; 0; --i) {
3487             // Read the attribute_info&#39;s attribute_name and attribute_length fields.
3488             String attributeName = readUTF8(currentAttributeOffset, charBuffer);
3489             int attributeLength = readInt(currentAttributeOffset + 2);
3490             currentAttributeOffset += 6;
3491             if (Constants.BOOTSTRAP_METHODS.equals(attributeName)) {
3492                 // Read the num_bootstrap_methods field and create an array of this size.
3493                 currentBootstrapMethodOffsets = new int[readUnsignedShort(currentAttributeOffset)];
3494                 // Compute and store the offset of each &#39;bootstrap_methods&#39; array field entry.
3495                 int currentBootstrapMethodOffset = currentAttributeOffset + 2;
3496                 for (int j = 0; j &lt; currentBootstrapMethodOffsets.length; ++j) {
3497                     currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;
3498                     // Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),
3499                     // as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).
3500                     currentBootstrapMethodOffset +=
3501                             4 + readUnsignedShort(currentBootstrapMethodOffset + 2) * 2;
3502                 }
3503                 return currentBootstrapMethodOffsets;
3504             }
3505             currentAttributeOffset += attributeLength;
3506         }
<span class="line-modified">3507         throw new IllegalArgumentException();</span>
3508     }
3509 
3510     /**
<span class="line-modified">3511       * Reads a non standard JVMS &#39;attribute&#39; structure in {@link #classFileBuffer}.</span>
3512       *
3513       * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
3514       *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
3515       *     be parsed: its byte array value will be passed unchanged to the ClassWriter.
3516       * @param type the type of the attribute.
<span class="line-modified">3517       * @param offset the start offset of the JVMS &#39;attribute&#39; structure in {@link #classFileBuffer}.</span>
<span class="line-modified">3518       *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into</span>
<span class="line-added">3519       *     account here.</span>
3520       * @param length the length of the attribute&#39;s content (excluding the 6 attribute header bytes).
3521       * @param charBuffer the buffer to be used to read strings in the constant pool.
<span class="line-modified">3522       * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link</span>
<span class="line-modified">3523       *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6</span>
<span class="line-modified">3524       *     attribute header bytes (attribute_name_index and attribute_length) are not taken into</span>
<span class="line-added">3525       *     account here.</span>
3526       * @param labels the labels of the method&#39;s code, or {@literal null} if the attribute to be read
3527       *     is not a code attribute.
3528       * @return the attribute that has been read.
3529       */
3530     private Attribute readAttribute(
3531             final Attribute[] attributePrototypes,
3532             final String type,
3533             final int offset,
3534             final int length,
3535             final char[] charBuffer,
3536             final int codeAttributeOffset,
3537             final Label[] labels) {
3538         for (Attribute attributePrototype : attributePrototypes) {
3539             if (attributePrototype.type.equals(type)) {
3540                 return attributePrototype.read(
3541                         this, offset, length, charBuffer, codeAttributeOffset, labels);
3542             }
3543         }
3544         return new Attribute(type).read(this, offset, length, null, -1, null);
3545     }
3546 
3547     // -----------------------------------------------------------------------------------------------
3548     // Utility methods: low level parsing
3549     // -----------------------------------------------------------------------------------------------
3550 
3551     /**
3552       * Returns the number of entries in the class&#39;s constant pool table.
3553       *
3554       * @return the number of entries in the class&#39;s constant pool table.
3555       */
3556     public int getItemCount() {
3557         return cpInfoOffsets.length;
3558     }
3559 
3560     /**
<span class="line-modified">3561       * Returns the start offset in this {@link ClassReader} of a JVMS &#39;cp_info&#39; structure (i.e. a</span>
<span class="line-modified">3562       * constant pool entry), plus one. &lt;i&gt;This method is intended for {@link Attribute} sub classes,</span>
<span class="line-modified">3563       * and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3564       *
3565       * @param constantPoolEntryIndex the index a constant pool entry in the class&#39;s constant pool
3566       *     table.
<span class="line-modified">3567       * @return the start offset in this {@link ClassReader} of the corresponding JVMS &#39;cp_info&#39;</span>
<span class="line-added">3568       *     structure, plus one.</span>
3569       */
3570     public int getItem(final int constantPoolEntryIndex) {
3571         return cpInfoOffsets[constantPoolEntryIndex];
3572     }
3573 
3574     /**
3575       * Returns a conservative estimate of the maximum length of the strings contained in the class&#39;s
3576       * constant pool table.
3577       *
3578       * @return a conservative estimate of the maximum length of the strings contained in the class&#39;s
3579       *     constant pool table.
3580       */
3581     public int getMaxStringLength() {
3582         return maxStringLength;
3583     }
3584 
3585     /**
<span class="line-modified">3586       * Reads a byte value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">3587       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3588       *
<span class="line-modified">3589       * @param offset the start offset of the value to be read in this {@link ClassReader}.</span>
3590       * @return the read value.
3591       */
3592     public int readByte(final int offset) {
<span class="line-modified">3593         return classFileBuffer[offset] &amp; 0xFF;</span>
3594     }
3595 
3596     /**
<span class="line-modified">3597       * Reads an unsigned short value in this {@link ClassReader}. &lt;i&gt;This method is intended for</span>
<span class="line-modified">3598       * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3599       *
<span class="line-modified">3600       * @param offset the start index of the value to be read in this {@link ClassReader}.</span>
3601       * @return the read value.
3602       */
3603     public int readUnsignedShort(final int offset) {
<span class="line-modified">3604         byte[] classBuffer = classFileBuffer;</span>
<span class="line-modified">3605         return ((classBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classBuffer[offset + 1] &amp; 0xFF);</span>
3606     }
3607 
3608     /**
<span class="line-modified">3609       * Reads a signed short value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">3610       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3611       *
<span class="line-modified">3612       * @param offset the start offset of the value to be read in this {@link ClassReader}.</span>
3613       * @return the read value.
3614       */
3615     public short readShort(final int offset) {
<span class="line-modified">3616         byte[] classBuffer = classFileBuffer;</span>
<span class="line-modified">3617         return (short) (((classBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classBuffer[offset + 1] &amp; 0xFF));</span>
3618     }
3619 
3620     /**
<span class="line-modified">3621       * Reads a signed int value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">3622       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3623       *
<span class="line-modified">3624       * @param offset the start offset of the value to be read in this {@link ClassReader}.</span>
3625       * @return the read value.
3626       */
3627     public int readInt(final int offset) {
<span class="line-modified">3628         byte[] classBuffer = classFileBuffer;</span>
<span class="line-modified">3629         return ((classBuffer[offset] &amp; 0xFF) &lt;&lt; 24)</span>
<span class="line-modified">3630                 | ((classBuffer[offset + 1] &amp; 0xFF) &lt;&lt; 16)</span>
<span class="line-modified">3631                 | ((classBuffer[offset + 2] &amp; 0xFF) &lt;&lt; 8)</span>
<span class="line-modified">3632                 | (classBuffer[offset + 3] &amp; 0xFF);</span>
3633     }
3634 
3635     /**
<span class="line-modified">3636       * Reads a signed long value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">3637       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
3638       *
<span class="line-modified">3639       * @param offset the start offset of the value to be read in this {@link ClassReader}.</span>
3640       * @return the read value.
3641       */
3642     public long readLong(final int offset) {
3643         long l1 = readInt(offset);
3644         long l0 = readInt(offset + 4) &amp; 0xFFFFFFFFL;
3645         return (l1 &lt;&lt; 32) | l0;
3646     }
3647 
3648     /**
<span class="line-modified">3649       * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is</span>
<span class="line-modified">3650       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">3651       * adapters.&lt;/i&gt;</span>
3652       *
<span class="line-modified">3653       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose</span>
<span class="line-modified">3654       *     value is the index of a CONSTANT_Utf8 entry in the class&#39;s constant pool table.</span>
3655       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3656       *     large. It is not automatically resized.
3657       * @return the String corresponding to the specified CONSTANT_Utf8 entry.
3658       */
3659     // DontCheck(AbbreviationAsWordInName): can&#39;t be renamed (for backward binary compatibility).
3660     public String readUTF8(final int offset, final char[] charBuffer) {
3661         int constantPoolEntryIndex = readUnsignedShort(offset);
3662         if (offset == 0 || constantPoolEntryIndex == 0) {
3663             return null;
3664         }
3665         return readUtf(constantPoolEntryIndex, charBuffer);
3666     }
3667 
3668     /**
<span class="line-modified">3669       * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.</span>
3670       *
3671       * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class&#39;s constant pool
3672       *     table.
3673       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3674       *     large. It is not automatically resized.
3675       * @return the String corresponding to the specified CONSTANT_Utf8 entry.
3676       */
3677     final String readUtf(final int constantPoolEntryIndex, final char[] charBuffer) {
3678         String value = constantUtf8Values[constantPoolEntryIndex];
3679         if (value != null) {
3680             return value;
3681         }
3682         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
3683         return constantUtf8Values[constantPoolEntryIndex] =
3684                 readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);
3685     }
3686 
3687     /**
<span class="line-modified">3688       * Reads an UTF8 string in {@link #classFileBuffer}.</span>
3689       *
3690       * @param utfOffset the start offset of the UTF8 string to be read.
3691       * @param utfLength the length of the UTF8 string to be read.
3692       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3693       *     large. It is not automatically resized.
3694       * @return the String corresponding to the specified UTF8 string.
3695       */
3696     private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {
3697         int currentOffset = utfOffset;
3698         int endOffset = currentOffset + utfLength;
3699         int strLength = 0;
<span class="line-modified">3700         byte[] classBuffer = classFileBuffer;</span>
3701         while (currentOffset &lt; endOffset) {
<span class="line-modified">3702             int currentByte = classBuffer[currentOffset++];</span>
3703             if ((currentByte &amp; 0x80) == 0) {
3704                 charBuffer[strLength++] = (char) (currentByte &amp; 0x7F);
3705             } else if ((currentByte &amp; 0xE0) == 0xC0) {
3706                 charBuffer[strLength++] =
<span class="line-modified">3707                         (char) (((currentByte &amp; 0x1F) &lt;&lt; 6) + (classBuffer[currentOffset++] &amp; 0x3F));</span>
3708             } else {
3709                 charBuffer[strLength++] =
3710                         (char)
3711                                 (((currentByte &amp; 0xF) &lt;&lt; 12)
<span class="line-modified">3712                                         + ((classBuffer[currentOffset++] &amp; 0x3F) &lt;&lt; 6)</span>
<span class="line-modified">3713                                         + (classBuffer[currentOffset++] &amp; 0x3F));</span>
3714             }
3715         }
3716         return new String(charBuffer, 0, strLength);
3717     }
3718 
3719     /**
3720       * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
<span class="line-modified">3721       * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. &lt;i&gt;This method is intended</span>
<span class="line-modified">3722       * for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">3723       * adapters.&lt;/i&gt;</span>
3724       *
<span class="line-modified">3725       * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose</span>
<span class="line-modified">3726       *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,</span>
<span class="line-modified">3727       *     CONSTANT_Module or CONSTANT_Package entry in class&#39;s constant pool table.</span>
3728       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3729       *     large. It is not automatically resized.
3730       * @return the String corresponding to the specified constant pool entry.
3731       */
3732     private String readStringish(final int offset, final char[] charBuffer) {
3733         // Get the start offset of the cp_info structure (plus one), and read the CONSTANT_Utf8 entry
3734         // designated by the first two bytes of this cp_info.
3735         return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);
3736     }
3737 
3738     /**
<span class="line-modified">3739       * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is</span>
<span class="line-modified">3740       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">3741       * adapters.&lt;/i&gt;</span>
3742       *
<span class="line-modified">3743       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose</span>
<span class="line-modified">3744       *     value is the index of a CONSTANT_Class entry in class&#39;s constant pool table.</span>
3745       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3746       *     large. It is not automatically resized.
3747       * @return the String corresponding to the specified CONSTANT_Class entry.
3748       */
3749     public String readClass(final int offset, final char[] charBuffer) {
3750         return readStringish(offset, charBuffer);
3751     }
3752 
3753     /**
<span class="line-modified">3754       * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is</span>
<span class="line-modified">3755       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">3756       * adapters.&lt;/i&gt;</span>
3757       *
<span class="line-modified">3758       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose</span>
<span class="line-modified">3759       *     value is the index of a CONSTANT_Module entry in class&#39;s constant pool table.</span>
3760       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3761       *     large. It is not automatically resized.
3762       * @return the String corresponding to the specified CONSTANT_Module entry.
3763       */
3764     public String readModule(final int offset, final char[] charBuffer) {
3765         return readStringish(offset, charBuffer);
3766     }
3767 
3768     /**
<span class="line-modified">3769       * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is</span>
<span class="line-modified">3770       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">3771       * adapters.&lt;/i&gt;</span>
3772       *
<span class="line-modified">3773       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose</span>
<span class="line-modified">3774       *     value is the index of a CONSTANT_Package entry in class&#39;s constant pool table.</span>
3775       * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
3776       *     large. It is not automatically resized.
3777       * @return the String corresponding to the specified CONSTANT_Package entry.
3778       */
3779     public String readPackage(final int offset, final char[] charBuffer) {
3780         return readStringish(offset, charBuffer);
3781     }
3782 
3783     /**
<span class="line-modified">3784       * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.</span>
3785       *
3786       * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class&#39;s constant
3787       *     pool table.
3788       * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
3789       *     large. It is not automatically resized.
3790       * @return the ConstantDynamic corresponding to the specified CONSTANT_Dynamic entry.
3791       */
3792     private ConstantDynamic readConstantDynamic(
3793             final int constantPoolEntryIndex, final char[] charBuffer) {
3794         ConstantDynamic constantDynamic = constantDynamicValues[constantPoolEntryIndex];
3795         if (constantDynamic != null) {
3796             return constantDynamic;
3797         }
3798         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
3799         int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
3800         String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
3801         String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
3802         int bootstrapMethodOffset = bootstrapMethodOffsets[readUnsignedShort(cpInfoOffset)];
3803         Handle handle = (Handle) readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
3804         Object[] bootstrapMethodArguments = new Object[readUnsignedShort(bootstrapMethodOffset + 2)];
3805         bootstrapMethodOffset += 4;
3806         for (int i = 0; i &lt; bootstrapMethodArguments.length; i++) {
3807             bootstrapMethodArguments[i] = readConst(readUnsignedShort(bootstrapMethodOffset), charBuffer);
3808             bootstrapMethodOffset += 2;
3809         }
3810         return constantDynamicValues[constantPoolEntryIndex] =
3811                 new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);
3812     }
3813 
3814     /**
<span class="line-modified">3815       * Reads a numeric or string constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is</span>
<span class="line-modified">3816       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">3817       * adapters.&lt;/i&gt;</span>
3818       *
3819       * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,
3820       *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
3821       *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class&#39;s constant pool.
3822       * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently
3823       *     large. It is not automatically resized.
3824       * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double}, {@link String},
3825       *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified
3826       *     constant pool entry.
3827       */
3828     public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {
3829         int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
<span class="line-modified">3830         switch (classFileBuffer[cpInfoOffset - 1]) {</span>
3831             case Symbol.CONSTANT_INTEGER_TAG:
3832                 return readInt(cpInfoOffset);
3833             case Symbol.CONSTANT_FLOAT_TAG:
3834                 return Float.intBitsToFloat(readInt(cpInfoOffset));
3835             case Symbol.CONSTANT_LONG_TAG:
3836                 return readLong(cpInfoOffset);
3837             case Symbol.CONSTANT_DOUBLE_TAG:
3838                 return Double.longBitsToDouble(readLong(cpInfoOffset));
3839             case Symbol.CONSTANT_CLASS_TAG:
3840                 return Type.getObjectType(readUTF8(cpInfoOffset, charBuffer));
3841             case Symbol.CONSTANT_STRING_TAG:
3842                 return readUTF8(cpInfoOffset, charBuffer);
3843             case Symbol.CONSTANT_METHOD_TYPE_TAG:
3844                 return Type.getMethodType(readUTF8(cpInfoOffset, charBuffer));
3845             case Symbol.CONSTANT_METHOD_HANDLE_TAG:
3846                 int referenceKind = readByte(cpInfoOffset);
3847                 int referenceCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 1)];
3848                 int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];
3849                 String owner = readClass(referenceCpInfoOffset, charBuffer);
3850                 String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
3851                 String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
3852                 boolean isInterface =
<span class="line-modified">3853                         classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;</span>
3854                 return new Handle(referenceKind, owner, name, descriptor, isInterface);
3855             case Symbol.CONSTANT_DYNAMIC_TAG:
3856                 return readConstantDynamic(constantPoolEntryIndex, charBuffer);
3857             default:
3858                 throw new IllegalArgumentException();
3859         }
3860     }
3861 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../java/lang/reflect/Field.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Constants.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
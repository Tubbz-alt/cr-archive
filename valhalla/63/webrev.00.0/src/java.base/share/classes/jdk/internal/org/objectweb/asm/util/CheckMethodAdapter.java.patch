diff a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckMethodAdapter.java b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckMethodAdapter.java
--- a/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckMethodAdapter.java
+++ b/src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckMethodAdapter.java
@@ -59,10 +59,11 @@
 package jdk.internal.org.objectweb.asm.util;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -395,34 +396,35 @@
       *     (in other methods). This map is updated with the labels from the visited method.
       * @throws IllegalStateException If a subclass calls this constructor.
       */
     public CheckMethodAdapter(
             final MethodVisitor methodVisitor, final Map<Label, Integer> labelInsnIndices) {
-        this(Opcodes.ASM7, methodVisitor, labelInsnIndices);
+        this(/* latest api = */ Opcodes.ASM8, methodVisitor, labelInsnIndices);
         if (getClass() != CheckMethodAdapter.class) {
             throw new IllegalStateException();
         }
     }
 
     /**
       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will not perform any
       * data flow check (see {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
       *
       * @param api the ASM API version implemented by this CheckMethodAdapter. Must be one of {@link
-      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
+      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link
+      *     Opcodes#ASM8}.
       * @param methodVisitor the method visitor to which this adapter must delegate calls.
       * @param labelInsnIndices the index of the instruction designated by each visited label so far
       *     (in other methods). This map is updated with the labels from the visited method.
       */
     protected CheckMethodAdapter(
             final int api,
             final MethodVisitor methodVisitor,
             final Map<Label, Integer> labelInsnIndices) {
         super(api, methodVisitor);
         this.labelInsnIndices = labelInsnIndices;
-        this.referencedLabels = new HashSet<Label>();
-        this.handlers = new ArrayList<Label>();
+        this.referencedLabels = new HashSet<>();
+        this.handlers = new ArrayList<>();
     }
 
     /**
       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will perform basic data
       * flow checks. For instance in a method whose signature is {@code void m ()}, the invalid
@@ -441,11 +443,12 @@
             final int access,
             final String name,
             final String descriptor,
             final MethodVisitor methodVisitor,
             final Map<Label, Integer> labelInsnIndices) {
-        this(Opcodes.ASM7, access, name, descriptor, methodVisitor, labelInsnIndices);
+        this(
+                /* latest api = */ Opcodes.ASM8, access, name, descriptor, methodVisitor, labelInsnIndices);
         if (getClass() != CheckMethodAdapter.class) {
             throw new IllegalStateException();
         }
     }
 
@@ -453,11 +456,12 @@
       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will perform basic data
       * flow checks. For instance in a method whose signature is {@code void m ()}, the invalid
       * instruction IRETURN, or the invalid sequence IADD L2I will be detected.
       *
       * @param api the ASM API version implemented by this CheckMethodAdapter. Must be one of {@link
-      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.
+      *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link
+      *     Opcodes#ASM8}.
       * @param access the method's access flags.
       * @param name the method's name.
       * @param descriptor the method's descriptor (see {@link Type}).
       * @param methodVisitor the method visitor to which this adapter must delegate calls.
       * @param labelInsnIndices the index of the instruction designated by each visited label so far
@@ -473,11 +477,11 @@
         this(
                 api,
                 new MethodNode(api, access, name, descriptor, null, null) {
                     @Override
                     public void visitEnd() {
-                        Analyzer<BasicValue> analyzer = new Analyzer<BasicValue>(new BasicVerifier());
+                        Analyzer<BasicValue> analyzer = new Analyzer<>(new BasicVerifier());
                         try {
                             analyzer.analyze("dummy", this);
                         } catch (IndexOutOfBoundsException e) {
                             if (maxLocals == 0 && maxStack == 0) {
                                 throw new IllegalArgumentException(
@@ -486,11 +490,13 @@
                             }
                             throwError(analyzer, e);
                         } catch (AnalyzerException e) {
                             throwError(analyzer, e);
                         }
-                        accept(methodVisitor);
+                        if (methodVisitor != null) {
+                            accept(methodVisitor);
+                        }
                     }
 
                     private void throwError(final Analyzer<BasicValue> analyzer, final Exception e) {
                         StringWriter stringWriter = new StringWriter();
                         PrintWriter printWriter = new PrintWriter(stringWriter, true);
@@ -733,46 +739,24 @@
         checkDescriptor(version, descriptor, false);
         super.visitFieldInsn(opcode, owner, name, descriptor);
         ++insnCount;
     }
 
-    /**
-      * Deprecated.
-      *
-      * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.
-      */
-    @Deprecated
-    @Override
-    public void visitMethodInsn(
-            final int opcode, final String owner, final String name, final String descriptor) {
-        if (api >= Opcodes.ASM5) {
-            super.visitMethodInsn(opcode, owner, name, descriptor);
-            return;
-        }
-        doVisitMethodInsn(opcode, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);
-    }
-
     @Override
     public void visitMethodInsn(
-            final int opcode,
+            final int opcodeAndSource,
             final String owner,
             final String name,
             final String descriptor,
             final boolean isInterface) {
-        if (api < Opcodes.ASM5) {
-            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
+        if (api < Opcodes.ASM5 && (opcodeAndSource & Opcodes.SOURCE_DEPRECATED) == 0) {
+            // Redirect the call to the deprecated version of this method.
+            super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
             return;
         }
-        doVisitMethodInsn(opcode, owner, name, descriptor, isInterface);
-    }
+        int opcode = opcodeAndSource & ~Opcodes.SOURCE_MASK;
 
-    private void doVisitMethodInsn(
-            final int opcode,
-            final String owner,
-            final String name,
-            final String descriptor,
-            final boolean isInterface) {
         checkVisitCodeCalled();
         checkVisitMaxsNotCalled();
         checkOpcodeMethod(opcode, Method.VISIT_METHOD_INSN);
         if (opcode != Opcodes.INVOKESPECIAL || !"<init>".equals(name)) {
             checkMethodIdentifier(version, name, "name");
@@ -787,17 +771,11 @@
         }
         if (opcode == Opcodes.INVOKESPECIAL && isInterface && (version & 0xFFFF) < Opcodes.V1_8) {
             throw new IllegalArgumentException(
                     "INVOKESPECIAL can't be used with interfaces prior to Java 8");
         }
-
-        // Calling super.visitMethodInsn requires to call the correct version depending on this.api
-        // (otherwise infinite loops can occur). To simplify and to make it easier to automatically
-        // remove the backward compatibility code, we inline the code of the overridden method here.
-        if (mv != null) {
-            mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
-        }
+        super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);
         ++insnCount;
     }
 
     @Override
     public void visitInvokeDynamicInsn(
@@ -877,13 +855,11 @@
         }
         for (int i = 0; i < labels.length; ++i) {
             checkLabel(labels[i], false, "label at index " + i);
         }
         super.visitTableSwitchInsn(min, max, dflt, labels);
-        for (Label label : labels) {
-            referencedLabels.add(label);
-        }
+        Collections.addAll(referencedLabels, labels);
         ++insnCount;
     }
 
     @Override
     public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
@@ -896,13 +872,11 @@
         for (int i = 0; i < labels.length; ++i) {
             checkLabel(labels[i], false, "label at index " + i);
         }
         super.visitLookupSwitchInsn(dflt, keys, labels);
         referencedLabels.add(dflt);
-        for (Label label : labels) {
-            referencedLabels.add(label);
-        }
+        Collections.addAll(referencedLabels, labels);
         ++insnCount;
     }
 
     @Override
     public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
@@ -995,10 +969,13 @@
             final int index) {
         checkVisitCodeCalled();
         checkVisitMaxsNotCalled();
         checkUnqualifiedName(version, name, "name");
         checkDescriptor(version, descriptor, false);
+        if (signature != null) {
+            CheckClassAdapter.checkFieldSignature(signature);
+        }
         checkLabel(start, true, START_LABEL);
         checkLabel(end, true, END_LABEL);
         checkUnsignedShort(index, INVALID_LOCAL_VARIABLE_INDEX);
         int startInsnIndex = labelInsnIndices.get(start).intValue();
         int endInsnIndex = labelInsnIndices.get(end).intValue();
@@ -1128,11 +1105,12 @@
                 || value == Opcodes.LONG
                 || value == Opcodes.DOUBLE
                 || value == Opcodes.NULL
                 || value == Opcodes.UNINITIALIZED_THIS) {
             return;
-        } else if (value instanceof String) {
+        }
+        if (value instanceof String) {
             checkInternalName(version, (String) value, "Invalid stack frame value");
         } else if (value instanceof Label) {
             referencedLabels.add((Label) value);
         } else {
             throw new IllegalArgumentException("Invalid stack frame value: " + value);
@@ -1312,11 +1290,11 @@
       * @param version the class version.
       * @param name the string to be checked.
       * @param message the message to use in case of error.
       */
     static void checkMethodIdentifier(final int version, final String name, final String message) {
-        if (name == null || name.isEmpty()) {
+        if (name == null || name.length() == 0) {
             throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
         }
         if ((version & 0xFFFF) >= Opcodes.V1_5) {
             for (int i = 0; i < name.length(); i = name.offsetByCodePoints(i, 1)) {
                 if (".;[/<>".indexOf(name.codePointAt(i)) != -1) {
@@ -1345,11 +1323,11 @@
       * @param version the class version.
       * @param name the string to be checked.
       * @param message the message to use in case of error.
       */
     static void checkInternalName(final int version, final String name, final String message) {
-        if (name == null || name.isEmpty()) {
+        if (name == null || name.length() == 0) {
             throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
         }
         if (name.charAt(0) == '[') {
             checkDescriptor(version, name, false);
         } else {
@@ -1368,14 +1346,14 @@
             final int version, final String name, final String message) {
         try {
             int startIndex = 0;
             int slashIndex;
             while ((slashIndex = name.indexOf('/', startIndex + 1)) != -1) {
-                CheckMethodAdapter.checkIdentifier(version, name, startIndex, slashIndex, null);
+                checkIdentifier(version, name, startIndex, slashIndex, null);
                 startIndex = slashIndex + 1;
             }
-            CheckMethodAdapter.checkIdentifier(version, name, startIndex, name.length(), null);
+            checkIdentifier(version, name, startIndex, name.length(), null);
         } catch (IllegalArgumentException e) {
             throw new IllegalArgumentException(
                     INVALID + message + " (must be an internal class name): " + name, e);
         }
     }
@@ -1456,11 +1434,11 @@
       *
       * @param version the class version.
       * @param descriptor the string to be checked.
       */
     static void checkMethodDescriptor(final int version, final String descriptor) {
-        if (descriptor == null || descriptor.isEmpty()) {
+        if (descriptor == null || descriptor.length() == 0) {
             throw new IllegalArgumentException("Invalid method descriptor (must not be null or empty)");
         }
         if (descriptor.charAt(0) != '(' || descriptor.length() < 3) {
             throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
         }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Constants.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Opcodes.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/org/objectweb/asm/Frame.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  68  *       the current basic block is updated by simulating the action of the instruction on the
  69  *       previous state of this so called &quot;output frame&quot;.
  70  *   &lt;li&gt;After all instructions have been visited, a fix point algorithm is used in MethodWriter to
  71  *       compute the &quot;input frame&quot; of each basic block (i.e. the stack map frame at the beginning of
  72  *       the basic block). See {@link MethodWriter#computeAllFrames}.
  73  * &lt;/ul&gt;
  74  *
  75  * &lt;p&gt;Output stack map frames are computed relatively to the input frame of the basic block, which
  76  * is not yet known when output frames are computed. It is therefore necessary to be able to
  77  * represent abstract types such as &quot;the type at position x in the input frame locals&quot; or &quot;the type
  78  * at position x from the top of the input frame stack&quot; or even &quot;the type at position x in the input
  79  * frame, with y more (or less) array dimensions&quot;. This explains the rather complicated type format
  80  * used in this class, explained below.
  81  *
  82  * &lt;p&gt;The local variables and the operand stack of input and output frames contain values called
  83  * &quot;abstract types&quot; hereafter. An abstract type is represented with 4 fields named DIM, KIND, FLAGS
  84  * and VALUE, packed in a single int value for better performance and memory efficiency:
  85  *
  86  * &lt;pre&gt;
  87  *   =====================================
<span class="line-modified">  88  *   |.DIM|KIND|FLAG|...............VALUE|</span>
  89  *   =====================================
  90  * &lt;/pre&gt;
  91  *
  92  * &lt;ul&gt;
<span class="line-modified">  93  *   &lt;li&gt;the DIM field, stored in the 4 most significant bits, is a signed number of array</span>
<span class="line-modified">  94  *       dimensions (from -8 to 7, included). It can be retrieved with {@link #DIM_MASK} and a right</span>
<span class="line-modified">  95  *       shift of {@link #DIM_SHIFT}.</span>
  96  *   &lt;li&gt;the KIND field, stored in 4 bits, indicates the kind of VALUE used. These 4 bits can be
  97  *       retrieved with {@link #KIND_MASK} and, without any shift, must be equal to {@link
  98  *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link #LOCAL_KIND}
  99  *       or {@link #STACK_KIND}.
<span class="line-modified"> 100  *   &lt;li&gt;the FLAGS field, stored in 4 bits, contains up to 4 boolean flags. Currently only one flag</span>
 101  *       is defined, namely {@link #TOP_IF_LONG_OR_DOUBLE_FLAG}.
 102  *   &lt;li&gt;the VALUE field, stored in the remaining 20 bits, contains either
 103  *       &lt;ul&gt;
 104  *         &lt;li&gt;one of the constants {@link #ITEM_TOP}, {@link #ITEM_ASM_BOOLEAN}, {@link
 105  *             #ITEM_ASM_BYTE}, {@link #ITEM_ASM_CHAR} or {@link #ITEM_ASM_SHORT}, {@link
 106  *             #ITEM_INTEGER}, {@link #ITEM_FLOAT}, {@link #ITEM_LONG}, {@link #ITEM_DOUBLE}, {@link
 107  *             #ITEM_NULL} or {@link #ITEM_UNINITIALIZED_THIS}, if KIND is equal to {@link
 108  *             #CONSTANT_KIND}.
 109  *         &lt;li&gt;the index of a {@link Symbol#TYPE_TAG} {@link Symbol} in the type table of a {@link
 110  *             SymbolTable}, if KIND is equal to {@link #REFERENCE_KIND}.
 111  *         &lt;li&gt;the index of an {@link Symbol#UNINITIALIZED_TYPE_TAG} {@link Symbol} in the type
 112  *             table of a SymbolTable, if KIND is equal to {@link #UNINITIALIZED_KIND}.
 113  *         &lt;li&gt;the index of a local variable in the input stack frame, if KIND is equal to {@link
 114  *             #LOCAL_KIND}.
 115  *         &lt;li&gt;a position relatively to the top of the stack of the input stack frame, if KIND is
 116  *             equal to {@link #STACK_KIND},
 117  *       &lt;/ul&gt;
 118  * &lt;/ul&gt;
 119  *
 120  * &lt;p&gt;Output frames can contain abstract types of any kind and with a positive or negative array
 121  * dimension (and even unassigned types, represented by 0 - which does not correspond to any valid
 122  * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND or
<span class="line-modified"> 123  * UNINITIALIZED_KIND abstract types of positive or null array dimension. In all cases the type</span>
<span class="line-modified"> 124  * table contains only internal type names (array type descriptors are forbidden - array dimensions</span>
<span class="line-modified"> 125  * must be represented through the DIM field).</span>
 126  *
 127  * &lt;p&gt;The LONG and DOUBLE types are always represented by using two slots (LONG + TOP or DOUBLE +
 128  * TOP), for local variables as well as in the operand stack. This is necessary to be able to
 129  * simulate DUPx_y instructions, whose effect would be dependent on the concrete types represented
 130  * by the abstract types in the stack (which are not always known).
 131  *
 132  * @author Eric Bruneton
 133  */
 134 class Frame {
 135 
 136     // Constants used in the StackMapTable attribute.
 137     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.
 138 
 139     static final int SAME_FRAME = 0;
 140     static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;
 141     static final int RESERVED = 128;
 142     static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;
 143     static final int CHOP_FRAME = 248;
 144     static final int SAME_FRAME_EXTENDED = 251;
 145     static final int APPEND_FRAME = 252;
 146     static final int FULL_FRAME = 255;
 147 
 148     static final int ITEM_TOP = 0;
 149     static final int ITEM_INTEGER = 1;
 150     static final int ITEM_FLOAT = 2;
 151     static final int ITEM_DOUBLE = 3;
 152     static final int ITEM_LONG = 4;
 153     static final int ITEM_NULL = 5;
 154     static final int ITEM_UNINITIALIZED_THIS = 6;
 155     static final int ITEM_OBJECT = 7;
 156     static final int ITEM_UNINITIALIZED = 8;
 157     // Additional, ASM specific constants used in abstract types below.
 158     private static final int ITEM_ASM_BOOLEAN = 9;
 159     private static final int ITEM_ASM_BYTE = 10;
 160     private static final int ITEM_ASM_CHAR = 11;
 161     private static final int ITEM_ASM_SHORT = 12;
 162 











 163     // Bitmasks to get each field of an abstract type.
 164 
<span class="line-modified"> 165     private static final int DIM_MASK = 0xF0000000;</span>
<span class="line-modified"> 166     private static final int KIND_MASK = 0x0F000000;</span>
<span class="line-modified"> 167     private static final int FLAGS_MASK = 0x00F00000;</span>
<span class="line-removed"> 168     private static final int VALUE_MASK = 0x000FFFFF;</span>
 169 
 170     // Constants to manipulate the DIM field of an abstract type.
 171 
<span class="line-removed"> 172     /** The number of right shift bits to use to get the array dimensions of an abstract type. */</span>
<span class="line-removed"> 173     private static final int DIM_SHIFT = 28;</span>
<span class="line-removed"> 174 </span>
 175     /** The constant to be added to an abstract type to get one with one more array dimension. */
 176     private static final int ARRAY_OF = +1 &lt;&lt; DIM_SHIFT;
 177 
 178     /** The constant to be added to an abstract type to get one with one less array dimension. */
 179     private static final int ELEMENT_OF = -1 &lt;&lt; DIM_SHIFT;
 180 
 181     // Possible values for the KIND field of an abstract type.
 182 
<span class="line-modified"> 183     private static final int CONSTANT_KIND = 0x01000000;</span>
<span class="line-modified"> 184     private static final int REFERENCE_KIND = 0x02000000;</span>
<span class="line-modified"> 185     private static final int UNINITIALIZED_KIND = 0x03000000;</span>
<span class="line-modified"> 186     private static final int LOCAL_KIND = 0x04000000;</span>
<span class="line-modified"> 187     private static final int STACK_KIND = 0x05000000;</span>
 188 
 189     // Possible flags for the FLAGS field of an abstract type.
 190 
 191     /**
 192       * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,
 193       * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been
 194       * partially overridden with an xSTORE instruction).
 195       */
<span class="line-modified"> 196     private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 0x00100000 &amp; FLAGS_MASK;</span>
 197 
 198     // Useful predefined abstract types (all the possible CONSTANT_KIND types).
 199 
 200     private static final int TOP = CONSTANT_KIND | ITEM_TOP;
 201     private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;
 202     private static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;
 203     private static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;
 204     private static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;
 205     private static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;
 206     private static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;
 207     private static final int LONG = CONSTANT_KIND | ITEM_LONG;
 208     private static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;
 209     private static final int NULL = CONSTANT_KIND | ITEM_NULL;
 210     private static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;
 211 
 212     // -----------------------------------------------------------------------------------------------
 213     // Instance fields
 214     // -----------------------------------------------------------------------------------------------
 215 
 216     /** The basic block to which these input and output stack map frames correspond. */
</pre>
<hr />
<pre>
 556             System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);
 557             outputStack = newOutputStack;
 558         }
 559         // Pushes the abstract type on the output stack.
 560         outputStack[outputStackTop++] = abstractType;
 561         // Updates the maximum size reached by the output stack, if needed (note that this size is
 562         // relative to the input stack size, which is not known yet).
 563         short outputStackSize = (short) (outputStackStart + outputStackTop);
 564         if (outputStackSize &gt; owner.outputStackMax) {
 565             owner.outputStackMax = outputStackSize;
 566         }
 567     }
 568 
 569     /**
 570       * Pushes the abstract type corresponding to the given descriptor on the output frame stack.
 571       *
 572       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
 573       * @param descriptor a type or method descriptor (in which case its return type is pushed).
 574       */
 575     private void push(final SymbolTable symbolTable, final String descriptor) {
<span class="line-modified"> 576         int typeDescriptorOffset = descriptor.charAt(0) == &#39;(&#39; ? descriptor.indexOf(&#39;)&#39;) + 1 : 0;</span>

 577         int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);
 578         if (abstractType != 0) {
 579             push(abstractType);
 580             if (abstractType == LONG || abstractType == DOUBLE) {
 581                 push(TOP);
 582             }
 583         }
 584     }
 585 
 586     /**
 587       * Pops an abstract type from the output frame stack and returns its value.
 588       *
 589       * @return the abstract type that has been popped from the output frame stack.
 590       */
 591     private int pop() {
 592         if (outputStackTop &gt; 0) {
 593             return outputStack[--outputStackTop];
 594         } else {
 595             // If the output frame stack is empty, pop from the input stack.
 596             return STACK_KIND | -(--outputStackStart);
</pre>
<hr />
<pre>
1119                 pop();
1120                 if (castType.charAt(0) == &#39;[&#39;) {
1121                     push(symbolTable, castType);
1122                 } else {
1123                     push(REFERENCE_KIND | symbolTable.addType(castType));
1124                 }
1125                 break;
1126             case Opcodes.MULTIANEWARRAY:
1127                 pop(arg);
1128                 push(symbolTable, argSymbol.value);
1129                 break;
1130             default:
1131                 throw new IllegalArgumentException();
1132         }
1133     }
1134 
1135     // -----------------------------------------------------------------------------------------------
1136     // Frame merging methods, used in the second step of the stack map frame computation algorithm
1137     // -----------------------------------------------------------------------------------------------
1138 




































1139     /**
1140       * Merges the input frame of the given {@link Frame} with the input and output frames of this
1141       * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation
1142       * (the input and output frames of this {@link Frame} are never changed).
1143       *
1144       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
1145       * @param dstFrame the {@link Frame} whose input frame must be updated. This should be the frame
1146       *     of a successor, in the control flow graph, of the basic block corresponding to this frame.
1147       * @param catchTypeIndex if &#39;frame&#39; corresponds to an exception handler basic block, the type
1148       *     table index of the caught exception type, otherwise 0.
1149       * @return {@literal true} if the input frame of &#39;frame&#39; has been changed by this operation.
1150       */
1151     final boolean merge(
1152             final SymbolTable symbolTable, final Frame dstFrame, final int catchTypeIndex) {
1153         boolean frameChanged = false;
1154 
1155         // Compute the concrete types of the local variables at the end of the basic block corresponding
1156         // to this frame, by resolving its abstract output types, and merge these concrete types with
1157         // those of the local variables in the input frame of dstFrame.
1158         int numLocal = inputLocals.length;
1159         int numStack = inputStack.length;
1160         if (dstFrame.inputLocals == null) {
1161             dstFrame.inputLocals = new int[numLocal];
1162             frameChanged = true;
1163         }
1164         for (int i = 0; i &lt; numLocal; ++i) {
1165             int concreteOutputType;
1166             if (outputLocals != null &amp;&amp; i &lt; outputLocals.length) {
1167                 int abstractOutputType = outputLocals[i];
1168                 if (abstractOutputType == 0) {
1169                     // If the local variable has never been assigned in this basic block, it is equal to its
1170                     // value at the beginning of the block.
1171                     concreteOutputType = inputLocals[i];
1172                 } else {
<span class="line-modified">1173                     int dim = abstractOutputType &amp; DIM_MASK;</span>
<span class="line-removed">1174                     int kind = abstractOutputType &amp; KIND_MASK;</span>
<span class="line-removed">1175                     if (kind == LOCAL_KIND) {</span>
<span class="line-removed">1176                         // By definition, a LOCAL_KIND type designates the concrete type of a local variable at</span>
<span class="line-removed">1177                         // the beginning of the basic block corresponding to this frame (which is known when</span>
<span class="line-removed">1178                         // this method is called, but was not when the abstract type was computed).</span>
<span class="line-removed">1179                         concreteOutputType = dim + inputLocals[abstractOutputType &amp; VALUE_MASK];</span>
<span class="line-removed">1180                         if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</span>
<span class="line-removed">1181                                 &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {</span>
<span class="line-removed">1182                             concreteOutputType = TOP;</span>
<span class="line-removed">1183                         }</span>
<span class="line-removed">1184                     } else if (kind == STACK_KIND) {</span>
<span class="line-removed">1185                         // By definition, a STACK_KIND type designates the concrete type of a local variable at</span>
<span class="line-removed">1186                         // the beginning of the basic block corresponding to this frame (which is known when</span>
<span class="line-removed">1187                         // this method is called, but was not when the abstract type was computed).</span>
<span class="line-removed">1188                         concreteOutputType = dim + inputStack[numStack - (abstractOutputType &amp; VALUE_MASK)];</span>
<span class="line-removed">1189                         if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</span>
<span class="line-removed">1190                                 &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {</span>
<span class="line-removed">1191                             concreteOutputType = TOP;</span>
<span class="line-removed">1192                         }</span>
<span class="line-removed">1193                     } else {</span>
<span class="line-removed">1194                         concreteOutputType = abstractOutputType;</span>
<span class="line-removed">1195                     }</span>
1196                 }
1197             } else {
1198                 // If the local variable has never been assigned in this basic block, it is equal to its
1199                 // value at the beginning of the block.
1200                 concreteOutputType = inputLocals[i];
1201             }
1202             // concreteOutputType might be an uninitialized type from the input locals or from the input
1203             // stack. However, if a constructor has been called for this class type in the basic block,
1204             // then this type is no longer uninitialized at the end of basic block.
1205             if (initializations != null) {
1206                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
1207             }
1208             frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);
1209         }
1210 
1211         // If dstFrame is an exception handler block, it can be reached from any instruction of the
1212         // basic block corresponding to this frame, in particular from the first one. Therefore, the
1213         // input locals of dstFrame should be compatible (i.e. merged) with the input locals of this
1214         // frame (and the input stack of dstFrame should be compatible, i.e. merged, with a one
1215         // element stack containing the caught exception type).
</pre>
<hr />
<pre>
1229         // to this frame, by resolving its abstract output types, and merge these concrete types with
1230         // those of the stack operands in the input frame of dstFrame.
1231         int numInputStack = inputStack.length + outputStackStart;
1232         if (dstFrame.inputStack == null) {
1233             dstFrame.inputStack = new int[numInputStack + outputStackTop];
1234             frameChanged = true;
1235         }
1236         // First, do this for the stack operands that have not been popped in the basic block
1237         // corresponding to this frame, and which are therefore equal to their value in the input
1238         // frame (except for uninitialized types, which may have been initialized).
1239         for (int i = 0; i &lt; numInputStack; ++i) {
1240             int concreteOutputType = inputStack[i];
1241             if (initializations != null) {
1242                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
1243             }
1244             frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);
1245         }
1246         // Then, do this for the stack operands that have pushed in the basic block (this code is the
1247         // same as the one above for local variables).
1248         for (int i = 0; i &lt; outputStackTop; ++i) {
<span class="line-modified">1249             int concreteOutputType;</span>
<span class="line-removed">1250             int abstractOutputType = outputStack[i];</span>
<span class="line-removed">1251             int dim = abstractOutputType &amp; DIM_MASK;</span>
<span class="line-removed">1252             int kind = abstractOutputType &amp; KIND_MASK;</span>
<span class="line-removed">1253             if (kind == LOCAL_KIND) {</span>
<span class="line-removed">1254                 concreteOutputType = dim + inputLocals[abstractOutputType &amp; VALUE_MASK];</span>
<span class="line-removed">1255                 if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</span>
<span class="line-removed">1256                         &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {</span>
<span class="line-removed">1257                     concreteOutputType = TOP;</span>
<span class="line-removed">1258                 }</span>
<span class="line-removed">1259             } else if (kind == STACK_KIND) {</span>
<span class="line-removed">1260                 concreteOutputType = dim + inputStack[numStack - (abstractOutputType &amp; VALUE_MASK)];</span>
<span class="line-removed">1261                 if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</span>
<span class="line-removed">1262                         &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {</span>
<span class="line-removed">1263                     concreteOutputType = TOP;</span>
<span class="line-removed">1264                 }</span>
<span class="line-removed">1265             } else {</span>
<span class="line-removed">1266                 concreteOutputType = abstractOutputType;</span>
1267             }
1268             if (initializations != null) {
1269                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
1270             }
1271             frameChanged |=
1272                     merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);
1273         }
1274         return frameChanged;
1275     }
1276 
1277     /**
1278       * Merges the type at the given index in the given abstract type array with the given type.
1279       * Returns {@literal true} if the type array has been modified by this operation.
1280       *
1281       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
1282       * @param sourceType the abstract type with which the abstract type array element must be merged.
1283       *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link
<span class="line-modified">1284       *     #UNINITIALIZED_KIND} kind, with positive or null array dimensions.</span>
1285       * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},
<span class="line-modified">1286       *     {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or null array</span>
<span class="line-modified">1287       *     dimensions.</span>
1288       * @param dstIndex the index of the type that must be merged in dstTypes.
1289       * @return {@literal true} if the type array has been modified by this operation.
1290       */
1291     private static boolean merge(
1292             final SymbolTable symbolTable,
1293             final int sourceType,
1294             final int[] dstTypes,
1295             final int dstIndex) {
1296         int dstType = dstTypes[dstIndex];
1297         if (dstType == sourceType) {
1298             // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.
1299             return false;
1300         }
1301         int srcType = sourceType;
1302         if ((sourceType &amp; ~DIM_MASK) == NULL) {
1303             if (dstType == NULL) {
1304                 return false;
1305             }
1306             srcType = NULL;
1307         }
</pre>
</td>
<td>
<hr />
<pre>
  68  *       the current basic block is updated by simulating the action of the instruction on the
  69  *       previous state of this so called &quot;output frame&quot;.
  70  *   &lt;li&gt;After all instructions have been visited, a fix point algorithm is used in MethodWriter to
  71  *       compute the &quot;input frame&quot; of each basic block (i.e. the stack map frame at the beginning of
  72  *       the basic block). See {@link MethodWriter#computeAllFrames}.
  73  * &lt;/ul&gt;
  74  *
  75  * &lt;p&gt;Output stack map frames are computed relatively to the input frame of the basic block, which
  76  * is not yet known when output frames are computed. It is therefore necessary to be able to
  77  * represent abstract types such as &quot;the type at position x in the input frame locals&quot; or &quot;the type
  78  * at position x from the top of the input frame stack&quot; or even &quot;the type at position x in the input
  79  * frame, with y more (or less) array dimensions&quot;. This explains the rather complicated type format
  80  * used in this class, explained below.
  81  *
  82  * &lt;p&gt;The local variables and the operand stack of input and output frames contain values called
  83  * &quot;abstract types&quot; hereafter. An abstract type is represented with 4 fields named DIM, KIND, FLAGS
  84  * and VALUE, packed in a single int value for better performance and memory efficiency:
  85  *
  86  * &lt;pre&gt;
  87  *   =====================================
<span class="line-modified">  88  *   |...DIM|KIND|.F|...............VALUE|</span>
  89  *   =====================================
  90  * &lt;/pre&gt;
  91  *
  92  * &lt;ul&gt;
<span class="line-modified">  93  *   &lt;li&gt;the DIM field, stored in the 6 most significant bits, is a signed number of array</span>
<span class="line-modified">  94  *       dimensions (from -32 to 31, included). It can be retrieved with {@link #DIM_MASK} and a</span>
<span class="line-modified">  95  *       right shift of {@link #DIM_SHIFT}.</span>
  96  *   &lt;li&gt;the KIND field, stored in 4 bits, indicates the kind of VALUE used. These 4 bits can be
  97  *       retrieved with {@link #KIND_MASK} and, without any shift, must be equal to {@link
  98  *       #CONSTANT_KIND}, {@link #REFERENCE_KIND}, {@link #UNINITIALIZED_KIND}, {@link #LOCAL_KIND}
  99  *       or {@link #STACK_KIND}.
<span class="line-modified"> 100  *   &lt;li&gt;the FLAGS field, stored in 2 bits, contains up to 2 boolean flags. Currently only one flag</span>
 101  *       is defined, namely {@link #TOP_IF_LONG_OR_DOUBLE_FLAG}.
 102  *   &lt;li&gt;the VALUE field, stored in the remaining 20 bits, contains either
 103  *       &lt;ul&gt;
 104  *         &lt;li&gt;one of the constants {@link #ITEM_TOP}, {@link #ITEM_ASM_BOOLEAN}, {@link
 105  *             #ITEM_ASM_BYTE}, {@link #ITEM_ASM_CHAR} or {@link #ITEM_ASM_SHORT}, {@link
 106  *             #ITEM_INTEGER}, {@link #ITEM_FLOAT}, {@link #ITEM_LONG}, {@link #ITEM_DOUBLE}, {@link
 107  *             #ITEM_NULL} or {@link #ITEM_UNINITIALIZED_THIS}, if KIND is equal to {@link
 108  *             #CONSTANT_KIND}.
 109  *         &lt;li&gt;the index of a {@link Symbol#TYPE_TAG} {@link Symbol} in the type table of a {@link
 110  *             SymbolTable}, if KIND is equal to {@link #REFERENCE_KIND}.
 111  *         &lt;li&gt;the index of an {@link Symbol#UNINITIALIZED_TYPE_TAG} {@link Symbol} in the type
 112  *             table of a SymbolTable, if KIND is equal to {@link #UNINITIALIZED_KIND}.
 113  *         &lt;li&gt;the index of a local variable in the input stack frame, if KIND is equal to {@link
 114  *             #LOCAL_KIND}.
 115  *         &lt;li&gt;a position relatively to the top of the stack of the input stack frame, if KIND is
 116  *             equal to {@link #STACK_KIND},
 117  *       &lt;/ul&gt;
 118  * &lt;/ul&gt;
 119  *
 120  * &lt;p&gt;Output frames can contain abstract types of any kind and with a positive or negative array
 121  * dimension (and even unassigned types, represented by 0 - which does not correspond to any valid
 122  * abstract type value). Input frames can only contain CONSTANT_KIND, REFERENCE_KIND or
<span class="line-modified"> 123  * UNINITIALIZED_KIND abstract types of positive or {@literal null} array dimension. In all cases</span>
<span class="line-modified"> 124  * the type table contains only internal type names (array type descriptors are forbidden - array</span>
<span class="line-modified"> 125  * dimensions must be represented through the DIM field).</span>
 126  *
 127  * &lt;p&gt;The LONG and DOUBLE types are always represented by using two slots (LONG + TOP or DOUBLE +
 128  * TOP), for local variables as well as in the operand stack. This is necessary to be able to
 129  * simulate DUPx_y instructions, whose effect would be dependent on the concrete types represented
 130  * by the abstract types in the stack (which are not always known).
 131  *
 132  * @author Eric Bruneton
 133  */
 134 class Frame {
 135 
 136     // Constants used in the StackMapTable attribute.
 137     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.4.
 138 
 139     static final int SAME_FRAME = 0;
 140     static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;
 141     static final int RESERVED = 128;
 142     static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;
 143     static final int CHOP_FRAME = 248;
 144     static final int SAME_FRAME_EXTENDED = 251;
 145     static final int APPEND_FRAME = 252;
 146     static final int FULL_FRAME = 255;
 147 
 148     static final int ITEM_TOP = 0;
 149     static final int ITEM_INTEGER = 1;
 150     static final int ITEM_FLOAT = 2;
 151     static final int ITEM_DOUBLE = 3;
 152     static final int ITEM_LONG = 4;
 153     static final int ITEM_NULL = 5;
 154     static final int ITEM_UNINITIALIZED_THIS = 6;
 155     static final int ITEM_OBJECT = 7;
 156     static final int ITEM_UNINITIALIZED = 8;
 157     // Additional, ASM specific constants used in abstract types below.
 158     private static final int ITEM_ASM_BOOLEAN = 9;
 159     private static final int ITEM_ASM_BYTE = 10;
 160     private static final int ITEM_ASM_CHAR = 11;
 161     private static final int ITEM_ASM_SHORT = 12;
 162 
<span class="line-added"> 163     // The size and offset in bits of each field of an abstract type.</span>
<span class="line-added"> 164 </span>
<span class="line-added"> 165     private static final int DIM_SIZE = 6;</span>
<span class="line-added"> 166     private static final int KIND_SIZE = 4;</span>
<span class="line-added"> 167     private static final int FLAGS_SIZE = 2;</span>
<span class="line-added"> 168     private static final int VALUE_SIZE = 32 - DIM_SIZE - KIND_SIZE - FLAGS_SIZE;</span>
<span class="line-added"> 169 </span>
<span class="line-added"> 170     private static final int DIM_SHIFT = KIND_SIZE + FLAGS_SIZE + VALUE_SIZE;</span>
<span class="line-added"> 171     private static final int KIND_SHIFT = FLAGS_SIZE + VALUE_SIZE;</span>
<span class="line-added"> 172     private static final int FLAGS_SHIFT = VALUE_SIZE;</span>
<span class="line-added"> 173 </span>
 174     // Bitmasks to get each field of an abstract type.
 175 
<span class="line-modified"> 176     private static final int DIM_MASK = ((1 &lt;&lt; DIM_SIZE) - 1) &lt;&lt; DIM_SHIFT;</span>
<span class="line-modified"> 177     private static final int KIND_MASK = ((1 &lt;&lt; KIND_SIZE) - 1) &lt;&lt; KIND_SHIFT;</span>
<span class="line-modified"> 178     private static final int VALUE_MASK = (1 &lt;&lt; VALUE_SIZE) - 1;</span>

 179 
 180     // Constants to manipulate the DIM field of an abstract type.
 181 



 182     /** The constant to be added to an abstract type to get one with one more array dimension. */
 183     private static final int ARRAY_OF = +1 &lt;&lt; DIM_SHIFT;
 184 
 185     /** The constant to be added to an abstract type to get one with one less array dimension. */
 186     private static final int ELEMENT_OF = -1 &lt;&lt; DIM_SHIFT;
 187 
 188     // Possible values for the KIND field of an abstract type.
 189 
<span class="line-modified"> 190     private static final int CONSTANT_KIND = 1 &lt;&lt; KIND_SHIFT;</span>
<span class="line-modified"> 191     private static final int REFERENCE_KIND = 2 &lt;&lt; KIND_SHIFT;</span>
<span class="line-modified"> 192     private static final int UNINITIALIZED_KIND = 3 &lt;&lt; KIND_SHIFT;</span>
<span class="line-modified"> 193     private static final int LOCAL_KIND = 4 &lt;&lt; KIND_SHIFT;</span>
<span class="line-modified"> 194     private static final int STACK_KIND = 5 &lt;&lt; KIND_SHIFT;</span>
 195 
 196     // Possible flags for the FLAGS field of an abstract type.
 197 
 198     /**
 199       * A flag used for LOCAL_KIND and STACK_KIND abstract types, indicating that if the resolved,
 200       * concrete type is LONG or DOUBLE, TOP should be used instead (because the value has been
 201       * partially overridden with an xSTORE instruction).
 202       */
<span class="line-modified"> 203     private static final int TOP_IF_LONG_OR_DOUBLE_FLAG = 1 &lt;&lt; FLAGS_SHIFT;</span>
 204 
 205     // Useful predefined abstract types (all the possible CONSTANT_KIND types).
 206 
 207     private static final int TOP = CONSTANT_KIND | ITEM_TOP;
 208     private static final int BOOLEAN = CONSTANT_KIND | ITEM_ASM_BOOLEAN;
 209     private static final int BYTE = CONSTANT_KIND | ITEM_ASM_BYTE;
 210     private static final int CHAR = CONSTANT_KIND | ITEM_ASM_CHAR;
 211     private static final int SHORT = CONSTANT_KIND | ITEM_ASM_SHORT;
 212     private static final int INTEGER = CONSTANT_KIND | ITEM_INTEGER;
 213     private static final int FLOAT = CONSTANT_KIND | ITEM_FLOAT;
 214     private static final int LONG = CONSTANT_KIND | ITEM_LONG;
 215     private static final int DOUBLE = CONSTANT_KIND | ITEM_DOUBLE;
 216     private static final int NULL = CONSTANT_KIND | ITEM_NULL;
 217     private static final int UNINITIALIZED_THIS = CONSTANT_KIND | ITEM_UNINITIALIZED_THIS;
 218 
 219     // -----------------------------------------------------------------------------------------------
 220     // Instance fields
 221     // -----------------------------------------------------------------------------------------------
 222 
 223     /** The basic block to which these input and output stack map frames correspond. */
</pre>
<hr />
<pre>
 563             System.arraycopy(outputStack, 0, newOutputStack, 0, outputStackLength);
 564             outputStack = newOutputStack;
 565         }
 566         // Pushes the abstract type on the output stack.
 567         outputStack[outputStackTop++] = abstractType;
 568         // Updates the maximum size reached by the output stack, if needed (note that this size is
 569         // relative to the input stack size, which is not known yet).
 570         short outputStackSize = (short) (outputStackStart + outputStackTop);
 571         if (outputStackSize &gt; owner.outputStackMax) {
 572             owner.outputStackMax = outputStackSize;
 573         }
 574     }
 575 
 576     /**
 577       * Pushes the abstract type corresponding to the given descriptor on the output frame stack.
 578       *
 579       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
 580       * @param descriptor a type or method descriptor (in which case its return type is pushed).
 581       */
 582     private void push(final SymbolTable symbolTable, final String descriptor) {
<span class="line-modified"> 583         int typeDescriptorOffset =</span>
<span class="line-added"> 584                 descriptor.charAt(0) == &#39;(&#39; ? Type.getReturnTypeOffset(descriptor) : 0;</span>
 585         int abstractType = getAbstractTypeFromDescriptor(symbolTable, descriptor, typeDescriptorOffset);
 586         if (abstractType != 0) {
 587             push(abstractType);
 588             if (abstractType == LONG || abstractType == DOUBLE) {
 589                 push(TOP);
 590             }
 591         }
 592     }
 593 
 594     /**
 595       * Pops an abstract type from the output frame stack and returns its value.
 596       *
 597       * @return the abstract type that has been popped from the output frame stack.
 598       */
 599     private int pop() {
 600         if (outputStackTop &gt; 0) {
 601             return outputStack[--outputStackTop];
 602         } else {
 603             // If the output frame stack is empty, pop from the input stack.
 604             return STACK_KIND | -(--outputStackStart);
</pre>
<hr />
<pre>
1127                 pop();
1128                 if (castType.charAt(0) == &#39;[&#39;) {
1129                     push(symbolTable, castType);
1130                 } else {
1131                     push(REFERENCE_KIND | symbolTable.addType(castType));
1132                 }
1133                 break;
1134             case Opcodes.MULTIANEWARRAY:
1135                 pop(arg);
1136                 push(symbolTable, argSymbol.value);
1137                 break;
1138             default:
1139                 throw new IllegalArgumentException();
1140         }
1141     }
1142 
1143     // -----------------------------------------------------------------------------------------------
1144     // Frame merging methods, used in the second step of the stack map frame computation algorithm
1145     // -----------------------------------------------------------------------------------------------
1146 
<span class="line-added">1147     /**</span>
<span class="line-added">1148       * Computes the concrete output type corresponding to a given abstract output type.</span>
<span class="line-added">1149       *</span>
<span class="line-added">1150       * @param abstractOutputType an abstract output type.</span>
<span class="line-added">1151       * @param numStack the size of the input stack, used to resolve abstract output types of</span>
<span class="line-added">1152       *     STACK_KIND kind.</span>
<span class="line-added">1153       * @return the concrete output type corresponding to &#39;abstractOutputType&#39;.</span>
<span class="line-added">1154       */</span>
<span class="line-added">1155     private int getConcreteOutputType(final int abstractOutputType, final int numStack) {</span>
<span class="line-added">1156         int dim = abstractOutputType &amp; DIM_MASK;</span>
<span class="line-added">1157         int kind = abstractOutputType &amp; KIND_MASK;</span>
<span class="line-added">1158         if (kind == LOCAL_KIND) {</span>
<span class="line-added">1159             // By definition, a LOCAL_KIND type designates the concrete type of a local variable at</span>
<span class="line-added">1160             // the beginning of the basic block corresponding to this frame (which is known when</span>
<span class="line-added">1161             // this method is called, but was not when the abstract type was computed).</span>
<span class="line-added">1162             int concreteOutputType = dim + inputLocals[abstractOutputType &amp; VALUE_MASK];</span>
<span class="line-added">1163             if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</span>
<span class="line-added">1164                     &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {</span>
<span class="line-added">1165                 concreteOutputType = TOP;</span>
<span class="line-added">1166             }</span>
<span class="line-added">1167             return concreteOutputType;</span>
<span class="line-added">1168         } else if (kind == STACK_KIND) {</span>
<span class="line-added">1169             // By definition, a STACK_KIND type designates the concrete type of a local variable at</span>
<span class="line-added">1170             // the beginning of the basic block corresponding to this frame (which is known when</span>
<span class="line-added">1171             // this method is called, but was not when the abstract type was computed).</span>
<span class="line-added">1172             int concreteOutputType = dim + inputStack[numStack - (abstractOutputType &amp; VALUE_MASK)];</span>
<span class="line-added">1173             if ((abstractOutputType &amp; TOP_IF_LONG_OR_DOUBLE_FLAG) != 0</span>
<span class="line-added">1174                     &amp;&amp; (concreteOutputType == LONG || concreteOutputType == DOUBLE)) {</span>
<span class="line-added">1175                 concreteOutputType = TOP;</span>
<span class="line-added">1176             }</span>
<span class="line-added">1177             return concreteOutputType;</span>
<span class="line-added">1178         } else {</span>
<span class="line-added">1179             return abstractOutputType;</span>
<span class="line-added">1180         }</span>
<span class="line-added">1181     }</span>
<span class="line-added">1182 </span>
1183     /**
1184       * Merges the input frame of the given {@link Frame} with the input and output frames of this
1185       * {@link Frame}. Returns {@literal true} if the given frame has been changed by this operation
1186       * (the input and output frames of this {@link Frame} are never changed).
1187       *
1188       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
1189       * @param dstFrame the {@link Frame} whose input frame must be updated. This should be the frame
1190       *     of a successor, in the control flow graph, of the basic block corresponding to this frame.
1191       * @param catchTypeIndex if &#39;frame&#39; corresponds to an exception handler basic block, the type
1192       *     table index of the caught exception type, otherwise 0.
1193       * @return {@literal true} if the input frame of &#39;frame&#39; has been changed by this operation.
1194       */
1195     final boolean merge(
1196             final SymbolTable symbolTable, final Frame dstFrame, final int catchTypeIndex) {
1197         boolean frameChanged = false;
1198 
1199         // Compute the concrete types of the local variables at the end of the basic block corresponding
1200         // to this frame, by resolving its abstract output types, and merge these concrete types with
1201         // those of the local variables in the input frame of dstFrame.
1202         int numLocal = inputLocals.length;
1203         int numStack = inputStack.length;
1204         if (dstFrame.inputLocals == null) {
1205             dstFrame.inputLocals = new int[numLocal];
1206             frameChanged = true;
1207         }
1208         for (int i = 0; i &lt; numLocal; ++i) {
1209             int concreteOutputType;
1210             if (outputLocals != null &amp;&amp; i &lt; outputLocals.length) {
1211                 int abstractOutputType = outputLocals[i];
1212                 if (abstractOutputType == 0) {
1213                     // If the local variable has never been assigned in this basic block, it is equal to its
1214                     // value at the beginning of the block.
1215                     concreteOutputType = inputLocals[i];
1216                 } else {
<span class="line-modified">1217                     concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);</span>






















1218                 }
1219             } else {
1220                 // If the local variable has never been assigned in this basic block, it is equal to its
1221                 // value at the beginning of the block.
1222                 concreteOutputType = inputLocals[i];
1223             }
1224             // concreteOutputType might be an uninitialized type from the input locals or from the input
1225             // stack. However, if a constructor has been called for this class type in the basic block,
1226             // then this type is no longer uninitialized at the end of basic block.
1227             if (initializations != null) {
1228                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
1229             }
1230             frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputLocals, i);
1231         }
1232 
1233         // If dstFrame is an exception handler block, it can be reached from any instruction of the
1234         // basic block corresponding to this frame, in particular from the first one. Therefore, the
1235         // input locals of dstFrame should be compatible (i.e. merged) with the input locals of this
1236         // frame (and the input stack of dstFrame should be compatible, i.e. merged, with a one
1237         // element stack containing the caught exception type).
</pre>
<hr />
<pre>
1251         // to this frame, by resolving its abstract output types, and merge these concrete types with
1252         // those of the stack operands in the input frame of dstFrame.
1253         int numInputStack = inputStack.length + outputStackStart;
1254         if (dstFrame.inputStack == null) {
1255             dstFrame.inputStack = new int[numInputStack + outputStackTop];
1256             frameChanged = true;
1257         }
1258         // First, do this for the stack operands that have not been popped in the basic block
1259         // corresponding to this frame, and which are therefore equal to their value in the input
1260         // frame (except for uninitialized types, which may have been initialized).
1261         for (int i = 0; i &lt; numInputStack; ++i) {
1262             int concreteOutputType = inputStack[i];
1263             if (initializations != null) {
1264                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
1265             }
1266             frameChanged |= merge(symbolTable, concreteOutputType, dstFrame.inputStack, i);
1267         }
1268         // Then, do this for the stack operands that have pushed in the basic block (this code is the
1269         // same as the one above for local variables).
1270         for (int i = 0; i &lt; outputStackTop; ++i) {
<span class="line-modified">1271             int abstractOutputType = outputStack[i];</span>

















1272             int concreteOutputType = getConcreteOutputType(abstractOutputType, numStack);
1273             if (initializations != null) {
1274                 concreteOutputType = getInitializedType(symbolTable, concreteOutputType);
1275             }
1276             frameChanged |=
1277                     merge(symbolTable, concreteOutputType, dstFrame.inputStack, numInputStack + i);
1278         }
1279         return frameChanged;
1280     }
1281 
1282     /**
1283       * Merges the type at the given index in the given abstract type array with the given type.
1284       * Returns {@literal true} if the type array has been modified by this operation.
1285       *
1286       * @param symbolTable the type table to use to lookup and store type {@link Symbol}.
1287       * @param sourceType the abstract type with which the abstract type array element must be merged.
1288       *     This type should be of {@link #CONSTANT_KIND}, {@link #REFERENCE_KIND} or {@link
<span class="line-modified">1289       *     #UNINITIALIZED_KIND} kind, with positive or {@literal null} array dimensions.</span>
1290       * @param dstTypes an array of abstract types. These types should be of {@link #CONSTANT_KIND},
<span class="line-modified">1291       *     {@link #REFERENCE_KIND} or {@link #UNINITIALIZED_KIND} kind, with positive or {@literal</span>
<span class="line-modified">1292       *     null} array dimensions.</span>
1293       * @param dstIndex the index of the type that must be merged in dstTypes.
1294       * @return {@literal true} if the type array has been modified by this operation.
1295       */
1296     private static boolean merge(
1297             final SymbolTable symbolTable,
1298             final int sourceType,
1299             final int[] dstTypes,
1300             final int dstIndex) {
1301         int dstType = dstTypes[dstIndex];
1302         if (dstType == sourceType) {
1303             // If the types are equal, merge(sourceType, dstType) = dstType, so there is no change.
1304             return false;
1305         }
1306         int srcType = sourceType;
1307         if ((sourceType &amp; ~DIM_MASK) == NULL) {
1308             if (dstType == NULL) {
1309                 return false;
1310             }
1311             srcType = NULL;
1312         }
</pre>
</td>
</tr>
</table>
<center><a href="Constants.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Opcodes.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckClassAdapter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /*
  26  * This file is available under and governed by the GNU General Public
  27  * License version 2 only, as published by the Free Software Foundation.
  28  * However, the following notice accompanied the original version of this
  29  * file:
  30  *
  31  * ASM: a very small and fast Java bytecode manipulation framework
  32  * Copyright (c) 2000-2011 INRIA, France Telecom
  33  * All rights reserved.
  34  *
  35  * Redistribution and use in source and binary forms, with or without
  36  * modification, are permitted provided that the following conditions
  37  * are met:
  38  * 1. Redistributions of source code must retain the above copyright
  39  *    notice, this list of conditions and the following disclaimer.
  40  * 2. Redistributions in binary form must reproduce the above copyright
  41  *    notice, this list of conditions and the following disclaimer in the
  42  *    documentation and/or other materials provided with the distribution.
  43  * 3. Neither the name of the copyright holders nor the names of its
  44  *    contributors may be used to endorse or promote products derived from
  45  *    this software without specific prior written permission.
  46  *
  47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  57  * THE POSSIBILITY OF SUCH DAMAGE.
  58  */
  59 package jdk.internal.org.objectweb.asm.util;
  60 
  61 import java.io.FileInputStream;
  62 import java.io.IOException;
  63 import java.io.InputStream;
  64 import java.io.PrintWriter;
  65 import java.util.ArrayList;
  66 import java.util.HashMap;
  67 import java.util.List;
  68 import java.util.Map;
  69 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  70 import jdk.internal.org.objectweb.asm.Attribute;
  71 import jdk.internal.org.objectweb.asm.ClassReader;
  72 import jdk.internal.org.objectweb.asm.ClassVisitor;
  73 import jdk.internal.org.objectweb.asm.FieldVisitor;
  74 import jdk.internal.org.objectweb.asm.Label;
  75 import jdk.internal.org.objectweb.asm.MethodVisitor;
  76 import jdk.internal.org.objectweb.asm.ModuleVisitor;
  77 import jdk.internal.org.objectweb.asm.Opcodes;
<a name="1" id="anc1"></a><span class="line-added">  78 import jdk.internal.org.objectweb.asm.RecordComponentVisitor;</span>
  79 import jdk.internal.org.objectweb.asm.Type;
  80 import jdk.internal.org.objectweb.asm.TypePath;
  81 import jdk.internal.org.objectweb.asm.TypeReference;
  82 import jdk.internal.org.objectweb.asm.tree.ClassNode;
  83 import jdk.internal.org.objectweb.asm.tree.MethodNode;
  84 import jdk.internal.org.objectweb.asm.tree.TryCatchBlockNode;
  85 import jdk.internal.org.objectweb.asm.tree.analysis.Analyzer;
  86 import jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException;
  87 import jdk.internal.org.objectweb.asm.tree.analysis.BasicValue;
  88 import jdk.internal.org.objectweb.asm.tree.analysis.Frame;
  89 import jdk.internal.org.objectweb.asm.tree.analysis.SimpleVerifier;
  90 
  91 /**
  92  * A {@link ClassVisitor} that checks that its methods are properly used. More precisely this class
  93  * adapter checks each method call individually, based &lt;i&gt;only&lt;/i&gt; on its arguments, but does
  94  * &lt;i&gt;not&lt;/i&gt; check the &lt;i&gt;sequence&lt;/i&gt; of method calls. For example, the invalid sequence {@code
  95  * visitField(ACC_PUBLIC, &quot;i&quot;, &quot;I&quot;, null)} {@code visitField(ACC_PUBLIC, &quot;i&quot;, &quot;D&quot;, null)} will
  96  * &lt;i&gt;not&lt;/i&gt; be detected by this class adapter.
  97  *
  98  * &lt;p&gt;&lt;code&gt;CheckClassAdapter&lt;/code&gt; can be also used to verify bytecode transformations in order to
  99  * make sure that the transformed bytecode is sane. For example:
 100  *
 101  * &lt;pre&gt;
 102  * InputStream inputStream = ...; // get bytes for the source class
 103  * ClassReader classReader = new ClassReader(inputStream);
 104  * ClassWriter classWriter = new ClassWriter(classReader, ClassWriter.COMPUTE_MAXS);
 105  * ClassVisitor classVisitor = new &lt;b&gt;MyClassAdapter&lt;/b&gt;(new CheckClassAdapter(classWriter, true));
 106  * classReader.accept(classVisitor, 0);
 107  *
 108  * StringWriter stringWriter = new StringWriter();
 109  * PrintWriter printWriter = new PrintWriter(stringWriter);
 110  * CheckClassAdapter.verify(new ClassReader(classWriter.toByteArray()), false, printWriter);
 111  * assertTrue(stringWriter.toString().isEmpty());
 112  * &lt;/pre&gt;
 113  *
 114  * &lt;p&gt;The above code pass the transformed bytecode through a &lt;code&gt;CheckClassAdapter&lt;/code&gt;, with
 115  * data flow checks enabled. These checks are not exactly the same as the JVM verification, but
 116  * provide some basic type checking for each method instruction. If the bytecode has errors, the
 117  * output text shows the erroneous instruction number, and a dump of the failed method with
 118  * information about the type of the local variables and of the operand stack slots for each
 119  * instruction. For example (format is - insnNumber locals : stack):
 120  *
 121  * &lt;pre&gt;
 122  * jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException: Error at instruction 71: Expected I, but found .
 123  *   at jdk.internal.org.objectweb.asm.tree.analysis.Analyzer.analyze(Analyzer.java:...)
 124  *   at jdk.internal.org.objectweb.asm.util.CheckClassAdapter.verify(CheckClassAdapter.java:...)
 125  * ...
 126  * remove()V
 127  * 00000 LinkedBlockingQueue$Itr . . . . . . . .  : ICONST_0
 128  * 00001 LinkedBlockingQueue$Itr . . . . . . . .  : I ISTORE 2
 129  * 00001 LinkedBlockingQueue$Itr &lt;b&gt;.&lt;/b&gt; I . . . . . .  :
 130  * ...
 131  * 00071 LinkedBlockingQueue$Itr &lt;b&gt;.&lt;/b&gt; I . . . . . .  : ILOAD 1
 132  * 00072 &lt;b&gt;?&lt;/b&gt; INVOKESPECIAL java/lang/Integer.&amp;lt;init&amp;gt; (I)V
 133  * ...
 134  * &lt;/pre&gt;
 135  *
 136  * &lt;p&gt;The above output shows that the local variable 1, loaded by the &lt;code&gt;ILOAD 1&lt;/code&gt;
 137  * instruction at position &lt;code&gt;00071&lt;/code&gt; is not initialized, whereas the local variable 2 is
 138  * initialized and contains an int value.
 139  *
 140  * @author Eric Bruneton
 141  */
 142 public class CheckClassAdapter extends ClassVisitor {
 143 
<a name="2" id="anc2"></a><span class="line-added"> 144     /** The help message shown when command line arguments are incorrect. */</span>
<span class="line-added"> 145     private static final String USAGE =</span>
<span class="line-added"> 146             &quot;Verifies the given class.\n&quot;</span>
<span class="line-added"> 147                     + &quot;Usage: CheckClassAdapter &lt;fully qualified class name or class file name&gt;&quot;;</span>
<span class="line-added"> 148 </span>
 149     private static final String ERROR_AT = &quot;: error at index &quot;;
 150 
 151     /** Whether the bytecode must be checked with a BasicVerifier. */
 152     private boolean checkDataFlow;
 153 
 154     /** The class version number. */
 155     private int version;
 156 
 157     /** Whether the {@link #visit} method has been called. */
 158     private boolean visitCalled;
 159 
 160     /** Whether the {@link #visitModule} method has been called. */
 161     private boolean visitModuleCalled;
 162 
 163     /** Whether the {@link #visitSource} method has been called. */
 164     private boolean visitSourceCalled;
 165 
 166     /** Whether the {@link #visitOuterClass} method has been called. */
 167     private boolean visitOuterClassCalled;
 168 
 169     /** Whether the {@link #visitNestHost} method has been called. */
 170     private boolean visitNestHostCalled;
 171 
 172     /**
 173       * The common package of all the nest members. Not {@literal null} if the visitNestMember method
 174       * has been called.
 175       */
 176     private String nestMemberPackageName;
 177 
 178     /** Whether the {@link #visitEnd} method has been called. */
 179     private boolean visitEndCalled;
 180 
 181     /** The index of the instruction designated by each visited label so far. */
 182     private Map&lt;Label, Integer&gt; labelInsnIndices;
 183 
 184     // -----------------------------------------------------------------------------------------------
 185     // Constructors
 186     // -----------------------------------------------------------------------------------------------
 187 
 188     /**
 189       * Constructs a new {@link CheckClassAdapter}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;.
 190       * Instead, they must use the {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
 191       *
 192       * @param classVisitor the class visitor to which this adapter must delegate calls.
 193       */
 194     public CheckClassAdapter(final ClassVisitor classVisitor) {
 195         this(classVisitor, true);
 196     }
 197 
 198     /**
 199       * Constructs a new {@link CheckClassAdapter}. &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;.
 200       * Instead, they must use the {@link #CheckClassAdapter(int, ClassVisitor, boolean)} version.
 201       *
 202       * @param classVisitor the class visitor to which this adapter must delegate calls.
 203       * @param checkDataFlow whether to perform basic data flow checks. This option requires valid
 204       *     maxLocals and maxStack values.
 205       * @throws IllegalStateException If a subclass calls this constructor.
 206       */
 207     public CheckClassAdapter(final ClassVisitor classVisitor, final boolean checkDataFlow) {
<a name="3" id="anc3"></a><span class="line-modified"> 208         this(/* latest api = */ Opcodes.ASM8, classVisitor, checkDataFlow);</span>
 209         if (getClass() != CheckClassAdapter.class) {
 210             throw new IllegalStateException();
 211         }
 212     }
 213 
 214     /**
 215       * Constructs a new {@link CheckClassAdapter}.
 216       *
 217       * @param api the ASM API version implemented by this visitor. Must be one of {@link
<a name="4" id="anc4"></a><span class="line-modified"> 218       *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link</span>
<span class="line-added"> 219       *     Opcodes#ASM8}.</span>
 220       * @param classVisitor the class visitor to which this adapter must delegate calls.
 221       * @param checkDataFlow {@literal true} to perform basic data flow checks, or {@literal false} to
 222       *     not perform any data flow check (see {@link CheckMethodAdapter}). This option requires
 223       *     valid maxLocals and maxStack values.
 224       */
 225     protected CheckClassAdapter(
 226             final int api, final ClassVisitor classVisitor, final boolean checkDataFlow) {
 227         super(api, classVisitor);
<a name="5" id="anc5"></a><span class="line-modified"> 228         this.labelInsnIndices = new HashMap&lt;&gt;();</span>
 229         this.checkDataFlow = checkDataFlow;
 230     }
 231 
 232     // -----------------------------------------------------------------------------------------------
 233     // Implementation of the ClassVisitor interface
 234     // -----------------------------------------------------------------------------------------------
 235 
 236     @Override
 237     public void visit(
 238             final int version,
 239             final int access,
 240             final String name,
 241             final String signature,
 242             final String superName,
 243             final String[] interfaces) {
 244         if (visitCalled) {
 245             throw new IllegalStateException(&quot;visit must be called only once&quot;);
 246         }
 247         visitCalled = true;
 248         checkState();
 249         checkAccess(
 250                 access,
 251                 Opcodes.ACC_PUBLIC
 252                         | Opcodes.ACC_FINAL
 253                         | Opcodes.ACC_SUPER
 254                         | Opcodes.ACC_INTERFACE
 255                         | Opcodes.ACC_ABSTRACT
 256                         | Opcodes.ACC_SYNTHETIC
 257                         | Opcodes.ACC_ANNOTATION
 258                         | Opcodes.ACC_ENUM
 259                         | Opcodes.ACC_DEPRECATED
<a name="6" id="anc6"></a><span class="line-added"> 260                         | Opcodes.ACC_RECORD</span>
 261                         | Opcodes.ACC_MODULE);
 262         if (name == null) {
 263             throw new IllegalArgumentException(&quot;Illegal class name (null)&quot;);
 264         }
 265         if (!name.endsWith(&quot;package-info&quot;) &amp;&amp; !name.endsWith(&quot;module-info&quot;)) {
 266             CheckMethodAdapter.checkInternalName(version, name, &quot;class name&quot;);
 267         }
 268         if (&quot;java/lang/Object&quot;.equals(name)) {
 269             if (superName != null) {
 270                 throw new IllegalArgumentException(
 271                         &quot;The super class name of the Object class must be &#39;null&#39;&quot;);
 272             }
 273         } else if (name.endsWith(&quot;module-info&quot;)) {
 274             if (superName != null) {
 275                 throw new IllegalArgumentException(
 276                         &quot;The super class name of a module-info class must be &#39;null&#39;&quot;);
 277             }
 278         } else {
 279             CheckMethodAdapter.checkInternalName(version, superName, &quot;super class name&quot;);
 280         }
 281         if (signature != null) {
 282             checkClassSignature(signature);
 283         }
 284         if ((access &amp; Opcodes.ACC_INTERFACE) != 0 &amp;&amp; !&quot;java/lang/Object&quot;.equals(superName)) {
 285             throw new IllegalArgumentException(
 286                     &quot;The super class name of interfaces must be &#39;java/lang/Object&#39;&quot;);
 287         }
 288         if (interfaces != null) {
 289             for (int i = 0; i &lt; interfaces.length; ++i) {
 290                 CheckMethodAdapter.checkInternalName(
 291                         version, interfaces[i], &quot;interface name at index &quot; + i);
 292             }
 293         }
 294         this.version = version;
 295         super.visit(version, access, name, signature, superName, interfaces);
 296     }
 297 
 298     @Override
 299     public void visitSource(final String file, final String debug) {
 300         checkState();
 301         if (visitSourceCalled) {
 302             throw new IllegalStateException(&quot;visitSource can be called only once.&quot;);
 303         }
 304         visitSourceCalled = true;
 305         super.visitSource(file, debug);
 306     }
 307 
 308     @Override
 309     public ModuleVisitor visitModule(final String name, final int access, final String version) {
 310         checkState();
 311         if (visitModuleCalled) {
 312             throw new IllegalStateException(&quot;visitModule can be called only once.&quot;);
 313         }
 314         visitModuleCalled = true;
 315         checkFullyQualifiedName(this.version, name, &quot;module name&quot;);
 316         checkAccess(access, Opcodes.ACC_OPEN | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_MANDATED);
 317         CheckModuleAdapter checkModuleAdapter =
 318                 new CheckModuleAdapter(
 319                         api, super.visitModule(name, access, version), (access &amp; Opcodes.ACC_OPEN) != 0);
 320         checkModuleAdapter.classVersion = this.version;
 321         return checkModuleAdapter;
 322     }
 323 
 324     @Override
 325     public void visitNestHost(final String nestHost) {
 326         checkState();
 327         CheckMethodAdapter.checkInternalName(version, nestHost, &quot;nestHost&quot;);
 328         if (visitNestHostCalled) {
 329             throw new IllegalStateException(&quot;visitNestHost can be called only once.&quot;);
 330         }
 331         if (nestMemberPackageName != null) {
 332             throw new IllegalStateException(&quot;visitNestHost and visitNestMember are mutually exclusive.&quot;);
 333         }
 334         visitNestHostCalled = true;
 335         super.visitNestHost(nestHost);
 336     }
 337 
 338     @Override
 339     public void visitNestMember(final String nestMember) {
 340         checkState();
 341         CheckMethodAdapter.checkInternalName(version, nestMember, &quot;nestMember&quot;);
 342         if (visitNestHostCalled) {
 343             throw new IllegalStateException(
 344                     &quot;visitMemberOfNest and visitNestHost are mutually exclusive.&quot;);
 345         }
 346         String packageName = packageName(nestMember);
 347         if (nestMemberPackageName == null) {
 348             nestMemberPackageName = packageName;
 349         } else if (!nestMemberPackageName.equals(packageName)) {
 350             throw new IllegalStateException(
 351                     &quot;nest member &quot; + nestMember + &quot; should be in the package &quot; + nestMemberPackageName);
 352         }
 353         super.visitNestMember(nestMember);
 354     }
 355 
<a name="7" id="anc7"></a><span class="line-added"> 356     /**</span>
<span class="line-added"> 357       * &lt;b&gt;Experimental, use at your own risk.&lt;/b&gt;.</span>
<span class="line-added"> 358       *</span>
<span class="line-added"> 359       * @param permittedSubtype the internal name of a permitted subtype.</span>
<span class="line-added"> 360       * @deprecated this API is experimental.</span>
<span class="line-added"> 361       */</span>
<span class="line-added"> 362     @Override</span>
<span class="line-added"> 363     @Deprecated</span>
<span class="line-added"> 364     public void visitPermittedSubtypeExperimental(final String permittedSubtype) {</span>
<span class="line-added"> 365         checkState();</span>
<span class="line-added"> 366         CheckMethodAdapter.checkInternalName(version, permittedSubtype, &quot;permittedSubtype&quot;);</span>
<span class="line-added"> 367         super.visitPermittedSubtypeExperimental(permittedSubtype);</span>
<span class="line-added"> 368     }</span>
<span class="line-added"> 369 </span>
 370     @Override
 371     public void visitOuterClass(final String owner, final String name, final String descriptor) {
 372         checkState();
 373         if (visitOuterClassCalled) {
 374             throw new IllegalStateException(&quot;visitOuterClass can be called only once.&quot;);
 375         }
 376         visitOuterClassCalled = true;
 377         if (owner == null) {
 378             throw new IllegalArgumentException(&quot;Illegal outer class owner&quot;);
 379         }
 380         if (descriptor != null) {
 381             CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
 382         }
 383         super.visitOuterClass(owner, name, descriptor);
 384     }
 385 
 386     @Override
 387     public void visitInnerClass(
 388             final String name, final String outerName, final String innerName, final int access) {
 389         checkState();
 390         CheckMethodAdapter.checkInternalName(version, name, &quot;class name&quot;);
 391         if (outerName != null) {
 392             CheckMethodAdapter.checkInternalName(version, outerName, &quot;outer class name&quot;);
 393         }
 394         if (innerName != null) {
 395             int startIndex = 0;
 396             while (startIndex &lt; innerName.length() &amp;&amp; Character.isDigit(innerName.charAt(startIndex))) {
 397                 startIndex++;
 398             }
 399             if (startIndex == 0 || startIndex &lt; innerName.length()) {
 400                 CheckMethodAdapter.checkIdentifier(version, innerName, startIndex, -1, &quot;inner class name&quot;);
 401             }
 402         }
 403         checkAccess(
 404                 access,
 405                 Opcodes.ACC_PUBLIC
 406                         | Opcodes.ACC_PRIVATE
 407                         | Opcodes.ACC_PROTECTED
 408                         | Opcodes.ACC_STATIC
 409                         | Opcodes.ACC_FINAL
 410                         | Opcodes.ACC_INTERFACE
 411                         | Opcodes.ACC_ABSTRACT
 412                         | Opcodes.ACC_SYNTHETIC
 413                         | Opcodes.ACC_ANNOTATION
 414                         | Opcodes.ACC_ENUM);
 415         super.visitInnerClass(name, outerName, innerName, access);
 416     }
 417 
<a name="8" id="anc8"></a><span class="line-added"> 418     @Override</span>
<span class="line-added"> 419     public RecordComponentVisitor visitRecordComponent(</span>
<span class="line-added"> 420             final String name, final String descriptor, final String signature) {</span>
<span class="line-added"> 421         checkState();</span>
<span class="line-added"> 422         CheckMethodAdapter.checkUnqualifiedName(version, name, &quot;record component name&quot;);</span>
<span class="line-added"> 423         CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid = */ false);</span>
<span class="line-added"> 424         if (signature != null) {</span>
<span class="line-added"> 425             checkFieldSignature(signature);</span>
<span class="line-added"> 426         }</span>
<span class="line-added"> 427         return new CheckRecordComponentAdapter(</span>
<span class="line-added"> 428                 api, super.visitRecordComponent(name, descriptor, signature));</span>
<span class="line-added"> 429     }</span>
<span class="line-added"> 430 </span>
 431     @Override
 432     public FieldVisitor visitField(
 433             final int access,
 434             final String name,
 435             final String descriptor,
 436             final String signature,
 437             final Object value) {
 438         checkState();
 439         checkAccess(
 440                 access,
 441                 Opcodes.ACC_PUBLIC
 442                         | Opcodes.ACC_PRIVATE
 443                         | Opcodes.ACC_PROTECTED
 444                         | Opcodes.ACC_STATIC
 445                         | Opcodes.ACC_FINAL
 446                         | Opcodes.ACC_VOLATILE
 447                         | Opcodes.ACC_TRANSIENT
 448                         | Opcodes.ACC_SYNTHETIC
 449                         | Opcodes.ACC_ENUM
<a name="9" id="anc9"></a><span class="line-added"> 450                         | Opcodes.ACC_MANDATED</span>
 451                         | Opcodes.ACC_DEPRECATED);
 452         CheckMethodAdapter.checkUnqualifiedName(version, name, &quot;field name&quot;);
 453         CheckMethodAdapter.checkDescriptor(version, descriptor, /* canBeVoid = */ false);
 454         if (signature != null) {
 455             checkFieldSignature(signature);
 456         }
 457         if (value != null) {
 458             CheckMethodAdapter.checkConstant(value);
 459         }
 460         return new CheckFieldAdapter(api, super.visitField(access, name, descriptor, signature, value));
 461     }
 462 
 463     @Override
 464     public MethodVisitor visitMethod(
 465             final int access,
 466             final String name,
 467             final String descriptor,
 468             final String signature,
 469             final String[] exceptions) {
 470         checkState();
 471         checkAccess(
 472                 access,
 473                 Opcodes.ACC_PUBLIC
 474                         | Opcodes.ACC_PRIVATE
 475                         | Opcodes.ACC_PROTECTED
 476                         | Opcodes.ACC_STATIC
 477                         | Opcodes.ACC_FINAL
 478                         | Opcodes.ACC_SYNCHRONIZED
 479                         | Opcodes.ACC_BRIDGE
 480                         | Opcodes.ACC_VARARGS
 481                         | Opcodes.ACC_NATIVE
 482                         | Opcodes.ACC_ABSTRACT
 483                         | Opcodes.ACC_STRICT
 484                         | Opcodes.ACC_SYNTHETIC
<a name="10" id="anc10"></a><span class="line-added"> 485                         | Opcodes.ACC_MANDATED</span>
 486                         | Opcodes.ACC_DEPRECATED);
 487         if (!&quot;&lt;init&gt;&quot;.equals(name) &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name)) {
 488             CheckMethodAdapter.checkMethodIdentifier(version, name, &quot;method name&quot;);
 489         }
 490         CheckMethodAdapter.checkMethodDescriptor(version, descriptor);
 491         if (signature != null) {
 492             checkMethodSignature(signature);
 493         }
 494         if (exceptions != null) {
 495             for (int i = 0; i &lt; exceptions.length; ++i) {
 496                 CheckMethodAdapter.checkInternalName(
 497                         version, exceptions[i], &quot;exception name at index &quot; + i);
 498             }
 499         }
 500         CheckMethodAdapter checkMethodAdapter;
 501         if (checkDataFlow) {
 502             checkMethodAdapter =
 503                     new CheckMethodAdapter(
 504                             api,
 505                             access,
 506                             name,
 507                             descriptor,
 508                             super.visitMethod(access, name, descriptor, signature, exceptions),
 509                             labelInsnIndices);
 510         } else {
 511             checkMethodAdapter =
 512                     new CheckMethodAdapter(
 513                             api,
 514                             super.visitMethod(access, name, descriptor, signature, exceptions),
 515                             labelInsnIndices);
 516         }
 517         checkMethodAdapter.version = version;
 518         return checkMethodAdapter;
 519     }
 520 
 521     @Override
 522     public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {
 523         checkState();
 524         CheckMethodAdapter.checkDescriptor(version, descriptor, false);
 525         return new CheckAnnotationAdapter(super.visitAnnotation(descriptor, visible));
 526     }
 527 
 528     @Override
 529     public AnnotationVisitor visitTypeAnnotation(
 530             final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {
 531         checkState();
 532         int sort = new TypeReference(typeRef).getSort();
 533         if (sort != TypeReference.CLASS_TYPE_PARAMETER
 534                 &amp;&amp; sort != TypeReference.CLASS_TYPE_PARAMETER_BOUND
 535                 &amp;&amp; sort != TypeReference.CLASS_EXTENDS) {
 536             throw new IllegalArgumentException(
 537                     &quot;Invalid type reference sort 0x&quot; + Integer.toHexString(sort));
 538         }
 539         checkTypeRef(typeRef);
 540         CheckMethodAdapter.checkDescriptor(version, descriptor, false);
 541         return new CheckAnnotationAdapter(
 542                 super.visitTypeAnnotation(typeRef, typePath, descriptor, visible));
 543     }
 544 
 545     @Override
 546     public void visitAttribute(final Attribute attribute) {
 547         checkState();
 548         if (attribute == null) {
 549             throw new IllegalArgumentException(&quot;Invalid attribute (must not be null)&quot;);
 550         }
 551         super.visitAttribute(attribute);
 552     }
 553 
 554     @Override
 555     public void visitEnd() {
 556         checkState();
 557         visitEndCalled = true;
 558         super.visitEnd();
 559     }
 560 
 561     // -----------------------------------------------------------------------------------------------
 562     // Utility methods
 563     // -----------------------------------------------------------------------------------------------
 564 
 565     /** Checks that the visit method has been called and that visitEnd has not been called. */
 566     private void checkState() {
 567         if (!visitCalled) {
 568             throw new IllegalStateException(&quot;Cannot visit member before visit has been called.&quot;);
 569         }
 570         if (visitEndCalled) {
 571             throw new IllegalStateException(&quot;Cannot visit member after visitEnd has been called.&quot;);
 572         }
 573     }
 574 
 575     /**
 576       * Checks that the given access flags do not contain invalid flags. This method also checks that
 577       * mutually incompatible flags are not set simultaneously.
 578       *
 579       * @param access the access flags to be checked.
 580       * @param possibleAccess the valid access flags.
 581       */
 582     static void checkAccess(final int access, final int possibleAccess) {
 583         if ((access &amp; ~possibleAccess) != 0) {
 584             throw new IllegalArgumentException(&quot;Invalid access flags: &quot; + access);
 585         }
 586         int publicProtectedPrivate = Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE;
 587         if (Integer.bitCount(access &amp; publicProtectedPrivate) &gt; 1) {
 588             throw new IllegalArgumentException(
 589                     &quot;public, protected and private are mutually exclusive: &quot; + access);
 590         }
 591         if (Integer.bitCount(access &amp; (Opcodes.ACC_FINAL | Opcodes.ACC_ABSTRACT)) &gt; 1) {
 592             throw new IllegalArgumentException(&quot;final and abstract are mutually exclusive: &quot; + access);
 593         }
 594     }
 595 
 596     /**
 597       * Checks that the given name is a fully qualified name, using dots.
 598       *
 599       * @param version the class version.
 600       * @param name the name to be checked.
 601       * @param source the source of &#39;name&#39; (e.g &#39;module&#39; for a module name).
 602       */
 603     static void checkFullyQualifiedName(final int version, final String name, final String source) {
 604         try {
 605             int startIndex = 0;
 606             int dotIndex;
 607             while ((dotIndex = name.indexOf(&#39;.&#39;, startIndex + 1)) != -1) {
 608                 CheckMethodAdapter.checkIdentifier(version, name, startIndex, dotIndex, null);
 609                 startIndex = dotIndex + 1;
 610             }
 611             CheckMethodAdapter.checkIdentifier(version, name, startIndex, name.length(), null);
 612         } catch (IllegalArgumentException e) {
 613             throw new IllegalArgumentException(
 614                     &quot;Invalid &quot; + source + &quot; (must be a fully qualified name): &quot; + name, e);
 615         }
 616     }
 617 
 618     /**
 619       * Checks a class signature.
 620       *
 621       * @param signature a string containing the signature that must be checked.
 622       */
 623     public static void checkClassSignature(final String signature) {
 624         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 625         // ClassSignature:
 626         //   [TypeParameters] SuperclassSignature SuperinterfaceSignature*
 627         // SuperclassSignature:
 628         //   ClassTypeSignature
 629         // SuperinterfaceSignature:
 630         //   ClassTypeSignature
 631         int pos = 0;
 632         if (getChar(signature, 0) == &#39;&lt;&#39;) {
 633             pos = checkTypeParameters(signature, pos);
 634         }
 635         pos = checkClassTypeSignature(signature, pos);
 636         while (getChar(signature, pos) == &#39;L&#39; || getChar(signature, pos) == &#39;Q&#39;) {
 637             pos = checkClassTypeSignature(signature, pos);
 638         }
 639         if (pos != signature.length()) {
 640             throw new IllegalArgumentException(signature + ERROR_AT + pos);
 641         }
 642     }
 643 
 644     /**
 645       * Checks a method signature.
 646       *
 647       * @param signature a string containing the signature that must be checked.
 648       */
 649     public static void checkMethodSignature(final String signature) {
 650         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 651         // MethodSignature:
 652         //   [TypeParameters] ( JavaTypeSignature* ) Result ThrowsSignature*
 653         // Result:
 654         //   JavaTypeSignature
 655         //   VoidDescriptor
 656         // ThrowsSignature:
 657         //   ^ ClassTypeSignature
 658         //   ^ TypeVariableSignature
 659         int pos = 0;
 660         if (getChar(signature, 0) == &#39;&lt;&#39;) {
 661             pos = checkTypeParameters(signature, pos);
 662         }
 663         pos = checkChar(&#39;(&#39;, signature, pos);
 664         while (&quot;ZCBSIFJDLQ[T&quot;.indexOf(getChar(signature, pos)) != -1) {
 665             pos = checkJavaTypeSignature(signature, pos);
 666         }
 667         pos = checkChar(&#39;)&#39;, signature, pos);
 668         if (getChar(signature, pos) == &#39;V&#39;) {
 669             ++pos;
 670         } else {
 671             pos = checkJavaTypeSignature(signature, pos);
 672         }
 673         while (getChar(signature, pos) == &#39;^&#39;) {
 674             ++pos;
 675             if (getChar(signature, pos) == &#39;L&#39; || getChar(signature, pos) == &#39;Q&#39;) {
 676                 pos = checkClassTypeSignature(signature, pos);
 677             } else {
 678                 pos = checkTypeVariableSignature(signature, pos);
 679             }
 680         }
 681         if (pos != signature.length()) {
 682             throw new IllegalArgumentException(signature + ERROR_AT + pos);
 683         }
 684     }
 685 
 686     /**
 687       * Checks a field signature.
 688       *
 689       * @param signature a string containing the signature that must be checked.
 690       */
 691     public static void checkFieldSignature(final String signature) {
 692         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 693         // FieldSignature:
 694         //   ReferenceTypeSignature
 695         int pos = checkReferenceTypeSignature(signature, 0);
 696         if (pos != signature.length()) {
 697             throw new IllegalArgumentException(signature + ERROR_AT + pos);
 698         }
 699     }
 700 
 701     /**
 702       * Checks the type parameters of a class or method signature.
 703       *
 704       * @param signature a string containing the signature that must be checked.
 705       * @param startPos index of first character to be checked.
 706       * @return the index of the first character after the checked part.
 707       */
 708     private static int checkTypeParameters(final String signature, final int startPos) {
 709         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 710         // TypeParameters:
 711         //   &lt; TypeParameter TypeParameter* &gt;
 712         int pos = startPos;
 713         pos = checkChar(&#39;&lt;&#39;, signature, pos);
 714         pos = checkTypeParameter(signature, pos);
 715         while (getChar(signature, pos) != &#39;&gt;&#39;) {
 716             pos = checkTypeParameter(signature, pos);
 717         }
 718         return pos + 1;
 719     }
 720 
 721     /**
 722       * Checks a type parameter of a class or method signature.
 723       *
 724       * @param signature a string containing the signature that must be checked.
 725       * @param startPos index of first character to be checked.
 726       * @return the index of the first character after the checked part.
 727       */
 728     private static int checkTypeParameter(final String signature, final int startPos) {
 729         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 730         // TypeParameter:
 731         //   Identifier ClassBound InterfaceBound*
 732         // ClassBound:
 733         //   : [ReferenceTypeSignature]
 734         // InterfaceBound:
 735         //   : ReferenceTypeSignature
 736         int pos = startPos;
 737         pos = checkSignatureIdentifier(signature, pos);
 738         pos = checkChar(&#39;:&#39;, signature, pos);
 739         if (&quot;L[T&quot;.indexOf(getChar(signature, pos)) != -1) {
 740             pos = checkReferenceTypeSignature(signature, pos);
 741         }
 742         while (getChar(signature, pos) == &#39;:&#39;) {
 743             pos = checkReferenceTypeSignature(signature, pos + 1);
 744         }
 745         return pos;
 746     }
 747 
 748     /**
 749       * Checks a reference type signature.
 750       *
 751       * @param signature a string containing the signature that must be checked.
 752       * @param pos index of first character to be checked.
 753       * @return the index of the first character after the checked part.
 754       */
 755     private static int checkReferenceTypeSignature(final String signature, final int pos) {
 756         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 757         // ReferenceTypeSignature:
 758         //   ClassTypeSignature
 759         //   TypeVariableSignature
 760         //   ArrayTypeSignature
 761         // ArrayTypeSignature:
 762         //   [ JavaTypeSignature
 763         switch (getChar(signature, pos)) {
 764             case &#39;L&#39;:
 765                 return checkClassTypeSignature(signature, pos);
 766             case &#39;[&#39;:
 767                 return checkJavaTypeSignature(signature, pos + 1);
 768             default:
 769                 return checkTypeVariableSignature(signature, pos);
 770         }
 771     }
 772 
 773     /**
 774       * Checks a class type signature.
 775       *
 776       * @param signature a string containing the signature that must be checked.
 777       * @param startPos index of first character to be checked.
 778       * @return the index of the first character after the checked part.
 779       */
 780     private static int checkClassTypeSignature(final String signature, final int startPos) {
 781         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 782         // ClassTypeSignature:
 783         //   L [PackageSpecifier] SimpleClassTypeSignature ClassTypeSignatureSuffix* ;
 784         // PackageSpecifier:
 785         //   Identifier / PackageSpecifier*
 786         // SimpleClassTypeSignature:
 787         //   Identifier [TypeArguments]
 788         // ClassTypeSignatureSuffix:
 789         //   . SimpleClassTypeSignature
 790         int pos = startPos;
 791         if (getChar(signature, pos) == &#39;L&#39; || getChar(signature, pos) == &#39;Q&#39;) {
 792             pos = pos + 1;
 793         } else {
 794             throw new IllegalArgumentException(signature + &quot;: &#39;L&#39; or &#39;Q&#39; expected at index &quot; + pos);
 795         }
 796 
 797         pos = checkSignatureIdentifier(signature, pos);
 798         while (getChar(signature, pos) == &#39;/&#39;) {
 799             pos = checkSignatureIdentifier(signature, pos + 1);
 800         }
 801         if (getChar(signature, pos) == &#39;&lt;&#39;) {
 802             pos = checkTypeArguments(signature, pos);
 803         }
 804         while (getChar(signature, pos) == &#39;.&#39;) {
 805             pos = checkSignatureIdentifier(signature, pos + 1);
 806             if (getChar(signature, pos) == &#39;&lt;&#39;) {
 807                 pos = checkTypeArguments(signature, pos);
 808             }
 809         }
 810         return checkChar(&#39;;&#39;, signature, pos);
 811     }
 812 
 813     /**
 814       * Checks the type arguments in a class type signature.
 815       *
 816       * @param signature a string containing the signature that must be checked.
 817       * @param startPos index of first character to be checked.
 818       * @return the index of the first character after the checked part.
 819       */
 820     private static int checkTypeArguments(final String signature, final int startPos) {
 821         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 822         // TypeArguments:
 823         //   &lt; TypeArgument TypeArgument* &gt;
 824         int pos = startPos;
 825         pos = checkChar(&#39;&lt;&#39;, signature, pos);
 826         pos = checkTypeArgument(signature, pos);
 827         while (getChar(signature, pos) != &#39;&gt;&#39;) {
 828             pos = checkTypeArgument(signature, pos);
 829         }
 830         return pos + 1;
 831     }
 832 
 833     /**
 834       * Checks a type argument in a class type signature.
 835       *
 836       * @param signature a string containing the signature that must be checked.
 837       * @param startPos index of first character to be checked.
 838       * @return the index of the first character after the checked part.
 839       */
 840     private static int checkTypeArgument(final String signature, final int startPos) {
 841         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 842         // TypeArgument:
 843         //   [WildcardIndicator] ReferenceTypeSignature
 844         //   *
 845         // WildcardIndicator:
 846         //   +
 847         //   -
 848         int pos = startPos;
 849         char c = getChar(signature, pos);
 850         if (c == &#39;*&#39;) {
 851             return pos + 1;
 852         } else if (c == &#39;+&#39; || c == &#39;-&#39;) {
 853             pos++;
 854         }
 855         return checkReferenceTypeSignature(signature, pos);
 856     }
 857 
 858     /**
 859       * Checks a type variable signature.
 860       *
 861       * @param signature a string containing the signature that must be checked.
 862       * @param startPos index of first character to be checked.
 863       * @return the index of the first character after the checked part.
 864       */
 865     private static int checkTypeVariableSignature(final String signature, final int startPos) {
 866         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 867         // TypeVariableSignature:
 868         //  T Identifier ;
 869         int pos = startPos;
 870         pos = checkChar(&#39;T&#39;, signature, pos);
 871         pos = checkSignatureIdentifier(signature, pos);
 872         return checkChar(&#39;;&#39;, signature, pos);
 873     }
 874 
 875     /**
 876       * Checks a Java type signature.
 877       *
 878       * @param signature a string containing the signature that must be checked.
 879       * @param startPos index of first character to be checked.
 880       * @return the index of the first character after the checked part.
 881       */
 882     private static int checkJavaTypeSignature(final String signature, final int startPos) {
 883         // From https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.9.1:
 884         // JavaTypeSignature:
 885         //   ReferenceTypeSignature
 886         //   BaseType
 887         // BaseType:
 888         //   (one of)
 889         //   B C D F I J S Z
 890         int pos = startPos;
 891         switch (getChar(signature, pos)) {
 892             case &#39;B&#39;:
 893             case &#39;C&#39;:
 894             case &#39;D&#39;:
 895             case &#39;F&#39;:
 896             case &#39;I&#39;:
 897             case &#39;J&#39;:
 898             case &#39;S&#39;:
 899             case &#39;Z&#39;:
 900                 return pos + 1;
 901             default:
 902                 return checkReferenceTypeSignature(signature, pos);
 903         }
 904     }
 905 
 906     /**
 907       * Checks an identifier.
 908       *
 909       * @param signature a string containing the signature that must be checked.
 910       * @param startPos index of first character to be checked.
 911       * @return the index of the first character after the checked part.
 912       */
 913     private static int checkSignatureIdentifier(final String signature, final int startPos) {
 914         int pos = startPos;
 915         while (pos &lt; signature.length() &amp;&amp; &quot;.;[/&lt;&gt;:&quot;.indexOf(signature.codePointAt(pos)) == -1) {
 916             pos = signature.offsetByCodePoints(pos, 1);
 917         }
 918         if (pos == startPos) {
 919             throw new IllegalArgumentException(signature + &quot;: identifier expected at index &quot; + startPos);
 920         }
 921         return pos;
 922     }
 923 
 924     /**
 925       * Checks a single character.
 926       *
 927       * @param c a character.
 928       * @param signature a string containing the signature that must be checked.
 929       * @param pos index of first character to be checked.
 930       * @return the index of the first character after the checked part.
 931       */
 932     private static int checkChar(final char c, final String signature, final int pos) {
 933         if (getChar(signature, pos) == c) {
 934             return pos + 1;
 935         }
 936         throw new IllegalArgumentException(signature + &quot;: &#39;&quot; + c + &quot;&#39; expected at index &quot; + pos);
 937     }
 938 
 939     /**
 940       * Returns the string character at the given index, or 0.
 941       *
 942       * @param string a string.
 943       * @param pos an index in &#39;string&#39;.
 944       * @return the character at the given index, or 0 if there is no such character.
 945       */
 946     private static char getChar(final String string, final int pos) {
 947         return pos &lt; string.length() ? string.charAt(pos) : (char) 0;
 948     }
 949 
 950     /**
 951       * Checks the reference to a type in a type annotation.
 952       *
 953       * @param typeRef a reference to an annotated type.
 954       */
 955     static void checkTypeRef(final int typeRef) {
 956         int mask = 0;
 957         switch (typeRef &gt;&gt;&gt; 24) {
 958             case TypeReference.CLASS_TYPE_PARAMETER:
 959             case TypeReference.METHOD_TYPE_PARAMETER:
 960             case TypeReference.METHOD_FORMAL_PARAMETER:
 961                 mask = 0xFFFF0000;
 962                 break;
 963             case TypeReference.FIELD:
 964             case TypeReference.METHOD_RETURN:
 965             case TypeReference.METHOD_RECEIVER:
 966             case TypeReference.LOCAL_VARIABLE:
 967             case TypeReference.RESOURCE_VARIABLE:
 968             case TypeReference.INSTANCEOF:
 969             case TypeReference.NEW:
 970             case TypeReference.CONSTRUCTOR_REFERENCE:
 971             case TypeReference.METHOD_REFERENCE:
 972                 mask = 0xFF000000;
 973                 break;
 974             case TypeReference.CLASS_EXTENDS:
 975             case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
 976             case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
 977             case TypeReference.THROWS:
 978             case TypeReference.EXCEPTION_PARAMETER:
 979                 mask = 0xFFFFFF00;
 980                 break;
 981             case TypeReference.CAST:
 982             case TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:
 983             case TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT:
 984             case TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:
 985             case TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT:
 986                 mask = 0xFF0000FF;
 987                 break;
 988             default:
 989                 throw new AssertionError();
 990         }
 991         if ((typeRef &amp; ~mask) != 0) {
 992             throw new IllegalArgumentException(
 993                     &quot;Invalid type reference 0x&quot; + Integer.toHexString(typeRef));
 994         }
 995     }
 996 
 997     /**
 998       * Returns the package name of an internal name.
 999       *
1000       * @param name an internal name.
1001       * @return the package name or &quot;&quot; if there is no package.
1002       */
1003     private static String packageName(final String name) {
1004         int index = name.lastIndexOf(&#39;/&#39;);
1005         if (index == -1) {
1006             return &quot;&quot;;
1007         }
1008         return name.substring(0, index);
1009     }
1010 
1011     // -----------------------------------------------------------------------------------------------
1012     // Static verification methods
1013     // -----------------------------------------------------------------------------------------------
1014 
1015     /**
1016       * Checks the given class.
1017       *
1018       * &lt;p&gt;Usage: CheckClassAdapter &amp;lt;binary class name or class file name&amp;gt;
1019       *
1020       * @param args the command line arguments.
1021       * @throws IOException if the class cannot be found, or if an IO exception occurs.
1022       */
1023     public static void main(final String[] args) throws IOException {
<a name="11" id="anc11"></a><span class="line-added">1024         main(args, new PrintWriter(System.err, true));</span>
<span class="line-added">1025     }</span>
<span class="line-added">1026 </span>
<span class="line-added">1027     /**</span>
<span class="line-added">1028       * Checks the given class.</span>
<span class="line-added">1029       *</span>
<span class="line-added">1030       * @param args the command line arguments.</span>
<span class="line-added">1031       * @param logger where to log errors.</span>
<span class="line-added">1032       * @throws IOException if the class cannot be found, or if an IO exception occurs.</span>
<span class="line-added">1033       */</span>
<span class="line-added">1034     static void main(final String[] args, final PrintWriter logger) throws IOException {</span>
1035         if (args.length != 1) {
<a name="12" id="anc12"></a><span class="line-modified">1036             logger.println(USAGE);</span>


1037             return;
1038         }
1039 
1040         ClassReader classReader;
1041         if (args[0].endsWith(&quot;.class&quot;)) {
1042             InputStream inputStream =
1043                     new FileInputStream(args[0]); // NOPMD(AvoidFileStream): can&#39;t fix for 1.5 compatibility
1044             classReader = new ClassReader(inputStream);
1045         } else {
1046             classReader = new ClassReader(args[0]);
1047         }
1048 
<a name="13" id="anc13"></a><span class="line-modified">1049         verify(classReader, false, logger);</span>
1050     }
1051 
1052     /**
1053       * Checks the given class.
1054       *
1055       * @param classReader the class to be checked.
1056       * @param printResults whether to print the results of the bytecode verification.
1057       * @param printWriter where the results (or the stack trace in case of error) must be printed.
1058       */
1059     public static void verify(
1060             final ClassReader classReader, final boolean printResults, final PrintWriter printWriter) {
1061         verify(classReader, null, printResults, printWriter);
1062     }
1063 
1064     /**
1065       * Checks the given class.
1066       *
1067       * @param classReader the class to be checked.
1068       * @param loader a &lt;code&gt;ClassLoader&lt;/code&gt; which will be used to load referenced classes. May be
1069       *     {@literal null}.
1070       * @param printResults whether to print the results of the bytecode verification.
1071       * @param printWriter where the results (or the stack trace in case of error) must be printed.
1072       */
<a name="14" id="anc14"></a><span class="line-added">1073     @SuppressWarnings(&quot;deprecation&quot;)</span>
1074     public static void verify(
1075             final ClassReader classReader,
1076             final ClassLoader loader,
1077             final boolean printResults,
1078             final PrintWriter printWriter) {
1079         ClassNode classNode = new ClassNode();
1080         classReader.accept(
<a name="15" id="anc15"></a><span class="line-modified">1081                 new CheckClassAdapter(Opcodes.ASM9_EXPERIMENTAL, classNode, false) {},</span>
<span class="line-added">1082                 ClassReader.SKIP_DEBUG);</span>
1083 
1084         Type syperType = classNode.superName == null ? null : Type.getObjectType(classNode.superName);
1085         List&lt;MethodNode&gt; methods = classNode.methods;
1086 
<a name="16" id="anc16"></a><span class="line-modified">1087         List&lt;Type&gt; interfaces = new ArrayList&lt;&gt;();</span>
1088         for (String interfaceName : classNode.interfaces) {
1089             interfaces.add(Type.getObjectType(interfaceName));
1090         }
1091 
1092         for (MethodNode method : methods) {
1093             SimpleVerifier verifier =
1094                     new SimpleVerifier(
1095                             Type.getObjectType(classNode.name),
1096                             syperType,
1097                             interfaces,
1098                             (classNode.access &amp; Opcodes.ACC_INTERFACE) != 0);
<a name="17" id="anc17"></a><span class="line-modified">1099             Analyzer&lt;BasicValue&gt; analyzer = new Analyzer&lt;&gt;(verifier);</span>
1100             if (loader != null) {
1101                 verifier.setClassLoader(loader);
1102             }
1103             try {
1104                 analyzer.analyze(classNode.name, method);
1105             } catch (AnalyzerException e) {
1106                 e.printStackTrace(printWriter);
1107             }
1108             if (printResults) {
1109                 printAnalyzerResult(method, analyzer, printWriter);
1110             }
1111         }
1112         printWriter.flush();
1113     }
1114 
1115     static void printAnalyzerResult(
1116             final MethodNode method, final Analyzer&lt;BasicValue&gt; analyzer, final PrintWriter printWriter) {
1117         Textifier textifier = new Textifier();
1118         TraceMethodVisitor traceMethodVisitor = new TraceMethodVisitor(textifier);
1119 
1120         printWriter.println(method.name + method.desc);
1121         for (int i = 0; i &lt; method.instructions.size(); ++i) {
1122             method.instructions.get(i).accept(traceMethodVisitor);
1123 
1124             StringBuilder stringBuilder = new StringBuilder();
1125             Frame&lt;BasicValue&gt; frame = analyzer.getFrames()[i];
1126             if (frame == null) {
1127                 stringBuilder.append(&#39;?&#39;);
1128             } else {
1129                 for (int j = 0; j &lt; frame.getLocals(); ++j) {
1130                     stringBuilder.append(getUnqualifiedName(frame.getLocal(j).toString())).append(&#39; &#39;);
1131                 }
1132                 stringBuilder.append(&quot; : &quot;);
1133                 for (int j = 0; j &lt; frame.getStackSize(); ++j) {
1134                     stringBuilder.append(getUnqualifiedName(frame.getStack(j).toString())).append(&#39; &#39;);
1135                 }
1136             }
1137             while (stringBuilder.length() &lt; method.maxStack + method.maxLocals + 1) {
1138                 stringBuilder.append(&#39; &#39;);
1139             }
1140             printWriter.print(Integer.toString(i + 100000).substring(1));
1141             printWriter.print(
1142                     &quot; &quot; + stringBuilder + &quot; : &quot; + textifier.text.get(textifier.text.size() - 1));
1143         }
1144         for (TryCatchBlockNode tryCatchBlock : method.tryCatchBlocks) {
1145             tryCatchBlock.accept(traceMethodVisitor);
1146             printWriter.print(&quot; &quot; + textifier.text.get(textifier.text.size() - 1));
1147         }
1148         printWriter.println();
1149     }
1150 
1151     private static String getUnqualifiedName(final String name) {
1152         int lastSlashIndex = name.lastIndexOf(&#39;/&#39;);
1153         if (lastSlashIndex == -1) {
1154             return name;
1155         } else {
1156             int endIndex = name.length();
1157             if (name.charAt(endIndex - 1) == &#39;;&#39;) {
1158                 endIndex--;
1159             }
1160             return name.substring(lastSlashIndex + 1, endIndex);
1161         }
1162     }
1163 }
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../java/lang/reflect/Field.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Constants.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/org/objectweb/asm/ClassReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 79,14 ***</span>
        * nor visited.
        */
      public static final int SKIP_CODE = 1;
  
      /**
<span class="line-modified">!       * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable</span>
<span class="line-modified">!       * and LineNumberTable attributes. If this flag is set these attributes are neither parsed nor</span>
<span class="line-modified">!       * visited (i.e. {@link ClassVisitor#visitSource}, {@link MethodVisitor#visitLocalVariable} and</span>
<span class="line-modified">!       * {@link MethodVisitor#visitLineNumber} are not called).</span>
        */
      public static final int SKIP_DEBUG = 2;
  
      /**
        * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes
<span class="line-new-header">--- 79,15 ---</span>
        * nor visited.
        */
      public static final int SKIP_CODE = 1;
  
      /**
<span class="line-modified">!       * A flag to skip the SourceFile, SourceDebugExtension, LocalVariableTable,</span>
<span class="line-modified">!       * LocalVariableTypeTable, LineNumberTable and MethodParameters attributes. If this flag is set</span>
<span class="line-modified">!       * these attributes are neither parsed nor visited (i.e. {@link ClassVisitor#visitSource}, {@link</span>
<span class="line-modified">!       * MethodVisitor#visitLocalVariable}, {@link MethodVisitor#visitLineNumber} and {@link</span>
<span class="line-added">+       * MethodVisitor#visitParameter} are not called).</span>
        */
      public static final int SKIP_DEBUG = 2;
  
      /**
        * A flag to skip the StackMap and StackMapTable attributes. If this flag is set these attributes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,26 ***</span>
      static final int EXPAND_ASM_INSNS = 256;
  
      /** The size of the temporary byte array used to read class input streams chunk by chunk. */
      private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;
  
      /**
        * A byte array containing the JVMS ClassFile structure to be parsed. &lt;i&gt;The content of this array
        * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally
        * not needed by class visitors.&lt;/i&gt;
        *
        * &lt;p&gt;NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not
        * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct
        * ClassFile element offsets within this byte array.
        */
<span class="line-modified">!     // DontCheck(MemberName): can&#39;t be renamed (for backward binary compatibility).</span>
<span class="line-removed">-     public final byte[] b;</span>
  
      /**
<span class="line-modified">!       * The offset in bytes, in {@link #b}, of each cp_info entry of the ClassFile&#39;s constant_pool</span>
<span class="line-modified">!       * array, &lt;i&gt;plus one&lt;/i&gt;. In other words, the offset of constant pool entry i is given by</span>
<span class="line-modified">!       * cpInfoOffsets[i] - 1, i.e. its cp_info&#39;s tag field is given by b[cpInfoOffsets[i] - 1].</span>
        */
      private final int[] cpInfoOffsets;
  
      /**
        * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids
<span class="line-new-header">--- 120,36 ---</span>
      static final int EXPAND_ASM_INSNS = 256;
  
      /** The size of the temporary byte array used to read class input streams chunk by chunk. */
      private static final int INPUT_STREAM_DATA_CHUNK_SIZE = 4096;
  
<span class="line-added">+     /**</span>
<span class="line-added">+       * A byte array containing the JVMS ClassFile structure to be parsed.</span>
<span class="line-added">+       *</span>
<span class="line-added">+       * @deprecated Use {@link #readByte(int)} and the other read methods instead. This field will</span>
<span class="line-added">+       *     eventually be deleted.</span>
<span class="line-added">+       */</span>
<span class="line-added">+     @Deprecated</span>
<span class="line-added">+     // DontCheck(MemberName): can&#39;t be renamed (for backward binary compatibility).</span>
<span class="line-added">+     public final byte[] b;</span>
<span class="line-added">+ </span>
      /**
        * A byte array containing the JVMS ClassFile structure to be parsed. &lt;i&gt;The content of this array
        * must not be modified. This field is intended for {@link Attribute} sub classes, and is normally
        * not needed by class visitors.&lt;/i&gt;
        *
        * &lt;p&gt;NOTE: the ClassFile structure can start at any offset within this array, i.e. it does not
        * necessarily start at offset 0. Use {@link #getItem} and {@link #header} to get correct
        * ClassFile element offsets within this byte array.
        */
<span class="line-modified">!     final byte[] classFileBuffer;</span>
  
      /**
<span class="line-modified">!       * The offset in bytes, in {@link #classFileBuffer}, of each cp_info entry of the ClassFile&#39;s</span>
<span class="line-modified">!       * constant_pool array, &lt;i&gt;plus one&lt;/i&gt;. In other words, the offset of constant pool entry i is</span>
<span class="line-modified">!       * given by cpInfoOffsets[i] - 1, i.e. its cp_info&#39;s tag field is given by b[cpInfoOffsets[i] -</span>
<span class="line-added">+       * 1].</span>
        */
      private final int[] cpInfoOffsets;
  
      /**
        * The String objects corresponding to the CONSTANT_Utf8 constant pool items. This cache avoids
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,12 ***</span>
        * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.
        */
      private final ConstantDynamic[] constantDynamicValues;
  
      /**
<span class="line-modified">!       * The start offsets in {@link #b} of each element of the bootstrap_methods array (in the</span>
<span class="line-modified">!       * BootstrapMethods attribute).</span>
        *
        * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23&quot;&gt;JVMS
        *     4.7.23&lt;/a&gt;
        */
      private final int[] bootstrapMethodOffsets;
<span class="line-new-header">--- 162,12 ---</span>
        * cache avoids multiple parsing of a given CONSTANT_Dynamic constant pool item.
        */
      private final ConstantDynamic[] constantDynamicValues;
  
      /**
<span class="line-modified">!       * The start offsets in {@link #classFileBuffer} of each element of the bootstrap_methods array</span>
<span class="line-modified">!       * (in the BootstrapMethods attribute).</span>
        *
        * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.7.23&quot;&gt;JVMS
        *     4.7.23&lt;/a&gt;
        */
      private final int[] bootstrapMethodOffsets;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 165,11 ***</span>
        * A conservative estimate of the maximum length of the strings contained in the constant pool of
        * the class.
        */
      private final int maxStringLength;
  
<span class="line-modified">!     /** The offset in bytes, in {@link #b}, of the ClassFile&#39;s access_flags field. */</span>
      public final int header;
  
      // -----------------------------------------------------------------------------------------------
      // Constructors
      // -----------------------------------------------------------------------------------------------
<span class="line-new-header">--- 176,11 ---</span>
        * A conservative estimate of the maximum length of the strings contained in the constant pool of
        * the class.
        */
      private final int maxStringLength;
  
<span class="line-modified">!     /** The offset in bytes of the ClassFile&#39;s access_flags field. */</span>
      public final int header;
  
      // -----------------------------------------------------------------------------------------------
      // Constructors
      // -----------------------------------------------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 205,11 ***</span>
        * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
        * @param checkClassVersion whether to check the class version or not.
        */
      ClassReader(
              final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
<span class="line-modified">!         b = classFileBuffer;</span>
          // Check the class&#39; major_version. This field is after the magic and minor_version fields, which
          // use 4 and 2 bytes respectively.
          if (checkClassVersion &amp;&amp; readShort(classFileOffset + 6) &gt; Opcodes.V15) {
              throw new IllegalArgumentException(
                      &quot;Unsupported class file major version &quot; + readShort(classFileOffset + 6));
<span class="line-new-header">--- 216,12 ---</span>
        * @param classFileOffset the offset in byteBuffer of the first byte of the ClassFile to be read.
        * @param checkClassVersion whether to check the class version or not.
        */
      ClassReader(
              final byte[] classFileBuffer, final int classFileOffset, final boolean checkClassVersion) {
<span class="line-modified">!         this.classFileBuffer = classFileBuffer;</span>
<span class="line-added">+         this.b = classFileBuffer;</span>
          // Check the class&#39; major_version. This field is after the magic and minor_version fields, which
          // use 4 and 2 bytes respectively.
          if (checkClassVersion &amp;&amp; readShort(classFileOffset + 6) &gt; Opcodes.V15) {
              throw new IllegalArgumentException(
                      &quot;Unsupported class file major version &quot; + readShort(classFileOffset + 6));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,12 ***</span>
          // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2
          // bytes respectively.
          int currentCpInfoIndex = 1;
          int currentCpInfoOffset = classFileOffset + 10;
          int currentMaxStringLength = 0;
          boolean hasConstantDynamic = false;
<span class="line-removed">-         boolean hasConstantInvokeDynamic = false;</span>
          // The offset of the other entries depend on the total size of all the previous entries.
          while (currentCpInfoIndex &lt; constantPoolCount) {
              cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;
              int cpInfoSize;
              switch (classFileBuffer[currentCpInfoOffset]) {
<span class="line-new-header">--- 236,12 ---</span>
          // magic, minor_version, major_version and constant_pool_count fields, which use 4, 2, 2 and 2
          // bytes respectively.
          int currentCpInfoIndex = 1;
          int currentCpInfoOffset = classFileOffset + 10;
          int currentMaxStringLength = 0;
<span class="line-added">+         boolean hasBootstrapMethods = false;</span>
          boolean hasConstantDynamic = false;
          // The offset of the other entries depend on the total size of all the previous entries.
          while (currentCpInfoIndex &lt; constantPoolCount) {
              cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + 1;
              int cpInfoSize;
              switch (classFileBuffer[currentCpInfoOffset]) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,15 ***</span>
                  case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
                      cpInfoSize = 5;
                      break;
                  case Symbol.CONSTANT_DYNAMIC_TAG:
                      cpInfoSize = 5;
                      hasConstantDynamic = true;
                      break;
                  case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
                      cpInfoSize = 5;
<span class="line-modified">!                     hasConstantInvokeDynamic = true;</span>
                      break;
                  case Symbol.CONSTANT_LONG_TAG:
                  case Symbol.CONSTANT_DOUBLE_TAG:
                      cpInfoSize = 9;
                      currentCpInfoIndex++;
<span class="line-new-header">--- 253,16 ---</span>
                  case Symbol.CONSTANT_NAME_AND_TYPE_TAG:
                      cpInfoSize = 5;
                      break;
                  case Symbol.CONSTANT_DYNAMIC_TAG:
                      cpInfoSize = 5;
<span class="line-added">+                     hasBootstrapMethods = true;</span>
                      hasConstantDynamic = true;
                      break;
                  case Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:
                      cpInfoSize = 5;
<span class="line-modified">!                     hasBootstrapMethods = true;</span>
                      break;
                  case Symbol.CONSTANT_LONG_TAG:
                  case Symbol.CONSTANT_DOUBLE_TAG:
                      cpInfoSize = 9;
                      currentCpInfoIndex++;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,13 ***</span>
          // Allocate the cache of ConstantDynamic values, if there is at least one.
          constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;
  
          // Read the BootstrapMethods attribute, if any (only get the offset of each method).
          bootstrapMethodOffsets =
<span class="line-modified">!                 (hasConstantDynamic | hasConstantInvokeDynamic)</span>
<span class="line-removed">-                         ? readBootstrapMethodsAttribute(currentMaxStringLength)</span>
<span class="line-removed">-                         : null;</span>
      }
  
      /**
        * Constructs a new {@link ClassReader} object.
        *
<span class="line-new-header">--- 298,11 ---</span>
          // Allocate the cache of ConstantDynamic values, if there is at least one.
          constantDynamicValues = hasConstantDynamic ? new ConstantDynamic[constantPoolCount] : null;
  
          // Read the BootstrapMethods attribute, if any (only get the offset of each method).
          bootstrapMethodOffsets =
<span class="line-modified">!                 hasBootstrapMethods ? readBootstrapMethodsAttribute(currentMaxStringLength) : null;</span>
      }
  
      /**
        * Constructs a new {@link ClassReader} object.
        *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,12 ***</span>
      private static byte[] readStream(final InputStream inputStream, final boolean close)
              throws IOException {
          if (inputStream == null) {
              throw new IOException(&quot;Class not found&quot;);
          }
<span class="line-modified">!         try {</span>
<span class="line-removed">-             ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</span>
              byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];
              int bytesRead;
              while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {
                  outputStream.write(data, 0, bytesRead);
              }
<span class="line-new-header">--- 339,11 ---</span>
      private static byte[] readStream(final InputStream inputStream, final boolean close)
              throws IOException {
          if (inputStream == null) {
              throw new IOException(&quot;Class not found&quot;);
          }
<span class="line-modified">!         try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {</span>
              byte[] data = new byte[INPUT_STREAM_DATA_CHUNK_SIZE];
              int bytesRead;
              while ((bytesRead = inputStream.read(data, 0, data.length)) != -1) {
                  outputStream.write(data, 0, bytesRead);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 434,10 ***</span>
<span class="line-new-header">--- 444,11 ---</span>
        *     semantic links with a class element that has been transformed by a class adapter between
        *     the reader and the writer&lt;/i&gt;.
        * @param parsingOptions the options to use to parse this class. One or more of {@link
        *     #SKIP_CODE}, {@link #SKIP_DEBUG}, {@link #SKIP_FRAMES} or {@link #EXPAND_FRAMES}.
        */
<span class="line-added">+     @SuppressWarnings(&quot;deprecation&quot;)</span>
      public void accept(
              final ClassVisitor classVisitor,
              final Attribute[] attributePrototypes,
              final int parsingOptions) {
          Context context = new Context();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 486,10 ***</span>
<span class="line-new-header">--- 497,14 ---</span>
          String moduleMainClass = null;
          // - The string corresponding to the NestHost attribute, or null.
          String nestHostClass = null;
          // - The offset of the NestMembers attribute, or 0.
          int nestMembersOffset = 0;
<span class="line-added">+         // - The offset of the PermittedSubtypes attribute, or 0</span>
<span class="line-added">+         int permittedSubtypesOffset = 0;</span>
<span class="line-added">+         // - The offset of the Record attribute, or 0.</span>
<span class="line-added">+         int recordOffset = 0;</span>
          // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).
          //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.
          Attribute attributes = null;
  
          int currentAttributeOffset = getFirstAttributeOffset();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 508,10 ***</span>
<span class="line-new-header">--- 523,12 ---</span>
                  enclosingMethodOffset = currentAttributeOffset;
              } else if (Constants.NEST_HOST.equals(attributeName)) {
                  nestHostClass = readClass(currentAttributeOffset, charBuffer);
              } else if (Constants.NEST_MEMBERS.equals(attributeName)) {
                  nestMembersOffset = currentAttributeOffset;
<span class="line-added">+             } else if (Constants.PERMITTED_SUBTYPES.equals(attributeName)) {</span>
<span class="line-added">+                 permittedSubtypesOffset = currentAttributeOffset;</span>
              } else if (Constants.SIGNATURE.equals(attributeName)) {
                  signature = readUTF8(currentAttributeOffset, charBuffer);
              } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {
                  runtimeVisibleAnnotationsOffset = currentAttributeOffset;
              } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 525,10 ***</span>
<span class="line-new-header">--- 542,13 ---</span>
                          readUtf(currentAttributeOffset, attributeLength, new char[attributeLength]);
              } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {
                  runtimeInvisibleAnnotationsOffset = currentAttributeOffset;
              } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {
                  runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;
<span class="line-added">+             } else if (Constants.RECORD.equals(attributeName)) {</span>
<span class="line-added">+                 recordOffset = currentAttributeOffset;</span>
<span class="line-added">+                 accessFlags |= Opcodes.ACC_RECORD;</span>
              } else if (Constants.MODULE.equals(attributeName)) {
                  moduleOffset = currentAttributeOffset;
              } else if (Constants.MODULE_MAIN_CLASS.equals(attributeName)) {
                  moduleMainClass = readClass(currentAttributeOffset, charBuffer);
              } else if (Constants.MODULE_PACKAGES.equals(attributeName)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 682,10 ***</span>
<span class="line-new-header">--- 702,21 ---</span>
                  classVisitor.visitNestMember(readClass(currentNestMemberOffset, charBuffer));
                  currentNestMemberOffset += 2;
              }
          }
  
<span class="line-added">+         // Visit the PermittedSubtypes attribute.</span>
<span class="line-added">+         if (permittedSubtypesOffset != 0) {</span>
<span class="line-added">+             int numberOfPermittedSubtypes = readUnsignedShort(permittedSubtypesOffset);</span>
<span class="line-added">+             int currentPermittedSubtypeOffset = permittedSubtypesOffset + 2;</span>
<span class="line-added">+             while (numberOfPermittedSubtypes-- &gt; 0) {</span>
<span class="line-added">+                 classVisitor.visitPermittedSubtypeExperimental(</span>
<span class="line-added">+                         readClass(currentPermittedSubtypeOffset, charBuffer));</span>
<span class="line-added">+                 currentPermittedSubtypeOffset += 2;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // Visit the InnerClasses attribute.
          if (innerClassesOffset != 0) {
              int numberOfClasses = readUnsignedShort(innerClassesOffset);
              int currentClassesOffset = innerClassesOffset + 2;
              while (numberOfClasses-- &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,10 ***</span>
<span class="line-new-header">--- 727,19 ---</span>
                          readUnsignedShort(currentClassesOffset + 6));
                  currentClassesOffset += 8;
              }
          }
  
<span class="line-added">+         // Visit Record components.</span>
<span class="line-added">+         if (recordOffset != 0) {</span>
<span class="line-added">+             int recordComponentsCount = readUnsignedShort(recordOffset);</span>
<span class="line-added">+             recordOffset += 2;</span>
<span class="line-added">+             while (recordComponentsCount-- &gt; 0) {</span>
<span class="line-added">+                 recordOffset = readRecordComponent(classVisitor, context, recordOffset);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // Visit the fields and methods.
          int fieldsCount = readUnsignedShort(currentOffset);
          currentOffset += 2;
          while (fieldsCount-- &gt; 0) {
              currentOffset = readField(classVisitor, context, currentOffset);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 725,11 ***</span>
        * @param context information about the class being parsed.
        * @param moduleOffset the offset of the Module attribute (excluding the attribute_info&#39;s
        *     attribute_name_index and attribute_length fields).
        * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the
        *     attribute_info&#39;s attribute_name_index and attribute_length fields), or 0.
<span class="line-modified">!       * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or null.</span>
        */
      private void readModuleAttributes(
              final ClassVisitor classVisitor,
              final Context context,
              final int moduleOffset,
<span class="line-new-header">--- 765,12 ---</span>
        * @param context information about the class being parsed.
        * @param moduleOffset the offset of the Module attribute (excluding the attribute_info&#39;s
        *     attribute_name_index and attribute_length fields).
        * @param modulePackagesOffset the offset of the ModulePackages attribute (excluding the
        *     attribute_info&#39;s attribute_name_index and attribute_length fields), or 0.
<span class="line-modified">!       * @param moduleMainClass the string corresponding to the ModuleMainClass attribute, or {@literal</span>
<span class="line-added">+       *     null}.</span>
        */
      private void readModuleAttributes(
              final ClassVisitor classVisitor,
              final Context context,
              final int moduleOffset,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 842,10 ***</span>
<span class="line-new-header">--- 883,184 ---</span>
  
          // Visit the end of the module attributes.
          moduleVisitor.visitEnd();
      }
  
<span class="line-added">+     /**</span>
<span class="line-added">+       * Reads a record component and visit it.</span>
<span class="line-added">+       *</span>
<span class="line-added">+       * @param classVisitor the current class visitor</span>
<span class="line-added">+       * @param context information about the class being parsed.</span>
<span class="line-added">+       * @param recordComponentOffset the offset of the current record component.</span>
<span class="line-added">+       * @return the offset of the first byte following the record component.</span>
<span class="line-added">+       */</span>
<span class="line-added">+     private int readRecordComponent(</span>
<span class="line-added">+             final ClassVisitor classVisitor, final Context context, final int recordComponentOffset) {</span>
<span class="line-added">+         char[] charBuffer = context.charBuffer;</span>
<span class="line-added">+ </span>
<span class="line-added">+         int currentOffset = recordComponentOffset;</span>
<span class="line-added">+         String name = readUTF8(currentOffset, charBuffer);</span>
<span class="line-added">+         String descriptor = readUTF8(currentOffset + 2, charBuffer);</span>
<span class="line-added">+         currentOffset += 4;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Read the record component attributes (the variables are ordered as in Section 4.7 of the</span>
<span class="line-added">+         // JVMS).</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Attribute offsets exclude the attribute_name_index and attribute_length fields.</span>
<span class="line-added">+         // - The string corresponding to the Signature attribute, or null.</span>
<span class="line-added">+         String signature = null;</span>
<span class="line-added">+         // - The offset of the RuntimeVisibleAnnotations attribute, or 0.</span>
<span class="line-added">+         int runtimeVisibleAnnotationsOffset = 0;</span>
<span class="line-added">+         // - The offset of the RuntimeInvisibleAnnotations attribute, or 0.</span>
<span class="line-added">+         int runtimeInvisibleAnnotationsOffset = 0;</span>
<span class="line-added">+         // - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.</span>
<span class="line-added">+         int runtimeVisibleTypeAnnotationsOffset = 0;</span>
<span class="line-added">+         // - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.</span>
<span class="line-added">+         int runtimeInvisibleTypeAnnotationsOffset = 0;</span>
<span class="line-added">+         // - The non standard attributes (linked with their {@link Attribute#nextAttribute} field).</span>
<span class="line-added">+         //   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.</span>
<span class="line-added">+         Attribute attributes = null;</span>
<span class="line-added">+ </span>
<span class="line-added">+         int attributesCount = readUnsignedShort(currentOffset);</span>
<span class="line-added">+         currentOffset += 2;</span>
<span class="line-added">+         while (attributesCount-- &gt; 0) {</span>
<span class="line-added">+             // Read the attribute_info&#39;s attribute_name and attribute_length fields.</span>
<span class="line-added">+             String attributeName = readUTF8(currentOffset, charBuffer);</span>
<span class="line-added">+             int attributeLength = readInt(currentOffset + 2);</span>
<span class="line-added">+             currentOffset += 6;</span>
<span class="line-added">+             // The tests are sorted in decreasing frequency order (based on frequencies observed on</span>
<span class="line-added">+             // typical classes).</span>
<span class="line-added">+             if (Constants.SIGNATURE.equals(attributeName)) {</span>
<span class="line-added">+                 signature = readUTF8(currentOffset, charBuffer);</span>
<span class="line-added">+             } else if (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="line-added">+                 runtimeVisibleAnnotationsOffset = currentOffset;</span>
<span class="line-added">+             } else if (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="line-added">+                 runtimeVisibleTypeAnnotationsOffset = currentOffset;</span>
<span class="line-added">+             } else if (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="line-added">+                 runtimeInvisibleAnnotationsOffset = currentOffset;</span>
<span class="line-added">+             } else if (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) {</span>
<span class="line-added">+                 runtimeInvisibleTypeAnnotationsOffset = currentOffset;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+                 Attribute attribute =</span>
<span class="line-added">+                         readAttribute(</span>
<span class="line-added">+                                 context.attributePrototypes,</span>
<span class="line-added">+                                 attributeName,</span>
<span class="line-added">+                                 currentOffset,</span>
<span class="line-added">+                                 attributeLength,</span>
<span class="line-added">+                                 charBuffer,</span>
<span class="line-added">+                                 -1,</span>
<span class="line-added">+                                 null);</span>
<span class="line-added">+                 attribute.nextAttribute = attributes;</span>
<span class="line-added">+                 attributes = attribute;</span>
<span class="line-added">+             }</span>
<span class="line-added">+             currentOffset += attributeLength;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         RecordComponentVisitor recordComponentVisitor =</span>
<span class="line-added">+                 classVisitor.visitRecordComponent(name, descriptor, signature);</span>
<span class="line-added">+         if (recordComponentVisitor == null) {</span>
<span class="line-added">+             return currentOffset;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Visit the RuntimeVisibleAnnotations attribute.</span>
<span class="line-added">+         if (runtimeVisibleAnnotationsOffset != 0) {</span>
<span class="line-added">+             int numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</span>
<span class="line-added">+             int currentAnnotationOffset = runtimeVisibleAnnotationsOffset + 2;</span>
<span class="line-added">+             while (numAnnotations-- &gt; 0) {</span>
<span class="line-added">+                 // Parse the type_index field.</span>
<span class="line-added">+                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="line-added">+                 currentAnnotationOffset += 2;</span>
<span class="line-added">+                 // Parse num_element_value_pairs and element_value_pairs and visit these values.</span>
<span class="line-added">+                 currentAnnotationOffset =</span>
<span class="line-added">+                         readElementValues(</span>
<span class="line-added">+                                 recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible = */ true),</span>
<span class="line-added">+                                 currentAnnotationOffset,</span>
<span class="line-added">+                                 /* named = */ true,</span>
<span class="line-added">+                                 charBuffer);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Visit the RuntimeInvisibleAnnotations attribute.</span>
<span class="line-added">+         if (runtimeInvisibleAnnotationsOffset != 0) {</span>
<span class="line-added">+             int numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</span>
<span class="line-added">+             int currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + 2;</span>
<span class="line-added">+             while (numAnnotations-- &gt; 0) {</span>
<span class="line-added">+                 // Parse the type_index field.</span>
<span class="line-added">+                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="line-added">+                 currentAnnotationOffset += 2;</span>
<span class="line-added">+                 // Parse num_element_value_pairs and element_value_pairs and visit these values.</span>
<span class="line-added">+                 currentAnnotationOffset =</span>
<span class="line-added">+                         readElementValues(</span>
<span class="line-added">+                                 recordComponentVisitor.visitAnnotation(annotationDescriptor, /* visible = */ false),</span>
<span class="line-added">+                                 currentAnnotationOffset,</span>
<span class="line-added">+                                 /* named = */ true,</span>
<span class="line-added">+                                 charBuffer);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Visit the RuntimeVisibleTypeAnnotations attribute.</span>
<span class="line-added">+         if (runtimeVisibleTypeAnnotationsOffset != 0) {</span>
<span class="line-added">+             int numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</span>
<span class="line-added">+             int currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + 2;</span>
<span class="line-added">+             while (numAnnotations-- &gt; 0) {</span>
<span class="line-added">+                 // Parse the target_type, target_info and target_path fields.</span>
<span class="line-added">+                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span>
<span class="line-added">+                 // Parse the type_index field.</span>
<span class="line-added">+                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="line-added">+                 currentAnnotationOffset += 2;</span>
<span class="line-added">+                 // Parse num_element_value_pairs and element_value_pairs and visit these values.</span>
<span class="line-added">+                 currentAnnotationOffset =</span>
<span class="line-added">+                         readElementValues(</span>
<span class="line-added">+                                 recordComponentVisitor.visitTypeAnnotation(</span>
<span class="line-added">+                                         context.currentTypeAnnotationTarget,</span>
<span class="line-added">+                                         context.currentTypeAnnotationTargetPath,</span>
<span class="line-added">+                                         annotationDescriptor,</span>
<span class="line-added">+                                         /* visible = */ true),</span>
<span class="line-added">+                                 currentAnnotationOffset,</span>
<span class="line-added">+                                 /* named = */ true,</span>
<span class="line-added">+                                 charBuffer);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Visit the RuntimeInvisibleTypeAnnotations attribute.</span>
<span class="line-added">+         if (runtimeInvisibleTypeAnnotationsOffset != 0) {</span>
<span class="line-added">+             int numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</span>
<span class="line-added">+             int currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + 2;</span>
<span class="line-added">+             while (numAnnotations-- &gt; 0) {</span>
<span class="line-added">+                 // Parse the target_type, target_info and target_path fields.</span>
<span class="line-added">+                 currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span>
<span class="line-added">+                 // Parse the type_index field.</span>
<span class="line-added">+                 String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span>
<span class="line-added">+                 currentAnnotationOffset += 2;</span>
<span class="line-added">+                 // Parse num_element_value_pairs and element_value_pairs and visit these values.</span>
<span class="line-added">+                 currentAnnotationOffset =</span>
<span class="line-added">+                         readElementValues(</span>
<span class="line-added">+                                 recordComponentVisitor.visitTypeAnnotation(</span>
<span class="line-added">+                                         context.currentTypeAnnotationTarget,</span>
<span class="line-added">+                                         context.currentTypeAnnotationTargetPath,</span>
<span class="line-added">+                                         annotationDescriptor,</span>
<span class="line-added">+                                         /* visible = */ false),</span>
<span class="line-added">+                                 currentAnnotationOffset,</span>
<span class="line-added">+                                 /* named = */ true,</span>
<span class="line-added">+                                 charBuffer);</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Visit the non standard attributes.</span>
<span class="line-added">+         while (attributes != null) {</span>
<span class="line-added">+             // Copy and reset the nextAttribute field so that it can also be used in FieldWriter.</span>
<span class="line-added">+             Attribute nextAttribute = attributes.nextAttribute;</span>
<span class="line-added">+             attributes.nextAttribute = null;</span>
<span class="line-added">+             recordComponentVisitor.visitAttribute(attributes);</span>
<span class="line-added">+             attributes = nextAttribute;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Visit the end of the field.</span>
<span class="line-added">+         recordComponentVisitor.visitEnd();</span>
<span class="line-added">+         return currentOffset;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
        * Reads a JVMS field_info structure and makes the given visitor visit it.
        *
        * @param classVisitor the visitor that must visit the field.
        * @param context information about the class being parsed.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1157,23 ***</span>
          // the content of these attributes.
          if (methodVisitor instanceof MethodWriter) {
              MethodWriter methodWriter = (MethodWriter) methodVisitor;
              if (methodWriter.canCopyMethodAttributes(
                      this,
<span class="line-removed">-                     methodInfoOffset,</span>
<span class="line-removed">-                     currentOffset - methodInfoOffset,</span>
                      synthetic,
                      (context.currentMethodAccessFlags &amp; Opcodes.ACC_DEPRECATED) != 0,
                      readUnsignedShort(methodInfoOffset + 4),
                      signatureIndex,
                      exceptionsOffset)) {
                  return currentOffset;
              }
          }
  
          // Visit the MethodParameters attribute.
<span class="line-modified">!         if (methodParametersOffset != 0) {</span>
              int parametersCount = readByte(methodParametersOffset);
              int currentParameterOffset = methodParametersOffset + 1;
              while (parametersCount-- &gt; 0) {
                  // Read the name_index and access_flags fields and visit them.
                  methodVisitor.visitParameter(
<span class="line-new-header">--- 1372,22 ---</span>
          // the content of these attributes.
          if (methodVisitor instanceof MethodWriter) {
              MethodWriter methodWriter = (MethodWriter) methodVisitor;
              if (methodWriter.canCopyMethodAttributes(
                      this,
                      synthetic,
                      (context.currentMethodAccessFlags &amp; Opcodes.ACC_DEPRECATED) != 0,
                      readUnsignedShort(methodInfoOffset + 4),
                      signatureIndex,
                      exceptionsOffset)) {
<span class="line-added">+                 methodWriter.setMethodAttributesSource(methodInfoOffset, currentOffset - methodInfoOffset);</span>
                  return currentOffset;
              }
          }
  
          // Visit the MethodParameters attribute.
<span class="line-modified">!         if (methodParametersOffset != 0 &amp;&amp; (context.parsingOptions &amp; SKIP_DEBUG) == 0) {</span>
              int parametersCount = readByte(methodParametersOffset);
              int currentParameterOffset = methodParametersOffset + 1;
              while (parametersCount-- &gt; 0) {
                  // Read the name_index and access_flags fields and visit them.
                  methodVisitor.visitParameter(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1318,19 ***</span>
      /**
        * Reads a JVMS &#39;Code&#39; attribute and makes the given visitor visit it.
        *
        * @param methodVisitor the visitor that must visit the Code attribute.
        * @param context information about the class being parsed.
<span class="line-modified">!       * @param codeOffset the start offset in {@link #b} of the Code attribute, excluding its</span>
<span class="line-modified">!       *     attribute_name_index and attribute_length fields.</span>
        */
      private void readCode(
              final MethodVisitor methodVisitor, final Context context, final int codeOffset) {
          int currentOffset = codeOffset;
  
          // Read the max_stack, max_locals and code_length fields.
<span class="line-modified">!         final byte[] classFileBuffer = b;</span>
          final char[] charBuffer = context.charBuffer;
          final int maxStack = readUnsignedShort(currentOffset);
          final int maxLocals = readUnsignedShort(currentOffset + 2);
          final int codeLength = readInt(currentOffset + 4);
          currentOffset += 8;
<span class="line-new-header">--- 1532,19 ---</span>
      /**
        * Reads a JVMS &#39;Code&#39; attribute and makes the given visitor visit it.
        *
        * @param methodVisitor the visitor that must visit the Code attribute.
        * @param context information about the class being parsed.
<span class="line-modified">!       * @param codeOffset the start offset in {@link #classFileBuffer} of the Code attribute, excluding</span>
<span class="line-modified">!       *     its attribute_name_index and attribute_length fields.</span>
        */
      private void readCode(
              final MethodVisitor methodVisitor, final Context context, final int codeOffset) {
          int currentOffset = codeOffset;
  
          // Read the max_stack, max_locals and code_length fields.
<span class="line-modified">!         final byte[] classBuffer = classFileBuffer;</span>
          final char[] charBuffer = context.charBuffer;
          final int maxStack = readUnsignedShort(currentOffset);
          final int maxLocals = readUnsignedShort(currentOffset + 2);
          final int codeLength = readInt(currentOffset + 4);
          currentOffset += 8;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1339,119 ***</span>
          final int bytecodeStartOffset = currentOffset;
          final int bytecodeEndOffset = currentOffset + codeLength;
          final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];
          while (currentOffset &lt; bytecodeEndOffset) {
              final int bytecodeOffset = currentOffset - bytecodeStartOffset;
<span class="line-modified">!             final int opcode = classFileBuffer[currentOffset] &amp; 0xFF;</span>
              switch (opcode) {
<span class="line-modified">!                 case Constants.NOP:</span>
<span class="line-modified">!                 case Constants.ACONST_NULL:</span>
<span class="line-modified">!                 case Constants.ICONST_M1:</span>
<span class="line-modified">!                 case Constants.ICONST_0:</span>
<span class="line-modified">!                 case Constants.ICONST_1:</span>
<span class="line-modified">!                 case Constants.ICONST_2:</span>
<span class="line-modified">!                 case Constants.ICONST_3:</span>
<span class="line-modified">!                 case Constants.ICONST_4:</span>
<span class="line-modified">!                 case Constants.ICONST_5:</span>
<span class="line-modified">!                 case Constants.LCONST_0:</span>
<span class="line-modified">!                 case Constants.LCONST_1:</span>
<span class="line-modified">!                 case Constants.FCONST_0:</span>
<span class="line-modified">!                 case Constants.FCONST_1:</span>
<span class="line-modified">!                 case Constants.FCONST_2:</span>
<span class="line-modified">!                 case Constants.DCONST_0:</span>
<span class="line-modified">!                 case Constants.DCONST_1:</span>
<span class="line-modified">!                 case Constants.IALOAD:</span>
<span class="line-modified">!                 case Constants.LALOAD:</span>
<span class="line-modified">!                 case Constants.FALOAD:</span>
<span class="line-modified">!                 case Constants.DALOAD:</span>
<span class="line-modified">!                 case Constants.AALOAD:</span>
<span class="line-modified">!                 case Constants.BALOAD:</span>
<span class="line-modified">!                 case Constants.CALOAD:</span>
<span class="line-modified">!                 case Constants.SALOAD:</span>
<span class="line-modified">!                 case Constants.IASTORE:</span>
<span class="line-modified">!                 case Constants.LASTORE:</span>
<span class="line-modified">!                 case Constants.FASTORE:</span>
<span class="line-modified">!                 case Constants.DASTORE:</span>
<span class="line-modified">!                 case Constants.AASTORE:</span>
<span class="line-modified">!                 case Constants.BASTORE:</span>
<span class="line-modified">!                 case Constants.CASTORE:</span>
<span class="line-modified">!                 case Constants.SASTORE:</span>
<span class="line-modified">!                 case Constants.POP:</span>
<span class="line-modified">!                 case Constants.POP2:</span>
<span class="line-modified">!                 case Constants.DUP:</span>
<span class="line-modified">!                 case Constants.DUP_X1:</span>
<span class="line-modified">!                 case Constants.DUP_X2:</span>
<span class="line-modified">!                 case Constants.DUP2:</span>
<span class="line-modified">!                 case Constants.DUP2_X1:</span>
<span class="line-modified">!                 case Constants.DUP2_X2:</span>
<span class="line-modified">!                 case Constants.SWAP:</span>
<span class="line-modified">!                 case Constants.IADD:</span>
<span class="line-modified">!                 case Constants.LADD:</span>
<span class="line-modified">!                 case Constants.FADD:</span>
<span class="line-modified">!                 case Constants.DADD:</span>
<span class="line-modified">!                 case Constants.ISUB:</span>
<span class="line-modified">!                 case Constants.LSUB:</span>
<span class="line-modified">!                 case Constants.FSUB:</span>
<span class="line-modified">!                 case Constants.DSUB:</span>
<span class="line-modified">!                 case Constants.IMUL:</span>
<span class="line-modified">!                 case Constants.LMUL:</span>
<span class="line-modified">!                 case Constants.FMUL:</span>
<span class="line-modified">!                 case Constants.DMUL:</span>
<span class="line-modified">!                 case Constants.IDIV:</span>
<span class="line-modified">!                 case Constants.LDIV:</span>
<span class="line-modified">!                 case Constants.FDIV:</span>
<span class="line-modified">!                 case Constants.DDIV:</span>
<span class="line-modified">!                 case Constants.IREM:</span>
<span class="line-modified">!                 case Constants.LREM:</span>
<span class="line-modified">!                 case Constants.FREM:</span>
<span class="line-modified">!                 case Constants.DREM:</span>
<span class="line-modified">!                 case Constants.INEG:</span>
<span class="line-modified">!                 case Constants.LNEG:</span>
<span class="line-modified">!                 case Constants.FNEG:</span>
<span class="line-modified">!                 case Constants.DNEG:</span>
<span class="line-modified">!                 case Constants.ISHL:</span>
<span class="line-modified">!                 case Constants.LSHL:</span>
<span class="line-modified">!                 case Constants.ISHR:</span>
<span class="line-modified">!                 case Constants.LSHR:</span>
<span class="line-modified">!                 case Constants.IUSHR:</span>
<span class="line-modified">!                 case Constants.LUSHR:</span>
<span class="line-modified">!                 case Constants.IAND:</span>
<span class="line-modified">!                 case Constants.LAND:</span>
<span class="line-modified">!                 case Constants.IOR:</span>
<span class="line-modified">!                 case Constants.LOR:</span>
<span class="line-modified">!                 case Constants.IXOR:</span>
<span class="line-modified">!                 case Constants.LXOR:</span>
<span class="line-modified">!                 case Constants.I2L:</span>
<span class="line-modified">!                 case Constants.I2F:</span>
<span class="line-modified">!                 case Constants.I2D:</span>
<span class="line-modified">!                 case Constants.L2I:</span>
<span class="line-modified">!                 case Constants.L2F:</span>
<span class="line-modified">!                 case Constants.L2D:</span>
<span class="line-modified">!                 case Constants.F2I:</span>
<span class="line-modified">!                 case Constants.F2L:</span>
<span class="line-modified">!                 case Constants.F2D:</span>
<span class="line-modified">!                 case Constants.D2I:</span>
<span class="line-modified">!                 case Constants.D2L:</span>
<span class="line-modified">!                 case Constants.D2F:</span>
<span class="line-modified">!                 case Constants.I2B:</span>
<span class="line-modified">!                 case Constants.I2C:</span>
<span class="line-modified">!                 case Constants.I2S:</span>
<span class="line-modified">!                 case Constants.LCMP:</span>
<span class="line-modified">!                 case Constants.FCMPL:</span>
<span class="line-modified">!                 case Constants.FCMPG:</span>
<span class="line-modified">!                 case Constants.DCMPL:</span>
<span class="line-modified">!                 case Constants.DCMPG:</span>
<span class="line-modified">!                 case Constants.IRETURN:</span>
<span class="line-modified">!                 case Constants.LRETURN:</span>
<span class="line-modified">!                 case Constants.FRETURN:</span>
<span class="line-modified">!                 case Constants.DRETURN:</span>
<span class="line-modified">!                 case Constants.ARETURN:</span>
<span class="line-modified">!                 case Constants.RETURN:</span>
<span class="line-modified">!                 case Constants.ARRAYLENGTH:</span>
<span class="line-modified">!                 case Constants.ATHROW:</span>
<span class="line-modified">!                 case Constants.MONITORENTER:</span>
<span class="line-modified">!                 case Constants.MONITOREXIT:</span>
                  case Constants.ILOAD_0:
                  case Constants.ILOAD_1:
                  case Constants.ILOAD_2:
                  case Constants.ILOAD_3:
                  case Constants.LLOAD_0:
<span class="line-new-header">--- 1553,119 ---</span>
          final int bytecodeStartOffset = currentOffset;
          final int bytecodeEndOffset = currentOffset + codeLength;
          final Label[] labels = context.currentMethodLabels = new Label[codeLength + 1];
          while (currentOffset &lt; bytecodeEndOffset) {
              final int bytecodeOffset = currentOffset - bytecodeStartOffset;
<span class="line-modified">!             final int opcode = classBuffer[currentOffset] &amp; 0xFF;</span>
              switch (opcode) {
<span class="line-modified">!                 case Opcodes.NOP:</span>
<span class="line-modified">!                 case Opcodes.ACONST_NULL:</span>
<span class="line-modified">!                 case Opcodes.ICONST_M1:</span>
<span class="line-modified">!                 case Opcodes.ICONST_0:</span>
<span class="line-modified">!                 case Opcodes.ICONST_1:</span>
<span class="line-modified">!                 case Opcodes.ICONST_2:</span>
<span class="line-modified">!                 case Opcodes.ICONST_3:</span>
<span class="line-modified">!                 case Opcodes.ICONST_4:</span>
<span class="line-modified">!                 case Opcodes.ICONST_5:</span>
<span class="line-modified">!                 case Opcodes.LCONST_0:</span>
<span class="line-modified">!                 case Opcodes.LCONST_1:</span>
<span class="line-modified">!                 case Opcodes.FCONST_0:</span>
<span class="line-modified">!                 case Opcodes.FCONST_1:</span>
<span class="line-modified">!                 case Opcodes.FCONST_2:</span>
<span class="line-modified">!                 case Opcodes.DCONST_0:</span>
<span class="line-modified">!                 case Opcodes.DCONST_1:</span>
<span class="line-modified">!                 case Opcodes.IALOAD:</span>
<span class="line-modified">!                 case Opcodes.LALOAD:</span>
<span class="line-modified">!                 case Opcodes.FALOAD:</span>
<span class="line-modified">!                 case Opcodes.DALOAD:</span>
<span class="line-modified">!                 case Opcodes.AALOAD:</span>
<span class="line-modified">!                 case Opcodes.BALOAD:</span>
<span class="line-modified">!                 case Opcodes.CALOAD:</span>
<span class="line-modified">!                 case Opcodes.SALOAD:</span>
<span class="line-modified">!                 case Opcodes.IASTORE:</span>
<span class="line-modified">!                 case Opcodes.LASTORE:</span>
<span class="line-modified">!                 case Opcodes.FASTORE:</span>
<span class="line-modified">!                 case Opcodes.DASTORE:</span>
<span class="line-modified">!                 case Opcodes.AASTORE:</span>
<span class="line-modified">!                 case Opcodes.BASTORE:</span>
<span class="line-modified">!                 case Opcodes.CASTORE:</span>
<span class="line-modified">!                 case Opcodes.SASTORE:</span>
<span class="line-modified">!                 case Opcodes.POP:</span>
<span class="line-modified">!                 case Opcodes.POP2:</span>
<span class="line-modified">!                 case Opcodes.DUP:</span>
<span class="line-modified">!                 case Opcodes.DUP_X1:</span>
<span class="line-modified">!                 case Opcodes.DUP_X2:</span>
<span class="line-modified">!                 case Opcodes.DUP2:</span>
<span class="line-modified">!                 case Opcodes.DUP2_X1:</span>
<span class="line-modified">!                 case Opcodes.DUP2_X2:</span>
<span class="line-modified">!                 case Opcodes.SWAP:</span>
<span class="line-modified">!                 case Opcodes.IADD:</span>
<span class="line-modified">!                 case Opcodes.LADD:</span>
<span class="line-modified">!                 case Opcodes.FADD:</span>
<span class="line-modified">!                 case Opcodes.DADD:</span>
<span class="line-modified">!                 case Opcodes.ISUB:</span>
<span class="line-modified">!                 case Opcodes.LSUB:</span>
<span class="line-modified">!                 case Opcodes.FSUB:</span>
<span class="line-modified">!                 case Opcodes.DSUB:</span>
<span class="line-modified">!                 case Opcodes.IMUL:</span>
<span class="line-modified">!                 case Opcodes.LMUL:</span>
<span class="line-modified">!                 case Opcodes.FMUL:</span>
<span class="line-modified">!                 case Opcodes.DMUL:</span>
<span class="line-modified">!                 case Opcodes.IDIV:</span>
<span class="line-modified">!                 case Opcodes.LDIV:</span>
<span class="line-modified">!                 case Opcodes.FDIV:</span>
<span class="line-modified">!                 case Opcodes.DDIV:</span>
<span class="line-modified">!                 case Opcodes.IREM:</span>
<span class="line-modified">!                 case Opcodes.LREM:</span>
<span class="line-modified">!                 case Opcodes.FREM:</span>
<span class="line-modified">!                 case Opcodes.DREM:</span>
<span class="line-modified">!                 case Opcodes.INEG:</span>
<span class="line-modified">!                 case Opcodes.LNEG:</span>
<span class="line-modified">!                 case Opcodes.FNEG:</span>
<span class="line-modified">!                 case Opcodes.DNEG:</span>
<span class="line-modified">!                 case Opcodes.ISHL:</span>
<span class="line-modified">!                 case Opcodes.LSHL:</span>
<span class="line-modified">!                 case Opcodes.ISHR:</span>
<span class="line-modified">!                 case Opcodes.LSHR:</span>
<span class="line-modified">!                 case Opcodes.IUSHR:</span>
<span class="line-modified">!                 case Opcodes.LUSHR:</span>
<span class="line-modified">!                 case Opcodes.IAND:</span>
<span class="line-modified">!                 case Opcodes.LAND:</span>
<span class="line-modified">!                 case Opcodes.IOR:</span>
<span class="line-modified">!                 case Opcodes.LOR:</span>
<span class="line-modified">!                 case Opcodes.IXOR:</span>
<span class="line-modified">!                 case Opcodes.LXOR:</span>
<span class="line-modified">!                 case Opcodes.I2L:</span>
<span class="line-modified">!                 case Opcodes.I2F:</span>
<span class="line-modified">!                 case Opcodes.I2D:</span>
<span class="line-modified">!                 case Opcodes.L2I:</span>
<span class="line-modified">!                 case Opcodes.L2F:</span>
<span class="line-modified">!                 case Opcodes.L2D:</span>
<span class="line-modified">!                 case Opcodes.F2I:</span>
<span class="line-modified">!                 case Opcodes.F2L:</span>
<span class="line-modified">!                 case Opcodes.F2D:</span>
<span class="line-modified">!                 case Opcodes.D2I:</span>
<span class="line-modified">!                 case Opcodes.D2L:</span>
<span class="line-modified">!                 case Opcodes.D2F:</span>
<span class="line-modified">!                 case Opcodes.I2B:</span>
<span class="line-modified">!                 case Opcodes.I2C:</span>
<span class="line-modified">!                 case Opcodes.I2S:</span>
<span class="line-modified">!                 case Opcodes.LCMP:</span>
<span class="line-modified">!                 case Opcodes.FCMPL:</span>
<span class="line-modified">!                 case Opcodes.FCMPG:</span>
<span class="line-modified">!                 case Opcodes.DCMPL:</span>
<span class="line-modified">!                 case Opcodes.DCMPG:</span>
<span class="line-modified">!                 case Opcodes.IRETURN:</span>
<span class="line-modified">!                 case Opcodes.LRETURN:</span>
<span class="line-modified">!                 case Opcodes.FRETURN:</span>
<span class="line-modified">!                 case Opcodes.DRETURN:</span>
<span class="line-modified">!                 case Opcodes.ARETURN:</span>
<span class="line-modified">!                 case Opcodes.RETURN:</span>
<span class="line-modified">!                 case Opcodes.ARRAYLENGTH:</span>
<span class="line-modified">!                 case Opcodes.ATHROW:</span>
<span class="line-modified">!                 case Opcodes.MONITORENTER:</span>
<span class="line-modified">!                 case Opcodes.MONITOREXIT:</span>
                  case Constants.ILOAD_0:
                  case Constants.ILOAD_1:
                  case Constants.ILOAD_2:
                  case Constants.ILOAD_3:
                  case Constants.LLOAD_0:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1490,28 ***</span>
                  case Constants.ASTORE_1:
                  case Constants.ASTORE_2:
                  case Constants.ASTORE_3:
                      currentOffset += 1;
                      break;
<span class="line-modified">!                 case Constants.IFEQ:</span>
<span class="line-modified">!                 case Constants.IFNE:</span>
<span class="line-modified">!                 case Constants.IFLT:</span>
<span class="line-modified">!                 case Constants.IFGE:</span>
<span class="line-modified">!                 case Constants.IFGT:</span>
<span class="line-modified">!                 case Constants.IFLE:</span>
<span class="line-modified">!                 case Constants.IF_ICMPEQ:</span>
<span class="line-modified">!                 case Constants.IF_ICMPNE:</span>
<span class="line-modified">!                 case Constants.IF_ICMPLT:</span>
<span class="line-modified">!                 case Constants.IF_ICMPGE:</span>
<span class="line-modified">!                 case Constants.IF_ICMPGT:</span>
<span class="line-modified">!                 case Constants.IF_ICMPLE:</span>
<span class="line-modified">!                 case Constants.IF_ACMPEQ:</span>
<span class="line-modified">!                 case Constants.IF_ACMPNE:</span>
<span class="line-modified">!                 case Constants.GOTO:</span>
<span class="line-modified">!                 case Constants.JSR:</span>
<span class="line-modified">!                 case Constants.IFNULL:</span>
<span class="line-modified">!                 case Constants.IFNONNULL:</span>
                      createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);
                      currentOffset += 3;
                      break;
                  case Constants.ASM_IFEQ:
                  case Constants.ASM_IFNE:
<span class="line-new-header">--- 1704,28 ---</span>
                  case Constants.ASTORE_1:
                  case Constants.ASTORE_2:
                  case Constants.ASTORE_3:
                      currentOffset += 1;
                      break;
<span class="line-modified">!                 case Opcodes.IFEQ:</span>
<span class="line-modified">!                 case Opcodes.IFNE:</span>
<span class="line-modified">!                 case Opcodes.IFLT:</span>
<span class="line-modified">!                 case Opcodes.IFGE:</span>
<span class="line-modified">!                 case Opcodes.IFGT:</span>
<span class="line-modified">!                 case Opcodes.IFLE:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPEQ:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPNE:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPLT:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPGE:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPGT:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPLE:</span>
<span class="line-modified">!                 case Opcodes.IF_ACMPEQ:</span>
<span class="line-modified">!                 case Opcodes.IF_ACMPNE:</span>
<span class="line-modified">!                 case Opcodes.GOTO:</span>
<span class="line-modified">!                 case Opcodes.JSR:</span>
<span class="line-modified">!                 case Opcodes.IFNULL:</span>
<span class="line-modified">!                 case Opcodes.IFNONNULL:</span>
                      createLabel(bytecodeOffset + readShort(currentOffset + 1), labels);
                      currentOffset += 3;
                      break;
                  case Constants.ASM_IFEQ:
                  case Constants.ASM_IFNE:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1539,32 ***</span>
                  case Constants.ASM_GOTO_W:
                      createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);
                      currentOffset += 5;
                      break;
                  case Constants.WIDE:
<span class="line-modified">!                     switch (classFileBuffer[currentOffset + 1] &amp; 0xFF) {</span>
<span class="line-modified">!                         case Constants.ILOAD:</span>
<span class="line-modified">!                         case Constants.FLOAD:</span>
<span class="line-modified">!                         case Constants.ALOAD:</span>
<span class="line-modified">!                         case Constants.LLOAD:</span>
<span class="line-modified">!                         case Constants.DLOAD:</span>
<span class="line-modified">!                         case Constants.ISTORE:</span>
<span class="line-modified">!                         case Constants.FSTORE:</span>
<span class="line-modified">!                         case Constants.ASTORE:</span>
<span class="line-modified">!                         case Constants.LSTORE:</span>
<span class="line-modified">!                         case Constants.DSTORE:</span>
<span class="line-modified">!                         case Constants.RET:</span>
                              currentOffset += 4;
                              break;
<span class="line-modified">!                         case Constants.IINC:</span>
                              currentOffset += 6;
                              break;
                          default:
                              throw new IllegalArgumentException();
                      }
                      break;
<span class="line-modified">!                 case Constants.TABLESWITCH:</span>
                      // Skip 0 to 3 padding bytes.
                      currentOffset += 4 - (bytecodeOffset &amp; 3);
                      // Read the default label and the number of table entries.
                      createLabel(bytecodeOffset + readInt(currentOffset), labels);
                      int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;
<span class="line-new-header">--- 1753,32 ---</span>
                  case Constants.ASM_GOTO_W:
                      createLabel(bytecodeOffset + readInt(currentOffset + 1), labels);
                      currentOffset += 5;
                      break;
                  case Constants.WIDE:
<span class="line-modified">!                     switch (classBuffer[currentOffset + 1] &amp; 0xFF) {</span>
<span class="line-modified">!                         case Opcodes.ILOAD:</span>
<span class="line-modified">!                         case Opcodes.FLOAD:</span>
<span class="line-modified">!                         case Opcodes.ALOAD:</span>
<span class="line-modified">!                         case Opcodes.LLOAD:</span>
<span class="line-modified">!                         case Opcodes.DLOAD:</span>
<span class="line-modified">!                         case Opcodes.ISTORE:</span>
<span class="line-modified">!                         case Opcodes.FSTORE:</span>
<span class="line-modified">!                         case Opcodes.ASTORE:</span>
<span class="line-modified">!                         case Opcodes.LSTORE:</span>
<span class="line-modified">!                         case Opcodes.DSTORE:</span>
<span class="line-modified">!                         case Opcodes.RET:</span>
                              currentOffset += 4;
                              break;
<span class="line-modified">!                         case Opcodes.IINC:</span>
                              currentOffset += 6;
                              break;
                          default:
                              throw new IllegalArgumentException();
                      }
                      break;
<span class="line-modified">!                 case Opcodes.TABLESWITCH:</span>
                      // Skip 0 to 3 padding bytes.
                      currentOffset += 4 - (bytecodeOffset &amp; 3);
                      // Read the default label and the number of table entries.
                      createLabel(bytecodeOffset + readInt(currentOffset), labels);
                      int numTableEntries = readInt(currentOffset + 8) - readInt(currentOffset + 4) + 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1573,11 ***</span>
                      while (numTableEntries-- &gt; 0) {
                          createLabel(bytecodeOffset + readInt(currentOffset), labels);
                          currentOffset += 4;
                      }
                      break;
<span class="line-modified">!                 case Constants.LOOKUPSWITCH:</span>
                      // Skip 0 to 3 padding bytes.
                      currentOffset += 4 - (bytecodeOffset &amp; 3);
                      // Read the default label and the number of switch cases.
                      createLabel(bytecodeOffset + readInt(currentOffset), labels);
                      int numSwitchCases = readInt(currentOffset + 4);
<span class="line-new-header">--- 1787,11 ---</span>
                      while (numTableEntries-- &gt; 0) {
                          createLabel(bytecodeOffset + readInt(currentOffset), labels);
                          currentOffset += 4;
                      }
                      break;
<span class="line-modified">!                 case Opcodes.LOOKUPSWITCH:</span>
                      // Skip 0 to 3 padding bytes.
                      currentOffset += 4 - (bytecodeOffset &amp; 3);
                      // Read the default label and the number of switch cases.
                      createLabel(bytecodeOffset + readInt(currentOffset), labels);
                      int numSwitchCases = readInt(currentOffset + 4);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1586,50 ***</span>
                      while (numSwitchCases-- &gt; 0) {
                          createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);
                          currentOffset += 8;
                      }
                      break;
<span class="line-modified">!                 case Constants.ILOAD:</span>
<span class="line-modified">!                 case Constants.LLOAD:</span>
<span class="line-modified">!                 case Constants.FLOAD:</span>
<span class="line-modified">!                 case Constants.DLOAD:</span>
<span class="line-modified">!                 case Constants.ALOAD:</span>
<span class="line-modified">!                 case Constants.ISTORE:</span>
<span class="line-modified">!                 case Constants.LSTORE:</span>
<span class="line-modified">!                 case Constants.FSTORE:</span>
<span class="line-modified">!                 case Constants.DSTORE:</span>
<span class="line-modified">!                 case Constants.ASTORE:</span>
<span class="line-modified">!                 case Constants.RET:</span>
<span class="line-modified">!                 case Constants.BIPUSH:</span>
<span class="line-modified">!                 case Constants.NEWARRAY:</span>
<span class="line-modified">!                 case Constants.LDC:</span>
                      currentOffset += 2;
                      break;
<span class="line-modified">!                 case Constants.SIPUSH:</span>
                  case Constants.LDC_W:
                  case Constants.LDC2_W:
<span class="line-modified">!                 case Constants.GETSTATIC:</span>
<span class="line-modified">!                 case Constants.PUTSTATIC:</span>
<span class="line-modified">!                 case Constants.GETFIELD:</span>
<span class="line-modified">!                 case Constants.PUTFIELD:</span>
<span class="line-modified">!                 case Constants.DEFAULT:</span>
<span class="line-modified">!                 case Constants.WITHFIELD:</span>
<span class="line-modified">!                 case Constants.INVOKEVIRTUAL:</span>
<span class="line-modified">!                 case Constants.INVOKESPECIAL:</span>
<span class="line-modified">!                 case Constants.INVOKESTATIC:</span>
<span class="line-modified">!                 case Constants.NEW:</span>
<span class="line-modified">!                 case Constants.ANEWARRAY:</span>
<span class="line-modified">!                 case Constants.CHECKCAST:</span>
<span class="line-modified">!                 case Constants.INSTANCEOF:</span>
<span class="line-modified">!                 case Constants.IINC:</span>
                      currentOffset += 3;
                      break;
<span class="line-modified">!                 case Constants.INVOKEINTERFACE:</span>
<span class="line-modified">!                 case Constants.INVOKEDYNAMIC:</span>
                      currentOffset += 5;
                      break;
<span class="line-modified">!                 case Constants.MULTIANEWARRAY:</span>
                      currentOffset += 4;
                      break;
                  default:
                      throw new IllegalArgumentException();
              }
<span class="line-new-header">--- 1800,50 ---</span>
                      while (numSwitchCases-- &gt; 0) {
                          createLabel(bytecodeOffset + readInt(currentOffset + 4), labels);
                          currentOffset += 8;
                      }
                      break;
<span class="line-modified">!                 case Opcodes.ILOAD:</span>
<span class="line-modified">!                 case Opcodes.LLOAD:</span>
<span class="line-modified">!                 case Opcodes.FLOAD:</span>
<span class="line-modified">!                 case Opcodes.DLOAD:</span>
<span class="line-modified">!                 case Opcodes.ALOAD:</span>
<span class="line-modified">!                 case Opcodes.ISTORE:</span>
<span class="line-modified">!                 case Opcodes.LSTORE:</span>
<span class="line-modified">!                 case Opcodes.FSTORE:</span>
<span class="line-modified">!                 case Opcodes.DSTORE:</span>
<span class="line-modified">!                 case Opcodes.ASTORE:</span>
<span class="line-modified">!                 case Opcodes.RET:</span>
<span class="line-modified">!                 case Opcodes.BIPUSH:</span>
<span class="line-modified">!                 case Opcodes.NEWARRAY:</span>
<span class="line-modified">!                 case Opcodes.LDC:</span>
                      currentOffset += 2;
                      break;
<span class="line-modified">!                 case Opcodes.SIPUSH:</span>
                  case Constants.LDC_W:
                  case Constants.LDC2_W:
<span class="line-modified">!                 case Opcodes.GETSTATIC:</span>
<span class="line-modified">!                 case Opcodes.PUTSTATIC:</span>
<span class="line-modified">!                 case Opcodes.GETFIELD:</span>
<span class="line-modified">!                 case Opcodes.PUTFIELD:</span>
<span class="line-modified">!                 case Opcodes.DEFAULT:</span>
<span class="line-modified">!                 case Opcodes.WITHFIELD:</span>
<span class="line-modified">!                 case Opcodes.INVOKEVIRTUAL:</span>
<span class="line-modified">!                 case Opcodes.INVOKESPECIAL:</span>
<span class="line-modified">!                 case Opcodes.INVOKESTATIC:</span>
<span class="line-modified">!                 case Opcodes.NEW:</span>
<span class="line-modified">!                 case Opcodes.ANEWARRAY:</span>
<span class="line-modified">!                 case Opcodes.CHECKCAST:</span>
<span class="line-modified">!                 case Opcodes.INSTANCEOF:</span>
<span class="line-modified">!                 case Opcodes.IINC:</span>
                      currentOffset += 3;
                      break;
<span class="line-modified">!                 case Opcodes.INVOKEINTERFACE:</span>
<span class="line-modified">!                 case Opcodes.INVOKEDYNAMIC:</span>
                      currentOffset += 5;
                      break;
<span class="line-modified">!                 case Opcodes.MULTIANEWARRAY:</span>
                      currentOffset += 4;
                      break;
                  default:
                      throw new IllegalArgumentException();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1790,15 ***</span>
              // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,
              // and the only consequence will be the creation of an unneeded label. This is better than
              // creating a label for each NEW instruction, and faster than fully decoding the whole stack
              // map table.
              for (int offset = stackMapFrameOffset; offset &lt; stackMapTableEndOffset - 2; ++offset) {
<span class="line-modified">!                 if (classFileBuffer[offset] == Frame.ITEM_UNINITIALIZED) {</span>
                      int potentialBytecodeOffset = readUnsignedShort(offset + 1);
                      if (potentialBytecodeOffset &gt;= 0
                              &amp;&amp; potentialBytecodeOffset &lt; codeLength
<span class="line-modified">!                             &amp;&amp; (classFileBuffer[bytecodeStartOffset + potentialBytecodeOffset] &amp; 0xFF)</span>
                                      == Opcodes.NEW) {
                          createLabel(potentialBytecodeOffset, labels);
                      }
                  }
              }
<span class="line-new-header">--- 2004,15 ---</span>
              // We may find false positives (i.e. not real UNINITIALIZED types), but this should be rare,
              // and the only consequence will be the creation of an unneeded label. This is better than
              // creating a label for each NEW instruction, and faster than fully decoding the whole stack
              // map table.
              for (int offset = stackMapFrameOffset; offset &lt; stackMapTableEndOffset - 2; ++offset) {
<span class="line-modified">!                 if (classBuffer[offset] == Frame.ITEM_UNINITIALIZED) {</span>
                      int potentialBytecodeOffset = readUnsignedShort(offset + 1);
                      if (potentialBytecodeOffset &gt;= 0
                              &amp;&amp; potentialBytecodeOffset &lt; codeLength
<span class="line-modified">!                             &amp;&amp; (classBuffer[bytecodeStartOffset + potentialBytecodeOffset] &amp; 0xFF)</span>
                                      == Opcodes.NEW) {
                          createLabel(potentialBytecodeOffset, labels);
                      }
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1890,119 ***</span>
                  }
                  insertFrame = false;
              }
  
              // Visit the instruction at this bytecode offset.
<span class="line-modified">!             int opcode = classFileBuffer[currentOffset] &amp; 0xFF;</span>
              switch (opcode) {
<span class="line-modified">!                 case Constants.NOP:</span>
<span class="line-modified">!                 case Constants.ACONST_NULL:</span>
<span class="line-modified">!                 case Constants.ICONST_M1:</span>
<span class="line-modified">!                 case Constants.ICONST_0:</span>
<span class="line-modified">!                 case Constants.ICONST_1:</span>
<span class="line-modified">!                 case Constants.ICONST_2:</span>
<span class="line-modified">!                 case Constants.ICONST_3:</span>
<span class="line-modified">!                 case Constants.ICONST_4:</span>
<span class="line-modified">!                 case Constants.ICONST_5:</span>
<span class="line-modified">!                 case Constants.LCONST_0:</span>
<span class="line-modified">!                 case Constants.LCONST_1:</span>
<span class="line-modified">!                 case Constants.FCONST_0:</span>
<span class="line-modified">!                 case Constants.FCONST_1:</span>
<span class="line-modified">!                 case Constants.FCONST_2:</span>
<span class="line-modified">!                 case Constants.DCONST_0:</span>
<span class="line-modified">!                 case Constants.DCONST_1:</span>
<span class="line-modified">!                 case Constants.IALOAD:</span>
<span class="line-modified">!                 case Constants.LALOAD:</span>
<span class="line-modified">!                 case Constants.FALOAD:</span>
<span class="line-modified">!                 case Constants.DALOAD:</span>
<span class="line-modified">!                 case Constants.AALOAD:</span>
<span class="line-modified">!                 case Constants.BALOAD:</span>
<span class="line-modified">!                 case Constants.CALOAD:</span>
<span class="line-modified">!                 case Constants.SALOAD:</span>
<span class="line-modified">!                 case Constants.IASTORE:</span>
<span class="line-modified">!                 case Constants.LASTORE:</span>
<span class="line-modified">!                 case Constants.FASTORE:</span>
<span class="line-modified">!                 case Constants.DASTORE:</span>
<span class="line-modified">!                 case Constants.AASTORE:</span>
<span class="line-modified">!                 case Constants.BASTORE:</span>
<span class="line-modified">!                 case Constants.CASTORE:</span>
<span class="line-modified">!                 case Constants.SASTORE:</span>
<span class="line-modified">!                 case Constants.POP:</span>
<span class="line-modified">!                 case Constants.POP2:</span>
<span class="line-modified">!                 case Constants.DUP:</span>
<span class="line-modified">!                 case Constants.DUP_X1:</span>
<span class="line-modified">!                 case Constants.DUP_X2:</span>
<span class="line-modified">!                 case Constants.DUP2:</span>
<span class="line-modified">!                 case Constants.DUP2_X1:</span>
<span class="line-modified">!                 case Constants.DUP2_X2:</span>
<span class="line-modified">!                 case Constants.SWAP:</span>
<span class="line-modified">!                 case Constants.IADD:</span>
<span class="line-modified">!                 case Constants.LADD:</span>
<span class="line-modified">!                 case Constants.FADD:</span>
<span class="line-modified">!                 case Constants.DADD:</span>
<span class="line-modified">!                 case Constants.ISUB:</span>
<span class="line-modified">!                 case Constants.LSUB:</span>
<span class="line-modified">!                 case Constants.FSUB:</span>
<span class="line-modified">!                 case Constants.DSUB:</span>
<span class="line-modified">!                 case Constants.IMUL:</span>
<span class="line-modified">!                 case Constants.LMUL:</span>
<span class="line-modified">!                 case Constants.FMUL:</span>
<span class="line-modified">!                 case Constants.DMUL:</span>
<span class="line-modified">!                 case Constants.IDIV:</span>
<span class="line-modified">!                 case Constants.LDIV:</span>
<span class="line-modified">!                 case Constants.FDIV:</span>
<span class="line-modified">!                 case Constants.DDIV:</span>
<span class="line-modified">!                 case Constants.IREM:</span>
<span class="line-modified">!                 case Constants.LREM:</span>
<span class="line-modified">!                 case Constants.FREM:</span>
<span class="line-modified">!                 case Constants.DREM:</span>
<span class="line-modified">!                 case Constants.INEG:</span>
<span class="line-modified">!                 case Constants.LNEG:</span>
<span class="line-modified">!                 case Constants.FNEG:</span>
<span class="line-modified">!                 case Constants.DNEG:</span>
<span class="line-modified">!                 case Constants.ISHL:</span>
<span class="line-modified">!                 case Constants.LSHL:</span>
<span class="line-modified">!                 case Constants.ISHR:</span>
<span class="line-modified">!                 case Constants.LSHR:</span>
<span class="line-modified">!                 case Constants.IUSHR:</span>
<span class="line-modified">!                 case Constants.LUSHR:</span>
<span class="line-modified">!                 case Constants.IAND:</span>
<span class="line-modified">!                 case Constants.LAND:</span>
<span class="line-modified">!                 case Constants.IOR:</span>
<span class="line-modified">!                 case Constants.LOR:</span>
<span class="line-modified">!                 case Constants.IXOR:</span>
<span class="line-modified">!                 case Constants.LXOR:</span>
<span class="line-modified">!                 case Constants.I2L:</span>
<span class="line-modified">!                 case Constants.I2F:</span>
<span class="line-modified">!                 case Constants.I2D:</span>
<span class="line-modified">!                 case Constants.L2I:</span>
<span class="line-modified">!                 case Constants.L2F:</span>
<span class="line-modified">!                 case Constants.L2D:</span>
<span class="line-modified">!                 case Constants.F2I:</span>
<span class="line-modified">!                 case Constants.F2L:</span>
<span class="line-modified">!                 case Constants.F2D:</span>
<span class="line-modified">!                 case Constants.D2I:</span>
<span class="line-modified">!                 case Constants.D2L:</span>
<span class="line-modified">!                 case Constants.D2F:</span>
<span class="line-modified">!                 case Constants.I2B:</span>
<span class="line-modified">!                 case Constants.I2C:</span>
<span class="line-modified">!                 case Constants.I2S:</span>
<span class="line-modified">!                 case Constants.LCMP:</span>
<span class="line-modified">!                 case Constants.FCMPL:</span>
<span class="line-modified">!                 case Constants.FCMPG:</span>
<span class="line-modified">!                 case Constants.DCMPL:</span>
<span class="line-modified">!                 case Constants.DCMPG:</span>
<span class="line-modified">!                 case Constants.IRETURN:</span>
<span class="line-modified">!                 case Constants.LRETURN:</span>
<span class="line-modified">!                 case Constants.FRETURN:</span>
<span class="line-modified">!                 case Constants.DRETURN:</span>
<span class="line-modified">!                 case Constants.ARETURN:</span>
<span class="line-modified">!                 case Constants.RETURN:</span>
<span class="line-modified">!                 case Constants.ARRAYLENGTH:</span>
<span class="line-modified">!                 case Constants.ATHROW:</span>
<span class="line-modified">!                 case Constants.MONITORENTER:</span>
<span class="line-modified">!                 case Constants.MONITOREXIT:</span>
                      methodVisitor.visitInsn(opcode);
                      currentOffset += 1;
                      break;
                  case Constants.ILOAD_0:
                  case Constants.ILOAD_1:
<span class="line-new-header">--- 2104,119 ---</span>
                  }
                  insertFrame = false;
              }
  
              // Visit the instruction at this bytecode offset.
<span class="line-modified">!             int opcode = classBuffer[currentOffset] &amp; 0xFF;</span>
              switch (opcode) {
<span class="line-modified">!                 case Opcodes.NOP:</span>
<span class="line-modified">!                 case Opcodes.ACONST_NULL:</span>
<span class="line-modified">!                 case Opcodes.ICONST_M1:</span>
<span class="line-modified">!                 case Opcodes.ICONST_0:</span>
<span class="line-modified">!                 case Opcodes.ICONST_1:</span>
<span class="line-modified">!                 case Opcodes.ICONST_2:</span>
<span class="line-modified">!                 case Opcodes.ICONST_3:</span>
<span class="line-modified">!                 case Opcodes.ICONST_4:</span>
<span class="line-modified">!                 case Opcodes.ICONST_5:</span>
<span class="line-modified">!                 case Opcodes.LCONST_0:</span>
<span class="line-modified">!                 case Opcodes.LCONST_1:</span>
<span class="line-modified">!                 case Opcodes.FCONST_0:</span>
<span class="line-modified">!                 case Opcodes.FCONST_1:</span>
<span class="line-modified">!                 case Opcodes.FCONST_2:</span>
<span class="line-modified">!                 case Opcodes.DCONST_0:</span>
<span class="line-modified">!                 case Opcodes.DCONST_1:</span>
<span class="line-modified">!                 case Opcodes.IALOAD:</span>
<span class="line-modified">!                 case Opcodes.LALOAD:</span>
<span class="line-modified">!                 case Opcodes.FALOAD:</span>
<span class="line-modified">!                 case Opcodes.DALOAD:</span>
<span class="line-modified">!                 case Opcodes.AALOAD:</span>
<span class="line-modified">!                 case Opcodes.BALOAD:</span>
<span class="line-modified">!                 case Opcodes.CALOAD:</span>
<span class="line-modified">!                 case Opcodes.SALOAD:</span>
<span class="line-modified">!                 case Opcodes.IASTORE:</span>
<span class="line-modified">!                 case Opcodes.LASTORE:</span>
<span class="line-modified">!                 case Opcodes.FASTORE:</span>
<span class="line-modified">!                 case Opcodes.DASTORE:</span>
<span class="line-modified">!                 case Opcodes.AASTORE:</span>
<span class="line-modified">!                 case Opcodes.BASTORE:</span>
<span class="line-modified">!                 case Opcodes.CASTORE:</span>
<span class="line-modified">!                 case Opcodes.SASTORE:</span>
<span class="line-modified">!                 case Opcodes.POP:</span>
<span class="line-modified">!                 case Opcodes.POP2:</span>
<span class="line-modified">!                 case Opcodes.DUP:</span>
<span class="line-modified">!                 case Opcodes.DUP_X1:</span>
<span class="line-modified">!                 case Opcodes.DUP_X2:</span>
<span class="line-modified">!                 case Opcodes.DUP2:</span>
<span class="line-modified">!                 case Opcodes.DUP2_X1:</span>
<span class="line-modified">!                 case Opcodes.DUP2_X2:</span>
<span class="line-modified">!                 case Opcodes.SWAP:</span>
<span class="line-modified">!                 case Opcodes.IADD:</span>
<span class="line-modified">!                 case Opcodes.LADD:</span>
<span class="line-modified">!                 case Opcodes.FADD:</span>
<span class="line-modified">!                 case Opcodes.DADD:</span>
<span class="line-modified">!                 case Opcodes.ISUB:</span>
<span class="line-modified">!                 case Opcodes.LSUB:</span>
<span class="line-modified">!                 case Opcodes.FSUB:</span>
<span class="line-modified">!                 case Opcodes.DSUB:</span>
<span class="line-modified">!                 case Opcodes.IMUL:</span>
<span class="line-modified">!                 case Opcodes.LMUL:</span>
<span class="line-modified">!                 case Opcodes.FMUL:</span>
<span class="line-modified">!                 case Opcodes.DMUL:</span>
<span class="line-modified">!                 case Opcodes.IDIV:</span>
<span class="line-modified">!                 case Opcodes.LDIV:</span>
<span class="line-modified">!                 case Opcodes.FDIV:</span>
<span class="line-modified">!                 case Opcodes.DDIV:</span>
<span class="line-modified">!                 case Opcodes.IREM:</span>
<span class="line-modified">!                 case Opcodes.LREM:</span>
<span class="line-modified">!                 case Opcodes.FREM:</span>
<span class="line-modified">!                 case Opcodes.DREM:</span>
<span class="line-modified">!                 case Opcodes.INEG:</span>
<span class="line-modified">!                 case Opcodes.LNEG:</span>
<span class="line-modified">!                 case Opcodes.FNEG:</span>
<span class="line-modified">!                 case Opcodes.DNEG:</span>
<span class="line-modified">!                 case Opcodes.ISHL:</span>
<span class="line-modified">!                 case Opcodes.LSHL:</span>
<span class="line-modified">!                 case Opcodes.ISHR:</span>
<span class="line-modified">!                 case Opcodes.LSHR:</span>
<span class="line-modified">!                 case Opcodes.IUSHR:</span>
<span class="line-modified">!                 case Opcodes.LUSHR:</span>
<span class="line-modified">!                 case Opcodes.IAND:</span>
<span class="line-modified">!                 case Opcodes.LAND:</span>
<span class="line-modified">!                 case Opcodes.IOR:</span>
<span class="line-modified">!                 case Opcodes.LOR:</span>
<span class="line-modified">!                 case Opcodes.IXOR:</span>
<span class="line-modified">!                 case Opcodes.LXOR:</span>
<span class="line-modified">!                 case Opcodes.I2L:</span>
<span class="line-modified">!                 case Opcodes.I2F:</span>
<span class="line-modified">!                 case Opcodes.I2D:</span>
<span class="line-modified">!                 case Opcodes.L2I:</span>
<span class="line-modified">!                 case Opcodes.L2F:</span>
<span class="line-modified">!                 case Opcodes.L2D:</span>
<span class="line-modified">!                 case Opcodes.F2I:</span>
<span class="line-modified">!                 case Opcodes.F2L:</span>
<span class="line-modified">!                 case Opcodes.F2D:</span>
<span class="line-modified">!                 case Opcodes.D2I:</span>
<span class="line-modified">!                 case Opcodes.D2L:</span>
<span class="line-modified">!                 case Opcodes.D2F:</span>
<span class="line-modified">!                 case Opcodes.I2B:</span>
<span class="line-modified">!                 case Opcodes.I2C:</span>
<span class="line-modified">!                 case Opcodes.I2S:</span>
<span class="line-modified">!                 case Opcodes.LCMP:</span>
<span class="line-modified">!                 case Opcodes.FCMPL:</span>
<span class="line-modified">!                 case Opcodes.FCMPG:</span>
<span class="line-modified">!                 case Opcodes.DCMPL:</span>
<span class="line-modified">!                 case Opcodes.DCMPG:</span>
<span class="line-modified">!                 case Opcodes.IRETURN:</span>
<span class="line-modified">!                 case Opcodes.LRETURN:</span>
<span class="line-modified">!                 case Opcodes.FRETURN:</span>
<span class="line-modified">!                 case Opcodes.DRETURN:</span>
<span class="line-modified">!                 case Opcodes.ARETURN:</span>
<span class="line-modified">!                 case Opcodes.RETURN:</span>
<span class="line-modified">!                 case Opcodes.ARRAYLENGTH:</span>
<span class="line-modified">!                 case Opcodes.ATHROW:</span>
<span class="line-modified">!                 case Opcodes.MONITORENTER:</span>
<span class="line-modified">!                 case Opcodes.MONITOREXIT:</span>
                      methodVisitor.visitInsn(opcode);
                      currentOffset += 1;
                      break;
                  case Constants.ILOAD_0:
                  case Constants.ILOAD_1:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2050,28 ***</span>
                  case Constants.ASTORE_3:
                      opcode -= Constants.ISTORE_0;
                      methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode &gt;&gt; 2), opcode &amp; 0x3);
                      currentOffset += 1;
                      break;
<span class="line-modified">!                 case Constants.IFEQ:</span>
<span class="line-modified">!                 case Constants.IFNE:</span>
<span class="line-modified">!                 case Constants.IFLT:</span>
<span class="line-modified">!                 case Constants.IFGE:</span>
<span class="line-modified">!                 case Constants.IFGT:</span>
<span class="line-modified">!                 case Constants.IFLE:</span>
<span class="line-modified">!                 case Constants.IF_ICMPEQ:</span>
<span class="line-modified">!                 case Constants.IF_ICMPNE:</span>
<span class="line-modified">!                 case Constants.IF_ICMPLT:</span>
<span class="line-modified">!                 case Constants.IF_ICMPGE:</span>
<span class="line-modified">!                 case Constants.IF_ICMPGT:</span>
<span class="line-modified">!                 case Constants.IF_ICMPLE:</span>
<span class="line-modified">!                 case Constants.IF_ACMPEQ:</span>
<span class="line-modified">!                 case Constants.IF_ACMPNE:</span>
<span class="line-modified">!                 case Constants.GOTO:</span>
<span class="line-modified">!                 case Constants.JSR:</span>
<span class="line-modified">!                 case Constants.IFNULL:</span>
<span class="line-modified">!                 case Constants.IFNONNULL:</span>
                      methodVisitor.visitJumpInsn(
                              opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);
                      currentOffset += 3;
                      break;
                  case Constants.GOTO_W:
<span class="line-new-header">--- 2264,28 ---</span>
                  case Constants.ASTORE_3:
                      opcode -= Constants.ISTORE_0;
                      methodVisitor.visitVarInsn(Opcodes.ISTORE + (opcode &gt;&gt; 2), opcode &amp; 0x3);
                      currentOffset += 1;
                      break;
<span class="line-modified">!                 case Opcodes.IFEQ:</span>
<span class="line-modified">!                 case Opcodes.IFNE:</span>
<span class="line-modified">!                 case Opcodes.IFLT:</span>
<span class="line-modified">!                 case Opcodes.IFGE:</span>
<span class="line-modified">!                 case Opcodes.IFGT:</span>
<span class="line-modified">!                 case Opcodes.IFLE:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPEQ:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPNE:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPLT:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPGE:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPGT:</span>
<span class="line-modified">!                 case Opcodes.IF_ICMPLE:</span>
<span class="line-modified">!                 case Opcodes.IF_ACMPEQ:</span>
<span class="line-modified">!                 case Opcodes.IF_ACMPNE:</span>
<span class="line-modified">!                 case Opcodes.GOTO:</span>
<span class="line-modified">!                 case Opcodes.JSR:</span>
<span class="line-modified">!                 case Opcodes.IFNULL:</span>
<span class="line-modified">!                 case Opcodes.IFNONNULL:</span>
                      methodVisitor.visitJumpInsn(
                              opcode, labels[currentBytecodeOffset + readShort(currentOffset + 1)]);
                      currentOffset += 3;
                      break;
                  case Constants.GOTO_W:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2128,33 ***</span>
                          }
                          currentOffset += 3;
                          break;
                      }
                  case Constants.ASM_GOTO_W:
<span class="line-modified">!                     {</span>
<span class="line-modified">!                         // Replace ASM_GOTO_W with GOTO_W.</span>
<span class="line-modified">!                         methodVisitor.visitJumpInsn(</span>
<span class="line-modified">!                                 Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);</span>
<span class="line-modified">!                         // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns</span>
<span class="line-modified">!                         // IFNOTxxx &lt;L&gt; ASM_GOTO_W &lt;l&gt; L:..., see MethodWriter), so we need to insert a frame</span>
<span class="line-modified">!                         // here.</span>
<span class="line-modified">!                         insertFrame = true;</span>
<span class="line-modified">!                         currentOffset += 5;</span>
<span class="line-removed">-                         break;</span>
<span class="line-removed">-                     }</span>
                  case Constants.WIDE:
<span class="line-modified">!                     opcode = classFileBuffer[currentOffset + 1] &amp; 0xFF;</span>
                      if (opcode == Opcodes.IINC) {
                          methodVisitor.visitIincInsn(
                                  readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));
                          currentOffset += 6;
                      } else {
                          methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));
                          currentOffset += 4;
                      }
                      break;
<span class="line-modified">!                 case Constants.TABLESWITCH:</span>
                      {
                          // Skip 0 to 3 padding bytes.
                          currentOffset += 4 - (currentBytecodeOffset &amp; 3);
                          // Read the instruction.
                          Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
<span class="line-new-header">--- 2342,31 ---</span>
                          }
                          currentOffset += 3;
                          break;
                      }
                  case Constants.ASM_GOTO_W:
<span class="line-modified">!                     // Replace ASM_GOTO_W with GOTO_W.</span>
<span class="line-modified">!                     methodVisitor.visitJumpInsn(</span>
<span class="line-modified">!                             Constants.GOTO_W, labels[currentBytecodeOffset + readInt(currentOffset + 1)]);</span>
<span class="line-modified">!                     // The instruction just after is a jump target (because ASM_GOTO_W is used in patterns</span>
<span class="line-modified">!                     // IFNOTxxx &lt;L&gt; ASM_GOTO_W &lt;l&gt; L:..., see MethodWriter), so we need to insert a frame</span>
<span class="line-modified">!                     // here.</span>
<span class="line-modified">!                     insertFrame = true;</span>
<span class="line-modified">!                     currentOffset += 5;</span>
<span class="line-modified">!                     break;</span>
                  case Constants.WIDE:
<span class="line-modified">!                     opcode = classBuffer[currentOffset + 1] &amp; 0xFF;</span>
                      if (opcode == Opcodes.IINC) {
                          methodVisitor.visitIincInsn(
                                  readUnsignedShort(currentOffset + 2), readShort(currentOffset + 4));
                          currentOffset += 6;
                      } else {
                          methodVisitor.visitVarInsn(opcode, readUnsignedShort(currentOffset + 2));
                          currentOffset += 4;
                      }
                      break;
<span class="line-modified">!                 case Opcodes.TABLESWITCH:</span>
                      {
                          // Skip 0 to 3 padding bytes.
                          currentOffset += 4 - (currentBytecodeOffset &amp; 3);
                          // Read the instruction.
                          Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2167,11 ***</span>
                              currentOffset += 4;
                          }
                          methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);
                          break;
                      }
<span class="line-modified">!                 case Constants.LOOKUPSWITCH:</span>
                      {
                          // Skip 0 to 3 padding bytes.
                          currentOffset += 4 - (currentBytecodeOffset &amp; 3);
                          // Read the instruction.
                          Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
<span class="line-new-header">--- 2379,11 ---</span>
                              currentOffset += 4;
                          }
                          methodVisitor.visitTableSwitchInsn(low, high, defaultLabel, table);
                          break;
                      }
<span class="line-modified">!                 case Opcodes.LOOKUPSWITCH:</span>
                      {
                          // Skip 0 to 3 padding bytes.
                          currentOffset += 4 - (currentBytecodeOffset &amp; 3);
                          // Read the instruction.
                          Label defaultLabel = labels[currentBytecodeOffset + readInt(currentOffset)];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2185,61 ***</span>
                              currentOffset += 8;
                          }
                          methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);
                          break;
                      }
<span class="line-modified">!                 case Constants.ILOAD:</span>
<span class="line-modified">!                 case Constants.LLOAD:</span>
<span class="line-modified">!                 case Constants.FLOAD:</span>
<span class="line-modified">!                 case Constants.DLOAD:</span>
<span class="line-modified">!                 case Constants.ALOAD:</span>
<span class="line-modified">!                 case Constants.ISTORE:</span>
<span class="line-modified">!                 case Constants.LSTORE:</span>
<span class="line-modified">!                 case Constants.FSTORE:</span>
<span class="line-modified">!                 case Constants.DSTORE:</span>
<span class="line-modified">!                 case Constants.ASTORE:</span>
<span class="line-modified">!                 case Constants.RET:</span>
<span class="line-modified">!                     methodVisitor.visitVarInsn(opcode, classFileBuffer[currentOffset + 1] &amp; 0xFF);</span>
                      currentOffset += 2;
                      break;
<span class="line-modified">!                 case Constants.BIPUSH:</span>
<span class="line-modified">!                 case Constants.NEWARRAY:</span>
<span class="line-modified">!                     methodVisitor.visitIntInsn(opcode, classFileBuffer[currentOffset + 1]);</span>
                      currentOffset += 2;
                      break;
<span class="line-modified">!                 case Constants.SIPUSH:</span>
                      methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));
                      currentOffset += 3;
                      break;
<span class="line-modified">!                 case Constants.LDC:</span>
<span class="line-modified">!                     methodVisitor.visitLdcInsn(</span>
<span class="line-removed">-                             readConst(classFileBuffer[currentOffset + 1] &amp; 0xFF, charBuffer));</span>
                      currentOffset += 2;
                      break;
                  case Constants.LDC_W:
                  case Constants.LDC2_W:
                      methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));
                      currentOffset += 3;
                      break;
<span class="line-modified">!                 case Constants.GETSTATIC:</span>
<span class="line-modified">!                 case Constants.PUTSTATIC:</span>
<span class="line-modified">!                 case Constants.GETFIELD:</span>
<span class="line-modified">!                 case Constants.PUTFIELD:</span>
<span class="line-modified">!                 case Constants.INVOKEVIRTUAL:</span>
<span class="line-modified">!                 case Constants.INVOKESPECIAL:</span>
<span class="line-modified">!                 case Constants.INVOKESTATIC:</span>
<span class="line-modified">!                 case Constants.INVOKEINTERFACE:</span>
<span class="line-modified">!                 case Constants.WITHFIELD:</span>
                      {
                          int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
                          int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
                          String owner = readClass(cpInfoOffset, charBuffer);
                          String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                          String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
                          if (opcode &gt;= Opcodes.INVOKEVIRTUAL &amp;&amp; opcode &lt;= Opcodes.INVOKEINTERFACE) {
                              boolean isInterface =
<span class="line-modified">!                                     classFileBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;</span>
                              methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
                          } else {
                              methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);
                          }
                          if (opcode == Opcodes.INVOKEINTERFACE) {
<span class="line-new-header">--- 2397,60 ---</span>
                              currentOffset += 8;
                          }
                          methodVisitor.visitLookupSwitchInsn(defaultLabel, keys, values);
                          break;
                      }
<span class="line-modified">!                 case Opcodes.ILOAD:</span>
<span class="line-modified">!                 case Opcodes.LLOAD:</span>
<span class="line-modified">!                 case Opcodes.FLOAD:</span>
<span class="line-modified">!                 case Opcodes.DLOAD:</span>
<span class="line-modified">!                 case Opcodes.ALOAD:</span>
<span class="line-modified">!                 case Opcodes.ISTORE:</span>
<span class="line-modified">!                 case Opcodes.LSTORE:</span>
<span class="line-modified">!                 case Opcodes.FSTORE:</span>
<span class="line-modified">!                 case Opcodes.DSTORE:</span>
<span class="line-modified">!                 case Opcodes.ASTORE:</span>
<span class="line-modified">!                 case Opcodes.RET:</span>
<span class="line-modified">!                     methodVisitor.visitVarInsn(opcode, classBuffer[currentOffset + 1] &amp; 0xFF);</span>
                      currentOffset += 2;
                      break;
<span class="line-modified">!                 case Opcodes.BIPUSH:</span>
<span class="line-modified">!                 case Opcodes.NEWARRAY:</span>
<span class="line-modified">!                     methodVisitor.visitIntInsn(opcode, classBuffer[currentOffset + 1]);</span>
                      currentOffset += 2;
                      break;
<span class="line-modified">!                 case Opcodes.SIPUSH:</span>
                      methodVisitor.visitIntInsn(opcode, readShort(currentOffset + 1));
                      currentOffset += 3;
                      break;
<span class="line-modified">!                 case Opcodes.LDC:</span>
<span class="line-modified">!                     methodVisitor.visitLdcInsn(readConst(classBuffer[currentOffset + 1] &amp; 0xFF, charBuffer));</span>
                      currentOffset += 2;
                      break;
                  case Constants.LDC_W:
                  case Constants.LDC2_W:
                      methodVisitor.visitLdcInsn(readConst(readUnsignedShort(currentOffset + 1), charBuffer));
                      currentOffset += 3;
                      break;
<span class="line-modified">!                 case Opcodes.GETSTATIC:</span>
<span class="line-modified">!                 case Opcodes.PUTSTATIC:</span>
<span class="line-modified">!                 case Opcodes.GETFIELD:</span>
<span class="line-modified">!                 case Opcodes.PUTFIELD:</span>
<span class="line-modified">!                 case Opcodes.INVOKEVIRTUAL:</span>
<span class="line-modified">!                 case Opcodes.INVOKESPECIAL:</span>
<span class="line-modified">!                 case Opcodes.INVOKESTATIC:</span>
<span class="line-modified">!                 case Opcodes.INVOKEINTERFACE:</span>
<span class="line-modified">!                 case Opcodes.WITHFIELD:</span>
                      {
                          int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
                          int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
                          String owner = readClass(cpInfoOffset, charBuffer);
                          String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                          String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
                          if (opcode &gt;= Opcodes.INVOKEVIRTUAL &amp;&amp; opcode &lt;= Opcodes.INVOKEINTERFACE) {
                              boolean isInterface =
<span class="line-modified">!                                     classBuffer[cpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;</span>
                              methodVisitor.visitMethodInsn(opcode, owner, name, descriptor, isInterface);
                          } else {
                              methodVisitor.visitFieldInsn(opcode, owner, name, descriptor);
                          }
                          if (opcode == Opcodes.INVOKEINTERFACE) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2247,11 ***</span>
                          } else {
                              currentOffset += 3;
                          }
                          break;
                      }
<span class="line-modified">!                 case Constants.INVOKEDYNAMIC:</span>
                      {
                          int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
                          int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
                          String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                          String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
<span class="line-new-header">--- 2458,11 ---</span>
                          } else {
                              currentOffset += 3;
                          }
                          break;
                      }
<span class="line-modified">!                 case Opcodes.INVOKEDYNAMIC:</span>
                      {
                          int cpInfoOffset = cpInfoOffsets[readUnsignedShort(currentOffset + 1)];
                          int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(cpInfoOffset + 2)];
                          String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                          String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2269,26 ***</span>
                          methodVisitor.visitInvokeDynamicInsn(
                                  name, descriptor, handle, bootstrapMethodArguments);
                          currentOffset += 5;
                          break;
                      }
<span class="line-modified">!                 case Constants.NEW:</span>
<span class="line-modified">!                 case Constants.ANEWARRAY:</span>
<span class="line-modified">!                 case Constants.CHECKCAST:</span>
<span class="line-modified">!                 case Constants.INSTANCEOF:</span>
<span class="line-modified">!                 case Constants.DEFAULT:</span>
                      methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));
                      currentOffset += 3;
                      break;
<span class="line-modified">!                 case Constants.IINC:</span>
                      methodVisitor.visitIincInsn(
<span class="line-modified">!                             classFileBuffer[currentOffset + 1] &amp; 0xFF, classFileBuffer[currentOffset + 2]);</span>
                      currentOffset += 3;
                      break;
<span class="line-modified">!                 case Constants.MULTIANEWARRAY:</span>
                      methodVisitor.visitMultiANewArrayInsn(
<span class="line-modified">!                             readClass(currentOffset + 1, charBuffer), classFileBuffer[currentOffset + 3] &amp; 0xFF);</span>
                      currentOffset += 4;
                      break;
                  default:
                      throw new AssertionError();
              }
<span class="line-new-header">--- 2480,26 ---</span>
                          methodVisitor.visitInvokeDynamicInsn(
                                  name, descriptor, handle, bootstrapMethodArguments);
                          currentOffset += 5;
                          break;
                      }
<span class="line-modified">!                 case Opcodes.NEW:</span>
<span class="line-modified">!                 case Opcodes.ANEWARRAY:</span>
<span class="line-modified">!                 case Opcodes.CHECKCAST:</span>
<span class="line-modified">!                 case Opcodes.INSTANCEOF:</span>
<span class="line-modified">!                 case Opcodes.DEFAULT:</span>
                      methodVisitor.visitTypeInsn(opcode, readClass(currentOffset + 1, charBuffer));
                      currentOffset += 3;
                      break;
<span class="line-modified">!                 case Opcodes.IINC:</span>
                      methodVisitor.visitIincInsn(
<span class="line-modified">!                             classBuffer[currentOffset + 1] &amp; 0xFF, classBuffer[currentOffset + 2]);</span>
                      currentOffset += 3;
                      break;
<span class="line-modified">!                 case Opcodes.MULTIANEWARRAY:</span>
                      methodVisitor.visitMultiANewArrayInsn(
<span class="line-modified">!                             readClass(currentOffset + 1, charBuffer), classBuffer[currentOffset + 3] &amp; 0xFF);</span>
                      currentOffset += 4;
                      break;
                  default:
                      throw new AssertionError();
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2588,11 ***</span>
              // Parse the rest of the type_annotation structure, starting with the target_path structure
              // (whose size depends on its path_length field).
              int pathLength = readByte(currentOffset);
              if ((targetType &gt;&gt;&gt; 24) == TypeReference.EXCEPTION_PARAMETER) {
                  // Parse the target_path structure and create a corresponding TypePath.
<span class="line-modified">!                 TypePath path = pathLength == 0 ? null : new TypePath(b, currentOffset);</span>
                  currentOffset += 1 + 2 * pathLength;
                  // Parse the type_index field.
                  String annotationDescriptor = readUTF8(currentOffset, charBuffer);
                  currentOffset += 2;
                  // Parse num_element_value_pairs and element_value_pairs and visit these values.
<span class="line-new-header">--- 2799,11 ---</span>
              // Parse the rest of the type_annotation structure, starting with the target_path structure
              // (whose size depends on its path_length field).
              int pathLength = readByte(currentOffset);
              if ((targetType &gt;&gt;&gt; 24) == TypeReference.EXCEPTION_PARAMETER) {
                  // Parse the target_path structure and create a corresponding TypePath.
<span class="line-modified">!                 TypePath path = pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);</span>
                  currentOffset += 1 + 2 * pathLength;
                  // Parse the type_index field.
                  String annotationDescriptor = readUTF8(currentOffset, charBuffer);
                  currentOffset += 2;
                  // Parse num_element_value_pairs and element_value_pairs and visit these values.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2621,11 ***</span>
      /**
        * Returns the bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or
        * -1 if there is no such type_annotation of if it does not have a bytecode offset.
        *
        * @param typeAnnotationOffsets the offset of each &#39;type_annotation&#39; entry in a
<span class="line-modified">!       *     Runtime[In]VisibleTypeAnnotations attribute, or null.</span>
        * @param typeAnnotationIndex the index a &#39;type_annotation&#39; entry in typeAnnotationOffsets.
        * @return bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or -1
        *     if there is no such type_annotation of if it does not have a bytecode offset.
        */
      private int getTypeAnnotationBytecodeOffset(
<span class="line-new-header">--- 2832,11 ---</span>
      /**
        * Returns the bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or
        * -1 if there is no such type_annotation of if it does not have a bytecode offset.
        *
        * @param typeAnnotationOffsets the offset of each &#39;type_annotation&#39; entry in a
<span class="line-modified">!       *     Runtime[In]VisibleTypeAnnotations attribute, or {@literal null}.</span>
        * @param typeAnnotationIndex the index a &#39;type_annotation&#39; entry in typeAnnotationOffsets.
        * @return bytecode offset corresponding to the specified JVMS &#39;type_annotation&#39; structure, or -1
        *     if there is no such type_annotation of if it does not have a bytecode offset.
        */
      private int getTypeAnnotationBytecodeOffset(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2713,11 ***</span>
          }
          context.currentTypeAnnotationTarget = targetType;
          // Parse and store the target_path structure.
          int pathLength = readByte(currentOffset);
          context.currentTypeAnnotationTargetPath =
<span class="line-modified">!                 pathLength == 0 ? null : new TypePath(b, currentOffset);</span>
          // Return the start offset of the rest of the type_annotation structure.
          return currentOffset + 1 + 2 * pathLength;
      }
  
      /**
<span class="line-new-header">--- 2924,11 ---</span>
          }
          context.currentTypeAnnotationTarget = targetType;
          // Parse and store the target_path structure.
          int pathLength = readByte(currentOffset);
          context.currentTypeAnnotationTargetPath =
<span class="line-modified">!                 pathLength == 0 ? null : new TypePath(classFileBuffer, currentOffset);</span>
          // Return the start offset of the rest of the type_annotation structure.
          return currentOffset + 1 + 2 * pathLength;
      }
  
      /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2735,11 ***</span>
              final MethodVisitor methodVisitor,
              final Context context,
              final int runtimeParameterAnnotationsOffset,
              final boolean visible) {
          int currentOffset = runtimeParameterAnnotationsOffset;
<span class="line-modified">!         int numParameters = b[currentOffset++] &amp; 0xFF;</span>
          methodVisitor.visitAnnotableParameterCount(numParameters, visible);
          char[] charBuffer = context.charBuffer;
          for (int i = 0; i &lt; numParameters; ++i) {
              int numAnnotations = readUnsignedShort(currentOffset);
              currentOffset += 2;
<span class="line-new-header">--- 2946,11 ---</span>
              final MethodVisitor methodVisitor,
              final Context context,
              final int runtimeParameterAnnotationsOffset,
              final boolean visible) {
          int currentOffset = runtimeParameterAnnotationsOffset;
<span class="line-modified">!         int numParameters = classFileBuffer[currentOffset++] &amp; 0xFF;</span>
          methodVisitor.visitAnnotableParameterCount(numParameters, visible);
          char[] charBuffer = context.charBuffer;
          for (int i = 0; i &lt; numParameters; ++i) {
              int numAnnotations = readUnsignedShort(currentOffset);
              currentOffset += 2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2803,12 ***</span>
  
      /**
        * Reads a JVMS &#39;element_value&#39; structure and makes the given visitor visit it.
        *
        * @param annotationVisitor the visitor that must visit the element_value structure.
<span class="line-modified">!       * @param elementValueOffset the start offset in {@link #b} of the element_value structure to be</span>
<span class="line-modified">!       *     read.</span>
        * @param elementName the name of the element_value structure to be read, or {@literal null}.
        * @param charBuffer the buffer used to read strings in the constant pool.
        * @return the end offset of the JVMS &#39;element_value&#39; structure.
        */
      private int readElementValue(
<span class="line-new-header">--- 3014,12 ---</span>
  
      /**
        * Reads a JVMS &#39;element_value&#39; structure and makes the given visitor visit it.
        *
        * @param annotationVisitor the visitor that must visit the element_value structure.
<span class="line-modified">!       * @param elementValueOffset the start offset in {@link #classFileBuffer} of the element_value</span>
<span class="line-modified">!       *     structure to be read.</span>
        * @param elementName the name of the element_value structure to be read, or {@literal null}.
        * @param charBuffer the buffer used to read strings in the constant pool.
        * @return the end offset of the JVMS &#39;element_value&#39; structure.
        */
      private int readElementValue(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2816,22 ***</span>
              final int elementValueOffset,
              final String elementName,
              final char[] charBuffer) {
          int currentOffset = elementValueOffset;
          if (annotationVisitor == null) {
<span class="line-modified">!             switch (b[currentOffset] &amp; 0xFF) {</span>
                  case &#39;e&#39;: // enum_const_value
                      return currentOffset + 5;
                  case &#39;@&#39;: // annotation_value
                      return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);
                  case &#39;[&#39;: // array_value
                      return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);
                  default:
                      return currentOffset + 3;
              }
          }
<span class="line-modified">!         switch (b[currentOffset++] &amp; 0xFF) {</span>
              case &#39;B&#39;: // const_value_index, CONSTANT_Integer
                  annotationVisitor.visit(
                          elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
                  currentOffset += 2;
                  break;
<span class="line-new-header">--- 3027,22 ---</span>
              final int elementValueOffset,
              final String elementName,
              final char[] charBuffer) {
          int currentOffset = elementValueOffset;
          if (annotationVisitor == null) {
<span class="line-modified">!             switch (classFileBuffer[currentOffset] &amp; 0xFF) {</span>
                  case &#39;e&#39;: // enum_const_value
                      return currentOffset + 5;
                  case &#39;@&#39;: // annotation_value
                      return readElementValues(null, currentOffset + 3, /* named = */ true, charBuffer);
                  case &#39;[&#39;: // array_value
                      return readElementValues(null, currentOffset + 1, /* named = */ false, charBuffer);
                  default:
                      return currentOffset + 3;
              }
          }
<span class="line-modified">!         switch (classFileBuffer[currentOffset++] &amp; 0xFF) {</span>
              case &#39;B&#39;: // const_value_index, CONSTANT_Integer
                  annotationVisitor.visit(
                          elementName, (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset)]));
                  currentOffset += 2;
                  break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2893,11 ***</span>
                              annotationVisitor.visitArray(elementName),
                              currentOffset - 2,
                              /* named = */ false,
                              charBuffer);
                  }
<span class="line-modified">!                 switch (b[currentOffset] &amp; 0xFF) {</span>
                      case &#39;B&#39;:
                          byte[] byteValues = new byte[numValues];
                          for (int i = 0; i &lt; numValues; i++) {
                              byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
                              currentOffset += 3;
<span class="line-new-header">--- 3104,11 ---</span>
                              annotationVisitor.visitArray(elementName),
                              currentOffset - 2,
                              /* named = */ false,
                              charBuffer);
                  }
<span class="line-modified">!                 switch (classFileBuffer[currentOffset] &amp; 0xFF) {</span>
                      case &#39;B&#39;:
                          byte[] byteValues = new byte[numValues];
                          for (int i = 0; i &lt; numValues; i++) {
                              byteValues[i] = (byte) readInt(cpInfoOffsets[readUnsignedShort(currentOffset + 1)]);
                              currentOffset += 3;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3056,13 ***</span>
      /**
        * Reads a JVMS &#39;stack_map_frame&#39; structure and stores the result in the given {@link Context}
        * object. This method can also be used to read a full_frame structure, excluding its frame_type
        * field (this is used to parse the legacy StackMap attributes).
        *
<span class="line-modified">!       * @param stackMapFrameOffset the start offset in {@link #b} of the stack_map_frame_value</span>
<span class="line-modified">!       *     structure to be read, or the start offset of a full_frame structure (excluding its</span>
<span class="line-modified">!       *     frame_type field).</span>
        * @param compressed true to read a &#39;stack_map_frame&#39; structure, false to read a &#39;full_frame&#39;
        *     structure without its frame_type field.
        * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.
        * @param context where the parsed stack map frame must be stored.
        * @return the end offset of the JVMS &#39;stack_map_frame&#39; or &#39;full_frame&#39; structure.
<span class="line-new-header">--- 3267,13 ---</span>
      /**
        * Reads a JVMS &#39;stack_map_frame&#39; structure and stores the result in the given {@link Context}
        * object. This method can also be used to read a full_frame structure, excluding its frame_type
        * field (this is used to parse the legacy StackMap attributes).
        *
<span class="line-modified">!       * @param stackMapFrameOffset the start offset in {@link #classFileBuffer} of the</span>
<span class="line-modified">!       *     stack_map_frame_value structure to be read, or the start offset of a full_frame structure</span>
<span class="line-modified">!       *     (excluding its frame_type field).</span>
        * @param compressed true to read a &#39;stack_map_frame&#39; structure, false to read a &#39;full_frame&#39;
        *     structure without its frame_type field.
        * @param expand if the stack map frame must be expanded. See {@link #EXPAND_FRAMES}.
        * @param context where the parsed stack map frame must be stored.
        * @return the end offset of the JVMS &#39;stack_map_frame&#39; or &#39;full_frame&#39; structure.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3076,11 ***</span>
          final char[] charBuffer = context.charBuffer;
          final Label[] labels = context.currentMethodLabels;
          int frameType;
          if (compressed) {
              // Read the frame_type field.
<span class="line-modified">!             frameType = b[currentOffset++] &amp; 0xFF;</span>
          } else {
              frameType = Frame.FULL_FRAME;
              context.currentFrameOffset = -1;
          }
          int offsetDelta;
<span class="line-new-header">--- 3287,11 ---</span>
          final char[] charBuffer = context.charBuffer;
          final Label[] labels = context.currentMethodLabels;
          int frameType;
          if (compressed) {
              // Read the frame_type field.
<span class="line-modified">!             frameType = classFileBuffer[currentOffset++] &amp; 0xFF;</span>
          } else {
              frameType = Frame.FULL_FRAME;
              context.currentFrameOffset = -1;
          }
          int offsetDelta;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3171,11 ***</span>
              final Object[] frame,
              final int index,
              final char[] charBuffer,
              final Label[] labels) {
          int currentOffset = verificationTypeInfoOffset;
<span class="line-modified">!         int tag = b[currentOffset++] &amp; 0xFF;</span>
          switch (tag) {
              case Frame.ITEM_TOP:
                  frame[index] = Opcodes.TOP;
                  break;
              case Frame.ITEM_INTEGER:
<span class="line-new-header">--- 3382,11 ---</span>
              final Object[] frame,
              final int index,
              final char[] charBuffer,
              final Label[] labels) {
          int currentOffset = verificationTypeInfoOffset;
<span class="line-modified">!         int tag = classFileBuffer[currentOffset++] &amp; 0xFF;</span>
          switch (tag) {
              case Frame.ITEM_TOP:
                  frame[index] = Opcodes.TOP;
                  break;
              case Frame.ITEM_INTEGER:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3213,13 ***</span>
      // ----------------------------------------------------------------------------------------------
      // Methods to parse attributes
      // ----------------------------------------------------------------------------------------------
  
      /**
<span class="line-modified">!       * Returns the offset in {@link #b} of the first ClassFile&#39;s &#39;attributes&#39; array field entry.</span>
        *
<span class="line-modified">!       * @return the offset in {@link #b} of the first ClassFile&#39;s &#39;attributes&#39; array field entry.</span>
        */
      final int getFirstAttributeOffset() {
          // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes
          // each), as well as the interfaces array field (2 bytes per interface).
          int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;
<span class="line-new-header">--- 3424,15 ---</span>
      // ----------------------------------------------------------------------------------------------
      // Methods to parse attributes
      // ----------------------------------------------------------------------------------------------
  
      /**
<span class="line-modified">!       * Returns the offset in {@link #classFileBuffer} of the first ClassFile&#39;s &#39;attributes&#39; array</span>
<span class="line-added">+       * field entry.</span>
        *
<span class="line-modified">!       * @return the offset in {@link #classFileBuffer} of the first ClassFile&#39;s &#39;attributes&#39; array</span>
<span class="line-added">+       *     field entry.</span>
        */
      final int getFirstAttributeOffset() {
          // Skip the access_flags, this_class, super_class, and interfaces_count fields (using 2 bytes
          // each), as well as the interfaces array field (2 bytes per interface).
          int currentOffset = header + 8 + readUnsignedShort(header + 6) * 2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3262,11 ***</span>
      /**
        * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
        *
        * @param maxStringLength a conservative estimate of the maximum length of the strings contained
        *     in the constant pool of the class.
<span class="line-modified">!       * @return the offsets of the bootstrap methods or null.</span>
        */
      private int[] readBootstrapMethodsAttribute(final int maxStringLength) {
          char[] charBuffer = new char[maxStringLength];
          int currentAttributeOffset = getFirstAttributeOffset();
          int[] currentBootstrapMethodOffsets = null;
<span class="line-new-header">--- 3475,11 ---</span>
      /**
        * Reads the BootstrapMethods attribute to compute the offset of each bootstrap method.
        *
        * @param maxStringLength a conservative estimate of the maximum length of the strings contained
        *     in the constant pool of the class.
<span class="line-modified">!       * @return the offsets of the bootstrap methods.</span>
        */
      private int[] readBootstrapMethodsAttribute(final int maxStringLength) {
          char[] charBuffer = new char[maxStringLength];
          int currentAttributeOffset = getFirstAttributeOffset();
          int[] currentBootstrapMethodOffsets = null;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3289,27 ***</span>
                  }
                  return currentBootstrapMethodOffsets;
              }
              currentAttributeOffset += attributeLength;
          }
<span class="line-modified">!         return null;</span>
      }
  
      /**
<span class="line-modified">!       * Reads a non standard JVMS &#39;attribute&#39; structure in {@link #b}.</span>
        *
        * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
        *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
        *     be parsed: its byte array value will be passed unchanged to the ClassWriter.
        * @param type the type of the attribute.
<span class="line-modified">!       * @param offset the start offset of the JVMS &#39;attribute&#39; structure in {@link #b}. The 6 attribute</span>
<span class="line-modified">!       *     header bytes (attribute_name_index and attribute_length) are not taken into account here.</span>
        * @param length the length of the attribute&#39;s content (excluding the 6 attribute header bytes).
        * @param charBuffer the buffer to be used to read strings in the constant pool.
<span class="line-modified">!       * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link #b}, or</span>
<span class="line-modified">!       *     -1 if the attribute to be read is not a code attribute. The 6 attribute header bytes</span>
<span class="line-modified">!       *     (attribute_name_index and attribute_length) are not taken into account here.</span>
        * @param labels the labels of the method&#39;s code, or {@literal null} if the attribute to be read
        *     is not a code attribute.
        * @return the attribute that has been read.
        */
      private Attribute readAttribute(
<span class="line-new-header">--- 3502,29 ---</span>
                  }
                  return currentBootstrapMethodOffsets;
              }
              currentAttributeOffset += attributeLength;
          }
<span class="line-modified">!         throw new IllegalArgumentException();</span>
      }
  
      /**
<span class="line-modified">!       * Reads a non standard JVMS &#39;attribute&#39; structure in {@link #classFileBuffer}.</span>
        *
        * @param attributePrototypes prototypes of the attributes that must be parsed during the visit of
        *     the class. Any attribute whose type is not equal to the type of one the prototypes will not
        *     be parsed: its byte array value will be passed unchanged to the ClassWriter.
        * @param type the type of the attribute.
<span class="line-modified">!       * @param offset the start offset of the JVMS &#39;attribute&#39; structure in {@link #classFileBuffer}.</span>
<span class="line-modified">!       *     The 6 attribute header bytes (attribute_name_index and attribute_length) are not taken into</span>
<span class="line-added">+       *     account here.</span>
        * @param length the length of the attribute&#39;s content (excluding the 6 attribute header bytes).
        * @param charBuffer the buffer to be used to read strings in the constant pool.
<span class="line-modified">!       * @param codeAttributeOffset the start offset of the enclosing Code attribute in {@link</span>
<span class="line-modified">!       *     #classFileBuffer}, or -1 if the attribute to be read is not a code attribute. The 6</span>
<span class="line-modified">!       *     attribute header bytes (attribute_name_index and attribute_length) are not taken into</span>
<span class="line-added">+       *     account here.</span>
        * @param labels the labels of the method&#39;s code, or {@literal null} if the attribute to be read
        *     is not a code attribute.
        * @return the attribute that has been read.
        */
      private Attribute readAttribute(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3341,17 ***</span>
      public int getItemCount() {
          return cpInfoOffsets.length;
      }
  
      /**
<span class="line-modified">!       * Returns the start offset in {@link #b} of a JVMS &#39;cp_info&#39; structure (i.e. a constant pool</span>
<span class="line-modified">!       * entry), plus one. &lt;i&gt;This method is intended for {@link Attribute} sub classes, and is normally</span>
<span class="line-modified">!       * not needed by class generators or adapters.&lt;/i&gt;</span>
        *
        * @param constantPoolEntryIndex the index a constant pool entry in the class&#39;s constant pool
        *     table.
<span class="line-modified">!       * @return the start offset in {@link #b} of the corresponding JVMS &#39;cp_info&#39; structure, plus one.</span>
        */
      public int getItem(final int constantPoolEntryIndex) {
          return cpInfoOffsets[constantPoolEntryIndex];
      }
  
<span class="line-new-header">--- 3556,18 ---</span>
      public int getItemCount() {
          return cpInfoOffsets.length;
      }
  
      /**
<span class="line-modified">!       * Returns the start offset in this {@link ClassReader} of a JVMS &#39;cp_info&#39; structure (i.e. a</span>
<span class="line-modified">!       * constant pool entry), plus one. &lt;i&gt;This method is intended for {@link Attribute} sub classes,</span>
<span class="line-modified">!       * and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
        * @param constantPoolEntryIndex the index a constant pool entry in the class&#39;s constant pool
        *     table.
<span class="line-modified">!       * @return the start offset in this {@link ClassReader} of the corresponding JVMS &#39;cp_info&#39;</span>
<span class="line-added">+       *     structure, plus one.</span>
        */
      public int getItem(final int constantPoolEntryIndex) {
          return cpInfoOffsets[constantPoolEntryIndex];
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3365,78 ***</span>
      public int getMaxStringLength() {
          return maxStringLength;
      }
  
      /**
<span class="line-modified">!       * Reads a byte value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub classes,</span>
<span class="line-modified">!       * and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of the value to be read in {@link #b}.</span>
        * @return the read value.
        */
      public int readByte(final int offset) {
<span class="line-modified">!         return b[offset] &amp; 0xFF;</span>
      }
  
      /**
<span class="line-modified">!       * Reads an unsigned short value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute}</span>
<span class="line-modified">!       * sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start index of the value to be read in {@link #b}.</span>
        * @return the read value.
        */
      public int readUnsignedShort(final int offset) {
<span class="line-modified">!         byte[] classFileBuffer = b;</span>
<span class="line-modified">!         return ((classFileBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classFileBuffer[offset + 1] &amp; 0xFF);</span>
      }
  
      /**
<span class="line-modified">!       * Reads a signed short value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub</span>
<span class="line-modified">!       * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of the value to be read in {@link #b}.</span>
        * @return the read value.
        */
      public short readShort(final int offset) {
<span class="line-modified">!         byte[] classFileBuffer = b;</span>
<span class="line-modified">!         return (short) (((classFileBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classFileBuffer[offset + 1] &amp; 0xFF));</span>
      }
  
      /**
<span class="line-modified">!       * Reads a signed int value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub</span>
<span class="line-modified">!       * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of the value to be read in {@link #b}.</span>
        * @return the read value.
        */
      public int readInt(final int offset) {
<span class="line-modified">!         byte[] classFileBuffer = b;</span>
<span class="line-modified">!         return ((classFileBuffer[offset] &amp; 0xFF) &lt;&lt; 24)</span>
<span class="line-modified">!                 | ((classFileBuffer[offset + 1] &amp; 0xFF) &lt;&lt; 16)</span>
<span class="line-modified">!                 | ((classFileBuffer[offset + 2] &amp; 0xFF) &lt;&lt; 8)</span>
<span class="line-modified">!                 | (classFileBuffer[offset + 3] &amp; 0xFF);</span>
      }
  
      /**
<span class="line-modified">!       * Reads a signed long value in {@link #b}. &lt;i&gt;This method is intended for {@link Attribute} sub</span>
<span class="line-modified">!       * classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of the value to be read in {@link #b}.</span>
        * @return the read value.
        */
      public long readLong(final int offset) {
          long l1 = readInt(offset);
          long l0 = readInt(offset + 4) &amp; 0xFFFFFFFFL;
          return (l1 &lt;&lt; 32) | l0;
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Utf8 constant pool entry in {@link #b}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">!       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the</span>
<span class="line-modified">!       *     index of a CONSTANT_Utf8 entry in the class&#39;s constant pool table.</span>
        * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
        *     large. It is not automatically resized.
        * @return the String corresponding to the specified CONSTANT_Utf8 entry.
        */
      // DontCheck(AbbreviationAsWordInName): can&#39;t be renamed (for backward binary compatibility).
<span class="line-new-header">--- 3581,79 ---</span>
      public int getMaxStringLength() {
          return maxStringLength;
      }
  
      /**
<span class="line-modified">!       * Reads a byte value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">!       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of the value to be read in this {@link ClassReader}.</span>
        * @return the read value.
        */
      public int readByte(final int offset) {
<span class="line-modified">!         return classFileBuffer[offset] &amp; 0xFF;</span>
      }
  
      /**
<span class="line-modified">!       * Reads an unsigned short value in this {@link ClassReader}. &lt;i&gt;This method is intended for</span>
<span class="line-modified">!       * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start index of the value to be read in this {@link ClassReader}.</span>
        * @return the read value.
        */
      public int readUnsignedShort(final int offset) {
<span class="line-modified">!         byte[] classBuffer = classFileBuffer;</span>
<span class="line-modified">!         return ((classBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classBuffer[offset + 1] &amp; 0xFF);</span>
      }
  
      /**
<span class="line-modified">!       * Reads a signed short value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">!       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of the value to be read in this {@link ClassReader}.</span>
        * @return the read value.
        */
      public short readShort(final int offset) {
<span class="line-modified">!         byte[] classBuffer = classFileBuffer;</span>
<span class="line-modified">!         return (short) (((classBuffer[offset] &amp; 0xFF) &lt;&lt; 8) | (classBuffer[offset + 1] &amp; 0xFF));</span>
      }
  
      /**
<span class="line-modified">!       * Reads a signed int value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">!       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of the value to be read in this {@link ClassReader}.</span>
        * @return the read value.
        */
      public int readInt(final int offset) {
<span class="line-modified">!         byte[] classBuffer = classFileBuffer;</span>
<span class="line-modified">!         return ((classBuffer[offset] &amp; 0xFF) &lt;&lt; 24)</span>
<span class="line-modified">!                 | ((classBuffer[offset + 1] &amp; 0xFF) &lt;&lt; 16)</span>
<span class="line-modified">!                 | ((classBuffer[offset + 2] &amp; 0xFF) &lt;&lt; 8)</span>
<span class="line-modified">!                 | (classBuffer[offset + 3] &amp; 0xFF);</span>
      }
  
      /**
<span class="line-modified">!       * Reads a signed long value in this {@link ClassReader}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">!       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of the value to be read in this {@link ClassReader}.</span>
        * @return the read value.
        */
      public long readLong(final int offset) {
          long l1 = readInt(offset);
          long l0 = readInt(offset + 4) &amp; 0xFFFFFFFFL;
          return (l1 &lt;&lt; 32) | l0;
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Utf8 constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is</span>
<span class="line-modified">!       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">+       * adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose</span>
<span class="line-modified">!       *     value is the index of a CONSTANT_Utf8 entry in the class&#39;s constant pool table.</span>
        * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
        *     large. It is not automatically resized.
        * @return the String corresponding to the specified CONSTANT_Utf8 entry.
        */
      // DontCheck(AbbreviationAsWordInName): can&#39;t be renamed (for backward binary compatibility).
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3447,11 ***</span>
          }
          return readUtf(constantPoolEntryIndex, charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Utf8 constant pool entry in {@link #b}.</span>
        *
        * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class&#39;s constant pool
        *     table.
        * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
        *     large. It is not automatically resized.
<span class="line-new-header">--- 3664,11 ---</span>
          }
          return readUtf(constantPoolEntryIndex, charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Utf8 constant pool entry in {@link #classFileBuffer}.</span>
        *
        * @param constantPoolEntryIndex the index of a CONSTANT_Utf8 entry in the class&#39;s constant pool
        *     table.
        * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
        *     large. It is not automatically resized.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3466,11 ***</span>
          return constantUtf8Values[constantPoolEntryIndex] =
                  readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads an UTF8 string in {@link #b}.</span>
        *
        * @param utfOffset the start offset of the UTF8 string to be read.
        * @param utfLength the length of the UTF8 string to be read.
        * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
        *     large. It is not automatically resized.
<span class="line-new-header">--- 3683,11 ---</span>
          return constantUtf8Values[constantPoolEntryIndex] =
                  readUtf(cpInfoOffset + 2, readUnsignedShort(cpInfoOffset), charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads an UTF8 string in {@link #classFileBuffer}.</span>
        *
        * @param utfOffset the start offset of the UTF8 string to be read.
        * @param utfLength the length of the UTF8 string to be read.
        * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
        *     large. It is not automatically resized.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3478,37 ***</span>
        */
      private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {
          int currentOffset = utfOffset;
          int endOffset = currentOffset + utfLength;
          int strLength = 0;
<span class="line-modified">!         byte[] classFileBuffer = b;</span>
          while (currentOffset &lt; endOffset) {
<span class="line-modified">!             int currentByte = classFileBuffer[currentOffset++];</span>
              if ((currentByte &amp; 0x80) == 0) {
                  charBuffer[strLength++] = (char) (currentByte &amp; 0x7F);
              } else if ((currentByte &amp; 0xE0) == 0xC0) {
                  charBuffer[strLength++] =
<span class="line-modified">!                         (char) (((currentByte &amp; 0x1F) &lt;&lt; 6) + (classFileBuffer[currentOffset++] &amp; 0x3F));</span>
              } else {
                  charBuffer[strLength++] =
                          (char)
                                  (((currentByte &amp; 0xF) &lt;&lt; 12)
<span class="line-modified">!                                         + ((classFileBuffer[currentOffset++] &amp; 0x3F) &lt;&lt; 6)</span>
<span class="line-modified">!                                         + (classFileBuffer[currentOffset++] &amp; 0x3F));</span>
              }
          }
          return new String(charBuffer, 0, strLength);
      }
  
      /**
        * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
<span class="line-modified">!       * CONSTANT_Package constant pool entry in {@link #b}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">!       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the</span>
<span class="line-modified">!       *     index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or</span>
<span class="line-modified">!       *     CONSTANT_Package entry in class&#39;s constant pool table.</span>
        * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
        *     large. It is not automatically resized.
        * @return the String corresponding to the specified constant pool entry.
        */
      private String readStringish(final int offset, final char[] charBuffer) {
<span class="line-new-header">--- 3695,38 ---</span>
        */
      private String readUtf(final int utfOffset, final int utfLength, final char[] charBuffer) {
          int currentOffset = utfOffset;
          int endOffset = currentOffset + utfLength;
          int strLength = 0;
<span class="line-modified">!         byte[] classBuffer = classFileBuffer;</span>
          while (currentOffset &lt; endOffset) {
<span class="line-modified">!             int currentByte = classBuffer[currentOffset++];</span>
              if ((currentByte &amp; 0x80) == 0) {
                  charBuffer[strLength++] = (char) (currentByte &amp; 0x7F);
              } else if ((currentByte &amp; 0xE0) == 0xC0) {
                  charBuffer[strLength++] =
<span class="line-modified">!                         (char) (((currentByte &amp; 0x1F) &lt;&lt; 6) + (classBuffer[currentOffset++] &amp; 0x3F));</span>
              } else {
                  charBuffer[strLength++] =
                          (char)
                                  (((currentByte &amp; 0xF) &lt;&lt; 12)
<span class="line-modified">!                                         + ((classBuffer[currentOffset++] &amp; 0x3F) &lt;&lt; 6)</span>
<span class="line-modified">!                                         + (classBuffer[currentOffset++] &amp; 0x3F));</span>
              }
          }
          return new String(charBuffer, 0, strLength);
      }
  
      /**
        * Reads a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType, CONSTANT_Module or
<span class="line-modified">!       * CONSTANT_Package constant pool entry in {@link #classFileBuffer}. &lt;i&gt;This method is intended</span>
<span class="line-modified">!       * for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">+       * adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of an unsigned short value in {@link #classFileBuffer}, whose</span>
<span class="line-modified">!       *     value is the index of a CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,</span>
<span class="line-modified">!       *     CONSTANT_Module or CONSTANT_Package entry in class&#39;s constant pool table.</span>
        * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
        *     large. It is not automatically resized.
        * @return the String corresponding to the specified constant pool entry.
        */
      private String readStringish(final int offset, final char[] charBuffer) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3516,53 ***</span>
          // designated by the first two bytes of this cp_info.
          return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Class constant pool entry in {@link #b}. &lt;i&gt;This method is intended for {@link</span>
<span class="line-modified">!       * Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the</span>
<span class="line-modified">!       *     index of a CONSTANT_Class entry in class&#39;s constant pool table.</span>
        * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
        *     large. It is not automatically resized.
        * @return the String corresponding to the specified CONSTANT_Class entry.
        */
      public String readClass(final int offset, final char[] charBuffer) {
          return readStringish(offset, charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Module constant pool entry in {@link #b}. &lt;i&gt;This method is intended for</span>
<span class="line-modified">!       * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the</span>
<span class="line-modified">!       *     index of a CONSTANT_Module entry in class&#39;s constant pool table.</span>
        * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
        *     large. It is not automatically resized.
        * @return the String corresponding to the specified CONSTANT_Module entry.
        */
      public String readModule(final int offset, final char[] charBuffer) {
          return readStringish(offset, charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Package constant pool entry in {@link #b}. &lt;i&gt;This method is intended for</span>
<span class="line-modified">!       * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of an unsigned short value in {@link #b}, whose value is the</span>
<span class="line-modified">!       *     index of a CONSTANT_Package entry in class&#39;s constant pool table.</span>
        * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
        *     large. It is not automatically resized.
        * @return the String corresponding to the specified CONSTANT_Package entry.
        */
      public String readPackage(final int offset, final char[] charBuffer) {
          return readStringish(offset, charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Dynamic constant pool entry in {@link #b}.</span>
        *
        * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class&#39;s constant
        *     pool table.
        * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
        *     large. It is not automatically resized.
<span class="line-new-header">--- 3734,56 ---</span>
          // designated by the first two bytes of this cp_info.
          return readUTF8(cpInfoOffsets[readUnsignedShort(offset)], charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Class constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is</span>
<span class="line-modified">!       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">+       * adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose</span>
<span class="line-modified">!       *     value is the index of a CONSTANT_Class entry in class&#39;s constant pool table.</span>
        * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
        *     large. It is not automatically resized.
        * @return the String corresponding to the specified CONSTANT_Class entry.
        */
      public String readClass(final int offset, final char[] charBuffer) {
          return readStringish(offset, charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Module constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is</span>
<span class="line-modified">!       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">+       * adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose</span>
<span class="line-modified">!       *     value is the index of a CONSTANT_Module entry in class&#39;s constant pool table.</span>
        * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
        *     large. It is not automatically resized.
        * @return the String corresponding to the specified CONSTANT_Module entry.
        */
      public String readModule(final int offset, final char[] charBuffer) {
          return readStringish(offset, charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Package constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is</span>
<span class="line-modified">!       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">+       * adapters.&lt;/i&gt;</span>
        *
<span class="line-modified">!       * @param offset the start offset of an unsigned short value in this {@link ClassReader}, whose</span>
<span class="line-modified">!       *     value is the index of a CONSTANT_Package entry in class&#39;s constant pool table.</span>
        * @param charBuffer the buffer to be used to read the item. This buffer must be sufficiently
        *     large. It is not automatically resized.
        * @return the String corresponding to the specified CONSTANT_Package entry.
        */
      public String readPackage(final int offset, final char[] charBuffer) {
          return readStringish(offset, charBuffer);
      }
  
      /**
<span class="line-modified">!       * Reads a CONSTANT_Dynamic constant pool entry in {@link #classFileBuffer}.</span>
        *
        * @param constantPoolEntryIndex the index of a CONSTANT_Dynamic entry in the class&#39;s constant
        *     pool table.
        * @param charBuffer the buffer to be used to read the string. This buffer must be sufficiently
        *     large. It is not automatically resized.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3589,12 ***</span>
          return constantDynamicValues[constantPoolEntryIndex] =
                  new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);
      }
  
      /**
<span class="line-modified">!       * Reads a numeric or string constant pool entry in {@link #b}. &lt;i&gt;This method is intended for</span>
<span class="line-modified">!       * {@link Attribute} sub classes, and is normally not needed by class generators or adapters.&lt;/i&gt;</span>
        *
        * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,
        *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
        *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class&#39;s constant pool.
        * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently
<span class="line-new-header">--- 3810,13 ---</span>
          return constantDynamicValues[constantPoolEntryIndex] =
                  new ConstantDynamic(name, descriptor, handle, bootstrapMethodArguments);
      }
  
      /**
<span class="line-modified">!       * Reads a numeric or string constant pool entry in this {@link ClassReader}. &lt;i&gt;This method is</span>
<span class="line-modified">!       * intended for {@link Attribute} sub classes, and is normally not needed by class generators or</span>
<span class="line-added">+       * adapters.&lt;/i&gt;</span>
        *
        * @param constantPoolEntryIndex the index of a CONSTANT_Integer, CONSTANT_Float, CONSTANT_Long,
        *     CONSTANT_Double, CONSTANT_Class, CONSTANT_String, CONSTANT_MethodType,
        *     CONSTANT_MethodHandle or CONSTANT_Dynamic entry in the class&#39;s constant pool.
        * @param charBuffer the buffer to be used to read strings. This buffer must be sufficiently
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3603,11 ***</span>
        *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified
        *     constant pool entry.
        */
      public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {
          int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
<span class="line-modified">!         switch (b[cpInfoOffset - 1]) {</span>
              case Symbol.CONSTANT_INTEGER_TAG:
                  return readInt(cpInfoOffset);
              case Symbol.CONSTANT_FLOAT_TAG:
                  return Float.intBitsToFloat(readInt(cpInfoOffset));
              case Symbol.CONSTANT_LONG_TAG:
<span class="line-new-header">--- 3825,11 ---</span>
        *     {@link Type}, {@link Handle} or {@link ConstantDynamic} corresponding to the specified
        *     constant pool entry.
        */
      public Object readConst(final int constantPoolEntryIndex, final char[] charBuffer) {
          int cpInfoOffset = cpInfoOffsets[constantPoolEntryIndex];
<span class="line-modified">!         switch (classFileBuffer[cpInfoOffset - 1]) {</span>
              case Symbol.CONSTANT_INTEGER_TAG:
                  return readInt(cpInfoOffset);
              case Symbol.CONSTANT_FLOAT_TAG:
                  return Float.intBitsToFloat(readInt(cpInfoOffset));
              case Symbol.CONSTANT_LONG_TAG:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3626,11 ***</span>
                  int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];
                  String owner = readClass(referenceCpInfoOffset, charBuffer);
                  String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                  String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
                  boolean isInterface =
<span class="line-modified">!                         b[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;</span>
                  return new Handle(referenceKind, owner, name, descriptor, isInterface);
              case Symbol.CONSTANT_DYNAMIC_TAG:
                  return readConstantDynamic(constantPoolEntryIndex, charBuffer);
              default:
                  throw new IllegalArgumentException();
<span class="line-new-header">--- 3848,11 ---</span>
                  int nameAndTypeCpInfoOffset = cpInfoOffsets[readUnsignedShort(referenceCpInfoOffset + 2)];
                  String owner = readClass(referenceCpInfoOffset, charBuffer);
                  String name = readUTF8(nameAndTypeCpInfoOffset, charBuffer);
                  String descriptor = readUTF8(nameAndTypeCpInfoOffset + 2, charBuffer);
                  boolean isInterface =
<span class="line-modified">!                         classFileBuffer[referenceCpInfoOffset - 1] == Symbol.CONSTANT_INTERFACE_METHODREF_TAG;</span>
                  return new Handle(referenceKind, owner, name, descriptor, isInterface);
              case Symbol.CONSTANT_DYNAMIC_TAG:
                  return readConstantDynamic(constantPoolEntryIndex, charBuffer);
              default:
                  throw new IllegalArgumentException();
</pre>
<center><a href="../../../../../java/lang/reflect/Field.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Constants.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
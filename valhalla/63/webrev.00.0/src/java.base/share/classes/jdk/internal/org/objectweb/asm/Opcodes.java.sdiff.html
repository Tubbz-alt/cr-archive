<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Frame.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Type.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/org/objectweb/asm/Opcodes.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 61 /**
 62  * The JVM opcodes, access flags and array type codes. This interface does not define all the JVM
 63  * opcodes because some opcodes are automatically handled. For example, the xLOAD and xSTORE opcodes
 64  * are automatically replaced by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and
 65  * xSTORE_n opcodes are therefore not defined in this interface. Likewise for LDC, automatically
 66  * replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and JSR_W.
 67  *
 68  * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html&quot;&gt;JVMS 6&lt;/a&gt;
 69  * @author Eric Bruneton
 70  * @author Eugene Kuleshov
 71  */
 72 // DontCheck(InterfaceIsType): can&#39;t be fixed (for backward binary compatibility).
 73 public interface Opcodes {
 74 
 75     // ASM API versions.
 76 
 77     int ASM4 = 4 &lt;&lt; 16 | 0 &lt;&lt; 8;
 78     int ASM5 = 5 &lt;&lt; 16 | 0 &lt;&lt; 8;
 79     int ASM6 = 6 &lt;&lt; 16 | 0 &lt;&lt; 8;
 80     int ASM7 = 7 &lt;&lt; 16 | 0 &lt;&lt; 8;

 81 
<span class="line-modified"> 82     // Java ClassFile versions (the minor version is stored in the 16 most</span>
<span class="line-modified"> 83     // significant bits, and the</span>




















































































































































































































 84     // major version in the 16 least significant bits).
 85 
 86     int V1_1 = 3 &lt;&lt; 16 | 45;
 87     int V1_2 = 0 &lt;&lt; 16 | 46;
 88     int V1_3 = 0 &lt;&lt; 16 | 47;
 89     int V1_4 = 0 &lt;&lt; 16 | 48;
 90     int V1_5 = 0 &lt;&lt; 16 | 49;
 91     int V1_6 = 0 &lt;&lt; 16 | 50;
 92     int V1_7 = 0 &lt;&lt; 16 | 51;
 93     int V1_8 = 0 &lt;&lt; 16 | 52;
 94     int V9 = 0 &lt;&lt; 16 | 53;
 95     int V10 = 0 &lt;&lt; 16 | 54;
 96     int V11 = 0 &lt;&lt; 16 | 55;
 97     int V12 = 0 &lt;&lt; 16 | 56;
 98     int V13 = 0 &lt;&lt; 16 | 57;
 99     int V14 = 0 &lt;&lt; 16 | 58;
100     int V15 = 0 &lt;&lt; 16 | 59;
101 
102     /**
103       * Version flag indicating that the class is using &#39;preview&#39; features.
</pre>
<hr />
<pre>
117     int ACC_PRIVATE = 0x0002; // class, field, method
118     int ACC_PROTECTED = 0x0004; // class, field, method
119     int ACC_STATIC = 0x0008; // field, method
120     int ACC_FINAL = 0x0010; // class, field, method, parameter
121     int ACC_SUPER = 0x0020; // class
122     int ACC_SYNCHRONIZED = 0x0020; // method
123     int ACC_OPEN = 0x0020; // module
124     int ACC_TRANSITIVE = 0x0020; // module requires
125     int ACC_VOLATILE = 0x0040; // field
126     int ACC_BRIDGE = 0x0040; // method
127     int ACC_STATIC_PHASE = 0x0040; // module requires
128     int ACC_VARARGS = 0x0080; // method
129     int ACC_TRANSIENT = 0x0080; // field
130     int ACC_NATIVE = 0x0100; // method
131     int ACC_INTERFACE = 0x0200; // class
132     int ACC_ABSTRACT = 0x0400; // class, method
133     int ACC_STRICT = 0x0800; // method
134     int ACC_SYNTHETIC = 0x1000; // class, field, method, parameter, module *
135     int ACC_ANNOTATION = 0x2000; // class
136     int ACC_ENUM = 0x4000; // class(?) field inner
<span class="line-modified">137     int ACC_MANDATED = 0x8000; // parameter, module, module *</span>
138     int ACC_MODULE = 0x8000; // class
139 
140     // ASM specific access flags.
141     // WARNING: the 16 least significant bits must NOT be used, to avoid conflicts with standard
142     // access flags, and also to make sure that these flags are automatically filtered out when
143     // written in class files (because access flags are stored using 16 bits only).
144 

145     int ACC_DEPRECATED = 0x20000; // class, field, method
146 
147     // Possible values for the type operand of the NEWARRAY instruction.
148     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html#jvms-6.5.newarray.
149 
150     int T_BOOLEAN = 4;
151     int T_CHAR = 5;
152     int T_FLOAT = 6;
153     int T_DOUBLE = 7;
154     int T_BYTE = 8;
155     int T_SHORT = 9;
156     int T_INT = 10;
157     int T_LONG = 11;
158 
159     // Possible values for the reference_kind field of CONSTANT_MethodHandle_info structures.
160     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4.8.
161 
162     int H_GETFIELD = 1;
163     int H_GETSTATIC = 2;
164     int H_PUTFIELD = 3;
</pre>
</td>
<td>
<hr />
<pre>
 61 /**
 62  * The JVM opcodes, access flags and array type codes. This interface does not define all the JVM
 63  * opcodes because some opcodes are automatically handled. For example, the xLOAD and xSTORE opcodes
 64  * are automatically replaced by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and
 65  * xSTORE_n opcodes are therefore not defined in this interface. Likewise for LDC, automatically
 66  * replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and JSR_W.
 67  *
 68  * @see &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html&quot;&gt;JVMS 6&lt;/a&gt;
 69  * @author Eric Bruneton
 70  * @author Eugene Kuleshov
 71  */
 72 // DontCheck(InterfaceIsType): can&#39;t be fixed (for backward binary compatibility).
 73 public interface Opcodes {
 74 
 75     // ASM API versions.
 76 
 77     int ASM4 = 4 &lt;&lt; 16 | 0 &lt;&lt; 8;
 78     int ASM5 = 5 &lt;&lt; 16 | 0 &lt;&lt; 8;
 79     int ASM6 = 6 &lt;&lt; 16 | 0 &lt;&lt; 8;
 80     int ASM7 = 7 &lt;&lt; 16 | 0 &lt;&lt; 8;
<span class="line-added"> 81     int ASM8 = 8 &lt;&lt; 16 | 0 &lt;&lt; 8;</span>
 82 
<span class="line-modified"> 83     /**</span>
<span class="line-modified"> 84       * &lt;i&gt;Experimental, use at your own risk. This field will be renamed when it becomes stable, this</span>
<span class="line-added"> 85       * will break existing code using it. Only code compiled with --enable-preview can use this.&lt;/i&gt;</span>
<span class="line-added"> 86       *</span>
<span class="line-added"> 87       * @deprecated This API is experimental.</span>
<span class="line-added"> 88       */</span>
<span class="line-added"> 89     @Deprecated int ASM9_EXPERIMENTAL = 1 &lt;&lt; 24 | 9 &lt;&lt; 16 | 0 &lt;&lt; 8;</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91     /*</span>
<span class="line-added"> 92       * Internal flags used to redirect calls to deprecated methods. For instance, if a visitOldStuff</span>
<span class="line-added"> 93       * method in API_OLD is deprecated and replaced with visitNewStuff in API_NEW, then the</span>
<span class="line-added"> 94       * redirection should be done as follows:</span>
<span class="line-added"> 95       *</span>
<span class="line-added"> 96       * &lt;pre&gt;</span>
<span class="line-added"> 97       * public class StuffVisitor {</span>
<span class="line-added"> 98       *   ...</span>
<span class="line-added"> 99       *</span>
<span class="line-added">100       *   &amp;#64;Deprecated public void visitOldStuff(int arg, ...) {</span>
<span class="line-added">101       *     // SOURCE_DEPRECATED means &quot;a call from a deprecated method using the old &#39;api&#39; value&quot;.</span>
<span class="line-added">102       *     visitNewStuf(arg | (api &amp;#60; API_NEW ? SOURCE_DEPRECATED : 0), ...);</span>
<span class="line-added">103       *   }</span>
<span class="line-added">104       *</span>
<span class="line-added">105       *   public void visitNewStuff(int argAndSource, ...) {</span>
<span class="line-added">106       *     if (api &amp;#60; API_NEW &amp;#38;&amp;#38; (argAndSource &amp;#38; SOURCE_DEPRECATED) == 0) {</span>
<span class="line-added">107       *       visitOldStuff(argAndSource, ...);</span>
<span class="line-added">108       *     } else {</span>
<span class="line-added">109       *       int arg = argAndSource &amp;#38; ~SOURCE_MASK;</span>
<span class="line-added">110       *       [ do stuff ]</span>
<span class="line-added">111       *     }</span>
<span class="line-added">112       *   }</span>
<span class="line-added">113       * }</span>
<span class="line-added">114       * &lt;/pre&gt;</span>
<span class="line-added">115       *</span>
<span class="line-added">116       * &lt;p&gt;If &#39;api&#39; is equal to API_NEW, there are two cases:</span>
<span class="line-added">117       *</span>
<span class="line-added">118       * &lt;ul&gt;</span>
<span class="line-added">119       *   &lt;li&gt;call visitNewStuff: the redirection test is skipped and &#39;do stuff&#39; is executed directly.</span>
<span class="line-added">120       *   &lt;li&gt;call visitOldSuff: the source is not set to SOURCE_DEPRECATED before calling</span>
<span class="line-added">121       *       visitNewStuff, but the redirection test is skipped anyway in visitNewStuff, which</span>
<span class="line-added">122       *       directly executes &#39;do stuff&#39;.</span>
<span class="line-added">123       * &lt;/ul&gt;</span>
<span class="line-added">124       *</span>
<span class="line-added">125       * &lt;p&gt;If &#39;api&#39; is equal to API_OLD, there are two cases:</span>
<span class="line-added">126       *</span>
<span class="line-added">127       * &lt;ul&gt;</span>
<span class="line-added">128       *   &lt;li&gt;call visitOldSuff: the source is set to SOURCE_DEPRECATED before calling visitNewStuff.</span>
<span class="line-added">129       *       Because of this visitNewStuff does not redirect back to visitOldStuff, and instead</span>
<span class="line-added">130       *       executes &#39;do stuff&#39;.</span>
<span class="line-added">131       *   &lt;li&gt;call visitNewStuff: the call is redirected to visitOldStuff because the source is 0.</span>
<span class="line-added">132       *       visitOldStuff now sets the source to SOURCE_DEPRECATED and calls visitNewStuff back. This</span>
<span class="line-added">133       *       time visitNewStuff does not redirect the call, and instead executes &#39;do stuff&#39;.</span>
<span class="line-added">134       * &lt;/ul&gt;</span>
<span class="line-added">135       *</span>
<span class="line-added">136       * &lt;h1&gt;User subclasses&lt;/h1&gt;</span>
<span class="line-added">137       *</span>
<span class="line-added">138       * &lt;p&gt;If a user subclass overrides one of these methods, there are only two cases: either &#39;api&#39; is</span>
<span class="line-added">139       * API_OLD and visitOldStuff is overridden (and visitNewStuff is not), or &#39;api&#39; is API_NEW or</span>
<span class="line-added">140       * more, and visitNewStuff is overridden (and visitOldStuff is not). Any other case is a user</span>
<span class="line-added">141       * programming error.</span>
<span class="line-added">142       *</span>
<span class="line-added">143       * &lt;p&gt;If &#39;api&#39; is equal to API_NEW, the class hierarchy is equivalent to</span>
<span class="line-added">144       *</span>
<span class="line-added">145       * &lt;pre&gt;</span>
<span class="line-added">146       * public class StuffVisitor {</span>
<span class="line-added">147       *   &amp;#64;Deprecated public void visitOldStuff(int arg, ...) { visitNewStuf(arg, ...); }</span>
<span class="line-added">148       *   public void visitNewStuff(int arg, ...) { [ do stuff ] }</span>
<span class="line-added">149       * }</span>
<span class="line-added">150       * class UserStuffVisitor extends StuffVisitor {</span>
<span class="line-added">151       *   &amp;#64;Override public void visitNewStuff(int arg, ...) {</span>
<span class="line-added">152       *     super.visitNewStuff(int arg, ...); // optional</span>
<span class="line-added">153       *     [ do user stuff ]</span>
<span class="line-added">154       *   }</span>
<span class="line-added">155       * }</span>
<span class="line-added">156       * &lt;/pre&gt;</span>
<span class="line-added">157       *</span>
<span class="line-added">158       * &lt;p&gt;It is then obvious that whether visitNewStuff or visitOldStuff is called, &#39;do stuff&#39; and &#39;do</span>
<span class="line-added">159       * user stuff&#39; will be executed, in this order.</span>
<span class="line-added">160       *</span>
<span class="line-added">161       * &lt;p&gt;If &#39;api&#39; is equal to API_OLD, the class hierarchy is equivalent to</span>
<span class="line-added">162       *</span>
<span class="line-added">163       * &lt;pre&gt;</span>
<span class="line-added">164       * public class StuffVisitor {</span>
<span class="line-added">165       *   &amp;#64;Deprecated public void visitOldStuff(int arg, ...) {</span>
<span class="line-added">166       *     visitNewStuf(arg | SOURCE_DEPRECATED, ...);</span>
<span class="line-added">167       *   }</span>
<span class="line-added">168       *   public void visitNewStuff(int argAndSource...) {</span>
<span class="line-added">169       *     if ((argAndSource &amp; SOURCE_DEPRECATED) == 0) {</span>
<span class="line-added">170       *       visitOldStuff(argAndSource, ...);</span>
<span class="line-added">171       *     } else {</span>
<span class="line-added">172       *       int arg = argAndSource &amp;#38; ~SOURCE_MASK;</span>
<span class="line-added">173       *       [ do stuff ]</span>
<span class="line-added">174       *     }</span>
<span class="line-added">175       *   }</span>
<span class="line-added">176       * }</span>
<span class="line-added">177       * class UserStuffVisitor extends StuffVisitor {</span>
<span class="line-added">178       *   &amp;#64;Override public void visitOldStuff(int arg, ...) {</span>
<span class="line-added">179       *     super.visitOldStuff(int arg, ...); // optional</span>
<span class="line-added">180       *     [ do user stuff ]</span>
<span class="line-added">181       *   }</span>
<span class="line-added">182       * }</span>
<span class="line-added">183       * &lt;/pre&gt;</span>
<span class="line-added">184       *</span>
<span class="line-added">185       * &lt;p&gt;and there are two cases:</span>
<span class="line-added">186       *</span>
<span class="line-added">187       * &lt;ul&gt;</span>
<span class="line-added">188       *   &lt;li&gt;call visitOldSuff: in the call to super.visitOldStuff, the source is set to</span>
<span class="line-added">189       *       SOURCE_DEPRECATED and visitNewStuff is called. Here &#39;do stuff&#39; is run because the source</span>
<span class="line-added">190       *       was previously set to SOURCE_DEPRECATED, and execution eventually returns to</span>
<span class="line-added">191       *       UserStuffVisitor.visitOldStuff, where &#39;do user stuff&#39; is run.</span>
<span class="line-added">192       *   &lt;li&gt;call visitNewStuff: the call is redirected to UserStuffVisitor.visitOldStuff because the</span>
<span class="line-added">193       *       source is 0. Execution continues as in the previous case, resulting in &#39;do stuff&#39; and &#39;do</span>
<span class="line-added">194       *       user stuff&#39; being executed, in this order.</span>
<span class="line-added">195       * &lt;/ul&gt;</span>
<span class="line-added">196       *</span>
<span class="line-added">197       * &lt;h1&gt;ASM subclasses&lt;/h1&gt;</span>
<span class="line-added">198       *</span>
<span class="line-added">199       * &lt;p&gt;In ASM packages, subclasses of StuffVisitor can typically be sub classed again by the user,</span>
<span class="line-added">200       * and can be used with API_OLD or API_NEW. Because of this, if such a subclass must override</span>
<span class="line-added">201       * visitNewStuff, it must do so in the following way (and must not override visitOldStuff):</span>
<span class="line-added">202       *</span>
<span class="line-added">203       * &lt;pre&gt;</span>
<span class="line-added">204       * public class AsmStuffVisitor extends StuffVisitor {</span>
<span class="line-added">205       *   &amp;#64;Override public void visitNewStuff(int argAndSource, ...) {</span>
<span class="line-added">206       *     if (api &amp;#60; API_NEW &amp;#38;&amp;#38; (argAndSource &amp;#38; SOURCE_DEPRECATED) == 0) {</span>
<span class="line-added">207       *       super.visitNewStuff(argAndSource, ...);</span>
<span class="line-added">208       *       return;</span>
<span class="line-added">209       *     }</span>
<span class="line-added">210       *     super.visitNewStuff(argAndSource, ...); // optional</span>
<span class="line-added">211       *     int arg = argAndSource &amp;#38; ~SOURCE_MASK;</span>
<span class="line-added">212       *     [ do other stuff ]</span>
<span class="line-added">213       *   }</span>
<span class="line-added">214       * }</span>
<span class="line-added">215       * &lt;/pre&gt;</span>
<span class="line-added">216       *</span>
<span class="line-added">217       * &lt;p&gt;If a user class extends this with &#39;api&#39; equal to API_NEW, the class hierarchy is equivalent</span>
<span class="line-added">218       * to</span>
<span class="line-added">219       *</span>
<span class="line-added">220       * &lt;pre&gt;</span>
<span class="line-added">221       * public class StuffVisitor {</span>
<span class="line-added">222       *   &amp;#64;Deprecated public void visitOldStuff(int arg, ...) { visitNewStuf(arg, ...); }</span>
<span class="line-added">223       *   public void visitNewStuff(int arg, ...) { [ do stuff ] }</span>
<span class="line-added">224       * }</span>
<span class="line-added">225       * public class AsmStuffVisitor extends StuffVisitor {</span>
<span class="line-added">226       *   &amp;#64;Override public void visitNewStuff(int arg, ...) {</span>
<span class="line-added">227       *     super.visitNewStuff(arg, ...);</span>
<span class="line-added">228       *     [ do other stuff ]</span>
<span class="line-added">229       *   }</span>
<span class="line-added">230       * }</span>
<span class="line-added">231       * class UserStuffVisitor extends StuffVisitor {</span>
<span class="line-added">232       *   &amp;#64;Override public void visitNewStuff(int arg, ...) {</span>
<span class="line-added">233       *     super.visitNewStuff(int arg, ...);</span>
<span class="line-added">234       *     [ do user stuff ]</span>
<span class="line-added">235       *   }</span>
<span class="line-added">236       * }</span>
<span class="line-added">237       * &lt;/pre&gt;</span>
<span class="line-added">238       *</span>
<span class="line-added">239       * &lt;p&gt;It is then obvious that whether visitNewStuff or visitOldStuff is called, &#39;do stuff&#39;, &#39;do</span>
<span class="line-added">240       * other stuff&#39; and &#39;do user stuff&#39; will be executed, in this order. If, on the other hand, a user</span>
<span class="line-added">241       * class extends AsmStuffVisitor with &#39;api&#39; equal to API_OLD, the class hierarchy is equivalent to</span>
<span class="line-added">242       *</span>
<span class="line-added">243       * &lt;pre&gt;</span>
<span class="line-added">244       * public class StuffVisitor {</span>
<span class="line-added">245       *   &amp;#64;Deprecated public void visitOldStuff(int arg, ...) {</span>
<span class="line-added">246       *     visitNewStuf(arg | SOURCE_DEPRECATED, ...);</span>
<span class="line-added">247       *   }</span>
<span class="line-added">248       *   public void visitNewStuff(int argAndSource, ...) {</span>
<span class="line-added">249       *     if ((argAndSource &amp; SOURCE_DEPRECATED) == 0) {</span>
<span class="line-added">250       *       visitOldStuff(argAndSource, ...);</span>
<span class="line-added">251       *     } else {</span>
<span class="line-added">252       *       int arg = argAndSource &amp;#38; ~SOURCE_MASK;</span>
<span class="line-added">253       *       [ do stuff ]</span>
<span class="line-added">254       *     }</span>
<span class="line-added">255       *   }</span>
<span class="line-added">256       * }</span>
<span class="line-added">257       * public class AsmStuffVisitor extends StuffVisitor {</span>
<span class="line-added">258       *   &amp;#64;Override public void visitNewStuff(int argAndSource, ...) {</span>
<span class="line-added">259       *     if ((argAndSource &amp;#38; SOURCE_DEPRECATED) == 0) {</span>
<span class="line-added">260       *       super.visitNewStuff(argAndSource, ...);</span>
<span class="line-added">261       *       return;</span>
<span class="line-added">262       *     }</span>
<span class="line-added">263       *     super.visitNewStuff(argAndSource, ...); // optional</span>
<span class="line-added">264       *     int arg = argAndSource &amp;#38; ~SOURCE_MASK;</span>
<span class="line-added">265       *     [ do other stuff ]</span>
<span class="line-added">266       *   }</span>
<span class="line-added">267       * }</span>
<span class="line-added">268       * class UserStuffVisitor extends StuffVisitor {</span>
<span class="line-added">269       *   &amp;#64;Override public void visitOldStuff(int arg, ...) {</span>
<span class="line-added">270       *     super.visitOldStuff(arg, ...);</span>
<span class="line-added">271       *     [ do user stuff ]</span>
<span class="line-added">272       *   }</span>
<span class="line-added">273       * }</span>
<span class="line-added">274       * &lt;/pre&gt;</span>
<span class="line-added">275       *</span>
<span class="line-added">276       * &lt;p&gt;and, here again, whether visitNewStuff or visitOldStuff is called, &#39;do stuff&#39;, &#39;do other</span>
<span class="line-added">277       * stuff&#39; and &#39;do user stuff&#39; will be executed, in this order (exercise left to the reader).</span>
<span class="line-added">278       *</span>
<span class="line-added">279       * &lt;h1&gt;Notes&lt;/h1&gt;</span>
<span class="line-added">280       *</span>
<span class="line-added">281       * &lt;ul&gt;</span>
<span class="line-added">282       *   &lt;li&gt;the SOURCE_DEPRECATED flag is set only if &#39;api&#39; is API_OLD, just before calling</span>
<span class="line-added">283       *       visitNewStuff. By hypothesis, this method is not overridden by the user. Therefore, user</span>
<span class="line-added">284       *       classes can never see this flag. Only ASM subclasses must take care of extracting the</span>
<span class="line-added">285       *       actual argument value by clearing the source flags.</span>
<span class="line-added">286       *   &lt;li&gt;because the SOURCE_DEPRECATED flag is immediately cleared in the caller, the caller can</span>
<span class="line-added">287       *       call visitOldStuff or visitNewStuff (in &#39;do stuff&#39; and &#39;do user stuff&#39;) on a delegate</span>
<span class="line-added">288       *       visitor without any risks (breaking the redirection logic, &quot;leaking&quot; the flag, etc).</span>
<span class="line-added">289       *   &lt;li&gt;all the scenarios discussed above are unit tested in MethodVisitorTest.</span>
<span class="line-added">290       * &lt;/ul&gt;</span>
<span class="line-added">291       */</span>
<span class="line-added">292 </span>
<span class="line-added">293     int SOURCE_DEPRECATED = 0x100;</span>
<span class="line-added">294     int SOURCE_MASK = SOURCE_DEPRECATED;</span>
<span class="line-added">295 </span>
<span class="line-added">296     // Java ClassFile versions (the minor version is stored in the 16 most significant bits, and the</span>
297     // major version in the 16 least significant bits).
298 
299     int V1_1 = 3 &lt;&lt; 16 | 45;
300     int V1_2 = 0 &lt;&lt; 16 | 46;
301     int V1_3 = 0 &lt;&lt; 16 | 47;
302     int V1_4 = 0 &lt;&lt; 16 | 48;
303     int V1_5 = 0 &lt;&lt; 16 | 49;
304     int V1_6 = 0 &lt;&lt; 16 | 50;
305     int V1_7 = 0 &lt;&lt; 16 | 51;
306     int V1_8 = 0 &lt;&lt; 16 | 52;
307     int V9 = 0 &lt;&lt; 16 | 53;
308     int V10 = 0 &lt;&lt; 16 | 54;
309     int V11 = 0 &lt;&lt; 16 | 55;
310     int V12 = 0 &lt;&lt; 16 | 56;
311     int V13 = 0 &lt;&lt; 16 | 57;
312     int V14 = 0 &lt;&lt; 16 | 58;
313     int V15 = 0 &lt;&lt; 16 | 59;
314 
315     /**
316       * Version flag indicating that the class is using &#39;preview&#39; features.
</pre>
<hr />
<pre>
330     int ACC_PRIVATE = 0x0002; // class, field, method
331     int ACC_PROTECTED = 0x0004; // class, field, method
332     int ACC_STATIC = 0x0008; // field, method
333     int ACC_FINAL = 0x0010; // class, field, method, parameter
334     int ACC_SUPER = 0x0020; // class
335     int ACC_SYNCHRONIZED = 0x0020; // method
336     int ACC_OPEN = 0x0020; // module
337     int ACC_TRANSITIVE = 0x0020; // module requires
338     int ACC_VOLATILE = 0x0040; // field
339     int ACC_BRIDGE = 0x0040; // method
340     int ACC_STATIC_PHASE = 0x0040; // module requires
341     int ACC_VARARGS = 0x0080; // method
342     int ACC_TRANSIENT = 0x0080; // field
343     int ACC_NATIVE = 0x0100; // method
344     int ACC_INTERFACE = 0x0200; // class
345     int ACC_ABSTRACT = 0x0400; // class, method
346     int ACC_STRICT = 0x0800; // method
347     int ACC_SYNTHETIC = 0x1000; // class, field, method, parameter, module *
348     int ACC_ANNOTATION = 0x2000; // class
349     int ACC_ENUM = 0x4000; // class(?) field inner
<span class="line-modified">350     int ACC_MANDATED = 0x8000; // field, method, parameter, module, module *</span>
351     int ACC_MODULE = 0x8000; // class
352 
353     // ASM specific access flags.
354     // WARNING: the 16 least significant bits must NOT be used, to avoid conflicts with standard
355     // access flags, and also to make sure that these flags are automatically filtered out when
356     // written in class files (because access flags are stored using 16 bits only).
357 
<span class="line-added">358     int ACC_RECORD = 0x10000; // class</span>
359     int ACC_DEPRECATED = 0x20000; // class, field, method
360 
361     // Possible values for the type operand of the NEWARRAY instruction.
362     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-6.html#jvms-6.5.newarray.
363 
364     int T_BOOLEAN = 4;
365     int T_CHAR = 5;
366     int T_FLOAT = 6;
367     int T_DOUBLE = 7;
368     int T_BYTE = 8;
369     int T_SHORT = 9;
370     int T_INT = 10;
371     int T_LONG = 11;
372 
373     // Possible values for the reference_kind field of CONSTANT_MethodHandle_info structures.
374     // See https://docs.oracle.com/javase/specs/jvms/se9/html/jvms-4.html#jvms-4.4.8.
375 
376     int H_GETFIELD = 1;
377     int H_GETSTATIC = 2;
378     int H_PUTFIELD = 3;
</pre>
</td>
</tr>
</table>
<center><a href="Frame.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Type.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
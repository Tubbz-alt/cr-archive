<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/jdk/internal/org/objectweb/asm/commons/Remapper.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*
 26  * This file is available under and governed by the GNU General Public
 27  * License version 2 only, as published by the Free Software Foundation.
 28  * However, the following notice accompanied the original version of this
 29  * file:
 30  *
 31  * ASM: a very small and fast Java bytecode manipulation framework
 32  * Copyright (c) 2000-2011 INRIA, France Telecom
 33  * All rights reserved.
 34  *
 35  * Redistribution and use in source and binary forms, with or without
 36  * modification, are permitted provided that the following conditions
 37  * are met:
 38  * 1. Redistributions of source code must retain the above copyright
 39  *    notice, this list of conditions and the following disclaimer.
 40  * 2. Redistributions in binary form must reproduce the above copyright
 41  *    notice, this list of conditions and the following disclaimer in the
 42  *    documentation and/or other materials provided with the distribution.
 43  * 3. Neither the name of the copyright holders nor the names of its
 44  *    contributors may be used to endorse or promote products derived from
 45  *    this software without specific prior written permission.
 46  *
 47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 57  * THE POSSIBILITY OF SUCH DAMAGE.
 58  */
 59 package jdk.internal.org.objectweb.asm.commons;
 60 
 61 import jdk.internal.org.objectweb.asm.ConstantDynamic;
 62 import jdk.internal.org.objectweb.asm.Handle;
 63 import jdk.internal.org.objectweb.asm.Opcodes;
 64 import jdk.internal.org.objectweb.asm.Type;
 65 import jdk.internal.org.objectweb.asm.signature.SignatureReader;
 66 import jdk.internal.org.objectweb.asm.signature.SignatureVisitor;
 67 import jdk.internal.org.objectweb.asm.signature.SignatureWriter;
 68 
 69 /**
 70  * A class responsible for remapping types and names.
 71  *
 72  * @author Eugene Kuleshov
 73  */
 74 public abstract class Remapper {
 75 
 76     /**
 77       * Returns the given descriptor, remapped with {@link #map(String)}.
 78       *
 79       * @param descriptor a type descriptor.
 80       * @return the given descriptor, with its [array element type] internal name remapped with {@link
 81       *     #map(String)} (if the descriptor corresponds to an array or object type, otherwise the
 82       *     descriptor is returned as is).
 83       */
 84     public String mapDesc(final String descriptor) {
 85         return mapType(Type.getType(descriptor)).getDescriptor();
 86             // FIXME: support Q-type
 87     }
 88 
 89     /**
 90       * Returns the given {@link Type}, remapped with {@link #map(String)} or {@link
 91       * #mapMethodDesc(String)}.
 92       *
 93       * @param type a type, which can be a method type.
 94       * @return the given type, with its [array element type] internal name remapped with {@link
 95       *     #map(String)} (if the type is an array or object type, otherwise the type is returned as
 96       *     is) or, of the type is a method type, with its descriptor remapped with {@link
 97       *     #mapMethodDesc(String)}.
 98       */
 99     private Type mapType(final Type type) {
100         switch (type.getSort()) {
101             case Type.ARRAY:
102                 StringBuilder remappedDescriptor = new StringBuilder();
103                 for (int i = 0; i &lt; type.getDimensions(); ++i) {
104                     remappedDescriptor.append(&#39;[&#39;);
105                 }
106                 remappedDescriptor.append(mapType(type.getElementType()).getDescriptor());
107                 return Type.getType(remappedDescriptor.toString());
108             case Type.OBJECT:
109                 String remappedInternalName = map(type.getInternalName());
110                 return remappedInternalName != null ? Type.getObjectType(remappedInternalName) : type;
111             case Type.METHOD:
112                 return Type.getMethodType(mapMethodDesc(type.getDescriptor()));
113             default:
114                 return type;
115         }
116     }
117 
118     /**
119       * Returns the given internal name, remapped with {@link #map(String)}.
120       *
121       * @param internalName the internal name (or array type descriptor) of some (array) class.
122       * @return the given internal name, remapped with {@link #map(String)}.
123       */
124     public String mapType(final String internalName) {
125         if (internalName == null) {
126             return null;
127         }
128         return mapType(Type.getObjectType(internalName)).getInternalName();
129     }
130 
131     /**
132       * Returns the given internal names, remapped with {@link #map(String)}.
133       *
134       * @param internalNames the internal names (or array type descriptors) of some (array) classes.
135       * @return the given internal name, remapped with {@link #map(String)}.
136       */
137     public String[] mapTypes(final String[] internalNames) {
138         String[] remappedInternalNames = null;
139         for (int i = 0; i &lt; internalNames.length; ++i) {
140             String internalName = internalNames[i];
141             String remappedInternalName = mapType(internalName);
142             if (remappedInternalName != null) {
143                 if (remappedInternalNames == null) {
<a name="1" id="anc1"></a><span class="line-modified">144                     remappedInternalNames = new String[internalNames.length];</span>
<span class="line-removed">145                     System.arraycopy(internalNames, 0, remappedInternalNames, 0, internalNames.length);</span>
146                 }
147                 remappedInternalNames[i] = remappedInternalName;
148             }
149         }
150         return remappedInternalNames != null ? remappedInternalNames : internalNames;
151     }
152 
153     /**
154       * Returns the given method descriptor, with its argument and return type descriptors remapped
155       * with {@link #mapDesc(String)}.
156       *
157       * @param methodDescriptor a method descriptor.
158       * @return the given method descriptor, with its argument and return type descriptors remapped
159       *     with {@link #mapDesc(String)}.
160       */
161     public String mapMethodDesc(final String methodDescriptor) {
162         if (&quot;()V&quot;.equals(methodDescriptor)) {
163             return methodDescriptor;
164         }
165 
166         StringBuilder stringBuilder = new StringBuilder(&quot;(&quot;);
167         for (Type argumentType : Type.getArgumentTypes(methodDescriptor)) {
168             stringBuilder.append(mapType(argumentType).getDescriptor());
169         }
170         Type returnType = Type.getReturnType(methodDescriptor);
171         if (returnType == Type.VOID_TYPE) {
172             stringBuilder.append(&quot;)V&quot;);
173         } else {
174             stringBuilder.append(&#39;)&#39;).append(mapType(returnType).getDescriptor());
175         }
176         return stringBuilder.toString();
177     }
178 
179     /**
180       * Returns the given value, remapped with this remapper. Possible values are {@link Boolean},
181       * {@link Byte}, {@link Short}, {@link Character}, {@link Integer}, {@link Long}, {@link Double},
182       * {@link Float}, {@link String}, {@link Type}, {@link Handle}, {@link ConstantDynamic} or arrays
183       * of primitive types .
184       *
185       * @param value an object. Only {@link Type}, {@link Handle} and {@link ConstantDynamic} values
186       *     are remapped.
187       * @return the given value, remapped with this remapper.
188       */
189     public Object mapValue(final Object value) {
190         if (value instanceof Type) {
191             return mapType((Type) value);
192         }
193         if (value instanceof Handle) {
194             Handle handle = (Handle) value;
195             return new Handle(
196                     handle.getTag(),
197                     mapType(handle.getOwner()),
198                     mapMethodName(handle.getOwner(), handle.getName(), handle.getDesc()),
199                     handle.getTag() &lt;= Opcodes.H_PUTSTATIC
200                             ? mapDesc(handle.getDesc())
201                             : mapMethodDesc(handle.getDesc()),
202                     handle.isInterface());
203         }
204         if (value instanceof ConstantDynamic) {
205             ConstantDynamic constantDynamic = (ConstantDynamic) value;
206             int bootstrapMethodArgumentCount = constantDynamic.getBootstrapMethodArgumentCount();
207             Object[] remappedBootstrapMethodArguments = new Object[bootstrapMethodArgumentCount];
208             for (int i = 0; i &lt; bootstrapMethodArgumentCount; ++i) {
209                 remappedBootstrapMethodArguments[i] =
210                         mapValue(constantDynamic.getBootstrapMethodArgument(i));
211             }
212             String descriptor = constantDynamic.getDescriptor();
213             return new ConstantDynamic(
214                     mapInvokeDynamicMethodName(constantDynamic.getName(), descriptor),
215                     mapDesc(descriptor),
216                     (Handle) mapValue(constantDynamic.getBootstrapMethod()),
217                     remappedBootstrapMethodArguments);
218         }
219         return value;
220     }
221 
222     /**
223       * Returns the given signature, remapped with the {@link SignatureVisitor} returned by {@link
224       * #createSignatureRemapper(SignatureVisitor)}.
225       *
226       * @param signature a &lt;i&gt;JavaTypeSignature&lt;/i&gt;, &lt;i&gt;ClassSignature&lt;/i&gt; or &lt;i&gt;MethodSignature&lt;/i&gt;.
227       * @param typeSignature whether the given signature is a &lt;i&gt;JavaTypeSignature&lt;/i&gt;.
228       * @return signature the given signature, remapped with the {@link SignatureVisitor} returned by
229       *     {@link #createSignatureRemapper(SignatureVisitor)}.
230       */
231     public String mapSignature(final String signature, final boolean typeSignature) {
232         if (signature == null) {
233             return null;
234         }
235         SignatureReader signatureReader = new SignatureReader(signature);
236         SignatureWriter signatureWriter = new SignatureWriter();
237         SignatureVisitor signatureRemapper = createSignatureRemapper(signatureWriter);
238         if (typeSignature) {
239             signatureReader.acceptType(signatureRemapper);
240         } else {
241             signatureReader.accept(signatureRemapper);
242         }
243         return signatureWriter.toString();
244     }
245 
246     /**
247       * Constructs a new remapper for signatures. The default implementation of this method returns a
248       * new {@link SignatureRemapper}.
249       *
250       * @param signatureVisitor the SignatureVisitor the remapper must delegate to.
251       * @return the newly created remapper.
252       * @deprecated use {@link #createSignatureRemapper} instead.
253       */
254     @Deprecated
255     protected SignatureVisitor createRemappingSignatureAdapter(
256             final SignatureVisitor signatureVisitor) {
257         return createSignatureRemapper(signatureVisitor);
258     }
259 
260     /**
261       * Constructs a new remapper for signatures. The default implementation of this method returns a
262       * new {@link SignatureRemapper}.
263       *
264       * @param signatureVisitor the SignatureVisitor the remapper must delegate to.
265       * @return the newly created remapper.
266       */
267     protected SignatureVisitor createSignatureRemapper(final SignatureVisitor signatureVisitor) {
268         return new SignatureRemapper(signatureVisitor, this);
269     }
270 
271     /**
272       * Maps an inner class name to its new name. The default implementation of this method provides a
273       * strategy that will work for inner classes produced by Java, but not necessarily other
274       * languages. Subclasses can override.
275       *
276       * @param name the fully-qualified internal name of the inner class.
277       * @param ownerName the internal name of the owner class of the inner class.
278       * @param innerName the internal name of the inner class.
279       * @return the new inner name of the inner class.
280       */
281     public String mapInnerClassName(
282             final String name, final String ownerName, final String innerName) {
283         final String remappedInnerName = this.mapType(name);
284         if (remappedInnerName.contains(&quot;$&quot;)) {
<a name="2" id="anc2"></a><span class="line-modified">285             return remappedInnerName.substring(remappedInnerName.lastIndexOf(&#39;$&#39;) + 1);</span>





286         } else {
287             return innerName;
288         }
289     }
290 
291     /**
292       * Maps a method name to its new name. The default implementation of this method returns the given
293       * name, unchanged. Subclasses can override.
294       *
295       * @param owner the internal name of the owner class of the method.
296       * @param name the name of the method.
297       * @param descriptor the descriptor of the method.
298       * @return the new name of the method.
299       */
300     public String mapMethodName(final String owner, final String name, final String descriptor) {
301         return name;
302     }
303 
304     /**
305       * Maps an invokedynamic or a constant dynamic method name to its new name. The default
306       * implementation of this method returns the given name, unchanged. Subclasses can override.
307       *
308       * @param name the name of the method.
309       * @param descriptor the descriptor of the method.
310       * @return the new name of the method.
311       */
312     public String mapInvokeDynamicMethodName(final String name, final String descriptor) {
313         return name;
314     }
315 
<a name="3" id="anc3"></a>













316     /**
317       * Maps a field name to its new name. The default implementation of this method returns the given
318       * name, unchanged. Subclasses can override.
319       *
320       * @param owner the internal name of the owner class of the field.
321       * @param name the name of the field.
322       * @param descriptor the descriptor of the field.
323       * @return the new name of the field.
324       */
325     public String mapFieldName(final String owner, final String name, final String descriptor) {
326         return name;
327     }
328 
329     /**
330       * Maps a package name to its new name. The default implementation of this method returns the
331       * given name, unchanged. Subclasses can override.
332       *
333       * @param name the fully qualified name of the package (using dots).
334       * @return the new name of the package.
335       */
336     public String mapPackageName(final String name) {
337         return name;
338     }
339 
340     /**
341       * Maps a module name to its new name. The default implementation of this method returns the given
342       * name, unchanged. Subclasses can override.
343       *
344       * @param name the fully qualified name (using dots) of a module.
345       * @return the new name of the module.
346       */
347     public String mapModuleName(final String name) {
348         return name;
349     }
350 
351     /**
352       * Maps the internal name of a class to its new name. The default implementation of this method
353       * returns the given name, unchanged. Subclasses can override.
354       *
355       * @param internalName the internal name of a class.
356       * @return the new internal name.
357       */
358     public String map(final String internalName) {
359         return internalName;
360     }
361 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckMethodAdapter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CheckClassAdapter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../reflect/UnsafeFieldAccessorFactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/jdk/internal/org/objectweb/asm/util/CheckMethodAdapter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  44  *    contributors may be used to endorse or promote products derived from
  45  *    this software without specific prior written permission.
  46  *
  47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  57  * THE POSSIBILITY OF SUCH DAMAGE.
  58  */
  59 package jdk.internal.org.objectweb.asm.util;
  60 
  61 import java.io.PrintWriter;
  62 import java.io.StringWriter;
  63 import java.util.ArrayList;

  64 import java.util.HashMap;
  65 import java.util.HashSet;
  66 import java.util.List;
  67 import java.util.Map;
  68 import java.util.Set;
  69 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  70 import jdk.internal.org.objectweb.asm.Attribute;
  71 import jdk.internal.org.objectweb.asm.ConstantDynamic;
  72 import jdk.internal.org.objectweb.asm.Handle;
  73 import jdk.internal.org.objectweb.asm.Label;
  74 import jdk.internal.org.objectweb.asm.MethodVisitor;
  75 import jdk.internal.org.objectweb.asm.Opcodes;
  76 import jdk.internal.org.objectweb.asm.Type;
  77 import jdk.internal.org.objectweb.asm.TypePath;
  78 import jdk.internal.org.objectweb.asm.TypeReference;
  79 import jdk.internal.org.objectweb.asm.tree.MethodNode;
  80 import jdk.internal.org.objectweb.asm.tree.analysis.Analyzer;
  81 import jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException;
  82 import jdk.internal.org.objectweb.asm.tree.analysis.BasicValue;
  83 import jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier;
</pre>
<hr />
<pre>
 380       *
 381       * @param methodvisitor the method visitor to which this adapter must delegate calls.
 382       */
 383     public CheckMethodAdapter(final MethodVisitor methodvisitor) {
 384         this(methodvisitor, new HashMap&lt;Label, Integer&gt;());
 385     }
 386 
 387     /**
 388       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will not perform any
 389       * data flow check (see {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
 390       * &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;. Instead, they must use the {@link
 391       * #CheckMethodAdapter(int, MethodVisitor, Map)} version.
 392       *
 393       * @param methodVisitor the method visitor to which this adapter must delegate calls.
 394       * @param labelInsnIndices the index of the instruction designated by each visited label so far
 395       *     (in other methods). This map is updated with the labels from the visited method.
 396       * @throws IllegalStateException If a subclass calls this constructor.
 397       */
 398     public CheckMethodAdapter(
 399             final MethodVisitor methodVisitor, final Map&lt;Label, Integer&gt; labelInsnIndices) {
<span class="line-modified"> 400         this(Opcodes.ASM7, methodVisitor, labelInsnIndices);</span>
 401         if (getClass() != CheckMethodAdapter.class) {
 402             throw new IllegalStateException();
 403         }
 404     }
 405 
 406     /**
 407       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will not perform any
 408       * data flow check (see {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
 409       *
 410       * @param api the ASM API version implemented by this CheckMethodAdapter. Must be one of {@link
<span class="line-modified"> 411       *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.</span>

 412       * @param methodVisitor the method visitor to which this adapter must delegate calls.
 413       * @param labelInsnIndices the index of the instruction designated by each visited label so far
 414       *     (in other methods). This map is updated with the labels from the visited method.
 415       */
 416     protected CheckMethodAdapter(
 417             final int api,
 418             final MethodVisitor methodVisitor,
 419             final Map&lt;Label, Integer&gt; labelInsnIndices) {
 420         super(api, methodVisitor);
 421         this.labelInsnIndices = labelInsnIndices;
<span class="line-modified"> 422         this.referencedLabels = new HashSet&lt;Label&gt;();</span>
<span class="line-modified"> 423         this.handlers = new ArrayList&lt;Label&gt;();</span>
 424     }
 425 
 426     /**
 427       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will perform basic data
 428       * flow checks. For instance in a method whose signature is {@code void m ()}, the invalid
 429       * instruction IRETURN, or the invalid sequence IADD L2I will be detected. &lt;i&gt;Subclasses must not
 430       * use this constructor&lt;/i&gt;. Instead, they must use the {@link
 431       * #CheckMethodAdapter(int,int,String,String,MethodVisitor,Map)} version.
 432       *
 433       * @param access the method&#39;s access flags.
 434       * @param name the method&#39;s name.
 435       * @param descriptor the method&#39;s descriptor (see {@link Type}).
 436       * @param methodVisitor the method visitor to which this adapter must delegate calls.
 437       * @param labelInsnIndices the index of the instruction designated by each visited label so far
 438       *     (in other methods). This map is updated with the labels from the visited method.
 439       */
 440     public CheckMethodAdapter(
 441             final int access,
 442             final String name,
 443             final String descriptor,
 444             final MethodVisitor methodVisitor,
 445             final Map&lt;Label, Integer&gt; labelInsnIndices) {
<span class="line-modified"> 446         this(Opcodes.ASM7, access, name, descriptor, methodVisitor, labelInsnIndices);</span>

 447         if (getClass() != CheckMethodAdapter.class) {
 448             throw new IllegalStateException();
 449         }
 450     }
 451 
 452     /**
 453       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will perform basic data
 454       * flow checks. For instance in a method whose signature is {@code void m ()}, the invalid
 455       * instruction IRETURN, or the invalid sequence IADD L2I will be detected.
 456       *
 457       * @param api the ASM API version implemented by this CheckMethodAdapter. Must be one of {@link
<span class="line-modified"> 458       *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6} or {@link Opcodes#ASM7}.</span>

 459       * @param access the method&#39;s access flags.
 460       * @param name the method&#39;s name.
 461       * @param descriptor the method&#39;s descriptor (see {@link Type}).
 462       * @param methodVisitor the method visitor to which this adapter must delegate calls.
 463       * @param labelInsnIndices the index of the instruction designated by each visited label so far
 464       *     (in other methods). This map is updated with the labels from the visited method.
 465       */
 466     protected CheckMethodAdapter(
 467             final int api,
 468             final int access,
 469             final String name,
 470             final String descriptor,
 471             final MethodVisitor methodVisitor,
 472             final Map&lt;Label, Integer&gt; labelInsnIndices) {
 473         this(
 474                 api,
 475                 new MethodNode(api, access, name, descriptor, null, null) {
 476                     @Override
 477                     public void visitEnd() {
<span class="line-modified"> 478                         Analyzer&lt;BasicValue&gt; analyzer = new Analyzer&lt;BasicValue&gt;(new BasicVerifier());</span>
 479                         try {
 480                             analyzer.analyze(&quot;dummy&quot;, this);
 481                         } catch (IndexOutOfBoundsException e) {
 482                             if (maxLocals == 0 &amp;&amp; maxStack == 0) {
 483                                 throw new IllegalArgumentException(
 484                                         &quot;Data flow checking option requires valid, non zero maxLocals and maxStack.&quot;,
 485                                         e);
 486                             }
 487                             throwError(analyzer, e);
 488                         } catch (AnalyzerException e) {
 489                             throwError(analyzer, e);
 490                         }
<span class="line-modified"> 491                         accept(methodVisitor);</span>


 492                     }
 493 
 494                     private void throwError(final Analyzer&lt;BasicValue&gt; analyzer, final Exception e) {
 495                         StringWriter stringWriter = new StringWriter();
 496                         PrintWriter printWriter = new PrintWriter(stringWriter, true);
 497                         CheckClassAdapter.printAnalyzerResult(this, analyzer, printWriter);
 498                         printWriter.close();
 499                         throw new IllegalArgumentException(e.getMessage() + &#39; &#39; + stringWriter.toString(), e);
 500                     }
 501                 },
 502                 labelInsnIndices);
 503         this.access = access;
 504     }
 505 
 506     @Override
 507     public void visitParameter(final String name, final int access) {
 508         if (name != null) {
 509             checkUnqualifiedName(version, name, &quot;name&quot;);
 510         }
 511         CheckClassAdapter.checkAccess(
</pre>
<hr />
<pre>
 718         if (opcode == Opcodes.NEW &amp;&amp; type.charAt(0) == &#39;[&#39;) {
 719             throw new IllegalArgumentException(&quot;NEW cannot be used to create arrays: &quot; + type);
 720         }
 721         super.visitTypeInsn(opcode, type);
 722         ++insnCount;
 723     }
 724 
 725     @Override
 726     public void visitFieldInsn(
 727             final int opcode, final String owner, final String name, final String descriptor) {
 728         checkVisitCodeCalled();
 729         checkVisitMaxsNotCalled();
 730         checkOpcodeMethod(opcode, Method.VISIT_FIELD_INSN);
 731         checkInternalName(version, owner, &quot;owner&quot;);
 732         checkUnqualifiedName(version, name, &quot;name&quot;);
 733         checkDescriptor(version, descriptor, false);
 734         super.visitFieldInsn(opcode, owner, name, descriptor);
 735         ++insnCount;
 736     }
 737 
<span class="line-removed"> 738     /**</span>
<span class="line-removed"> 739       * Deprecated.</span>
<span class="line-removed"> 740       *</span>
<span class="line-removed"> 741       * @deprecated use {@link #visitMethodInsn(int, String, String, String, boolean)} instead.</span>
<span class="line-removed"> 742       */</span>
<span class="line-removed"> 743     @Deprecated</span>
<span class="line-removed"> 744     @Override</span>
<span class="line-removed"> 745     public void visitMethodInsn(</span>
<span class="line-removed"> 746             final int opcode, final String owner, final String name, final String descriptor) {</span>
<span class="line-removed"> 747         if (api &gt;= Opcodes.ASM5) {</span>
<span class="line-removed"> 748             super.visitMethodInsn(opcode, owner, name, descriptor);</span>
<span class="line-removed"> 749             return;</span>
<span class="line-removed"> 750         }</span>
<span class="line-removed"> 751         doVisitMethodInsn(opcode, owner, name, descriptor, opcode == Opcodes.INVOKEINTERFACE);</span>
<span class="line-removed"> 752     }</span>
<span class="line-removed"> 753 </span>
 754     @Override
 755     public void visitMethodInsn(
<span class="line-modified"> 756             final int opcode,</span>
 757             final String owner,
 758             final String name,
 759             final String descriptor,
 760             final boolean isInterface) {
<span class="line-modified"> 761         if (api &lt; Opcodes.ASM5) {</span>
<span class="line-modified"> 762             super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);</span>

 763             return;
 764         }
<span class="line-modified"> 765         doVisitMethodInsn(opcode, owner, name, descriptor, isInterface);</span>
<span class="line-removed"> 766     }</span>
 767 
<span class="line-removed"> 768     private void doVisitMethodInsn(</span>
<span class="line-removed"> 769             final int opcode,</span>
<span class="line-removed"> 770             final String owner,</span>
<span class="line-removed"> 771             final String name,</span>
<span class="line-removed"> 772             final String descriptor,</span>
<span class="line-removed"> 773             final boolean isInterface) {</span>
 774         checkVisitCodeCalled();
 775         checkVisitMaxsNotCalled();
 776         checkOpcodeMethod(opcode, Method.VISIT_METHOD_INSN);
 777         if (opcode != Opcodes.INVOKESPECIAL || !&quot;&lt;init&gt;&quot;.equals(name)) {
 778             checkMethodIdentifier(version, name, &quot;name&quot;);
 779         }
 780         checkInternalName(version, owner, &quot;owner&quot;);
 781         checkMethodDescriptor(version, descriptor);
 782         if (opcode == Opcodes.INVOKEVIRTUAL &amp;&amp; isInterface) {
 783             throw new IllegalArgumentException(&quot;INVOKEVIRTUAL can&#39;t be used with interfaces&quot;);
 784         }
 785         if (opcode == Opcodes.INVOKEINTERFACE &amp;&amp; !isInterface) {
 786             throw new IllegalArgumentException(&quot;INVOKEINTERFACE can&#39;t be used with classes&quot;);
 787         }
 788         if (opcode == Opcodes.INVOKESPECIAL &amp;&amp; isInterface &amp;&amp; (version &amp; 0xFFFF) &lt; Opcodes.V1_8) {
 789             throw new IllegalArgumentException(
 790                     &quot;INVOKESPECIAL can&#39;t be used with interfaces prior to Java 8&quot;);
 791         }
<span class="line-modified"> 792 </span>
<span class="line-removed"> 793         // Calling super.visitMethodInsn requires to call the correct version depending on this.api</span>
<span class="line-removed"> 794         // (otherwise infinite loops can occur). To simplify and to make it easier to automatically</span>
<span class="line-removed"> 795         // remove the backward compatibility code, we inline the code of the overridden method here.</span>
<span class="line-removed"> 796         if (mv != null) {</span>
<span class="line-removed"> 797             mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface);</span>
<span class="line-removed"> 798         }</span>
 799         ++insnCount;
 800     }
 801 
 802     @Override
 803     public void visitInvokeDynamicInsn(
 804             final String name,
 805             final String descriptor,
 806             final Handle bootstrapMethodHandle,
 807             final Object... bootstrapMethodArguments) {
 808         checkVisitCodeCalled();
 809         checkVisitMaxsNotCalled();
 810         checkMethodIdentifier(version, name, &quot;name&quot;);
 811         checkMethodDescriptor(version, descriptor);
 812         if (bootstrapMethodHandle.getTag() != Opcodes.H_INVOKESTATIC
 813                 &amp;&amp; bootstrapMethodHandle.getTag() != Opcodes.H_NEWINVOKESPECIAL) {
 814             throw new IllegalArgumentException(&quot;invalid handle tag &quot; + bootstrapMethodHandle.getTag());
 815         }
 816         for (Object bootstrapMethodArgument : bootstrapMethodArguments) {
 817             checkLdcConstant(bootstrapMethodArgument);
 818         }
</pre>
<hr />
<pre>
 862         ++insnCount;
 863     }
 864 
 865     @Override
 866     public void visitTableSwitchInsn(
 867             final int min, final int max, final Label dflt, final Label... labels) {
 868         checkVisitCodeCalled();
 869         checkVisitMaxsNotCalled();
 870         if (max &lt; min) {
 871             throw new IllegalArgumentException(
 872                     &quot;Max = &quot; + max + &quot; must be greater than or equal to min = &quot; + min);
 873         }
 874         checkLabel(dflt, false, &quot;default label&quot;);
 875         if (labels == null || labels.length != max - min + 1) {
 876             throw new IllegalArgumentException(&quot;There must be max - min + 1 labels&quot;);
 877         }
 878         for (int i = 0; i &lt; labels.length; ++i) {
 879             checkLabel(labels[i], false, &quot;label at index &quot; + i);
 880         }
 881         super.visitTableSwitchInsn(min, max, dflt, labels);
<span class="line-modified"> 882         for (Label label : labels) {</span>
<span class="line-removed"> 883             referencedLabels.add(label);</span>
<span class="line-removed"> 884         }</span>
 885         ++insnCount;
 886     }
 887 
 888     @Override
 889     public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
 890         checkVisitMaxsNotCalled();
 891         checkVisitCodeCalled();
 892         checkLabel(dflt, false, &quot;default label&quot;);
 893         if (keys == null || labels == null || keys.length != labels.length) {
 894             throw new IllegalArgumentException(&quot;There must be the same number of keys and labels&quot;);
 895         }
 896         for (int i = 0; i &lt; labels.length; ++i) {
 897             checkLabel(labels[i], false, &quot;label at index &quot; + i);
 898         }
 899         super.visitLookupSwitchInsn(dflt, keys, labels);
 900         referencedLabels.add(dflt);
<span class="line-modified"> 901         for (Label label : labels) {</span>
<span class="line-removed"> 902             referencedLabels.add(label);</span>
<span class="line-removed"> 903         }</span>
 904         ++insnCount;
 905     }
 906 
 907     @Override
 908     public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
 909         checkVisitCodeCalled();
 910         checkVisitMaxsNotCalled();
 911         checkDescriptor(version, descriptor, false);
 912         if (descriptor.charAt(0) != &#39;[&#39;) {
 913             throw new IllegalArgumentException(
 914                     &quot;Invalid descriptor (must be an array type descriptor): &quot; + descriptor);
 915         }
 916         if (numDimensions &lt; 1) {
 917             throw new IllegalArgumentException(
 918                     &quot;Invalid dimensions (must be greater than 0): &quot; + numDimensions);
 919         }
 920         if (numDimensions &gt; descriptor.lastIndexOf(&#39;[&#39;) + 1) {
 921             throw new IllegalArgumentException(
 922                     &quot;Invalid dimensions (must not be greater than numDimensions(descriptor)): &quot;
 923                             + numDimensions);
</pre>
<hr />
<pre>
 980             throw new IllegalArgumentException(INVALID_TYPE_REFERENCE + Integer.toHexString(sort));
 981         }
 982         CheckClassAdapter.checkTypeRef(typeRef);
 983         CheckMethodAdapter.checkDescriptor(version, descriptor, false);
 984         return new CheckAnnotationAdapter(
 985                 super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible));
 986     }
 987 
 988     @Override
 989     public void visitLocalVariable(
 990             final String name,
 991             final String descriptor,
 992             final String signature,
 993             final Label start,
 994             final Label end,
 995             final int index) {
 996         checkVisitCodeCalled();
 997         checkVisitMaxsNotCalled();
 998         checkUnqualifiedName(version, name, &quot;name&quot;);
 999         checkDescriptor(version, descriptor, false);



1000         checkLabel(start, true, START_LABEL);
1001         checkLabel(end, true, END_LABEL);
1002         checkUnsignedShort(index, INVALID_LOCAL_VARIABLE_INDEX);
1003         int startInsnIndex = labelInsnIndices.get(start).intValue();
1004         int endInsnIndex = labelInsnIndices.get(end).intValue();
1005         if (endInsnIndex &lt; startInsnIndex) {
1006             throw new IllegalArgumentException(
1007                     &quot;Invalid start and end labels (end must be greater than start)&quot;);
1008         }
1009         super.visitLocalVariable(name, descriptor, signature, start, end, index);
1010     }
1011 
1012     @Override
1013     public AnnotationVisitor visitLocalVariableAnnotation(
1014             final int typeRef,
1015             final TypePath typePath,
1016             final Label[] start,
1017             final Label[] end,
1018             final int[] index,
1019             final String descriptor,
</pre>
<hr />
<pre>
1113     private void checkVisitEndNotCalled() {
1114         if (visitEndCalled) {
1115             throw new IllegalStateException(&quot;Cannot visit elements after visitEnd has been called.&quot;);
1116         }
1117     }
1118 
1119     /**
1120       * Checks a stack frame value.
1121       *
1122       * @param value the value to be checked.
1123       */
1124     private void checkFrameValue(final Object value) {
1125         if (value == Opcodes.TOP
1126                 || value == Opcodes.INTEGER
1127                 || value == Opcodes.FLOAT
1128                 || value == Opcodes.LONG
1129                 || value == Opcodes.DOUBLE
1130                 || value == Opcodes.NULL
1131                 || value == Opcodes.UNINITIALIZED_THIS) {
1132             return;
<span class="line-modified">1133         } else if (value instanceof String) {</span>

1134             checkInternalName(version, (String) value, &quot;Invalid stack frame value&quot;);
1135         } else if (value instanceof Label) {
1136             referencedLabels.add((Label) value);
1137         } else {
1138             throw new IllegalArgumentException(&quot;Invalid stack frame value: &quot; + value);
1139         }
1140     }
1141 
1142     /**
1143       * Checks that the method to visit the given opcode is equal to the given method.
1144       *
1145       * @param opcode the opcode to be checked.
1146       * @param method the expected visit method.
1147       */
1148     private static void checkOpcodeMethod(final int opcode, final Method method) {
1149         if (opcode &lt; Opcodes.NOP || opcode &gt; Opcodes.IFNONNULL || OPCODE_METHODS[opcode] != method) {
1150             throw new IllegalArgumentException(&quot;Invalid opcode: &quot; + opcode);
1151         }
1152     }
1153 
</pre>
<hr />
<pre>
1297             return;
1298         }
1299         for (int i = startPos; i &lt; max; i = name.offsetByCodePoints(i, 1)) {
1300             if (i == startPos
1301                     ? !Character.isJavaIdentifierStart(name.codePointAt(i))
1302                     : !Character.isJavaIdentifierPart(name.codePointAt(i))) {
1303                 throw new IllegalArgumentException(
1304                         INVALID + message + &quot; (must be a valid Java identifier): &quot; + name);
1305             }
1306         }
1307     }
1308 
1309     /**
1310       * Checks that the given string is a valid Java identifier.
1311       *
1312       * @param version the class version.
1313       * @param name the string to be checked.
1314       * @param message the message to use in case of error.
1315       */
1316     static void checkMethodIdentifier(final int version, final String name, final String message) {
<span class="line-modified">1317         if (name == null || name.isEmpty()) {</span>
1318             throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
1319         }
1320         if ((version &amp; 0xFFFF) &gt;= Opcodes.V1_5) {
1321             for (int i = 0; i &lt; name.length(); i = name.offsetByCodePoints(i, 1)) {
1322                 if (&quot;.;[/&lt;&gt;&quot;.indexOf(name.codePointAt(i)) != -1) {
1323                     throw new IllegalArgumentException(
1324                             INVALID + message + &quot; (must be a valid unqualified name): &quot; + name);
1325                 }
1326             }
1327             return;
1328         }
1329         for (int i = 0; i &lt; name.length(); i = name.offsetByCodePoints(i, 1)) {
1330             if (i == 0
1331                     ? !Character.isJavaIdentifierStart(name.codePointAt(i))
1332                     : !Character.isJavaIdentifierPart(name.codePointAt(i))) {
1333                 throw new IllegalArgumentException(
1334                         INVALID
1335                                 + message
1336                                 + &quot; (must be a &#39;&lt;init&gt;&#39;, &#39;&lt;clinit&gt;&#39; or a valid Java identifier): &quot;
1337                                 + name);
1338             }
1339         }
1340     }
1341 
1342     /**
1343       * Checks that the given string is a valid internal class name or array type descriptor.
1344       *
1345       * @param version the class version.
1346       * @param name the string to be checked.
1347       * @param message the message to use in case of error.
1348       */
1349     static void checkInternalName(final int version, final String name, final String message) {
<span class="line-modified">1350         if (name == null || name.isEmpty()) {</span>
1351             throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
1352         }
1353         if (name.charAt(0) == &#39;[&#39;) {
1354             checkDescriptor(version, name, false);
1355         } else {
1356             checkInternalClassName(version, name, message);
1357         }
1358     }
1359 
1360     /**
1361       * Checks that the given string is a valid internal class name.
1362       *
1363       * @param version the class version.
1364       * @param name the string to be checked.
1365       * @param message the message to use in case of error.
1366       */
1367     private static void checkInternalClassName(
1368             final int version, final String name, final String message) {
1369         try {
1370             int startIndex = 0;
1371             int slashIndex;
1372             while ((slashIndex = name.indexOf(&#39;/&#39;, startIndex + 1)) != -1) {
<span class="line-modified">1373                 CheckMethodAdapter.checkIdentifier(version, name, startIndex, slashIndex, null);</span>
1374                 startIndex = slashIndex + 1;
1375             }
<span class="line-modified">1376             CheckMethodAdapter.checkIdentifier(version, name, startIndex, name.length(), null);</span>
1377         } catch (IllegalArgumentException e) {
1378             throw new IllegalArgumentException(
1379                     INVALID + message + &quot; (must be an internal class name): &quot; + name, e);
1380         }
1381     }
1382 
1383     /**
1384       * Checks that the given string is a valid type descriptor.
1385       *
1386       * @param version the class version.
1387       * @param descriptor the string to be checked.
1388       * @param canBeVoid {@literal true} if {@code V} can be considered valid.
1389       */
1390     static void checkDescriptor(final int version, final String descriptor, final boolean canBeVoid) {
1391         int endPos = checkDescriptor(version, descriptor, 0, canBeVoid);
1392         if (endPos != descriptor.length()) {
1393             throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1394         }
1395     }
1396 
</pre>
<hr />
<pre>
1441                     throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1442                 }
1443                 try {
1444                     checkInternalClassName(version, descriptor.substring(startPos + 1, endPos), null);
1445                 } catch (IllegalArgumentException e) {
1446                     throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor, e);
1447                 }
1448                 return endPos + 1;
1449             default:
1450                 throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1451         }
1452     }
1453 
1454     /**
1455       * Checks that the given string is a valid method descriptor.
1456       *
1457       * @param version the class version.
1458       * @param descriptor the string to be checked.
1459       */
1460     static void checkMethodDescriptor(final int version, final String descriptor) {
<span class="line-modified">1461         if (descriptor == null || descriptor.isEmpty()) {</span>
1462             throw new IllegalArgumentException(&quot;Invalid method descriptor (must not be null or empty)&quot;);
1463         }
1464         if (descriptor.charAt(0) != &#39;(&#39; || descriptor.length() &lt; 3) {
1465             throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1466         }
1467         int pos = 1;
1468         if (descriptor.charAt(pos) != &#39;)&#39;) {
1469             do {
1470                 if (descriptor.charAt(pos) == &#39;V&#39;) {
1471                     throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1472                 }
1473                 pos = checkDescriptor(version, descriptor, pos, false);
1474             } while (pos &lt; descriptor.length() &amp;&amp; descriptor.charAt(pos) != &#39;)&#39;);
1475         }
1476         pos = checkDescriptor(version, descriptor, pos + 1, true);
1477         if (pos != descriptor.length()) {
1478             throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1479         }
1480     }
1481 
</pre>
</td>
<td>
<hr />
<pre>
  44  *    contributors may be used to endorse or promote products derived from
  45  *    this software without specific prior written permission.
  46  *
  47  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
  48  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  49  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  50  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  51  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  52  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  53  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  54  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  55  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  56  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  57  * THE POSSIBILITY OF SUCH DAMAGE.
  58  */
  59 package jdk.internal.org.objectweb.asm.util;
  60 
  61 import java.io.PrintWriter;
  62 import java.io.StringWriter;
  63 import java.util.ArrayList;
<span class="line-added">  64 import java.util.Collections;</span>
  65 import java.util.HashMap;
  66 import java.util.HashSet;
  67 import java.util.List;
  68 import java.util.Map;
  69 import java.util.Set;
  70 import jdk.internal.org.objectweb.asm.AnnotationVisitor;
  71 import jdk.internal.org.objectweb.asm.Attribute;
  72 import jdk.internal.org.objectweb.asm.ConstantDynamic;
  73 import jdk.internal.org.objectweb.asm.Handle;
  74 import jdk.internal.org.objectweb.asm.Label;
  75 import jdk.internal.org.objectweb.asm.MethodVisitor;
  76 import jdk.internal.org.objectweb.asm.Opcodes;
  77 import jdk.internal.org.objectweb.asm.Type;
  78 import jdk.internal.org.objectweb.asm.TypePath;
  79 import jdk.internal.org.objectweb.asm.TypeReference;
  80 import jdk.internal.org.objectweb.asm.tree.MethodNode;
  81 import jdk.internal.org.objectweb.asm.tree.analysis.Analyzer;
  82 import jdk.internal.org.objectweb.asm.tree.analysis.AnalyzerException;
  83 import jdk.internal.org.objectweb.asm.tree.analysis.BasicValue;
  84 import jdk.internal.org.objectweb.asm.tree.analysis.BasicVerifier;
</pre>
<hr />
<pre>
 381       *
 382       * @param methodvisitor the method visitor to which this adapter must delegate calls.
 383       */
 384     public CheckMethodAdapter(final MethodVisitor methodvisitor) {
 385         this(methodvisitor, new HashMap&lt;Label, Integer&gt;());
 386     }
 387 
 388     /**
 389       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will not perform any
 390       * data flow check (see {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
 391       * &lt;i&gt;Subclasses must not use this constructor&lt;/i&gt;. Instead, they must use the {@link
 392       * #CheckMethodAdapter(int, MethodVisitor, Map)} version.
 393       *
 394       * @param methodVisitor the method visitor to which this adapter must delegate calls.
 395       * @param labelInsnIndices the index of the instruction designated by each visited label so far
 396       *     (in other methods). This map is updated with the labels from the visited method.
 397       * @throws IllegalStateException If a subclass calls this constructor.
 398       */
 399     public CheckMethodAdapter(
 400             final MethodVisitor methodVisitor, final Map&lt;Label, Integer&gt; labelInsnIndices) {
<span class="line-modified"> 401         this(/* latest api = */ Opcodes.ASM8, methodVisitor, labelInsnIndices);</span>
 402         if (getClass() != CheckMethodAdapter.class) {
 403             throw new IllegalStateException();
 404         }
 405     }
 406 
 407     /**
 408       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will not perform any
 409       * data flow check (see {@link #CheckMethodAdapter(int,String,String,MethodVisitor,Map)}).
 410       *
 411       * @param api the ASM API version implemented by this CheckMethodAdapter. Must be one of {@link
<span class="line-modified"> 412       *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link</span>
<span class="line-added"> 413       *     Opcodes#ASM8}.</span>
 414       * @param methodVisitor the method visitor to which this adapter must delegate calls.
 415       * @param labelInsnIndices the index of the instruction designated by each visited label so far
 416       *     (in other methods). This map is updated with the labels from the visited method.
 417       */
 418     protected CheckMethodAdapter(
 419             final int api,
 420             final MethodVisitor methodVisitor,
 421             final Map&lt;Label, Integer&gt; labelInsnIndices) {
 422         super(api, methodVisitor);
 423         this.labelInsnIndices = labelInsnIndices;
<span class="line-modified"> 424         this.referencedLabels = new HashSet&lt;&gt;();</span>
<span class="line-modified"> 425         this.handlers = new ArrayList&lt;&gt;();</span>
 426     }
 427 
 428     /**
 429       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will perform basic data
 430       * flow checks. For instance in a method whose signature is {@code void m ()}, the invalid
 431       * instruction IRETURN, or the invalid sequence IADD L2I will be detected. &lt;i&gt;Subclasses must not
 432       * use this constructor&lt;/i&gt;. Instead, they must use the {@link
 433       * #CheckMethodAdapter(int,int,String,String,MethodVisitor,Map)} version.
 434       *
 435       * @param access the method&#39;s access flags.
 436       * @param name the method&#39;s name.
 437       * @param descriptor the method&#39;s descriptor (see {@link Type}).
 438       * @param methodVisitor the method visitor to which this adapter must delegate calls.
 439       * @param labelInsnIndices the index of the instruction designated by each visited label so far
 440       *     (in other methods). This map is updated with the labels from the visited method.
 441       */
 442     public CheckMethodAdapter(
 443             final int access,
 444             final String name,
 445             final String descriptor,
 446             final MethodVisitor methodVisitor,
 447             final Map&lt;Label, Integer&gt; labelInsnIndices) {
<span class="line-modified"> 448         this(</span>
<span class="line-added"> 449                 /* latest api = */ Opcodes.ASM8, access, name, descriptor, methodVisitor, labelInsnIndices);</span>
 450         if (getClass() != CheckMethodAdapter.class) {
 451             throw new IllegalStateException();
 452         }
 453     }
 454 
 455     /**
 456       * Constructs a new {@link CheckMethodAdapter} object. This method adapter will perform basic data
 457       * flow checks. For instance in a method whose signature is {@code void m ()}, the invalid
 458       * instruction IRETURN, or the invalid sequence IADD L2I will be detected.
 459       *
 460       * @param api the ASM API version implemented by this CheckMethodAdapter. Must be one of {@link
<span class="line-modified"> 461       *     Opcodes#ASM4}, {@link Opcodes#ASM5}, {@link Opcodes#ASM6}, {@link Opcodes#ASM7} or {@link</span>
<span class="line-added"> 462       *     Opcodes#ASM8}.</span>
 463       * @param access the method&#39;s access flags.
 464       * @param name the method&#39;s name.
 465       * @param descriptor the method&#39;s descriptor (see {@link Type}).
 466       * @param methodVisitor the method visitor to which this adapter must delegate calls.
 467       * @param labelInsnIndices the index of the instruction designated by each visited label so far
 468       *     (in other methods). This map is updated with the labels from the visited method.
 469       */
 470     protected CheckMethodAdapter(
 471             final int api,
 472             final int access,
 473             final String name,
 474             final String descriptor,
 475             final MethodVisitor methodVisitor,
 476             final Map&lt;Label, Integer&gt; labelInsnIndices) {
 477         this(
 478                 api,
 479                 new MethodNode(api, access, name, descriptor, null, null) {
 480                     @Override
 481                     public void visitEnd() {
<span class="line-modified"> 482                         Analyzer&lt;BasicValue&gt; analyzer = new Analyzer&lt;&gt;(new BasicVerifier());</span>
 483                         try {
 484                             analyzer.analyze(&quot;dummy&quot;, this);
 485                         } catch (IndexOutOfBoundsException e) {
 486                             if (maxLocals == 0 &amp;&amp; maxStack == 0) {
 487                                 throw new IllegalArgumentException(
 488                                         &quot;Data flow checking option requires valid, non zero maxLocals and maxStack.&quot;,
 489                                         e);
 490                             }
 491                             throwError(analyzer, e);
 492                         } catch (AnalyzerException e) {
 493                             throwError(analyzer, e);
 494                         }
<span class="line-modified"> 495                         if (methodVisitor != null) {</span>
<span class="line-added"> 496                             accept(methodVisitor);</span>
<span class="line-added"> 497                         }</span>
 498                     }
 499 
 500                     private void throwError(final Analyzer&lt;BasicValue&gt; analyzer, final Exception e) {
 501                         StringWriter stringWriter = new StringWriter();
 502                         PrintWriter printWriter = new PrintWriter(stringWriter, true);
 503                         CheckClassAdapter.printAnalyzerResult(this, analyzer, printWriter);
 504                         printWriter.close();
 505                         throw new IllegalArgumentException(e.getMessage() + &#39; &#39; + stringWriter.toString(), e);
 506                     }
 507                 },
 508                 labelInsnIndices);
 509         this.access = access;
 510     }
 511 
 512     @Override
 513     public void visitParameter(final String name, final int access) {
 514         if (name != null) {
 515             checkUnqualifiedName(version, name, &quot;name&quot;);
 516         }
 517         CheckClassAdapter.checkAccess(
</pre>
<hr />
<pre>
 724         if (opcode == Opcodes.NEW &amp;&amp; type.charAt(0) == &#39;[&#39;) {
 725             throw new IllegalArgumentException(&quot;NEW cannot be used to create arrays: &quot; + type);
 726         }
 727         super.visitTypeInsn(opcode, type);
 728         ++insnCount;
 729     }
 730 
 731     @Override
 732     public void visitFieldInsn(
 733             final int opcode, final String owner, final String name, final String descriptor) {
 734         checkVisitCodeCalled();
 735         checkVisitMaxsNotCalled();
 736         checkOpcodeMethod(opcode, Method.VISIT_FIELD_INSN);
 737         checkInternalName(version, owner, &quot;owner&quot;);
 738         checkUnqualifiedName(version, name, &quot;name&quot;);
 739         checkDescriptor(version, descriptor, false);
 740         super.visitFieldInsn(opcode, owner, name, descriptor);
 741         ++insnCount;
 742     }
 743 
















 744     @Override
 745     public void visitMethodInsn(
<span class="line-modified"> 746             final int opcodeAndSource,</span>
 747             final String owner,
 748             final String name,
 749             final String descriptor,
 750             final boolean isInterface) {
<span class="line-modified"> 751         if (api &lt; Opcodes.ASM5 &amp;&amp; (opcodeAndSource &amp; Opcodes.SOURCE_DEPRECATED) == 0) {</span>
<span class="line-modified"> 752             // Redirect the call to the deprecated version of this method.</span>
<span class="line-added"> 753             super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);</span>
 754             return;
 755         }
<span class="line-modified"> 756         int opcode = opcodeAndSource &amp; ~Opcodes.SOURCE_MASK;</span>

 757 






 758         checkVisitCodeCalled();
 759         checkVisitMaxsNotCalled();
 760         checkOpcodeMethod(opcode, Method.VISIT_METHOD_INSN);
 761         if (opcode != Opcodes.INVOKESPECIAL || !&quot;&lt;init&gt;&quot;.equals(name)) {
 762             checkMethodIdentifier(version, name, &quot;name&quot;);
 763         }
 764         checkInternalName(version, owner, &quot;owner&quot;);
 765         checkMethodDescriptor(version, descriptor);
 766         if (opcode == Opcodes.INVOKEVIRTUAL &amp;&amp; isInterface) {
 767             throw new IllegalArgumentException(&quot;INVOKEVIRTUAL can&#39;t be used with interfaces&quot;);
 768         }
 769         if (opcode == Opcodes.INVOKEINTERFACE &amp;&amp; !isInterface) {
 770             throw new IllegalArgumentException(&quot;INVOKEINTERFACE can&#39;t be used with classes&quot;);
 771         }
 772         if (opcode == Opcodes.INVOKESPECIAL &amp;&amp; isInterface &amp;&amp; (version &amp; 0xFFFF) &lt; Opcodes.V1_8) {
 773             throw new IllegalArgumentException(
 774                     &quot;INVOKESPECIAL can&#39;t be used with interfaces prior to Java 8&quot;);
 775         }
<span class="line-modified"> 776         super.visitMethodInsn(opcodeAndSource, owner, name, descriptor, isInterface);</span>






 777         ++insnCount;
 778     }
 779 
 780     @Override
 781     public void visitInvokeDynamicInsn(
 782             final String name,
 783             final String descriptor,
 784             final Handle bootstrapMethodHandle,
 785             final Object... bootstrapMethodArguments) {
 786         checkVisitCodeCalled();
 787         checkVisitMaxsNotCalled();
 788         checkMethodIdentifier(version, name, &quot;name&quot;);
 789         checkMethodDescriptor(version, descriptor);
 790         if (bootstrapMethodHandle.getTag() != Opcodes.H_INVOKESTATIC
 791                 &amp;&amp; bootstrapMethodHandle.getTag() != Opcodes.H_NEWINVOKESPECIAL) {
 792             throw new IllegalArgumentException(&quot;invalid handle tag &quot; + bootstrapMethodHandle.getTag());
 793         }
 794         for (Object bootstrapMethodArgument : bootstrapMethodArguments) {
 795             checkLdcConstant(bootstrapMethodArgument);
 796         }
</pre>
<hr />
<pre>
 840         ++insnCount;
 841     }
 842 
 843     @Override
 844     public void visitTableSwitchInsn(
 845             final int min, final int max, final Label dflt, final Label... labels) {
 846         checkVisitCodeCalled();
 847         checkVisitMaxsNotCalled();
 848         if (max &lt; min) {
 849             throw new IllegalArgumentException(
 850                     &quot;Max = &quot; + max + &quot; must be greater than or equal to min = &quot; + min);
 851         }
 852         checkLabel(dflt, false, &quot;default label&quot;);
 853         if (labels == null || labels.length != max - min + 1) {
 854             throw new IllegalArgumentException(&quot;There must be max - min + 1 labels&quot;);
 855         }
 856         for (int i = 0; i &lt; labels.length; ++i) {
 857             checkLabel(labels[i], false, &quot;label at index &quot; + i);
 858         }
 859         super.visitTableSwitchInsn(min, max, dflt, labels);
<span class="line-modified"> 860         Collections.addAll(referencedLabels, labels);</span>


 861         ++insnCount;
 862     }
 863 
 864     @Override
 865     public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {
 866         checkVisitMaxsNotCalled();
 867         checkVisitCodeCalled();
 868         checkLabel(dflt, false, &quot;default label&quot;);
 869         if (keys == null || labels == null || keys.length != labels.length) {
 870             throw new IllegalArgumentException(&quot;There must be the same number of keys and labels&quot;);
 871         }
 872         for (int i = 0; i &lt; labels.length; ++i) {
 873             checkLabel(labels[i], false, &quot;label at index &quot; + i);
 874         }
 875         super.visitLookupSwitchInsn(dflt, keys, labels);
 876         referencedLabels.add(dflt);
<span class="line-modified"> 877         Collections.addAll(referencedLabels, labels);</span>


 878         ++insnCount;
 879     }
 880 
 881     @Override
 882     public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {
 883         checkVisitCodeCalled();
 884         checkVisitMaxsNotCalled();
 885         checkDescriptor(version, descriptor, false);
 886         if (descriptor.charAt(0) != &#39;[&#39;) {
 887             throw new IllegalArgumentException(
 888                     &quot;Invalid descriptor (must be an array type descriptor): &quot; + descriptor);
 889         }
 890         if (numDimensions &lt; 1) {
 891             throw new IllegalArgumentException(
 892                     &quot;Invalid dimensions (must be greater than 0): &quot; + numDimensions);
 893         }
 894         if (numDimensions &gt; descriptor.lastIndexOf(&#39;[&#39;) + 1) {
 895             throw new IllegalArgumentException(
 896                     &quot;Invalid dimensions (must not be greater than numDimensions(descriptor)): &quot;
 897                             + numDimensions);
</pre>
<hr />
<pre>
 954             throw new IllegalArgumentException(INVALID_TYPE_REFERENCE + Integer.toHexString(sort));
 955         }
 956         CheckClassAdapter.checkTypeRef(typeRef);
 957         CheckMethodAdapter.checkDescriptor(version, descriptor, false);
 958         return new CheckAnnotationAdapter(
 959                 super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible));
 960     }
 961 
 962     @Override
 963     public void visitLocalVariable(
 964             final String name,
 965             final String descriptor,
 966             final String signature,
 967             final Label start,
 968             final Label end,
 969             final int index) {
 970         checkVisitCodeCalled();
 971         checkVisitMaxsNotCalled();
 972         checkUnqualifiedName(version, name, &quot;name&quot;);
 973         checkDescriptor(version, descriptor, false);
<span class="line-added"> 974         if (signature != null) {</span>
<span class="line-added"> 975             CheckClassAdapter.checkFieldSignature(signature);</span>
<span class="line-added"> 976         }</span>
 977         checkLabel(start, true, START_LABEL);
 978         checkLabel(end, true, END_LABEL);
 979         checkUnsignedShort(index, INVALID_LOCAL_VARIABLE_INDEX);
 980         int startInsnIndex = labelInsnIndices.get(start).intValue();
 981         int endInsnIndex = labelInsnIndices.get(end).intValue();
 982         if (endInsnIndex &lt; startInsnIndex) {
 983             throw new IllegalArgumentException(
 984                     &quot;Invalid start and end labels (end must be greater than start)&quot;);
 985         }
 986         super.visitLocalVariable(name, descriptor, signature, start, end, index);
 987     }
 988 
 989     @Override
 990     public AnnotationVisitor visitLocalVariableAnnotation(
 991             final int typeRef,
 992             final TypePath typePath,
 993             final Label[] start,
 994             final Label[] end,
 995             final int[] index,
 996             final String descriptor,
</pre>
<hr />
<pre>
1090     private void checkVisitEndNotCalled() {
1091         if (visitEndCalled) {
1092             throw new IllegalStateException(&quot;Cannot visit elements after visitEnd has been called.&quot;);
1093         }
1094     }
1095 
1096     /**
1097       * Checks a stack frame value.
1098       *
1099       * @param value the value to be checked.
1100       */
1101     private void checkFrameValue(final Object value) {
1102         if (value == Opcodes.TOP
1103                 || value == Opcodes.INTEGER
1104                 || value == Opcodes.FLOAT
1105                 || value == Opcodes.LONG
1106                 || value == Opcodes.DOUBLE
1107                 || value == Opcodes.NULL
1108                 || value == Opcodes.UNINITIALIZED_THIS) {
1109             return;
<span class="line-modified">1110         }</span>
<span class="line-added">1111         if (value instanceof String) {</span>
1112             checkInternalName(version, (String) value, &quot;Invalid stack frame value&quot;);
1113         } else if (value instanceof Label) {
1114             referencedLabels.add((Label) value);
1115         } else {
1116             throw new IllegalArgumentException(&quot;Invalid stack frame value: &quot; + value);
1117         }
1118     }
1119 
1120     /**
1121       * Checks that the method to visit the given opcode is equal to the given method.
1122       *
1123       * @param opcode the opcode to be checked.
1124       * @param method the expected visit method.
1125       */
1126     private static void checkOpcodeMethod(final int opcode, final Method method) {
1127         if (opcode &lt; Opcodes.NOP || opcode &gt; Opcodes.IFNONNULL || OPCODE_METHODS[opcode] != method) {
1128             throw new IllegalArgumentException(&quot;Invalid opcode: &quot; + opcode);
1129         }
1130     }
1131 
</pre>
<hr />
<pre>
1275             return;
1276         }
1277         for (int i = startPos; i &lt; max; i = name.offsetByCodePoints(i, 1)) {
1278             if (i == startPos
1279                     ? !Character.isJavaIdentifierStart(name.codePointAt(i))
1280                     : !Character.isJavaIdentifierPart(name.codePointAt(i))) {
1281                 throw new IllegalArgumentException(
1282                         INVALID + message + &quot; (must be a valid Java identifier): &quot; + name);
1283             }
1284         }
1285     }
1286 
1287     /**
1288       * Checks that the given string is a valid Java identifier.
1289       *
1290       * @param version the class version.
1291       * @param name the string to be checked.
1292       * @param message the message to use in case of error.
1293       */
1294     static void checkMethodIdentifier(final int version, final String name, final String message) {
<span class="line-modified">1295         if (name == null || name.length() == 0) {</span>
1296             throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
1297         }
1298         if ((version &amp; 0xFFFF) &gt;= Opcodes.V1_5) {
1299             for (int i = 0; i &lt; name.length(); i = name.offsetByCodePoints(i, 1)) {
1300                 if (&quot;.;[/&lt;&gt;&quot;.indexOf(name.codePointAt(i)) != -1) {
1301                     throw new IllegalArgumentException(
1302                             INVALID + message + &quot; (must be a valid unqualified name): &quot; + name);
1303                 }
1304             }
1305             return;
1306         }
1307         for (int i = 0; i &lt; name.length(); i = name.offsetByCodePoints(i, 1)) {
1308             if (i == 0
1309                     ? !Character.isJavaIdentifierStart(name.codePointAt(i))
1310                     : !Character.isJavaIdentifierPart(name.codePointAt(i))) {
1311                 throw new IllegalArgumentException(
1312                         INVALID
1313                                 + message
1314                                 + &quot; (must be a &#39;&lt;init&gt;&#39;, &#39;&lt;clinit&gt;&#39; or a valid Java identifier): &quot;
1315                                 + name);
1316             }
1317         }
1318     }
1319 
1320     /**
1321       * Checks that the given string is a valid internal class name or array type descriptor.
1322       *
1323       * @param version the class version.
1324       * @param name the string to be checked.
1325       * @param message the message to use in case of error.
1326       */
1327     static void checkInternalName(final int version, final String name, final String message) {
<span class="line-modified">1328         if (name == null || name.length() == 0) {</span>
1329             throw new IllegalArgumentException(INVALID + message + MUST_NOT_BE_NULL_OR_EMPTY);
1330         }
1331         if (name.charAt(0) == &#39;[&#39;) {
1332             checkDescriptor(version, name, false);
1333         } else {
1334             checkInternalClassName(version, name, message);
1335         }
1336     }
1337 
1338     /**
1339       * Checks that the given string is a valid internal class name.
1340       *
1341       * @param version the class version.
1342       * @param name the string to be checked.
1343       * @param message the message to use in case of error.
1344       */
1345     private static void checkInternalClassName(
1346             final int version, final String name, final String message) {
1347         try {
1348             int startIndex = 0;
1349             int slashIndex;
1350             while ((slashIndex = name.indexOf(&#39;/&#39;, startIndex + 1)) != -1) {
<span class="line-modified">1351                 checkIdentifier(version, name, startIndex, slashIndex, null);</span>
1352                 startIndex = slashIndex + 1;
1353             }
<span class="line-modified">1354             checkIdentifier(version, name, startIndex, name.length(), null);</span>
1355         } catch (IllegalArgumentException e) {
1356             throw new IllegalArgumentException(
1357                     INVALID + message + &quot; (must be an internal class name): &quot; + name, e);
1358         }
1359     }
1360 
1361     /**
1362       * Checks that the given string is a valid type descriptor.
1363       *
1364       * @param version the class version.
1365       * @param descriptor the string to be checked.
1366       * @param canBeVoid {@literal true} if {@code V} can be considered valid.
1367       */
1368     static void checkDescriptor(final int version, final String descriptor, final boolean canBeVoid) {
1369         int endPos = checkDescriptor(version, descriptor, 0, canBeVoid);
1370         if (endPos != descriptor.length()) {
1371             throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1372         }
1373     }
1374 
</pre>
<hr />
<pre>
1419                     throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1420                 }
1421                 try {
1422                     checkInternalClassName(version, descriptor.substring(startPos + 1, endPos), null);
1423                 } catch (IllegalArgumentException e) {
1424                     throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor, e);
1425                 }
1426                 return endPos + 1;
1427             default:
1428                 throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1429         }
1430     }
1431 
1432     /**
1433       * Checks that the given string is a valid method descriptor.
1434       *
1435       * @param version the class version.
1436       * @param descriptor the string to be checked.
1437       */
1438     static void checkMethodDescriptor(final int version, final String descriptor) {
<span class="line-modified">1439         if (descriptor == null || descriptor.length() == 0) {</span>
1440             throw new IllegalArgumentException(&quot;Invalid method descriptor (must not be null or empty)&quot;);
1441         }
1442         if (descriptor.charAt(0) != &#39;(&#39; || descriptor.length() &lt; 3) {
1443             throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1444         }
1445         int pos = 1;
1446         if (descriptor.charAt(pos) != &#39;)&#39;) {
1447             do {
1448                 if (descriptor.charAt(pos) == &#39;V&#39;) {
1449                     throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1450                 }
1451                 pos = checkDescriptor(version, descriptor, pos, false);
1452             } while (pos &lt; descriptor.length() &amp;&amp; descriptor.charAt(pos) != &#39;)&#39;);
1453         }
1454         pos = checkDescriptor(version, descriptor, pos + 1, true);
1455         if (pos != descriptor.length()) {
1456             throw new IllegalArgumentException(INVALID_DESCRIPTOR + descriptor);
1457         }
1458     }
1459 
</pre>
</td>
</tr>
</table>
<center><a href="CheckClassAdapter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../reflect/UnsafeFieldAccessorFactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/reflect/Field.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibleObject.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/org/objectweb/asm/ClassReader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/reflect/Field.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 711      * Sets the field represented by this {@code Field} object on the
 712      * specified object argument to the specified new value. The new
 713      * value is automatically unwrapped if the underlying field has a
 714      * primitive type.
 715      *
 716      * &lt;p&gt;The operation proceeds as follows:
 717      *
 718      * &lt;p&gt;If the underlying field is static, the {@code obj} argument is
 719      * ignored; it may be null.
 720      *
 721      * &lt;p&gt;Otherwise the underlying field is an instance field.  If the
 722      * specified object argument is null, the method throws a
 723      * {@code NullPointerException}.  If the specified object argument is not
 724      * an instance of the class or interface declaring the underlying
 725      * field, the method throws an {@code IllegalArgumentException}.
 726      *
 727      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 728      * the underlying field is inaccessible, the method throws an
 729      * {@code IllegalAccessException}.
 730      *
<span class="line-modified"> 731      * &lt;p&gt;If the underlying field is final, the method throws an</span>
<span class="line-modified"> 732      * {@code IllegalAccessException} unless {@code setAccessible(true)}</span>
<span class="line-modified"> 733      * has succeeded for this {@code Field} object</span>
<span class="line-modified"> 734      * and the field is non-static. Setting a final field in this way</span>









 735      * is meaningful only during deserialization or reconstruction of
 736      * instances of classes with blank final fields, before they are
 737      * made available for access by other parts of a program. Use in
 738      * any other context may have unpredictable effects, including cases
 739      * in which other parts of a program continue to use the original
 740      * value of this field.
 741      *
 742      * &lt;p&gt;If the underlying field is of a primitive type, an unwrapping
 743      * conversion is attempted to convert the new value to a value of
 744      * a primitive type.  If this attempt fails, the method throws an
 745      * {@code IllegalArgumentException}.
 746      *
 747      * &lt;p&gt;If, after possible unwrapping, the new value cannot be
 748      * converted to the type of the underlying field by an identity or
 749      * widening conversion, the method throws an
 750      * {@code IllegalArgumentException}.
 751      *
 752      * &lt;p&gt;If the underlying field is static, the class that declared the
 753      * field is initialized if it has not already been initialized.
 754      *
 755      * &lt;p&gt;The field is set to the possibly unwrapped and widened new value.
 756      *
 757      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 758      * the field&#39;s value is set according to the preceding rules.
 759      *
 760      * @param obj the object whose field should be modified
 761      * @param value the new value for the field of {@code obj}
 762      * being modified
 763      *
 764      * @throws    IllegalAccessException    if this {@code Field} object
 765      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 766      *              field is either inaccessible or final.</span>

 767      * @throws    IllegalArgumentException  if the specified object is not an
 768      *              instance of the class or interface declaring the underlying
 769      *              field (or a subclass or implementor thereof),
 770      *              or if an unwrapping conversion fails.
 771      * @throws    NullPointerException      if the specified object is null
 772      *              and the field is an instance field.
 773      * @throws    ExceptionInInitializerError if the initialization provoked
 774      *              by this method fails.
 775      */
 776     @CallerSensitive
 777     @ForceInline // to ensure Reflection.getCallerClass optimization
 778     public void set(Object obj, Object value)
 779         throws IllegalArgumentException, IllegalAccessException
 780     {
 781         if (!override) {
 782             Class&lt;?&gt; caller = Reflection.getCallerClass();
 783             checkAccess(caller, obj);
 784         }
 785         getFieldAccessor(obj).set(obj, value);
 786     }
 787 
 788     /**
 789      * Sets the value of a field as a {@code boolean} on the specified object.
 790      * This method is equivalent to
 791      * {@code set(obj, zObj)},
 792      * where {@code zObj} is a {@code Boolean} object and
 793      * {@code zObj.booleanValue() == z}.
 794      *
 795      * @param obj the object whose field should be modified
 796      * @param z   the new value for the field of {@code obj}
 797      * being modified
 798      *
 799      * @throws    IllegalAccessException    if this {@code Field} object
 800      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 801      *              field is either inaccessible or final.</span>

 802      * @throws    IllegalArgumentException  if the specified object is not an
 803      *              instance of the class or interface declaring the underlying
 804      *              field (or a subclass or implementor thereof),
 805      *              or if an unwrapping conversion fails.
 806      * @throws    NullPointerException      if the specified object is null
 807      *              and the field is an instance field.
 808      * @throws    ExceptionInInitializerError if the initialization provoked
 809      *              by this method fails.
 810      * @see       Field#set
 811      */
 812     @CallerSensitive
 813     @ForceInline // to ensure Reflection.getCallerClass optimization
 814     public void setBoolean(Object obj, boolean z)
 815         throws IllegalArgumentException, IllegalAccessException
 816     {
 817         if (!override) {
 818             Class&lt;?&gt; caller = Reflection.getCallerClass();
 819             checkAccess(caller, obj);
 820         }
 821         getFieldAccessor(obj).setBoolean(obj, z);
 822     }
 823 
 824     /**
 825      * Sets the value of a field as a {@code byte} on the specified object.
 826      * This method is equivalent to
 827      * {@code set(obj, bObj)},
 828      * where {@code bObj} is a {@code Byte} object and
 829      * {@code bObj.byteValue() == b}.
 830      *
 831      * @param obj the object whose field should be modified
 832      * @param b   the new value for the field of {@code obj}
 833      * being modified
 834      *
 835      * @throws    IllegalAccessException    if this {@code Field} object
 836      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 837      *              field is either inaccessible or final.</span>

 838      * @throws    IllegalArgumentException  if the specified object is not an
 839      *              instance of the class or interface declaring the underlying
 840      *              field (or a subclass or implementor thereof),
 841      *              or if an unwrapping conversion fails.
 842      * @throws    NullPointerException      if the specified object is null
 843      *              and the field is an instance field.
 844      * @throws    ExceptionInInitializerError if the initialization provoked
 845      *              by this method fails.
 846      * @see       Field#set
 847      */
 848     @CallerSensitive
 849     @ForceInline // to ensure Reflection.getCallerClass optimization
 850     public void setByte(Object obj, byte b)
 851         throws IllegalArgumentException, IllegalAccessException
 852     {
 853         if (!override) {
 854             Class&lt;?&gt; caller = Reflection.getCallerClass();
 855             checkAccess(caller, obj);
 856         }
 857         getFieldAccessor(obj).setByte(obj, b);
 858     }
 859 
 860     /**
 861      * Sets the value of a field as a {@code char} on the specified object.
 862      * This method is equivalent to
 863      * {@code set(obj, cObj)},
 864      * where {@code cObj} is a {@code Character} object and
 865      * {@code cObj.charValue() == c}.
 866      *
 867      * @param obj the object whose field should be modified
 868      * @param c   the new value for the field of {@code obj}
 869      * being modified
 870      *
 871      * @throws    IllegalAccessException    if this {@code Field} object
 872      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 873      *              field is either inaccessible or final.</span>

 874      * @throws    IllegalArgumentException  if the specified object is not an
 875      *              instance of the class or interface declaring the underlying
 876      *              field (or a subclass or implementor thereof),
 877      *              or if an unwrapping conversion fails.
 878      * @throws    NullPointerException      if the specified object is null
 879      *              and the field is an instance field.
 880      * @throws    ExceptionInInitializerError if the initialization provoked
 881      *              by this method fails.
 882      * @see       Field#set
 883      */
 884     @CallerSensitive
 885     @ForceInline // to ensure Reflection.getCallerClass optimization
 886     public void setChar(Object obj, char c)
 887         throws IllegalArgumentException, IllegalAccessException
 888     {
 889         if (!override) {
 890             Class&lt;?&gt; caller = Reflection.getCallerClass();
 891             checkAccess(caller, obj);
 892         }
 893         getFieldAccessor(obj).setChar(obj, c);
 894     }
 895 
 896     /**
 897      * Sets the value of a field as a {@code short} on the specified object.
 898      * This method is equivalent to
 899      * {@code set(obj, sObj)},
 900      * where {@code sObj} is a {@code Short} object and
 901      * {@code sObj.shortValue() == s}.
 902      *
 903      * @param obj the object whose field should be modified
 904      * @param s   the new value for the field of {@code obj}
 905      * being modified
 906      *
 907      * @throws    IllegalAccessException    if this {@code Field} object
 908      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 909      *              field is either inaccessible or final.</span>

 910      * @throws    IllegalArgumentException  if the specified object is not an
 911      *              instance of the class or interface declaring the underlying
 912      *              field (or a subclass or implementor thereof),
 913      *              or if an unwrapping conversion fails.
 914      * @throws    NullPointerException      if the specified object is null
 915      *              and the field is an instance field.
 916      * @throws    ExceptionInInitializerError if the initialization provoked
 917      *              by this method fails.
 918      * @see       Field#set
 919      */
 920     @CallerSensitive
 921     @ForceInline // to ensure Reflection.getCallerClass optimization
 922     public void setShort(Object obj, short s)
 923         throws IllegalArgumentException, IllegalAccessException
 924     {
 925         if (!override) {
 926             Class&lt;?&gt; caller = Reflection.getCallerClass();
 927             checkAccess(caller, obj);
 928         }
 929         getFieldAccessor(obj).setShort(obj, s);
 930     }
 931 
 932     /**
 933      * Sets the value of a field as an {@code int} on the specified object.
 934      * This method is equivalent to
 935      * {@code set(obj, iObj)},
 936      * where {@code iObj} is an {@code Integer} object and
 937      * {@code iObj.intValue() == i}.
 938      *
 939      * @param obj the object whose field should be modified
 940      * @param i   the new value for the field of {@code obj}
 941      * being modified
 942      *
 943      * @throws    IllegalAccessException    if this {@code Field} object
 944      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 945      *              field is either inaccessible or final.</span>

 946      * @throws    IllegalArgumentException  if the specified object is not an
 947      *              instance of the class or interface declaring the underlying
 948      *              field (or a subclass or implementor thereof),
 949      *              or if an unwrapping conversion fails.
 950      * @throws    NullPointerException      if the specified object is null
 951      *              and the field is an instance field.
 952      * @throws    ExceptionInInitializerError if the initialization provoked
 953      *              by this method fails.
 954      * @see       Field#set
 955      */
 956     @CallerSensitive
 957     @ForceInline // to ensure Reflection.getCallerClass optimization
 958     public void setInt(Object obj, int i)
 959         throws IllegalArgumentException, IllegalAccessException
 960     {
 961         if (!override) {
 962             Class&lt;?&gt; caller = Reflection.getCallerClass();
 963             checkAccess(caller, obj);
 964         }
 965         getFieldAccessor(obj).setInt(obj, i);
 966     }
 967 
 968     /**
 969      * Sets the value of a field as a {@code long} on the specified object.
 970      * This method is equivalent to
 971      * {@code set(obj, lObj)},
 972      * where {@code lObj} is a {@code Long} object and
 973      * {@code lObj.longValue() == l}.
 974      *
 975      * @param obj the object whose field should be modified
 976      * @param l   the new value for the field of {@code obj}
 977      * being modified
 978      *
 979      * @throws    IllegalAccessException    if this {@code Field} object
 980      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 981      *              field is either inaccessible or final.</span>

 982      * @throws    IllegalArgumentException  if the specified object is not an
 983      *              instance of the class or interface declaring the underlying
 984      *              field (or a subclass or implementor thereof),
 985      *              or if an unwrapping conversion fails.
 986      * @throws    NullPointerException      if the specified object is null
 987      *              and the field is an instance field.
 988      * @throws    ExceptionInInitializerError if the initialization provoked
 989      *              by this method fails.
 990      * @see       Field#set
 991      */
 992     @CallerSensitive
 993     @ForceInline // to ensure Reflection.getCallerClass optimization
 994     public void setLong(Object obj, long l)
 995         throws IllegalArgumentException, IllegalAccessException
 996     {
 997         if (!override) {
 998             Class&lt;?&gt; caller = Reflection.getCallerClass();
 999             checkAccess(caller, obj);
1000         }
1001         getFieldAccessor(obj).setLong(obj, l);
1002     }
1003 
1004     /**
1005      * Sets the value of a field as a {@code float} on the specified object.
1006      * This method is equivalent to
1007      * {@code set(obj, fObj)},
1008      * where {@code fObj} is a {@code Float} object and
1009      * {@code fObj.floatValue() == f}.
1010      *
1011      * @param obj the object whose field should be modified
1012      * @param f   the new value for the field of {@code obj}
1013      * being modified
1014      *
1015      * @throws    IllegalAccessException    if this {@code Field} object
1016      *              is enforcing Java language access control and the underlying
<span class="line-modified">1017      *              field is either inaccessible or final.</span>

1018      * @throws    IllegalArgumentException  if the specified object is not an
1019      *              instance of the class or interface declaring the underlying
1020      *              field (or a subclass or implementor thereof),
1021      *              or if an unwrapping conversion fails.
1022      * @throws    NullPointerException      if the specified object is null
1023      *              and the field is an instance field.
1024      * @throws    ExceptionInInitializerError if the initialization provoked
1025      *              by this method fails.
1026      * @see       Field#set
1027      */
1028     @CallerSensitive
1029     @ForceInline // to ensure Reflection.getCallerClass optimization
1030     public void setFloat(Object obj, float f)
1031         throws IllegalArgumentException, IllegalAccessException
1032     {
1033         if (!override) {
1034             Class&lt;?&gt; caller = Reflection.getCallerClass();
1035             checkAccess(caller, obj);
1036         }
1037         getFieldAccessor(obj).setFloat(obj, f);
1038     }
1039 
1040     /**
1041      * Sets the value of a field as a {@code double} on the specified object.
1042      * This method is equivalent to
1043      * {@code set(obj, dObj)},
1044      * where {@code dObj} is a {@code Double} object and
1045      * {@code dObj.doubleValue() == d}.
1046      *
1047      * @param obj the object whose field should be modified
1048      * @param d   the new value for the field of {@code obj}
1049      * being modified
1050      *
1051      * @throws    IllegalAccessException    if this {@code Field} object
1052      *              is enforcing Java language access control and the underlying
<span class="line-modified">1053      *              field is either inaccessible or final.</span>

1054      * @throws    IllegalArgumentException  if the specified object is not an
1055      *              instance of the class or interface declaring the underlying
1056      *              field (or a subclass or implementor thereof),
1057      *              or if an unwrapping conversion fails.
1058      * @throws    NullPointerException      if the specified object is null
1059      *              and the field is an instance field.
1060      * @throws    ExceptionInInitializerError if the initialization provoked
1061      *              by this method fails.
1062      * @see       Field#set
1063      */
1064     @CallerSensitive
1065     @ForceInline // to ensure Reflection.getCallerClass optimization
1066     public void setDouble(Object obj, double d)
1067         throws IllegalArgumentException, IllegalAccessException
1068     {
1069         if (!override) {
1070             Class&lt;?&gt; caller = Reflection.getCallerClass();
1071             checkAccess(caller, obj);
1072         }
1073         getFieldAccessor(obj).setDouble(obj, d);
</pre>
</td>
<td>
<hr />
<pre>
 711      * Sets the field represented by this {@code Field} object on the
 712      * specified object argument to the specified new value. The new
 713      * value is automatically unwrapped if the underlying field has a
 714      * primitive type.
 715      *
 716      * &lt;p&gt;The operation proceeds as follows:
 717      *
 718      * &lt;p&gt;If the underlying field is static, the {@code obj} argument is
 719      * ignored; it may be null.
 720      *
 721      * &lt;p&gt;Otherwise the underlying field is an instance field.  If the
 722      * specified object argument is null, the method throws a
 723      * {@code NullPointerException}.  If the specified object argument is not
 724      * an instance of the class or interface declaring the underlying
 725      * field, the method throws an {@code IllegalArgumentException}.
 726      *
 727      * &lt;p&gt;If this {@code Field} object is enforcing Java language access control, and
 728      * the underlying field is inaccessible, the method throws an
 729      * {@code IllegalAccessException}.
 730      *
<span class="line-modified"> 731      * &lt;p&gt;If the underlying field is final, this {@code Field} object has</span>
<span class="line-modified"> 732      * &lt;em&gt;write&lt;/em&gt; access if and only if the following conditions are met:</span>
<span class="line-modified"> 733      * &lt;ul&gt;</span>
<span class="line-modified"> 734      * &lt;li&gt;{@link #setAccessible(boolean) setAccessible(true)} has succeeded for</span>
<span class="line-added"> 735      *     this {@code Field} object;&lt;/li&gt;</span>
<span class="line-added"> 736      * &lt;li&gt;the field is non-static; and&lt;/li&gt;</span>
<span class="line-added"> 737      * &lt;li&gt;the field&#39;s declaring class is not a {@linkplain Class#isHidden()</span>
<span class="line-added"> 738      *     hidden class}.&lt;/li&gt;</span>
<span class="line-added"> 739      * &lt;/ul&gt;</span>
<span class="line-added"> 740      * If any of the above checks is not met, this method throws an</span>
<span class="line-added"> 741      * {@code IllegalAccessException}.</span>
<span class="line-added"> 742      *</span>
<span class="line-added"> 743      * &lt;p&gt; Setting a final field in this way</span>
 744      * is meaningful only during deserialization or reconstruction of
 745      * instances of classes with blank final fields, before they are
 746      * made available for access by other parts of a program. Use in
 747      * any other context may have unpredictable effects, including cases
 748      * in which other parts of a program continue to use the original
 749      * value of this field.
 750      *
 751      * &lt;p&gt;If the underlying field is of a primitive type, an unwrapping
 752      * conversion is attempted to convert the new value to a value of
 753      * a primitive type.  If this attempt fails, the method throws an
 754      * {@code IllegalArgumentException}.
 755      *
 756      * &lt;p&gt;If, after possible unwrapping, the new value cannot be
 757      * converted to the type of the underlying field by an identity or
 758      * widening conversion, the method throws an
 759      * {@code IllegalArgumentException}.
 760      *
 761      * &lt;p&gt;If the underlying field is static, the class that declared the
 762      * field is initialized if it has not already been initialized.
 763      *
 764      * &lt;p&gt;The field is set to the possibly unwrapped and widened new value.
 765      *
 766      * &lt;p&gt;If the field is hidden in the type of {@code obj},
 767      * the field&#39;s value is set according to the preceding rules.
 768      *
 769      * @param obj the object whose field should be modified
 770      * @param value the new value for the field of {@code obj}
 771      * being modified
 772      *
 773      * @throws    IllegalAccessException    if this {@code Field} object
 774      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 775      *              field is inaccessible or final;</span>
<span class="line-added"> 776      *              or if this {@code Field} object has no write access.</span>
 777      * @throws    IllegalArgumentException  if the specified object is not an
 778      *              instance of the class or interface declaring the underlying
 779      *              field (or a subclass or implementor thereof),
 780      *              or if an unwrapping conversion fails.
 781      * @throws    NullPointerException      if the specified object is null
 782      *              and the field is an instance field.
 783      * @throws    ExceptionInInitializerError if the initialization provoked
 784      *              by this method fails.
 785      */
 786     @CallerSensitive
 787     @ForceInline // to ensure Reflection.getCallerClass optimization
 788     public void set(Object obj, Object value)
 789         throws IllegalArgumentException, IllegalAccessException
 790     {
 791         if (!override) {
 792             Class&lt;?&gt; caller = Reflection.getCallerClass();
 793             checkAccess(caller, obj);
 794         }
 795         getFieldAccessor(obj).set(obj, value);
 796     }
 797 
 798     /**
 799      * Sets the value of a field as a {@code boolean} on the specified object.
 800      * This method is equivalent to
 801      * {@code set(obj, zObj)},
 802      * where {@code zObj} is a {@code Boolean} object and
 803      * {@code zObj.booleanValue() == z}.
 804      *
 805      * @param obj the object whose field should be modified
 806      * @param z   the new value for the field of {@code obj}
 807      * being modified
 808      *
 809      * @throws    IllegalAccessException    if this {@code Field} object
 810      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 811      *              field is either inaccessible or final;</span>
<span class="line-added"> 812      *              or if this {@code Field} object has no write access.</span>
 813      * @throws    IllegalArgumentException  if the specified object is not an
 814      *              instance of the class or interface declaring the underlying
 815      *              field (or a subclass or implementor thereof),
 816      *              or if an unwrapping conversion fails.
 817      * @throws    NullPointerException      if the specified object is null
 818      *              and the field is an instance field.
 819      * @throws    ExceptionInInitializerError if the initialization provoked
 820      *              by this method fails.
 821      * @see       Field#set
 822      */
 823     @CallerSensitive
 824     @ForceInline // to ensure Reflection.getCallerClass optimization
 825     public void setBoolean(Object obj, boolean z)
 826         throws IllegalArgumentException, IllegalAccessException
 827     {
 828         if (!override) {
 829             Class&lt;?&gt; caller = Reflection.getCallerClass();
 830             checkAccess(caller, obj);
 831         }
 832         getFieldAccessor(obj).setBoolean(obj, z);
 833     }
 834 
 835     /**
 836      * Sets the value of a field as a {@code byte} on the specified object.
 837      * This method is equivalent to
 838      * {@code set(obj, bObj)},
 839      * where {@code bObj} is a {@code Byte} object and
 840      * {@code bObj.byteValue() == b}.
 841      *
 842      * @param obj the object whose field should be modified
 843      * @param b   the new value for the field of {@code obj}
 844      * being modified
 845      *
 846      * @throws    IllegalAccessException    if this {@code Field} object
 847      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 848      *              field is either inaccessible or final;</span>
<span class="line-added"> 849      *              or if this {@code Field} object has no write access.</span>
 850      * @throws    IllegalArgumentException  if the specified object is not an
 851      *              instance of the class or interface declaring the underlying
 852      *              field (or a subclass or implementor thereof),
 853      *              or if an unwrapping conversion fails.
 854      * @throws    NullPointerException      if the specified object is null
 855      *              and the field is an instance field.
 856      * @throws    ExceptionInInitializerError if the initialization provoked
 857      *              by this method fails.
 858      * @see       Field#set
 859      */
 860     @CallerSensitive
 861     @ForceInline // to ensure Reflection.getCallerClass optimization
 862     public void setByte(Object obj, byte b)
 863         throws IllegalArgumentException, IllegalAccessException
 864     {
 865         if (!override) {
 866             Class&lt;?&gt; caller = Reflection.getCallerClass();
 867             checkAccess(caller, obj);
 868         }
 869         getFieldAccessor(obj).setByte(obj, b);
 870     }
 871 
 872     /**
 873      * Sets the value of a field as a {@code char} on the specified object.
 874      * This method is equivalent to
 875      * {@code set(obj, cObj)},
 876      * where {@code cObj} is a {@code Character} object and
 877      * {@code cObj.charValue() == c}.
 878      *
 879      * @param obj the object whose field should be modified
 880      * @param c   the new value for the field of {@code obj}
 881      * being modified
 882      *
 883      * @throws    IllegalAccessException    if this {@code Field} object
 884      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 885      *              field is either inaccessible or final;</span>
<span class="line-added"> 886      *              or if this {@code Field} object has no write access.</span>
 887      * @throws    IllegalArgumentException  if the specified object is not an
 888      *              instance of the class or interface declaring the underlying
 889      *              field (or a subclass or implementor thereof),
 890      *              or if an unwrapping conversion fails.
 891      * @throws    NullPointerException      if the specified object is null
 892      *              and the field is an instance field.
 893      * @throws    ExceptionInInitializerError if the initialization provoked
 894      *              by this method fails.
 895      * @see       Field#set
 896      */
 897     @CallerSensitive
 898     @ForceInline // to ensure Reflection.getCallerClass optimization
 899     public void setChar(Object obj, char c)
 900         throws IllegalArgumentException, IllegalAccessException
 901     {
 902         if (!override) {
 903             Class&lt;?&gt; caller = Reflection.getCallerClass();
 904             checkAccess(caller, obj);
 905         }
 906         getFieldAccessor(obj).setChar(obj, c);
 907     }
 908 
 909     /**
 910      * Sets the value of a field as a {@code short} on the specified object.
 911      * This method is equivalent to
 912      * {@code set(obj, sObj)},
 913      * where {@code sObj} is a {@code Short} object and
 914      * {@code sObj.shortValue() == s}.
 915      *
 916      * @param obj the object whose field should be modified
 917      * @param s   the new value for the field of {@code obj}
 918      * being modified
 919      *
 920      * @throws    IllegalAccessException    if this {@code Field} object
 921      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 922      *              field is either inaccessible or final;</span>
<span class="line-added"> 923      *              or if this {@code Field} object has no write access.</span>
 924      * @throws    IllegalArgumentException  if the specified object is not an
 925      *              instance of the class or interface declaring the underlying
 926      *              field (or a subclass or implementor thereof),
 927      *              or if an unwrapping conversion fails.
 928      * @throws    NullPointerException      if the specified object is null
 929      *              and the field is an instance field.
 930      * @throws    ExceptionInInitializerError if the initialization provoked
 931      *              by this method fails.
 932      * @see       Field#set
 933      */
 934     @CallerSensitive
 935     @ForceInline // to ensure Reflection.getCallerClass optimization
 936     public void setShort(Object obj, short s)
 937         throws IllegalArgumentException, IllegalAccessException
 938     {
 939         if (!override) {
 940             Class&lt;?&gt; caller = Reflection.getCallerClass();
 941             checkAccess(caller, obj);
 942         }
 943         getFieldAccessor(obj).setShort(obj, s);
 944     }
 945 
 946     /**
 947      * Sets the value of a field as an {@code int} on the specified object.
 948      * This method is equivalent to
 949      * {@code set(obj, iObj)},
 950      * where {@code iObj} is an {@code Integer} object and
 951      * {@code iObj.intValue() == i}.
 952      *
 953      * @param obj the object whose field should be modified
 954      * @param i   the new value for the field of {@code obj}
 955      * being modified
 956      *
 957      * @throws    IllegalAccessException    if this {@code Field} object
 958      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 959      *              field is either inaccessible or final;</span>
<span class="line-added"> 960      *              or if this {@code Field} object has no write access.</span>
 961      * @throws    IllegalArgumentException  if the specified object is not an
 962      *              instance of the class or interface declaring the underlying
 963      *              field (or a subclass or implementor thereof),
 964      *              or if an unwrapping conversion fails.
 965      * @throws    NullPointerException      if the specified object is null
 966      *              and the field is an instance field.
 967      * @throws    ExceptionInInitializerError if the initialization provoked
 968      *              by this method fails.
 969      * @see       Field#set
 970      */
 971     @CallerSensitive
 972     @ForceInline // to ensure Reflection.getCallerClass optimization
 973     public void setInt(Object obj, int i)
 974         throws IllegalArgumentException, IllegalAccessException
 975     {
 976         if (!override) {
 977             Class&lt;?&gt; caller = Reflection.getCallerClass();
 978             checkAccess(caller, obj);
 979         }
 980         getFieldAccessor(obj).setInt(obj, i);
 981     }
 982 
 983     /**
 984      * Sets the value of a field as a {@code long} on the specified object.
 985      * This method is equivalent to
 986      * {@code set(obj, lObj)},
 987      * where {@code lObj} is a {@code Long} object and
 988      * {@code lObj.longValue() == l}.
 989      *
 990      * @param obj the object whose field should be modified
 991      * @param l   the new value for the field of {@code obj}
 992      * being modified
 993      *
 994      * @throws    IllegalAccessException    if this {@code Field} object
 995      *              is enforcing Java language access control and the underlying
<span class="line-modified"> 996      *              field is either inaccessible or final;</span>
<span class="line-added"> 997      *              or if this {@code Field} object has no write access.</span>
 998      * @throws    IllegalArgumentException  if the specified object is not an
 999      *              instance of the class or interface declaring the underlying
1000      *              field (or a subclass or implementor thereof),
1001      *              or if an unwrapping conversion fails.
1002      * @throws    NullPointerException      if the specified object is null
1003      *              and the field is an instance field.
1004      * @throws    ExceptionInInitializerError if the initialization provoked
1005      *              by this method fails.
1006      * @see       Field#set
1007      */
1008     @CallerSensitive
1009     @ForceInline // to ensure Reflection.getCallerClass optimization
1010     public void setLong(Object obj, long l)
1011         throws IllegalArgumentException, IllegalAccessException
1012     {
1013         if (!override) {
1014             Class&lt;?&gt; caller = Reflection.getCallerClass();
1015             checkAccess(caller, obj);
1016         }
1017         getFieldAccessor(obj).setLong(obj, l);
1018     }
1019 
1020     /**
1021      * Sets the value of a field as a {@code float} on the specified object.
1022      * This method is equivalent to
1023      * {@code set(obj, fObj)},
1024      * where {@code fObj} is a {@code Float} object and
1025      * {@code fObj.floatValue() == f}.
1026      *
1027      * @param obj the object whose field should be modified
1028      * @param f   the new value for the field of {@code obj}
1029      * being modified
1030      *
1031      * @throws    IllegalAccessException    if this {@code Field} object
1032      *              is enforcing Java language access control and the underlying
<span class="line-modified">1033      *              field is either inaccessible or final;</span>
<span class="line-added">1034      *              or if this {@code Field} object has no write access.</span>
1035      * @throws    IllegalArgumentException  if the specified object is not an
1036      *              instance of the class or interface declaring the underlying
1037      *              field (or a subclass or implementor thereof),
1038      *              or if an unwrapping conversion fails.
1039      * @throws    NullPointerException      if the specified object is null
1040      *              and the field is an instance field.
1041      * @throws    ExceptionInInitializerError if the initialization provoked
1042      *              by this method fails.
1043      * @see       Field#set
1044      */
1045     @CallerSensitive
1046     @ForceInline // to ensure Reflection.getCallerClass optimization
1047     public void setFloat(Object obj, float f)
1048         throws IllegalArgumentException, IllegalAccessException
1049     {
1050         if (!override) {
1051             Class&lt;?&gt; caller = Reflection.getCallerClass();
1052             checkAccess(caller, obj);
1053         }
1054         getFieldAccessor(obj).setFloat(obj, f);
1055     }
1056 
1057     /**
1058      * Sets the value of a field as a {@code double} on the specified object.
1059      * This method is equivalent to
1060      * {@code set(obj, dObj)},
1061      * where {@code dObj} is a {@code Double} object and
1062      * {@code dObj.doubleValue() == d}.
1063      *
1064      * @param obj the object whose field should be modified
1065      * @param d   the new value for the field of {@code obj}
1066      * being modified
1067      *
1068      * @throws    IllegalAccessException    if this {@code Field} object
1069      *              is enforcing Java language access control and the underlying
<span class="line-modified">1070      *              field is either inaccessible or final;</span>
<span class="line-added">1071      *              or if this {@code Field} object has no write access.</span>
1072      * @throws    IllegalArgumentException  if the specified object is not an
1073      *              instance of the class or interface declaring the underlying
1074      *              field (or a subclass or implementor thereof),
1075      *              or if an unwrapping conversion fails.
1076      * @throws    NullPointerException      if the specified object is null
1077      *              and the field is an instance field.
1078      * @throws    ExceptionInInitializerError if the initialization provoked
1079      *              by this method fails.
1080      * @see       Field#set
1081      */
1082     @CallerSensitive
1083     @ForceInline // to ensure Reflection.getCallerClass optimization
1084     public void setDouble(Object obj, double d)
1085         throws IllegalArgumentException, IllegalAccessException
1086     {
1087         if (!override) {
1088             Class&lt;?&gt; caller = Reflection.getCallerClass();
1089             checkAccess(caller, obj);
1090         }
1091         getFieldAccessor(obj).setDouble(obj, d);
</pre>
</td>
</tr>
</table>
<center><a href="AccessibleObject.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../jdk/internal/org/objectweb/asm/ClassReader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
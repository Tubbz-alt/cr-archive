diff a/src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java b/src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java
--- a/src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java
+++ b/src/java.base/share/classes/java/lang/invoke/MethodHandleNatives.java
@@ -23,10 +23,12 @@
  * questions.
  */
 
 package java.lang.invoke;
 
+import jdk.internal.access.JavaLangAccess;
+import jdk.internal.access.SharedSecrets;
 import jdk.internal.ref.CleanerFactory;
 import sun.invoke.util.Wrapper;
 
 import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Field;
@@ -135,10 +137,19 @@
             REF_invokeStatic            = 6,
             REF_invokeSpecial           = 7,
             REF_newInvokeSpecial        = 8,
             REF_invokeInterface         = 9,
             REF_LIMIT                  = 10;
+
+        /**
+         * Flags for Lookup.ClassOptions
+         */
+        static final int
+            NESTMATE_CLASS            = 0x00000001,
+            HIDDEN_CLASS              = 0x00000002,
+            STRONG_LOADER_LINK        = 0x00000004,
+            ACCESS_VM_ANNOTATIONS     = 0x00000008;
     }
 
     static boolean refKindIsValid(int refKind) {
         return (refKind > REF_NONE && refKind < REF_LIMIT);
     }
@@ -657,6 +668,15 @@
         if (symbolicRefClass == definingClass)  return true;
         if (symbolicRef.isStatic() || symbolicRef.isPrivate())  return false;
         return (definingClass.isAssignableFrom(symbolicRefClass) ||  // Msym overrides Mdef
                 symbolicRefClass.isInterface());                     // Mdef implements Msym
     }
+
+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();
+    /*
+     * A convenient method for LambdaForms to get the class data of a given class.
+     * LambdaForms cannot use condy via MethodHandles.classData
+     */
+    static Object classData(Class<?> c) {
+        return JLA.classData(c);
+    }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/utilities/exceptions.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  package java.lang;
  
  import java.lang.annotation.Annotation;
  import java.lang.constant.ClassDesc;
  import java.lang.invoke.TypeDescriptor;
<span class="line-added">+ import java.lang.invoke.MethodHandles;</span>
  import java.lang.module.ModuleReader;
  import java.lang.ref.SoftReference;
  import java.io.IOException;
  import java.io.InputStream;
  import java.io.ObjectStreamField;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,20 ***</span>
   * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
   * int}, {@code long}, {@code float}, and {@code double}), and the
   * keyword {@code void} are also represented as {@code Class} objects.
   *
   * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
<span class="line-modified">!  * object is constructed automatically by the Java Virtual Machine</span>
<span class="line-modified">!  * when a class loader invokes one of the</span>
<span class="line-modified">!  * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods</span>
<span class="line-modified">!  * and passes the bytes of a {@code class} file.</span>
   *
   * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
   * class or interface. Most characteristics are derived from the {@code class}
<span class="line-modified">!  * file that the class loader passed to the Java Virtual Machine. A few</span>
<span class="line-modified">!  * characteristics are determined by the class loading environment at run time,</span>
<span class="line-modified">!  * such as the module returned by {@link #getModule() getModule()}.</span>
   *
   * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
   * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
   * another declaration. Other methods describe how a class or interface
   * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
<span class="line-new-header">--- 97,46 ---</span>
   * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
   * int}, {@code long}, {@code float}, and {@code double}), and the
   * keyword {@code void} are also represented as {@code Class} objects.
   *
   * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
<span class="line-modified">!  * object is constructed automatically by the Java Virtual Machine when</span>
<span class="line-modified">!  * a class is derived from the bytes of a {@code class} file through</span>
<span class="line-modified">!  * the invocation of one of the following methods:</span>
<span class="line-modified">!  * &lt;ul&gt;</span>
<span class="line-added">+  * &lt;li&gt; {@link ClassLoader#defineClass(String, byte[], int, int) ClassLoader::defineClass}</span>
<span class="line-added">+  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])</span>
<span class="line-added">+  *      java.lang.invoke.MethodHandles.Lookup::defineClass}</span>
<span class="line-added">+  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added">+  *      java.lang.invoke.MethodHandles.Lookup::defineHiddenClass}</span>
<span class="line-added">+  * &lt;/ul&gt;</span>
   *
   * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
   * class or interface. Most characteristics are derived from the {@code class}
<span class="line-modified">!  * file that the class loader passed to the Java Virtual Machine or</span>
<span class="line-modified">!  * from the {@code class} file passed to {@code Lookup::defineClass}</span>
<span class="line-modified">!  * or {@code Lookup::defineHiddenClass}.</span>
<span class="line-added">+  * A few characteristics are determined by the class loading environment</span>
<span class="line-added">+  * at run time, such as the module returned by {@link #getModule() getModule()}.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * &lt;p&gt; The following example uses a {@code Class} object to print the</span>
<span class="line-added">+  * class name of an object:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added">+  *     void printClassName(Object obj) {</span>
<span class="line-added">+  *         System.out.println(&quot;The class of &quot; + obj +</span>
<span class="line-added">+  *                            &quot; is &quot; + obj.getClass().getName());</span>
<span class="line-added">+  *     }</span>
<span class="line-added">+  * &lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * It is also possible to get the {@code Class} object for a named</span>
<span class="line-added">+  * type (or for {@code void}) using a &lt;i&gt;class literal&lt;/i&gt;.</span>
<span class="line-added">+  * For example:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * &lt;blockquote&gt;</span>
<span class="line-added">+  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}</span>
<span class="line-added">+  * &lt;/blockquote&gt;</span>
   *
   * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
   * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
   * another declaration. Other methods describe how a class or interface
   * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 124,37 ***</span>
   * {@code class} files are generated, for example, a Java compiler
   * will typically record a top-level class as the host of a nest where the
   * other members are the classes and interfaces whose declarations are
   * enclosed within the top-level class declaration.
   *
<span class="line-modified">!  * &lt;p&gt; The following example uses a {@code Class} object to print the</span>
<span class="line-modified">!  * class name of an object:</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-modified">!  *     void printClassName(Object obj) {</span>
<span class="line-modified">!  *         System.out.println(&quot;The class of &quot; + obj +</span>
<span class="line-modified">!  *                            &quot; is &quot; + obj.getClass().getName());</span>
<span class="line-removed">-  *     }</span>
<span class="line-removed">-  * &lt;/pre&gt;&lt;/blockquote&gt;</span>
   *
<span class="line-modified">!  * &lt;p&gt; It is also possible to get the {@code Class} object for a named</span>
<span class="line-modified">!  * type (or for void) using a class literal.  See Section {@jls</span>
<span class="line-modified">!  * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
<span class="line-modified">!  * For example:</span>
   *
<span class="line-modified">!  * &lt;blockquote&gt;</span>
<span class="line-modified">!  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}</span>
<span class="line-modified">!  * &lt;/blockquote&gt;</span>
   *
   * @param &lt;T&gt; the type of the class modeled by this {@code Class}
   * object.  For example, the type of {@code String.class} is {@code
   * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
   * unknown.
   *
   * @author  unascribed
   * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
   * @since   1.0
   */
  public final class Class&lt;T&gt; implements java.io.Serializable,
                                GenericDeclaration,
                                Type,
                                AnnotatedElement,
<span class="line-new-header">--- 151,47 ---</span>
   * {@code class} files are generated, for example, a Java compiler
   * will typically record a top-level class as the host of a nest where the
   * other members are the classes and interfaces whose declarations are
   * enclosed within the top-level class declaration.
   *
<span class="line-modified">!  * &lt;p&gt; A class or interface created by the invocation of</span>
<span class="line-modified">!  * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-modified">!  * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() &lt;em&gt;hidden&lt;/em&gt;}</span>
<span class="line-modified">!  * class or interface.</span>
<span class="line-modified">!  * All kinds of class, including enum types and record types, may be</span>
<span class="line-modified">!  * hidden classes; all kinds of interface, including annotation types,</span>
<span class="line-modified">!  * may be hidden interfaces.</span>
   *
<span class="line-modified">!  * The {@linkplain #getName() name of a hidden class or interface} is</span>
<span class="line-modified">!  * not a &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;,</span>
<span class="line-modified">!  * which means the following:</span>
<span class="line-modified">!  * &lt;ul&gt;</span>
<span class="line-added">+  * &lt;li&gt;A hidden class or interface cannot be referenced by the constant pools</span>
<span class="line-added">+  *     of other classes and interfaces.</span>
<span class="line-added">+  * &lt;li&gt;A hidden class or interface cannot be described in</span>
<span class="line-added">+  *     {@linkplain java.lang.constant.ConstantDesc &lt;em&gt;nominal form&lt;/em&gt;} by</span>
<span class="line-added">+  *     {@link #describeConstable() Class::describeConstable},</span>
<span class="line-added">+  *     {@link ClassDesc#of(String) ClassDesc::of}, or</span>
<span class="line-added">+  *     {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}.</span>
<span class="line-added">+  * &lt;li&gt;A hidden class or interface cannot be discovered by {@link #forName Class::forName}</span>
<span class="line-added">+  *     or {@link ClassLoader#loadClass(String, boolean) ClassLoader::loadClass}.</span>
<span class="line-added">+  * &lt;/ul&gt;</span>
   *
<span class="line-modified">!  * A hidden class or interface is never an array class, but may be</span>
<span class="line-modified">!  * the element type of an array. In all other respects, the fact that</span>
<span class="line-modified">!  * a class or interface is hidden has no bearing on the characteristics</span>
<span class="line-added">+  * exposed by the methods of class {@code Class}.</span>
   *
   * @param &lt;T&gt; the type of the class modeled by this {@code Class}
   * object.  For example, the type of {@code String.class} is {@code
   * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
   * unknown.
   *
   * @author  unascribed
   * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
   * @since   1.0
<span class="line-added">+  * @jls 15.8.2 Class Literals</span>
   */
  public final class Class&lt;T&gt; implements java.io.Serializable,
                                GenericDeclaration,
                                Type,
                                AnnotatedElement,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 183,13 ***</span>
      }
  
      /**
       * Converts the object to a string. The string representation is the
       * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
<span class="line-modified">!      * fully qualified name of the class in the format returned by</span>
<span class="line-modified">!      * {@code getName}.  If this {@code Class} object represents a</span>
<span class="line-modified">!      * primitive type, this method returns the name of the primitive type.  If</span>
       * this {@code Class} object represents void this method returns
       * &quot;void&quot;. If this {@code Class} object represents an array type,
       * this method returns &quot;class &quot; followed by {@code getName}.
       *
       * @return a string representation of this {@code Class} object.
<span class="line-new-header">--- 220,13 ---</span>
      }
  
      /**
       * Converts the object to a string. The string representation is the
       * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
<span class="line-modified">!      * name of the class in the format returned by {@code getName}.</span>
<span class="line-modified">!      * If this {@code Class} object represents a primitive type,</span>
<span class="line-modified">!      * this method returns the name of the primitive type.  If</span>
       * this {@code Class} object represents void this method returns
       * &quot;void&quot;. If this {@code Class} object represents an array type,
       * this method returns &quot;class &quot; followed by {@code getName}.
       *
       * @return a string representation of this {@code Class} object.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 794,63 ***</span>
      public boolean isAnnotation() {
          return (getModifiers() &amp; ANNOTATION) != 0;
      }
  
      /**
<span class="line-modified">!      * Returns {@code true} if this class is a synthetic class;</span>
<span class="line-modified">!      * returns {@code false} otherwise.</span>
<span class="line-modified">!      * @return {@code true} if and only if this class is a synthetic class as</span>
<span class="line-modified">!      *         defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
       * @jls 13.1 The Form of a Binary
       * @since 1.5
       */
      public boolean isSynthetic() {
          return (getModifiers() &amp; SYNTHETIC) != 0;
      }
  
      /**
       * Returns the  name of the entity (class, interface, array class,
<span class="line-modified">!      * primitive type, or void) represented by this {@code Class} object,</span>
<span class="line-removed">-      * as a {@code String}.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt; If this {@code Class} object represents a reference type that is</span>
<span class="line-removed">-      * not an array type then the binary name of the class is</span>
<span class="line-removed">-      * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-removed">-      * Specification&lt;/cite&gt;.</span>
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the</span>
<span class="line-modified">!      * name returned is a {@code String} equal to the Java language</span>
<span class="line-modified">!      * keyword corresponding to the primitive type or void.</span>
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal</span>
<span class="line-modified">!      * form of the name consists of the name of the element type preceded by</span>
<span class="line-modified">!      * one or more &#39;{@code [}&#39; characters representing the depth of the array</span>
<span class="line-modified">!      * nesting.  The encoding of element type names is as follows:</span>
       *
       * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
       * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
       * &lt;thead&gt;
       * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
       * &lt;/thead&gt;
       * &lt;tbody style=&quot;text-align:left&quot;&gt;
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface</span>
<span class="line-modified">!      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class}</span>
<span class="line-modified">!      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S</span>
       * &lt;/tbody&gt;
       * &lt;/table&gt;&lt;/blockquote&gt;
       *
<span class="line-modified">!      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of</span>
<span class="line-modified">!      * the class specified above.</span>
       *
       * &lt;p&gt; Examples:
       * &lt;blockquote&gt;&lt;pre&gt;
       * String.class.getName()
       *     returns &quot;java.lang.String&quot;
<span class="line-new-header">--- 831,69 ---</span>
      public boolean isAnnotation() {
          return (getModifiers() &amp; ANNOTATION) != 0;
      }
  
      /**
<span class="line-modified">!      * Returns {@code true} if and only if this class has the synthetic modifier</span>
<span class="line-modified">!      * bit set.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * @return {@code true} if and only if this class has the synthetic modifier bit set</span>
       * @jls 13.1 The Form of a Binary
<span class="line-added">+      * @jvms 4.1 The {@code ClassFile} Structure</span>
       * @since 1.5
       */
      public boolean isSynthetic() {
          return (getModifiers() &amp; SYNTHETIC) != 0;
      }
  
      /**
       * Returns the  name of the entity (class, interface, array class,
<span class="line-modified">!      * primitive type, or void) represented by this {@code Class} object.</span>
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents a class or interface,</span>
<span class="line-modified">!      * not an array class, then:</span>
<span class="line-modified">!      * &lt;ul&gt;</span>
<span class="line-added">+      * &lt;li&gt; If the class or interface is not {@linkplain #isHidden() hidden},</span>
<span class="line-added">+      *      then the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;</span>
<span class="line-added">+      *      of the class or interface is returned.</span>
<span class="line-added">+      * &lt;li&gt; If the class or interface is hidden, then the result is a string</span>
<span class="line-added">+      *      of the form: {@code N + &#39;/&#39; + &lt;suffix&gt;}</span>
<span class="line-added">+      *      where {@code N} is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;</span>
<span class="line-added">+      *      indicated by the {@code class} file passed to</span>
<span class="line-added">+      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added">+      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.</span>
<span class="line-added">+      * &lt;/ul&gt;</span>
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents an array class, then</span>
<span class="line-modified">!      * the result is a string consisting of one or more &#39;{@code [}&#39; characters</span>
<span class="line-modified">!      * representing the depth of the array nesting, followed by the element</span>
<span class="line-modified">!      * type as encoded using the following table:</span>
       *
       * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
       * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
       * &lt;thead&gt;
       * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
       * &lt;/thead&gt;
       * &lt;tbody style=&quot;text-align:left&quot;&gt;
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-modified">!      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class} with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-modified">!      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code Q}&lt;em&gt;N&lt;/em&gt;{@code ;}</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}</span>
<span class="line-modified">!      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}</span>
       * &lt;/tbody&gt;
       * &lt;/table&gt;&lt;/blockquote&gt;
       *
<span class="line-modified">!      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},</span>
<span class="line-modified">!      * then the result is a string with the same spelling as the Java language</span>
<span class="line-added">+      * keyword which corresponds to the primitive type or {@code void}.</span>
       *
       * &lt;p&gt; Examples:
       * &lt;blockquote&gt;&lt;pre&gt;
       * String.class.getName()
       *     returns &quot;java.lang.String&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 866,12 ***</span>
       *     returns &quot;[[LPoint$ref;&quot;
       * (new int[3][4][5][6][7][8][9]).getClass().getName()
       *     returns &quot;[[[[[[[I&quot;
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
<span class="line-modified">!      * @return  the name of the class or interface</span>
       *          represented by this {@code Class} object.
       */
      public String getName() {
          String name = this.name;
          return name != null ? name : initClassName();
      }
<span class="line-new-header">--- 909,13 ---</span>
       *     returns &quot;[[LPoint$ref;&quot;
       * (new int[3][4][5][6][7][8][9]).getClass().getName()
       *     returns &quot;[[[[[[[I&quot;
       * &lt;/pre&gt;&lt;/blockquote&gt;
       *
<span class="line-modified">!      * @return  the name of the class, interface, or other entity</span>
       *          represented by this {@code Class} object.
<span class="line-added">+      * @jls 13.1 The Form of a Binary</span>
       */
      public String getName() {
          String name = this.name;
          return name != null ? name : initClassName();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 945,10 ***</span>
<span class="line-new-header">--- 989,18 ---</span>
      // Initialized in JVM not by private constructor
      // This field is filtered from reflection access, i.e. getDeclaredField
      // will throw NoSuchFieldException
      private final ClassLoader classLoader;
  
<span class="line-added">+     // Set by VM</span>
<span class="line-added">+     private transient Object classData;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // package-private</span>
<span class="line-added">+     Object getClassData() {</span>
<span class="line-added">+         return classData;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /**
       * Returns an array of {@code TypeVariable} objects that represent the
       * type variables declared by the generic declaration represented by this
       * {@code GenericDeclaration} object, in declaration order.  Returns an
       * array of length 0 if the underlying generic declaration declares no type
</pre>
<hr />
<pre>
<span class="line-old-header">*** 957,11 ***</span>
       * @return an array of {@code TypeVariable} objects that represent
       *     the type variables declared by this generic declaration
       * @throws java.lang.reflect.GenericSignatureFormatError if the generic
       *     signature of this generic declaration does not conform to
       *     the format specified in section {@jvms 4.7.9} of
<span class="line-modified">!      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;,</span>
       * @since 1.5
       */
      @SuppressWarnings(&quot;unchecked&quot;)
      public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
          ClassRepository info = getGenericInfo();
<span class="line-new-header">--- 1009,11 ---</span>
       * @return an array of {@code TypeVariable} objects that represent
       *     the type variables declared by this generic declaration
       * @throws java.lang.reflect.GenericSignatureFormatError if the generic
       *     signature of this generic declaration does not conform to
       *     the format specified in section {@jvms 4.7.9} of
<span class="line-modified">!      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
       * @since 1.5
       */
      @SuppressWarnings(&quot;unchecked&quot;)
      public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
          ClassRepository info = getGenericInfo();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1080,14 ***</span>
       * @jls 6.7 Fully Qualified Names
       */
      public String getPackageName() {
          String pn = this.packageName;
          if (pn == null) {
<span class="line-modified">!             Class&lt;?&gt; c = this;</span>
<span class="line-removed">-             while (c.isArray()) {</span>
<span class="line-removed">-                 c = c.getComponentType();</span>
<span class="line-removed">-             }</span>
              if (c.isPrimitive()) {
                  pn = &quot;java.lang&quot;;
              } else {
                  String cn = c.getName();
                  int dot = cn.lastIndexOf(&#39;.&#39;);
<span class="line-new-header">--- 1132,11 ---</span>
       * @jls 6.7 Fully Qualified Names
       */
      public String getPackageName() {
          String pn = this.packageName;
          if (pn == null) {
<span class="line-modified">!             Class&lt;?&gt; c = isArray() ? elementType() : this;</span>
              if (c.isPrimitive()) {
                  pn = &quot;java.lang&quot;;
              } else {
                  String cn = c.getName();
                  int dot = cn.lastIndexOf(&#39;.&#39;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1241,10 ***</span>
<span class="line-new-header">--- 1290,24 ---</span>
          }
      }
  
      private final Class&lt;?&gt; componentType;
  
<span class="line-added">+     /*</span>
<span class="line-added">+      * Returns the {@code Class} representing the element type of an array class.</span>
<span class="line-added">+      * If this class does not represent an array class, then this method returns</span>
<span class="line-added">+      * {@code null}.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     private Class&lt;?&gt; elementType() {</span>
<span class="line-added">+         if (!isArray()) return null;</span>
<span class="line-added">+ </span>
<span class="line-added">+         Class&lt;?&gt; c = this;</span>
<span class="line-added">+         while (c.isArray()) {</span>
<span class="line-added">+             c = c.getComponentType();</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return c;</span>
<span class="line-added">+     }</span>
  
      /**
       * Returns the Java language modifiers for this class or interface, encoded
       * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
       * constants for {@code public}, {@code protected},
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1669,15 ***</span>
          }
          return getName();
      }
  
      /**
<span class="line-modified">!      * Returns the canonical name of the underlying class as defined</span>
<span class="line-modified">!      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section</span>
<span class="line-modified">!      * {@jls 6.7}.  Returns null if the underlying class does not have</span>
<span class="line-modified">!      * a canonical name (i.e., if it is a local or anonymous class or</span>
<span class="line-modified">!      * an array whose component type does not have a canonical name).</span>
       * @return the canonical name of the underlying class if it exists, and
       * {@code null} otherwise.
       * @since 1.5
       */
      public String getCanonicalName() {
<span class="line-new-header">--- 1732,21 ---</span>
          }
          return getName();
      }
  
      /**
<span class="line-modified">!      * Returns the canonical name of the underlying class as</span>
<span class="line-modified">!      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
<span class="line-modified">!      * Returns {@code null} if the underlying class does not have a canonical</span>
<span class="line-modified">!      * name. Classes without canonical names include:</span>
<span class="line-modified">!      * &lt;ul&gt;</span>
<span class="line-added">+      * &lt;li&gt;a {@linkplain #isLocalClass() local class}</span>
<span class="line-added">+      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}</span>
<span class="line-added">+      * &lt;li&gt;a {@linkplain #isHidden() hidden class}</span>
<span class="line-added">+      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;</span>
<span class="line-added">+      * &lt;/ul&gt;</span>
<span class="line-added">+      *</span>
       * @return the canonical name of the underlying class if it exists, and
       * {@code null} otherwise.
       * @since 1.5
       */
      public String getCanonicalName() {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1695,11 ***</span>
              if (canonicalName != null)
                  return canonicalName + &quot;[]&quot;;
              else
                  return ReflectionData.NULL_SENTINEL;
          }
<span class="line-modified">!         if (isLocalOrAnonymousClass())</span>
              return ReflectionData.NULL_SENTINEL;
          Class&lt;?&gt; enclosingClass = getEnclosingClass();
          if (enclosingClass == null) { // top level class
              return getName();
          } else {
<span class="line-new-header">--- 1764,11 ---</span>
              if (canonicalName != null)
                  return canonicalName + &quot;[]&quot;;
              else
                  return ReflectionData.NULL_SENTINEL;
          }
<span class="line-modified">!         if (isHidden() || isLocalOrAnonymousClass())</span>
              return ReflectionData.NULL_SENTINEL;
          Class&lt;?&gt; enclosingClass = getEnclosingClass();
          if (enclosingClass == null) { // top level class
              return getName();
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1712,10 ***</span>
<span class="line-new-header">--- 1781,13 ---</span>
  
      /**
       * Returns {@code true} if and only if the underlying class
       * is an anonymous class.
       *
<span class="line-added">+      * @apiNote</span>
<span class="line-added">+      * An anonymous class is not a {@linkplain #isHidden() hidden class}.</span>
<span class="line-added">+      *</span>
       * @return {@code true} if and only if this class is an anonymous class.
       * @since 1.5
       */
      public boolean isAnonymousClass() {
          return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2937,10 ***</span>
<span class="line-new-header">--- 3009,15 ---</span>
      public java.security.ProtectionDomain getProtectionDomain() {
          SecurityManager sm = System.getSecurityManager();
          if (sm != null) {
              sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
          }
<span class="line-added">+         return protectionDomain();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // package-private</span>
<span class="line-added">+     java.security.ProtectionDomain protectionDomain() {</span>
          java.security.ProtectionDomain pd = getProtectionDomain0();
          if (pd == null) {
              if (allPermDomain == null) {
                  java.security.Permissions perms =
                      new java.security.Permissions();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2951,11 ***</span>
              pd = allPermDomain;
          }
          return pd;
      }
  
<span class="line-removed">- </span>
      /**
       * Returns the ProtectionDomain of this class.
       */
      private native java.security.ProtectionDomain getProtectionDomain0();
  
<span class="line-new-header">--- 3028,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3023,14 ***</span>
       * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
       * if name is absolute
       */
      private String resolveName(String name) {
          if (!name.startsWith(&quot;/&quot;)) {
<span class="line-modified">!             Class&lt;?&gt; c = this;</span>
<span class="line-removed">-             while (c.isArray()) {</span>
<span class="line-removed">-                 c = c.getComponentType();</span>
<span class="line-removed">-             }</span>
              String baseName = c.getPackageName();
              if (baseName != null &amp;&amp; !baseName.isEmpty()) {
                  name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
              }
          } else {
<span class="line-new-header">--- 3099,11 ---</span>
       * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
       * if name is absolute
       */
      private String resolveName(String name) {
          if (!name.startsWith(&quot;/&quot;)) {
<span class="line-modified">!             Class&lt;?&gt; c = isArray() ? elementType() : this;</span>
              String baseName = c.getPackageName();
              if (baseName != null &amp;&amp; !baseName.isEmpty()) {
                  name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
              }
          } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4102,33 ***</span>
      private native Class&lt;?&gt; getNestHost0();
  
      /**
       * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
       * or interface represented by this {@code Class} object belongs.
<span class="line-modified">!      * Every class and interface is a member of exactly one nest.</span>
<span class="line-removed">-      * A class or interface that is not recorded as belonging to a nest</span>
<span class="line-removed">-      * belongs to the nest consisting only of itself, and is the nest</span>
<span class="line-removed">-      * host.</span>
<span class="line-removed">-      *</span>
<span class="line-removed">-      * &lt;p&gt;Each of the {@code Class} objects representing array types,</span>
<span class="line-removed">-      * primitive types, and {@code void} returns {@code this} to indicate</span>
<span class="line-removed">-      * that the represented entity belongs to the nest consisting only of</span>
<span class="line-removed">-      * itself, and is the nest host.</span>
       *
<span class="line-modified">!      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing</span>
<span class="line-modified">!      * the nest host, or if this class or interface is not enumerated as</span>
<span class="line-modified">!      * a member of the nest by the nest host, then it is considered to belong</span>
<span class="line-modified">!      * to its own nest and {@code this} is returned as the host.</span>
       *
<span class="line-modified">!      * @apiNote A {@code class} file of version 55.0 or greater may record the</span>
<span class="line-modified">!      * host of the nest to which it belongs by using the {@code NestHost}</span>
<span class="line-modified">!      * attribute (JVMS {@jvms 4.7.28}). Alternatively, a {@code class} file of</span>
<span class="line-modified">!      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s</span>
<span class="line-modified">!      * other members with the</span>
<span class="line-modified">!      * {@code NestMembers} attribute (JVMS {@jvms 4.7.29}).</span>
<span class="line-modified">!      * A {@code class} file of version 54.0 or lower does not use these</span>
<span class="line-modified">!      * attributes.</span>
       *
       * @return the nest host of this class or interface
       *
       * @throws SecurityException
       *         If the returned class is not the current class, and
<span class="line-new-header">--- 4175,26 ---</span>
      private native Class&lt;?&gt; getNestHost0();
  
      /**
       * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
       * or interface represented by this {@code Class} object belongs.
<span class="line-modified">!      * Every class and interface belongs to exactly one nest.</span>
       *
<span class="line-modified">!      * If the nest host of this class or interface has previously</span>
<span class="line-modified">!      * been determined, then this method returns the nest host.</span>
<span class="line-modified">!      * If the nest host of this class or interface has</span>
<span class="line-modified">!      * not previously been determined, then this method determines the nest</span>
<span class="line-added">+      * host using the algorithm of JVMS 5.4.4, and returns it.</span>
       *
<span class="line-modified">!      * Often, a class or interface belongs to a nest consisting only of itself,</span>
<span class="line-modified">!      * in which case this method returns {@code this} to indicate that the class</span>
<span class="line-modified">!      * or interface is the nest host.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,</span>
<span class="line-modified">!      * or {@code void}, then this method returns {@code this},</span>
<span class="line-modified">!      * indicating that the represented entity belongs to the nest consisting only of</span>
<span class="line-modified">!      * itself, and is the nest host.</span>
       *
       * @return the nest host of this class or interface
       *
       * @throws SecurityException
       *         If the returned class is not the current class, and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4145,21 ***</span>
      @CallerSensitive
      public Class&lt;?&gt; getNestHost() {
          if (isPrimitive() || isArray()) {
              return this;
          }
<span class="line-modified">!         Class&lt;?&gt; host;</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             host = getNestHost0();</span>
<span class="line-removed">-         } catch (LinkageError e) {</span>
<span class="line-removed">-             // if we couldn&#39;t load our nest-host then we</span>
<span class="line-removed">-             // act as-if we have no nest-host attribute</span>
<span class="line-removed">-             return this;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         // if null then nest membership validation failed, so we</span>
<span class="line-removed">-         // act as-if we have no nest-host attribute</span>
<span class="line-removed">-         if (host == null || host == this) {</span>
              return this;
          }
          // returning a different class requires a security check
          SecurityManager sm = System.getSecurityManager();
          if (sm != null) {
<span class="line-new-header">--- 4211,13 ---</span>
      @CallerSensitive
      public Class&lt;?&gt; getNestHost() {
          if (isPrimitive() || isArray()) {
              return this;
          }
<span class="line-modified">! </span>
<span class="line-modified">!         Class&lt;?&gt; host = getNestHost0();</span>
<span class="line-modified">!         if (host == this) {</span>
              return this;
          }
          // returning a different class requires a security check
          SecurityManager sm = System.getSecurityManager();
          if (sm != null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4187,56 ***</span>
          }
          if (isPrimitive() || isArray() ||
              c.isPrimitive() || c.isArray()) {
              return false;
          }
<span class="line-modified">!         try {</span>
<span class="line-modified">!             return getNestHost0() == c.getNestHost0();</span>
<span class="line-removed">-         } catch (LinkageError e) {</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         }</span>
      }
  
      private native Class&lt;?&gt;[] getNestMembers0();
  
      /**
       * Returns an array containing {@code Class} objects representing all the
       * classes and interfaces that are members of the nest to which the class
       * or interface represented by this {@code Class} object belongs.
<span class="line-modified">!      * The {@linkplain #getNestHost() nest host} of that nest is the zeroth</span>
<span class="line-modified">!      * element of the array. Subsequent elements represent any classes or</span>
<span class="line-modified">!      * interfaces that are recorded by the nest host as being members of</span>
<span class="line-modified">!      * the nest; the order of such elements is unspecified. Duplicates are</span>
<span class="line-modified">!      * permitted.</span>
<span class="line-modified">!      * If the nest host of that nest does not enumerate any members, then the</span>
<span class="line-modified">!      * array has a single element containing {@code this}.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * &lt;p&gt;Each of the {@code Class} objects representing array types,</span>
<span class="line-modified">!      * primitive types, and {@code void} returns an array containing only</span>
       * {@code this}.
       *
<span class="line-modified">!      * &lt;p&gt;This method validates that, for each class or interface which is</span>
<span class="line-modified">!      * recorded as a member of the nest by the nest host, that class or</span>
<span class="line-modified">!      * interface records itself as a member of that same nest. Any exceptions</span>
<span class="line-modified">!      * that occur during this validation are rethrown by this method.</span>
       *
       * @return an array of all classes and interfaces in the same nest as
<span class="line-modified">!      * this class</span>
       *
<span class="line-modified">!      * @throws LinkageError</span>
<span class="line-modified">!      *         If there is any problem loading or validating a nest member or</span>
<span class="line-modified">!      *         its nest host</span>
<span class="line-modified">!      * @throws SecurityException</span>
<span class="line-modified">!      *         If any returned class is not the current class, and</span>
<span class="line-modified">!      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s</span>
<span class="line-removed">-      *         class loader is not the same as or an ancestor of the class</span>
<span class="line-removed">-      *         loader for that returned class and invocation of {@link</span>
<span class="line-removed">-      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}</span>
       * denies access to the package of that returned class
       *
       * @since 11
       * @see #getNestHost()
       */
      @CallerSensitive
      public Class&lt;?&gt;[] getNestMembers() {
          if (isPrimitive() || isArray()) {
              return new Class&lt;?&gt;[] { this };
<span class="line-new-header">--- 4245,61 ---</span>
          }
          if (isPrimitive() || isArray() ||
              c.isPrimitive() || c.isArray()) {
              return false;
          }
<span class="line-modified">! </span>
<span class="line-modified">!         return getNestHost() == c.getNestHost();</span>
      }
  
      private native Class&lt;?&gt;[] getNestMembers0();
  
      /**
       * Returns an array containing {@code Class} objects representing all the
       * classes and interfaces that are members of the nest to which the class
       * or interface represented by this {@code Class} object belongs.
<span class="line-modified">!      *</span>
<span class="line-modified">!      * First, this method obtains the {@linkplain #getNestHost() nest host},</span>
<span class="line-modified">!      * {@code H}, of the nest to which the class or interface represented by</span>
<span class="line-modified">!      * this {@code Class} object belongs. The zeroth element of the returned</span>
<span class="line-modified">!      * array is {@code H}.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * Then, for each class or interface {@code C} which is recorded by {@code H}</span>
<span class="line-modified">!      * as being a member of its nest, this method attempts to obtain the {@code Class}</span>
<span class="line-modified">!      * object for {@code C} (using {@linkplain #getClassLoader() the defining class</span>
<span class="line-modified">!      * loader} of the current {@code Class} object), and then obtains the</span>
<span class="line-added">+      * {@linkplain #getNestHost() nest host} of the nest to which {@code C} belongs.</span>
<span class="line-added">+      * The classes and interfaces which are recorded by {@code H} as being members</span>
<span class="line-added">+      * of its nest, and for which {@code H} can be determined as their nest host,</span>
<span class="line-added">+      * are indicated by subsequent elements of the returned array. The order of</span>
<span class="line-added">+      * such elements is unspecified. Duplicates are permitted.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,</span>
<span class="line-added">+      * or {@code void}, then this method returns a single-element array containing</span>
       * {@code this}.
       *
<span class="line-modified">!      * @apiNote</span>
<span class="line-modified">!      * The returned array includes only the nest members recorded in the {@code NestMembers}</span>
<span class="line-modified">!      * attribute, and not any hidden classes that were added to the nest via</span>
<span class="line-modified">!      * {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added">+      * Lookup::defineHiddenClass}.</span>
       *
       * @return an array of all classes and interfaces in the same nest as
<span class="line-modified">!      * this class or interface</span>
       *
<span class="line-modified">!      * @throws SecurityException</span>
<span class="line-modified">!      * If any returned class is not the current class, and</span>
<span class="line-modified">!      * if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s</span>
<span class="line-modified">!      * class loader is not the same as or an ancestor of the class</span>
<span class="line-modified">!      * loader for that returned class and invocation of {@link</span>
<span class="line-modified">!      * SecurityManager#checkPackageAccess s.checkPackageAccess()}</span>
       * denies access to the package of that returned class
       *
       * @since 11
       * @see #getNestHost()
<span class="line-added">+      * @jvms 4.7.28 The {@code NestHost} Attribute</span>
<span class="line-added">+      * @jvms 4.7.29 The {@code NestMembers} Attribute</span>
       */
      @CallerSensitive
      public Class&lt;?&gt;[] getNestMembers() {
          if (isPrimitive() || isArray()) {
              return new Class&lt;?&gt;[] { this };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4256,30 ***</span>
          }
          return members;
      }
  
      /**
<span class="line-modified">!      * Returns the type descriptor string for this class.</span>
<span class="line-modified">!      * &lt;p&gt;</span>
<span class="line-modified">!      * Note that this is not a strict inverse of {@link #forName};</span>
       * distinct classes which share a common name but have different class loaders
       * will have identical descriptor strings.
       *
<span class="line-modified">!      * @return the type descriptor representation</span>
       * @jvms 4.3.2 Field Descriptors
       * @since 12
       */
      @Override
      public String descriptorString() {
          if (isPrimitive())
              return Wrapper.forPrimitiveType(this).basicTypeString();
<span class="line-modified">!         else if (isArray()) {</span>
              return &quot;[&quot; + componentType.descriptorString();
          }
<span class="line-modified">!         else {</span>
<span class="line-modified">!             return (isInlineClass() ? &quot;Q&quot; : &quot;L&quot;)</span>
<span class="line-modified">!                     + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
          }
      }
  
      /**
       * Returns the component type of this {@code Class}, if it describes
<span class="line-new-header">--- 4319,80 ---</span>
          }
          return members;
      }
  
      /**
<span class="line-modified">!      * Returns the descriptor string of the entity (class, interface, array class,</span>
<span class="line-modified">!      * primitive type, or {@code void}) represented by this {@code Class} object.</span>
<span class="line-modified">!      *</span>
<span class="line-added">+      * &lt;p&gt; If this {@code Class} object represents a class or interface,</span>
<span class="line-added">+      * not an array class, then:</span>
<span class="line-added">+      * &lt;ul&gt;</span>
<span class="line-added">+      * &lt;li&gt; If the class or interface is not {@linkplain Class#isHidden() hidden},</span>
<span class="line-added">+      *      then the result is a field descriptor (JVMS {@jvms 4.3.2})</span>
<span class="line-added">+      *      for the class or interface. Calling</span>
<span class="line-added">+      *      {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}</span>
<span class="line-added">+      *      with the result descriptor string produces a {@link ClassDesc ClassDesc}</span>
<span class="line-added">+      *      describing this class or interface.</span>
<span class="line-added">+      * &lt;li&gt; If the class or interface is {@linkplain Class#isHidden() hidden},</span>
<span class="line-added">+      *      then the result is a string of the form:</span>
<span class="line-added">+      *      &lt;blockquote&gt;</span>
<span class="line-added">+      *      {@code &quot;L&quot; +} &lt;em&gt;N&lt;/em&gt; {@code + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;}</span>
<span class="line-added">+      *      &lt;/blockquote&gt;</span>
<span class="line-added">+      *      where &lt;em&gt;N&lt;/em&gt; is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;</span>
<span class="line-added">+      *      encoded in internal form indicated by the {@code class} file passed to</span>
<span class="line-added">+      *      {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added">+      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.</span>
<span class="line-added">+      *      A hidden class or interface has no {@linkplain ClassDesc nominal descriptor}.</span>
<span class="line-added">+      *      The result string is not a type descriptor.</span>
<span class="line-added">+      * &lt;/ul&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;p&gt; If this {@code Class} object represents an array class, then</span>
<span class="line-added">+      * the result is a string consisting of one or more &#39;{@code [}&#39; characters</span>
<span class="line-added">+      * representing the depth of the array nesting, followed by the</span>
<span class="line-added">+      * descriptor string of the element type.</span>
<span class="line-added">+      * &lt;ul&gt;</span>
<span class="line-added">+      * &lt;li&gt; If the element type is not a {@linkplain Class#isHidden() hidden} class</span>
<span class="line-added">+      * or interface, then this array class can be described nominally.</span>
<span class="line-added">+      * Calling {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}</span>
<span class="line-added">+      * with the result descriptor string produces a {@link ClassDesc ClassDesc}</span>
<span class="line-added">+      * describing this array class.</span>
<span class="line-added">+      * &lt;li&gt; If the element type is a {@linkplain Class#isHidden() hidden} class or</span>
<span class="line-added">+      * interface, then this array class cannot be described nominally.</span>
<span class="line-added">+      * The result string is not a type descriptor.</span>
<span class="line-added">+      * &lt;/ul&gt;</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * &lt;p&gt; If this {@code Class} object represents a primitive type or</span>
<span class="line-added">+      * {@code void}, then the result is a field descriptor string which</span>
<span class="line-added">+      * is a one-letter code corresponding to a primitive type or {@code void}</span>
<span class="line-added">+      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @apiNote</span>
<span class="line-added">+      * This is not a strict inverse of {@link #forName};</span>
       * distinct classes which share a common name but have different class loaders
       * will have identical descriptor strings.
       *
<span class="line-modified">!      * @return the descriptor string for this {@code Class} object</span>
       * @jvms 4.3.2 Field Descriptors
       * @since 12
       */
      @Override
      public String descriptorString() {
          if (isPrimitive())
              return Wrapper.forPrimitiveType(this).basicTypeString();
<span class="line-modified">! </span>
<span class="line-added">+         if (isArray()) {</span>
              return &quot;[&quot; + componentType.descriptorString();
          }
<span class="line-modified">!         String typeDesc = isInlineClass() ? &quot;Q&quot; : &quot;L&quot;;</span>
<span class="line-modified">!         if (isHidden()) {</span>
<span class="line-modified">!             String name = getName();</span>
<span class="line-added">+             int index = name.indexOf(&#39;/&#39;);</span>
<span class="line-added">+             return typeDesc + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)</span>
<span class="line-added">+                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             return typeDesc + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
          }
      }
  
      /**
       * Returns the component type of this {@code Class}, if it describes
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4317,8 ***</span>
       * or an empty {@link Optional} if one cannot be constructed.
       * @since 12
       */
      @Override
      public Optional&lt;ClassDesc&gt; describeConstable() {
<span class="line-modified">!         return Optional.of(ClassDesc.ofDescriptor(descriptorString()));</span>
<span class="line-modified">!     }</span>
  }
<span class="line-new-header">--- 4430,22 ---</span>
       * or an empty {@link Optional} if one cannot be constructed.
       * @since 12
       */
      @Override
      public Optional&lt;ClassDesc&gt; describeConstable() {
<span class="line-modified">!         Class&lt;?&gt; c = isArray() ? elementType() : this;</span>
<span class="line-modified">!         return c.isHidden() ? Optional.empty()</span>
<span class="line-added">+                             : Optional.of(ClassDesc.ofDescriptor(descriptorString()));</span>
<span class="line-added">+    }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /**</span>
<span class="line-added">+      * Returns {@code true} if and only if the underlying class is a hidden class.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @return {@code true} if and only if this class is a hidden class.</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * @since 15</span>
<span class="line-added">+      * @see MethodHandles.Lookup#defineHiddenClass</span>
<span class="line-added">+      */</span>
<span class="line-added">+     @HotSpotIntrinsicCandidate</span>
<span class="line-added">+     public native boolean isHidden();</span>
<span class="line-added">+ </span>
  }
</pre>
<center><a href="../../../../../hotspot/share/utilities/exceptions.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
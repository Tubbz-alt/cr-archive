<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleNatives.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/AccessibleObject.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 

  28 import jdk.internal.access.SharedSecrets;

  29 import jdk.internal.module.IllegalAccessLogger;
  30 import jdk.internal.org.objectweb.asm.ClassReader;

  31 import jdk.internal.reflect.CallerSensitive;
  32 import jdk.internal.reflect.Reflection;
  33 import jdk.internal.vm.annotation.ForceInline;
  34 import sun.invoke.util.ValueConversions;
  35 import sun.invoke.util.VerifyAccess;
  36 import sun.invoke.util.Wrapper;
  37 import sun.reflect.misc.ReflectUtil;
  38 import sun.security.util.SecurityConstants;
  39 
  40 import java.lang.invoke.LambdaForm.BasicType;
  41 import java.lang.reflect.Constructor;
  42 import java.lang.reflect.Field;
  43 import java.lang.reflect.Member;
  44 import java.lang.reflect.Method;
  45 import java.lang.reflect.Modifier;
  46 import java.lang.reflect.ReflectPermission;
  47 import java.nio.ByteOrder;
<span class="line-removed">  48 import java.security.AccessController;</span>
<span class="line-removed">  49 import java.security.PrivilegedAction;</span>
  50 import java.security.ProtectionDomain;
  51 import java.util.ArrayList;
  52 import java.util.Arrays;
  53 import java.util.BitSet;
  54 import java.util.Iterator;
  55 import java.util.List;
  56 import java.util.Objects;
  57 import java.util.Set;
  58 import java.util.concurrent.ConcurrentHashMap;
  59 import java.util.stream.Collectors;
  60 import java.util.stream.Stream;
  61 
  62 import static java.lang.invoke.MethodHandleImpl.Intrinsic;
  63 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  64 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
  65 import static java.lang.invoke.MethodType.methodType;
  66 
  67 /**
  68  * This class consists exclusively of static methods that operate on or return
  69  * method handles. They fall into several categories:
</pre>
<hr />
<pre>
 202      * {@code null} previous lookup class.
 203      * &lt;p&gt;
 204      * Otherwise, {@code M1} and {@code M2} are two different modules.  This method
 205      * returns a {@code Lookup} on {@code targetClass} that records
 206      * the lookup class of the caller as the new previous lookup class and
 207      * drops {@code MODULE} access from the full privilege access.
 208      *
 209      * @param targetClass the target class
 210      * @param caller the caller lookup object
 211      * @return a lookup object for the target class, with private access
 212      * @throws IllegalArgumentException if {@code targetClass} is a primitive type or void or array class
 213      * @throws NullPointerException if {@code targetClass} or {@code caller} is {@code null}
 214      * @throws SecurityException if denied by the security manager
 215      * @throws IllegalAccessException if any of the other access checks specified above fails
 216      * @since 9
 217      * @spec JPMS
 218      * @see Lookup#dropLookupMode
 219      * @see &lt;a href=&quot;MethodHandles.Lookup.html#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
 220      */
 221     public static Lookup privateLookupIn(Class&lt;?&gt; targetClass, Lookup caller) throws IllegalAccessException {




 222         SecurityManager sm = System.getSecurityManager();
 223         if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
 224         if (targetClass.isPrimitive())
 225             throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
 226         if (targetClass.isArray())
 227             throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
 228         // Ensure that we can reason accurately about private and module access.
 229         if (!caller.hasFullPrivilegeAccess())
 230             throw new IllegalAccessException(&quot;caller does not have PRIVATE and MODULE lookup mode&quot;);
 231 
 232         // previous lookup class is never set if it has MODULE access
 233         assert caller.previousLookupClass() == null;
 234 
 235         Class&lt;?&gt; callerClass = caller.lookupClass();
 236         Module callerModule = callerClass.getModule();  // M1
 237         Module targetModule = targetClass.getModule();  // M2
 238         Class&lt;?&gt; newPreviousClass = null;
 239         int newModes = Lookup.FULL_POWER_MODES;
 240 
 241         if (targetModule != callerModule) {
</pre>
<hr />
<pre>
 245                 String pn = targetClass.getPackageName();
 246                 assert !pn.isEmpty() : &quot;unnamed package cannot be in named module&quot;;
 247                 if (!targetModule.isOpen(pn, callerModule))
 248                     throw new IllegalAccessException(targetModule + &quot; does not open &quot; + pn + &quot; to &quot; + callerModule);
 249             }
 250 
 251             // M2 != M1, set previous lookup class to M1 and drop MODULE access
 252             newPreviousClass = callerClass;
 253             newModes &amp;= ~Lookup.MODULE;
 254         }
 255 
 256         if (!callerModule.isNamed() &amp;&amp; targetModule.isNamed()) {
 257             IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();
 258             if (logger != null) {
 259                 logger.logIfOpenedForIllegalAccess(caller, targetClass);
 260             }
 261         }
 262         return Lookup.newLookup(targetClass, newPreviousClass, newModes);
 263     }
 264 



















































 265     /**
 266      * Performs an unchecked &quot;crack&quot; of a
 267      * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;.
 268      * The result is as if the user had obtained a lookup object capable enough
 269      * to crack the target method handle, called
 270      * {@link java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect}
 271      * on the target to obtain its symbolic reference, and then called
 272      * {@link java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs}
 273      * to resolve the symbolic reference to a member.
 274      * &lt;p&gt;
 275      * If there is a security manager, its {@code checkPermission} method
 276      * is called with a {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} permission.
 277      * @param &lt;T&gt; the desired type of the result, either {@link Member} or a subtype
 278      * @param target a direct method handle to crack into symbolic reference components
 279      * @param expected a class object representing the desired result type {@code T}
 280      * @return a reference to the method, constructor, or field object
 281      * @throws    SecurityException if the caller is not privileged to call {@code setAccessible}
 282      * @throws    NullPointerException if either argument is {@code null}
 283      * @throws    IllegalArgumentException if the target is not a direct method handle
 284      * @throws    ClassCastException if the member is not of the expected type
</pre>
<hr />
<pre>
 500      * do not require any access checks, and are used
 501      * independently of any {@code Lookup} object.
 502      * &lt;p&gt;
 503      * If the desired member is {@code protected}, the usual JVM rules apply,
 504      * including the requirement that the lookup class must either be in the
 505      * same package as the desired member, or must inherit that member.
 506      * (See the Java Virtual Machine Specification, sections {@jvms
 507      * 4.9.2}, {@jvms 5.4.3.5}, and {@jvms 6.4}.)
 508      * In addition, if the desired member is a non-static field or method
 509      * in a different package, the resulting method handle may only be applied
 510      * to objects of the lookup class or one of its subclasses.
 511      * This requirement is enforced by narrowing the type of the leading
 512      * {@code this} parameter from {@code C}
 513      * (which will necessarily be a superclass of the lookup class)
 514      * to the lookup class itself.
 515      * &lt;p&gt;
 516      * The JVM imposes a similar requirement on {@code invokespecial} instruction,
 517      * that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt;
 518      * the current class.  Again, this requirement is enforced by narrowing the
 519      * type of the leading parameter to the resulting method handle.
<span class="line-modified"> 520      * (See the Java Virtual Machine Specification, section {@jmvs 4.10.1.9}.)</span>
 521      * &lt;p&gt;
 522      * The JVM represents constructors and static initializer blocks as internal methods
 523      * with special names ({@code &quot;&lt;init&gt;&quot;} and {@code &quot;&lt;clinit&gt;&quot;}).
 524      * The internal syntax of invocation instructions allows them to refer to such internal
 525      * methods as if they were normal methods, but the JVM bytecode verifier rejects them.
 526      * A lookup of such an internal method will produce a {@code NoSuchMethodException}.
 527      * &lt;p&gt;
 528      * If the relationship between nested types is expressed directly through the
 529      * {@code NestHost} and {@code NestMembers} attributes
 530      * (see the Java Virtual Machine Specification, sections {@jvms
 531      * 4.7.28} and {@jvms 4.7.29}),
 532      * then the associated {@code Lookup} object provides direct access to
 533      * the lookup class and all of its nestmates
 534      * (see {@link java.lang.Class#getNestHost Class.getNestHost}).
 535      * Otherwise, access between nested classes is obtained by the Java compiler creating
 536      * a wrapper method to access a private method of another class in the same nest.
 537      * For example, a nested class {@code C.D}
 538      * can access private members within other related classes such as
 539      * {@code C}, {@code C.D.E}, or {@code C.B},
 540      * but the Java compiler may need to generate wrapper methods in
</pre>
<hr />
<pre>
1383          *  so that it can access only names which can be reached by the original
1384          *  lookup object, and also by the new lookup class.
1385          *  @return the lookup modes, which limit the kinds of access performed by this lookup object
1386          *  @see #in
1387          *  @see #dropLookupMode
1388          *
1389          *  @revised 9
1390          *  @spec JPMS
1391          */
1392         public int lookupModes() {
1393             return allowedModes &amp; ALL_MODES;
1394         }
1395 
1396         /** Embody the current class (the lookupClass) as a lookup class
1397          * for method handle creation.
1398          * Must be called by from a method in this package,
1399          * which in turn is called by a method not in this package.
1400          */
1401         Lookup(Class&lt;?&gt; lookupClass) {
1402             this(lookupClass, null, FULL_POWER_MODES);
<span class="line-removed">1403             // make sure we haven&#39;t accidentally picked up a privileged class:</span>
<span class="line-removed">1404             checkUnprivilegedlookupClass(lookupClass);</span>
1405         }
1406 
1407         private Lookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {
1408             assert prevLookupClass == null || ((allowedModes &amp; MODULE) == 0
1409                     &amp;&amp; prevLookupClass.getModule() != lookupClass.getModule());
1410             assert !lookupClass.isArray() &amp;&amp; !lookupClass.isPrimitive();
1411             this.lookupClass = lookupClass;
1412             this.prevLookupClass = prevLookupClass;
1413             this.allowedModes = allowedModes;
1414         }
1415 
1416         private static Lookup newLookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {
1417             // make sure we haven&#39;t accidentally picked up a privileged class:
1418             checkUnprivilegedlookupClass(lookupClass);
1419             return new Lookup(lookupClass, prevLookupClass, allowedModes);
1420         }
1421 
1422         /**
1423          * Creates a lookup on the specified new lookup class.
1424          * The resulting object will report the specified
</pre>
<hr />
<pre>
1491             if ((this.allowedModes &amp; UNCONDITIONAL) != 0) {
1492                 assert plc == null;
1493                 newModes = UNCONDITIONAL;
1494             } else if (fromModule != targetModule) {
1495                 if (plc != null &amp;&amp; !VerifyAccess.isSameModule(plc, requestedLookupClass)) {
1496                     // allow hopping back and forth between fromModule and plc&#39;s module
1497                     // but not the third module
1498                     newModes = 0;
1499                 }
1500                 // drop MODULE access
1501                 newModes &amp;= ~(MODULE|PACKAGE|PRIVATE|PROTECTED);
1502                 // teleport from this lookup class
1503                 plc = this.lookupClass;
1504             }
1505             if ((newModes &amp; PACKAGE) != 0
1506                 &amp;&amp; !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
1507                 newModes &amp;= ~(PACKAGE|PRIVATE|PROTECTED);
1508             }
1509             // Allow nestmate lookups to be created without special privilege:
1510             if ((newModes &amp; PRIVATE) != 0
<span class="line-modified">1511                 &amp;&amp; !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {</span>
1512                 newModes &amp;= ~(PRIVATE|PROTECTED);
1513             }
1514             if ((newModes &amp; (PUBLIC|UNCONDITIONAL)) != 0
1515                 &amp;&amp; !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, this.prevLookupClass, allowedModes)) {
1516                 // The requested class it not accessible from the lookup class.
1517                 // No permissions.
1518                 newModes = 0;
1519             }
1520             return newLookup(requestedLookupClass, plc, newModes);
1521         }
1522 
1523         /**
1524          * Creates a lookup on the same lookup class which this lookup object
1525          * finds members, but with a lookup mode that has lost the given lookup mode.
1526          * The lookup mode to drop is one of {@link #PUBLIC PUBLIC}, {@link #MODULE
1527          * MODULE}, {@link #PACKAGE PACKAGE}, {@link #PROTECTED PROTECTED},
1528          * {@link #PRIVATE PRIVATE}, or {@link #UNCONDITIONAL UNCONDITIONAL}.
1529          *
1530          * &lt;p&gt; If this lookup is a {@linkplain MethodHandles#publicLookup() public lookup},
1531          * this lookup has {@code UNCONDITIONAL} mode set and it has no other mode set.
</pre>
<hr />
<pre>
1560          * @see MethodHandles#privateLookupIn
1561          * @since 9
1562          */
1563         public Lookup dropLookupMode(int modeToDrop) {
1564             int oldModes = lookupModes();
1565             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED);
1566             switch (modeToDrop) {
1567                 case PUBLIC: newModes &amp;= ~(FULL_POWER_MODES); break;
1568                 case MODULE: newModes &amp;= ~(PACKAGE | PRIVATE); break;
1569                 case PACKAGE: newModes &amp;= ~(PRIVATE); break;
1570                 case PROTECTED:
1571                 case PRIVATE:
1572                 case UNCONDITIONAL: break;
1573                 default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);
1574             }
1575             if (newModes == oldModes) return this;  // return self if no change
1576             return newLookup(lookupClass(), previousLookupClass(), newModes);
1577         }
1578 
1579         /**
<span class="line-modified">1580          * Defines a class to the same class loader and in the same runtime package and</span>

1581          * {@linkplain java.security.ProtectionDomain protection domain} as this lookup&#39;s
<span class="line-modified">1582          * {@linkplain #lookupClass() lookup class}.</span>


1583          *
1584          * &lt;p&gt; The {@linkplain #lookupModes() lookup modes} for this lookup must include
1585          * {@link #PACKAGE PACKAGE} access as default (package) members will be
1586          * accessible to the class. The {@code PACKAGE} lookup mode serves to authenticate
1587          * that the lookup object was created by a caller in the runtime package (or derived
1588          * from a lookup originally created by suitably privileged code to a target class in
1589          * the runtime package). &lt;/p&gt;
1590          *
1591          * &lt;p&gt; The {@code bytes} parameter is the class bytes of a valid class file (as defined
1592          * by the &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;) with a class name in the
1593          * same package as the lookup class. &lt;/p&gt;
1594          *
1595          * &lt;p&gt; This method does not run the class initializer. The class initializer may
1596          * run at a later time, as detailed in section 12.4 of the &lt;em&gt;The Java Language
1597          * Specification&lt;/em&gt;. &lt;/p&gt;
1598          *
1599          * &lt;p&gt; If there is a security manager and this lookup does not have {@linkplain
1600          * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method
1601          * is first called to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;
1602          *
1603          * @param bytes the class bytes
1604          * @return the {@code Class} object for the class


1605          * @throws IllegalArgumentException the bytes are for a class in a different package
1606          * to the lookup class
<span class="line-modified">1607          * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access</span>
<span class="line-modified">1608          * @throws LinkageError if the class is malformed ({@code ClassFormatError}), cannot be</span>
<span class="line-removed">1609          * verified ({@code VerifyError}), is already defined, or another linkage error occurs</span>
1610          * @throws SecurityException if a security manager is present and it
1611          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1612          * @throws NullPointerException if {@code bytes} is {@code null}
1613          * @since 9
1614          * @spec JPMS
1615          * @see Lookup#privateLookupIn
1616          * @see Lookup#dropLookupMode
1617          * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
1618          */
1619         public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {









1620             if (!hasFullPrivilegeAccess()) {
1621                 SecurityManager sm = System.getSecurityManager();
1622                 if (sm != null)
1623                     sm.checkPermission(new RuntimePermission(&quot;defineClass&quot;));
1624             }
<span class="line-modified">1625             if ((lookupModes() &amp; PACKAGE) == 0)</span>
<span class="line-modified">1626                 throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);</span>




















































1627 
<span class="line-modified">1628             // parse class bytes to get class name (in internal form)</span>
<span class="line-modified">1629             bytes = bytes.clone();</span>
<span class="line-modified">1630             String name;</span>






















































































































































































































































































1631             try {
1632                 ClassReader reader = new ClassReader(bytes);
<span class="line-modified">1633                 name = reader.getClassName();</span>












1634             } catch (RuntimeException e) {
1635                 // ASM exceptions are poorly specified
1636                 ClassFormatError cfe = new ClassFormatError();
1637                 cfe.initCause(e);
1638                 throw cfe;
1639             }

1640 
<span class="line-modified">1641             // get package and class name in binary form</span>
<span class="line-modified">1642             String cn, pn;</span>
<span class="line-modified">1643             int index = name.lastIndexOf(&#39;/&#39;);</span>
<span class="line-modified">1644             if (index == -1) {</span>
<span class="line-modified">1645                 cn = name;</span>
<span class="line-modified">1646                 pn = &quot;&quot;;</span>
<span class="line-modified">1647             } else {</span>
<span class="line-modified">1648                 cn = name.replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="line-modified">1649                 pn = cn.substring(0, index);</span>




























































































































1650             }
<span class="line-modified">1651             if (!pn.equals(lookupClass.getPackageName())) {</span>
<span class="line-modified">1652                 throw new IllegalArgumentException(&quot;Class not in same package as lookup class&quot;);</span>




1653             }
1654 
<span class="line-modified">1655             // invoke the class loader&#39;s defineClass method</span>
<span class="line-modified">1656             ClassLoader loader = lookupClass.getClassLoader();</span>
<span class="line-modified">1657             ProtectionDomain pd = (loader != null) ? lookupClassProtectionDomain() : null;</span>
<span class="line-removed">1658             String source = &quot;__Lookup_defineClass__&quot;;</span>
<span class="line-removed">1659             Class&lt;?&gt; clazz = SharedSecrets.getJavaLangAccess().defineClass(loader, cn, bytes, pd, source);</span>
<span class="line-removed">1660             return clazz;</span>
1661         }
1662 
1663         private ProtectionDomain lookupClassProtectionDomain() {
1664             ProtectionDomain pd = cachedProtectionDomain;
1665             if (pd == null) {
<span class="line-modified">1666                 cachedProtectionDomain = pd = protectionDomain(lookupClass);</span>
1667             }
1668             return pd;
1669         }
1670 
<span class="line-removed">1671         private ProtectionDomain protectionDomain(Class&lt;?&gt; clazz) {</span>
<span class="line-removed">1672             PrivilegedAction&lt;ProtectionDomain&gt; pa = clazz::getProtectionDomain;</span>
<span class="line-removed">1673             return AccessController.doPrivileged(pa);</span>
<span class="line-removed">1674         }</span>
<span class="line-removed">1675 </span>
1676         // cached protection domain
1677         private volatile ProtectionDomain cachedProtectionDomain;
1678 
<span class="line-removed">1679 </span>
1680         // Make sure outer class is initialized first.
1681         static { IMPL_NAMES.getClass(); }
1682 
1683         /** Package-private version of lookup which is trusted. */
1684         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, null, TRUSTED);
1685 
1686         /** Version of lookup which is trusted minimally.
1687          *  It can only be used to create method handles to publicly accessible
1688          *  members in packages that are exported unconditionally.
1689          */
1690         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, null, UNCONDITIONAL);
1691 


1692         private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
1693             String name = lookupClass.getName();
1694             if (name.startsWith(&quot;java.lang.invoke.&quot;))
1695                 throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
1696         }
1697 
1698         /**
1699          * Displays the name of the class from which lookups are to be made.
1700          * followed with &quot;/&quot; and the name of the {@linkplain #previousLookupClass()
1701          * previous lookup class} if present.
1702          * (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
1703          * If there are restrictions on the access permitted to this lookup,
1704          * this is indicated by adding a suffix to the class name, consisting
1705          * of a slash and a keyword.  The keyword represents the strongest
1706          * allowed access, and is chosen as follows:
1707          * &lt;ul&gt;
1708          * &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.
1709          * &lt;li&gt;If only unconditional access is allowed, the suffix is &quot;/publicLookup&quot;.
1710          * &lt;li&gt;If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.
1711          * &lt;li&gt;If only public and module access are allowed, the suffix is &quot;/module&quot;.
</pre>
<hr />
<pre>
1732          */
1733         @Override
1734         public String toString() {
1735             String cname = lookupClass.getName();
1736             if (prevLookupClass != null)
1737                 cname += &quot;/&quot; + prevLookupClass.getName();
1738             switch (allowedModes) {
1739             case 0:  // no privileges
1740                 return cname + &quot;/noaccess&quot;;
1741             case UNCONDITIONAL:
1742                 return cname + &quot;/publicLookup&quot;;
1743             case PUBLIC:
1744                 return cname + &quot;/public&quot;;
1745             case PUBLIC|MODULE:
1746                 return cname + &quot;/module&quot;;
1747             case PUBLIC|PACKAGE:
1748             case PUBLIC|MODULE|PACKAGE:
1749                 return cname + &quot;/package&quot;;
1750             case FULL_POWER_MODES &amp; (~PROTECTED):
1751             case FULL_POWER_MODES &amp; ~(PROTECTED|MODULE):
<span class="line-modified">1752                     return cname + &quot;/private&quot;;</span>
1753             case FULL_POWER_MODES:
1754             case FULL_POWER_MODES &amp; (~MODULE):
1755                 return cname;
1756             case TRUSTED:
1757                 return &quot;/trusted&quot;;  // internal only; not exported
1758             default:  // Should not happen, but it&#39;s a bitfield...
1759                 cname = cname + &quot;/&quot; + Integer.toHexString(allowedModes);
1760                 assert(false) : cname;
1761                 return cname;
1762             }
1763         }
1764 
1765         /**
1766          * Produces a method handle for a static method.
1767          * The type of the method handle will be that of the method.
1768          * (Since static methods do not take receivers, there is no
1769          * additional receiver argument inserted into the method handle type,
1770          * as there would be with {@link #findVirtual findVirtual} or {@link #findSpecial findSpecial}.)
1771          * The method and all its argument types must be accessible to the lookup object.
1772          * &lt;p&gt;
</pre>
<hr />
<pre>
2646          * the {@code Field} object&#39;s {@code set} method could return
2647          * normally.  In particular, fields which are both {@code static}
2648          * and {@code final} may never be set.
2649          * &lt;p&gt;
2650          * If the field is {@code static}, and
2651          * if the returned method handle is invoked, the field&#39;s class will
2652          * be initialized, if it has not already been initialized.
2653          * @param f the reflected field
2654          * @return a method handle which can store values into the reflected field
2655          * @throws IllegalAccessException if access checking fails,
2656          *         or if the field is {@code final} and write access
2657          *         is not enabled on the {@code Field} object
2658          * @throws NullPointerException if the argument is null
2659          */
2660         public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
2661             return unreflectField(f, true);
2662         }
2663 
2664         private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {
2665             MemberName field = new MemberName(f, isSetter);
<span class="line-modified">2666             if (isSetter &amp;&amp; field.isStatic() &amp;&amp; field.isFinal())</span>
<span class="line-modified">2667                 throw field.makeAccessException(&quot;static final field has no write access&quot;, this);</span>





2668             assert(isSetter
2669                     ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())
2670                     : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));
2671             @SuppressWarnings(&quot;deprecation&quot;)
2672             Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;
2673             return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);
2674         }
2675 
2676         /**
2677          * Produces a VarHandle giving access to a reflected field {@code f}
2678          * of type {@code T} declared in a class of type {@code R}.
2679          * The VarHandle&#39;s variable type is {@code T}.
2680          * If the field is non-static the VarHandle has one coordinate type,
2681          * {@code R}.  Otherwise, the field is static, and the VarHandle has no
2682          * coordinate types.
2683          * &lt;p&gt;
2684          * Access checking is performed immediately on behalf of the lookup
2685          * class, regardless of the value of the field&#39;s {@code accessible}
2686          * flag.
2687          * &lt;p&gt;
</pre>
<hr />
<pre>
3210             if (!putField.isFinal()) {
3211                 // A VarHandle does not support updates to final fields, any
3212                 // such VarHandle to a final field will be read-only and
3213                 // therefore the following write-based accessibility checks are
3214                 // only required for non-final fields
3215                 checkField(putRefKind, refc, putField);
3216                 if (checkSecurity)
3217                     checkSecurityManager(refc, putField);
3218             }
3219 
3220             boolean doRestrict = (MethodHandleNatives.refKindHasReceiver(getRefKind) &amp;&amp;
3221                                   restrictProtectedReceiver(getField));
3222             if (doRestrict) {
3223                 assert !getField.isStatic();
3224                 // receiver type of VarHandle is too wide; narrow to caller
3225                 if (!getField.getDeclaringClass().isAssignableFrom(lookupClass())) {
3226                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3227                 }
3228                 refc = lookupClass();
3229             }
<span class="line-modified">3230             boolean isWriteAllowedOnFinalFields = this.allowedModes == TRUSTED;</span>
<span class="line-modified">3231             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(), isWriteAllowedOnFinalFields);</span>
3232         }
3233         /** Check access and get the requested constructor. */
3234         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3235             final boolean checkSecurity = true;
3236             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3237         }
3238         /** Check access and get the requested constructor, eliding security manager checks. */
3239         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3240             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3241             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3242         }
3243         /** Common code for all constructors; do not call directly except from immediately above. */
3244         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3245                                                   boolean checkSecurity) throws IllegalAccessException {
3246             assert(ctor.isObjectConstructor());
3247             checkAccess(REF_newInvokeSpecial, refc, ctor);
3248             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3249             if (checkSecurity)
3250                 checkSecurityManager(refc, ctor);
3251             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
</pre>
</td>
<td>
<hr />
<pre>
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
<span class="line-added">  28 import jdk.internal.access.JavaLangAccess;</span>
  29 import jdk.internal.access.SharedSecrets;
<span class="line-added">  30 import jdk.internal.misc.VM;</span>
  31 import jdk.internal.module.IllegalAccessLogger;
  32 import jdk.internal.org.objectweb.asm.ClassReader;
<span class="line-added">  33 import jdk.internal.org.objectweb.asm.Opcodes;</span>
  34 import jdk.internal.reflect.CallerSensitive;
  35 import jdk.internal.reflect.Reflection;
  36 import jdk.internal.vm.annotation.ForceInline;
  37 import sun.invoke.util.ValueConversions;
  38 import sun.invoke.util.VerifyAccess;
  39 import sun.invoke.util.Wrapper;
  40 import sun.reflect.misc.ReflectUtil;
  41 import sun.security.util.SecurityConstants;
  42 
  43 import java.lang.invoke.LambdaForm.BasicType;
  44 import java.lang.reflect.Constructor;
  45 import java.lang.reflect.Field;
  46 import java.lang.reflect.Member;
  47 import java.lang.reflect.Method;
  48 import java.lang.reflect.Modifier;
  49 import java.lang.reflect.ReflectPermission;
  50 import java.nio.ByteOrder;


  51 import java.security.ProtectionDomain;
  52 import java.util.ArrayList;
  53 import java.util.Arrays;
  54 import java.util.BitSet;
  55 import java.util.Iterator;
  56 import java.util.List;
  57 import java.util.Objects;
  58 import java.util.Set;
  59 import java.util.concurrent.ConcurrentHashMap;
  60 import java.util.stream.Collectors;
  61 import java.util.stream.Stream;
  62 
  63 import static java.lang.invoke.MethodHandleImpl.Intrinsic;
  64 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  65 import static java.lang.invoke.MethodHandleStatics.newIllegalArgumentException;
  66 import static java.lang.invoke.MethodType.methodType;
  67 
  68 /**
  69  * This class consists exclusively of static methods that operate on or return
  70  * method handles. They fall into several categories:
</pre>
<hr />
<pre>
 203      * {@code null} previous lookup class.
 204      * &lt;p&gt;
 205      * Otherwise, {@code M1} and {@code M2} are two different modules.  This method
 206      * returns a {@code Lookup} on {@code targetClass} that records
 207      * the lookup class of the caller as the new previous lookup class and
 208      * drops {@code MODULE} access from the full privilege access.
 209      *
 210      * @param targetClass the target class
 211      * @param caller the caller lookup object
 212      * @return a lookup object for the target class, with private access
 213      * @throws IllegalArgumentException if {@code targetClass} is a primitive type or void or array class
 214      * @throws NullPointerException if {@code targetClass} or {@code caller} is {@code null}
 215      * @throws SecurityException if denied by the security manager
 216      * @throws IllegalAccessException if any of the other access checks specified above fails
 217      * @since 9
 218      * @spec JPMS
 219      * @see Lookup#dropLookupMode
 220      * @see &lt;a href=&quot;MethodHandles.Lookup.html#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
 221      */
 222     public static Lookup privateLookupIn(Class&lt;?&gt; targetClass, Lookup caller) throws IllegalAccessException {
<span class="line-added"> 223         if (caller.allowedModes == Lookup.TRUSTED) {</span>
<span class="line-added"> 224             return new Lookup(targetClass);</span>
<span class="line-added"> 225         }</span>
<span class="line-added"> 226 </span>
 227         SecurityManager sm = System.getSecurityManager();
 228         if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
 229         if (targetClass.isPrimitive())
 230             throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
 231         if (targetClass.isArray())
 232             throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);
 233         // Ensure that we can reason accurately about private and module access.
 234         if (!caller.hasFullPrivilegeAccess())
 235             throw new IllegalAccessException(&quot;caller does not have PRIVATE and MODULE lookup mode&quot;);
 236 
 237         // previous lookup class is never set if it has MODULE access
 238         assert caller.previousLookupClass() == null;
 239 
 240         Class&lt;?&gt; callerClass = caller.lookupClass();
 241         Module callerModule = callerClass.getModule();  // M1
 242         Module targetModule = targetClass.getModule();  // M2
 243         Class&lt;?&gt; newPreviousClass = null;
 244         int newModes = Lookup.FULL_POWER_MODES;
 245 
 246         if (targetModule != callerModule) {
</pre>
<hr />
<pre>
 250                 String pn = targetClass.getPackageName();
 251                 assert !pn.isEmpty() : &quot;unnamed package cannot be in named module&quot;;
 252                 if (!targetModule.isOpen(pn, callerModule))
 253                     throw new IllegalAccessException(targetModule + &quot; does not open &quot; + pn + &quot; to &quot; + callerModule);
 254             }
 255 
 256             // M2 != M1, set previous lookup class to M1 and drop MODULE access
 257             newPreviousClass = callerClass;
 258             newModes &amp;= ~Lookup.MODULE;
 259         }
 260 
 261         if (!callerModule.isNamed() &amp;&amp; targetModule.isNamed()) {
 262             IllegalAccessLogger logger = IllegalAccessLogger.illegalAccessLogger();
 263             if (logger != null) {
 264                 logger.logIfOpenedForIllegalAccess(caller, targetClass);
 265             }
 266         }
 267         return Lookup.newLookup(targetClass, newPreviousClass, newModes);
 268     }
 269 
<span class="line-added"> 270     /**</span>
<span class="line-added"> 271      * Returns the &lt;em&gt;class data&lt;/em&gt; associated with the lookup class</span>
<span class="line-added"> 272      * of the specified {@code Lookup} object, or {@code null}.</span>
<span class="line-added"> 273      *</span>
<span class="line-added"> 274      * &lt;p&gt; Classes can be created with class data by calling</span>
<span class="line-added"> 275      * {@link Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)</span>
<span class="line-added"> 276      * Lookup::defineHiddenClassWithClassData}.</span>
<span class="line-added"> 277      * A hidden class with a class data behaves as if the hidden class</span>
<span class="line-added"> 278      * has a private static final unnamed field pre-initialized with</span>
<span class="line-added"> 279      * the class data and this method is equivalent as if calling</span>
<span class="line-added"> 280      * {@link ConstantBootstraps#getStaticFinal(Lookup, String, Class)} to</span>
<span class="line-added"> 281      * obtain the value of such field corresponding to the class data.</span>
<span class="line-added"> 282      *</span>
<span class="line-added"> 283      * &lt;p&gt; The {@linkplain Lookup#lookupModes() lookup modes} for this lookup</span>
<span class="line-added"> 284      * must have {@link Lookup#ORIGINAL ORIGINAL} access in order to retrieve</span>
<span class="line-added"> 285      * the class data.</span>
<span class="line-added"> 286      *</span>
<span class="line-added"> 287      * @apiNote</span>
<span class="line-added"> 288      * This method can be called as a bootstrap method for a dynamically computed</span>
<span class="line-added"> 289      * constant.  A framework can create a hidden class with class data, for</span>
<span class="line-added"> 290      * example that can be {@code List.of(o1, o2, o3....)} containing more than</span>
<span class="line-added"> 291      * one live object.  The class data is accessible only to the lookup object</span>
<span class="line-added"> 292      * created by the original caller but inaccessible to other members</span>
<span class="line-added"> 293      * in the same nest.  If a framework passes security sensitive live objects</span>
<span class="line-added"> 294      * to a hidden class via class data, it is recommended to load the value</span>
<span class="line-added"> 295      * of class data as a dynamically computed constant instead of storing</span>
<span class="line-added"> 296      * the live objects in private fields which are accessible to other</span>
<span class="line-added"> 297      * nestmates.</span>
<span class="line-added"> 298      *</span>
<span class="line-added"> 299      * @param &lt;T&gt; the type to cast the class data object to</span>
<span class="line-added"> 300      * @param caller the lookup context describing the class performing the</span>
<span class="line-added"> 301      * operation (normally stacked by the JVM)</span>
<span class="line-added"> 302      * @param name ignored</span>
<span class="line-added"> 303      * @param type the type of the class data</span>
<span class="line-added"> 304      * @return the value of the class data if present in the lookup class;</span>
<span class="line-added"> 305      * otherwise {@code null}</span>
<span class="line-added"> 306      * @throws IllegalAccessException if the lookup context does not have</span>
<span class="line-added"> 307      * original caller access</span>
<span class="line-added"> 308      * @throws ClassCastException if the class data cannot be converted to</span>
<span class="line-added"> 309      * the specified {@code type}</span>
<span class="line-added"> 310      * @see Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)</span>
<span class="line-added"> 311      * @since 15</span>
<span class="line-added"> 312      */</span>
<span class="line-added"> 313     static &lt;T&gt; T classData(Lookup caller, String name, Class&lt;T&gt; type) throws IllegalAccessException {</span>
<span class="line-added"> 314         if (!caller.hasFullPrivilegeAccess()) {</span>
<span class="line-added"> 315             throw new IllegalAccessException(caller + &quot; does not have full privilege access&quot;);</span>
<span class="line-added"> 316         }</span>
<span class="line-added"> 317         Object classData = MethodHandleNatives.classData(caller.lookupClass);</span>
<span class="line-added"> 318         return type.cast(classData);</span>
<span class="line-added"> 319     }</span>
<span class="line-added"> 320 </span>
 321     /**
 322      * Performs an unchecked &quot;crack&quot; of a
 323      * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;.
 324      * The result is as if the user had obtained a lookup object capable enough
 325      * to crack the target method handle, called
 326      * {@link java.lang.invoke.MethodHandles.Lookup#revealDirect Lookup.revealDirect}
 327      * on the target to obtain its symbolic reference, and then called
 328      * {@link java.lang.invoke.MethodHandleInfo#reflectAs MethodHandleInfo.reflectAs}
 329      * to resolve the symbolic reference to a member.
 330      * &lt;p&gt;
 331      * If there is a security manager, its {@code checkPermission} method
 332      * is called with a {@code ReflectPermission(&quot;suppressAccessChecks&quot;)} permission.
 333      * @param &lt;T&gt; the desired type of the result, either {@link Member} or a subtype
 334      * @param target a direct method handle to crack into symbolic reference components
 335      * @param expected a class object representing the desired result type {@code T}
 336      * @return a reference to the method, constructor, or field object
 337      * @throws    SecurityException if the caller is not privileged to call {@code setAccessible}
 338      * @throws    NullPointerException if either argument is {@code null}
 339      * @throws    IllegalArgumentException if the target is not a direct method handle
 340      * @throws    ClassCastException if the member is not of the expected type
</pre>
<hr />
<pre>
 556      * do not require any access checks, and are used
 557      * independently of any {@code Lookup} object.
 558      * &lt;p&gt;
 559      * If the desired member is {@code protected}, the usual JVM rules apply,
 560      * including the requirement that the lookup class must either be in the
 561      * same package as the desired member, or must inherit that member.
 562      * (See the Java Virtual Machine Specification, sections {@jvms
 563      * 4.9.2}, {@jvms 5.4.3.5}, and {@jvms 6.4}.)
 564      * In addition, if the desired member is a non-static field or method
 565      * in a different package, the resulting method handle may only be applied
 566      * to objects of the lookup class or one of its subclasses.
 567      * This requirement is enforced by narrowing the type of the leading
 568      * {@code this} parameter from {@code C}
 569      * (which will necessarily be a superclass of the lookup class)
 570      * to the lookup class itself.
 571      * &lt;p&gt;
 572      * The JVM imposes a similar requirement on {@code invokespecial} instruction,
 573      * that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt;
 574      * the current class.  Again, this requirement is enforced by narrowing the
 575      * type of the leading parameter to the resulting method handle.
<span class="line-modified"> 576      * (See the Java Virtual Machine Specification, section {@jvms 4.10.1.9}.)</span>
 577      * &lt;p&gt;
 578      * The JVM represents constructors and static initializer blocks as internal methods
 579      * with special names ({@code &quot;&lt;init&gt;&quot;} and {@code &quot;&lt;clinit&gt;&quot;}).
 580      * The internal syntax of invocation instructions allows them to refer to such internal
 581      * methods as if they were normal methods, but the JVM bytecode verifier rejects them.
 582      * A lookup of such an internal method will produce a {@code NoSuchMethodException}.
 583      * &lt;p&gt;
 584      * If the relationship between nested types is expressed directly through the
 585      * {@code NestHost} and {@code NestMembers} attributes
 586      * (see the Java Virtual Machine Specification, sections {@jvms
 587      * 4.7.28} and {@jvms 4.7.29}),
 588      * then the associated {@code Lookup} object provides direct access to
 589      * the lookup class and all of its nestmates
 590      * (see {@link java.lang.Class#getNestHost Class.getNestHost}).
 591      * Otherwise, access between nested classes is obtained by the Java compiler creating
 592      * a wrapper method to access a private method of another class in the same nest.
 593      * For example, a nested class {@code C.D}
 594      * can access private members within other related classes such as
 595      * {@code C}, {@code C.D.E}, or {@code C.B},
 596      * but the Java compiler may need to generate wrapper methods in
</pre>
<hr />
<pre>
1439          *  so that it can access only names which can be reached by the original
1440          *  lookup object, and also by the new lookup class.
1441          *  @return the lookup modes, which limit the kinds of access performed by this lookup object
1442          *  @see #in
1443          *  @see #dropLookupMode
1444          *
1445          *  @revised 9
1446          *  @spec JPMS
1447          */
1448         public int lookupModes() {
1449             return allowedModes &amp; ALL_MODES;
1450         }
1451 
1452         /** Embody the current class (the lookupClass) as a lookup class
1453          * for method handle creation.
1454          * Must be called by from a method in this package,
1455          * which in turn is called by a method not in this package.
1456          */
1457         Lookup(Class&lt;?&gt; lookupClass) {
1458             this(lookupClass, null, FULL_POWER_MODES);


1459         }
1460 
1461         private Lookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {
1462             assert prevLookupClass == null || ((allowedModes &amp; MODULE) == 0
1463                     &amp;&amp; prevLookupClass.getModule() != lookupClass.getModule());
1464             assert !lookupClass.isArray() &amp;&amp; !lookupClass.isPrimitive();
1465             this.lookupClass = lookupClass;
1466             this.prevLookupClass = prevLookupClass;
1467             this.allowedModes = allowedModes;
1468         }
1469 
1470         private static Lookup newLookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {
1471             // make sure we haven&#39;t accidentally picked up a privileged class:
1472             checkUnprivilegedlookupClass(lookupClass);
1473             return new Lookup(lookupClass, prevLookupClass, allowedModes);
1474         }
1475 
1476         /**
1477          * Creates a lookup on the specified new lookup class.
1478          * The resulting object will report the specified
</pre>
<hr />
<pre>
1545             if ((this.allowedModes &amp; UNCONDITIONAL) != 0) {
1546                 assert plc == null;
1547                 newModes = UNCONDITIONAL;
1548             } else if (fromModule != targetModule) {
1549                 if (plc != null &amp;&amp; !VerifyAccess.isSameModule(plc, requestedLookupClass)) {
1550                     // allow hopping back and forth between fromModule and plc&#39;s module
1551                     // but not the third module
1552                     newModes = 0;
1553                 }
1554                 // drop MODULE access
1555                 newModes &amp;= ~(MODULE|PACKAGE|PRIVATE|PROTECTED);
1556                 // teleport from this lookup class
1557                 plc = this.lookupClass;
1558             }
1559             if ((newModes &amp; PACKAGE) != 0
1560                 &amp;&amp; !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
1561                 newModes &amp;= ~(PACKAGE|PRIVATE|PROTECTED);
1562             }
1563             // Allow nestmate lookups to be created without special privilege:
1564             if ((newModes &amp; PRIVATE) != 0
<span class="line-modified">1565                     &amp;&amp; !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {</span>
1566                 newModes &amp;= ~(PRIVATE|PROTECTED);
1567             }
1568             if ((newModes &amp; (PUBLIC|UNCONDITIONAL)) != 0
1569                 &amp;&amp; !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, this.prevLookupClass, allowedModes)) {
1570                 // The requested class it not accessible from the lookup class.
1571                 // No permissions.
1572                 newModes = 0;
1573             }
1574             return newLookup(requestedLookupClass, plc, newModes);
1575         }
1576 
1577         /**
1578          * Creates a lookup on the same lookup class which this lookup object
1579          * finds members, but with a lookup mode that has lost the given lookup mode.
1580          * The lookup mode to drop is one of {@link #PUBLIC PUBLIC}, {@link #MODULE
1581          * MODULE}, {@link #PACKAGE PACKAGE}, {@link #PROTECTED PROTECTED},
1582          * {@link #PRIVATE PRIVATE}, or {@link #UNCONDITIONAL UNCONDITIONAL}.
1583          *
1584          * &lt;p&gt; If this lookup is a {@linkplain MethodHandles#publicLookup() public lookup},
1585          * this lookup has {@code UNCONDITIONAL} mode set and it has no other mode set.
</pre>
<hr />
<pre>
1614          * @see MethodHandles#privateLookupIn
1615          * @since 9
1616          */
1617         public Lookup dropLookupMode(int modeToDrop) {
1618             int oldModes = lookupModes();
1619             int newModes = oldModes &amp; ~(modeToDrop | PROTECTED);
1620             switch (modeToDrop) {
1621                 case PUBLIC: newModes &amp;= ~(FULL_POWER_MODES); break;
1622                 case MODULE: newModes &amp;= ~(PACKAGE | PRIVATE); break;
1623                 case PACKAGE: newModes &amp;= ~(PRIVATE); break;
1624                 case PROTECTED:
1625                 case PRIVATE:
1626                 case UNCONDITIONAL: break;
1627                 default: throw new IllegalArgumentException(modeToDrop + &quot; is not a valid mode to drop&quot;);
1628             }
1629             if (newModes == oldModes) return this;  // return self if no change
1630             return newLookup(lookupClass(), previousLookupClass(), newModes);
1631         }
1632 
1633         /**
<span class="line-modified">1634          * Creates and links a class or interface from {@code bytes}</span>
<span class="line-added">1635          * with the same class loader and in the same runtime package and</span>
1636          * {@linkplain java.security.ProtectionDomain protection domain} as this lookup&#39;s
<span class="line-modified">1637          * {@linkplain #lookupClass() lookup class} as if calling</span>
<span class="line-added">1638          * {@link ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)</span>
<span class="line-added">1639          * ClassLoader::defineClass}.</span>
1640          *
1641          * &lt;p&gt; The {@linkplain #lookupModes() lookup modes} for this lookup must include
1642          * {@link #PACKAGE PACKAGE} access as default (package) members will be
1643          * accessible to the class. The {@code PACKAGE} lookup mode serves to authenticate
1644          * that the lookup object was created by a caller in the runtime package (or derived
1645          * from a lookup originally created by suitably privileged code to a target class in
1646          * the runtime package). &lt;/p&gt;
1647          *
1648          * &lt;p&gt; The {@code bytes} parameter is the class bytes of a valid class file (as defined
1649          * by the &lt;em&gt;The Java Virtual Machine Specification&lt;/em&gt;) with a class name in the
1650          * same package as the lookup class. &lt;/p&gt;
1651          *
1652          * &lt;p&gt; This method does not run the class initializer. The class initializer may
1653          * run at a later time, as detailed in section 12.4 of the &lt;em&gt;The Java Language
1654          * Specification&lt;/em&gt;. &lt;/p&gt;
1655          *
1656          * &lt;p&gt; If there is a security manager and this lookup does not have {@linkplain
1657          * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method
1658          * is first called to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;
1659          *
1660          * @param bytes the class bytes
1661          * @return the {@code Class} object for the class
<span class="line-added">1662          * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access</span>
<span class="line-added">1663          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure</span>
1664          * @throws IllegalArgumentException the bytes are for a class in a different package
1665          * to the lookup class
<span class="line-modified">1666          * @throws VerifyError if the newly created class cannot be verified</span>
<span class="line-modified">1667          * @throws LinkageError if the newly created class cannot be linked for any other reason</span>

1668          * @throws SecurityException if a security manager is present and it
1669          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
1670          * @throws NullPointerException if {@code bytes} is {@code null}
1671          * @since 9
1672          * @spec JPMS
1673          * @see Lookup#privateLookupIn
1674          * @see Lookup#dropLookupMode
1675          * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
1676          */
1677         public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {
<span class="line-added">1678             ensureDefineClassPermission();</span>
<span class="line-added">1679             if ((lookupModes() &amp; PACKAGE) == 0)</span>
<span class="line-added">1680                 throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);</span>
<span class="line-added">1681             return makeClassDefiner(bytes.clone()).defineClass(false);</span>
<span class="line-added">1682         }</span>
<span class="line-added">1683 </span>
<span class="line-added">1684         private void ensureDefineClassPermission() {</span>
<span class="line-added">1685             if (allowedModes == TRUSTED)  return;</span>
<span class="line-added">1686 </span>
1687             if (!hasFullPrivilegeAccess()) {
1688                 SecurityManager sm = System.getSecurityManager();
1689                 if (sm != null)
1690                     sm.checkPermission(new RuntimePermission(&quot;defineClass&quot;));
1691             }
<span class="line-modified">1692         }</span>
<span class="line-modified">1693 </span>
<span class="line-added">1694         /**</span>
<span class="line-added">1695          * The set of class options that specify whether a hidden class created by</span>
<span class="line-added">1696          * {@link Lookup#defineHiddenClass(byte[], boolean, ClassOption...)</span>
<span class="line-added">1697          * Lookup::defineHiddenClass} method is dynamically added as a new member</span>
<span class="line-added">1698          * to the nest of a lookup class and/or whether a hidden class has</span>
<span class="line-added">1699          * a strong relationship with the class loader marked as its defining loader.</span>
<span class="line-added">1700          *</span>
<span class="line-added">1701          * @since 15</span>
<span class="line-added">1702          */</span>
<span class="line-added">1703         public enum ClassOption {</span>
<span class="line-added">1704             /**</span>
<span class="line-added">1705              * Specifies that a hidden class be added to {@linkplain Class#getNestHost nest}</span>
<span class="line-added">1706              * of a lookup class as a nestmate.</span>
<span class="line-added">1707              *</span>
<span class="line-added">1708              * &lt;p&gt; A hidden nestmate class has access to the private members of all</span>
<span class="line-added">1709              * classes and interfaces in the same nest.</span>
<span class="line-added">1710              *</span>
<span class="line-added">1711              * @see Class#getNestHost()</span>
<span class="line-added">1712              */</span>
<span class="line-added">1713             NESTMATE(NESTMATE_CLASS),</span>
<span class="line-added">1714 </span>
<span class="line-added">1715             /**</span>
<span class="line-added">1716              * Specifies that a hidden class has a &lt;em&gt;strong&lt;/em&gt;</span>
<span class="line-added">1717              * relationship with the class loader marked as its defining loader,</span>
<span class="line-added">1718              * as a normal class or interface has with its own defining loader.</span>
<span class="line-added">1719              * This means that the hidden class may be unloaded if and only if</span>
<span class="line-added">1720              * its defining loader is not reachable and thus may be reclaimed</span>
<span class="line-added">1721              * by a garbage collector (JLS 12.7).</span>
<span class="line-added">1722              *</span>
<span class="line-added">1723              * &lt;p&gt; By default, a hidden class or interface may be unloaded</span>
<span class="line-added">1724              * even if the class loader that is marked as its defining loader is</span>
<span class="line-added">1725              * &lt;a href=&quot;../ref/package.html#reachability&quot;&gt;reachable&lt;/a&gt;.</span>
<span class="line-added">1726 </span>
<span class="line-added">1727              *</span>
<span class="line-added">1728              * @jls 12.7 Unloading of Classes and Interfaces</span>
<span class="line-added">1729              */</span>
<span class="line-added">1730             STRONG(STRONG_LOADER_LINK);</span>
<span class="line-added">1731 </span>
<span class="line-added">1732             /* the flag value is used by VM at define class time */</span>
<span class="line-added">1733             private final int flag;</span>
<span class="line-added">1734             ClassOption(int flag) {</span>
<span class="line-added">1735                 this.flag = flag;</span>
<span class="line-added">1736             }</span>
<span class="line-added">1737 </span>
<span class="line-added">1738             static int optionsToFlag(Set&lt;ClassOption&gt; options) {</span>
<span class="line-added">1739                 int flags = 0;</span>
<span class="line-added">1740                 for (ClassOption cp : options) {</span>
<span class="line-added">1741                     flags |= cp.flag;</span>
<span class="line-added">1742                 }</span>
<span class="line-added">1743                 return flags;</span>
<span class="line-added">1744             }</span>
<span class="line-added">1745         }</span>
1746 
<span class="line-modified">1747         /**</span>
<span class="line-modified">1748          * Creates a &lt;em&gt;hidden&lt;/em&gt; class or interface from {@code bytes},</span>
<span class="line-modified">1749          * returning a {@code Lookup} on the newly created class or interface.</span>
<span class="line-added">1750          *</span>
<span class="line-added">1751          * &lt;p&gt; Ordinarily, a class or interface {@code C} is created by a class loader,</span>
<span class="line-added">1752          * which either defines {@code C} directly or delegates to another class loader.</span>
<span class="line-added">1753          * A class loader defines {@code C} directly by invoking</span>
<span class="line-added">1754          * {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)</span>
<span class="line-added">1755          * ClassLoader::defineClass}, which causes the Java Virtual Machine</span>
<span class="line-added">1756          * to derive {@code C} from a purported representation in {@code class} file format.</span>
<span class="line-added">1757          * In situations where use of a class loader is undesirable, a class or interface</span>
<span class="line-added">1758          * {@code C} can be created by this method instead. This method is capable of</span>
<span class="line-added">1759          * defining {@code C}, and thereby creating it, without invoking</span>
<span class="line-added">1760          * {@code ClassLoader::defineClass}.</span>
<span class="line-added">1761          * Instead, this method defines {@code C} as if by arranging for</span>
<span class="line-added">1762          * the Java Virtual Machine to derive a nonarray class or interface {@code C}</span>
<span class="line-added">1763          * from a purported representation in {@code class} file format</span>
<span class="line-added">1764          * using the following rules:</span>
<span class="line-added">1765          *</span>
<span class="line-added">1766          * &lt;ol&gt;</span>
<span class="line-added">1767          * &lt;li&gt; The {@linkplain #lookupModes() lookup modes} for this {@code Lookup}</span>
<span class="line-added">1768          * must include {@linkplain #hasFullPrivilegeAccess() full privilege} access.</span>
<span class="line-added">1769          * This level of access is needed to create {@code C} in the module</span>
<span class="line-added">1770          * of the lookup class of this {@code Lookup}.&lt;/li&gt;</span>
<span class="line-added">1771          *</span>
<span class="line-added">1772          * &lt;li&gt; The purported representation in {@code bytes} must be a {@code ClassFile}</span>
<span class="line-added">1773          * structure of a supported major and minor version. The major and minor version</span>
<span class="line-added">1774          * may differ from the {@code class} file version of the lookup class of this</span>
<span class="line-added">1775          * {@code Lookup}.&lt;/li&gt;</span>
<span class="line-added">1776          *</span>
<span class="line-added">1777          * &lt;li&gt; The value of {@code this_class} must be a valid index in the</span>
<span class="line-added">1778          * {@code constant_pool} table, and the entry at that index must be a valid</span>
<span class="line-added">1779          * {@code CONSTANT_Class_info} structure. Let {@code N} be the binary name</span>
<span class="line-added">1780          * encoded in internal form that is specified by this structure. {@code N} must</span>
<span class="line-added">1781          * denote a class or interface in the same package as the lookup class.&lt;/li&gt;</span>
<span class="line-added">1782          *</span>
<span class="line-added">1783          * &lt;li&gt; Let {@code CN} be the string {@code N + &quot;.&quot; + &lt;suffix&gt;},</span>
<span class="line-added">1784          * where {@code &lt;suffix&gt;} is an unqualified name.</span>
<span class="line-added">1785          *</span>
<span class="line-added">1786          * &lt;p&gt; Let {@code newBytes} be the {@code ClassFile} structure given by</span>
<span class="line-added">1787          * {@code bytes} with an additional entry in the {@code constant_pool} table,</span>
<span class="line-added">1788          * indicating a {@code CONSTANT_Utf8_info} structure for {@code CN}, and</span>
<span class="line-added">1789          * where the {@code CONSTANT_Class_info} structure indicated by {@code this_class}</span>
<span class="line-added">1790          * refers to the new {@code CONSTANT_Utf8_info} structure.</span>
<span class="line-added">1791          *</span>
<span class="line-added">1792          * &lt;p&gt; Let {@code L} be the defining class loader of the lookup class of this {@code Lookup}.</span>
<span class="line-added">1793          *</span>
<span class="line-added">1794          * &lt;p&gt; {@code C} is derived with name {@code CN}, class loader {@code L}, and</span>
<span class="line-added">1795          * purported representation {@code newBytes} as if by the rules of JVMS {@jvms 5.3.5},</span>
<span class="line-added">1796          * with the following adjustments:</span>
<span class="line-added">1797          * &lt;ul&gt;</span>
<span class="line-added">1798          * &lt;li&gt; The constant indicated by {@code this_class} is permitted to specify a name</span>
<span class="line-added">1799          * that includes a single {@code &quot;.&quot;} character, even though this is not a valid</span>
<span class="line-added">1800          * binary class or interface name in internal form.&lt;/li&gt;</span>
<span class="line-added">1801          *</span>
<span class="line-added">1802          * &lt;li&gt; The Java Virtual Machine marks {@code L} as the defining class loader of {@code C},</span>
<span class="line-added">1803          * but no class loader is recorded as an initiating class loader of {@code C}.&lt;/li&gt;</span>
<span class="line-added">1804          *</span>
<span class="line-added">1805          * &lt;li&gt; {@code C} is considered to have the same runtime</span>
<span class="line-added">1806          * {@linkplain Class#getPackage() package}, {@linkplain Class#getModule() module}</span>
<span class="line-added">1807          * and {@linkplain java.security.ProtectionDomain protection domain}</span>
<span class="line-added">1808          * as the lookup class of this {@code Lookup}.</span>
<span class="line-added">1809          * &lt;li&gt; Let {@code GN} be the binary name obtained by taking {@code N}</span>
<span class="line-added">1810          * (a binary name encoded in internal form) and replacing ASCII forward slashes with</span>
<span class="line-added">1811          * ASCII periods. For the instance of {@link java.lang.Class} representing {@code C}:</span>
<span class="line-added">1812          * &lt;ul&gt;</span>
<span class="line-added">1813          * &lt;li&gt; {@link Class#getName()} returns the string {@code GN + &quot;/&quot; + &lt;suffix&gt;},</span>
<span class="line-added">1814          *      even though this is not a valid binary class or interface name.&lt;/li&gt;</span>
<span class="line-added">1815          * &lt;li&gt; {@link Class#descriptorString()} returns the string</span>
<span class="line-added">1816          *      {@code &quot;L&quot; + N + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;},</span>
<span class="line-added">1817          *      even though this is not a valid type descriptor name.&lt;/li&gt;</span>
<span class="line-added">1818          * &lt;li&gt; {@link Class#describeConstable()} returns an empty optional as {@code C}</span>
<span class="line-added">1819          *      cannot be described in {@linkplain java.lang.constant.ClassDesc nominal form}.&lt;/li&gt;</span>
<span class="line-added">1820          * &lt;/ul&gt;</span>
<span class="line-added">1821          * &lt;/ul&gt;</span>
<span class="line-added">1822          * &lt;/li&gt;</span>
<span class="line-added">1823          * &lt;/ol&gt;</span>
<span class="line-added">1824          *</span>
<span class="line-added">1825          * &lt;p&gt; After {@code C} is derived, it is linked by the Java Virtual Machine.</span>
<span class="line-added">1826          * Linkage occurs as specified in JVMS {@jvms 5.4.3}, with the following adjustments:</span>
<span class="line-added">1827          * &lt;ul&gt;</span>
<span class="line-added">1828          * &lt;li&gt; During verification, whenever it is necessary to load the class named</span>
<span class="line-added">1829          * {@code CN}, the attempt succeeds, producing class {@code C}. No request is</span>
<span class="line-added">1830          * made of any class loader.&lt;/li&gt;</span>
<span class="line-added">1831          *</span>
<span class="line-added">1832          * &lt;li&gt; On any attempt to resolve the entry in the run-time constant pool indicated</span>
<span class="line-added">1833          * by {@code this_class}, the symbolic reference is considered to be resolved to</span>
<span class="line-added">1834          * {@code C} and resolution always succeeds immediately.&lt;/li&gt;</span>
<span class="line-added">1835          * &lt;/ul&gt;</span>
<span class="line-added">1836          *</span>
<span class="line-added">1837          * &lt;p&gt; If the {@code initialize} parameter is {@code true},</span>
<span class="line-added">1838          * then {@code C} is initialized by the Java Virtual Machine.</span>
<span class="line-added">1839          *</span>
<span class="line-added">1840          * &lt;p&gt; The newly created class or interface {@code C} serves as the</span>
<span class="line-added">1841          * {@linkplain #lookupClass() lookup class} of the {@code Lookup} object</span>
<span class="line-added">1842          * returned by this method. {@code C} is &lt;em&gt;hidden&lt;/em&gt; in the sense that</span>
<span class="line-added">1843          * no other class or interface can refer to {@code C} via a constant pool entry.</span>
<span class="line-added">1844          * That is, a hidden class or interface cannot be named as a supertype, a field type,</span>
<span class="line-added">1845          * a method parameter type, or a method return type by any other class.</span>
<span class="line-added">1846          * This is because a hidden class or interface does not have a binary name, so</span>
<span class="line-added">1847          * there is no internal form available to record in any class&#39;s constant pool.</span>
<span class="line-added">1848          * A hidden class or interface is not discoverable by {@link Class#forName(String, boolean, ClassLoader)},</span>
<span class="line-added">1849          * {@link ClassLoader#loadClass(String, boolean)}, or {@link #findClass(String)}, and</span>
<span class="line-added">1850          * is not {@linkplain java.lang.instrument.Instrumentation#isModifiableClass(Class)</span>
<span class="line-added">1851          * modifiable} by Java agents or tool agents using the &lt;a href=&quot;{@docRoot}/../specs/jvmti.html&quot;&gt;</span>
<span class="line-added">1852          * JVM Tool Interface&lt;/a&gt;.</span>
<span class="line-added">1853          *</span>
<span class="line-added">1854          * &lt;p&gt; A class or interface created by</span>
<span class="line-added">1855          * {@linkplain ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)</span>
<span class="line-added">1856          * a class loader} has a strong relationship with that class loader.</span>
<span class="line-added">1857          * That is, every {@code Class} object contains a reference to the {@code ClassLoader}</span>
<span class="line-added">1858          * that {@linkplain Class#getClassLoader() defined it}.</span>
<span class="line-added">1859          * This means that a class created by a class loader may be unloaded if and</span>
<span class="line-added">1860          * only if its defining loader is not reachable and thus may be reclaimed</span>
<span class="line-added">1861          * by a garbage collector (JLS 12.7).</span>
<span class="line-added">1862          *</span>
<span class="line-added">1863          * By default, however, a hidden class or interface may be unloaded even if</span>
<span class="line-added">1864          * the class loader that is marked as its defining loader is</span>
<span class="line-added">1865          * &lt;a href=&quot;../ref/package.html#reachability&quot;&gt;reachable&lt;/a&gt;.</span>
<span class="line-added">1866          * This behavior is useful when a hidden class or interface serves multiple</span>
<span class="line-added">1867          * classes defined by arbitrary class loaders.  In other cases, a hidden</span>
<span class="line-added">1868          * class or interface may be linked to a single class (or a small number of classes)</span>
<span class="line-added">1869          * with the same defining loader as the hidden class or interface.</span>
<span class="line-added">1870          * In such cases, where the hidden class or interface must be coterminous</span>
<span class="line-added">1871          * with a normal class or interface, the {@link ClassOption#STRONG STRONG}</span>
<span class="line-added">1872          * option may be passed in {@code options}.</span>
<span class="line-added">1873          * This arranges for a hidden class to have the same strong relationship</span>
<span class="line-added">1874          * with the class loader marked as its defining loader,</span>
<span class="line-added">1875          * as a normal class or interface has with its own defining loader.</span>
<span class="line-added">1876          *</span>
<span class="line-added">1877          * If {@code STRONG} is not used, then the invoker of {@code defineHiddenClass}</span>
<span class="line-added">1878          * may still prevent a hidden class or interface from being</span>
<span class="line-added">1879          * unloaded by ensuring that the {@code Class} object is reachable.</span>
<span class="line-added">1880          *</span>
<span class="line-added">1881          * &lt;p&gt; The unloading characteristics are set for each hidden class when it is</span>
<span class="line-added">1882          * defined, and cannot be changed later.  An advantage of allowing hidden classes</span>
<span class="line-added">1883          * to be unloaded independently of the class loader marked as their defining loader</span>
<span class="line-added">1884          * is that a very large number of hidden classes may be created by an application.</span>
<span class="line-added">1885          * In contrast, if {@code STRONG} is used, then the JVM may run out of memory,</span>
<span class="line-added">1886          * just as if normal classes were created by class loaders.</span>
<span class="line-added">1887          *</span>
<span class="line-added">1888          * &lt;p&gt; Classes and interfaces in a nest are allowed to have mutual access to</span>
<span class="line-added">1889          * their private members.  The nest relationship is determined by</span>
<span class="line-added">1890          * the {@code NestHost} attribute (JVMS {@jvms 4.7.28}) and</span>
<span class="line-added">1891          * the {@code NestMembers} attribute (JVMS {@jvms 4.7.29}) in a {@code class} file.</span>
<span class="line-added">1892          * By default, a hidden class belongs to a nest consisting only of itself</span>
<span class="line-added">1893          * because a hidden class has no binary name.</span>
<span class="line-added">1894          * The {@link ClassOption#NESTMATE NESTMATE} option can be passed in {@code options}</span>
<span class="line-added">1895          * to create a hidden class or interface {@code C} as a member of a nest.</span>
<span class="line-added">1896          * The nest to which {@code C} belongs is not based on any {@code NestHost} attribute</span>
<span class="line-added">1897          * in the {@code ClassFile} structure from which {@code C} was derived.</span>
<span class="line-added">1898          * Instead, the following rules determine the nest host of {@code C}:</span>
<span class="line-added">1899          * &lt;ul&gt;</span>
<span class="line-added">1900          * &lt;li&gt;If the nest host of the lookup class of this {@code Lookup} has previously</span>
<span class="line-added">1901          *     been determined, then let {@code H} be the nest host of the lookup class.</span>
<span class="line-added">1902          *     Otherwise, the nest host of the lookup class is determined using the</span>
<span class="line-added">1903          *     algorithm in JVMS {@jvms 5.4.4}, yielding {@code H}.&lt;/li&gt;</span>
<span class="line-added">1904          * &lt;li&gt;The nest host of {@code C} is determined to be {@code H},</span>
<span class="line-added">1905          *     the nest host of the lookup class.&lt;/li&gt;</span>
<span class="line-added">1906          * &lt;/ul&gt;</span>
<span class="line-added">1907          *</span>
<span class="line-added">1908          * &lt;p&gt; A hidden class or interface may be serializable, but this requires a custom</span>
<span class="line-added">1909          * serialization mechanism in order to ensure that instances are properly serialized</span>
<span class="line-added">1910          * and deserialized. The default serialization mechanism supports only classes and</span>
<span class="line-added">1911          * interfaces that are discoverable by their class name.</span>
<span class="line-added">1912          *</span>
<span class="line-added">1913          * @param bytes the bytes that make up the class data,</span>
<span class="line-added">1914          * in the format of a valid {@code class} file as defined by</span>
<span class="line-added">1915          * &lt;cite&gt;The Java Virtual Machine Specification&lt;/cite&gt;.</span>
<span class="line-added">1916          * @param initialize if {@code true} the class will be initialized.</span>
<span class="line-added">1917          * @param options {@linkplain ClassOption class options}</span>
<span class="line-added">1918          * @return the {@code Lookup} object on the hidden class</span>
<span class="line-added">1919          *</span>
<span class="line-added">1920          * @throws IllegalAccessException if this {@code Lookup} does not have</span>
<span class="line-added">1921          * {@linkplain #hasFullPrivilegeAccess() full privilege} access</span>
<span class="line-added">1922          * @throws SecurityException if a security manager is present and it</span>
<span class="line-added">1923          * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
<span class="line-added">1924          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure</span>
<span class="line-added">1925          * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version</span>
<span class="line-added">1926          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="line-added">1927          * {@bytes} denotes a class in a different package than the lookup class</span>
<span class="line-added">1928          * @throws IncompatibleClassChangeError if the class or interface named as</span>
<span class="line-added">1929          * the direct superclass of {@code C} is in fact an interface, or if any of the classes</span>
<span class="line-added">1930          * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces</span>
<span class="line-added">1931          * @throws ClassCircularityError if any of the superclasses or superinterfaces of</span>
<span class="line-added">1932          * {@code C} is {@code C} itself</span>
<span class="line-added">1933          * @throws VerifyError if the newly created class cannot be verified</span>
<span class="line-added">1934          * @throws LinkageError if the newly created class cannot be linked for any other reason</span>
<span class="line-added">1935          * @throws NullPointerException if any parameter is {@code null}</span>
<span class="line-added">1936          *</span>
<span class="line-added">1937          * @since 15</span>
<span class="line-added">1938          * @see Class#isHidden()</span>
<span class="line-added">1939          * @jvms 4.2.1 Binary Class and Interface Names</span>
<span class="line-added">1940          * @jvms 4.2.2 Unqualified Names</span>
<span class="line-added">1941          * @jvms 4.7.28 The {@code NestHost} Attribute</span>
<span class="line-added">1942          * @jvms 4.7.29 The {@code NestMembers} Attribute</span>
<span class="line-added">1943          * @jvms 5.4.3.1 Class and Interface Resolution</span>
<span class="line-added">1944          * @jvms 5.4.4 Access Control</span>
<span class="line-added">1945          * @jvms 5.3.5 Deriving a {@code Class} from a {@code class} File Representation</span>
<span class="line-added">1946          * @jvms 5.4 Linking</span>
<span class="line-added">1947          * @jvms 5.5 Initialization</span>
<span class="line-added">1948          * @jls 12.7 Unloading of Classes and Interfaces</span>
<span class="line-added">1949          */</span>
<span class="line-added">1950         public Lookup defineHiddenClass(byte[] bytes, boolean initialize, ClassOption... options)</span>
<span class="line-added">1951                 throws IllegalAccessException</span>
<span class="line-added">1952         {</span>
<span class="line-added">1953             Objects.requireNonNull(bytes);</span>
<span class="line-added">1954             Objects.requireNonNull(options);</span>
<span class="line-added">1955 </span>
<span class="line-added">1956             ensureDefineClassPermission();</span>
<span class="line-added">1957             if (!hasFullPrivilegeAccess()) {</span>
<span class="line-added">1958                 throw new IllegalAccessException(this + &quot; does not have full privilege access&quot;);</span>
<span class="line-added">1959             }</span>
<span class="line-added">1960 </span>
<span class="line-added">1961             return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false).defineClassAsLookup(initialize);</span>
<span class="line-added">1962         }</span>
<span class="line-added">1963 </span>
<span class="line-added">1964         /**</span>
<span class="line-added">1965          * Creates a &lt;em&gt;hidden&lt;/em&gt; class or interface from {@code bytes} with associated</span>
<span class="line-added">1966          * {@linkplain MethodHandles#classData(Lookup, String, Class) class data},</span>
<span class="line-added">1967          * returning a {@code Lookup} on the newly created class or interface.</span>
<span class="line-added">1968          *</span>
<span class="line-added">1969          * &lt;p&gt; This method is equivalent to calling</span>
<span class="line-added">1970          * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass(bytes, true, options)}</span>
<span class="line-added">1971          * as if the hidden class has a private static final unnamed field whose value</span>
<span class="line-added">1972          * is initialized to {@code classData} right before the class initializer is</span>
<span class="line-added">1973          * executed.  The newly created class is linked and initialized by the Java</span>
<span class="line-added">1974          * Virtual Machine.</span>
<span class="line-added">1975          *</span>
<span class="line-added">1976          * &lt;p&gt; The {@link MethodHandles#classData(Lookup, String, Class) MethodHandles::classData}</span>
<span class="line-added">1977          * method can be used to retrieve the {@code classData}.</span>
<span class="line-added">1978          *</span>
<span class="line-added">1979          * @param bytes     the class bytes</span>
<span class="line-added">1980          * @param classData pre-initialized class data</span>
<span class="line-added">1981          * @param options   {@linkplain ClassOption class options}</span>
<span class="line-added">1982          * @return the {@code Lookup} object on the hidden class</span>
<span class="line-added">1983          *</span>
<span class="line-added">1984          * @throws IllegalAccessException if this {@code Lookup} does not have</span>
<span class="line-added">1985          * {@linkplain #hasFullPrivilegeAccess() full privilege} access</span>
<span class="line-added">1986          * @throws SecurityException if a security manager is present and it</span>
<span class="line-added">1987          * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
<span class="line-added">1988          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure</span>
<span class="line-added">1989          * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version</span>
<span class="line-added">1990          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="line-added">1991          * {@bytes} denotes a class in a different package than the lookup class</span>
<span class="line-added">1992          * @throws IncompatibleClassChangeError if the class or interface named as</span>
<span class="line-added">1993          * the direct superclass of {@code C} is in fact an interface, or if any of the classes</span>
<span class="line-added">1994          * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces</span>
<span class="line-added">1995          * @throws ClassCircularityError if any of the superclasses or superinterfaces of</span>
<span class="line-added">1996          * {@code C} is {@code C} itself</span>
<span class="line-added">1997          * @throws VerifyError if the newly created class cannot be verified</span>
<span class="line-added">1998          * @throws LinkageError if the newly created class cannot be linked for any other reason</span>
<span class="line-added">1999          * @throws NullPointerException if any parameter is {@code null}</span>
<span class="line-added">2000          *</span>
<span class="line-added">2001          * @since 15</span>
<span class="line-added">2002          * @see Lookup#defineHiddenClass(byte[], boolean, ClassOption...)</span>
<span class="line-added">2003          * @see Class#isHidden()</span>
<span class="line-added">2004          */</span>
<span class="line-added">2005         /* package-private */ Lookup defineHiddenClassWithClassData(byte[] bytes, Object classData, ClassOption... options)</span>
<span class="line-added">2006                 throws IllegalAccessException</span>
<span class="line-added">2007         {</span>
<span class="line-added">2008             Objects.requireNonNull(bytes);</span>
<span class="line-added">2009             Objects.requireNonNull(classData);</span>
<span class="line-added">2010             Objects.requireNonNull(options);</span>
<span class="line-added">2011 </span>
<span class="line-added">2012             ensureDefineClassPermission();</span>
<span class="line-added">2013             if (!hasFullPrivilegeAccess()) {</span>
<span class="line-added">2014                 throw new IllegalAccessException(this + &quot; does not have full privilege access&quot;);</span>
<span class="line-added">2015             }</span>
<span class="line-added">2016 </span>
<span class="line-added">2017             return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false)</span>
<span class="line-added">2018                        .defineClassAsLookup(true, classData);</span>
<span class="line-added">2019         }</span>
<span class="line-added">2020 </span>
<span class="line-added">2021         /*</span>
<span class="line-added">2022          * Validates the given bytes to be a class or interface and the class name</span>
<span class="line-added">2023          * is in the same package as the lookup class.</span>
<span class="line-added">2024          *</span>
<span class="line-added">2025          * This method returns the class name.</span>
<span class="line-added">2026          */</span>
<span class="line-added">2027         private String validateAndGetClassName(byte[] bytes) {</span>
2028             try {
2029                 ClassReader reader = new ClassReader(bytes);
<span class="line-modified">2030                 if ((reader.getAccess() &amp; Opcodes.ACC_MODULE) != 0) {</span>
<span class="line-added">2031                     throw newIllegalArgumentException(&quot;Not a class or interface: ACC_MODULE flag is set&quot;);</span>
<span class="line-added">2032                 }</span>
<span class="line-added">2033                 String name = reader.getClassName().replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="line-added">2034                 int index = name.lastIndexOf(&#39;.&#39;);</span>
<span class="line-added">2035                 String pn = (index == -1) ? &quot;&quot; : name.substring(0, index);</span>
<span class="line-added">2036                 if (!pn.equals(lookupClass.getPackageName())) {</span>
<span class="line-added">2037                     throw newIllegalArgumentException(name + &quot; not in same package as lookup class: &quot; +</span>
<span class="line-added">2038                             lookupClass.getName());</span>
<span class="line-added">2039                 }</span>
<span class="line-added">2040                 return name;</span>
<span class="line-added">2041             } catch (IllegalArgumentException e) {</span>
<span class="line-added">2042                 throw e;</span>
2043             } catch (RuntimeException e) {
2044                 // ASM exceptions are poorly specified
2045                 ClassFormatError cfe = new ClassFormatError();
2046                 cfe.initCause(e);
2047                 throw cfe;
2048             }
<span class="line-added">2049         }</span>
2050 
<span class="line-modified">2051 </span>
<span class="line-modified">2052         /*</span>
<span class="line-modified">2053          * Returns a ClassDefiner that creates a {@code Class} object of a normal class</span>
<span class="line-modified">2054          * from the given bytes.</span>
<span class="line-modified">2055          *</span>
<span class="line-modified">2056          * Caller should make a defensive copy of the arguments if needed</span>
<span class="line-modified">2057          * before calling this factory method.</span>
<span class="line-modified">2058          *</span>
<span class="line-modified">2059          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="line-added">2060          * {@bytes} denotes a class in a different package than the lookup class</span>
<span class="line-added">2061          */</span>
<span class="line-added">2062         private ClassDefiner makeClassDefiner(byte[] bytes) {</span>
<span class="line-added">2063             return new ClassDefiner(this, validateAndGetClassName(bytes), bytes, STRONG_LOADER_LINK);</span>
<span class="line-added">2064         }</span>
<span class="line-added">2065 </span>
<span class="line-added">2066         /**</span>
<span class="line-added">2067          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class</span>
<span class="line-added">2068          * from the given bytes.  The name must be in the same package as the lookup class.</span>
<span class="line-added">2069          *</span>
<span class="line-added">2070          * Caller should make a defensive copy of the arguments if needed</span>
<span class="line-added">2071          * before calling this factory method.</span>
<span class="line-added">2072          *</span>
<span class="line-added">2073          * @param bytes   class bytes</span>
<span class="line-added">2074          * @return ClassDefiner that defines a hidden class of the given bytes.</span>
<span class="line-added">2075          *</span>
<span class="line-added">2076          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="line-added">2077          * {@bytes} denotes a class in a different package than the lookup class</span>
<span class="line-added">2078          */</span>
<span class="line-added">2079         ClassDefiner makeHiddenClassDefiner(byte[] bytes) {</span>
<span class="line-added">2080             return makeHiddenClassDefiner(validateAndGetClassName(bytes), bytes, Set.of(), false);</span>
<span class="line-added">2081         }</span>
<span class="line-added">2082 </span>
<span class="line-added">2083         /**</span>
<span class="line-added">2084          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class</span>
<span class="line-added">2085          * from the given bytes and options.</span>
<span class="line-added">2086          * The name must be in the same package as the lookup class.</span>
<span class="line-added">2087          *</span>
<span class="line-added">2088          * Caller should make a defensive copy of the arguments if needed</span>
<span class="line-added">2089          * before calling this factory method.</span>
<span class="line-added">2090          *</span>
<span class="line-added">2091          * @param bytes   class bytes</span>
<span class="line-added">2092          * @param options class options</span>
<span class="line-added">2093          * @param accessVmAnnotations true to give the hidden class access to VM annotations</span>
<span class="line-added">2094          * @return ClassDefiner that defines a hidden class of the given bytes and options</span>
<span class="line-added">2095          *</span>
<span class="line-added">2096          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="line-added">2097          * {@bytes} denotes a class in a different package than the lookup class</span>
<span class="line-added">2098          */</span>
<span class="line-added">2099         ClassDefiner makeHiddenClassDefiner(byte[] bytes,</span>
<span class="line-added">2100                                             Set&lt;ClassOption&gt; options,</span>
<span class="line-added">2101                                             boolean accessVmAnnotations) {</span>
<span class="line-added">2102             return makeHiddenClassDefiner(validateAndGetClassName(bytes), bytes, options, accessVmAnnotations);</span>
<span class="line-added">2103         }</span>
<span class="line-added">2104 </span>
<span class="line-added">2105         /**</span>
<span class="line-added">2106          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class</span>
<span class="line-added">2107          * from the given bytes.  No package name check on the given name.</span>
<span class="line-added">2108          *</span>
<span class="line-added">2109          * @param name    fully-qualified name that specifies the prefix of the hidden class</span>
<span class="line-added">2110          * @param bytes   class bytes</span>
<span class="line-added">2111          * @return ClassDefiner that defines a hidden class of the given bytes.</span>
<span class="line-added">2112          */</span>
<span class="line-added">2113         ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes) {</span>
<span class="line-added">2114             return makeHiddenClassDefiner(name, bytes, Set.of(), false);</span>
<span class="line-added">2115         }</span>
<span class="line-added">2116 </span>
<span class="line-added">2117         /**</span>
<span class="line-added">2118          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class</span>
<span class="line-added">2119          * from the given bytes and options.  No package name check on the given name.</span>
<span class="line-added">2120          *</span>
<span class="line-added">2121          * @param name the name of the class and the name in the class bytes is ignored.</span>
<span class="line-added">2122          * @param bytes class bytes</span>
<span class="line-added">2123          * @param options class options</span>
<span class="line-added">2124          * @param accessVmAnnotations true to give the hidden class access to VM annotations</span>
<span class="line-added">2125          */</span>
<span class="line-added">2126         ClassDefiner makeHiddenClassDefiner(String name,</span>
<span class="line-added">2127                                             byte[] bytes,</span>
<span class="line-added">2128                                             Set&lt;ClassOption&gt; options,</span>
<span class="line-added">2129                                             boolean accessVmAnnotations) {</span>
<span class="line-added">2130             int flags = HIDDEN_CLASS | ClassOption.optionsToFlag(options);</span>
<span class="line-added">2131             if (accessVmAnnotations | VM.isSystemDomainLoader(lookupClass.getClassLoader())) {</span>
<span class="line-added">2132                 // jdk.internal.vm.annotations are permitted for classes</span>
<span class="line-added">2133                 // defined to boot loader and platform loader</span>
<span class="line-added">2134                 flags |= ACCESS_VM_ANNOTATIONS;</span>
<span class="line-added">2135             }</span>
<span class="line-added">2136 </span>
<span class="line-added">2137             return new ClassDefiner(this, name, bytes, flags);</span>
<span class="line-added">2138         }</span>
<span class="line-added">2139 </span>
<span class="line-added">2140         static class ClassDefiner {</span>
<span class="line-added">2141             private final Lookup lookup;</span>
<span class="line-added">2142             private final String name;</span>
<span class="line-added">2143             private final byte[] bytes;</span>
<span class="line-added">2144             private final int classFlags;</span>
<span class="line-added">2145 </span>
<span class="line-added">2146             private ClassDefiner(Lookup lookup, String name, byte[] bytes, int flags) {</span>
<span class="line-added">2147                 assert ((flags &amp; HIDDEN_CLASS) != 0 || (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK);</span>
<span class="line-added">2148                 this.lookup = lookup;</span>
<span class="line-added">2149                 this.bytes = bytes;</span>
<span class="line-added">2150                 this.classFlags = flags;</span>
<span class="line-added">2151                 this.name = name;</span>
<span class="line-added">2152             }</span>
<span class="line-added">2153 </span>
<span class="line-added">2154             String className() {</span>
<span class="line-added">2155                 return name;</span>
<span class="line-added">2156             }</span>
<span class="line-added">2157 </span>
<span class="line-added">2158             Class&lt;?&gt; defineClass(boolean initialize) {</span>
<span class="line-added">2159                 return defineClass(initialize, null);</span>
<span class="line-added">2160             }</span>
<span class="line-added">2161 </span>
<span class="line-added">2162             Lookup defineClassAsLookup(boolean initialize) {</span>
<span class="line-added">2163                 Class&lt;?&gt; c = defineClass(initialize, null);</span>
<span class="line-added">2164                 return new Lookup(c, null, FULL_POWER_MODES);</span>
<span class="line-added">2165             }</span>
<span class="line-added">2166 </span>
<span class="line-added">2167             /**</span>
<span class="line-added">2168              * Defines the class of the given bytes and the given classData.</span>
<span class="line-added">2169              * If {@code initialize} parameter is true, then the class will be initialized.</span>
<span class="line-added">2170              *</span>
<span class="line-added">2171              * @param initialize true if the class to be initialized</span>
<span class="line-added">2172              * @param classData classData or null</span>
<span class="line-added">2173              * @return the class</span>
<span class="line-added">2174              *</span>
<span class="line-added">2175              * @throws LinkageError linkage error</span>
<span class="line-added">2176              */</span>
<span class="line-added">2177             Class&lt;?&gt; defineClass(boolean initialize, Object classData) {</span>
<span class="line-added">2178                 Class&lt;?&gt; lookupClass = lookup.lookupClass();</span>
<span class="line-added">2179                 ClassLoader loader = lookupClass.getClassLoader();</span>
<span class="line-added">2180                 ProtectionDomain pd = (loader != null) ? lookup.lookupClassProtectionDomain() : null;</span>
<span class="line-added">2181                 Class&lt;?&gt; c = JLA.defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);</span>
<span class="line-added">2182                 assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();</span>
<span class="line-added">2183                 return c;</span>
2184             }
<span class="line-modified">2185 </span>
<span class="line-modified">2186             Lookup defineClassAsLookup(boolean initialize, Object classData) {</span>
<span class="line-added">2187                 // initialize must be true if classData is non-null</span>
<span class="line-added">2188                 assert classData == null || initialize == true;</span>
<span class="line-added">2189                 Class&lt;?&gt; c = defineClass(initialize, classData);</span>
<span class="line-added">2190                 return new Lookup(c, null, FULL_POWER_MODES);</span>
2191             }
2192 
<span class="line-modified">2193             private boolean isNestmate() {</span>
<span class="line-modified">2194                 return (classFlags &amp; NESTMATE_CLASS) != 0;</span>
<span class="line-modified">2195             }</span>



2196         }
2197 
2198         private ProtectionDomain lookupClassProtectionDomain() {
2199             ProtectionDomain pd = cachedProtectionDomain;
2200             if (pd == null) {
<span class="line-modified">2201                 cachedProtectionDomain = pd = JLA.protectionDomain(lookupClass);</span>
2202             }
2203             return pd;
2204         }
2205 





2206         // cached protection domain
2207         private volatile ProtectionDomain cachedProtectionDomain;
2208 

2209         // Make sure outer class is initialized first.
2210         static { IMPL_NAMES.getClass(); }
2211 
2212         /** Package-private version of lookup which is trusted. */
2213         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, null, TRUSTED);
2214 
2215         /** Version of lookup which is trusted minimally.
2216          *  It can only be used to create method handles to publicly accessible
2217          *  members in packages that are exported unconditionally.
2218          */
2219         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, null, UNCONDITIONAL);
2220 
<span class="line-added">2221         static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();</span>
<span class="line-added">2222 </span>
2223         private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
2224             String name = lookupClass.getName();
2225             if (name.startsWith(&quot;java.lang.invoke.&quot;))
2226                 throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
2227         }
2228 
2229         /**
2230          * Displays the name of the class from which lookups are to be made.
2231          * followed with &quot;/&quot; and the name of the {@linkplain #previousLookupClass()
2232          * previous lookup class} if present.
2233          * (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
2234          * If there are restrictions on the access permitted to this lookup,
2235          * this is indicated by adding a suffix to the class name, consisting
2236          * of a slash and a keyword.  The keyword represents the strongest
2237          * allowed access, and is chosen as follows:
2238          * &lt;ul&gt;
2239          * &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.
2240          * &lt;li&gt;If only unconditional access is allowed, the suffix is &quot;/publicLookup&quot;.
2241          * &lt;li&gt;If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.
2242          * &lt;li&gt;If only public and module access are allowed, the suffix is &quot;/module&quot;.
</pre>
<hr />
<pre>
2263          */
2264         @Override
2265         public String toString() {
2266             String cname = lookupClass.getName();
2267             if (prevLookupClass != null)
2268                 cname += &quot;/&quot; + prevLookupClass.getName();
2269             switch (allowedModes) {
2270             case 0:  // no privileges
2271                 return cname + &quot;/noaccess&quot;;
2272             case UNCONDITIONAL:
2273                 return cname + &quot;/publicLookup&quot;;
2274             case PUBLIC:
2275                 return cname + &quot;/public&quot;;
2276             case PUBLIC|MODULE:
2277                 return cname + &quot;/module&quot;;
2278             case PUBLIC|PACKAGE:
2279             case PUBLIC|MODULE|PACKAGE:
2280                 return cname + &quot;/package&quot;;
2281             case FULL_POWER_MODES &amp; (~PROTECTED):
2282             case FULL_POWER_MODES &amp; ~(PROTECTED|MODULE):
<span class="line-modified">2283                 return cname + &quot;/private&quot;;</span>
2284             case FULL_POWER_MODES:
2285             case FULL_POWER_MODES &amp; (~MODULE):
2286                 return cname;
2287             case TRUSTED:
2288                 return &quot;/trusted&quot;;  // internal only; not exported
2289             default:  // Should not happen, but it&#39;s a bitfield...
2290                 cname = cname + &quot;/&quot; + Integer.toHexString(allowedModes);
2291                 assert(false) : cname;
2292                 return cname;
2293             }
2294         }
2295 
2296         /**
2297          * Produces a method handle for a static method.
2298          * The type of the method handle will be that of the method.
2299          * (Since static methods do not take receivers, there is no
2300          * additional receiver argument inserted into the method handle type,
2301          * as there would be with {@link #findVirtual findVirtual} or {@link #findSpecial findSpecial}.)
2302          * The method and all its argument types must be accessible to the lookup object.
2303          * &lt;p&gt;
</pre>
<hr />
<pre>
3177          * the {@code Field} object&#39;s {@code set} method could return
3178          * normally.  In particular, fields which are both {@code static}
3179          * and {@code final} may never be set.
3180          * &lt;p&gt;
3181          * If the field is {@code static}, and
3182          * if the returned method handle is invoked, the field&#39;s class will
3183          * be initialized, if it has not already been initialized.
3184          * @param f the reflected field
3185          * @return a method handle which can store values into the reflected field
3186          * @throws IllegalAccessException if access checking fails,
3187          *         or if the field is {@code final} and write access
3188          *         is not enabled on the {@code Field} object
3189          * @throws NullPointerException if the argument is null
3190          */
3191         public MethodHandle unreflectSetter(Field f) throws IllegalAccessException {
3192             return unreflectField(f, true);
3193         }
3194 
3195         private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {
3196             MemberName field = new MemberName(f, isSetter);
<span class="line-modified">3197             if (isSetter &amp;&amp; field.isFinal()) {</span>
<span class="line-modified">3198                 if (field.isStatic()) {</span>
<span class="line-added">3199                     throw field.makeAccessException(&quot;static final field has no write access&quot;, this);</span>
<span class="line-added">3200                 } else if (field.getDeclaringClass().isHidden()){</span>
<span class="line-added">3201                     throw field.makeAccessException(&quot;final field in a hidden class has no write access&quot;, this);</span>
<span class="line-added">3202                 }</span>
<span class="line-added">3203             }</span>
3204             assert(isSetter
3205                     ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())
3206                     : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));
3207             @SuppressWarnings(&quot;deprecation&quot;)
3208             Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;
3209             return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);
3210         }
3211 
3212         /**
3213          * Produces a VarHandle giving access to a reflected field {@code f}
3214          * of type {@code T} declared in a class of type {@code R}.
3215          * The VarHandle&#39;s variable type is {@code T}.
3216          * If the field is non-static the VarHandle has one coordinate type,
3217          * {@code R}.  Otherwise, the field is static, and the VarHandle has no
3218          * coordinate types.
3219          * &lt;p&gt;
3220          * Access checking is performed immediately on behalf of the lookup
3221          * class, regardless of the value of the field&#39;s {@code accessible}
3222          * flag.
3223          * &lt;p&gt;
</pre>
<hr />
<pre>
3746             if (!putField.isFinal()) {
3747                 // A VarHandle does not support updates to final fields, any
3748                 // such VarHandle to a final field will be read-only and
3749                 // therefore the following write-based accessibility checks are
3750                 // only required for non-final fields
3751                 checkField(putRefKind, refc, putField);
3752                 if (checkSecurity)
3753                     checkSecurityManager(refc, putField);
3754             }
3755 
3756             boolean doRestrict = (MethodHandleNatives.refKindHasReceiver(getRefKind) &amp;&amp;
3757                                   restrictProtectedReceiver(getField));
3758             if (doRestrict) {
3759                 assert !getField.isStatic();
3760                 // receiver type of VarHandle is too wide; narrow to caller
3761                 if (!getField.getDeclaringClass().isAssignableFrom(lookupClass())) {
3762                     throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
3763                 }
3764                 refc = lookupClass();
3765             }
<span class="line-modified">3766             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),</span>
<span class="line-modified">3767                                              this.allowedModes == TRUSTED &amp;&amp; !getField.getDeclaringClass().isHidden());</span>
3768         }
3769         /** Check access and get the requested constructor. */
3770         private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3771             final boolean checkSecurity = true;
3772             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3773         }
3774         /** Check access and get the requested constructor, eliding security manager checks. */
3775         private MethodHandle getDirectConstructorNoSecurityManager(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
3776             final boolean checkSecurity = false;  // not needed for reflection or for linking CONSTANT_MH constants
3777             return getDirectConstructorCommon(refc, ctor, checkSecurity);
3778         }
3779         /** Common code for all constructors; do not call directly except from immediately above. */
3780         private MethodHandle getDirectConstructorCommon(Class&lt;?&gt; refc, MemberName ctor,
3781                                                   boolean checkSecurity) throws IllegalAccessException {
3782             assert(ctor.isObjectConstructor());
3783             checkAccess(REF_newInvokeSpecial, refc, ctor);
3784             // Optionally check with the security manager; this isn&#39;t needed for unreflect* calls.
3785             if (checkSecurity)
3786                 checkSecurityManager(refc, ctor);
3787             assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandleNatives.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/AccessibleObject.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
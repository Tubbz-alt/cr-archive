<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="GenerateJLIClassesHelper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="InvokerBytecodeGenerator.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.access.JavaLangAccess;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.org.objectweb.asm.*;
 31 import sun.invoke.util.BytecodeDescriptor;
<span class="line-removed"> 32 import jdk.internal.misc.Unsafe;</span>
 33 import sun.security.action.GetPropertyAction;
 34 import sun.security.action.GetBooleanAction;
 35 
 36 import java.io.FilePermission;
 37 import java.io.Serializable;

 38 import java.lang.reflect.Constructor;

 39 import java.security.AccessController;
 40 import java.security.PrivilegedAction;
 41 import java.util.LinkedHashSet;
 42 import java.util.concurrent.atomic.AtomicInteger;
 43 import java.util.PropertyPermission;
 44 import java.util.Set;
 45 


 46 import static jdk.internal.org.objectweb.asm.Opcodes.*;
 47 
 48 /**
 49  * Lambda metafactory implementation which dynamically creates an
 50  * inner-class-like class per lambda callsite.
 51  *
 52  * @see LambdaMetafactory
 53  */
 54 /* package */ final class InnerClassLambdaMetafactory extends AbstractValidatingLambdaMetafactory {
<span class="line-modified"> 55     private static final Unsafe UNSAFE = Unsafe.getUnsafe();</span>
<span class="line-removed"> 56 </span>
<span class="line-removed"> 57     private static final int CLASSFILE_VERSION = V15;</span>
 58     private static final String METHOD_DESCRIPTOR_VOID = Type.getMethodDescriptor(Type.VOID_TYPE);
 59     private static final String JAVA_LANG_OBJECT = &quot;java/lang/Object&quot;;
 60     private static final String NAME_CTOR = &quot;&lt;init&gt;&quot;;
<span class="line-removed"> 61     private static final String NAME_FACTORY = &quot;get$Lambda&quot;;</span>
 62 
 63     //Serialization support
 64     private static final String NAME_SERIALIZED_LAMBDA = &quot;java/lang/invoke/SerializedLambda&quot;;
 65     private static final String NAME_NOT_SERIALIZABLE_EXCEPTION = &quot;java/io/NotSerializableException&quot;;
 66     private static final String DESCR_METHOD_WRITE_REPLACE = &quot;()Ljava/lang/Object;&quot;;
 67     private static final String DESCR_METHOD_WRITE_OBJECT = &quot;(Ljava/io/ObjectOutputStream;)V&quot;;
 68     private static final String DESCR_METHOD_READ_OBJECT = &quot;(Ljava/io/ObjectInputStream;)V&quot;;


 69     private static final String NAME_METHOD_WRITE_REPLACE = &quot;writeReplace&quot;;
 70     private static final String NAME_METHOD_READ_OBJECT = &quot;readObject&quot;;
 71     private static final String NAME_METHOD_WRITE_OBJECT = &quot;writeObject&quot;;

 72 
 73     private static final String DESCR_CLASS = &quot;Ljava/lang/Class;&quot;;
 74     private static final String DESCR_STRING = &quot;Ljava/lang/String;&quot;;
 75     private static final String DESCR_OBJECT = &quot;Ljava/lang/Object;&quot;;

 76     private static final String DESCR_CTOR_SERIALIZED_LAMBDA
 77             = &quot;(&quot; + DESCR_CLASS + DESCR_STRING + DESCR_STRING + DESCR_STRING + &quot;I&quot;
 78             + DESCR_STRING + DESCR_STRING + DESCR_STRING + DESCR_STRING + &quot;[&quot; + DESCR_OBJECT + &quot;)V&quot;;
 79 
 80     private static final String DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION = &quot;(Ljava/lang/String;)V&quot;;
 81     private static final String[] SER_HOSTILE_EXCEPTIONS = new String[] {NAME_NOT_SERIALIZABLE_EXCEPTION};
 82 
<span class="line-removed"> 83     private static final String DESCR_HIDDEN = &quot;Ljdk/internal/vm/annotation/Hidden;&quot;;</span>
<span class="line-removed"> 84 </span>
 85     private static final String[] EMPTY_STRING_ARRAY = new String[0];
 86 
 87     // Used to ensure that each spun class name is unique
 88     private static final AtomicInteger counter = new AtomicInteger(0);
 89 
 90     // For dumping generated classes to disk, for debugging purposes
 91     private static final ProxyClassesDumper dumper;
 92 
 93     private static final boolean disableEagerInitialization;
 94 
 95     static {
 96         final String dumpProxyClassesKey = &quot;jdk.internal.lambda.dumpProxyClasses&quot;;
 97         String dumpPath = GetPropertyAction.privilegedGetProperty(dumpProxyClassesKey);
 98         dumper = (null == dumpPath) ? null : ProxyClassesDumper.getInstance(dumpPath);
 99 
100         final String disableEagerInitializationKey = &quot;jdk.internal.lambda.disableEagerInitialization&quot;;
101         disableEagerInitialization = GetBooleanAction.privilegedGetProperty(disableEagerInitializationKey);
102     }
103 
104     // See context values in AbstractValidatingLambdaMetafactory
105     private final String implMethodClassName;        // Name of type containing implementation &quot;CC&quot;
106     private final String implMethodName;             // Name of implementation method &quot;impl&quot;
107     private final String implMethodDesc;             // Type descriptor for implementation methods &quot;(I)Ljava/lang/String;&quot;
108     private final MethodType constructorType;        // Generated class constructor type &quot;(CC)void&quot;
109     private final ClassWriter cw;                    // ASM class writer
110     private final String[] argNames;                 // Generated names for the constructor arguments
111     private final String[] argDescs;                 // Type descriptors for the constructor arguments
112     private final String lambdaClassName;            // Generated name for the generated class &quot;X$$Lambda$1&quot;

113 
114     /**
115      * General meta-factory constructor, supporting both standard cases and
116      * allowing for uncommon options such as serialization or bridging.
117      *
118      * @param caller Stacked automatically by VM; represents a lookup context
119      *               with the accessibility privileges of the caller.
120      * @param invokedType Stacked automatically by VM; the signature of the
121      *                    invoked method, which includes the expected static
122      *                    type of the returned lambda object, and the static
123      *                    types of the captured arguments for the lambda.  In
124      *                    the event that the implementation method is an
125      *                    instance method, the first argument in the invocation
126      *                    signature will correspond to the receiver.
127      * @param samMethodName Name of the method in the functional interface to
128      *                      which the lambda or method reference is being
129      *                      converted, represented as a String.
130      * @param samMethodType Type of the method in the functional interface to
131      *                      which the lambda or method reference is being
132      *                      converted, represented as a MethodType.
</pre>
<hr />
<pre>
148      * @throws LambdaConversionException If any of the meta-factory protocol
149      * invariants are violated
150      */
151     public InnerClassLambdaMetafactory(MethodHandles.Lookup caller,
152                                        MethodType invokedType,
153                                        String samMethodName,
154                                        MethodType samMethodType,
155                                        MethodHandle implMethod,
156                                        MethodType instantiatedMethodType,
157                                        boolean isSerializable,
158                                        Class&lt;?&gt;[] markerInterfaces,
159                                        MethodType[] additionalBridges)
160             throws LambdaConversionException {
161         super(caller, invokedType, samMethodName, samMethodType,
162               implMethod, instantiatedMethodType,
163               isSerializable, markerInterfaces, additionalBridges);
164         implMethodClassName = implClass.getName().replace(&#39;.&#39;, &#39;/&#39;);
165         implMethodName = implInfo.getName();
166         implMethodDesc = implInfo.getMethodType().toMethodDescriptorString();
167         constructorType = invokedType.changeReturnType(Void.TYPE);
<span class="line-modified">168         lambdaClassName = targetClass.getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$Lambda$&quot; + counter.incrementAndGet();</span>


169         cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
170         int parameterCount = invokedType.parameterCount();
171         if (parameterCount &gt; 0) {
172             argNames = new String[parameterCount];
173             argDescs = new String[parameterCount];
174             for (int i = 0; i &lt; parameterCount; i++) {
175                 argNames[i] = &quot;arg$&quot; + (i + 1);
176                 argDescs[i] = BytecodeDescriptor.unparse(invokedType.parameterType(i));
177             }
178         } else {
179             argNames = argDescs = EMPTY_STRING_ARRAY;
180         }
181     }
182 









183     /**
184      * Build the CallSite. Generate a class file which implements the functional
185      * interface, define the class, if there are no parameters create an instance
186      * of the class which the CallSite will return, otherwise, generate handles
187      * which will call the class&#39; constructor.
188      *
189      * @return a CallSite, which, when invoked, will return an instance of the
190      * functional interface
191      * @throws ReflectiveOperationException
192      * @throws LambdaConversionException If properly formed functional interface
193      * is not found
194      */
195     @Override
196     CallSite buildCallSite() throws LambdaConversionException {
197         final Class&lt;?&gt; innerClass = spinInnerClass();
198         if (invokedType.parameterCount() == 0 &amp;&amp; !disableEagerInitialization) {
199             // In the case of a non-capturing lambda, we optimize linkage by pre-computing a single instance,
200             // unless we&#39;ve suppressed eager initialization
201             final Constructor&lt;?&gt;[] ctrs = AccessController.doPrivileged(
202                     new PrivilegedAction&lt;&gt;() {
203                 @Override
204                 public Constructor&lt;?&gt;[] run() {
205                     Constructor&lt;?&gt;[] ctrs = innerClass.getDeclaredConstructors();
206                     if (ctrs.length == 1) {
207                         // The lambda implementing inner class constructor is private, set
208                         // it accessible (by us) before creating the constant sole instance
209                         ctrs[0].setAccessible(true);
210                     }
211                     return ctrs;
212                 }
213                     });
214             if (ctrs.length != 1) {
215                 throw new LambdaConversionException(&quot;Expected one lambda constructor for &quot;
216                         + innerClass.getCanonicalName() + &quot;, got &quot; + ctrs.length);
217             }
218 
219             try {
220                 Object inst = ctrs[0].newInstance();
221                 return new ConstantCallSite(MethodHandles.constant(samBase, inst));
<span class="line-modified">222             }</span>
<span class="line-removed">223             catch (ReflectiveOperationException e) {</span>
224                 throw new LambdaConversionException(&quot;Exception instantiating lambda object&quot;, e);
225             }
226         } else {
227             try {
<span class="line-modified">228                 if (!disableEagerInitialization) {</span>
<span class="line-modified">229                     UNSAFE.ensureClassInitialized(innerClass);</span>
<span class="line-modified">230                 }</span>
<span class="line-removed">231                 return new ConstantCallSite(</span>
<span class="line-removed">232                         MethodHandles.Lookup.IMPL_LOOKUP</span>
<span class="line-removed">233                              .findStatic(innerClass, NAME_FACTORY, invokedType));</span>
<span class="line-removed">234             }</span>
<span class="line-removed">235             catch (ReflectiveOperationException e) {</span>
236                 throw new LambdaConversionException(&quot;Exception finding constructor&quot;, e);
237             }
238         }
239     }
240 
241     /**
242      * Generate a class file which implements the functional
243      * interface, define and return the class.
244      *
245      * @implNote The class that is generated does not include signature
246      * information for exceptions that may be present on the SAM method.
247      * This is to reduce classfile size, and is harmless as checked exceptions
248      * are erased anyway, no one will ever compile against this classfile,
249      * and we make no guarantees about the reflective properties of lambda
250      * objects.
251      *
252      * @return a Class which implements the functional interface
253      * @throws LambdaConversionException If properly formed functional interface
254      * is not found
255      */
</pre>
<hr />
<pre>
268                 accidentallySerializable |= !isSerializable &amp;&amp; Serializable.class.isAssignableFrom(markerInterface);
269             }
270             interfaces = itfs.toArray(new String[itfs.size()]);
271         }
272 
273         cw.visit(CLASSFILE_VERSION, ACC_SUPER + ACC_FINAL + ACC_SYNTHETIC,
274                  lambdaClassName, null,
275                  JAVA_LANG_OBJECT, interfaces);
276 
277         // Generate final fields to be filled in by constructor
278         for (int i = 0; i &lt; argDescs.length; i++) {
279             FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_FINAL,
280                                             argNames[i],
281                                             argDescs[i],
282                                             null, null);
283             fv.visitEnd();
284         }
285 
286         generateConstructor();
287 
<span class="line-removed">288         if (invokedType.parameterCount() != 0 || disableEagerInitialization) {</span>
<span class="line-removed">289             generateFactory();</span>
<span class="line-removed">290         }</span>
<span class="line-removed">291 </span>
292         // Forward the SAM method
293         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, samMethodName,
294                                           samMethodType.toMethodDescriptorString(), null, null);
<span class="line-removed">295         mv.visitAnnotation(DESCR_HIDDEN, true);</span>
296         new ForwardingMethodGenerator(mv).generate(samMethodType);
297 
298         // Forward the bridges
299         if (additionalBridges != null) {
300             for (MethodType mt : additionalBridges) {
301                 mv = cw.visitMethod(ACC_PUBLIC|ACC_BRIDGE, samMethodName,
302                                     mt.toMethodDescriptorString(), null, null);
<span class="line-removed">303                 mv.visitAnnotation(DESCR_HIDDEN, true);</span>
304                 new ForwardingMethodGenerator(mv).generate(mt);
305             }
306         }
307 








308         if (isSerializable)
309             generateSerializationFriendlyMethods();
310         else if (accidentallySerializable)
311             generateSerializationHostileMethods();
312 
313         cw.visitEnd();
314 
315         // Define the generated class in this VM.
316 
317         final byte[] classBytes = cw.toByteArray();
<span class="line-removed">318 </span>
319         // If requested, dump out to a file for debugging purposes
320         if (dumper != null) {
321             AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
322                 @Override
323                 public Void run() {
324                     dumper.dumpClass(lambdaClassName, classBytes);
325                     return null;
326                 }
327             }, null,
328             new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read, write&quot;),
329             // createDirectories may need it
330             new PropertyPermission(&quot;user.dir&quot;, &quot;read&quot;));
331         }
<span class="line-modified">332 </span>
<span class="line-modified">333         return UNSAFE.defineAnonymousClass(targetClass, classBytes, null);</span>
<span class="line-modified">334     }</span>
<span class="line-modified">335 </span>
<span class="line-modified">336     /**</span>
<span class="line-modified">337      * Generate the factory method for the class</span>
<span class="line-modified">338      */</span>
<span class="line-modified">339     private void generateFactory() {</span>
<span class="line-modified">340         MethodVisitor m = cw.visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_FACTORY, invokedType.toMethodDescriptorString(), null, null);</span>
<span class="line-modified">341         m.visitCode();</span>
<span class="line-modified">342         m.visitTypeInsn(NEW, lambdaClassName);</span>
<span class="line-modified">343         m.visitInsn(Opcodes.DUP);</span>
<span class="line-modified">344         int parameterCount = invokedType.parameterCount();</span>
<span class="line-modified">345         for (int typeIndex = 0, varIndex = 0; typeIndex &lt; parameterCount; typeIndex++) {</span>
<span class="line-modified">346             Class&lt;?&gt; argType = invokedType.parameterType(typeIndex);</span>
<span class="line-modified">347             m.visitVarInsn(getLoadOpcode(argType), varIndex);</span>
<span class="line-modified">348             varIndex += getParameterSize(argType);</span>


349         }
<span class="line-removed">350         m.visitMethodInsn(INVOKESPECIAL, lambdaClassName, NAME_CTOR, constructorType.toMethodDescriptorString(), false);</span>
<span class="line-removed">351         m.visitInsn(ARETURN);</span>
<span class="line-removed">352         m.visitMaxs(-1, -1);</span>
<span class="line-removed">353         m.visitEnd();</span>
354     }
355 
356     /**
357      * Generate the constructor for the class
358      */
359     private void generateConstructor() {
360         // Generate constructor
361         MethodVisitor ctor = cw.visitMethod(ACC_PRIVATE, NAME_CTOR,
362                                             constructorType.toMethodDescriptorString(), null, null);
363         ctor.visitCode();
364         ctor.visitVarInsn(ALOAD, 0);
365         ctor.visitMethodInsn(INVOKESPECIAL, JAVA_LANG_OBJECT, NAME_CTOR,
366                              METHOD_DESCRIPTOR_VOID, false);
367         int parameterCount = invokedType.parameterCount();
368         for (int i = 0, lvIndex = 0; i &lt; parameterCount; i++) {
369             ctor.visitVarInsn(ALOAD, 0);
370             Class&lt;?&gt; argType = invokedType.parameterType(i);
371             ctor.visitVarInsn(getLoadOpcode(argType), lvIndex + 1);
372             lvIndex += getParameterSize(argType);
373             ctor.visitFieldInsn(PUTFIELD, lambdaClassName, argNames[i], argDescs[i]);
</pre>
<hr />
<pre>
449         mv.visitEnd();
450     }
451 
452     /**
453      * This class generates a method body which calls the lambda implementation
454      * method, converting arguments, as needed.
455      */
456     private class ForwardingMethodGenerator extends TypeConvertingMethodAdapter {
457 
458         ForwardingMethodGenerator(MethodVisitor mv) {
459             super(mv);
460         }
461 
462         void generate(MethodType methodType) {
463             visitCode();
464 
465             if (implKind == MethodHandleInfo.REF_newInvokeSpecial) {
466                 visitTypeInsn(NEW, implMethodClassName);
467                 visitInsn(DUP);
468             }




469             for (int i = 0; i &lt; argNames.length; i++) {
470                 visitVarInsn(ALOAD, 0);
471                 visitFieldInsn(GETFIELD, lambdaClassName, argNames[i], argDescs[i]);
472             }
473 
474             convertArgumentTypes(methodType);
475 
<span class="line-modified">476             // Invoke the method we want to forward to</span>
<span class="line-modified">477             visitMethodInsn(invocationOpcode(), implMethodClassName,</span>
<span class="line-modified">478                             implMethodName, implMethodDesc,</span>
<span class="line-modified">479                             implClass.isInterface());</span>
<span class="line-modified">480 </span>





481             // Convert the return value (if any) and return it
482             // Note: if adapting from non-void to void, the &#39;return&#39;
483             // instruction will pop the unneeded result
484             Class&lt;?&gt; implReturnClass = implMethodType.returnType();
485             Class&lt;?&gt; samReturnClass = methodType.returnType();
486             convertType(implReturnClass, samReturnClass, samReturnClass);
487             visitInsn(getReturnOpcode(samReturnClass));
488             // Maxs computed by ClassWriter.COMPUTE_MAXS,these arguments ignored
489             visitMaxs(-1, -1);
490             visitEnd();
491         }
492 
493         private void convertArgumentTypes(MethodType samType) {
494             int lvIndex = 0;
495             int samParametersLength = samType.parameterCount();
496             int captureArity = invokedType.parameterCount();
497             for (int i = 0; i &lt; samParametersLength; i++) {
498                 Class&lt;?&gt; argType = samType.parameterType(i);
499                 visitVarInsn(getLoadOpcode(argType), lvIndex + 1);
500                 lvIndex += getParameterSize(argType);
</pre>
</td>
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.access.JavaLangAccess;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.org.objectweb.asm.*;
 31 import sun.invoke.util.BytecodeDescriptor;

 32 import sun.security.action.GetPropertyAction;
 33 import sun.security.action.GetBooleanAction;
 34 
 35 import java.io.FilePermission;
 36 import java.io.Serializable;
<span class="line-added"> 37 import java.lang.invoke.MethodHandles.Lookup;</span>
 38 import java.lang.reflect.Constructor;
<span class="line-added"> 39 import java.lang.reflect.Modifier;</span>
 40 import java.security.AccessController;
 41 import java.security.PrivilegedAction;
 42 import java.util.LinkedHashSet;
 43 import java.util.concurrent.atomic.AtomicInteger;
 44 import java.util.PropertyPermission;
 45 import java.util.Set;
 46 
<span class="line-added"> 47 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;</span>
<span class="line-added"> 48 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;</span>
 49 import static jdk.internal.org.objectweb.asm.Opcodes.*;
 50 
 51 /**
 52  * Lambda metafactory implementation which dynamically creates an
 53  * inner-class-like class per lambda callsite.
 54  *
 55  * @see LambdaMetafactory
 56  */
 57 /* package */ final class InnerClassLambdaMetafactory extends AbstractValidatingLambdaMetafactory {
<span class="line-modified"> 58     private static final int CLASSFILE_VERSION = 52;</span>


 59     private static final String METHOD_DESCRIPTOR_VOID = Type.getMethodDescriptor(Type.VOID_TYPE);
 60     private static final String JAVA_LANG_OBJECT = &quot;java/lang/Object&quot;;
 61     private static final String NAME_CTOR = &quot;&lt;init&gt;&quot;;

 62 
 63     //Serialization support
 64     private static final String NAME_SERIALIZED_LAMBDA = &quot;java/lang/invoke/SerializedLambda&quot;;
 65     private static final String NAME_NOT_SERIALIZABLE_EXCEPTION = &quot;java/io/NotSerializableException&quot;;
 66     private static final String DESCR_METHOD_WRITE_REPLACE = &quot;()Ljava/lang/Object;&quot;;
 67     private static final String DESCR_METHOD_WRITE_OBJECT = &quot;(Ljava/io/ObjectOutputStream;)V&quot;;
 68     private static final String DESCR_METHOD_READ_OBJECT = &quot;(Ljava/io/ObjectInputStream;)V&quot;;
<span class="line-added"> 69     private static final String DESCR_SET_IMPL_METHOD = &quot;(Ljava/lang/invoke/MethodHandle;)V&quot;;</span>
<span class="line-added"> 70 </span>
 71     private static final String NAME_METHOD_WRITE_REPLACE = &quot;writeReplace&quot;;
 72     private static final String NAME_METHOD_READ_OBJECT = &quot;readObject&quot;;
 73     private static final String NAME_METHOD_WRITE_OBJECT = &quot;writeObject&quot;;
<span class="line-added"> 74     private static final String NAME_FIELD_IMPL_METHOD = &quot;protectedImplMethod&quot;;</span>
 75 
 76     private static final String DESCR_CLASS = &quot;Ljava/lang/Class;&quot;;
 77     private static final String DESCR_STRING = &quot;Ljava/lang/String;&quot;;
 78     private static final String DESCR_OBJECT = &quot;Ljava/lang/Object;&quot;;
<span class="line-added"> 79     private static final String DESCR_METHOD_HANDLE = &quot;Ljava/lang/invoke/MethodHandle;&quot;;</span>
 80     private static final String DESCR_CTOR_SERIALIZED_LAMBDA
 81             = &quot;(&quot; + DESCR_CLASS + DESCR_STRING + DESCR_STRING + DESCR_STRING + &quot;I&quot;
 82             + DESCR_STRING + DESCR_STRING + DESCR_STRING + DESCR_STRING + &quot;[&quot; + DESCR_OBJECT + &quot;)V&quot;;
 83 
 84     private static final String DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION = &quot;(Ljava/lang/String;)V&quot;;
 85     private static final String[] SER_HOSTILE_EXCEPTIONS = new String[] {NAME_NOT_SERIALIZABLE_EXCEPTION};
 86 


 87     private static final String[] EMPTY_STRING_ARRAY = new String[0];
 88 
 89     // Used to ensure that each spun class name is unique
 90     private static final AtomicInteger counter = new AtomicInteger(0);
 91 
 92     // For dumping generated classes to disk, for debugging purposes
 93     private static final ProxyClassesDumper dumper;
 94 
 95     private static final boolean disableEagerInitialization;
 96 
 97     static {
 98         final String dumpProxyClassesKey = &quot;jdk.internal.lambda.dumpProxyClasses&quot;;
 99         String dumpPath = GetPropertyAction.privilegedGetProperty(dumpProxyClassesKey);
100         dumper = (null == dumpPath) ? null : ProxyClassesDumper.getInstance(dumpPath);
101 
102         final String disableEagerInitializationKey = &quot;jdk.internal.lambda.disableEagerInitialization&quot;;
103         disableEagerInitialization = GetBooleanAction.privilegedGetProperty(disableEagerInitializationKey);
104     }
105 
106     // See context values in AbstractValidatingLambdaMetafactory
107     private final String implMethodClassName;        // Name of type containing implementation &quot;CC&quot;
108     private final String implMethodName;             // Name of implementation method &quot;impl&quot;
109     private final String implMethodDesc;             // Type descriptor for implementation methods &quot;(I)Ljava/lang/String;&quot;
110     private final MethodType constructorType;        // Generated class constructor type &quot;(CC)void&quot;
111     private final ClassWriter cw;                    // ASM class writer
112     private final String[] argNames;                 // Generated names for the constructor arguments
113     private final String[] argDescs;                 // Type descriptors for the constructor arguments
114     private final String lambdaClassName;            // Generated name for the generated class &quot;X$$Lambda$1&quot;
<span class="line-added">115     private final boolean useImplMethodHandle;       // use MethodHandle invocation instead of symbolic bytecode invocation</span>
116 
117     /**
118      * General meta-factory constructor, supporting both standard cases and
119      * allowing for uncommon options such as serialization or bridging.
120      *
121      * @param caller Stacked automatically by VM; represents a lookup context
122      *               with the accessibility privileges of the caller.
123      * @param invokedType Stacked automatically by VM; the signature of the
124      *                    invoked method, which includes the expected static
125      *                    type of the returned lambda object, and the static
126      *                    types of the captured arguments for the lambda.  In
127      *                    the event that the implementation method is an
128      *                    instance method, the first argument in the invocation
129      *                    signature will correspond to the receiver.
130      * @param samMethodName Name of the method in the functional interface to
131      *                      which the lambda or method reference is being
132      *                      converted, represented as a String.
133      * @param samMethodType Type of the method in the functional interface to
134      *                      which the lambda or method reference is being
135      *                      converted, represented as a MethodType.
</pre>
<hr />
<pre>
151      * @throws LambdaConversionException If any of the meta-factory protocol
152      * invariants are violated
153      */
154     public InnerClassLambdaMetafactory(MethodHandles.Lookup caller,
155                                        MethodType invokedType,
156                                        String samMethodName,
157                                        MethodType samMethodType,
158                                        MethodHandle implMethod,
159                                        MethodType instantiatedMethodType,
160                                        boolean isSerializable,
161                                        Class&lt;?&gt;[] markerInterfaces,
162                                        MethodType[] additionalBridges)
163             throws LambdaConversionException {
164         super(caller, invokedType, samMethodName, samMethodType,
165               implMethod, instantiatedMethodType,
166               isSerializable, markerInterfaces, additionalBridges);
167         implMethodClassName = implClass.getName().replace(&#39;.&#39;, &#39;/&#39;);
168         implMethodName = implInfo.getName();
169         implMethodDesc = implInfo.getMethodType().toMethodDescriptorString();
170         constructorType = invokedType.changeReturnType(Void.TYPE);
<span class="line-modified">171         lambdaClassName = lambdaClassName(targetClass);</span>
<span class="line-added">172         useImplMethodHandle = !implClass.getPackageName().equals(implInfo.getDeclaringClass().getPackageName())</span>
<span class="line-added">173                                 &amp;&amp; !Modifier.isPublic(implInfo.getModifiers());</span>
174         cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
175         int parameterCount = invokedType.parameterCount();
176         if (parameterCount &gt; 0) {
177             argNames = new String[parameterCount];
178             argDescs = new String[parameterCount];
179             for (int i = 0; i &lt; parameterCount; i++) {
180                 argNames[i] = &quot;arg$&quot; + (i + 1);
181                 argDescs[i] = BytecodeDescriptor.unparse(invokedType.parameterType(i));
182             }
183         } else {
184             argNames = argDescs = EMPTY_STRING_ARRAY;
185         }
186     }
187 
<span class="line-added">188     private static String lambdaClassName(Class&lt;?&gt; targetClass) {</span>
<span class="line-added">189         String name = targetClass.getName();</span>
<span class="line-added">190         if (targetClass.isHidden()) {</span>
<span class="line-added">191             // use the original class name</span>
<span class="line-added">192             name = name.replace(&#39;/&#39;, &#39;_&#39;);</span>
<span class="line-added">193         }</span>
<span class="line-added">194         return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$Lambda$&quot; + counter.incrementAndGet();</span>
<span class="line-added">195     }</span>
<span class="line-added">196 </span>
197     /**
198      * Build the CallSite. Generate a class file which implements the functional
199      * interface, define the class, if there are no parameters create an instance
200      * of the class which the CallSite will return, otherwise, generate handles
201      * which will call the class&#39; constructor.
202      *
203      * @return a CallSite, which, when invoked, will return an instance of the
204      * functional interface
205      * @throws ReflectiveOperationException
206      * @throws LambdaConversionException If properly formed functional interface
207      * is not found
208      */
209     @Override
210     CallSite buildCallSite() throws LambdaConversionException {
211         final Class&lt;?&gt; innerClass = spinInnerClass();
212         if (invokedType.parameterCount() == 0 &amp;&amp; !disableEagerInitialization) {
213             // In the case of a non-capturing lambda, we optimize linkage by pre-computing a single instance,
214             // unless we&#39;ve suppressed eager initialization
215             final Constructor&lt;?&gt;[] ctrs = AccessController.doPrivileged(
216                     new PrivilegedAction&lt;&gt;() {
217                 @Override
218                 public Constructor&lt;?&gt;[] run() {
219                     Constructor&lt;?&gt;[] ctrs = innerClass.getDeclaredConstructors();
220                     if (ctrs.length == 1) {
221                         // The lambda implementing inner class constructor is private, set
222                         // it accessible (by us) before creating the constant sole instance
223                         ctrs[0].setAccessible(true);
224                     }
225                     return ctrs;
226                 }
227                     });
228             if (ctrs.length != 1) {
229                 throw new LambdaConversionException(&quot;Expected one lambda constructor for &quot;
230                         + innerClass.getCanonicalName() + &quot;, got &quot; + ctrs.length);
231             }
232 
233             try {
234                 Object inst = ctrs[0].newInstance();
235                 return new ConstantCallSite(MethodHandles.constant(samBase, inst));
<span class="line-modified">236             } catch (ReflectiveOperationException e) {</span>

237                 throw new LambdaConversionException(&quot;Exception instantiating lambda object&quot;, e);
238             }
239         } else {
240             try {
<span class="line-modified">241                 MethodHandle mh = caller.findConstructor(innerClass, invokedType.changeReturnType(void.class));</span>
<span class="line-modified">242                 return new ConstantCallSite(mh.asType(invokedType));</span>
<span class="line-modified">243             } catch (ReflectiveOperationException e) {</span>





244                 throw new LambdaConversionException(&quot;Exception finding constructor&quot;, e);
245             }
246         }
247     }
248 
249     /**
250      * Generate a class file which implements the functional
251      * interface, define and return the class.
252      *
253      * @implNote The class that is generated does not include signature
254      * information for exceptions that may be present on the SAM method.
255      * This is to reduce classfile size, and is harmless as checked exceptions
256      * are erased anyway, no one will ever compile against this classfile,
257      * and we make no guarantees about the reflective properties of lambda
258      * objects.
259      *
260      * @return a Class which implements the functional interface
261      * @throws LambdaConversionException If properly formed functional interface
262      * is not found
263      */
</pre>
<hr />
<pre>
276                 accidentallySerializable |= !isSerializable &amp;&amp; Serializable.class.isAssignableFrom(markerInterface);
277             }
278             interfaces = itfs.toArray(new String[itfs.size()]);
279         }
280 
281         cw.visit(CLASSFILE_VERSION, ACC_SUPER + ACC_FINAL + ACC_SYNTHETIC,
282                  lambdaClassName, null,
283                  JAVA_LANG_OBJECT, interfaces);
284 
285         // Generate final fields to be filled in by constructor
286         for (int i = 0; i &lt; argDescs.length; i++) {
287             FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_FINAL,
288                                             argNames[i],
289                                             argDescs[i],
290                                             null, null);
291             fv.visitEnd();
292         }
293 
294         generateConstructor();
295 




296         // Forward the SAM method
297         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, samMethodName,
298                                           samMethodType.toMethodDescriptorString(), null, null);

299         new ForwardingMethodGenerator(mv).generate(samMethodType);
300 
301         // Forward the bridges
302         if (additionalBridges != null) {
303             for (MethodType mt : additionalBridges) {
304                 mv = cw.visitMethod(ACC_PUBLIC|ACC_BRIDGE, samMethodName,
305                                     mt.toMethodDescriptorString(), null, null);

306                 new ForwardingMethodGenerator(mv).generate(mt);
307             }
308         }
309 
<span class="line-added">310         if (useImplMethodHandle) {</span>
<span class="line-added">311             FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_STATIC,</span>
<span class="line-added">312                                             NAME_FIELD_IMPL_METHOD,</span>
<span class="line-added">313                                             DESCR_METHOD_HANDLE,</span>
<span class="line-added">314                                             null, null);</span>
<span class="line-added">315             fv.visitEnd();</span>
<span class="line-added">316         }</span>
<span class="line-added">317 </span>
318         if (isSerializable)
319             generateSerializationFriendlyMethods();
320         else if (accidentallySerializable)
321             generateSerializationHostileMethods();
322 
323         cw.visitEnd();
324 
325         // Define the generated class in this VM.
326 
327         final byte[] classBytes = cw.toByteArray();

328         // If requested, dump out to a file for debugging purposes
329         if (dumper != null) {
330             AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
331                 @Override
332                 public Void run() {
333                     dumper.dumpClass(lambdaClassName, classBytes);
334                     return null;
335                 }
336             }, null,
337             new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read, write&quot;),
338             // createDirectories may need it
339             new PropertyPermission(&quot;user.dir&quot;, &quot;read&quot;));
340         }
<span class="line-modified">341         try {</span>
<span class="line-modified">342             // this class is linked at the indy callsite; so define a hidden nestmate</span>
<span class="line-modified">343             Lookup lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);</span>
<span class="line-modified">344             if (useImplMethodHandle) {</span>
<span class="line-modified">345                 // If the target class invokes a method reference this::m which is</span>
<span class="line-modified">346                 // resolved to a protected method inherited from a superclass in a different</span>
<span class="line-modified">347                 // package, the target class does not have a bridge and this method reference</span>
<span class="line-modified">348                 // has been changed from public to protected after the target class was compiled.</span>
<span class="line-modified">349                 // This lambda proxy class has no access to the resolved method.</span>
<span class="line-modified">350                 // So this workaround by passing the live implMethod method handle</span>
<span class="line-modified">351                 // to the proxy class to invoke directly.</span>
<span class="line-modified">352                 MethodHandle mh = lookup.findStaticSetter(lookup.lookupClass(), NAME_FIELD_IMPL_METHOD, MethodHandle.class);</span>
<span class="line-modified">353                 mh.invokeExact(implMethod);</span>
<span class="line-modified">354             }</span>
<span class="line-modified">355             return lookup.lookupClass();</span>
<span class="line-modified">356         } catch (IllegalAccessException e) {</span>
<span class="line-modified">357             throw new LambdaConversionException(&quot;Exception defining lambda proxy class&quot;, e);</span>
<span class="line-added">358         } catch (Throwable t) {</span>
<span class="line-added">359             throw new InternalError(t);</span>
360         }




361     }
362 
363     /**
364      * Generate the constructor for the class
365      */
366     private void generateConstructor() {
367         // Generate constructor
368         MethodVisitor ctor = cw.visitMethod(ACC_PRIVATE, NAME_CTOR,
369                                             constructorType.toMethodDescriptorString(), null, null);
370         ctor.visitCode();
371         ctor.visitVarInsn(ALOAD, 0);
372         ctor.visitMethodInsn(INVOKESPECIAL, JAVA_LANG_OBJECT, NAME_CTOR,
373                              METHOD_DESCRIPTOR_VOID, false);
374         int parameterCount = invokedType.parameterCount();
375         for (int i = 0, lvIndex = 0; i &lt; parameterCount; i++) {
376             ctor.visitVarInsn(ALOAD, 0);
377             Class&lt;?&gt; argType = invokedType.parameterType(i);
378             ctor.visitVarInsn(getLoadOpcode(argType), lvIndex + 1);
379             lvIndex += getParameterSize(argType);
380             ctor.visitFieldInsn(PUTFIELD, lambdaClassName, argNames[i], argDescs[i]);
</pre>
<hr />
<pre>
456         mv.visitEnd();
457     }
458 
459     /**
460      * This class generates a method body which calls the lambda implementation
461      * method, converting arguments, as needed.
462      */
463     private class ForwardingMethodGenerator extends TypeConvertingMethodAdapter {
464 
465         ForwardingMethodGenerator(MethodVisitor mv) {
466             super(mv);
467         }
468 
469         void generate(MethodType methodType) {
470             visitCode();
471 
472             if (implKind == MethodHandleInfo.REF_newInvokeSpecial) {
473                 visitTypeInsn(NEW, implMethodClassName);
474                 visitInsn(DUP);
475             }
<span class="line-added">476             if (useImplMethodHandle) {</span>
<span class="line-added">477                 visitVarInsn(ALOAD, 0);</span>
<span class="line-added">478                 visitFieldInsn(GETSTATIC, lambdaClassName, NAME_FIELD_IMPL_METHOD, DESCR_METHOD_HANDLE);</span>
<span class="line-added">479             }</span>
480             for (int i = 0; i &lt; argNames.length; i++) {
481                 visitVarInsn(ALOAD, 0);
482                 visitFieldInsn(GETFIELD, lambdaClassName, argNames[i], argDescs[i]);
483             }
484 
485             convertArgumentTypes(methodType);
486 
<span class="line-modified">487             if (useImplMethodHandle) {</span>
<span class="line-modified">488                 MethodType mtype = implInfo.getMethodType().insertParameterTypes(0, implClass);</span>
<span class="line-modified">489                 visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandle&quot;,</span>
<span class="line-modified">490                                 &quot;invokeExact&quot;, mtype.descriptorString(), false);</span>
<span class="line-modified">491             } else {</span>
<span class="line-added">492                 // Invoke the method we want to forward to</span>
<span class="line-added">493                 visitMethodInsn(invocationOpcode(), implMethodClassName,</span>
<span class="line-added">494                                 implMethodName, implMethodDesc,</span>
<span class="line-added">495                                 implClass.isInterface());</span>
<span class="line-added">496             }</span>
497             // Convert the return value (if any) and return it
498             // Note: if adapting from non-void to void, the &#39;return&#39;
499             // instruction will pop the unneeded result
500             Class&lt;?&gt; implReturnClass = implMethodType.returnType();
501             Class&lt;?&gt; samReturnClass = methodType.returnType();
502             convertType(implReturnClass, samReturnClass, samReturnClass);
503             visitInsn(getReturnOpcode(samReturnClass));
504             // Maxs computed by ClassWriter.COMPUTE_MAXS,these arguments ignored
505             visitMaxs(-1, -1);
506             visitEnd();
507         }
508 
509         private void convertArgumentTypes(MethodType samType) {
510             int lvIndex = 0;
511             int samParametersLength = samType.parameterCount();
512             int captureArity = invokedType.parameterCount();
513             for (int i = 0; i &lt; samParametersLength; i++) {
514                 Class&lt;?&gt; argType = samType.parameterType(i);
515                 visitVarInsn(getLoadOpcode(argType), lvIndex + 1);
516                 lvIndex += getParameterSize(argType);
</pre>
</td>
</tr>
</table>
<center><a href="GenerateJLIClassesHelper.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="InvokerBytecodeGenerator.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
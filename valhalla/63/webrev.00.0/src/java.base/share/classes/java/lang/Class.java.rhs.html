<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1994, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
<a name="1" id="anc1"></a><span class="line-added">  31 import java.lang.invoke.MethodHandles;</span>
  32 import java.lang.module.ModuleReader;
  33 import java.lang.ref.SoftReference;
  34 import java.io.IOException;
  35 import java.io.InputStream;
  36 import java.io.ObjectStreamField;
  37 import java.lang.reflect.AnnotatedElement;
  38 import java.lang.reflect.AnnotatedType;
  39 import java.lang.reflect.Array;
  40 import java.lang.reflect.Constructor;
  41 import java.lang.reflect.Executable;
  42 import java.lang.reflect.Field;
  43 import java.lang.reflect.GenericArrayType;
  44 import java.lang.reflect.GenericDeclaration;
  45 import java.lang.reflect.InvocationTargetException;
  46 import java.lang.reflect.Member;
  47 import java.lang.reflect.Method;
  48 import java.lang.reflect.Modifier;
  49 import java.lang.reflect.Proxy;
  50 import java.lang.reflect.RecordComponent;
  51 import java.lang.reflect.Type;
  52 import java.lang.reflect.TypeVariable;
  53 import java.lang.constant.Constable;
  54 import java.net.URL;
  55 import java.security.AccessController;
  56 import java.security.PrivilegedAction;
  57 import java.util.ArrayList;
  58 import java.util.Arrays;
  59 import java.util.Collection;
  60 import java.util.HashMap;
  61 import java.util.LinkedHashMap;
  62 import java.util.LinkedHashSet;
  63 import java.util.List;
  64 import java.util.Map;
  65 import java.util.Objects;
  66 import java.util.Optional;
  67 import java.util.stream.Collectors;
  68 
  69 import jdk.internal.HotSpotIntrinsicCandidate;
  70 import jdk.internal.loader.BootLoader;
  71 import jdk.internal.loader.BuiltinClassLoader;
  72 import jdk.internal.misc.Unsafe;
  73 import jdk.internal.module.Resources;
  74 import jdk.internal.reflect.CallerSensitive;
  75 import jdk.internal.reflect.ConstantPool;
  76 import jdk.internal.reflect.Reflection;
  77 import jdk.internal.reflect.ReflectionFactory;
  78 import jdk.internal.vm.annotation.ForceInline;
  79 import sun.invoke.util.Wrapper;
  80 import sun.reflect.generics.factory.CoreReflectionFactory;
  81 import sun.reflect.generics.factory.GenericsFactory;
  82 import sun.reflect.generics.repository.ClassRepository;
  83 import sun.reflect.generics.repository.MethodRepository;
  84 import sun.reflect.generics.repository.ConstructorRepository;
  85 import sun.reflect.generics.scope.ClassScope;
  86 import sun.security.util.SecurityConstants;
  87 import sun.reflect.annotation.*;
  88 import sun.reflect.misc.ReflectUtil;
  89 
  90 /**
  91  * Instances of the class {@code Class} represent classes and
  92  * interfaces in a running Java application. An enum type and a record
  93  * type are kinds of class; an annotation type is a kind of
  94  * interface. Every array also belongs to a class that is reflected as
  95  * a {@code Class} object that is shared by all arrays with the same
  96  * element type and number of dimensions.  The primitive Java types
  97  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  98  * int}, {@code long}, {@code float}, and {@code double}), and the
  99  * keyword {@code void} are also represented as {@code Class} objects.
 100  *
 101  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
<a name="2" id="anc2"></a><span class="line-modified"> 102  * object is constructed automatically by the Java Virtual Machine when</span>
<span class="line-modified"> 103  * a class is derived from the bytes of a {@code class} file through</span>
<span class="line-modified"> 104  * the invocation of one of the following methods:</span>
<span class="line-modified"> 105  * &lt;ul&gt;</span>
<span class="line-added"> 106  * &lt;li&gt; {@link ClassLoader#defineClass(String, byte[], int, int) ClassLoader::defineClass}</span>
<span class="line-added"> 107  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])</span>
<span class="line-added"> 108  *      java.lang.invoke.MethodHandles.Lookup::defineClass}</span>
<span class="line-added"> 109  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added"> 110  *      java.lang.invoke.MethodHandles.Lookup::defineHiddenClass}</span>
<span class="line-added"> 111  * &lt;/ul&gt;</span>
 112  *
 113  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 114  * class or interface. Most characteristics are derived from the {@code class}
<a name="3" id="anc3"></a><span class="line-modified"> 115  * file that the class loader passed to the Java Virtual Machine or</span>
<span class="line-modified"> 116  * from the {@code class} file passed to {@code Lookup::defineClass}</span>
<span class="line-modified"> 117  * or {@code Lookup::defineHiddenClass}.</span>
<span class="line-added"> 118  * A few characteristics are determined by the class loading environment</span>
<span class="line-added"> 119  * at run time, such as the module returned by {@link #getModule() getModule()}.</span>
<span class="line-added"> 120  *</span>
<span class="line-added"> 121  * &lt;p&gt; The following example uses a {@code Class} object to print the</span>
<span class="line-added"> 122  * class name of an object:</span>
<span class="line-added"> 123  *</span>
<span class="line-added"> 124  * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added"> 125  *     void printClassName(Object obj) {</span>
<span class="line-added"> 126  *         System.out.println(&quot;The class of &quot; + obj +</span>
<span class="line-added"> 127  *                            &quot; is &quot; + obj.getClass().getName());</span>
<span class="line-added"> 128  *     }</span>
<span class="line-added"> 129  * &lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added"> 130  *</span>
<span class="line-added"> 131  * It is also possible to get the {@code Class} object for a named</span>
<span class="line-added"> 132  * type (or for {@code void}) using a &lt;i&gt;class literal&lt;/i&gt;.</span>
<span class="line-added"> 133  * For example:</span>
<span class="line-added"> 134  *</span>
<span class="line-added"> 135  * &lt;blockquote&gt;</span>
<span class="line-added"> 136  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}</span>
<span class="line-added"> 137  * &lt;/blockquote&gt;</span>
 138  *
 139  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 140  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 141  * another declaration. Other methods describe how a class or interface
 142  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 143  * classes and interfaces, in the same run-time package, that
 144  * allow mutual access to their {@code private} members.
 145  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 146  * One nestmate acts as the
 147  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 148  * belong to the nest; each of them in turn records it as the nest host.
 149  * The classes and interfaces which belong to a nest, including its host, are
 150  * determined when
 151  * {@code class} files are generated, for example, a Java compiler
 152  * will typically record a top-level class as the host of a nest where the
 153  * other members are the classes and interfaces whose declarations are
 154  * enclosed within the top-level class declaration.
 155  *
<a name="4" id="anc4"></a><span class="line-modified"> 156  * &lt;p&gt; A class or interface created by the invocation of</span>
<span class="line-modified"> 157  * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-modified"> 158  * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() &lt;em&gt;hidden&lt;/em&gt;}</span>
<span class="line-modified"> 159  * class or interface.</span>
<span class="line-modified"> 160  * All kinds of class, including enum types and record types, may be</span>
<span class="line-modified"> 161  * hidden classes; all kinds of interface, including annotation types,</span>
<span class="line-modified"> 162  * may be hidden interfaces.</span>


 163  *
<a name="5" id="anc5"></a><span class="line-modified"> 164  * The {@linkplain #getName() name of a hidden class or interface} is</span>
<span class="line-modified"> 165  * not a &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;,</span>
<span class="line-modified"> 166  * which means the following:</span>
<span class="line-modified"> 167  * &lt;ul&gt;</span>
<span class="line-added"> 168  * &lt;li&gt;A hidden class or interface cannot be referenced by the constant pools</span>
<span class="line-added"> 169  *     of other classes and interfaces.</span>
<span class="line-added"> 170  * &lt;li&gt;A hidden class or interface cannot be described in</span>
<span class="line-added"> 171  *     {@linkplain java.lang.constant.ConstantDesc &lt;em&gt;nominal form&lt;/em&gt;} by</span>
<span class="line-added"> 172  *     {@link #describeConstable() Class::describeConstable},</span>
<span class="line-added"> 173  *     {@link ClassDesc#of(String) ClassDesc::of}, or</span>
<span class="line-added"> 174  *     {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}.</span>
<span class="line-added"> 175  * &lt;li&gt;A hidden class or interface cannot be discovered by {@link #forName Class::forName}</span>
<span class="line-added"> 176  *     or {@link ClassLoader#loadClass(String, boolean) ClassLoader::loadClass}.</span>
<span class="line-added"> 177  * &lt;/ul&gt;</span>
 178  *
<a name="6" id="anc6"></a><span class="line-modified"> 179  * A hidden class or interface is never an array class, but may be</span>
<span class="line-modified"> 180  * the element type of an array. In all other respects, the fact that</span>
<span class="line-modified"> 181  * a class or interface is hidden has no bearing on the characteristics</span>
<span class="line-added"> 182  * exposed by the methods of class {@code Class}.</span>
 183  *
 184  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 185  * object.  For example, the type of {@code String.class} is {@code
 186  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 187  * unknown.
 188  *
 189  * @author  unascribed
 190  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 191  * @since   1.0
<a name="7" id="anc7"></a><span class="line-added"> 192  * @jls 15.8.2 Class Literals</span>
 193  */
 194 public final class Class&lt;T&gt; implements java.io.Serializable,
 195                               GenericDeclaration,
 196                               Type,
 197                               AnnotatedElement,
 198                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 199                               Constable {
 200     private static final int ANNOTATION = 0x00002000;
 201     private static final int ENUM       = 0x00004000;
 202     private static final int SYNTHETIC  = 0x00001000;
 203     private static final int INLINE     = 0x00000100;
 204 
 205     private static native void registerNatives();
 206     static {
 207         registerNatives();
 208     }
 209 
 210     /*
 211      * Private constructor. Only the Java Virtual Machine creates Class objects.
 212      * This constructor is not used and prevents the default constructor being
 213      * generated.
 214      */
 215     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 216         // Initialize final field for classLoader.  The initialization value of non-null
 217         // prevents future JIT optimizations from assuming this final field is null.
 218         classLoader = loader;
 219         componentType = arrayComponentType;
 220     }
 221 
 222     /**
 223      * Converts the object to a string. The string representation is the
 224      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
<a name="8" id="anc8"></a><span class="line-modified"> 225      * name of the class in the format returned by {@code getName}.</span>
<span class="line-modified"> 226      * If this {@code Class} object represents a primitive type,</span>
<span class="line-modified"> 227      * this method returns the name of the primitive type.  If</span>
 228      * this {@code Class} object represents void this method returns
 229      * &quot;void&quot;. If this {@code Class} object represents an array type,
 230      * this method returns &quot;class &quot; followed by {@code getName}.
 231      *
 232      * @return a string representation of this {@code Class} object.
 233      */
 234     public String toString() {
 235         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 236                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 237                + getName();
 238     }
 239 
 240     /**
 241      * Returns a string describing this {@code Class}, including
 242      * information about modifiers and type parameters.
 243      *
 244      * The string is formatted as a list of type modifiers, if any,
 245      * followed by the kind of type (empty string for primitive types
 246      * and {@code class}, {@code enum}, {@code interface},
 247      * {@code @interface}, or {@code record} as appropriate), followed
 248      * by the type&#39;s name, followed by an angle-bracketed
 249      * comma-separated list of the type&#39;s type parameters, if any,
 250      * including informative bounds on the type parameters, if any.
 251      *
 252      * A space is used to separate modifiers from one another and to
 253      * separate any modifiers from the kind of type. The modifiers
 254      * occur in canonical order. If there are no type parameters, the
 255      * type parameter list is elided.
 256      *
 257      * For an array type, the string starts with the type name,
 258      * followed by an angle-bracketed comma-separated list of the
 259      * type&#39;s type parameters, if any, followed by a sequence of
 260      * {@code []} characters, one set of brackets per dimension of
 261      * the array.
 262      *
 263      * &lt;p&gt;Note that since information about the runtime representation
 264      * of a type is being generated, modifiers not present on the
 265      * originating source code or illegal on the originating source
 266      * code may be present.
 267      *
 268      * @return a string describing this {@code Class}, including
 269      * information about modifiers and type parameters
 270      *
 271      * @since 1.8
 272      */
 273     @SuppressWarnings(&quot;preview&quot;)
 274     public String toGenericString() {
 275         if (isPrimitive()) {
 276             return toString();
 277         } else {
 278             StringBuilder sb = new StringBuilder();
 279             Class&lt;?&gt; component = this;
 280             int arrayDepth = 0;
 281 
 282             if (isArray()) {
 283                 do {
 284                     arrayDepth++;
 285                     component = component.getComponentType();
 286                 } while (component.isArray());
 287                 sb.append(component.getName());
 288             } else {
 289                 // Class modifiers are a superset of interface modifiers
 290                 int modifiers = getModifiers() &amp; Modifier.classModifiers();
 291                 if (modifiers != 0) {
 292                     sb.append(Modifier.toString(modifiers));
 293                     sb.append(&#39; &#39;);
 294                 }
 295 
 296                 if (isAnnotation()) {
 297                     sb.append(&#39;@&#39;);
 298                 }
 299                 if (isInlineClass()) {
 300                     sb.append(&quot;inline&quot;);
 301                     sb.append(&#39; &#39;);
 302                 }
 303                 if (isInterface()) { // Note: all annotation types are interfaces
 304                     sb.append(&quot;interface&quot;);
 305                 } else {
 306                     if (isEnum())
 307                         sb.append(&quot;enum&quot;);
 308                     else if (isRecord())
 309                         sb.append(&quot;record&quot;);
 310                     else
 311                         sb.append(&quot;class&quot;);
 312                 }
 313                 sb.append(&#39; &#39;);
 314                 sb.append(getName());
 315             }
 316 
 317             TypeVariable&lt;?&gt;[] typeparms = component.getTypeParameters();
 318             if (typeparms.length &gt; 0) {
 319                 sb.append(Arrays.stream(typeparms)
 320                           .map(Class::typeVarBounds)
 321                           .collect(Collectors.joining(&quot;,&quot;, &quot;&lt;&quot;, &quot;&gt;&quot;)));
 322             }
 323 
 324             if (arrayDepth &gt; 0) sb.append(&quot;[]&quot;.repeat(arrayDepth));
 325 
 326             return sb.toString();
 327         }
 328     }
 329 
 330     static String typeVarBounds(TypeVariable&lt;?&gt; typeVar) {
 331         Type[] bounds = typeVar.getBounds();
 332         if (bounds.length == 1 &amp;&amp; bounds[0].equals(Object.class)) {
 333             return typeVar.getName();
 334         } else {
 335             return typeVar.getName() + &quot; extends &quot; +
 336                 Arrays.stream(bounds)
 337                 .map(Type::getTypeName)
 338                 .collect(Collectors.joining(&quot; &amp; &quot;));
 339         }
 340     }
 341 
 342     /**
 343      * Returns the {@code Class} object associated with the class or
 344      * interface with the given string name.  Invoking this method is
 345      * equivalent to:
 346      *
 347      * &lt;blockquote&gt;
 348      *  {@code Class.forName(className, true, currentLoader)}
 349      * &lt;/blockquote&gt;
 350      *
 351      * where {@code currentLoader} denotes the defining class loader of
 352      * the current class.
 353      *
 354      * &lt;p&gt; For example, the following code fragment returns the
 355      * runtime {@code Class} descriptor for the class named
 356      * {@code java.lang.Thread}:
 357      *
 358      * &lt;blockquote&gt;
 359      *   {@code Class t = Class.forName(&quot;java.lang.Thread&quot;)}
 360      * &lt;/blockquote&gt;
 361      * &lt;p&gt;
 362      * A call to {@code forName(&quot;X&quot;)} causes the class named
 363      * {@code X} to be initialized.
 364      *
 365      * @param      className   the fully qualified name of the desired class.
 366      * @return     the {@code Class} object for the class with the
 367      *             specified name.
 368      * @throws    LinkageError if the linkage fails
 369      * @throws    ExceptionInInitializerError if the initialization provoked
 370      *            by this method fails
 371      * @throws    ClassNotFoundException if the class cannot be located
 372      *
 373      * @jls 12.2 Loading of Classes and Interfaces
 374      * @jls 12.3 Linking of Classes and Interfaces
 375      * @jls 12.4 Initialization of Classes and Interfaces
 376      */
 377     @CallerSensitive
 378     public static Class&lt;?&gt; forName(String className)
 379                 throws ClassNotFoundException {
 380         Class&lt;?&gt; caller = Reflection.getCallerClass();
 381         return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
 382     }
 383 
 384 
 385     /**
 386      * Returns the {@code Class} object associated with the class or
 387      * interface with the given string name, using the given class loader.
 388      * Given the fully qualified name for a class or interface (in the same
 389      * format returned by {@code getName}) this method attempts to
 390      * locate and load the class or interface.  The specified class
 391      * loader is used to load the class or interface.  If the parameter
 392      * {@code loader} is null, the class is loaded through the bootstrap
 393      * class loader.  The class is initialized only if the
 394      * {@code initialize} parameter is {@code true} and if it has
 395      * not been initialized earlier.
 396      *
 397      * &lt;p&gt; If {@code name} denotes a primitive type or void, an attempt
 398      * will be made to locate a user-defined class in the unnamed package whose
 399      * name is {@code name}. Therefore, this method cannot be used to
 400      * obtain any of the {@code Class} objects representing primitive
 401      * types or void.
 402      *
 403      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 404      * the array class is loaded but not initialized.
 405      *
 406      * &lt;p&gt; For example, in an instance method the expression:
 407      *
 408      * &lt;blockquote&gt;
 409      *  {@code Class.forName(&quot;Foo&quot;)}
 410      * &lt;/blockquote&gt;
 411      *
 412      * is equivalent to:
 413      *
 414      * &lt;blockquote&gt;
 415      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 416      * &lt;/blockquote&gt;
 417      *
 418      * Note that this method throws errors related to loading, linking
 419      * or initializing as specified in Sections {@jls 12.2}, {@jls
 420      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language
 421      * Specification&lt;/cite&gt;.
 422      * Note that this method does not check whether the requested class
 423      * is accessible to its caller.
 424      *
 425      * @param name       fully qualified name of the desired class
 426 
 427      * @param initialize if {@code true} the class will be initialized
 428      *                   (which implies linking). See Section {@jls
 429      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language
 430      *                   Specification&lt;/cite&gt;.
 431      * @param loader     class loader from which the class must be loaded
 432      * @return           class object representing the desired class
 433      *
 434      * @throws    LinkageError if the linkage fails
 435      * @throws    ExceptionInInitializerError if the initialization provoked
 436      *            by this method fails
 437      * @throws    ClassNotFoundException if the class cannot be located by
 438      *            the specified class loader
 439      * @throws    SecurityException
 440      *            if a security manager is present, and the {@code loader} is
 441      *            {@code null}, and the caller&#39;s class loader is not
 442      *            {@code null}, and the caller does not have the
 443      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 444      *
 445      * @see       java.lang.Class#forName(String)
 446      * @see       java.lang.ClassLoader
 447      *
 448      * @jls 12.2 Loading of Classes and Interfaces
 449      * @jls 12.3 Linking of Classes and Interfaces
 450      * @jls 12.4 Initialization of Classes and Interfaces
 451      * @since     1.2
 452      */
 453     @CallerSensitive
 454     public static Class&lt;?&gt; forName(String name, boolean initialize,
 455                                    ClassLoader loader)
 456         throws ClassNotFoundException
 457     {
 458         Class&lt;?&gt; caller = null;
 459         SecurityManager sm = System.getSecurityManager();
 460         if (sm != null) {
 461             // Reflective call to get caller class is only needed if a security manager
 462             // is present.  Avoid the overhead of making this call otherwise.
 463             caller = Reflection.getCallerClass();
 464             if (loader == null) {
 465                 ClassLoader ccl = ClassLoader.getClassLoader(caller);
 466                 if (ccl != null) {
 467                     sm.checkPermission(
 468                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
 469                 }
 470             }
 471         }
 472         return forName0(name, initialize, loader, caller);
 473     }
 474 
 475     /** Called after security check for system loader access checks have been made. */
 476     private static native Class&lt;?&gt; forName0(String name, boolean initialize,
 477                                     ClassLoader loader,
 478                                     Class&lt;?&gt; caller)
 479         throws ClassNotFoundException;
 480 
 481 
 482     /**
 483      * Returns the {@code Class} with the given &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;
 484      * binary name&lt;/a&gt; in the given module.
 485      *
 486      * &lt;p&gt; This method attempts to locate and load the class or interface.
 487      * It does not link the class, and does not run the class initializer.
 488      * If the class is not found, this method returns {@code null}. &lt;/p&gt;
 489      *
 490      * &lt;p&gt; If the class loader of the given module defines other modules and
 491      * the given name is a class defined in a different module, this method
 492      * returns {@code null} after the class is loaded. &lt;/p&gt;
 493      *
 494      * &lt;p&gt; This method does not check whether the requested class is
 495      * accessible to its caller. &lt;/p&gt;
 496      *
 497      * @apiNote
 498      * This method returns {@code null} on failure rather than
 499      * throwing a {@link ClassNotFoundException}, as is done by
 500      * the {@link #forName(String, boolean, ClassLoader)} method.
 501      * The security check is a stack-based permission check if the caller
 502      * loads a class in another module.
 503      *
 504      * @param  module   A module
 505      * @param  name     The &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;
 506      *                  of the class
 507      * @return {@code Class} object of the given name defined in the given module;
 508      *         {@code null} if not found.
 509      *
 510      * @throws NullPointerException if the given module or name is {@code null}
 511      *
 512      * @throws LinkageError if the linkage fails
 513      *
 514      * @throws SecurityException
 515      *         &lt;ul&gt;
 516      *         &lt;li&gt; if the caller is not the specified module and
 517      *         {@code RuntimePermission(&quot;getClassLoader&quot;)} permission is denied; or&lt;/li&gt;
 518      *         &lt;li&gt; access to the module content is denied. For example,
 519      *         permission check will be performed when a class loader calls
 520      *         {@link ModuleReader#open(String)} to read the bytes of a class file
 521      *         in a module.&lt;/li&gt;
 522      *         &lt;/ul&gt;
 523      *
 524      * @jls 12.2 Loading of Classes and Interfaces
 525      * @jls 12.3 Linking of Classes and Interfaces
 526      * @since 9
 527      * @spec JPMS
 528      */
 529     @CallerSensitive
 530     public static Class&lt;?&gt; forName(Module module, String name) {
 531         Objects.requireNonNull(module);
 532         Objects.requireNonNull(name);
 533 
 534         ClassLoader cl;
 535         SecurityManager sm = System.getSecurityManager();
 536         if (sm != null) {
 537             Class&lt;?&gt; caller = Reflection.getCallerClass();
 538             if (caller != null &amp;&amp; caller.getModule() != module) {
 539                 // if caller is null, Class.forName is the last java frame on the stack.
 540                 // java.base has all permissions
 541                 sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);
 542             }
 543             PrivilegedAction&lt;ClassLoader&gt; pa = module::getClassLoader;
 544             cl = AccessController.doPrivileged(pa);
 545         } else {
 546             cl = module.getClassLoader();
 547         }
 548 
 549         if (cl != null) {
 550             return cl.loadClass(module, name);
 551         } else {
 552             return BootLoader.loadClass(module, name);
 553         }
 554     }
 555 
 556     /**
 557      * Returns {@code true} if this class is an inline class.
 558      *
 559      * @return {@code true} if this class is an inline class
 560      * @since Valhalla
 561      */
 562     public boolean isInlineClass() {
 563         return (this.getModifiers() &amp; INLINE) != 0;
 564     }
 565 
 566     /**
 567      * Returns a {@code Class} object representing the &lt;em&gt;value projection&lt;/em&gt;
 568      * type of this class if this {@code Class} is the reference projection type
 569      * of an {@linkplain #isInlineClass() inline class}.  Otherwise an empty
 570      * {@link Optional} is returned.
 571      *
 572      * @return the {@code Class} object representing the value projection type of
 573      *         this class if this class is the reference projection type of an
 574      *         inline class; an empty {@link Optional} otherwise
 575      * @since Valhalla
 576      */
 577     public Optional&lt;Class&lt;T&gt;&gt; valueType() {
 578         return Optional.ofNullable(valType);
 579     }
 580 
 581     /**
 582      * Returns a {@code Class} object representing the &lt;em&gt;reference projection&lt;/em&gt;
 583      * type of this class if this class is an {@linkplain #isInlineClass() inline class}
 584      * with a reference projection.
 585      * If this class is an {@linkplain #isInlineClass() inline class}
 586      * without a reference projection or this class is not an inline class,
 587      * then this method returns an empty {@link Optional}.
 588      *
 589      * @return the {@code Class} object representing the value projection type of
 590      *         this class if this class is the reference projection type of an
 591      *         inline class; an empty {@link Optional} otherwise
 592      * @since Valhalla
 593      */
 594     public Optional&lt;Class&lt;T&gt;&gt; referenceType() {
 595         return valType != null ? Optional.ofNullable(refType) : Optional.of(this);
 596     }
 597 
 598     // set by VM if this class is an inline type
 599     // otherwise, these two fields are null
 600     private transient Class&lt;T&gt; valType;
 601     private transient Class&lt;T&gt; refType;
 602 
 603     /**
 604      * Creates a new instance of the class represented by this {@code Class}
 605      * object.  The class is instantiated as if by a {@code new}
 606      * expression with an empty argument list.  The class is initialized if it
 607      * has not already been initialized.
 608      *
 609      * @deprecated This method propagates any exception thrown by the
 610      * nullary constructor, including a checked exception.  Use of
 611      * this method effectively bypasses the compile-time exception
 612      * checking that would otherwise be performed by the compiler.
 613      * The {@link
 614      * java.lang.reflect.Constructor#newInstance(java.lang.Object...)
 615      * Constructor.newInstance} method avoids this problem by wrapping
 616      * any exception thrown by the constructor in a (checked) {@link
 617      * java.lang.reflect.InvocationTargetException}.
 618      *
 619      * &lt;p&gt;The call
 620      *
 621      * &lt;pre&gt;{@code
 622      * clazz.newInstance()
 623      * }&lt;/pre&gt;
 624      *
 625      * can be replaced by
 626      *
 627      * &lt;pre&gt;{@code
 628      * clazz.getDeclaredConstructor().newInstance()
 629      * }&lt;/pre&gt;
 630      *
 631      * The latter sequence of calls is inferred to be able to throw
 632      * the additional exception types {@link
 633      * InvocationTargetException} and {@link
 634      * NoSuchMethodException}. Both of these exception types are
 635      * subclasses of {@link ReflectiveOperationException}.
 636      *
 637      * @return  a newly allocated instance of the class represented by this
 638      *          object.
 639      * @throws  IllegalAccessException  if the class or its nullary
 640      *          constructor is not accessible.
 641      * @throws  InstantiationException
 642      *          if this {@code Class} represents an abstract class,
 643      *          an interface, an array class, a primitive type, or void;
 644      *          or if the class has no nullary constructor;
 645      *          or if the instantiation fails for some other reason.
 646      * @throws  ExceptionInInitializerError if the initialization
 647      *          provoked by this method fails.
 648      * @throws  SecurityException
 649      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
 650      *          the caller&#39;s class loader is not the same as or an
 651      *          ancestor of the class loader for the current class and
 652      *          invocation of {@link SecurityManager#checkPackageAccess
 653      *          s.checkPackageAccess()} denies access to the package
 654      *          of this class.
 655      */
 656     @CallerSensitive
 657     @Deprecated(since=&quot;9&quot;)
 658     public T newInstance()
 659         throws InstantiationException, IllegalAccessException
 660     {
 661         SecurityManager sm = System.getSecurityManager();
 662         if (sm != null) {
 663             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
 664         }
 665 
 666         // Constructor lookup
 667         Constructor&lt;T&gt; tmpConstructor = cachedConstructor;
 668         if (tmpConstructor == null) {
 669             if (this == Class.class) {
 670                 throw new IllegalAccessException(
 671                     &quot;Can not call newInstance() on the Class for java.lang.Class&quot;
 672                 );
 673             }
 674             try {
 675                 Class&lt;?&gt;[] empty = {};
 676                 final Constructor&lt;T&gt; c = getReflectionFactory().copyConstructor(
 677                     getConstructor0(empty, Member.DECLARED));
 678                 // Disable accessibility checks on the constructor
 679                 // access check is done with the true caller
 680                 java.security.AccessController.doPrivileged(
 681                     new java.security.PrivilegedAction&lt;&gt;() {
 682                         public Void run() {
 683                                 c.setAccessible(true);
 684                                 return null;
 685                             }
 686                         });
 687                 cachedConstructor = tmpConstructor = c;
 688             } catch (NoSuchMethodException e) {
 689                 throw (InstantiationException)
 690                     new InstantiationException(getName()).initCause(e);
 691             }
 692         }
 693 
 694         try {
 695             Class&lt;?&gt; caller = Reflection.getCallerClass();
 696             return getReflectionFactory().newInstance(tmpConstructor, null, caller);
 697         } catch (InvocationTargetException e) {
 698             Unsafe.getUnsafe().throwException(e.getTargetException());
 699             // Not reached
 700             return null;
 701         }
 702     }
 703 
 704     private transient volatile Constructor&lt;T&gt; cachedConstructor;
 705 
 706     /**
 707      * Determines if the specified {@code Object} is assignment-compatible
 708      * with the object represented by this {@code Class}.  This method is
 709      * the dynamic equivalent of the Java language {@code instanceof}
 710      * operator. The method returns {@code true} if the specified
 711      * {@code Object} argument is non-null and can be cast to the
 712      * reference type represented by this {@code Class} object without
 713      * raising a {@code ClassCastException.} It returns {@code false}
 714      * otherwise.
 715      *
 716      * &lt;p&gt; Specifically, if this {@code Class} object represents a
 717      * declared class, this method returns {@code true} if the specified
 718      * {@code Object} argument is an instance of the represented class (or
 719      * of any of its subclasses); it returns {@code false} otherwise. If
 720      * this {@code Class} object represents an array class, this method
 721      * returns {@code true} if the specified {@code Object} argument
 722      * can be converted to an object of the array class by an identity
 723      * conversion or by a widening reference conversion; it returns
 724      * {@code false} otherwise. If this {@code Class} object
 725      * represents an interface, this method returns {@code true} if the
 726      * class or any superclass of the specified {@code Object} argument
 727      * implements this interface; it returns {@code false} otherwise. If
 728      * this {@code Class} object represents a primitive type, this method
 729      * returns {@code false}.
 730      *
 731      * @param   obj the object to check
 732      * @return  true if {@code obj} is an instance of this class
 733      *
 734      * @since 1.1
 735      */
 736     @HotSpotIntrinsicCandidate
 737     public native boolean isInstance(Object obj);
 738 
 739 
 740     /**
 741      * Determines if the class or interface represented by this
 742      * {@code Class} object is either the same as, or is a superclass or
 743      * superinterface of, the class or interface represented by the specified
 744      * {@code Class} parameter. It returns {@code true} if so;
 745      * otherwise it returns {@code false}. If this {@code Class}
 746      * object represents a primitive type, this method returns
 747      * {@code true} if the specified {@code Class} parameter is
 748      * exactly this {@code Class} object; otherwise it returns
 749      * {@code false}.
 750      *
 751      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 752      * specified {@code Class} parameter can be converted to the type
 753      * represented by this {@code Class} object via an identity conversion
 754      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language
 755      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},
 756      * for details.
 757      *
 758      * @param     cls the {@code Class} object to be checked
 759      * @return    the {@code boolean} value indicating whether objects of the
 760      *            type {@code cls} can be assigned to objects of this class
 761      * @throws    NullPointerException if the specified Class parameter is
 762      *            null.
 763      * @since     1.1
 764      */
 765     @HotSpotIntrinsicCandidate
 766     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 767 
 768 
 769     /**
 770      * Determines if this {@code Class} object represents an
 771      * interface type.
 772      *
 773      * @return  {@code true} if this {@code Class} object represents an interface;
 774      *          {@code false} otherwise.
 775      */
 776     @HotSpotIntrinsicCandidate
 777     public native boolean isInterface();
 778 
 779 
 780     /**
 781      * Determines if this {@code Class} object represents an array class.
 782      *
 783      * @return  {@code true} if this {@code Class} object represents an array class;
 784      *          {@code false} otherwise.
 785      * @since   1.1
 786      */
 787     @HotSpotIntrinsicCandidate
 788     public native boolean isArray();
 789 
 790 
 791     /**
 792      * Determines if the specified {@code Class} object represents a
 793      * primitive type.
 794      *
 795      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 796      * the eight primitive types and void.  These are created by the Java
 797      * Virtual Machine, and have the same names as the primitive types that
 798      * they represent, namely {@code boolean}, {@code byte},
 799      * {@code char}, {@code short}, {@code int},
 800      * {@code long}, {@code float}, and {@code double}.
 801      *
 802      * &lt;p&gt; These objects may only be accessed via the following public static
 803      * final variables, and are the only {@code Class} objects for which
 804      * this method returns {@code true}.
 805      *
 806      * @return true if and only if this class represents a primitive type
 807      *
 808      * @see     java.lang.Boolean#TYPE
 809      * @see     java.lang.Character#TYPE
 810      * @see     java.lang.Byte#TYPE
 811      * @see     java.lang.Short#TYPE
 812      * @see     java.lang.Integer#TYPE
 813      * @see     java.lang.Long#TYPE
 814      * @see     java.lang.Float#TYPE
 815      * @see     java.lang.Double#TYPE
 816      * @see     java.lang.Void#TYPE
 817      * @since 1.1
 818      */
 819     @HotSpotIntrinsicCandidate
 820     public native boolean isPrimitive();
 821 
 822     /**
 823      * Returns true if this {@code Class} object represents an annotation
 824      * type.  Note that if this method returns true, {@link #isInterface()}
 825      * would also return true, as all annotation types are also interfaces.
 826      *
 827      * @return {@code true} if this {@code Class} object represents an annotation
 828      *      type; {@code false} otherwise
 829      * @since 1.5
 830      */
 831     public boolean isAnnotation() {
 832         return (getModifiers() &amp; ANNOTATION) != 0;
 833     }
 834 
 835     /**
<a name="9" id="anc9"></a><span class="line-modified"> 836      * Returns {@code true} if and only if this class has the synthetic modifier</span>
<span class="line-modified"> 837      * bit set.</span>
<span class="line-modified"> 838      *</span>
<span class="line-modified"> 839      * @return {@code true} if and only if this class has the synthetic modifier bit set</span>
 840      * @jls 13.1 The Form of a Binary
<a name="10" id="anc10"></a><span class="line-added"> 841      * @jvms 4.1 The {@code ClassFile} Structure</span>
 842      * @since 1.5
 843      */
 844     public boolean isSynthetic() {
 845         return (getModifiers() &amp; SYNTHETIC) != 0;
 846     }
 847 
 848     /**
 849      * Returns the  name of the entity (class, interface, array class,
<a name="11" id="anc11"></a><span class="line-modified"> 850      * primitive type, or void) represented by this {@code Class} object.</span>






 851      *
<a name="12" id="anc12"></a><span class="line-modified"> 852      * &lt;p&gt; If this {@code Class} object represents a class or interface,</span>
<span class="line-modified"> 853      * not an array class, then:</span>
<span class="line-modified"> 854      * &lt;ul&gt;</span>
<span class="line-added"> 855      * &lt;li&gt; If the class or interface is not {@linkplain #isHidden() hidden},</span>
<span class="line-added"> 856      *      then the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;</span>
<span class="line-added"> 857      *      of the class or interface is returned.</span>
<span class="line-added"> 858      * &lt;li&gt; If the class or interface is hidden, then the result is a string</span>
<span class="line-added"> 859      *      of the form: {@code N + &#39;/&#39; + &lt;suffix&gt;}</span>
<span class="line-added"> 860      *      where {@code N} is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;</span>
<span class="line-added"> 861      *      indicated by the {@code class} file passed to</span>
<span class="line-added"> 862      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added"> 863      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.</span>
<span class="line-added"> 864      * &lt;/ul&gt;</span>
 865      *
<a name="13" id="anc13"></a><span class="line-modified"> 866      * &lt;p&gt; If this {@code Class} object represents an array class, then</span>
<span class="line-modified"> 867      * the result is a string consisting of one or more &#39;{@code [}&#39; characters</span>
<span class="line-modified"> 868      * representing the depth of the array nesting, followed by the element</span>
<span class="line-modified"> 869      * type as encoded using the following table:</span>
 870      *
 871      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 872      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 873      * &lt;thead&gt;
 874      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 875      * &lt;/thead&gt;
 876      * &lt;tbody style=&quot;text-align:left&quot;&gt;
<a name="14" id="anc14"></a><span class="line-modified"> 877      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}</span>
<span class="line-modified"> 878      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}</span>
<span class="line-modified"> 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}</span>
<span class="line-modified"> 880      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-modified"> 881      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}</span>
<span class="line-modified"> 882      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class} with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-modified"> 883      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code Q}&lt;em&gt;N&lt;/em&gt;{@code ;}</span>
<span class="line-modified"> 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}</span>
<span class="line-modified"> 885      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}</span>
<span class="line-modified"> 886      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}</span>
<span class="line-modified"> 887      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}</span>
<span class="line-modified"> 888      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}</span>
 889      * &lt;/tbody&gt;
 890      * &lt;/table&gt;&lt;/blockquote&gt;
 891      *
<a name="15" id="anc15"></a><span class="line-modified"> 892      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},</span>
<span class="line-modified"> 893      * then the result is a string with the same spelling as the Java language</span>
<span class="line-added"> 894      * keyword which corresponds to the primitive type or {@code void}.</span>
 895      *
 896      * &lt;p&gt; Examples:
 897      * &lt;blockquote&gt;&lt;pre&gt;
 898      * String.class.getName()
 899      *     returns &quot;java.lang.String&quot;
 900      * byte.class.getName()
 901      *     returns &quot;byte&quot;
 902      * Point.class.getName()
 903      *     returns &quot;Point&quot;
 904      * (new Object[3]).getClass().getName()
 905      *     returns &quot;[Ljava.lang.Object;&quot;
 906      * (new Point[3]).getClass().getName()
 907      *     returns &quot;[QPoint;&quot;
 908      * (new Point.ref[3][4]).getClass().getName()
 909      *     returns &quot;[[LPoint$ref;&quot;
 910      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 911      *     returns &quot;[[[[[[[I&quot;
 912      * &lt;/pre&gt;&lt;/blockquote&gt;
 913      *
<a name="16" id="anc16"></a><span class="line-modified"> 914      * @return  the name of the class, interface, or other entity</span>
 915      *          represented by this {@code Class} object.
<a name="17" id="anc17"></a><span class="line-added"> 916      * @jls 13.1 The Form of a Binary</span>
 917      */
 918     public String getName() {
 919         String name = this.name;
 920         return name != null ? name : initClassName();
 921     }
 922 
 923     // Cache the name to reduce the number of calls into the VM.
 924     // This field would be set by VM itself during initClassName call.
 925     private transient String name;
 926     private native String initClassName();
 927 
 928     /**
 929      * Returns the class loader for the class.  Some implementations may use
 930      * null to represent the bootstrap class loader. This method will return
 931      * null in such implementations if this class was loaded by the bootstrap
 932      * class loader.
 933      *
 934      * &lt;p&gt;If this {@code Class} object
 935      * represents a primitive type or void, null is returned.
 936      *
 937      * @return  the class loader that loaded the class or interface
 938      *          represented by this {@code Class} object.
 939      * @throws  SecurityException
 940      *          if a security manager is present, and the caller&#39;s class loader
 941      *          is not {@code null} and is not the same as or an ancestor of the
 942      *          class loader for the class whose class loader is requested,
 943      *          and the caller does not have the
 944      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 945      * @see java.lang.ClassLoader
 946      * @see SecurityManager#checkPermission
 947      * @see java.lang.RuntimePermission
 948      */
 949     @CallerSensitive
 950     @ForceInline // to ensure Reflection.getCallerClass optimization
 951     public ClassLoader getClassLoader() {
 952         ClassLoader cl = getClassLoader0();
 953         if (cl == null)
 954             return null;
 955         SecurityManager sm = System.getSecurityManager();
 956         if (sm != null) {
 957             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 958         }
 959         return cl;
 960     }
 961 
 962     // Package-private to allow ClassLoader access
 963     ClassLoader getClassLoader0() { return classLoader; }
 964 
 965     /**
 966      * Returns the module that this class or interface is a member of.
 967      *
 968      * If this class represents an array type then this method returns the
 969      * {@code Module} for the element type. If this class represents a
 970      * primitive type or void, then the {@code Module} object for the
 971      * {@code java.base} module is returned.
 972      *
 973      * If this class is in an unnamed module then the {@linkplain
 974      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
 975      * loader for this class is returned.
 976      *
 977      * @return the module that this class or interface is a member of
 978      *
 979      * @since 9
 980      * @spec JPMS
 981      */
 982     public Module getModule() {
 983         return module;
 984     }
 985 
 986     // set by VM
 987     private transient Module module;
 988 
 989     // Initialized in JVM not by private constructor
 990     // This field is filtered from reflection access, i.e. getDeclaredField
 991     // will throw NoSuchFieldException
 992     private final ClassLoader classLoader;
 993 
<a name="18" id="anc18"></a><span class="line-added"> 994     // Set by VM</span>
<span class="line-added"> 995     private transient Object classData;</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997     // package-private</span>
<span class="line-added"> 998     Object getClassData() {</span>
<span class="line-added"> 999         return classData;</span>
<span class="line-added">1000     }</span>
<span class="line-added">1001 </span>
1002     /**
1003      * Returns an array of {@code TypeVariable} objects that represent the
1004      * type variables declared by the generic declaration represented by this
1005      * {@code GenericDeclaration} object, in declaration order.  Returns an
1006      * array of length 0 if the underlying generic declaration declares no type
1007      * variables.
1008      *
1009      * @return an array of {@code TypeVariable} objects that represent
1010      *     the type variables declared by this generic declaration
1011      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1012      *     signature of this generic declaration does not conform to
1013      *     the format specified in section {@jvms 4.7.9} of
<a name="19" id="anc19"></a><span class="line-modified">1014      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
1015      * @since 1.5
1016      */
1017     @SuppressWarnings(&quot;unchecked&quot;)
1018     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1019         ClassRepository info = getGenericInfo();
1020         if (info != null)
1021             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1022         else
1023             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1024     }
1025 
1026 
1027     /**
1028      * Returns the {@code Class} representing the direct superclass of the
1029      * entity (class, interface, primitive type or void) represented by
1030      * this {@code Class}.  If this {@code Class} represents either the
1031      * {@code Object} class, an interface, a primitive type, or void, then
1032      * null is returned.  If this {@code Class} object represents an array class
1033      * then the {@code Class} object representing the {@code Object} class is
1034      * returned.
1035      *
1036      * @return the direct superclass of the class represented by this {@code Class} object
1037      */
1038     @HotSpotIntrinsicCandidate
1039     public native Class&lt;? super T&gt; getSuperclass();
1040 
1041 
1042     /**
1043      * Returns the {@code Type} representing the direct superclass of
1044      * the entity (class, interface, primitive type or void) represented by
1045      * this {@code Class} object.
1046      *
1047      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
1048      * object returned must accurately reflect the actual type
1049      * arguments used in the source code. The parameterized type
1050      * representing the superclass is created if it had not been
1051      * created before. See the declaration of {@link
1052      * java.lang.reflect.ParameterizedType ParameterizedType} for the
1053      * semantics of the creation process for parameterized types.  If
1054      * this {@code Class} object represents either the {@code Object}
1055      * class, an interface, a primitive type, or void, then null is
1056      * returned.  If this {@code Class} object represents an array class
1057      * then the {@code Class} object representing the {@code Object} class is
1058      * returned.
1059      *
1060      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1061      *     class signature does not conform to the format specified in
1062      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual
1063      *     Machine Specification&lt;/cite&gt;
1064      * @throws TypeNotPresentException if the generic superclass
1065      *     refers to a non-existent type declaration
1066      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
1067      *     generic superclass refers to a parameterized type that cannot be
1068      *     instantiated  for any reason
1069      * @return the direct superclass of the class represented by this {@code Class} object
1070      * @since 1.5
1071      */
1072     public Type getGenericSuperclass() {
1073         ClassRepository info = getGenericInfo();
1074         if (info == null) {
1075             return getSuperclass();
1076         }
1077 
1078         // Historical irregularity:
1079         // Generic signature marks interfaces with superclass = Object
1080         // but this API returns null for interfaces
1081         if (isInterface()) {
1082             return null;
1083         }
1084 
1085         return info.getSuperclass();
1086     }
1087 
1088     /**
1089      * Gets the package of this class.
1090      *
1091      * &lt;p&gt;If this class represents an array type, a primitive type or void,
1092      * this method returns {@code null}.
1093      *
1094      * @return the package of this class.
1095      * @revised 9
1096      * @spec JPMS
1097      */
1098     public Package getPackage() {
1099         if (isPrimitive() || isArray()) {
1100             return null;
1101         }
1102         ClassLoader cl = getClassLoader0();
1103         return cl != null ? cl.definePackage(this)
1104                           : BootLoader.definePackage(this);
1105     }
1106 
1107     /**
1108      * Returns the fully qualified package name.
1109      *
1110      * &lt;p&gt; If this class is a top level class, then this method returns the fully
1111      * qualified name of the package that the class is a member of, or the
1112      * empty string if the class is in an unnamed package.
1113      *
1114      * &lt;p&gt; If this class is a member class, then this method is equivalent to
1115      * invoking {@code getPackageName()} on the {@linkplain #getEnclosingClass
1116      * enclosing class}.
1117      *
1118      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1119      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1120      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1121      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1122      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1123      *
1124      * &lt;p&gt; If this class represents an array type then this method returns the
1125      * package name of the element type. If this class represents a primitive
1126      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1127      *
1128      * @return the fully qualified package name
1129      *
1130      * @since 9
1131      * @spec JPMS
1132      * @jls 6.7 Fully Qualified Names
1133      */
1134     public String getPackageName() {
1135         String pn = this.packageName;
1136         if (pn == null) {
<a name="20" id="anc20"></a><span class="line-modified">1137             Class&lt;?&gt; c = isArray() ? elementType() : this;</span>



1138             if (c.isPrimitive()) {
1139                 pn = &quot;java.lang&quot;;
1140             } else {
1141                 String cn = c.getName();
1142                 int dot = cn.lastIndexOf(&#39;.&#39;);
1143                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1144             }
1145             this.packageName = pn;
1146         }
1147         return pn;
1148     }
1149 
1150     // cached package name
1151     private transient String packageName;
1152 
1153     /**
1154      * Returns the interfaces directly implemented by the class or interface
1155      * represented by this {@code Class} object.
1156      *
1157      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1158      * containing objects representing all interfaces directly implemented by
1159      * the class.  The order of the interface objects in the array corresponds
1160      * to the order of the interface names in the {@code implements} clause of
1161      * the declaration of the class represented by this {@code Class} object.  For example,
1162      * given the declaration:
1163      * &lt;blockquote&gt;
1164      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1165      * &lt;/blockquote&gt;
1166      * suppose the value of {@code s} is an instance of
1167      * {@code Shimmer}; the value of the expression:
1168      * &lt;blockquote&gt;
1169      * {@code s.getClass().getInterfaces()[0]}
1170      * &lt;/blockquote&gt;
1171      * is the {@code Class} object that represents interface
1172      * {@code FloorWax}; and the value of:
1173      * &lt;blockquote&gt;
1174      * {@code s.getClass().getInterfaces()[1]}
1175      * &lt;/blockquote&gt;
1176      * is the {@code Class} object that represents interface
1177      * {@code DessertTopping}.
1178      *
1179      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1180      * representing all interfaces directly extended by the interface.  The
1181      * order of the interface objects in the array corresponds to the order of
1182      * the interface names in the {@code extends} clause of the declaration of
1183      * the interface represented by this {@code Class} object.
1184      *
1185      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1186      * interfaces, the method returns an array of length 0.
1187      *
1188      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1189      * returns an array of length 0.
1190      *
1191      * &lt;p&gt;If this {@code Class} object represents an array type, the
1192      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1193      * returned in that order.
1194      *
1195      * @return an array of interfaces directly implemented by this class
1196      */
1197     public Class&lt;?&gt;[] getInterfaces() {
1198         // defensively copy before handing over to user code
1199         return getInterfaces(true);
1200     }
1201 
1202     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1203         ReflectionData&lt;T&gt; rd = reflectionData();
1204         if (rd == null) {
1205             // no cloning required
1206             return getInterfaces0();
1207         } else {
1208             Class&lt;?&gt;[] interfaces = rd.interfaces;
1209             if (interfaces == null) {
1210                 interfaces = getInterfaces0();
1211                 rd.interfaces = interfaces;
1212             }
1213             // defensively copy if requested
1214             return cloneArray ? interfaces.clone() : interfaces;
1215         }
1216     }
1217 
1218     private native Class&lt;?&gt;[] getInterfaces0();
1219 
1220     /**
1221      * Returns the {@code Type}s representing the interfaces
1222      * directly implemented by the class or interface represented by
1223      * this {@code Class} object.
1224      *
1225      * &lt;p&gt;If a superinterface is a parameterized type, the
1226      * {@code Type} object returned for it must accurately reflect
1227      * the actual type arguments used in the source code. The
1228      * parameterized type representing each superinterface is created
1229      * if it had not been created before. See the declaration of
1230      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1231      * for the semantics of the creation process for parameterized
1232      * types.
1233      *
1234      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
1235      * containing objects representing all interfaces directly implemented by
1236      * the class.  The order of the interface objects in the array corresponds
1237      * to the order of the interface names in the {@code implements} clause of
1238      * the declaration of the class represented by this {@code Class} object.
1239      *
1240      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects
1241      * representing all interfaces directly extended by the interface.  The
1242      * order of the interface objects in the array corresponds to the order of
1243      * the interface names in the {@code extends} clause of the declaration of
1244      * the interface represented by this {@code Class} object.
1245      *
1246      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no
1247      * interfaces, the method returns an array of length 0.
1248      *
1249      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method
1250      * returns an array of length 0.
1251      *
1252      * &lt;p&gt;If this {@code Class} object represents an array type, the
1253      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1254      * returned in that order.
1255      *
1256      * @throws java.lang.reflect.GenericSignatureFormatError
1257      *     if the generic class signature does not conform to the
1258      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The
1259      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;
1260      * @throws TypeNotPresentException if any of the generic
1261      *     superinterfaces refers to a non-existent type declaration
1262      * @throws java.lang.reflect.MalformedParameterizedTypeException
1263      *     if any of the generic superinterfaces refer to a parameterized
1264      *     type that cannot be instantiated for any reason
1265      * @return an array of interfaces directly implemented by this class
1266      * @since 1.5
1267      */
1268     public Type[] getGenericInterfaces() {
1269         ClassRepository info = getGenericInfo();
1270         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1271     }
1272 
1273 
1274     /**
1275      * Returns the {@code Class} representing the component type of an
1276      * array.  If this class does not represent an array class this method
1277      * returns null.
1278      *
1279      * @return the {@code Class} representing the component type of this
1280      * class if this class is an array
1281      * @see     java.lang.reflect.Array
1282      * @since 1.1
1283      */
1284     public Class&lt;?&gt; getComponentType() {
1285         // Only return for array types. Storage may be reused for Class for instance types.
1286         if (isArray()) {
1287             return componentType;
1288         } else {
1289             return null;
1290         }
1291     }
1292 
1293     private final Class&lt;?&gt; componentType;
1294 
<a name="21" id="anc21"></a><span class="line-added">1295     /*</span>
<span class="line-added">1296      * Returns the {@code Class} representing the element type of an array class.</span>
<span class="line-added">1297      * If this class does not represent an array class, then this method returns</span>
<span class="line-added">1298      * {@code null}.</span>
<span class="line-added">1299      */</span>
<span class="line-added">1300     private Class&lt;?&gt; elementType() {</span>
<span class="line-added">1301         if (!isArray()) return null;</span>
<span class="line-added">1302 </span>
<span class="line-added">1303         Class&lt;?&gt; c = this;</span>
<span class="line-added">1304         while (c.isArray()) {</span>
<span class="line-added">1305             c = c.getComponentType();</span>
<span class="line-added">1306         }</span>
<span class="line-added">1307         return c;</span>
<span class="line-added">1308     }</span>
1309 
1310     /**
1311      * Returns the Java language modifiers for this class or interface, encoded
1312      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1313      * constants for {@code public}, {@code protected},
1314      * {@code private}, {@code final}, {@code static},
1315      * {@code abstract} and {@code interface}; they should be decoded
1316      * using the methods of class {@code Modifier}.
1317      *
1318      * &lt;p&gt; If the underlying class is an array class, then its
1319      * {@code public}, {@code private} and {@code protected}
1320      * modifiers are the same as those of its component type.  If this
1321      * {@code Class} object represents a primitive type or void, its
1322      * {@code public} modifier is always {@code true}, and its
1323      * {@code protected} and {@code private} modifiers are always
1324      * {@code false}. If this {@code Class} object represents an array class, a
1325      * primitive type or void, then its {@code final} modifier is always
1326      * {@code true} and its interface modifier is always
1327      * {@code false}. The values of its other modifiers are not determined
1328      * by this specification.
1329      *
1330      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}
1331      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.
1332      *
1333      * @return the {@code int} representing the modifiers for this class
1334      * @see     java.lang.reflect.Modifier
1335      * @since 1.1
1336      */
1337     @HotSpotIntrinsicCandidate
1338     public native int getModifiers();
1339 
1340     /**
1341      * Gets the signers of this class.
1342      *
1343      * @return  the signers of this class, or null if there are no signers.  In
1344      *          particular, this method returns null if this {@code Class} object represents
1345      *          a primitive type or void.
1346      * @since   1.1
1347      */
1348     public native Object[] getSigners();
1349 
1350     /**
1351      * Set the signers of this class.
1352      */
1353     native void setSigners(Object[] signers);
1354 
1355 
1356     /**
1357      * If this {@code Class} object represents a local or anonymous
1358      * class within a method, returns a {@link
1359      * java.lang.reflect.Method Method} object representing the
1360      * immediately enclosing method of the underlying class. Returns
1361      * {@code null} otherwise.
1362      *
1363      * In particular, this method returns {@code null} if the underlying
1364      * class is a local or anonymous class immediately enclosed by a type
1365      * declaration, instance initializer or static initializer.
1366      *
1367      * @return the immediately enclosing method of the underlying class, if
1368      *     that class is a local or anonymous class; otherwise {@code null}.
1369      *
1370      * @throws SecurityException
1371      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1372      *         following conditions is met:
1373      *
1374      *         &lt;ul&gt;
1375      *
1376      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1377      *         class loader of the enclosing class and invocation of
1378      *         {@link SecurityManager#checkPermission
1379      *         s.checkPermission} method with
1380      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1381      *         denies access to the methods within the enclosing class
1382      *
1383      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1384      *         ancestor of the class loader for the enclosing class and
1385      *         invocation of {@link SecurityManager#checkPackageAccess
1386      *         s.checkPackageAccess()} denies access to the package
1387      *         of the enclosing class
1388      *
1389      *         &lt;/ul&gt;
1390      * @since 1.5
1391      */
1392     @CallerSensitive
1393     public Method getEnclosingMethod() throws SecurityException {
1394         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1395 
1396         if (enclosingInfo == null)
1397             return null;
1398         else {
1399             if (!enclosingInfo.isMethod())
1400                 return null;
1401 
1402             MethodRepository typeInfo = MethodRepository.make(enclosingInfo.getDescriptor(),
1403                                                               getFactory());
1404             Class&lt;?&gt;   returnType       = toClass(typeInfo.getReturnType());
1405             Type []    parameterTypes   = typeInfo.getParameterTypes();
1406             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1407 
1408             // Convert Types to Classes; returned types *should*
1409             // be class objects since the methodDescriptor&#39;s used
1410             // don&#39;t have generics information
1411             for(int i = 0; i &lt; parameterClasses.length; i++)
1412                 parameterClasses[i] = toClass(parameterTypes[i]);
1413 
1414             // Perform access check
1415             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1416             SecurityManager sm = System.getSecurityManager();
1417             if (sm != null) {
1418                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1419                                                      Reflection.getCallerClass(), true);
1420             }
1421             Method[] candidates = enclosingCandidate.privateGetDeclaredMethods(false);
1422 
1423             /*
1424              * Loop over all declared methods; match method name,
1425              * number of and type of parameters, *and* return
1426              * type.  Matching return type is also necessary
1427              * because of covariant returns, etc.
1428              */
1429             ReflectionFactory fact = getReflectionFactory();
1430             for (Method m : candidates) {
1431                 if (m.getName().equals(enclosingInfo.getName()) &amp;&amp;
1432                     arrayContentsEq(parameterClasses,
1433                                     fact.getExecutableSharedParameterTypes(m))) {
1434                     // finally, check return type
1435                     if (m.getReturnType().equals(returnType)) {
1436                         return fact.copyMethod(m);
1437                     }
1438                 }
1439             }
1440 
1441             throw new InternalError(&quot;Enclosing method not found&quot;);
1442         }
1443     }
1444 
1445     private native Object[] getEnclosingMethod0();
1446 
1447     private EnclosingMethodInfo getEnclosingMethodInfo() {
1448         Object[] enclosingInfo = getEnclosingMethod0();
1449         if (enclosingInfo == null)
1450             return null;
1451         else {
1452             return new EnclosingMethodInfo(enclosingInfo);
1453         }
1454     }
1455 
1456     private static final class EnclosingMethodInfo {
1457         private final Class&lt;?&gt; enclosingClass;
1458         private final String name;
1459         private final String descriptor;
1460 
1461         static void validate(Object[] enclosingInfo) {
1462             if (enclosingInfo.length != 3)
1463                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1464             try {
1465                 // The array is expected to have three elements:
1466 
1467                 // the immediately enclosing class
1468                 Class&lt;?&gt; enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1469                 assert(enclosingClass != null);
1470 
1471                 // the immediately enclosing method or constructor&#39;s
1472                 // name (can be null).
1473                 String name = (String)enclosingInfo[1];
1474 
1475                 // the immediately enclosing method or constructor&#39;s
1476                 // descriptor (null iff name is).
1477                 String descriptor = (String)enclosingInfo[2];
1478                 assert((name != null &amp;&amp; descriptor != null) || name == descriptor);
1479             } catch (ClassCastException cce) {
1480                 throw new InternalError(&quot;Invalid type in enclosing method information&quot;, cce);
1481             }
1482         }
1483 
1484         EnclosingMethodInfo(Object[] enclosingInfo) {
1485             validate(enclosingInfo);
1486             this.enclosingClass = (Class&lt;?&gt;)enclosingInfo[0];
1487             this.name = (String)enclosingInfo[1];
1488             this.descriptor = (String)enclosingInfo[2];
1489         }
1490 
1491         boolean isPartial() {
1492             return enclosingClass == null || name == null || descriptor == null;
1493         }
1494 
1495         boolean isConstructor() { return !isPartial() &amp;&amp; &quot;&lt;init&gt;&quot;.equals(name); }
1496 
1497         boolean isMethod() { return !isPartial() &amp;&amp; !isConstructor() &amp;&amp; !&quot;&lt;clinit&gt;&quot;.equals(name); }
1498 
1499         Class&lt;?&gt; getEnclosingClass() { return enclosingClass; }
1500 
1501         String getName() { return name; }
1502 
1503         String getDescriptor() { return descriptor; }
1504 
1505     }
1506 
1507     private static Class&lt;?&gt; toClass(Type o) {
1508         if (o instanceof GenericArrayType)
1509             return Array.newInstance(toClass(((GenericArrayType)o).getGenericComponentType()),
1510                                      0)
1511                 .getClass();
1512         return (Class&lt;?&gt;)o;
1513      }
1514 
1515     /**
1516      * If this {@code Class} object represents a local or anonymous
1517      * class within a constructor, returns a {@link
1518      * java.lang.reflect.Constructor Constructor} object representing
1519      * the immediately enclosing constructor of the underlying
1520      * class. Returns {@code null} otherwise.  In particular, this
1521      * method returns {@code null} if the underlying class is a local
1522      * or anonymous class immediately enclosed by a type declaration,
1523      * instance initializer or static initializer.
1524      *
1525      * @return the immediately enclosing constructor of the underlying class, if
1526      *     that class is a local or anonymous class; otherwise {@code null}.
1527      * @throws SecurityException
1528      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
1529      *         following conditions is met:
1530      *
1531      *         &lt;ul&gt;
1532      *
1533      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
1534      *         class loader of the enclosing class and invocation of
1535      *         {@link SecurityManager#checkPermission
1536      *         s.checkPermission} method with
1537      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
1538      *         denies access to the constructors within the enclosing class
1539      *
1540      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
1541      *         ancestor of the class loader for the enclosing class and
1542      *         invocation of {@link SecurityManager#checkPackageAccess
1543      *         s.checkPackageAccess()} denies access to the package
1544      *         of the enclosing class
1545      *
1546      *         &lt;/ul&gt;
1547      * @since 1.5
1548      */
1549     @CallerSensitive
1550     public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException {
1551         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1552 
1553         if (enclosingInfo == null)
1554             return null;
1555         else {
1556             if (!enclosingInfo.isConstructor())
1557                 return null;
1558 
1559             ConstructorRepository typeInfo = ConstructorRepository.make(enclosingInfo.getDescriptor(),
1560                                                                         getFactory());
1561             Type []    parameterTypes   = typeInfo.getParameterTypes();
1562             Class&lt;?&gt;[] parameterClasses = new Class&lt;?&gt;[parameterTypes.length];
1563 
1564             // Convert Types to Classes; returned types *should*
1565             // be class objects since the methodDescriptor&#39;s used
1566             // don&#39;t have generics information
1567             for(int i = 0; i &lt; parameterClasses.length; i++)
1568                 parameterClasses[i] = toClass(parameterTypes[i]);
1569 
1570             // Perform access check
1571             final Class&lt;?&gt; enclosingCandidate = enclosingInfo.getEnclosingClass();
1572             SecurityManager sm = System.getSecurityManager();
1573             if (sm != null) {
1574                 enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,
1575                                                      Reflection.getCallerClass(), true);
1576             }
1577 
1578             Constructor&lt;?&gt;[] candidates = enclosingCandidate
1579                     .privateGetDeclaredConstructors(false);
1580             /*
1581              * Loop over all declared constructors; match number
1582              * of and type of parameters.
1583              */
1584             ReflectionFactory fact = getReflectionFactory();
1585             for (Constructor&lt;?&gt; c : candidates) {
1586                 if (arrayContentsEq(parameterClasses,
1587                                     fact.getExecutableSharedParameterTypes(c))) {
1588                     return fact.copyConstructor(c);
1589                 }
1590             }
1591 
1592             throw new InternalError(&quot;Enclosing constructor not found&quot;);
1593         }
1594     }
1595 
1596 
1597     /**
1598      * If the class or interface represented by this {@code Class} object
1599      * is a member of another class, returns the {@code Class} object
1600      * representing the class in which it was declared.  This method returns
1601      * null if this class or interface is not a member of any other class.  If
1602      * this {@code Class} object represents an array class, a primitive
1603      * type, or void,then this method returns null.
1604      *
1605      * @return the declaring class for this class
1606      * @throws SecurityException
1607      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1608      *         class loader is not the same as or an ancestor of the class
1609      *         loader for the declaring class and invocation of {@link
1610      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
1611      *         denies access to the package of the declaring class
1612      * @since 1.1
1613      */
1614     @CallerSensitive
1615     public Class&lt;?&gt; getDeclaringClass() throws SecurityException {
1616         final Class&lt;?&gt; candidate = getDeclaringClass0();
1617 
1618         if (candidate != null) {
1619             SecurityManager sm = System.getSecurityManager();
1620             if (sm != null) {
1621                 candidate.checkPackageAccess(sm,
1622                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1623             }
1624         }
1625         return candidate;
1626     }
1627 
1628     private native Class&lt;?&gt; getDeclaringClass0();
1629 
1630 
1631     /**
1632      * Returns the immediately enclosing class of the underlying
1633      * class.  If the underlying class is a top level class this
1634      * method returns {@code null}.
1635      * @return the immediately enclosing class of the underlying class
1636      * @throws     SecurityException
1637      *             If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
1638      *             class loader is not the same as or an ancestor of the class
1639      *             loader for the enclosing class and invocation of {@link
1640      *             SecurityManager#checkPackageAccess s.checkPackageAccess()}
1641      *             denies access to the package of the enclosing class
1642      * @since 1.5
1643      */
1644     @CallerSensitive
1645     public Class&lt;?&gt; getEnclosingClass() throws SecurityException {
1646         // There are five kinds of classes (or interfaces):
1647         // a) Top level classes
1648         // b) Nested classes (static member classes)
1649         // c) Inner classes (non-static member classes)
1650         // d) Local classes (named classes declared within a method)
1651         // e) Anonymous classes
1652 
1653 
1654         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1655         // attribute if and only if it is a local class or an
1656         // anonymous class.
1657         EnclosingMethodInfo enclosingInfo = getEnclosingMethodInfo();
1658         Class&lt;?&gt; enclosingCandidate;
1659 
1660         if (enclosingInfo == null) {
1661             // This is a top level or a nested class or an inner class (a, b, or c)
1662             enclosingCandidate = getDeclaringClass0();
1663         } else {
1664             Class&lt;?&gt; enclosingClass = enclosingInfo.getEnclosingClass();
1665             // This is a local class or an anonymous class (d or e)
1666             if (enclosingClass == this || enclosingClass == null)
1667                 throw new InternalError(&quot;Malformed enclosing method information&quot;);
1668             else
1669                 enclosingCandidate = enclosingClass;
1670         }
1671 
1672         if (enclosingCandidate != null) {
1673             SecurityManager sm = System.getSecurityManager();
1674             if (sm != null) {
1675                 enclosingCandidate.checkPackageAccess(sm,
1676                     ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
1677             }
1678         }
1679         return enclosingCandidate;
1680     }
1681 
1682     /**
1683      * Returns the simple name of the underlying class as given in the
1684      * source code. Returns an empty string if the underlying class is
1685      * anonymous.
1686      *
1687      * &lt;p&gt;The simple name of an array is the simple name of the
1688      * component type with &quot;[]&quot; appended.  In particular the simple
1689      * name of an array whose component type is anonymous is &quot;[]&quot;.
1690      *
1691      * @return the simple name of the underlying class
1692      * @since 1.5
1693      */
1694     public String getSimpleName() {
1695         ReflectionData&lt;T&gt; rd = reflectionData();
1696         String simpleName = rd.simpleName;
1697         if (simpleName == null) {
1698             rd.simpleName = simpleName = getSimpleName0();
1699         }
1700         return simpleName;
1701     }
1702 
1703     private String getSimpleName0() {
1704         if (isArray()) {
1705             return getComponentType().getSimpleName() + &quot;[]&quot;;
1706         }
1707         String simpleName = getSimpleBinaryName();
1708         if (simpleName == null) { // top level class
1709             simpleName = getName();
1710             simpleName = simpleName.substring(simpleName.lastIndexOf(&#39;.&#39;) + 1); // strip the package name
1711         }
1712         return simpleName;
1713     }
1714 
1715     /**
1716      * Return an informative string for the name of this type.
1717      *
1718      * @return an informative string for the name of this type
1719      * @since 1.8
1720      */
1721     public String getTypeName() {
1722         if (isArray()) {
1723             try {
1724                 Class&lt;?&gt; cl = this;
1725                 int dimensions = 0;
1726                 do {
1727                     dimensions++;
1728                     cl = cl.getComponentType();
1729                 } while (cl.isArray());
1730                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1731             } catch (Throwable e) { /*FALLTHRU*/ }
1732         }
1733         return getName();
1734     }
1735 
1736     /**
<a name="22" id="anc22"></a><span class="line-modified">1737      * Returns the canonical name of the underlying class as</span>
<span class="line-modified">1738      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
<span class="line-modified">1739      * Returns {@code null} if the underlying class does not have a canonical</span>
<span class="line-modified">1740      * name. Classes without canonical names include:</span>
<span class="line-modified">1741      * &lt;ul&gt;</span>
<span class="line-added">1742      * &lt;li&gt;a {@linkplain #isLocalClass() local class}</span>
<span class="line-added">1743      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}</span>
<span class="line-added">1744      * &lt;li&gt;a {@linkplain #isHidden() hidden class}</span>
<span class="line-added">1745      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;</span>
<span class="line-added">1746      * &lt;/ul&gt;</span>
<span class="line-added">1747      *</span>
1748      * @return the canonical name of the underlying class if it exists, and
1749      * {@code null} otherwise.
1750      * @since 1.5
1751      */
1752     public String getCanonicalName() {
1753         ReflectionData&lt;T&gt; rd = reflectionData();
1754         String canonicalName = rd.canonicalName;
1755         if (canonicalName == null) {
1756             rd.canonicalName = canonicalName = getCanonicalName0();
1757         }
1758         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1759     }
1760 
1761     private String getCanonicalName0() {
1762         if (isArray()) {
1763             String canonicalName = getComponentType().getCanonicalName();
1764             if (canonicalName != null)
1765                 return canonicalName + &quot;[]&quot;;
1766             else
1767                 return ReflectionData.NULL_SENTINEL;
1768         }
<a name="23" id="anc23"></a><span class="line-modified">1769         if (isHidden() || isLocalOrAnonymousClass())</span>
1770             return ReflectionData.NULL_SENTINEL;
1771         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1772         if (enclosingClass == null) { // top level class
1773             return getName();
1774         } else {
1775             String enclosingName = enclosingClass.getCanonicalName();
1776             if (enclosingName == null)
1777                 return ReflectionData.NULL_SENTINEL;
1778             return enclosingName + &quot;.&quot; + getSimpleName();
1779         }
1780     }
1781 
1782     /**
1783      * Returns {@code true} if and only if the underlying class
1784      * is an anonymous class.
1785      *
<a name="24" id="anc24"></a><span class="line-added">1786      * @apiNote</span>
<span class="line-added">1787      * An anonymous class is not a {@linkplain #isHidden() hidden class}.</span>
<span class="line-added">1788      *</span>
1789      * @return {@code true} if and only if this class is an anonymous class.
1790      * @since 1.5
1791      */
1792     public boolean isAnonymousClass() {
1793         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1794                 getSimpleBinaryName0() == null;
1795     }
1796 
1797     /**
1798      * Returns {@code true} if and only if the underlying class
1799      * is a local class.
1800      *
1801      * @return {@code true} if and only if this class is a local class.
1802      * @since 1.5
1803      */
1804     public boolean isLocalClass() {
1805         return isLocalOrAnonymousClass() &amp;&amp;
1806                 (isArray() || getSimpleBinaryName0() != null);
1807     }
1808 
1809     /**
1810      * Returns {@code true} if and only if the underlying class
1811      * is a member class.
1812      *
1813      * @return {@code true} if and only if this class is a member class.
1814      * @since 1.5
1815      */
1816     public boolean isMemberClass() {
1817         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() != null;
1818     }
1819 
1820     /**
1821      * Returns the &quot;simple binary name&quot; of the underlying class, i.e.,
1822      * the binary name without the leading enclosing class name.
1823      * Returns {@code null} if the underlying class is a top level
1824      * class.
1825      */
1826     private String getSimpleBinaryName() {
1827         if (isTopLevelClass())
1828             return null;
1829         String name = getSimpleBinaryName0();
1830         if (name == null) // anonymous class
1831             return &quot;&quot;;
1832         return name;
1833     }
1834 
1835     private native String getSimpleBinaryName0();
1836 
1837     /**
1838      * Returns {@code true} if this is a top level class.  Returns {@code false}
1839      * otherwise.
1840      */
1841     private boolean isTopLevelClass() {
1842         return !isLocalOrAnonymousClass() &amp;&amp; getDeclaringClass0() == null;
1843     }
1844 
1845     /**
1846      * Returns {@code true} if this is a local class or an anonymous
1847      * class.  Returns {@code false} otherwise.
1848      */
1849     private boolean isLocalOrAnonymousClass() {
1850         // JVM Spec 4.7.7: A class must have an EnclosingMethod
1851         // attribute if and only if it is a local class or an
1852         // anonymous class.
1853         return hasEnclosingMethodInfo();
1854     }
1855 
1856     private boolean hasEnclosingMethodInfo() {
1857         Object[] enclosingInfo = getEnclosingMethod0();
1858         if (enclosingInfo != null) {
1859             EnclosingMethodInfo.validate(enclosingInfo);
1860             return true;
1861         }
1862         return false;
1863     }
1864 
1865     /**
1866      * Returns an array containing {@code Class} objects representing all
1867      * the public classes and interfaces that are members of the class
1868      * represented by this {@code Class} object.  This includes public
1869      * class and interface members inherited from superclasses and public class
1870      * and interface members declared by the class.  This method returns an
1871      * array of length 0 if this {@code Class} object has no public member
1872      * classes or interfaces.  This method also returns an array of length 0 if
1873      * this {@code Class} object represents a primitive type, an array
1874      * class, or void.
1875      *
1876      * @return the array of {@code Class} objects representing the public
1877      *         members of this class
1878      * @throws SecurityException
1879      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1880      *         the caller&#39;s class loader is not the same as or an
1881      *         ancestor of the class loader for the current class and
1882      *         invocation of {@link SecurityManager#checkPackageAccess
1883      *         s.checkPackageAccess()} denies access to the package
1884      *         of this class.
1885      *
1886      * @since 1.1
1887      */
1888     @CallerSensitive
1889     public Class&lt;?&gt;[] getClasses() {
1890         SecurityManager sm = System.getSecurityManager();
1891         if (sm != null) {
1892             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);
1893         }
1894 
1895         // Privileged so this implementation can look at DECLARED classes,
1896         // something the caller might not have privilege to do.  The code here
1897         // is allowed to look at DECLARED classes because (1) it does not hand
1898         // out anything other than public members and (2) public member access
1899         // has already been ok&#39;d by the SecurityManager.
1900 
1901         return java.security.AccessController.doPrivileged(
1902             new java.security.PrivilegedAction&lt;&gt;() {
1903                 public Class&lt;?&gt;[] run() {
1904                     List&lt;Class&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();
1905                     Class&lt;?&gt; currentClass = Class.this;
1906                     while (currentClass != null) {
1907                         for (Class&lt;?&gt; m : currentClass.getDeclaredClasses()) {
1908                             if (Modifier.isPublic(m.getModifiers())) {
1909                                 list.add(m);
1910                             }
1911                         }
1912                         currentClass = currentClass.getSuperclass();
1913                     }
1914                     return list.toArray(new Class&lt;?&gt;[0]);
1915                 }
1916             });
1917     }
1918 
1919 
1920     /**
1921      * Returns an array containing {@code Field} objects reflecting all
1922      * the accessible public fields of the class or interface represented by
1923      * this {@code Class} object.
1924      *
1925      * &lt;p&gt; If this {@code Class} object represents a class or interface with
1926      * no accessible public fields, then this method returns an array of length
1927      * 0.
1928      *
1929      * &lt;p&gt; If this {@code Class} object represents a class, then this method
1930      * returns the public fields of the class and of all its superclasses and
1931      * superinterfaces.
1932      *
1933      * &lt;p&gt; If this {@code Class} object represents an interface, then this
1934      * method returns the fields of the interface and of all its
1935      * superinterfaces.
1936      *
1937      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
1938      * type, or void, then this method returns an array of length 0.
1939      *
1940      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1941      * particular order.
1942      *
1943      * @return the array of {@code Field} objects representing the
1944      *         public fields
1945      * @throws SecurityException
1946      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1947      *         the caller&#39;s class loader is not the same as or an
1948      *         ancestor of the class loader for the current class and
1949      *         invocation of {@link SecurityManager#checkPackageAccess
1950      *         s.checkPackageAccess()} denies access to the package
1951      *         of this class.
1952      *
1953      * @since 1.1
1954      * @jls 8.2 Class Members
1955      * @jls 8.3 Field Declarations
1956      */
1957     @CallerSensitive
1958     public Field[] getFields() throws SecurityException {
1959         SecurityManager sm = System.getSecurityManager();
1960         if (sm != null) {
1961             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1962         }
1963         return copyFields(privateGetPublicFields());
1964     }
1965 
1966 
1967     /**
1968      * Returns an array containing {@code Method} objects reflecting all the
1969      * public methods of the class or interface represented by this {@code
1970      * Class} object, including those declared by the class or interface and
1971      * those inherited from superclasses and superinterfaces.
1972      *
1973      * &lt;p&gt; If this {@code Class} object represents an array type, then the
1974      * returned array has a {@code Method} object for each of the public
1975      * methods inherited by the array type from {@code Object}. It does not
1976      * contain a {@code Method} object for {@code clone()}.
1977      *
1978      * &lt;p&gt; If this {@code Class} object represents an interface then the
1979      * returned array does not contain any implicitly declared methods from
1980      * {@code Object}. Therefore, if no methods are explicitly declared in
1981      * this interface or any of its superinterfaces then the returned array
1982      * has length 0. (Note that a {@code Class} object which represents a class
1983      * always has public methods, inherited from {@code Object}.)
1984      *
1985      * &lt;p&gt; The returned array never contains methods with names &quot;{@code &lt;init&gt;}&quot;
1986      * or &quot;{@code &lt;clinit&gt;}&quot;.
1987      *
1988      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
1989      * particular order.
1990      *
1991      * &lt;p&gt; Generally, the result is computed as with the following 4 step algorithm.
1992      * Let C be the class or interface represented by this {@code Class} object:
1993      * &lt;ol&gt;
1994      * &lt;li&gt; A union of methods is composed of:
1995      *   &lt;ol type=&quot;a&quot;&gt;
1996      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
1997      *        {@link #getDeclaredMethods()} and filtered to include only public
1998      *        methods.&lt;/li&gt;
1999      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2000      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2001      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2002      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2003      *   &lt;/ol&gt;&lt;/li&gt;
2004      * &lt;li&gt; Union from step 1 is partitioned into subsets of methods with same
2005      *      signature (name, parameter types) and return type.&lt;/li&gt;
2006      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2007      *      Let method M be a method from a set of methods with same signature
2008      *      and return type. M is most specific if there is no such method
2009      *      N != M from the same set, such that N is more specific than M.
2010      *      N is more specific than M if:
2011      *   &lt;ol type=&quot;a&quot;&gt;
2012      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2013      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2014      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2015      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2016      *        M and N are the same method).&lt;/li&gt;
2017      *   &lt;/ol&gt;&lt;/li&gt;
2018      * &lt;li&gt; The result of this algorithm is the union of all selected methods from
2019      *      step 3.&lt;/li&gt;
2020      * &lt;/ol&gt;
2021      *
2022      * @apiNote There may be more than one method with a particular name
2023      * and parameter types in a class because while the Java language forbids a
2024      * class to declare multiple methods with the same signature but different
2025      * return types, the Java virtual machine does not.  This
2026      * increased flexibility in the virtual machine can be used to
2027      * implement various language features.  For example, covariant
2028      * returns can be implemented with {@linkplain
2029      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2030      * method and the overriding method would have the same
2031      * signature but different return types.
2032      *
2033      * @return the array of {@code Method} objects representing the
2034      *         public methods of this class
2035      * @throws SecurityException
2036      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2037      *         the caller&#39;s class loader is not the same as or an
2038      *         ancestor of the class loader for the current class and
2039      *         invocation of {@link SecurityManager#checkPackageAccess
2040      *         s.checkPackageAccess()} denies access to the package
2041      *         of this class.
2042      *
2043      * @jls 8.2 Class Members
2044      * @jls 8.4 Method Declarations
2045      * @since 1.1
2046      */
2047     @CallerSensitive
2048     public Method[] getMethods() throws SecurityException {
2049         SecurityManager sm = System.getSecurityManager();
2050         if (sm != null) {
2051             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2052         }
2053         return copyMethods(privateGetPublicMethods());
2054     }
2055 
2056 
2057     /**
2058      * Returns an array containing {@code Constructor} objects reflecting
2059      * all the public constructors of the class represented by this
2060      * {@code Class} object.  An array of length 0 is returned if the
2061      * class has no public constructors, or if the class is an array class, or
2062      * if the class reflects a primitive type or void.
2063      *
2064      * @apiNote
2065      * While this method returns an array of {@code
2066      * Constructor&lt;T&gt;} objects (that is an array of constructors from
2067      * this class), the return type of this method is {@code
2068      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
2069      * might be expected.  This less informative return type is
2070      * necessary since after being returned from this method, the
2071      * array could be modified to hold {@code Constructor} objects for
2072      * different classes, which would violate the type guarantees of
2073      * {@code Constructor&lt;T&gt;[]}.
2074      *
2075      * @return the array of {@code Constructor} objects representing the
2076      *         public constructors of this class
2077      * @throws SecurityException
2078      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2079      *         the caller&#39;s class loader is not the same as or an
2080      *         ancestor of the class loader for the current class and
2081      *         invocation of {@link SecurityManager#checkPackageAccess
2082      *         s.checkPackageAccess()} denies access to the package
2083      *         of this class.
2084      *
2085      * @since 1.1
2086      */
2087     @CallerSensitive
2088     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
2089         SecurityManager sm = System.getSecurityManager();
2090         if (sm != null) {
2091             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2092         }
2093         return copyConstructors(privateGetDeclaredConstructors(true));
2094     }
2095 
2096 
2097     /**
2098      * Returns a {@code Field} object that reflects the specified public member
2099      * field of the class or interface represented by this {@code Class}
2100      * object. The {@code name} parameter is a {@code String} specifying the
2101      * simple name of the desired field.
2102      *
2103      * &lt;p&gt; The field to be reflected is determined by the algorithm that
2104      * follows.  Let C be the class or interface represented by this {@code Class} object:
2105      *
2106      * &lt;OL&gt;
2107      * &lt;LI&gt; If C declares a public field with the name specified, that is the
2108      *      field to be reflected.&lt;/LI&gt;
2109      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
2110      *      recursively to each direct superinterface of C. The direct
2111      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
2112      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
2113      *      superclass S, then this algorithm is invoked recursively upon S.
2114      *      If C has no superclass, then a {@code NoSuchFieldException}
2115      *      is thrown.&lt;/LI&gt;
2116      * &lt;/OL&gt;
2117      *
2118      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2119      * method does not find the {@code length} field of the array type.
2120      *
2121      * @param name the field name
2122      * @return the {@code Field} object of this class specified by
2123      *         {@code name}
2124      * @throws NoSuchFieldException if a field with the specified name is
2125      *         not found.
2126      * @throws NullPointerException if {@code name} is {@code null}
2127      * @throws SecurityException
2128      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2129      *         the caller&#39;s class loader is not the same as or an
2130      *         ancestor of the class loader for the current class and
2131      *         invocation of {@link SecurityManager#checkPackageAccess
2132      *         s.checkPackageAccess()} denies access to the package
2133      *         of this class.
2134      *
2135      * @since 1.1
2136      * @jls 8.2 Class Members
2137      * @jls 8.3 Field Declarations
2138      */
2139     @CallerSensitive
2140     public Field getField(String name)
2141         throws NoSuchFieldException, SecurityException {
2142         Objects.requireNonNull(name);
2143         SecurityManager sm = System.getSecurityManager();
2144         if (sm != null) {
2145             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2146         }
2147         Field field = getField0(name);
2148         if (field == null) {
2149             throw new NoSuchFieldException(name);
2150         }
2151         return getReflectionFactory().copyField(field);
2152     }
2153 
2154 
2155     /**
2156      * Returns a {@code Method} object that reflects the specified public
2157      * member method of the class or interface represented by this
2158      * {@code Class} object. The {@code name} parameter is a
2159      * {@code String} specifying the simple name of the desired method. The
2160      * {@code parameterTypes} parameter is an array of {@code Class}
2161      * objects that identify the method&#39;s formal parameter types, in declared
2162      * order. If {@code parameterTypes} is {@code null}, it is
2163      * treated as if it were an empty array.
2164      *
2165      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2166      * method finds any public method inherited by the array type from
2167      * {@code Object} except method {@code clone()}.
2168      *
2169      * &lt;p&gt; If this {@code Class} object represents an interface then this
2170      * method does not find any implicitly declared method from
2171      * {@code Object}. Therefore, if no methods are explicitly declared in
2172      * this interface or any of its superinterfaces, then this method does not
2173      * find any method.
2174      *
2175      * &lt;p&gt; This method does not find any method with name &quot;{@code &lt;init&gt;}&quot; or
2176      * &quot;{@code &lt;clinit&gt;}&quot;.
2177      *
2178      * &lt;p&gt; Generally, the method to be reflected is determined by the 4 step
2179      * algorithm that follows.
2180      * Let C be the class or interface represented by this {@code Class} object:
2181      * &lt;ol&gt;
2182      * &lt;li&gt; A union of methods is composed of:
2183      *   &lt;ol type=&quot;a&quot;&gt;
2184      *   &lt;li&gt; C&#39;s declared public instance and static methods as returned by
2185      *        {@link #getDeclaredMethods()} and filtered to include only public
2186      *        methods that match given {@code name} and {@code parameterTypes}&lt;/li&gt;
2187      *   &lt;li&gt; If C is a class other than {@code Object}, then include the result
2188      *        of invoking this algorithm recursively on the superclass of C.&lt;/li&gt;
2189      *   &lt;li&gt; Include the results of invoking this algorithm recursively on all
2190      *        direct superinterfaces of C, but include only instance methods.&lt;/li&gt;
2191      *   &lt;/ol&gt;&lt;/li&gt;
2192      * &lt;li&gt; This union is partitioned into subsets of methods with same
2193      *      return type (the selection of methods from step 1 also guarantees that
2194      *      they have the same method name and parameter types).&lt;/li&gt;
2195      * &lt;li&gt; Within each such subset only the most specific methods are selected.
2196      *      Let method M be a method from a set of methods with same VM
2197      *      signature (return type, name, parameter types).
2198      *      M is most specific if there is no such method N != M from the same
2199      *      set, such that N is more specific than M. N is more specific than M
2200      *      if:
2201      *   &lt;ol type=&quot;a&quot;&gt;
2202      *   &lt;li&gt; N is declared by a class and M is declared by an interface; or&lt;/li&gt;
2203      *   &lt;li&gt; N and M are both declared by classes or both by interfaces and
2204      *        N&#39;s declaring type is the same as or a subtype of M&#39;s declaring type
2205      *        (clearly, if M&#39;s and N&#39;s declaring types are the same type, then
2206      *        M and N are the same method).&lt;/li&gt;
2207      *   &lt;/ol&gt;&lt;/li&gt;
2208      * &lt;li&gt; The result of this algorithm is chosen arbitrarily from the methods
2209      *      with most specific return type among all selected methods from step 3.
2210      *      Let R be a return type of a method M from the set of all selected methods
2211      *      from step 3. M is a method with most specific return type if there is
2212      *      no such method N != M from the same set, having return type S != R,
2213      *      such that S is a subtype of R as determined by
2214      *      R.class.{@link #isAssignableFrom}(S.class).
2215      * &lt;/ol&gt;
2216      *
2217      * @apiNote There may be more than one method with matching name and
2218      * parameter types in a class because while the Java language forbids a
2219      * class to declare multiple methods with the same signature but different
2220      * return types, the Java virtual machine does not.  This
2221      * increased flexibility in the virtual machine can be used to
2222      * implement various language features.  For example, covariant
2223      * returns can be implemented with {@linkplain
2224      * java.lang.reflect.Method#isBridge bridge methods}; the bridge
2225      * method and the overriding method would have the same
2226      * signature but different return types. This method would return the
2227      * overriding method as it would have a more specific return type.
2228      *
2229      * @param name the name of the method
2230      * @param parameterTypes the list of parameters
2231      * @return the {@code Method} object that matches the specified
2232      *         {@code name} and {@code parameterTypes}
2233      * @throws NoSuchMethodException if a matching method is not found
2234      *         or if the name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot;.
2235      * @throws NullPointerException if {@code name} is {@code null}
2236      * @throws SecurityException
2237      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2238      *         the caller&#39;s class loader is not the same as or an
2239      *         ancestor of the class loader for the current class and
2240      *         invocation of {@link SecurityManager#checkPackageAccess
2241      *         s.checkPackageAccess()} denies access to the package
2242      *         of this class.
2243      *
2244      * @jls 8.2 Class Members
2245      * @jls 8.4 Method Declarations
2246      * @since 1.1
2247      */
2248     @CallerSensitive
2249     public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)
2250         throws NoSuchMethodException, SecurityException {
2251         Objects.requireNonNull(name);
2252         SecurityManager sm = System.getSecurityManager();
2253         if (sm != null) {
2254             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2255         }
2256         Method method = getMethod0(name, parameterTypes);
2257         if (method == null) {
2258             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2259         }
2260         return getReflectionFactory().copyMethod(method);
2261     }
2262 
2263     /**
2264      * Returns a {@code Constructor} object that reflects the specified
2265      * public constructor of the class represented by this {@code Class}
2266      * object. The {@code parameterTypes} parameter is an array of
2267      * {@code Class} objects that identify the constructor&#39;s formal
2268      * parameter types, in declared order.
2269      *
2270      * If this {@code Class} object represents an inner class
2271      * declared in a non-static context, the formal parameter types
2272      * include the explicit enclosing instance as the first parameter.
2273      *
2274      * &lt;p&gt; The constructor to reflect is the public constructor of the class
2275      * represented by this {@code Class} object whose formal parameter
2276      * types match those specified by {@code parameterTypes}.
2277      *
2278      * @param parameterTypes the parameter array
2279      * @return the {@code Constructor} object of the public constructor that
2280      *         matches the specified {@code parameterTypes}
2281      * @throws NoSuchMethodException if a matching method is not found.
2282      * @throws SecurityException
2283      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
2284      *         the caller&#39;s class loader is not the same as or an
2285      *         ancestor of the class loader for the current class and
2286      *         invocation of {@link SecurityManager#checkPackageAccess
2287      *         s.checkPackageAccess()} denies access to the package
2288      *         of this class.
2289      *
2290      * @since 1.1
2291      */
2292     @CallerSensitive
2293     public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)
2294         throws NoSuchMethodException, SecurityException
2295     {
2296         SecurityManager sm = System.getSecurityManager();
2297         if (sm != null) {
2298             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
2299         }
2300         return getReflectionFactory().copyConstructor(
2301             getConstructor0(parameterTypes, Member.PUBLIC));
2302     }
2303 
2304 
2305     /**
2306      * Returns an array of {@code Class} objects reflecting all the
2307      * classes and interfaces declared as members of the class represented by
2308      * this {@code Class} object. This includes public, protected, default
2309      * (package) access, and private classes and interfaces declared by the
2310      * class, but excludes inherited classes and interfaces.  This method
2311      * returns an array of length 0 if the class declares no classes or
2312      * interfaces as members, or if this {@code Class} object represents a
2313      * primitive type, an array class, or void.
2314      *
2315      * @return the array of {@code Class} objects representing all the
2316      *         declared members of this class
2317      * @throws SecurityException
2318      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2319      *         following conditions is met:
2320      *
2321      *         &lt;ul&gt;
2322      *
2323      *         &lt;li&gt; the caller&#39;s class loader is not the same as the
2324      *         class loader of this class and invocation of
2325      *         {@link SecurityManager#checkPermission
2326      *         s.checkPermission} method with
2327      *         {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2328      *         denies access to the declared classes within this class
2329      *
2330      *         &lt;li&gt; the caller&#39;s class loader is not the same as or an
2331      *         ancestor of the class loader for the current class and
2332      *         invocation of {@link SecurityManager#checkPackageAccess
2333      *         s.checkPackageAccess()} denies access to the package
2334      *         of this class
2335      *
2336      *         &lt;/ul&gt;
2337      *
2338      * @since 1.1
2339      */
2340     @CallerSensitive
2341     public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException {
2342         SecurityManager sm = System.getSecurityManager();
2343         if (sm != null) {
2344             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);
2345         }
2346         return getDeclaredClasses0();
2347     }
2348 
2349 
2350     /**
2351      * Returns an array of {@code Field} objects reflecting all the fields
2352      * declared by the class or interface represented by this
2353      * {@code Class} object. This includes public, protected, default
2354      * (package) access, and private fields, but excludes inherited fields.
2355      *
2356      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2357      * declared fields, then this method returns an array of length 0.
2358      *
2359      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2360      * type, or void, then this method returns an array of length 0.
2361      *
2362      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2363      * particular order.
2364      *
2365      * @return  the array of {@code Field} objects representing all the
2366      *          declared fields of this class
2367      * @throws  SecurityException
2368      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2369      *          following conditions is met:
2370      *
2371      *          &lt;ul&gt;
2372      *
2373      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2374      *          class loader of this class and invocation of
2375      *          {@link SecurityManager#checkPermission
2376      *          s.checkPermission} method with
2377      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2378      *          denies access to the declared fields within this class
2379      *
2380      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2381      *          ancestor of the class loader for the current class and
2382      *          invocation of {@link SecurityManager#checkPackageAccess
2383      *          s.checkPackageAccess()} denies access to the package
2384      *          of this class
2385      *
2386      *          &lt;/ul&gt;
2387      *
2388      * @since 1.1
2389      * @jls 8.2 Class Members
2390      * @jls 8.3 Field Declarations
2391      */
2392     @CallerSensitive
2393     public Field[] getDeclaredFields() throws SecurityException {
2394         SecurityManager sm = System.getSecurityManager();
2395         if (sm != null) {
2396             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2397         }
2398         return copyFields(privateGetDeclaredFields(false));
2399     }
2400 
2401     /**
2402      * {@preview Associated with records, a preview feature of the Java language.
2403      *
2404      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
2405      *           feature of the Java language. Preview features
2406      *           may be removed in a future release, or upgraded to permanent
2407      *           features of the Java language.}
2408      *
2409      * Returns an array of {@code RecordComponent} objects representing all the
2410      * record components of this record class, or {@code null} if this class is
2411      * not a record class.
2412      *
2413      * &lt;p&gt; The components are returned in the same order that they are declared
2414      * in the record header. The array is empty if this record class has no
2415      * components. If the class is not a record class, that is {@link
2416      * #isRecord()} returns {@code false}, then this method returns {@code null}.
2417      * Conversely, if {@link #isRecord()} returns {@code true}, then this method
2418      * returns a non-null value.
2419      *
2420      * @return  An array of {@code RecordComponent} objects representing all the
2421      *          record components of this record class, or {@code null} if this
2422      *          class is not a record class
2423      * @throws  SecurityException
2424      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2425      *          following conditions is met:
2426      *
2427      *          &lt;ul&gt;
2428      *
2429      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2430      *          class loader of this class and invocation of
2431      *          {@link SecurityManager#checkPermission
2432      *          s.checkPermission} method with
2433      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2434      *          denies access to the declared methods within this class
2435      *
2436      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2437      *          ancestor of the class loader for the current class and
2438      *          invocation of {@link SecurityManager#checkPackageAccess
2439      *          s.checkPackageAccess()} denies access to the package
2440      *          of this class
2441      *
2442      *          &lt;/ul&gt;
2443      *
2444      * @jls 8.10 Record Types
2445      * @since 14
2446      */
2447     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
2448                                  essentialAPI=false)
2449     @SuppressWarnings(&quot;preview&quot;)
2450     @CallerSensitive
2451     public RecordComponent[] getRecordComponents() {
2452         SecurityManager sm = System.getSecurityManager();
2453         if (sm != null) {
2454             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2455         }
2456         if (!isRecord()) {
2457             return null;
2458         }
2459         RecordComponent[] recordComponents = getRecordComponents0();
2460         if (recordComponents == null) {
2461             return new RecordComponent[0];
2462         }
2463         return recordComponents;
2464     }
2465 
2466     /**
2467      * Returns an array containing {@code Method} objects reflecting all the
2468      * declared methods of the class or interface represented by this {@code
2469      * Class} object, including public, protected, default (package)
2470      * access, and private methods, but excluding inherited methods.
2471      *
2472      * &lt;p&gt; If this {@code Class} object represents a type that has multiple
2473      * declared methods with the same name and parameter types, but different
2474      * return types, then the returned array has a {@code Method} object for
2475      * each such method.
2476      *
2477      * &lt;p&gt; If this {@code Class} object represents a type that has a class
2478      * initialization method {@code &lt;clinit&gt;}, then the returned array does
2479      * &lt;em&gt;not&lt;/em&gt; have a corresponding {@code Method} object.
2480      *
2481      * &lt;p&gt; If this {@code Class} object represents a class or interface with no
2482      * declared methods, then the returned array has length 0.
2483      *
2484      * &lt;p&gt; If this {@code Class} object represents an array type, a primitive
2485      * type, or void, then the returned array has length 0.
2486      *
2487      * &lt;p&gt; The elements in the returned array are not sorted and are not in any
2488      * particular order.
2489      *
2490      * @return  the array of {@code Method} objects representing all the
2491      *          declared methods of this class
2492      * @throws  SecurityException
2493      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2494      *          following conditions is met:
2495      *
2496      *          &lt;ul&gt;
2497      *
2498      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2499      *          class loader of this class and invocation of
2500      *          {@link SecurityManager#checkPermission
2501      *          s.checkPermission} method with
2502      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2503      *          denies access to the declared methods within this class
2504      *
2505      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2506      *          ancestor of the class loader for the current class and
2507      *          invocation of {@link SecurityManager#checkPackageAccess
2508      *          s.checkPackageAccess()} denies access to the package
2509      *          of this class
2510      *
2511      *          &lt;/ul&gt;
2512      *
2513      * @jls 8.2 Class Members
2514      * @jls 8.4 Method Declarations
2515      * @since 1.1
2516      */
2517     @CallerSensitive
2518     public Method[] getDeclaredMethods() throws SecurityException {
2519         SecurityManager sm = System.getSecurityManager();
2520         if (sm != null) {
2521             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2522         }
2523         return copyMethods(privateGetDeclaredMethods(false));
2524     }
2525 
2526 
2527     /**
2528      * Returns an array of {@code Constructor} objects reflecting all the
2529      * constructors declared by the class represented by this
2530      * {@code Class} object. These are public, protected, default
2531      * (package) access, and private constructors.  The elements in the array
2532      * returned are not sorted and are not in any particular order.  If the
2533      * class has a default constructor, it is included in the returned array.
2534      * This method returns an array of length 0 if this {@code Class}
2535      * object represents an interface, a primitive type, an array class, or
2536      * void.
2537      *
2538      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
2539      * section {@jls 8.2}.
2540      *
2541      * @return  the array of {@code Constructor} objects representing all the
2542      *          declared constructors of this class
2543      * @throws  SecurityException
2544      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2545      *          following conditions is met:
2546      *
2547      *          &lt;ul&gt;
2548      *
2549      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2550      *          class loader of this class and invocation of
2551      *          {@link SecurityManager#checkPermission
2552      *          s.checkPermission} method with
2553      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2554      *          denies access to the declared constructors within this class
2555      *
2556      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2557      *          ancestor of the class loader for the current class and
2558      *          invocation of {@link SecurityManager#checkPackageAccess
2559      *          s.checkPackageAccess()} denies access to the package
2560      *          of this class
2561      *
2562      *          &lt;/ul&gt;
2563      *
2564      * @since 1.1
2565      */
2566     @CallerSensitive
2567     public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException {
2568         SecurityManager sm = System.getSecurityManager();
2569         if (sm != null) {
2570             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2571         }
2572         return copyConstructors(privateGetDeclaredConstructors(false));
2573     }
2574 
2575 
2576     /**
2577      * Returns a {@code Field} object that reflects the specified declared
2578      * field of the class or interface represented by this {@code Class}
2579      * object. The {@code name} parameter is a {@code String} that specifies
2580      * the simple name of the desired field.
2581      *
2582      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2583      * method does not find the {@code length} field of the array type.
2584      *
2585      * @param name the name of the field
2586      * @return  the {@code Field} object for the specified field in this
2587      *          class
2588      * @throws  NoSuchFieldException if a field with the specified name is
2589      *          not found.
2590      * @throws  NullPointerException if {@code name} is {@code null}
2591      * @throws  SecurityException
2592      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2593      *          following conditions is met:
2594      *
2595      *          &lt;ul&gt;
2596      *
2597      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2598      *          class loader of this class and invocation of
2599      *          {@link SecurityManager#checkPermission
2600      *          s.checkPermission} method with
2601      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2602      *          denies access to the declared field
2603      *
2604      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2605      *          ancestor of the class loader for the current class and
2606      *          invocation of {@link SecurityManager#checkPackageAccess
2607      *          s.checkPackageAccess()} denies access to the package
2608      *          of this class
2609      *
2610      *          &lt;/ul&gt;
2611      *
2612      * @since 1.1
2613      * @jls 8.2 Class Members
2614      * @jls 8.3 Field Declarations
2615      */
2616     @CallerSensitive
2617     public Field getDeclaredField(String name)
2618         throws NoSuchFieldException, SecurityException {
2619         Objects.requireNonNull(name);
2620         SecurityManager sm = System.getSecurityManager();
2621         if (sm != null) {
2622             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2623         }
2624         Field field = searchFields(privateGetDeclaredFields(false), name);
2625         if (field == null) {
2626             throw new NoSuchFieldException(name);
2627         }
2628         return getReflectionFactory().copyField(field);
2629     }
2630 
2631 
2632     /**
2633      * Returns a {@code Method} object that reflects the specified
2634      * declared method of the class or interface represented by this
2635      * {@code Class} object. The {@code name} parameter is a
2636      * {@code String} that specifies the simple name of the desired
2637      * method, and the {@code parameterTypes} parameter is an array of
2638      * {@code Class} objects that identify the method&#39;s formal parameter
2639      * types, in declared order.  If more than one method with the same
2640      * parameter types is declared in a class, and one of these methods has a
2641      * return type that is more specific than any of the others, that method is
2642      * returned; otherwise one of the methods is chosen arbitrarily.  If the
2643      * name is &quot;&amp;lt;init&amp;gt;&quot;or &quot;&amp;lt;clinit&amp;gt;&quot; a {@code NoSuchMethodException}
2644      * is raised.
2645      *
2646      * &lt;p&gt; If this {@code Class} object represents an array type, then this
2647      * method does not find the {@code clone()} method.
2648      *
2649      * @param name the name of the method
2650      * @param parameterTypes the parameter array
2651      * @return  the {@code Method} object for the method of this class
2652      *          matching the specified name and parameters
2653      * @throws  NoSuchMethodException if a matching method is not found.
2654      * @throws  NullPointerException if {@code name} is {@code null}
2655      * @throws  SecurityException
2656      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2657      *          following conditions is met:
2658      *
2659      *          &lt;ul&gt;
2660      *
2661      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2662      *          class loader of this class and invocation of
2663      *          {@link SecurityManager#checkPermission
2664      *          s.checkPermission} method with
2665      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2666      *          denies access to the declared method
2667      *
2668      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2669      *          ancestor of the class loader for the current class and
2670      *          invocation of {@link SecurityManager#checkPackageAccess
2671      *          s.checkPackageAccess()} denies access to the package
2672      *          of this class
2673      *
2674      *          &lt;/ul&gt;
2675      *
2676      * @jls 8.2 Class Members
2677      * @jls 8.4 Method Declarations
2678      * @since 1.1
2679      */
2680     @CallerSensitive
2681     public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)
2682         throws NoSuchMethodException, SecurityException {
2683         Objects.requireNonNull(name);
2684         SecurityManager sm = System.getSecurityManager();
2685         if (sm != null) {
2686             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2687         }
2688         Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);
2689         if (method == null) {
2690             throw new NoSuchMethodException(methodToString(name, parameterTypes));
2691         }
2692         return getReflectionFactory().copyMethod(method);
2693     }
2694 
2695     /**
2696      * Returns the list of {@code Method} objects for the declared public
2697      * methods of this class or interface that have the specified method name
2698      * and parameter types.
2699      *
2700      * @param name the name of the method
2701      * @param parameterTypes the parameter array
2702      * @return the list of {@code Method} objects for the public methods of
2703      *         this class matching the specified name and parameters
2704      */
2705     List&lt;Method&gt; getDeclaredPublicMethods(String name, Class&lt;?&gt;... parameterTypes) {
2706         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
2707         ReflectionFactory factory = getReflectionFactory();
2708         List&lt;Method&gt; result = new ArrayList&lt;&gt;();
2709         for (Method method : methods) {
2710             if (method.getName().equals(name)
2711                 &amp;&amp; Arrays.equals(
2712                     factory.getExecutableSharedParameterTypes(method),
2713                     parameterTypes)) {
2714                 result.add(factory.copyMethod(method));
2715             }
2716         }
2717         return result;
2718     }
2719 
2720     /**
2721      * Returns a {@code Constructor} object that reflects the specified
2722      * constructor of the class or interface represented by this
2723      * {@code Class} object.  The {@code parameterTypes} parameter is
2724      * an array of {@code Class} objects that identify the constructor&#39;s
2725      * formal parameter types, in declared order.
2726      *
2727      * If this {@code Class} object represents an inner class
2728      * declared in a non-static context, the formal parameter types
2729      * include the explicit enclosing instance as the first parameter.
2730      *
2731      * @param parameterTypes the parameter array
2732      * @return  The {@code Constructor} object for the constructor with the
2733      *          specified parameter list
2734      * @throws  NoSuchMethodException if a matching method is not found.
2735      * @throws  SecurityException
2736      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2737      *          following conditions is met:
2738      *
2739      *          &lt;ul&gt;
2740      *
2741      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2742      *          class loader of this class and invocation of
2743      *          {@link SecurityManager#checkPermission
2744      *          s.checkPermission} method with
2745      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2746      *          denies access to the declared constructor
2747      *
2748      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2749      *          ancestor of the class loader for the current class and
2750      *          invocation of {@link SecurityManager#checkPackageAccess
2751      *          s.checkPackageAccess()} denies access to the package
2752      *          of this class
2753      *
2754      *          &lt;/ul&gt;
2755      *
2756      * @since 1.1
2757      */
2758     @CallerSensitive
2759     public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)
2760         throws NoSuchMethodException, SecurityException
2761     {
2762         SecurityManager sm = System.getSecurityManager();
2763         if (sm != null) {
2764             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2765         }
2766 
2767         return getReflectionFactory().copyConstructor(
2768             getConstructor0(parameterTypes, Member.DECLARED));
2769     }
2770 
2771     /**
2772      * Finds a resource with a given name.
2773      *
2774      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2775      * will attempt to find the resource in the module. This is done by
2776      * delegating to the module&#39;s class loader {@link
2777      * ClassLoader#findResource(String,String) findResource(String,String)}
2778      * method, invoking it with the module name and the absolute name of the
2779      * resource. Resources in named modules are subject to the rules for
2780      * encapsulation specified in the {@code Module} {@link
2781      * Module#getResourceAsStream getResourceAsStream} method and so this
2782      * method returns {@code null} when the resource is a
2783      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2784      * caller&#39;s module.
2785      *
2786      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2787      * searching resources associated with a given class are implemented by the
2788      * defining {@linkplain ClassLoader class loader} of the class.  This method
2789      * delegates to this {@code Class} object&#39;s class loader.
2790      * If this {@code Class} object was loaded by the bootstrap class loader,
2791      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.
2792      *
2793      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2794      * given resource name using this algorithm:
2795      *
2796      * &lt;ul&gt;
2797      *
2798      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2799      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2800      * portion of the {@code name} following the {@code &#39;/&#39;}.
2801      *
2802      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2803      *
2804      * &lt;blockquote&gt;
2805      *   {@code modified_package_name/name}
2806      * &lt;/blockquote&gt;
2807      *
2808      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2809      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2810      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2811      *
2812      * &lt;/ul&gt;
2813      *
2814      * @param  name name of the desired resource
2815      * @return  A {@link java.io.InputStream} object; {@code null} if no
2816      *          resource with this name is found, the resource is in a package
2817      *          that is not {@linkplain Module#isOpen(String, Module) open} to at
2818      *          least the caller module, or access to the resource is denied
2819      *          by the security manager.
2820      * @throws  NullPointerException If {@code name} is {@code null}
2821      *
2822      * @see Module#getResourceAsStream(String)
2823      * @since  1.1
2824      * @revised 9
2825      * @spec JPMS
2826      */
2827     @CallerSensitive
2828     public InputStream getResourceAsStream(String name) {
2829         name = resolveName(name);
2830 
2831         Module thisModule = getModule();
2832         if (thisModule.isNamed()) {
2833             // check if resource can be located by caller
2834             if (Resources.canEncapsulate(name)
2835                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2836                 return null;
2837             }
2838 
2839             // resource not encapsulated or in package open to caller
2840             String mn = thisModule.getName();
2841             ClassLoader cl = getClassLoader0();
2842             try {
2843 
2844                 // special-case built-in class loaders to avoid the
2845                 // need for a URL connection
2846                 if (cl == null) {
2847                     return BootLoader.findResourceAsStream(mn, name);
2848                 } else if (cl instanceof BuiltinClassLoader) {
2849                     return ((BuiltinClassLoader) cl).findResourceAsStream(mn, name);
2850                 } else {
2851                     URL url = cl.findResource(mn, name);
2852                     return (url != null) ? url.openStream() : null;
2853                 }
2854 
2855             } catch (IOException | SecurityException e) {
2856                 return null;
2857             }
2858         }
2859 
2860         // unnamed module
2861         ClassLoader cl = getClassLoader0();
2862         if (cl == null) {
2863             return ClassLoader.getSystemResourceAsStream(name);
2864         } else {
2865             return cl.getResourceAsStream(name);
2866         }
2867     }
2868 
2869     /**
2870      * Finds a resource with a given name.
2871      *
2872      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2873      * will attempt to find the resource in the module. This is done by
2874      * delegating to the module&#39;s class loader {@link
2875      * ClassLoader#findResource(String,String) findResource(String,String)}
2876      * method, invoking it with the module name and the absolute name of the
2877      * resource. Resources in named modules are subject to the rules for
2878      * encapsulation specified in the {@code Module} {@link
2879      * Module#getResourceAsStream getResourceAsStream} method and so this
2880      * method returns {@code null} when the resource is a
2881      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2882      * caller&#39;s module.
2883      *
2884      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2885      * searching resources associated with a given class are implemented by the
2886      * defining {@linkplain ClassLoader class loader} of the class.  This method
2887      * delegates to this {@code Class} object&#39;s class loader.
2888      * If this {@code Class} object was loaded by the bootstrap class loader,
2889      * the method delegates to {@link ClassLoader#getSystemResource}.
2890      *
2891      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2892      * given resource name using this algorithm:
2893      *
2894      * &lt;ul&gt;
2895      *
2896      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2897      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2898      * portion of the {@code name} following the {@code &#39;/&#39;}.
2899      *
2900      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2901      *
2902      * &lt;blockquote&gt;
2903      *   {@code modified_package_name/name}
2904      * &lt;/blockquote&gt;
2905      *
2906      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2907      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2908      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2909      *
2910      * &lt;/ul&gt;
2911      *
2912      * @param  name name of the desired resource
2913      * @return A {@link java.net.URL} object; {@code null} if no resource with
2914      *         this name is found, the resource cannot be located by a URL, the
2915      *         resource is in a package that is not
2916      *         {@linkplain Module#isOpen(String, Module) open} to at least the caller
2917      *         module, or access to the resource is denied by the security
2918      *         manager.
2919      * @throws NullPointerException If {@code name} is {@code null}
2920      * @since  1.1
2921      * @revised 9
2922      * @spec JPMS
2923      */
2924     @CallerSensitive
2925     public URL getResource(String name) {
2926         name = resolveName(name);
2927 
2928         Module thisModule = getModule();
2929         if (thisModule.isNamed()) {
2930             // check if resource can be located by caller
2931             if (Resources.canEncapsulate(name)
2932                 &amp;&amp; !isOpenToCaller(name, Reflection.getCallerClass())) {
2933                 return null;
2934             }
2935 
2936             // resource not encapsulated or in package open to caller
2937             String mn = thisModule.getName();
2938             ClassLoader cl = getClassLoader0();
2939             try {
2940                 if (cl == null) {
2941                     return BootLoader.findResource(mn, name);
2942                 } else {
2943                     return cl.findResource(mn, name);
2944                 }
2945             } catch (IOException ioe) {
2946                 return null;
2947             }
2948         }
2949 
2950         // unnamed module
2951         ClassLoader cl = getClassLoader0();
2952         if (cl == null) {
2953             return ClassLoader.getSystemResource(name);
2954         } else {
2955             return cl.getResource(name);
2956         }
2957     }
2958 
2959     /**
2960      * Returns true if a resource with the given name can be located by the
2961      * given caller. All resources in a module can be located by code in
2962      * the module. For other callers, then the package needs to be open to
2963      * the caller.
2964      */
2965     private boolean isOpenToCaller(String name, Class&lt;?&gt; caller) {
2966         // assert getModule().isNamed();
2967         Module thisModule = getModule();
2968         Module callerModule = (caller != null) ? caller.getModule() : null;
2969         if (callerModule != thisModule) {
2970             String pn = Resources.toPackageName(name);
2971             if (thisModule.getDescriptor().packages().contains(pn)) {
2972                 if (callerModule == null &amp;&amp; !thisModule.isOpen(pn)) {
2973                     // no caller, package not open
2974                     return false;
2975                 }
2976                 if (!thisModule.isOpen(pn, callerModule)) {
2977                     // package not open to caller
2978                     return false;
2979                 }
2980             }
2981         }
2982         return true;
2983     }
2984 
2985 
2986     /** protection domain returned when the internal domain is null */
2987     private static java.security.ProtectionDomain allPermDomain;
2988 
2989     /**
2990      * Returns the {@code ProtectionDomain} of this class.  If there is a
2991      * security manager installed, this method first calls the security
2992      * manager&#39;s {@code checkPermission} method with a
2993      * {@code RuntimePermission(&quot;getProtectionDomain&quot;)} permission to
2994      * ensure it&#39;s ok to get the
2995      * {@code ProtectionDomain}.
2996      *
2997      * @return the ProtectionDomain of this class
2998      *
2999      * @throws SecurityException
3000      *        if a security manager exists and its
3001      *        {@code checkPermission} method doesn&#39;t allow
3002      *        getting the ProtectionDomain.
3003      *
3004      * @see java.security.ProtectionDomain
3005      * @see SecurityManager#checkPermission
3006      * @see java.lang.RuntimePermission
3007      * @since 1.2
3008      */
3009     public java.security.ProtectionDomain getProtectionDomain() {
3010         SecurityManager sm = System.getSecurityManager();
3011         if (sm != null) {
3012             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
3013         }
<a name="25" id="anc25"></a><span class="line-added">3014         return protectionDomain();</span>
<span class="line-added">3015     }</span>
<span class="line-added">3016 </span>
<span class="line-added">3017     // package-private</span>
<span class="line-added">3018     java.security.ProtectionDomain protectionDomain() {</span>
3019         java.security.ProtectionDomain pd = getProtectionDomain0();
3020         if (pd == null) {
3021             if (allPermDomain == null) {
3022                 java.security.Permissions perms =
3023                     new java.security.Permissions();
3024                 perms.add(SecurityConstants.ALL_PERMISSION);
3025                 allPermDomain =
3026                     new java.security.ProtectionDomain(null, perms);
3027             }
3028             pd = allPermDomain;
3029         }
3030         return pd;
3031     }
3032 
<a name="26" id="anc26"></a>
3033     /**
3034      * Returns the ProtectionDomain of this class.
3035      */
3036     private native java.security.ProtectionDomain getProtectionDomain0();
3037 
3038     /*
3039      * Return the Virtual Machine&#39;s Class object for the named
3040      * primitive type.
3041      */
3042     static native Class&lt;?&gt; getPrimitiveClass(String name);
3043 
3044     /*
3045      * Check if client is allowed to access members.  If access is denied,
3046      * throw a SecurityException.
3047      *
3048      * This method also enforces package access.
3049      *
3050      * &lt;p&gt; Default policy: allow all clients access with normal Java access
3051      * control.
3052      *
3053      * &lt;p&gt; NOTE: should only be called if a SecurityManager is installed
3054      */
3055     private void checkMemberAccess(SecurityManager sm, int which,
3056                                    Class&lt;?&gt; caller, boolean checkProxyInterfaces) {
3057         /* Default policy allows access to all {@link Member#PUBLIC} members,
3058          * as well as access to classes that have the same class loader as the caller.
3059          * In all other cases, it requires RuntimePermission(&quot;accessDeclaredMembers&quot;)
3060          * permission.
3061          */
3062         final ClassLoader ccl = ClassLoader.getClassLoader(caller);
3063         if (which != Member.PUBLIC) {
3064             final ClassLoader cl = getClassLoader0();
3065             if (ccl != cl) {
3066                 sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);
3067             }
3068         }
3069         this.checkPackageAccess(sm, ccl, checkProxyInterfaces);
3070     }
3071 
3072     /*
3073      * Checks if a client loaded in ClassLoader ccl is allowed to access this
3074      * class under the current package access policy. If access is denied,
3075      * throw a SecurityException.
3076      *
3077      * NOTE: this method should only be called if a SecurityManager is active
3078      */
3079     private void checkPackageAccess(SecurityManager sm, final ClassLoader ccl,
3080                                     boolean checkProxyInterfaces) {
3081         final ClassLoader cl = getClassLoader0();
3082 
3083         if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {
3084             String pkg = this.getPackageName();
3085             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3086                 // skip the package access check on a proxy class in default proxy package
3087                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3088                     sm.checkPackageAccess(pkg);
3089                 }
3090             }
3091         }
3092         // check package access on the proxy interfaces
3093         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3094             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3095         }
3096     }
3097 
3098     /**
3099      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3100      * if name is absolute
3101      */
3102     private String resolveName(String name) {
3103         if (!name.startsWith(&quot;/&quot;)) {
<a name="27" id="anc27"></a><span class="line-modified">3104             Class&lt;?&gt; c = isArray() ? elementType() : this;</span>



3105             String baseName = c.getPackageName();
3106             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3107                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3108             }
3109         } else {
3110             name = name.substring(1);
3111         }
3112         return name;
3113     }
3114 
3115     /**
3116      * Atomic operations support.
3117      */
3118     private static class Atomic {
3119         // initialize Unsafe machinery here, since we need to call Class.class instance method
3120         // and have to avoid calling it in the static initializer of the Class class...
3121         private static final Unsafe unsafe = Unsafe.getUnsafe();
3122         // offset of Class.reflectionData instance field
3123         private static final long reflectionDataOffset
3124                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
3125         // offset of Class.annotationType instance field
3126         private static final long annotationTypeOffset
3127                 = unsafe.objectFieldOffset(Class.class, &quot;annotationType&quot;);
3128         // offset of Class.annotationData instance field
3129         private static final long annotationDataOffset
3130                 = unsafe.objectFieldOffset(Class.class, &quot;annotationData&quot;);
3131 
3132         static &lt;T&gt; boolean casReflectionData(Class&lt;?&gt; clazz,
3133                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldData,
3134                                              SoftReference&lt;ReflectionData&lt;T&gt;&gt; newData) {
3135             return unsafe.compareAndSetReference(clazz, reflectionDataOffset, oldData, newData);
3136         }
3137 
3138         static &lt;T&gt; boolean casAnnotationType(Class&lt;?&gt; clazz,
3139                                              AnnotationType oldType,
3140                                              AnnotationType newType) {
3141             return unsafe.compareAndSetReference(clazz, annotationTypeOffset, oldType, newType);
3142         }
3143 
3144         static &lt;T&gt; boolean casAnnotationData(Class&lt;?&gt; clazz,
3145                                              AnnotationData oldData,
3146                                              AnnotationData newData) {
3147             return unsafe.compareAndSetReference(clazz, annotationDataOffset, oldData, newData);
3148         }
3149     }
3150 
3151     /**
3152      * Reflection support.
3153      */
3154 
3155     // Reflection data caches various derived names and reflective members. Cached
3156     // values may be invalidated when JVM TI RedefineClasses() is called
3157     private static class ReflectionData&lt;T&gt; {
3158         volatile Field[] declaredFields;
3159         volatile Field[] publicFields;
3160         volatile Method[] declaredMethods;
3161         volatile Method[] publicMethods;
3162         volatile Constructor&lt;T&gt;[] declaredConstructors;
3163         volatile Constructor&lt;T&gt;[] publicConstructors;
3164         // Intermediate results for getFields and getMethods
3165         volatile Field[] declaredPublicFields;
3166         volatile Method[] declaredPublicMethods;
3167         volatile Class&lt;?&gt;[] interfaces;
3168 
3169         // Cached names
3170         String simpleName;
3171         String canonicalName;
3172         static final String NULL_SENTINEL = new String();
3173 
3174         // Value of classRedefinedCount when we created this ReflectionData instance
3175         final int redefinedCount;
3176 
3177         ReflectionData(int redefinedCount) {
3178             this.redefinedCount = redefinedCount;
3179         }
3180     }
3181 
3182     private transient volatile SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData;
3183 
3184     // Incremented by the VM on each call to JVM TI RedefineClasses()
3185     // that redefines this class or a superclass.
3186     private transient volatile int classRedefinedCount;
3187 
3188     // Lazily create and cache ReflectionData
3189     private ReflectionData&lt;T&gt; reflectionData() {
3190         SoftReference&lt;ReflectionData&lt;T&gt;&gt; reflectionData = this.reflectionData;
3191         int classRedefinedCount = this.classRedefinedCount;
3192         ReflectionData&lt;T&gt; rd;
3193         if (reflectionData != null &amp;&amp;
3194             (rd = reflectionData.get()) != null &amp;&amp;
3195             rd.redefinedCount == classRedefinedCount) {
3196             return rd;
3197         }
3198         // else no SoftReference or cleared SoftReference or stale ReflectionData
3199         // -&gt; create and replace new instance
3200         return newReflectionData(reflectionData, classRedefinedCount);
3201     }
3202 
3203     private ReflectionData&lt;T&gt; newReflectionData(SoftReference&lt;ReflectionData&lt;T&gt;&gt; oldReflectionData,
3204                                                 int classRedefinedCount) {
3205         while (true) {
3206             ReflectionData&lt;T&gt; rd = new ReflectionData&lt;&gt;(classRedefinedCount);
3207             // try to CAS it...
3208             if (Atomic.casReflectionData(this, oldReflectionData, new SoftReference&lt;&gt;(rd))) {
3209                 return rd;
3210             }
3211             // else retry
3212             oldReflectionData = this.reflectionData;
3213             classRedefinedCount = this.classRedefinedCount;
3214             if (oldReflectionData != null &amp;&amp;
3215                 (rd = oldReflectionData.get()) != null &amp;&amp;
3216                 rd.redefinedCount == classRedefinedCount) {
3217                 return rd;
3218             }
3219         }
3220     }
3221 
3222     // Generic signature handling
3223     private native String getGenericSignature0();
3224 
3225     // Generic info repository; lazily initialized
3226     private transient volatile ClassRepository genericInfo;
3227 
3228     // accessor for factory
3229     private GenericsFactory getFactory() {
3230         // create scope and factory
3231         return CoreReflectionFactory.make(this, ClassScope.make(this));
3232     }
3233 
3234     // accessor for generic info repository;
3235     // generic info is lazily initialized
3236     private ClassRepository getGenericInfo() {
3237         ClassRepository genericInfo = this.genericInfo;
3238         if (genericInfo == null) {
3239             String signature = getGenericSignature0();
3240             if (signature == null) {
3241                 genericInfo = ClassRepository.NONE;
3242             } else {
3243                 genericInfo = ClassRepository.make(signature, getFactory());
3244             }
3245             this.genericInfo = genericInfo;
3246         }
3247         return (genericInfo != ClassRepository.NONE) ? genericInfo : null;
3248     }
3249 
3250     // Annotations handling
3251     native byte[] getRawAnnotations();
3252     // Since 1.8
3253     native byte[] getRawTypeAnnotations();
3254     static byte[] getExecutableTypeAnnotationBytes(Executable ex) {
3255         return getReflectionFactory().getExecutableTypeAnnotationBytes(ex);
3256     }
3257 
3258     native ConstantPool getConstantPool();
3259 
3260     //
3261     //
3262     // java.lang.reflect.Field handling
3263     //
3264     //
3265 
3266     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3267     // be propagated to the outside world, but must instead be copied
3268     // via ReflectionFactory.copyField.
3269     private Field[] privateGetDeclaredFields(boolean publicOnly) {
3270         Field[] res;
3271         ReflectionData&lt;T&gt; rd = reflectionData();
3272         if (rd != null) {
3273             res = publicOnly ? rd.declaredPublicFields : rd.declaredFields;
3274             if (res != null) return res;
3275         }
3276         // No cached value available; request value from VM
3277         res = Reflection.filterFields(this, getDeclaredFields0(publicOnly));
3278         if (rd != null) {
3279             if (publicOnly) {
3280                 rd.declaredPublicFields = res;
3281             } else {
3282                 rd.declaredFields = res;
3283             }
3284         }
3285         return res;
3286     }
3287 
3288     // Returns an array of &quot;root&quot; fields. These Field objects must NOT
3289     // be propagated to the outside world, but must instead be copied
3290     // via ReflectionFactory.copyField.
3291     private Field[] privateGetPublicFields() {
3292         Field[] res;
3293         ReflectionData&lt;T&gt; rd = reflectionData();
3294         if (rd != null) {
3295             res = rd.publicFields;
3296             if (res != null) return res;
3297         }
3298 
3299         // Use a linked hash set to ensure order is preserved and
3300         // fields from common super interfaces are not duplicated
3301         LinkedHashSet&lt;Field&gt; fields = new LinkedHashSet&lt;&gt;();
3302 
3303         // Local fields
3304         addAll(fields, privateGetDeclaredFields(true));
3305 
3306         // Direct superinterfaces, recursively
3307         for (Class&lt;?&gt; si : getInterfaces()) {
3308             addAll(fields, si.privateGetPublicFields());
3309         }
3310 
3311         // Direct superclass, recursively
3312         Class&lt;?&gt; sc = getSuperclass();
3313         if (sc != null) {
3314             addAll(fields, sc.privateGetPublicFields());
3315         }
3316 
3317         res = fields.toArray(new Field[0]);
3318         if (rd != null) {
3319             rd.publicFields = res;
3320         }
3321         return res;
3322     }
3323 
3324     private static void addAll(Collection&lt;Field&gt; c, Field[] o) {
3325         for (Field f : o) {
3326             c.add(f);
3327         }
3328     }
3329 
3330 
3331     //
3332     //
3333     // java.lang.reflect.Constructor handling
3334     //
3335     //
3336 
3337     // Returns an array of &quot;root&quot; constructors. These Constructor
3338     // objects must NOT be propagated to the outside world, but must
3339     // instead be copied via ReflectionFactory.copyConstructor.
3340     private Constructor&lt;T&gt;[] privateGetDeclaredConstructors(boolean publicOnly) {
3341         Constructor&lt;T&gt;[] res;
3342         ReflectionData&lt;T&gt; rd = reflectionData();
3343         if (rd != null) {
3344             res = publicOnly ? rd.publicConstructors : rd.declaredConstructors;
3345             if (res != null) return res;
3346         }
3347         // No cached value available; request value from VM
3348         if (isInterface()) {
3349             @SuppressWarnings(&quot;unchecked&quot;)
3350             Constructor&lt;T&gt;[] temporaryRes = (Constructor&lt;T&gt;[]) new Constructor&lt;?&gt;[0];
3351             res = temporaryRes;
3352         } else {
3353             res = getDeclaredConstructors0(publicOnly);
3354         }
3355         if (rd != null) {
3356             if (publicOnly) {
3357                 rd.publicConstructors = res;
3358             } else {
3359                 rd.declaredConstructors = res;
3360             }
3361         }
3362         return res;
3363     }
3364 
3365     //
3366     //
3367     // java.lang.reflect.Method handling
3368     //
3369     //
3370 
3371     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3372     // be propagated to the outside world, but must instead be copied
3373     // via ReflectionFactory.copyMethod.
3374     private Method[] privateGetDeclaredMethods(boolean publicOnly) {
3375         Method[] res;
3376         ReflectionData&lt;T&gt; rd = reflectionData();
3377         if (rd != null) {
3378             res = publicOnly ? rd.declaredPublicMethods : rd.declaredMethods;
3379             if (res != null) return res;
3380         }
3381         // No cached value available; request value from VM
3382         res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));
3383         if (rd != null) {
3384             if (publicOnly) {
3385                 rd.declaredPublicMethods = res;
3386             } else {
3387                 rd.declaredMethods = res;
3388             }
3389         }
3390         return res;
3391     }
3392 
3393     // Returns an array of &quot;root&quot; methods. These Method objects must NOT
3394     // be propagated to the outside world, but must instead be copied
3395     // via ReflectionFactory.copyMethod.
3396     private Method[] privateGetPublicMethods() {
3397         Method[] res;
3398         ReflectionData&lt;T&gt; rd = reflectionData();
3399         if (rd != null) {
3400             res = rd.publicMethods;
3401             if (res != null) return res;
3402         }
3403 
3404         // No cached value available; compute value recursively.
3405         // Start by fetching public declared methods...
3406         PublicMethods pms = new PublicMethods();
3407         for (Method m : privateGetDeclaredMethods(/* publicOnly */ true)) {
3408             pms.merge(m);
3409         }
3410         // ...then recur over superclass methods...
3411         Class&lt;?&gt; sc = getSuperclass();
3412         if (sc != null) {
3413             for (Method m : sc.privateGetPublicMethods()) {
3414                 pms.merge(m);
3415             }
3416         }
3417         // ...and finally over direct superinterfaces.
3418         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3419             for (Method m : intf.privateGetPublicMethods()) {
3420                 // static interface methods are not inherited
3421                 if (!Modifier.isStatic(m.getModifiers())) {
3422                     pms.merge(m);
3423                 }
3424             }
3425         }
3426 
3427         res = pms.toArray();
3428         if (rd != null) {
3429             rd.publicMethods = res;
3430         }
3431         return res;
3432     }
3433 
3434 
3435     //
3436     // Helpers for fetchers of one field, method, or constructor
3437     //
3438 
3439     // This method does not copy the returned Field object!
3440     private static Field searchFields(Field[] fields, String name) {
3441         for (Field field : fields) {
3442             if (field.getName().equals(name)) {
3443                 return field;
3444             }
3445         }
3446         return null;
3447     }
3448 
3449     // Returns a &quot;root&quot; Field object. This Field object must NOT
3450     // be propagated to the outside world, but must instead be copied
3451     // via ReflectionFactory.copyField.
3452     private Field getField0(String name) {
3453         // Note: the intent is that the search algorithm this routine
3454         // uses be equivalent to the ordering imposed by
3455         // privateGetPublicFields(). It fetches only the declared
3456         // public fields for each class, however, to reduce the number
3457         // of Field objects which have to be created for the common
3458         // case where the field being requested is declared in the
3459         // class which is being queried.
3460         Field res;
3461         // Search declared public fields
3462         if ((res = searchFields(privateGetDeclaredFields(true), name)) != null) {
3463             return res;
3464         }
3465         // Direct superinterfaces, recursively
3466         Class&lt;?&gt;[] interfaces = getInterfaces(/* cloneArray */ false);
3467         for (Class&lt;?&gt; c : interfaces) {
3468             if ((res = c.getField0(name)) != null) {
3469                 return res;
3470             }
3471         }
3472         // Direct superclass, recursively
3473         if (!isInterface()) {
3474             Class&lt;?&gt; c = getSuperclass();
3475             if (c != null) {
3476                 if ((res = c.getField0(name)) != null) {
3477                     return res;
3478                 }
3479             }
3480         }
3481         return null;
3482     }
3483 
3484     // This method does not copy the returned Method object!
3485     private static Method searchMethods(Method[] methods,
3486                                         String name,
3487                                         Class&lt;?&gt;[] parameterTypes)
3488     {
3489         ReflectionFactory fact = getReflectionFactory();
3490         Method res = null;
3491         for (Method m : methods) {
3492             if (m.getName().equals(name)
3493                 &amp;&amp; arrayContentsEq(parameterTypes,
3494                                    fact.getExecutableSharedParameterTypes(m))
3495                 &amp;&amp; (res == null
3496                     || (res.getReturnType() != m.getReturnType()
3497                         &amp;&amp; res.getReturnType().isAssignableFrom(m.getReturnType()))))
3498                 res = m;
3499         }
3500         return res;
3501     }
3502 
3503     private static final Class&lt;?&gt;[] EMPTY_CLASS_ARRAY = new Class&lt;?&gt;[0];
3504 
3505     // Returns a &quot;root&quot; Method object. This Method object must NOT
3506     // be propagated to the outside world, but must instead be copied
3507     // via ReflectionFactory.copyMethod.
3508     private Method getMethod0(String name, Class&lt;?&gt;[] parameterTypes) {
3509         PublicMethods.MethodList res = getMethodsRecursive(
3510             name,
3511             parameterTypes == null ? EMPTY_CLASS_ARRAY : parameterTypes,
3512             /* includeStatic */ true);
3513         return res == null ? null : res.getMostSpecific();
3514     }
3515 
3516     // Returns a list of &quot;root&quot; Method objects. These Method objects must NOT
3517     // be propagated to the outside world, but must instead be copied
3518     // via ReflectionFactory.copyMethod.
3519     private PublicMethods.MethodList getMethodsRecursive(String name,
3520                                                          Class&lt;?&gt;[] parameterTypes,
3521                                                          boolean includeStatic) {
3522         // 1st check declared public methods
3523         Method[] methods = privateGetDeclaredMethods(/* publicOnly */ true);
3524         PublicMethods.MethodList res = PublicMethods.MethodList
3525             .filter(methods, name, parameterTypes, includeStatic);
3526         // if there is at least one match among declared methods, we need not
3527         // search any further as such match surely overrides matching methods
3528         // declared in superclass(es) or interface(s).
3529         if (res != null) {
3530             return res;
3531         }
3532 
3533         // if there was no match among declared methods,
3534         // we must consult the superclass (if any) recursively...
3535         Class&lt;?&gt; sc = getSuperclass();
3536         if (sc != null) {
3537             res = sc.getMethodsRecursive(name, parameterTypes, includeStatic);
3538         }
3539 
3540         // ...and coalesce the superclass methods with methods obtained
3541         // from directly implemented interfaces excluding static methods...
3542         for (Class&lt;?&gt; intf : getInterfaces(/* cloneArray */ false)) {
3543             res = PublicMethods.MethodList.merge(
3544                 res, intf.getMethodsRecursive(name, parameterTypes,
3545                                               /* includeStatic */ false));
3546         }
3547 
3548         return res;
3549     }
3550 
3551     // Returns a &quot;root&quot; Constructor object. This Constructor object must NOT
3552     // be propagated to the outside world, but must instead be copied
3553     // via ReflectionFactory.copyConstructor.
3554     private Constructor&lt;T&gt; getConstructor0(Class&lt;?&gt;[] parameterTypes,
3555                                         int which) throws NoSuchMethodException
3556     {
3557         ReflectionFactory fact = getReflectionFactory();
3558         Constructor&lt;T&gt;[] constructors = privateGetDeclaredConstructors((which == Member.PUBLIC));
3559         for (Constructor&lt;T&gt; constructor : constructors) {
3560             if (arrayContentsEq(parameterTypes,
3561                                 fact.getExecutableSharedParameterTypes(constructor))) {
3562                 return constructor;
3563             }
3564         }
3565         throw new NoSuchMethodException(methodToString(&quot;&lt;init&gt;&quot;, parameterTypes));
3566     }
3567 
3568     //
3569     // Other helpers and base implementation
3570     //
3571 
3572     private static boolean arrayContentsEq(Object[] a1, Object[] a2) {
3573         if (a1 == null) {
3574             return a2 == null || a2.length == 0;
3575         }
3576 
3577         if (a2 == null) {
3578             return a1.length == 0;
3579         }
3580 
3581         if (a1.length != a2.length) {
3582             return false;
3583         }
3584 
3585         for (int i = 0; i &lt; a1.length; i++) {
3586             if (a1[i] != a2[i]) {
3587                 return false;
3588             }
3589         }
3590 
3591         return true;
3592     }
3593 
3594     private static Field[] copyFields(Field[] arg) {
3595         Field[] out = new Field[arg.length];
3596         ReflectionFactory fact = getReflectionFactory();
3597         for (int i = 0; i &lt; arg.length; i++) {
3598             out[i] = fact.copyField(arg[i]);
3599         }
3600         return out;
3601     }
3602 
3603     private static Method[] copyMethods(Method[] arg) {
3604         Method[] out = new Method[arg.length];
3605         ReflectionFactory fact = getReflectionFactory();
3606         for (int i = 0; i &lt; arg.length; i++) {
3607             out[i] = fact.copyMethod(arg[i]);
3608         }
3609         return out;
3610     }
3611 
3612     private static &lt;U&gt; Constructor&lt;U&gt;[] copyConstructors(Constructor&lt;U&gt;[] arg) {
3613         Constructor&lt;U&gt;[] out = arg.clone();
3614         ReflectionFactory fact = getReflectionFactory();
3615         for (int i = 0; i &lt; out.length; i++) {
3616             out[i] = fact.copyConstructor(out[i]);
3617         }
3618         return out;
3619     }
3620 
3621     private native Field[]       getDeclaredFields0(boolean publicOnly);
3622     private native Method[]      getDeclaredMethods0(boolean publicOnly);
3623     private native Constructor&lt;T&gt;[] getDeclaredConstructors0(boolean publicOnly);
3624     private native Class&lt;?&gt;[]   getDeclaredClasses0();
3625     @SuppressWarnings(&quot;preview&quot;)
3626     private native RecordComponent[] getRecordComponents0();
3627     private native boolean      isRecord0();
3628 
3629     /**
3630      * Helper method to get the method name from arguments.
3631      */
3632     private String methodToString(String name, Class&lt;?&gt;[] argTypes) {
3633         return getName() + &#39;.&#39; + name +
3634                 ((argTypes == null || argTypes.length == 0) ?
3635                 &quot;()&quot; :
3636                 Arrays.stream(argTypes)
3637                         .map(c -&gt; c == null ? &quot;null&quot; : c.getName())
3638                         .collect(Collectors.joining(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;)));
3639     }
3640 
3641     /** use serialVersionUID from JDK 1.1 for interoperability */
3642     @java.io.Serial
3643     private static final long serialVersionUID = 3206093459760846163L;
3644 
3645 
3646     /**
3647      * Class Class is special cased within the Serialization Stream Protocol.
3648      *
3649      * A Class instance is written initially into an ObjectOutputStream in the
3650      * following format:
3651      * &lt;pre&gt;
3652      *      {@code TC_CLASS} ClassDescriptor
3653      *      A ClassDescriptor is a special cased serialization of
3654      *      a {@code java.io.ObjectStreamClass} instance.
3655      * &lt;/pre&gt;
3656      * A new handle is generated for the initial time the class descriptor
3657      * is written into the stream. Future references to the class descriptor
3658      * are written as references to the initial class descriptor instance.
3659      *
3660      * @see java.io.ObjectStreamClass
3661      */
3662     @java.io.Serial
3663     private static final ObjectStreamField[] serialPersistentFields =
3664         new ObjectStreamField[0];
3665 
3666 
3667     /**
3668      * Returns the assertion status that would be assigned to this
3669      * class if it were to be initialized at the time this method is invoked.
3670      * If this class has had its assertion status set, the most recent
3671      * setting will be returned; otherwise, if any package default assertion
3672      * status pertains to this class, the most recent setting for the most
3673      * specific pertinent package default assertion status is returned;
3674      * otherwise, if this class is not a system class (i.e., it has a
3675      * class loader) its class loader&#39;s default assertion status is returned;
3676      * otherwise, the system class default assertion status is returned.
3677      *
3678      * @apiNote
3679      * Few programmers will have any need for this method; it is provided
3680      * for the benefit of the JDK itself.  (It allows a class to determine at
3681      * the time that it is initialized whether assertions should be enabled.)
3682      * Note that this method is not guaranteed to return the actual
3683      * assertion status that was (or will be) associated with the specified
3684      * class when it was (or will be) initialized.
3685      *
3686      * @return the desired assertion status of the specified class.
3687      * @see    java.lang.ClassLoader#setClassAssertionStatus
3688      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3689      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3690      * @since  1.4
3691      */
3692     public boolean desiredAssertionStatus() {
3693         ClassLoader loader = getClassLoader0();
3694         // If the loader is null this is a system class, so ask the VM
3695         if (loader == null)
3696             return desiredAssertionStatus0(this);
3697 
3698         // If the classloader has been initialized with the assertion
3699         // directives, ask it. Otherwise, ask the VM.
3700         synchronized(loader.assertionLock) {
3701             if (loader.classAssertionStatus != null) {
3702                 return loader.desiredAssertionStatus(getName());
3703             }
3704         }
3705         return desiredAssertionStatus0(this);
3706     }
3707 
3708     // Retrieves the desired assertion status of this class from the VM
3709     private static native boolean desiredAssertionStatus0(Class&lt;?&gt; clazz);
3710 
3711     /**
3712      * Returns true if and only if this class was declared as an enum in the
3713      * source code.
3714      *
3715      * Note that {@link java.lang.Enum} is not itself an enum type.
3716      *
3717      * Also note that if an enum constant is declared with a class body,
3718      * the class of that enum constant object is an anonymous class
3719      * and &lt;em&gt;not&lt;/em&gt; the class of the declaring enum type. The
3720      * {@link Enum#getDeclaringClass} method of an enum constant can
3721      * be used to get the class of the enum type declaring the
3722      * constant.
3723      *
3724      * @return true if and only if this class was declared as an enum in the
3725      *     source code
3726      * @since 1.5
3727      * @jls 8.9.1 Enum Constants
3728      */
3729     public boolean isEnum() {
3730         // An enum must both directly extend java.lang.Enum and have
3731         // the ENUM bit set; classes for specialized enum constants
3732         // don&#39;t do the former.
3733         return (this.getModifiers() &amp; ENUM) != 0 &amp;&amp;
3734         this.getSuperclass() == java.lang.Enum.class;
3735     }
3736 
3737     /** java.lang.Record.class */
3738     private static final Class&lt;?&gt; JAVA_LANG_RECORD_CLASS = javaLangRecordClass();
3739     private static Class&lt;?&gt; javaLangRecordClass() {
3740         try {
3741             return Class.forName0(&quot;java.lang.Record&quot;, false, null, null);
3742         } catch (ClassNotFoundException e) {
3743             throw new InternalError(&quot;should not reach here&quot;, e);
3744         }
3745     }
3746 
3747     /**
3748      * {@preview Associated with records, a preview feature of the Java language.
3749      *
3750      *           This method is associated with &lt;i&gt;records&lt;/i&gt;, a preview
3751      *           feature of the Java language. Preview features
3752      *           may be removed in a future release, or upgraded to permanent
3753      *           features of the Java language.}
3754      *
3755      * Returns {@code true} if and only if this class is a record class.
3756      *
3757      * &lt;p&gt; The {@linkplain #getSuperclass() direct superclass} of a record
3758      * class is {@code java.lang.Record}. A record class has (possibly zero)
3759      * record components, that is, {@link #getRecordComponents()} returns a
3760      * non-null value.
3761      *
3762      * &lt;p&gt; Note that class {@link Record} is not a record type and thus invoking
3763      * this method on class {@code Record} returns {@code false}.
3764      *
3765      * @return true if and only if this class is a record class, otherwise false
3766      * @jls 8.10 Record Types
3767      * @since 14
3768      */
3769     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.RECORDS,
3770                                  essentialAPI=false)
3771     public boolean isRecord() {
3772         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3773     }
3774 
3775     // Fetches the factory for reflective objects
3776     private static ReflectionFactory getReflectionFactory() {
3777         if (reflectionFactory == null) {
3778             reflectionFactory =
3779                 java.security.AccessController.doPrivileged
3780                     (new ReflectionFactory.GetReflectionFactoryAction());
3781         }
3782         return reflectionFactory;
3783     }
3784     private static ReflectionFactory reflectionFactory;
3785 
3786     /**
3787      * Returns the elements of this enum class or null if this
3788      * Class object does not represent an enum type.
3789      *
3790      * @return an array containing the values comprising the enum class
3791      *     represented by this {@code Class} object in the order they&#39;re
3792      *     declared, or null if this {@code Class} object does not
3793      *     represent an enum type
3794      * @since 1.5
3795      */
3796     public T[] getEnumConstants() {
3797         T[] values = getEnumConstantsShared();
3798         return (values != null) ? values.clone() : null;
3799     }
3800 
3801     /**
3802      * Returns the elements of this enum class or null if this
3803      * Class object does not represent an enum type;
3804      * identical to getEnumConstants except that the result is
3805      * uncloned, cached, and shared by all callers.
3806      */
3807     T[] getEnumConstantsShared() {
3808         T[] constants = enumConstants;
3809         if (constants == null) {
3810             if (!isEnum()) return null;
3811             try {
3812                 final Method values = getMethod(&quot;values&quot;);
3813                 java.security.AccessController.doPrivileged(
3814                     new java.security.PrivilegedAction&lt;&gt;() {
3815                         public Void run() {
3816                                 values.setAccessible(true);
3817                                 return null;
3818                             }
3819                         });
3820                 @SuppressWarnings(&quot;unchecked&quot;)
3821                 T[] temporaryConstants = (T[])values.invoke(null);
3822                 enumConstants = constants = temporaryConstants;
3823             }
3824             // These can happen when users concoct enum-like classes
3825             // that don&#39;t comply with the enum spec.
3826             catch (InvocationTargetException | NoSuchMethodException |
3827                    IllegalAccessException ex) { return null; }
3828         }
3829         return constants;
3830     }
3831     private transient volatile T[] enumConstants;
3832 
3833     /**
3834      * Returns a map from simple name to enum constant.  This package-private
3835      * method is used internally by Enum to implement
3836      * {@code public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt;, String)}
3837      * efficiently.  Note that the map is returned by this method is
3838      * created lazily on first use.  Typically it won&#39;t ever get created.
3839      */
3840     Map&lt;String, T&gt; enumConstantDirectory() {
3841         Map&lt;String, T&gt; directory = enumConstantDirectory;
3842         if (directory == null) {
3843             T[] universe = getEnumConstantsShared();
3844             if (universe == null)
3845                 throw new IllegalArgumentException(
3846                     getName() + &quot; is not an enum type&quot;);
3847             directory = new HashMap&lt;&gt;((int)(universe.length / 0.75f) + 1);
3848             for (T constant : universe) {
3849                 directory.put(((Enum&lt;?&gt;)constant).name(), constant);
3850             }
3851             enumConstantDirectory = directory;
3852         }
3853         return directory;
3854     }
3855     private transient volatile Map&lt;String, T&gt; enumConstantDirectory;
3856 
3857     /**
3858      * Casts an object to the class or interface represented
3859      * by this {@code Class} object.
3860      *
3861      * @param obj the object to be cast
3862      * @return the object after casting, or null if obj is null
3863      *
3864      * @throws ClassCastException if the object is not
3865      * {@code null} and is not assignable to the type T.
3866      * @throws NullPointerException if this is an {@linkplain #isInlineClass()
3867      * inline type} and the object is {@code null}
3868      *
3869      * @since 1.5
3870      */
3871     @SuppressWarnings(&quot;unchecked&quot;)
3872     @HotSpotIntrinsicCandidate
3873     public T cast(Object obj) {
3874         if (isInlineClass() &amp;&amp; obj == null)
3875             throw new NullPointerException(getName() + &quot; is an inline class&quot;);
3876 
3877         if (obj != null &amp;&amp; !isInstance(obj))
3878             throw new ClassCastException(cannotCastMsg(obj));
3879         return (T) obj;
3880     }
3881 
3882     private String cannotCastMsg(Object obj) {
3883         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3884     }
3885 
3886     /**
3887      * Casts this {@code Class} object to represent a subclass of the class
3888      * represented by the specified class object.  Checks that the cast
3889      * is valid, and throws a {@code ClassCastException} if it is not.  If
3890      * this method succeeds, it always returns a reference to this {@code Class} object.
3891      *
3892      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3893      * a {@code Class} object to pass it to an API that restricts the
3894      * {@code Class} objects that it is willing to accept.  A cast would
3895      * generate a compile-time warning, as the correctness of the cast
3896      * could not be checked at runtime (because generic types are implemented
3897      * by erasure).
3898      *
3899      * @param &lt;U&gt; the type to cast this {@code Class} object to
3900      * @param clazz the class of the type to cast this {@code Class} object to
3901      * @return this {@code Class} object, cast to represent a subclass of
3902      *    the specified class object.
3903      * @throws ClassCastException if this {@code Class} object does not
3904      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3905      *    the class itself).
3906      * @since 1.5
3907      */
3908     @SuppressWarnings(&quot;unchecked&quot;)
3909     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3910         if (clazz.isAssignableFrom(this))
3911             return (Class&lt;? extends U&gt;) this;
3912         else
3913             throw new ClassCastException(this.toString());
3914     }
3915 
3916     /**
3917      * {@inheritDoc}
3918      * &lt;p&gt;Note that any annotation returned by this method is a
3919      * declaration annotation.
3920      *
3921      * @throws NullPointerException {@inheritDoc}
3922      * @since 1.5
3923      */
3924     @Override
3925     @SuppressWarnings(&quot;unchecked&quot;)
3926     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3927         Objects.requireNonNull(annotationClass);
3928 
3929         return (A) annotationData().annotations.get(annotationClass);
3930     }
3931 
3932     /**
3933      * {@inheritDoc}
3934      * @throws NullPointerException {@inheritDoc}
3935      * @since 1.5
3936      */
3937     @Override
3938     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
3939         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
3940     }
3941 
3942     /**
3943      * {@inheritDoc}
3944      * &lt;p&gt;Note that any annotations returned by this method are
3945      * declaration annotations.
3946      *
3947      * @throws NullPointerException {@inheritDoc}
3948      * @since 1.8
3949      */
3950     @Override
3951     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
3952         Objects.requireNonNull(annotationClass);
3953 
3954         AnnotationData annotationData = annotationData();
3955         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
3956                                                           this,
3957                                                           annotationClass);
3958     }
3959 
3960     /**
3961      * {@inheritDoc}
3962      * &lt;p&gt;Note that any annotations returned by this method are
3963      * declaration annotations.
3964      *
3965      * @since 1.5
3966      */
3967     @Override
3968     public Annotation[] getAnnotations() {
3969         return AnnotationParser.toArray(annotationData().annotations);
3970     }
3971 
3972     /**
3973      * {@inheritDoc}
3974      * &lt;p&gt;Note that any annotation returned by this method is a
3975      * declaration annotation.
3976      *
3977      * @throws NullPointerException {@inheritDoc}
3978      * @since 1.8
3979      */
3980     @Override
3981     @SuppressWarnings(&quot;unchecked&quot;)
3982     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
3983         Objects.requireNonNull(annotationClass);
3984 
3985         return (A) annotationData().declaredAnnotations.get(annotationClass);
3986     }
3987 
3988     /**
3989      * {@inheritDoc}
3990      * &lt;p&gt;Note that any annotations returned by this method are
3991      * declaration annotations.
3992      *
3993      * @throws NullPointerException {@inheritDoc}
3994      * @since 1.8
3995      */
3996     @Override
3997     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
3998         Objects.requireNonNull(annotationClass);
3999 
4000         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
4001                                                                  annotationClass);
4002     }
4003 
4004     /**
4005      * {@inheritDoc}
4006      * &lt;p&gt;Note that any annotations returned by this method are
4007      * declaration annotations.
4008      *
4009      * @since 1.5
4010      */
4011     @Override
4012     public Annotation[] getDeclaredAnnotations()  {
4013         return AnnotationParser.toArray(annotationData().declaredAnnotations);
4014     }
4015 
4016     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
4017     private static class AnnotationData {
4018         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
4019         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
4020 
4021         // Value of classRedefinedCount when we created this AnnotationData instance
4022         final int redefinedCount;
4023 
4024         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
4025                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
4026                        int redefinedCount) {
4027             this.annotations = annotations;
4028             this.declaredAnnotations = declaredAnnotations;
4029             this.redefinedCount = redefinedCount;
4030         }
4031     }
4032 
4033     // Annotations cache
4034     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4035     private transient volatile AnnotationData annotationData;
4036 
4037     private AnnotationData annotationData() {
4038         while (true) { // retry loop
4039             AnnotationData annotationData = this.annotationData;
4040             int classRedefinedCount = this.classRedefinedCount;
4041             if (annotationData != null &amp;&amp;
4042                 annotationData.redefinedCount == classRedefinedCount) {
4043                 return annotationData;
4044             }
4045             // null or stale annotationData -&gt; optimistically create new instance
4046             AnnotationData newAnnotationData = createAnnotationData(classRedefinedCount);
4047             // try to install it
4048             if (Atomic.casAnnotationData(this, annotationData, newAnnotationData)) {
4049                 // successfully installed new AnnotationData
4050                 return newAnnotationData;
4051             }
4052         }
4053     }
4054 
4055     private AnnotationData createAnnotationData(int classRedefinedCount) {
4056         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations =
4057             AnnotationParser.parseAnnotations(getRawAnnotations(), getConstantPool(), this);
4058         Class&lt;?&gt; superClass = getSuperclass();
4059         Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations = null;
4060         if (superClass != null) {
4061             Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; superAnnotations =
4062                 superClass.annotationData().annotations;
4063             for (Map.Entry&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; e : superAnnotations.entrySet()) {
4064                 Class&lt;? extends Annotation&gt; annotationClass = e.getKey();
4065                 if (AnnotationType.getInstance(annotationClass).isInherited()) {
4066                     if (annotations == null) { // lazy construction
4067                         annotations = new LinkedHashMap&lt;&gt;((Math.max(
4068                                 declaredAnnotations.size(),
4069                                 Math.min(12, declaredAnnotations.size() + superAnnotations.size())
4070                             ) * 4 + 2) / 3
4071                         );
4072                     }
4073                     annotations.put(annotationClass, e.getValue());
4074                 }
4075             }
4076         }
4077         if (annotations == null) {
4078             // no inherited annotations -&gt; share the Map with declaredAnnotations
4079             annotations = declaredAnnotations;
4080         } else {
4081             // at least one inherited annotation -&gt; declared may override inherited
4082             annotations.putAll(declaredAnnotations);
4083         }
4084         return new AnnotationData(annotations, declaredAnnotations, classRedefinedCount);
4085     }
4086 
4087     // Annotation types cache their internal (AnnotationType) form
4088 
4089     @SuppressWarnings(&quot;UnusedDeclaration&quot;)
4090     private transient volatile AnnotationType annotationType;
4091 
4092     boolean casAnnotationType(AnnotationType oldType, AnnotationType newType) {
4093         return Atomic.casAnnotationType(this, oldType, newType);
4094     }
4095 
4096     AnnotationType getAnnotationType() {
4097         return annotationType;
4098     }
4099 
4100     Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; getDeclaredAnnotationMap() {
4101         return annotationData().declaredAnnotations;
4102     }
4103 
4104     /* Backing store of user-defined values pertaining to this class.
4105      * Maintained by the ClassValue class.
4106      */
4107     transient ClassValue.ClassValueMap classValueMap;
4108 
4109     /**
4110      * Returns an {@code AnnotatedType} object that represents the use of a
4111      * type to specify the superclass of the entity represented by this {@code
4112      * Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify the superclass
4113      * in &#39;...  extends Foo&#39; is distinct from the &lt;em&gt;declaration&lt;/em&gt; of type
4114      * Foo.)
4115      *
4116      * &lt;p&gt; If this {@code Class} object represents a type whose declaration
4117      * does not explicitly indicate an annotated superclass, then the return
4118      * value is an {@code AnnotatedType} object representing an element with no
4119      * annotations.
4120      *
4121      * &lt;p&gt; If this {@code Class} represents either the {@code Object} class, an
4122      * interface type, an array type, a primitive type, or void, the return
4123      * value is {@code null}.
4124      *
4125      * @return an object representing the superclass
4126      * @since 1.8
4127      */
4128     public AnnotatedType getAnnotatedSuperclass() {
4129         if (this == Object.class ||
4130                 isInterface() ||
4131                 isArray() ||
4132                 isPrimitive() ||
4133                 this == Void.TYPE) {
4134             return null;
4135         }
4136 
4137         return TypeAnnotationParser.buildAnnotatedSuperclass(getRawTypeAnnotations(), getConstantPool(), this);
4138     }
4139 
4140     /**
4141      * Returns an array of {@code AnnotatedType} objects that represent the use
4142      * of types to specify superinterfaces of the entity represented by this
4143      * {@code Class} object. (The &lt;em&gt;use&lt;/em&gt; of type Foo to specify a
4144      * superinterface in &#39;... implements Foo&#39; is distinct from the
4145      * &lt;em&gt;declaration&lt;/em&gt; of type Foo.)
4146      *
4147      * &lt;p&gt; If this {@code Class} object represents a class, the return value is
4148      * an array containing objects representing the uses of interface types to
4149      * specify interfaces implemented by the class. The order of the objects in
4150      * the array corresponds to the order of the interface types used in the
4151      * &#39;implements&#39; clause of the declaration of this {@code Class} object.
4152      *
4153      * &lt;p&gt; If this {@code Class} object represents an interface, the return
4154      * value is an array containing objects representing the uses of interface
4155      * types to specify interfaces directly extended by the interface. The
4156      * order of the objects in the array corresponds to the order of the
4157      * interface types used in the &#39;extends&#39; clause of the declaration of this
4158      * {@code Class} object.
4159      *
4160      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4161      * declaration does not explicitly indicate any annotated superinterfaces,
4162      * the return value is an array of length 0.
4163      *
4164      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4165      * class, an array type, a primitive type, or void, the return value is an
4166      * array of length 0.
4167      *
4168      * @return an array representing the superinterfaces
4169      * @since 1.8
4170      */
4171     public AnnotatedType[] getAnnotatedInterfaces() {
4172         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
4173     }
4174 
4175     private native Class&lt;?&gt; getNestHost0();
4176 
4177     /**
4178      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4179      * or interface represented by this {@code Class} object belongs.
<a name="28" id="anc28"></a><span class="line-modified">4180      * Every class and interface belongs to exactly one nest.</span>








4181      *
<a name="29" id="anc29"></a><span class="line-modified">4182      * If the nest host of this class or interface has previously</span>
<span class="line-modified">4183      * been determined, then this method returns the nest host.</span>
<span class="line-modified">4184      * If the nest host of this class or interface has</span>
<span class="line-modified">4185      * not previously been determined, then this method determines the nest</span>
<span class="line-added">4186      * host using the algorithm of JVMS 5.4.4, and returns it.</span>
4187      *
<a name="30" id="anc30"></a><span class="line-modified">4188      * Often, a class or interface belongs to a nest consisting only of itself,</span>
<span class="line-modified">4189      * in which case this method returns {@code this} to indicate that the class</span>
<span class="line-modified">4190      * or interface is the nest host.</span>
<span class="line-modified">4191      *</span>
<span class="line-modified">4192      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,</span>
<span class="line-modified">4193      * or {@code void}, then this method returns {@code this},</span>
<span class="line-modified">4194      * indicating that the represented entity belongs to the nest consisting only of</span>
<span class="line-modified">4195      * itself, and is the nest host.</span>
4196      *
4197      * @return the nest host of this class or interface
4198      *
4199      * @throws SecurityException
4200      *         If the returned class is not the current class, and
4201      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4202      *         class loader is not the same as or an ancestor of the class
4203      *         loader for the returned class and invocation of {@link
4204      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4205      *         denies access to the package of the returned class
4206      * @since 11
4207      * @jvms 4.7.28 The {@code NestHost} Attribute
4208      * @jvms 4.7.29 The {@code NestMembers} Attribute
4209      * @jvms 5.4.4 Access Control
4210      */
4211     @CallerSensitive
4212     public Class&lt;?&gt; getNestHost() {
4213         if (isPrimitive() || isArray()) {
4214             return this;
4215         }
<a name="31" id="anc31"></a><span class="line-modified">4216 </span>
<span class="line-modified">4217         Class&lt;?&gt; host = getNestHost0();</span>
<span class="line-modified">4218         if (host == this) {</span>








4219             return this;
4220         }
4221         // returning a different class requires a security check
4222         SecurityManager sm = System.getSecurityManager();
4223         if (sm != null) {
4224             checkPackageAccess(sm,
4225                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4226         }
4227         return host;
4228     }
4229 
4230     /**
4231      * Determines if the given {@code Class} is a nestmate of the
4232      * class or interface represented by this {@code Class} object.
4233      * Two classes or interfaces are nestmates
4234      * if they have the same {@linkplain #getNestHost() nest host}.
4235      *
4236      * @param c the class to check
4237      * @return {@code true} if this class and {@code c} are members of
4238      * the same nest; and {@code false} otherwise.
4239      *
4240      * @since 11
4241      */
4242     public boolean isNestmateOf(Class&lt;?&gt; c) {
4243         if (this == c) {
4244             return true;
4245         }
4246         if (isPrimitive() || isArray() ||
4247             c.isPrimitive() || c.isArray()) {
4248             return false;
4249         }
<a name="32" id="anc32"></a><span class="line-modified">4250 </span>
<span class="line-modified">4251         return getNestHost() == c.getNestHost();</span>



4252     }
4253 
4254     private native Class&lt;?&gt;[] getNestMembers0();
4255 
4256     /**
4257      * Returns an array containing {@code Class} objects representing all the
4258      * classes and interfaces that are members of the nest to which the class
4259      * or interface represented by this {@code Class} object belongs.
<a name="33" id="anc33"></a><span class="line-modified">4260      *</span>
<span class="line-modified">4261      * First, this method obtains the {@linkplain #getNestHost() nest host},</span>
<span class="line-modified">4262      * {@code H}, of the nest to which the class or interface represented by</span>
<span class="line-modified">4263      * this {@code Class} object belongs. The zeroth element of the returned</span>
<span class="line-modified">4264      * array is {@code H}.</span>
<span class="line-modified">4265      *</span>
<span class="line-modified">4266      * Then, for each class or interface {@code C} which is recorded by {@code H}</span>
<span class="line-modified">4267      * as being a member of its nest, this method attempts to obtain the {@code Class}</span>
<span class="line-modified">4268      * object for {@code C} (using {@linkplain #getClassLoader() the defining class</span>
<span class="line-modified">4269      * loader} of the current {@code Class} object), and then obtains the</span>
<span class="line-added">4270      * {@linkplain #getNestHost() nest host} of the nest to which {@code C} belongs.</span>
<span class="line-added">4271      * The classes and interfaces which are recorded by {@code H} as being members</span>
<span class="line-added">4272      * of its nest, and for which {@code H} can be determined as their nest host,</span>
<span class="line-added">4273      * are indicated by subsequent elements of the returned array. The order of</span>
<span class="line-added">4274      * such elements is unspecified. Duplicates are permitted.</span>
<span class="line-added">4275      *</span>
<span class="line-added">4276      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,</span>
<span class="line-added">4277      * or {@code void}, then this method returns a single-element array containing</span>
4278      * {@code this}.
4279      *
<a name="34" id="anc34"></a><span class="line-modified">4280      * @apiNote</span>
<span class="line-modified">4281      * The returned array includes only the nest members recorded in the {@code NestMembers}</span>
<span class="line-modified">4282      * attribute, and not any hidden classes that were added to the nest via</span>
<span class="line-modified">4283      * {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added">4284      * Lookup::defineHiddenClass}.</span>
4285      *
4286      * @return an array of all classes and interfaces in the same nest as
<a name="35" id="anc35"></a><span class="line-modified">4287      * this class or interface</span>
4288      *
<a name="36" id="anc36"></a><span class="line-modified">4289      * @throws SecurityException</span>
<span class="line-modified">4290      * If any returned class is not the current class, and</span>
<span class="line-modified">4291      * if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s</span>
<span class="line-modified">4292      * class loader is not the same as or an ancestor of the class</span>
<span class="line-modified">4293      * loader for that returned class and invocation of {@link</span>
<span class="line-modified">4294      * SecurityManager#checkPackageAccess s.checkPackageAccess()}</span>



4295      * denies access to the package of that returned class
4296      *
4297      * @since 11
4298      * @see #getNestHost()
<a name="37" id="anc37"></a><span class="line-added">4299      * @jvms 4.7.28 The {@code NestHost} Attribute</span>
<span class="line-added">4300      * @jvms 4.7.29 The {@code NestMembers} Attribute</span>
4301      */
4302     @CallerSensitive
4303     public Class&lt;?&gt;[] getNestMembers() {
4304         if (isPrimitive() || isArray()) {
4305             return new Class&lt;?&gt;[] { this };
4306         }
4307         Class&lt;?&gt;[] members = getNestMembers0();
4308         // Can&#39;t actually enable this due to bootstrapping issues
4309         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4310 
4311         if (members.length &gt; 1) {
4312             // If we return anything other than the current class we need
4313             // a security check
4314             SecurityManager sm = System.getSecurityManager();
4315             if (sm != null) {
4316                 checkPackageAccess(sm,
4317                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4318             }
4319         }
4320         return members;
4321     }
4322 
4323     /**
<a name="38" id="anc38"></a><span class="line-modified">4324      * Returns the descriptor string of the entity (class, interface, array class,</span>
<span class="line-modified">4325      * primitive type, or {@code void}) represented by this {@code Class} object.</span>
<span class="line-modified">4326      *</span>
<span class="line-added">4327      * &lt;p&gt; If this {@code Class} object represents a class or interface,</span>
<span class="line-added">4328      * not an array class, then:</span>
<span class="line-added">4329      * &lt;ul&gt;</span>
<span class="line-added">4330      * &lt;li&gt; If the class or interface is not {@linkplain Class#isHidden() hidden},</span>
<span class="line-added">4331      *      then the result is a field descriptor (JVMS {@jvms 4.3.2})</span>
<span class="line-added">4332      *      for the class or interface. Calling</span>
<span class="line-added">4333      *      {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}</span>
<span class="line-added">4334      *      with the result descriptor string produces a {@link ClassDesc ClassDesc}</span>
<span class="line-added">4335      *      describing this class or interface.</span>
<span class="line-added">4336      * &lt;li&gt; If the class or interface is {@linkplain Class#isHidden() hidden},</span>
<span class="line-added">4337      *      then the result is a string of the form:</span>
<span class="line-added">4338      *      &lt;blockquote&gt;</span>
<span class="line-added">4339      *      {@code &quot;L&quot; +} &lt;em&gt;N&lt;/em&gt; {@code + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;}</span>
<span class="line-added">4340      *      &lt;/blockquote&gt;</span>
<span class="line-added">4341      *      where &lt;em&gt;N&lt;/em&gt; is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;</span>
<span class="line-added">4342      *      encoded in internal form indicated by the {@code class} file passed to</span>
<span class="line-added">4343      *      {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added">4344      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.</span>
<span class="line-added">4345      *      A hidden class or interface has no {@linkplain ClassDesc nominal descriptor}.</span>
<span class="line-added">4346      *      The result string is not a type descriptor.</span>
<span class="line-added">4347      * &lt;/ul&gt;</span>
<span class="line-added">4348      *</span>
<span class="line-added">4349      * &lt;p&gt; If this {@code Class} object represents an array class, then</span>
<span class="line-added">4350      * the result is a string consisting of one or more &#39;{@code [}&#39; characters</span>
<span class="line-added">4351      * representing the depth of the array nesting, followed by the</span>
<span class="line-added">4352      * descriptor string of the element type.</span>
<span class="line-added">4353      * &lt;ul&gt;</span>
<span class="line-added">4354      * &lt;li&gt; If the element type is not a {@linkplain Class#isHidden() hidden} class</span>
<span class="line-added">4355      * or interface, then this array class can be described nominally.</span>
<span class="line-added">4356      * Calling {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}</span>
<span class="line-added">4357      * with the result descriptor string produces a {@link ClassDesc ClassDesc}</span>
<span class="line-added">4358      * describing this array class.</span>
<span class="line-added">4359      * &lt;li&gt; If the element type is a {@linkplain Class#isHidden() hidden} class or</span>
<span class="line-added">4360      * interface, then this array class cannot be described nominally.</span>
<span class="line-added">4361      * The result string is not a type descriptor.</span>
<span class="line-added">4362      * &lt;/ul&gt;</span>
<span class="line-added">4363      *</span>
<span class="line-added">4364      * &lt;p&gt; If this {@code Class} object represents a primitive type or</span>
<span class="line-added">4365      * {@code void}, then the result is a field descriptor string which</span>
<span class="line-added">4366      * is a one-letter code corresponding to a primitive type or {@code void}</span>
<span class="line-added">4367      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).</span>
<span class="line-added">4368      *</span>
<span class="line-added">4369      * @apiNote</span>
<span class="line-added">4370      * This is not a strict inverse of {@link #forName};</span>
4371      * distinct classes which share a common name but have different class loaders
4372      * will have identical descriptor strings.
4373      *
<a name="39" id="anc39"></a><span class="line-modified">4374      * @return the descriptor string for this {@code Class} object</span>
4375      * @jvms 4.3.2 Field Descriptors
4376      * @since 12
4377      */
4378     @Override
4379     public String descriptorString() {
4380         if (isPrimitive())
4381             return Wrapper.forPrimitiveType(this).basicTypeString();
<a name="40" id="anc40"></a><span class="line-modified">4382 </span>
<span class="line-added">4383         if (isArray()) {</span>
4384             return &quot;[&quot; + componentType.descriptorString();
4385         }
<a name="41" id="anc41"></a><span class="line-modified">4386         String typeDesc = isInlineClass() ? &quot;Q&quot; : &quot;L&quot;;</span>
<span class="line-modified">4387         if (isHidden()) {</span>
<span class="line-modified">4388             String name = getName();</span>
<span class="line-added">4389             int index = name.indexOf(&#39;/&#39;);</span>
<span class="line-added">4390             return typeDesc + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)</span>
<span class="line-added">4391                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;</span>
<span class="line-added">4392         } else {</span>
<span class="line-added">4393             return typeDesc + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
4394         }
4395     }
4396 
4397     /**
4398      * Returns the component type of this {@code Class}, if it describes
4399      * an array type, or {@code null} otherwise.
4400      *
4401      * @implSpec
4402      * Equivalent to {@link Class#getComponentType()}.
4403      *
4404      * @return a {@code Class} describing the component type, or {@code null}
4405      * if this {@code Class} does not describe an array type
4406      * @since 12
4407      */
4408     @Override
4409     public Class&lt;?&gt; componentType() {
4410         return isArray() ? componentType : null;
4411     }
4412 
4413     /**
4414      * Returns a {@code Class} for an array type whose component type
4415      * is described by this {@linkplain Class}.
4416      *
4417      * @return a {@code Class} describing the array type
4418      * @since 12
4419      */
4420     @Override
4421     public Class&lt;?&gt; arrayType() {
4422         return Array.newInstance(this, 0).getClass();
4423     }
4424 
4425     /**
4426      * Returns a nominal descriptor for this instance, if one can be
4427      * constructed, or an empty {@link Optional} if one cannot be.
4428      *
4429      * @return An {@link Optional} containing the resulting nominal descriptor,
4430      * or an empty {@link Optional} if one cannot be constructed.
4431      * @since 12
4432      */
4433     @Override
4434     public Optional&lt;ClassDesc&gt; describeConstable() {
<a name="42" id="anc42"></a><span class="line-modified">4435         Class&lt;?&gt; c = isArray() ? elementType() : this;</span>
<span class="line-modified">4436         return c.isHidden() ? Optional.empty()</span>
<span class="line-added">4437                             : Optional.of(ClassDesc.ofDescriptor(descriptorString()));</span>
<span class="line-added">4438    }</span>
<span class="line-added">4439 </span>
<span class="line-added">4440     /**</span>
<span class="line-added">4441      * Returns {@code true} if and only if the underlying class is a hidden class.</span>
<span class="line-added">4442      *</span>
<span class="line-added">4443      * @return {@code true} if and only if this class is a hidden class.</span>
<span class="line-added">4444      *</span>
<span class="line-added">4445      * @since 15</span>
<span class="line-added">4446      * @see MethodHandles.Lookup#defineHiddenClass</span>
<span class="line-added">4447      */</span>
<span class="line-added">4448     @HotSpotIntrinsicCandidate</span>
<span class="line-added">4449     public native boolean isHidden();</span>
<span class="line-added">4450 </span>
4451 }
<a name="43" id="anc43"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="43" type="hidden" />
</body>
</html>
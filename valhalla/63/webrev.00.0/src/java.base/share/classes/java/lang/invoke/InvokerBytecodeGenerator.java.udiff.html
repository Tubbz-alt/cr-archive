<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InnerClassLambdaMetafactory.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleNatives.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,10 +24,11 @@</span>
   */
  
  package java.lang.invoke;
  
  import jdk.internal.org.objectweb.asm.ClassWriter;
<span class="udiff-line-added">+ import jdk.internal.org.objectweb.asm.FieldVisitor;</span>
  import jdk.internal.org.objectweb.asm.Label;
  import jdk.internal.org.objectweb.asm.MethodVisitor;
  import jdk.internal.org.objectweb.asm.Opcodes;
  import jdk.internal.org.objectweb.asm.Type;
  import sun.invoke.util.VerifyAccess;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -40,17 +41,19 @@</span>
  import java.io.IOException;
  import java.lang.reflect.Modifier;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.HashMap;
<span class="udiff-line-added">+ import java.util.List;</span>
  import java.util.stream.Stream;
  
  import static java.lang.invoke.LambdaForm.BasicType;
  import static java.lang.invoke.LambdaForm.BasicType.*;
  import static java.lang.invoke.LambdaForm.*;
  import static java.lang.invoke.MethodHandleNatives.Constants.*;
  import static java.lang.invoke.MethodHandleStatics.*;
<span class="udiff-line-added">+ import static java.lang.invoke.MethodHandles.Lookup.*;</span>
  
  /**
   * Code generation backend for LambdaForm.
   * &lt;p&gt;
   * @author John Rose, JSR 292 EG
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,10 +68,12 @@</span>
      private static final String OBJ     = &quot;java/lang/Object&quot;;
      private static final String OBJARY  = &quot;[Ljava/lang/Object;&quot;;
  
      private static final String LOOP_CLAUSES = MHI + &quot;$LoopClauses&quot;;
      private static final String MHARY2       = &quot;[[L&quot; + MH + &quot;;&quot;;
<span class="udiff-line-added">+     private static final String MH_SIG       = &quot;L&quot; + MH + &quot;;&quot;;</span>
<span class="udiff-line-added">+ </span>
  
      private static final String LF_SIG  = &quot;L&quot; + LF + &quot;;&quot;;
      private static final String LFN_SIG = &quot;L&quot; + LFN + &quot;;&quot;;
      private static final String LL_SIG  = &quot;(L&quot; + OBJ + &quot;;)L&quot; + OBJ + &quot;;&quot;;
      private static final String LLV_SIG = &quot;(L&quot; + OBJ + &quot;;L&quot; + OBJ + &quot;;)V&quot;;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90,17 +95,27 @@</span>
      private Class&lt;?&gt;[]  localClasses; // type
  
      /** ASM bytecode generation. */
      private ClassWriter cw;
      private MethodVisitor mv;
<span class="udiff-line-added">+     private final List&lt;ClassData&gt; classData = new ArrayList&lt;&gt;();</span>
  
      /** Single element internal class name lookup cache. */
      private Class&lt;?&gt; lastClass;
      private String lastInternalName;
  
      private static final MemberName.Factory MEMBERNAME_FACTORY = MemberName.getFactory();
      private static final Class&lt;?&gt; HOST_CLASS = LambdaForm.class;
<span class="udiff-line-added">+     private static final MethodHandles.Lookup LOOKUP = lookup();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static MethodHandles.Lookup lookup() {</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             return MethodHandles.privateLookupIn(HOST_CLASS, IMPL_LOOKUP);</span>
<span class="udiff-line-added">+         } catch (IllegalAccessException e) {</span>
<span class="udiff-line-added">+             throw newInternalError(e);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
      /** Main constructor; other constructors delegate to this one. */
      private InvokerBytecodeGenerator(LambdaForm lambdaForm, int localsMapSize,
                                       String className, String invokerName, MethodType invokerType) {
          int p = invokerName.indexOf(&#39;.&#39;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -219,45 +234,56 @@</span>
              sfx = &quot;0&quot;+sfx;
          className += sfx;
          return className;
      }
  
<span class="udiff-line-modified-removed">-     class CpPatch {</span>
<span class="udiff-line-modified-removed">-         final int index;</span>
<span class="udiff-line-modified-added">+     public static class ClassData {</span>
<span class="udiff-line-modified-added">+         final String name;</span>
<span class="udiff-line-added">+         final String desc;</span>
          final Object value;
<span class="udiff-line-modified-removed">-         CpPatch(int index, Object value) {</span>
<span class="udiff-line-modified-removed">-             this.index = index;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         ClassData(String name, String desc, Object value) {</span>
<span class="udiff-line-added">+             this.name = name;</span>
<span class="udiff-line-added">+             this.desc = desc;</span>
              this.value = value;
          }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         public String name() { return name; }</span>
          public String toString() {
<span class="udiff-line-modified-removed">-             return &quot;CpPatch/index=&quot;+index+&quot;,value=&quot;+value;</span>
<span class="udiff-line-modified-added">+             return name + &quot;,value=&quot;+value;</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     private final ArrayList&lt;CpPatch&gt; cpPatches = new ArrayList&lt;&gt;();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     private int cph = 0;  // for counting constant placeholders</span>
<span class="udiff-line-modified-added">+     String classData(Object arg) {</span>
<span class="udiff-line-modified-added">+         String desc;</span>
<span class="udiff-line-modified-added">+         if (arg instanceof Class) {</span>
<span class="udiff-line-added">+             desc = &quot;Ljava/lang/Class;&quot;;</span>
<span class="udiff-line-added">+         } else if (arg instanceof MethodHandle) {</span>
<span class="udiff-line-added">+             desc = MH_SIG;</span>
<span class="udiff-line-added">+         } else if (arg instanceof LambdaForm) {</span>
<span class="udiff-line-added">+             desc = LF_SIG;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             desc = &quot;Ljava/lang/Object;&quot;;</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-     String constantPlaceholder(Object arg) {</span>
<span class="udiff-line-modified-removed">-         String cpPlaceholder = &quot;CONSTANT_PLACEHOLDER_&quot; + cph++;</span>
<span class="udiff-line-modified-removed">-         if (DUMP_CLASS_FILES) cpPlaceholder += &quot; &lt;&lt;&quot; + debugString(arg) + &quot;&gt;&gt;&quot;;</span>
<span class="udiff-line-modified-removed">-         // TODO check if arg is already in the constant pool</span>
<span class="udiff-line-modified-removed">-         // insert placeholder in CP and remember the patch</span>
<span class="udiff-line-modified-removed">-         int index = cw.newConst((Object) cpPlaceholder);</span>
<span class="udiff-line-modified-removed">-         cpPatches.add(new CpPatch(index, arg));</span>
<span class="udiff-line-modified-removed">-         return cpPlaceholder;</span>
<span class="udiff-line-modified-added">+         Class&lt;?&gt; c = arg.getClass();</span>
<span class="udiff-line-modified-added">+         while (c.isArray()) {</span>
<span class="udiff-line-modified-added">+             c = c.getComponentType();</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         // unique static variable name</span>
<span class="udiff-line-modified-added">+         String name = &quot;_DATA_&quot; + c.getSimpleName() + &quot;_&quot; + classData.size();</span>
<span class="udiff-line-modified-added">+         ClassData cd = new ClassData(name, desc, arg);</span>
<span class="udiff-line-modified-added">+         classData.add(cd);</span>
<span class="udiff-line-added">+         return cd.name();</span>
      }
  
<span class="udiff-line-modified-removed">-     Object[] cpPatches(byte[] classFile) {</span>
<span class="udiff-line-modified-removed">-         int size = getConstantPoolSize(classFile);</span>
<span class="udiff-line-modified-removed">-         Object[] res = new Object[size];</span>
<span class="udiff-line-modified-removed">-         for (CpPatch p : cpPatches) {</span>
<span class="udiff-line-removed">-             if (p.index &gt;= size)</span>
<span class="udiff-line-removed">-                 throw new InternalError(&quot;in cpool[&quot;+size+&quot;]: &quot;+p+&quot;\n&quot;+Arrays.toString(Arrays.copyOf(classFile, 20)));</span>
<span class="udiff-line-removed">-             res[p.index] = p.value;</span>
<span class="udiff-line-modified-added">+     List&lt;Object&gt; classDataValues() {</span>
<span class="udiff-line-modified-added">+         Object[] data = new Object[classData.size()];</span>
<span class="udiff-line-modified-added">+         for (int i = 0; i &lt; classData.size(); i++) {</span>
<span class="udiff-line-modified-added">+             data[i] = classData.get(i).value;</span>
          }
<span class="udiff-line-modified-removed">-         return res;</span>
<span class="udiff-line-modified-added">+         return List.of(data);</span>
      }
  
      private static String debugString(Object arg) {
          if (arg instanceof MethodHandle) {
              MethodHandle mh = (MethodHandle) arg;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -286,24 +312,16 @@</span>
  
      /**
       * Extract the MemberName of a newly-defined method.
       */
      private MemberName loadMethod(byte[] classFile) {
<span class="udiff-line-modified-removed">-         Class&lt;?&gt; invokerClass = loadAndInitializeInvokerClass(classFile, cpPatches(classFile));</span>
<span class="udiff-line-modified-added">+         Class&lt;?&gt; invokerClass = LOOKUP.makeHiddenClassDefiner(classFile)</span>
<span class="udiff-line-added">+                                       .defineClass(true, classDataValues());</span>
          return resolveInvokerMember(invokerClass, invokerName, invokerType);
      }
  
<span class="udiff-line-modified-removed">-     /**</span>
<span class="udiff-line-removed">-      * Define a given class as anonymous class in the runtime system.</span>
<span class="udiff-line-removed">-      */</span>
<span class="udiff-line-removed">-     private static Class&lt;?&gt; loadAndInitializeInvokerClass(byte[] classBytes, Object[] patches) {</span>
<span class="udiff-line-removed">-         Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(HOST_CLASS, classBytes, patches);</span>
<span class="udiff-line-removed">-         UNSAFE.ensureClassInitialized(invokerClass);  // Make sure the class is initialized; VM might complain.</span>
<span class="udiff-line-removed">-         return invokerClass;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static MemberName resolveInvokerMember(Class&lt;?&gt; invokerClass, String name, MethodType type) {</span>
<span class="udiff-line-modified-added">+     private static MemberName resolveInvokerMember(Class&lt;?&gt; invokerClass, String name, MethodType type) {</span>
          MemberName member = new MemberName(invokerClass, name, type, REF_invokeStatic);
          try {
              member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);
          } catch (ReflectiveOperationException e) {
              throw newInternalError(e);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -314,11 +332,12 @@</span>
      /**
       * Set up class file generation.
       */
      private ClassWriter classFilePrologue() {
          final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
<span class="udiff-line-modified-removed">-         cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>
<span class="udiff-line-modified-added">+         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>
<span class="udiff-line-added">+         setClassWriter(cw);</span>
          cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
                  CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);
          cw.visitSource(SOURCE_PREFIX + className, null);
          return cw;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -334,10 +353,55 @@</span>
      private void methodEpilogue() {
          mv.visitMaxs(0, 0);
          mv.visitEnd();
      }
  
<span class="udiff-line-added">+     private String className() {</span>
<span class="udiff-line-added">+         return CLASS_PREFIX + className;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private void clinit() {</span>
<span class="udiff-line-added">+         clinit(cw, className(), classData);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /*</span>
<span class="udiff-line-added">+      * &lt;clinit&gt; to initialize the static final fields with the live class data</span>
<span class="udiff-line-added">+      * LambdaForms can&#39;t use condy due to bootstrapping issue.</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static void clinit(ClassWriter cw, String className, List&lt;ClassData&gt; classData) {</span>
<span class="udiff-line-added">+         if (classData.isEmpty())</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         for (ClassData p : classData) {</span>
<span class="udiff-line-added">+             // add the static field</span>
<span class="udiff-line-added">+             FieldVisitor fv = cw.visitField(Opcodes.ACC_STATIC|Opcodes.ACC_FINAL, p.name, p.desc, null, null);</span>
<span class="udiff-line-added">+             fv.visitEnd();</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);</span>
<span class="udiff-line-added">+         mv.visitCode();</span>
<span class="udiff-line-added">+         mv.visitLdcInsn(Type.getType(&quot;L&quot; + className + &quot;;&quot;));</span>
<span class="udiff-line-added">+         mv.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/invoke/MethodHandleNatives&quot;,</span>
<span class="udiff-line-added">+                            &quot;classData&quot;, &quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, false);</span>
<span class="udiff-line-added">+         // we should optimize one single element case that does not need to create a List</span>
<span class="udiff-line-added">+         mv.visitTypeInsn(Opcodes.CHECKCAST, &quot;java/util/List&quot;);</span>
<span class="udiff-line-added">+         mv.visitVarInsn(Opcodes.ASTORE, 0);</span>
<span class="udiff-line-added">+         int index = 0;</span>
<span class="udiff-line-added">+         for (ClassData p : classData) {</span>
<span class="udiff-line-added">+             // initialize the static field</span>
<span class="udiff-line-added">+             mv.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="udiff-line-added">+             emitIconstInsn(mv, index++);</span>
<span class="udiff-line-added">+             mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, &quot;java/util/List&quot;,</span>
<span class="udiff-line-added">+                                &quot;get&quot;, &quot;(I)Ljava/lang/Object;&quot;, true);</span>
<span class="udiff-line-added">+             mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));</span>
<span class="udiff-line-added">+             mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         mv.visitInsn(Opcodes.RETURN);</span>
<span class="udiff-line-added">+         mv.visitMaxs(2, 1);</span>
<span class="udiff-line-added">+         mv.visitEnd();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /*
       * Low-level emit helpers.
       */
      private void emitConst(Object con) {
          if (con == null) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -406,10 +470,14 @@</span>
          // fall through:
          mv.visitLdcInsn(con);
      }
  
      private void emitIconstInsn(final int cst) {
<span class="udiff-line-added">+         emitIconstInsn(mv, cst);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private static void emitIconstInsn(MethodVisitor mv, int cst) {</span>
          if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {
              mv.visitInsn(Opcodes.ICONST_0 + cst);
          } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {
              mv.visitIntInsn(Opcodes.BIPUSH, cst);
          } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -575,12 +643,11 @@</span>
          }
          if (isStaticallyNameable(cls)) {
              String sig = getInternalName(cls);
              mv.visitTypeInsn(Opcodes.CHECKCAST, sig);
          } else {
<span class="udiff-line-modified-removed">-             mv.visitLdcInsn(constantPlaceholder(cls));</span>
<span class="udiff-line-removed">-             mv.visitTypeInsn(Opcodes.CHECKCAST, CLS);</span>
<span class="udiff-line-modified-added">+             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(cls), &quot;Ljava/lang/Class;&quot;);</span>
              mv.visitInsn(Opcodes.SWAP);
              mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, &quot;cast&quot;, LL_SIG, false);
              if (Object[].class.isAssignableFrom(cls))
                  mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);
              else if (PROFILE_LEVEL &gt; 0)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -735,10 +802,11 @@</span>
       * Generate an invoker method for the passed {@link LambdaForm}.
       */
      private byte[] generateCustomizedCodeBytes() {
          classFilePrologue();
          addMethod();
<span class="udiff-line-added">+         clinit();</span>
          bogusMethod(lambdaForm);
  
          final byte[] classFile = toByteArray();
          maybeDump(classFile);
          return classFile;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -762,18 +830,18 @@</span>
              mv.visitAnnotation(FORCEINLINE_SIG, true);
          } else {
              mv.visitAnnotation(DONTINLINE_SIG, true);
          }
  
<span class="udiff-line-modified-removed">-         constantPlaceholder(lambdaForm); // keep LambdaForm instance &amp; its compiled form lifetime tightly coupled.</span>
<span class="udiff-line-modified-added">+         classData(lambdaForm); // keep LambdaForm instance &amp; its compiled form lifetime tightly coupled.</span>
  
          if (lambdaForm.customized != null) {
              // Since LambdaForm is customized for a particular MethodHandle, it&#39;s safe to substitute
              // receiver MethodHandle (at slot #0) with an embedded constant and use it instead.
              // It enables more efficient code generation in some situations, since embedded constants
              // are compile-time constants for JIT compiler.
<span class="udiff-line-modified-removed">-             mv.visitLdcInsn(constantPlaceholder(lambdaForm.customized));</span>
<span class="udiff-line-modified-added">+             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(lambdaForm.customized), MH_SIG);</span>
              mv.visitTypeInsn(Opcodes.CHECKCAST, MH);
              assert(checkActualReceiver()); // expects MethodHandle on top of the stack
              mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);
          }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -899,11 +967,11 @@</span>
          assert(!name.isLinkerMethodInvoke());  // should use the static path for these
          if (true) {
              // push receiver
              MethodHandle target = name.function.resolvedHandle();
              assert(target != null) : name.exprString();
<span class="udiff-line-modified-removed">-             mv.visitLdcInsn(constantPlaceholder(target));</span>
<span class="udiff-line-modified-added">+             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(target), MH_SIG);</span>
              emitReferenceCast(MethodHandle.class, target);
          } else {
              // load receiver
              emitAloadInsn(0);
              emitReferenceCast(MethodHandle.class, null);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -956,11 +1024,13 @@</span>
              return false;  // FIXME
          if (cls.isAnonymousClass() || cls.isLocalClass())
              return false;  // inner class of some sort
          if (cls.getClassLoader() != MethodHandle.class.getClassLoader())
              return false;  // not on BCP
<span class="udiff-line-modified-removed">-         if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added</span>
<span class="udiff-line-modified-added">+         if (cls.isHidden())</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         if (ReflectUtil.isVMAnonymousClass(cls))   // FIXME: Unsafe::defineAnonymousClass to be removed</span>
              return false;
          if (!isStaticallyInvocableType(member.getMethodOrFieldType()))
              return false;
          if (!member.isPrivate() &amp;&amp; VerifyAccess.isSamePackage(MethodHandle.class, cls))
              return true;   // in java.lang.invoke package
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -980,18 +1050,20 @@</span>
  
      static boolean isStaticallyNameable(Class&lt;?&gt; cls) {
          if (cls == Object.class)
              return true;
          if (MethodHandle.class.isAssignableFrom(cls)) {
<span class="udiff-line-modified-removed">-             assert(!ReflectUtil.isVMAnonymousClass(cls));</span>
<span class="udiff-line-modified-added">+             assert(!cls.isHidden());</span>
              return true;
          }
          while (cls.isArray())
              cls = cls.getComponentType();
          if (cls.isPrimitive())
              return true;  // int[].class, for example
<span class="udiff-line-modified-removed">-         if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added</span>
<span class="udiff-line-modified-added">+         if (cls.isHidden())</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         if (ReflectUtil.isVMAnonymousClass(cls))   // FIXME: Unsafe::defineAnonymousClass to be removed</span>
              return false;
          // could use VerifyAccess.isClassAccessible but the following is a safe approximation
          if (cls.getClassLoader() != Object.class.getClassLoader())
              return false;
          if (VerifyAccess.isSamePackage(MethodHandle.class, cls))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1059,11 +1131,11 @@</span>
              } catch (Throwable ex) {
                  throw uncaughtException(ex);
              }
              assert(java.lang.reflect.Array.getLength(emptyArray) == 0);
              assert(emptyArray.getClass() == rtype);  // exact typing
<span class="udiff-line-modified-removed">-             mv.visitLdcInsn(constantPlaceholder(emptyArray));</span>
<span class="udiff-line-modified-added">+             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(emptyArray), &quot;Ljava/lang/Object;&quot;);</span>
              emitReferenceCast(rtype, emptyArray);
              return;
          }
          Class&lt;?&gt; arrayElementType = rtype.getComponentType();
          assert(arrayElementType != null);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1622,11 +1694,11 @@</span>
              emitConst(arg);
          } else {
              if (Wrapper.isWrapperType(arg.getClass()) &amp;&amp; bptype != L_TYPE) {
                  emitConst(arg);
              } else {
<span class="udiff-line-modified-removed">-                 mv.visitLdcInsn(constantPlaceholder(arg));</span>
<span class="udiff-line-modified-added">+                 mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(arg), &quot;Ljava/lang/Object;&quot;);</span>
                  emitImplicitConversion(L_TYPE, ptype, arg);
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1814,10 +1886,11 @@</span>
  
          // return statement
          emitReturnInsn(basicType(rtype));
  
          methodEpilogue();
<span class="udiff-line-added">+         clinit();</span>
          bogusMethod(invokerType);
  
          final byte[] classFile = cw.toByteArray();
          maybeDump(classFile);
          return classFile;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1882,10 +1955,11 @@</span>
              mv.visitInsn(Opcodes.ACONST_NULL);
          }
          emitReturnInsn(L_TYPE);  // NOTE: NamedFunction invokers always return a reference value.
  
          methodEpilogue();
<span class="udiff-line-added">+         clinit();</span>
          bogusMethod(dstType);
  
          final byte[] classFile = cw.toByteArray();
          maybeDump(classFile);
          return classFile;
</pre>
<center><a href="InnerClassLambdaMetafactory.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleNatives.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
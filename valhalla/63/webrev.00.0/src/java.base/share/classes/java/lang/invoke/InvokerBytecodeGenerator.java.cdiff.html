<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InnerClassLambdaMetafactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleNatives.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,10 ***</span>
<span class="line-new-header">--- 24,11 ---</span>
   */
  
  package java.lang.invoke;
  
  import jdk.internal.org.objectweb.asm.ClassWriter;
<span class="line-added">+ import jdk.internal.org.objectweb.asm.FieldVisitor;</span>
  import jdk.internal.org.objectweb.asm.Label;
  import jdk.internal.org.objectweb.asm.MethodVisitor;
  import jdk.internal.org.objectweb.asm.Opcodes;
  import jdk.internal.org.objectweb.asm.Type;
  import sun.invoke.util.VerifyAccess;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 40,17 ***</span>
<span class="line-new-header">--- 41,19 ---</span>
  import java.io.IOException;
  import java.lang.reflect.Modifier;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.HashMap;
<span class="line-added">+ import java.util.List;</span>
  import java.util.stream.Stream;
  
  import static java.lang.invoke.LambdaForm.BasicType;
  import static java.lang.invoke.LambdaForm.BasicType.*;
  import static java.lang.invoke.LambdaForm.*;
  import static java.lang.invoke.MethodHandleNatives.Constants.*;
  import static java.lang.invoke.MethodHandleStatics.*;
<span class="line-added">+ import static java.lang.invoke.MethodHandles.Lookup.*;</span>
  
  /**
   * Code generation backend for LambdaForm.
   * &lt;p&gt;
   * @author John Rose, JSR 292 EG
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,10 ***</span>
<span class="line-new-header">--- 68,12 ---</span>
      private static final String OBJ     = &quot;java/lang/Object&quot;;
      private static final String OBJARY  = &quot;[Ljava/lang/Object;&quot;;
  
      private static final String LOOP_CLAUSES = MHI + &quot;$LoopClauses&quot;;
      private static final String MHARY2       = &quot;[[L&quot; + MH + &quot;;&quot;;
<span class="line-added">+     private static final String MH_SIG       = &quot;L&quot; + MH + &quot;;&quot;;</span>
<span class="line-added">+ </span>
  
      private static final String LF_SIG  = &quot;L&quot; + LF + &quot;;&quot;;
      private static final String LFN_SIG = &quot;L&quot; + LFN + &quot;;&quot;;
      private static final String LL_SIG  = &quot;(L&quot; + OBJ + &quot;;)L&quot; + OBJ + &quot;;&quot;;
      private static final String LLV_SIG = &quot;(L&quot; + OBJ + &quot;;L&quot; + OBJ + &quot;;)V&quot;;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,17 ***</span>
<span class="line-new-header">--- 95,27 ---</span>
      private Class&lt;?&gt;[]  localClasses; // type
  
      /** ASM bytecode generation. */
      private ClassWriter cw;
      private MethodVisitor mv;
<span class="line-added">+     private final List&lt;ClassData&gt; classData = new ArrayList&lt;&gt;();</span>
  
      /** Single element internal class name lookup cache. */
      private Class&lt;?&gt; lastClass;
      private String lastInternalName;
  
      private static final MemberName.Factory MEMBERNAME_FACTORY = MemberName.getFactory();
      private static final Class&lt;?&gt; HOST_CLASS = LambdaForm.class;
<span class="line-added">+     private static final MethodHandles.Lookup LOOKUP = lookup();</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static MethodHandles.Lookup lookup() {</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             return MethodHandles.privateLookupIn(HOST_CLASS, IMPL_LOOKUP);</span>
<span class="line-added">+         } catch (IllegalAccessException e) {</span>
<span class="line-added">+             throw newInternalError(e);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
  
      /** Main constructor; other constructors delegate to this one. */
      private InvokerBytecodeGenerator(LambdaForm lambdaForm, int localsMapSize,
                                       String className, String invokerName, MethodType invokerType) {
          int p = invokerName.indexOf(&#39;.&#39;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 219,45 ***</span>
              sfx = &quot;0&quot;+sfx;
          className += sfx;
          return className;
      }
  
<span class="line-modified">!     class CpPatch {</span>
<span class="line-modified">!         final int index;</span>
          final Object value;
<span class="line-modified">!         CpPatch(int index, Object value) {</span>
<span class="line-modified">!             this.index = index;</span>
              this.value = value;
          }
          public String toString() {
<span class="line-modified">!             return &quot;CpPatch/index=&quot;+index+&quot;,value=&quot;+value;</span>
          }
      }
  
<span class="line-modified">!     private final ArrayList&lt;CpPatch&gt; cpPatches = new ArrayList&lt;&gt;();</span>
<span class="line-modified">! </span>
<span class="line-modified">!     private int cph = 0;  // for counting constant placeholders</span>
  
<span class="line-modified">!     String constantPlaceholder(Object arg) {</span>
<span class="line-modified">!         String cpPlaceholder = &quot;CONSTANT_PLACEHOLDER_&quot; + cph++;</span>
<span class="line-modified">!         if (DUMP_CLASS_FILES) cpPlaceholder += &quot; &lt;&lt;&quot; + debugString(arg) + &quot;&gt;&gt;&quot;;</span>
<span class="line-modified">!         // TODO check if arg is already in the constant pool</span>
<span class="line-modified">!         // insert placeholder in CP and remember the patch</span>
<span class="line-modified">!         int index = cw.newConst((Object) cpPlaceholder);</span>
<span class="line-modified">!         cpPatches.add(new CpPatch(index, arg));</span>
<span class="line-modified">!         return cpPlaceholder;</span>
      }
  
<span class="line-modified">!     Object[] cpPatches(byte[] classFile) {</span>
<span class="line-modified">!         int size = getConstantPoolSize(classFile);</span>
<span class="line-modified">!         Object[] res = new Object[size];</span>
<span class="line-modified">!         for (CpPatch p : cpPatches) {</span>
<span class="line-removed">-             if (p.index &gt;= size)</span>
<span class="line-removed">-                 throw new InternalError(&quot;in cpool[&quot;+size+&quot;]: &quot;+p+&quot;\n&quot;+Arrays.toString(Arrays.copyOf(classFile, 20)));</span>
<span class="line-removed">-             res[p.index] = p.value;</span>
          }
<span class="line-modified">!         return res;</span>
      }
  
      private static String debugString(Object arg) {
          if (arg instanceof MethodHandle) {
              MethodHandle mh = (MethodHandle) arg;
<span class="line-new-header">--- 234,56 ---</span>
              sfx = &quot;0&quot;+sfx;
          className += sfx;
          return className;
      }
  
<span class="line-modified">!     public static class ClassData {</span>
<span class="line-modified">!         final String name;</span>
<span class="line-added">+         final String desc;</span>
          final Object value;
<span class="line-modified">! </span>
<span class="line-modified">!         ClassData(String name, String desc, Object value) {</span>
<span class="line-added">+             this.name = name;</span>
<span class="line-added">+             this.desc = desc;</span>
              this.value = value;
          }
<span class="line-added">+ </span>
<span class="line-added">+         public String name() { return name; }</span>
          public String toString() {
<span class="line-modified">!             return name + &quot;,value=&quot;+value;</span>
          }
      }
  
<span class="line-modified">!     String classData(Object arg) {</span>
<span class="line-modified">!         String desc;</span>
<span class="line-modified">!         if (arg instanceof Class) {</span>
<span class="line-added">+             desc = &quot;Ljava/lang/Class;&quot;;</span>
<span class="line-added">+         } else if (arg instanceof MethodHandle) {</span>
<span class="line-added">+             desc = MH_SIG;</span>
<span class="line-added">+         } else if (arg instanceof LambdaForm) {</span>
<span class="line-added">+             desc = LF_SIG;</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             desc = &quot;Ljava/lang/Object;&quot;;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         Class&lt;?&gt; c = arg.getClass();</span>
<span class="line-modified">!         while (c.isArray()) {</span>
<span class="line-modified">!             c = c.getComponentType();</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // unique static variable name</span>
<span class="line-modified">!         String name = &quot;_DATA_&quot; + c.getSimpleName() + &quot;_&quot; + classData.size();</span>
<span class="line-modified">!         ClassData cd = new ClassData(name, desc, arg);</span>
<span class="line-modified">!         classData.add(cd);</span>
<span class="line-added">+         return cd.name();</span>
      }
  
<span class="line-modified">!     List&lt;Object&gt; classDataValues() {</span>
<span class="line-modified">!         Object[] data = new Object[classData.size()];</span>
<span class="line-modified">!         for (int i = 0; i &lt; classData.size(); i++) {</span>
<span class="line-modified">!             data[i] = classData.get(i).value;</span>
          }
<span class="line-modified">!         return List.of(data);</span>
      }
  
      private static String debugString(Object arg) {
          if (arg instanceof MethodHandle) {
              MethodHandle mh = (MethodHandle) arg;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,24 ***</span>
  
      /**
       * Extract the MemberName of a newly-defined method.
       */
      private MemberName loadMethod(byte[] classFile) {
<span class="line-modified">!         Class&lt;?&gt; invokerClass = loadAndInitializeInvokerClass(classFile, cpPatches(classFile));</span>
          return resolveInvokerMember(invokerClass, invokerName, invokerType);
      }
  
<span class="line-modified">!     /**</span>
<span class="line-removed">-      * Define a given class as anonymous class in the runtime system.</span>
<span class="line-removed">-      */</span>
<span class="line-removed">-     private static Class&lt;?&gt; loadAndInitializeInvokerClass(byte[] classBytes, Object[] patches) {</span>
<span class="line-removed">-         Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(HOST_CLASS, classBytes, patches);</span>
<span class="line-removed">-         UNSAFE.ensureClassInitialized(invokerClass);  // Make sure the class is initialized; VM might complain.</span>
<span class="line-removed">-         return invokerClass;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     static MemberName resolveInvokerMember(Class&lt;?&gt; invokerClass, String name, MethodType type) {</span>
          MemberName member = new MemberName(invokerClass, name, type, REF_invokeStatic);
          try {
              member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);
          } catch (ReflectiveOperationException e) {
              throw newInternalError(e);
<span class="line-new-header">--- 312,16 ---</span>
  
      /**
       * Extract the MemberName of a newly-defined method.
       */
      private MemberName loadMethod(byte[] classFile) {
<span class="line-modified">!         Class&lt;?&gt; invokerClass = LOOKUP.makeHiddenClassDefiner(classFile)</span>
<span class="line-added">+                                       .defineClass(true, classDataValues());</span>
          return resolveInvokerMember(invokerClass, invokerName, invokerType);
      }
  
<span class="line-modified">!     private static MemberName resolveInvokerMember(Class&lt;?&gt; invokerClass, String name, MethodType type) {</span>
          MemberName member = new MemberName(invokerClass, name, type, REF_invokeStatic);
          try {
              member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);
          } catch (ReflectiveOperationException e) {
              throw newInternalError(e);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,11 ***</span>
      /**
       * Set up class file generation.
       */
      private ClassWriter classFilePrologue() {
          final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
<span class="line-modified">!         cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>
          cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
                  CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);
          cw.visitSource(SOURCE_PREFIX + className, null);
          return cw;
      }
<span class="line-new-header">--- 332,12 ---</span>
      /**
       * Set up class file generation.
       */
      private ClassWriter classFilePrologue() {
          final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
<span class="line-modified">!         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>
<span class="line-added">+         setClassWriter(cw);</span>
          cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
                  CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);
          cw.visitSource(SOURCE_PREFIX + className, null);
          return cw;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,10 ***</span>
<span class="line-new-header">--- 353,55 ---</span>
      private void methodEpilogue() {
          mv.visitMaxs(0, 0);
          mv.visitEnd();
      }
  
<span class="line-added">+     private String className() {</span>
<span class="line-added">+         return CLASS_PREFIX + className;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private void clinit() {</span>
<span class="line-added">+         clinit(cw, className(), classData);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /*</span>
<span class="line-added">+      * &lt;clinit&gt; to initialize the static final fields with the live class data</span>
<span class="line-added">+      * LambdaForms can&#39;t use condy due to bootstrapping issue.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     static void clinit(ClassWriter cw, String className, List&lt;ClassData&gt; classData) {</span>
<span class="line-added">+         if (classData.isEmpty())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (ClassData p : classData) {</span>
<span class="line-added">+             // add the static field</span>
<span class="line-added">+             FieldVisitor fv = cw.visitField(Opcodes.ACC_STATIC|Opcodes.ACC_FINAL, p.name, p.desc, null, null);</span>
<span class="line-added">+             fv.visitEnd();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);</span>
<span class="line-added">+         mv.visitCode();</span>
<span class="line-added">+         mv.visitLdcInsn(Type.getType(&quot;L&quot; + className + &quot;;&quot;));</span>
<span class="line-added">+         mv.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/invoke/MethodHandleNatives&quot;,</span>
<span class="line-added">+                            &quot;classData&quot;, &quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, false);</span>
<span class="line-added">+         // we should optimize one single element case that does not need to create a List</span>
<span class="line-added">+         mv.visitTypeInsn(Opcodes.CHECKCAST, &quot;java/util/List&quot;);</span>
<span class="line-added">+         mv.visitVarInsn(Opcodes.ASTORE, 0);</span>
<span class="line-added">+         int index = 0;</span>
<span class="line-added">+         for (ClassData p : classData) {</span>
<span class="line-added">+             // initialize the static field</span>
<span class="line-added">+             mv.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="line-added">+             emitIconstInsn(mv, index++);</span>
<span class="line-added">+             mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, &quot;java/util/List&quot;,</span>
<span class="line-added">+                                &quot;get&quot;, &quot;(I)Ljava/lang/Object;&quot;, true);</span>
<span class="line-added">+             mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));</span>
<span class="line-added">+             mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         mv.visitInsn(Opcodes.RETURN);</span>
<span class="line-added">+         mv.visitMaxs(2, 1);</span>
<span class="line-added">+         mv.visitEnd();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      /*
       * Low-level emit helpers.
       */
      private void emitConst(Object con) {
          if (con == null) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 406,10 ***</span>
<span class="line-new-header">--- 470,14 ---</span>
          // fall through:
          mv.visitLdcInsn(con);
      }
  
      private void emitIconstInsn(final int cst) {
<span class="line-added">+         emitIconstInsn(mv, cst);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     private static void emitIconstInsn(MethodVisitor mv, int cst) {</span>
          if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {
              mv.visitInsn(Opcodes.ICONST_0 + cst);
          } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {
              mv.visitIntInsn(Opcodes.BIPUSH, cst);
          } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 575,12 ***</span>
          }
          if (isStaticallyNameable(cls)) {
              String sig = getInternalName(cls);
              mv.visitTypeInsn(Opcodes.CHECKCAST, sig);
          } else {
<span class="line-modified">!             mv.visitLdcInsn(constantPlaceholder(cls));</span>
<span class="line-removed">-             mv.visitTypeInsn(Opcodes.CHECKCAST, CLS);</span>
              mv.visitInsn(Opcodes.SWAP);
              mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, &quot;cast&quot;, LL_SIG, false);
              if (Object[].class.isAssignableFrom(cls))
                  mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);
              else if (PROFILE_LEVEL &gt; 0)
<span class="line-new-header">--- 643,11 ---</span>
          }
          if (isStaticallyNameable(cls)) {
              String sig = getInternalName(cls);
              mv.visitTypeInsn(Opcodes.CHECKCAST, sig);
          } else {
<span class="line-modified">!             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(cls), &quot;Ljava/lang/Class;&quot;);</span>
              mv.visitInsn(Opcodes.SWAP);
              mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, &quot;cast&quot;, LL_SIG, false);
              if (Object[].class.isAssignableFrom(cls))
                  mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);
              else if (PROFILE_LEVEL &gt; 0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 735,10 ***</span>
<span class="line-new-header">--- 802,11 ---</span>
       * Generate an invoker method for the passed {@link LambdaForm}.
       */
      private byte[] generateCustomizedCodeBytes() {
          classFilePrologue();
          addMethod();
<span class="line-added">+         clinit();</span>
          bogusMethod(lambdaForm);
  
          final byte[] classFile = toByteArray();
          maybeDump(classFile);
          return classFile;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 762,18 ***</span>
              mv.visitAnnotation(FORCEINLINE_SIG, true);
          } else {
              mv.visitAnnotation(DONTINLINE_SIG, true);
          }
  
<span class="line-modified">!         constantPlaceholder(lambdaForm); // keep LambdaForm instance &amp; its compiled form lifetime tightly coupled.</span>
  
          if (lambdaForm.customized != null) {
              // Since LambdaForm is customized for a particular MethodHandle, it&#39;s safe to substitute
              // receiver MethodHandle (at slot #0) with an embedded constant and use it instead.
              // It enables more efficient code generation in some situations, since embedded constants
              // are compile-time constants for JIT compiler.
<span class="line-modified">!             mv.visitLdcInsn(constantPlaceholder(lambdaForm.customized));</span>
              mv.visitTypeInsn(Opcodes.CHECKCAST, MH);
              assert(checkActualReceiver()); // expects MethodHandle on top of the stack
              mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);
          }
  
<span class="line-new-header">--- 830,18 ---</span>
              mv.visitAnnotation(FORCEINLINE_SIG, true);
          } else {
              mv.visitAnnotation(DONTINLINE_SIG, true);
          }
  
<span class="line-modified">!         classData(lambdaForm); // keep LambdaForm instance &amp; its compiled form lifetime tightly coupled.</span>
  
          if (lambdaForm.customized != null) {
              // Since LambdaForm is customized for a particular MethodHandle, it&#39;s safe to substitute
              // receiver MethodHandle (at slot #0) with an embedded constant and use it instead.
              // It enables more efficient code generation in some situations, since embedded constants
              // are compile-time constants for JIT compiler.
<span class="line-modified">!             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(lambdaForm.customized), MH_SIG);</span>
              mv.visitTypeInsn(Opcodes.CHECKCAST, MH);
              assert(checkActualReceiver()); // expects MethodHandle on top of the stack
              mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 899,11 ***</span>
          assert(!name.isLinkerMethodInvoke());  // should use the static path for these
          if (true) {
              // push receiver
              MethodHandle target = name.function.resolvedHandle();
              assert(target != null) : name.exprString();
<span class="line-modified">!             mv.visitLdcInsn(constantPlaceholder(target));</span>
              emitReferenceCast(MethodHandle.class, target);
          } else {
              // load receiver
              emitAloadInsn(0);
              emitReferenceCast(MethodHandle.class, null);
<span class="line-new-header">--- 967,11 ---</span>
          assert(!name.isLinkerMethodInvoke());  // should use the static path for these
          if (true) {
              // push receiver
              MethodHandle target = name.function.resolvedHandle();
              assert(target != null) : name.exprString();
<span class="line-modified">!             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(target), MH_SIG);</span>
              emitReferenceCast(MethodHandle.class, target);
          } else {
              // load receiver
              emitAloadInsn(0);
              emitReferenceCast(MethodHandle.class, null);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 956,11 ***</span>
              return false;  // FIXME
          if (cls.isAnonymousClass() || cls.isLocalClass())
              return false;  // inner class of some sort
          if (cls.getClassLoader() != MethodHandle.class.getClassLoader())
              return false;  // not on BCP
<span class="line-modified">!         if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added</span>
              return false;
          if (!isStaticallyInvocableType(member.getMethodOrFieldType()))
              return false;
          if (!member.isPrivate() &amp;&amp; VerifyAccess.isSamePackage(MethodHandle.class, cls))
              return true;   // in java.lang.invoke package
<span class="line-new-header">--- 1024,13 ---</span>
              return false;  // FIXME
          if (cls.isAnonymousClass() || cls.isLocalClass())
              return false;  // inner class of some sort
          if (cls.getClassLoader() != MethodHandle.class.getClassLoader())
              return false;  // not on BCP
<span class="line-modified">!         if (cls.isHidden())</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         if (ReflectUtil.isVMAnonymousClass(cls))   // FIXME: Unsafe::defineAnonymousClass to be removed</span>
              return false;
          if (!isStaticallyInvocableType(member.getMethodOrFieldType()))
              return false;
          if (!member.isPrivate() &amp;&amp; VerifyAccess.isSamePackage(MethodHandle.class, cls))
              return true;   // in java.lang.invoke package
</pre>
<hr />
<pre>
<span class="line-old-header">*** 980,18 ***</span>
  
      static boolean isStaticallyNameable(Class&lt;?&gt; cls) {
          if (cls == Object.class)
              return true;
          if (MethodHandle.class.isAssignableFrom(cls)) {
<span class="line-modified">!             assert(!ReflectUtil.isVMAnonymousClass(cls));</span>
              return true;
          }
          while (cls.isArray())
              cls = cls.getComponentType();
          if (cls.isPrimitive())
              return true;  // int[].class, for example
<span class="line-modified">!         if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added</span>
              return false;
          // could use VerifyAccess.isClassAccessible but the following is a safe approximation
          if (cls.getClassLoader() != Object.class.getClassLoader())
              return false;
          if (VerifyAccess.isSamePackage(MethodHandle.class, cls))
<span class="line-new-header">--- 1050,20 ---</span>
  
      static boolean isStaticallyNameable(Class&lt;?&gt; cls) {
          if (cls == Object.class)
              return true;
          if (MethodHandle.class.isAssignableFrom(cls)) {
<span class="line-modified">!             assert(!cls.isHidden());</span>
              return true;
          }
          while (cls.isArray())
              cls = cls.getComponentType();
          if (cls.isPrimitive())
              return true;  // int[].class, for example
<span class="line-modified">!         if (cls.isHidden())</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         if (ReflectUtil.isVMAnonymousClass(cls))   // FIXME: Unsafe::defineAnonymousClass to be removed</span>
              return false;
          // could use VerifyAccess.isClassAccessible but the following is a safe approximation
          if (cls.getClassLoader() != Object.class.getClassLoader())
              return false;
          if (VerifyAccess.isSamePackage(MethodHandle.class, cls))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1059,11 ***</span>
              } catch (Throwable ex) {
                  throw uncaughtException(ex);
              }
              assert(java.lang.reflect.Array.getLength(emptyArray) == 0);
              assert(emptyArray.getClass() == rtype);  // exact typing
<span class="line-modified">!             mv.visitLdcInsn(constantPlaceholder(emptyArray));</span>
              emitReferenceCast(rtype, emptyArray);
              return;
          }
          Class&lt;?&gt; arrayElementType = rtype.getComponentType();
          assert(arrayElementType != null);
<span class="line-new-header">--- 1131,11 ---</span>
              } catch (Throwable ex) {
                  throw uncaughtException(ex);
              }
              assert(java.lang.reflect.Array.getLength(emptyArray) == 0);
              assert(emptyArray.getClass() == rtype);  // exact typing
<span class="line-modified">!             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(emptyArray), &quot;Ljava/lang/Object;&quot;);</span>
              emitReferenceCast(rtype, emptyArray);
              return;
          }
          Class&lt;?&gt; arrayElementType = rtype.getComponentType();
          assert(arrayElementType != null);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1622,11 ***</span>
              emitConst(arg);
          } else {
              if (Wrapper.isWrapperType(arg.getClass()) &amp;&amp; bptype != L_TYPE) {
                  emitConst(arg);
              } else {
<span class="line-modified">!                 mv.visitLdcInsn(constantPlaceholder(arg));</span>
                  emitImplicitConversion(L_TYPE, ptype, arg);
              }
          }
      }
  
<span class="line-new-header">--- 1694,11 ---</span>
              emitConst(arg);
          } else {
              if (Wrapper.isWrapperType(arg.getClass()) &amp;&amp; bptype != L_TYPE) {
                  emitConst(arg);
              } else {
<span class="line-modified">!                 mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(arg), &quot;Ljava/lang/Object;&quot;);</span>
                  emitImplicitConversion(L_TYPE, ptype, arg);
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1814,10 ***</span>
<span class="line-new-header">--- 1886,11 ---</span>
  
          // return statement
          emitReturnInsn(basicType(rtype));
  
          methodEpilogue();
<span class="line-added">+         clinit();</span>
          bogusMethod(invokerType);
  
          final byte[] classFile = cw.toByteArray();
          maybeDump(classFile);
          return classFile;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1882,10 ***</span>
<span class="line-new-header">--- 1955,11 ---</span>
              mv.visitInsn(Opcodes.ACONST_NULL);
          }
          emitReturnInsn(L_TYPE);  // NOTE: NamedFunction invokers always return a reference value.
  
          methodEpilogue();
<span class="line-added">+         clinit();</span>
          bogusMethod(dstType);
  
          final byte[] classFile = cw.toByteArray();
          maybeDump(classFile);
          return classFile;
</pre>
<center><a href="InnerClassLambdaMetafactory.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleNatives.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
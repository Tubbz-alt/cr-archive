<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../hotspot/share/utilities/exceptions.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;

  31 import java.lang.module.ModuleReader;
  32 import java.lang.ref.SoftReference;
  33 import java.io.IOException;
  34 import java.io.InputStream;
  35 import java.io.ObjectStreamField;
  36 import java.lang.reflect.AnnotatedElement;
  37 import java.lang.reflect.AnnotatedType;
  38 import java.lang.reflect.Array;
  39 import java.lang.reflect.Constructor;
  40 import java.lang.reflect.Executable;
  41 import java.lang.reflect.Field;
  42 import java.lang.reflect.GenericArrayType;
  43 import java.lang.reflect.GenericDeclaration;
  44 import java.lang.reflect.InvocationTargetException;
  45 import java.lang.reflect.Member;
  46 import java.lang.reflect.Method;
  47 import java.lang.reflect.Modifier;
  48 import java.lang.reflect.Proxy;
  49 import java.lang.reflect.RecordComponent;
  50 import java.lang.reflect.Type;
</pre>
<hr />
<pre>
  81 import sun.reflect.generics.repository.ClassRepository;
  82 import sun.reflect.generics.repository.MethodRepository;
  83 import sun.reflect.generics.repository.ConstructorRepository;
  84 import sun.reflect.generics.scope.ClassScope;
  85 import sun.security.util.SecurityConstants;
  86 import sun.reflect.annotation.*;
  87 import sun.reflect.misc.ReflectUtil;
  88 
  89 /**
  90  * Instances of the class {@code Class} represent classes and
  91  * interfaces in a running Java application. An enum type and a record
  92  * type are kinds of class; an annotation type is a kind of
  93  * interface. Every array also belongs to a class that is reflected as
  94  * a {@code Class} object that is shared by all arrays with the same
  95  * element type and number of dimensions.  The primitive Java types
  96  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  97  * int}, {@code long}, {@code float}, and {@code double}), and the
  98  * keyword {@code void} are also represented as {@code Class} objects.
  99  *
 100  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
<span class="line-modified"> 101  * object is constructed automatically by the Java Virtual Machine</span>
<span class="line-modified"> 102  * when a class loader invokes one of the</span>
<span class="line-modified"> 103  * {@link ClassLoader#defineClass(String,byte[], int,int) defineClass} methods</span>
<span class="line-modified"> 104  * and passes the bytes of a {@code class} file.</span>






 105  *
 106  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 107  * class or interface. Most characteristics are derived from the {@code class}
<span class="line-modified"> 108  * file that the class loader passed to the Java Virtual Machine. A few</span>
<span class="line-modified"> 109  * characteristics are determined by the class loading environment at run time,</span>
<span class="line-modified"> 110  * such as the module returned by {@link #getModule() getModule()}.</span>




















 111  *
 112  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 113  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 114  * another declaration. Other methods describe how a class or interface
 115  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 116  * classes and interfaces, in the same run-time package, that
 117  * allow mutual access to their {@code private} members.
 118  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 119  * One nestmate acts as the
 120  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 121  * belong to the nest; each of them in turn records it as the nest host.
 122  * The classes and interfaces which belong to a nest, including its host, are
 123  * determined when
 124  * {@code class} files are generated, for example, a Java compiler
 125  * will typically record a top-level class as the host of a nest where the
 126  * other members are the classes and interfaces whose declarations are
 127  * enclosed within the top-level class declaration.
 128  *
<span class="line-modified"> 129  * &lt;p&gt; The following example uses a {@code Class} object to print the</span>
<span class="line-modified"> 130  * class name of an object:</span>
<span class="line-modified"> 131  *</span>
<span class="line-modified"> 132  * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-modified"> 133  *     void printClassName(Object obj) {</span>
<span class="line-modified"> 134  *         System.out.println(&quot;The class of &quot; + obj +</span>
<span class="line-modified"> 135  *                            &quot; is &quot; + obj.getClass().getName());</span>
<span class="line-removed"> 136  *     }</span>
<span class="line-removed"> 137  * &lt;/pre&gt;&lt;/blockquote&gt;</span>
 138  *
<span class="line-modified"> 139  * &lt;p&gt; It is also possible to get the {@code Class} object for a named</span>
<span class="line-modified"> 140  * type (or for void) using a class literal.  See Section {@jls</span>
<span class="line-modified"> 141  * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
<span class="line-modified"> 142  * For example:</span>










 143  *
<span class="line-modified"> 144  * &lt;blockquote&gt;</span>
<span class="line-modified"> 145  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}</span>
<span class="line-modified"> 146  * &lt;/blockquote&gt;</span>

 147  *
 148  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 149  * object.  For example, the type of {@code String.class} is {@code
 150  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 151  * unknown.
 152  *
 153  * @author  unascribed
 154  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 155  * @since   1.0

 156  */
 157 public final class Class&lt;T&gt; implements java.io.Serializable,
 158                               GenericDeclaration,
 159                               Type,
 160                               AnnotatedElement,
 161                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 162                               Constable {
 163     private static final int ANNOTATION = 0x00002000;
 164     private static final int ENUM       = 0x00004000;
 165     private static final int SYNTHETIC  = 0x00001000;
 166     private static final int INLINE     = 0x00000100;
 167 
 168     private static native void registerNatives();
 169     static {
 170         registerNatives();
 171     }
 172 
 173     /*
 174      * Private constructor. Only the Java Virtual Machine creates Class objects.
 175      * This constructor is not used and prevents the default constructor being
 176      * generated.
 177      */
 178     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 179         // Initialize final field for classLoader.  The initialization value of non-null
 180         // prevents future JIT optimizations from assuming this final field is null.
 181         classLoader = loader;
 182         componentType = arrayComponentType;
 183     }
 184 
 185     /**
 186      * Converts the object to a string. The string representation is the
 187      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
<span class="line-modified"> 188      * fully qualified name of the class in the format returned by</span>
<span class="line-modified"> 189      * {@code getName}.  If this {@code Class} object represents a</span>
<span class="line-modified"> 190      * primitive type, this method returns the name of the primitive type.  If</span>
 191      * this {@code Class} object represents void this method returns
 192      * &quot;void&quot;. If this {@code Class} object represents an array type,
 193      * this method returns &quot;class &quot; followed by {@code getName}.
 194      *
 195      * @return a string representation of this {@code Class} object.
 196      */
 197     public String toString() {
 198         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 199                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 200                + getName();
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
 210      * {@code @interface}, or {@code record} as appropriate), followed
</pre>
<hr />
<pre>
 779      * @see     java.lang.Void#TYPE
 780      * @since 1.1
 781      */
 782     @HotSpotIntrinsicCandidate
 783     public native boolean isPrimitive();
 784 
 785     /**
 786      * Returns true if this {@code Class} object represents an annotation
 787      * type.  Note that if this method returns true, {@link #isInterface()}
 788      * would also return true, as all annotation types are also interfaces.
 789      *
 790      * @return {@code true} if this {@code Class} object represents an annotation
 791      *      type; {@code false} otherwise
 792      * @since 1.5
 793      */
 794     public boolean isAnnotation() {
 795         return (getModifiers() &amp; ANNOTATION) != 0;
 796     }
 797 
 798     /**
<span class="line-modified"> 799      * Returns {@code true} if this class is a synthetic class;</span>
<span class="line-modified"> 800      * returns {@code false} otherwise.</span>
<span class="line-modified"> 801      * @return {@code true} if and only if this class is a synthetic class as</span>
<span class="line-modified"> 802      *         defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 803      * @jls 13.1 The Form of a Binary

 804      * @since 1.5
 805      */
 806     public boolean isSynthetic() {
 807         return (getModifiers() &amp; SYNTHETIC) != 0;
 808     }
 809 
 810     /**
 811      * Returns the  name of the entity (class, interface, array class,
<span class="line-modified"> 812      * primitive type, or void) represented by this {@code Class} object,</span>
<span class="line-removed"> 813      * as a {@code String}.</span>
<span class="line-removed"> 814      *</span>
<span class="line-removed"> 815      * &lt;p&gt; If this {@code Class} object represents a reference type that is</span>
<span class="line-removed"> 816      * not an array type then the binary name of the class is</span>
<span class="line-removed"> 817      * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-removed"> 818      * Specification&lt;/cite&gt;.</span>
 819      *
<span class="line-modified"> 820      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the</span>
<span class="line-modified"> 821      * name returned is a {@code String} equal to the Java language</span>
<span class="line-modified"> 822      * keyword corresponding to the primitive type or void.</span>










 823      *
<span class="line-modified"> 824      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal</span>
<span class="line-modified"> 825      * form of the name consists of the name of the element type preceded by</span>
<span class="line-modified"> 826      * one or more &#39;{@code [}&#39; characters representing the depth of the array</span>
<span class="line-modified"> 827      * nesting.  The encoding of element type names is as follows:</span>
 828      *
 829      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 830      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 831      * &lt;thead&gt;
 832      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 833      * &lt;/thead&gt;
 834      * &lt;tbody style=&quot;text-align:left&quot;&gt;
<span class="line-modified"> 835      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z</span>
<span class="line-modified"> 836      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B</span>
<span class="line-modified"> 837      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C</span>
<span class="line-modified"> 838      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface</span>
<span class="line-modified"> 839      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;</span>
<span class="line-modified"> 840      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class}</span>
<span class="line-modified"> 841      *                                   &lt;td style=&quot;text-align:center&quot;&gt; Q&lt;i&gt;classname&lt;/i&gt;;</span>
<span class="line-modified"> 842      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D</span>
<span class="line-modified"> 843      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F</span>
<span class="line-modified"> 844      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I</span>
<span class="line-modified"> 845      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J</span>
<span class="line-modified"> 846      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S</span>
 847      * &lt;/tbody&gt;
 848      * &lt;/table&gt;&lt;/blockquote&gt;
 849      *
<span class="line-modified"> 850      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of</span>
<span class="line-modified"> 851      * the class specified above.</span>

 852      *
 853      * &lt;p&gt; Examples:
 854      * &lt;blockquote&gt;&lt;pre&gt;
 855      * String.class.getName()
 856      *     returns &quot;java.lang.String&quot;
 857      * byte.class.getName()
 858      *     returns &quot;byte&quot;
 859      * Point.class.getName()
 860      *     returns &quot;Point&quot;
 861      * (new Object[3]).getClass().getName()
 862      *     returns &quot;[Ljava.lang.Object;&quot;
 863      * (new Point[3]).getClass().getName()
 864      *     returns &quot;[QPoint;&quot;
 865      * (new Point.ref[3][4]).getClass().getName()
 866      *     returns &quot;[[LPoint$ref;&quot;
 867      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 868      *     returns &quot;[[[[[[[I&quot;
 869      * &lt;/pre&gt;&lt;/blockquote&gt;
 870      *
<span class="line-modified"> 871      * @return  the name of the class or interface</span>
 872      *          represented by this {@code Class} object.

 873      */
 874     public String getName() {
 875         String name = this.name;
 876         return name != null ? name : initClassName();
 877     }
 878 
 879     // Cache the name to reduce the number of calls into the VM.
 880     // This field would be set by VM itself during initClassName call.
 881     private transient String name;
 882     private native String initClassName();
 883 
 884     /**
 885      * Returns the class loader for the class.  Some implementations may use
 886      * null to represent the bootstrap class loader. This method will return
 887      * null in such implementations if this class was loaded by the bootstrap
 888      * class loader.
 889      *
 890      * &lt;p&gt;If this {@code Class} object
 891      * represents a primitive type or void, null is returned.
 892      *
</pre>
<hr />
<pre>
 930      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
 931      * loader for this class is returned.
 932      *
 933      * @return the module that this class or interface is a member of
 934      *
 935      * @since 9
 936      * @spec JPMS
 937      */
 938     public Module getModule() {
 939         return module;
 940     }
 941 
 942     // set by VM
 943     private transient Module module;
 944 
 945     // Initialized in JVM not by private constructor
 946     // This field is filtered from reflection access, i.e. getDeclaredField
 947     // will throw NoSuchFieldException
 948     private final ClassLoader classLoader;
 949 








 950     /**
 951      * Returns an array of {@code TypeVariable} objects that represent the
 952      * type variables declared by the generic declaration represented by this
 953      * {@code GenericDeclaration} object, in declaration order.  Returns an
 954      * array of length 0 if the underlying generic declaration declares no type
 955      * variables.
 956      *
 957      * @return an array of {@code TypeVariable} objects that represent
 958      *     the type variables declared by this generic declaration
 959      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 960      *     signature of this generic declaration does not conform to
 961      *     the format specified in section {@jvms 4.7.9} of
<span class="line-modified"> 962      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;,</span>
 963      * @since 1.5
 964      */
 965     @SuppressWarnings(&quot;unchecked&quot;)
 966     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
 967         ClassRepository info = getGenericInfo();
 968         if (info != null)
 969             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
 970         else
 971             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
 972     }
 973 
 974 
 975     /**
 976      * Returns the {@code Class} representing the direct superclass of the
 977      * entity (class, interface, primitive type or void) represented by
 978      * this {@code Class}.  If this {@code Class} represents either the
 979      * {@code Object} class, an interface, a primitive type, or void, then
 980      * null is returned.  If this {@code Class} object represents an array class
 981      * then the {@code Class} object representing the {@code Object} class is
 982      * returned.
</pre>
<hr />
<pre>
1065      *
1066      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1067      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1068      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1069      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1070      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1071      *
1072      * &lt;p&gt; If this class represents an array type then this method returns the
1073      * package name of the element type. If this class represents a primitive
1074      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1075      *
1076      * @return the fully qualified package name
1077      *
1078      * @since 9
1079      * @spec JPMS
1080      * @jls 6.7 Fully Qualified Names
1081      */
1082     public String getPackageName() {
1083         String pn = this.packageName;
1084         if (pn == null) {
<span class="line-modified">1085             Class&lt;?&gt; c = this;</span>
<span class="line-removed">1086             while (c.isArray()) {</span>
<span class="line-removed">1087                 c = c.getComponentType();</span>
<span class="line-removed">1088             }</span>
1089             if (c.isPrimitive()) {
1090                 pn = &quot;java.lang&quot;;
1091             } else {
1092                 String cn = c.getName();
1093                 int dot = cn.lastIndexOf(&#39;.&#39;);
1094                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1095             }
1096             this.packageName = pn;
1097         }
1098         return pn;
1099     }
1100 
1101     // cached package name
1102     private transient String packageName;
1103 
1104     /**
1105      * Returns the interfaces directly implemented by the class or interface
1106      * represented by this {@code Class} object.
1107      *
1108      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
</pre>
<hr />
<pre>
1226      * Returns the {@code Class} representing the component type of an
1227      * array.  If this class does not represent an array class this method
1228      * returns null.
1229      *
1230      * @return the {@code Class} representing the component type of this
1231      * class if this class is an array
1232      * @see     java.lang.reflect.Array
1233      * @since 1.1
1234      */
1235     public Class&lt;?&gt; getComponentType() {
1236         // Only return for array types. Storage may be reused for Class for instance types.
1237         if (isArray()) {
1238             return componentType;
1239         } else {
1240             return null;
1241         }
1242     }
1243 
1244     private final Class&lt;?&gt; componentType;
1245 














1246 
1247     /**
1248      * Returns the Java language modifiers for this class or interface, encoded
1249      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1250      * constants for {@code public}, {@code protected},
1251      * {@code private}, {@code final}, {@code static},
1252      * {@code abstract} and {@code interface}; they should be decoded
1253      * using the methods of class {@code Modifier}.
1254      *
1255      * &lt;p&gt; If the underlying class is an array class, then its
1256      * {@code public}, {@code private} and {@code protected}
1257      * modifiers are the same as those of its component type.  If this
1258      * {@code Class} object represents a primitive type or void, its
1259      * {@code public} modifier is always {@code true}, and its
1260      * {@code protected} and {@code private} modifiers are always
1261      * {@code false}. If this {@code Class} object represents an array class, a
1262      * primitive type or void, then its {@code final} modifier is always
1263      * {@code true} and its interface modifier is always
1264      * {@code false}. The values of its other modifiers are not determined
1265      * by this specification.
</pre>
<hr />
<pre>
1654      *
1655      * @return an informative string for the name of this type
1656      * @since 1.8
1657      */
1658     public String getTypeName() {
1659         if (isArray()) {
1660             try {
1661                 Class&lt;?&gt; cl = this;
1662                 int dimensions = 0;
1663                 do {
1664                     dimensions++;
1665                     cl = cl.getComponentType();
1666                 } while (cl.isArray());
1667                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1668             } catch (Throwable e) { /*FALLTHRU*/ }
1669         }
1670         return getName();
1671     }
1672 
1673     /**
<span class="line-modified">1674      * Returns the canonical name of the underlying class as defined</span>
<span class="line-modified">1675      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section</span>
<span class="line-modified">1676      * {@jls 6.7}.  Returns null if the underlying class does not have</span>
<span class="line-modified">1677      * a canonical name (i.e., if it is a local or anonymous class or</span>
<span class="line-modified">1678      * an array whose component type does not have a canonical name).</span>






1679      * @return the canonical name of the underlying class if it exists, and
1680      * {@code null} otherwise.
1681      * @since 1.5
1682      */
1683     public String getCanonicalName() {
1684         ReflectionData&lt;T&gt; rd = reflectionData();
1685         String canonicalName = rd.canonicalName;
1686         if (canonicalName == null) {
1687             rd.canonicalName = canonicalName = getCanonicalName0();
1688         }
1689         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1690     }
1691 
1692     private String getCanonicalName0() {
1693         if (isArray()) {
1694             String canonicalName = getComponentType().getCanonicalName();
1695             if (canonicalName != null)
1696                 return canonicalName + &quot;[]&quot;;
1697             else
1698                 return ReflectionData.NULL_SENTINEL;
1699         }
<span class="line-modified">1700         if (isLocalOrAnonymousClass())</span>
1701             return ReflectionData.NULL_SENTINEL;
1702         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1703         if (enclosingClass == null) { // top level class
1704             return getName();
1705         } else {
1706             String enclosingName = enclosingClass.getCanonicalName();
1707             if (enclosingName == null)
1708                 return ReflectionData.NULL_SENTINEL;
1709             return enclosingName + &quot;.&quot; + getSimpleName();
1710         }
1711     }
1712 
1713     /**
1714      * Returns {@code true} if and only if the underlying class
1715      * is an anonymous class.
1716      *



1717      * @return {@code true} if and only if this class is an anonymous class.
1718      * @since 1.5
1719      */
1720     public boolean isAnonymousClass() {
1721         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1722                 getSimpleBinaryName0() == null;
1723     }
1724 
1725     /**
1726      * Returns {@code true} if and only if the underlying class
1727      * is a local class.
1728      *
1729      * @return {@code true} if and only if this class is a local class.
1730      * @since 1.5
1731      */
1732     public boolean isLocalClass() {
1733         return isLocalOrAnonymousClass() &amp;&amp;
1734                 (isArray() || getSimpleBinaryName0() != null);
1735     }
1736 
</pre>
<hr />
<pre>
2922      * ensure it&#39;s ok to get the
2923      * {@code ProtectionDomain}.
2924      *
2925      * @return the ProtectionDomain of this class
2926      *
2927      * @throws SecurityException
2928      *        if a security manager exists and its
2929      *        {@code checkPermission} method doesn&#39;t allow
2930      *        getting the ProtectionDomain.
2931      *
2932      * @see java.security.ProtectionDomain
2933      * @see SecurityManager#checkPermission
2934      * @see java.lang.RuntimePermission
2935      * @since 1.2
2936      */
2937     public java.security.ProtectionDomain getProtectionDomain() {
2938         SecurityManager sm = System.getSecurityManager();
2939         if (sm != null) {
2940             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
2941         }





2942         java.security.ProtectionDomain pd = getProtectionDomain0();
2943         if (pd == null) {
2944             if (allPermDomain == null) {
2945                 java.security.Permissions perms =
2946                     new java.security.Permissions();
2947                 perms.add(SecurityConstants.ALL_PERMISSION);
2948                 allPermDomain =
2949                     new java.security.ProtectionDomain(null, perms);
2950             }
2951             pd = allPermDomain;
2952         }
2953         return pd;
2954     }
2955 
<span class="line-removed">2956 </span>
2957     /**
2958      * Returns the ProtectionDomain of this class.
2959      */
2960     private native java.security.ProtectionDomain getProtectionDomain0();
2961 
2962     /*
2963      * Return the Virtual Machine&#39;s Class object for the named
2964      * primitive type.
2965      */
2966     static native Class&lt;?&gt; getPrimitiveClass(String name);
2967 
2968     /*
2969      * Check if client is allowed to access members.  If access is denied,
2970      * throw a SecurityException.
2971      *
2972      * This method also enforces package access.
2973      *
2974      * &lt;p&gt; Default policy: allow all clients access with normal Java access
2975      * control.
2976      *
</pre>
<hr />
<pre>
3008             String pkg = this.getPackageName();
3009             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3010                 // skip the package access check on a proxy class in default proxy package
3011                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3012                     sm.checkPackageAccess(pkg);
3013                 }
3014             }
3015         }
3016         // check package access on the proxy interfaces
3017         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3018             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3019         }
3020     }
3021 
3022     /**
3023      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3024      * if name is absolute
3025      */
3026     private String resolveName(String name) {
3027         if (!name.startsWith(&quot;/&quot;)) {
<span class="line-modified">3028             Class&lt;?&gt; c = this;</span>
<span class="line-removed">3029             while (c.isArray()) {</span>
<span class="line-removed">3030                 c = c.getComponentType();</span>
<span class="line-removed">3031             }</span>
3032             String baseName = c.getPackageName();
3033             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3034                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3035             }
3036         } else {
3037             name = name.substring(1);
3038         }
3039         return name;
3040     }
3041 
3042     /**
3043      * Atomic operations support.
3044      */
3045     private static class Atomic {
3046         // initialize Unsafe machinery here, since we need to call Class.class instance method
3047         // and have to avoid calling it in the static initializer of the Class class...
3048         private static final Unsafe unsafe = Unsafe.getUnsafe();
3049         // offset of Class.reflectionData instance field
3050         private static final long reflectionDataOffset
3051                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
</pre>
<hr />
<pre>
4087      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4088      * declaration does not explicitly indicate any annotated superinterfaces,
4089      * the return value is an array of length 0.
4090      *
4091      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4092      * class, an array type, a primitive type, or void, the return value is an
4093      * array of length 0.
4094      *
4095      * @return an array representing the superinterfaces
4096      * @since 1.8
4097      */
4098     public AnnotatedType[] getAnnotatedInterfaces() {
4099         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
4100     }
4101 
4102     private native Class&lt;?&gt; getNestHost0();
4103 
4104     /**
4105      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4106      * or interface represented by this {@code Class} object belongs.
<span class="line-modified">4107      * Every class and interface is a member of exactly one nest.</span>
<span class="line-removed">4108      * A class or interface that is not recorded as belonging to a nest</span>
<span class="line-removed">4109      * belongs to the nest consisting only of itself, and is the nest</span>
<span class="line-removed">4110      * host.</span>
<span class="line-removed">4111      *</span>
<span class="line-removed">4112      * &lt;p&gt;Each of the {@code Class} objects representing array types,</span>
<span class="line-removed">4113      * primitive types, and {@code void} returns {@code this} to indicate</span>
<span class="line-removed">4114      * that the represented entity belongs to the nest consisting only of</span>
<span class="line-removed">4115      * itself, and is the nest host.</span>
4116      *
<span class="line-modified">4117      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing</span>
<span class="line-modified">4118      * the nest host, or if this class or interface is not enumerated as</span>
<span class="line-modified">4119      * a member of the nest by the nest host, then it is considered to belong</span>
<span class="line-modified">4120      * to its own nest and {@code this} is returned as the host.</span>

4121      *
<span class="line-modified">4122      * @apiNote A {@code class} file of version 55.0 or greater may record the</span>
<span class="line-modified">4123      * host of the nest to which it belongs by using the {@code NestHost}</span>
<span class="line-modified">4124      * attribute (JVMS {@jvms 4.7.28}). Alternatively, a {@code class} file of</span>
<span class="line-modified">4125      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s</span>
<span class="line-modified">4126      * other members with the</span>
<span class="line-modified">4127      * {@code NestMembers} attribute (JVMS {@jvms 4.7.29}).</span>
<span class="line-modified">4128      * A {@code class} file of version 54.0 or lower does not use these</span>
<span class="line-modified">4129      * attributes.</span>
4130      *
4131      * @return the nest host of this class or interface
4132      *
4133      * @throws SecurityException
4134      *         If the returned class is not the current class, and
4135      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4136      *         class loader is not the same as or an ancestor of the class
4137      *         loader for the returned class and invocation of {@link
4138      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4139      *         denies access to the package of the returned class
4140      * @since 11
4141      * @jvms 4.7.28 The {@code NestHost} Attribute
4142      * @jvms 4.7.29 The {@code NestMembers} Attribute
4143      * @jvms 5.4.4 Access Control
4144      */
4145     @CallerSensitive
4146     public Class&lt;?&gt; getNestHost() {
4147         if (isPrimitive() || isArray()) {
4148             return this;
4149         }
<span class="line-modified">4150         Class&lt;?&gt; host;</span>
<span class="line-modified">4151         try {</span>
<span class="line-modified">4152             host = getNestHost0();</span>
<span class="line-removed">4153         } catch (LinkageError e) {</span>
<span class="line-removed">4154             // if we couldn&#39;t load our nest-host then we</span>
<span class="line-removed">4155             // act as-if we have no nest-host attribute</span>
<span class="line-removed">4156             return this;</span>
<span class="line-removed">4157         }</span>
<span class="line-removed">4158         // if null then nest membership validation failed, so we</span>
<span class="line-removed">4159         // act as-if we have no nest-host attribute</span>
<span class="line-removed">4160         if (host == null || host == this) {</span>
4161             return this;
4162         }
4163         // returning a different class requires a security check
4164         SecurityManager sm = System.getSecurityManager();
4165         if (sm != null) {
4166             checkPackageAccess(sm,
4167                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4168         }
4169         return host;
4170     }
4171 
4172     /**
4173      * Determines if the given {@code Class} is a nestmate of the
4174      * class or interface represented by this {@code Class} object.
4175      * Two classes or interfaces are nestmates
4176      * if they have the same {@linkplain #getNestHost() nest host}.
4177      *
4178      * @param c the class to check
4179      * @return {@code true} if this class and {@code c} are members of
4180      * the same nest; and {@code false} otherwise.
4181      *
4182      * @since 11
4183      */
4184     public boolean isNestmateOf(Class&lt;?&gt; c) {
4185         if (this == c) {
4186             return true;
4187         }
4188         if (isPrimitive() || isArray() ||
4189             c.isPrimitive() || c.isArray()) {
4190             return false;
4191         }
<span class="line-modified">4192         try {</span>
<span class="line-modified">4193             return getNestHost0() == c.getNestHost0();</span>
<span class="line-removed">4194         } catch (LinkageError e) {</span>
<span class="line-removed">4195             return false;</span>
<span class="line-removed">4196         }</span>
4197     }
4198 
4199     private native Class&lt;?&gt;[] getNestMembers0();
4200 
4201     /**
4202      * Returns an array containing {@code Class} objects representing all the
4203      * classes and interfaces that are members of the nest to which the class
4204      * or interface represented by this {@code Class} object belongs.
<span class="line-modified">4205      * The {@linkplain #getNestHost() nest host} of that nest is the zeroth</span>
<span class="line-modified">4206      * element of the array. Subsequent elements represent any classes or</span>
<span class="line-modified">4207      * interfaces that are recorded by the nest host as being members of</span>
<span class="line-modified">4208      * the nest; the order of such elements is unspecified. Duplicates are</span>
<span class="line-modified">4209      * permitted.</span>
<span class="line-modified">4210      * If the nest host of that nest does not enumerate any members, then the</span>
<span class="line-modified">4211      * array has a single element containing {@code this}.</span>
<span class="line-modified">4212      *</span>
<span class="line-modified">4213      * &lt;p&gt;Each of the {@code Class} objects representing array types,</span>
<span class="line-modified">4214      * primitive types, and {@code void} returns an array containing only</span>








4215      * {@code this}.
4216      *
<span class="line-modified">4217      * &lt;p&gt;This method validates that, for each class or interface which is</span>
<span class="line-modified">4218      * recorded as a member of the nest by the nest host, that class or</span>
<span class="line-modified">4219      * interface records itself as a member of that same nest. Any exceptions</span>
<span class="line-modified">4220      * that occur during this validation are rethrown by this method.</span>

4221      *
4222      * @return an array of all classes and interfaces in the same nest as
<span class="line-modified">4223      * this class</span>
4224      *
<span class="line-modified">4225      * @throws LinkageError</span>
<span class="line-modified">4226      *         If there is any problem loading or validating a nest member or</span>
<span class="line-modified">4227      *         its nest host</span>
<span class="line-modified">4228      * @throws SecurityException</span>
<span class="line-modified">4229      *         If any returned class is not the current class, and</span>
<span class="line-modified">4230      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s</span>
<span class="line-removed">4231      *         class loader is not the same as or an ancestor of the class</span>
<span class="line-removed">4232      *         loader for that returned class and invocation of {@link</span>
<span class="line-removed">4233      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}</span>
4234      *         denies access to the package of that returned class
4235      *
4236      * @since 11
4237      * @see #getNestHost()


4238      */
4239     @CallerSensitive
4240     public Class&lt;?&gt;[] getNestMembers() {
4241         if (isPrimitive() || isArray()) {
4242             return new Class&lt;?&gt;[] { this };
4243         }
4244         Class&lt;?&gt;[] members = getNestMembers0();
4245         // Can&#39;t actually enable this due to bootstrapping issues
4246         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4247 
4248         if (members.length &gt; 1) {
4249             // If we return anything other than the current class we need
4250             // a security check
4251             SecurityManager sm = System.getSecurityManager();
4252             if (sm != null) {
4253                 checkPackageAccess(sm,
4254                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4255             }
4256         }
4257         return members;
4258     }
4259 
4260     /**
<span class="line-modified">4261      * Returns the type descriptor string for this class.</span>
<span class="line-modified">4262      * &lt;p&gt;</span>
<span class="line-modified">4263      * Note that this is not a strict inverse of {@link #forName};</span>












































4264      * distinct classes which share a common name but have different class loaders
4265      * will have identical descriptor strings.
4266      *
<span class="line-modified">4267      * @return the type descriptor representation</span>
4268      * @jvms 4.3.2 Field Descriptors
4269      * @since 12
4270      */
4271     @Override
4272     public String descriptorString() {
4273         if (isPrimitive())
4274             return Wrapper.forPrimitiveType(this).basicTypeString();
<span class="line-modified">4275         else if (isArray()) {</span>

4276             return &quot;[&quot; + componentType.descriptorString();
4277         }
<span class="line-modified">4278         else {</span>
<span class="line-modified">4279             return (isInlineClass() ? &quot;Q&quot; : &quot;L&quot;)</span>
<span class="line-modified">4280                     + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>





4281         }
4282     }
4283 
4284     /**
4285      * Returns the component type of this {@code Class}, if it describes
4286      * an array type, or {@code null} otherwise.
4287      *
4288      * @implSpec
4289      * Equivalent to {@link Class#getComponentType()}.
4290      *
4291      * @return a {@code Class} describing the component type, or {@code null}
4292      * if this {@code Class} does not describe an array type
4293      * @since 12
4294      */
4295     @Override
4296     public Class&lt;?&gt; componentType() {
4297         return isArray() ? componentType : null;
4298     }
4299 
4300     /**
</pre>
<hr />
<pre>
4302      * is described by this {@linkplain Class}.
4303      *
4304      * @return a {@code Class} describing the array type
4305      * @since 12
4306      */
4307     @Override
4308     public Class&lt;?&gt; arrayType() {
4309         return Array.newInstance(this, 0).getClass();
4310     }
4311 
4312     /**
4313      * Returns a nominal descriptor for this instance, if one can be
4314      * constructed, or an empty {@link Optional} if one cannot be.
4315      *
4316      * @return An {@link Optional} containing the resulting nominal descriptor,
4317      * or an empty {@link Optional} if one cannot be constructed.
4318      * @since 12
4319      */
4320     @Override
4321     public Optional&lt;ClassDesc&gt; describeConstable() {
<span class="line-modified">4322         return Optional.of(ClassDesc.ofDescriptor(descriptorString()));</span>
<span class="line-modified">4323     }</span>














4324 }
</pre>
</td>
<td>
<hr />
<pre>
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.annotation.Annotation;
  29 import java.lang.constant.ClassDesc;
  30 import java.lang.invoke.TypeDescriptor;
<span class="line-added">  31 import java.lang.invoke.MethodHandles;</span>
  32 import java.lang.module.ModuleReader;
  33 import java.lang.ref.SoftReference;
  34 import java.io.IOException;
  35 import java.io.InputStream;
  36 import java.io.ObjectStreamField;
  37 import java.lang.reflect.AnnotatedElement;
  38 import java.lang.reflect.AnnotatedType;
  39 import java.lang.reflect.Array;
  40 import java.lang.reflect.Constructor;
  41 import java.lang.reflect.Executable;
  42 import java.lang.reflect.Field;
  43 import java.lang.reflect.GenericArrayType;
  44 import java.lang.reflect.GenericDeclaration;
  45 import java.lang.reflect.InvocationTargetException;
  46 import java.lang.reflect.Member;
  47 import java.lang.reflect.Method;
  48 import java.lang.reflect.Modifier;
  49 import java.lang.reflect.Proxy;
  50 import java.lang.reflect.RecordComponent;
  51 import java.lang.reflect.Type;
</pre>
<hr />
<pre>
  82 import sun.reflect.generics.repository.ClassRepository;
  83 import sun.reflect.generics.repository.MethodRepository;
  84 import sun.reflect.generics.repository.ConstructorRepository;
  85 import sun.reflect.generics.scope.ClassScope;
  86 import sun.security.util.SecurityConstants;
  87 import sun.reflect.annotation.*;
  88 import sun.reflect.misc.ReflectUtil;
  89 
  90 /**
  91  * Instances of the class {@code Class} represent classes and
  92  * interfaces in a running Java application. An enum type and a record
  93  * type are kinds of class; an annotation type is a kind of
  94  * interface. Every array also belongs to a class that is reflected as
  95  * a {@code Class} object that is shared by all arrays with the same
  96  * element type and number of dimensions.  The primitive Java types
  97  * ({@code boolean}, {@code byte}, {@code char}, {@code short}, {@code
  98  * int}, {@code long}, {@code float}, and {@code double}), and the
  99  * keyword {@code void} are also represented as {@code Class} objects.
 100  *
 101  * &lt;p&gt; {@code Class} has no public constructor. Instead a {@code Class}
<span class="line-modified"> 102  * object is constructed automatically by the Java Virtual Machine when</span>
<span class="line-modified"> 103  * a class is derived from the bytes of a {@code class} file through</span>
<span class="line-modified"> 104  * the invocation of one of the following methods:</span>
<span class="line-modified"> 105  * &lt;ul&gt;</span>
<span class="line-added"> 106  * &lt;li&gt; {@link ClassLoader#defineClass(String, byte[], int, int) ClassLoader::defineClass}</span>
<span class="line-added"> 107  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineClass(byte[])</span>
<span class="line-added"> 108  *      java.lang.invoke.MethodHandles.Lookup::defineClass}</span>
<span class="line-added"> 109  * &lt;li&gt; {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added"> 110  *      java.lang.invoke.MethodHandles.Lookup::defineHiddenClass}</span>
<span class="line-added"> 111  * &lt;/ul&gt;</span>
 112  *
 113  * &lt;p&gt; The methods of class {@code Class} expose many characteristics of a
 114  * class or interface. Most characteristics are derived from the {@code class}
<span class="line-modified"> 115  * file that the class loader passed to the Java Virtual Machine or</span>
<span class="line-modified"> 116  * from the {@code class} file passed to {@code Lookup::defineClass}</span>
<span class="line-modified"> 117  * or {@code Lookup::defineHiddenClass}.</span>
<span class="line-added"> 118  * A few characteristics are determined by the class loading environment</span>
<span class="line-added"> 119  * at run time, such as the module returned by {@link #getModule() getModule()}.</span>
<span class="line-added"> 120  *</span>
<span class="line-added"> 121  * &lt;p&gt; The following example uses a {@code Class} object to print the</span>
<span class="line-added"> 122  * class name of an object:</span>
<span class="line-added"> 123  *</span>
<span class="line-added"> 124  * &lt;blockquote&gt;&lt;pre&gt;</span>
<span class="line-added"> 125  *     void printClassName(Object obj) {</span>
<span class="line-added"> 126  *         System.out.println(&quot;The class of &quot; + obj +</span>
<span class="line-added"> 127  *                            &quot; is &quot; + obj.getClass().getName());</span>
<span class="line-added"> 128  *     }</span>
<span class="line-added"> 129  * &lt;/pre&gt;&lt;/blockquote&gt;</span>
<span class="line-added"> 130  *</span>
<span class="line-added"> 131  * It is also possible to get the {@code Class} object for a named</span>
<span class="line-added"> 132  * type (or for {@code void}) using a &lt;i&gt;class literal&lt;/i&gt;.</span>
<span class="line-added"> 133  * For example:</span>
<span class="line-added"> 134  *</span>
<span class="line-added"> 135  * &lt;blockquote&gt;</span>
<span class="line-added"> 136  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}</span>
<span class="line-added"> 137  * &lt;/blockquote&gt;</span>
 138  *
 139  * &lt;p&gt; Some methods of class {@code Class} expose whether the declaration of
 140  * a class or interface in Java source code was &lt;em&gt;enclosed&lt;/em&gt; within
 141  * another declaration. Other methods describe how a class or interface
 142  * is situated in a &lt;em&gt;nest&lt;/em&gt;. A &lt;a id=&quot;nest&quot;&gt;nest&lt;/a&gt; is a set of
 143  * classes and interfaces, in the same run-time package, that
 144  * allow mutual access to their {@code private} members.
 145  * The classes and interfaces are known as &lt;em&gt;nestmates&lt;/em&gt;.
 146  * One nestmate acts as the
 147  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 148  * belong to the nest; each of them in turn records it as the nest host.
 149  * The classes and interfaces which belong to a nest, including its host, are
 150  * determined when
 151  * {@code class} files are generated, for example, a Java compiler
 152  * will typically record a top-level class as the host of a nest where the
 153  * other members are the classes and interfaces whose declarations are
 154  * enclosed within the top-level class declaration.
 155  *
<span class="line-modified"> 156  * &lt;p&gt; A class or interface created by the invocation of</span>
<span class="line-modified"> 157  * {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-modified"> 158  * Lookup::defineHiddenClass} is a {@linkplain Class#isHidden() &lt;em&gt;hidden&lt;/em&gt;}</span>
<span class="line-modified"> 159  * class or interface.</span>
<span class="line-modified"> 160  * All kinds of class, including enum types and record types, may be</span>
<span class="line-modified"> 161  * hidden classes; all kinds of interface, including annotation types,</span>
<span class="line-modified"> 162  * may be hidden interfaces.</span>


 163  *
<span class="line-modified"> 164  * The {@linkplain #getName() name of a hidden class or interface} is</span>
<span class="line-modified"> 165  * not a &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;,</span>
<span class="line-modified"> 166  * which means the following:</span>
<span class="line-modified"> 167  * &lt;ul&gt;</span>
<span class="line-added"> 168  * &lt;li&gt;A hidden class or interface cannot be referenced by the constant pools</span>
<span class="line-added"> 169  *     of other classes and interfaces.</span>
<span class="line-added"> 170  * &lt;li&gt;A hidden class or interface cannot be described in</span>
<span class="line-added"> 171  *     {@linkplain java.lang.constant.ConstantDesc &lt;em&gt;nominal form&lt;/em&gt;} by</span>
<span class="line-added"> 172  *     {@link #describeConstable() Class::describeConstable},</span>
<span class="line-added"> 173  *     {@link ClassDesc#of(String) ClassDesc::of}, or</span>
<span class="line-added"> 174  *     {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}.</span>
<span class="line-added"> 175  * &lt;li&gt;A hidden class or interface cannot be discovered by {@link #forName Class::forName}</span>
<span class="line-added"> 176  *     or {@link ClassLoader#loadClass(String, boolean) ClassLoader::loadClass}.</span>
<span class="line-added"> 177  * &lt;/ul&gt;</span>
 178  *
<span class="line-modified"> 179  * A hidden class or interface is never an array class, but may be</span>
<span class="line-modified"> 180  * the element type of an array. In all other respects, the fact that</span>
<span class="line-modified"> 181  * a class or interface is hidden has no bearing on the characteristics</span>
<span class="line-added"> 182  * exposed by the methods of class {@code Class}.</span>
 183  *
 184  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 185  * object.  For example, the type of {@code String.class} is {@code
 186  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 187  * unknown.
 188  *
 189  * @author  unascribed
 190  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 191  * @since   1.0
<span class="line-added"> 192  * @jls 15.8.2 Class Literals</span>
 193  */
 194 public final class Class&lt;T&gt; implements java.io.Serializable,
 195                               GenericDeclaration,
 196                               Type,
 197                               AnnotatedElement,
 198                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 199                               Constable {
 200     private static final int ANNOTATION = 0x00002000;
 201     private static final int ENUM       = 0x00004000;
 202     private static final int SYNTHETIC  = 0x00001000;
 203     private static final int INLINE     = 0x00000100;
 204 
 205     private static native void registerNatives();
 206     static {
 207         registerNatives();
 208     }
 209 
 210     /*
 211      * Private constructor. Only the Java Virtual Machine creates Class objects.
 212      * This constructor is not used and prevents the default constructor being
 213      * generated.
 214      */
 215     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 216         // Initialize final field for classLoader.  The initialization value of non-null
 217         // prevents future JIT optimizations from assuming this final field is null.
 218         classLoader = loader;
 219         componentType = arrayComponentType;
 220     }
 221 
 222     /**
 223      * Converts the object to a string. The string representation is the
 224      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
<span class="line-modified"> 225      * name of the class in the format returned by {@code getName}.</span>
<span class="line-modified"> 226      * If this {@code Class} object represents a primitive type,</span>
<span class="line-modified"> 227      * this method returns the name of the primitive type.  If</span>
 228      * this {@code Class} object represents void this method returns
 229      * &quot;void&quot;. If this {@code Class} object represents an array type,
 230      * this method returns &quot;class &quot; followed by {@code getName}.
 231      *
 232      * @return a string representation of this {@code Class} object.
 233      */
 234     public String toString() {
 235         return (isInlineClass() ? &quot;inline &quot; : &quot;&quot;)
 236                + (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 237                + getName();
 238     }
 239 
 240     /**
 241      * Returns a string describing this {@code Class}, including
 242      * information about modifiers and type parameters.
 243      *
 244      * The string is formatted as a list of type modifiers, if any,
 245      * followed by the kind of type (empty string for primitive types
 246      * and {@code class}, {@code enum}, {@code interface},
 247      * {@code @interface}, or {@code record} as appropriate), followed
</pre>
<hr />
<pre>
 816      * @see     java.lang.Void#TYPE
 817      * @since 1.1
 818      */
 819     @HotSpotIntrinsicCandidate
 820     public native boolean isPrimitive();
 821 
 822     /**
 823      * Returns true if this {@code Class} object represents an annotation
 824      * type.  Note that if this method returns true, {@link #isInterface()}
 825      * would also return true, as all annotation types are also interfaces.
 826      *
 827      * @return {@code true} if this {@code Class} object represents an annotation
 828      *      type; {@code false} otherwise
 829      * @since 1.5
 830      */
 831     public boolean isAnnotation() {
 832         return (getModifiers() &amp; ANNOTATION) != 0;
 833     }
 834 
 835     /**
<span class="line-modified"> 836      * Returns {@code true} if and only if this class has the synthetic modifier</span>
<span class="line-modified"> 837      * bit set.</span>
<span class="line-modified"> 838      *</span>
<span class="line-modified"> 839      * @return {@code true} if and only if this class has the synthetic modifier bit set</span>
 840      * @jls 13.1 The Form of a Binary
<span class="line-added"> 841      * @jvms 4.1 The {@code ClassFile} Structure</span>
 842      * @since 1.5
 843      */
 844     public boolean isSynthetic() {
 845         return (getModifiers() &amp; SYNTHETIC) != 0;
 846     }
 847 
 848     /**
 849      * Returns the  name of the entity (class, interface, array class,
<span class="line-modified"> 850      * primitive type, or void) represented by this {@code Class} object.</span>






 851      *
<span class="line-modified"> 852      * &lt;p&gt; If this {@code Class} object represents a class or interface,</span>
<span class="line-modified"> 853      * not an array class, then:</span>
<span class="line-modified"> 854      * &lt;ul&gt;</span>
<span class="line-added"> 855      * &lt;li&gt; If the class or interface is not {@linkplain #isHidden() hidden},</span>
<span class="line-added"> 856      *      then the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;</span>
<span class="line-added"> 857      *      of the class or interface is returned.</span>
<span class="line-added"> 858      * &lt;li&gt; If the class or interface is hidden, then the result is a string</span>
<span class="line-added"> 859      *      of the form: {@code N + &#39;/&#39; + &lt;suffix&gt;}</span>
<span class="line-added"> 860      *      where {@code N} is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;</span>
<span class="line-added"> 861      *      indicated by the {@code class} file passed to</span>
<span class="line-added"> 862      *      {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added"> 863      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.</span>
<span class="line-added"> 864      * &lt;/ul&gt;</span>
 865      *
<span class="line-modified"> 866      * &lt;p&gt; If this {@code Class} object represents an array class, then</span>
<span class="line-modified"> 867      * the result is a string consisting of one or more &#39;{@code [}&#39; characters</span>
<span class="line-modified"> 868      * representing the depth of the array nesting, followed by the element</span>
<span class="line-modified"> 869      * type as encoded using the following table:</span>
 870      *
 871      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 872      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 873      * &lt;thead&gt;
 874      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 875      * &lt;/thead&gt;
 876      * &lt;tbody style=&quot;text-align:left&quot;&gt;
<span class="line-modified"> 877      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code boolean} &lt;td style=&quot;text-align:center&quot;&gt; {@code Z}</span>
<span class="line-modified"> 878      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code byte}    &lt;td style=&quot;text-align:center&quot;&gt; {@code B}</span>
<span class="line-modified"> 879      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code char}    &lt;td style=&quot;text-align:center&quot;&gt; {@code C}</span>
<span class="line-modified"> 880      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-modified"> 881      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code L}&lt;em&gt;N&lt;/em&gt;{@code ;}</span>
<span class="line-modified"> 882      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@linkplain #isInlineClass() inline class} with &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt; &lt;i&gt;N&lt;/i&gt;</span>
<span class="line-modified"> 883      *                                      &lt;td style=&quot;text-align:center&quot;&gt; {@code Q}&lt;em&gt;N&lt;/em&gt;{@code ;}</span>
<span class="line-modified"> 884      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code double}  &lt;td style=&quot;text-align:center&quot;&gt; {@code D}</span>
<span class="line-modified"> 885      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code float}   &lt;td style=&quot;text-align:center&quot;&gt; {@code F}</span>
<span class="line-modified"> 886      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code int}     &lt;td style=&quot;text-align:center&quot;&gt; {@code I}</span>
<span class="line-modified"> 887      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code long}    &lt;td style=&quot;text-align:center&quot;&gt; {@code J}</span>
<span class="line-modified"> 888      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; {@code short}   &lt;td style=&quot;text-align:center&quot;&gt; {@code S}</span>
 889      * &lt;/tbody&gt;
 890      * &lt;/table&gt;&lt;/blockquote&gt;
 891      *
<span class="line-modified"> 892      * &lt;p&gt; If this {@code Class} object represents a primitive type or {@code void},</span>
<span class="line-modified"> 893      * then the result is a string with the same spelling as the Java language</span>
<span class="line-added"> 894      * keyword which corresponds to the primitive type or {@code void}.</span>
 895      *
 896      * &lt;p&gt; Examples:
 897      * &lt;blockquote&gt;&lt;pre&gt;
 898      * String.class.getName()
 899      *     returns &quot;java.lang.String&quot;
 900      * byte.class.getName()
 901      *     returns &quot;byte&quot;
 902      * Point.class.getName()
 903      *     returns &quot;Point&quot;
 904      * (new Object[3]).getClass().getName()
 905      *     returns &quot;[Ljava.lang.Object;&quot;
 906      * (new Point[3]).getClass().getName()
 907      *     returns &quot;[QPoint;&quot;
 908      * (new Point.ref[3][4]).getClass().getName()
 909      *     returns &quot;[[LPoint$ref;&quot;
 910      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 911      *     returns &quot;[[[[[[[I&quot;
 912      * &lt;/pre&gt;&lt;/blockquote&gt;
 913      *
<span class="line-modified"> 914      * @return  the name of the class, interface, or other entity</span>
 915      *          represented by this {@code Class} object.
<span class="line-added"> 916      * @jls 13.1 The Form of a Binary</span>
 917      */
 918     public String getName() {
 919         String name = this.name;
 920         return name != null ? name : initClassName();
 921     }
 922 
 923     // Cache the name to reduce the number of calls into the VM.
 924     // This field would be set by VM itself during initClassName call.
 925     private transient String name;
 926     private native String initClassName();
 927 
 928     /**
 929      * Returns the class loader for the class.  Some implementations may use
 930      * null to represent the bootstrap class loader. This method will return
 931      * null in such implementations if this class was loaded by the bootstrap
 932      * class loader.
 933      *
 934      * &lt;p&gt;If this {@code Class} object
 935      * represents a primitive type or void, null is returned.
 936      *
</pre>
<hr />
<pre>
 974      * ClassLoader#getUnnamedModule() unnamed} {@code Module} of the class
 975      * loader for this class is returned.
 976      *
 977      * @return the module that this class or interface is a member of
 978      *
 979      * @since 9
 980      * @spec JPMS
 981      */
 982     public Module getModule() {
 983         return module;
 984     }
 985 
 986     // set by VM
 987     private transient Module module;
 988 
 989     // Initialized in JVM not by private constructor
 990     // This field is filtered from reflection access, i.e. getDeclaredField
 991     // will throw NoSuchFieldException
 992     private final ClassLoader classLoader;
 993 
<span class="line-added"> 994     // Set by VM</span>
<span class="line-added"> 995     private transient Object classData;</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997     // package-private</span>
<span class="line-added"> 998     Object getClassData() {</span>
<span class="line-added"> 999         return classData;</span>
<span class="line-added">1000     }</span>
<span class="line-added">1001 </span>
1002     /**
1003      * Returns an array of {@code TypeVariable} objects that represent the
1004      * type variables declared by the generic declaration represented by this
1005      * {@code GenericDeclaration} object, in declaration order.  Returns an
1006      * array of length 0 if the underlying generic declaration declares no type
1007      * variables.
1008      *
1009      * @return an array of {@code TypeVariable} objects that represent
1010      *     the type variables declared by this generic declaration
1011      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
1012      *     signature of this generic declaration does not conform to
1013      *     the format specified in section {@jvms 4.7.9} of
<span class="line-modified">1014      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
1015      * @since 1.5
1016      */
1017     @SuppressWarnings(&quot;unchecked&quot;)
1018     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
1019         ClassRepository info = getGenericInfo();
1020         if (info != null)
1021             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
1022         else
1023             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
1024     }
1025 
1026 
1027     /**
1028      * Returns the {@code Class} representing the direct superclass of the
1029      * entity (class, interface, primitive type or void) represented by
1030      * this {@code Class}.  If this {@code Class} represents either the
1031      * {@code Object} class, an interface, a primitive type, or void, then
1032      * null is returned.  If this {@code Class} object represents an array class
1033      * then the {@code Class} object representing the {@code Object} class is
1034      * returned.
</pre>
<hr />
<pre>
1117      *
1118      * &lt;p&gt; If this class is a {@linkplain #isLocalClass local class} or an {@linkplain
1119      * #isAnonymousClass() anonymous class}, then this method is equivalent to
1120      * invoking {@code getPackageName()} on the {@linkplain #getDeclaringClass
1121      * declaring class} of the {@linkplain #getEnclosingMethod enclosing method} or
1122      * {@linkplain #getEnclosingConstructor enclosing constructor}.
1123      *
1124      * &lt;p&gt; If this class represents an array type then this method returns the
1125      * package name of the element type. If this class represents a primitive
1126      * type or void then the package name &quot;{@code java.lang}&quot; is returned.
1127      *
1128      * @return the fully qualified package name
1129      *
1130      * @since 9
1131      * @spec JPMS
1132      * @jls 6.7 Fully Qualified Names
1133      */
1134     public String getPackageName() {
1135         String pn = this.packageName;
1136         if (pn == null) {
<span class="line-modified">1137             Class&lt;?&gt; c = isArray() ? elementType() : this;</span>



1138             if (c.isPrimitive()) {
1139                 pn = &quot;java.lang&quot;;
1140             } else {
1141                 String cn = c.getName();
1142                 int dot = cn.lastIndexOf(&#39;.&#39;);
1143                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1144             }
1145             this.packageName = pn;
1146         }
1147         return pn;
1148     }
1149 
1150     // cached package name
1151     private transient String packageName;
1152 
1153     /**
1154      * Returns the interfaces directly implemented by the class or interface
1155      * represented by this {@code Class} object.
1156      *
1157      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array
</pre>
<hr />
<pre>
1275      * Returns the {@code Class} representing the component type of an
1276      * array.  If this class does not represent an array class this method
1277      * returns null.
1278      *
1279      * @return the {@code Class} representing the component type of this
1280      * class if this class is an array
1281      * @see     java.lang.reflect.Array
1282      * @since 1.1
1283      */
1284     public Class&lt;?&gt; getComponentType() {
1285         // Only return for array types. Storage may be reused for Class for instance types.
1286         if (isArray()) {
1287             return componentType;
1288         } else {
1289             return null;
1290         }
1291     }
1292 
1293     private final Class&lt;?&gt; componentType;
1294 
<span class="line-added">1295     /*</span>
<span class="line-added">1296      * Returns the {@code Class} representing the element type of an array class.</span>
<span class="line-added">1297      * If this class does not represent an array class, then this method returns</span>
<span class="line-added">1298      * {@code null}.</span>
<span class="line-added">1299      */</span>
<span class="line-added">1300     private Class&lt;?&gt; elementType() {</span>
<span class="line-added">1301         if (!isArray()) return null;</span>
<span class="line-added">1302 </span>
<span class="line-added">1303         Class&lt;?&gt; c = this;</span>
<span class="line-added">1304         while (c.isArray()) {</span>
<span class="line-added">1305             c = c.getComponentType();</span>
<span class="line-added">1306         }</span>
<span class="line-added">1307         return c;</span>
<span class="line-added">1308     }</span>
1309 
1310     /**
1311      * Returns the Java language modifiers for this class or interface, encoded
1312      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1313      * constants for {@code public}, {@code protected},
1314      * {@code private}, {@code final}, {@code static},
1315      * {@code abstract} and {@code interface}; they should be decoded
1316      * using the methods of class {@code Modifier}.
1317      *
1318      * &lt;p&gt; If the underlying class is an array class, then its
1319      * {@code public}, {@code private} and {@code protected}
1320      * modifiers are the same as those of its component type.  If this
1321      * {@code Class} object represents a primitive type or void, its
1322      * {@code public} modifier is always {@code true}, and its
1323      * {@code protected} and {@code private} modifiers are always
1324      * {@code false}. If this {@code Class} object represents an array class, a
1325      * primitive type or void, then its {@code final} modifier is always
1326      * {@code true} and its interface modifier is always
1327      * {@code false}. The values of its other modifiers are not determined
1328      * by this specification.
</pre>
<hr />
<pre>
1717      *
1718      * @return an informative string for the name of this type
1719      * @since 1.8
1720      */
1721     public String getTypeName() {
1722         if (isArray()) {
1723             try {
1724                 Class&lt;?&gt; cl = this;
1725                 int dimensions = 0;
1726                 do {
1727                     dimensions++;
1728                     cl = cl.getComponentType();
1729                 } while (cl.isArray());
1730                 return cl.getTypeName() + &quot;[]&quot;.repeat(dimensions);
1731             } catch (Throwable e) { /*FALLTHRU*/ }
1732         }
1733         return getName();
1734     }
1735 
1736     /**
<span class="line-modified">1737      * Returns the canonical name of the underlying class as</span>
<span class="line-modified">1738      * defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
<span class="line-modified">1739      * Returns {@code null} if the underlying class does not have a canonical</span>
<span class="line-modified">1740      * name. Classes without canonical names include:</span>
<span class="line-modified">1741      * &lt;ul&gt;</span>
<span class="line-added">1742      * &lt;li&gt;a {@linkplain #isLocalClass() local class}</span>
<span class="line-added">1743      * &lt;li&gt;a {@linkplain #isAnonymousClass() anonymous class}</span>
<span class="line-added">1744      * &lt;li&gt;a {@linkplain #isHidden() hidden class}</span>
<span class="line-added">1745      * &lt;li&gt;an array whose component type does not have a canonical name&lt;/li&gt;</span>
<span class="line-added">1746      * &lt;/ul&gt;</span>
<span class="line-added">1747      *</span>
1748      * @return the canonical name of the underlying class if it exists, and
1749      * {@code null} otherwise.
1750      * @since 1.5
1751      */
1752     public String getCanonicalName() {
1753         ReflectionData&lt;T&gt; rd = reflectionData();
1754         String canonicalName = rd.canonicalName;
1755         if (canonicalName == null) {
1756             rd.canonicalName = canonicalName = getCanonicalName0();
1757         }
1758         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1759     }
1760 
1761     private String getCanonicalName0() {
1762         if (isArray()) {
1763             String canonicalName = getComponentType().getCanonicalName();
1764             if (canonicalName != null)
1765                 return canonicalName + &quot;[]&quot;;
1766             else
1767                 return ReflectionData.NULL_SENTINEL;
1768         }
<span class="line-modified">1769         if (isHidden() || isLocalOrAnonymousClass())</span>
1770             return ReflectionData.NULL_SENTINEL;
1771         Class&lt;?&gt; enclosingClass = getEnclosingClass();
1772         if (enclosingClass == null) { // top level class
1773             return getName();
1774         } else {
1775             String enclosingName = enclosingClass.getCanonicalName();
1776             if (enclosingName == null)
1777                 return ReflectionData.NULL_SENTINEL;
1778             return enclosingName + &quot;.&quot; + getSimpleName();
1779         }
1780     }
1781 
1782     /**
1783      * Returns {@code true} if and only if the underlying class
1784      * is an anonymous class.
1785      *
<span class="line-added">1786      * @apiNote</span>
<span class="line-added">1787      * An anonymous class is not a {@linkplain #isHidden() hidden class}.</span>
<span class="line-added">1788      *</span>
1789      * @return {@code true} if and only if this class is an anonymous class.
1790      * @since 1.5
1791      */
1792     public boolean isAnonymousClass() {
1793         return !isArray() &amp;&amp; isLocalOrAnonymousClass() &amp;&amp;
1794                 getSimpleBinaryName0() == null;
1795     }
1796 
1797     /**
1798      * Returns {@code true} if and only if the underlying class
1799      * is a local class.
1800      *
1801      * @return {@code true} if and only if this class is a local class.
1802      * @since 1.5
1803      */
1804     public boolean isLocalClass() {
1805         return isLocalOrAnonymousClass() &amp;&amp;
1806                 (isArray() || getSimpleBinaryName0() != null);
1807     }
1808 
</pre>
<hr />
<pre>
2994      * ensure it&#39;s ok to get the
2995      * {@code ProtectionDomain}.
2996      *
2997      * @return the ProtectionDomain of this class
2998      *
2999      * @throws SecurityException
3000      *        if a security manager exists and its
3001      *        {@code checkPermission} method doesn&#39;t allow
3002      *        getting the ProtectionDomain.
3003      *
3004      * @see java.security.ProtectionDomain
3005      * @see SecurityManager#checkPermission
3006      * @see java.lang.RuntimePermission
3007      * @since 1.2
3008      */
3009     public java.security.ProtectionDomain getProtectionDomain() {
3010         SecurityManager sm = System.getSecurityManager();
3011         if (sm != null) {
3012             sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);
3013         }
<span class="line-added">3014         return protectionDomain();</span>
<span class="line-added">3015     }</span>
<span class="line-added">3016 </span>
<span class="line-added">3017     // package-private</span>
<span class="line-added">3018     java.security.ProtectionDomain protectionDomain() {</span>
3019         java.security.ProtectionDomain pd = getProtectionDomain0();
3020         if (pd == null) {
3021             if (allPermDomain == null) {
3022                 java.security.Permissions perms =
3023                     new java.security.Permissions();
3024                 perms.add(SecurityConstants.ALL_PERMISSION);
3025                 allPermDomain =
3026                     new java.security.ProtectionDomain(null, perms);
3027             }
3028             pd = allPermDomain;
3029         }
3030         return pd;
3031     }
3032 

3033     /**
3034      * Returns the ProtectionDomain of this class.
3035      */
3036     private native java.security.ProtectionDomain getProtectionDomain0();
3037 
3038     /*
3039      * Return the Virtual Machine&#39;s Class object for the named
3040      * primitive type.
3041      */
3042     static native Class&lt;?&gt; getPrimitiveClass(String name);
3043 
3044     /*
3045      * Check if client is allowed to access members.  If access is denied,
3046      * throw a SecurityException.
3047      *
3048      * This method also enforces package access.
3049      *
3050      * &lt;p&gt; Default policy: allow all clients access with normal Java access
3051      * control.
3052      *
</pre>
<hr />
<pre>
3084             String pkg = this.getPackageName();
3085             if (pkg != null &amp;&amp; !pkg.isEmpty()) {
3086                 // skip the package access check on a proxy class in default proxy package
3087                 if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {
3088                     sm.checkPackageAccess(pkg);
3089                 }
3090             }
3091         }
3092         // check package access on the proxy interfaces
3093         if (checkProxyInterfaces &amp;&amp; Proxy.isProxyClass(this)) {
3094             ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces());
3095         }
3096     }
3097 
3098     /**
3099      * Add a package name prefix if the name is not absolute Remove leading &quot;/&quot;
3100      * if name is absolute
3101      */
3102     private String resolveName(String name) {
3103         if (!name.startsWith(&quot;/&quot;)) {
<span class="line-modified">3104             Class&lt;?&gt; c = isArray() ? elementType() : this;</span>



3105             String baseName = c.getPackageName();
3106             if (baseName != null &amp;&amp; !baseName.isEmpty()) {
3107                 name = baseName.replace(&#39;.&#39;, &#39;/&#39;) + &quot;/&quot; + name;
3108             }
3109         } else {
3110             name = name.substring(1);
3111         }
3112         return name;
3113     }
3114 
3115     /**
3116      * Atomic operations support.
3117      */
3118     private static class Atomic {
3119         // initialize Unsafe machinery here, since we need to call Class.class instance method
3120         // and have to avoid calling it in the static initializer of the Class class...
3121         private static final Unsafe unsafe = Unsafe.getUnsafe();
3122         // offset of Class.reflectionData instance field
3123         private static final long reflectionDataOffset
3124                 = unsafe.objectFieldOffset(Class.class, &quot;reflectionData&quot;);
</pre>
<hr />
<pre>
4160      * &lt;p&gt; If this {@code Class} object represents a class or interface whose
4161      * declaration does not explicitly indicate any annotated superinterfaces,
4162      * the return value is an array of length 0.
4163      *
4164      * &lt;p&gt; If this {@code Class} object represents either the {@code Object}
4165      * class, an array type, a primitive type, or void, the return value is an
4166      * array of length 0.
4167      *
4168      * @return an array representing the superinterfaces
4169      * @since 1.8
4170      */
4171     public AnnotatedType[] getAnnotatedInterfaces() {
4172         return TypeAnnotationParser.buildAnnotatedInterfaces(getRawTypeAnnotations(), getConstantPool(), this);
4173     }
4174 
4175     private native Class&lt;?&gt; getNestHost0();
4176 
4177     /**
4178      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4179      * or interface represented by this {@code Class} object belongs.
<span class="line-modified">4180      * Every class and interface belongs to exactly one nest.</span>








4181      *
<span class="line-modified">4182      * If the nest host of this class or interface has previously</span>
<span class="line-modified">4183      * been determined, then this method returns the nest host.</span>
<span class="line-modified">4184      * If the nest host of this class or interface has</span>
<span class="line-modified">4185      * not previously been determined, then this method determines the nest</span>
<span class="line-added">4186      * host using the algorithm of JVMS 5.4.4, and returns it.</span>
4187      *
<span class="line-modified">4188      * Often, a class or interface belongs to a nest consisting only of itself,</span>
<span class="line-modified">4189      * in which case this method returns {@code this} to indicate that the class</span>
<span class="line-modified">4190      * or interface is the nest host.</span>
<span class="line-modified">4191      *</span>
<span class="line-modified">4192      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,</span>
<span class="line-modified">4193      * or {@code void}, then this method returns {@code this},</span>
<span class="line-modified">4194      * indicating that the represented entity belongs to the nest consisting only of</span>
<span class="line-modified">4195      * itself, and is the nest host.</span>
4196      *
4197      * @return the nest host of this class or interface
4198      *
4199      * @throws SecurityException
4200      *         If the returned class is not the current class, and
4201      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4202      *         class loader is not the same as or an ancestor of the class
4203      *         loader for the returned class and invocation of {@link
4204      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4205      *         denies access to the package of the returned class
4206      * @since 11
4207      * @jvms 4.7.28 The {@code NestHost} Attribute
4208      * @jvms 4.7.29 The {@code NestMembers} Attribute
4209      * @jvms 5.4.4 Access Control
4210      */
4211     @CallerSensitive
4212     public Class&lt;?&gt; getNestHost() {
4213         if (isPrimitive() || isArray()) {
4214             return this;
4215         }
<span class="line-modified">4216 </span>
<span class="line-modified">4217         Class&lt;?&gt; host = getNestHost0();</span>
<span class="line-modified">4218         if (host == this) {</span>








4219             return this;
4220         }
4221         // returning a different class requires a security check
4222         SecurityManager sm = System.getSecurityManager();
4223         if (sm != null) {
4224             checkPackageAccess(sm,
4225                                ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4226         }
4227         return host;
4228     }
4229 
4230     /**
4231      * Determines if the given {@code Class} is a nestmate of the
4232      * class or interface represented by this {@code Class} object.
4233      * Two classes or interfaces are nestmates
4234      * if they have the same {@linkplain #getNestHost() nest host}.
4235      *
4236      * @param c the class to check
4237      * @return {@code true} if this class and {@code c} are members of
4238      * the same nest; and {@code false} otherwise.
4239      *
4240      * @since 11
4241      */
4242     public boolean isNestmateOf(Class&lt;?&gt; c) {
4243         if (this == c) {
4244             return true;
4245         }
4246         if (isPrimitive() || isArray() ||
4247             c.isPrimitive() || c.isArray()) {
4248             return false;
4249         }
<span class="line-modified">4250 </span>
<span class="line-modified">4251         return getNestHost() == c.getNestHost();</span>



4252     }
4253 
4254     private native Class&lt;?&gt;[] getNestMembers0();
4255 
4256     /**
4257      * Returns an array containing {@code Class} objects representing all the
4258      * classes and interfaces that are members of the nest to which the class
4259      * or interface represented by this {@code Class} object belongs.
<span class="line-modified">4260      *</span>
<span class="line-modified">4261      * First, this method obtains the {@linkplain #getNestHost() nest host},</span>
<span class="line-modified">4262      * {@code H}, of the nest to which the class or interface represented by</span>
<span class="line-modified">4263      * this {@code Class} object belongs. The zeroth element of the returned</span>
<span class="line-modified">4264      * array is {@code H}.</span>
<span class="line-modified">4265      *</span>
<span class="line-modified">4266      * Then, for each class or interface {@code C} which is recorded by {@code H}</span>
<span class="line-modified">4267      * as being a member of its nest, this method attempts to obtain the {@code Class}</span>
<span class="line-modified">4268      * object for {@code C} (using {@linkplain #getClassLoader() the defining class</span>
<span class="line-modified">4269      * loader} of the current {@code Class} object), and then obtains the</span>
<span class="line-added">4270      * {@linkplain #getNestHost() nest host} of the nest to which {@code C} belongs.</span>
<span class="line-added">4271      * The classes and interfaces which are recorded by {@code H} as being members</span>
<span class="line-added">4272      * of its nest, and for which {@code H} can be determined as their nest host,</span>
<span class="line-added">4273      * are indicated by subsequent elements of the returned array. The order of</span>
<span class="line-added">4274      * such elements is unspecified. Duplicates are permitted.</span>
<span class="line-added">4275      *</span>
<span class="line-added">4276      * &lt;p&gt;If this {@code Class} object represents a primitive type, an array type,</span>
<span class="line-added">4277      * or {@code void}, then this method returns a single-element array containing</span>
4278      * {@code this}.
4279      *
<span class="line-modified">4280      * @apiNote</span>
<span class="line-modified">4281      * The returned array includes only the nest members recorded in the {@code NestMembers}</span>
<span class="line-modified">4282      * attribute, and not any hidden classes that were added to the nest via</span>
<span class="line-modified">4283      * {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added">4284      * Lookup::defineHiddenClass}.</span>
4285      *
4286      * @return an array of all classes and interfaces in the same nest as
<span class="line-modified">4287      * this class or interface</span>
4288      *
<span class="line-modified">4289      * @throws SecurityException</span>
<span class="line-modified">4290      * If any returned class is not the current class, and</span>
<span class="line-modified">4291      * if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s</span>
<span class="line-modified">4292      * class loader is not the same as or an ancestor of the class</span>
<span class="line-modified">4293      * loader for that returned class and invocation of {@link</span>
<span class="line-modified">4294      * SecurityManager#checkPackageAccess s.checkPackageAccess()}</span>



4295      * denies access to the package of that returned class
4296      *
4297      * @since 11
4298      * @see #getNestHost()
<span class="line-added">4299      * @jvms 4.7.28 The {@code NestHost} Attribute</span>
<span class="line-added">4300      * @jvms 4.7.29 The {@code NestMembers} Attribute</span>
4301      */
4302     @CallerSensitive
4303     public Class&lt;?&gt;[] getNestMembers() {
4304         if (isPrimitive() || isArray()) {
4305             return new Class&lt;?&gt;[] { this };
4306         }
4307         Class&lt;?&gt;[] members = getNestMembers0();
4308         // Can&#39;t actually enable this due to bootstrapping issues
4309         // assert(members.length != 1 || members[0] == this); // expected invariant from VM
4310 
4311         if (members.length &gt; 1) {
4312             // If we return anything other than the current class we need
4313             // a security check
4314             SecurityManager sm = System.getSecurityManager();
4315             if (sm != null) {
4316                 checkPackageAccess(sm,
4317                                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);
4318             }
4319         }
4320         return members;
4321     }
4322 
4323     /**
<span class="line-modified">4324      * Returns the descriptor string of the entity (class, interface, array class,</span>
<span class="line-modified">4325      * primitive type, or {@code void}) represented by this {@code Class} object.</span>
<span class="line-modified">4326      *</span>
<span class="line-added">4327      * &lt;p&gt; If this {@code Class} object represents a class or interface,</span>
<span class="line-added">4328      * not an array class, then:</span>
<span class="line-added">4329      * &lt;ul&gt;</span>
<span class="line-added">4330      * &lt;li&gt; If the class or interface is not {@linkplain Class#isHidden() hidden},</span>
<span class="line-added">4331      *      then the result is a field descriptor (JVMS {@jvms 4.3.2})</span>
<span class="line-added">4332      *      for the class or interface. Calling</span>
<span class="line-added">4333      *      {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}</span>
<span class="line-added">4334      *      with the result descriptor string produces a {@link ClassDesc ClassDesc}</span>
<span class="line-added">4335      *      describing this class or interface.</span>
<span class="line-added">4336      * &lt;li&gt; If the class or interface is {@linkplain Class#isHidden() hidden},</span>
<span class="line-added">4337      *      then the result is a string of the form:</span>
<span class="line-added">4338      *      &lt;blockquote&gt;</span>
<span class="line-added">4339      *      {@code &quot;L&quot; +} &lt;em&gt;N&lt;/em&gt; {@code + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;}</span>
<span class="line-added">4340      *      &lt;/blockquote&gt;</span>
<span class="line-added">4341      *      where &lt;em&gt;N&lt;/em&gt; is the &lt;a href=&quot;ClassLoader.html#binary-name&quot;&gt;binary name&lt;/a&gt;</span>
<span class="line-added">4342      *      encoded in internal form indicated by the {@code class} file passed to</span>
<span class="line-added">4343      *      {@link MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)</span>
<span class="line-added">4344      *      Lookup::defineHiddenClass}, and {@code &lt;suffix&gt;} is an unqualified name.</span>
<span class="line-added">4345      *      A hidden class or interface has no {@linkplain ClassDesc nominal descriptor}.</span>
<span class="line-added">4346      *      The result string is not a type descriptor.</span>
<span class="line-added">4347      * &lt;/ul&gt;</span>
<span class="line-added">4348      *</span>
<span class="line-added">4349      * &lt;p&gt; If this {@code Class} object represents an array class, then</span>
<span class="line-added">4350      * the result is a string consisting of one or more &#39;{@code [}&#39; characters</span>
<span class="line-added">4351      * representing the depth of the array nesting, followed by the</span>
<span class="line-added">4352      * descriptor string of the element type.</span>
<span class="line-added">4353      * &lt;ul&gt;</span>
<span class="line-added">4354      * &lt;li&gt; If the element type is not a {@linkplain Class#isHidden() hidden} class</span>
<span class="line-added">4355      * or interface, then this array class can be described nominally.</span>
<span class="line-added">4356      * Calling {@link ClassDesc#ofDescriptor(String) ClassDesc::ofDescriptor}</span>
<span class="line-added">4357      * with the result descriptor string produces a {@link ClassDesc ClassDesc}</span>
<span class="line-added">4358      * describing this array class.</span>
<span class="line-added">4359      * &lt;li&gt; If the element type is a {@linkplain Class#isHidden() hidden} class or</span>
<span class="line-added">4360      * interface, then this array class cannot be described nominally.</span>
<span class="line-added">4361      * The result string is not a type descriptor.</span>
<span class="line-added">4362      * &lt;/ul&gt;</span>
<span class="line-added">4363      *</span>
<span class="line-added">4364      * &lt;p&gt; If this {@code Class} object represents a primitive type or</span>
<span class="line-added">4365      * {@code void}, then the result is a field descriptor string which</span>
<span class="line-added">4366      * is a one-letter code corresponding to a primitive type or {@code void}</span>
<span class="line-added">4367      * ({@code &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;F&quot;, &quot;I&quot;, &quot;J&quot;, &quot;S&quot;, &quot;Z&quot;, &quot;V&quot;}) (JVMS {@jvms 4.3.2}).</span>
<span class="line-added">4368      *</span>
<span class="line-added">4369      * @apiNote</span>
<span class="line-added">4370      * This is not a strict inverse of {@link #forName};</span>
4371      * distinct classes which share a common name but have different class loaders
4372      * will have identical descriptor strings.
4373      *
<span class="line-modified">4374      * @return the descriptor string for this {@code Class} object</span>
4375      * @jvms 4.3.2 Field Descriptors
4376      * @since 12
4377      */
4378     @Override
4379     public String descriptorString() {
4380         if (isPrimitive())
4381             return Wrapper.forPrimitiveType(this).basicTypeString();
<span class="line-modified">4382 </span>
<span class="line-added">4383         if (isArray()) {</span>
4384             return &quot;[&quot; + componentType.descriptorString();
4385         }
<span class="line-modified">4386         String typeDesc = isInlineClass() ? &quot;Q&quot; : &quot;L&quot;;</span>
<span class="line-modified">4387         if (isHidden()) {</span>
<span class="line-modified">4388             String name = getName();</span>
<span class="line-added">4389             int index = name.indexOf(&#39;/&#39;);</span>
<span class="line-added">4390             return typeDesc + name.substring(0, index).replace(&#39;.&#39;, &#39;/&#39;)</span>
<span class="line-added">4391                        + &quot;.&quot; + name.substring(index+1) + &quot;;&quot;;</span>
<span class="line-added">4392         } else {</span>
<span class="line-added">4393             return typeDesc + getName().replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</span>
4394         }
4395     }
4396 
4397     /**
4398      * Returns the component type of this {@code Class}, if it describes
4399      * an array type, or {@code null} otherwise.
4400      *
4401      * @implSpec
4402      * Equivalent to {@link Class#getComponentType()}.
4403      *
4404      * @return a {@code Class} describing the component type, or {@code null}
4405      * if this {@code Class} does not describe an array type
4406      * @since 12
4407      */
4408     @Override
4409     public Class&lt;?&gt; componentType() {
4410         return isArray() ? componentType : null;
4411     }
4412 
4413     /**
</pre>
<hr />
<pre>
4415      * is described by this {@linkplain Class}.
4416      *
4417      * @return a {@code Class} describing the array type
4418      * @since 12
4419      */
4420     @Override
4421     public Class&lt;?&gt; arrayType() {
4422         return Array.newInstance(this, 0).getClass();
4423     }
4424 
4425     /**
4426      * Returns a nominal descriptor for this instance, if one can be
4427      * constructed, or an empty {@link Optional} if one cannot be.
4428      *
4429      * @return An {@link Optional} containing the resulting nominal descriptor,
4430      * or an empty {@link Optional} if one cannot be constructed.
4431      * @since 12
4432      */
4433     @Override
4434     public Optional&lt;ClassDesc&gt; describeConstable() {
<span class="line-modified">4435         Class&lt;?&gt; c = isArray() ? elementType() : this;</span>
<span class="line-modified">4436         return c.isHidden() ? Optional.empty()</span>
<span class="line-added">4437                             : Optional.of(ClassDesc.ofDescriptor(descriptorString()));</span>
<span class="line-added">4438    }</span>
<span class="line-added">4439 </span>
<span class="line-added">4440     /**</span>
<span class="line-added">4441      * Returns {@code true} if and only if the underlying class is a hidden class.</span>
<span class="line-added">4442      *</span>
<span class="line-added">4443      * @return {@code true} if and only if this class is a hidden class.</span>
<span class="line-added">4444      *</span>
<span class="line-added">4445      * @since 15</span>
<span class="line-added">4446      * @see MethodHandles.Lookup#defineHiddenClass</span>
<span class="line-added">4447      */</span>
<span class="line-added">4448     @HotSpotIntrinsicCandidate</span>
<span class="line-added">4449     public native boolean isHidden();</span>
<span class="line-added">4450 </span>
4451 }
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../hotspot/share/utilities/exceptions.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
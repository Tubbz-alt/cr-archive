<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="InnerClassLambdaMetafactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleNatives.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.org.objectweb.asm.ClassWriter;

  29 import jdk.internal.org.objectweb.asm.Label;
  30 import jdk.internal.org.objectweb.asm.MethodVisitor;
  31 import jdk.internal.org.objectweb.asm.Opcodes;
  32 import jdk.internal.org.objectweb.asm.Type;
  33 import sun.invoke.util.VerifyAccess;
  34 import sun.invoke.util.VerifyType;
  35 import sun.invoke.util.Wrapper;
  36 import sun.reflect.misc.ReflectUtil;
  37 
  38 import java.io.File;
  39 import java.io.FileOutputStream;
  40 import java.io.IOException;
  41 import java.lang.reflect.Modifier;
  42 import java.util.ArrayList;
  43 import java.util.Arrays;
  44 import java.util.HashMap;

  45 import java.util.stream.Stream;
  46 
  47 import static java.lang.invoke.LambdaForm.BasicType;
  48 import static java.lang.invoke.LambdaForm.BasicType.*;
  49 import static java.lang.invoke.LambdaForm.*;
  50 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  51 import static java.lang.invoke.MethodHandleStatics.*;

  52 
  53 /**
  54  * Code generation backend for LambdaForm.
  55  * &lt;p&gt;
  56  * @author John Rose, JSR 292 EG
  57  */
  58 class InvokerBytecodeGenerator {
  59     /** Define class names for convenience. */
  60     private static final String MH      = &quot;java/lang/invoke/MethodHandle&quot;;
  61     private static final String MHI     = &quot;java/lang/invoke/MethodHandleImpl&quot;;
  62     private static final String LF      = &quot;java/lang/invoke/LambdaForm&quot;;
  63     private static final String LFN     = &quot;java/lang/invoke/LambdaForm$Name&quot;;
  64     private static final String CLS     = &quot;java/lang/Class&quot;;
  65     private static final String OBJ     = &quot;java/lang/Object&quot;;
  66     private static final String OBJARY  = &quot;[Ljava/lang/Object;&quot;;
  67 
  68     private static final String LOOP_CLAUSES = MHI + &quot;$LoopClauses&quot;;
  69     private static final String MHARY2       = &quot;[[L&quot; + MH + &quot;;&quot;;


  70 
  71     private static final String LF_SIG  = &quot;L&quot; + LF + &quot;;&quot;;
  72     private static final String LFN_SIG = &quot;L&quot; + LFN + &quot;;&quot;;
  73     private static final String LL_SIG  = &quot;(L&quot; + OBJ + &quot;;)L&quot; + OBJ + &quot;;&quot;;
  74     private static final String LLV_SIG = &quot;(L&quot; + OBJ + &quot;;L&quot; + OBJ + &quot;;)V&quot;;
  75     private static final String CLASS_PREFIX = LF + &quot;$&quot;;
  76     private static final String SOURCE_PREFIX = &quot;LambdaForm$&quot;;
  77 
  78     /** Name of its super class*/
  79     static final String INVOKER_SUPER_NAME = OBJ;
  80 
  81     /** Name of new class */
  82     private final String className;
  83 
  84     private final LambdaForm lambdaForm;
  85     private final String     invokerName;
  86     private final MethodType invokerType;
  87 
  88     /** Info about local variables in compiled lambda form */
  89     private int[]       localsMap;    // index
  90     private Class&lt;?&gt;[]  localClasses; // type
  91 
  92     /** ASM bytecode generation. */
  93     private ClassWriter cw;
  94     private MethodVisitor mv;

  95 
  96     /** Single element internal class name lookup cache. */
  97     private Class&lt;?&gt; lastClass;
  98     private String lastInternalName;
  99 
 100     private static final MemberName.Factory MEMBERNAME_FACTORY = MemberName.getFactory();
 101     private static final Class&lt;?&gt; HOST_CLASS = LambdaForm.class;









 102 
 103     /** Main constructor; other constructors delegate to this one. */
 104     private InvokerBytecodeGenerator(LambdaForm lambdaForm, int localsMapSize,
 105                                      String className, String invokerName, MethodType invokerType) {
 106         int p = invokerName.indexOf(&#39;.&#39;);
 107         if (p &gt; -1) {
 108             className = invokerName.substring(0, p);
 109             invokerName = invokerName.substring(p + 1);
 110         }
 111         if (DUMP_CLASS_FILES) {
 112             className = makeDumpableClassName(className);
 113         }
 114         this.className  = className;
 115         this.lambdaForm = lambdaForm;
 116         this.invokerName = invokerName;
 117         this.invokerType = invokerType;
 118         this.localsMap = new int[localsMapSize+1]; // last entry of localsMap is count of allocated local slots
 119         this.localClasses = new Class&lt;?&gt;[localsMapSize+1];
 120     }
 121 
</pre>
<hr />
<pre>
 204                     }
 205                 }
 206             });
 207         }
 208     }
 209 
 210     private static String makeDumpableClassName(String className) {
 211         Integer ctr;
 212         synchronized (DUMP_CLASS_FILES_COUNTERS) {
 213             ctr = DUMP_CLASS_FILES_COUNTERS.get(className);
 214             if (ctr == null)  ctr = 0;
 215             DUMP_CLASS_FILES_COUNTERS.put(className, ctr+1);
 216         }
 217         String sfx = ctr.toString();
 218         while (sfx.length() &lt; 3)
 219             sfx = &quot;0&quot;+sfx;
 220         className += sfx;
 221         return className;
 222     }
 223 
<span class="line-modified"> 224     class CpPatch {</span>
<span class="line-modified"> 225         final int index;</span>

 226         final Object value;
<span class="line-modified"> 227         CpPatch(int index, Object value) {</span>
<span class="line-modified"> 228             this.index = index;</span>


 229             this.value = value;
 230         }


 231         public String toString() {
<span class="line-modified"> 232             return &quot;CpPatch/index=&quot;+index+&quot;,value=&quot;+value;</span>
 233         }
 234     }
 235 
<span class="line-modified"> 236     private final ArrayList&lt;CpPatch&gt; cpPatches = new ArrayList&lt;&gt;();</span>
<span class="line-modified"> 237 </span>
<span class="line-modified"> 238     private int cph = 0;  // for counting constant placeholders</span>








 239 
<span class="line-modified"> 240     String constantPlaceholder(Object arg) {</span>
<span class="line-modified"> 241         String cpPlaceholder = &quot;CONSTANT_PLACEHOLDER_&quot; + cph++;</span>
<span class="line-modified"> 242         if (DUMP_CLASS_FILES) cpPlaceholder += &quot; &lt;&lt;&quot; + debugString(arg) + &quot;&gt;&gt;&quot;;</span>
<span class="line-modified"> 243         // TODO check if arg is already in the constant pool</span>
<span class="line-modified"> 244         // insert placeholder in CP and remember the patch</span>
<span class="line-modified"> 245         int index = cw.newConst((Object) cpPlaceholder);</span>
<span class="line-modified"> 246         cpPatches.add(new CpPatch(index, arg));</span>
<span class="line-modified"> 247         return cpPlaceholder;</span>

 248     }
 249 
<span class="line-modified"> 250     Object[] cpPatches(byte[] classFile) {</span>
<span class="line-modified"> 251         int size = getConstantPoolSize(classFile);</span>
<span class="line-modified"> 252         Object[] res = new Object[size];</span>
<span class="line-modified"> 253         for (CpPatch p : cpPatches) {</span>
<span class="line-removed"> 254             if (p.index &gt;= size)</span>
<span class="line-removed"> 255                 throw new InternalError(&quot;in cpool[&quot;+size+&quot;]: &quot;+p+&quot;\n&quot;+Arrays.toString(Arrays.copyOf(classFile, 20)));</span>
<span class="line-removed"> 256             res[p.index] = p.value;</span>
 257         }
<span class="line-modified"> 258         return res;</span>
 259     }
 260 
 261     private static String debugString(Object arg) {
 262         if (arg instanceof MethodHandle) {
 263             MethodHandle mh = (MethodHandle) arg;
 264             MemberName member = mh.internalMemberName();
 265             if (member != null)
 266                 return member.toString();
 267             return mh.debugString();
 268         }
 269         return arg.toString();
 270     }
 271 
 272     /**
 273      * Extract the number of constant pool entries from a given class file.
 274      *
 275      * @param classFile the bytes of the class file in question.
 276      * @return the number of entries in the constant pool.
 277      */
 278     private static int getConstantPoolSize(byte[] classFile) {
 279         // The first few bytes:
 280         // u4 magic;
 281         // u2 minor_version;
 282         // u2 major_version;
 283         // u2 constant_pool_count;
 284         return ((classFile[8] &amp; 0xFF) &lt;&lt; 8) | (classFile[9] &amp; 0xFF);
 285     }
 286 
 287     /**
 288      * Extract the MemberName of a newly-defined method.
 289      */
 290     private MemberName loadMethod(byte[] classFile) {
<span class="line-modified"> 291         Class&lt;?&gt; invokerClass = loadAndInitializeInvokerClass(classFile, cpPatches(classFile));</span>

 292         return resolveInvokerMember(invokerClass, invokerName, invokerType);
 293     }
 294 
<span class="line-modified"> 295     /**</span>
<span class="line-removed"> 296      * Define a given class as anonymous class in the runtime system.</span>
<span class="line-removed"> 297      */</span>
<span class="line-removed"> 298     private static Class&lt;?&gt; loadAndInitializeInvokerClass(byte[] classBytes, Object[] patches) {</span>
<span class="line-removed"> 299         Class&lt;?&gt; invokerClass = UNSAFE.defineAnonymousClass(HOST_CLASS, classBytes, patches);</span>
<span class="line-removed"> 300         UNSAFE.ensureClassInitialized(invokerClass);  // Make sure the class is initialized; VM might complain.</span>
<span class="line-removed"> 301         return invokerClass;</span>
<span class="line-removed"> 302     }</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304     static MemberName resolveInvokerMember(Class&lt;?&gt; invokerClass, String name, MethodType type) {</span>
 305         MemberName member = new MemberName(invokerClass, name, type, REF_invokeStatic);
 306         try {
 307             member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);
 308         } catch (ReflectiveOperationException e) {
 309             throw newInternalError(e);
 310         }
 311         return member;
 312     }
 313 
 314     /**
 315      * Set up class file generation.
 316      */
 317     private ClassWriter classFilePrologue() {
 318         final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
<span class="line-modified"> 319         cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>

 320         cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
 321                 CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);
 322         cw.visitSource(SOURCE_PREFIX + className, null);
 323         return cw;
 324     }
 325 
 326     private void methodPrologue() {
 327         String invokerDesc = invokerType.toMethodDescriptorString();
 328         mv = cw.visitMethod(Opcodes.ACC_STATIC, invokerName, invokerDesc, null, null);
 329     }
 330 
 331     /**
 332      * Tear down class file generation.
 333      */
 334     private void methodEpilogue() {
 335         mv.visitMaxs(0, 0);
 336         mv.visitEnd();
 337     }
 338 













































 339     /*
 340      * Low-level emit helpers.
 341      */
 342     private void emitConst(Object con) {
 343         if (con == null) {
 344             mv.visitInsn(Opcodes.ACONST_NULL);
 345             return;
 346         }
 347         if (con instanceof Integer) {
 348             emitIconstInsn((int) con);
 349             return;
 350         }
 351         if (con instanceof Byte) {
 352             emitIconstInsn((byte)con);
 353             return;
 354         }
 355         if (con instanceof Short) {
 356             emitIconstInsn((short)con);
 357             return;
 358         }
</pre>
<hr />
<pre>
 391             short sx = (short)x;
 392             if (x == sx) {
 393                 if (sx &gt;= 0 &amp;&amp; sx &lt;= 1) {
 394                     mv.visitInsn(Opcodes.DCONST_0 + (int) sx);
 395                 } else {
 396                     emitIconstInsn((int) x);
 397                     mv.visitInsn(Opcodes.I2D);
 398                 }
 399                 return;
 400             }
 401         }
 402         if (con instanceof Boolean) {
 403             emitIconstInsn((boolean) con ? 1 : 0);
 404             return;
 405         }
 406         // fall through:
 407         mv.visitLdcInsn(con);
 408     }
 409 
 410     private void emitIconstInsn(final int cst) {




 411         if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {
 412             mv.visitInsn(Opcodes.ICONST_0 + cst);
 413         } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {
 414             mv.visitIntInsn(Opcodes.BIPUSH, cst);
 415         } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {
 416             mv.visitIntInsn(Opcodes.SIPUSH, cst);
 417         } else {
 418             mv.visitLdcInsn(cst);
 419         }
 420     }
 421 
 422     /*
 423      * NOTE: These load/store methods use the localsMap to find the correct index!
 424      */
 425     private void emitLoadInsn(BasicType type, int index) {
 426         int opcode = loadInsnOpcode(type);
 427         mv.visitVarInsn(opcode, localsMap[index]);
 428     }
 429 
 430     private int loadInsnOpcode(BasicType type) throws InternalError {
</pre>
<hr />
<pre>
 560         }
 561         return false;
 562     }
 563 
 564     private void emitReferenceCast(Class&lt;?&gt; cls, Object arg) {
 565         Name writeBack = null;  // local to write back result
 566         if (arg instanceof Name) {
 567             Name n = (Name) arg;
 568             if (lambdaForm.useCount(n) &gt; 1) {
 569                 // This guy gets used more than once.
 570                 writeBack = n;
 571                 if (assertStaticType(cls, n)) {
 572                     return; // this cast was already performed
 573                 }
 574             }
 575         }
 576         if (isStaticallyNameable(cls)) {
 577             String sig = getInternalName(cls);
 578             mv.visitTypeInsn(Opcodes.CHECKCAST, sig);
 579         } else {
<span class="line-modified"> 580             mv.visitLdcInsn(constantPlaceholder(cls));</span>
<span class="line-removed"> 581             mv.visitTypeInsn(Opcodes.CHECKCAST, CLS);</span>
 582             mv.visitInsn(Opcodes.SWAP);
 583             mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, &quot;cast&quot;, LL_SIG, false);
 584             if (Object[].class.isAssignableFrom(cls))
 585                 mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);
 586             else if (PROFILE_LEVEL &gt; 0)
 587                 mv.visitTypeInsn(Opcodes.CHECKCAST, OBJ);
 588         }
 589         if (writeBack != null) {
 590             mv.visitInsn(Opcodes.DUP);
 591             emitAstoreInsn(writeBack.index());
 592         }
 593     }
 594 
 595     /**
 596      * Emits an actual return instruction conforming to the given return type.
 597      */
 598     private void emitReturnInsn(BasicType type) {
 599         int opcode;
 600         switch (type) {
 601         case I_TYPE:  opcode = Opcodes.IRETURN;  break;
</pre>
<hr />
<pre>
 720         try {
 721             Class&lt;?&gt; c = Class.forName(tp.getClassName(), false, null);
 722             return true;
 723         } catch (ClassNotFoundException e) {
 724             return false;
 725         }
 726     }
 727 
 728     static final String      DONTINLINE_SIG = className(&quot;Ljdk/internal/vm/annotation/DontInline;&quot;);
 729     static final String     FORCEINLINE_SIG = className(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;);
 730     static final String          HIDDEN_SIG = className(&quot;Ljdk/internal/vm/annotation/Hidden;&quot;);
 731     static final String INJECTEDPROFILE_SIG = className(&quot;Ljava/lang/invoke/InjectedProfile;&quot;);
 732     static final String     LF_COMPILED_SIG = className(&quot;Ljava/lang/invoke/LambdaForm$Compiled;&quot;);
 733 
 734     /**
 735      * Generate an invoker method for the passed {@link LambdaForm}.
 736      */
 737     private byte[] generateCustomizedCodeBytes() {
 738         classFilePrologue();
 739         addMethod();

 740         bogusMethod(lambdaForm);
 741 
 742         final byte[] classFile = toByteArray();
 743         maybeDump(classFile);
 744         return classFile;
 745     }
 746 
 747     void setClassWriter(ClassWriter cw) {
 748         this.cw = cw;
 749     }
 750 
 751     void addMethod() {
 752         methodPrologue();
 753 
 754         // Suppress this method in backtraces displayed to the user.
 755         mv.visitAnnotation(HIDDEN_SIG, true);
 756 
 757         // Mark this method as a compiled LambdaForm
 758         mv.visitAnnotation(LF_COMPILED_SIG, true);
 759 
 760         if (lambdaForm.forceInline) {
 761             // Force inlining of this invoker method.
 762             mv.visitAnnotation(FORCEINLINE_SIG, true);
 763         } else {
 764             mv.visitAnnotation(DONTINLINE_SIG, true);
 765         }
 766 
<span class="line-modified"> 767         constantPlaceholder(lambdaForm); // keep LambdaForm instance &amp; its compiled form lifetime tightly coupled.</span>
 768 
 769         if (lambdaForm.customized != null) {
 770             // Since LambdaForm is customized for a particular MethodHandle, it&#39;s safe to substitute
 771             // receiver MethodHandle (at slot #0) with an embedded constant and use it instead.
 772             // It enables more efficient code generation in some situations, since embedded constants
 773             // are compile-time constants for JIT compiler.
<span class="line-modified"> 774             mv.visitLdcInsn(constantPlaceholder(lambdaForm.customized));</span>
 775             mv.visitTypeInsn(Opcodes.CHECKCAST, MH);
 776             assert(checkActualReceiver()); // expects MethodHandle on top of the stack
 777             mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);
 778         }
 779 
 780         // iterate over the form&#39;s names, generating bytecode instructions for each
 781         // start iterating at the first name following the arguments
 782         Name onStack = null;
 783         for (int i = lambdaForm.arity; i &lt; lambdaForm.names.length; i++) {
 784             Name name = lambdaForm.names[i];
 785 
 786             emitStoreResult(onStack);
 787             onStack = name;  // unless otherwise modified below
 788             MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();
 789             switch (intr) {
 790                 case SELECT_ALTERNATIVE:
 791                     assert lambdaForm.isSelectAlternative(i);
 792                     if (PROFILE_GWT) {
 793                         assert(name.arguments[0] instanceof Name &amp;&amp;
 794                                 ((Name)name.arguments[0]).refersTo(MethodHandleImpl.class, &quot;profileBoolean&quot;));
</pre>
<hr />
<pre>
 884         assert arrayOpcode == Opcodes.AALOAD || arrayOpcode == Opcodes.AASTORE || arrayOpcode == Opcodes.ARRAYLENGTH;
 885         Class&lt;?&gt; elementType = name.function.methodType().parameterType(0).getComponentType();
 886         assert elementType != null;
 887         emitPushArguments(name, 0);
 888         if (arrayOpcode != Opcodes.ARRAYLENGTH &amp;&amp; elementType.isPrimitive()) {
 889             Wrapper w = Wrapper.forPrimitiveType(elementType);
 890             arrayOpcode = arrayInsnOpcode(arrayTypeCode(w), arrayOpcode);
 891         }
 892         mv.visitInsn(arrayOpcode);
 893     }
 894 
 895     /**
 896      * Emit an invoke for the given name.
 897      */
 898     void emitInvoke(Name name) {
 899         assert(!name.isLinkerMethodInvoke());  // should use the static path for these
 900         if (true) {
 901             // push receiver
 902             MethodHandle target = name.function.resolvedHandle();
 903             assert(target != null) : name.exprString();
<span class="line-modified"> 904             mv.visitLdcInsn(constantPlaceholder(target));</span>
 905             emitReferenceCast(MethodHandle.class, target);
 906         } else {
 907             // load receiver
 908             emitAloadInsn(0);
 909             emitReferenceCast(MethodHandle.class, null);
 910             mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, LF_SIG);
 911             mv.visitFieldInsn(Opcodes.GETFIELD, LF, &quot;names&quot;, LFN_SIG);
 912             // TODO more to come
 913         }
 914 
 915         // push arguments
 916         emitPushArguments(name, 0);
 917 
 918         // invocation
 919         MethodType type = name.function.methodType();
 920         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
 921     }
 922 
 923     private static Class&lt;?&gt;[] STATICALLY_INVOCABLE_PACKAGES = {
 924         // Sample classes from each package we are willing to bind to statically:
</pre>
<hr />
<pre>
 941         return isStaticallyInvocable(name.function.member());
 942     }
 943 
 944     static boolean isStaticallyInvocable(MemberName member) {
 945         if (member == null)  return false;
 946         if (member.isObjectConstructorOrStaticInitMethod())  return false;
 947 
 948         Class&lt;?&gt; cls = member.getDeclaringClass();
 949         // Fast-path non-private members declared by MethodHandles, which is a common
 950         // case
 951         if (MethodHandle.class.isAssignableFrom(cls) &amp;&amp; !member.isPrivate()) {
 952             assert(isStaticallyInvocableType(member.getMethodOrFieldType()));
 953             return true;
 954         }
 955         if (cls.isArray() || cls.isPrimitive())
 956             return false;  // FIXME
 957         if (cls.isAnonymousClass() || cls.isLocalClass())
 958             return false;  // inner class of some sort
 959         if (cls.getClassLoader() != MethodHandle.class.getClassLoader())
 960             return false;  // not on BCP
<span class="line-modified"> 961         if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added</span>


 962             return false;
 963         if (!isStaticallyInvocableType(member.getMethodOrFieldType()))
 964             return false;
 965         if (!member.isPrivate() &amp;&amp; VerifyAccess.isSamePackage(MethodHandle.class, cls))
 966             return true;   // in java.lang.invoke package
 967         if (member.isPublic() &amp;&amp; isStaticallyNameable(cls))
 968             return true;
 969         return false;
 970     }
 971 
 972     private static boolean isStaticallyInvocableType(MethodType mtype) {
 973         if (!isStaticallyNameable(mtype.returnType()))
 974             return false;
 975         for (Class&lt;?&gt; ptype : mtype.parameterArray())
 976             if (!isStaticallyNameable(ptype))
 977                 return false;
 978         return true;
 979     }
 980 
 981     static boolean isStaticallyNameable(Class&lt;?&gt; cls) {
 982         if (cls == Object.class)
 983             return true;
 984         if (MethodHandle.class.isAssignableFrom(cls)) {
<span class="line-modified"> 985             assert(!ReflectUtil.isVMAnonymousClass(cls));</span>
 986             return true;
 987         }
 988         while (cls.isArray())
 989             cls = cls.getComponentType();
 990         if (cls.isPrimitive())
 991             return true;  // int[].class, for example
<span class="line-modified"> 992         if (ReflectUtil.isVMAnonymousClass(cls)) // FIXME: switch to supported API once it is added</span>


 993             return false;
 994         // could use VerifyAccess.isClassAccessible but the following is a safe approximation
 995         if (cls.getClassLoader() != Object.class.getClassLoader())
 996             return false;
 997         if (VerifyAccess.isSamePackage(MethodHandle.class, cls))
 998             return true;
 999         if (!Modifier.isPublic(cls.getModifiers()))
1000             return false;
1001         for (Class&lt;?&gt; pkgcls : STATICALLY_INVOCABLE_PACKAGES) {
1002             if (VerifyAccess.isSamePackage(pkgcls, cls))
1003                 return true;
1004         }
1005         return false;
1006     }
1007 
1008     void emitStaticInvoke(Name name) {
1009         emitStaticInvoke(name.function.member(), name);
1010     }
1011 
1012     /**
</pre>
<hr />
<pre>
1044             Class&lt;?&gt; rtype = member.getInvocationType().returnType();
1045             assert(!rtype.isPrimitive());
1046             if (rtype != Object.class &amp;&amp; !rtype.isInterface()) {
1047                 assertStaticType(rtype, name);
1048             }
1049         }
1050     }
1051 
1052     void emitNewArray(Name name) throws InternalError {
1053         Class&lt;?&gt; rtype = name.function.methodType().returnType();
1054         if (name.arguments.length == 0) {
1055             // The array will be a constant.
1056             Object emptyArray;
1057             try {
1058                 emptyArray = name.function.resolvedHandle().invoke();
1059             } catch (Throwable ex) {
1060                 throw uncaughtException(ex);
1061             }
1062             assert(java.lang.reflect.Array.getLength(emptyArray) == 0);
1063             assert(emptyArray.getClass() == rtype);  // exact typing
<span class="line-modified">1064             mv.visitLdcInsn(constantPlaceholder(emptyArray));</span>
1065             emitReferenceCast(rtype, emptyArray);
1066             return;
1067         }
1068         Class&lt;?&gt; arrayElementType = rtype.getComponentType();
1069         assert(arrayElementType != null);
1070         emitIconstInsn(name.arguments.length);
1071         int xas = Opcodes.AASTORE;
1072         if (!arrayElementType.isPrimitive()) {
1073             mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(arrayElementType));
1074         } else {
1075             byte tc = arrayTypeCode(Wrapper.forPrimitiveType(arrayElementType));
1076             xas = arrayInsnOpcode(tc, xas);
1077             mv.visitIntInsn(Opcodes.NEWARRAY, tc);
1078         }
1079         // store arguments
1080         for (int i = 0; i &lt; name.arguments.length; i++) {
1081             mv.visitInsn(Opcodes.DUP);
1082             emitIconstInsn(i);
1083             emitPushArgument(name, i);
1084             mv.visitInsn(xas);
</pre>
<hr />
<pre>
1607     }
1608 
1609     private void emitPushArgument(Name name, int paramIndex) {
1610         Object arg = name.arguments[paramIndex];
1611         Class&lt;?&gt; ptype = name.function.methodType().parameterType(paramIndex);
1612         emitPushArgument(ptype, arg);
1613     }
1614 
1615     private void emitPushArgument(Class&lt;?&gt; ptype, Object arg) {
1616         BasicType bptype = basicType(ptype);
1617         if (arg instanceof Name) {
1618             Name n = (Name) arg;
1619             emitLoadInsn(n.type, n.index());
1620             emitImplicitConversion(n.type, ptype, n);
1621         } else if ((arg == null || arg instanceof String) &amp;&amp; bptype == L_TYPE) {
1622             emitConst(arg);
1623         } else {
1624             if (Wrapper.isWrapperType(arg.getClass()) &amp;&amp; bptype != L_TYPE) {
1625                 emitConst(arg);
1626             } else {
<span class="line-modified">1627                 mv.visitLdcInsn(constantPlaceholder(arg));</span>
1628                 emitImplicitConversion(L_TYPE, ptype, arg);
1629             }
1630         }
1631     }
1632 
1633     /**
1634      * Store the name to its local, if necessary.
1635      */
1636     private void emitStoreResult(Name name) {
1637         if (name != null &amp;&amp; name.type != V_TYPE) {
1638             // non-void: actually assign
1639             emitStoreInsn(name.type, name.index());
1640         }
1641     }
1642 
1643     /**
1644      * Emits a return statement from a LF invoker. If required, the result type is cast to the correct return type.
1645      */
1646     private void emitReturn(Name onStack) {
1647         // return statement
</pre>
<hr />
<pre>
1799                 emitBoxing(Wrapper.forPrimitiveType(ptype));
1800             }
1801             mv.visitInsn(Opcodes.AASTORE);
1802         }
1803         // invoke
1804         emitAloadInsn(0);
1805         mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, &quot;Ljava/lang/invoke/LambdaForm;&quot;);
1806         mv.visitInsn(Opcodes.SWAP);  // swap form and array; avoid local variable
1807         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, LF, &quot;interpretWithArguments&quot;, &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);
1808 
1809         // maybe unbox
1810         Class&lt;?&gt; rtype = invokerType.returnType();
1811         if (rtype.isPrimitive() &amp;&amp; rtype != void.class) {
1812             emitUnboxing(Wrapper.forPrimitiveType(rtype));
1813         }
1814 
1815         // return statement
1816         emitReturnInsn(basicType(rtype));
1817 
1818         methodEpilogue();

1819         bogusMethod(invokerType);
1820 
1821         final byte[] classFile = cw.toByteArray();
1822         maybeDump(classFile);
1823         return classFile;
1824     }
1825 
1826     /**
1827      * Generate bytecode for a NamedFunction invoker.
1828      */
1829     static MemberName generateNamedFunctionInvoker(MethodTypeForm typeForm) {
1830         MethodType invokerType = NamedFunction.INVOKER_METHOD_TYPE;
1831         String invokerName = &quot;invoke_&quot; + shortenSignature(basicTypeSignature(typeForm.erasedType()));
1832         InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;NFI&quot;, invokerName, invokerType);
1833         return g.loadMethod(g.generateNamedFunctionInvokerImpl(typeForm));
1834     }
1835 
1836     private byte[] generateNamedFunctionInvokerImpl(MethodTypeForm typeForm) {
1837         MethodType dstType = typeForm.erasedType();
1838         classFilePrologue();
</pre>
<hr />
<pre>
1867         String targetDesc = dstType.basicType().toMethodDescriptorString();
1868         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, targetDesc, false);
1869 
1870         // Box primitive types
1871         Class&lt;?&gt; rtype = dstType.returnType();
1872         if (rtype != void.class &amp;&amp; rtype.isPrimitive()) {
1873             Wrapper srcWrapper = Wrapper.forBasicType(rtype);
1874             Wrapper dstWrapper = srcWrapper.isSubwordOrInt() ? Wrapper.INT : srcWrapper;  // widen subword to int
1875             // boolean casts not allowed
1876             emitPrimCast(srcWrapper, dstWrapper);
1877             emitBoxing(dstWrapper);
1878         }
1879 
1880         // If the return type is void we return a null reference.
1881         if (rtype == void.class) {
1882             mv.visitInsn(Opcodes.ACONST_NULL);
1883         }
1884         emitReturnInsn(L_TYPE);  // NOTE: NamedFunction invokers always return a reference value.
1885 
1886         methodEpilogue();

1887         bogusMethod(dstType);
1888 
1889         final byte[] classFile = cw.toByteArray();
1890         maybeDump(classFile);
1891         return classFile;
1892     }
1893 
1894     /**
1895      * Emit a bogus method that just loads some string constants. This is to get the constants into the constant pool
1896      * for debugging purposes.
1897      */
1898     private void bogusMethod(Object os) {
1899         if (DUMP_CLASS_FILES) {
1900             mv = cw.visitMethod(Opcodes.ACC_STATIC, &quot;dummy&quot;, &quot;()V&quot;, null, null);
1901             mv.visitLdcInsn(os.toString());
1902             mv.visitInsn(Opcodes.POP);
1903             mv.visitInsn(Opcodes.RETURN);
1904             mv.visitMaxs(0, 0);
1905             mv.visitEnd();
1906         }
</pre>
</td>
<td>
<hr />
<pre>
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.org.objectweb.asm.ClassWriter;
<span class="line-added">  29 import jdk.internal.org.objectweb.asm.FieldVisitor;</span>
  30 import jdk.internal.org.objectweb.asm.Label;
  31 import jdk.internal.org.objectweb.asm.MethodVisitor;
  32 import jdk.internal.org.objectweb.asm.Opcodes;
  33 import jdk.internal.org.objectweb.asm.Type;
  34 import sun.invoke.util.VerifyAccess;
  35 import sun.invoke.util.VerifyType;
  36 import sun.invoke.util.Wrapper;
  37 import sun.reflect.misc.ReflectUtil;
  38 
  39 import java.io.File;
  40 import java.io.FileOutputStream;
  41 import java.io.IOException;
  42 import java.lang.reflect.Modifier;
  43 import java.util.ArrayList;
  44 import java.util.Arrays;
  45 import java.util.HashMap;
<span class="line-added">  46 import java.util.List;</span>
  47 import java.util.stream.Stream;
  48 
  49 import static java.lang.invoke.LambdaForm.BasicType;
  50 import static java.lang.invoke.LambdaForm.BasicType.*;
  51 import static java.lang.invoke.LambdaForm.*;
  52 import static java.lang.invoke.MethodHandleNatives.Constants.*;
  53 import static java.lang.invoke.MethodHandleStatics.*;
<span class="line-added">  54 import static java.lang.invoke.MethodHandles.Lookup.*;</span>
  55 
  56 /**
  57  * Code generation backend for LambdaForm.
  58  * &lt;p&gt;
  59  * @author John Rose, JSR 292 EG
  60  */
  61 class InvokerBytecodeGenerator {
  62     /** Define class names for convenience. */
  63     private static final String MH      = &quot;java/lang/invoke/MethodHandle&quot;;
  64     private static final String MHI     = &quot;java/lang/invoke/MethodHandleImpl&quot;;
  65     private static final String LF      = &quot;java/lang/invoke/LambdaForm&quot;;
  66     private static final String LFN     = &quot;java/lang/invoke/LambdaForm$Name&quot;;
  67     private static final String CLS     = &quot;java/lang/Class&quot;;
  68     private static final String OBJ     = &quot;java/lang/Object&quot;;
  69     private static final String OBJARY  = &quot;[Ljava/lang/Object;&quot;;
  70 
  71     private static final String LOOP_CLAUSES = MHI + &quot;$LoopClauses&quot;;
  72     private static final String MHARY2       = &quot;[[L&quot; + MH + &quot;;&quot;;
<span class="line-added">  73     private static final String MH_SIG       = &quot;L&quot; + MH + &quot;;&quot;;</span>
<span class="line-added">  74 </span>
  75 
  76     private static final String LF_SIG  = &quot;L&quot; + LF + &quot;;&quot;;
  77     private static final String LFN_SIG = &quot;L&quot; + LFN + &quot;;&quot;;
  78     private static final String LL_SIG  = &quot;(L&quot; + OBJ + &quot;;)L&quot; + OBJ + &quot;;&quot;;
  79     private static final String LLV_SIG = &quot;(L&quot; + OBJ + &quot;;L&quot; + OBJ + &quot;;)V&quot;;
  80     private static final String CLASS_PREFIX = LF + &quot;$&quot;;
  81     private static final String SOURCE_PREFIX = &quot;LambdaForm$&quot;;
  82 
  83     /** Name of its super class*/
  84     static final String INVOKER_SUPER_NAME = OBJ;
  85 
  86     /** Name of new class */
  87     private final String className;
  88 
  89     private final LambdaForm lambdaForm;
  90     private final String     invokerName;
  91     private final MethodType invokerType;
  92 
  93     /** Info about local variables in compiled lambda form */
  94     private int[]       localsMap;    // index
  95     private Class&lt;?&gt;[]  localClasses; // type
  96 
  97     /** ASM bytecode generation. */
  98     private ClassWriter cw;
  99     private MethodVisitor mv;
<span class="line-added"> 100     private final List&lt;ClassData&gt; classData = new ArrayList&lt;&gt;();</span>
 101 
 102     /** Single element internal class name lookup cache. */
 103     private Class&lt;?&gt; lastClass;
 104     private String lastInternalName;
 105 
 106     private static final MemberName.Factory MEMBERNAME_FACTORY = MemberName.getFactory();
 107     private static final Class&lt;?&gt; HOST_CLASS = LambdaForm.class;
<span class="line-added"> 108     private static final MethodHandles.Lookup LOOKUP = lookup();</span>
<span class="line-added"> 109 </span>
<span class="line-added"> 110     private static MethodHandles.Lookup lookup() {</span>
<span class="line-added"> 111         try {</span>
<span class="line-added"> 112             return MethodHandles.privateLookupIn(HOST_CLASS, IMPL_LOOKUP);</span>
<span class="line-added"> 113         } catch (IllegalAccessException e) {</span>
<span class="line-added"> 114             throw newInternalError(e);</span>
<span class="line-added"> 115         }</span>
<span class="line-added"> 116     }</span>
 117 
 118     /** Main constructor; other constructors delegate to this one. */
 119     private InvokerBytecodeGenerator(LambdaForm lambdaForm, int localsMapSize,
 120                                      String className, String invokerName, MethodType invokerType) {
 121         int p = invokerName.indexOf(&#39;.&#39;);
 122         if (p &gt; -1) {
 123             className = invokerName.substring(0, p);
 124             invokerName = invokerName.substring(p + 1);
 125         }
 126         if (DUMP_CLASS_FILES) {
 127             className = makeDumpableClassName(className);
 128         }
 129         this.className  = className;
 130         this.lambdaForm = lambdaForm;
 131         this.invokerName = invokerName;
 132         this.invokerType = invokerType;
 133         this.localsMap = new int[localsMapSize+1]; // last entry of localsMap is count of allocated local slots
 134         this.localClasses = new Class&lt;?&gt;[localsMapSize+1];
 135     }
 136 
</pre>
<hr />
<pre>
 219                     }
 220                 }
 221             });
 222         }
 223     }
 224 
 225     private static String makeDumpableClassName(String className) {
 226         Integer ctr;
 227         synchronized (DUMP_CLASS_FILES_COUNTERS) {
 228             ctr = DUMP_CLASS_FILES_COUNTERS.get(className);
 229             if (ctr == null)  ctr = 0;
 230             DUMP_CLASS_FILES_COUNTERS.put(className, ctr+1);
 231         }
 232         String sfx = ctr.toString();
 233         while (sfx.length() &lt; 3)
 234             sfx = &quot;0&quot;+sfx;
 235         className += sfx;
 236         return className;
 237     }
 238 
<span class="line-modified"> 239     public static class ClassData {</span>
<span class="line-modified"> 240         final String name;</span>
<span class="line-added"> 241         final String desc;</span>
 242         final Object value;
<span class="line-modified"> 243 </span>
<span class="line-modified"> 244         ClassData(String name, String desc, Object value) {</span>
<span class="line-added"> 245             this.name = name;</span>
<span class="line-added"> 246             this.desc = desc;</span>
 247             this.value = value;
 248         }
<span class="line-added"> 249 </span>
<span class="line-added"> 250         public String name() { return name; }</span>
 251         public String toString() {
<span class="line-modified"> 252             return name + &quot;,value=&quot;+value;</span>
 253         }
 254     }
 255 
<span class="line-modified"> 256     String classData(Object arg) {</span>
<span class="line-modified"> 257         String desc;</span>
<span class="line-modified"> 258         if (arg instanceof Class) {</span>
<span class="line-added"> 259             desc = &quot;Ljava/lang/Class;&quot;;</span>
<span class="line-added"> 260         } else if (arg instanceof MethodHandle) {</span>
<span class="line-added"> 261             desc = MH_SIG;</span>
<span class="line-added"> 262         } else if (arg instanceof LambdaForm) {</span>
<span class="line-added"> 263             desc = LF_SIG;</span>
<span class="line-added"> 264         } else {</span>
<span class="line-added"> 265             desc = &quot;Ljava/lang/Object;&quot;;</span>
<span class="line-added"> 266         }</span>
 267 
<span class="line-modified"> 268         Class&lt;?&gt; c = arg.getClass();</span>
<span class="line-modified"> 269         while (c.isArray()) {</span>
<span class="line-modified"> 270             c = c.getComponentType();</span>
<span class="line-modified"> 271         }</span>
<span class="line-modified"> 272         // unique static variable name</span>
<span class="line-modified"> 273         String name = &quot;_DATA_&quot; + c.getSimpleName() + &quot;_&quot; + classData.size();</span>
<span class="line-modified"> 274         ClassData cd = new ClassData(name, desc, arg);</span>
<span class="line-modified"> 275         classData.add(cd);</span>
<span class="line-added"> 276         return cd.name();</span>
 277     }
 278 
<span class="line-modified"> 279     List&lt;Object&gt; classDataValues() {</span>
<span class="line-modified"> 280         Object[] data = new Object[classData.size()];</span>
<span class="line-modified"> 281         for (int i = 0; i &lt; classData.size(); i++) {</span>
<span class="line-modified"> 282             data[i] = classData.get(i).value;</span>



 283         }
<span class="line-modified"> 284         return List.of(data);</span>
 285     }
 286 
 287     private static String debugString(Object arg) {
 288         if (arg instanceof MethodHandle) {
 289             MethodHandle mh = (MethodHandle) arg;
 290             MemberName member = mh.internalMemberName();
 291             if (member != null)
 292                 return member.toString();
 293             return mh.debugString();
 294         }
 295         return arg.toString();
 296     }
 297 
 298     /**
 299      * Extract the number of constant pool entries from a given class file.
 300      *
 301      * @param classFile the bytes of the class file in question.
 302      * @return the number of entries in the constant pool.
 303      */
 304     private static int getConstantPoolSize(byte[] classFile) {
 305         // The first few bytes:
 306         // u4 magic;
 307         // u2 minor_version;
 308         // u2 major_version;
 309         // u2 constant_pool_count;
 310         return ((classFile[8] &amp; 0xFF) &lt;&lt; 8) | (classFile[9] &amp; 0xFF);
 311     }
 312 
 313     /**
 314      * Extract the MemberName of a newly-defined method.
 315      */
 316     private MemberName loadMethod(byte[] classFile) {
<span class="line-modified"> 317         Class&lt;?&gt; invokerClass = LOOKUP.makeHiddenClassDefiner(classFile)</span>
<span class="line-added"> 318                                       .defineClass(true, classDataValues());</span>
 319         return resolveInvokerMember(invokerClass, invokerName, invokerType);
 320     }
 321 
<span class="line-modified"> 322     private static MemberName resolveInvokerMember(Class&lt;?&gt; invokerClass, String name, MethodType type) {</span>









 323         MemberName member = new MemberName(invokerClass, name, type, REF_invokeStatic);
 324         try {
 325             member = MEMBERNAME_FACTORY.resolveOrFail(REF_invokeStatic, member, HOST_CLASS, ReflectiveOperationException.class);
 326         } catch (ReflectiveOperationException e) {
 327             throw newInternalError(e);
 328         }
 329         return member;
 330     }
 331 
 332     /**
 333      * Set up class file generation.
 334      */
 335     private ClassWriter classFilePrologue() {
 336         final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
<span class="line-modified"> 337         ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);</span>
<span class="line-added"> 338         setClassWriter(cw);</span>
 339         cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER,
 340                 CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);
 341         cw.visitSource(SOURCE_PREFIX + className, null);
 342         return cw;
 343     }
 344 
 345     private void methodPrologue() {
 346         String invokerDesc = invokerType.toMethodDescriptorString();
 347         mv = cw.visitMethod(Opcodes.ACC_STATIC, invokerName, invokerDesc, null, null);
 348     }
 349 
 350     /**
 351      * Tear down class file generation.
 352      */
 353     private void methodEpilogue() {
 354         mv.visitMaxs(0, 0);
 355         mv.visitEnd();
 356     }
 357 
<span class="line-added"> 358     private String className() {</span>
<span class="line-added"> 359         return CLASS_PREFIX + className;</span>
<span class="line-added"> 360     }</span>
<span class="line-added"> 361 </span>
<span class="line-added"> 362     private void clinit() {</span>
<span class="line-added"> 363         clinit(cw, className(), classData);</span>
<span class="line-added"> 364     }</span>
<span class="line-added"> 365 </span>
<span class="line-added"> 366     /*</span>
<span class="line-added"> 367      * &lt;clinit&gt; to initialize the static final fields with the live class data</span>
<span class="line-added"> 368      * LambdaForms can&#39;t use condy due to bootstrapping issue.</span>
<span class="line-added"> 369      */</span>
<span class="line-added"> 370     static void clinit(ClassWriter cw, String className, List&lt;ClassData&gt; classData) {</span>
<span class="line-added"> 371         if (classData.isEmpty())</span>
<span class="line-added"> 372             return;</span>
<span class="line-added"> 373 </span>
<span class="line-added"> 374         for (ClassData p : classData) {</span>
<span class="line-added"> 375             // add the static field</span>
<span class="line-added"> 376             FieldVisitor fv = cw.visitField(Opcodes.ACC_STATIC|Opcodes.ACC_FINAL, p.name, p.desc, null, null);</span>
<span class="line-added"> 377             fv.visitEnd();</span>
<span class="line-added"> 378         }</span>
<span class="line-added"> 379 </span>
<span class="line-added"> 380         MethodVisitor mv = cw.visitMethod(Opcodes.ACC_STATIC, &quot;&lt;clinit&gt;&quot;, &quot;()V&quot;, null, null);</span>
<span class="line-added"> 381         mv.visitCode();</span>
<span class="line-added"> 382         mv.visitLdcInsn(Type.getType(&quot;L&quot; + className + &quot;;&quot;));</span>
<span class="line-added"> 383         mv.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/invoke/MethodHandleNatives&quot;,</span>
<span class="line-added"> 384                            &quot;classData&quot;, &quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, false);</span>
<span class="line-added"> 385         // we should optimize one single element case that does not need to create a List</span>
<span class="line-added"> 386         mv.visitTypeInsn(Opcodes.CHECKCAST, &quot;java/util/List&quot;);</span>
<span class="line-added"> 387         mv.visitVarInsn(Opcodes.ASTORE, 0);</span>
<span class="line-added"> 388         int index = 0;</span>
<span class="line-added"> 389         for (ClassData p : classData) {</span>
<span class="line-added"> 390             // initialize the static field</span>
<span class="line-added"> 391             mv.visitVarInsn(Opcodes.ALOAD, 0);</span>
<span class="line-added"> 392             emitIconstInsn(mv, index++);</span>
<span class="line-added"> 393             mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, &quot;java/util/List&quot;,</span>
<span class="line-added"> 394                                &quot;get&quot;, &quot;(I)Ljava/lang/Object;&quot;, true);</span>
<span class="line-added"> 395             mv.visitTypeInsn(Opcodes.CHECKCAST, p.desc.substring(1, p.desc.length()-1));</span>
<span class="line-added"> 396             mv.visitFieldInsn(Opcodes.PUTSTATIC, className, p.name, p.desc);</span>
<span class="line-added"> 397         }</span>
<span class="line-added"> 398         mv.visitInsn(Opcodes.RETURN);</span>
<span class="line-added"> 399         mv.visitMaxs(2, 1);</span>
<span class="line-added"> 400         mv.visitEnd();</span>
<span class="line-added"> 401     }</span>
<span class="line-added"> 402 </span>
 403     /*
 404      * Low-level emit helpers.
 405      */
 406     private void emitConst(Object con) {
 407         if (con == null) {
 408             mv.visitInsn(Opcodes.ACONST_NULL);
 409             return;
 410         }
 411         if (con instanceof Integer) {
 412             emitIconstInsn((int) con);
 413             return;
 414         }
 415         if (con instanceof Byte) {
 416             emitIconstInsn((byte)con);
 417             return;
 418         }
 419         if (con instanceof Short) {
 420             emitIconstInsn((short)con);
 421             return;
 422         }
</pre>
<hr />
<pre>
 455             short sx = (short)x;
 456             if (x == sx) {
 457                 if (sx &gt;= 0 &amp;&amp; sx &lt;= 1) {
 458                     mv.visitInsn(Opcodes.DCONST_0 + (int) sx);
 459                 } else {
 460                     emitIconstInsn((int) x);
 461                     mv.visitInsn(Opcodes.I2D);
 462                 }
 463                 return;
 464             }
 465         }
 466         if (con instanceof Boolean) {
 467             emitIconstInsn((boolean) con ? 1 : 0);
 468             return;
 469         }
 470         // fall through:
 471         mv.visitLdcInsn(con);
 472     }
 473 
 474     private void emitIconstInsn(final int cst) {
<span class="line-added"> 475         emitIconstInsn(mv, cst);</span>
<span class="line-added"> 476     }</span>
<span class="line-added"> 477 </span>
<span class="line-added"> 478     private static void emitIconstInsn(MethodVisitor mv, int cst) {</span>
 479         if (cst &gt;= -1 &amp;&amp; cst &lt;= 5) {
 480             mv.visitInsn(Opcodes.ICONST_0 + cst);
 481         } else if (cst &gt;= Byte.MIN_VALUE &amp;&amp; cst &lt;= Byte.MAX_VALUE) {
 482             mv.visitIntInsn(Opcodes.BIPUSH, cst);
 483         } else if (cst &gt;= Short.MIN_VALUE &amp;&amp; cst &lt;= Short.MAX_VALUE) {
 484             mv.visitIntInsn(Opcodes.SIPUSH, cst);
 485         } else {
 486             mv.visitLdcInsn(cst);
 487         }
 488     }
 489 
 490     /*
 491      * NOTE: These load/store methods use the localsMap to find the correct index!
 492      */
 493     private void emitLoadInsn(BasicType type, int index) {
 494         int opcode = loadInsnOpcode(type);
 495         mv.visitVarInsn(opcode, localsMap[index]);
 496     }
 497 
 498     private int loadInsnOpcode(BasicType type) throws InternalError {
</pre>
<hr />
<pre>
 628         }
 629         return false;
 630     }
 631 
 632     private void emitReferenceCast(Class&lt;?&gt; cls, Object arg) {
 633         Name writeBack = null;  // local to write back result
 634         if (arg instanceof Name) {
 635             Name n = (Name) arg;
 636             if (lambdaForm.useCount(n) &gt; 1) {
 637                 // This guy gets used more than once.
 638                 writeBack = n;
 639                 if (assertStaticType(cls, n)) {
 640                     return; // this cast was already performed
 641                 }
 642             }
 643         }
 644         if (isStaticallyNameable(cls)) {
 645             String sig = getInternalName(cls);
 646             mv.visitTypeInsn(Opcodes.CHECKCAST, sig);
 647         } else {
<span class="line-modified"> 648             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(cls), &quot;Ljava/lang/Class;&quot;);</span>

 649             mv.visitInsn(Opcodes.SWAP);
 650             mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, CLS, &quot;cast&quot;, LL_SIG, false);
 651             if (Object[].class.isAssignableFrom(cls))
 652                 mv.visitTypeInsn(Opcodes.CHECKCAST, OBJARY);
 653             else if (PROFILE_LEVEL &gt; 0)
 654                 mv.visitTypeInsn(Opcodes.CHECKCAST, OBJ);
 655         }
 656         if (writeBack != null) {
 657             mv.visitInsn(Opcodes.DUP);
 658             emitAstoreInsn(writeBack.index());
 659         }
 660     }
 661 
 662     /**
 663      * Emits an actual return instruction conforming to the given return type.
 664      */
 665     private void emitReturnInsn(BasicType type) {
 666         int opcode;
 667         switch (type) {
 668         case I_TYPE:  opcode = Opcodes.IRETURN;  break;
</pre>
<hr />
<pre>
 787         try {
 788             Class&lt;?&gt; c = Class.forName(tp.getClassName(), false, null);
 789             return true;
 790         } catch (ClassNotFoundException e) {
 791             return false;
 792         }
 793     }
 794 
 795     static final String      DONTINLINE_SIG = className(&quot;Ljdk/internal/vm/annotation/DontInline;&quot;);
 796     static final String     FORCEINLINE_SIG = className(&quot;Ljdk/internal/vm/annotation/ForceInline;&quot;);
 797     static final String          HIDDEN_SIG = className(&quot;Ljdk/internal/vm/annotation/Hidden;&quot;);
 798     static final String INJECTEDPROFILE_SIG = className(&quot;Ljava/lang/invoke/InjectedProfile;&quot;);
 799     static final String     LF_COMPILED_SIG = className(&quot;Ljava/lang/invoke/LambdaForm$Compiled;&quot;);
 800 
 801     /**
 802      * Generate an invoker method for the passed {@link LambdaForm}.
 803      */
 804     private byte[] generateCustomizedCodeBytes() {
 805         classFilePrologue();
 806         addMethod();
<span class="line-added"> 807         clinit();</span>
 808         bogusMethod(lambdaForm);
 809 
 810         final byte[] classFile = toByteArray();
 811         maybeDump(classFile);
 812         return classFile;
 813     }
 814 
 815     void setClassWriter(ClassWriter cw) {
 816         this.cw = cw;
 817     }
 818 
 819     void addMethod() {
 820         methodPrologue();
 821 
 822         // Suppress this method in backtraces displayed to the user.
 823         mv.visitAnnotation(HIDDEN_SIG, true);
 824 
 825         // Mark this method as a compiled LambdaForm
 826         mv.visitAnnotation(LF_COMPILED_SIG, true);
 827 
 828         if (lambdaForm.forceInline) {
 829             // Force inlining of this invoker method.
 830             mv.visitAnnotation(FORCEINLINE_SIG, true);
 831         } else {
 832             mv.visitAnnotation(DONTINLINE_SIG, true);
 833         }
 834 
<span class="line-modified"> 835         classData(lambdaForm); // keep LambdaForm instance &amp; its compiled form lifetime tightly coupled.</span>
 836 
 837         if (lambdaForm.customized != null) {
 838             // Since LambdaForm is customized for a particular MethodHandle, it&#39;s safe to substitute
 839             // receiver MethodHandle (at slot #0) with an embedded constant and use it instead.
 840             // It enables more efficient code generation in some situations, since embedded constants
 841             // are compile-time constants for JIT compiler.
<span class="line-modified"> 842             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(lambdaForm.customized), MH_SIG);</span>
 843             mv.visitTypeInsn(Opcodes.CHECKCAST, MH);
 844             assert(checkActualReceiver()); // expects MethodHandle on top of the stack
 845             mv.visitVarInsn(Opcodes.ASTORE, localsMap[0]);
 846         }
 847 
 848         // iterate over the form&#39;s names, generating bytecode instructions for each
 849         // start iterating at the first name following the arguments
 850         Name onStack = null;
 851         for (int i = lambdaForm.arity; i &lt; lambdaForm.names.length; i++) {
 852             Name name = lambdaForm.names[i];
 853 
 854             emitStoreResult(onStack);
 855             onStack = name;  // unless otherwise modified below
 856             MethodHandleImpl.Intrinsic intr = name.function.intrinsicName();
 857             switch (intr) {
 858                 case SELECT_ALTERNATIVE:
 859                     assert lambdaForm.isSelectAlternative(i);
 860                     if (PROFILE_GWT) {
 861                         assert(name.arguments[0] instanceof Name &amp;&amp;
 862                                 ((Name)name.arguments[0]).refersTo(MethodHandleImpl.class, &quot;profileBoolean&quot;));
</pre>
<hr />
<pre>
 952         assert arrayOpcode == Opcodes.AALOAD || arrayOpcode == Opcodes.AASTORE || arrayOpcode == Opcodes.ARRAYLENGTH;
 953         Class&lt;?&gt; elementType = name.function.methodType().parameterType(0).getComponentType();
 954         assert elementType != null;
 955         emitPushArguments(name, 0);
 956         if (arrayOpcode != Opcodes.ARRAYLENGTH &amp;&amp; elementType.isPrimitive()) {
 957             Wrapper w = Wrapper.forPrimitiveType(elementType);
 958             arrayOpcode = arrayInsnOpcode(arrayTypeCode(w), arrayOpcode);
 959         }
 960         mv.visitInsn(arrayOpcode);
 961     }
 962 
 963     /**
 964      * Emit an invoke for the given name.
 965      */
 966     void emitInvoke(Name name) {
 967         assert(!name.isLinkerMethodInvoke());  // should use the static path for these
 968         if (true) {
 969             // push receiver
 970             MethodHandle target = name.function.resolvedHandle();
 971             assert(target != null) : name.exprString();
<span class="line-modified"> 972             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(target), MH_SIG);</span>
 973             emitReferenceCast(MethodHandle.class, target);
 974         } else {
 975             // load receiver
 976             emitAloadInsn(0);
 977             emitReferenceCast(MethodHandle.class, null);
 978             mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, LF_SIG);
 979             mv.visitFieldInsn(Opcodes.GETFIELD, LF, &quot;names&quot;, LFN_SIG);
 980             // TODO more to come
 981         }
 982 
 983         // push arguments
 984         emitPushArguments(name, 0);
 985 
 986         // invocation
 987         MethodType type = name.function.methodType();
 988         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, type.basicType().toMethodDescriptorString(), false);
 989     }
 990 
 991     private static Class&lt;?&gt;[] STATICALLY_INVOCABLE_PACKAGES = {
 992         // Sample classes from each package we are willing to bind to statically:
</pre>
<hr />
<pre>
1009         return isStaticallyInvocable(name.function.member());
1010     }
1011 
1012     static boolean isStaticallyInvocable(MemberName member) {
1013         if (member == null)  return false;
1014         if (member.isObjectConstructorOrStaticInitMethod())  return false;
1015 
1016         Class&lt;?&gt; cls = member.getDeclaringClass();
1017         // Fast-path non-private members declared by MethodHandles, which is a common
1018         // case
1019         if (MethodHandle.class.isAssignableFrom(cls) &amp;&amp; !member.isPrivate()) {
1020             assert(isStaticallyInvocableType(member.getMethodOrFieldType()));
1021             return true;
1022         }
1023         if (cls.isArray() || cls.isPrimitive())
1024             return false;  // FIXME
1025         if (cls.isAnonymousClass() || cls.isLocalClass())
1026             return false;  // inner class of some sort
1027         if (cls.getClassLoader() != MethodHandle.class.getClassLoader())
1028             return false;  // not on BCP
<span class="line-modified">1029         if (cls.isHidden())</span>
<span class="line-added">1030             return false;</span>
<span class="line-added">1031         if (ReflectUtil.isVMAnonymousClass(cls))   // FIXME: Unsafe::defineAnonymousClass to be removed</span>
1032             return false;
1033         if (!isStaticallyInvocableType(member.getMethodOrFieldType()))
1034             return false;
1035         if (!member.isPrivate() &amp;&amp; VerifyAccess.isSamePackage(MethodHandle.class, cls))
1036             return true;   // in java.lang.invoke package
1037         if (member.isPublic() &amp;&amp; isStaticallyNameable(cls))
1038             return true;
1039         return false;
1040     }
1041 
1042     private static boolean isStaticallyInvocableType(MethodType mtype) {
1043         if (!isStaticallyNameable(mtype.returnType()))
1044             return false;
1045         for (Class&lt;?&gt; ptype : mtype.parameterArray())
1046             if (!isStaticallyNameable(ptype))
1047                 return false;
1048         return true;
1049     }
1050 
1051     static boolean isStaticallyNameable(Class&lt;?&gt; cls) {
1052         if (cls == Object.class)
1053             return true;
1054         if (MethodHandle.class.isAssignableFrom(cls)) {
<span class="line-modified">1055             assert(!cls.isHidden());</span>
1056             return true;
1057         }
1058         while (cls.isArray())
1059             cls = cls.getComponentType();
1060         if (cls.isPrimitive())
1061             return true;  // int[].class, for example
<span class="line-modified">1062         if (cls.isHidden())</span>
<span class="line-added">1063             return false;</span>
<span class="line-added">1064         if (ReflectUtil.isVMAnonymousClass(cls))   // FIXME: Unsafe::defineAnonymousClass to be removed</span>
1065             return false;
1066         // could use VerifyAccess.isClassAccessible but the following is a safe approximation
1067         if (cls.getClassLoader() != Object.class.getClassLoader())
1068             return false;
1069         if (VerifyAccess.isSamePackage(MethodHandle.class, cls))
1070             return true;
1071         if (!Modifier.isPublic(cls.getModifiers()))
1072             return false;
1073         for (Class&lt;?&gt; pkgcls : STATICALLY_INVOCABLE_PACKAGES) {
1074             if (VerifyAccess.isSamePackage(pkgcls, cls))
1075                 return true;
1076         }
1077         return false;
1078     }
1079 
1080     void emitStaticInvoke(Name name) {
1081         emitStaticInvoke(name.function.member(), name);
1082     }
1083 
1084     /**
</pre>
<hr />
<pre>
1116             Class&lt;?&gt; rtype = member.getInvocationType().returnType();
1117             assert(!rtype.isPrimitive());
1118             if (rtype != Object.class &amp;&amp; !rtype.isInterface()) {
1119                 assertStaticType(rtype, name);
1120             }
1121         }
1122     }
1123 
1124     void emitNewArray(Name name) throws InternalError {
1125         Class&lt;?&gt; rtype = name.function.methodType().returnType();
1126         if (name.arguments.length == 0) {
1127             // The array will be a constant.
1128             Object emptyArray;
1129             try {
1130                 emptyArray = name.function.resolvedHandle().invoke();
1131             } catch (Throwable ex) {
1132                 throw uncaughtException(ex);
1133             }
1134             assert(java.lang.reflect.Array.getLength(emptyArray) == 0);
1135             assert(emptyArray.getClass() == rtype);  // exact typing
<span class="line-modified">1136             mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(emptyArray), &quot;Ljava/lang/Object;&quot;);</span>
1137             emitReferenceCast(rtype, emptyArray);
1138             return;
1139         }
1140         Class&lt;?&gt; arrayElementType = rtype.getComponentType();
1141         assert(arrayElementType != null);
1142         emitIconstInsn(name.arguments.length);
1143         int xas = Opcodes.AASTORE;
1144         if (!arrayElementType.isPrimitive()) {
1145             mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(arrayElementType));
1146         } else {
1147             byte tc = arrayTypeCode(Wrapper.forPrimitiveType(arrayElementType));
1148             xas = arrayInsnOpcode(tc, xas);
1149             mv.visitIntInsn(Opcodes.NEWARRAY, tc);
1150         }
1151         // store arguments
1152         for (int i = 0; i &lt; name.arguments.length; i++) {
1153             mv.visitInsn(Opcodes.DUP);
1154             emitIconstInsn(i);
1155             emitPushArgument(name, i);
1156             mv.visitInsn(xas);
</pre>
<hr />
<pre>
1679     }
1680 
1681     private void emitPushArgument(Name name, int paramIndex) {
1682         Object arg = name.arguments[paramIndex];
1683         Class&lt;?&gt; ptype = name.function.methodType().parameterType(paramIndex);
1684         emitPushArgument(ptype, arg);
1685     }
1686 
1687     private void emitPushArgument(Class&lt;?&gt; ptype, Object arg) {
1688         BasicType bptype = basicType(ptype);
1689         if (arg instanceof Name) {
1690             Name n = (Name) arg;
1691             emitLoadInsn(n.type, n.index());
1692             emitImplicitConversion(n.type, ptype, n);
1693         } else if ((arg == null || arg instanceof String) &amp;&amp; bptype == L_TYPE) {
1694             emitConst(arg);
1695         } else {
1696             if (Wrapper.isWrapperType(arg.getClass()) &amp;&amp; bptype != L_TYPE) {
1697                 emitConst(arg);
1698             } else {
<span class="line-modified">1699                 mv.visitFieldInsn(Opcodes.GETSTATIC, className(), classData(arg), &quot;Ljava/lang/Object;&quot;);</span>
1700                 emitImplicitConversion(L_TYPE, ptype, arg);
1701             }
1702         }
1703     }
1704 
1705     /**
1706      * Store the name to its local, if necessary.
1707      */
1708     private void emitStoreResult(Name name) {
1709         if (name != null &amp;&amp; name.type != V_TYPE) {
1710             // non-void: actually assign
1711             emitStoreInsn(name.type, name.index());
1712         }
1713     }
1714 
1715     /**
1716      * Emits a return statement from a LF invoker. If required, the result type is cast to the correct return type.
1717      */
1718     private void emitReturn(Name onStack) {
1719         // return statement
</pre>
<hr />
<pre>
1871                 emitBoxing(Wrapper.forPrimitiveType(ptype));
1872             }
1873             mv.visitInsn(Opcodes.AASTORE);
1874         }
1875         // invoke
1876         emitAloadInsn(0);
1877         mv.visitFieldInsn(Opcodes.GETFIELD, MH, &quot;form&quot;, &quot;Ljava/lang/invoke/LambdaForm;&quot;);
1878         mv.visitInsn(Opcodes.SWAP);  // swap form and array; avoid local variable
1879         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, LF, &quot;interpretWithArguments&quot;, &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);
1880 
1881         // maybe unbox
1882         Class&lt;?&gt; rtype = invokerType.returnType();
1883         if (rtype.isPrimitive() &amp;&amp; rtype != void.class) {
1884             emitUnboxing(Wrapper.forPrimitiveType(rtype));
1885         }
1886 
1887         // return statement
1888         emitReturnInsn(basicType(rtype));
1889 
1890         methodEpilogue();
<span class="line-added">1891         clinit();</span>
1892         bogusMethod(invokerType);
1893 
1894         final byte[] classFile = cw.toByteArray();
1895         maybeDump(classFile);
1896         return classFile;
1897     }
1898 
1899     /**
1900      * Generate bytecode for a NamedFunction invoker.
1901      */
1902     static MemberName generateNamedFunctionInvoker(MethodTypeForm typeForm) {
1903         MethodType invokerType = NamedFunction.INVOKER_METHOD_TYPE;
1904         String invokerName = &quot;invoke_&quot; + shortenSignature(basicTypeSignature(typeForm.erasedType()));
1905         InvokerBytecodeGenerator g = new InvokerBytecodeGenerator(&quot;NFI&quot;, invokerName, invokerType);
1906         return g.loadMethod(g.generateNamedFunctionInvokerImpl(typeForm));
1907     }
1908 
1909     private byte[] generateNamedFunctionInvokerImpl(MethodTypeForm typeForm) {
1910         MethodType dstType = typeForm.erasedType();
1911         classFilePrologue();
</pre>
<hr />
<pre>
1940         String targetDesc = dstType.basicType().toMethodDescriptorString();
1941         mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, MH, &quot;invokeBasic&quot;, targetDesc, false);
1942 
1943         // Box primitive types
1944         Class&lt;?&gt; rtype = dstType.returnType();
1945         if (rtype != void.class &amp;&amp; rtype.isPrimitive()) {
1946             Wrapper srcWrapper = Wrapper.forBasicType(rtype);
1947             Wrapper dstWrapper = srcWrapper.isSubwordOrInt() ? Wrapper.INT : srcWrapper;  // widen subword to int
1948             // boolean casts not allowed
1949             emitPrimCast(srcWrapper, dstWrapper);
1950             emitBoxing(dstWrapper);
1951         }
1952 
1953         // If the return type is void we return a null reference.
1954         if (rtype == void.class) {
1955             mv.visitInsn(Opcodes.ACONST_NULL);
1956         }
1957         emitReturnInsn(L_TYPE);  // NOTE: NamedFunction invokers always return a reference value.
1958 
1959         methodEpilogue();
<span class="line-added">1960         clinit();</span>
1961         bogusMethod(dstType);
1962 
1963         final byte[] classFile = cw.toByteArray();
1964         maybeDump(classFile);
1965         return classFile;
1966     }
1967 
1968     /**
1969      * Emit a bogus method that just loads some string constants. This is to get the constants into the constant pool
1970      * for debugging purposes.
1971      */
1972     private void bogusMethod(Object os) {
1973         if (DUMP_CLASS_FILES) {
1974             mv = cw.visitMethod(Opcodes.ACC_STATIC, &quot;dummy&quot;, &quot;()V&quot;, null, null);
1975             mv.visitLdcInsn(os.toString());
1976             mv.visitInsn(Opcodes.POP);
1977             mv.visitInsn(Opcodes.RETURN);
1978             mv.visitMaxs(0, 0);
1979             mv.visitEnd();
1980         }
</pre>
</td>
</tr>
</table>
<center><a href="InnerClassLambdaMetafactory.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MethodHandleNatives.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleNatives.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/AccessibleObject.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -23,13 +23,16 @@</span>
   * questions.
   */
  
  package java.lang.invoke;
  
<span class="udiff-line-added">+ import jdk.internal.access.JavaLangAccess;</span>
  import jdk.internal.access.SharedSecrets;
<span class="udiff-line-added">+ import jdk.internal.misc.VM;</span>
  import jdk.internal.module.IllegalAccessLogger;
  import jdk.internal.org.objectweb.asm.ClassReader;
<span class="udiff-line-added">+ import jdk.internal.org.objectweb.asm.Opcodes;</span>
  import jdk.internal.reflect.CallerSensitive;
  import jdk.internal.reflect.Reflection;
  import jdk.internal.vm.annotation.ForceInline;
  import sun.invoke.util.ValueConversions;
  import sun.invoke.util.VerifyAccess;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -43,12 +46,10 @@</span>
  import java.lang.reflect.Member;
  import java.lang.reflect.Method;
  import java.lang.reflect.Modifier;
  import java.lang.reflect.ReflectPermission;
  import java.nio.ByteOrder;
<span class="udiff-line-removed">- import java.security.AccessController;</span>
<span class="udiff-line-removed">- import java.security.PrivilegedAction;</span>
  import java.security.ProtectionDomain;
  import java.util.ArrayList;
  import java.util.Arrays;
  import java.util.BitSet;
  import java.util.Iterator;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -217,10 +218,14 @@</span>
       * @spec JPMS
       * @see Lookup#dropLookupMode
       * @see &lt;a href=&quot;MethodHandles.Lookup.html#cross-module-lookup&quot;&gt;Cross-module lookups&lt;/a&gt;
       */
      public static Lookup privateLookupIn(Class&lt;?&gt; targetClass, Lookup caller) throws IllegalAccessException {
<span class="udiff-line-added">+         if (caller.allowedModes == Lookup.TRUSTED) {</span>
<span class="udiff-line-added">+             return new Lookup(targetClass);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
          SecurityManager sm = System.getSecurityManager();
          if (sm != null) sm.checkPermission(ACCESS_PERMISSION);
          if (targetClass.isPrimitive())
              throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);
          if (targetClass.isArray())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -260,10 +265,61 @@</span>
              }
          }
          return Lookup.newLookup(targetClass, newPreviousClass, newModes);
      }
  
<span class="udiff-line-added">+     /**</span>
<span class="udiff-line-added">+      * Returns the &lt;em&gt;class data&lt;/em&gt; associated with the lookup class</span>
<span class="udiff-line-added">+      * of the specified {@code Lookup} object, or {@code null}.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;p&gt; Classes can be created with class data by calling</span>
<span class="udiff-line-added">+      * {@link Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)</span>
<span class="udiff-line-added">+      * Lookup::defineHiddenClassWithClassData}.</span>
<span class="udiff-line-added">+      * A hidden class with a class data behaves as if the hidden class</span>
<span class="udiff-line-added">+      * has a private static final unnamed field pre-initialized with</span>
<span class="udiff-line-added">+      * the class data and this method is equivalent as if calling</span>
<span class="udiff-line-added">+      * {@link ConstantBootstraps#getStaticFinal(Lookup, String, Class)} to</span>
<span class="udiff-line-added">+      * obtain the value of such field corresponding to the class data.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * &lt;p&gt; The {@linkplain Lookup#lookupModes() lookup modes} for this lookup</span>
<span class="udiff-line-added">+      * must have {@link Lookup#ORIGINAL ORIGINAL} access in order to retrieve</span>
<span class="udiff-line-added">+      * the class data.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @apiNote</span>
<span class="udiff-line-added">+      * This method can be called as a bootstrap method for a dynamically computed</span>
<span class="udiff-line-added">+      * constant.  A framework can create a hidden class with class data, for</span>
<span class="udiff-line-added">+      * example that can be {@code List.of(o1, o2, o3....)} containing more than</span>
<span class="udiff-line-added">+      * one live object.  The class data is accessible only to the lookup object</span>
<span class="udiff-line-added">+      * created by the original caller but inaccessible to other members</span>
<span class="udiff-line-added">+      * in the same nest.  If a framework passes security sensitive live objects</span>
<span class="udiff-line-added">+      * to a hidden class via class data, it is recommended to load the value</span>
<span class="udiff-line-added">+      * of class data as a dynamically computed constant instead of storing</span>
<span class="udiff-line-added">+      * the live objects in private fields which are accessible to other</span>
<span class="udiff-line-added">+      * nestmates.</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * @param &lt;T&gt; the type to cast the class data object to</span>
<span class="udiff-line-added">+      * @param caller the lookup context describing the class performing the</span>
<span class="udiff-line-added">+      * operation (normally stacked by the JVM)</span>
<span class="udiff-line-added">+      * @param name ignored</span>
<span class="udiff-line-added">+      * @param type the type of the class data</span>
<span class="udiff-line-added">+      * @return the value of the class data if present in the lookup class;</span>
<span class="udiff-line-added">+      * otherwise {@code null}</span>
<span class="udiff-line-added">+      * @throws IllegalAccessException if the lookup context does not have</span>
<span class="udiff-line-added">+      * original caller access</span>
<span class="udiff-line-added">+      * @throws ClassCastException if the class data cannot be converted to</span>
<span class="udiff-line-added">+      * the specified {@code type}</span>
<span class="udiff-line-added">+      * @see Lookup#defineHiddenClassWithClassData(byte[], Object, Lookup.ClassOption...)</span>
<span class="udiff-line-added">+      * @since 15</span>
<span class="udiff-line-added">+      */</span>
<span class="udiff-line-added">+     static &lt;T&gt; T classData(Lookup caller, String name, Class&lt;T&gt; type) throws IllegalAccessException {</span>
<span class="udiff-line-added">+         if (!caller.hasFullPrivilegeAccess()) {</span>
<span class="udiff-line-added">+             throw new IllegalAccessException(caller + &quot; does not have full privilege access&quot;);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         Object classData = MethodHandleNatives.classData(caller.lookupClass);</span>
<span class="udiff-line-added">+         return type.cast(classData);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /**
       * Performs an unchecked &quot;crack&quot; of a
       * &lt;a href=&quot;MethodHandleInfo.html#directmh&quot;&gt;direct method handle&lt;/a&gt;.
       * The result is as if the user had obtained a lookup object capable enough
       * to crack the target method handle, called
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -515,11 +571,11 @@</span>
       * &lt;p&gt;
       * The JVM imposes a similar requirement on {@code invokespecial} instruction,
       * that the receiver argument must match both the resolved method &lt;em&gt;and&lt;/em&gt;
       * the current class.  Again, this requirement is enforced by narrowing the
       * type of the leading parameter to the resulting method handle.
<span class="udiff-line-modified-removed">-      * (See the Java Virtual Machine Specification, section {@jmvs 4.10.1.9}.)</span>
<span class="udiff-line-modified-added">+      * (See the Java Virtual Machine Specification, section {@jvms 4.10.1.9}.)</span>
       * &lt;p&gt;
       * The JVM represents constructors and static initializer blocks as internal methods
       * with special names ({@code &quot;&lt;init&gt;&quot;} and {@code &quot;&lt;clinit&gt;&quot;}).
       * The internal syntax of invocation instructions allows them to refer to such internal
       * methods as if they were normal methods, but the JVM bytecode verifier rejects them.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1398,12 +1454,10 @@</span>
           * Must be called by from a method in this package,
           * which in turn is called by a method not in this package.
           */
          Lookup(Class&lt;?&gt; lookupClass) {
              this(lookupClass, null, FULL_POWER_MODES);
<span class="udiff-line-removed">-             // make sure we haven&#39;t accidentally picked up a privileged class:</span>
<span class="udiff-line-removed">-             checkUnprivilegedlookupClass(lookupClass);</span>
          }
  
          private Lookup(Class&lt;?&gt; lookupClass, Class&lt;?&gt; prevLookupClass, int allowedModes) {
              assert prevLookupClass == null || ((allowedModes &amp; MODULE) == 0
                      &amp;&amp; prevLookupClass.getModule() != lookupClass.getModule());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1506,11 +1560,11 @@</span>
                  &amp;&amp; !VerifyAccess.isSamePackage(this.lookupClass, requestedLookupClass)) {
                  newModes &amp;= ~(PACKAGE|PRIVATE|PROTECTED);
              }
              // Allow nestmate lookups to be created without special privilege:
              if ((newModes &amp; PRIVATE) != 0
<span class="udiff-line-modified-removed">-                 &amp;&amp; !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {</span>
<span class="udiff-line-modified-added">+                     &amp;&amp; !VerifyAccess.isSamePackageMember(this.lookupClass, requestedLookupClass)) {</span>
                  newModes &amp;= ~(PRIVATE|PROTECTED);
              }
              if ((newModes &amp; (PUBLIC|UNCONDITIONAL)) != 0
                  &amp;&amp; !VerifyAccess.isClassAccessible(requestedLookupClass, this.lookupClass, this.prevLookupClass, allowedModes)) {
                  // The requested class it not accessible from the lookup class.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1575,13 +1629,16 @@</span>
              if (newModes == oldModes) return this;  // return self if no change
              return newLookup(lookupClass(), previousLookupClass(), newModes);
          }
  
          /**
<span class="udiff-line-modified-removed">-          * Defines a class to the same class loader and in the same runtime package and</span>
<span class="udiff-line-modified-added">+          * Creates and links a class or interface from {@code bytes}</span>
<span class="udiff-line-added">+          * with the same class loader and in the same runtime package and</span>
           * {@linkplain java.security.ProtectionDomain protection domain} as this lookup&#39;s
<span class="udiff-line-modified-removed">-          * {@linkplain #lookupClass() lookup class}.</span>
<span class="udiff-line-modified-added">+          * {@linkplain #lookupClass() lookup class} as if calling</span>
<span class="udiff-line-added">+          * {@link ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)</span>
<span class="udiff-line-added">+          * ClassLoader::defineClass}.</span>
           *
           * &lt;p&gt; The {@linkplain #lookupModes() lookup modes} for this lookup must include
           * {@link #PACKAGE PACKAGE} access as default (package) members will be
           * accessible to the class. The {@code PACKAGE} lookup mode serves to authenticate
           * that the lookup object was created by a caller in the runtime package (or derived
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1600,85 +1657,557 @@</span>
           * #hasFullPrivilegeAccess() full privilege access}, its {@code checkPermission} method
           * is first called to check {@code RuntimePermission(&quot;defineClass&quot;)}. &lt;/p&gt;
           *
           * @param bytes the class bytes
           * @return the {@code Class} object for the class
<span class="udiff-line-added">+          * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access</span>
<span class="udiff-line-added">+          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure</span>
           * @throws IllegalArgumentException the bytes are for a class in a different package
           * to the lookup class
<span class="udiff-line-modified-removed">-          * @throws IllegalAccessException if this lookup does not have {@code PACKAGE} access</span>
<span class="udiff-line-modified-removed">-          * @throws LinkageError if the class is malformed ({@code ClassFormatError}), cannot be</span>
<span class="udiff-line-removed">-          * verified ({@code VerifyError}), is already defined, or another linkage error occurs</span>
<span class="udiff-line-modified-added">+          * @throws VerifyError if the newly created class cannot be verified</span>
<span class="udiff-line-modified-added">+          * @throws LinkageError if the newly created class cannot be linked for any other reason</span>
           * @throws SecurityException if a security manager is present and it
           *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
           * @throws NullPointerException if {@code bytes} is {@code null}
           * @since 9
           * @spec JPMS
           * @see Lookup#privateLookupIn
           * @see Lookup#dropLookupMode
           * @see ClassLoader#defineClass(String,byte[],int,int,ProtectionDomain)
           */
          public Class&lt;?&gt; defineClass(byte[] bytes) throws IllegalAccessException {
<span class="udiff-line-added">+             ensureDefineClassPermission();</span>
<span class="udiff-line-added">+             if ((lookupModes() &amp; PACKAGE) == 0)</span>
<span class="udiff-line-added">+                 throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);</span>
<span class="udiff-line-added">+             return makeClassDefiner(bytes.clone()).defineClass(false);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         private void ensureDefineClassPermission() {</span>
<span class="udiff-line-added">+             if (allowedModes == TRUSTED)  return;</span>
<span class="udiff-line-added">+ </span>
              if (!hasFullPrivilegeAccess()) {
                  SecurityManager sm = System.getSecurityManager();
                  if (sm != null)
                      sm.checkPermission(new RuntimePermission(&quot;defineClass&quot;));
              }
<span class="udiff-line-modified-removed">-             if ((lookupModes() &amp; PACKAGE) == 0)</span>
<span class="udiff-line-modified-removed">-                 throw new IllegalAccessException(&quot;Lookup does not have PACKAGE access&quot;);</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * The set of class options that specify whether a hidden class created by</span>
<span class="udiff-line-added">+          * {@link Lookup#defineHiddenClass(byte[], boolean, ClassOption...)</span>
<span class="udiff-line-added">+          * Lookup::defineHiddenClass} method is dynamically added as a new member</span>
<span class="udiff-line-added">+          * to the nest of a lookup class and/or whether a hidden class has</span>
<span class="udiff-line-added">+          * a strong relationship with the class loader marked as its defining loader.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @since 15</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public enum ClassOption {</span>
<span class="udiff-line-added">+             /**</span>
<span class="udiff-line-added">+              * Specifies that a hidden class be added to {@linkplain Class#getNestHost nest}</span>
<span class="udiff-line-added">+              * of a lookup class as a nestmate.</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              * &lt;p&gt; A hidden nestmate class has access to the private members of all</span>
<span class="udiff-line-added">+              * classes and interfaces in the same nest.</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              * @see Class#getNestHost()</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             NESTMATE(NESTMATE_CLASS),</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /**</span>
<span class="udiff-line-added">+              * Specifies that a hidden class has a &lt;em&gt;strong&lt;/em&gt;</span>
<span class="udiff-line-added">+              * relationship with the class loader marked as its defining loader,</span>
<span class="udiff-line-added">+              * as a normal class or interface has with its own defining loader.</span>
<span class="udiff-line-added">+              * This means that the hidden class may be unloaded if and only if</span>
<span class="udiff-line-added">+              * its defining loader is not reachable and thus may be reclaimed</span>
<span class="udiff-line-added">+              * by a garbage collector (JLS 12.7).</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              * &lt;p&gt; By default, a hidden class or interface may be unloaded</span>
<span class="udiff-line-added">+              * even if the class loader that is marked as its defining loader is</span>
<span class="udiff-line-added">+              * &lt;a href=&quot;../ref/package.html#reachability&quot;&gt;reachable&lt;/a&gt;.</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              * @jls 12.7 Unloading of Classes and Interfaces</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             STRONG(STRONG_LOADER_LINK);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /* the flag value is used by VM at define class time */</span>
<span class="udiff-line-added">+             private final int flag;</span>
<span class="udiff-line-added">+             ClassOption(int flag) {</span>
<span class="udiff-line-added">+                 this.flag = flag;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             static int optionsToFlag(Set&lt;ClassOption&gt; options) {</span>
<span class="udiff-line-added">+                 int flags = 0;</span>
<span class="udiff-line-added">+                 for (ClassOption cp : options) {</span>
<span class="udiff-line-added">+                     flags |= cp.flag;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return flags;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-             // parse class bytes to get class name (in internal form)</span>
<span class="udiff-line-modified-removed">-             bytes = bytes.clone();</span>
<span class="udiff-line-modified-removed">-             String name;</span>
<span class="udiff-line-modified-added">+         /**</span>
<span class="udiff-line-modified-added">+          * Creates a &lt;em&gt;hidden&lt;/em&gt; class or interface from {@code bytes},</span>
<span class="udiff-line-modified-added">+          * returning a {@code Lookup} on the newly created class or interface.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; Ordinarily, a class or interface {@code C} is created by a class loader,</span>
<span class="udiff-line-added">+          * which either defines {@code C} directly or delegates to another class loader.</span>
<span class="udiff-line-added">+          * A class loader defines {@code C} directly by invoking</span>
<span class="udiff-line-added">+          * {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)</span>
<span class="udiff-line-added">+          * ClassLoader::defineClass}, which causes the Java Virtual Machine</span>
<span class="udiff-line-added">+          * to derive {@code C} from a purported representation in {@code class} file format.</span>
<span class="udiff-line-added">+          * In situations where use of a class loader is undesirable, a class or interface</span>
<span class="udiff-line-added">+          * {@code C} can be created by this method instead. This method is capable of</span>
<span class="udiff-line-added">+          * defining {@code C}, and thereby creating it, without invoking</span>
<span class="udiff-line-added">+          * {@code ClassLoader::defineClass}.</span>
<span class="udiff-line-added">+          * Instead, this method defines {@code C} as if by arranging for</span>
<span class="udiff-line-added">+          * the Java Virtual Machine to derive a nonarray class or interface {@code C}</span>
<span class="udiff-line-added">+          * from a purported representation in {@code class} file format</span>
<span class="udiff-line-added">+          * using the following rules:</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;ol&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt; The {@linkplain #lookupModes() lookup modes} for this {@code Lookup}</span>
<span class="udiff-line-added">+          * must include {@linkplain #hasFullPrivilegeAccess() full privilege} access.</span>
<span class="udiff-line-added">+          * This level of access is needed to create {@code C} in the module</span>
<span class="udiff-line-added">+          * of the lookup class of this {@code Lookup}.&lt;/li&gt;</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;li&gt; The purported representation in {@code bytes} must be a {@code ClassFile}</span>
<span class="udiff-line-added">+          * structure of a supported major and minor version. The major and minor version</span>
<span class="udiff-line-added">+          * may differ from the {@code class} file version of the lookup class of this</span>
<span class="udiff-line-added">+          * {@code Lookup}.&lt;/li&gt;</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;li&gt; The value of {@code this_class} must be a valid index in the</span>
<span class="udiff-line-added">+          * {@code constant_pool} table, and the entry at that index must be a valid</span>
<span class="udiff-line-added">+          * {@code CONSTANT_Class_info} structure. Let {@code N} be the binary name</span>
<span class="udiff-line-added">+          * encoded in internal form that is specified by this structure. {@code N} must</span>
<span class="udiff-line-added">+          * denote a class or interface in the same package as the lookup class.&lt;/li&gt;</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;li&gt; Let {@code CN} be the string {@code N + &quot;.&quot; + &lt;suffix&gt;},</span>
<span class="udiff-line-added">+          * where {@code &lt;suffix&gt;} is an unqualified name.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; Let {@code newBytes} be the {@code ClassFile} structure given by</span>
<span class="udiff-line-added">+          * {@code bytes} with an additional entry in the {@code constant_pool} table,</span>
<span class="udiff-line-added">+          * indicating a {@code CONSTANT_Utf8_info} structure for {@code CN}, and</span>
<span class="udiff-line-added">+          * where the {@code CONSTANT_Class_info} structure indicated by {@code this_class}</span>
<span class="udiff-line-added">+          * refers to the new {@code CONSTANT_Utf8_info} structure.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; Let {@code L} be the defining class loader of the lookup class of this {@code Lookup}.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; {@code C} is derived with name {@code CN}, class loader {@code L}, and</span>
<span class="udiff-line-added">+          * purported representation {@code newBytes} as if by the rules of JVMS {@jvms 5.3.5},</span>
<span class="udiff-line-added">+          * with the following adjustments:</span>
<span class="udiff-line-added">+          * &lt;ul&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt; The constant indicated by {@code this_class} is permitted to specify a name</span>
<span class="udiff-line-added">+          * that includes a single {@code &quot;.&quot;} character, even though this is not a valid</span>
<span class="udiff-line-added">+          * binary class or interface name in internal form.&lt;/li&gt;</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;li&gt; The Java Virtual Machine marks {@code L} as the defining class loader of {@code C},</span>
<span class="udiff-line-added">+          * but no class loader is recorded as an initiating class loader of {@code C}.&lt;/li&gt;</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;li&gt; {@code C} is considered to have the same runtime</span>
<span class="udiff-line-added">+          * {@linkplain Class#getPackage() package}, {@linkplain Class#getModule() module}</span>
<span class="udiff-line-added">+          * and {@linkplain java.security.ProtectionDomain protection domain}</span>
<span class="udiff-line-added">+          * as the lookup class of this {@code Lookup}.</span>
<span class="udiff-line-added">+          * &lt;li&gt; Let {@code GN} be the binary name obtained by taking {@code N}</span>
<span class="udiff-line-added">+          * (a binary name encoded in internal form) and replacing ASCII forward slashes with</span>
<span class="udiff-line-added">+          * ASCII periods. For the instance of {@link java.lang.Class} representing {@code C}:</span>
<span class="udiff-line-added">+          * &lt;ul&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt; {@link Class#getName()} returns the string {@code GN + &quot;/&quot; + &lt;suffix&gt;},</span>
<span class="udiff-line-added">+          *      even though this is not a valid binary class or interface name.&lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt; {@link Class#descriptorString()} returns the string</span>
<span class="udiff-line-added">+          *      {@code &quot;L&quot; + N + &quot;.&quot; + &lt;suffix&gt; + &quot;;&quot;},</span>
<span class="udiff-line-added">+          *      even though this is not a valid type descriptor name.&lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt; {@link Class#describeConstable()} returns an empty optional as {@code C}</span>
<span class="udiff-line-added">+          *      cannot be described in {@linkplain java.lang.constant.ClassDesc nominal form}.&lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;/ul&gt;</span>
<span class="udiff-line-added">+          * &lt;/ul&gt;</span>
<span class="udiff-line-added">+          * &lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;/ol&gt;</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; After {@code C} is derived, it is linked by the Java Virtual Machine.</span>
<span class="udiff-line-added">+          * Linkage occurs as specified in JVMS {@jvms 5.4.3}, with the following adjustments:</span>
<span class="udiff-line-added">+          * &lt;ul&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt; During verification, whenever it is necessary to load the class named</span>
<span class="udiff-line-added">+          * {@code CN}, the attempt succeeds, producing class {@code C}. No request is</span>
<span class="udiff-line-added">+          * made of any class loader.&lt;/li&gt;</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;li&gt; On any attempt to resolve the entry in the run-time constant pool indicated</span>
<span class="udiff-line-added">+          * by {@code this_class}, the symbolic reference is considered to be resolved to</span>
<span class="udiff-line-added">+          * {@code C} and resolution always succeeds immediately.&lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;/ul&gt;</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; If the {@code initialize} parameter is {@code true},</span>
<span class="udiff-line-added">+          * then {@code C} is initialized by the Java Virtual Machine.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; The newly created class or interface {@code C} serves as the</span>
<span class="udiff-line-added">+          * {@linkplain #lookupClass() lookup class} of the {@code Lookup} object</span>
<span class="udiff-line-added">+          * returned by this method. {@code C} is &lt;em&gt;hidden&lt;/em&gt; in the sense that</span>
<span class="udiff-line-added">+          * no other class or interface can refer to {@code C} via a constant pool entry.</span>
<span class="udiff-line-added">+          * That is, a hidden class or interface cannot be named as a supertype, a field type,</span>
<span class="udiff-line-added">+          * a method parameter type, or a method return type by any other class.</span>
<span class="udiff-line-added">+          * This is because a hidden class or interface does not have a binary name, so</span>
<span class="udiff-line-added">+          * there is no internal form available to record in any class&#39;s constant pool.</span>
<span class="udiff-line-added">+          * A hidden class or interface is not discoverable by {@link Class#forName(String, boolean, ClassLoader)},</span>
<span class="udiff-line-added">+          * {@link ClassLoader#loadClass(String, boolean)}, or {@link #findClass(String)}, and</span>
<span class="udiff-line-added">+          * is not {@linkplain java.lang.instrument.Instrumentation#isModifiableClass(Class)</span>
<span class="udiff-line-added">+          * modifiable} by Java agents or tool agents using the &lt;a href=&quot;{@docRoot}/../specs/jvmti.html&quot;&gt;</span>
<span class="udiff-line-added">+          * JVM Tool Interface&lt;/a&gt;.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; A class or interface created by</span>
<span class="udiff-line-added">+          * {@linkplain ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)</span>
<span class="udiff-line-added">+          * a class loader} has a strong relationship with that class loader.</span>
<span class="udiff-line-added">+          * That is, every {@code Class} object contains a reference to the {@code ClassLoader}</span>
<span class="udiff-line-added">+          * that {@linkplain Class#getClassLoader() defined it}.</span>
<span class="udiff-line-added">+          * This means that a class created by a class loader may be unloaded if and</span>
<span class="udiff-line-added">+          * only if its defining loader is not reachable and thus may be reclaimed</span>
<span class="udiff-line-added">+          * by a garbage collector (JLS 12.7).</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * By default, however, a hidden class or interface may be unloaded even if</span>
<span class="udiff-line-added">+          * the class loader that is marked as its defining loader is</span>
<span class="udiff-line-added">+          * &lt;a href=&quot;../ref/package.html#reachability&quot;&gt;reachable&lt;/a&gt;.</span>
<span class="udiff-line-added">+          * This behavior is useful when a hidden class or interface serves multiple</span>
<span class="udiff-line-added">+          * classes defined by arbitrary class loaders.  In other cases, a hidden</span>
<span class="udiff-line-added">+          * class or interface may be linked to a single class (or a small number of classes)</span>
<span class="udiff-line-added">+          * with the same defining loader as the hidden class or interface.</span>
<span class="udiff-line-added">+          * In such cases, where the hidden class or interface must be coterminous</span>
<span class="udiff-line-added">+          * with a normal class or interface, the {@link ClassOption#STRONG STRONG}</span>
<span class="udiff-line-added">+          * option may be passed in {@code options}.</span>
<span class="udiff-line-added">+          * This arranges for a hidden class to have the same strong relationship</span>
<span class="udiff-line-added">+          * with the class loader marked as its defining loader,</span>
<span class="udiff-line-added">+          * as a normal class or interface has with its own defining loader.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * If {@code STRONG} is not used, then the invoker of {@code defineHiddenClass}</span>
<span class="udiff-line-added">+          * may still prevent a hidden class or interface from being</span>
<span class="udiff-line-added">+          * unloaded by ensuring that the {@code Class} object is reachable.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; The unloading characteristics are set for each hidden class when it is</span>
<span class="udiff-line-added">+          * defined, and cannot be changed later.  An advantage of allowing hidden classes</span>
<span class="udiff-line-added">+          * to be unloaded independently of the class loader marked as their defining loader</span>
<span class="udiff-line-added">+          * is that a very large number of hidden classes may be created by an application.</span>
<span class="udiff-line-added">+          * In contrast, if {@code STRONG} is used, then the JVM may run out of memory,</span>
<span class="udiff-line-added">+          * just as if normal classes were created by class loaders.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; Classes and interfaces in a nest are allowed to have mutual access to</span>
<span class="udiff-line-added">+          * their private members.  The nest relationship is determined by</span>
<span class="udiff-line-added">+          * the {@code NestHost} attribute (JVMS {@jvms 4.7.28}) and</span>
<span class="udiff-line-added">+          * the {@code NestMembers} attribute (JVMS {@jvms 4.7.29}) in a {@code class} file.</span>
<span class="udiff-line-added">+          * By default, a hidden class belongs to a nest consisting only of itself</span>
<span class="udiff-line-added">+          * because a hidden class has no binary name.</span>
<span class="udiff-line-added">+          * The {@link ClassOption#NESTMATE NESTMATE} option can be passed in {@code options}</span>
<span class="udiff-line-added">+          * to create a hidden class or interface {@code C} as a member of a nest.</span>
<span class="udiff-line-added">+          * The nest to which {@code C} belongs is not based on any {@code NestHost} attribute</span>
<span class="udiff-line-added">+          * in the {@code ClassFile} structure from which {@code C} was derived.</span>
<span class="udiff-line-added">+          * Instead, the following rules determine the nest host of {@code C}:</span>
<span class="udiff-line-added">+          * &lt;ul&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt;If the nest host of the lookup class of this {@code Lookup} has previously</span>
<span class="udiff-line-added">+          *     been determined, then let {@code H} be the nest host of the lookup class.</span>
<span class="udiff-line-added">+          *     Otherwise, the nest host of the lookup class is determined using the</span>
<span class="udiff-line-added">+          *     algorithm in JVMS {@jvms 5.4.4}, yielding {@code H}.&lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;li&gt;The nest host of {@code C} is determined to be {@code H},</span>
<span class="udiff-line-added">+          *     the nest host of the lookup class.&lt;/li&gt;</span>
<span class="udiff-line-added">+          * &lt;/ul&gt;</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; A hidden class or interface may be serializable, but this requires a custom</span>
<span class="udiff-line-added">+          * serialization mechanism in order to ensure that instances are properly serialized</span>
<span class="udiff-line-added">+          * and deserialized. The default serialization mechanism supports only classes and</span>
<span class="udiff-line-added">+          * interfaces that are discoverable by their class name.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @param bytes the bytes that make up the class data,</span>
<span class="udiff-line-added">+          * in the format of a valid {@code class} file as defined by</span>
<span class="udiff-line-added">+          * &lt;cite&gt;The Java Virtual Machine Specification&lt;/cite&gt;.</span>
<span class="udiff-line-added">+          * @param initialize if {@code true} the class will be initialized.</span>
<span class="udiff-line-added">+          * @param options {@linkplain ClassOption class options}</span>
<span class="udiff-line-added">+          * @return the {@code Lookup} object on the hidden class</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @throws IllegalAccessException if this {@code Lookup} does not have</span>
<span class="udiff-line-added">+          * {@linkplain #hasFullPrivilegeAccess() full privilege} access</span>
<span class="udiff-line-added">+          * @throws SecurityException if a security manager is present and it</span>
<span class="udiff-line-added">+          * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
<span class="udiff-line-added">+          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure</span>
<span class="udiff-line-added">+          * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version</span>
<span class="udiff-line-added">+          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="udiff-line-added">+          * {@bytes} denotes a class in a different package than the lookup class</span>
<span class="udiff-line-added">+          * @throws IncompatibleClassChangeError if the class or interface named as</span>
<span class="udiff-line-added">+          * the direct superclass of {@code C} is in fact an interface, or if any of the classes</span>
<span class="udiff-line-added">+          * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces</span>
<span class="udiff-line-added">+          * @throws ClassCircularityError if any of the superclasses or superinterfaces of</span>
<span class="udiff-line-added">+          * {@code C} is {@code C} itself</span>
<span class="udiff-line-added">+          * @throws VerifyError if the newly created class cannot be verified</span>
<span class="udiff-line-added">+          * @throws LinkageError if the newly created class cannot be linked for any other reason</span>
<span class="udiff-line-added">+          * @throws NullPointerException if any parameter is {@code null}</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @since 15</span>
<span class="udiff-line-added">+          * @see Class#isHidden()</span>
<span class="udiff-line-added">+          * @jvms 4.2.1 Binary Class and Interface Names</span>
<span class="udiff-line-added">+          * @jvms 4.2.2 Unqualified Names</span>
<span class="udiff-line-added">+          * @jvms 4.7.28 The {@code NestHost} Attribute</span>
<span class="udiff-line-added">+          * @jvms 4.7.29 The {@code NestMembers} Attribute</span>
<span class="udiff-line-added">+          * @jvms 5.4.3.1 Class and Interface Resolution</span>
<span class="udiff-line-added">+          * @jvms 5.4.4 Access Control</span>
<span class="udiff-line-added">+          * @jvms 5.3.5 Deriving a {@code Class} from a {@code class} File Representation</span>
<span class="udiff-line-added">+          * @jvms 5.4 Linking</span>
<span class="udiff-line-added">+          * @jvms 5.5 Initialization</span>
<span class="udiff-line-added">+          * @jls 12.7 Unloading of Classes and Interfaces</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         public Lookup defineHiddenClass(byte[] bytes, boolean initialize, ClassOption... options)</span>
<span class="udiff-line-added">+                 throws IllegalAccessException</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             Objects.requireNonNull(bytes);</span>
<span class="udiff-line-added">+             Objects.requireNonNull(options);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             ensureDefineClassPermission();</span>
<span class="udiff-line-added">+             if (!hasFullPrivilegeAccess()) {</span>
<span class="udiff-line-added">+                 throw new IllegalAccessException(this + &quot; does not have full privilege access&quot;);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false).defineClassAsLookup(initialize);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Creates a &lt;em&gt;hidden&lt;/em&gt; class or interface from {@code bytes} with associated</span>
<span class="udiff-line-added">+          * {@linkplain MethodHandles#classData(Lookup, String, Class) class data},</span>
<span class="udiff-line-added">+          * returning a {@code Lookup} on the newly created class or interface.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; This method is equivalent to calling</span>
<span class="udiff-line-added">+          * {@link #defineHiddenClass(byte[], boolean, ClassOption...) defineHiddenClass(bytes, true, options)}</span>
<span class="udiff-line-added">+          * as if the hidden class has a private static final unnamed field whose value</span>
<span class="udiff-line-added">+          * is initialized to {@code classData} right before the class initializer is</span>
<span class="udiff-line-added">+          * executed.  The newly created class is linked and initialized by the Java</span>
<span class="udiff-line-added">+          * Virtual Machine.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * &lt;p&gt; The {@link MethodHandles#classData(Lookup, String, Class) MethodHandles::classData}</span>
<span class="udiff-line-added">+          * method can be used to retrieve the {@code classData}.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @param bytes     the class bytes</span>
<span class="udiff-line-added">+          * @param classData pre-initialized class data</span>
<span class="udiff-line-added">+          * @param options   {@linkplain ClassOption class options}</span>
<span class="udiff-line-added">+          * @return the {@code Lookup} object on the hidden class</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @throws IllegalAccessException if this {@code Lookup} does not have</span>
<span class="udiff-line-added">+          * {@linkplain #hasFullPrivilegeAccess() full privilege} access</span>
<span class="udiff-line-added">+          * @throws SecurityException if a security manager is present and it</span>
<span class="udiff-line-added">+          * &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
<span class="udiff-line-added">+          * @throws ClassFormatError if {@code bytes} is not a {@code ClassFile} structure</span>
<span class="udiff-line-added">+          * @throws UnsupportedClassVersionError if {@code bytes} is not of a supported major or minor version</span>
<span class="udiff-line-added">+          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="udiff-line-added">+          * {@bytes} denotes a class in a different package than the lookup class</span>
<span class="udiff-line-added">+          * @throws IncompatibleClassChangeError if the class or interface named as</span>
<span class="udiff-line-added">+          * the direct superclass of {@code C} is in fact an interface, or if any of the classes</span>
<span class="udiff-line-added">+          * or interfaces named as direct superinterfaces of {@code C} are not in fact interfaces</span>
<span class="udiff-line-added">+          * @throws ClassCircularityError if any of the superclasses or superinterfaces of</span>
<span class="udiff-line-added">+          * {@code C} is {@code C} itself</span>
<span class="udiff-line-added">+          * @throws VerifyError if the newly created class cannot be verified</span>
<span class="udiff-line-added">+          * @throws LinkageError if the newly created class cannot be linked for any other reason</span>
<span class="udiff-line-added">+          * @throws NullPointerException if any parameter is {@code null}</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @since 15</span>
<span class="udiff-line-added">+          * @see Lookup#defineHiddenClass(byte[], boolean, ClassOption...)</span>
<span class="udiff-line-added">+          * @see Class#isHidden()</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         /* package-private */ Lookup defineHiddenClassWithClassData(byte[] bytes, Object classData, ClassOption... options)</span>
<span class="udiff-line-added">+                 throws IllegalAccessException</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             Objects.requireNonNull(bytes);</span>
<span class="udiff-line-added">+             Objects.requireNonNull(classData);</span>
<span class="udiff-line-added">+             Objects.requireNonNull(options);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             ensureDefineClassPermission();</span>
<span class="udiff-line-added">+             if (!hasFullPrivilegeAccess()) {</span>
<span class="udiff-line-added">+                 throw new IllegalAccessException(this + &quot; does not have full privilege access&quot;);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             return makeHiddenClassDefiner(bytes.clone(), Set.of(options), false)</span>
<span class="udiff-line-added">+                        .defineClassAsLookup(true, classData);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /*</span>
<span class="udiff-line-added">+          * Validates the given bytes to be a class or interface and the class name</span>
<span class="udiff-line-added">+          * is in the same package as the lookup class.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * This method returns the class name.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private String validateAndGetClassName(byte[] bytes) {</span>
              try {
                  ClassReader reader = new ClassReader(bytes);
<span class="udiff-line-modified-removed">-                 name = reader.getClassName();</span>
<span class="udiff-line-modified-added">+                 if ((reader.getAccess() &amp; Opcodes.ACC_MODULE) != 0) {</span>
<span class="udiff-line-added">+                     throw newIllegalArgumentException(&quot;Not a class or interface: ACC_MODULE flag is set&quot;);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 String name = reader.getClassName().replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="udiff-line-added">+                 int index = name.lastIndexOf(&#39;.&#39;);</span>
<span class="udiff-line-added">+                 String pn = (index == -1) ? &quot;&quot; : name.substring(0, index);</span>
<span class="udiff-line-added">+                 if (!pn.equals(lookupClass.getPackageName())) {</span>
<span class="udiff-line-added">+                     throw newIllegalArgumentException(name + &quot; not in same package as lookup class: &quot; +</span>
<span class="udiff-line-added">+                             lookupClass.getName());</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 return name;</span>
<span class="udiff-line-added">+             } catch (IllegalArgumentException e) {</span>
<span class="udiff-line-added">+                 throw e;</span>
              } catch (RuntimeException e) {
                  // ASM exceptions are poorly specified
                  ClassFormatError cfe = new ClassFormatError();
                  cfe.initCause(e);
                  throw cfe;
              }
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-             // get package and class name in binary form</span>
<span class="udiff-line-modified-removed">-             String cn, pn;</span>
<span class="udiff-line-modified-removed">-             int index = name.lastIndexOf(&#39;/&#39;);</span>
<span class="udiff-line-modified-removed">-             if (index == -1) {</span>
<span class="udiff-line-modified-removed">-                 cn = name;</span>
<span class="udiff-line-modified-removed">-                 pn = &quot;&quot;;</span>
<span class="udiff-line-modified-removed">-             } else {</span>
<span class="udiff-line-modified-removed">-                 cn = name.replace(&#39;/&#39;, &#39;.&#39;);</span>
<span class="udiff-line-modified-removed">-                 pn = cn.substring(0, index);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         /*</span>
<span class="udiff-line-modified-added">+          * Returns a ClassDefiner that creates a {@code Class} object of a normal class</span>
<span class="udiff-line-modified-added">+          * from the given bytes.</span>
<span class="udiff-line-modified-added">+          *</span>
<span class="udiff-line-modified-added">+          * Caller should make a defensive copy of the arguments if needed</span>
<span class="udiff-line-modified-added">+          * before calling this factory method.</span>
<span class="udiff-line-modified-added">+          *</span>
<span class="udiff-line-modified-added">+          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="udiff-line-added">+          * {@bytes} denotes a class in a different package than the lookup class</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         private ClassDefiner makeClassDefiner(byte[] bytes) {</span>
<span class="udiff-line-added">+             return new ClassDefiner(this, validateAndGetClassName(bytes), bytes, STRONG_LOADER_LINK);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class</span>
<span class="udiff-line-added">+          * from the given bytes.  The name must be in the same package as the lookup class.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * Caller should make a defensive copy of the arguments if needed</span>
<span class="udiff-line-added">+          * before calling this factory method.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @param bytes   class bytes</span>
<span class="udiff-line-added">+          * @return ClassDefiner that defines a hidden class of the given bytes.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="udiff-line-added">+          * {@bytes} denotes a class in a different package than the lookup class</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         ClassDefiner makeHiddenClassDefiner(byte[] bytes) {</span>
<span class="udiff-line-added">+             return makeHiddenClassDefiner(validateAndGetClassName(bytes), bytes, Set.of(), false);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class</span>
<span class="udiff-line-added">+          * from the given bytes and options.</span>
<span class="udiff-line-added">+          * The name must be in the same package as the lookup class.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * Caller should make a defensive copy of the arguments if needed</span>
<span class="udiff-line-added">+          * before calling this factory method.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @param bytes   class bytes</span>
<span class="udiff-line-added">+          * @param options class options</span>
<span class="udiff-line-added">+          * @param accessVmAnnotations true to give the hidden class access to VM annotations</span>
<span class="udiff-line-added">+          * @return ClassDefiner that defines a hidden class of the given bytes and options</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @throws IllegalArgumentException if {@code bytes} is not a class or interface or</span>
<span class="udiff-line-added">+          * {@bytes} denotes a class in a different package than the lookup class</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         ClassDefiner makeHiddenClassDefiner(byte[] bytes,</span>
<span class="udiff-line-added">+                                             Set&lt;ClassOption&gt; options,</span>
<span class="udiff-line-added">+                                             boolean accessVmAnnotations) {</span>
<span class="udiff-line-added">+             return makeHiddenClassDefiner(validateAndGetClassName(bytes), bytes, options, accessVmAnnotations);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class</span>
<span class="udiff-line-added">+          * from the given bytes.  No package name check on the given name.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @param name    fully-qualified name that specifies the prefix of the hidden class</span>
<span class="udiff-line-added">+          * @param bytes   class bytes</span>
<span class="udiff-line-added">+          * @return ClassDefiner that defines a hidden class of the given bytes.</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes) {</span>
<span class="udiff-line-added">+             return makeHiddenClassDefiner(name, bytes, Set.of(), false);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         /**</span>
<span class="udiff-line-added">+          * Returns a ClassDefiner that creates a {@code Class} object of a hidden class</span>
<span class="udiff-line-added">+          * from the given bytes and options.  No package name check on the given name.</span>
<span class="udiff-line-added">+          *</span>
<span class="udiff-line-added">+          * @param name the name of the class and the name in the class bytes is ignored.</span>
<span class="udiff-line-added">+          * @param bytes class bytes</span>
<span class="udiff-line-added">+          * @param options class options</span>
<span class="udiff-line-added">+          * @param accessVmAnnotations true to give the hidden class access to VM annotations</span>
<span class="udiff-line-added">+          */</span>
<span class="udiff-line-added">+         ClassDefiner makeHiddenClassDefiner(String name,</span>
<span class="udiff-line-added">+                                             byte[] bytes,</span>
<span class="udiff-line-added">+                                             Set&lt;ClassOption&gt; options,</span>
<span class="udiff-line-added">+                                             boolean accessVmAnnotations) {</span>
<span class="udiff-line-added">+             int flags = HIDDEN_CLASS | ClassOption.optionsToFlag(options);</span>
<span class="udiff-line-added">+             if (accessVmAnnotations | VM.isSystemDomainLoader(lookupClass.getClassLoader())) {</span>
<span class="udiff-line-added">+                 // jdk.internal.vm.annotations are permitted for classes</span>
<span class="udiff-line-added">+                 // defined to boot loader and platform loader</span>
<span class="udiff-line-added">+                 flags |= ACCESS_VM_ANNOTATIONS;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             return new ClassDefiner(this, name, bytes, flags);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         static class ClassDefiner {</span>
<span class="udiff-line-added">+             private final Lookup lookup;</span>
<span class="udiff-line-added">+             private final String name;</span>
<span class="udiff-line-added">+             private final byte[] bytes;</span>
<span class="udiff-line-added">+             private final int classFlags;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             private ClassDefiner(Lookup lookup, String name, byte[] bytes, int flags) {</span>
<span class="udiff-line-added">+                 assert ((flags &amp; HIDDEN_CLASS) != 0 || (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK);</span>
<span class="udiff-line-added">+                 this.lookup = lookup;</span>
<span class="udiff-line-added">+                 this.bytes = bytes;</span>
<span class="udiff-line-added">+                 this.classFlags = flags;</span>
<span class="udiff-line-added">+                 this.name = name;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             String className() {</span>
<span class="udiff-line-added">+                 return name;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             Class&lt;?&gt; defineClass(boolean initialize) {</span>
<span class="udiff-line-added">+                 return defineClass(initialize, null);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             Lookup defineClassAsLookup(boolean initialize) {</span>
<span class="udiff-line-added">+                 Class&lt;?&gt; c = defineClass(initialize, null);</span>
<span class="udiff-line-added">+                 return new Lookup(c, null, FULL_POWER_MODES);</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             /**</span>
<span class="udiff-line-added">+              * Defines the class of the given bytes and the given classData.</span>
<span class="udiff-line-added">+              * If {@code initialize} parameter is true, then the class will be initialized.</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              * @param initialize true if the class to be initialized</span>
<span class="udiff-line-added">+              * @param classData classData or null</span>
<span class="udiff-line-added">+              * @return the class</span>
<span class="udiff-line-added">+              *</span>
<span class="udiff-line-added">+              * @throws LinkageError linkage error</span>
<span class="udiff-line-added">+              */</span>
<span class="udiff-line-added">+             Class&lt;?&gt; defineClass(boolean initialize, Object classData) {</span>
<span class="udiff-line-added">+                 Class&lt;?&gt; lookupClass = lookup.lookupClass();</span>
<span class="udiff-line-added">+                 ClassLoader loader = lookupClass.getClassLoader();</span>
<span class="udiff-line-added">+                 ProtectionDomain pd = (loader != null) ? lookup.lookupClassProtectionDomain() : null;</span>
<span class="udiff-line-added">+                 Class&lt;?&gt; c = JLA.defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);</span>
<span class="udiff-line-added">+                 assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();</span>
<span class="udiff-line-added">+                 return c;</span>
              }
<span class="udiff-line-modified-removed">-             if (!pn.equals(lookupClass.getPackageName())) {</span>
<span class="udiff-line-modified-removed">-                 throw new IllegalArgumentException(&quot;Class not in same package as lookup class&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             Lookup defineClassAsLookup(boolean initialize, Object classData) {</span>
<span class="udiff-line-added">+                 // initialize must be true if classData is non-null</span>
<span class="udiff-line-added">+                 assert classData == null || initialize == true;</span>
<span class="udiff-line-added">+                 Class&lt;?&gt; c = defineClass(initialize, classData);</span>
<span class="udiff-line-added">+                 return new Lookup(c, null, FULL_POWER_MODES);</span>
              }
  
<span class="udiff-line-modified-removed">-             // invoke the class loader&#39;s defineClass method</span>
<span class="udiff-line-modified-removed">-             ClassLoader loader = lookupClass.getClassLoader();</span>
<span class="udiff-line-modified-removed">-             ProtectionDomain pd = (loader != null) ? lookupClassProtectionDomain() : null;</span>
<span class="udiff-line-removed">-             String source = &quot;__Lookup_defineClass__&quot;;</span>
<span class="udiff-line-removed">-             Class&lt;?&gt; clazz = SharedSecrets.getJavaLangAccess().defineClass(loader, cn, bytes, pd, source);</span>
<span class="udiff-line-removed">-             return clazz;</span>
<span class="udiff-line-modified-added">+             private boolean isNestmate() {</span>
<span class="udiff-line-modified-added">+                 return (classFlags &amp; NESTMATE_CLASS) != 0;</span>
<span class="udiff-line-modified-added">+             }</span>
          }
  
          private ProtectionDomain lookupClassProtectionDomain() {
              ProtectionDomain pd = cachedProtectionDomain;
              if (pd == null) {
<span class="udiff-line-modified-removed">-                 cachedProtectionDomain = pd = protectionDomain(lookupClass);</span>
<span class="udiff-line-modified-added">+                 cachedProtectionDomain = pd = JLA.protectionDomain(lookupClass);</span>
              }
              return pd;
          }
  
<span class="udiff-line-removed">-         private ProtectionDomain protectionDomain(Class&lt;?&gt; clazz) {</span>
<span class="udiff-line-removed">-             PrivilegedAction&lt;ProtectionDomain&gt; pa = clazz::getProtectionDomain;</span>
<span class="udiff-line-removed">-             return AccessController.doPrivileged(pa);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
          // cached protection domain
          private volatile ProtectionDomain cachedProtectionDomain;
  
<span class="udiff-line-removed">- </span>
          // Make sure outer class is initialized first.
          static { IMPL_NAMES.getClass(); }
  
          /** Package-private version of lookup which is trusted. */
          static final Lookup IMPL_LOOKUP = new Lookup(Object.class, null, TRUSTED);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1687,10 +2216,12 @@</span>
           *  It can only be used to create method handles to publicly accessible
           *  members in packages that are exported unconditionally.
           */
          static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, null, UNCONDITIONAL);
  
<span class="udiff-line-added">+         static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();</span>
<span class="udiff-line-added">+ </span>
          private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
              String name = lookupClass.getName();
              if (name.startsWith(&quot;java.lang.invoke.&quot;))
                  throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1747,11 +2278,11 @@</span>
              case PUBLIC|PACKAGE:
              case PUBLIC|MODULE|PACKAGE:
                  return cname + &quot;/package&quot;;
              case FULL_POWER_MODES &amp; (~PROTECTED):
              case FULL_POWER_MODES &amp; ~(PROTECTED|MODULE):
<span class="udiff-line-modified-removed">-                     return cname + &quot;/private&quot;;</span>
<span class="udiff-line-modified-added">+                 return cname + &quot;/private&quot;;</span>
              case FULL_POWER_MODES:
              case FULL_POWER_MODES &amp; (~MODULE):
                  return cname;
              case TRUSTED:
                  return &quot;/trusted&quot;;  // internal only; not exported
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2661,12 +3192,17 @@</span>
              return unreflectField(f, true);
          }
  
          private MethodHandle unreflectField(Field f, boolean isSetter) throws IllegalAccessException {
              MemberName field = new MemberName(f, isSetter);
<span class="udiff-line-modified-removed">-             if (isSetter &amp;&amp; field.isStatic() &amp;&amp; field.isFinal())</span>
<span class="udiff-line-modified-removed">-                 throw field.makeAccessException(&quot;static final field has no write access&quot;, this);</span>
<span class="udiff-line-modified-added">+             if (isSetter &amp;&amp; field.isFinal()) {</span>
<span class="udiff-line-modified-added">+                 if (field.isStatic()) {</span>
<span class="udiff-line-added">+                     throw field.makeAccessException(&quot;static final field has no write access&quot;, this);</span>
<span class="udiff-line-added">+                 } else if (field.getDeclaringClass().isHidden()){</span>
<span class="udiff-line-added">+                     throw field.makeAccessException(&quot;final field in a hidden class has no write access&quot;, this);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
              assert(isSetter
                      ? MethodHandleNatives.refKindIsSetter(field.getReferenceKind())
                      : MethodHandleNatives.refKindIsGetter(field.getReferenceKind()));
              @SuppressWarnings(&quot;deprecation&quot;)
              Lookup lookup = f.isAccessible() ? IMPL_LOOKUP : this;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3225,12 +3761,12 @@</span>
                  if (!getField.getDeclaringClass().isAssignableFrom(lookupClass())) {
                      throw getField.makeAccessException(&quot;caller class must be a subclass below the method&quot;, lookupClass());
                  }
                  refc = lookupClass();
              }
<span class="udiff-line-modified-removed">-             boolean isWriteAllowedOnFinalFields = this.allowedModes == TRUSTED;</span>
<span class="udiff-line-modified-removed">-             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(), isWriteAllowedOnFinalFields);</span>
<span class="udiff-line-modified-added">+             return VarHandles.makeFieldHandle(getField, refc, getField.getFieldType(),</span>
<span class="udiff-line-modified-added">+                                              this.allowedModes == TRUSTED &amp;&amp; !getField.getDeclaringClass().isHidden());</span>
          }
          /** Check access and get the requested constructor. */
          private MethodHandle getDirectConstructor(Class&lt;?&gt; refc, MemberName ctor) throws IllegalAccessException {
              final boolean checkSecurity = true;
              return getDirectConstructorCommon(refc, ctor, checkSecurity);
</pre>
<center><a href="MethodHandleNatives.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../reflect/AccessibleObject.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
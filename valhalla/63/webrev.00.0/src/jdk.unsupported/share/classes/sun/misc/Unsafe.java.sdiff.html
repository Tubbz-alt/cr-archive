<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.unsupported/share/classes/sun/misc/Unsafe.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../jdk.jdwp.agent/share/native/libjdwp/util.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../../test/hotspot/jtreg/ProblemList.txt.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.unsupported/share/classes/sun/misc/Unsafe.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.misc;
  27 
  28 import jdk.internal.vm.annotation.ForceInline;
  29 import jdk.internal.misc.VM;
  30 import jdk.internal.reflect.CallerSensitive;
  31 import jdk.internal.reflect.Reflection;
  32 

  33 import java.lang.reflect.Field;
  34 import java.util.Set;
  35 
  36 
  37 /**
  38  * A collection of methods for performing low-level, unsafe operations.
  39  * Although the class and all methods are public, use of this class is
  40  * limited because only trusted code can obtain instances of it.
  41  *
  42  * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make sure
  43  * arguments are checked before methods of this class are
  44  * called. While some rudimentary checks are performed on the input,
  45  * the checks are best effort and when performance is an overriding
  46  * priority, as when methods of this class are optimized by the
  47  * runtime compiler, some or all checks (if any) may be elided. Hence,
  48  * the caller must not rely on the checks and corresponding
  49  * exceptions!
  50  *
  51  * @author John R. Rose
  52  * @see #getUnsafe
</pre>
<hr />
<pre>
 622      * it is just a cookie which is passed to the unsafe heap memory accessors.
 623      *
 624      * &lt;p&gt;Any given field will always have the same offset and base, and no
 625      * two distinct fields of the same class will ever have the same offset
 626      * and base.
 627      *
 628      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 629      * although the Sun JVM does not use the most significant 32 bits.
 630      * However, JVM implementations which store static fields at absolute
 631      * addresses can use long offsets and null base pointers to express
 632      * the field locations in a form usable by {@link #getInt(Object,long)}.
 633      * Therefore, code which will be ported to such JVMs on 64-bit platforms
 634      * must preserve all bits of static field offsets.
 635      * @see #getInt(Object, long)
 636      */
 637     @ForceInline
 638     public long objectFieldOffset(Field f) {
 639         if (f == null) {
 640             throw new NullPointerException();
 641         }



 642         if (f.getDeclaringClass().isInlineClass()) {
 643             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on an inline class: &quot; + f);
 644         }
 645         return theInternalUnsafe.objectFieldOffset(f);
 646     }
 647 
 648     /**
 649      * Reports the location of a given static field, in conjunction with {@link
 650      * #staticFieldBase}.
 651      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
 652      * it is just a cookie which is passed to the unsafe heap memory accessors.
 653      *
 654      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
 655      * fields of the same class will ever have the same offset.
 656      *
 657      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 658      * although the Sun JVM does not use the most significant 32 bits.
 659      * It is hard to imagine a JVM technology which needs more than
 660      * a few bits to encode an offset within a non-array object,
 661      * However, for consistency with other methods in this class,
 662      * this method reports its result as a long value.
 663      * @see #getInt(Object, long)
 664      */
 665     @ForceInline
 666     public long staticFieldOffset(Field f) {
 667         if (f == null) {
 668             throw new NullPointerException();
 669         }



 670         if (f.getDeclaringClass().isInlineClass()) {
 671             throw new UnsupportedOperationException(&quot;can&#39;t get static field offset on an inline class: &quot; + f);
 672         }
 673         return theInternalUnsafe.staticFieldOffset(f);
 674     }
 675 
 676     /**
 677      * Reports the location of a given static field, in conjunction with {@link
 678      * #staticFieldOffset}.
 679      * &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
 680      * given class can be accessed via methods like {@link #getInt(Object,
 681      * long)}.  This value may be null.  This value may refer to an object
 682      * which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
 683      * not be used in any way except as argument to the get and put routines in
 684      * this class.
 685      */
 686     @ForceInline
 687     public Object staticFieldBase(Field f) {
 688         if (f == null) {
 689             throw new NullPointerException();
 690         }



 691         if (f.getDeclaringClass().isInlineClass()) {
 692             throw new UnsupportedOperationException(&quot;can&#39;t get base address on an inline class: &quot; + f);
 693         }
 694         return theInternalUnsafe.staticFieldBase(f);
 695     }
 696 
 697     /**
 698      * Detects if the given class may need to be initialized. This is often
 699      * needed in conjunction with obtaining the static field base of a
 700      * class.
 701      * @return false only if a call to {@code ensureClassInitialized} would have no effect
 702      */
 703     @ForceInline
 704     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
 705         return theInternalUnsafe.shouldBeInitialized(c);
 706     }
 707 
 708     /**
 709      * Ensures the given class has been initialized. This is often
 710      * needed in conjunction with obtaining the static field base of a
</pre>
<hr />
<pre>
 821     @ForceInline
 822     public int pageSize() {
 823         return theInternalUnsafe.pageSize();
 824     }
 825 
 826 
 827     /// random trusted operations from JNI:
 828 
 829     /**
 830      * Defines a class but does not make it known to the class loader or system dictionary.
 831      * &lt;p&gt;
 832      * For each CP entry, the corresponding CP patch must either be null or have
 833      * the a format that matches its tag:
 834      * &lt;ul&gt;
 835      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
 836      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
 837      * &lt;li&gt;Class: any java.lang.Class object
 838      * &lt;li&gt;String: any object (not just a java.lang.String)
 839      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site&#39;s arguments
 840      * &lt;/ul&gt;




 841      * @param hostClass context for linkage, access control, protection domain, and class loader
 842      * @param data      bytes of a class file
 843      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
 844      */
 845     @ForceInline

 846     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
 847         return theInternalUnsafe.defineAnonymousClass(hostClass, data, cpPatches);
 848     }
 849 
 850     /**
 851      * Allocates an instance but does not run any constructor.
 852      * Initializes the class if it has not yet been.
 853      */
 854     @ForceInline
 855     public Object allocateInstance(Class&lt;?&gt; cls)
 856         throws InstantiationException {
 857         return theInternalUnsafe.allocateInstance(cls);
 858     }
 859 
 860     /** Throws the exception without telling the verifier. */
 861     @ForceInline
 862     public void throwException(Throwable ee) {
 863         theInternalUnsafe.throwException(ee);
 864     }
 865 
</pre>
</td>
<td>
<hr />
<pre>
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.misc;
  27 
  28 import jdk.internal.vm.annotation.ForceInline;
  29 import jdk.internal.misc.VM;
  30 import jdk.internal.reflect.CallerSensitive;
  31 import jdk.internal.reflect.Reflection;
  32 
<span class="line-added">  33 import java.lang.invoke.MethodHandles;</span>
  34 import java.lang.reflect.Field;
  35 import java.util.Set;
  36 
  37 
  38 /**
  39  * A collection of methods for performing low-level, unsafe operations.
  40  * Although the class and all methods are public, use of this class is
  41  * limited because only trusted code can obtain instances of it.
  42  *
  43  * &lt;em&gt;Note:&lt;/em&gt; It is the responsibility of the caller to make sure
  44  * arguments are checked before methods of this class are
  45  * called. While some rudimentary checks are performed on the input,
  46  * the checks are best effort and when performance is an overriding
  47  * priority, as when methods of this class are optimized by the
  48  * runtime compiler, some or all checks (if any) may be elided. Hence,
  49  * the caller must not rely on the checks and corresponding
  50  * exceptions!
  51  *
  52  * @author John R. Rose
  53  * @see #getUnsafe
</pre>
<hr />
<pre>
 623      * it is just a cookie which is passed to the unsafe heap memory accessors.
 624      *
 625      * &lt;p&gt;Any given field will always have the same offset and base, and no
 626      * two distinct fields of the same class will ever have the same offset
 627      * and base.
 628      *
 629      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 630      * although the Sun JVM does not use the most significant 32 bits.
 631      * However, JVM implementations which store static fields at absolute
 632      * addresses can use long offsets and null base pointers to express
 633      * the field locations in a form usable by {@link #getInt(Object,long)}.
 634      * Therefore, code which will be ported to such JVMs on 64-bit platforms
 635      * must preserve all bits of static field offsets.
 636      * @see #getInt(Object, long)
 637      */
 638     @ForceInline
 639     public long objectFieldOffset(Field f) {
 640         if (f == null) {
 641             throw new NullPointerException();
 642         }
<span class="line-added"> 643         if (f.getDeclaringClass().isHidden()) {</span>
<span class="line-added"> 644             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a hidden class: &quot; + f);</span>
<span class="line-added"> 645         }</span>
 646         if (f.getDeclaringClass().isInlineClass()) {
 647             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on an inline class: &quot; + f);
 648         }
 649         return theInternalUnsafe.objectFieldOffset(f);
 650     }
 651 
 652     /**
 653      * Reports the location of a given static field, in conjunction with {@link
 654      * #staticFieldBase}.
 655      * &lt;p&gt;Do not expect to perform any sort of arithmetic on this offset;
 656      * it is just a cookie which is passed to the unsafe heap memory accessors.
 657      *
 658      * &lt;p&gt;Any given field will always have the same offset, and no two distinct
 659      * fields of the same class will ever have the same offset.
 660      *
 661      * &lt;p&gt;As of 1.4.1, offsets for fields are represented as long values,
 662      * although the Sun JVM does not use the most significant 32 bits.
 663      * It is hard to imagine a JVM technology which needs more than
 664      * a few bits to encode an offset within a non-array object,
 665      * However, for consistency with other methods in this class,
 666      * this method reports its result as a long value.
 667      * @see #getInt(Object, long)
 668      */
 669     @ForceInline
 670     public long staticFieldOffset(Field f) {
 671         if (f == null) {
 672             throw new NullPointerException();
 673         }
<span class="line-added"> 674         if (f.getDeclaringClass().isHidden()) {</span>
<span class="line-added"> 675             throw new UnsupportedOperationException(&quot;can&#39;t get field offset on a hidden class: &quot; + f);</span>
<span class="line-added"> 676         }</span>
 677         if (f.getDeclaringClass().isInlineClass()) {
 678             throw new UnsupportedOperationException(&quot;can&#39;t get static field offset on an inline class: &quot; + f);
 679         }
 680         return theInternalUnsafe.staticFieldOffset(f);
 681     }
 682 
 683     /**
 684      * Reports the location of a given static field, in conjunction with {@link
 685      * #staticFieldOffset}.
 686      * &lt;p&gt;Fetch the base &quot;Object&quot;, if any, with which static fields of the
 687      * given class can be accessed via methods like {@link #getInt(Object,
 688      * long)}.  This value may be null.  This value may refer to an object
 689      * which is a &quot;cookie&quot;, not guaranteed to be a real Object, and it should
 690      * not be used in any way except as argument to the get and put routines in
 691      * this class.
 692      */
 693     @ForceInline
 694     public Object staticFieldBase(Field f) {
 695         if (f == null) {
 696             throw new NullPointerException();
 697         }
<span class="line-added"> 698         if (f.getDeclaringClass().isHidden()) {</span>
<span class="line-added"> 699             throw new UnsupportedOperationException(&quot;can&#39;t get base address on a hidden class: &quot; + f);</span>
<span class="line-added"> 700         }</span>
 701         if (f.getDeclaringClass().isInlineClass()) {
 702             throw new UnsupportedOperationException(&quot;can&#39;t get base address on an inline class: &quot; + f);
 703         }
 704         return theInternalUnsafe.staticFieldBase(f);
 705     }
 706 
 707     /**
 708      * Detects if the given class may need to be initialized. This is often
 709      * needed in conjunction with obtaining the static field base of a
 710      * class.
 711      * @return false only if a call to {@code ensureClassInitialized} would have no effect
 712      */
 713     @ForceInline
 714     public boolean shouldBeInitialized(Class&lt;?&gt; c) {
 715         return theInternalUnsafe.shouldBeInitialized(c);
 716     }
 717 
 718     /**
 719      * Ensures the given class has been initialized. This is often
 720      * needed in conjunction with obtaining the static field base of a
</pre>
<hr />
<pre>
 831     @ForceInline
 832     public int pageSize() {
 833         return theInternalUnsafe.pageSize();
 834     }
 835 
 836 
 837     /// random trusted operations from JNI:
 838 
 839     /**
 840      * Defines a class but does not make it known to the class loader or system dictionary.
 841      * &lt;p&gt;
 842      * For each CP entry, the corresponding CP patch must either be null or have
 843      * the a format that matches its tag:
 844      * &lt;ul&gt;
 845      * &lt;li&gt;Integer, Long, Float, Double: the corresponding wrapper object type from java.lang
 846      * &lt;li&gt;Utf8: a string (must have suitable syntax if used as signature or name)
 847      * &lt;li&gt;Class: any java.lang.Class object
 848      * &lt;li&gt;String: any object (not just a java.lang.String)
 849      * &lt;li&gt;InterfaceMethodRef: (NYI) a method handle to invoke on that call site&#39;s arguments
 850      * &lt;/ul&gt;
<span class="line-added"> 851      *</span>
<span class="line-added"> 852      * @deprecated Use the {@link java.lang.invoke.MethodHandles.Lookup#defineHiddenClass(byte[], boolean, MethodHandles.Lookup.ClassOption...)}</span>
<span class="line-added"> 853      * method.</span>
<span class="line-added"> 854      *</span>
 855      * @param hostClass context for linkage, access control, protection domain, and class loader
 856      * @param data      bytes of a class file
 857      * @param cpPatches where non-null entries exist, they replace corresponding CP entries in data
 858      */
 859     @ForceInline
<span class="line-added"> 860     @Deprecated(since = &quot;15&quot;, forRemoval = false)</span>
 861     public Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches) {
 862         return theInternalUnsafe.defineAnonymousClass(hostClass, data, cpPatches);
 863     }
 864 
 865     /**
 866      * Allocates an instance but does not run any constructor.
 867      * Initializes the class if it has not yet been.
 868      */
 869     @ForceInline
 870     public Object allocateInstance(Class&lt;?&gt; cls)
 871         throws InstantiationException {
 872         return theInternalUnsafe.allocateInstance(cls);
 873     }
 874 
 875     /** Throws the exception without telling the verifier. */
 876     @ForceInline
 877     public void throwException(Throwable ee) {
 878         theInternalUnsafe.throwException(ee);
 879     }
 880 
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../jdk.jdwp.agent/share/native/libjdwp/util.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../../../../../test/hotspot/jtreg/ProblemList.txt.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/library_call.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/library_call.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 188     int offset = java_lang_Class::array_klass_offset_in_bytes();
 189     return load_klass_from_mirror_common(mirror, never_see_null,
 190                                          region, null_path,
 191                                          offset);
 192   }
 193   Node* generate_access_flags_guard(Node* kls,
 194                                     int modifier_mask, int modifier_bits,
 195                                     RegionNode* region);
 196   Node* generate_interface_guard(Node* kls, RegionNode* region);
 197   Node* generate_value_guard(Node* kls, RegionNode* region);
 198 
 199   enum ArrayKind {
 200     AnyArray,
 201     NonArray,
 202     ObjectArray,
 203     NonObjectArray,
 204     TypeArray,
 205     ValueArray
 206   };
 207 


 208   Node* generate_array_guard(Node* kls, RegionNode* region) {
 209     return generate_array_guard_common(kls, region, AnyArray);
 210   }
 211   Node* generate_non_array_guard(Node* kls, RegionNode* region) {
 212     return generate_array_guard_common(kls, region, NonArray);
 213   }
 214   Node* generate_objArray_guard(Node* kls, RegionNode* region) {
 215     return generate_array_guard_common(kls, region, ObjectArray);
 216   }
 217   Node* generate_non_objArray_guard(Node* kls, RegionNode* region) {
 218     return generate_array_guard_common(kls, region, NonObjectArray);
 219   }
 220   Node* generate_typeArray_guard(Node* kls, RegionNode* region) {
 221     return generate_array_guard_common(kls, region, TypeArray);
 222   }
 223   Node* generate_valueArray_guard(Node* kls, RegionNode* region) {
 224     assert(ValueArrayFlatten, &quot;can never be flattened&quot;);
 225     return generate_array_guard_common(kls, region, ValueArray);
 226   }
 227   Node* generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind);
</pre>
<hr />
<pre>
 797   case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
 798   case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
 799   case vmIntrinsics::_getLength:                return inline_native_getLength();
 800   case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
 801   case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
 802   case vmIntrinsics::_equalsB:                  return inline_array_equals(StrIntrinsicNode::LL);
 803   case vmIntrinsics::_equalsC:                  return inline_array_equals(StrIntrinsicNode::UU);
 804   case vmIntrinsics::_Preconditions_checkIndex: return inline_preconditions_checkIndex();
 805   case vmIntrinsics::_clone:                    return inline_native_clone(intrinsic()-&gt;is_virtual());
 806 
 807   case vmIntrinsics::_allocateUninitializedArray: return inline_unsafe_newArray(true);
 808   case vmIntrinsics::_newArray:                   return inline_unsafe_newArray(false);
 809 
 810   case vmIntrinsics::_isAssignableFrom:         return inline_native_subtype_check();
 811 
 812   case vmIntrinsics::_isInstance:
 813   case vmIntrinsics::_getModifiers:
 814   case vmIntrinsics::_isInterface:
 815   case vmIntrinsics::_isArray:
 816   case vmIntrinsics::_isPrimitive:

 817   case vmIntrinsics::_getSuperclass:
 818   case vmIntrinsics::_getClassAccessFlags:      return inline_native_Class_query(intrinsic_id());
 819 
 820   case vmIntrinsics::_floatToRawIntBits:
 821   case vmIntrinsics::_floatToIntBits:
 822   case vmIntrinsics::_intBitsToFloat:
 823   case vmIntrinsics::_doubleToRawLongBits:
 824   case vmIntrinsics::_doubleToLongBits:
 825   case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());
 826 
 827   case vmIntrinsics::_numberOfLeadingZeros_i:
 828   case vmIntrinsics::_numberOfLeadingZeros_l:
 829   case vmIntrinsics::_numberOfTrailingZeros_i:
 830   case vmIntrinsics::_numberOfTrailingZeros_l:
 831   case vmIntrinsics::_bitCount_i:
 832   case vmIntrinsics::_bitCount_l:
 833   case vmIntrinsics::_reverseBytes_i:
 834   case vmIntrinsics::_reverseBytes_l:
 835   case vmIntrinsics::_reverseBytes_s:
 836   case vmIntrinsics::_reverseBytes_c:           return inline_number_methods(intrinsic_id());
</pre>
<hr />
<pre>
3273 
3274 //--------------------(inline_native_Class_query helpers)---------------------
3275 // Use this for JVM_ACC_INTERFACE, JVM_ACC_IS_CLONEABLE_FAST, JVM_ACC_HAS_FINALIZER.
3276 // Fall through if (mods &amp; mask) == bits, take the guard otherwise.
3277 Node* LibraryCallKit::generate_access_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {
3278   // Branch around if the given klass has the given modifier bit set.
3279   // Like generate_guard, adds a new path onto the region.
3280   Node* modp = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));
3281   Node* mods = make_load(NULL, modp, TypeInt::INT, T_INT, MemNode::unordered);
3282   Node* mask = intcon(modifier_mask);
3283   Node* bits = intcon(modifier_bits);
3284   Node* mbit = _gvn.transform(new AndINode(mods, mask));
3285   Node* cmp  = _gvn.transform(new CmpINode(mbit, bits));
3286   Node* bol  = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
3287   return generate_fair_guard(bol, region);
3288 }
3289 
3290 Node* LibraryCallKit::generate_interface_guard(Node* kls, RegionNode* region) {
3291   return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);
3292 }



3293 
3294 Node* LibraryCallKit::generate_value_guard(Node* kls, RegionNode* region) {
3295   return generate_access_flags_guard(kls, JVM_ACC_VALUE, 0, region);
3296 }
3297 
3298 //-------------------------inline_native_Class_query-------------------
3299 bool LibraryCallKit::inline_native_Class_query(vmIntrinsics::ID id) {
3300   const Type* return_type = TypeInt::BOOL;
3301   Node* prim_return_value = top();  // what happens if it&#39;s a primitive class?
3302   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3303   bool expect_prim = false;     // most of these guys expect to work on refs
3304 
3305   enum { _normal_path = 1, _prim_path = 2, PATH_LIMIT };
3306 
3307   Node* mirror = argument(0);
3308   Node* obj    = top();
3309 
3310   switch (id) {
3311   case vmIntrinsics::_isInstance:
3312     // nothing is an instance of a primitive type
3313     prim_return_value = intcon(0);
3314     obj = argument(1);
3315     break;
3316   case vmIntrinsics::_getModifiers:
3317     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3318     assert(is_power_of_2((int)JVM_ACC_WRITTEN_FLAGS+1), &quot;change next line&quot;);
3319     return_type = TypeInt::make(0, JVM_ACC_WRITTEN_FLAGS, Type::WidenMin);
3320     break;
3321   case vmIntrinsics::_isInterface:
3322     prim_return_value = intcon(0);
3323     break;
3324   case vmIntrinsics::_isArray:
3325     prim_return_value = intcon(0);
3326     expect_prim = true;  // cf. ObjectStreamClass.getClassSignature
3327     break;
3328   case vmIntrinsics::_isPrimitive:
3329     prim_return_value = intcon(1);
3330     expect_prim = true;  // obviously
3331     break;



3332   case vmIntrinsics::_getSuperclass:
3333     prim_return_value = null();
3334     return_type = TypeInstPtr::MIRROR-&gt;cast_to_ptr_type(TypePtr::BotPTR);
3335     break;
3336   case vmIntrinsics::_getClassAccessFlags:
3337     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3338     return_type = TypeInt::INT;  // not bool!  6297094
3339     break;
3340   default:
3341     fatal_unexpected_iid(id);
3342     break;
3343   }
3344 
3345   const TypeInstPtr* mirror_con = _gvn.type(mirror)-&gt;isa_instptr();
3346   if (mirror_con == NULL)  return false;  // cannot happen?
3347 
3348 #ifndef PRODUCT
3349   if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
3350     ciType* k = mirror_con-&gt;java_mirror_type();
3351     if (k) {
</pre>
<hr />
<pre>
3404     if (generate_interface_guard(kls, region) != NULL)
3405       // A guard was added.  If the guard is taken, it was an interface.
3406       phi-&gt;add_req(intcon(1));
3407     // If we fall through, it&#39;s a plain class.
3408     query_value = intcon(0);
3409     break;
3410 
3411   case vmIntrinsics::_isArray:
3412     // (To verify this code sequence, check the asserts in JVM_IsArrayClass.)
3413     if (generate_array_guard(kls, region) != NULL)
3414       // A guard was added.  If the guard is taken, it was an array.
3415       phi-&gt;add_req(intcon(1));
3416     // If we fall through, it&#39;s a plain class.
3417     query_value = intcon(0);
3418     break;
3419 
3420   case vmIntrinsics::_isPrimitive:
3421     query_value = intcon(0); // &quot;normal&quot; path produces false
3422     break;
3423 










3424   case vmIntrinsics::_getSuperclass:
3425     // The rules here are somewhat unfortunate, but we can still do better
3426     // with random logic than with a JNI call.
3427     // Interfaces store null or Object as _super, but must report null.
3428     // Arrays store an intermediate super as _super, but must report Object.
3429     // Other types can report the actual _super.
3430     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3431     if (generate_interface_guard(kls, region) != NULL)
3432       // A guard was added.  If the guard is taken, it was an interface.
3433       phi-&gt;add_req(null());
3434     if (generate_array_guard(kls, region) != NULL)
3435       // A guard was added.  If the guard is taken, it was an array.
3436       phi-&gt;add_req(makecon(TypeInstPtr::make(env()-&gt;Object_klass()-&gt;java_mirror())));
3437     // If we fall through, it&#39;s a plain class.  Get its _super.
3438     p = basic_plus_adr(kls, in_bytes(Klass::super_offset()));
3439     kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));
3440     null_ctl = top();
3441     kls = null_check_oop(kls, &amp;null_ctl);
3442     if (null_ctl != top()) {
3443       // If the guard is taken, Object.superClass is null (both klass and mirror).
</pre>
</td>
<td>
<hr />
<pre>
 188     int offset = java_lang_Class::array_klass_offset_in_bytes();
 189     return load_klass_from_mirror_common(mirror, never_see_null,
 190                                          region, null_path,
 191                                          offset);
 192   }
 193   Node* generate_access_flags_guard(Node* kls,
 194                                     int modifier_mask, int modifier_bits,
 195                                     RegionNode* region);
 196   Node* generate_interface_guard(Node* kls, RegionNode* region);
 197   Node* generate_value_guard(Node* kls, RegionNode* region);
 198 
 199   enum ArrayKind {
 200     AnyArray,
 201     NonArray,
 202     ObjectArray,
 203     NonObjectArray,
 204     TypeArray,
 205     ValueArray
 206   };
 207 
<span class="line-added"> 208   Node* generate_hidden_class_guard(Node* kls, RegionNode* region);</span>
<span class="line-added"> 209 </span>
 210   Node* generate_array_guard(Node* kls, RegionNode* region) {
 211     return generate_array_guard_common(kls, region, AnyArray);
 212   }
 213   Node* generate_non_array_guard(Node* kls, RegionNode* region) {
 214     return generate_array_guard_common(kls, region, NonArray);
 215   }
 216   Node* generate_objArray_guard(Node* kls, RegionNode* region) {
 217     return generate_array_guard_common(kls, region, ObjectArray);
 218   }
 219   Node* generate_non_objArray_guard(Node* kls, RegionNode* region) {
 220     return generate_array_guard_common(kls, region, NonObjectArray);
 221   }
 222   Node* generate_typeArray_guard(Node* kls, RegionNode* region) {
 223     return generate_array_guard_common(kls, region, TypeArray);
 224   }
 225   Node* generate_valueArray_guard(Node* kls, RegionNode* region) {
 226     assert(ValueArrayFlatten, &quot;can never be flattened&quot;);
 227     return generate_array_guard_common(kls, region, ValueArray);
 228   }
 229   Node* generate_array_guard_common(Node* kls, RegionNode* region, ArrayKind kind);
</pre>
<hr />
<pre>
 799   case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
 800   case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
 801   case vmIntrinsics::_getLength:                return inline_native_getLength();
 802   case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
 803   case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
 804   case vmIntrinsics::_equalsB:                  return inline_array_equals(StrIntrinsicNode::LL);
 805   case vmIntrinsics::_equalsC:                  return inline_array_equals(StrIntrinsicNode::UU);
 806   case vmIntrinsics::_Preconditions_checkIndex: return inline_preconditions_checkIndex();
 807   case vmIntrinsics::_clone:                    return inline_native_clone(intrinsic()-&gt;is_virtual());
 808 
 809   case vmIntrinsics::_allocateUninitializedArray: return inline_unsafe_newArray(true);
 810   case vmIntrinsics::_newArray:                   return inline_unsafe_newArray(false);
 811 
 812   case vmIntrinsics::_isAssignableFrom:         return inline_native_subtype_check();
 813 
 814   case vmIntrinsics::_isInstance:
 815   case vmIntrinsics::_getModifiers:
 816   case vmIntrinsics::_isInterface:
 817   case vmIntrinsics::_isArray:
 818   case vmIntrinsics::_isPrimitive:
<span class="line-added"> 819   case vmIntrinsics::_isHidden:</span>
 820   case vmIntrinsics::_getSuperclass:
 821   case vmIntrinsics::_getClassAccessFlags:      return inline_native_Class_query(intrinsic_id());
 822 
 823   case vmIntrinsics::_floatToRawIntBits:
 824   case vmIntrinsics::_floatToIntBits:
 825   case vmIntrinsics::_intBitsToFloat:
 826   case vmIntrinsics::_doubleToRawLongBits:
 827   case vmIntrinsics::_doubleToLongBits:
 828   case vmIntrinsics::_longBitsToDouble:         return inline_fp_conversions(intrinsic_id());
 829 
 830   case vmIntrinsics::_numberOfLeadingZeros_i:
 831   case vmIntrinsics::_numberOfLeadingZeros_l:
 832   case vmIntrinsics::_numberOfTrailingZeros_i:
 833   case vmIntrinsics::_numberOfTrailingZeros_l:
 834   case vmIntrinsics::_bitCount_i:
 835   case vmIntrinsics::_bitCount_l:
 836   case vmIntrinsics::_reverseBytes_i:
 837   case vmIntrinsics::_reverseBytes_l:
 838   case vmIntrinsics::_reverseBytes_s:
 839   case vmIntrinsics::_reverseBytes_c:           return inline_number_methods(intrinsic_id());
</pre>
<hr />
<pre>
3276 
3277 //--------------------(inline_native_Class_query helpers)---------------------
3278 // Use this for JVM_ACC_INTERFACE, JVM_ACC_IS_CLONEABLE_FAST, JVM_ACC_HAS_FINALIZER.
3279 // Fall through if (mods &amp; mask) == bits, take the guard otherwise.
3280 Node* LibraryCallKit::generate_access_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {
3281   // Branch around if the given klass has the given modifier bit set.
3282   // Like generate_guard, adds a new path onto the region.
3283   Node* modp = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));
3284   Node* mods = make_load(NULL, modp, TypeInt::INT, T_INT, MemNode::unordered);
3285   Node* mask = intcon(modifier_mask);
3286   Node* bits = intcon(modifier_bits);
3287   Node* mbit = _gvn.transform(new AndINode(mods, mask));
3288   Node* cmp  = _gvn.transform(new CmpINode(mbit, bits));
3289   Node* bol  = _gvn.transform(new BoolNode(cmp, BoolTest::ne));
3290   return generate_fair_guard(bol, region);
3291 }
3292 
3293 Node* LibraryCallKit::generate_interface_guard(Node* kls, RegionNode* region) {
3294   return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);
3295 }
<span class="line-added">3296 Node* LibraryCallKit::generate_hidden_class_guard(Node* kls, RegionNode* region) {</span>
<span class="line-added">3297   return generate_access_flags_guard(kls, JVM_ACC_IS_HIDDEN_CLASS, 0, region);</span>
<span class="line-added">3298 }</span>
3299 
3300 Node* LibraryCallKit::generate_value_guard(Node* kls, RegionNode* region) {
3301   return generate_access_flags_guard(kls, JVM_ACC_VALUE, 0, region);
3302 }
3303 
3304 //-------------------------inline_native_Class_query-------------------
3305 bool LibraryCallKit::inline_native_Class_query(vmIntrinsics::ID id) {
3306   const Type* return_type = TypeInt::BOOL;
3307   Node* prim_return_value = top();  // what happens if it&#39;s a primitive class?
3308   bool never_see_null = !too_many_traps(Deoptimization::Reason_null_check);
3309   bool expect_prim = false;     // most of these guys expect to work on refs
3310 
3311   enum { _normal_path = 1, _prim_path = 2, PATH_LIMIT };
3312 
3313   Node* mirror = argument(0);
3314   Node* obj    = top();
3315 
3316   switch (id) {
3317   case vmIntrinsics::_isInstance:
3318     // nothing is an instance of a primitive type
3319     prim_return_value = intcon(0);
3320     obj = argument(1);
3321     break;
3322   case vmIntrinsics::_getModifiers:
3323     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3324     assert(is_power_of_2((int)JVM_ACC_WRITTEN_FLAGS+1), &quot;change next line&quot;);
3325     return_type = TypeInt::make(0, JVM_ACC_WRITTEN_FLAGS, Type::WidenMin);
3326     break;
3327   case vmIntrinsics::_isInterface:
3328     prim_return_value = intcon(0);
3329     break;
3330   case vmIntrinsics::_isArray:
3331     prim_return_value = intcon(0);
3332     expect_prim = true;  // cf. ObjectStreamClass.getClassSignature
3333     break;
3334   case vmIntrinsics::_isPrimitive:
3335     prim_return_value = intcon(1);
3336     expect_prim = true;  // obviously
3337     break;
<span class="line-added">3338   case vmIntrinsics::_isHidden:</span>
<span class="line-added">3339     prim_return_value = intcon(0);</span>
<span class="line-added">3340     break;</span>
3341   case vmIntrinsics::_getSuperclass:
3342     prim_return_value = null();
3343     return_type = TypeInstPtr::MIRROR-&gt;cast_to_ptr_type(TypePtr::BotPTR);
3344     break;
3345   case vmIntrinsics::_getClassAccessFlags:
3346     prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);
3347     return_type = TypeInt::INT;  // not bool!  6297094
3348     break;
3349   default:
3350     fatal_unexpected_iid(id);
3351     break;
3352   }
3353 
3354   const TypeInstPtr* mirror_con = _gvn.type(mirror)-&gt;isa_instptr();
3355   if (mirror_con == NULL)  return false;  // cannot happen?
3356 
3357 #ifndef PRODUCT
3358   if (C-&gt;print_intrinsics() || C-&gt;print_inlining()) {
3359     ciType* k = mirror_con-&gt;java_mirror_type();
3360     if (k) {
</pre>
<hr />
<pre>
3413     if (generate_interface_guard(kls, region) != NULL)
3414       // A guard was added.  If the guard is taken, it was an interface.
3415       phi-&gt;add_req(intcon(1));
3416     // If we fall through, it&#39;s a plain class.
3417     query_value = intcon(0);
3418     break;
3419 
3420   case vmIntrinsics::_isArray:
3421     // (To verify this code sequence, check the asserts in JVM_IsArrayClass.)
3422     if (generate_array_guard(kls, region) != NULL)
3423       // A guard was added.  If the guard is taken, it was an array.
3424       phi-&gt;add_req(intcon(1));
3425     // If we fall through, it&#39;s a plain class.
3426     query_value = intcon(0);
3427     break;
3428 
3429   case vmIntrinsics::_isPrimitive:
3430     query_value = intcon(0); // &quot;normal&quot; path produces false
3431     break;
3432 
<span class="line-added">3433   case vmIntrinsics::_isHidden:</span>
<span class="line-added">3434     // (To verify this code sequence, check the asserts in JVM_IsHiddenClass.)</span>
<span class="line-added">3435     if (generate_hidden_class_guard(kls, region) != NULL)</span>
<span class="line-added">3436       // A guard was added.  If the guard is taken, it was an hidden class.</span>
<span class="line-added">3437       phi-&gt;add_req(intcon(1));</span>
<span class="line-added">3438     // If we fall through, it&#39;s a plain class.</span>
<span class="line-added">3439     query_value = intcon(0);</span>
<span class="line-added">3440     break;</span>
<span class="line-added">3441 </span>
<span class="line-added">3442 </span>
3443   case vmIntrinsics::_getSuperclass:
3444     // The rules here are somewhat unfortunate, but we can still do better
3445     // with random logic than with a JNI call.
3446     // Interfaces store null or Object as _super, but must report null.
3447     // Arrays store an intermediate super as _super, but must report Object.
3448     // Other types can report the actual _super.
3449     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3450     if (generate_interface_guard(kls, region) != NULL)
3451       // A guard was added.  If the guard is taken, it was an interface.
3452       phi-&gt;add_req(null());
3453     if (generate_array_guard(kls, region) != NULL)
3454       // A guard was added.  If the guard is taken, it was an array.
3455       phi-&gt;add_req(makecon(TypeInstPtr::make(env()-&gt;Object_klass()-&gt;java_mirror())));
3456     // If we fall through, it&#39;s a plain class.  Get its _super.
3457     p = basic_plus_adr(kls, in_bytes(Klass::super_offset()));
3458     kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(), p, TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));
3459     null_ctl = top();
3460     kls = null_check_oop(kls, &amp;null_ctl);
3461     if (null_ctl != top()) {
3462       // If the guard is taken, Object.superClass is null (both klass and mirror).
</pre>
</td>
</tr>
</table>
<center><a href="graphKit.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
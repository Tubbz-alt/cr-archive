<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/matcher.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="matcher.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/matcher.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
321   // Some uarchs have different sized float register resources
322   static const int float_pressure(int default_pressure_threshold);
323 
324   // Used to determine if we have fast l2f conversion
325   // USII has it, USIII doesn&#39;t
326   static const bool convL2FSupported(void);
327 
328   // Vector width in bytes
329   static const int vector_width_in_bytes(BasicType bt);
330 
331   // Limits on vector size (number of elements).
332   static const int max_vector_size(const BasicType bt);
333   static const int min_vector_size(const BasicType bt);
334   static const bool vector_size_supported(const BasicType bt, int size) {
335     return (Matcher::max_vector_size(bt) &gt;= size &amp;&amp;
336             Matcher::min_vector_size(bt) &lt;= size);
337   }
338 
339   // Vector ideal reg
340   static const uint vector_ideal_reg(int len);
<span class="line-removed">341   static const uint vector_shift_count_ideal_reg(int len);</span>
342 
343   // CPU supports misaligned vectors store/load.
344   static const bool misaligned_vectors_ok();
345 
346   // Should original key array reference be passed to AES stubs
347   static const bool pass_original_key_for_aes();
348 
349   // Used to determine a &quot;low complexity&quot; 64-bit constant.  (Zero is simple.)
350   // The standard of comparison is one (StoreL ConL) vs. two (StoreI ConI).
351   // Depends on the details of 64-bit constant generation on the CPU.
352   static const bool isSimpleConstant64(jlong con);
353 
354   // These calls are all generated by the ADLC
355 
356   // TRUE - grows up, FALSE - grows down (Intel)
357   virtual bool stack_direction() const;
358 
359   // Java-Java calling convention
360   // (what you use when Java calls Java)
361 
</pre>
<hr />
<pre>
505   // piece-by-piece.  Only happens when passing doubles into C code or when
506   // calling i2c adapters as the Java calling convention forces doubles to be
507   // aligned.
508   static const bool misaligned_doubles_ok;
509 
510   // Does the CPU require postalloc expand (see block.cpp for description of
511   // postalloc expand)?
512   static const bool require_postalloc_expand;
513 
514   // Does the platform support generic vector operands?
515   // Requires cleanup after selection phase.
516   static const bool supports_generic_vector_operands;
517 
518  private:
519   void do_postselect_cleanup();
520 
521   void specialize_generic_vector_operands();
522   void specialize_mach_node(MachNode* m);
523   void specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx);
524   MachOper* specialize_vector_operand(MachNode* m, uint opnd_idx);
<span class="line-modified">525   MachOper* specialize_vector_operand_helper(MachNode* m, uint opnd_idx, const TypeVect* vt);</span>
<span class="line-removed">526 </span>
<span class="line-removed">527   static MachOper* specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp);</span>
528 
529   static bool is_generic_reg2reg_move(MachNode* m);
530   static bool is_generic_vector(MachOper* opnd);
531 
532   const RegMask* regmask_for_ideal_register(uint ideal_reg, Node* ret);
533 
534   // Graph verification code
535   DEBUG_ONLY( bool verify_after_postselect_cleanup(); )
536 
537  public:
538   // Perform a platform dependent implicit null fixup.  This is needed
539   // on windows95 to take care of some unusual register constraints.
540   void pd_implicit_null_fixup(MachNode *load, uint idx);
541 
542   // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
543   static const bool strict_fp_requires_explicit_rounding;
544 
545   // Are floats conerted to double when stored to stack during deoptimization?
546   static bool float_in_double();
547   // Do ints take an entire long register or just half?
</pre>
</td>
<td>
<hr />
<pre>
321   // Some uarchs have different sized float register resources
322   static const int float_pressure(int default_pressure_threshold);
323 
324   // Used to determine if we have fast l2f conversion
325   // USII has it, USIII doesn&#39;t
326   static const bool convL2FSupported(void);
327 
328   // Vector width in bytes
329   static const int vector_width_in_bytes(BasicType bt);
330 
331   // Limits on vector size (number of elements).
332   static const int max_vector_size(const BasicType bt);
333   static const int min_vector_size(const BasicType bt);
334   static const bool vector_size_supported(const BasicType bt, int size) {
335     return (Matcher::max_vector_size(bt) &gt;= size &amp;&amp;
336             Matcher::min_vector_size(bt) &lt;= size);
337   }
338 
339   // Vector ideal reg
340   static const uint vector_ideal_reg(int len);

341 
342   // CPU supports misaligned vectors store/load.
343   static const bool misaligned_vectors_ok();
344 
345   // Should original key array reference be passed to AES stubs
346   static const bool pass_original_key_for_aes();
347 
348   // Used to determine a &quot;low complexity&quot; 64-bit constant.  (Zero is simple.)
349   // The standard of comparison is one (StoreL ConL) vs. two (StoreI ConI).
350   // Depends on the details of 64-bit constant generation on the CPU.
351   static const bool isSimpleConstant64(jlong con);
352 
353   // These calls are all generated by the ADLC
354 
355   // TRUE - grows up, FALSE - grows down (Intel)
356   virtual bool stack_direction() const;
357 
358   // Java-Java calling convention
359   // (what you use when Java calls Java)
360 
</pre>
<hr />
<pre>
504   // piece-by-piece.  Only happens when passing doubles into C code or when
505   // calling i2c adapters as the Java calling convention forces doubles to be
506   // aligned.
507   static const bool misaligned_doubles_ok;
508 
509   // Does the CPU require postalloc expand (see block.cpp for description of
510   // postalloc expand)?
511   static const bool require_postalloc_expand;
512 
513   // Does the platform support generic vector operands?
514   // Requires cleanup after selection phase.
515   static const bool supports_generic_vector_operands;
516 
517  private:
518   void do_postselect_cleanup();
519 
520   void specialize_generic_vector_operands();
521   void specialize_mach_node(MachNode* m);
522   void specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx);
523   MachOper* specialize_vector_operand(MachNode* m, uint opnd_idx);
<span class="line-modified">524 </span>


525   static MachOper* pd_specialize_generic_vector_operand(MachOper* generic_opnd, uint ideal_reg, bool is_temp);
526   static bool is_generic_reg2reg_move(MachNode* m);
527   static bool is_generic_vector(MachOper* opnd);
528 
529   const RegMask* regmask_for_ideal_register(uint ideal_reg, Node* ret);
530 
531   // Graph verification code
532   DEBUG_ONLY( bool verify_after_postselect_cleanup(); )
533 
534  public:
535   // Perform a platform dependent implicit null fixup.  This is needed
536   // on windows95 to take care of some unusual register constraints.
537   void pd_implicit_null_fixup(MachNode *load, uint idx);
538 
539   // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
540   static const bool strict_fp_requires_explicit_rounding;
541 
542   // Are floats conerted to double when stored to stack during deoptimization?
543   static bool float_in_double();
544   // Do ints take an entire long register or just half?
</pre>
</td>
</tr>
</table>
<center><a href="matcher.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
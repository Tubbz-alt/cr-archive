diff a/src/hotspot/share/opto/matcher.cpp b/src/hotspot/share/opto/matcher.cpp
--- a/src/hotspot/share/opto/matcher.cpp
+++ b/src/hotspot/share/opto/matcher.cpp
@@ -2517,35 +2517,20 @@
 
 //----------------------------------------------------------------------
 // Generic machine operands elision.
 //----------------------------------------------------------------------
 
-// Convert (leg)Vec to (leg)Vec[SDXYZ].
-MachOper* Matcher::specialize_vector_operand_helper(MachNode* m, uint opnd_idx, const TypeVect* vt) {
-  MachOper* original_opnd = m->_opnds[opnd_idx];
-  uint ideal_reg = vt->ideal_reg();
-  // Handle special cases.
-  // LShiftCntV/RShiftCntV report wide vector type, but Matcher::vector_shift_count_ideal_reg() as ideal register (see vectornode.hpp).
-  // Look for shift count use sites as well (at vector shift nodes).
-  int opc = m->ideal_Opcode();
-  if ((VectorNode::is_vector_shift_count(opc)  && opnd_idx == 0) || // DEF operand of LShiftCntV/RShiftCntV
-      (VectorNode::is_vector_shift(opc)        && opnd_idx == 2)) { // shift operand of a vector shift node
-    ideal_reg = Matcher::vector_shift_count_ideal_reg(vt->length_in_bytes());
-  }
-  return Matcher::specialize_generic_vector_operand(original_opnd, ideal_reg, false);
-}
-
 // Compute concrete vector operand for a generic TEMP vector mach node based on its user info.
 void Matcher::specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx) {
   assert(use->in(idx) == tmp, "not a user");
   assert(!Matcher::is_generic_vector(use->_opnds[0]), "use not processed yet");
 
   if ((uint)idx == use->two_adr()) { // DEF_TEMP case
     tmp->_opnds[0] = use->_opnds[0]->clone();
   } else {
     uint ideal_vreg = vector_ideal_reg(C->max_vector_size());
-    tmp->_opnds[0] = specialize_generic_vector_operand(tmp->_opnds[0], ideal_vreg, true);
+    tmp->_opnds[0] = Matcher::pd_specialize_generic_vector_operand(tmp->_opnds[0], ideal_vreg, true /*is_temp*/);
   }
 }
 
 // Compute concrete vector operand for a generic DEF/USE vector operand (of mach node m at index idx).
 MachOper* Matcher::specialize_vector_operand(MachNode* m, uint opnd_idx) {
@@ -2562,11 +2547,13 @@
       } else if (is_generic_reg2reg_move(def->as_Mach())) {
         def = def->in(1); // skip over generic reg-to-reg moves
       }
     }
   }
-  return specialize_vector_operand_helper(m, opnd_idx, def->bottom_type()->is_vect());
+  assert(def->bottom_type()->isa_vect(), "not a vector");
+  uint ideal_vreg = def->bottom_type()->ideal_reg();
+  return Matcher::pd_specialize_generic_vector_operand(m->_opnds[opnd_idx], ideal_vreg, false /*is_temp*/);
 }
 
 void Matcher::specialize_mach_node(MachNode* m) {
   assert(!m->is_MachTemp(), "processed along with its user");
   // For generic use operands pull specific register class operands from

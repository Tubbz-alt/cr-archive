<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/node.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_NODE_HPP
  26 #define SHARE_OPTO_NODE_HPP
  27 
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;opto/compile.hpp&quot;
  30 #include &quot;opto/type.hpp&quot;
  31 
  32 // Portions of code courtesy of Clifford Click
  33 
  34 // Optimization - Graph Style
  35 
  36 
  37 class AbstractLockNode;
  38 class AddNode;
  39 class AddPNode;
  40 class AliasInfo;
  41 class AllocateArrayNode;
  42 class AllocateNode;
  43 class ArrayCopyNode;
  44 class Block;
  45 class BoolNode;
  46 class BoxLockNode;
  47 class CMoveNode;
  48 class CallDynamicJavaNode;
  49 class CallJavaNode;
  50 class CallLeafNode;
  51 class CallNode;
  52 class CallRuntimeNode;
  53 class CallStaticJavaNode;
  54 class CastIINode;
<a name="1" id="anc1"></a><span class="line-removed">  55 class CastLLNode;</span>
  56 class CatchNode;
  57 class CatchProjNode;
  58 class CheckCastPPNode;
  59 class ClearArrayNode;
  60 class CmpNode;
  61 class CodeBuffer;
  62 class ConstraintCastNode;
  63 class ConNode;
  64 class CompareAndSwapNode;
  65 class CompareAndExchangeNode;
  66 class CountedLoopNode;
  67 class CountedLoopEndNode;
  68 class DecodeNarrowPtrNode;
  69 class DecodeNNode;
  70 class DecodeNKlassNode;
  71 class EncodeNarrowPtrNode;
  72 class EncodePNode;
  73 class EncodePKlassNode;
  74 class FastLockNode;
  75 class FastUnlockNode;
  76 class HaltNode;
  77 class IfNode;
  78 class IfProjNode;
  79 class IfFalseNode;
  80 class IfTrueNode;
  81 class InitializeNode;
  82 class JVMState;
  83 class JumpNode;
  84 class JumpProjNode;
  85 class LoadNode;
  86 class LoadStoreNode;
  87 class LoadStoreConditionalNode;
  88 class LockNode;
  89 class LoopNode;
  90 class MachBranchNode;
  91 class MachCallDynamicJavaNode;
  92 class MachCallJavaNode;
  93 class MachCallLeafNode;
  94 class MachCallNode;
  95 class MachCallRuntimeNode;
  96 class MachCallStaticJavaNode;
  97 class MachConstantBaseNode;
  98 class MachConstantNode;
  99 class MachGotoNode;
 100 class MachIfNode;
 101 class MachJumpNode;
 102 class MachNode;
 103 class MachNullCheckNode;
 104 class MachProjNode;
 105 class MachPrologNode;
 106 class MachReturnNode;
 107 class MachSafePointNode;
 108 class MachSpillCopyNode;
 109 class MachTempNode;
 110 class MachMergeNode;
 111 class MachMemBarNode;
 112 class MachVEPNode;
 113 class Matcher;
 114 class MemBarNode;
 115 class MemBarStoreStoreNode;
 116 class MemNode;
 117 class MergeMemNode;
 118 class MulNode;
 119 class MultiNode;
 120 class MultiBranchNode;
 121 class NeverBranchNode;
 122 class OuterStripMinedLoopNode;
 123 class OuterStripMinedLoopEndNode;
 124 class Node;
 125 class Node_Array;
 126 class Node_List;
 127 class Node_Stack;
 128 class NullCheckNode;
 129 class OopMap;
 130 class ParmNode;
 131 class PCTableNode;
 132 class PhaseCCP;
 133 class PhaseGVN;
 134 class PhaseIterGVN;
 135 class PhaseRegAlloc;
 136 class PhaseTransform;
 137 class PhaseValues;
 138 class PhiNode;
 139 class Pipeline;
 140 class ProjNode;
 141 class RangeCheckNode;
 142 class RegMask;
 143 class RegionNode;
 144 class RootNode;
 145 class SafePointNode;
 146 class SafePointScalarObjectNode;
 147 class StartNode;
 148 class State;
 149 class StoreNode;
 150 class SubNode;
 151 class SubTypeCheckNode;
 152 class Type;
 153 class TypeNode;
 154 class UnlockNode;
 155 class ValueTypeBaseNode;
 156 class ValueTypeNode;
 157 class ValueTypePtrNode;
 158 class VectorNode;
 159 class LoadVectorNode;
 160 class StoreVectorNode;
 161 class VectorSet;
 162 typedef void (*NFunc)(Node&amp;,void*);
 163 extern &quot;C&quot; {
 164   typedef int (*C_sort_func_t)(const void *, const void *);
 165 }
 166 
 167 // The type of all node counts and indexes.
 168 // It must hold at least 16 bits, but must also be fast to load and store.
 169 // This type, if less than 32 bits, could limit the number of possible nodes.
 170 // (To make this type platform-specific, move to globalDefinitions_xxx.hpp.)
 171 typedef unsigned int node_idx_t;
 172 
 173 
 174 #ifndef OPTO_DU_ITERATOR_ASSERT
 175 #ifdef ASSERT
 176 #define OPTO_DU_ITERATOR_ASSERT 1
 177 #else
 178 #define OPTO_DU_ITERATOR_ASSERT 0
 179 #endif
 180 #endif //OPTO_DU_ITERATOR_ASSERT
 181 
 182 #if OPTO_DU_ITERATOR_ASSERT
 183 class DUIterator;
 184 class DUIterator_Fast;
 185 class DUIterator_Last;
 186 #else
 187 typedef uint   DUIterator;
 188 typedef Node** DUIterator_Fast;
 189 typedef Node** DUIterator_Last;
 190 #endif
 191 
 192 // Node Sentinel
 193 #define NodeSentinel (Node*)-1
 194 
 195 // Unknown count frequency
 196 #define COUNT_UNKNOWN (-1.0f)
 197 
 198 //------------------------------Node-------------------------------------------
 199 // Nodes define actions in the program.  They create values, which have types.
 200 // They are both vertices in a directed graph and program primitives.  Nodes
 201 // are labeled; the label is the &quot;opcode&quot;, the primitive function in the lambda
 202 // calculus sense that gives meaning to the Node.  Node inputs are ordered (so
 203 // that &quot;a-b&quot; is different from &quot;b-a&quot;).  The inputs to a Node are the inputs to
 204 // the Node&#39;s function.  These inputs also define a Type equation for the Node.
 205 // Solving these Type equations amounts to doing dataflow analysis.
 206 // Control and data are uniformly represented in the graph.  Finally, Nodes
 207 // have a unique dense integer index which is used to index into side arrays
 208 // whenever I have phase-specific information.
 209 
 210 class Node {
 211   friend class VMStructs;
 212 
 213   // Lots of restrictions on cloning Nodes
 214   Node(const Node&amp;);            // not defined; linker error to use these
 215   Node &amp;operator=(const Node &amp;rhs);
 216 
 217 public:
 218   friend class Compile;
 219   #if OPTO_DU_ITERATOR_ASSERT
 220   friend class DUIterator_Common;
 221   friend class DUIterator;
 222   friend class DUIterator_Fast;
 223   friend class DUIterator_Last;
 224   #endif
 225 
 226   // Because Nodes come and go, I define an Arena of Node structures to pull
 227   // from.  This should allow fast access to node creation &amp; deletion.  This
 228   // field is a local cache of a value defined in some &quot;program fragment&quot; for
 229   // which these Nodes are just a part of.
 230 
 231   inline void* operator new(size_t x) throw() {
 232     Compile* C = Compile::current();
 233     Node* n = (Node*)C-&gt;node_arena()-&gt;Amalloc_D(x);
 234     return (void*)n;
 235   }
 236 
 237   // Delete is a NOP
 238   void operator delete( void *ptr ) {}
 239   // Fancy destructor; eagerly attempt to reclaim Node numberings and storage
 240   void destruct();
 241 
 242   // Create a new Node.  Required is the number is of inputs required for
 243   // semantic correctness.
 244   Node( uint required );
 245 
 246   // Create a new Node with given input edges.
 247   // This version requires use of the &quot;edge-count&quot; new.
 248   // E.g.  new (C,3) FooNode( C, NULL, left, right );
 249   Node( Node *n0 );
 250   Node( Node *n0, Node *n1 );
 251   Node( Node *n0, Node *n1, Node *n2 );
 252   Node( Node *n0, Node *n1, Node *n2, Node *n3 );
 253   Node( Node *n0, Node *n1, Node *n2, Node *n3, Node *n4 );
 254   Node( Node *n0, Node *n1, Node *n2, Node *n3, Node *n4, Node *n5 );
 255   Node( Node *n0, Node *n1, Node *n2, Node *n3,
 256             Node *n4, Node *n5, Node *n6 );
 257 
 258   // Clone an inherited Node given only the base Node type.
 259   Node* clone() const;
 260 
 261   // Clone a Node, immediately supplying one or two new edges.
 262   // The first and second arguments, if non-null, replace in(1) and in(2),
 263   // respectively.
 264   Node* clone_with_data_edge(Node* in1, Node* in2 = NULL) const {
 265     Node* nn = clone();
 266     if (in1 != NULL)  nn-&gt;set_req(1, in1);
 267     if (in2 != NULL)  nn-&gt;set_req(2, in2);
 268     return nn;
 269   }
 270 
 271 private:
 272   // Shared setup for the above constructors.
 273   // Handles all interactions with Compile::current.
 274   // Puts initial values in all Node fields except _idx.
 275   // Returns the initial value for _idx, which cannot
 276   // be initialized by assignment.
 277   inline int Init(int req);
 278 
 279 //----------------- input edge handling
 280 protected:
 281   friend class PhaseCFG;        // Access to address of _in array elements
 282   Node **_in;                   // Array of use-def references to Nodes
 283   Node **_out;                  // Array of def-use references to Nodes
 284 
 285   // Input edges are split into two categories.  Required edges are required
 286   // for semantic correctness; order is important and NULLs are allowed.
 287   // Precedence edges are used to help determine execution order and are
 288   // added, e.g., for scheduling purposes.  They are unordered and not
 289   // duplicated; they have no embedded NULLs.  Edges from 0 to _cnt-1
 290   // are required, from _cnt to _max-1 are precedence edges.
 291   node_idx_t _cnt;              // Total number of required Node inputs.
 292 
 293   node_idx_t _max;              // Actual length of input array.
 294 
 295   // Output edges are an unordered list of def-use edges which exactly
 296   // correspond to required input edges which point from other nodes
 297   // to this one.  Thus the count of the output edges is the number of
 298   // users of this node.
 299   node_idx_t _outcnt;           // Total number of Node outputs.
 300 
 301   node_idx_t _outmax;           // Actual length of output array.
 302 
 303   // Grow the actual input array to the next larger power-of-2 bigger than len.
 304   void grow( uint len );
 305   // Grow the output array to the next larger power-of-2 bigger than len.
 306   void out_grow( uint len );
 307 
 308  public:
 309   // Each Node is assigned a unique small/dense number.  This number is used
 310   // to index into auxiliary arrays of data and bit vectors.
 311   // The field _idx is declared constant to defend against inadvertent assignments,
 312   // since it is used by clients as a naked field. However, the field&#39;s value can be
 313   // changed using the set_idx() method.
 314   //
 315   // The PhaseRenumberLive phase renumbers nodes based on liveness information.
 316   // Therefore, it updates the value of the _idx field. The parse-time _idx is
 317   // preserved in _parse_idx.
 318   const node_idx_t _idx;
 319   DEBUG_ONLY(const node_idx_t _parse_idx;)
 320 
 321   // Get the (read-only) number of input edges
 322   uint req() const { return _cnt; }
 323   uint len() const { return _max; }
 324   // Get the (read-only) number of output edges
 325   uint outcnt() const { return _outcnt; }
 326 
 327 #if OPTO_DU_ITERATOR_ASSERT
 328   // Iterate over the out-edges of this node.  Deletions are illegal.
 329   inline DUIterator outs() const;
 330   // Use this when the out array might have changed to suppress asserts.
 331   inline DUIterator&amp; refresh_out_pos(DUIterator&amp; i) const;
 332   // Does the node have an out at this position?  (Used for iteration.)
 333   inline bool has_out(DUIterator&amp; i) const;
 334   inline Node*    out(DUIterator&amp; i) const;
 335   // Iterate over the out-edges of this node.  All changes are illegal.
 336   inline DUIterator_Fast fast_outs(DUIterator_Fast&amp; max) const;
 337   inline Node*    fast_out(DUIterator_Fast&amp; i) const;
 338   // Iterate over the out-edges of this node, deleting one at a time.
 339   inline DUIterator_Last last_outs(DUIterator_Last&amp; min) const;
 340   inline Node*    last_out(DUIterator_Last&amp; i) const;
 341   // The inline bodies of all these methods are after the iterator definitions.
 342 #else
 343   // Iterate over the out-edges of this node.  Deletions are illegal.
 344   // This iteration uses integral indexes, to decouple from array reallocations.
 345   DUIterator outs() const  { return 0; }
 346   // Use this when the out array might have changed to suppress asserts.
 347   DUIterator refresh_out_pos(DUIterator i) const { return i; }
 348 
 349   // Reference to the i&#39;th output Node.  Error if out of bounds.
 350   Node*    out(DUIterator i) const { assert(i &lt; _outcnt, &quot;oob&quot;); return _out[i]; }
 351   // Does the node have an out at this position?  (Used for iteration.)
 352   bool has_out(DUIterator i) const { return i &lt; _outcnt; }
 353 
 354   // Iterate over the out-edges of this node.  All changes are illegal.
 355   // This iteration uses a pointer internal to the out array.
 356   DUIterator_Fast fast_outs(DUIterator_Fast&amp; max) const {
 357     Node** out = _out;
 358     // Assign a limit pointer to the reference argument:
 359     max = out + (ptrdiff_t)_outcnt;
 360     // Return the base pointer:
 361     return out;
 362   }
 363   Node*    fast_out(DUIterator_Fast i) const  { return *i; }
 364   // Iterate over the out-edges of this node, deleting one at a time.
 365   // This iteration uses a pointer internal to the out array.
 366   DUIterator_Last last_outs(DUIterator_Last&amp; min) const {
 367     Node** out = _out;
 368     // Assign a limit pointer to the reference argument:
 369     min = out;
 370     // Return the pointer to the start of the iteration:
 371     return out + (ptrdiff_t)_outcnt - 1;
 372   }
 373   Node*    last_out(DUIterator_Last i) const  { return *i; }
 374 #endif
 375 
 376   // Reference to the i&#39;th input Node.  Error if out of bounds.
 377   Node* in(uint i) const { assert(i &lt; _max, &quot;oob: i=%d, _max=%d&quot;, i, _max); return _in[i]; }
 378   // Reference to the i&#39;th input Node.  NULL if out of bounds.
 379   Node* lookup(uint i) const { return ((i &lt; _max) ? _in[i] : NULL); }
 380   // Reference to the i&#39;th output Node.  Error if out of bounds.
 381   // Use this accessor sparingly.  We are going trying to use iterators instead.
 382   Node* raw_out(uint i) const { assert(i &lt; _outcnt,&quot;oob&quot;); return _out[i]; }
 383   // Return the unique out edge.
 384   Node* unique_out() const { assert(_outcnt==1,&quot;not unique&quot;); return _out[0]; }
 385   // Delete out edge at position &#39;i&#39; by moving last out edge to position &#39;i&#39;
 386   void  raw_del_out(uint i) {
 387     assert(i &lt; _outcnt,&quot;oob&quot;);
 388     assert(_outcnt &gt; 0,&quot;oob&quot;);
 389     #if OPTO_DU_ITERATOR_ASSERT
 390     // Record that a change happened here.
 391     debug_only(_last_del = _out[i]; ++_del_tick);
 392     #endif
 393     _out[i] = _out[--_outcnt];
 394     // Smash the old edge so it can&#39;t be used accidentally.
 395     debug_only(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);
 396   }
 397 
 398 #ifdef ASSERT
 399   bool is_dead() const;
 400 #define is_not_dead(n) ((n) == NULL || !VerifyIterativeGVN || !((n)-&gt;is_dead()))
 401   bool is_reachable_from_root() const;
 402 #endif
 403   // Check whether node has become unreachable
 404   bool is_unreachable(PhaseIterGVN &amp;igvn) const;
 405 
 406   // Set a required input edge, also updates corresponding output edge
 407   void add_req( Node *n ); // Append a NEW required input
 408   void add_req( Node *n0, Node *n1 ) {
 409     add_req(n0); add_req(n1); }
 410   void add_req( Node *n0, Node *n1, Node *n2 ) {
 411     add_req(n0); add_req(n1); add_req(n2); }
 412   void add_req_batch( Node* n, uint m ); // Append m NEW required inputs (all n).
 413   void del_req( uint idx ); // Delete required edge &amp; compact
 414   void del_req_ordered( uint idx ); // Delete required edge &amp; compact with preserved order
 415   void ins_req( uint i, Node *n ); // Insert a NEW required input
 416   void set_req( uint i, Node *n ) {
 417     assert( is_not_dead(n), &quot;can not use dead node&quot;);
 418     assert( i &lt; _cnt, &quot;oob: i=%d, _cnt=%d&quot;, i, _cnt);
 419     assert( !VerifyHashTableKeys || _hash_lock == 0,
 420             &quot;remove node from hash table before modifying it&quot;);
 421     Node** p = &amp;_in[i];    // cache this._in, across the del_out call
 422     if (*p != NULL)  (*p)-&gt;del_out((Node *)this);
 423     (*p) = n;
 424     if (n != NULL)      n-&gt;add_out((Node *)this);
 425     Compile::current()-&gt;record_modified_node(this);
 426   }
 427   // Light version of set_req() to init inputs after node creation.
 428   void init_req( uint i, Node *n ) {
 429     assert( i == 0 &amp;&amp; this == n ||
 430             is_not_dead(n), &quot;can not use dead node&quot;);
 431     assert( i &lt; _cnt, &quot;oob&quot;);
 432     assert( !VerifyHashTableKeys || _hash_lock == 0,
 433             &quot;remove node from hash table before modifying it&quot;);
 434     assert( _in[i] == NULL, &quot;sanity&quot;);
 435     _in[i] = n;
 436     if (n != NULL)      n-&gt;add_out((Node *)this);
 437     Compile::current()-&gt;record_modified_node(this);
 438   }
 439   // Find first occurrence of n among my edges:
 440   int find_edge(Node* n);
 441   int find_prec_edge(Node* n) {
 442     for (uint i = req(); i &lt; len(); i++) {
 443       if (_in[i] == n) return i;
 444       if (_in[i] == NULL) {
 445         DEBUG_ONLY( while ((++i) &lt; len()) assert(_in[i] == NULL, &quot;Gap in prec edges!&quot;); )
 446         break;
 447       }
 448     }
 449     return -1;
 450   }
 451   int replace_edge(Node* old, Node* neww);
 452   int replace_edges_in_range(Node* old, Node* neww, int start, int end);
 453   // NULL out all inputs to eliminate incoming Def-Use edges.
 454   // Return the number of edges between &#39;n&#39; and &#39;this&#39;
 455   int  disconnect_inputs(Node *n, Compile *c);
 456 
 457   // Quickly, return true if and only if I am Compile::current()-&gt;top().
 458   bool is_top() const {
 459     assert((this == (Node*) Compile::current()-&gt;top()) == (_out == NULL), &quot;&quot;);
 460     return (_out == NULL);
 461   }
 462   // Reaffirm invariants for is_top.  (Only from Compile::set_cached_top_node.)
 463   void setup_is_top();
 464 
 465   // Strip away casting.  (It is depth-limited.)
 466   Node* uncast(bool keep_deps = false) const;
 467   // Return whether two Nodes are equivalent, after stripping casting.
 468   bool eqv_uncast(const Node* n, bool keep_deps = false) const {
 469     return (this-&gt;uncast(keep_deps) == n-&gt;uncast(keep_deps));
 470   }
 471 
 472   // Find out of current node that matches opcode.
 473   Node* find_out_with(int opcode);
 474   // Return true if the current node has an out that matches opcode.
 475   bool has_out_with(int opcode);
 476   // Return true if the current node has an out that matches any of the opcodes.
 477   bool has_out_with(int opcode1, int opcode2, int opcode3, int opcode4);
 478 
 479 private:
 480   static Node* uncast_helper(const Node* n, bool keep_deps);
 481 
 482   // Add an output edge to the end of the list
 483   void add_out( Node *n ) {
 484     if (is_top())  return;
 485     if( _outcnt == _outmax ) out_grow(_outcnt);
 486     _out[_outcnt++] = n;
 487   }
 488   // Delete an output edge
 489   void del_out( Node *n ) {
 490     if (is_top())  return;
 491     Node** outp = &amp;_out[_outcnt];
 492     // Find and remove n
 493     do {
 494       assert(outp &gt; _out, &quot;Missing Def-Use edge&quot;);
 495     } while (*--outp != n);
 496     *outp = _out[--_outcnt];
 497     // Smash the old edge so it can&#39;t be used accidentally.
 498     debug_only(_out[_outcnt] = (Node *)(uintptr_t)0xdeadbeef);
 499     // Record that a change happened here.
 500     #if OPTO_DU_ITERATOR_ASSERT
 501     debug_only(_last_del = n; ++_del_tick);
 502     #endif
 503   }
 504   // Close gap after removing edge.
 505   void close_prec_gap_at(uint gap) {
 506     assert(_cnt &lt;= gap &amp;&amp; gap &lt; _max, &quot;no valid prec edge&quot;);
 507     uint i = gap;
 508     Node *last = NULL;
 509     for (; i &lt; _max-1; ++i) {
 510       Node *next = _in[i+1];
 511       if (next == NULL) break;
 512       last = next;
 513     }
 514     _in[gap] = last; // Move last slot to empty one.
 515     _in[i] = NULL;   // NULL out last slot.
 516   }
 517 
 518 public:
 519   // Globally replace this node by a given new node, updating all uses.
 520   void replace_by(Node* new_node);
 521   // Globally replace this node by a given new node, updating all uses
 522   // and cutting input edges of old node.
 523   void subsume_by(Node* new_node, Compile* c) {
 524     replace_by(new_node);
 525     disconnect_inputs(NULL, c);
 526   }
 527   void set_req_X( uint i, Node *n, PhaseIterGVN *igvn );
 528   // Find the one non-null required input.  RegionNode only
 529   Node *nonnull_req() const;
 530   // Add or remove precedence edges
 531   void add_prec( Node *n );
 532   void rm_prec( uint i );
 533 
 534   // Note: prec(i) will not necessarily point to n if edge already exists.
 535   void set_prec( uint i, Node *n ) {
 536     assert(i &lt; _max, &quot;oob: i=%d, _max=%d&quot;, i, _max);
 537     assert(is_not_dead(n), &quot;can not use dead node&quot;);
 538     assert(i &gt;= _cnt, &quot;not a precedence edge&quot;);
 539     // Avoid spec violation: duplicated prec edge.
 540     if (_in[i] == n) return;
 541     if (n == NULL || find_prec_edge(n) != -1) {
 542       rm_prec(i);
 543       return;
 544     }
 545     if (_in[i] != NULL) _in[i]-&gt;del_out((Node *)this);
 546     _in[i] = n;
 547     if (n != NULL) n-&gt;add_out((Node *)this);
 548   }
 549 
 550   // Set this node&#39;s index, used by cisc_version to replace current node
 551   void set_idx(uint new_idx) {
 552     const node_idx_t* ref = &amp;_idx;
 553     *(node_idx_t*)ref = new_idx;
 554   }
 555   // Swap input edge order.  (Edge indexes i1 and i2 are usually 1 and 2.)
 556   void swap_edges(uint i1, uint i2) {
 557     debug_only(uint check_hash = (VerifyHashTableKeys &amp;&amp; _hash_lock) ? hash() : NO_HASH);
 558     // Def-Use info is unchanged
 559     Node* n1 = in(i1);
 560     Node* n2 = in(i2);
 561     _in[i1] = n2;
 562     _in[i2] = n1;
 563     // If this node is in the hash table, make sure it doesn&#39;t need a rehash.
 564     assert(check_hash == NO_HASH || check_hash == hash(), &quot;edge swap must preserve hash code&quot;);
 565   }
 566 
 567   // Iterators over input Nodes for a Node X are written as:
 568   // for( i = 0; i &lt; X.req(); i++ ) ... X[i] ...
 569   // NOTE: Required edges can contain embedded NULL pointers.
 570 
 571 //----------------- Other Node Properties
 572 
 573   // Generate class IDs for (some) ideal nodes so that it is possible to determine
 574   // the type of a node using a non-virtual method call (the method is_&lt;Node&gt;() below).
 575   //
 576   // A class ID of an ideal node is a set of bits. In a class ID, a single bit determines
 577   // the type of the node the ID represents; another subset of an ID&#39;s bits are reserved
 578   // for the superclasses of the node represented by the ID.
 579   //
 580   // By design, if A is a supertype of B, A.is_B() returns true and B.is_A()
 581   // returns false. A.is_A() returns true.
 582   //
 583   // If two classes, A and B, have the same superclass, a different bit of A&#39;s class id
 584   // is reserved for A&#39;s type than for B&#39;s type. That bit is specified by the third
 585   // parameter in the macro DEFINE_CLASS_ID.
 586   //
 587   // By convention, classes with deeper hierarchy are declared first. Moreover,
 588   // classes with the same hierarchy depth are sorted by usage frequency.
 589   //
 590   // The query method masks the bits to cut off bits of subclasses and then compares
 591   // the result with the class id (see the macro DEFINE_CLASS_QUERY below).
 592   //
 593   //  Class_MachCall=30, ClassMask_MachCall=31
 594   // 12               8               4               0
 595   //  0   0   0   0   0   0   0   0   1   1   1   1   0
 596   //                                  |   |   |   |
 597   //                                  |   |   |   Bit_Mach=2
 598   //                                  |   |   Bit_MachReturn=4
 599   //                                  |   Bit_MachSafePoint=8
 600   //                                  Bit_MachCall=16
 601   //
 602   //  Class_CountedLoop=56, ClassMask_CountedLoop=63
 603   // 12               8               4               0
 604   //  0   0   0   0   0   0   0   1   1   1   0   0   0
 605   //                              |   |   |
 606   //                              |   |   Bit_Region=8
 607   //                              |   Bit_Loop=16
 608   //                              Bit_CountedLoop=32
 609 
 610   #define DEFINE_CLASS_ID(cl, supcl, subn) \
 611   Bit_##cl = (Class_##supcl == 0) ? 1 &lt;&lt; subn : (Bit_##supcl) &lt;&lt; (1 + subn) , \
 612   Class_##cl = Class_##supcl + Bit_##cl , \
 613   ClassMask_##cl = ((Bit_##cl &lt;&lt; 1) - 1) ,
 614 
 615   // This enum is used only for C2 ideal and mach nodes with is_&lt;node&gt;() methods
 616   // so that it&#39;s values fits into 16 bits.
 617   enum NodeClasses {
 618     Bit_Node   = 0x0000,
 619     Class_Node = 0x0000,
 620     ClassMask_Node = 0xFFFF,
 621 
 622     DEFINE_CLASS_ID(Multi, Node, 0)
 623       DEFINE_CLASS_ID(SafePoint, Multi, 0)
 624         DEFINE_CLASS_ID(Call,      SafePoint, 0)
 625           DEFINE_CLASS_ID(CallJava,         Call, 0)
 626             DEFINE_CLASS_ID(CallStaticJava,   CallJava, 0)
 627             DEFINE_CLASS_ID(CallDynamicJava,  CallJava, 1)
 628           DEFINE_CLASS_ID(CallRuntime,      Call, 1)
 629             DEFINE_CLASS_ID(CallLeaf,         CallRuntime, 0)
 630           DEFINE_CLASS_ID(Allocate,         Call, 2)
 631             DEFINE_CLASS_ID(AllocateArray,    Allocate, 0)
 632           DEFINE_CLASS_ID(AbstractLock,     Call, 3)
 633             DEFINE_CLASS_ID(Lock,             AbstractLock, 0)
 634             DEFINE_CLASS_ID(Unlock,           AbstractLock, 1)
 635           DEFINE_CLASS_ID(ArrayCopy,        Call, 4)
 636       DEFINE_CLASS_ID(MultiBranch, Multi, 1)
 637         DEFINE_CLASS_ID(PCTable,     MultiBranch, 0)
 638           DEFINE_CLASS_ID(Catch,       PCTable, 0)
 639           DEFINE_CLASS_ID(Jump,        PCTable, 1)
 640         DEFINE_CLASS_ID(If,          MultiBranch, 1)
 641           DEFINE_CLASS_ID(CountedLoopEnd,         If, 0)
 642           DEFINE_CLASS_ID(RangeCheck,             If, 1)
 643           DEFINE_CLASS_ID(OuterStripMinedLoopEnd, If, 2)
 644         DEFINE_CLASS_ID(NeverBranch, MultiBranch, 2)
 645       DEFINE_CLASS_ID(Start,       Multi, 2)
 646       DEFINE_CLASS_ID(MemBar,      Multi, 3)
 647         DEFINE_CLASS_ID(Initialize,       MemBar, 0)
 648         DEFINE_CLASS_ID(MemBarStoreStore, MemBar, 1)
 649 
 650     DEFINE_CLASS_ID(Mach,  Node, 1)
 651       DEFINE_CLASS_ID(MachReturn, Mach, 0)
 652         DEFINE_CLASS_ID(MachSafePoint, MachReturn, 0)
 653           DEFINE_CLASS_ID(MachCall, MachSafePoint, 0)
 654             DEFINE_CLASS_ID(MachCallJava,         MachCall, 0)
 655               DEFINE_CLASS_ID(MachCallStaticJava,   MachCallJava, 0)
 656               DEFINE_CLASS_ID(MachCallDynamicJava,  MachCallJava, 1)
 657             DEFINE_CLASS_ID(MachCallRuntime,      MachCall, 1)
 658               DEFINE_CLASS_ID(MachCallLeaf,         MachCallRuntime, 0)
 659       DEFINE_CLASS_ID(MachBranch, Mach, 1)
 660         DEFINE_CLASS_ID(MachIf,         MachBranch, 0)
 661         DEFINE_CLASS_ID(MachGoto,       MachBranch, 1)
 662         DEFINE_CLASS_ID(MachNullCheck,  MachBranch, 2)
 663       DEFINE_CLASS_ID(MachSpillCopy,    Mach, 2)
 664       DEFINE_CLASS_ID(MachTemp,         Mach, 3)
 665       DEFINE_CLASS_ID(MachConstantBase, Mach, 4)
 666       DEFINE_CLASS_ID(MachConstant,     Mach, 5)
 667         DEFINE_CLASS_ID(MachJump,       MachConstant, 0)
 668       DEFINE_CLASS_ID(MachMerge,        Mach, 6)
 669       DEFINE_CLASS_ID(MachMemBar,       Mach, 7)
 670       DEFINE_CLASS_ID(MachProlog,       Mach, 8)
 671       DEFINE_CLASS_ID(MachVEP,          Mach, 9)
 672 
 673     DEFINE_CLASS_ID(Type,  Node, 2)
 674       DEFINE_CLASS_ID(Phi,   Type, 0)
 675       DEFINE_CLASS_ID(ConstraintCast, Type, 1)
 676         DEFINE_CLASS_ID(CastII, ConstraintCast, 0)
<a name="2" id="anc2"></a><span class="line-modified"> 677         DEFINE_CLASS_ID(CastLL, ConstraintCast, 1)</span>
<span class="line-removed"> 678         DEFINE_CLASS_ID(CheckCastPP, ConstraintCast, 2)</span>
 679       DEFINE_CLASS_ID(CMove, Type, 3)
 680       DEFINE_CLASS_ID(SafePointScalarObject, Type, 4)
 681       DEFINE_CLASS_ID(DecodeNarrowPtr, Type, 5)
 682         DEFINE_CLASS_ID(DecodeN, DecodeNarrowPtr, 0)
 683         DEFINE_CLASS_ID(DecodeNKlass, DecodeNarrowPtr, 1)
 684       DEFINE_CLASS_ID(EncodeNarrowPtr, Type, 6)
 685         DEFINE_CLASS_ID(EncodeP, EncodeNarrowPtr, 0)
 686         DEFINE_CLASS_ID(EncodePKlass, EncodeNarrowPtr, 1)
 687       DEFINE_CLASS_ID(ValueTypeBase, Type, 8)
 688         DEFINE_CLASS_ID(ValueType, ValueTypeBase, 0)
 689         DEFINE_CLASS_ID(ValueTypePtr, ValueTypeBase, 1)
 690 
 691     DEFINE_CLASS_ID(Proj,  Node, 3)
 692       DEFINE_CLASS_ID(CatchProj, Proj, 0)
 693       DEFINE_CLASS_ID(JumpProj,  Proj, 1)
 694       DEFINE_CLASS_ID(IfProj,    Proj, 2)
 695         DEFINE_CLASS_ID(IfTrue,    IfProj, 0)
 696         DEFINE_CLASS_ID(IfFalse,   IfProj, 1)
 697       DEFINE_CLASS_ID(Parm,      Proj, 4)
 698       DEFINE_CLASS_ID(MachProj,  Proj, 5)
 699 
 700     DEFINE_CLASS_ID(Mem,   Node, 4)
 701       DEFINE_CLASS_ID(Load,  Mem, 0)
 702         DEFINE_CLASS_ID(LoadVector,  Load, 0)
 703       DEFINE_CLASS_ID(Store, Mem, 1)
 704         DEFINE_CLASS_ID(StoreVector, Store, 0)
 705       DEFINE_CLASS_ID(LoadStore, Mem, 2)
 706         DEFINE_CLASS_ID(LoadStoreConditional, LoadStore, 0)
 707           DEFINE_CLASS_ID(CompareAndSwap, LoadStoreConditional, 0)
 708         DEFINE_CLASS_ID(CompareAndExchangeNode, LoadStore, 1)
 709 
 710     DEFINE_CLASS_ID(Region, Node, 5)
 711       DEFINE_CLASS_ID(Loop, Region, 0)
 712         DEFINE_CLASS_ID(Root,                Loop, 0)
 713         DEFINE_CLASS_ID(CountedLoop,         Loop, 1)
 714         DEFINE_CLASS_ID(OuterStripMinedLoop, Loop, 2)
 715 
 716     DEFINE_CLASS_ID(Sub,   Node, 6)
 717       DEFINE_CLASS_ID(Cmp,   Sub, 0)
 718         DEFINE_CLASS_ID(FastLock,   Cmp, 0)
 719         DEFINE_CLASS_ID(FastUnlock, Cmp, 1)
 720         DEFINE_CLASS_ID(SubTypeCheck,Cmp, 2)
 721 
 722     DEFINE_CLASS_ID(MergeMem, Node, 7)
 723     DEFINE_CLASS_ID(Bool,     Node, 8)
 724     DEFINE_CLASS_ID(AddP,     Node, 9)
 725     DEFINE_CLASS_ID(BoxLock,  Node, 10)
 726     DEFINE_CLASS_ID(Add,      Node, 11)
 727     DEFINE_CLASS_ID(Mul,      Node, 12)
 728     DEFINE_CLASS_ID(Vector,   Node, 13)
 729     DEFINE_CLASS_ID(ClearArray, Node, 14)
 730     DEFINE_CLASS_ID(Halt, Node, 15)
 731 
 732     _max_classes  = ClassMask_Halt
 733   };
 734   #undef DEFINE_CLASS_ID
 735 
 736   // Flags are sorted by usage frequency.
 737   enum NodeFlags {
 738     Flag_is_Copy                     = 0x01, // should be first bit to avoid shift
 739     Flag_rematerialize               = Flag_is_Copy &lt;&lt; 1,
 740     Flag_needs_anti_dependence_check = Flag_rematerialize &lt;&lt; 1,
 741     Flag_is_macro                    = Flag_needs_anti_dependence_check &lt;&lt; 1,
 742     Flag_is_Con                      = Flag_is_macro &lt;&lt; 1,
 743     Flag_is_cisc_alternate           = Flag_is_Con &lt;&lt; 1,
 744     Flag_is_dead_loop_safe           = Flag_is_cisc_alternate &lt;&lt; 1,
 745     Flag_may_be_short_branch         = Flag_is_dead_loop_safe &lt;&lt; 1,
 746     Flag_avoid_back_to_back_before   = Flag_may_be_short_branch &lt;&lt; 1,
 747     Flag_avoid_back_to_back_after    = Flag_avoid_back_to_back_before &lt;&lt; 1,
 748     Flag_has_call                    = Flag_avoid_back_to_back_after &lt;&lt; 1,
 749     Flag_is_reduction                = Flag_has_call &lt;&lt; 1,
 750     Flag_is_scheduled                = Flag_is_reduction &lt;&lt; 1,
 751     Flag_has_vector_mask_set         = Flag_is_scheduled &lt;&lt; 1,
 752     Flag_is_expensive                = Flag_has_vector_mask_set &lt;&lt; 1,
 753     _last_flag                       = Flag_is_expensive
 754   };
 755 
 756   class PD;
 757 
 758 private:
 759   jushort _class_id;
 760   jushort _flags;
 761 
 762   static juint max_flags();
 763 
 764 protected:
 765   // These methods should be called from constructors only.
 766   void init_class_id(jushort c) {
 767     _class_id = c; // cast out const
 768   }
 769   void init_flags(uint fl) {
 770     assert(fl &lt;= max_flags(), &quot;invalid node flag&quot;);
 771     _flags |= fl;
 772   }
 773   void clear_flag(uint fl) {
 774     assert(fl &lt;= max_flags(), &quot;invalid node flag&quot;);
 775     _flags &amp;= ~fl;
 776   }
 777 
 778 public:
 779   const jushort class_id() const { return _class_id; }
 780 
 781   const jushort flags() const { return _flags; }
 782 
 783   void add_flag(jushort fl) { init_flags(fl); }
 784 
 785   void remove_flag(jushort fl) { clear_flag(fl); }
 786 
 787   // Return a dense integer opcode number
 788   virtual int Opcode() const;
 789 
 790   // Virtual inherited Node size
 791   virtual uint size_of() const;
 792 
 793   // Other interesting Node properties
 794   #define DEFINE_CLASS_QUERY(type)                           \
 795   bool is_##type() const {                                   \
 796     return ((_class_id &amp; ClassMask_##type) == Class_##type); \
 797   }                                                          \
 798   type##Node *as_##type() const {                            \
 799     assert(is_##type(), &quot;invalid node class&quot;);               \
 800     return (type##Node*)this;                                \
 801   }                                                          \
 802   type##Node* isa_##type() const {                           \
 803     return (is_##type()) ? as_##type() : NULL;               \
 804   }
 805 
 806   DEFINE_CLASS_QUERY(AbstractLock)
 807   DEFINE_CLASS_QUERY(Add)
 808   DEFINE_CLASS_QUERY(AddP)
 809   DEFINE_CLASS_QUERY(Allocate)
 810   DEFINE_CLASS_QUERY(AllocateArray)
 811   DEFINE_CLASS_QUERY(ArrayCopy)
 812   DEFINE_CLASS_QUERY(Bool)
 813   DEFINE_CLASS_QUERY(BoxLock)
 814   DEFINE_CLASS_QUERY(Call)
 815   DEFINE_CLASS_QUERY(CallDynamicJava)
 816   DEFINE_CLASS_QUERY(CallJava)
 817   DEFINE_CLASS_QUERY(CallLeaf)
 818   DEFINE_CLASS_QUERY(CallRuntime)
 819   DEFINE_CLASS_QUERY(CallStaticJava)
 820   DEFINE_CLASS_QUERY(Catch)
 821   DEFINE_CLASS_QUERY(CatchProj)
 822   DEFINE_CLASS_QUERY(CheckCastPP)
 823   DEFINE_CLASS_QUERY(CastII)
<a name="3" id="anc3"></a><span class="line-removed"> 824   DEFINE_CLASS_QUERY(CastLL)</span>
 825   DEFINE_CLASS_QUERY(ConstraintCast)
 826   DEFINE_CLASS_QUERY(ClearArray)
 827   DEFINE_CLASS_QUERY(CMove)
 828   DEFINE_CLASS_QUERY(Cmp)
 829   DEFINE_CLASS_QUERY(CountedLoop)
 830   DEFINE_CLASS_QUERY(CountedLoopEnd)
 831   DEFINE_CLASS_QUERY(DecodeNarrowPtr)
 832   DEFINE_CLASS_QUERY(DecodeN)
 833   DEFINE_CLASS_QUERY(DecodeNKlass)
 834   DEFINE_CLASS_QUERY(EncodeNarrowPtr)
 835   DEFINE_CLASS_QUERY(EncodeP)
 836   DEFINE_CLASS_QUERY(EncodePKlass)
 837   DEFINE_CLASS_QUERY(FastLock)
 838   DEFINE_CLASS_QUERY(FastUnlock)
 839   DEFINE_CLASS_QUERY(Halt)
 840   DEFINE_CLASS_QUERY(If)
 841   DEFINE_CLASS_QUERY(RangeCheck)
 842   DEFINE_CLASS_QUERY(IfProj)
 843   DEFINE_CLASS_QUERY(IfFalse)
 844   DEFINE_CLASS_QUERY(IfTrue)
 845   DEFINE_CLASS_QUERY(Initialize)
 846   DEFINE_CLASS_QUERY(Jump)
 847   DEFINE_CLASS_QUERY(JumpProj)
 848   DEFINE_CLASS_QUERY(Load)
 849   DEFINE_CLASS_QUERY(LoadStore)
 850   DEFINE_CLASS_QUERY(LoadStoreConditional)
 851   DEFINE_CLASS_QUERY(Lock)
 852   DEFINE_CLASS_QUERY(Loop)
 853   DEFINE_CLASS_QUERY(Mach)
 854   DEFINE_CLASS_QUERY(MachBranch)
 855   DEFINE_CLASS_QUERY(MachCall)
 856   DEFINE_CLASS_QUERY(MachCallDynamicJava)
 857   DEFINE_CLASS_QUERY(MachCallJava)
 858   DEFINE_CLASS_QUERY(MachCallLeaf)
 859   DEFINE_CLASS_QUERY(MachCallRuntime)
 860   DEFINE_CLASS_QUERY(MachCallStaticJava)
 861   DEFINE_CLASS_QUERY(MachConstantBase)
 862   DEFINE_CLASS_QUERY(MachConstant)
 863   DEFINE_CLASS_QUERY(MachGoto)
 864   DEFINE_CLASS_QUERY(MachIf)
 865   DEFINE_CLASS_QUERY(MachJump)
 866   DEFINE_CLASS_QUERY(MachNullCheck)
 867   DEFINE_CLASS_QUERY(MachProj)
 868   DEFINE_CLASS_QUERY(MachProlog)
 869   DEFINE_CLASS_QUERY(MachReturn)
 870   DEFINE_CLASS_QUERY(MachSafePoint)
 871   DEFINE_CLASS_QUERY(MachSpillCopy)
 872   DEFINE_CLASS_QUERY(MachTemp)
 873   DEFINE_CLASS_QUERY(MachMemBar)
 874   DEFINE_CLASS_QUERY(MachMerge)
 875   DEFINE_CLASS_QUERY(MachVEP)
 876   DEFINE_CLASS_QUERY(Mem)
 877   DEFINE_CLASS_QUERY(MemBar)
 878   DEFINE_CLASS_QUERY(MemBarStoreStore)
 879   DEFINE_CLASS_QUERY(MergeMem)
 880   DEFINE_CLASS_QUERY(Mul)
 881   DEFINE_CLASS_QUERY(Multi)
 882   DEFINE_CLASS_QUERY(MultiBranch)
 883   DEFINE_CLASS_QUERY(OuterStripMinedLoop)
 884   DEFINE_CLASS_QUERY(OuterStripMinedLoopEnd)
 885   DEFINE_CLASS_QUERY(Parm)
 886   DEFINE_CLASS_QUERY(PCTable)
 887   DEFINE_CLASS_QUERY(Phi)
 888   DEFINE_CLASS_QUERY(Proj)
 889   DEFINE_CLASS_QUERY(Region)
 890   DEFINE_CLASS_QUERY(Root)
 891   DEFINE_CLASS_QUERY(SafePoint)
 892   DEFINE_CLASS_QUERY(SafePointScalarObject)
 893   DEFINE_CLASS_QUERY(Start)
 894   DEFINE_CLASS_QUERY(Store)
 895   DEFINE_CLASS_QUERY(Sub)
 896   DEFINE_CLASS_QUERY(SubTypeCheck)
 897   DEFINE_CLASS_QUERY(Type)
 898   DEFINE_CLASS_QUERY(ValueType)
 899   DEFINE_CLASS_QUERY(ValueTypeBase)
 900   DEFINE_CLASS_QUERY(ValueTypePtr)
 901   DEFINE_CLASS_QUERY(Vector)
 902   DEFINE_CLASS_QUERY(LoadVector)
 903   DEFINE_CLASS_QUERY(StoreVector)
 904   DEFINE_CLASS_QUERY(Unlock)
 905 
 906   #undef DEFINE_CLASS_QUERY
 907 
 908   // duplicate of is_MachSpillCopy()
 909   bool is_SpillCopy () const {
 910     return ((_class_id &amp; ClassMask_MachSpillCopy) == Class_MachSpillCopy);
 911   }
 912 
 913   bool is_Con () const { return (_flags &amp; Flag_is_Con) != 0; }
 914   // The data node which is safe to leave in dead loop during IGVN optimization.
 915   bool is_dead_loop_safe() const {
 916     return is_Phi() || (is_Proj() &amp;&amp; in(0) == NULL) ||
 917            ((_flags &amp; (Flag_is_dead_loop_safe | Flag_is_Con)) != 0 &amp;&amp;
 918             (!is_Proj() || !in(0)-&gt;is_Allocate()));
 919   }
 920 
 921   // is_Copy() returns copied edge index (0 or 1)
 922   uint is_Copy() const { return (_flags &amp; Flag_is_Copy); }
 923 
 924   virtual bool is_CFG() const { return false; }
 925 
 926   // If this node is control-dependent on a test, can it be
 927   // rerouted to a dominating equivalent test?  This is usually
 928   // true of non-CFG nodes, but can be false for operations which
 929   // depend for their correct sequencing on more than one test.
 930   // (In that case, hoisting to a dominating test may silently
 931   // skip some other important test.)
 932   virtual bool depends_only_on_test() const { assert(!is_CFG(), &quot;&quot;); return true; };
 933 
 934   // When building basic blocks, I need to have a notion of block beginning
 935   // Nodes, next block selector Nodes (block enders), and next block
 936   // projections.  These calls need to work on their machine equivalents.  The
 937   // Ideal beginning Nodes are RootNode, RegionNode and StartNode.
 938   bool is_block_start() const {
 939     if ( is_Region() )
 940       return this == (const Node*)in(0);
 941     else
 942       return is_Start();
 943   }
 944 
 945   // The Ideal control projection Nodes are IfTrue/IfFalse, JumpProjNode, Root,
 946   // Goto and Return.  This call also returns the block ending Node.
 947   virtual const Node *is_block_proj() const;
 948 
 949   // The node is a &quot;macro&quot; node which needs to be expanded before matching
 950   bool is_macro() const { return (_flags &amp; Flag_is_macro) != 0; }
 951   // The node is expensive: the best control is set during loop opts
 952   bool is_expensive() const { return (_flags &amp; Flag_is_expensive) != 0 &amp;&amp; in(0) != NULL; }
 953 
 954   // An arithmetic node which accumulates a data in a loop.
 955   // It must have the loop&#39;s phi as input and provide a def to the phi.
 956   bool is_reduction() const { return (_flags &amp; Flag_is_reduction) != 0; }
 957 
 958   // The node is a CountedLoopEnd with a mask annotation so as to emit a restore context
 959   bool has_vector_mask_set() const { return (_flags &amp; Flag_has_vector_mask_set) != 0; }
 960 
 961   // Used in lcm to mark nodes that have scheduled
 962   bool is_scheduled() const { return (_flags &amp; Flag_is_scheduled) != 0; }
 963 
 964 //----------------- Optimization
 965 
 966   // Get the worst-case Type output for this Node.
 967   virtual const class Type *bottom_type() const;
 968 
 969   // If we find a better type for a node, try to record it permanently.
 970   // Return true if this node actually changed.
 971   // Be sure to do the hash_delete game in the &quot;rehash&quot; variant.
 972   void raise_bottom_type(const Type* new_type);
 973 
 974   // Get the address type with which this node uses and/or defs memory,
 975   // or NULL if none.  The address type is conservatively wide.
 976   // Returns non-null for calls, membars, loads, stores, etc.
 977   // Returns TypePtr::BOTTOM if the node touches memory &quot;broadly&quot;.
 978   virtual const class TypePtr *adr_type() const { return NULL; }
 979 
 980   // Return an existing node which computes the same function as this node.
 981   // The optimistic combined algorithm requires this to return a Node which
 982   // is a small number of steps away (e.g., one of my inputs).
 983   virtual Node* Identity(PhaseGVN* phase);
 984 
 985   // Return the set of values this Node can take on at runtime.
 986   virtual const Type* Value(PhaseGVN* phase) const;
 987 
 988   // Return a node which is more &quot;ideal&quot; than the current node.
 989   // The invariants on this call are subtle.  If in doubt, read the
 990   // treatise in node.cpp above the default implemention AND TEST WITH
 991   // +VerifyIterativeGVN!
 992   virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);
 993 
 994   // Some nodes have specific Ideal subgraph transformations only if they are
 995   // unique users of specific nodes. Such nodes should be put on IGVN worklist
 996   // for the transformations to happen.
 997   bool has_special_unique_user() const;
 998 
 999   // Skip Proj and CatchProj nodes chains. Check for Null and Top.
1000   Node* find_exact_control(Node* ctrl);
1001 
1002   // Check if &#39;this&#39; node dominates or equal to &#39;sub&#39;.
1003   bool dominates(Node* sub, Node_List &amp;nlist);
1004 
1005 protected:
1006   bool remove_dead_region(PhaseGVN *phase, bool can_reshape);
1007 public:
1008 
1009   // See if there is valid pipeline info
1010   static  const Pipeline *pipeline_class();
1011   virtual const Pipeline *pipeline() const;
1012 
1013   // Compute the latency from the def to this instruction of the ith input node
1014   uint latency(uint i);
1015 
1016   // Hash &amp; compare functions, for pessimistic value numbering
1017 
1018   // If the hash function returns the special sentinel value NO_HASH,
1019   // the node is guaranteed never to compare equal to any other node.
1020   // If we accidentally generate a hash with value NO_HASH the node
1021   // won&#39;t go into the table and we&#39;ll lose a little optimization.
1022   static const uint NO_HASH = 0;
1023   virtual uint hash() const;
1024   virtual bool cmp( const Node &amp;n ) const;
1025 
1026   // Operation appears to be iteratively computed (such as an induction variable)
1027   // It is possible for this operation to return false for a loop-varying
1028   // value, if it appears (by local graph inspection) to be computed by a simple conditional.
1029   bool is_iteratively_computed();
1030 
1031   // Determine if a node is a counted loop induction variable.
1032   // NOTE: The method is defined in &quot;loopnode.cpp&quot;.
1033   bool is_cloop_ind_var() const;
1034 
1035   // Return a node with opcode &quot;opc&quot; and same inputs as &quot;this&quot; if one can
1036   // be found; Otherwise return NULL;
1037   Node* find_similar(int opc);
1038 
1039   // Return the unique control out if only one. Null if none or more than one.
1040   Node* unique_ctrl_out() const;
1041 
1042   // Set control or add control as precedence edge
1043   void ensure_control_or_add_prec(Node* c);
1044 
1045 //----------------- Code Generation
1046 
1047   // Ideal register class for Matching.  Zero means unmatched instruction
1048   // (these are cloned instead of converted to machine nodes).
1049   virtual uint ideal_reg() const;
1050 
1051   static const uint NotAMachineReg;   // must be &gt; max. machine register
1052 
1053   // Do we Match on this edge index or not?  Generally false for Control
1054   // and true for everything else.  Weird for calls &amp; returns.
1055   virtual uint match_edge(uint idx) const;
1056 
1057   // Register class output is returned in
1058   virtual const RegMask &amp;out_RegMask() const;
1059   // Register class input is expected in
1060   virtual const RegMask &amp;in_RegMask(uint) const;
1061   // Should we clone rather than spill this instruction?
1062   bool rematerialize() const;
1063 
1064   // Return JVM State Object if this Node carries debug info, or NULL otherwise
1065   virtual JVMState* jvms() const;
1066 
1067   // Print as assembly
1068   virtual void format( PhaseRegAlloc *, outputStream* st = tty ) const;
1069   // Emit bytes starting at parameter &#39;ptr&#39;
1070   // Bump &#39;ptr&#39; by the number of output bytes
1071   virtual void emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const;
1072   // Size of instruction in bytes
1073   virtual uint size(PhaseRegAlloc *ra_) const;
1074 
1075   // Convenience function to extract an integer constant from a node.
1076   // If it is not an integer constant (either Con, CastII, or Mach),
1077   // return value_if_unknown.
1078   jint find_int_con(jint value_if_unknown) const {
1079     const TypeInt* t = find_int_type();
1080     return (t != NULL &amp;&amp; t-&gt;is_con()) ? t-&gt;get_con() : value_if_unknown;
1081   }
1082   // Return the constant, knowing it is an integer constant already
1083   jint get_int() const {
1084     const TypeInt* t = find_int_type();
1085     guarantee(t != NULL, &quot;must be con&quot;);
1086     return t-&gt;get_con();
1087   }
1088   // Here&#39;s where the work is done.  Can produce non-constant int types too.
1089   const TypeInt* find_int_type() const;
1090 
1091   // Same thing for long (and intptr_t, via type.hpp):
1092   jlong get_long() const {
1093     const TypeLong* t = find_long_type();
1094     guarantee(t != NULL, &quot;must be con&quot;);
1095     return t-&gt;get_con();
1096   }
1097   jlong find_long_con(jint value_if_unknown) const {
1098     const TypeLong* t = find_long_type();
1099     return (t != NULL &amp;&amp; t-&gt;is_con()) ? t-&gt;get_con() : value_if_unknown;
1100   }
1101   const TypeLong* find_long_type() const;
1102 
1103   const TypePtr* get_ptr_type() const;
1104 
1105   // These guys are called by code generated by ADLC:
1106   intptr_t get_ptr() const;
1107   intptr_t get_narrowcon() const;
1108   jdouble getd() const;
1109   jfloat getf() const;
1110 
1111   // Nodes which are pinned into basic blocks
1112   virtual bool pinned() const { return false; }
1113 
1114   // Nodes which use memory without consuming it, hence need antidependences
1115   // More specifically, needs_anti_dependence_check returns true iff the node
1116   // (a) does a load, and (b) does not perform a store (except perhaps to a
1117   // stack slot or some other unaliased location).
1118   bool needs_anti_dependence_check() const;
1119 
1120   // Return which operand this instruction may cisc-spill. In other words,
1121   // return operand position that can convert from reg to memory access
1122   virtual int cisc_operand() const { return AdlcVMDeps::Not_cisc_spillable; }
1123   bool is_cisc_alternate() const { return (_flags &amp; Flag_is_cisc_alternate) != 0; }
1124 
1125 //----------------- Graph walking
1126 public:
1127   // Walk and apply member functions recursively.
1128   // Supplied (this) pointer is root.
1129   void walk(NFunc pre, NFunc post, void *env);
1130   static void nop(Node &amp;, void*); // Dummy empty function
1131   static void packregion( Node &amp;n, void* );
1132 private:
1133   void walk_(NFunc pre, NFunc post, void *env, VectorSet &amp;visited);
1134 
1135 //----------------- Printing, etc
1136 public:
1137 #ifndef PRODUCT
1138   Node* find(int idx) const;         // Search the graph for the given idx.
1139   Node* find_ctrl(int idx) const;    // Search control ancestors for the given idx.
1140   void dump() const { dump(&quot;\n&quot;); }  // Print this node.
1141   void dump(const char* suffix, bool mark = false, outputStream *st = tty) const; // Print this node.
1142   void dump(int depth) const;        // Print this node, recursively to depth d
1143   void dump_ctrl(int depth) const;   // Print control nodes, to depth d
1144   void dump_comp() const;            // Print this node in compact representation.
1145   // Print this node in compact representation.
1146   void dump_comp(const char* suffix, outputStream *st = tty) const;
1147   virtual void dump_req(outputStream *st = tty) const;    // Print required-edge info
1148   virtual void dump_prec(outputStream *st = tty) const;   // Print precedence-edge info
1149   virtual void dump_out(outputStream *st = tty) const;    // Print the output edge info
1150   virtual void dump_spec(outputStream *st) const {};      // Print per-node info
1151   // Print compact per-node info
1152   virtual void dump_compact_spec(outputStream *st) const { dump_spec(st); }
1153   void dump_related() const;             // Print related nodes (depends on node at hand).
1154   // Print related nodes up to given depths for input and output nodes.
1155   void dump_related(uint d_in, uint d_out) const;
1156   void dump_related_compact() const;     // Print related nodes in compact representation.
1157   // Collect related nodes.
1158   virtual void related(GrowableArray&lt;Node*&gt; *in_rel, GrowableArray&lt;Node*&gt; *out_rel, bool compact) const;
1159   // Collect nodes starting from this node, explicitly including/excluding control and data links.
1160   void collect_nodes(GrowableArray&lt;Node*&gt; *ns, int d, bool ctrl, bool data) const;
1161 
1162   // Node collectors, to be used in implementations of Node::rel().
1163   // Collect the entire data input graph. Include control inputs if requested.
1164   void collect_nodes_in_all_data(GrowableArray&lt;Node*&gt; *ns, bool ctrl) const;
1165   // Collect the entire control input graph. Include data inputs if requested.
1166   void collect_nodes_in_all_ctrl(GrowableArray&lt;Node*&gt; *ns, bool data) const;
1167   // Collect the entire output graph until hitting and including control nodes.
1168   void collect_nodes_out_all_ctrl_boundary(GrowableArray&lt;Node*&gt; *ns) const;
1169 
1170   void verify_edges(Unique_Node_List &amp;visited); // Verify bi-directional edges
1171   void verify() const;               // Check Def-Use info for my subgraph
1172   static void verify_recur(const Node *n, int verify_depth, VectorSet &amp;old_space, VectorSet &amp;new_space);
1173 
1174   // This call defines a class-unique string used to identify class instances
1175   virtual const char *Name() const;
1176 
1177   void dump_format(PhaseRegAlloc *ra) const; // debug access to MachNode::format(...)
1178   // RegMask Print Functions
1179   void dump_in_regmask(int idx) { in_RegMask(idx).dump(); }
1180   void dump_out_regmask() { out_RegMask().dump(); }
1181   static bool in_dump() { return Compile::current()-&gt;_in_dump_cnt &gt; 0; }
1182   void fast_dump() const {
1183     tty-&gt;print(&quot;%4d: %-17s&quot;, _idx, Name());
1184     for (uint i = 0; i &lt; len(); i++)
1185       if (in(i))
1186         tty-&gt;print(&quot; %4d&quot;, in(i)-&gt;_idx);
1187       else
1188         tty-&gt;print(&quot; NULL&quot;);
1189     tty-&gt;print(&quot;\n&quot;);
1190   }
1191 #endif
1192 #ifdef ASSERT
1193   void verify_construction();
1194   bool verify_jvms(const JVMState* jvms) const;
1195   int  _debug_idx;                     // Unique value assigned to every node.
1196   int   debug_idx() const              { return _debug_idx; }
1197   void  set_debug_idx( int debug_idx ) { _debug_idx = debug_idx; }
1198 
1199   Node* _debug_orig;                   // Original version of this, if any.
1200   Node*  debug_orig() const            { return _debug_orig; }
1201   void   set_debug_orig(Node* orig);   // _debug_orig = orig
1202   void   dump_orig(outputStream *st, bool print_key = true) const;
1203 
1204   int        _hash_lock;               // Barrier to modifications of nodes in the hash table
1205   void  enter_hash_lock() { ++_hash_lock; assert(_hash_lock &lt; 99, &quot;in too many hash tables?&quot;); }
1206   void   exit_hash_lock() { --_hash_lock; assert(_hash_lock &gt;= 0, &quot;mispaired hash locks&quot;); }
1207 
1208   static void init_NodeProperty();
1209 
1210   #if OPTO_DU_ITERATOR_ASSERT
1211   const Node* _last_del;               // The last deleted node.
1212   uint        _del_tick;               // Bumped when a deletion happens..
1213   #endif
1214 #endif
1215 };
1216 
1217 
1218 #ifndef PRODUCT
1219 
1220 // Used in debugging code to avoid walking across dead or uninitialized edges.
1221 inline bool NotANode(const Node* n) {
1222   if (n == NULL)                   return true;
1223   if (((intptr_t)n &amp; 1) != 0)      return true;  // uninitialized, etc.
1224   if (*(address*)n == badAddress)  return true;  // kill by Node::destruct
1225   return false;
1226 }
1227 
1228 #endif
1229 
1230 
1231 //-----------------------------------------------------------------------------
1232 // Iterators over DU info, and associated Node functions.
1233 
1234 #if OPTO_DU_ITERATOR_ASSERT
1235 
1236 // Common code for assertion checking on DU iterators.
1237 class DUIterator_Common {
1238 #ifdef ASSERT
1239  protected:
1240   bool         _vdui;               // cached value of VerifyDUIterators
1241   const Node*  _node;               // the node containing the _out array
1242   uint         _outcnt;             // cached node-&gt;_outcnt
1243   uint         _del_tick;           // cached node-&gt;_del_tick
1244   Node*        _last;               // last value produced by the iterator
1245 
1246   void sample(const Node* node);    // used by c&#39;tor to set up for verifies
1247   void verify(const Node* node, bool at_end_ok = false);
1248   void verify_resync();
1249   void reset(const DUIterator_Common&amp; that);
1250 
1251 // The VDUI_ONLY macro protects code conditionalized on VerifyDUIterators
1252   #define I_VDUI_ONLY(i,x) { if ((i)._vdui) { x; } }
1253 #else
1254   #define I_VDUI_ONLY(i,x) { }
1255 #endif //ASSERT
1256 };
1257 
1258 #define VDUI_ONLY(x)     I_VDUI_ONLY(*this, x)
1259 
1260 // Default DU iterator.  Allows appends onto the out array.
1261 // Allows deletion from the out array only at the current point.
1262 // Usage:
1263 //  for (DUIterator i = x-&gt;outs(); x-&gt;has_out(i); i++) {
1264 //    Node* y = x-&gt;out(i);
1265 //    ...
1266 //  }
1267 // Compiles in product mode to a unsigned integer index, which indexes
1268 // onto a repeatedly reloaded base pointer of x-&gt;_out.  The loop predicate
1269 // also reloads x-&gt;_outcnt.  If you delete, you must perform &quot;--i&quot; just
1270 // before continuing the loop.  You must delete only the last-produced
1271 // edge.  You must delete only a single copy of the last-produced edge,
1272 // or else you must delete all copies at once (the first time the edge
1273 // is produced by the iterator).
1274 class DUIterator : public DUIterator_Common {
1275   friend class Node;
1276 
1277   // This is the index which provides the product-mode behavior.
1278   // Whatever the product-mode version of the system does to the
1279   // DUI index is done to this index.  All other fields in
1280   // this class are used only for assertion checking.
1281   uint         _idx;
1282 
1283   #ifdef ASSERT
1284   uint         _refresh_tick;    // Records the refresh activity.
1285 
1286   void sample(const Node* node); // Initialize _refresh_tick etc.
1287   void verify(const Node* node, bool at_end_ok = false);
1288   void verify_increment();       // Verify an increment operation.
1289   void verify_resync();          // Verify that we can back up over a deletion.
1290   void verify_finish();          // Verify that the loop terminated properly.
1291   void refresh();                // Resample verification info.
1292   void reset(const DUIterator&amp; that);  // Resample after assignment.
1293   #endif
1294 
1295   DUIterator(const Node* node, int dummy_to_avoid_conversion)
1296     { _idx = 0;                         debug_only(sample(node)); }
1297 
1298  public:
1299   // initialize to garbage; clear _vdui to disable asserts
1300   DUIterator()
1301     { /*initialize to garbage*/         debug_only(_vdui = false); }
1302 
1303   void operator++(int dummy_to_specify_postfix_op)
1304     { _idx++;                           VDUI_ONLY(verify_increment()); }
1305 
1306   void operator--()
1307     { VDUI_ONLY(verify_resync());       --_idx; }
1308 
1309   ~DUIterator()
1310     { VDUI_ONLY(verify_finish()); }
1311 
1312   void operator=(const DUIterator&amp; that)
1313     { _idx = that._idx;                 debug_only(reset(that)); }
1314 };
1315 
1316 DUIterator Node::outs() const
1317   { return DUIterator(this, 0); }
1318 DUIterator&amp; Node::refresh_out_pos(DUIterator&amp; i) const
1319   { I_VDUI_ONLY(i, i.refresh());        return i; }
1320 bool Node::has_out(DUIterator&amp; i) const
1321   { I_VDUI_ONLY(i, i.verify(this,true));return i._idx &lt; _outcnt; }
1322 Node*    Node::out(DUIterator&amp; i) const
1323   { I_VDUI_ONLY(i, i.verify(this));     return debug_only(i._last=) _out[i._idx]; }
1324 
1325 
1326 // Faster DU iterator.  Disallows insertions into the out array.
1327 // Allows deletion from the out array only at the current point.
1328 // Usage:
1329 //  for (DUIterator_Fast imax, i = x-&gt;fast_outs(imax); i &lt; imax; i++) {
1330 //    Node* y = x-&gt;fast_out(i);
1331 //    ...
1332 //  }
1333 // Compiles in product mode to raw Node** pointer arithmetic, with
1334 // no reloading of pointers from the original node x.  If you delete,
1335 // you must perform &quot;--i; --imax&quot; just before continuing the loop.
1336 // If you delete multiple copies of the same edge, you must decrement
1337 // imax, but not i, multiple times:  &quot;--i, imax -= num_edges&quot;.
1338 class DUIterator_Fast : public DUIterator_Common {
1339   friend class Node;
1340   friend class DUIterator_Last;
1341 
1342   // This is the pointer which provides the product-mode behavior.
1343   // Whatever the product-mode version of the system does to the
1344   // DUI pointer is done to this pointer.  All other fields in
1345   // this class are used only for assertion checking.
1346   Node**       _outp;
1347 
1348   #ifdef ASSERT
1349   void verify(const Node* node, bool at_end_ok = false);
1350   void verify_limit();
1351   void verify_resync();
1352   void verify_relimit(uint n);
1353   void reset(const DUIterator_Fast&amp; that);
1354   #endif
1355 
1356   // Note:  offset must be signed, since -1 is sometimes passed
1357   DUIterator_Fast(const Node* node, ptrdiff_t offset)
1358     { _outp = node-&gt;_out + offset;      debug_only(sample(node)); }
1359 
1360  public:
1361   // initialize to garbage; clear _vdui to disable asserts
1362   DUIterator_Fast()
1363     { /*initialize to garbage*/         debug_only(_vdui = false); }
1364 
1365   void operator++(int dummy_to_specify_postfix_op)
1366     { _outp++;                          VDUI_ONLY(verify(_node, true)); }
1367 
1368   void operator--()
1369     { VDUI_ONLY(verify_resync());       --_outp; }
1370 
1371   void operator-=(uint n)   // applied to the limit only
1372     { _outp -= n;           VDUI_ONLY(verify_relimit(n));  }
1373 
1374   bool operator&lt;(DUIterator_Fast&amp; limit) {
1375     I_VDUI_ONLY(*this, this-&gt;verify(_node, true));
1376     I_VDUI_ONLY(limit, limit.verify_limit());
1377     return _outp &lt; limit._outp;
1378   }
1379 
1380   void operator=(const DUIterator_Fast&amp; that)
1381     { _outp = that._outp;               debug_only(reset(that)); }
1382 };
1383 
1384 DUIterator_Fast Node::fast_outs(DUIterator_Fast&amp; imax) const {
1385   // Assign a limit pointer to the reference argument:
1386   imax = DUIterator_Fast(this, (ptrdiff_t)_outcnt);
1387   // Return the base pointer:
1388   return DUIterator_Fast(this, 0);
1389 }
1390 Node* Node::fast_out(DUIterator_Fast&amp; i) const {
1391   I_VDUI_ONLY(i, i.verify(this));
1392   return debug_only(i._last=) *i._outp;
1393 }
1394 
1395 
1396 // Faster DU iterator.  Requires each successive edge to be removed.
1397 // Does not allow insertion of any edges.
1398 // Usage:
1399 //  for (DUIterator_Last imin, i = x-&gt;last_outs(imin); i &gt;= imin; i -= num_edges) {
1400 //    Node* y = x-&gt;last_out(i);
1401 //    ...
1402 //  }
1403 // Compiles in product mode to raw Node** pointer arithmetic, with
1404 // no reloading of pointers from the original node x.
1405 class DUIterator_Last : private DUIterator_Fast {
1406   friend class Node;
1407 
1408   #ifdef ASSERT
1409   void verify(const Node* node, bool at_end_ok = false);
1410   void verify_limit();
1411   void verify_step(uint num_edges);
1412   #endif
1413 
1414   // Note:  offset must be signed, since -1 is sometimes passed
1415   DUIterator_Last(const Node* node, ptrdiff_t offset)
1416     : DUIterator_Fast(node, offset) { }
1417 
1418   void operator++(int dummy_to_specify_postfix_op) {} // do not use
1419   void operator&lt;(int)                              {} // do not use
1420 
1421  public:
1422   DUIterator_Last() { }
1423   // initialize to garbage
1424 
1425   void operator--()
1426     { _outp--;              VDUI_ONLY(verify_step(1));  }
1427 
1428   void operator-=(uint n)
1429     { _outp -= n;           VDUI_ONLY(verify_step(n));  }
1430 
1431   bool operator&gt;=(DUIterator_Last&amp; limit) {
1432     I_VDUI_ONLY(*this, this-&gt;verify(_node, true));
1433     I_VDUI_ONLY(limit, limit.verify_limit());
1434     return _outp &gt;= limit._outp;
1435   }
1436 
1437   void operator=(const DUIterator_Last&amp; that)
1438     { DUIterator_Fast::operator=(that); }
1439 };
1440 
1441 DUIterator_Last Node::last_outs(DUIterator_Last&amp; imin) const {
1442   // Assign a limit pointer to the reference argument:
1443   imin = DUIterator_Last(this, 0);
1444   // Return the initial pointer:
1445   return DUIterator_Last(this, (ptrdiff_t)_outcnt - 1);
1446 }
1447 Node* Node::last_out(DUIterator_Last&amp; i) const {
1448   I_VDUI_ONLY(i, i.verify(this));
1449   return debug_only(i._last=) *i._outp;
1450 }
1451 
1452 #endif //OPTO_DU_ITERATOR_ASSERT
1453 
1454 #undef I_VDUI_ONLY
1455 #undef VDUI_ONLY
1456 
1457 // An Iterator that truly follows the iterator pattern.  Doesn&#39;t
1458 // support deletion but could be made to.
1459 //
1460 //   for (SimpleDUIterator i(n); i.has_next(); i.next()) {
1461 //     Node* m = i.get();
1462 //
1463 class SimpleDUIterator : public StackObj {
1464  private:
1465   Node* node;
1466   DUIterator_Fast i;
1467   DUIterator_Fast imax;
1468  public:
1469   SimpleDUIterator(Node* n): node(n), i(n-&gt;fast_outs(imax)) {}
1470   bool has_next() { return i &lt; imax; }
1471   void next() { i++; }
1472   Node* get() { return node-&gt;fast_out(i); }
1473 };
1474 
1475 
1476 //-----------------------------------------------------------------------------
1477 // Map dense integer indices to Nodes.  Uses classic doubling-array trick.
1478 // Abstractly provides an infinite array of Node*&#39;s, initialized to NULL.
1479 // Note that the constructor just zeros things, and since I use Arena
1480 // allocation I do not need a destructor to reclaim storage.
1481 class Node_Array : public ResourceObj {
1482   friend class VMStructs;
1483 protected:
1484   Arena *_a;                    // Arena to allocate in
1485   uint   _max;
1486   Node **_nodes;
1487   void   grow( uint i );        // Grow array node to fit
1488 public:
1489   Node_Array(Arena *a) : _a(a), _max(OptoNodeListSize) {
1490     _nodes = NEW_ARENA_ARRAY( a, Node *, OptoNodeListSize );
1491     for( int i = 0; i &lt; OptoNodeListSize; i++ ) {
1492       _nodes[i] = NULL;
1493     }
1494   }
1495 
1496   Node_Array(Node_Array *na) : _a(na-&gt;_a), _max(na-&gt;_max), _nodes(na-&gt;_nodes) {}
1497   Node *operator[] ( uint i ) const // Lookup, or NULL for not mapped
1498   { return (i&lt;_max) ? _nodes[i] : (Node*)NULL; }
1499   Node *at( uint i ) const { assert(i&lt;_max,&quot;oob&quot;); return _nodes[i]; }
1500   Node **adr() { return _nodes; }
1501   // Extend the mapping: index i maps to Node *n.
1502   void map( uint i, Node *n ) { if( i&gt;=_max ) grow(i); _nodes[i] = n; }
1503   void insert( uint i, Node *n );
1504   void remove( uint i );        // Remove, preserving order
1505   void sort( C_sort_func_t func);
1506   void reset( Arena *new_a );   // Zap mapping to empty; reclaim storage
1507   void clear();                 // Set all entries to NULL, keep storage
1508   uint Size() const { return _max; }
1509   void dump() const;
1510 };
1511 
1512 class Node_List : public Node_Array {
1513   friend class VMStructs;
1514   uint _cnt;
1515 public:
1516   Node_List() : Node_Array(Thread::current()-&gt;resource_area()), _cnt(0) {}
1517   Node_List(Arena *a) : Node_Array(a), _cnt(0) {}
1518   bool contains(const Node* n) const {
1519     for (uint e = 0; e &lt; size(); e++) {
1520       if (at(e) == n) return true;
1521     }
1522     return false;
1523   }
1524   void insert( uint i, Node *n ) { Node_Array::insert(i,n); _cnt++; }
1525   void remove( uint i ) { Node_Array::remove(i); _cnt--; }
1526   void push( Node *b ) { map(_cnt++,b); }
1527   void yank( Node *n );         // Find and remove
1528   Node *pop() { return _nodes[--_cnt]; }
1529   Node *rpop() { Node *b = _nodes[0]; _nodes[0]=_nodes[--_cnt]; return b;}
1530   void clear() { _cnt = 0; Node_Array::clear(); } // retain storage
1531   uint size() const { return _cnt; }
1532   void dump() const;
1533   void dump_simple() const;
1534 };
1535 
1536 //------------------------------Unique_Node_List-------------------------------
1537 class Unique_Node_List : public Node_List {
1538   friend class VMStructs;
1539   VectorSet _in_worklist;
1540   uint _clock_index;            // Index in list where to pop from next
1541 public:
1542   Unique_Node_List() : Node_List(), _in_worklist(Thread::current()-&gt;resource_area()), _clock_index(0) {}
1543   Unique_Node_List(Arena *a) : Node_List(a), _in_worklist(a), _clock_index(0) {}
1544 
1545   void remove( Node *n );
1546   bool member( Node *n ) { return _in_worklist.test(n-&gt;_idx) != 0; }
1547   VectorSet&amp; member_set(){ return _in_worklist; }
1548 
1549   void push(Node* b) {
1550     if( !_in_worklist.test_set(b-&gt;_idx) )
1551       Node_List::push(b);
1552   }
1553   Node *pop() {
1554     if( _clock_index &gt;= size() ) _clock_index = 0;
1555     Node *b = at(_clock_index);
1556     map( _clock_index, Node_List::pop());
1557     if (size() != 0) _clock_index++; // Always start from 0
1558     _in_worklist.remove(b-&gt;_idx);
1559     return b;
1560   }
1561   Node *remove(uint i) {
1562     Node *b = Node_List::at(i);
1563     _in_worklist.remove(b-&gt;_idx);
1564     map(i,Node_List::pop());
1565     return b;
1566   }
1567   void yank(Node *n) {
1568     _in_worklist.remove(n-&gt;_idx);
1569     Node_List::yank(n);
1570   }
1571   void  clear() {
1572     _in_worklist.clear();        // Discards storage but grows automatically
1573     Node_List::clear();
1574     _clock_index = 0;
1575   }
1576 
1577   // Used after parsing to remove useless nodes before Iterative GVN
1578   void remove_useless_nodes(VectorSet&amp; useful);
1579 
1580   bool contains(const Node* n) const {
1581     fatal(&quot;use faster member() instead&quot;);
1582     return false;
1583   }
1584 
1585 #ifndef PRODUCT
1586   void print_set() const { _in_worklist.print(); }
1587 #endif
1588 };
1589 
1590 // Inline definition of Compile::record_for_igvn must be deferred to this point.
1591 inline void Compile::record_for_igvn(Node* n) {
1592   _for_igvn-&gt;push(n);
1593 }
1594 
1595 //------------------------------Node_Stack-------------------------------------
1596 class Node_Stack {
1597   friend class VMStructs;
1598 protected:
1599   struct INode {
1600     Node *node; // Processed node
1601     uint  indx; // Index of next node&#39;s child
1602   };
1603   INode *_inode_top; // tos, stack grows up
1604   INode *_inode_max; // End of _inodes == _inodes + _max
1605   INode *_inodes;    // Array storage for the stack
1606   Arena *_a;         // Arena to allocate in
1607   void grow();
1608 public:
1609   Node_Stack(int size) {
1610     size_t max = (size &gt; OptoNodeListSize) ? size : OptoNodeListSize;
1611     _a = Thread::current()-&gt;resource_area();
1612     _inodes = NEW_ARENA_ARRAY( _a, INode, max );
1613     _inode_max = _inodes + max;
1614     _inode_top = _inodes - 1; // stack is empty
1615   }
1616 
1617   Node_Stack(Arena *a, int size) : _a(a) {
1618     size_t max = (size &gt; OptoNodeListSize) ? size : OptoNodeListSize;
1619     _inodes = NEW_ARENA_ARRAY( _a, INode, max );
1620     _inode_max = _inodes + max;
1621     _inode_top = _inodes - 1; // stack is empty
1622   }
1623 
1624   void pop() {
1625     assert(_inode_top &gt;= _inodes, &quot;node stack underflow&quot;);
1626     --_inode_top;
1627   }
1628   void push(Node *n, uint i) {
1629     ++_inode_top;
1630     if (_inode_top &gt;= _inode_max) grow();
1631     INode *top = _inode_top; // optimization
1632     top-&gt;node = n;
1633     top-&gt;indx = i;
1634   }
1635   Node *node() const {
1636     return _inode_top-&gt;node;
1637   }
1638   Node* node_at(uint i) const {
1639     assert(_inodes + i &lt;= _inode_top, &quot;in range&quot;);
1640     return _inodes[i].node;
1641   }
1642   uint index() const {
1643     return _inode_top-&gt;indx;
1644   }
1645   uint index_at(uint i) const {
1646     assert(_inodes + i &lt;= _inode_top, &quot;in range&quot;);
1647     return _inodes[i].indx;
1648   }
1649   void set_node(Node *n) {
1650     _inode_top-&gt;node = n;
1651   }
1652   void set_index(uint i) {
1653     _inode_top-&gt;indx = i;
1654   }
1655   uint size_max() const { return (uint)pointer_delta(_inode_max, _inodes,  sizeof(INode)); } // Max size
1656   uint size() const { return (uint)pointer_delta((_inode_top+1), _inodes,  sizeof(INode)); } // Current size
1657   bool is_nonempty() const { return (_inode_top &gt;= _inodes); }
1658   bool is_empty() const { return (_inode_top &lt; _inodes); }
1659   void clear() { _inode_top = _inodes - 1; } // retain storage
1660 
1661   // Node_Stack is used to map nodes.
1662   Node* find(uint idx) const;
1663 };
1664 
1665 
1666 //-----------------------------Node_Notes--------------------------------------
1667 // Debugging or profiling annotations loosely and sparsely associated
1668 // with some nodes.  See Compile::node_notes_at for the accessor.
1669 class Node_Notes {
1670   friend class VMStructs;
1671   JVMState* _jvms;
1672 
1673 public:
1674   Node_Notes(JVMState* jvms = NULL) {
1675     _jvms = jvms;
1676   }
1677 
1678   JVMState* jvms()            { return _jvms; }
1679   void  set_jvms(JVMState* x) {        _jvms = x; }
1680 
1681   // True if there is nothing here.
1682   bool is_clear() {
1683     return (_jvms == NULL);
1684   }
1685 
1686   // Make there be nothing here.
1687   void clear() {
1688     _jvms = NULL;
1689   }
1690 
1691   // Make a new, clean node notes.
1692   static Node_Notes* make(Compile* C) {
1693     Node_Notes* nn = NEW_ARENA_ARRAY(C-&gt;comp_arena(), Node_Notes, 1);
1694     nn-&gt;clear();
1695     return nn;
1696   }
1697 
1698   Node_Notes* clone(Compile* C) {
1699     Node_Notes* nn = NEW_ARENA_ARRAY(C-&gt;comp_arena(), Node_Notes, 1);
1700     (*nn) = (*this);
1701     return nn;
1702   }
1703 
1704   // Absorb any information from source.
1705   bool update_from(Node_Notes* source) {
1706     bool changed = false;
1707     if (source != NULL) {
1708       if (source-&gt;jvms() != NULL) {
1709         set_jvms(source-&gt;jvms());
1710         changed = true;
1711       }
1712     }
1713     return changed;
1714   }
1715 };
1716 
1717 // Inlined accessors for Compile::node_nodes that require the preceding class:
1718 inline Node_Notes*
1719 Compile::locate_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr,
1720                            int idx, bool can_grow) {
1721   assert(idx &gt;= 0, &quot;oob&quot;);
1722   int block_idx = (idx &gt;&gt; _log2_node_notes_block_size);
1723   int grow_by = (block_idx - (arr == NULL? 0: arr-&gt;length()));
1724   if (grow_by &gt;= 0) {
1725     if (!can_grow) return NULL;
1726     grow_node_notes(arr, grow_by + 1);
1727   }
1728   if (arr == NULL) return NULL;
1729   // (Every element of arr is a sub-array of length _node_notes_block_size.)
1730   return arr-&gt;at(block_idx) + (idx &amp; (_node_notes_block_size-1));
1731 }
1732 
1733 inline bool
1734 Compile::set_node_notes_at(int idx, Node_Notes* value) {
1735   if (value == NULL || value-&gt;is_clear())
1736     return false;  // nothing to write =&gt; write nothing
1737   Node_Notes* loc = locate_node_notes(_node_note_array, idx, true);
1738   assert(loc != NULL, &quot;&quot;);
1739   return loc-&gt;update_from(value);
1740 }
1741 
1742 
1743 //------------------------------TypeNode---------------------------------------
1744 // Node with a Type constant.
1745 class TypeNode : public Node {
1746 protected:
1747   virtual uint hash() const;    // Check the type
1748   virtual bool cmp( const Node &amp;n ) const;
1749   virtual uint size_of() const; // Size is bigger
1750   const Type* const _type;
1751 public:
1752   void set_type(const Type* t) {
1753     assert(t != NULL, &quot;sanity&quot;);
1754     debug_only(uint check_hash = (VerifyHashTableKeys &amp;&amp; _hash_lock) ? hash() : NO_HASH);
1755     *(const Type**)&amp;_type = t;   // cast away const-ness
1756     // If this node is in the hash table, make sure it doesn&#39;t need a rehash.
1757     assert(check_hash == NO_HASH || check_hash == hash(), &quot;type change must preserve hash code&quot;);
1758   }
1759   const Type* type() const { assert(_type != NULL, &quot;sanity&quot;); return _type; };
1760   TypeNode( const Type *t, uint required ) : Node(required), _type(t) {
1761     init_class_id(Class_Type);
1762   }
1763   virtual const Type* Value(PhaseGVN* phase) const;
1764   virtual const Type *bottom_type() const;
1765   virtual       uint  ideal_reg() const;
1766 #ifndef PRODUCT
1767   virtual void dump_spec(outputStream *st) const;
1768   virtual void dump_compact_spec(outputStream *st) const;
1769 #endif
1770 };
1771 
1772 #endif // SHARE_OPTO_NODE_HPP
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
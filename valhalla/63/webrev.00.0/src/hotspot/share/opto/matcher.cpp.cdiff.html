<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/matcher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="library_call.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/matcher.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 2517,35 ***</span>
  
  //----------------------------------------------------------------------
  // Generic machine operands elision.
  //----------------------------------------------------------------------
  
<span class="line-removed">- // Convert (leg)Vec to (leg)Vec[SDXYZ].</span>
<span class="line-removed">- MachOper* Matcher::specialize_vector_operand_helper(MachNode* m, uint opnd_idx, const TypeVect* vt) {</span>
<span class="line-removed">-   MachOper* original_opnd = m-&gt;_opnds[opnd_idx];</span>
<span class="line-removed">-   uint ideal_reg = vt-&gt;ideal_reg();</span>
<span class="line-removed">-   // Handle special cases.</span>
<span class="line-removed">-   // LShiftCntV/RShiftCntV report wide vector type, but Matcher::vector_shift_count_ideal_reg() as ideal register (see vectornode.hpp).</span>
<span class="line-removed">-   // Look for shift count use sites as well (at vector shift nodes).</span>
<span class="line-removed">-   int opc = m-&gt;ideal_Opcode();</span>
<span class="line-removed">-   if ((VectorNode::is_vector_shift_count(opc)  &amp;&amp; opnd_idx == 0) || // DEF operand of LShiftCntV/RShiftCntV</span>
<span class="line-removed">-       (VectorNode::is_vector_shift(opc)        &amp;&amp; opnd_idx == 2)) { // shift operand of a vector shift node</span>
<span class="line-removed">-     ideal_reg = Matcher::vector_shift_count_ideal_reg(vt-&gt;length_in_bytes());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return Matcher::specialize_generic_vector_operand(original_opnd, ideal_reg, false);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Compute concrete vector operand for a generic TEMP vector mach node based on its user info.
  void Matcher::specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx) {
    assert(use-&gt;in(idx) == tmp, &quot;not a user&quot;);
    assert(!Matcher::is_generic_vector(use-&gt;_opnds[0]), &quot;use not processed yet&quot;);
  
    if ((uint)idx == use-&gt;two_adr()) { // DEF_TEMP case
      tmp-&gt;_opnds[0] = use-&gt;_opnds[0]-&gt;clone();
    } else {
      uint ideal_vreg = vector_ideal_reg(C-&gt;max_vector_size());
<span class="line-modified">!     tmp-&gt;_opnds[0] = specialize_generic_vector_operand(tmp-&gt;_opnds[0], ideal_vreg, true);</span>
    }
  }
  
  // Compute concrete vector operand for a generic DEF/USE vector operand (of mach node m at index idx).
  MachOper* Matcher::specialize_vector_operand(MachNode* m, uint opnd_idx) {
<span class="line-new-header">--- 2517,20 ---</span>
  
  //----------------------------------------------------------------------
  // Generic machine operands elision.
  //----------------------------------------------------------------------
  
  // Compute concrete vector operand for a generic TEMP vector mach node based on its user info.
  void Matcher::specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx) {
    assert(use-&gt;in(idx) == tmp, &quot;not a user&quot;);
    assert(!Matcher::is_generic_vector(use-&gt;_opnds[0]), &quot;use not processed yet&quot;);
  
    if ((uint)idx == use-&gt;two_adr()) { // DEF_TEMP case
      tmp-&gt;_opnds[0] = use-&gt;_opnds[0]-&gt;clone();
    } else {
      uint ideal_vreg = vector_ideal_reg(C-&gt;max_vector_size());
<span class="line-modified">!     tmp-&gt;_opnds[0] = Matcher::pd_specialize_generic_vector_operand(tmp-&gt;_opnds[0], ideal_vreg, true /*is_temp*/);</span>
    }
  }
  
  // Compute concrete vector operand for a generic DEF/USE vector operand (of mach node m at index idx).
  MachOper* Matcher::specialize_vector_operand(MachNode* m, uint opnd_idx) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2562,11 ***</span>
        } else if (is_generic_reg2reg_move(def-&gt;as_Mach())) {
          def = def-&gt;in(1); // skip over generic reg-to-reg moves
        }
      }
    }
<span class="line-modified">!   return specialize_vector_operand_helper(m, opnd_idx, def-&gt;bottom_type()-&gt;is_vect());</span>
  }
  
  void Matcher::specialize_mach_node(MachNode* m) {
    assert(!m-&gt;is_MachTemp(), &quot;processed along with its user&quot;);
    // For generic use operands pull specific register class operands from
<span class="line-new-header">--- 2547,13 ---</span>
        } else if (is_generic_reg2reg_move(def-&gt;as_Mach())) {
          def = def-&gt;in(1); // skip over generic reg-to-reg moves
        }
      }
    }
<span class="line-modified">!   assert(def-&gt;bottom_type()-&gt;isa_vect(), &quot;not a vector&quot;);</span>
<span class="line-added">+   uint ideal_vreg = def-&gt;bottom_type()-&gt;ideal_reg();</span>
<span class="line-added">+   return Matcher::pd_specialize_generic_vector_operand(m-&gt;_opnds[opnd_idx], ideal_vreg, false /*is_temp*/);</span>
  }
  
  void Matcher::specialize_mach_node(MachNode* m) {
    assert(!m-&gt;is_MachTemp(), &quot;processed along with its user&quot;);
    // For generic use operands pull specific register class operands from
</pre>
<center><a href="library_call.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
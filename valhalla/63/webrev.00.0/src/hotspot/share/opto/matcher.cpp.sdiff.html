<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/matcher.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/matcher.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2502   assert(mspill != NULL, &quot;matching failed: %d&quot;, ideal_reg);
2503   // Handle generic vector operand case
2504   if (Matcher::supports_generic_vector_operands &amp;&amp; t-&gt;isa_vect()) {
2505     specialize_mach_node(mspill);
2506   }
2507   return &amp;mspill-&gt;out_RegMask();
2508 }
2509 
2510 // Process Mach IR right after selection phase is over.
2511 void Matcher::do_postselect_cleanup() {
2512   if (supports_generic_vector_operands) {
2513     specialize_generic_vector_operands();
2514     if (C-&gt;failing())  return;
2515   }
2516 }
2517 
2518 //----------------------------------------------------------------------
2519 // Generic machine operands elision.
2520 //----------------------------------------------------------------------
2521 
<span class="line-removed">2522 // Convert (leg)Vec to (leg)Vec[SDXYZ].</span>
<span class="line-removed">2523 MachOper* Matcher::specialize_vector_operand_helper(MachNode* m, uint opnd_idx, const TypeVect* vt) {</span>
<span class="line-removed">2524   MachOper* original_opnd = m-&gt;_opnds[opnd_idx];</span>
<span class="line-removed">2525   uint ideal_reg = vt-&gt;ideal_reg();</span>
<span class="line-removed">2526   // Handle special cases.</span>
<span class="line-removed">2527   // LShiftCntV/RShiftCntV report wide vector type, but Matcher::vector_shift_count_ideal_reg() as ideal register (see vectornode.hpp).</span>
<span class="line-removed">2528   // Look for shift count use sites as well (at vector shift nodes).</span>
<span class="line-removed">2529   int opc = m-&gt;ideal_Opcode();</span>
<span class="line-removed">2530   if ((VectorNode::is_vector_shift_count(opc)  &amp;&amp; opnd_idx == 0) || // DEF operand of LShiftCntV/RShiftCntV</span>
<span class="line-removed">2531       (VectorNode::is_vector_shift(opc)        &amp;&amp; opnd_idx == 2)) { // shift operand of a vector shift node</span>
<span class="line-removed">2532     ideal_reg = Matcher::vector_shift_count_ideal_reg(vt-&gt;length_in_bytes());</span>
<span class="line-removed">2533   }</span>
<span class="line-removed">2534   return Matcher::specialize_generic_vector_operand(original_opnd, ideal_reg, false);</span>
<span class="line-removed">2535 }</span>
<span class="line-removed">2536 </span>
2537 // Compute concrete vector operand for a generic TEMP vector mach node based on its user info.
2538 void Matcher::specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx) {
2539   assert(use-&gt;in(idx) == tmp, &quot;not a user&quot;);
2540   assert(!Matcher::is_generic_vector(use-&gt;_opnds[0]), &quot;use not processed yet&quot;);
2541 
2542   if ((uint)idx == use-&gt;two_adr()) { // DEF_TEMP case
2543     tmp-&gt;_opnds[0] = use-&gt;_opnds[0]-&gt;clone();
2544   } else {
2545     uint ideal_vreg = vector_ideal_reg(C-&gt;max_vector_size());
<span class="line-modified">2546     tmp-&gt;_opnds[0] = specialize_generic_vector_operand(tmp-&gt;_opnds[0], ideal_vreg, true);</span>
2547   }
2548 }
2549 
2550 // Compute concrete vector operand for a generic DEF/USE vector operand (of mach node m at index idx).
2551 MachOper* Matcher::specialize_vector_operand(MachNode* m, uint opnd_idx) {
2552   assert(Matcher::is_generic_vector(m-&gt;_opnds[opnd_idx]), &quot;repeated updates&quot;);
2553   Node* def = NULL;
2554   if (opnd_idx == 0) { // DEF
2555     def = m; // use mach node itself to compute vector operand type
2556   } else {
2557     int base_idx = m-&gt;operand_index(opnd_idx);
2558     def = m-&gt;in(base_idx);
2559     if (def-&gt;is_Mach()) {
2560       if (def-&gt;is_MachTemp() &amp;&amp; Matcher::is_generic_vector(def-&gt;as_Mach()-&gt;_opnds[0])) {
2561         specialize_temp_node(def-&gt;as_MachTemp(), m, base_idx); // MachTemp node use site
2562       } else if (is_generic_reg2reg_move(def-&gt;as_Mach())) {
2563         def = def-&gt;in(1); // skip over generic reg-to-reg moves
2564       }
2565     }
2566   }
<span class="line-modified">2567   return specialize_vector_operand_helper(m, opnd_idx, def-&gt;bottom_type()-&gt;is_vect());</span>


2568 }
2569 
2570 void Matcher::specialize_mach_node(MachNode* m) {
2571   assert(!m-&gt;is_MachTemp(), &quot;processed along with its user&quot;);
2572   // For generic use operands pull specific register class operands from
2573   // its def instruction&#39;s output operand (def operand).
2574   for (uint i = 0; i &lt; m-&gt;num_opnds(); i++) {
2575     if (Matcher::is_generic_vector(m-&gt;_opnds[i])) {
2576       m-&gt;_opnds[i] = specialize_vector_operand(m, i);
2577     }
2578   }
2579 }
2580 
2581 // Replace generic vector operands with concrete vector operands and eliminate generic reg-to-reg moves from the graph.
2582 void Matcher::specialize_generic_vector_operands() {
2583   assert(supports_generic_vector_operands, &quot;sanity&quot;);
2584   ResourceMark rm;
2585 
2586   if (C-&gt;max_vector_size() == 0) {
2587     return; // no vector instructions or operands
</pre>
</td>
<td>
<hr />
<pre>
2502   assert(mspill != NULL, &quot;matching failed: %d&quot;, ideal_reg);
2503   // Handle generic vector operand case
2504   if (Matcher::supports_generic_vector_operands &amp;&amp; t-&gt;isa_vect()) {
2505     specialize_mach_node(mspill);
2506   }
2507   return &amp;mspill-&gt;out_RegMask();
2508 }
2509 
2510 // Process Mach IR right after selection phase is over.
2511 void Matcher::do_postselect_cleanup() {
2512   if (supports_generic_vector_operands) {
2513     specialize_generic_vector_operands();
2514     if (C-&gt;failing())  return;
2515   }
2516 }
2517 
2518 //----------------------------------------------------------------------
2519 // Generic machine operands elision.
2520 //----------------------------------------------------------------------
2521 















2522 // Compute concrete vector operand for a generic TEMP vector mach node based on its user info.
2523 void Matcher::specialize_temp_node(MachTempNode* tmp, MachNode* use, uint idx) {
2524   assert(use-&gt;in(idx) == tmp, &quot;not a user&quot;);
2525   assert(!Matcher::is_generic_vector(use-&gt;_opnds[0]), &quot;use not processed yet&quot;);
2526 
2527   if ((uint)idx == use-&gt;two_adr()) { // DEF_TEMP case
2528     tmp-&gt;_opnds[0] = use-&gt;_opnds[0]-&gt;clone();
2529   } else {
2530     uint ideal_vreg = vector_ideal_reg(C-&gt;max_vector_size());
<span class="line-modified">2531     tmp-&gt;_opnds[0] = Matcher::pd_specialize_generic_vector_operand(tmp-&gt;_opnds[0], ideal_vreg, true /*is_temp*/);</span>
2532   }
2533 }
2534 
2535 // Compute concrete vector operand for a generic DEF/USE vector operand (of mach node m at index idx).
2536 MachOper* Matcher::specialize_vector_operand(MachNode* m, uint opnd_idx) {
2537   assert(Matcher::is_generic_vector(m-&gt;_opnds[opnd_idx]), &quot;repeated updates&quot;);
2538   Node* def = NULL;
2539   if (opnd_idx == 0) { // DEF
2540     def = m; // use mach node itself to compute vector operand type
2541   } else {
2542     int base_idx = m-&gt;operand_index(opnd_idx);
2543     def = m-&gt;in(base_idx);
2544     if (def-&gt;is_Mach()) {
2545       if (def-&gt;is_MachTemp() &amp;&amp; Matcher::is_generic_vector(def-&gt;as_Mach()-&gt;_opnds[0])) {
2546         specialize_temp_node(def-&gt;as_MachTemp(), m, base_idx); // MachTemp node use site
2547       } else if (is_generic_reg2reg_move(def-&gt;as_Mach())) {
2548         def = def-&gt;in(1); // skip over generic reg-to-reg moves
2549       }
2550     }
2551   }
<span class="line-modified">2552   assert(def-&gt;bottom_type()-&gt;isa_vect(), &quot;not a vector&quot;);</span>
<span class="line-added">2553   uint ideal_vreg = def-&gt;bottom_type()-&gt;ideal_reg();</span>
<span class="line-added">2554   return Matcher::pd_specialize_generic_vector_operand(m-&gt;_opnds[opnd_idx], ideal_vreg, false /*is_temp*/);</span>
2555 }
2556 
2557 void Matcher::specialize_mach_node(MachNode* m) {
2558   assert(!m-&gt;is_MachTemp(), &quot;processed along with its user&quot;);
2559   // For generic use operands pull specific register class operands from
2560   // its def instruction&#39;s output operand (def operand).
2561   for (uint i = 0; i &lt; m-&gt;num_opnds(); i++) {
2562     if (Matcher::is_generic_vector(m-&gt;_opnds[i])) {
2563       m-&gt;_opnds[i] = specialize_vector_operand(m, i);
2564     }
2565   }
2566 }
2567 
2568 // Replace generic vector operands with concrete vector operands and eliminate generic reg-to-reg moves from the graph.
2569 void Matcher::specialize_generic_vector_operands() {
2570   assert(supports_generic_vector_operands, &quot;sanity&quot;);
2571   ResourceMark rm;
2572 
2573   if (C-&gt;max_vector_size() == 0) {
2574     return; // no vector instructions or operands
</pre>
</td>
</tr>
</table>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="matcher.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
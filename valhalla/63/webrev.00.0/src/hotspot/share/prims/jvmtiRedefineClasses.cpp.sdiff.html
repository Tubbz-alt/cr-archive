<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/jvmtiRedefineClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvmtiRedefineClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 133   if (_class_defs == NULL) {
 134     _res = JVMTI_ERROR_NULL_POINTER;
 135     return false;
 136   }
 137 
 138   for (int i = 0; i &lt; _class_count; i++) {
 139     if (_class_defs[i].klass == NULL) {
 140       _res = JVMTI_ERROR_INVALID_CLASS;
 141       return false;
 142     }
 143     if (_class_defs[i].class_byte_count == 0) {
 144       _res = JVMTI_ERROR_INVALID_CLASS_FORMAT;
 145       return false;
 146     }
 147     if (_class_defs[i].class_bytes == NULL) {
 148       _res = JVMTI_ERROR_NULL_POINTER;
 149       return false;
 150     }
 151 
 152     oop mirror = JNIHandles::resolve_non_null(_class_defs[i].klass);
<span class="line-modified"> 153     // classes for primitives and arrays and vm unsafe anonymous classes cannot be redefined</span>
<span class="line-modified"> 154     // check here so following code can assume these classes are InstanceKlass</span>
 155     if (!is_modifiable_class(mirror)) {
 156       _res = JVMTI_ERROR_UNMODIFIABLE_CLASS;
 157       return false;
 158     }
 159   }
 160 
 161   // Start timer after all the sanity checks; not quite accurate, but
 162   // better than adding a bunch of stop() calls.
 163   if (log_is_enabled(Info, redefine, class, timer)) {
 164     _timer_vm_op_prologue.start();
 165   }
 166 
 167   lock_classes();
 168   // We first load new class versions in the prologue, because somewhere down the
 169   // call chain it is required that the current thread is a Java thread.
 170   _res = load_new_class_versions(Thread::current());
 171   if (_res != JVMTI_ERROR_NONE) {
 172     // free any successfully created classes, since none are redefined
 173     for (int i = 0; i &lt; _class_count; i++) {
 174       if (_scratch_classes[i] != NULL) {
</pre>
<hr />
<pre>
 276     log_info(redefine, class, timer)
 277       (&quot;vm_op: all=&quot; JULONG_FORMAT &quot;  prologue=&quot; JULONG_FORMAT &quot;  doit=&quot; JULONG_FORMAT,
 278        all_time, (julong)_timer_vm_op_prologue.milliseconds(), doit_time);
 279     log_info(redefine, class, timer)
 280       (&quot;redefine_single_class: phase1=&quot; JULONG_FORMAT &quot;  phase2=&quot; JULONG_FORMAT,
 281        (julong)_timer_rsc_phase1.milliseconds(), (julong)_timer_rsc_phase2.milliseconds());
 282   }
 283 }
 284 
 285 bool VM_RedefineClasses::is_modifiable_class(oop klass_mirror) {
 286   // classes for primitives cannot be redefined
 287   if (java_lang_Class::is_primitive(klass_mirror)) {
 288     return false;
 289   }
 290   Klass* k = java_lang_Class::as_Klass(klass_mirror);
 291   // classes for arrays cannot be redefined
 292   if (k == NULL || !k-&gt;is_instance_klass()) {
 293     return false;
 294   }
 295 
<span class="line-modified"> 296   // Cannot redefine or retransform an unsafe anonymous class.</span>
<span class="line-modified"> 297   if (InstanceKlass::cast(k)-&gt;is_unsafe_anonymous()) {</span>

 298     return false;
 299   }
 300   return true;
 301 }
 302 
 303 // Append the current entry at scratch_i in scratch_cp to *merge_cp_p
 304 // where the end of *merge_cp_p is specified by *merge_cp_length_p. For
 305 // direct CP entries, there is just the current entry to append. For
 306 // indirect and double-indirect CP entries, there are zero or more
 307 // referenced CP entries along with the current entry to append.
 308 // Indirect and double-indirect CP entries are handled by recursive
 309 // calls to append_entry() as needed. The referenced CP entries are
 310 // always appended to *merge_cp_p before the referee CP entry. These
 311 // referenced CP entries may already exist in *merge_cp_p in which case
 312 // there is nothing extra to append and only the current entry is
 313 // appended.
 314 void VM_RedefineClasses::append_entry(const constantPoolHandle&amp; scratch_cp,
 315        int scratch_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p,
 316        TRAPS) {
 317 
</pre>
<hr />
<pre>
1221     InstanceKlass* the_class = get_ik(_class_defs[i].klass);
1222     Symbol*  the_class_sym = the_class-&gt;name();
1223 
1224     log_debug(redefine, class, load)
1225       (&quot;loading name=%s kind=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
1226        the_class-&gt;external_name(), _class_load_kind, os::available_memory() &gt;&gt; 10);
1227 
1228     ClassFileStream st((u1*)_class_defs[i].class_bytes,
1229                        _class_defs[i].class_byte_count,
1230                        &quot;__VM_RedefineClasses__&quot;,
1231                        ClassFileStream::verify);
1232 
1233     // Parse the stream.
1234     Handle the_class_loader(THREAD, the_class-&gt;class_loader());
1235     Handle protection_domain(THREAD, the_class-&gt;protection_domain());
1236     // Set redefined class handle in JvmtiThreadState class.
1237     // This redefined class is sent to agent event handler for class file
1238     // load hook event.
1239     state-&gt;set_class_being_redefined(the_class, _class_load_kind);
1240 

1241     InstanceKlass* scratch_class = SystemDictionary::parse_stream(
1242                                                       the_class_sym,
1243                                                       the_class_loader,
<span class="line-modified">1244                                                       protection_domain,</span>
1245                                                       &amp;st,
1246                                                       THREAD);
1247     // Clear class_being_redefined just to be sure.
1248     state-&gt;clear_class_being_redefined();
1249 
1250     // TODO: if this is retransform, and nothing changed we can skip it
1251 
1252     // Need to clean up allocated InstanceKlass if there&#39;s an error so assign
1253     // the result here. Caller deallocates all the scratch classes in case of
1254     // an error.
1255     _scratch_classes[i] = scratch_class;
1256 
1257     if (HAS_PENDING_EXCEPTION) {
1258       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1259       log_info(redefine, class, load, exceptions)(&quot;parse_stream exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1260       CLEAR_PENDING_EXCEPTION;
1261 
1262       if (ex_name == vmSymbols::java_lang_UnsupportedClassVersionError()) {
1263         return JVMTI_ERROR_UNSUPPORTED_VERSION;
1264       } else if (ex_name == vmSymbols::java_lang_ClassFormatError()) {
</pre>
</td>
<td>
<hr />
<pre>
 133   if (_class_defs == NULL) {
 134     _res = JVMTI_ERROR_NULL_POINTER;
 135     return false;
 136   }
 137 
 138   for (int i = 0; i &lt; _class_count; i++) {
 139     if (_class_defs[i].klass == NULL) {
 140       _res = JVMTI_ERROR_INVALID_CLASS;
 141       return false;
 142     }
 143     if (_class_defs[i].class_byte_count == 0) {
 144       _res = JVMTI_ERROR_INVALID_CLASS_FORMAT;
 145       return false;
 146     }
 147     if (_class_defs[i].class_bytes == NULL) {
 148       _res = JVMTI_ERROR_NULL_POINTER;
 149       return false;
 150     }
 151 
 152     oop mirror = JNIHandles::resolve_non_null(_class_defs[i].klass);
<span class="line-modified"> 153     // classes for primitives, arrays, hidden and vm unsafe anonymous classes</span>
<span class="line-modified"> 154     // cannot be redefined.</span>
 155     if (!is_modifiable_class(mirror)) {
 156       _res = JVMTI_ERROR_UNMODIFIABLE_CLASS;
 157       return false;
 158     }
 159   }
 160 
 161   // Start timer after all the sanity checks; not quite accurate, but
 162   // better than adding a bunch of stop() calls.
 163   if (log_is_enabled(Info, redefine, class, timer)) {
 164     _timer_vm_op_prologue.start();
 165   }
 166 
 167   lock_classes();
 168   // We first load new class versions in the prologue, because somewhere down the
 169   // call chain it is required that the current thread is a Java thread.
 170   _res = load_new_class_versions(Thread::current());
 171   if (_res != JVMTI_ERROR_NONE) {
 172     // free any successfully created classes, since none are redefined
 173     for (int i = 0; i &lt; _class_count; i++) {
 174       if (_scratch_classes[i] != NULL) {
</pre>
<hr />
<pre>
 276     log_info(redefine, class, timer)
 277       (&quot;vm_op: all=&quot; JULONG_FORMAT &quot;  prologue=&quot; JULONG_FORMAT &quot;  doit=&quot; JULONG_FORMAT,
 278        all_time, (julong)_timer_vm_op_prologue.milliseconds(), doit_time);
 279     log_info(redefine, class, timer)
 280       (&quot;redefine_single_class: phase1=&quot; JULONG_FORMAT &quot;  phase2=&quot; JULONG_FORMAT,
 281        (julong)_timer_rsc_phase1.milliseconds(), (julong)_timer_rsc_phase2.milliseconds());
 282   }
 283 }
 284 
 285 bool VM_RedefineClasses::is_modifiable_class(oop klass_mirror) {
 286   // classes for primitives cannot be redefined
 287   if (java_lang_Class::is_primitive(klass_mirror)) {
 288     return false;
 289   }
 290   Klass* k = java_lang_Class::as_Klass(klass_mirror);
 291   // classes for arrays cannot be redefined
 292   if (k == NULL || !k-&gt;is_instance_klass()) {
 293     return false;
 294   }
 295 
<span class="line-modified"> 296   // Cannot redefine or retransform a hidden or an unsafe anonymous class.</span>
<span class="line-modified"> 297   if (InstanceKlass::cast(k)-&gt;is_hidden() ||</span>
<span class="line-added"> 298       InstanceKlass::cast(k)-&gt;is_unsafe_anonymous()) {</span>
 299     return false;
 300   }
 301   return true;
 302 }
 303 
 304 // Append the current entry at scratch_i in scratch_cp to *merge_cp_p
 305 // where the end of *merge_cp_p is specified by *merge_cp_length_p. For
 306 // direct CP entries, there is just the current entry to append. For
 307 // indirect and double-indirect CP entries, there are zero or more
 308 // referenced CP entries along with the current entry to append.
 309 // Indirect and double-indirect CP entries are handled by recursive
 310 // calls to append_entry() as needed. The referenced CP entries are
 311 // always appended to *merge_cp_p before the referee CP entry. These
 312 // referenced CP entries may already exist in *merge_cp_p in which case
 313 // there is nothing extra to append and only the current entry is
 314 // appended.
 315 void VM_RedefineClasses::append_entry(const constantPoolHandle&amp; scratch_cp,
 316        int scratch_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p,
 317        TRAPS) {
 318 
</pre>
<hr />
<pre>
1222     InstanceKlass* the_class = get_ik(_class_defs[i].klass);
1223     Symbol*  the_class_sym = the_class-&gt;name();
1224 
1225     log_debug(redefine, class, load)
1226       (&quot;loading name=%s kind=%d (avail_mem=&quot; UINT64_FORMAT &quot;K)&quot;,
1227        the_class-&gt;external_name(), _class_load_kind, os::available_memory() &gt;&gt; 10);
1228 
1229     ClassFileStream st((u1*)_class_defs[i].class_bytes,
1230                        _class_defs[i].class_byte_count,
1231                        &quot;__VM_RedefineClasses__&quot;,
1232                        ClassFileStream::verify);
1233 
1234     // Parse the stream.
1235     Handle the_class_loader(THREAD, the_class-&gt;class_loader());
1236     Handle protection_domain(THREAD, the_class-&gt;protection_domain());
1237     // Set redefined class handle in JvmtiThreadState class.
1238     // This redefined class is sent to agent event handler for class file
1239     // load hook event.
1240     state-&gt;set_class_being_redefined(the_class, _class_load_kind);
1241 
<span class="line-added">1242     ClassLoadInfo cl_info(protection_domain);</span>
1243     InstanceKlass* scratch_class = SystemDictionary::parse_stream(
1244                                                       the_class_sym,
1245                                                       the_class_loader,
<span class="line-modified">1246                                                       &amp;st,</span>
1247                                                       cl_info,
1248                                                       THREAD);
1249     // Clear class_being_redefined just to be sure.
1250     state-&gt;clear_class_being_redefined();
1251 
1252     // TODO: if this is retransform, and nothing changed we can skip it
1253 
1254     // Need to clean up allocated InstanceKlass if there&#39;s an error so assign
1255     // the result here. Caller deallocates all the scratch classes in case of
1256     // an error.
1257     _scratch_classes[i] = scratch_class;
1258 
1259     if (HAS_PENDING_EXCEPTION) {
1260       Symbol* ex_name = PENDING_EXCEPTION-&gt;klass()-&gt;name();
1261       log_info(redefine, class, load, exceptions)(&quot;parse_stream exception: &#39;%s&#39;&quot;, ex_name-&gt;as_C_string());
1262       CLEAR_PENDING_EXCEPTION;
1263 
1264       if (ex_name == vmSymbols::java_lang_UnsupportedClassVersionError()) {
1265         return JVMTI_ERROR_UNSUPPORTED_VERSION;
1266       } else if (ex_name == vmSymbols::java_lang_ClassFormatError()) {
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiEnv.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="methodHandles.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;compiler/methodMatcher.hpp&quot;
  37 #include &quot;compiler/directivesParser.hpp&quot;
  38 #include &quot;gc/shared/concurrentGCBreakpoints.hpp&quot;
  39 #include &quot;gc/shared/gcConfig.hpp&quot;
  40 #include &quot;gc/shared/genArguments.hpp&quot;
  41 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  42 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  43 #include &quot;memory/filemap.hpp&quot;
  44 #include &quot;memory/heapShared.inline.hpp&quot;
  45 #include &quot;memory/metaspaceShared.hpp&quot;
  46 #include &quot;memory/metadataFactory.hpp&quot;
  47 #include &quot;memory/iterator.inline.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;memory/oopFactory.hpp&quot;
  51 #include &quot;oops/array.hpp&quot;
  52 #include &quot;oops/compressedOops.hpp&quot;
  53 #include &quot;oops/compressedOops.inline.hpp&quot;
  54 #include &quot;oops/constantPool.inline.hpp&quot;
  55 #include &quot;oops/method.inline.hpp&quot;
  56 #include &quot;oops/objArrayKlass.hpp&quot;
  57 #include &quot;oops/objArrayOop.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/objArrayOop.inline.hpp&quot;
  60 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  61 #include &quot;prims/resolvedMethodTable.hpp&quot;
  62 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  63 #include &quot;prims/whitebox.inline.hpp&quot;
  64 #include &quot;runtime/arguments.hpp&quot;
  65 #include &quot;runtime/atomic.hpp&quot;
  66 #include &quot;runtime/deoptimization.hpp&quot;
  67 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  68 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  69 #include &quot;runtime/frame.inline.hpp&quot;
  70 #include &quot;runtime/handles.inline.hpp&quot;
  71 #include &quot;runtime/handshake.hpp&quot;
  72 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  73 #include &quot;runtime/javaCalls.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/os.hpp&quot;
  76 #include &quot;runtime/sweeper.hpp&quot;
  77 #include &quot;runtime/thread.hpp&quot;
  78 #include &quot;runtime/threadSMR.hpp&quot;
  79 #include &quot;runtime/vm_version.hpp&quot;
  80 #include &quot;services/memoryService.hpp&quot;
  81 #include &quot;utilities/align.hpp&quot;
  82 #include &quot;utilities/debug.hpp&quot;
  83 #include &quot;utilities/elfFile.hpp&quot;
  84 #include &quot;utilities/exceptions.hpp&quot;
  85 #include &quot;utilities/macros.hpp&quot;
  86 #if INCLUDE_CDS
  87 #include &quot;prims/cdsoffsets.hpp&quot;
  88 #endif // INCLUDE_CDS
  89 #if INCLUDE_G1GC
  90 #include &quot;gc/g1/g1Arguments.hpp&quot;
  91 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  92 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  93 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  94 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  95 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  96 #endif // INCLUDE_G1GC
  97 #if INCLUDE_PARALLELGC
  98 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  99 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
 100 #endif // INCLUDE_PARALLELGC
 101 #if INCLUDE_NMT
 102 #include &quot;services/mallocSiteTable.hpp&quot;
 103 #include &quot;services/memTracker.hpp&quot;
 104 #include &quot;utilities/nativeCallStack.hpp&quot;
 105 #endif // INCLUDE_NMT
 106 #if INCLUDE_AOT
 107 #include &quot;aot/aotLoader.hpp&quot;
 108 #endif // INCLUDE_AOT
 109 
 110 #ifdef LINUX
 111 #include &quot;osContainer_linux.hpp&quot;
 112 #include &quot;cgroupSubsystem_linux.hpp&quot;
 113 #endif
 114 
 115 #define SIZE_T_MAX_VALUE ((size_t) -1)
 116 
 117 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 118   do {                                                                 \
 119     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 120     THREAD-&gt;clear_pending_jni_exception_check();                       \
 121     if (HAS_PENDING_EXCEPTION) {                                       \
 122       return(value);                                                   \
 123     }                                                                  \
 124   } while (0)
 125 
 126 #define CHECK_JNI_EXCEPTION(env)                                       \
 127   do {                                                                 \
 128     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 129     THREAD-&gt;clear_pending_jni_exception_check();                       \
 130     if (HAS_PENDING_EXCEPTION) {                                       \
 131       return;                                                          \
 132     }                                                                  \
 133   } while (0)
 134 
 135 bool WhiteBox::_used = false;
 136 volatile bool WhiteBox::compilation_locked = false;
 137 
 138 class VM_WhiteBoxOperation : public VM_Operation {
 139  public:
 140   VM_WhiteBoxOperation()                         { }
 141   VMOp_Type type()                  const        { return VMOp_WhiteBoxOperation; }
 142   bool allow_nested_vm_operations() const        { return true; }
 143 };
 144 
 145 
 146 WB_ENTRY(jlong, WB_GetObjectAddress(JNIEnv* env, jobject o, jobject obj))
 147   return (jlong)(void*)JNIHandles::resolve(obj);
 148 WB_END
 149 
 150 WB_ENTRY(jint, WB_GetHeapOopSize(JNIEnv* env, jobject o))
 151   return heapOopSize;
 152 WB_END
 153 
 154 WB_ENTRY(jint, WB_GetVMPageSize(JNIEnv* env, jobject o))
 155   return os::vm_page_size();
 156 WB_END
 157 
 158 WB_ENTRY(jlong, WB_GetVMAllocationGranularity(JNIEnv* env, jobject o))
 159   return os::vm_allocation_granularity();
 160 WB_END
 161 
 162 WB_ENTRY(jlong, WB_GetVMLargePageSize(JNIEnv* env, jobject o))
 163   return os::large_page_size();
 164 WB_END
 165 
 166 class WBIsKlassAliveClosure : public LockedClassesDo {
 167     Symbol* _name;
 168     int _count;
 169 public:
 170     WBIsKlassAliveClosure(Symbol* name) : _name(name), _count(0) {}
 171 
 172     void do_klass(Klass* k) {
 173       Symbol* ksym = k-&gt;name();
 174       if (ksym-&gt;fast_compare(_name) == 0) {
 175         _count++;
 176       }
 177     }
 178 
 179     int count() const {
 180         return _count;
 181     }
 182 };
 183 
 184 WB_ENTRY(jint, WB_CountAliveClasses(JNIEnv* env, jobject target, jstring name))
 185   oop h_name = JNIHandles::resolve(name);
 186   if (h_name == NULL) return false;
 187   Symbol* sym = java_lang_String::as_symbol(h_name);
 188   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 189 
 190   WBIsKlassAliveClosure closure(sym);
 191   ClassLoaderDataGraph::classes_do(&amp;closure);
 192 
 193   // Return the count of alive classes with this name.
 194   return closure.count();
 195 WB_END
 196 
 197 WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
 198   oop h_name = JNIHandles::resolve(name);
 199   if (h_name == NULL) return false;
 200   Symbol* sym = java_lang_String::as_symbol(h_name);
 201   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 202   return (jint)sym-&gt;refcount();
 203 WB_END
 204 
 205 
 206 WB_ENTRY(void, WB_AddToBootstrapClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 207 #if INCLUDE_JVMTI
 208   ResourceMark rm;
 209   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 210   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 211   jvmtiError err = jvmti_env-&gt;AddToBootstrapClassLoaderSearch(seg);
 212   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 213 #endif
 214 }
 215 WB_END
 216 
 217 WB_ENTRY(void, WB_AddToSystemClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 218 #if INCLUDE_JVMTI
 219   ResourceMark rm;
 220   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 221   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 222   jvmtiError err = jvmti_env-&gt;AddToSystemClassLoaderSearch(seg);
 223   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 224 #endif
 225 }
 226 WB_END
 227 
 228 
 229 WB_ENTRY(jlong, WB_GetCompressedOopsMaxHeapSize(JNIEnv* env, jobject o)) {
 230   return (jlong)Arguments::max_heap_for_compressed_oops();
 231 }
 232 WB_END
 233 
 234 WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
 235   tty-&gt;print_cr(&quot;Minimum heap &quot; SIZE_FORMAT &quot; Initial heap &quot; SIZE_FORMAT &quot; &quot;
 236                 &quot;Maximum heap &quot; SIZE_FORMAT &quot; Space alignment &quot; SIZE_FORMAT &quot; Heap alignment &quot; SIZE_FORMAT,
 237                 MinHeapSize,
 238                 InitialHeapSize,
 239                 MaxHeapSize,
 240                 SpaceAlignment,
 241                 HeapAlignment);
 242 }
 243 WB_END
 244 
 245 #ifndef PRODUCT
 246 // Forward declaration
 247 void TestReservedSpace_test();
 248 void TestReserveMemorySpecial_test();
 249 void TestVirtualSpace_test();
 250 #endif
 251 
 252 WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
 253 #ifndef PRODUCT
 254   TestReservedSpace_test();
 255   TestReserveMemorySpecial_test();
 256   TestVirtualSpace_test();
 257 #endif
 258 WB_END
 259 
 260 WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
 261   size_t granularity = os::vm_allocation_granularity();
 262   ReservedHeapSpace rhs(100 * granularity, granularity, false);
 263   VirtualSpace vs;
 264   vs.initialize(rhs, 50 * granularity);
 265 
 266   // Check if constraints are complied
 267   if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
 268          CompressedOops::base() != NULL &amp;&amp;
 269          CompressedOops::use_implicit_null_checks() )) {
 270     tty-&gt;print_cr(&quot;WB_ReadFromNoaccessArea method is useless:\n &quot;
 271                   &quot;\tUseCompressedOops is %d\n&quot;
 272                   &quot;\trhs.base() is &quot; PTR_FORMAT &quot;\n&quot;
 273                   &quot;\tCompressedOops::base() is &quot; PTR_FORMAT &quot;\n&quot;
 274                   &quot;\tCompressedOops::use_implicit_null_checks() is %d&quot;,
 275                   UseCompressedOops,
 276                   p2i(rhs.base()),
 277                   p2i(CompressedOops::base()),
 278                   CompressedOops::use_implicit_null_checks());
 279     return;
 280   }
 281   tty-&gt;print_cr(&quot;Reading from no access area... &quot;);
 282   tty-&gt;print_cr(&quot;*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c&quot;,
 283                 *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
 284 WB_END
 285 
 286 static jint wb_stress_virtual_space_resize(size_t reserved_space_size,
 287                                            size_t magnitude, size_t iterations) {
 288   size_t granularity = os::vm_allocation_granularity();
 289   ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, false);
 290   VirtualSpace vs;
 291   if (!vs.initialize(rhs, 0)) {
 292     tty-&gt;print_cr(&quot;Failed to initialize VirtualSpace. Can&#39;t proceed.&quot;);
 293     return 3;
 294   }
 295 
 296   int seed = os::random();
 297   tty-&gt;print_cr(&quot;Random seed is %d&quot;, seed);
 298   os::init_random(seed);
 299 
 300   for (size_t i = 0; i &lt; iterations; i++) {
 301 
 302     // Whether we will shrink or grow
 303     bool shrink = os::random() % 2L == 0;
 304 
 305     // Get random delta to resize virtual space
 306     size_t delta = (size_t)os::random() % magnitude;
 307 
 308     // If we are about to shrink virtual space below zero, then expand instead
 309     if (shrink &amp;&amp; vs.committed_size() &lt; delta) {
 310       shrink = false;
 311     }
 312 
 313     // Resizing by delta
 314     if (shrink) {
 315       vs.shrink_by(delta);
 316     } else {
 317       // If expanding fails expand_by will silently return false
 318       vs.expand_by(delta, true);
 319     }
 320   }
 321   return 0;
 322 }
 323 
 324 WB_ENTRY(jint, WB_StressVirtualSpaceResize(JNIEnv* env, jobject o,
 325         jlong reserved_space_size, jlong magnitude, jlong iterations))
 326   tty-&gt;print_cr(&quot;reservedSpaceSize=&quot; JLONG_FORMAT &quot;, magnitude=&quot; JLONG_FORMAT &quot;, &quot;
 327                 &quot;iterations=&quot; JLONG_FORMAT &quot;\n&quot;, reserved_space_size, magnitude,
 328                 iterations);
 329   if (reserved_space_size &lt; 0 || magnitude &lt; 0 || iterations &lt; 0) {
 330     tty-&gt;print_cr(&quot;One of variables printed above is negative. Can&#39;t proceed.\n&quot;);
 331     return 1;
 332   }
 333 
 334   // sizeof(size_t) depends on whether OS is 32bit or 64bit. sizeof(jlong) is
 335   // always 8 byte. That&#39;s why we should avoid overflow in case of 32bit platform.
 336   if (sizeof(size_t) &lt; sizeof(jlong)) {
 337     jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;
 338     if (reserved_space_size &gt; size_t_max_value || magnitude &gt; size_t_max_value
 339         || iterations &gt; size_t_max_value) {
 340       tty-&gt;print_cr(&quot;One of variables printed above overflows size_t. Can&#39;t proceed.\n&quot;);
 341       return 2;
 342     }
 343   }
 344 
 345   return wb_stress_virtual_space_resize((size_t) reserved_space_size,
 346                                         (size_t) magnitude, (size_t) iterations);
 347 WB_END
 348 
 349 WB_ENTRY(jboolean, WB_IsGCSupported(JNIEnv* env, jobject o, jint name))
 350   return GCConfig::is_gc_supported((CollectedHeap::Name)name);
 351 WB_END
 352 
 353 WB_ENTRY(jboolean, WB_IsGCSelected(JNIEnv* env, jobject o, jint name))
 354   return GCConfig::is_gc_selected((CollectedHeap::Name)name);
 355 WB_END
 356 
 357 WB_ENTRY(jboolean, WB_IsGCSelectedErgonomically(JNIEnv* env, jobject o))
 358   return GCConfig::is_gc_selected_ergonomically();
 359 WB_END
 360 
 361 WB_ENTRY(jboolean, WB_isObjectInOldGen(JNIEnv* env, jobject o, jobject obj))
 362   oop p = JNIHandles::resolve(obj);
 363 #if INCLUDE_G1GC
 364   if (UseG1GC) {
 365     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 366     const HeapRegion* hr = g1h-&gt;heap_region_containing(p);
 367     if (hr == NULL) {
 368       return false;
 369     }
 370     return !(hr-&gt;is_young());
 371   }
 372 #endif
 373 #if INCLUDE_PARALLELGC
 374   if (UseParallelGC) {
 375     ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();
 376     return !psh-&gt;is_in_young(p);
 377   }
 378 #endif
 379 #if INCLUDE_ZGC
 380   if (UseZGC) {
 381     return Universe::heap()-&gt;is_in(p);
 382   }
 383 #endif
 384   GenCollectedHeap* gch = GenCollectedHeap::heap();
 385   return !gch-&gt;is_in_young(p);
 386 WB_END
 387 
 388 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 389   oop p = JNIHandles::resolve(obj);
 390   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 391 WB_END
 392 
 393 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 394   return (jlong)SpaceAlignment;
 395 WB_END
 396 
 397 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 398   return (jlong)HeapAlignment;
 399 WB_END
 400 
 401 WB_ENTRY(jboolean, WB_SupportsConcurrentGCBreakpoints(JNIEnv* env, jobject o))
 402   return Universe::heap()-&gt;supports_concurrent_gc_breakpoints();
 403 WB_END
 404 
 405 WB_ENTRY(void, WB_ConcurrentGCAcquireControl(JNIEnv* env, jobject o))
 406   ConcurrentGCBreakpoints::acquire_control();
 407 WB_END
 408 
 409 WB_ENTRY(void, WB_ConcurrentGCReleaseControl(JNIEnv* env, jobject o))
 410   ConcurrentGCBreakpoints::release_control();
 411 WB_END
 412 
 413 WB_ENTRY(void, WB_ConcurrentGCRunToIdle(JNIEnv* env, jobject o))
 414   ConcurrentGCBreakpoints::run_to_idle();
 415 WB_END
 416 
 417 WB_ENTRY(jboolean, WB_ConcurrentGCRunTo(JNIEnv* env, jobject o, jobject at))
 418   Handle h_name(THREAD, JNIHandles::resolve(at));
 419   ResourceMark rm;
 420   const char* c_name = java_lang_String::as_utf8_string(h_name());
 421   return ConcurrentGCBreakpoints::run_to(c_name);
 422 WB_END
 423 
 424 #if INCLUDE_G1GC
 425 
 426 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 427   if (UseG1GC) {
 428     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 429     oop result = JNIHandles::resolve(obj);
 430     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 431     return hr-&gt;is_humongous();
 432   }
 433   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 434 WB_END
 435 
 436 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 437   if (UseG1GC) {
 438     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 439     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 440     return hr-&gt;is_humongous();
 441   }
 442   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToHumongousRegion: G1 GC is not enabled&quot;);
 443 WB_END
 444 
 445 WB_ENTRY(jboolean, WB_G1BelongsToFreeRegion(JNIEnv* env, jobject o, jlong addr))
 446   if (UseG1GC) {
 447     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 448     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 449     return hr-&gt;is_free();
 450   }
 451   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToFreeRegion: G1 GC is not enabled&quot;);
 452 WB_END
 453 
 454 WB_ENTRY(jlong, WB_G1NumMaxRegions(JNIEnv* env, jobject o))
 455   if (UseG1GC) {
 456     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 457     size_t nr = g1h-&gt;max_regions();
 458     return (jlong)nr;
 459   }
 460   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumMaxRegions: G1 GC is not enabled&quot;);
 461 WB_END
 462 
 463 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 464   if (UseG1GC) {
 465     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 466     size_t nr = g1h-&gt;num_free_regions();
 467     return (jlong)nr;
 468   }
 469   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 470 WB_END
 471 
 472 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 473   if (UseG1GC) {
 474     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 475     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 476   }
 477   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 478 WB_END
 479 
 480 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 481   if (UseG1GC) {
 482     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 483     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 484       g1h-&gt;collect(GCCause::_wb_conc_mark);
 485       return true;
 486     }
 487     return false;
 488   }
 489   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 490 WB_END
 491 
 492 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 493   if (UseG1GC) {
 494     return (jint)HeapRegion::GrainBytes;
 495   }
 496   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 497 WB_END
 498 
 499 #endif // INCLUDE_G1GC
 500 
 501 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
 502 WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))
 503 #if INCLUDE_G1GC
 504   if (UseG1GC) {
 505     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 506     if (g1h-&gt;is_heterogeneous_heap()) {
 507       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_dram();
 508       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 509     } else {
 510       return (jlong)g1h-&gt;base();
 511     }
 512   }
 513 #endif // INCLUDE_G1GC
 514 #if INCLUDE_PARALLELGC
 515   if (UseParallelGC) {
 516     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 517     if (AllocateOldGenAt != NULL) {
 518       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 519       return (jlong)reserved.start();
 520     } else {
 521       return (jlong)ps_heap-&gt;base();
 522     }
 523   }
 524 #endif // INCLUDE_PARALLELGC
 525   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedStart: enabled only for G1 and Parallel GC&quot;);
 526 WB_END
 527 
 528 WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))
 529 #if INCLUDE_G1GC
 530   if (UseG1GC) {
 531     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 532     if (g1h-&gt;is_heterogeneous_heap()) {
 533       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
 534       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 535     } else {
 536       return (jlong)g1h-&gt;base() + G1Arguments::heap_max_size_bytes();
 537     }
 538   }
 539 #endif // INCLUDE_G1GC
 540 #if INCLUDE_PARALLELGC
 541   if (UseParallelGC) {
 542     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 543     if (AllocateOldGenAt != NULL) {
 544       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 545       return (jlong)reserved.end();
 546     } else {
 547       return (jlong)ps_heap-&gt;reserved_region().end();
 548     }
 549   }
 550 #endif // INCLUDE_PARALLELGC
 551   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedEnd: enabled only for G1 and Parallel GC&quot;);
 552 WB_END
 553 
 554 WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))
 555 #if INCLUDE_G1GC
 556   if (UseG1GC) {
 557     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 558     if (g1h-&gt;is_heterogeneous_heap()) {
 559       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 560       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 561     } else {
 562       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 563     }
 564   }
 565 #endif // INCLUDE_G1GC
 566 #if INCLUDE_PARALLELGC
 567   if (UseParallelGC) {
 568     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 569     if (AllocateOldGenAt != NULL) {
 570       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 571       return (jlong)reserved.start();
 572     } else {
 573       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 574     }
 575   }
 576 #endif // INCLUDE_PARALLELGC
 577   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: enabled only for G1 and Parallel GC&quot;);
 578 WB_END
 579 
 580 WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))
 581 #if INCLUDE_G1GC
 582   if (UseG1GC) {
 583     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 584     if (g1h-&gt;is_heterogeneous_heap()) {
 585       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 586       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 587     } else {
 588       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 589     }
 590   }
 591 #endif // INCLUDE_G1GC
 592 #if INCLUDE_PARALLELGC
 593   if (UseParallelGC) {
 594     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 595     if (AllocateOldGenAt != NULL) {
 596       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 597       return (jlong)reserved.end();
 598       } else {
 599       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 600     }
 601   }
 602 #endif // INCLUDE_PARALLELGC
 603   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC&quot;);
 604 WB_END
 605 
 606 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
 607 
 608 #if INCLUDE_PARALLELGC
 609 
 610 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
 611   if (UseParallelGC) {
 612     return ParallelScavengeHeap::heap()-&gt;gens()-&gt;virtual_spaces()-&gt;alignment();
 613   }
 614   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSVirtualSpaceAlignment: Parallel GC is not enabled&quot;);
 615 WB_END
 616 
 617 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
 618   if (UseParallelGC) {
 619     return GenAlignment;
 620   }
 621   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSHeapGenerationAlignment: Parallel GC is not enabled&quot;);
 622 WB_END
 623 
 624 #endif // INCLUDE_PARALLELGC
 625 
 626 #if INCLUDE_G1GC
 627 
 628 WB_ENTRY(jobject, WB_G1AuxiliaryMemoryUsage(JNIEnv* env))
 629   if (UseG1GC) {
 630     ResourceMark rm(THREAD);
 631     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 632     MemoryUsage usage = g1h-&gt;get_auxiliary_data_memory_usage();
 633     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 634     return JNIHandles::make_local(env, h());
 635   }
 636   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled&quot;);
 637 WB_END
 638 
 639 WB_ENTRY(jint, WB_G1ActiveMemoryNodeCount(JNIEnv* env, jobject o))
 640   if (UseG1GC) {
 641     G1NUMA* numa = G1NUMA::numa();
 642     return (jint)numa-&gt;num_active_nodes();
 643   }
 644   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1ActiveMemoryNodeCount: G1 GC is not enabled&quot;);
 645 WB_END
 646 
 647 WB_ENTRY(jintArray, WB_G1MemoryNodeIds(JNIEnv* env, jobject o))
 648   if (UseG1GC) {
 649     G1NUMA* numa = G1NUMA::numa();
 650     int num_node_ids = (int)numa-&gt;num_active_nodes();
 651     const int* node_ids = numa-&gt;node_ids();
 652 
 653     typeArrayOop result = oopFactory::new_intArray(num_node_ids, CHECK_NULL);
 654     for (int i = 0; i &lt; num_node_ids; i++) {
 655       result-&gt;int_at_put(i, (jint)node_ids[i]);
 656     }
 657     return (jintArray) JNIHandles::make_local(env, result);
 658   }
 659   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1MemoryNodeIds: G1 GC is not enabled&quot;);
 660 WB_END
 661 
 662 class OldRegionsLivenessClosure: public HeapRegionClosure {
 663 
 664  private:
 665   const int _liveness;
 666   size_t _total_count;
 667   size_t _total_memory;
 668   size_t _total_memory_to_free;
 669 
 670  public:
 671   OldRegionsLivenessClosure(int liveness) :
 672     _liveness(liveness),
 673     _total_count(0),
 674     _total_memory(0),
 675     _total_memory_to_free(0) { }
 676 
 677     size_t total_count() { return _total_count; }
 678     size_t total_memory() { return _total_memory; }
 679     size_t total_memory_to_free() { return _total_memory_to_free; }
 680 
 681   bool do_heap_region(HeapRegion* r) {
 682     if (r-&gt;is_old()) {
 683       size_t prev_live = r-&gt;marked_bytes();
 684       size_t live = r-&gt;live_bytes();
 685       size_t size = r-&gt;used();
 686       size_t reg_size = HeapRegion::GrainBytes;
 687       if (size &gt; 0 &amp;&amp; ((int)(live * 100 / size) &lt; _liveness)) {
 688         _total_memory += size;
 689         ++_total_count;
 690         if (size == reg_size) {
 691         // we don&#39;t include non-full regions since they are unlikely included in mixed gc
 692         // for testing purposes it&#39;s enough to have lowest estimation of total memory that is expected to be freed
 693           _total_memory_to_free += size - prev_live;
 694         }
 695       }
 696     }
 697     return false;
 698   }
 699 };
 700 
 701 
 702 WB_ENTRY(jlongArray, WB_G1GetMixedGCInfo(JNIEnv* env, jobject o, jint liveness))
 703   if (!UseG1GC) {
 704     THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1GetMixedGCInfo: G1 GC is not enabled&quot;);
 705   }
 706   if (liveness &lt; 0) {
 707     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;liveness value should be non-negative&quot;);
 708   }
 709 
 710   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 711   OldRegionsLivenessClosure rli(liveness);
 712   g1h-&gt;heap_region_iterate(&amp;rli);
 713 
 714   typeArrayOop result = oopFactory::new_longArray(3, CHECK_NULL);
 715   result-&gt;long_at_put(0, rli.total_count());
 716   result-&gt;long_at_put(1, rli.total_memory());
 717   result-&gt;long_at_put(2, rli.total_memory_to_free());
 718   return (jlongArray) JNIHandles::make_local(env, result);
 719 WB_END
 720 
 721 #endif // INCLUDE_G1GC
 722 
 723 #if INCLUDE_NMT
 724 // Alloc memory using the test memory type so that we can use that to see if
 725 // NMT picks it up correctly
 726 WB_ENTRY(jlong, WB_NMTMalloc(JNIEnv* env, jobject o, jlong size))
 727   jlong addr = 0;
 728   addr = (jlong)(uintptr_t)os::malloc(size, mtTest);
 729   return addr;
 730 WB_END
 731 
 732 // Alloc memory with pseudo call stack. The test can create psudo malloc
 733 // allocation site to stress the malloc tracking.
 734 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStack(JNIEnv* env, jobject o, jlong size, jint pseudo_stack))
 735   address pc = (address)(size_t)pseudo_stack;
 736   NativeCallStack stack(&amp;pc, 1);
 737   return (jlong)(uintptr_t)os::malloc(size, mtTest, stack);
 738 WB_END
 739 
 740 // Alloc memory with pseudo call stack and specific memory type.
 741 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))
 742   address pc = (address)(size_t)pseudo_stack;
 743   NativeCallStack stack(&amp;pc, 1);
 744   return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);
 745 WB_END
 746 
 747 // Free the memory allocated by NMTAllocTest
 748 WB_ENTRY(void, WB_NMTFree(JNIEnv* env, jobject o, jlong mem))
 749   os::free((void*)(uintptr_t)mem);
 750 WB_END
 751 
 752 WB_ENTRY(jlong, WB_NMTReserveMemory(JNIEnv* env, jobject o, jlong size))
 753   jlong addr = 0;
 754 
 755   addr = (jlong)(uintptr_t)os::reserve_memory(size);
 756   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 757 
 758   return addr;
 759 WB_END
 760 
 761 WB_ENTRY(jlong, WB_NMTAttemptReserveMemoryAt(JNIEnv* env, jobject o, jlong addr, jlong size))
 762   addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((size_t)size, (char*)(uintptr_t)addr);
 763   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 764 
 765   return addr;
 766 WB_END
 767 
 768 WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 769   os::commit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 770   MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);
 771 WB_END
 772 
 773 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 774   os::uncommit_memory((char *)(uintptr_t)addr, size);
 775 WB_END
 776 
 777 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 778   os::release_memory((char *)(uintptr_t)addr, size);
 779 WB_END
 780 
 781 WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))
 782   // Test that we can downgrade NMT levels but not upgrade them.
 783   if (MemTracker::tracking_level() == NMT_off) {
 784     MemTracker::transition_to(NMT_off);
 785     return MemTracker::tracking_level() == NMT_off;
 786   } else {
 787     assert(MemTracker::tracking_level() == NMT_detail, &quot;Should start out as detail tracking&quot;);
 788     MemTracker::transition_to(NMT_summary);
 789     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should be summary now&quot;);
 790 
 791     // Can&#39;t go to detail once NMT is set to summary.
 792     MemTracker::transition_to(NMT_detail);
 793     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should still be summary now&quot;);
 794 
 795     // Shutdown sets tracking level to minimal.
 796     MemTracker::shutdown();
 797     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should be minimal now&quot;);
 798 
 799     // Once the tracking level is minimal, we cannot increase to summary.
 800     // The code ignores this request instead of asserting because if the malloc site
 801     // table overflows in another thread, it tries to change the code to summary.
 802     MemTracker::transition_to(NMT_summary);
 803     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 804 
 805     // Really can never go up to detail, verify that the code would never do this.
 806     MemTracker::transition_to(NMT_detail);
 807     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 808     return MemTracker::tracking_level() == NMT_minimal;
 809   }
 810 WB_END
 811 
 812 WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
 813   int hash_size = MallocSiteTable::hash_buckets();
 814   assert(hash_size &gt; 0, &quot;NMT hash_size should be &gt; 0&quot;);
 815   return (jint)hash_size;
 816 WB_END
 817 
 818 WB_ENTRY(jlong, WB_NMTNewArena(JNIEnv* env, jobject o, jlong init_size))
 819   Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));
 820   return (jlong)arena;
 821 WB_END
 822 
 823 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 824   Arena* a = (Arena*)arena;
 825   delete a;
 826 WB_END
 827 
 828 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 829   Arena* a = (Arena*)arena;
 830   a-&gt;Amalloc(size_t(size));
 831 WB_END
 832 #endif // INCLUDE_NMT
 833 
 834 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 835   assert(method != NULL, &quot;method should not be null&quot;);
 836   ThreadToNativeFromVM ttn(thread);
 837   return env-&gt;FromReflectedMethod(method);
 838 }
 839 
 840 static CompLevel highestCompLevel() {
 841   return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;
 842 }
 843 
 844 // Deoptimizes all compiled frames and makes nmethods not entrant if it&#39;s requested
 845 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 846  private:
 847   int _result;
 848   const bool _make_not_entrant;
 849  public:
 850   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 851         _result(0), _make_not_entrant(make_not_entrant) { }
 852   int  result() const { return _result; }
 853 
 854   void doit() {
 855     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 856       if (t-&gt;has_last_Java_frame()) {
 857         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {
 858           frame* f = fst.current();
 859           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
 860             Deoptimization::deoptimize(t, *f);
 861             if (_make_not_entrant) {
 862                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 863                 assert(cm != NULL, &quot;sanity check&quot;);
 864                 cm-&gt;make_not_entrant();
 865             }
 866             ++_result;
 867           }
 868         }
 869       }
 870     }
 871   }
 872 };
 873 
 874 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 875   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 876   VMThread::execute(&amp;op);
 877   return op.result();
 878 WB_END
 879 
 880 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
 881   CodeCache::mark_all_nmethods_for_deoptimization();
 882   Deoptimization::deoptimize_all_marked();
 883 WB_END
 884 
 885 WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 886   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 887   int result = 0;
 888   CHECK_JNI_EXCEPTION_(env, result);
 889   MutexLocker mu(Compile_lock);
 890   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 891   if (is_osr) {
 892     result += mh-&gt;mark_osr_nmethods();
 893   } else if (mh-&gt;code() != NULL) {
 894     mh-&gt;code()-&gt;mark_for_deoptimization();
 895     ++result;
 896   }
 897   result += CodeCache::mark_for_deoptimization(mh());
 898   if (result &gt; 0) {
 899     Deoptimization::deoptimize_all_marked();
 900   }
 901   return result;
 902 WB_END
 903 
 904 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 905   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 906   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 907   MutexLocker mu(Compile_lock);
 908   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 909   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 910   if (code == NULL) {
 911     return JNI_FALSE;
 912   }
 913   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 914 WB_END
 915 
 916 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 917   if (method == NULL || comp_level &gt; highestCompLevel()) {
 918     return false;
 919   }
 920   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 921   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 922   MutexLocker mu(Compile_lock);
 923   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 924   if (is_osr) {
 925     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 926   } else {
 927     return CompilationPolicy::can_be_compiled(mh, comp_level);
 928   }
 929 WB_END
 930 
 931 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 932   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 933   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 934   MutexLocker mu(Compile_lock);
 935   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 936   return mh-&gt;queued_for_compilation();
 937 WB_END
 938 
 939 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
 940   if (compLevel &lt; CompLevel_none || compLevel &gt; highestCompLevel()) {
 941     return false; // Intrinsic is not available on a non-existent compilation level.
 942   }
 943   jmethodID method_id, compilation_context_id;
 944   method_id = reflected_method_to_jmid(thread, env, method);
 945   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 946   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 947 
 948   DirectiveSet* directive;
 949   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 950   assert(comp != NULL, &quot;compiler not available&quot;);
 951   if (compilation_context != NULL) {
 952     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 953     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 954     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 955     directive = DirectivesStack::getMatchingDirective(cch, comp);
 956   } else {
 957     // Calling with NULL matches default directive
 958     directive = DirectivesStack::getDefaultDirective(comp);
 959   }
 960   bool result = comp-&gt;is_intrinsic_available(mh, directive);
 961   DirectivesStack::release(directive);
 962   return result;
 963 WB_END
 964 
 965 WB_ENTRY(jint, WB_GetMethodCompilationLevel(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 966   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 967   CHECK_JNI_EXCEPTION_(env, CompLevel_none);
 968   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 969   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 970   return (code != NULL ? code-&gt;comp_level() : CompLevel_none);
 971 WB_END
 972 
 973 WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 974   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 975   CHECK_JNI_EXCEPTION(env);
 976   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 977   if (is_osr) {
 978     mh-&gt;set_not_osr_compilable(&quot;WhiteBox&quot;, comp_level);
 979   } else {
 980     mh-&gt;set_not_compilable(&quot;WhiteBox&quot;, comp_level);
 981   }
 982 WB_END
 983 
 984 WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
 985   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 986   CHECK_JNI_EXCEPTION_(env, InvocationEntryBci);
 987   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 988   CompiledMethod* code = mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);
 989   return (code != NULL &amp;&amp; code-&gt;is_osr_method() ? code-&gt;osr_entry_bci() : InvocationEntryBci);
 990 WB_END
 991 
 992 WB_ENTRY(jboolean, WB_TestSetDontInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 993   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 994   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 995   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 996   bool result = mh-&gt;dont_inline();
 997   mh-&gt;set_dont_inline(value == JNI_TRUE);
 998   return result;
 999 WB_END
1000 
1001 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
1002   if (comp_level == CompLevel_any) {
1003     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
1004         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
1005   } else {
1006     return CompileBroker::queue_size(comp_level);
1007   }
1008 WB_END
1009 
1010 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
1011   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1012   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1013   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1014   bool result = mh-&gt;force_inline();
1015   mh-&gt;set_force_inline(value == JNI_TRUE);
1016   return result;
1017 WB_END
1018 
1019 #ifdef LINUX
1020 bool WhiteBox::validate_cgroup(const char* proc_cgroups,
1021                                const char* proc_self_cgroup,
1022                                const char* proc_self_mountinfo,
1023                                u1* cg_flags) {
1024   CgroupInfo cg_infos[4];
1025   return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,
1026                                                     proc_self_cgroup,
1027                                                     proc_self_mountinfo, cg_flags);
1028 }
1029 #endif
1030 
1031 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1032   // Screen for unavailable/bad comp level or null method
1033   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1034   if (method == NULL) {
1035     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
1036     return false;
1037   }
1038   if (comp_level &gt; highestCompLevel()) {
1039     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
1040     return false;
1041   }
1042   if (comp == NULL) {
1043     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
1044     return false;
1045   }
1046 
1047   // Check if compilation is blocking
1048   methodHandle mh(THREAD, method);
1049   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1050   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1051   DirectivesStack::release(directive);
1052 
1053   // Compile method and check result
1054   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1055   MutexLocker mu(THREAD, Compile_lock);
1056   bool is_queued = mh-&gt;queued_for_compilation();
1057   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1058     return true;
1059   }
1060   tty-&gt;print(&quot;WB error: failed to %s compile at level %d method &quot;, is_blocking ? &quot;blocking&quot; : &quot;&quot;, comp_level);
1061   mh-&gt;print_short_name(tty);
1062   tty-&gt;cr();
1063   if (is_blocking &amp;&amp; is_queued) {
1064     tty-&gt;print_cr(&quot;WB error: blocking compilation is still in queue!&quot;);
1065   }
1066   return false;
1067 }
1068 
1069 WB_ENTRY(jboolean, WB_EnqueueMethodForCompilation(JNIEnv* env, jobject o, jobject method, jint comp_level, jint bci))
1070   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1071   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1072   return WhiteBox::compile_method(Method::checked_resolve_jmethod_id(jmid), comp_level, bci, THREAD);
1073 WB_END
1074 
1075 WB_ENTRY(jboolean, WB_EnqueueInitializerForCompilation(JNIEnv* env, jobject o, jclass klass, jint comp_level))
1076   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1077   Method* clinit = ik-&gt;class_initializer();
1078   if (clinit == NULL) {
1079     return false;
1080   }
1081   return WhiteBox::compile_method(clinit, comp_level, InvocationEntryBci, THREAD);
1082 WB_END
1083 
1084 WB_ENTRY(jboolean, WB_ShouldPrintAssembly(JNIEnv* env, jobject o, jobject method, jint comp_level))
1085   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1086   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1087 
1088   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1089   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, CompileBroker::compiler(comp_level));
1090   bool result = directive-&gt;PrintAssemblyOption;
1091   DirectivesStack::release(directive);
1092 
1093   return result;
1094 WB_END
1095 
1096 WB_ENTRY(jint, WB_MatchesInline(JNIEnv* env, jobject o, jobject method, jstring pattern))
1097   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1098   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1099 
1100   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1101 
1102   ResourceMark rm(THREAD);
1103   const char* error_msg = NULL;
1104   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1105   InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
1106 
1107   if (m == NULL) {
1108     assert(error_msg != NULL, &quot;Always have an error message&quot;);
1109     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1110     return -1; // Pattern failed
1111   }
1112 
1113   // Pattern works - now check if it matches
1114   int result;
1115   if (m-&gt;match(mh, InlineMatcher::force_inline)) {
1116     result = 2; // Force inline match
1117   } else if (m-&gt;match(mh, InlineMatcher::dont_inline)) {
1118     result = 1; // Dont inline match
1119   } else {
1120     result = 0; // No match
1121   }
1122   delete m;
1123   return result;
1124 WB_END
1125 
1126 WB_ENTRY(jint, WB_MatchesMethod(JNIEnv* env, jobject o, jobject method, jstring pattern))
1127   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1128   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1129 
1130   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1131 
1132   ResourceMark rm;
1133   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1134 
1135   const char* error_msg = NULL;
1136 
1137   BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);
1138   if (m == NULL) {
1139     assert(error_msg != NULL, &quot;Must have error_msg&quot;);
1140     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1141     return -1;
1142   }
1143 
1144   // Pattern works - now check if it matches
1145   int result = m-&gt;matches(mh);
1146   delete m;
1147   assert(result == 0 || result == 1, &quot;Result out of range&quot;);
1148   return result;
1149 WB_END
1150 
1151 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1152   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1153   CHECK_JNI_EXCEPTION(env);
1154   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1155 
1156   MethodData* mdo = mh-&gt;method_data();
1157   if (mdo == NULL) {
1158     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1159     mdo = mh-&gt;method_data();
1160   }
1161   mdo-&gt;init();
1162   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1163   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1164   // set i-counter according to TieredThresholdPolicy::is_method_profiled
1165   icnt-&gt;set(Tier4MinInvocationThreshold);
1166   bcnt-&gt;set(Tier4CompileThreshold);
1167 WB_END
1168 
1169 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1170   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1171   CHECK_JNI_EXCEPTION(env);
1172   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1173   MutexLocker mu(THREAD, Compile_lock);
1174   MethodData* mdo = mh-&gt;method_data();
1175   MethodCounters* mcs = mh-&gt;method_counters();
1176 
1177   if (mdo != NULL) {
1178     mdo-&gt;init();
1179     ResourceMark rm(THREAD);
1180     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1181     for (int i = 0; i &lt; arg_count; i++) {
1182       mdo-&gt;set_arg_modified(i, 0);
1183     }
1184     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1185     mdo-&gt;clean_method_data(/*always_clean*/true);
1186   }
1187 
1188   mh-&gt;clear_not_c1_compilable();
1189   mh-&gt;clear_not_c2_compilable();
1190   mh-&gt;clear_not_c2_osr_compilable();
1191   NOT_PRODUCT(mh-&gt;set_compiled_invocation_count(0));
1192   if (mcs != NULL) {
1193     mcs-&gt;backedge_counter()-&gt;init();
1194     mcs-&gt;invocation_counter()-&gt;init();
1195     mcs-&gt;set_interpreter_invocation_count(0);
1196     mcs-&gt;set_interpreter_throwout_count(0);
1197 
1198 #ifdef TIERED
1199     mcs-&gt;set_rate(0.0F);
1200     mh-&gt;set_prev_event_count(0);
1201     mh-&gt;set_prev_time(0);
1202 #endif
1203   }
1204 WB_END
1205 
1206 template &lt;typename T&gt;
1207 static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {
1208   if (name == NULL) {
1209     return false;
1210   }
1211   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1212   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1213   CHECK_JNI_EXCEPTION_(env, false);
1214   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
1215   JVMFlag::Error result = (*TAt)(flag, value);
1216   env-&gt;ReleaseStringUTFChars(name, flag_name);
1217   return (result == JVMFlag::SUCCESS);
1218 }
1219 
1220 template &lt;typename T&gt;
1221 static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {
1222   if (name == NULL) {
1223     return false;
1224   }
1225   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1226   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1227   CHECK_JNI_EXCEPTION_(env, false);
1228   JVMFlag* flag = JVMFlag::find_flag(flag_name);
1229   JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);
1230   env-&gt;ReleaseStringUTFChars(name, flag_name);
1231   return (result == JVMFlag::SUCCESS);
1232 }
1233 
1234 template &lt;typename T&gt;
1235 static jobject box(JavaThread* thread, JNIEnv* env, Symbol* name, Symbol* sig, T value) {
1236   ResourceMark rm(thread);
1237   jclass clazz = env-&gt;FindClass(name-&gt;as_C_string());
1238   CHECK_JNI_EXCEPTION_(env, NULL);
1239   jmethodID methodID = env-&gt;GetStaticMethodID(clazz,
1240         vmSymbols::valueOf_name()-&gt;as_C_string(),
1241         sig-&gt;as_C_string());
1242   CHECK_JNI_EXCEPTION_(env, NULL);
1243   jobject result = env-&gt;CallStaticObjectMethod(clazz, methodID, value);
1244   CHECK_JNI_EXCEPTION_(env, NULL);
1245   return result;
1246 }
1247 
1248 static jobject booleanBox(JavaThread* thread, JNIEnv* env, jboolean value) {
1249   return box(thread, env, vmSymbols::java_lang_Boolean(), vmSymbols::Boolean_valueOf_signature(), value);
1250 }
1251 static jobject integerBox(JavaThread* thread, JNIEnv* env, jint value) {
1252   return box(thread, env, vmSymbols::java_lang_Integer(), vmSymbols::Integer_valueOf_signature(), value);
1253 }
1254 static jobject longBox(JavaThread* thread, JNIEnv* env, jlong value) {
1255   return box(thread, env, vmSymbols::java_lang_Long(), vmSymbols::Long_valueOf_signature(), value);
1256 }
1257 /* static jobject floatBox(JavaThread* thread, JNIEnv* env, jfloat value) {
1258   return box(thread, env, vmSymbols::java_lang_Float(), vmSymbols::Float_valueOf_signature(), value);
1259 }*/
1260 static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
1261   return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
1262 }
1263 
1264 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
1265   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1266   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1267   CHECK_JNI_EXCEPTION_(env, NULL);
1268   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
1269   env-&gt;ReleaseStringUTFChars(name, flag_name);
1270   return result;
1271 }
1272 
1273 WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
1274   const JVMFlag* flag = getVMFlag(thread, env, name);
1275   return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
1276 WB_END
1277 
1278 WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
1279   const JVMFlag* flag = getVMFlag(thread, env, name);
1280   return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
1281 WB_END
1282 
1283 WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
1284   bool result;
1285   if (GetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAt)) {
1286     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1287     return booleanBox(thread, env, result);
1288   }
1289   return NULL;
1290 WB_END
1291 
1292 WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
1293   int result;
1294   if (GetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAt)) {
1295     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1296     return longBox(thread, env, result);
1297   }
1298   return NULL;
1299 WB_END
1300 
1301 WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
1302   uint result;
1303   if (GetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAt)) {
1304     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1305     return longBox(thread, env, result);
1306   }
1307   return NULL;
1308 WB_END
1309 
1310 WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
1311   intx result;
1312   if (GetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAt)) {
1313     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1314     return longBox(thread, env, result);
1315   }
1316   return NULL;
1317 WB_END
1318 
1319 WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
1320   uintx result;
1321   if (GetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAt)) {
1322     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1323     return longBox(thread, env, result);
1324   }
1325   return NULL;
1326 WB_END
1327 
1328 WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
1329   uint64_t result;
1330   if (GetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAt)) {
1331     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1332     return longBox(thread, env, result);
1333   }
1334   return NULL;
1335 WB_END
1336 
1337 WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
1338   size_t result;
1339   if (GetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAt)) {
1340     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1341     return longBox(thread, env, result);
1342   }
1343   return NULL;
1344 WB_END
1345 
1346 WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
1347   double result;
1348   if (GetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAt)) {
1349     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1350     return doubleBox(thread, env, result);
1351   }
1352   return NULL;
1353 WB_END
1354 
1355 WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
1356   ccstr ccstrResult;
1357   if (GetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAt)) {
1358     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1359     jstring result = env-&gt;NewStringUTF(ccstrResult);
1360     CHECK_JNI_EXCEPTION_(env, NULL);
1361     return result;
1362   }
1363   return NULL;
1364 WB_END
1365 
1366 WB_ENTRY(void, WB_SetBooleanVMFlag(JNIEnv* env, jobject o, jstring name, jboolean value))
1367   bool result = value == JNI_TRUE ? true : false;
1368   SetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAtPut);
1369 WB_END
1370 
1371 WB_ENTRY(void, WB_SetIntVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1372   int result = value;
1373   SetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAtPut);
1374 WB_END
1375 
1376 WB_ENTRY(void, WB_SetUintVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1377   uint result = value;
1378   SetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAtPut);
1379 WB_END
1380 
1381 WB_ENTRY(void, WB_SetIntxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1382   intx result = value;
1383   SetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAtPut);
1384 WB_END
1385 
1386 WB_ENTRY(void, WB_SetUintxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1387   uintx result = value;
1388   SetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAtPut);
1389 WB_END
1390 
1391 WB_ENTRY(void, WB_SetUint64VMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1392   uint64_t result = value;
1393   SetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAtPut);
1394 WB_END
1395 
1396 WB_ENTRY(void, WB_SetSizeTVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1397   size_t result = value;
1398   SetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAtPut);
1399 WB_END
1400 
1401 WB_ENTRY(void, WB_SetDoubleVMFlag(JNIEnv* env, jobject o, jstring name, jdouble value))
1402   double result = value;
1403   SetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAtPut);
1404 WB_END
1405 
1406 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
1407   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1408   const char* ccstrValue;
1409   if (value == NULL) {
1410     ccstrValue = NULL;
1411   }
1412   else {
1413     ccstrValue = env-&gt;GetStringUTFChars(value, NULL);
1414     CHECK_JNI_EXCEPTION(env);
1415   }
1416   ccstr ccstrResult = ccstrValue;
1417   bool needFree;
1418   {
1419     ThreadInVMfromNative ttvfn(thread); // back to VM
1420     needFree = SetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAtPut);
1421   }
1422   if (value != NULL) {
1423     env-&gt;ReleaseStringUTFChars(value, ccstrValue);
1424   }
1425   if (needFree) {
1426     FREE_C_HEAP_ARRAY(char, ccstrResult);
1427   }
1428 WB_END
1429 
1430 WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
1431   WhiteBox::compilation_locked = true;
1432 WB_END
1433 
1434 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1435   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1436   WhiteBox::compilation_locked = false;
1437   mo.notify_all();
1438 WB_END
1439 
1440 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1441   // Force a code cache sweep and block until it finished
1442   NMethodSweeper::force_sweep();
1443 WB_END
1444 
1445 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1446   ResourceMark rm(THREAD);
1447   int len;
1448   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1449   return (StringTable::lookup(name, len) != NULL);
1450 WB_END
1451 
1452 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
1453   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1454   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1455 #if INCLUDE_G1GC
1456   if (UseG1GC) {
1457     // Needs to be cleared explicitly for G1
1458     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1459   }
1460 #endif // INCLUDE_G1GC
1461 WB_END
1462 
1463 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1464   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1465 WB_END
1466 
1467 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1468   // static+volatile in order to force the read to happen
1469   // (not be eliminated by the compiler)
1470   static char c;
1471   static volatile char* p;
1472 
1473   p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);
1474   if (p == NULL) {
1475     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), &quot;Failed to reserve memory&quot;);
1476   }
1477 
1478   c = *p;
1479 WB_END
1480 
1481 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
1482   const char* features = VM_Version::features_string();
1483   ThreadToNativeFromVM ttn(thread);
1484   jstring features_string = env-&gt;NewStringUTF(features);
1485 
1486   CHECK_JNI_EXCEPTION_(env, NULL);
1487 
1488   return features_string;
1489 WB_END
1490 
1491 int WhiteBox::get_blob_type(const CodeBlob* code) {
1492   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1493   if (code-&gt;is_aot()) {
1494     return -1;
1495   }
1496   return CodeCache::get_code_heap(code)-&gt;code_blob_type();
1497 }
1498 
1499 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1500   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1501   return CodeCache::get_code_heap(blob_type);
1502 }
1503 
1504 struct CodeBlobStub {
1505   CodeBlobStub(const CodeBlob* blob) :
1506       name(os::strdup(blob-&gt;name())),
1507       size(blob-&gt;size()),
1508       blob_type(WhiteBox::get_blob_type(blob)),
1509       address((jlong) blob) { }
1510   ~CodeBlobStub() { os::free((void*) name); }
1511   const char* const name;
1512   const jint        size;
1513   const jint        blob_type;
1514   const jlong       address;
1515 };
1516 
1517 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
1518   ResourceMark rm;
1519   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1520   CHECK_JNI_EXCEPTION_(env, NULL);
1521   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1522 
1523   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1524   CHECK_JNI_EXCEPTION_(env, NULL);
1525   env-&gt;SetObjectArrayElement(result, 0, name);
1526 
1527   jobject obj = integerBox(thread, env, cb-&gt;size);
1528   CHECK_JNI_EXCEPTION_(env, NULL);
1529   env-&gt;SetObjectArrayElement(result, 1, obj);
1530 
1531   obj = integerBox(thread, env, cb-&gt;blob_type);
1532   CHECK_JNI_EXCEPTION_(env, NULL);
1533   env-&gt;SetObjectArrayElement(result, 2, obj);
1534 
1535   obj = longBox(thread, env, cb-&gt;address);
1536   CHECK_JNI_EXCEPTION_(env, NULL);
1537   env-&gt;SetObjectArrayElement(result, 3, obj);
1538 
1539   return result;
1540 }
1541 
1542 WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
1543   ResourceMark rm(THREAD);
1544   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1545   CHECK_JNI_EXCEPTION_(env, NULL);
1546   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1547   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
1548   jobjectArray result = NULL;
1549   if (code == NULL) {
1550     return result;
1551   }
1552   int comp_level = code-&gt;comp_level();
1553   int insts_size = comp_level == CompLevel_aot ? code-&gt;code_end() - code-&gt;code_begin() : code-&gt;insts_size();
1554 
1555   ThreadToNativeFromVM ttn(thread);
1556   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1557   CHECK_JNI_EXCEPTION_(env, NULL);
1558   result = env-&gt;NewObjectArray(5, clazz, NULL);
1559   if (result == NULL) {
1560     return result;
1561   }
1562 
1563   CodeBlobStub stub(code);
1564   jobjectArray codeBlob = codeBlob2objectArray(thread, env, &amp;stub);
1565   CHECK_JNI_EXCEPTION_(env, NULL);
1566   env-&gt;SetObjectArrayElement(result, 0, codeBlob);
1567 
1568   jobject level = integerBox(thread, env, comp_level);
1569   CHECK_JNI_EXCEPTION_(env, NULL);
1570   env-&gt;SetObjectArrayElement(result, 1, level);
1571 
1572   jbyteArray insts = env-&gt;NewByteArray(insts_size);
1573   CHECK_JNI_EXCEPTION_(env, NULL);
1574   env-&gt;SetByteArrayRegion(insts, 0, insts_size, (jbyte*) code-&gt;insts_begin());
1575   env-&gt;SetObjectArrayElement(result, 2, insts);
1576 
1577   jobject id = integerBox(thread, env, code-&gt;compile_id());
1578   CHECK_JNI_EXCEPTION_(env, NULL);
1579   env-&gt;SetObjectArrayElement(result, 3, id);
1580 
1581   jobject entry_point = longBox(thread, env, (jlong) code-&gt;entry_point());
1582   CHECK_JNI_EXCEPTION_(env, NULL);
1583   env-&gt;SetObjectArrayElement(result, 4, entry_point);
1584 
1585   return result;
1586 WB_END
1587 
1588 CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {
1589   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1590   BufferBlob* blob;
1591   int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
1592   if (full_size &lt; size) {
1593     full_size += align_up(size - full_size, oopSize);
1594   }
1595   {
1596     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1597     blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
1598     if (blob != NULL) {
1599       ::new (blob) BufferBlob(&quot;WB::DummyBlob&quot;, full_size);
1600     }
1601   }
1602   // Track memory usage statistic after releasing CodeCache_lock
1603   MemoryService::track_code_cache_memory_usage();
1604   return blob;
1605 }
1606 
1607 WB_ENTRY(jlong, WB_AllocateCodeBlob(JNIEnv* env, jobject o, jint size, jint blob_type))
1608   if (size &lt; 0) {
1609     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1610       err_msg(&quot;WB_AllocateCodeBlob: size is negative: &quot; INT32_FORMAT, size));
1611   }
1612   return (jlong) WhiteBox::allocate_code_blob(size, blob_type);
1613 WB_END
1614 
1615 WB_ENTRY(void, WB_FreeCodeBlob(JNIEnv* env, jobject o, jlong addr))
1616   if (addr == 0) {
1617     return;
1618   }
1619   BufferBlob::free((BufferBlob*) addr);
1620 WB_END
1621 
1622 WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
1623   ResourceMark rm;
1624   GrowableArray&lt;CodeBlobStub*&gt; blobs;
1625   {
1626     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1627     CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
1628     if (heap == NULL) {
1629       return NULL;
1630     }
1631     for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
1632          cb != NULL; cb = (CodeBlob*) heap-&gt;next(cb)) {
1633       CodeBlobStub* stub = NEW_RESOURCE_OBJ(CodeBlobStub);
1634       new (stub) CodeBlobStub(cb);
1635       blobs.append(stub);
1636     }
1637   }
1638   ThreadToNativeFromVM ttn(thread);
1639   jobjectArray result = NULL;
1640   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1641   CHECK_JNI_EXCEPTION_(env, NULL);
1642   result = env-&gt;NewObjectArray(blobs.length(), clazz, NULL);
1643   CHECK_JNI_EXCEPTION_(env, NULL);
1644   if (result == NULL) {
1645     return result;
1646   }
1647   int i = 0;
1648   for (GrowableArrayIterator&lt;CodeBlobStub*&gt; it = blobs.begin();
1649        it != blobs.end(); ++it) {
1650     jobjectArray obj = codeBlob2objectArray(thread, env, *it);
1651     CHECK_JNI_EXCEPTION_(env, NULL);
1652     env-&gt;SetObjectArrayElement(result, i, obj);
1653     CHECK_JNI_EXCEPTION_(env, NULL);
1654     ++i;
1655   }
1656   return result;
1657 WB_END
1658 
1659 WB_ENTRY(jint, WB_GetCompilationActivityMode(JNIEnv* env, jobject o))
1660   return CompileBroker::get_compilation_activity_mode();
1661 WB_END
1662 
1663 WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
1664   if (addr == 0) {
1665     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
1666       &quot;WB_GetCodeBlob: addr is null&quot;);
1667   }
1668   ThreadToNativeFromVM ttn(thread);
1669   CodeBlobStub stub((CodeBlob*) addr);
1670   return codeBlob2objectArray(thread, env, &amp;stub);
1671 WB_END
1672 
1673 WB_ENTRY(jlong, WB_GetMethodData(JNIEnv* env, jobject wv, jobject method))
1674   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1675   CHECK_JNI_EXCEPTION_(env, 0);
1676   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1677   return (jlong) mh-&gt;method_data();
1678 WB_END
1679 
1680 WB_ENTRY(jlong, WB_GetThreadStackSize(JNIEnv* env, jobject o))
1681   return (jlong) Thread::current()-&gt;stack_size();
1682 WB_END
1683 
1684 WB_ENTRY(jlong, WB_GetThreadRemainingStackSize(JNIEnv* env, jobject o))
1685   JavaThread* t = JavaThread::current();
1686   return (jlong) t-&gt;stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();
1687 WB_END
1688 
1689 
1690 int WhiteBox::array_bytes_to_length(size_t bytes) {
1691   return Array&lt;u1&gt;::bytes_to_length(bytes);
1692 }
1693 
1694 WB_ENTRY(jlong, WB_AllocateMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong size))
1695   if (size &lt; 0) {
1696     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1697         err_msg(&quot;WB_AllocateMetaspace: size is negative: &quot; JLONG_FORMAT, size));
1698   }
1699 
1700   oop class_loader_oop = JNIHandles::resolve(class_loader);
1701   ClassLoaderData* cld = class_loader_oop != NULL
1702       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1703       : ClassLoaderData::the_null_class_loader_data();
1704 
1705   void* metadata = MetadataFactory::new_array&lt;u1&gt;(cld, WhiteBox::array_bytes_to_length((size_t)size), thread);
1706 
1707   return (jlong)(uintptr_t)metadata;
1708 WB_END
1709 
1710 WB_ENTRY(void, WB_FreeMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong addr, jlong size))
1711   oop class_loader_oop = JNIHandles::resolve(class_loader);
1712   ClassLoaderData* cld = class_loader_oop != NULL
1713       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1714       : ClassLoaderData::the_null_class_loader_data();
1715 
1716   MetadataFactory::free_array(cld, (Array&lt;u1&gt;*)(uintptr_t)addr);
1717 WB_END
1718 
1719 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
1720                                 jstring version, jstring location, jobjectArray packages))
1721   ResourceMark rm(THREAD);
1722 
1723   objArrayOop packages_oop = objArrayOop(JNIHandles::resolve(packages));
1724   objArrayHandle packages_h(THREAD, packages_oop);
1725   int num_packages = (packages_h == NULL ? 0 : packages_h-&gt;length());
1726 
1727   char** pkgs = NULL;
1728   if (num_packages &gt; 0) {
1729     pkgs = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char*, num_packages);
1730     for (int x = 0; x &lt; num_packages; x++) {
1731       oop pkg_str = packages_h-&gt;obj_at(x);
1732       if (pkg_str == NULL || !pkg_str-&gt;is_a(SystemDictionary::String_klass())) {
1733         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1734                   err_msg(&quot;Bad package name&quot;));
1735       }
1736       pkgs[x] = java_lang_String::as_utf8_string(pkg_str);
1737     }
1738   }
1739   Modules::define_module(module, is_open, version, location, (const char* const*)pkgs, num_packages, CHECK);
1740 WB_END
1741 
1742 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
1743   ResourceMark rm(THREAD);
1744   char* package_name = NULL;
1745   if (package != NULL) {
1746       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1747   }
1748   Modules::add_module_exports_qualified(from_module, package_name, to_module, CHECK);
1749 WB_END
1750 
1751 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
1752   ResourceMark rm(THREAD);
1753   char* package_name = NULL;
1754   if (package != NULL) {
1755       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1756   }
1757   Modules::add_module_exports_to_all_unnamed(module, package_name, CHECK);
1758 WB_END
1759 
1760 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
1761   ResourceMark rm(THREAD);
1762   char* package_name = NULL;
1763   if (package != NULL) {
1764       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1765   }
1766   Modules::add_module_exports(module, package_name, NULL, CHECK);
1767 WB_END
1768 
1769 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
1770   Modules::add_reads_module(from_module, source_module, CHECK);
1771 WB_END
1772 
1773 WB_ENTRY(jlong, WB_IncMetaspaceCapacityUntilGC(JNIEnv* env, jobject wb, jlong inc))
1774   if (inc &lt; 0) {
1775     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1776         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc is negative: &quot; JLONG_FORMAT, inc));
1777   }
1778 
1779   jlong max_size_t = (jlong) ((size_t) -1);
1780   if (inc &gt; max_size_t) {
1781     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1782         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc does not fit in size_t: &quot; JLONG_FORMAT, inc));
1783   }
1784 
1785   size_t new_cap_until_GC = 0;
1786   size_t aligned_inc = align_down((size_t) inc, Metaspace::commit_alignment());
1787   bool success = MetaspaceGC::inc_capacity_until_GC(aligned_inc, &amp;new_cap_until_GC);
1788   if (!success) {
1789     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(),
1790                 &quot;WB_IncMetaspaceCapacityUntilGC: could not increase capacity until GC &quot;
1791                 &quot;due to contention with another thread&quot;);
1792   }
1793   return (jlong) new_cap_until_GC;
1794 WB_END
1795 
1796 WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
1797   return (jlong) MetaspaceGC::capacity_until_GC();
1798 WB_END
1799 
1800 WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
1801   return (jlong)Metaspace::reserve_alignment();
1802 WB_END
1803 
1804 WB_ENTRY(void, WB_AssertMatchingSafepointCalls(JNIEnv* env, jobject o, jboolean mutexSafepointValue, jboolean attemptedNoSafepointValue))
1805   Mutex::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?
1806                                            Mutex::_safepoint_check_always :
1807                                            Mutex::_safepoint_check_never;
1808   Mutex::SafepointCheckFlag sfpt_check_attempted = attemptedNoSafepointValue ?
1809                                            Mutex::_no_safepoint_check_flag :
1810                                            Mutex::_safepoint_check_flag;
1811   MutexLocker ml(new Mutex(Mutex::leaf, &quot;SFPT_Test_lock&quot;, true, sfpt_check_required),
1812                  sfpt_check_attempted);
1813 WB_END
1814 
1815 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1816   // Create a special lock violating condition in value
1817   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1818                                            Mutex::_safepoint_check_always :
1819                                            Mutex::_safepoint_check_never;
1820   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1821                                            Monitor::_safepoint_check_flag :
1822                                            Monitor::_no_safepoint_check_flag;
1823 
1824   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);
1825   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1826   ThreadBlockInVM tbivm(JavaThread::current());
1827 WB_END
1828 
1829 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1830   oop obj_oop = JNIHandles::resolve(obj);
1831   return (jboolean) obj_oop-&gt;mark().has_monitor();
1832 WB_END
1833 
1834 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
1835   VM_ForceSafepoint force_safepoint_op;
1836   VMThread::execute(&amp;force_safepoint_op);
1837 WB_END
1838 
1839 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1840   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1841   return (jlong) ik-&gt;constants();
1842 WB_END
1843 
1844 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1845   return ConstantPool::CPCACHE_INDEX_TAG;
1846 WB_END
1847 
1848 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1849   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1850   ConstantPool* cp = ik-&gt;constants();
1851   if (cp-&gt;cache() == NULL) {
1852       return -1;
1853   }
1854   return cp-&gt;cache()-&gt;length();
1855 WB_END
1856 
1857 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1858   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1859   ConstantPool* cp = ik-&gt;constants();
1860   if (cp-&gt;cache() == NULL) {
1861     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), &quot;Constant pool does not have a cache&quot;);
1862   }
1863   jint cpci = index;
1864   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1865   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1866     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool cache index is out of range&quot;);
1867   }
1868   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1869   return cpi;
1870 WB_END
1871 
1872 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1873   return ConstantPool::encode_invokedynamic_index(index);
1874 WB_END
1875 
1876 WB_ENTRY(jobjectArray, WB_getObjectsViaKlassOopMaps(JNIEnv* env, jobject wb, jobject thing))
1877   oop aoop = JNIHandles::resolve(thing);
1878   if (!aoop-&gt;is_instance()) {
1879     return NULL;
1880   }
1881   instanceHandle ih(THREAD, (instanceOop) aoop);
1882   InstanceKlass* klass = InstanceKlass::cast(aoop-&gt;klass());
1883   if (klass-&gt;nonstatic_oop_map_count() == 0) {
1884     return NULL;
1885   }
1886   const OopMapBlock* map = klass-&gt;start_of_nonstatic_oop_maps();
1887   const OopMapBlock* const end = map + klass-&gt;nonstatic_oop_map_count();
1888   int oop_count = 0;
1889   while (map &lt; end) {
1890     oop_count += map-&gt;count();
1891     map++;
1892   }
1893 
1894   objArrayOop result_array =
1895       oopFactory::new_objArray(SystemDictionary::Object_klass(), oop_count, CHECK_NULL);
1896   map = klass-&gt;start_of_nonstatic_oop_maps();
1897   instanceOop ioop = ih();
1898   int index = 0;
1899   while (map &lt; end) {
1900     int offset = map-&gt;offset();
1901     for (unsigned int j = 0; j &lt; map-&gt;count(); j++) {
1902       result_array-&gt;obj_at_put(index++, ioop-&gt;obj_field(offset));
1903       offset += heapOopSize;
1904     }
1905     map++;
1906   }
1907   return (jobjectArray)JNIHandles::make_local(env, result_array);
1908 WB_END
1909 
1910 class CollectOops : public BasicOopIterateClosure {
1911  public:
1912   GrowableArray&lt;Handle&gt;* array;
1913 
1914   objArrayOop create_results(TRAPS) {
1915     objArrayOop result_array =
1916         oopFactory::new_objArray(SystemDictionary::Object_klass(), array-&gt;length(), CHECK_NULL);
1917     for (int i = 0 ; i &lt; array-&gt;length(); i++) {
1918       result_array-&gt;obj_at_put(i, array-&gt;at(i)());
1919     }
1920     return result_array;
1921   }
1922 
1923   jobjectArray create_jni_result(JNIEnv* env, TRAPS) {
1924     return (jobjectArray)JNIHandles::make_local(env, create_results(THREAD));
1925   }
1926 
1927   void add_oop(oop o) {
1928     // Value might be oop, but JLS can&#39;t see as Object, just iterate through it...
1929     if (o != NULL &amp;&amp; o-&gt;is_value()) {
1930       o-&gt;oop_iterate(this);
1931     } else {
1932       array-&gt;append(Handle(Thread::current(), o));
1933     }
1934   }
1935 
1936   void do_oop(oop* o) { add_oop(*o); }
1937   void do_oop(narrowOop* v) { add_oop(CompressedOops::decode(*v)); }
1938 };
1939 
1940 
1941 WB_ENTRY(jobjectArray, WB_getObjectsViaOopIterator(JNIEnv* env, jobject wb, jobject thing))
1942   ResourceMark rm(THREAD);
1943   GrowableArray&lt;Handle&gt;* array = new GrowableArray&lt;Handle&gt;(128);
1944   CollectOops collectOops;
1945   collectOops.array = array;
1946 
1947   JNIHandles::resolve(thing)-&gt;oop_iterate(&amp;collectOops);
1948 
1949   return collectOops.create_jni_result(env, THREAD);
1950 WB_END
1951 
1952 WB_ENTRY(jobjectArray, WB_getObjectsViaFrameOopIterator(JNIEnv* env, jobject wb, jint depth))
1953   ResourceMark rm(THREAD);
1954   GrowableArray&lt;Handle&gt;* array = new GrowableArray&lt;Handle&gt;(128);
1955   CollectOops collectOops;
1956   collectOops.array = array;
1957   StackFrameStream sfs(thread);
1958   while (depth &gt; 0) { // Skip the native WB API frame
1959     sfs.next();
1960     frame* f = sfs.current();
1961     f-&gt;oops_do(&amp;collectOops, NULL, sfs.register_map());
1962     depth--;
1963   }
1964   return collectOops.create_jni_result(env, THREAD);
1965 WB_END
1966 
1967 
1968 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1969   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1970   VMThread::execute(&amp;clear_ics);
1971 WB_END
1972 
1973 template &lt;typename T&gt;
1974 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1975   assert(value != NULL, &quot;sanity&quot;);
1976   if (method == NULL || name == NULL) {
1977     return false;
1978   }
1979   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1980   CHECK_JNI_EXCEPTION_(env, false);
1981   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1982   // can&#39;t be in VM when we call JNI
1983   ThreadToNativeFromVM ttnfv(thread);
1984   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1985   CHECK_JNI_EXCEPTION_(env, false);
1986   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1987   env-&gt;ReleaseStringUTFChars(name, flag_name);
1988   return result;
1989 }
1990 
1991 WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1992   bool result;
1993   if (GetMethodOption&lt;bool&gt; (thread, env, method, name, &amp;result)) {
1994     // can&#39;t be in VM when we call JNI
1995     ThreadToNativeFromVM ttnfv(thread);
1996     return booleanBox(thread, env, result);
1997   }
1998   return NULL;
1999 WB_END
2000 
2001 WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
2002   intx result;
2003   if (GetMethodOption &lt;intx&gt; (thread, env, method, name, &amp;result)) {
2004     // can&#39;t be in VM when we call JNI
2005     ThreadToNativeFromVM ttnfv(thread);
2006     return longBox(thread, env, result);
2007   }
2008   return NULL;
2009 WB_END
2010 
2011 WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
2012   uintx result;
2013   if (GetMethodOption &lt;uintx&gt; (thread, env, method, name, &amp;result)) {
2014     // can&#39;t be in VM when we call JNI
2015     ThreadToNativeFromVM ttnfv(thread);
2016     return longBox(thread, env, result);
2017   }
2018   return NULL;
2019 WB_END
2020 
2021 WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject method, jstring name))
2022   double result;
2023   if (GetMethodOption &lt;double&gt; (thread, env, method, name, &amp;result)) {
2024     // can&#39;t be in VM when we call JNI
2025     ThreadToNativeFromVM ttnfv(thread);
2026     return doubleBox(thread, env, result);
2027   }
2028   return NULL;
2029 WB_END
2030 
2031 WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject method, jstring name))
2032   ccstr ccstrResult;
2033   if (GetMethodOption &lt;ccstr&gt; (thread, env, method, name, &amp;ccstrResult)) {
2034     // can&#39;t be in VM when we call JNI
2035     ThreadToNativeFromVM ttnfv(thread);
2036     jstring result = env-&gt;NewStringUTF(ccstrResult);
2037     CHECK_JNI_EXCEPTION_(env, NULL);
2038     return result;
2039   }
2040   return NULL;
2041 WB_END
2042 
2043 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
2044   const char* p = Arguments::get_default_shared_archive_path();
2045   ThreadToNativeFromVM ttn(thread);
2046   jstring path_string = env-&gt;NewStringUTF(p);
2047 
2048   CHECK_JNI_EXCEPTION_(env, NULL);
2049 
2050   return path_string;
2051 WB_END
2052 
2053 WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
2054   return UseSharedSpaces;
2055 WB_END
2056 
2057 WB_ENTRY(jboolean, WB_CDSMemoryMappingFailed(JNIEnv* env, jobject wb))
2058   return FileMapInfo::memory_mapping_failed();
2059 WB_END
2060 
2061 WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
2062   oop obj_oop = JNIHandles::resolve(obj);
2063   return HeapShared::is_archived_object(obj_oop);
2064 WB_END
2065 
2066 WB_ENTRY(jboolean, WB_IsSharedClass(JNIEnv* env, jobject wb, jclass clazz))
2067   return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
2068 WB_END
2069 
2070 WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))
2071   return !HeapShared::closed_archive_heap_region_mapped();
2072 WB_END
2073 
2074 WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))
2075   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2076   if (k-&gt;is_instance_klass()) {
2077     InstanceKlass *ik = InstanceKlass::cast(k);
2078     ConstantPool *cp = ik-&gt;constants();
2079     objArrayOop refs =  cp-&gt;resolved_references();
2080     return (jobject)JNIHandles::make_local(env, refs);
2081   } else {
2082     return NULL;
2083   }
2084 WB_END
2085 
2086 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
2087   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
2088   if (!k-&gt;is_instance_klass()) {
2089     return;
2090   }
2091   InstanceKlass *ik = InstanceKlass::cast(k);
2092   ik-&gt;link_class(THREAD); // may throw verification error
2093 WB_END
2094 
2095 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
2096   return HeapShared::open_archive_heap_region_mapped();
2097 WB_END
2098 
2099 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
2100 #if INCLUDE_CDS
2101   return true;
2102 #else
2103   return false;
2104 #endif // INCLUDE_CDS
2105 WB_END
2106 
2107 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
2108 #if COMPILER2_OR_JVMCI
2109   return true;
2110 #else
2111   return false;
2112 #endif
2113 WB_END
2114 
2115 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2116   return HeapShared::is_heap_object_archiving_allowed();
2117 WB_END
2118 
2119 
2120 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
2121 #if INCLUDE_JFR
2122   return true;
2123 #else
2124   return false;
2125 #endif // INCLUDE_JFR
2126 WB_END
2127 
2128 #if INCLUDE_CDS
2129 
2130 WB_ENTRY(jint, WB_GetOffsetForName(JNIEnv* env, jobject o, jstring name))
2131   ResourceMark rm;
2132   char* c_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
2133   int result = CDSOffsets::find_offset(c_name);
2134   return (jint)result;
2135 WB_END
2136 
2137 #endif // INCLUDE_CDS
2138 
2139 WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
2140   class TraceSelfClosure : public HandshakeClosure {
2141     jint _num_threads_completed;
2142 
2143     void do_thread(Thread* th) {
2144       assert(th-&gt;is_Java_thread(), &quot;sanity&quot;);
2145       JavaThread* jt = (JavaThread*)th;
2146       ResourceMark rm;
2147 
2148       jt-&gt;print_on(tty);
2149       jt-&gt;print_stack_on(tty);
2150       tty-&gt;cr();
2151       Atomic::inc(&amp;_num_threads_completed);
2152     }
2153 
2154   public:
2155     TraceSelfClosure() : HandshakeClosure(&quot;WB_TraceSelf&quot;), _num_threads_completed(0) {}
2156 
2157     jint num_threads_completed() const { return _num_threads_completed; }
2158   };
2159   TraceSelfClosure tsc;
2160 
2161   if (all_threads) {
2162     Handshake::execute(&amp;tsc);
2163   } else {
2164     oop thread_oop = JNIHandles::resolve(thread_handle);
2165     if (thread_oop != NULL) {
2166       JavaThread* target = java_lang_Thread::thread(thread_oop);
2167       Handshake::execute(&amp;tsc, target);
2168     }
2169   }
2170   return tsc.num_threads_completed();
2171 WB_END
2172 
2173 //Some convenience methods to deal with objects from java
2174 int WhiteBox::offset_for_field(const char* field_name, oop object,
2175     Symbol* signature_symbol) {
2176   assert(field_name != NULL &amp;&amp; strlen(field_name) &gt; 0, &quot;Field name not valid&quot;);
2177   Thread* THREAD = Thread::current();
2178 
2179   //Get the class of our object
2180   Klass* arg_klass = object-&gt;klass();
2181   //Turn it into an instance-klass
2182   InstanceKlass* ik = InstanceKlass::cast(arg_klass);
2183 
2184   //Create symbols to look for in the class
2185   TempNewSymbol name_symbol = SymbolTable::new_symbol(field_name);
2186 
2187   //To be filled in with an offset of the field we&#39;re looking for
2188   fieldDescriptor fd;
2189 
2190   Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
2191   if (res == NULL) {
2192     tty-&gt;print_cr(&quot;Invalid layout of %s at %s&quot;, ik-&gt;external_name(),
2193         name_symbol-&gt;as_C_string());
2194     vm_exit_during_initialization(&quot;Invalid layout of preloaded class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
2195   }
2196 
2197   //fetch the field at the offset we&#39;ve found
2198   int dest_offset = fd.offset();
2199 
2200   return dest_offset;
2201 }
2202 
2203 
2204 const char* WhiteBox::lookup_jstring(const char* field_name, oop object) {
2205   int offset = offset_for_field(field_name, object,
2206       vmSymbols::string_signature());
2207   oop string = object-&gt;obj_field(offset);
2208   if (string == NULL) {
2209     return NULL;
2210   }
2211   const char* ret = java_lang_String::as_utf8_string(string);
2212   return ret;
2213 }
2214 
2215 bool WhiteBox::lookup_bool(const char* field_name, oop object) {
2216   int offset =
2217       offset_for_field(field_name, object, vmSymbols::bool_signature());
2218   bool ret = (object-&gt;bool_field(offset) == JNI_TRUE);
2219   return ret;
2220 }
2221 
2222 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
2223   ResourceMark rm;
2224   ThreadToNativeFromVM ttnfv(thread); // can&#39;t be in VM when we call JNI
2225 
2226   //  one by one registration natives for exception catching
2227   jclass no_such_method_error_klass = env-&gt;FindClass(vmSymbols::java_lang_NoSuchMethodError()-&gt;as_C_string());
2228   CHECK_JNI_EXCEPTION(env);
2229   for (int i = 0, n = method_count; i &lt; n; ++i) {
2230     // Skip dummy entries
2231     if (method_array[i].fnPtr == NULL) continue;
2232     if (env-&gt;RegisterNatives(wbclass, &amp;method_array[i], 1) != 0) {
2233       jthrowable throwable_obj = env-&gt;ExceptionOccurred();
2234       if (throwable_obj != NULL) {
2235         env-&gt;ExceptionClear();
2236         if (env-&gt;IsInstanceOf(throwable_obj, no_such_method_error_klass)) {
2237           // NoSuchMethodError is thrown when a method can&#39;t be found or a method is not native.
2238           // Ignoring the exception since it is not preventing use of other WhiteBox methods.
2239           tty-&gt;print_cr(&quot;Warning: &#39;NoSuchMethodError&#39; on register of sun.hotspot.WhiteBox::%s%s&quot;,
2240               method_array[i].name, method_array[i].signature);
2241         }
2242       } else {
2243         // Registration failed unexpectedly.
2244         tty-&gt;print_cr(&quot;Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered&quot;,
2245             method_array[i].name, method_array[i].signature);
2246         env-&gt;UnregisterNatives(wbclass);
2247         break;
2248       }
2249     }
2250   }
2251 }
2252 
2253 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
2254   // can&#39;t be in VM when we call JNI
2255   ThreadToNativeFromVM ttnfv(thread);
2256   const char* dir = env-&gt;GetStringUTFChars(compDirect, NULL);
2257   CHECK_JNI_EXCEPTION_(env, 0);
2258   int ret;
2259   {
2260     ThreadInVMfromNative ttvfn(thread); // back to VM
2261     ret = DirectivesParser::parse_string(dir, tty);
2262   }
2263   env-&gt;ReleaseStringUTFChars(compDirect, dir);
2264   // -1 for error parsing directive. Return 0 as number of directives added.
2265   if (ret == -1) {
2266     ret = 0;
2267   }
2268   return (jint) ret;
2269 WB_END
2270 
2271 WB_ENTRY(void, WB_RemoveCompilerDirective(JNIEnv* env, jobject o, jint count))
2272   DirectivesStack::pop(count);
2273 WB_END
2274 
2275 // Checks that the library libfile has the noexecstack bit set.
2276 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2277   jboolean ret = false;
2278 #ifdef LINUX
2279   // Can&#39;t be in VM when we call JNI.
2280   ThreadToNativeFromVM ttnfv(thread);
2281   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2282   CHECK_JNI_EXCEPTION_(env, 0);
2283   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2284   env-&gt;ReleaseStringUTFChars(libfile, lf);
2285 #endif
2286   return ret;
2287 WB_END
2288 
2289 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2290   LINUX_ONLY(return OSContainer::is_containerized();)
2291   return false;
2292 WB_END
2293 
2294 WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,
2295                                     jobject o,
2296                                     jstring proc_cgroups,
2297                                     jstring proc_self_cgroup,
2298                                     jstring proc_self_mountinfo))
2299   jint ret = 0;
2300 #ifdef LINUX
2301   ThreadToNativeFromVM ttnfv(thread);
2302   const char* p_cgroups = env-&gt;GetStringUTFChars(proc_cgroups, NULL);
2303   CHECK_JNI_EXCEPTION_(env, 0);
2304   const char* p_s_cgroup = env-&gt;GetStringUTFChars(proc_self_cgroup, NULL);
2305   CHECK_JNI_EXCEPTION_(env, 0);
2306   const char* p_s_mountinfo = env-&gt;GetStringUTFChars(proc_self_mountinfo, NULL);
2307   CHECK_JNI_EXCEPTION_(env, 0);
2308   u1 cg_type_flags = 0;
2309   // This sets cg_type_flags
2310   WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &amp;cg_type_flags);
2311   ret = (jint)cg_type_flags;
2312   env-&gt;ReleaseStringUTFChars(proc_cgroups, p_cgroups);
2313   env-&gt;ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);
2314   env-&gt;ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);
2315 #endif
2316   return ret;
2317 WB_END
2318 
2319 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2320   os::print_os_info(tty);
2321 WB_END
2322 
2323 // Elf decoder
2324 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2325 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2326   ElfFile::_do_not_cache_elf_section = true;
2327 #endif
2328 WB_END
2329 
2330 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2331   return (jlong) ResolvedMethodTable::items_count();
2332 WB_END
2333 
2334 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2335   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2336 WB_END
2337 
2338 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
2339   jint result = 0;
2340 #if INCLUDE_AOT
2341   result = (jint) AOTLoader::heaps_count();
2342 #endif
2343   return result;
2344 WB_END
2345 
2346 WB_ENTRY(jint, WB_GetKlassMetadataSize(JNIEnv* env, jobject wb, jclass mirror))
2347   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2348   // Return size in bytes.
2349   return k-&gt;size() * wordSize;
2350 WB_END
2351 
2352 #define CC (char*)
2353 
2354 static JNINativeMethod methods[] = {
2355   {CC&quot;getObjectAddress0&quot;,                CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectAddress  },
2356   {CC&quot;getObjectSize0&quot;,                   CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectSize     },
2357   {CC&quot;isObjectInOldGen0&quot;,                CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_isObjectInOldGen  },
2358   {CC&quot;getHeapOopSize&quot;,                   CC&quot;()I&quot;,                   (void*)&amp;WB_GetHeapOopSize    },
2359   {CC&quot;getVMPageSize&quot;,                    CC&quot;()I&quot;,                   (void*)&amp;WB_GetVMPageSize     },
2360   {CC&quot;getVMAllocationGranularity&quot;,       CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMAllocationGranularity },
2361   {CC&quot;getVMLargePageSize&quot;,               CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMLargePageSize},
2362   {CC&quot;getHeapSpaceAlignment&quot;,            CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapSpaceAlignment},
2363   {CC&quot;getHeapAlignment&quot;,                 CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapAlignment},
2364   {CC&quot;countAliveClasses0&quot;,               CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_CountAliveClasses },
2365   {CC&quot;getSymbolRefcount&quot;,                CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_GetSymbolRefcount },
2366   {CC&quot;parseCommandLine0&quot;,
2367       CC&quot;(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;&quot;,
2368       (void*) &amp;WB_ParseCommandLine
2369   },
2370   {CC&quot;addToBootstrapClassLoaderSearch0&quot;, CC&quot;(Ljava/lang/String;)V&quot;,
2371                                                       (void*)&amp;WB_AddToBootstrapClassLoaderSearch},
2372   {CC&quot;addToSystemClassLoaderSearch0&quot;,    CC&quot;(Ljava/lang/String;)V&quot;,
2373                                                       (void*)&amp;WB_AddToSystemClassLoaderSearch},
2374   {CC&quot;getCompressedOopsMaxHeapSize&quot;, CC&quot;()J&quot;,
2375       (void*)&amp;WB_GetCompressedOopsMaxHeapSize},
2376   {CC&quot;printHeapSizes&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_PrintHeapSizes    },
2377   {CC&quot;runMemoryUnitTests&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_RunMemoryUnitTests},
2378   {CC&quot;readFromNoaccessArea&quot;,CC&quot;()V&quot;,                  (void*)&amp;WB_ReadFromNoaccessArea},
2379   {CC&quot;stressVirtualSpaceResize&quot;,CC&quot;(JJJ)I&quot;,           (void*)&amp;WB_StressVirtualSpaceResize},
2380 #if INCLUDE_CDS
2381   {CC&quot;getOffsetForName0&quot;, CC&quot;(Ljava/lang/String;)I&quot;,  (void*)&amp;WB_GetOffsetForName},
2382 #endif
2383 #if INCLUDE_G1GC
2384   {CC&quot;g1InConcurrentMark&quot;, CC&quot;()Z&quot;,                   (void*)&amp;WB_G1InConcurrentMark},
2385   {CC&quot;g1IsHumongous0&quot;,      CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_G1IsHumongous     },
2386   {CC&quot;g1BelongsToHumongousRegion0&quot;, CC&quot;(J)Z&quot;,         (void*)&amp;WB_G1BelongsToHumongousRegion},
2387   {CC&quot;g1BelongsToFreeRegion0&quot;, CC&quot;(J)Z&quot;,              (void*)&amp;WB_G1BelongsToFreeRegion},
2388   {CC&quot;g1NumMaxRegions&quot;,    CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumMaxRegions  },
2389   {CC&quot;g1NumFreeRegions&quot;,   CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumFreeRegions  },
2390   {CC&quot;g1RegionSize&quot;,       CC&quot;()I&quot;,                   (void*)&amp;WB_G1RegionSize      },
2391   {CC&quot;g1StartConcMarkCycle&quot;,       CC&quot;()Z&quot;,           (void*)&amp;WB_G1StartMarkCycle  },
2392   {CC&quot;g1AuxiliaryMemoryUsage&quot;, CC&quot;()Ljava/lang/management/MemoryUsage;&quot;,
2393                                                       (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
2394   {CC&quot;g1ActiveMemoryNodeCount&quot;, CC&quot;()I&quot;,              (void*)&amp;WB_G1ActiveMemoryNodeCount },
2395   {CC&quot;g1MemoryNodeIds&quot;,    CC&quot;()[I&quot;,                  (void*)&amp;WB_G1MemoryNodeIds },
2396   {CC&quot;g1GetMixedGCInfo&quot;,   CC&quot;(I)[J&quot;,                 (void*)&amp;WB_G1GetMixedGCInfo },
2397 #endif // INCLUDE_G1GC
2398 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
2399   {CC&quot;dramReservedStart&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedStart },
2400   {CC&quot;dramReservedEnd&quot;,     CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedEnd },
2401   {CC&quot;nvdimmReservedStart&quot;, CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedStart },
2402   {CC&quot;nvdimmReservedEnd&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedEnd },
2403 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
2404 #if INCLUDE_PARALLELGC
2405   {CC&quot;psVirtualSpaceAlignment&quot;,CC&quot;()J&quot;,               (void*)&amp;WB_PSVirtualSpaceAlignment},
2406   {CC&quot;psHeapGenerationAlignment&quot;,CC&quot;()J&quot;,             (void*)&amp;WB_PSHeapGenerationAlignment},
2407 #endif
2408 #if INCLUDE_NMT
2409   {CC&quot;NMTMalloc&quot;,           CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTMalloc          },
2410   {CC&quot;NMTMallocWithPseudoStack&quot;, CC&quot;(JI)J&quot;,           (void*)&amp;WB_NMTMallocWithPseudoStack},
2411   {CC&quot;NMTMallocWithPseudoStackAndType&quot;, CC&quot;(JII)J&quot;,   (void*)&amp;WB_NMTMallocWithPseudoStackAndType},
2412   {CC&quot;NMTFree&quot;,             CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFree            },
2413   {CC&quot;NMTReserveMemory&quot;,    CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTReserveMemory   },
2414   {CC&quot;NMTAttemptReserveMemoryAt&quot;,    CC&quot;(JJ)J&quot;,       (void*)&amp;WB_NMTAttemptReserveMemoryAt },
2415   {CC&quot;NMTCommitMemory&quot;,     CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTCommitMemory    },
2416   {CC&quot;NMTUncommitMemory&quot;,   CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTUncommitMemory  },
2417   {CC&quot;NMTReleaseMemory&quot;,    CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTReleaseMemory   },
2418   {CC&quot;NMTChangeTrackingLevel&quot;, CC&quot;()Z&quot;,               (void*)&amp;WB_NMTChangeTrackingLevel},
2419   {CC&quot;NMTGetHashSize&quot;,      CC&quot;()I&quot;,                  (void*)&amp;WB_NMTGetHashSize     },
2420   {CC&quot;NMTNewArena&quot;,         CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTNewArena        },
2421   {CC&quot;NMTFreeArena&quot;,        CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFreeArena       },
2422   {CC&quot;NMTArenaMalloc&quot;,      CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTArenaMalloc     },
2423 #endif // INCLUDE_NMT
2424   {CC&quot;deoptimizeFrames&quot;,   CC&quot;(Z)I&quot;,                  (void*)&amp;WB_DeoptimizeFrames  },
2425   {CC&quot;deoptimizeAll&quot;,      CC&quot;()V&quot;,                   (void*)&amp;WB_DeoptimizeAll     },
2426   {CC&quot;deoptimizeMethod0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,
2427                                                       (void*)&amp;WB_DeoptimizeMethod  },
2428   {CC&quot;isMethodCompiled0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,
2429                                                       (void*)&amp;WB_IsMethodCompiled  },
2430   {CC&quot;isMethodCompilable0&quot;, CC&quot;(Ljava/lang/reflect/Executable;IZ)Z&quot;,
2431                                                       (void*)&amp;WB_IsMethodCompilable},
2432   {CC&quot;isMethodQueuedForCompilation0&quot;,
2433       CC&quot;(Ljava/lang/reflect/Executable;)Z&quot;,          (void*)&amp;WB_IsMethodQueuedForCompilation},
2434   {CC&quot;isIntrinsicAvailable0&quot;,
2435       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/reflect/Executable;I)Z&quot;,
2436                                                       (void*)&amp;WB_IsIntrinsicAvailable},
2437   {CC&quot;makeMethodNotCompilable0&quot;,
2438       CC&quot;(Ljava/lang/reflect/Executable;IZ)V&quot;,        (void*)&amp;WB_MakeMethodNotCompilable},
2439   {CC&quot;testSetDontInlineMethod0&quot;,
2440       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetDontInlineMethod},
2441   {CC&quot;getMethodCompilationLevel0&quot;,
2442       CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,         (void*)&amp;WB_GetMethodCompilationLevel},
2443   {CC&quot;getMethodEntryBci0&quot;,
2444       CC&quot;(Ljava/lang/reflect/Executable;)I&quot;,          (void*)&amp;WB_GetMethodEntryBci},
2445   {CC&quot;getCompileQueueSize&quot;,
2446       CC&quot;(I)I&quot;,                                       (void*)&amp;WB_GetCompileQueueSize},
2447   {CC&quot;testSetForceInlineMethod0&quot;,
2448       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetForceInlineMethod},
2449   {CC&quot;enqueueMethodForCompilation0&quot;,
2450       CC&quot;(Ljava/lang/reflect/Executable;II)Z&quot;,        (void*)&amp;WB_EnqueueMethodForCompilation},
2451   {CC&quot;enqueueInitializerForCompilation0&quot;,
2452       CC&quot;(Ljava/lang/Class;I)Z&quot;,                      (void*)&amp;WB_EnqueueInitializerForCompilation},
2453   {CC&quot;markMethodProfiled&quot;,
2454       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_MarkMethodProfiled},
2455   {CC&quot;clearMethodState0&quot;,
2456       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_ClearMethodState},
2457   {CC&quot;lockCompilation&quot;,    CC&quot;()V&quot;,                   (void*)&amp;WB_LockCompilation},
2458   {CC&quot;unlockCompilation&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_UnlockCompilation},
2459   {CC&quot;matchesMethod&quot;,
2460       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2461                                                       (void*)&amp;WB_MatchesMethod},
2462   {CC&quot;matchesInline&quot;,
2463       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2464                                                       (void*)&amp;WB_MatchesInline},
2465   {CC&quot;shouldPrintAssembly&quot;,
2466         CC&quot;(Ljava/lang/reflect/Executable;I)Z&quot;,
2467                                                         (void*)&amp;WB_ShouldPrintAssembly},
2468 
2469   {CC&quot;isConstantVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsConstantVMFlag},
2470   {CC&quot;isLockedVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsLockedVMFlag},
2471   {CC&quot;setBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;Z)V&quot;,(void*)&amp;WB_SetBooleanVMFlag},
2472   {CC&quot;setIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntVMFlag},
2473   {CC&quot;setUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintVMFlag},
2474   {CC&quot;setIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntxVMFlag},
2475   {CC&quot;setUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintxVMFlag},
2476   {CC&quot;setUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUint64VMFlag},
2477   {CC&quot;setSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetSizeTVMFlag},
2478   {CC&quot;setDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;D)V&quot;,(void*)&amp;WB_SetDoubleVMFlag},
2479   {CC&quot;setStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;,
2480                                                       (void*)&amp;WB_SetStringVMFlag},
2481   {CC&quot;getBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2482                                                       (void*)&amp;WB_GetBooleanVMFlag},
2483   {CC&quot;getIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2484                                                       (void*)&amp;WB_GetIntVMFlag},
2485   {CC&quot;getUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2486                                                       (void*)&amp;WB_GetUintVMFlag},
2487   {CC&quot;getIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2488                                                       (void*)&amp;WB_GetIntxVMFlag},
2489   {CC&quot;getUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2490                                                       (void*)&amp;WB_GetUintxVMFlag},
2491   {CC&quot;getUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2492                                                       (void*)&amp;WB_GetUint64VMFlag},
2493   {CC&quot;getSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2494                                                       (void*)&amp;WB_GetSizeTVMFlag},
2495   {CC&quot;getDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Double;&quot;,
2496                                                       (void*)&amp;WB_GetDoubleVMFlag},
2497   {CC&quot;getStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;,
2498                                                       (void*)&amp;WB_GetStringVMFlag},
2499   {CC&quot;isInStringTable&quot;,    CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsInStringTable  },
2500   {CC&quot;fullGC&quot;,   CC&quot;()V&quot;,                             (void*)&amp;WB_FullGC },
2501   {CC&quot;youngGC&quot;,  CC&quot;()V&quot;,                             (void*)&amp;WB_YoungGC },
2502   {CC&quot;readReservedMemory&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_ReadReservedMemory },
2503   {CC&quot;allocateMetaspace&quot;,
2504      CC&quot;(Ljava/lang/ClassLoader;J)J&quot;,                 (void*)&amp;WB_AllocateMetaspace },
2505   {CC&quot;freeMetaspace&quot;,
2506      CC&quot;(Ljava/lang/ClassLoader;JJ)V&quot;,                (void*)&amp;WB_FreeMetaspace },
2507   {CC&quot;incMetaspaceCapacityUntilGC&quot;, CC&quot;(J)J&quot;,         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
2508   {CC&quot;metaspaceCapacityUntilGC&quot;, CC&quot;()J&quot;,             (void*)&amp;WB_MetaspaceCapacityUntilGC },
2509   {CC&quot;metaspaceReserveAlignment&quot;, CC&quot;()J&quot;,            (void*)&amp;WB_MetaspaceReserveAlignment },
2510   {CC&quot;getCPUFeatures&quot;,     CC&quot;()Ljava/lang/String;&quot;,  (void*)&amp;WB_GetCPUFeatures     },
2511   {CC&quot;getNMethod0&quot;,         CC&quot;(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;&quot;,
2512                                                       (void*)&amp;WB_GetNMethod         },
2513   {CC&quot;forceNMethodSweep&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_ForceNMethodSweep  },
2514   {CC&quot;allocateCodeBlob&quot;,   CC&quot;(II)J&quot;,                 (void*)&amp;WB_AllocateCodeBlob   },
2515   {CC&quot;freeCodeBlob&quot;,       CC&quot;(J)V&quot;,                  (void*)&amp;WB_FreeCodeBlob       },
2516   {CC&quot;getCodeHeapEntries&quot;, CC&quot;(I)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeHeapEntries },
2517   {CC&quot;getCompilationActivityMode&quot;,
2518                            CC&quot;()I&quot;,                   (void*)&amp;WB_GetCompilationActivityMode},
2519   {CC&quot;getMethodData0&quot;,     CC&quot;(Ljava/lang/reflect/Executable;)J&quot;,
2520                                                       (void*)&amp;WB_GetMethodData      },
2521   {CC&quot;getCodeBlob&quot;,        CC&quot;(J)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeBlob        },
2522   {CC&quot;getThreadStackSize&quot;, CC&quot;()J&quot;,                   (void*)&amp;WB_GetThreadStackSize },
2523   {CC&quot;getThreadRemainingStackSize&quot;, CC&quot;()J&quot;,          (void*)&amp;WB_GetThreadRemainingStackSize },
2524   {CC&quot;DefineModule&quot;,       CC&quot;(Ljava/lang/Object;ZLjava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V&quot;,
2525                                                       (void*)&amp;WB_DefineModule },
2526   {CC&quot;AddModuleExports&quot;,   CC&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,
2527                                                       (void*)&amp;WB_AddModuleExports },
2528   {CC&quot;AddReadsModule&quot;,     CC&quot;(Ljava/lang/Object;Ljava/lang/Object;)V&quot;,
2529                                                       (void*)&amp;WB_AddReadsModule },
2530   {CC&quot;AddModuleExportsToAllUnnamed&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2531                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2532   {CC&quot;AddModuleExportsToAll&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2533                                                       (void*)&amp;WB_AddModuleExportsToAll },
2534   {CC&quot;assertMatchingSafepointCalls&quot;, CC&quot;(ZZ)V&quot;,       (void*)&amp;WB_AssertMatchingSafepointCalls },
2535   {CC&quot;assertSpecialLock&quot;,  CC&quot;(ZZ)V&quot;,                 (void*)&amp;WB_AssertSpecialLock },
2536   {CC&quot;isMonitorInflated0&quot;, CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsMonitorInflated  },
2537   {CC&quot;forceSafepoint&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_ForceSafepoint     },
2538   {CC&quot;getConstantPool0&quot;,   CC&quot;(Ljava/lang/Class;)J&quot;,  (void*)&amp;WB_GetConstantPool    },
2539   {CC&quot;getConstantPoolCacheIndexTag0&quot;, CC&quot;()I&quot;,  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2540   {CC&quot;getConstantPoolCacheLength0&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,  (void*)&amp;WB_GetConstantPoolCacheLength},
2541   {CC&quot;remapInstructionOperandFromCPCache0&quot;,
2542       CC&quot;(Ljava/lang/Class;I)I&quot;,                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2543   {CC&quot;encodeConstantPoolIndyIndex0&quot;,
2544       CC&quot;(I)I&quot;,                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
2545   {CC&quot;getObjectsViaKlassOopMaps0&quot;,
2546       CC&quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;,    (void*)&amp;WB_getObjectsViaKlassOopMaps},
2547   {CC&quot;getObjectsViaOopIterator0&quot;,
2548           CC&quot;(Ljava/lang/Object;)[Ljava/lang/Object;&quot;,(void*)&amp;WB_getObjectsViaOopIterator},
2549   {CC&quot;getObjectsViaFrameOopIterator&quot;,
2550       CC&quot;(I)[Ljava/lang/Object;&quot;,                     (void*)&amp;WB_getObjectsViaFrameOopIterator},
2551   {CC&quot;getMethodBooleanOption&quot;,
2552       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2553                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2554   {CC&quot;getMethodIntxOption&quot;,
2555       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2556                                                       (void*)&amp;WB_GetMethodIntxOption},
2557   {CC&quot;getMethodUintxOption&quot;,
2558       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2559                                                       (void*)&amp;WB_GetMethodUintxOption},
2560   {CC&quot;getMethodDoubleOption&quot;,
2561       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;&quot;,
2562                                                       (void*)&amp;WB_GetMethodDoubleOption},
2563   {CC&quot;getMethodStringOption&quot;,
2564       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;&quot;,
2565                                                       (void*)&amp;WB_GetMethodStringOption},
2566   {CC&quot;getDefaultArchivePath&quot;,             CC&quot;()Ljava/lang/String;&quot;,
2567                                                       (void*)&amp;WB_GetDefaultArchivePath},
2568   {CC&quot;isSharingEnabled&quot;,   CC&quot;()Z&quot;,                   (void*)&amp;WB_IsSharingEnabled},
2569   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2570   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2571   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2572   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
2573   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},
2574   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2575   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2576   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2577   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2578   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2579   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },
2580 
2581   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2582   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2583   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2584                                                       (void*)&amp;WB_AddCompilerDirective },
2585   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2586   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2587   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2588   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
2589   {CC&quot;supportsConcurrentGCBreakpoints&quot;, CC&quot;()Z&quot;,      (void*)&amp;WB_SupportsConcurrentGCBreakpoints},
2590   {CC&quot;concurrentGCAcquireControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCAcquireControl},
2591   {CC&quot;concurrentGCReleaseControl0&quot;, CC&quot;()V&quot;,          (void*)&amp;WB_ConcurrentGCReleaseControl},
2592   {CC&quot;concurrentGCRunToIdle0&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_ConcurrentGCRunToIdle},
2593   {CC&quot;concurrentGCRunTo0&quot;,        CC&quot;(Ljava/lang/String;)Z&quot;,
2594                                                       (void*)&amp;WB_ConcurrentGCRunTo},
2595   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2596                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2597   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },
2598   {CC&quot;validateCgroup&quot;,
2599       CC&quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I&quot;,
2600                                                       (void*)&amp;WB_ValidateCgroup },
2601   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2602   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
2603   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },
2604   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2605   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
2606   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},
2607 };
2608 
2609 
2610 #undef CC
2611 
2612 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2613   {
2614     if (WhiteBoxAPI) {
2615       // Make sure that wbclass is loaded by the null classloader
2616       InstanceKlass* ik = InstanceKlass::cast(JNIHandles::resolve(wbclass)-&gt;klass());
2617       Handle loader(THREAD, ik-&gt;class_loader());
2618       if (loader.is_null()) {
2619         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2620         WhiteBox::set_used();
2621       }
2622     }
2623   }
2624 JVM_END
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/prims/methodHandles.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="jvmtiRedefineClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="unsafe.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/methodHandles.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/codeCache.hpp&quot;
  30 #include &quot;code/dependencyContext.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/oopMapCache.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;


  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/oopFactory.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/objArrayOop.inline.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  43 #include &quot;prims/methodHandles.hpp&quot;
  44 #include &quot;runtime/deoptimization.hpp&quot;
  45 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  46 #include &quot;runtime/handles.inline.hpp&quot;
  47 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  48 #include &quot;runtime/javaCalls.hpp&quot;
  49 #include &quot;runtime/jniHandles.inline.hpp&quot;
  50 #include &quot;runtime/timerTrace.hpp&quot;
  51 #include &quot;runtime/reflection.hpp&quot;
  52 #include &quot;runtime/safepointVerifiers.hpp&quot;
  53 #include &quot;runtime/signature.hpp&quot;
  54 #include &quot;runtime/stubRoutines.hpp&quot;
</pre>
<hr />
<pre>
 211     int slot   = java_lang_reflect_Constructor::slot(target_oop);
 212     Klass* k = java_lang_Class::as_Klass(clazz);
 213     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 214       Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
 215       if (m == NULL)  return NULL;
 216       CallInfo info(m, k, CHECK_NULL);
 217       return init_method_MemberName(mname, info);
 218     }
 219   }
 220   return NULL;
 221 }
 222 
 223 oop MethodHandles::init_method_MemberName(Handle mname, CallInfo&amp; info) {
 224   assert(info.resolved_appendix().is_null(), &quot;only normal methods here&quot;);
 225   methodHandle m(Thread::current(), info.resolved_method());
 226   assert(m.not_null(), &quot;null method handle&quot;);
 227   InstanceKlass* m_klass = m-&gt;method_holder();
 228   assert(m_klass != NULL, &quot;null holder for method handle&quot;);
 229   int flags = (jushort)( m-&gt;access_flags().as_short() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS );
 230   int vmindex = Method::invalid_vtable_index;

 231 
 232   switch (info.call_kind()) {
 233   case CallInfo::itable_call:
 234     vmindex = info.itable_index();
 235     // More importantly, the itable index only works with the method holder.
 236     assert(m_klass-&gt;verify_itable_index(vmindex), &quot;&quot;);
 237     flags |= IS_METHOD | (JVM_REF_invokeInterface &lt;&lt; REFERENCE_KIND_SHIFT);
<span class="line-modified"> 238     if (TraceInvokeDynamic) {</span>
<span class="line-removed"> 239       ttyLocker ttyl;</span>
 240       ResourceMark rm;
<span class="line-modified"> 241       tty-&gt;print_cr(&quot;memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:&quot;,</span>
<span class="line-modified"> 242             Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),</span>
<span class="line-modified"> 243             vmindex);</span>
<span class="line-modified"> 244        m-&gt;access_flags().print_on(tty);</span>

 245        if (!m-&gt;is_abstract()) {
 246          if (!m-&gt;is_private()) {
<span class="line-modified"> 247            tty-&gt;print(&quot;default&quot;);</span>
 248          }
 249          else {
<span class="line-modified"> 250            tty-&gt;print(&quot;private-intf&quot;);</span>
 251          }
 252        }
<span class="line-modified"> 253        tty-&gt;cr();</span>
 254     }
 255     break;
 256 
 257   case CallInfo::vtable_call:
 258     vmindex = info.vtable_index();
 259     flags |= IS_METHOD | (JVM_REF_invokeVirtual &lt;&lt; REFERENCE_KIND_SHIFT);
 260     assert(info.resolved_klass()-&gt;is_subtype_of(m_klass), &quot;virtual call must be type-safe&quot;);
 261     if (m_klass-&gt;is_interface()) {
 262       // This is a vtable call to an interface method (abstract &quot;miranda method&quot; or default method).
 263       // The vtable index is meaningless without a class (not interface) receiver type, so get one.
 264       // (LinkResolver should help us figure this out.)
 265       assert(info.resolved_klass()-&gt;is_instance_klass(), &quot;subtype of interface must be an instance klass&quot;);
 266       InstanceKlass* m_klass_non_interface = InstanceKlass::cast(info.resolved_klass());
 267       if (m_klass_non_interface-&gt;is_interface()) {
 268         m_klass_non_interface = SystemDictionary::Object_klass();
 269 #ifdef ASSERT
 270         { ResourceMark rm;
 271           Method* m2 = m_klass_non_interface-&gt;vtable().method_at(vmindex);
 272           assert(m-&gt;name() == m2-&gt;name() &amp;&amp; m-&gt;signature() == m2-&gt;signature(),
 273                  &quot;at %d, %s != %s&quot;, vmindex,
 274                  m-&gt;name_and_sig_as_C_string(), m2-&gt;name_and_sig_as_C_string());
 275         }
 276 #endif //ASSERT
 277       }
 278       if (!m-&gt;is_public()) {
 279         assert(m-&gt;is_public(), &quot;virtual call must be to public interface method&quot;);
 280         return NULL;  // elicit an error later in product build
 281       }
 282       assert(info.resolved_klass()-&gt;is_subtype_of(m_klass_non_interface), &quot;virtual call must be type-safe&quot;);
 283       m_klass = m_klass_non_interface;
 284     }
<span class="line-modified"> 285     if (TraceInvokeDynamic) {</span>
<span class="line-removed"> 286       ttyLocker ttyl;</span>
 287       ResourceMark rm;
<span class="line-modified"> 288       tty-&gt;print_cr(&quot;memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:&quot;,</span>
<span class="line-modified"> 289             Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),</span>
<span class="line-modified"> 290             m_klass-&gt;internal_name(), vmindex);</span>
<span class="line-modified"> 291        m-&gt;access_flags().print_on(tty);</span>

 292        if (m-&gt;is_default_method()) {
<span class="line-modified"> 293          tty-&gt;print(&quot;default&quot;);</span>
 294        }
<span class="line-modified"> 295        tty-&gt;cr();</span>
 296     }
 297     break;
 298 
 299   case CallInfo::direct_call:
 300     vmindex = Method::nonvirtual_vtable_index;
 301     if (m-&gt;is_static()) {
 302       flags |= IS_METHOD      | (JVM_REF_invokeStatic  &lt;&lt; REFERENCE_KIND_SHIFT);
 303     } else if (m-&gt;is_object_constructor()) {
 304       flags |= IS_OBJECT_CONSTRUCTOR | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 305     } else {
 306       // &quot;special&quot; reflects that this is a direct call, not that it
 307       // necessarily originates from an invokespecial. We can also do
 308       // direct calls for private and/or final non-static methods.
 309       flags |= IS_METHOD      | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 310     }
 311     break;
 312 
 313   default:  assert(false, &quot;bad CallInfo&quot;);  return NULL;
 314   }
 315 
</pre>
<hr />
<pre>
1061 void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {
1062   assert_lock_strong(Compile_lock);
1063 
1064   int marked = 0;
1065   CallSiteDepChange changes(call_site, target);
1066   {
1067     NoSafepointVerifier nsv;
1068     MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1069 
1070     oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
1071     DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1072     marked = deps.mark_dependent_nmethods(changes);
1073   }
1074   if (marked &gt; 0) {
1075     // At least one nmethod has been marked for deoptimization.
1076     Deoptimization::deoptimize_all_marked();
1077   }
1078 }
1079 
1080 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
<span class="line-modified">1081   if (TraceMethodHandles) {</span>
1082     const char* name = vmIntrinsics::name_at(iid);
1083     if (*name == &#39;_&#39;)  name += 1;
1084     const size_t len = strlen(name) + 50;
1085     char* qname = NEW_C_HEAP_ARRAY(char, len, mtInternal);
1086     const char* suffix = &quot;&quot;;
1087     if (is_signature_polymorphic(iid)) {
1088       if (is_signature_polymorphic_static(iid))
1089         suffix = &quot;/static&quot;;
1090       else
1091         suffix = &quot;/private&quot;;
1092     }
1093     jio_snprintf(qname, len, &quot;MethodHandle::interpreter_entry::%s%s&quot;, name, suffix);
1094     trace_method_handle(_masm, qname);
1095     // Note:  Don&#39;t free the allocated char array because it&#39;s used
1096     // during runtime.
1097   }
1098 }
1099 
1100 //
1101 // Here are the native methods in java.lang.invoke.MethodHandleNatives
1102 // They are the private interface between this JVM and the HotSpot-specific
1103 // Java code that implements JSR 292 method handles.
1104 //
1105 // Note:  We use a JVM_ENTRY macro to define each of these, for this is the way
1106 // that intrinsic (non-JNI) native methods are defined in HotSpot.
1107 //
1108 
1109 #ifndef PRODUCT
1110 #define EACH_NAMED_CON(template, requirement) \
1111     template(java_lang_invoke_MemberName,MN_IS_METHOD) \
1112     template(java_lang_invoke_MemberName,MN_IS_OBJECT_CONSTRUCTOR) \
1113     template(java_lang_invoke_MemberName,MN_IS_FIELD) \
1114     template(java_lang_invoke_MemberName,MN_IS_TYPE) \
1115     template(java_lang_invoke_MemberName,MN_CALLER_SENSITIVE) \
1116     template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \
1117     template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \
1118     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_SHIFT) \
1119     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_MASK) \




1120     /*end*/
1121 
1122 #define IGNORE_REQ(req_expr) /* req_expr */
1123 #define ONE_PLUS(scope,value) 1+
1124 static const int con_value_count = EACH_NAMED_CON(ONE_PLUS, IGNORE_REQ) 0;
1125 #define VALUE_COMMA(scope,value) scope::value,
1126 static const int con_values[con_value_count+1] = { EACH_NAMED_CON(VALUE_COMMA, IGNORE_REQ) 0 };
1127 #define STRING_NULL(scope,value) #value &quot;\0&quot;
1128 static const char con_names[] = { EACH_NAMED_CON(STRING_NULL, IGNORE_REQ) };
1129 
1130 static bool advertise_con_value(int which) {
1131   if (which &lt; 0)  return false;
1132   bool ok = true;
1133   int count = 0;
1134 #define INC_COUNT(scope,value) \
1135   ++count;
1136 #define CHECK_REQ(req_expr) \
1137   if (which &lt; count)  return ok; \
1138   ok = (req_expr);
1139   EACH_NAMED_CON(INC_COUNT, CHECK_REQ);
</pre>
<hr />
<pre>
1516 #define CC (char*)  /*cast a literal from (const char*)*/
1517 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
1518 
1519 // These are the native methods on java.lang.invoke.MethodHandleNatives.
1520 static JNINativeMethod MHN_methods[] = {
1521   {CC &quot;init&quot;,                      CC &quot;(&quot; MEM &quot;&quot; OBJ &quot;)V&quot;,                   FN_PTR(MHN_init_Mem)},
1522   {CC &quot;expand&quot;,                    CC &quot;(&quot; MEM &quot;)V&quot;,                          FN_PTR(MHN_expand_Mem)},
1523   {CC &quot;resolve&quot;,                   CC &quot;(&quot; MEM &quot;&quot; CLS &quot;Z)&quot; MEM,               FN_PTR(MHN_resolve_Mem)},
1524   //  static native int getNamedCon(int which, Object[] name)
1525   {CC &quot;getNamedCon&quot;,               CC &quot;(I[&quot; OBJ &quot;)I&quot;,                        FN_PTR(MHN_getNamedCon)},
1526   //  static native int getMembers(Class&lt;?&gt; defc, String matchName, String matchSig,
1527   //          int matchFlags, Class&lt;?&gt; caller, int skip, MemberName[] results);
1528   {CC &quot;getMembers&quot;,                CC &quot;(&quot; CLS &quot;&quot; STRG &quot;&quot; STRG &quot;I&quot; CLS &quot;I[&quot; MEM &quot;)I&quot;, FN_PTR(MHN_getMembers)},
1529   {CC &quot;objectFieldOffset&quot;,         CC &quot;(&quot; MEM &quot;)J&quot;,                          FN_PTR(MHN_objectFieldOffset)},
1530   {CC &quot;setCallSiteTargetNormal&quot;,   CC &quot;(&quot; CS &quot;&quot; MH &quot;)V&quot;,                     FN_PTR(MHN_setCallSiteTargetNormal)},
1531   {CC &quot;setCallSiteTargetVolatile&quot;, CC &quot;(&quot; CS &quot;&quot; MH &quot;)V&quot;,                     FN_PTR(MHN_setCallSiteTargetVolatile)},
1532   {CC &quot;copyOutBootstrapArguments&quot;, CC &quot;(&quot; CLS &quot;[III[&quot; OBJ &quot;IZ&quot; OBJ &quot;)V&quot;,     FN_PTR(MHN_copyOutBootstrapArguments)},
1533   {CC &quot;clearCallSiteContext&quot;,      CC &quot;(&quot; CTX &quot;)V&quot;,                          FN_PTR(MHN_clearCallSiteContext)},
1534   {CC &quot;staticFieldOffset&quot;,         CC &quot;(&quot; MEM &quot;)J&quot;,                          FN_PTR(MHN_staticFieldOffset)},
1535   {CC &quot;staticFieldBase&quot;,           CC &quot;(&quot; MEM &quot;)&quot; OBJ,                        FN_PTR(MHN_staticFieldBase)},
<span class="line-modified">1536   {CC &quot;getMemberVMInfo&quot;,           CC &quot;(&quot; MEM &quot;)&quot; OBJ,                        FN_PTR(MHN_getMemberVMInfo)}</span>
1537 };
1538 
1539 static JNINativeMethod MH_methods[] = {
1540   // UnsupportedOperationException throwers
1541   {CC &quot;invoke&quot;,                    CC &quot;([&quot; OBJ &quot;)&quot; OBJ,                       FN_PTR(MH_invoke_UOE)},
1542   {CC &quot;invokeExact&quot;,               CC &quot;([&quot; OBJ &quot;)&quot; OBJ,                       FN_PTR(MH_invokeExact_UOE)}
1543 };
1544 
1545 /**
1546  * This one function is exported, used by NativeLookup.
1547  */
1548 JVM_ENTRY(void, JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass MHN_class)) {
1549   assert(!MethodHandles::enabled(), &quot;must not be enabled&quot;);
1550   assert(SystemDictionary::MethodHandle_klass() != NULL, &quot;should be present&quot;);
1551 
1552   oop mirror = SystemDictionary::MethodHandle_klass()-&gt;java_mirror();
1553   jclass MH_class = (jclass) JNIHandles::make_local(env, mirror);
1554 
1555   {
1556     ThreadToNativeFromVM ttnfv(thread);
1557 
1558     int status = env-&gt;RegisterNatives(MHN_class, MHN_methods, sizeof(MHN_methods)/sizeof(JNINativeMethod));
1559     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1560               &quot;register java.lang.invoke.MethodHandleNative natives&quot;);
1561 
1562     status = env-&gt;RegisterNatives(MH_class, MH_methods, sizeof(MH_methods)/sizeof(JNINativeMethod));
1563     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1564               &quot;register java.lang.invoke.MethodHandle natives&quot;);
1565   }
1566 
<span class="line-modified">1567   if (TraceInvokeDynamic) {</span>
<span class="line-removed">1568     tty-&gt;print_cr(&quot;MethodHandle support loaded (using LambdaForms)&quot;);</span>
<span class="line-removed">1569   }</span>
1570 
1571   MethodHandles::set_enabled(true);
1572 }
1573 JVM_END
</pre>
</td>
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/javaClasses.inline.hpp&quot;
  27 #include &quot;classfile/stringTable.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;code/codeCache.hpp&quot;
  30 #include &quot;code/dependencyContext.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;interpreter/interpreter.hpp&quot;
  33 #include &quot;interpreter/oopMapCache.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
<span class="line-added">  35 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added">  36 #include &quot;logging/logStream.hpp&quot;</span>
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/oopFactory.hpp&quot;
  39 #include &quot;memory/resourceArea.hpp&quot;
  40 #include &quot;memory/universe.hpp&quot;
  41 #include &quot;oops/objArrayKlass.hpp&quot;
  42 #include &quot;oops/objArrayOop.inline.hpp&quot;
  43 #include &quot;oops/oop.inline.hpp&quot;
  44 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  45 #include &quot;prims/methodHandles.hpp&quot;
  46 #include &quot;runtime/deoptimization.hpp&quot;
  47 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;
  49 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  50 #include &quot;runtime/javaCalls.hpp&quot;
  51 #include &quot;runtime/jniHandles.inline.hpp&quot;
  52 #include &quot;runtime/timerTrace.hpp&quot;
  53 #include &quot;runtime/reflection.hpp&quot;
  54 #include &quot;runtime/safepointVerifiers.hpp&quot;
  55 #include &quot;runtime/signature.hpp&quot;
  56 #include &quot;runtime/stubRoutines.hpp&quot;
</pre>
<hr />
<pre>
 213     int slot   = java_lang_reflect_Constructor::slot(target_oop);
 214     Klass* k = java_lang_Class::as_Klass(clazz);
 215     if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
 216       Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
 217       if (m == NULL)  return NULL;
 218       CallInfo info(m, k, CHECK_NULL);
 219       return init_method_MemberName(mname, info);
 220     }
 221   }
 222   return NULL;
 223 }
 224 
 225 oop MethodHandles::init_method_MemberName(Handle mname, CallInfo&amp; info) {
 226   assert(info.resolved_appendix().is_null(), &quot;only normal methods here&quot;);
 227   methodHandle m(Thread::current(), info.resolved_method());
 228   assert(m.not_null(), &quot;null method handle&quot;);
 229   InstanceKlass* m_klass = m-&gt;method_holder();
 230   assert(m_klass != NULL, &quot;null holder for method handle&quot;);
 231   int flags = (jushort)( m-&gt;access_flags().as_short() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS );
 232   int vmindex = Method::invalid_vtable_index;
<span class="line-added"> 233   LogTarget(Debug, methodhandles, indy) lt_indy;</span>
 234 
 235   switch (info.call_kind()) {
 236   case CallInfo::itable_call:
 237     vmindex = info.itable_index();
 238     // More importantly, the itable index only works with the method holder.
 239     assert(m_klass-&gt;verify_itable_index(vmindex), &quot;&quot;);
 240     flags |= IS_METHOD | (JVM_REF_invokeInterface &lt;&lt; REFERENCE_KIND_SHIFT);
<span class="line-modified"> 241     if (lt_indy.is_enabled()) {</span>

 242       ResourceMark rm;
<span class="line-modified"> 243       LogStream ls(lt_indy);</span>
<span class="line-modified"> 244       ls.print_cr(&quot;memberName: invokeinterface method_holder::method: %s, itableindex: %d, access_flags:&quot;,</span>
<span class="line-modified"> 245                   Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),</span>
<span class="line-modified"> 246                   vmindex);</span>
<span class="line-added"> 247        m-&gt;access_flags().print_on(&amp;ls);</span>
 248        if (!m-&gt;is_abstract()) {
 249          if (!m-&gt;is_private()) {
<span class="line-modified"> 250            ls.print(&quot;default&quot;);</span>
 251          }
 252          else {
<span class="line-modified"> 253            ls.print(&quot;private-intf&quot;);</span>
 254          }
 255        }
<span class="line-modified"> 256        ls.cr();</span>
 257     }
 258     break;
 259 
 260   case CallInfo::vtable_call:
 261     vmindex = info.vtable_index();
 262     flags |= IS_METHOD | (JVM_REF_invokeVirtual &lt;&lt; REFERENCE_KIND_SHIFT);
 263     assert(info.resolved_klass()-&gt;is_subtype_of(m_klass), &quot;virtual call must be type-safe&quot;);
 264     if (m_klass-&gt;is_interface()) {
 265       // This is a vtable call to an interface method (abstract &quot;miranda method&quot; or default method).
 266       // The vtable index is meaningless without a class (not interface) receiver type, so get one.
 267       // (LinkResolver should help us figure this out.)
 268       assert(info.resolved_klass()-&gt;is_instance_klass(), &quot;subtype of interface must be an instance klass&quot;);
 269       InstanceKlass* m_klass_non_interface = InstanceKlass::cast(info.resolved_klass());
 270       if (m_klass_non_interface-&gt;is_interface()) {
 271         m_klass_non_interface = SystemDictionary::Object_klass();
 272 #ifdef ASSERT
 273         { ResourceMark rm;
 274           Method* m2 = m_klass_non_interface-&gt;vtable().method_at(vmindex);
 275           assert(m-&gt;name() == m2-&gt;name() &amp;&amp; m-&gt;signature() == m2-&gt;signature(),
 276                  &quot;at %d, %s != %s&quot;, vmindex,
 277                  m-&gt;name_and_sig_as_C_string(), m2-&gt;name_and_sig_as_C_string());
 278         }
 279 #endif //ASSERT
 280       }
 281       if (!m-&gt;is_public()) {
 282         assert(m-&gt;is_public(), &quot;virtual call must be to public interface method&quot;);
 283         return NULL;  // elicit an error later in product build
 284       }
 285       assert(info.resolved_klass()-&gt;is_subtype_of(m_klass_non_interface), &quot;virtual call must be type-safe&quot;);
 286       m_klass = m_klass_non_interface;
 287     }
<span class="line-modified"> 288     if (lt_indy.is_enabled()) {</span>

 289       ResourceMark rm;
<span class="line-modified"> 290       LogStream ls(lt_indy);</span>
<span class="line-modified"> 291       ls.print_cr(&quot;memberName: invokevirtual method_holder::method: %s, receiver: %s, vtableindex: %d, access_flags:&quot;,</span>
<span class="line-modified"> 292                   Method::name_and_sig_as_C_string(m-&gt;method_holder(), m-&gt;name(), m-&gt;signature()),</span>
<span class="line-modified"> 293                   m_klass-&gt;internal_name(), vmindex);</span>
<span class="line-added"> 294        m-&gt;access_flags().print_on(&amp;ls);</span>
 295        if (m-&gt;is_default_method()) {
<span class="line-modified"> 296          ls.print(&quot;default&quot;);</span>
 297        }
<span class="line-modified"> 298        ls.cr();</span>
 299     }
 300     break;
 301 
 302   case CallInfo::direct_call:
 303     vmindex = Method::nonvirtual_vtable_index;
 304     if (m-&gt;is_static()) {
 305       flags |= IS_METHOD      | (JVM_REF_invokeStatic  &lt;&lt; REFERENCE_KIND_SHIFT);
 306     } else if (m-&gt;is_object_constructor()) {
 307       flags |= IS_OBJECT_CONSTRUCTOR | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 308     } else {
 309       // &quot;special&quot; reflects that this is a direct call, not that it
 310       // necessarily originates from an invokespecial. We can also do
 311       // direct calls for private and/or final non-static methods.
 312       flags |= IS_METHOD      | (JVM_REF_invokeSpecial &lt;&lt; REFERENCE_KIND_SHIFT);
 313     }
 314     break;
 315 
 316   default:  assert(false, &quot;bad CallInfo&quot;);  return NULL;
 317   }
 318 
</pre>
<hr />
<pre>
1064 void MethodHandles::flush_dependent_nmethods(Handle call_site, Handle target) {
1065   assert_lock_strong(Compile_lock);
1066 
1067   int marked = 0;
1068   CallSiteDepChange changes(call_site, target);
1069   {
1070     NoSafepointVerifier nsv;
1071     MutexLocker mu2(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1072 
1073     oop context = java_lang_invoke_CallSite::context_no_keepalive(call_site());
1074     DependencyContext deps = java_lang_invoke_MethodHandleNatives_CallSiteContext::vmdependencies(context);
1075     marked = deps.mark_dependent_nmethods(changes);
1076   }
1077   if (marked &gt; 0) {
1078     // At least one nmethod has been marked for deoptimization.
1079     Deoptimization::deoptimize_all_marked();
1080   }
1081 }
1082 
1083 void MethodHandles::trace_method_handle_interpreter_entry(MacroAssembler* _masm, vmIntrinsics::ID iid) {
<span class="line-modified">1084   if (log_is_enabled(Info, methodhandles)) {</span>
1085     const char* name = vmIntrinsics::name_at(iid);
1086     if (*name == &#39;_&#39;)  name += 1;
1087     const size_t len = strlen(name) + 50;
1088     char* qname = NEW_C_HEAP_ARRAY(char, len, mtInternal);
1089     const char* suffix = &quot;&quot;;
1090     if (is_signature_polymorphic(iid)) {
1091       if (is_signature_polymorphic_static(iid))
1092         suffix = &quot;/static&quot;;
1093       else
1094         suffix = &quot;/private&quot;;
1095     }
1096     jio_snprintf(qname, len, &quot;MethodHandle::interpreter_entry::%s%s&quot;, name, suffix);
1097     trace_method_handle(_masm, qname);
1098     // Note:  Don&#39;t free the allocated char array because it&#39;s used
1099     // during runtime.
1100   }
1101 }
1102 
1103 //
1104 // Here are the native methods in java.lang.invoke.MethodHandleNatives
1105 // They are the private interface between this JVM and the HotSpot-specific
1106 // Java code that implements JSR 292 method handles.
1107 //
1108 // Note:  We use a JVM_ENTRY macro to define each of these, for this is the way
1109 // that intrinsic (non-JNI) native methods are defined in HotSpot.
1110 //
1111 
1112 #ifndef PRODUCT
1113 #define EACH_NAMED_CON(template, requirement) \
1114     template(java_lang_invoke_MemberName,MN_IS_METHOD) \
1115     template(java_lang_invoke_MemberName,MN_IS_OBJECT_CONSTRUCTOR) \
1116     template(java_lang_invoke_MemberName,MN_IS_FIELD) \
1117     template(java_lang_invoke_MemberName,MN_IS_TYPE) \
1118     template(java_lang_invoke_MemberName,MN_CALLER_SENSITIVE) \
1119     template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \
1120     template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \
1121     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_SHIFT) \
1122     template(java_lang_invoke_MemberName,MN_REFERENCE_KIND_MASK) \
<span class="line-added">1123     template(java_lang_invoke_MemberName,MN_NESTMATE_CLASS) \</span>
<span class="line-added">1124     template(java_lang_invoke_MemberName,MN_HIDDEN_CLASS) \</span>
<span class="line-added">1125     template(java_lang_invoke_MemberName,MN_STRONG_LOADER_LINK) \</span>
<span class="line-added">1126     template(java_lang_invoke_MemberName,MN_ACCESS_VM_ANNOTATIONS) \</span>
1127     /*end*/
1128 
1129 #define IGNORE_REQ(req_expr) /* req_expr */
1130 #define ONE_PLUS(scope,value) 1+
1131 static const int con_value_count = EACH_NAMED_CON(ONE_PLUS, IGNORE_REQ) 0;
1132 #define VALUE_COMMA(scope,value) scope::value,
1133 static const int con_values[con_value_count+1] = { EACH_NAMED_CON(VALUE_COMMA, IGNORE_REQ) 0 };
1134 #define STRING_NULL(scope,value) #value &quot;\0&quot;
1135 static const char con_names[] = { EACH_NAMED_CON(STRING_NULL, IGNORE_REQ) };
1136 
1137 static bool advertise_con_value(int which) {
1138   if (which &lt; 0)  return false;
1139   bool ok = true;
1140   int count = 0;
1141 #define INC_COUNT(scope,value) \
1142   ++count;
1143 #define CHECK_REQ(req_expr) \
1144   if (which &lt; count)  return ok; \
1145   ok = (req_expr);
1146   EACH_NAMED_CON(INC_COUNT, CHECK_REQ);
</pre>
<hr />
<pre>
1523 #define CC (char*)  /*cast a literal from (const char*)*/
1524 #define FN_PTR(f) CAST_FROM_FN_PTR(void*, &amp;f)
1525 
1526 // These are the native methods on java.lang.invoke.MethodHandleNatives.
1527 static JNINativeMethod MHN_methods[] = {
1528   {CC &quot;init&quot;,                      CC &quot;(&quot; MEM &quot;&quot; OBJ &quot;)V&quot;,                   FN_PTR(MHN_init_Mem)},
1529   {CC &quot;expand&quot;,                    CC &quot;(&quot; MEM &quot;)V&quot;,                          FN_PTR(MHN_expand_Mem)},
1530   {CC &quot;resolve&quot;,                   CC &quot;(&quot; MEM &quot;&quot; CLS &quot;Z)&quot; MEM,               FN_PTR(MHN_resolve_Mem)},
1531   //  static native int getNamedCon(int which, Object[] name)
1532   {CC &quot;getNamedCon&quot;,               CC &quot;(I[&quot; OBJ &quot;)I&quot;,                        FN_PTR(MHN_getNamedCon)},
1533   //  static native int getMembers(Class&lt;?&gt; defc, String matchName, String matchSig,
1534   //          int matchFlags, Class&lt;?&gt; caller, int skip, MemberName[] results);
1535   {CC &quot;getMembers&quot;,                CC &quot;(&quot; CLS &quot;&quot; STRG &quot;&quot; STRG &quot;I&quot; CLS &quot;I[&quot; MEM &quot;)I&quot;, FN_PTR(MHN_getMembers)},
1536   {CC &quot;objectFieldOffset&quot;,         CC &quot;(&quot; MEM &quot;)J&quot;,                          FN_PTR(MHN_objectFieldOffset)},
1537   {CC &quot;setCallSiteTargetNormal&quot;,   CC &quot;(&quot; CS &quot;&quot; MH &quot;)V&quot;,                     FN_PTR(MHN_setCallSiteTargetNormal)},
1538   {CC &quot;setCallSiteTargetVolatile&quot;, CC &quot;(&quot; CS &quot;&quot; MH &quot;)V&quot;,                     FN_PTR(MHN_setCallSiteTargetVolatile)},
1539   {CC &quot;copyOutBootstrapArguments&quot;, CC &quot;(&quot; CLS &quot;[III[&quot; OBJ &quot;IZ&quot; OBJ &quot;)V&quot;,     FN_PTR(MHN_copyOutBootstrapArguments)},
1540   {CC &quot;clearCallSiteContext&quot;,      CC &quot;(&quot; CTX &quot;)V&quot;,                          FN_PTR(MHN_clearCallSiteContext)},
1541   {CC &quot;staticFieldOffset&quot;,         CC &quot;(&quot; MEM &quot;)J&quot;,                          FN_PTR(MHN_staticFieldOffset)},
1542   {CC &quot;staticFieldBase&quot;,           CC &quot;(&quot; MEM &quot;)&quot; OBJ,                        FN_PTR(MHN_staticFieldBase)},
<span class="line-modified">1543   {CC &quot;getMemberVMInfo&quot;,           CC &quot;(&quot; MEM &quot;)&quot; OBJ,                       FN_PTR(MHN_getMemberVMInfo)}</span>
1544 };
1545 
1546 static JNINativeMethod MH_methods[] = {
1547   // UnsupportedOperationException throwers
1548   {CC &quot;invoke&quot;,                    CC &quot;([&quot; OBJ &quot;)&quot; OBJ,                       FN_PTR(MH_invoke_UOE)},
1549   {CC &quot;invokeExact&quot;,               CC &quot;([&quot; OBJ &quot;)&quot; OBJ,                       FN_PTR(MH_invokeExact_UOE)}
1550 };
1551 
1552 /**
1553  * This one function is exported, used by NativeLookup.
1554  */
1555 JVM_ENTRY(void, JVM_RegisterMethodHandleMethods(JNIEnv *env, jclass MHN_class)) {
1556   assert(!MethodHandles::enabled(), &quot;must not be enabled&quot;);
1557   assert(SystemDictionary::MethodHandle_klass() != NULL, &quot;should be present&quot;);
1558 
1559   oop mirror = SystemDictionary::MethodHandle_klass()-&gt;java_mirror();
1560   jclass MH_class = (jclass) JNIHandles::make_local(env, mirror);
1561 
1562   {
1563     ThreadToNativeFromVM ttnfv(thread);
1564 
1565     int status = env-&gt;RegisterNatives(MHN_class, MHN_methods, sizeof(MHN_methods)/sizeof(JNINativeMethod));
1566     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1567               &quot;register java.lang.invoke.MethodHandleNative natives&quot;);
1568 
1569     status = env-&gt;RegisterNatives(MH_class, MH_methods, sizeof(MH_methods)/sizeof(JNINativeMethod));
1570     guarantee(status == JNI_OK &amp;&amp; !env-&gt;ExceptionOccurred(),
1571               &quot;register java.lang.invoke.MethodHandle natives&quot;);
1572   }
1573 
<span class="line-modified">1574   log_debug(methodhandles, indy)(&quot;MethodHandle support loaded (using LambdaForms)&quot;);</span>


1575 
1576   MethodHandles::set_enabled(true);
1577 }
1578 JVM_END
</pre>
</td>
</tr>
</table>
<center><a href="jvmtiRedefineClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="unsafe.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/sharedRuntime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/stringTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;classfile/vmSymbols.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/compiledIC.hpp&quot;
  33 #include &quot;code/icBuffer.hpp&quot;
  34 #include &quot;code/compiledMethod.inline.hpp&quot;
  35 #include &quot;code/scopeDesc.hpp&quot;
  36 #include &quot;code/vtableStubs.hpp&quot;
  37 #include &quot;compiler/abstractCompiler.hpp&quot;
  38 #include &quot;compiler/compileBroker.hpp&quot;
  39 #include &quot;compiler/disassembler.hpp&quot;
  40 #include &quot;gc/shared/barrierSet.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.inline.hpp&quot;
  42 #include &quot;interpreter/interpreter.hpp&quot;
  43 #include &quot;interpreter/interpreterRuntime.hpp&quot;
  44 #include &quot;jfr/jfrEvents.hpp&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;memory/metaspaceShared.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/access.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/klass.hpp&quot;
  53 #include &quot;oops/method.inline.hpp&quot;
  54 #include &quot;oops/objArrayKlass.hpp&quot;
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;
  57 #include &quot;oops/valueKlass.inline.hpp&quot;
  58 #include &quot;prims/forte.hpp&quot;
  59 #include &quot;prims/jvmtiExport.hpp&quot;
  60 #include &quot;prims/methodHandles.hpp&quot;
  61 #include &quot;prims/nativeLookup.hpp&quot;
  62 #include &quot;runtime/arguments.hpp&quot;
  63 #include &quot;runtime/atomic.hpp&quot;
  64 #include &quot;runtime/biasedLocking.hpp&quot;
  65 #include &quot;runtime/frame.inline.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/init.hpp&quot;
  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  69 #include &quot;runtime/java.hpp&quot;
  70 #include &quot;runtime/javaCalls.hpp&quot;
  71 #include &quot;runtime/sharedRuntime.hpp&quot;
  72 #include &quot;runtime/stubRoutines.hpp&quot;
  73 #include &quot;runtime/vframe.inline.hpp&quot;
  74 #include &quot;runtime/vframeArray.hpp&quot;
  75 #include &quot;utilities/copy.hpp&quot;
  76 #include &quot;utilities/dtrace.hpp&quot;
  77 #include &quot;utilities/events.hpp&quot;
  78 #include &quot;utilities/hashtable.inline.hpp&quot;
  79 #include &quot;utilities/macros.hpp&quot;
  80 #include &quot;utilities/xmlstream.hpp&quot;
  81 #ifdef COMPILER1
  82 #include &quot;c1/c1_Runtime1.hpp&quot;
  83 #endif
  84 
  85 // Shared stub locations
  86 RuntimeStub*        SharedRuntime::_wrong_method_blob;
  87 RuntimeStub*        SharedRuntime::_wrong_method_abstract_blob;
  88 RuntimeStub*        SharedRuntime::_ic_miss_blob;
  89 RuntimeStub*        SharedRuntime::_resolve_opt_virtual_call_blob;
  90 RuntimeStub*        SharedRuntime::_resolve_virtual_call_blob;
  91 RuntimeStub*        SharedRuntime::_resolve_static_call_blob;
  92 
  93 DeoptimizationBlob* SharedRuntime::_deopt_blob;
  94 SafepointBlob*      SharedRuntime::_polling_page_vectors_safepoint_handler_blob;
  95 SafepointBlob*      SharedRuntime::_polling_page_safepoint_handler_blob;
  96 SafepointBlob*      SharedRuntime::_polling_page_return_handler_blob;
  97 
  98 #ifdef COMPILER2
  99 UncommonTrapBlob*   SharedRuntime::_uncommon_trap_blob;
 100 #endif // COMPILER2
 101 
 102 
 103 //----------------------------generate_stubs-----------------------------------
 104 void SharedRuntime::generate_stubs() {
 105   _wrong_method_blob                   = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method),          &quot;wrong_method_stub&quot;);
 106   _wrong_method_abstract_blob          = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_abstract), &quot;wrong_method_abstract_stub&quot;);
 107   _ic_miss_blob                        = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::handle_wrong_method_ic_miss),  &quot;ic_miss_stub&quot;);
 108   _resolve_opt_virtual_call_blob       = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_opt_virtual_call_C),   &quot;resolve_opt_virtual_call&quot;);
 109   _resolve_virtual_call_blob           = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_virtual_call_C),       &quot;resolve_virtual_call&quot;);
 110   _resolve_static_call_blob            = generate_resolve_blob(CAST_FROM_FN_PTR(address, SharedRuntime::resolve_static_call_C),        &quot;resolve_static_call&quot;);
 111 
 112 #if COMPILER2_OR_JVMCI
 113   // Vectors are generated only by C2 and JVMCI.
 114   bool support_wide = is_wide_vector(MaxVectorSize);
 115   if (support_wide) {
 116     _polling_page_vectors_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_VECTOR_LOOP);
 117   }
 118 #endif // COMPILER2_OR_JVMCI
 119   _polling_page_safepoint_handler_blob = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_LOOP);
 120   _polling_page_return_handler_blob    = generate_handler_blob(CAST_FROM_FN_PTR(address, SafepointSynchronize::handle_polling_page_exception), POLL_AT_RETURN);
 121 
 122   generate_deopt_blob();
 123 
 124 #ifdef COMPILER2
 125   generate_uncommon_trap_blob();
 126 #endif // COMPILER2
 127 }
 128 
 129 #include &lt;math.h&gt;
 130 
 131 // Implementation of SharedRuntime
 132 
 133 #ifndef PRODUCT
 134 // For statistics
 135 int SharedRuntime::_ic_miss_ctr = 0;
 136 int SharedRuntime::_wrong_method_ctr = 0;
 137 int SharedRuntime::_resolve_static_ctr = 0;
 138 int SharedRuntime::_resolve_virtual_ctr = 0;
 139 int SharedRuntime::_resolve_opt_virtual_ctr = 0;
 140 int SharedRuntime::_implicit_null_throws = 0;
 141 int SharedRuntime::_implicit_div0_throws = 0;
 142 int SharedRuntime::_throw_null_ctr = 0;
 143 
 144 int SharedRuntime::_nof_normal_calls = 0;
 145 int SharedRuntime::_nof_optimized_calls = 0;
 146 int SharedRuntime::_nof_inlined_calls = 0;
 147 int SharedRuntime::_nof_megamorphic_calls = 0;
 148 int SharedRuntime::_nof_static_calls = 0;
 149 int SharedRuntime::_nof_inlined_static_calls = 0;
 150 int SharedRuntime::_nof_interface_calls = 0;
 151 int SharedRuntime::_nof_optimized_interface_calls = 0;
 152 int SharedRuntime::_nof_inlined_interface_calls = 0;
 153 int SharedRuntime::_nof_megamorphic_interface_calls = 0;
 154 int SharedRuntime::_nof_removable_exceptions = 0;
 155 
 156 int SharedRuntime::_new_instance_ctr=0;
 157 int SharedRuntime::_new_array_ctr=0;
 158 int SharedRuntime::_multi1_ctr=0;
 159 int SharedRuntime::_multi2_ctr=0;
 160 int SharedRuntime::_multi3_ctr=0;
 161 int SharedRuntime::_multi4_ctr=0;
 162 int SharedRuntime::_multi5_ctr=0;
 163 int SharedRuntime::_mon_enter_stub_ctr=0;
 164 int SharedRuntime::_mon_exit_stub_ctr=0;
 165 int SharedRuntime::_mon_enter_ctr=0;
 166 int SharedRuntime::_mon_exit_ctr=0;
 167 int SharedRuntime::_partial_subtype_ctr=0;
 168 int SharedRuntime::_jbyte_array_copy_ctr=0;
 169 int SharedRuntime::_jshort_array_copy_ctr=0;
 170 int SharedRuntime::_jint_array_copy_ctr=0;
 171 int SharedRuntime::_jlong_array_copy_ctr=0;
 172 int SharedRuntime::_oop_array_copy_ctr=0;
 173 int SharedRuntime::_checkcast_array_copy_ctr=0;
 174 int SharedRuntime::_unsafe_array_copy_ctr=0;
 175 int SharedRuntime::_generic_array_copy_ctr=0;
 176 int SharedRuntime::_slow_array_copy_ctr=0;
 177 int SharedRuntime::_find_handler_ctr=0;
 178 int SharedRuntime::_rethrow_ctr=0;
 179 
 180 int     SharedRuntime::_ICmiss_index                    = 0;
 181 int     SharedRuntime::_ICmiss_count[SharedRuntime::maxICmiss_count];
 182 address SharedRuntime::_ICmiss_at[SharedRuntime::maxICmiss_count];
 183 
 184 
 185 void SharedRuntime::trace_ic_miss(address at) {
 186   for (int i = 0; i &lt; _ICmiss_index; i++) {
 187     if (_ICmiss_at[i] == at) {
 188       _ICmiss_count[i]++;
 189       return;
 190     }
 191   }
 192   int index = _ICmiss_index++;
 193   if (_ICmiss_index &gt;= maxICmiss_count) _ICmiss_index = maxICmiss_count - 1;
 194   _ICmiss_at[index] = at;
 195   _ICmiss_count[index] = 1;
 196 }
 197 
 198 void SharedRuntime::print_ic_miss_histogram() {
 199   if (ICMissHistogram) {
 200     tty-&gt;print_cr(&quot;IC Miss Histogram:&quot;);
 201     int tot_misses = 0;
 202     for (int i = 0; i &lt; _ICmiss_index; i++) {
 203       tty-&gt;print_cr(&quot;  at: &quot; INTPTR_FORMAT &quot;  nof: %d&quot;, p2i(_ICmiss_at[i]), _ICmiss_count[i]);
 204       tot_misses += _ICmiss_count[i];
 205     }
 206     tty-&gt;print_cr(&quot;Total IC misses: %7d&quot;, tot_misses);
 207   }
 208 }
 209 #endif // PRODUCT
 210 
 211 
 212 JRT_LEAF(jlong, SharedRuntime::lmul(jlong y, jlong x))
 213   return x * y;
 214 JRT_END
 215 
 216 
 217 JRT_LEAF(jlong, SharedRuntime::ldiv(jlong y, jlong x))
 218   if (x == min_jlong &amp;&amp; y == CONST64(-1)) {
 219     return x;
 220   } else {
 221     return x / y;
 222   }
 223 JRT_END
 224 
 225 
 226 JRT_LEAF(jlong, SharedRuntime::lrem(jlong y, jlong x))
 227   if (x == min_jlong &amp;&amp; y == CONST64(-1)) {
 228     return 0;
 229   } else {
 230     return x % y;
 231   }
 232 JRT_END
 233 
 234 
 235 const juint  float_sign_mask  = 0x7FFFFFFF;
 236 const juint  float_infinity   = 0x7F800000;
 237 const julong double_sign_mask = CONST64(0x7FFFFFFFFFFFFFFF);
 238 const julong double_infinity  = CONST64(0x7FF0000000000000);
 239 
 240 JRT_LEAF(jfloat, SharedRuntime::frem(jfloat  x, jfloat  y))
 241 #ifdef _WIN64
 242   // 64-bit Windows on amd64 returns the wrong values for
 243   // infinity operands.
 244   union { jfloat f; juint i; } xbits, ybits;
 245   xbits.f = x;
 246   ybits.f = y;
 247   // x Mod Infinity == x unless x is infinity
 248   if (((xbits.i &amp; float_sign_mask) != float_infinity) &amp;&amp;
 249        ((ybits.i &amp; float_sign_mask) == float_infinity) ) {
 250     return x;
 251   }
 252   return ((jfloat)fmod_winx64((double)x, (double)y));
 253 #else
 254   return ((jfloat)fmod((double)x,(double)y));
 255 #endif
 256 JRT_END
 257 
 258 
 259 JRT_LEAF(jdouble, SharedRuntime::drem(jdouble x, jdouble y))
 260 #ifdef _WIN64
 261   union { jdouble d; julong l; } xbits, ybits;
 262   xbits.d = x;
 263   ybits.d = y;
 264   // x Mod Infinity == x unless x is infinity
 265   if (((xbits.l &amp; double_sign_mask) != double_infinity) &amp;&amp;
 266        ((ybits.l &amp; double_sign_mask) == double_infinity) ) {
 267     return x;
 268   }
 269   return ((jdouble)fmod_winx64((double)x, (double)y));
 270 #else
 271   return ((jdouble)fmod((double)x,(double)y));
 272 #endif
 273 JRT_END
 274 
 275 #ifdef __SOFTFP__
 276 JRT_LEAF(jfloat, SharedRuntime::fadd(jfloat x, jfloat y))
 277   return x + y;
 278 JRT_END
 279 
 280 JRT_LEAF(jfloat, SharedRuntime::fsub(jfloat x, jfloat y))
 281   return x - y;
 282 JRT_END
 283 
 284 JRT_LEAF(jfloat, SharedRuntime::fmul(jfloat x, jfloat y))
 285   return x * y;
 286 JRT_END
 287 
 288 JRT_LEAF(jfloat, SharedRuntime::fdiv(jfloat x, jfloat y))
 289   return x / y;
 290 JRT_END
 291 
 292 JRT_LEAF(jdouble, SharedRuntime::dadd(jdouble x, jdouble y))
 293   return x + y;
 294 JRT_END
 295 
 296 JRT_LEAF(jdouble, SharedRuntime::dsub(jdouble x, jdouble y))
 297   return x - y;
 298 JRT_END
 299 
 300 JRT_LEAF(jdouble, SharedRuntime::dmul(jdouble x, jdouble y))
 301   return x * y;
 302 JRT_END
 303 
 304 JRT_LEAF(jdouble, SharedRuntime::ddiv(jdouble x, jdouble y))
 305   return x / y;
 306 JRT_END
 307 
 308 JRT_LEAF(jfloat, SharedRuntime::i2f(jint x))
 309   return (jfloat)x;
 310 JRT_END
 311 
 312 JRT_LEAF(jdouble, SharedRuntime::i2d(jint x))
 313   return (jdouble)x;
 314 JRT_END
 315 
 316 JRT_LEAF(jdouble, SharedRuntime::f2d(jfloat x))
 317   return (jdouble)x;
 318 JRT_END
 319 
 320 JRT_LEAF(int,  SharedRuntime::fcmpl(float x, float y))
 321   return x&gt;y ? 1 : (x==y ? 0 : -1);  /* x&lt;y or is_nan*/
 322 JRT_END
 323 
 324 JRT_LEAF(int,  SharedRuntime::fcmpg(float x, float y))
 325   return x&lt;y ? -1 : (x==y ? 0 : 1);  /* x&gt;y or is_nan */
 326 JRT_END
 327 
 328 JRT_LEAF(int,  SharedRuntime::dcmpl(double x, double y))
 329   return x&gt;y ? 1 : (x==y ? 0 : -1); /* x&lt;y or is_nan */
 330 JRT_END
 331 
 332 JRT_LEAF(int,  SharedRuntime::dcmpg(double x, double y))
 333   return x&lt;y ? -1 : (x==y ? 0 : 1);  /* x&gt;y or is_nan */
 334 JRT_END
 335 
 336 // Functions to return the opposite of the aeabi functions for nan.
 337 JRT_LEAF(int, SharedRuntime::unordered_fcmplt(float x, float y))
 338   return (x &lt; y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 339 JRT_END
 340 
 341 JRT_LEAF(int, SharedRuntime::unordered_dcmplt(double x, double y))
 342   return (x &lt; y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 343 JRT_END
 344 
 345 JRT_LEAF(int, SharedRuntime::unordered_fcmple(float x, float y))
 346   return (x &lt;= y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 347 JRT_END
 348 
 349 JRT_LEAF(int, SharedRuntime::unordered_dcmple(double x, double y))
 350   return (x &lt;= y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 351 JRT_END
 352 
 353 JRT_LEAF(int, SharedRuntime::unordered_fcmpge(float x, float y))
 354   return (x &gt;= y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 355 JRT_END
 356 
 357 JRT_LEAF(int, SharedRuntime::unordered_dcmpge(double x, double y))
 358   return (x &gt;= y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 359 JRT_END
 360 
 361 JRT_LEAF(int, SharedRuntime::unordered_fcmpgt(float x, float y))
 362   return (x &gt; y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 363 JRT_END
 364 
 365 JRT_LEAF(int, SharedRuntime::unordered_dcmpgt(double x, double y))
 366   return (x &gt; y) ? 1 : ((g_isnan(x) || g_isnan(y)) ? 1 : 0);
 367 JRT_END
 368 
 369 // Intrinsics make gcc generate code for these.
 370 float  SharedRuntime::fneg(float f)   {
 371   return -f;
 372 }
 373 
 374 double SharedRuntime::dneg(double f)  {
 375   return -f;
 376 }
 377 
 378 #endif // __SOFTFP__
 379 
 380 #if defined(__SOFTFP__) || defined(E500V2)
 381 // Intrinsics make gcc generate code for these.
 382 double SharedRuntime::dabs(double f)  {
 383   return (f &lt;= (double)0.0) ? (double)0.0 - f : f;
 384 }
 385 
 386 #endif
 387 
 388 #if defined(__SOFTFP__) || defined(PPC)
 389 double SharedRuntime::dsqrt(double f) {
 390   return sqrt(f);
 391 }
 392 #endif
 393 
 394 JRT_LEAF(jint, SharedRuntime::f2i(jfloat  x))
 395   if (g_isnan(x))
 396     return 0;
 397   if (x &gt;= (jfloat) max_jint)
 398     return max_jint;
 399   if (x &lt;= (jfloat) min_jint)
 400     return min_jint;
 401   return (jint) x;
 402 JRT_END
 403 
 404 
 405 JRT_LEAF(jlong, SharedRuntime::f2l(jfloat  x))
 406   if (g_isnan(x))
 407     return 0;
 408   if (x &gt;= (jfloat) max_jlong)
 409     return max_jlong;
 410   if (x &lt;= (jfloat) min_jlong)
 411     return min_jlong;
 412   return (jlong) x;
 413 JRT_END
 414 
 415 
 416 JRT_LEAF(jint, SharedRuntime::d2i(jdouble x))
 417   if (g_isnan(x))
 418     return 0;
 419   if (x &gt;= (jdouble) max_jint)
 420     return max_jint;
 421   if (x &lt;= (jdouble) min_jint)
 422     return min_jint;
 423   return (jint) x;
 424 JRT_END
 425 
 426 
 427 JRT_LEAF(jlong, SharedRuntime::d2l(jdouble x))
 428   if (g_isnan(x))
 429     return 0;
 430   if (x &gt;= (jdouble) max_jlong)
 431     return max_jlong;
 432   if (x &lt;= (jdouble) min_jlong)
 433     return min_jlong;
 434   return (jlong) x;
 435 JRT_END
 436 
 437 
 438 JRT_LEAF(jfloat, SharedRuntime::d2f(jdouble x))
 439   return (jfloat)x;
 440 JRT_END
 441 
 442 
 443 JRT_LEAF(jfloat, SharedRuntime::l2f(jlong x))
 444   return (jfloat)x;
 445 JRT_END
 446 
 447 
 448 JRT_LEAF(jdouble, SharedRuntime::l2d(jlong x))
 449   return (jdouble)x;
 450 JRT_END
 451 
 452 // Exception handling across interpreter/compiler boundaries
 453 //
 454 // exception_handler_for_return_address(...) returns the continuation address.
 455 // The continuation address is the entry point of the exception handler of the
 456 // previous frame depending on the return address.
 457 
 458 address SharedRuntime::raw_exception_handler_for_return_address(JavaThread* thread, address return_address) {
 459   assert(frame::verify_return_pc(return_address), &quot;must be a return address: &quot; INTPTR_FORMAT, p2i(return_address));
 460   assert(thread-&gt;frames_to_pop_failed_realloc() == 0 || Interpreter::contains(return_address), &quot;missed frames to pop?&quot;);
 461 
 462   // Reset method handle flag.
 463   thread-&gt;set_is_method_handle_return(false);
 464 
 465 #if INCLUDE_JVMCI
 466   // JVMCI&#39;s ExceptionHandlerStub expects the thread local exception PC to be clear
 467   // and other exception handler continuations do not read it
 468   thread-&gt;set_exception_pc(NULL);
 469 #endif // INCLUDE_JVMCI
 470 
 471   // The fastest case first
 472   CodeBlob* blob = CodeCache::find_blob(return_address);
 473   CompiledMethod* nm = (blob != NULL) ? blob-&gt;as_compiled_method_or_null() : NULL;
 474   if (nm != NULL) {
 475     // Set flag if return address is a method handle call site.
 476     thread-&gt;set_is_method_handle_return(nm-&gt;is_method_handle_return(return_address));
 477     // native nmethods don&#39;t have exception handlers
 478     assert(!nm-&gt;is_native_method(), &quot;no exception handler&quot;);
 479     assert(nm-&gt;header_begin() != nm-&gt;exception_begin(), &quot;no exception handler&quot;);
 480     if (nm-&gt;is_deopt_pc(return_address)) {
 481       // If we come here because of a stack overflow, the stack may be
 482       // unguarded. Reguard the stack otherwise if we return to the
 483       // deopt blob and the stack bang causes a stack overflow we
 484       // crash.
 485       bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
 486       if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
 487       if (thread-&gt;reserved_stack_activation() != thread-&gt;stack_base()) {
 488         thread-&gt;set_reserved_stack_activation(thread-&gt;stack_base());
 489       }
 490       assert(guard_pages_enabled, &quot;stack banging in deopt blob may cause crash&quot;);
 491       return SharedRuntime::deopt_blob()-&gt;unpack_with_exception();
 492     } else {
 493       return nm-&gt;exception_begin();
 494     }
 495   }
 496 
 497   // Entry code
 498   if (StubRoutines::returns_to_call_stub(return_address)) {
 499     return StubRoutines::catch_exception_entry();
 500   }
 501   // Interpreted code
 502   if (Interpreter::contains(return_address)) {
 503     return Interpreter::rethrow_exception_entry();
 504   }
 505 
 506   guarantee(blob == NULL || !blob-&gt;is_runtime_stub(), &quot;caller should have skipped stub&quot;);
 507   guarantee(!VtableStubs::contains(return_address), &quot;NULL exceptions in vtables should have been handled already!&quot;);
 508 
 509 #ifndef PRODUCT
 510   { ResourceMark rm;
 511     tty-&gt;print_cr(&quot;No exception handler found for exception at &quot; INTPTR_FORMAT &quot; - potential problems:&quot;, p2i(return_address));
 512     tty-&gt;print_cr(&quot;a) exception happened in (new?) code stubs/buffers that is not handled here&quot;);
 513     tty-&gt;print_cr(&quot;b) other problem&quot;);
 514   }
 515 #endif // PRODUCT
 516 
 517   ShouldNotReachHere();
 518   return NULL;
 519 }
 520 
 521 
 522 JRT_LEAF(address, SharedRuntime::exception_handler_for_return_address(JavaThread* thread, address return_address))
 523   return raw_exception_handler_for_return_address(thread, return_address);
 524 JRT_END
 525 
 526 
 527 address SharedRuntime::get_poll_stub(address pc) {
 528   address stub;
 529   // Look up the code blob
 530   CodeBlob *cb = CodeCache::find_blob(pc);
 531 
 532   // Should be an nmethod
 533   guarantee(cb != NULL &amp;&amp; cb-&gt;is_compiled(), &quot;safepoint polling: pc must refer to an nmethod&quot;);
 534 
 535   // Look up the relocation information
 536   assert(((CompiledMethod*)cb)-&gt;is_at_poll_or_poll_return(pc),
 537     &quot;safepoint polling: type must be poll&quot;);
 538 
 539 #ifdef ASSERT
 540   if (!((NativeInstruction*)pc)-&gt;is_safepoint_poll()) {
 541     tty-&gt;print_cr(&quot;bad pc: &quot; PTR_FORMAT, p2i(pc));
 542     Disassembler::decode(cb);
 543     fatal(&quot;Only polling locations are used for safepoint&quot;);
 544   }
 545 #endif
 546 
 547   bool at_poll_return = ((CompiledMethod*)cb)-&gt;is_at_poll_return(pc);
 548   bool has_wide_vectors = ((CompiledMethod*)cb)-&gt;has_wide_vectors();
 549   if (at_poll_return) {
 550     assert(SharedRuntime::polling_page_return_handler_blob() != NULL,
 551            &quot;polling page return stub not created yet&quot;);
 552     stub = SharedRuntime::polling_page_return_handler_blob()-&gt;entry_point();
 553   } else if (has_wide_vectors) {
 554     assert(SharedRuntime::polling_page_vectors_safepoint_handler_blob() != NULL,
 555            &quot;polling page vectors safepoint stub not created yet&quot;);
 556     stub = SharedRuntime::polling_page_vectors_safepoint_handler_blob()-&gt;entry_point();
 557   } else {
 558     assert(SharedRuntime::polling_page_safepoint_handler_blob() != NULL,
 559            &quot;polling page safepoint stub not created yet&quot;);
 560     stub = SharedRuntime::polling_page_safepoint_handler_blob()-&gt;entry_point();
 561   }
 562   log_debug(safepoint)(&quot;... found polling page %s exception at pc = &quot;
 563                        INTPTR_FORMAT &quot;, stub =&quot; INTPTR_FORMAT,
 564                        at_poll_return ? &quot;return&quot; : &quot;loop&quot;,
 565                        (intptr_t)pc, (intptr_t)stub);
 566   return stub;
 567 }
 568 
 569 
 570 oop SharedRuntime::retrieve_receiver( Symbol* sig, frame caller ) {
 571   assert(caller.is_interpreted_frame(), &quot;&quot;);
 572   int args_size = ArgumentSizeComputer(sig).size() + 1;
 573   assert(args_size &lt;= caller.interpreter_frame_expression_stack_size(), &quot;receiver must be on interpreter stack&quot;);
 574   oop result = cast_to_oop(*caller.interpreter_frame_tos_at(args_size - 1));
 575   assert(Universe::heap()-&gt;is_in(result) &amp;&amp; oopDesc::is_oop(result), &quot;receiver must be an oop&quot;);
 576   return result;
 577 }
 578 
 579 
 580 void SharedRuntime::throw_and_post_jvmti_exception(JavaThread *thread, Handle h_exception) {
 581   if (JvmtiExport::can_post_on_exceptions()) {
 582     vframeStream vfst(thread, true);
 583     methodHandle method = methodHandle(thread, vfst.method());
 584     address bcp = method()-&gt;bcp_from(vfst.bci());
 585     JvmtiExport::post_exception_throw(thread, method(), bcp, h_exception());
 586   }
 587   Exceptions::_throw(thread, __FILE__, __LINE__, h_exception);
 588 }
 589 
 590 void SharedRuntime::throw_and_post_jvmti_exception(JavaThread *thread, Symbol* name, const char *message) {
 591   Handle h_exception = Exceptions::new_exception(thread, name, message);
 592   throw_and_post_jvmti_exception(thread, h_exception);
 593 }
 594 
 595 // The interpreter code to call this tracing function is only
 596 // called/generated when UL is on for redefine, class and has the right level
 597 // and tags. Since obsolete methods are never compiled, we don&#39;t have
 598 // to modify the compilers to generate calls to this function.
 599 //
 600 JRT_LEAF(int, SharedRuntime::rc_trace_method_entry(
 601     JavaThread* thread, Method* method))
 602   if (method-&gt;is_obsolete()) {
 603     // We are calling an obsolete method, but this is not necessarily
 604     // an error. Our method could have been redefined just after we
 605     // fetched the Method* from the constant pool.
 606     ResourceMark rm;
 607     log_trace(redefine, class, obsolete)(&quot;calling obsolete method &#39;%s&#39;&quot;, method-&gt;name_and_sig_as_C_string());
 608   }
 609   return 0;
 610 JRT_END
 611 
 612 // ret_pc points into caller; we are returning caller&#39;s exception handler
 613 // for given exception
 614 address SharedRuntime::compute_compiled_exc_handler(CompiledMethod* cm, address ret_pc, Handle&amp; exception,
 615                                                     bool force_unwind, bool top_frame_only, bool&amp; recursive_exception_occurred) {
 616   assert(cm != NULL, &quot;must exist&quot;);
 617   ResourceMark rm;
 618 
 619 #if INCLUDE_JVMCI
 620   if (cm-&gt;is_compiled_by_jvmci()) {
 621     // lookup exception handler for this pc
 622     int catch_pco = ret_pc - cm-&gt;code_begin();
 623     ExceptionHandlerTable table(cm);
 624     HandlerTableEntry *t = table.entry_for(catch_pco, -1, 0);
 625     if (t != NULL) {
 626       return cm-&gt;code_begin() + t-&gt;pco();
 627     } else {
 628       return Deoptimization::deoptimize_for_missing_exception_handler(cm);
 629     }
 630   }
 631 #endif // INCLUDE_JVMCI
 632 
 633   nmethod* nm = cm-&gt;as_nmethod();
 634   ScopeDesc* sd = nm-&gt;scope_desc_at(ret_pc);
 635   // determine handler bci, if any
 636   EXCEPTION_MARK;
 637 
 638   int handler_bci = -1;
 639   int scope_depth = 0;
 640   if (!force_unwind) {
 641     int bci = sd-&gt;bci();
 642     bool recursive_exception = false;
 643     do {
 644       bool skip_scope_increment = false;
 645       // exception handler lookup
 646       Klass* ek = exception-&gt;klass();
 647       methodHandle mh(THREAD, sd-&gt;method());
 648       handler_bci = Method::fast_exception_handler_bci_for(mh, ek, bci, THREAD);
 649       if (HAS_PENDING_EXCEPTION) {
 650         recursive_exception = true;
 651         // We threw an exception while trying to find the exception handler.
 652         // Transfer the new exception to the exception handle which will
 653         // be set into thread local storage, and do another lookup for an
 654         // exception handler for this exception, this time starting at the
 655         // BCI of the exception handler which caused the exception to be
 656         // thrown (bugs 4307310 and 4546590). Set &quot;exception&quot; reference
 657         // argument to ensure that the correct exception is thrown (4870175).
 658         recursive_exception_occurred = true;
 659         exception = Handle(THREAD, PENDING_EXCEPTION);
 660         CLEAR_PENDING_EXCEPTION;
 661         if (handler_bci &gt;= 0) {
 662           bci = handler_bci;
 663           handler_bci = -1;
 664           skip_scope_increment = true;
 665         }
 666       }
 667       else {
 668         recursive_exception = false;
 669       }
 670       if (!top_frame_only &amp;&amp; handler_bci &lt; 0 &amp;&amp; !skip_scope_increment) {
 671         sd = sd-&gt;sender();
 672         if (sd != NULL) {
 673           bci = sd-&gt;bci();
 674         }
 675         ++scope_depth;
 676       }
 677     } while (recursive_exception || (!top_frame_only &amp;&amp; handler_bci &lt; 0 &amp;&amp; sd != NULL));
 678   }
 679 
 680   // found handling method =&gt; lookup exception handler
 681   int catch_pco = ret_pc - nm-&gt;code_begin();
 682 
 683   ExceptionHandlerTable table(nm);
 684   HandlerTableEntry *t = table.entry_for(catch_pco, handler_bci, scope_depth);
 685   if (t == NULL &amp;&amp; (nm-&gt;is_compiled_by_c1() || handler_bci != -1)) {
 686     // Allow abbreviated catch tables.  The idea is to allow a method
 687     // to materialize its exceptions without committing to the exact
 688     // routing of exceptions.  In particular this is needed for adding
 689     // a synthetic handler to unlock monitors when inlining
 690     // synchronized methods since the unlock path isn&#39;t represented in
 691     // the bytecodes.
 692     t = table.entry_for(catch_pco, -1, 0);
 693   }
 694 
 695 #ifdef COMPILER1
 696   if (t == NULL &amp;&amp; nm-&gt;is_compiled_by_c1()) {
 697     assert(nm-&gt;unwind_handler_begin() != NULL, &quot;&quot;);
 698     return nm-&gt;unwind_handler_begin();
 699   }
 700 #endif
 701 
 702   if (t == NULL) {
 703     ttyLocker ttyl;
 704     tty-&gt;print_cr(&quot;MISSING EXCEPTION HANDLER for pc &quot; INTPTR_FORMAT &quot; and handler bci %d&quot;, p2i(ret_pc), handler_bci);
 705     tty-&gt;print_cr(&quot;   Exception:&quot;);
 706     exception-&gt;print();
 707     tty-&gt;cr();
 708     tty-&gt;print_cr(&quot; Compiled exception table :&quot;);
 709     table.print();
 710     nm-&gt;print_code();
 711     guarantee(false, &quot;missing exception handler&quot;);
 712     return NULL;
 713   }
 714 
 715   return nm-&gt;code_begin() + t-&gt;pco();
 716 }
 717 
 718 JRT_ENTRY(void, SharedRuntime::throw_AbstractMethodError(JavaThread* thread))
 719   // These errors occur only at call sites
 720   throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_AbstractMethodError());
 721 JRT_END
 722 
 723 JRT_ENTRY(void, SharedRuntime::throw_IncompatibleClassChangeError(JavaThread* thread))
 724   // These errors occur only at call sites
 725   throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_IncompatibleClassChangeError(), &quot;vtable stub&quot;);
 726 JRT_END
 727 
 728 JRT_ENTRY(void, SharedRuntime::throw_ArithmeticException(JavaThread* thread))
 729   throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_ArithmeticException(), &quot;/ by zero&quot;);
 730 JRT_END
 731 
 732 JRT_ENTRY(void, SharedRuntime::throw_NullPointerException(JavaThread* thread))
 733   throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());
 734 JRT_END
 735 
 736 JRT_ENTRY(void, SharedRuntime::throw_NullPointerException_at_call(JavaThread* thread))
 737   // This entry point is effectively only used for NullPointerExceptions which occur at inline
 738   // cache sites (when the callee activation is not yet set up) so we are at a call site
 739   throw_and_post_jvmti_exception(thread, vmSymbols::java_lang_NullPointerException());
 740 JRT_END
 741 
 742 JRT_ENTRY(void, SharedRuntime::throw_StackOverflowError(JavaThread* thread))
 743   throw_StackOverflowError_common(thread, false);
 744 JRT_END
 745 
 746 JRT_ENTRY(void, SharedRuntime::throw_delayed_StackOverflowError(JavaThread* thread))
 747   throw_StackOverflowError_common(thread, true);
 748 JRT_END
 749 
 750 void SharedRuntime::throw_StackOverflowError_common(JavaThread* thread, bool delayed) {
 751   // We avoid using the normal exception construction in this case because
 752   // it performs an upcall to Java, and we&#39;re already out of stack space.
 753   Thread* THREAD = thread;
 754   Klass* k = SystemDictionary::StackOverflowError_klass();
 755   oop exception_oop = InstanceKlass::cast(k)-&gt;allocate_instance(CHECK);
 756   if (delayed) {
 757     java_lang_Throwable::set_message(exception_oop,
 758                                      Universe::delayed_stack_overflow_error_message());
 759   }
 760   Handle exception (thread, exception_oop);
 761   if (StackTraceInThrowable) {
 762     java_lang_Throwable::fill_in_stack_trace(exception);
 763   }
 764   // Increment counter for hs_err file reporting
 765   Atomic::inc(&amp;Exceptions::_stack_overflow_errors);
 766   throw_and_post_jvmti_exception(thread, exception);
 767 }
 768 
 769 address SharedRuntime::continuation_for_implicit_exception(JavaThread* thread,
 770                                                            address pc,
 771                                                            ImplicitExceptionKind exception_kind)
 772 {
 773   address target_pc = NULL;
 774 
 775   if (Interpreter::contains(pc)) {
 776 #ifdef CC_INTERP
 777     // C++ interpreter doesn&#39;t throw implicit exceptions
 778     ShouldNotReachHere();
 779 #else
 780     switch (exception_kind) {
 781       case IMPLICIT_NULL:           return Interpreter::throw_NullPointerException_entry();
 782       case IMPLICIT_DIVIDE_BY_ZERO: return Interpreter::throw_ArithmeticException_entry();
 783       case STACK_OVERFLOW:          return Interpreter::throw_StackOverflowError_entry();
 784       default:                      ShouldNotReachHere();
 785     }
 786 #endif // !CC_INTERP
 787   } else {
 788     switch (exception_kind) {
 789       case STACK_OVERFLOW: {
 790         // Stack overflow only occurs upon frame setup; the callee is
 791         // going to be unwound. Dispatch to a shared runtime stub
 792         // which will cause the StackOverflowError to be fabricated
 793         // and processed.
 794         // Stack overflow should never occur during deoptimization:
 795         // the compiled method bangs the stack by as much as the
 796         // interpreter would need in case of a deoptimization. The
 797         // deoptimization blob and uncommon trap blob bang the stack
 798         // in a debug VM to verify the correctness of the compiled
 799         // method stack banging.
 800         assert(thread-&gt;deopt_mark() == NULL, &quot;no stack overflow from deopt blob/uncommon trap&quot;);
 801         Events::log_exception(thread, &quot;StackOverflowError at &quot; INTPTR_FORMAT, p2i(pc));
 802         return StubRoutines::throw_StackOverflowError_entry();
 803       }
 804 
 805       case IMPLICIT_NULL: {
 806         if (VtableStubs::contains(pc)) {
 807           // We haven&#39;t yet entered the callee frame. Fabricate an
 808           // exception and begin dispatching it in the caller. Since
 809           // the caller was at a call site, it&#39;s safe to destroy all
 810           // caller-saved registers, as these entry points do.
 811           VtableStub* vt_stub = VtableStubs::stub_containing(pc);
 812 
 813           // If vt_stub is NULL, then return NULL to signal handler to report the SEGV error.
 814           if (vt_stub == NULL) return NULL;
 815 
 816           if (vt_stub-&gt;is_abstract_method_error(pc)) {
 817             assert(!vt_stub-&gt;is_vtable_stub(), &quot;should never see AbstractMethodErrors from vtable-type VtableStubs&quot;);
 818             Events::log_exception(thread, &quot;AbstractMethodError at &quot; INTPTR_FORMAT, p2i(pc));
 819             // Instead of throwing the abstract method error here directly, we re-resolve
 820             // and will throw the AbstractMethodError during resolve. As a result, we&#39;ll
 821             // get a more detailed error message.
 822             return SharedRuntime::get_handle_wrong_method_stub();
 823           } else {
 824             Events::log_exception(thread, &quot;NullPointerException at vtable entry &quot; INTPTR_FORMAT, p2i(pc));
 825             // Assert that the signal comes from the expected location in stub code.
 826             assert(vt_stub-&gt;is_null_pointer_exception(pc),
 827                    &quot;obtained signal from unexpected location in stub code&quot;);
 828             return StubRoutines::throw_NullPointerException_at_call_entry();
 829           }
 830         } else {
 831           CodeBlob* cb = CodeCache::find_blob(pc);
 832 
 833           // If code blob is NULL, then return NULL to signal handler to report the SEGV error.
 834           if (cb == NULL) return NULL;
 835 
 836           // Exception happened in CodeCache. Must be either:
 837           // 1. Inline-cache check in C2I handler blob,
 838           // 2. Inline-cache check in nmethod, or
 839           // 3. Implicit null exception in nmethod
 840 
 841           if (!cb-&gt;is_compiled()) {
 842             bool is_in_blob = cb-&gt;is_adapter_blob() || cb-&gt;is_method_handles_adapter_blob();
 843             if (!is_in_blob) {
 844               // Allow normal crash reporting to handle this
 845               return NULL;
 846             }
 847             Events::log_exception(thread, &quot;NullPointerException in code blob at &quot; INTPTR_FORMAT, p2i(pc));
 848             // There is no handler here, so we will simply unwind.
 849             return StubRoutines::throw_NullPointerException_at_call_entry();
 850           }
 851 
 852           // Otherwise, it&#39;s a compiled method.  Consult its exception handlers.
 853           CompiledMethod* cm = (CompiledMethod*)cb;
 854           if (cm-&gt;inlinecache_check_contains(pc)) {
 855             // exception happened inside inline-cache check code
 856             // =&gt; the nmethod is not yet active (i.e., the frame
 857             // is not set up yet) =&gt; use return address pushed by
 858             // caller =&gt; don&#39;t push another return address
 859             Events::log_exception(thread, &quot;NullPointerException in IC check &quot; INTPTR_FORMAT, p2i(pc));
 860             return StubRoutines::throw_NullPointerException_at_call_entry();
 861           }
 862 
 863           if (cm-&gt;method()-&gt;is_method_handle_intrinsic()) {
 864             // exception happened inside MH dispatch code, similar to a vtable stub
 865             Events::log_exception(thread, &quot;NullPointerException in MH adapter &quot; INTPTR_FORMAT, p2i(pc));
 866             return StubRoutines::throw_NullPointerException_at_call_entry();
 867           }
 868 
 869 #ifndef PRODUCT
 870           _implicit_null_throws++;
 871 #endif
 872           target_pc = cm-&gt;continuation_for_implicit_null_exception(pc);
 873           // If there&#39;s an unexpected fault, target_pc might be NULL,
 874           // in which case we want to fall through into the normal
 875           // error handling code.
 876         }
 877 
 878         break; // fall through
 879       }
 880 
 881 
 882       case IMPLICIT_DIVIDE_BY_ZERO: {
 883         CompiledMethod* cm = CodeCache::find_compiled(pc);
 884         guarantee(cm != NULL, &quot;must have containing compiled method for implicit division-by-zero exceptions&quot;);
 885 #ifndef PRODUCT
 886         _implicit_div0_throws++;
 887 #endif
 888         target_pc = cm-&gt;continuation_for_implicit_div0_exception(pc);
 889         // If there&#39;s an unexpected fault, target_pc might be NULL,
 890         // in which case we want to fall through into the normal
 891         // error handling code.
 892         break; // fall through
 893       }
 894 
 895       default: ShouldNotReachHere();
 896     }
 897 
 898     assert(exception_kind == IMPLICIT_NULL || exception_kind == IMPLICIT_DIVIDE_BY_ZERO, &quot;wrong implicit exception kind&quot;);
 899 
 900     if (exception_kind == IMPLICIT_NULL) {
 901 #ifndef PRODUCT
 902       // for AbortVMOnException flag
 903       Exceptions::debug_check_abort(&quot;java.lang.NullPointerException&quot;);
 904 #endif //PRODUCT
 905       Events::log_exception(thread, &quot;Implicit null exception at &quot; INTPTR_FORMAT &quot; to &quot; INTPTR_FORMAT, p2i(pc), p2i(target_pc));
 906     } else {
 907 #ifndef PRODUCT
 908       // for AbortVMOnException flag
 909       Exceptions::debug_check_abort(&quot;java.lang.ArithmeticException&quot;);
 910 #endif //PRODUCT
 911       Events::log_exception(thread, &quot;Implicit division by zero exception at &quot; INTPTR_FORMAT &quot; to &quot; INTPTR_FORMAT, p2i(pc), p2i(target_pc));
 912     }
 913     return target_pc;
 914   }
 915 
 916   ShouldNotReachHere();
 917   return NULL;
 918 }
 919 
 920 
 921 /**
 922  * Throws an java/lang/UnsatisfiedLinkError.  The address of this method is
 923  * installed in the native function entry of all native Java methods before
 924  * they get linked to their actual native methods.
 925  *
 926  * \note
 927  * This method actually never gets called!  The reason is because
 928  * the interpreter&#39;s native entries call NativeLookup::lookup() which
 929  * throws the exception when the lookup fails.  The exception is then
 930  * caught and forwarded on the return from NativeLookup::lookup() call
 931  * before the call to the native function.  This might change in the future.
 932  */
 933 JNI_ENTRY(void*, throw_unsatisfied_link_error(JNIEnv* env, ...))
 934 {
 935   // We return a bad value here to make sure that the exception is
 936   // forwarded before we look at the return value.
 937   THROW_(vmSymbols::java_lang_UnsatisfiedLinkError(), (void*)badAddress);
 938 }
 939 JNI_END
 940 
 941 address SharedRuntime::native_method_throw_unsatisfied_link_error_entry() {
 942   return CAST_FROM_FN_PTR(address, &amp;throw_unsatisfied_link_error);
 943 }
 944 
 945 JRT_ENTRY_NO_ASYNC(void, SharedRuntime::register_finalizer(JavaThread* thread, oopDesc* obj))
 946 #if INCLUDE_JVMCI
 947   if (!obj-&gt;klass()-&gt;has_finalizer()) {
 948     return;
 949   }
 950 #endif // INCLUDE_JVMCI
 951   assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
 952   assert(obj-&gt;klass()-&gt;has_finalizer(), &quot;shouldn&#39;t be here otherwise&quot;);
 953   InstanceKlass::register_finalizer(instanceOop(obj), CHECK);
 954 JRT_END
 955 
 956 
 957 jlong SharedRuntime::get_java_tid(Thread* thread) {
 958   if (thread != NULL) {
 959     if (thread-&gt;is_Java_thread()) {
 960       oop obj = ((JavaThread*)thread)-&gt;threadObj();
 961       return (obj == NULL) ? 0 : java_lang_Thread::thread_id(obj);
 962     }
 963   }
 964   return 0;
 965 }
 966 
 967 /**
 968  * This function ought to be a void function, but cannot be because
 969  * it gets turned into a tail-call on sparc, which runs into dtrace bug
 970  * 6254741.  Once that is fixed we can remove the dummy return value.
 971  */
 972 int SharedRuntime::dtrace_object_alloc(oopDesc* o, int size) {
 973   return dtrace_object_alloc_base(Thread::current(), o, size);
 974 }
 975 
 976 int SharedRuntime::dtrace_object_alloc_base(Thread* thread, oopDesc* o, int size) {
 977   assert(DTraceAllocProbes, &quot;wrong call&quot;);
 978   Klass* klass = o-&gt;klass();
 979   Symbol* name = klass-&gt;name();
 980   HOTSPOT_OBJECT_ALLOC(
 981                    get_java_tid(thread),
 982                    (char *) name-&gt;bytes(), name-&gt;utf8_length(), size * HeapWordSize);
 983   return 0;
 984 }
 985 
 986 JRT_LEAF(int, SharedRuntime::dtrace_method_entry(
 987     JavaThread* thread, Method* method))
 988   assert(DTraceMethodProbes, &quot;wrong call&quot;);
 989   Symbol* kname = method-&gt;klass_name();
 990   Symbol* name = method-&gt;name();
 991   Symbol* sig = method-&gt;signature();
 992   HOTSPOT_METHOD_ENTRY(
 993       get_java_tid(thread),
 994       (char *) kname-&gt;bytes(), kname-&gt;utf8_length(),
 995       (char *) name-&gt;bytes(), name-&gt;utf8_length(),
 996       (char *) sig-&gt;bytes(), sig-&gt;utf8_length());
 997   return 0;
 998 JRT_END
 999 
1000 JRT_LEAF(int, SharedRuntime::dtrace_method_exit(
1001     JavaThread* thread, Method* method))
1002   assert(DTraceMethodProbes, &quot;wrong call&quot;);
1003   Symbol* kname = method-&gt;klass_name();
1004   Symbol* name = method-&gt;name();
1005   Symbol* sig = method-&gt;signature();
1006   HOTSPOT_METHOD_RETURN(
1007       get_java_tid(thread),
1008       (char *) kname-&gt;bytes(), kname-&gt;utf8_length(),
1009       (char *) name-&gt;bytes(), name-&gt;utf8_length(),
1010       (char *) sig-&gt;bytes(), sig-&gt;utf8_length());
1011   return 0;
1012 JRT_END
1013 
1014 
1015 // Finds receiver, CallInfo (i.e. receiver method), and calling bytecode)
1016 // for a call current in progress, i.e., arguments has been pushed on stack
1017 // put callee has not been invoked yet.  Used by: resolve virtual/static,
1018 // vtable updates, etc.  Caller frame must be compiled.
1019 Handle SharedRuntime::find_callee_info(JavaThread* thread, Bytecodes::Code&amp; bc, CallInfo&amp; callinfo, TRAPS) {
1020   ResourceMark rm(THREAD);
1021 
1022   // last java frame on stack (which includes native call frames)
1023   vframeStream vfst(thread, true);  // Do not skip and javaCalls
1024 
1025   return find_callee_info_helper(thread, vfst, bc, callinfo, THREAD);
1026 }
1027 
1028 Method* SharedRuntime::extract_attached_method(vframeStream&amp; vfst) {
1029   CompiledMethod* caller = vfst.nm();
1030 
1031   nmethodLocker caller_lock(caller);
1032 
1033   address pc = vfst.frame_pc();
1034   { // Get call instruction under lock because another thread may be busy patching it.
1035     CompiledICLocker ic_locker(caller);
1036     return caller-&gt;attached_method_before_pc(pc);
1037   }
1038   return NULL;
1039 }
1040 
1041 // Finds receiver, CallInfo (i.e. receiver method), and calling bytecode
1042 // for a call current in progress, i.e., arguments has been pushed on stack
1043 // but callee has not been invoked yet.  Caller frame must be compiled.
1044 Handle SharedRuntime::find_callee_info_helper(JavaThread* thread,
1045                                               vframeStream&amp; vfst,
1046                                               Bytecodes::Code&amp; bc,
1047                                               CallInfo&amp; callinfo, TRAPS) {
1048   Handle receiver;
1049   Handle nullHandle;  //create a handy null handle for exception returns
1050 
1051   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1052 
1053   // Find caller and bci from vframe
1054   methodHandle caller(THREAD, vfst.method());
1055   int          bci   = vfst.bci();
1056 
1057   // Substitutability test implementation piggy backs on static call resolution
1058   Bytecodes::Code code = caller-&gt;java_code_at(bci);
1059   if (code == Bytecodes::_if_acmpeq || code == Bytecodes::_if_acmpne) {
1060     bc = Bytecodes::_invokestatic;
1061     methodHandle attached_method(THREAD, extract_attached_method(vfst));
1062     assert(attached_method.not_null(), &quot;must have attached method&quot;);
1063     SystemDictionary::ValueBootstrapMethods_klass()-&gt;initialize(CHECK_NH);
1064     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, false, CHECK_NH);
1065 #ifdef ASSERT
1066     Method* is_subst = SystemDictionary::ValueBootstrapMethods_klass()-&gt;find_method(vmSymbols::isSubstitutable_name(), vmSymbols::object_object_boolean_signature());
1067     assert(callinfo.selected_method() == is_subst, &quot;must be isSubstitutable method&quot;);
1068 #endif
1069     return receiver;
1070   }
1071 
1072   Bytecode_invoke bytecode(caller, bci);
1073   int bytecode_index = bytecode.index();
1074   bc = bytecode.invoke_code();
1075 
1076   methodHandle attached_method(THREAD, extract_attached_method(vfst));
1077   if (attached_method.not_null()) {
1078     Method* callee = bytecode.static_target(CHECK_NH);
1079     vmIntrinsics::ID id = callee-&gt;intrinsic_id();
1080     // When VM replaces MH.invokeBasic/linkTo* call with a direct/virtual call,
1081     // it attaches statically resolved method to the call site.
1082     if (MethodHandles::is_signature_polymorphic(id) &amp;&amp;
1083         MethodHandles::is_signature_polymorphic_intrinsic(id)) {
1084       bc = MethodHandles::signature_polymorphic_intrinsic_bytecode(id);
1085 
1086       // Adjust invocation mode according to the attached method.
1087       switch (bc) {
1088         case Bytecodes::_invokevirtual:
1089           if (attached_method-&gt;method_holder()-&gt;is_interface()) {
1090             bc = Bytecodes::_invokeinterface;
1091           }
1092           break;
1093         case Bytecodes::_invokeinterface:
1094           if (!attached_method-&gt;method_holder()-&gt;is_interface()) {
1095             bc = Bytecodes::_invokevirtual;
1096           }
1097           break;
1098         case Bytecodes::_invokehandle:
1099           if (!MethodHandles::is_signature_polymorphic_method(attached_method())) {
1100             bc = attached_method-&gt;is_static() ? Bytecodes::_invokestatic
1101                                               : Bytecodes::_invokevirtual;
1102           }
1103           break;
1104         default:
1105           break;
1106       }
1107     } else {
1108       assert(attached_method-&gt;has_scalarized_args(), &quot;invalid use of attached method&quot;);
1109       if (!attached_method-&gt;method_holder()-&gt;is_value()) {
1110         // Ignore the attached method in this case to not confuse below code
1111         attached_method = methodHandle(thread, NULL);
1112       }
1113     }
1114   }
1115 
1116   assert(bc != Bytecodes::_illegal, &quot;not initialized&quot;);
1117 
1118   bool has_receiver = bc != Bytecodes::_invokestatic &amp;&amp;
1119                       bc != Bytecodes::_invokedynamic &amp;&amp;
1120                       bc != Bytecodes::_invokehandle;
1121   bool check_null_and_abstract = true;
1122 
1123   // Find receiver for non-static call
1124   if (has_receiver) {
1125     // This register map must be update since we need to find the receiver for
1126     // compiled frames. The receiver might be in a register.
1127     RegisterMap reg_map2(thread);
1128     frame stubFrame   = thread-&gt;last_frame();
1129     // Caller-frame is a compiled frame
1130     frame callerFrame = stubFrame.sender(&amp;reg_map2);
1131     bool caller_is_c1 = false;
1132 
1133     if (callerFrame.is_compiled_frame() &amp;&amp; !callerFrame.is_deoptimized_frame()) {
1134       caller_is_c1 = callerFrame.cb()-&gt;is_compiled_by_c1();
1135     }
1136 
1137     Method* callee = attached_method();
1138     if (callee == NULL) {
1139       callee = bytecode.static_target(CHECK_NH);
1140       if (callee == NULL) {
1141         THROW_(vmSymbols::java_lang_NoSuchMethodException(), nullHandle);
1142       }
1143     }
1144     if (!caller_is_c1 &amp;&amp; callee-&gt;has_scalarized_args() &amp;&amp; callee-&gt;method_holder()-&gt;is_value()) {
1145       // If the receiver is a value type that is passed as fields, no oop is available.
1146       // Resolve the call without receiver null checking.
1147       assert(attached_method.not_null() &amp;&amp; !attached_method-&gt;is_abstract(), &quot;must have non-abstract attached method&quot;);
1148       if (bc == Bytecodes::_invokeinterface) {
1149         bc = Bytecodes::_invokevirtual; // C2 optimistically replaces interface calls by virtual calls
1150       }
1151       check_null_and_abstract = false;
1152     } else {
1153       // Retrieve from a compiled argument list
1154       receiver = Handle(THREAD, callerFrame.retrieve_receiver(&amp;reg_map2));
1155       if (receiver.is_null()) {
1156         THROW_(vmSymbols::java_lang_NullPointerException(), nullHandle);
1157       }
1158     }
1159   }
1160 
1161   // Resolve method
1162   if (attached_method.not_null()) {
1163     // Parameterized by attached method.
1164     LinkResolver::resolve_invoke(callinfo, receiver, attached_method, bc, check_null_and_abstract, CHECK_NH);
1165   } else {
1166     // Parameterized by bytecode.
1167     constantPoolHandle constants(THREAD, caller-&gt;constants());
1168     LinkResolver::resolve_invoke(callinfo, receiver, constants, bytecode_index, bc, CHECK_NH);
1169   }
1170 
1171 #ifdef ASSERT
1172   // Check that the receiver klass is of the right subtype and that it is initialized for virtual calls
1173   if (has_receiver &amp;&amp; check_null_and_abstract) {
1174     assert(receiver.not_null(), &quot;should have thrown exception&quot;);
1175     Klass* receiver_klass = receiver-&gt;klass();
1176     Klass* rk = NULL;
1177     if (attached_method.not_null()) {
1178       // In case there&#39;s resolved method attached, use its holder during the check.
1179       rk = attached_method-&gt;method_holder();
1180     } else {
1181       // Klass is already loaded.
1182       constantPoolHandle constants(THREAD, caller-&gt;constants());
1183       rk = constants-&gt;klass_ref_at(bytecode_index, CHECK_NH);
1184     }
1185     Klass* static_receiver_klass = rk;
1186     assert(receiver_klass-&gt;is_subtype_of(static_receiver_klass),
1187            &quot;actual receiver must be subclass of static receiver klass&quot;);
1188     if (receiver_klass-&gt;is_instance_klass()) {
1189       if (InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized()) {
1190         tty-&gt;print_cr(&quot;ERROR: Klass not yet initialized!!&quot;);
1191         receiver_klass-&gt;print();
1192       }
1193       assert(!InstanceKlass::cast(receiver_klass)-&gt;is_not_initialized(), &quot;receiver_klass must be initialized&quot;);
1194     }
1195   }
1196 #endif
1197 
1198   return receiver;
1199 }
1200 
1201 methodHandle SharedRuntime::find_callee_method(JavaThread* thread, TRAPS) {
1202   ResourceMark rm(THREAD);
1203   // We need first to check if any Java activations (compiled, interpreted)
1204   // exist on the stack since last JavaCall.  If not, we need
1205   // to get the target method from the JavaCall wrapper.
1206   vframeStream vfst(thread, true);  // Do not skip any javaCalls
1207   methodHandle callee_method;
1208   if (vfst.at_end()) {
1209     // No Java frames were found on stack since we did the JavaCall.
1210     // Hence the stack can only contain an entry_frame.  We need to
1211     // find the target method from the stub frame.
1212     RegisterMap reg_map(thread, false);
1213     frame fr = thread-&gt;last_frame();
1214     assert(fr.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1215     fr = fr.sender(&amp;reg_map);
1216     assert(fr.is_entry_frame(), &quot;must be&quot;);
1217     // fr is now pointing to the entry frame.
1218     callee_method = methodHandle(THREAD, fr.entry_frame_call_wrapper()-&gt;callee_method());
1219   } else {
1220     Bytecodes::Code bc;
1221     CallInfo callinfo;
1222     find_callee_info_helper(thread, vfst, bc, callinfo, CHECK_(methodHandle()));
1223     callee_method = methodHandle(THREAD, callinfo.selected_method());
1224   }
1225   assert(callee_method()-&gt;is_method(), &quot;must be&quot;);
1226   return callee_method;
1227 }
1228 
1229 // Resolves a call.
1230 methodHandle SharedRuntime::resolve_helper(JavaThread *thread,
1231                                            bool is_virtual,
1232                                            bool is_optimized,
1233                                            bool* caller_is_c1, TRAPS) {
1234   methodHandle callee_method;
1235   callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, caller_is_c1, THREAD);
1236   if (JvmtiExport::can_hotswap_or_post_breakpoint()) {
1237     int retry_count = 0;
1238     while (!HAS_PENDING_EXCEPTION &amp;&amp; callee_method-&gt;is_old() &amp;&amp;
1239            callee_method-&gt;method_holder() != SystemDictionary::Object_klass()) {
1240       // If has a pending exception then there is no need to re-try to
1241       // resolve this method.
1242       // If the method has been redefined, we need to try again.
1243       // Hack: we have no way to update the vtables of arrays, so don&#39;t
1244       // require that java.lang.Object has been updated.
1245 
1246       // It is very unlikely that method is redefined more than 100 times
1247       // in the middle of resolve. If it is looping here more than 100 times
1248       // means then there could be a bug here.
1249       guarantee((retry_count++ &lt; 100),
1250                 &quot;Could not resolve to latest version of redefined method&quot;);
1251       // method is redefined in the middle of resolve so re-try.
1252       callee_method = resolve_sub_helper(thread, is_virtual, is_optimized, caller_is_c1, THREAD);
1253     }
1254   }
1255   return callee_method;
1256 }
1257 
1258 // This fails if resolution required refilling of IC stubs
1259 bool SharedRuntime::resolve_sub_helper_internal(methodHandle callee_method, const frame&amp; caller_frame,
1260                                                 CompiledMethod* caller_nm, bool is_virtual, bool is_optimized,
1261                                                 Handle receiver, CallInfo&amp; call_info, Bytecodes::Code invoke_code, TRAPS) {
1262   StaticCallInfo static_call_info;
1263   CompiledICInfo virtual_call_info;
1264 
1265   // Make sure the callee nmethod does not get deoptimized and removed before
1266   // we are done patching the code.
1267   CompiledMethod* callee = callee_method-&gt;code();
1268 
1269   if (callee != NULL) {
1270     assert(callee-&gt;is_compiled(), &quot;must be nmethod for patching&quot;);
1271   }
1272 
1273   if (callee != NULL &amp;&amp; !callee-&gt;is_in_use()) {
1274     // Patch call site to C2I adapter if callee nmethod is deoptimized or unloaded.
1275     callee = NULL;
1276   }
1277   nmethodLocker nl_callee(callee);
1278 #ifdef ASSERT
1279   address dest_entry_point = callee == NULL ? 0 : callee-&gt;entry_point(); // used below
1280 #endif
1281 
1282   bool is_nmethod = caller_nm-&gt;is_nmethod();
1283   bool caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
1284 
1285   if (is_virtual) {
1286     Klass* receiver_klass = NULL;
1287     if (ValueTypePassFieldsAsArgs &amp;&amp; !caller_is_c1 &amp;&amp; callee_method-&gt;method_holder()-&gt;is_value()) {
1288       // If the receiver is a value type that is passed as fields, no oop is available
1289       receiver_klass = callee_method-&gt;method_holder();
1290     } else {
1291       assert(receiver.not_null() || invoke_code == Bytecodes::_invokehandle, &quot;sanity check&quot;);
1292       receiver_klass = invoke_code == Bytecodes::_invokehandle ? NULL : receiver-&gt;klass();
1293     }
1294     bool static_bound = call_info.resolved_method()-&gt;can_be_statically_bound();
1295     CompiledIC::compute_monomorphic_entry(callee_method, receiver_klass,
1296                      is_optimized, static_bound, is_nmethod, caller_is_c1, virtual_call_info,
1297                      CHECK_false);
1298   } else {
1299     // static call
1300     CompiledStaticCall::compute_entry(callee_method, caller_nm, static_call_info);
1301   }
1302 
1303   // grab lock, check for deoptimization and potentially patch caller
1304   {
1305     CompiledICLocker ml(caller_nm);
1306 
1307     // Lock blocks for safepoint during which both nmethods can change state.
1308 
1309     // Now that we are ready to patch if the Method* was redefined then
1310     // don&#39;t update call site and let the caller retry.
1311     // Don&#39;t update call site if callee nmethod was unloaded or deoptimized.
1312     // Don&#39;t update call site if callee nmethod was replaced by an other nmethod
1313     // which may happen when multiply alive nmethod (tiered compilation)
1314     // will be supported.
1315     if (!callee_method-&gt;is_old() &amp;&amp;
1316         (callee == NULL || (callee-&gt;is_in_use() &amp;&amp; callee_method-&gt;code() == callee))) {
1317       NoSafepointVerifier nsv;
1318 #ifdef ASSERT
1319       // We must not try to patch to jump to an already unloaded method.
1320       if (dest_entry_point != 0) {
1321         CodeBlob* cb = CodeCache::find_blob(dest_entry_point);
1322         assert((cb != NULL) &amp;&amp; cb-&gt;is_compiled() &amp;&amp; (((CompiledMethod*)cb) == callee),
1323                &quot;should not call unloaded nmethod&quot;);
1324       }
1325 #endif
1326       if (is_virtual) {
1327         CompiledIC* inline_cache = CompiledIC_before(caller_nm, caller_frame.pc());
1328         if (inline_cache-&gt;is_clean()) {
1329           if (!inline_cache-&gt;set_to_monomorphic(virtual_call_info)) {
1330             return false;
1331           }
1332         }
1333       } else {
1334         if (VM_Version::supports_fast_class_init_checks() &amp;&amp;
1335             invoke_code == Bytecodes::_invokestatic &amp;&amp;
1336             callee_method-&gt;needs_clinit_barrier() &amp;&amp;
1337             callee != NULL &amp;&amp; (callee-&gt;is_compiled_by_jvmci() || callee-&gt;is_aot())) {
1338           return true; // skip patching for JVMCI or AOT code
1339         }
1340         CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_before(caller_frame.pc());
1341         if (ssc-&gt;is_clean()) ssc-&gt;set(static_call_info);
1342       }
1343     }
1344   } // unlock CompiledICLocker
1345   return true;
1346 }
1347 
1348 // Resolves a call.  The compilers generate code for calls that go here
1349 // and are patched with the real destination of the call.
1350 methodHandle SharedRuntime::resolve_sub_helper(JavaThread *thread,
1351                                                bool is_virtual,
1352                                                bool is_optimized,
1353                                                bool* caller_is_c1, TRAPS) {
1354 
1355   ResourceMark rm(thread);
1356   RegisterMap cbl_map(thread, false);
1357   frame caller_frame = thread-&gt;last_frame().sender(&amp;cbl_map);
1358 
1359   CodeBlob* caller_cb = caller_frame.cb();
1360   guarantee(caller_cb != NULL &amp;&amp; caller_cb-&gt;is_compiled(), &quot;must be called from compiled method&quot;);
1361   CompiledMethod* caller_nm = caller_cb-&gt;as_compiled_method_or_null();
1362   *caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
1363 
1364   // make sure caller is not getting deoptimized
1365   // and removed before we are done with it.
1366   // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1367   nmethodLocker caller_lock(caller_nm);
1368 
1369   // determine call info &amp; receiver
1370   // note: a) receiver is NULL for static calls
1371   //       b) an exception is thrown if receiver is NULL for non-static calls
1372   CallInfo call_info;
1373   Bytecodes::Code invoke_code = Bytecodes::_illegal;
1374   Handle receiver = find_callee_info(thread, invoke_code,
1375                                      call_info, CHECK_(methodHandle()));
1376   methodHandle callee_method(THREAD, call_info.selected_method());
1377 
1378   assert((!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokestatic ) ||
1379          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokespecial) ||
1380          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokehandle ) ||
1381          (!is_virtual &amp;&amp; invoke_code == Bytecodes::_invokedynamic) ||
1382          ( is_virtual &amp;&amp; invoke_code != Bytecodes::_invokestatic ), &quot;inconsistent bytecode&quot;);
1383 
1384   assert(caller_nm-&gt;is_alive() &amp;&amp; !caller_nm-&gt;is_unloading(), &quot;It should be alive&quot;);
1385 
1386 #ifndef PRODUCT
1387   // tracing/debugging/statistics
1388   int *addr = (is_optimized) ? (&amp;_resolve_opt_virtual_ctr) :
1389                 (is_virtual) ? (&amp;_resolve_virtual_ctr) :
1390                                (&amp;_resolve_static_ctr);
1391   Atomic::inc(addr);
1392 
1393   if (TraceCallFixup) {
1394     ResourceMark rm(thread);
1395     tty-&gt;print(&quot;resolving %s%s (%s) call to&quot;,
1396       (is_optimized) ? &quot;optimized &quot; : &quot;&quot;, (is_virtual) ? &quot;virtual&quot; : &quot;static&quot;,
1397       Bytecodes::name(invoke_code));
1398     callee_method-&gt;print_short_name(tty);
1399     tty-&gt;print_cr(&quot; at pc: &quot; INTPTR_FORMAT &quot; to code: &quot; INTPTR_FORMAT,
1400                   p2i(caller_frame.pc()), p2i(callee_method-&gt;code()));
1401   }
1402 #endif
1403 
1404   if (invoke_code == Bytecodes::_invokestatic) {
1405     assert(callee_method-&gt;method_holder()-&gt;is_initialized() ||
1406            callee_method-&gt;method_holder()-&gt;is_reentrant_initialization(thread),
1407            &quot;invalid class initialization state for invoke_static&quot;);
1408     if (!VM_Version::supports_fast_class_init_checks() &amp;&amp; callee_method-&gt;needs_clinit_barrier()) {
1409       // In order to keep class initialization check, do not patch call
1410       // site for static call when the class is not fully initialized.
1411       // Proper check is enforced by call site re-resolution on every invocation.
1412       //
1413       // When fast class initialization checks are supported (VM_Version::supports_fast_class_init_checks() == true),
1414       // explicit class initialization check is put in nmethod entry (VEP).
1415       assert(callee_method-&gt;method_holder()-&gt;is_linked(), &quot;must be&quot;);
1416       return callee_method;
1417     }
1418   }
1419 
1420   // JSR 292 key invariant:
1421   // If the resolved method is a MethodHandle invoke target, the call
1422   // site must be a MethodHandle call site, because the lambda form might tail-call
1423   // leaving the stack in a state unknown to either caller or callee
1424   // TODO detune for now but we might need it again
1425 //  assert(!callee_method-&gt;is_compiled_lambda_form() ||
1426 //         caller_nm-&gt;is_method_handle_return(caller_frame.pc()), &quot;must be MH call site&quot;);
1427 
1428   // Compute entry points. This might require generation of C2I converter
1429   // frames, so we cannot be holding any locks here. Furthermore, the
1430   // computation of the entry points is independent of patching the call.  We
1431   // always return the entry-point, but we only patch the stub if the call has
1432   // not been deoptimized.  Return values: For a virtual call this is an
1433   // (cached_oop, destination address) pair. For a static call/optimized
1434   // virtual this is just a destination address.
1435 
1436   // Patching IC caches may fail if we run out if transition stubs.
1437   // We refill the ic stubs then and try again.
1438   for (;;) {
1439     ICRefillVerifier ic_refill_verifier;
1440     bool successful = resolve_sub_helper_internal(callee_method, caller_frame, caller_nm,
1441                                                   is_virtual, is_optimized, receiver,
1442                                                   call_info, invoke_code, CHECK_(methodHandle()));
1443     if (successful) {
1444       return callee_method;
1445     } else {
1446       InlineCacheBuffer::refill_ic_stubs();
1447     }
1448   }
1449 
1450 }
1451 
1452 
1453 // Inline caches exist only in compiled code
1454 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_ic_miss(JavaThread* thread))
1455 #ifdef ASSERT
1456   RegisterMap reg_map(thread, false);
1457   frame stub_frame = thread-&gt;last_frame();
1458   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1459   frame caller_frame = stub_frame.sender(&amp;reg_map);
1460   assert(!caller_frame.is_interpreted_frame() &amp;&amp; !caller_frame.is_entry_frame(), &quot;unexpected frame&quot;);
1461 #endif /* ASSERT */
1462 
1463   methodHandle callee_method;
1464   bool is_optimized = false;
1465   bool caller_is_c1 = false;
1466   JRT_BLOCK
1467     callee_method = SharedRuntime::handle_ic_miss_helper(thread, is_optimized, caller_is_c1, CHECK_NULL);
1468     // Return Method* through TLS
1469     thread-&gt;set_vm_result_2(callee_method());
1470   JRT_BLOCK_END
1471   // return compiled code entry point after potential safepoints
1472   return entry_for_handle_wrong_method(callee_method, false, is_optimized, caller_is_c1);
1473 JRT_END
1474 
1475 
1476 // Handle call site that has been made non-entrant
1477 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method(JavaThread* thread))
1478   // 6243940 We might end up in here if the callee is deoptimized
1479   // as we race to call it.  We don&#39;t want to take a safepoint if
1480   // the caller was interpreted because the caller frame will look
1481   // interpreted to the stack walkers and arguments are now
1482   // &quot;compiled&quot; so it is much better to make this transition
1483   // invisible to the stack walking code. The i2c path will
1484   // place the callee method in the callee_target. It is stashed
1485   // there because if we try and find the callee by normal means a
1486   // safepoint is possible and have trouble gc&#39;ing the compiled args.
1487   RegisterMap reg_map(thread, false);
1488   frame stub_frame = thread-&gt;last_frame();
1489   assert(stub_frame.is_runtime_frame(), &quot;sanity check&quot;);
1490   frame caller_frame = stub_frame.sender(&amp;reg_map);
1491 
1492   if (caller_frame.is_interpreted_frame() ||
1493       caller_frame.is_entry_frame()) {
1494     Method* callee = thread-&gt;callee_target();
1495     guarantee(callee != NULL &amp;&amp; callee-&gt;is_method(), &quot;bad handshake&quot;);
1496     thread-&gt;set_vm_result_2(callee);
1497     thread-&gt;set_callee_target(NULL);
1498     if (caller_frame.is_entry_frame() &amp;&amp; VM_Version::supports_fast_class_init_checks()) {
1499       // Bypass class initialization checks in c2i when caller is in native.
1500       // JNI calls to static methods don&#39;t have class initialization checks.
1501       // Fast class initialization checks are present in c2i adapters and call into
1502       // SharedRuntime::handle_wrong_method() on the slow path.
1503       //
1504       // JVM upcalls may land here as well, but there&#39;s a proper check present in
1505       // LinkResolver::resolve_static_call (called from JavaCalls::call_static),
1506       // so bypassing it in c2i adapter is benign.
1507       return callee-&gt;get_c2i_no_clinit_check_entry();
1508     } else {
1509       return callee-&gt;get_c2i_entry();
1510     }
1511   }
1512 
1513   // Must be compiled to compiled path which is safe to stackwalk
1514   methodHandle callee_method;
1515   bool is_static_call = false;
1516   bool is_optimized = false;
1517   bool caller_is_c1 = false;
1518   JRT_BLOCK
1519     // Force resolving of caller (if we called from compiled frame)
1520     callee_method = SharedRuntime::reresolve_call_site(thread, is_static_call, is_optimized, caller_is_c1, CHECK_NULL);
1521     thread-&gt;set_vm_result_2(callee_method());
1522   JRT_BLOCK_END
1523   // return compiled code entry point after potential safepoints
1524   return entry_for_handle_wrong_method(callee_method, is_static_call, is_optimized, caller_is_c1);
1525 JRT_END
1526 
1527 // Handle abstract method call
1528 JRT_BLOCK_ENTRY(address, SharedRuntime::handle_wrong_method_abstract(JavaThread* thread))
1529   // Verbose error message for AbstractMethodError.
1530   // Get the called method from the invoke bytecode.
1531   vframeStream vfst(thread, true);
1532   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
1533   methodHandle caller(thread, vfst.method());
1534   Bytecode_invoke invoke(caller, vfst.bci());
1535   DEBUG_ONLY( invoke.verify(); )
1536 
1537   // Find the compiled caller frame.
1538   RegisterMap reg_map(thread);
1539   frame stubFrame = thread-&gt;last_frame();
1540   assert(stubFrame.is_runtime_frame(), &quot;must be&quot;);
1541   frame callerFrame = stubFrame.sender(&amp;reg_map);
1542   assert(callerFrame.is_compiled_frame(), &quot;must be&quot;);
1543 
1544   // Install exception and return forward entry.
1545   address res = StubRoutines::throw_AbstractMethodError_entry();
1546   JRT_BLOCK
1547     methodHandle callee(thread, invoke.static_target(thread));
1548     if (!callee.is_null()) {
1549       oop recv = callerFrame.retrieve_receiver(&amp;reg_map);
1550       Klass *recv_klass = (recv != NULL) ? recv-&gt;klass() : NULL;
1551       LinkResolver::throw_abstract_method_error(callee, recv_klass, thread);
1552       res = StubRoutines::forward_exception_entry();
1553     }
1554   JRT_BLOCK_END
1555   return res;
1556 JRT_END
1557 
1558 
1559 // resolve a static call and patch code
1560 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_static_call_C(JavaThread *thread ))
1561   methodHandle callee_method;
1562   bool caller_is_c1;
1563   JRT_BLOCK
1564     callee_method = SharedRuntime::resolve_helper(thread, false, false, &amp;caller_is_c1, CHECK_NULL);
1565     thread-&gt;set_vm_result_2(callee_method());
1566   JRT_BLOCK_END
1567   // return compiled code entry point after potential safepoints
1568   address entry = caller_is_c1 ?
1569     callee_method-&gt;verified_value_code_entry() : callee_method-&gt;verified_code_entry();
1570   assert(entry != NULL, &quot;Jump to zero!&quot;);
1571   return entry;
1572 JRT_END
1573 
1574 
1575 // resolve virtual call and update inline cache to monomorphic
1576 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_virtual_call_C(JavaThread *thread ))
1577   methodHandle callee_method;
1578   bool caller_is_c1;
1579   JRT_BLOCK
1580     callee_method = SharedRuntime::resolve_helper(thread, true, false, &amp;caller_is_c1, CHECK_NULL);
1581     thread-&gt;set_vm_result_2(callee_method());
1582   JRT_BLOCK_END
1583   // return compiled code entry point after potential safepoints
1584   address entry = caller_is_c1 ?
1585     callee_method-&gt;verified_value_code_entry() : callee_method-&gt;verified_value_ro_code_entry();
1586   assert(entry != NULL, &quot;Jump to zero!&quot;);
1587   return entry;
1588 JRT_END
1589 
1590 
1591 // Resolve a virtual call that can be statically bound (e.g., always
1592 // monomorphic, so it has no inline cache).  Patch code to resolved target.
1593 JRT_BLOCK_ENTRY(address, SharedRuntime::resolve_opt_virtual_call_C(JavaThread *thread))
1594   methodHandle callee_method;
1595   bool caller_is_c1;
1596   JRT_BLOCK
1597     callee_method = SharedRuntime::resolve_helper(thread, true, true, &amp;caller_is_c1, CHECK_NULL);
1598     thread-&gt;set_vm_result_2(callee_method());
1599   JRT_BLOCK_END
1600   // return compiled code entry point after potential safepoints
1601   address entry = caller_is_c1 ?
1602     callee_method-&gt;verified_value_code_entry() : callee_method-&gt;verified_code_entry();
1603   assert(entry != NULL, &quot;Jump to zero!&quot;);
1604   return entry;
1605 JRT_END
1606 
1607 // The handle_ic_miss_helper_internal function returns false if it failed due
1608 // to either running out of vtable stubs or ic stubs due to IC transitions
1609 // to transitional states. The needs_ic_stub_refill value will be set if
1610 // the failure was due to running out of IC stubs, in which case handle_ic_miss_helper
1611 // refills the IC stubs and tries again.
1612 bool SharedRuntime::handle_ic_miss_helper_internal(Handle receiver, CompiledMethod* caller_nm,
1613                                                    const frame&amp; caller_frame, methodHandle callee_method,
1614                                                    Bytecodes::Code bc, CallInfo&amp; call_info,
1615                                                    bool&amp; needs_ic_stub_refill, bool&amp; is_optimized, bool caller_is_c1, TRAPS) {
1616   CompiledICLocker ml(caller_nm);
1617   CompiledIC* inline_cache = CompiledIC_before(caller_nm, caller_frame.pc());
1618   bool should_be_mono = false;
1619   if (inline_cache-&gt;is_optimized()) {
1620     if (TraceCallFixup) {
1621       ResourceMark rm(THREAD);
1622       tty-&gt;print(&quot;OPTIMIZED IC miss (%s) call to&quot;, Bytecodes::name(bc));
1623       callee_method-&gt;print_short_name(tty);
1624       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1625     }
1626     is_optimized = true;
1627     should_be_mono = true;
1628   } else if (inline_cache-&gt;is_icholder_call()) {
1629     CompiledICHolder* ic_oop = inline_cache-&gt;cached_icholder();
1630     if (ic_oop != NULL) {
1631       if (!ic_oop-&gt;is_loader_alive()) {
1632         // Deferred IC cleaning due to concurrent class unloading
1633         if (!inline_cache-&gt;set_to_clean()) {
1634           needs_ic_stub_refill = true;
1635           return false;
1636         }
1637       } else if (receiver()-&gt;klass() == ic_oop-&gt;holder_klass()) {
1638         // This isn&#39;t a real miss. We must have seen that compiled code
1639         // is now available and we want the call site converted to a
1640         // monomorphic compiled call site.
1641         // We can&#39;t assert for callee_method-&gt;code() != NULL because it
1642         // could have been deoptimized in the meantime
1643         if (TraceCallFixup) {
1644           ResourceMark rm(THREAD);
1645           tty-&gt;print(&quot;FALSE IC miss (%s) converting to compiled call to&quot;, Bytecodes::name(bc));
1646           callee_method-&gt;print_short_name(tty);
1647           tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1648         }
1649         should_be_mono = true;
1650       }
1651     }
1652   }
1653 
1654   if (should_be_mono) {
1655     // We have a path that was monomorphic but was going interpreted
1656     // and now we have (or had) a compiled entry. We correct the IC
1657     // by using a new icBuffer.
1658     CompiledICInfo info;
1659     Klass* receiver_klass = receiver()-&gt;klass();
1660     inline_cache-&gt;compute_monomorphic_entry(callee_method,
1661                                             receiver_klass,
1662                                             inline_cache-&gt;is_optimized(),
1663                                             false, caller_nm-&gt;is_nmethod(),
1664                                             caller_nm-&gt;is_compiled_by_c1(),
1665                                             info, CHECK_false);
1666     if (!inline_cache-&gt;set_to_monomorphic(info)) {
1667       needs_ic_stub_refill = true;
1668       return false;
1669     }
1670   } else if (!inline_cache-&gt;is_megamorphic() &amp;&amp; !inline_cache-&gt;is_clean()) {
1671     // Potential change to megamorphic
1672 
1673     bool successful = inline_cache-&gt;set_to_megamorphic(&amp;call_info, bc, needs_ic_stub_refill, caller_is_c1, CHECK_false);
1674     if (needs_ic_stub_refill) {
1675       return false;
1676     }
1677     if (!successful) {
1678       if (!inline_cache-&gt;set_to_clean()) {
1679         needs_ic_stub_refill = true;
1680         return false;
1681       }
1682     }
1683   } else {
1684     // Either clean or megamorphic
1685   }
1686   return true;
1687 }
1688 
1689 methodHandle SharedRuntime::handle_ic_miss_helper(JavaThread *thread, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS) {
1690   ResourceMark rm(thread);
1691   CallInfo call_info;
1692   Bytecodes::Code bc;
1693 
1694   // receiver is NULL for static calls. An exception is thrown for NULL
1695   // receivers for non-static calls
1696   Handle receiver = find_callee_info(thread, bc, call_info,
1697                                      CHECK_(methodHandle()));
1698   // Compiler1 can produce virtual call sites that can actually be statically bound
1699   // If we fell thru to below we would think that the site was going megamorphic
1700   // when in fact the site can never miss. Worse because we&#39;d think it was megamorphic
1701   // we&#39;d try and do a vtable dispatch however methods that can be statically bound
1702   // don&#39;t have vtable entries (vtable_index &lt; 0) and we&#39;d blow up. So we force a
1703   // reresolution of the  call site (as if we did a handle_wrong_method and not an
1704   // plain ic_miss) and the site will be converted to an optimized virtual call site
1705   // never to miss again. I don&#39;t believe C2 will produce code like this but if it
1706   // did this would still be the correct thing to do for it too, hence no ifdef.
1707   //
1708   if (call_info.resolved_method()-&gt;can_be_statically_bound()) {
1709     bool is_static_call = false;
1710     methodHandle callee_method = SharedRuntime::reresolve_call_site(thread, is_static_call, is_optimized, caller_is_c1, CHECK_(methodHandle()));
1711     assert(!is_static_call, &quot;IC miss at static call?&quot;);
1712     if (TraceCallFixup) {
1713       RegisterMap reg_map(thread, false);
1714       frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1715       ResourceMark rm(thread);
1716       tty-&gt;print(&quot;converting IC miss to reresolve (%s) call to&quot;, Bytecodes::name(bc));
1717       callee_method-&gt;print_short_name(tty);
1718       tty-&gt;print_cr(&quot; from pc: &quot; INTPTR_FORMAT, p2i(caller_frame.pc()));
1719       tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1720     }
1721     return callee_method;
1722   }
1723 
1724   methodHandle callee_method(thread, call_info.selected_method());
1725 
1726 #ifndef PRODUCT
1727   Atomic::inc(&amp;_ic_miss_ctr);
1728 
1729   // Statistics &amp; Tracing
1730   if (TraceCallFixup) {
1731     ResourceMark rm(thread);
1732     tty-&gt;print(&quot;IC miss (%s) call to&quot;, Bytecodes::name(bc));
1733     callee_method-&gt;print_short_name(tty);
1734     tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1735   }
1736 
1737   if (ICMissHistogram) {
1738     MutexLocker m(VMStatistic_lock);
1739     RegisterMap reg_map(thread, false);
1740     frame f = thread-&gt;last_frame().real_sender(&amp;reg_map);// skip runtime stub
1741     // produce statistics under the lock
1742     trace_ic_miss(f.pc());
1743   }
1744 #endif
1745 
1746   // install an event collector so that when a vtable stub is created the
1747   // profiler can be notified via a DYNAMIC_CODE_GENERATED event. The
1748   // event can&#39;t be posted when the stub is created as locks are held
1749   // - instead the event will be deferred until the event collector goes
1750   // out of scope.
1751   JvmtiDynamicCodeEventCollector event_collector;
1752 
1753   // Update inline cache to megamorphic. Skip update if we are called from interpreted.
1754   // Transitioning IC caches may require transition stubs. If we run out
1755   // of transition stubs, we have to drop locks and perform a safepoint
1756   // that refills them.
1757   RegisterMap reg_map(thread, false);
1758   frame caller_frame = thread-&gt;last_frame().sender(&amp;reg_map);
1759   CodeBlob* cb = caller_frame.cb();
1760   CompiledMethod* caller_nm = cb-&gt;as_compiled_method();
1761   caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
1762 
1763   for (;;) {
1764     ICRefillVerifier ic_refill_verifier;
1765     bool needs_ic_stub_refill = false;
1766     bool successful = handle_ic_miss_helper_internal(receiver, caller_nm, caller_frame, callee_method,
1767                                                      bc, call_info, needs_ic_stub_refill, is_optimized, caller_is_c1, CHECK_(methodHandle()));
1768     if (successful || !needs_ic_stub_refill) {
1769       return callee_method;
1770     } else {
1771       InlineCacheBuffer::refill_ic_stubs();
1772     }
1773   }
1774 }
1775 
1776 static bool clear_ic_at_addr(CompiledMethod* caller_nm, address call_addr, bool is_static_call) {
1777   CompiledICLocker ml(caller_nm);
1778   if (is_static_call) {
1779     CompiledStaticCall* ssc = caller_nm-&gt;compiledStaticCall_at(call_addr);
1780     if (!ssc-&gt;is_clean()) {
1781       return ssc-&gt;set_to_clean();
1782     }
1783   } else {
1784     // compiled, dispatched call (which used to call an interpreted method)
1785     CompiledIC* inline_cache = CompiledIC_at(caller_nm, call_addr);
1786     if (!inline_cache-&gt;is_clean()) {
1787       return inline_cache-&gt;set_to_clean();
1788     }
1789   }
1790   return true;
1791 }
1792 
1793 //
1794 // Resets a call-site in compiled code so it will get resolved again.
1795 // This routines handles both virtual call sites, optimized virtual call
1796 // sites, and static call sites. Typically used to change a call sites
1797 // destination from compiled to interpreted.
1798 //
1799 methodHandle SharedRuntime::reresolve_call_site(JavaThread *thread, bool&amp; is_static_call, bool&amp; is_optimized, bool&amp; caller_is_c1, TRAPS) {
1800   ResourceMark rm(thread);
1801   RegisterMap reg_map(thread, false);
1802   frame stub_frame = thread-&gt;last_frame();
1803   assert(stub_frame.is_runtime_frame(), &quot;must be a runtimeStub&quot;);
1804   frame caller = stub_frame.sender(&amp;reg_map);
1805 
1806   // Do nothing if the frame isn&#39;t a live compiled frame.
1807   // nmethod could be deoptimized by the time we get here
1808   // so no update to the caller is needed.
1809 
1810   if (caller.is_compiled_frame() &amp;&amp; !caller.is_deoptimized_frame()) {
1811 
1812     address pc = caller.pc();
1813 
1814     // Check for static or virtual call
1815     CompiledMethod* caller_nm = CodeCache::find_compiled(pc);
1816     caller_is_c1 = caller_nm-&gt;is_compiled_by_c1();
1817 
1818     // Default call_addr is the location of the &quot;basic&quot; call.
1819     // Determine the address of the call we a reresolving. With
1820     // Inline Caches we will always find a recognizable call.
1821     // With Inline Caches disabled we may or may not find a
1822     // recognizable call. We will always find a call for static
1823     // calls and for optimized virtual calls. For vanilla virtual
1824     // calls it depends on the state of the UseInlineCaches switch.
1825     //
1826     // With Inline Caches disabled we can get here for a virtual call
1827     // for two reasons:
1828     //   1 - calling an abstract method. The vtable for abstract methods
1829     //       will run us thru handle_wrong_method and we will eventually
1830     //       end up in the interpreter to throw the ame.
1831     //   2 - a racing deoptimization. We could be doing a vanilla vtable
1832     //       call and between the time we fetch the entry address and
1833     //       we jump to it the target gets deoptimized. Similar to 1
1834     //       we will wind up in the interprter (thru a c2i with c2).
1835     //
1836     address call_addr = NULL;
1837     {
1838       // Get call instruction under lock because another thread may be
1839       // busy patching it.
1840       CompiledICLocker ml(caller_nm);
1841       // Location of call instruction
1842       call_addr = caller_nm-&gt;call_instruction_address(pc);
1843     }
1844     // Make sure nmethod doesn&#39;t get deoptimized and removed until
1845     // this is done with it.
1846     // CLEANUP - with lazy deopt shouldn&#39;t need this lock
1847     nmethodLocker nmlock(caller_nm);
1848 
1849     if (call_addr != NULL) {
1850       RelocIterator iter(caller_nm, call_addr, call_addr+1);
1851       int ret = iter.next(); // Get item
1852       if (ret) {
1853         assert(iter.addr() == call_addr, &quot;must find call&quot;);
1854         if (iter.type() == relocInfo::static_call_type) {
1855           is_static_call = true;
1856         } else {
1857           assert(iter.type() == relocInfo::virtual_call_type ||
1858                  iter.type() == relocInfo::opt_virtual_call_type
1859                 , &quot;unexpected relocInfo. type&quot;);
1860           is_optimized = (iter.type() == relocInfo::opt_virtual_call_type);
1861         }
1862       } else {
1863         assert(!UseInlineCaches, &quot;relocation info. must exist for this address&quot;);
1864       }
1865 
1866       // Cleaning the inline cache will force a new resolve. This is more robust
1867       // than directly setting it to the new destination, since resolving of calls
1868       // is always done through the same code path. (experience shows that it
1869       // leads to very hard to track down bugs, if an inline cache gets updated
1870       // to a wrong method). It should not be performance critical, since the
1871       // resolve is only done once.
1872 
1873       for (;;) {
1874         ICRefillVerifier ic_refill_verifier;
1875         if (!clear_ic_at_addr(caller_nm, call_addr, is_static_call)) {
1876           InlineCacheBuffer::refill_ic_stubs();
1877         } else {
1878           break;
1879         }
1880       }
1881     }
1882   }
1883 
1884   methodHandle callee_method = find_callee_method(thread, CHECK_(methodHandle()));
1885 
1886 #ifndef PRODUCT
1887   Atomic::inc(&amp;_wrong_method_ctr);
1888 
1889   if (TraceCallFixup) {
1890     ResourceMark rm(thread);
1891     tty-&gt;print(&quot;handle_wrong_method reresolving call to&quot;);
1892     callee_method-&gt;print_short_name(tty);
1893     tty-&gt;print_cr(&quot; code: &quot; INTPTR_FORMAT, p2i(callee_method-&gt;code()));
1894   }
1895 #endif
1896 
1897   return callee_method;
1898 }
1899 
1900 address SharedRuntime::handle_unsafe_access(JavaThread* thread, address next_pc) {
1901   // The faulting unsafe accesses should be changed to throw the error
1902   // synchronously instead. Meanwhile the faulting instruction will be
1903   // skipped over (effectively turning it into a no-op) and an
1904   // asynchronous exception will be raised which the thread will
1905   // handle at a later point. If the instruction is a load it will
1906   // return garbage.
1907 
1908   // Request an async exception.
1909   thread-&gt;set_pending_unsafe_access_error();
1910 
1911   // Return address of next instruction to execute.
1912   return next_pc;
1913 }
1914 
1915 #ifdef ASSERT
1916 void SharedRuntime::check_member_name_argument_is_last_argument(const methodHandle&amp; method,
1917                                                                 const BasicType* sig_bt,
1918                                                                 const VMRegPair* regs) {
1919   ResourceMark rm;
1920   const int total_args_passed = method-&gt;size_of_parameters();
1921   const VMRegPair*    regs_with_member_name = regs;
1922         VMRegPair* regs_without_member_name = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed - 1);
1923 
1924   const int member_arg_pos = total_args_passed - 1;
1925   assert(member_arg_pos &gt;= 0 &amp;&amp; member_arg_pos &lt; total_args_passed, &quot;oob&quot;);
1926   assert(sig_bt[member_arg_pos] == T_OBJECT, &quot;dispatch argument must be an object&quot;);
1927 
1928   const bool is_outgoing = method-&gt;is_method_handle_intrinsic();
1929   int comp_args_on_stack = java_calling_convention(sig_bt, regs_without_member_name, total_args_passed - 1, is_outgoing);
1930 
1931   for (int i = 0; i &lt; member_arg_pos; i++) {
1932     VMReg a =    regs_with_member_name[i].first();
1933     VMReg b = regs_without_member_name[i].first();
1934     assert(a-&gt;value() == b-&gt;value(), &quot;register allocation mismatch: a=&quot; INTX_FORMAT &quot;, b=&quot; INTX_FORMAT, a-&gt;value(), b-&gt;value());
1935   }
1936   assert(regs_with_member_name[member_arg_pos].first()-&gt;is_valid(), &quot;bad member arg&quot;);
1937 }
1938 #endif
1939 
1940 bool SharedRuntime::should_fixup_call_destination(address destination, address entry_point, address caller_pc, Method* moop, CodeBlob* cb) {
1941   if (destination != entry_point) {
1942     CodeBlob* callee = CodeCache::find_blob(destination);
1943     // callee == cb seems weird. It means calling interpreter thru stub.
1944     if (callee != NULL &amp;&amp; (callee == cb || callee-&gt;is_adapter_blob())) {
1945       // static call or optimized virtual
1946       if (TraceCallFixup) {
1947         tty-&gt;print(&quot;fixup callsite           at &quot; INTPTR_FORMAT &quot; to compiled code for&quot;, p2i(caller_pc));
1948         moop-&gt;print_short_name(tty);
1949         tty-&gt;print_cr(&quot; to &quot; INTPTR_FORMAT, p2i(entry_point));
1950       }
1951       return true;
1952     } else {
1953       if (TraceCallFixup) {
1954         tty-&gt;print(&quot;failed to fixup callsite at &quot; INTPTR_FORMAT &quot; to compiled code for&quot;, p2i(caller_pc));
1955         moop-&gt;print_short_name(tty);
1956         tty-&gt;print_cr(&quot; to &quot; INTPTR_FORMAT, p2i(entry_point));
1957       }
1958       // assert is too strong could also be resolve destinations.
1959       // assert(InlineCacheBuffer::contains(destination) || VtableStubs::contains(destination), &quot;must be&quot;);
1960     }
1961   } else {
1962     if (TraceCallFixup) {
1963       tty-&gt;print(&quot;already patched callsite at &quot; INTPTR_FORMAT &quot; to compiled code for&quot;, p2i(caller_pc));
1964       moop-&gt;print_short_name(tty);
1965       tty-&gt;print_cr(&quot; to &quot; INTPTR_FORMAT, p2i(entry_point));
1966     }
1967   }
1968   return false;
1969 }
1970 
1971 // ---------------------------------------------------------------------------
1972 // We are calling the interpreter via a c2i. Normally this would mean that
1973 // we were called by a compiled method. However we could have lost a race
1974 // where we went int -&gt; i2c -&gt; c2i and so the caller could in fact be
1975 // interpreted. If the caller is compiled we attempt to patch the caller
1976 // so he no longer calls into the interpreter.
1977 JRT_LEAF(void, SharedRuntime::fixup_callers_callsite(Method* method, address caller_pc))
1978   Method* moop(method);
1979 
1980   // It&#39;s possible that deoptimization can occur at a call site which hasn&#39;t
1981   // been resolved yet, in which case this function will be called from
1982   // an nmethod that has been patched for deopt and we can ignore the
1983   // request for a fixup.
1984   // Also it is possible that we lost a race in that from_compiled_entry
1985   // is now back to the i2c in that case we don&#39;t need to patch and if
1986   // we did we&#39;d leap into space because the callsite needs to use
1987   // &quot;to interpreter&quot; stub in order to load up the Method*. Don&#39;t
1988   // ask me how I know this...
1989 
1990   CodeBlob* cb = CodeCache::find_blob(caller_pc);
1991   if (cb == NULL || !cb-&gt;is_compiled()) {
1992     return;
1993   }
1994   address entry_point = moop-&gt;from_compiled_entry_no_trampoline(cb-&gt;is_compiled_by_c1());
1995   if (entry_point == moop-&gt;get_c2i_entry()) {
1996     return;
1997   }
1998 
1999   // The check above makes sure this is a nmethod.
2000   CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
2001   assert(nm, &quot;must be&quot;);
2002 
2003   // Get the return PC for the passed caller PC.
2004   address return_pc = caller_pc + frame::pc_return_offset;
2005 
2006   // There is a benign race here. We could be attempting to patch to a compiled
2007   // entry point at the same time the callee is being deoptimized. If that is
2008   // the case then entry_point may in fact point to a c2i and we&#39;d patch the
2009   // call site with the same old data. clear_code will set code() to NULL
2010   // at the end of it. If we happen to see that NULL then we can skip trying
2011   // to patch. If we hit the window where the callee has a c2i in the
2012   // from_compiled_entry and the NULL isn&#39;t present yet then we lose the race
2013   // and patch the code with the same old data. Asi es la vida.
2014 
2015   if (moop-&gt;code() == NULL) return;
2016 
2017   if (nm-&gt;is_in_use()) {
2018     // Expect to find a native call there (unless it was no-inline cache vtable dispatch)
2019     CompiledICLocker ic_locker(nm);
2020     if (NativeCall::is_call_before(return_pc)) {
2021       ResourceMark mark;
2022       NativeCallWrapper* call = nm-&gt;call_wrapper_before(return_pc);
2023       //
2024       // bug 6281185. We might get here after resolving a call site to a vanilla
2025       // virtual call. Because the resolvee uses the verified entry it may then
2026       // see compiled code and attempt to patch the site by calling us. This would
2027       // then incorrectly convert the call site to optimized and its downhill from
2028       // there. If you&#39;re lucky you&#39;ll get the assert in the bugid, if not you&#39;ve
2029       // just made a call site that could be megamorphic into a monomorphic site
2030       // for the rest of its life! Just another racing bug in the life of
2031       // fixup_callers_callsite ...
2032       //
2033       RelocIterator iter(nm, call-&gt;instruction_address(), call-&gt;next_instruction_address());
2034       iter.next();
2035       assert(iter.has_current(), &quot;must have a reloc at java call site&quot;);
2036       relocInfo::relocType typ = iter.reloc()-&gt;type();
2037       if (typ != relocInfo::static_call_type &amp;&amp;
2038            typ != relocInfo::opt_virtual_call_type &amp;&amp;
2039            typ != relocInfo::static_stub_type) {
2040         return;
2041       }
2042       address destination = call-&gt;destination();
2043       if (should_fixup_call_destination(destination, entry_point, caller_pc, moop, cb)) {
2044         call-&gt;set_destination_mt_safe(entry_point);
2045       }
2046     }
2047   }
2048 JRT_END
2049 
2050 
2051 // same as JVM_Arraycopy, but called directly from compiled code
2052 JRT_ENTRY(void, SharedRuntime::slow_arraycopy_C(oopDesc* src,  jint src_pos,
2053                                                 oopDesc* dest, jint dest_pos,
2054                                                 jint length,
2055                                                 JavaThread* thread)) {
2056 #ifndef PRODUCT
2057   _slow_array_copy_ctr++;
2058 #endif
2059   // Check if we have null pointers
2060   if (src == NULL || dest == NULL) {
2061     THROW(vmSymbols::java_lang_NullPointerException());
2062   }
2063   // Do the copy.  The casts to arrayOop are necessary to the copy_array API,
2064   // even though the copy_array API also performs dynamic checks to ensure
2065   // that src and dest are truly arrays (and are conformable).
2066   // The copy_array mechanism is awkward and could be removed, but
2067   // the compilers don&#39;t call this function except as a last resort,
2068   // so it probably doesn&#39;t matter.
2069   src-&gt;klass()-&gt;copy_array((arrayOopDesc*)src, src_pos,
2070                                         (arrayOopDesc*)dest, dest_pos,
2071                                         length, thread);
2072 }
2073 JRT_END
2074 
2075 // The caller of generate_class_cast_message() (or one of its callers)
2076 // must use a ResourceMark in order to correctly free the result.
2077 char* SharedRuntime::generate_class_cast_message(
2078     JavaThread* thread, Klass* caster_klass) {
2079 
2080   // Get target class name from the checkcast instruction
2081   vframeStream vfst(thread, true);
2082   assert(!vfst.at_end(), &quot;Java frame must exist&quot;);
2083   Bytecode_checkcast cc(vfst.method(), vfst.method()-&gt;bcp_from(vfst.bci()));
2084   constantPoolHandle cpool(thread, vfst.method()-&gt;constants());
2085   Klass* target_klass = ConstantPool::klass_at_if_loaded(cpool, cc.index());
2086   Symbol* target_klass_name = NULL;
2087   if (target_klass == NULL) {
2088     // This klass should be resolved, but just in case, get the name in the klass slot.
2089     target_klass_name = cpool-&gt;klass_name_at(cc.index());
2090   }
2091   return generate_class_cast_message(caster_klass, target_klass, target_klass_name);
2092 }
2093 
2094 
2095 // The caller of generate_class_cast_message() (or one of its callers)
2096 // must use a ResourceMark in order to correctly free the result.
2097 char* SharedRuntime::generate_class_cast_message(
2098     Klass* caster_klass, Klass* target_klass, Symbol* target_klass_name) {
2099   const char* caster_name = caster_klass-&gt;external_name();
2100 
2101   assert(target_klass != NULL || target_klass_name != NULL, &quot;one must be provided&quot;);
2102   const char* target_name = target_klass == NULL ? target_klass_name-&gt;as_klass_external_name() :
2103                                                    target_klass-&gt;external_name();
2104 
2105   size_t msglen = strlen(caster_name) + strlen(&quot;class &quot;) + strlen(&quot; cannot be cast to class &quot;) + strlen(target_name) + 1;
2106 
2107   const char* caster_klass_description = &quot;&quot;;
2108   const char* target_klass_description = &quot;&quot;;
2109   const char* klass_separator = &quot;&quot;;
2110   if (target_klass != NULL &amp;&amp; caster_klass-&gt;module() == target_klass-&gt;module()) {
2111     caster_klass_description = caster_klass-&gt;joint_in_module_of_loader(target_klass);
2112   } else {
2113     caster_klass_description = caster_klass-&gt;class_in_module_of_loader();
2114     target_klass_description = (target_klass != NULL) ? target_klass-&gt;class_in_module_of_loader() : &quot;&quot;;
2115     klass_separator = (target_klass != NULL) ? &quot;; &quot; : &quot;&quot;;
2116   }
2117 
2118   // add 3 for parenthesis and preceeding space
2119   msglen += strlen(caster_klass_description) + strlen(target_klass_description) + strlen(klass_separator) + 3;
2120 
2121   char* message = NEW_RESOURCE_ARRAY_RETURN_NULL(char, msglen);
2122   if (message == NULL) {
2123     // Shouldn&#39;t happen, but don&#39;t cause even more problems if it does
2124     message = const_cast&lt;char*&gt;(caster_klass-&gt;external_name());
2125   } else {
2126     jio_snprintf(message,
2127                  msglen,
2128                  &quot;class %s cannot be cast to class %s (%s%s%s)&quot;,
2129                  caster_name,
2130                  target_name,
2131                  caster_klass_description,
2132                  klass_separator,
2133                  target_klass_description
2134                  );
2135   }
2136   return message;
2137 }
2138 
2139 JRT_LEAF(void, SharedRuntime::reguard_yellow_pages())
2140   (void) JavaThread::current()-&gt;reguard_stack();
2141 JRT_END
2142 
<a name="1" id="anc1"></a><span class="line-modified">2143 </span>
<span class="line-removed">2144 // Handles the uncommon case in locking, i.e., contention or an inflated lock.</span>
<span class="line-removed">2145 JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* _obj, BasicLock* lock, JavaThread* thread))</span>
2146   if (!SafepointSynchronize::is_synchronizing()) {
2147     // Only try quick_enter() if we&#39;re not trying to reach a safepoint
2148     // so that the calling thread reaches the safepoint more quickly.
<a name="2" id="anc2"></a><span class="line-modified">2149     if (ObjectSynchronizer::quick_enter(_obj, thread, lock)) return;</span>
2150   }
2151   // NO_ASYNC required because an async exception on the state transition destructor
2152   // would leave you with the lock held and it would never be released.
2153   // The normal monitorenter NullPointerException is thrown without acquiring a lock
2154   // and the model is that an exception implies the method failed.
2155   JRT_BLOCK_NO_ASYNC
<a name="3" id="anc3"></a><span class="line-removed">2156   oop obj(_obj);</span>
2157   if (PrintBiasedLockingStatistics) {
2158     Atomic::inc(BiasedLocking::slow_path_entry_count_addr());
2159   }
2160   Handle h_obj(THREAD, obj);
2161   ObjectSynchronizer::enter(h_obj, lock, CHECK);
2162   assert(!HAS_PENDING_EXCEPTION, &quot;Should have no exception here&quot;);
2163   JRT_BLOCK_END
<a name="4" id="anc4"></a><span class="line-modified">2164 JRT_END</span>
2165 
<a name="5" id="anc5"></a><span class="line-modified">2166 // Handles the uncommon cases of monitor unlocking in compiled code</span>
<span class="line-modified">2167 JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* _obj, BasicLock* lock, JavaThread * THREAD))</span>
<span class="line-modified">2168    oop obj(_obj);</span>
<span class="line-modified">2169   assert(JavaThread::current() == THREAD, &quot;invariant&quot;);</span>
<span class="line-removed">2170   // I&#39;m not convinced we need the code contained by MIGHT_HAVE_PENDING anymore</span>
<span class="line-removed">2171   // testing was unable to ever fire the assert that guarded it so I have removed it.</span>
<span class="line-removed">2172   assert(!HAS_PENDING_EXCEPTION, &quot;Do we need code below anymore?&quot;);</span>
<span class="line-removed">2173 #undef MIGHT_HAVE_PENDING</span>
<span class="line-removed">2174 #ifdef MIGHT_HAVE_PENDING</span>
<span class="line-removed">2175   // Save and restore any pending_exception around the exception mark.</span>
<span class="line-removed">2176   // While the slow_exit must not throw an exception, we could come into</span>
<span class="line-removed">2177   // this routine with one set.</span>
<span class="line-removed">2178   oop pending_excep = NULL;</span>
<span class="line-removed">2179   const char* pending_file;</span>
<span class="line-removed">2180   int pending_line;</span>
<span class="line-removed">2181   if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-removed">2182     pending_excep = PENDING_EXCEPTION;</span>
<span class="line-removed">2183     pending_file  = THREAD-&gt;exception_file();</span>
<span class="line-removed">2184     pending_line  = THREAD-&gt;exception_line();</span>
<span class="line-removed">2185     CLEAR_PENDING_EXCEPTION;</span>
<span class="line-removed">2186   }</span>
<span class="line-removed">2187 #endif /* MIGHT_HAVE_PENDING */</span>
2188 
<a name="6" id="anc6"></a><span class="line-modified">2189   {</span>
<span class="line-modified">2190     // Exit must be non-blocking, and therefore no exceptions can be thrown.</span>
<span class="line-modified">2191     EXCEPTION_MARK;</span>
<span class="line-modified">2192     ObjectSynchronizer::exit(obj, lock, THREAD);</span>
<span class="line-modified">2193   }</span>

2194 
<a name="7" id="anc7"></a><span class="line-modified">2195 #ifdef MIGHT_HAVE_PENDING</span>
<span class="line-modified">2196   if (pending_excep != NULL) {</span>
<span class="line-modified">2197     THREAD-&gt;set_pending_exception(pending_excep, pending_file, pending_line);</span>
<span class="line-removed">2198   }</span>
<span class="line-removed">2199 #endif /* MIGHT_HAVE_PENDING */</span>
2200 JRT_END
2201 
2202 #ifndef PRODUCT
2203 
2204 void SharedRuntime::print_statistics() {
2205   ttyLocker ttyl;
2206   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;SharedRuntime&#39;&quot;);
2207 
2208   if (_throw_null_ctr) tty-&gt;print_cr(&quot;%5d implicit null throw&quot;, _throw_null_ctr);
2209 
2210   SharedRuntime::print_ic_miss_histogram();
2211 
2212   if (CountRemovableExceptions) {
2213     if (_nof_removable_exceptions &gt; 0) {
2214       Unimplemented(); // this counter is not yet incremented
2215       tty-&gt;print_cr(&quot;Removable exceptions: %d&quot;, _nof_removable_exceptions);
2216     }
2217   }
2218 
2219   // Dump the JRT_ENTRY counters
2220   if (_new_instance_ctr) tty-&gt;print_cr(&quot;%5d new instance requires GC&quot;, _new_instance_ctr);
2221   if (_new_array_ctr) tty-&gt;print_cr(&quot;%5d new array requires GC&quot;, _new_array_ctr);
2222   if (_multi1_ctr) tty-&gt;print_cr(&quot;%5d multianewarray 1 dim&quot;, _multi1_ctr);
2223   if (_multi2_ctr) tty-&gt;print_cr(&quot;%5d multianewarray 2 dim&quot;, _multi2_ctr);
2224   if (_multi3_ctr) tty-&gt;print_cr(&quot;%5d multianewarray 3 dim&quot;, _multi3_ctr);
2225   if (_multi4_ctr) tty-&gt;print_cr(&quot;%5d multianewarray 4 dim&quot;, _multi4_ctr);
2226   if (_multi5_ctr) tty-&gt;print_cr(&quot;%5d multianewarray 5 dim&quot;, _multi5_ctr);
2227 
2228   tty-&gt;print_cr(&quot;%5d inline cache miss in compiled&quot;, _ic_miss_ctr);
2229   tty-&gt;print_cr(&quot;%5d wrong method&quot;, _wrong_method_ctr);
2230   tty-&gt;print_cr(&quot;%5d unresolved static call site&quot;, _resolve_static_ctr);
2231   tty-&gt;print_cr(&quot;%5d unresolved virtual call site&quot;, _resolve_virtual_ctr);
2232   tty-&gt;print_cr(&quot;%5d unresolved opt virtual call site&quot;, _resolve_opt_virtual_ctr);
2233 
2234   if (_mon_enter_stub_ctr) tty-&gt;print_cr(&quot;%5d monitor enter stub&quot;, _mon_enter_stub_ctr);
2235   if (_mon_exit_stub_ctr) tty-&gt;print_cr(&quot;%5d monitor exit stub&quot;, _mon_exit_stub_ctr);
2236   if (_mon_enter_ctr) tty-&gt;print_cr(&quot;%5d monitor enter slow&quot;, _mon_enter_ctr);
2237   if (_mon_exit_ctr) tty-&gt;print_cr(&quot;%5d monitor exit slow&quot;, _mon_exit_ctr);
2238   if (_partial_subtype_ctr) tty-&gt;print_cr(&quot;%5d slow partial subtype&quot;, _partial_subtype_ctr);
2239   if (_jbyte_array_copy_ctr) tty-&gt;print_cr(&quot;%5d byte array copies&quot;, _jbyte_array_copy_ctr);
2240   if (_jshort_array_copy_ctr) tty-&gt;print_cr(&quot;%5d short array copies&quot;, _jshort_array_copy_ctr);
2241   if (_jint_array_copy_ctr) tty-&gt;print_cr(&quot;%5d int array copies&quot;, _jint_array_copy_ctr);
2242   if (_jlong_array_copy_ctr) tty-&gt;print_cr(&quot;%5d long array copies&quot;, _jlong_array_copy_ctr);
2243   if (_oop_array_copy_ctr) tty-&gt;print_cr(&quot;%5d oop array copies&quot;, _oop_array_copy_ctr);
2244   if (_checkcast_array_copy_ctr) tty-&gt;print_cr(&quot;%5d checkcast array copies&quot;, _checkcast_array_copy_ctr);
2245   if (_unsafe_array_copy_ctr) tty-&gt;print_cr(&quot;%5d unsafe array copies&quot;, _unsafe_array_copy_ctr);
2246   if (_generic_array_copy_ctr) tty-&gt;print_cr(&quot;%5d generic array copies&quot;, _generic_array_copy_ctr);
2247   if (_slow_array_copy_ctr) tty-&gt;print_cr(&quot;%5d slow array copies&quot;, _slow_array_copy_ctr);
2248   if (_find_handler_ctr) tty-&gt;print_cr(&quot;%5d find exception handler&quot;, _find_handler_ctr);
2249   if (_rethrow_ctr) tty-&gt;print_cr(&quot;%5d rethrow handler&quot;, _rethrow_ctr);
2250 
2251   AdapterHandlerLibrary::print_statistics();
2252 
2253   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
2254 }
2255 
2256 inline double percent(int x, int y) {
2257   return 100.0 * x / MAX2(y, 1);
2258 }
2259 
2260 class MethodArityHistogram {
2261  public:
2262   enum { MAX_ARITY = 256 };
2263  private:
2264   static int _arity_histogram[MAX_ARITY];     // histogram of #args
2265   static int _size_histogram[MAX_ARITY];      // histogram of arg size in words
2266   static int _max_arity;                      // max. arity seen
2267   static int _max_size;                       // max. arg size seen
2268 
2269   static void add_method_to_histogram(nmethod* nm) {
2270     if (CompiledMethod::nmethod_access_is_safe(nm)) {
2271       Method* method = nm-&gt;method();
2272       ArgumentCount args(method-&gt;signature());
2273       int arity   = args.size() + (method-&gt;is_static() ? 0 : 1);
2274       int argsize = method-&gt;size_of_parameters();
2275       arity   = MIN2(arity, MAX_ARITY-1);
2276       argsize = MIN2(argsize, MAX_ARITY-1);
2277       int count = method-&gt;compiled_invocation_count();
2278       _arity_histogram[arity]  += count;
2279       _size_histogram[argsize] += count;
2280       _max_arity = MAX2(_max_arity, arity);
2281       _max_size  = MAX2(_max_size, argsize);
2282     }
2283   }
2284 
2285   void print_histogram_helper(int n, int* histo, const char* name) {
2286     const int N = MIN2(5, n);
2287     tty-&gt;print_cr(&quot;\nHistogram of call arity (incl. rcvr, calls to compiled methods only):&quot;);
2288     double sum = 0;
2289     double weighted_sum = 0;
2290     int i;
2291     for (i = 0; i &lt;= n; i++) { sum += histo[i]; weighted_sum += i*histo[i]; }
2292     double rest = sum;
2293     double percent = sum / 100;
2294     for (i = 0; i &lt;= N; i++) {
2295       rest -= histo[i];
2296       tty-&gt;print_cr(&quot;%4d: %7d (%5.1f%%)&quot;, i, histo[i], histo[i] / percent);
2297     }
2298     tty-&gt;print_cr(&quot;rest: %7d (%5.1f%%))&quot;, (int)rest, rest / percent);
2299     tty-&gt;print_cr(&quot;(avg. %s = %3.1f, max = %d)&quot;, name, weighted_sum / sum, n);
2300   }
2301 
2302   void print_histogram() {
2303     tty-&gt;print_cr(&quot;\nHistogram of call arity (incl. rcvr, calls to compiled methods only):&quot;);
2304     print_histogram_helper(_max_arity, _arity_histogram, &quot;arity&quot;);
2305     tty-&gt;print_cr(&quot;\nSame for parameter size (in words):&quot;);
2306     print_histogram_helper(_max_size, _size_histogram, &quot;size&quot;);
2307     tty-&gt;cr();
2308   }
2309 
2310  public:
2311   MethodArityHistogram() {
2312     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
2313     _max_arity = _max_size = 0;
2314     for (int i = 0; i &lt; MAX_ARITY; i++) _arity_histogram[i] = _size_histogram[i] = 0;
2315     CodeCache::nmethods_do(add_method_to_histogram);
2316     print_histogram();
2317   }
2318 };
2319 
2320 int MethodArityHistogram::_arity_histogram[MethodArityHistogram::MAX_ARITY];
2321 int MethodArityHistogram::_size_histogram[MethodArityHistogram::MAX_ARITY];
2322 int MethodArityHistogram::_max_arity;
2323 int MethodArityHistogram::_max_size;
2324 
2325 void SharedRuntime::print_call_statistics(int comp_total) {
2326   tty-&gt;print_cr(&quot;Calls from compiled code:&quot;);
2327   int total  = _nof_normal_calls + _nof_interface_calls + _nof_static_calls;
2328   int mono_c = _nof_normal_calls - _nof_optimized_calls - _nof_megamorphic_calls;
2329   int mono_i = _nof_interface_calls - _nof_optimized_interface_calls - _nof_megamorphic_interface_calls;
2330   tty-&gt;print_cr(&quot;\t%9d   (%4.1f%%) total non-inlined   &quot;, total, percent(total, total));
2331   tty-&gt;print_cr(&quot;\t%9d   (%4.1f%%) virtual calls       &quot;, _nof_normal_calls, percent(_nof_normal_calls, total));
2332   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   inlined          &quot;, _nof_inlined_calls, percent(_nof_inlined_calls, _nof_normal_calls));
2333   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   optimized        &quot;, _nof_optimized_calls, percent(_nof_optimized_calls, _nof_normal_calls));
2334   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   monomorphic      &quot;, mono_c, percent(mono_c, _nof_normal_calls));
2335   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   megamorphic      &quot;, _nof_megamorphic_calls, percent(_nof_megamorphic_calls, _nof_normal_calls));
2336   tty-&gt;print_cr(&quot;\t%9d   (%4.1f%%) interface calls     &quot;, _nof_interface_calls, percent(_nof_interface_calls, total));
2337   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   inlined          &quot;, _nof_inlined_interface_calls, percent(_nof_inlined_interface_calls, _nof_interface_calls));
2338   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   optimized        &quot;, _nof_optimized_interface_calls, percent(_nof_optimized_interface_calls, _nof_interface_calls));
2339   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   monomorphic      &quot;, mono_i, percent(mono_i, _nof_interface_calls));
2340   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   megamorphic      &quot;, _nof_megamorphic_interface_calls, percent(_nof_megamorphic_interface_calls, _nof_interface_calls));
2341   tty-&gt;print_cr(&quot;\t%9d   (%4.1f%%) static/special calls&quot;, _nof_static_calls, percent(_nof_static_calls, total));
2342   tty-&gt;print_cr(&quot;\t  %9d  (%3.0f%%)   inlined          &quot;, _nof_inlined_static_calls, percent(_nof_inlined_static_calls, _nof_static_calls));
2343   tty-&gt;cr();
2344   tty-&gt;print_cr(&quot;Note 1: counter updates are not MT-safe.&quot;);
2345   tty-&gt;print_cr(&quot;Note 2: %% in major categories are relative to total non-inlined calls;&quot;);
2346   tty-&gt;print_cr(&quot;        %% in nested categories are relative to their category&quot;);
2347   tty-&gt;print_cr(&quot;        (and thus add up to more than 100%% with inlining)&quot;);
2348   tty-&gt;cr();
2349 
2350   MethodArityHistogram h;
2351 }
2352 #endif
2353 
2354 
2355 // A simple wrapper class around the calling convention information
2356 // that allows sharing of adapters for the same calling convention.
2357 class AdapterFingerPrint : public CHeapObj&lt;mtCode&gt; {
2358  private:
2359   enum {
2360     _basic_type_bits = 4,
2361     _basic_type_mask = right_n_bits(_basic_type_bits),
2362     _basic_types_per_int = BitsPerInt / _basic_type_bits,
2363     _compact_int_count = 3
2364   };
2365   // TO DO:  Consider integrating this with a more global scheme for compressing signatures.
2366   // For now, 4 bits per components (plus T_VOID gaps after double/long) is not excessive.
2367 
2368   union {
2369     int  _compact[_compact_int_count];
2370     int* _fingerprint;
2371   } _value;
2372   int _length; // A negative length indicates the fingerprint is in the compact form,
2373                // Otherwise _value._fingerprint is the array.
2374 
2375   // Remap BasicTypes that are handled equivalently by the adapters.
2376   // These are correct for the current system but someday it might be
2377   // necessary to make this mapping platform dependent.
2378   static int adapter_encoding(BasicType in, bool is_valuetype) {
2379     switch (in) {
2380       case T_BOOLEAN:
2381       case T_BYTE:
2382       case T_SHORT:
2383       case T_CHAR: {
2384         if (is_valuetype) {
2385           // Do not widen value type field types
2386           assert(ValueTypePassFieldsAsArgs, &quot;must be enabled&quot;);
2387           return in;
2388         } else {
2389           // They are all promoted to T_INT in the calling convention
2390           return T_INT;
2391         }
2392       }
2393 
2394       case T_VALUETYPE: {
2395         // If value types are passed as fields, return &#39;in&#39; to differentiate
2396         // between a T_VALUETYPE and a T_OBJECT in the signature.
2397         return ValueTypePassFieldsAsArgs ? in : adapter_encoding(T_OBJECT, false);
2398       }
2399 
2400       case T_OBJECT:
2401       case T_ARRAY:
2402         // In other words, we assume that any register good enough for
2403         // an int or long is good enough for a managed pointer.
2404 #ifdef _LP64
2405         return T_LONG;
2406 #else
2407         return T_INT;
2408 #endif
2409 
2410       case T_INT:
2411       case T_LONG:
2412       case T_FLOAT:
2413       case T_DOUBLE:
2414       case T_VOID:
2415         return in;
2416 
2417       default:
2418         ShouldNotReachHere();
2419         return T_CONFLICT;
2420     }
2421   }
2422 
2423  public:
2424   AdapterFingerPrint(const GrowableArray&lt;SigEntry&gt;* sig, bool has_ro_adapter = false) {
2425     // The fingerprint is based on the BasicType signature encoded
2426     // into an array of ints with eight entries per int.
2427     int total_args_passed = (sig != NULL) ? sig-&gt;length() : 0;
2428     int* ptr;
2429     int len = (total_args_passed + (_basic_types_per_int-1)) / _basic_types_per_int;
2430     if (len &lt;= _compact_int_count) {
2431       assert(_compact_int_count == 3, &quot;else change next line&quot;);
2432       _value._compact[0] = _value._compact[1] = _value._compact[2] = 0;
2433       // Storing the signature encoded as signed chars hits about 98%
2434       // of the time.
2435       _length = -len;
2436       ptr = _value._compact;
2437     } else {
2438       _length = len;
2439       _value._fingerprint = NEW_C_HEAP_ARRAY(int, _length, mtCode);
2440       ptr = _value._fingerprint;
2441     }
2442 
2443     // Now pack the BasicTypes with 8 per int
2444     int sig_index = 0;
2445     BasicType prev_sbt = T_ILLEGAL;
2446     int vt_count = 0;
2447     for (int index = 0; index &lt; len; index++) {
2448       int value = 0;
2449       for (int byte = 0; byte &lt; _basic_types_per_int; byte++) {
2450         int bt = 0;
2451         if (sig_index &lt; total_args_passed) {
2452           BasicType sbt = sig-&gt;at(sig_index++)._bt;
2453           if (ValueTypePassFieldsAsArgs &amp;&amp; sbt == T_VALUETYPE) {
2454             // Found start of value type in signature
2455             vt_count++;
2456             if (sig_index == 1 &amp;&amp; has_ro_adapter) {
2457               // With a ro_adapter, replace receiver value type delimiter by T_VOID to prevent matching
2458               // with other adapters that have the same value type as first argument and no receiver.
2459               sbt = T_VOID;
2460             }
2461           } else if (ValueTypePassFieldsAsArgs &amp;&amp; sbt == T_VOID &amp;&amp;
2462                      prev_sbt != T_LONG &amp;&amp; prev_sbt != T_DOUBLE) {
2463             // Found end of value type in signature
2464             vt_count--;
2465             assert(vt_count &gt;= 0, &quot;invalid vt_count&quot;);
2466           }
2467           bt = adapter_encoding(sbt, vt_count &gt; 0);
2468           prev_sbt = sbt;
2469         }
2470         assert((bt &amp; _basic_type_mask) == bt, &quot;must fit in 4 bits&quot;);
2471         value = (value &lt;&lt; _basic_type_bits) | bt;
2472       }
2473       ptr[index] = value;
2474     }
2475     assert(vt_count == 0, &quot;invalid vt_count&quot;);
2476   }
2477 
2478   ~AdapterFingerPrint() {
2479     if (_length &gt; 0) {
2480       FREE_C_HEAP_ARRAY(int, _value._fingerprint);
2481     }
2482   }
2483 
2484   int value(int index) {
2485     if (_length &lt; 0) {
2486       return _value._compact[index];
2487     }
2488     return _value._fingerprint[index];
2489   }
2490   int length() {
2491     if (_length &lt; 0) return -_length;
2492     return _length;
2493   }
2494 
2495   bool is_compact() {
2496     return _length &lt;= 0;
2497   }
2498 
2499   unsigned int compute_hash() {
2500     int hash = 0;
2501     for (int i = 0; i &lt; length(); i++) {
2502       int v = value(i);
2503       hash = (hash &lt;&lt; 8) ^ v ^ (hash &gt;&gt; 5);
2504     }
2505     return (unsigned int)hash;
2506   }
2507 
2508   const char* as_string() {
2509     stringStream st;
2510     st.print(&quot;0x&quot;);
2511     for (int i = 0; i &lt; length(); i++) {
2512       st.print(&quot;%08x&quot;, value(i));
2513     }
2514     return st.as_string();
2515   }
2516 
2517   bool equals(AdapterFingerPrint* other) {
2518     if (other-&gt;_length != _length) {
2519       return false;
2520     }
2521     if (_length &lt; 0) {
2522       assert(_compact_int_count == 3, &quot;else change next line&quot;);
2523       return _value._compact[0] == other-&gt;_value._compact[0] &amp;&amp;
2524              _value._compact[1] == other-&gt;_value._compact[1] &amp;&amp;
2525              _value._compact[2] == other-&gt;_value._compact[2];
2526     } else {
2527       for (int i = 0; i &lt; _length; i++) {
2528         if (_value._fingerprint[i] != other-&gt;_value._fingerprint[i]) {
2529           return false;
2530         }
2531       }
2532     }
2533     return true;
2534   }
2535 };
2536 
2537 
2538 // A hashtable mapping from AdapterFingerPrints to AdapterHandlerEntries
2539 class AdapterHandlerTable : public BasicHashtable&lt;mtCode&gt; {
2540   friend class AdapterHandlerTableIterator;
2541 
2542  private:
2543 
2544 #ifndef PRODUCT
2545   static int _lookups; // number of calls to lookup
2546   static int _buckets; // number of buckets checked
2547   static int _equals;  // number of buckets checked with matching hash
2548   static int _hits;    // number of successful lookups
2549   static int _compact; // number of equals calls with compact signature
2550 #endif
2551 
2552   AdapterHandlerEntry* bucket(int i) {
2553     return (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::bucket(i);
2554   }
2555 
2556  public:
2557   AdapterHandlerTable()
2558     : BasicHashtable&lt;mtCode&gt;(293, (DumpSharedSpaces ? sizeof(CDSAdapterHandlerEntry) : sizeof(AdapterHandlerEntry))) { }
2559 
2560   // Create a new entry suitable for insertion in the table
2561   AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry,
2562                                  address c2i_value_entry, address c2i_value_ro_entry,
2563                                  address c2i_unverified_entry, address c2i_unverified_value_entry, address c2i_no_clinit_check_entry) {
2564     AdapterHandlerEntry* entry = (AdapterHandlerEntry*)BasicHashtable&lt;mtCode&gt;::new_entry(fingerprint-&gt;compute_hash());
2565     entry-&gt;init(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry,
2566                 c2i_unverified_entry, c2i_unverified_value_entry, c2i_no_clinit_check_entry);
2567     if (DumpSharedSpaces) {
2568       ((CDSAdapterHandlerEntry*)entry)-&gt;init();
2569     }
2570     return entry;
2571   }
2572 
2573   // Insert an entry into the table
2574   void add(AdapterHandlerEntry* entry) {
2575     int index = hash_to_index(entry-&gt;hash());
2576     add_entry(index, entry);
2577   }
2578 
2579   void free_entry(AdapterHandlerEntry* entry) {
2580     entry-&gt;deallocate();
2581     BasicHashtable&lt;mtCode&gt;::free_entry(entry);
2582   }
2583 
2584   // Find a entry with the same fingerprint if it exists
2585   AdapterHandlerEntry* lookup(const GrowableArray&lt;SigEntry&gt;* sig, bool has_ro_adapter = false) {
2586     NOT_PRODUCT(_lookups++);
2587     AdapterFingerPrint fp(sig, has_ro_adapter);
2588     unsigned int hash = fp.compute_hash();
2589     int index = hash_to_index(hash);
2590     for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
2591       NOT_PRODUCT(_buckets++);
2592       if (e-&gt;hash() == hash) {
2593         NOT_PRODUCT(_equals++);
2594         if (fp.equals(e-&gt;fingerprint())) {
2595 #ifndef PRODUCT
2596           if (fp.is_compact()) _compact++;
2597           _hits++;
2598 #endif
2599           return e;
2600         }
2601       }
2602     }
2603     return NULL;
2604   }
2605 
2606 #ifndef PRODUCT
2607   void print_statistics() {
2608     ResourceMark rm;
2609     int longest = 0;
2610     int empty = 0;
2611     int total = 0;
2612     int nonempty = 0;
2613     for (int index = 0; index &lt; table_size(); index++) {
2614       int count = 0;
2615       for (AdapterHandlerEntry* e = bucket(index); e != NULL; e = e-&gt;next()) {
2616         count++;
2617       }
2618       if (count != 0) nonempty++;
2619       if (count == 0) empty++;
2620       if (count &gt; longest) longest = count;
2621       total += count;
2622     }
2623     tty-&gt;print_cr(&quot;AdapterHandlerTable: empty %d longest %d total %d average %f&quot;,
2624                   empty, longest, total, total / (double)nonempty);
2625     tty-&gt;print_cr(&quot;AdapterHandlerTable: lookups %d buckets %d equals %d hits %d compact %d&quot;,
2626                   _lookups, _buckets, _equals, _hits, _compact);
2627   }
2628 #endif
2629 };
2630 
2631 
2632 #ifndef PRODUCT
2633 
2634 int AdapterHandlerTable::_lookups;
2635 int AdapterHandlerTable::_buckets;
2636 int AdapterHandlerTable::_equals;
2637 int AdapterHandlerTable::_hits;
2638 int AdapterHandlerTable::_compact;
2639 
2640 #endif
2641 
2642 class AdapterHandlerTableIterator : public StackObj {
2643  private:
2644   AdapterHandlerTable* _table;
2645   int _index;
2646   AdapterHandlerEntry* _current;
2647 
2648   void scan() {
2649     while (_index &lt; _table-&gt;table_size()) {
2650       AdapterHandlerEntry* a = _table-&gt;bucket(_index);
2651       _index++;
2652       if (a != NULL) {
2653         _current = a;
2654         return;
2655       }
2656     }
2657   }
2658 
2659  public:
2660   AdapterHandlerTableIterator(AdapterHandlerTable* table): _table(table), _index(0), _current(NULL) {
2661     scan();
2662   }
2663   bool has_next() {
2664     return _current != NULL;
2665   }
2666   AdapterHandlerEntry* next() {
2667     if (_current != NULL) {
2668       AdapterHandlerEntry* result = _current;
2669       _current = _current-&gt;next();
2670       if (_current == NULL) scan();
2671       return result;
2672     } else {
2673       return NULL;
2674     }
2675   }
2676 };
2677 
2678 
2679 // ---------------------------------------------------------------------------
2680 // Implementation of AdapterHandlerLibrary
2681 AdapterHandlerTable* AdapterHandlerLibrary::_adapters = NULL;
2682 AdapterHandlerEntry* AdapterHandlerLibrary::_abstract_method_handler = NULL;
2683 const int AdapterHandlerLibrary_size = 32*K;
2684 BufferBlob* AdapterHandlerLibrary::_buffer = NULL;
2685 
2686 BufferBlob* AdapterHandlerLibrary::buffer_blob() {
2687   // Should be called only when AdapterHandlerLibrary_lock is active.
2688   if (_buffer == NULL) // Initialize lazily
2689       _buffer = BufferBlob::create(&quot;adapters&quot;, AdapterHandlerLibrary_size);
2690   return _buffer;
2691 }
2692 
2693 extern &quot;C&quot; void unexpected_adapter_call() {
2694   ShouldNotCallThis();
2695 }
2696 
2697 void AdapterHandlerLibrary::initialize() {
2698   if (_adapters != NULL) return;
2699   _adapters = new AdapterHandlerTable();
2700 
2701   // Create a special handler for abstract methods.  Abstract methods
2702   // are never compiled so an i2c entry is somewhat meaningless, but
2703   // throw AbstractMethodError just in case.
2704   // Pass wrong_method_abstract for the c2i transitions to return
2705   // AbstractMethodError for invalid invocations.
2706   address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();
2707   _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),
2708                                                               StubRoutines::throw_AbstractMethodError_entry(),
2709                                                               wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,
2710                                                               wrong_method_abstract, wrong_method_abstract);
2711 }
2712 
2713 AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint,
2714                                                       address i2c_entry,
2715                                                       address c2i_entry,
2716                                                       address c2i_value_entry,
2717                                                       address c2i_value_ro_entry,
2718                                                       address c2i_unverified_entry,
2719                                                       address c2i_unverified_value_entry,
2720                                                       address c2i_no_clinit_check_entry) {
2721   return _adapters-&gt;new_entry(fingerprint, i2c_entry, c2i_entry, c2i_value_entry, c2i_value_ro_entry, c2i_unverified_entry,
2722                               c2i_unverified_value_entry, c2i_no_clinit_check_entry);
2723 }
2724 
2725 static void generate_trampoline(address trampoline, address destination) {
2726   if (*(int*)trampoline == 0) {
2727     CodeBuffer buffer(trampoline, (int)SharedRuntime::trampoline_size());
2728     MacroAssembler _masm(&amp;buffer);
2729     SharedRuntime::generate_trampoline(&amp;_masm, destination);
2730     assert(*(int*)trampoline != 0, &quot;Instruction(s) for trampoline must not be encoded as zeros.&quot;);
2731       _masm.flush();
2732 
2733     if (PrintInterpreter) {
2734       Disassembler::decode(buffer.insts_begin(), buffer.insts_end());
2735     }
2736   }
2737 }
2738 
2739 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter(const methodHandle&amp; method) {
2740   AdapterHandlerEntry* entry = get_adapter0(method);
2741   if (entry != NULL &amp;&amp; method-&gt;is_shared()) {
2742     // See comments around Method::link_method()
2743     MutexLocker mu(AdapterHandlerLibrary_lock);
2744     if (method-&gt;adapter() == NULL) {
2745       method-&gt;update_adapter_trampoline(entry);
2746     }
2747     generate_trampoline(method-&gt;from_compiled_entry(),          entry-&gt;get_c2i_entry());
2748     generate_trampoline(method-&gt;from_compiled_value_ro_entry(), entry-&gt;get_c2i_value_ro_entry());
2749     generate_trampoline(method-&gt;from_compiled_value_entry(),    entry-&gt;get_c2i_value_entry());
2750   }
2751 
2752   return entry;
2753 }
2754 
2755 
2756 CompiledEntrySignature::CompiledEntrySignature(Method* method) :
2757   _method(method), _num_value_args(0), _has_value_recv(false),
2758   _sig_cc(NULL), _sig_cc_ro(NULL), _regs(NULL), _regs_cc(NULL), _regs_cc_ro(NULL),
2759   _args_on_stack(0), _args_on_stack_cc(0), _args_on_stack_cc_ro(0),
2760   _c1_needs_stack_repair(false), _c2_needs_stack_repair(false), _has_scalarized_args(false) {
2761   _has_reserved_entries = false;
2762   _sig = new GrowableArray&lt;SigEntry&gt;(method-&gt;size_of_parameters());
2763 
2764 }
2765 
2766 int CompiledEntrySignature::compute_scalarized_cc(GrowableArray&lt;SigEntry&gt;*&amp; sig_cc, VMRegPair*&amp; regs_cc, bool scalar_receiver) {
2767   InstanceKlass* holder = _method-&gt;method_holder();
2768   sig_cc = new GrowableArray&lt;SigEntry&gt;(_method-&gt;size_of_parameters());
2769   if (!_method-&gt;is_static()) {
2770     if (holder-&gt;is_value() &amp;&amp; scalar_receiver &amp;&amp; ValueKlass::cast(holder)-&gt;is_scalarizable()) {
2771       sig_cc-&gt;appendAll(ValueKlass::cast(holder)-&gt;extended_sig());
2772     } else {
2773       SigEntry::add_entry(sig_cc, T_OBJECT);
2774     }
2775   }
2776   Thread* THREAD = Thread::current();
2777   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {
2778     if (ss.type() == T_VALUETYPE) {
2779       ValueKlass* vk = ss.as_value_klass(holder);
2780       if (vk-&gt;is_scalarizable()) {
2781         sig_cc-&gt;appendAll(vk-&gt;extended_sig());
2782       } else {
2783         SigEntry::add_entry(sig_cc, T_OBJECT);
2784       }
2785     } else {
2786       SigEntry::add_entry(sig_cc, ss.type());
2787     }
2788   }
2789   regs_cc = NEW_RESOURCE_ARRAY(VMRegPair, sig_cc-&gt;length() + 2);
2790   return SharedRuntime::java_calling_convention(sig_cc, regs_cc);
2791 }
2792 
2793 int CompiledEntrySignature::insert_reserved_entry(int ret_off) {
2794   // Find index in signature that belongs to return address slot
2795   BasicType bt = T_ILLEGAL;
2796   int i = 0;
2797   for (uint off = 0; i &lt; _sig_cc-&gt;length(); ++i) {
2798     if (SigEntry::skip_value_delimiters(_sig_cc, i)) {
2799       VMReg first = _regs_cc[off++].first();
2800       if (first-&gt;is_valid() &amp;&amp; first-&gt;is_stack()) {
2801         // Select a type for the reserved entry that will end up on the stack
2802         bt = _sig_cc-&gt;at(i)._bt;
2803         if (((int)first-&gt;reg2stack() + VMRegImpl::slots_per_word) == ret_off) {
2804           break; // Index of the return address found
2805         }
2806       }
2807     }
2808   }
2809   // Insert reserved entry and re-compute calling convention
2810   SigEntry::insert_reserved_entry(_sig_cc, i, bt);
2811   return SharedRuntime::java_calling_convention(_sig_cc, _regs_cc);
2812 }
2813 
2814 // See if we can save space by sharing the same entry for VVEP and VVEP(RO),
2815 // or the same entry for VEP and VVEP(RO).
2816 CodeOffsets::Entries CompiledEntrySignature::c1_value_ro_entry_type() const {
2817   if (!has_scalarized_args()) {
2818     // VEP/VVEP/VVEP(RO) all share the same entry. There&#39;s no packing.
2819     return CodeOffsets::Verified_Entry;
2820   }
2821   if (_method-&gt;is_static()) {
2822     // Static methods don&#39;t need VVEP(RO)
2823     return CodeOffsets::Verified_Entry;
2824   }
2825 
2826   if (has_value_recv()) {
2827     if (num_value_args() == 1) {
2828       // Share same entry for VVEP and VVEP(RO).
2829       // This is quite common: we have an instance method in a ValueKlass that has
2830       // no value args other than &lt;this&gt;.
2831       return CodeOffsets::Verified_Value_Entry;
2832     } else {
2833       assert(num_value_args() &gt; 1, &quot;must be&quot;);
2834       // No sharing:
2835       //   VVEP(RO) -- &lt;this&gt; is passed as object
2836       //   VEP      -- &lt;this&gt; is passed as fields
2837       return CodeOffsets::Verified_Value_Entry_RO;
2838     }
2839   }
2840 
2841   // Either a static method, or &lt;this&gt; is not a value type
2842   if (args_on_stack_cc() != args_on_stack_cc_ro() || _has_reserved_entries) {
2843     // No sharing:
2844     // Some arguments are passed on the stack, and we have inserted reserved entries
2845     // into the VEP, but we never insert reserved entries into the VVEP(RO).
2846     return CodeOffsets::Verified_Value_Entry_RO;
2847   } else {
2848     // Share same entry for VEP and VVEP(RO).
2849     return CodeOffsets::Verified_Entry;
2850   }
2851 }
2852 
2853 
2854 void CompiledEntrySignature::compute_calling_conventions() {
2855   // Get the (non-scalarized) signature and check for value type arguments
2856   if (!_method-&gt;is_static()) {
2857     if (_method-&gt;method_holder()-&gt;is_value() &amp;&amp; ValueKlass::cast(_method-&gt;method_holder())-&gt;is_scalarizable()) {
2858       _has_value_recv = true;
2859       _num_value_args++;
2860     }
2861     SigEntry::add_entry(_sig, T_OBJECT);
2862   }
2863   for (SignatureStream ss(_method-&gt;signature()); !ss.at_return_type(); ss.next()) {
2864     BasicType bt = ss.type();
2865     if (bt == T_VALUETYPE) {
2866       if (ss.as_value_klass(_method-&gt;method_holder())-&gt;is_scalarizable()) {
2867         _num_value_args++;
2868       }
2869       bt = T_OBJECT;
2870     }
2871     SigEntry::add_entry(_sig, bt);
2872   }
2873   if (_method-&gt;is_abstract() &amp;&amp; !(ValueTypePassFieldsAsArgs &amp;&amp; has_value_arg())) {
2874     return;
2875   }
2876 
2877   // Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage
2878   _regs = NEW_RESOURCE_ARRAY(VMRegPair, _sig-&gt;length());
2879   _args_on_stack = SharedRuntime::java_calling_convention(_sig, _regs);
2880 
2881   // Now compute the scalarized calling convention if there are value types in the signature
2882   _sig_cc = _sig;
2883   _sig_cc_ro = _sig;
2884   _regs_cc = _regs;
2885   _regs_cc_ro = _regs;
2886   _args_on_stack_cc = _args_on_stack;
2887   _args_on_stack_cc_ro = _args_on_stack;
2888 
2889   if (ValueTypePassFieldsAsArgs &amp;&amp; has_value_arg() &amp;&amp; !_method-&gt;is_native()) {
2890     _args_on_stack_cc = compute_scalarized_cc(_sig_cc, _regs_cc, /* scalar_receiver = */ true);
2891 
2892     _sig_cc_ro = _sig_cc;
2893     _regs_cc_ro = _regs_cc;
2894     _args_on_stack_cc_ro = _args_on_stack_cc;
2895     if (_has_value_recv || _args_on_stack_cc &gt; _args_on_stack) {
2896       // For interface calls, we need another entry point / adapter to unpack the receiver
2897       _args_on_stack_cc_ro = compute_scalarized_cc(_sig_cc_ro, _regs_cc_ro, /* scalar_receiver = */ false);
2898     }
2899 
2900     // Compute the stack extension that is required to convert between the calling conventions.
2901     // The stack slots at these offsets are occupied by the return address with the unscalarized
2902     // calling convention. Don&#39;t use them for arguments with the scalarized calling convention.
2903     int ret_off    = _args_on_stack_cc - _args_on_stack;
2904     int ret_off_ro = _args_on_stack_cc - _args_on_stack_cc_ro;
2905     assert(ret_off_ro &lt;= 0 || ret_off &gt; 0, &quot;receiver unpacking requires more stack space than expected&quot;);
2906 
2907     if (ret_off &gt; 0) {
2908       // Make sure the stack of the scalarized calling convention with the reserved
2909       // entries (2 slots each) remains 16-byte (4 slots) aligned after stack extension.
2910       int alignment = StackAlignmentInBytes / VMRegImpl::stack_slot_size;
2911       if (ret_off_ro != ret_off &amp;&amp; ret_off_ro &gt;= 0) {
2912         ret_off    += 4; // Account for two reserved entries (4 slots)
2913         ret_off_ro += 4;
2914         ret_off     = align_up(ret_off, alignment);
2915         ret_off_ro  = align_up(ret_off_ro, alignment);
2916         // TODO can we avoid wasting a stack slot here?
2917         //assert(ret_off != ret_off_ro, &quot;fail&quot;);
2918         if (ret_off &gt; ret_off_ro) {
2919           swap(ret_off, ret_off_ro); // Sort by offset
2920         }
2921         _args_on_stack_cc = insert_reserved_entry(ret_off);
2922         _args_on_stack_cc = insert_reserved_entry(ret_off_ro);
2923       } else {
2924         ret_off += 2; // Account for one reserved entry (2 slots)
2925         ret_off = align_up(ret_off, alignment);
2926         _args_on_stack_cc = insert_reserved_entry(ret_off);
2927       }
2928 
2929       _has_reserved_entries = true;
2930     }
2931 
2932     // Upper bound on stack arguments to avoid hitting the argument limit and
2933     // bailing out of compilation (&quot;unsupported incoming calling sequence&quot;).
2934     // TODO we need a reasonable limit (flag?) here
2935     if (_args_on_stack_cc &gt; 50) {
2936       // Don&#39;t scalarize value type arguments
2937       _sig_cc = _sig;
2938       _sig_cc_ro = _sig;
2939       _regs_cc = _regs;
2940       _regs_cc_ro = _regs;
2941       _args_on_stack_cc = _args_on_stack;
2942       _args_on_stack_cc_ro = _args_on_stack;
2943     } else {
2944       _c1_needs_stack_repair = (_args_on_stack_cc &lt; _args_on_stack) || (_args_on_stack_cc_ro &lt; _args_on_stack);
2945       _c2_needs_stack_repair = (_args_on_stack_cc &gt; _args_on_stack) || (_args_on_stack_cc &gt; _args_on_stack_cc_ro);
2946       _has_scalarized_args = true;
2947     }
2948   }
2949 }
2950 
2951 AdapterHandlerEntry* AdapterHandlerLibrary::get_adapter0(const methodHandle&amp; method) {
2952   // Use customized signature handler.  Need to lock around updates to
2953   // the AdapterHandlerTable (it is not safe for concurrent readers
2954   // and a single writer: this could be fixed if it becomes a
2955   // problem).
2956 
2957   ResourceMark rm;
2958 
2959   NOT_PRODUCT(int insts_size = 0);
2960   AdapterBlob* new_adapter = NULL;
2961   AdapterHandlerEntry* entry = NULL;
2962   AdapterFingerPrint* fingerprint = NULL;
2963 
2964   {
2965     MutexLocker mu(AdapterHandlerLibrary_lock);
2966     // make sure data structure is initialized
2967     initialize();
2968 
2969     CompiledEntrySignature ces(method());
2970     {
2971        MutexUnlocker mul(AdapterHandlerLibrary_lock);
2972        ces.compute_calling_conventions();
2973     }
2974     GrowableArray&lt;SigEntry&gt;&amp; sig       = ces.sig();
2975     GrowableArray&lt;SigEntry&gt;&amp; sig_cc    = ces.sig_cc();
2976     GrowableArray&lt;SigEntry&gt;&amp; sig_cc_ro = ces.sig_cc_ro();
2977     VMRegPair* regs         = ces.regs();
2978     VMRegPair* regs_cc      = ces.regs_cc();
2979     VMRegPair* regs_cc_ro   = ces.regs_cc_ro();
2980 
2981     if (ces.has_scalarized_args()) {
2982       method-&gt;set_has_scalarized_args(true);
2983       method-&gt;set_c1_needs_stack_repair(ces.c1_needs_stack_repair());
2984       method-&gt;set_c2_needs_stack_repair(ces.c2_needs_stack_repair());
2985     }
2986 
2987     if (method-&gt;is_abstract()) {
2988       if (ces.has_scalarized_args()) {
2989         // Save a C heap allocated version of the signature for abstract methods with scalarized value type arguments
2990         address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();
2991         entry = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(NULL),
2992                                                  StubRoutines::throw_AbstractMethodError_entry(),
2993                                                  wrong_method_abstract, wrong_method_abstract, wrong_method_abstract,
2994                                                  wrong_method_abstract, wrong_method_abstract);
2995         GrowableArray&lt;SigEntry&gt;* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;SigEntry&gt;(sig_cc_ro.length(), true);
2996         heap_sig-&gt;appendAll(&amp;sig_cc_ro);
2997         entry-&gt;set_sig_cc(heap_sig);
2998         return entry;
2999       } else {
3000         return _abstract_method_handler;
3001       }
3002     }
3003 
3004     // Lookup method signature&#39;s fingerprint
3005     entry = _adapters-&gt;lookup(&amp;sig_cc, regs_cc != regs_cc_ro);
3006 
3007 #ifdef ASSERT
3008     AdapterHandlerEntry* shared_entry = NULL;
3009     // Start adapter sharing verification only after the VM is booted.
3010     if (VerifyAdapterSharing &amp;&amp; (entry != NULL)) {
3011       shared_entry = entry;
3012       entry = NULL;
3013     }
3014 #endif
3015 
3016     if (entry != NULL) {
3017       return entry;
3018     }
3019 
3020     // Make a C heap allocated version of the fingerprint to store in the adapter
3021     fingerprint = new AdapterFingerPrint(&amp;sig_cc, regs_cc != regs_cc_ro);
3022 
3023     // StubRoutines::code2() is initialized after this function can be called. As a result,
3024     // VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated
3025     // prior to StubRoutines::code2() being set. Checks refer to checks generated in an I2C
3026     // stub that ensure that an I2C stub is called from an interpreter frame.
3027     bool contains_all_checks = StubRoutines::code2() != NULL;
3028 
3029     // Create I2C &amp; C2I handlers
3030     BufferBlob* buf = buffer_blob(); // the temporary code buffer in CodeCache
3031     if (buf != NULL) {
3032       CodeBuffer buffer(buf);
3033       short buffer_locs[20];
3034       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)buffer_locs,
3035                                              sizeof(buffer_locs)/sizeof(relocInfo));
3036 
3037       MacroAssembler _masm(&amp;buffer);
3038       entry = SharedRuntime::generate_i2c2i_adapters(&amp;_masm,
3039                                                      ces.args_on_stack(),
3040                                                      &amp;sig,
3041                                                      regs,
3042                                                      &amp;sig_cc,
3043                                                      regs_cc,
3044                                                      &amp;sig_cc_ro,
3045                                                      regs_cc_ro,
3046                                                      fingerprint,
3047                                                      new_adapter);
3048 
3049       if (ces.has_scalarized_args()) {
3050         // Save a C heap allocated version of the scalarized signature and store it in the adapter
3051         GrowableArray&lt;SigEntry&gt;* heap_sig = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;SigEntry&gt;(sig_cc.length(), true);
3052         heap_sig-&gt;appendAll(&amp;sig_cc);
3053         entry-&gt;set_sig_cc(heap_sig);
3054       }
3055 
3056 #ifdef ASSERT
3057       if (VerifyAdapterSharing) {
3058         if (shared_entry != NULL) {
3059           if (!shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size())) {
3060             method-&gt;print();
3061           }
3062           assert(shared_entry-&gt;compare_code(buf-&gt;code_begin(), buffer.insts_size()), &quot;code must match&quot;);
3063           // Release the one just created and return the original
3064           _adapters-&gt;free_entry(entry);
3065           return shared_entry;
3066         } else  {
3067           entry-&gt;save_code(buf-&gt;code_begin(), buffer.insts_size());
3068         }
3069       }
3070 #endif
3071 
3072       NOT_PRODUCT(insts_size = buffer.insts_size());
3073     }
3074     if (new_adapter == NULL) {
3075       // CodeCache is full, disable compilation
3076       // Ought to log this but compile log is only per compile thread
3077       // and we&#39;re some non descript Java thread.
3078       return NULL; // Out of CodeCache space
3079     }
3080     entry-&gt;relocate(new_adapter-&gt;content_begin());
3081 #ifndef PRODUCT
3082     // debugging suppport
3083     if (PrintAdapterHandlers || PrintStubCode) {
3084       ttyLocker ttyl;
3085       entry-&gt;print_adapter_on(tty);
3086       tty-&gt;print_cr(&quot;i2c argument handler #%d for: %s %s %s (%d bytes generated)&quot;,
3087                     _adapters-&gt;number_of_entries(), (method-&gt;is_static() ? &quot;static&quot; : &quot;receiver&quot;),
3088                     method-&gt;signature()-&gt;as_C_string(), fingerprint-&gt;as_string(), insts_size);
3089       tty-&gt;print_cr(&quot;c2i argument handler starts at %p&quot;, entry-&gt;get_c2i_entry());
3090       if (Verbose || PrintStubCode) {
3091         address first_pc = entry-&gt;base_address();
3092         if (first_pc != NULL) {
3093           Disassembler::decode(first_pc, first_pc + insts_size);
3094           tty-&gt;cr();
3095         }
3096       }
3097     }
3098 #endif
3099     // Add the entry only if the entry contains all required checks (see sharedRuntime_xxx.cpp)
3100     // The checks are inserted only if -XX:+VerifyAdapterCalls is specified.
3101     if (contains_all_checks || !VerifyAdapterCalls) {
3102       _adapters-&gt;add(entry);
3103     }
3104   }
3105   // Outside of the lock
3106   if (new_adapter != NULL) {
3107     char blob_id[256];
3108     jio_snprintf(blob_id,
3109                  sizeof(blob_id),
3110                  &quot;%s(%s)@&quot; PTR_FORMAT,
3111                  new_adapter-&gt;name(),
3112                  fingerprint-&gt;as_string(),
3113                  new_adapter-&gt;content_begin());
3114     Forte::register_stub(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
3115 
3116     if (JvmtiExport::should_post_dynamic_code_generated()) {
3117       JvmtiExport::post_dynamic_code_generated(blob_id, new_adapter-&gt;content_begin(), new_adapter-&gt;content_end());
3118     }
3119   }
3120   return entry;
3121 }
3122 
3123 address AdapterHandlerEntry::base_address() {
3124   address base = _i2c_entry;
3125   if (base == NULL)  base = _c2i_entry;
3126   assert(base &lt;= _c2i_entry || _c2i_entry == NULL, &quot;&quot;);
3127   assert(base &lt;= _c2i_value_entry || _c2i_value_entry == NULL, &quot;&quot;);
3128   assert(base &lt;= _c2i_value_ro_entry || _c2i_value_ro_entry == NULL, &quot;&quot;);
3129   assert(base &lt;= _c2i_unverified_entry || _c2i_unverified_entry == NULL, &quot;&quot;);
3130   assert(base &lt;= _c2i_unverified_value_entry || _c2i_unverified_value_entry == NULL, &quot;&quot;);
3131   assert(base &lt;= _c2i_no_clinit_check_entry || _c2i_no_clinit_check_entry == NULL, &quot;&quot;);
3132   return base;
3133 }
3134 
3135 void AdapterHandlerEntry::relocate(address new_base) {
3136   address old_base = base_address();
3137   assert(old_base != NULL, &quot;&quot;);
3138   ptrdiff_t delta = new_base - old_base;
3139   if (_i2c_entry != NULL)
3140     _i2c_entry += delta;
3141   if (_c2i_entry != NULL)
3142     _c2i_entry += delta;
3143   if (_c2i_value_entry != NULL)
3144     _c2i_value_entry += delta;
3145   if (_c2i_value_ro_entry != NULL)
3146     _c2i_value_ro_entry += delta;
3147   if (_c2i_unverified_entry != NULL)
3148     _c2i_unverified_entry += delta;
3149   if (_c2i_unverified_value_entry != NULL)
3150     _c2i_unverified_value_entry += delta;
3151   if (_c2i_no_clinit_check_entry != NULL)
3152     _c2i_no_clinit_check_entry += delta;
3153   assert(base_address() == new_base, &quot;&quot;);
3154 }
3155 
3156 
3157 void AdapterHandlerEntry::deallocate() {
3158   delete _fingerprint;
3159   if (_sig_cc != NULL) {
3160     delete _sig_cc;
3161   }
3162 #ifdef ASSERT
3163   FREE_C_HEAP_ARRAY(unsigned char, _saved_code);
3164 #endif
3165 }
3166 
3167 
3168 #ifdef ASSERT
3169 // Capture the code before relocation so that it can be compared
3170 // against other versions.  If the code is captured after relocation
3171 // then relative instructions won&#39;t be equivalent.
3172 void AdapterHandlerEntry::save_code(unsigned char* buffer, int length) {
3173   _saved_code = NEW_C_HEAP_ARRAY(unsigned char, length, mtCode);
3174   _saved_code_length = length;
3175   memcpy(_saved_code, buffer, length);
3176 }
3177 
3178 
3179 bool AdapterHandlerEntry::compare_code(unsigned char* buffer, int length) {
3180   if (length != _saved_code_length) {
3181     return false;
3182   }
3183 
3184   return (memcmp(buffer, _saved_code, length) == 0) ? true : false;
3185 }
3186 #endif
3187 
3188 
3189 /**
3190  * Create a native wrapper for this native method.  The wrapper converts the
3191  * Java-compiled calling convention to the native convention, handles
3192  * arguments, and transitions to native.  On return from the native we transition
3193  * back to java blocking if a safepoint is in progress.
3194  */
3195 void AdapterHandlerLibrary::create_native_wrapper(const methodHandle&amp; method) {
3196   ResourceMark rm;
3197   nmethod* nm = NULL;
3198   address critical_entry = NULL;
3199 
3200   assert(method-&gt;is_native(), &quot;must be native&quot;);
3201   assert(method-&gt;is_method_handle_intrinsic() ||
3202          method-&gt;has_native_function(), &quot;must have something valid to call!&quot;);
3203 
3204   if (CriticalJNINatives &amp;&amp; !method-&gt;is_method_handle_intrinsic()) {
3205     // We perform the I/O with transition to native before acquiring AdapterHandlerLibrary_lock.
3206     critical_entry = NativeLookup::lookup_critical_entry(method);
3207   }
3208 
3209   {
3210     // Perform the work while holding the lock, but perform any printing outside the lock
3211     MutexLocker mu(AdapterHandlerLibrary_lock);
3212     // See if somebody beat us to it
3213     if (method-&gt;code() != NULL) {
3214       return;
3215     }
3216 
3217     const int compile_id = CompileBroker::assign_compile_id(method, CompileBroker::standard_entry_bci);
3218     assert(compile_id &gt; 0, &quot;Must generate native wrapper&quot;);
3219 
3220 
3221     ResourceMark rm;
3222     BufferBlob*  buf = buffer_blob(); // the temporary code buffer in CodeCache
3223     if (buf != NULL) {
3224       CodeBuffer buffer(buf);
3225       double locs_buf[20];
3226       buffer.insts()-&gt;initialize_shared_locs((relocInfo*)locs_buf, sizeof(locs_buf) / sizeof(relocInfo));
3227       MacroAssembler _masm(&amp;buffer);
3228 
3229       // Fill in the signature array, for the calling-convention call.
3230       const int total_args_passed = method-&gt;size_of_parameters();
3231 
3232       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_args_passed);
3233       VMRegPair*   regs = NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);
3234       int i=0;
3235       if (!method-&gt;is_static())  // Pass in receiver first
3236         sig_bt[i++] = T_OBJECT;
3237       SignatureStream ss(method-&gt;signature());
3238       for (; !ss.at_return_type(); ss.next()) {
3239         BasicType bt = ss.type();
3240         sig_bt[i++] = bt;  // Collect remaining bits of signature
3241         if (ss.type() == T_LONG || ss.type() == T_DOUBLE)
3242           sig_bt[i++] = T_VOID;   // Longs &amp; doubles take 2 Java slots
3243       }
3244       assert(i == total_args_passed, &quot;&quot;);
3245       BasicType ret_type = ss.type();
3246 
3247       // Now get the compiled-Java layout as input (or output) arguments.
3248       // NOTE: Stubs for compiled entry points of method handle intrinsics
3249       // are just trampolines so the argument registers must be outgoing ones.
3250       const bool is_outgoing = method-&gt;is_method_handle_intrinsic();
3251       int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed, is_outgoing);
3252 
3253       // Generate the compiled-to-native wrapper code
3254       nm = SharedRuntime::generate_native_wrapper(&amp;_masm, method, compile_id, sig_bt, regs, ret_type, critical_entry);
3255 
3256       if (nm != NULL) {
3257         {
3258           MutexLocker pl(CompiledMethod_lock, Mutex::_no_safepoint_check_flag);
3259           if (nm-&gt;make_in_use()) {
3260             method-&gt;set_code(method, nm);
3261           }
3262         }
3263 
3264         DirectiveSet* directive = DirectivesStack::getDefaultDirective(CompileBroker::compiler(CompLevel_simple));
3265         if (directive-&gt;PrintAssemblyOption) {
3266           nm-&gt;print_code();
3267         }
3268         DirectivesStack::release(directive);
3269       }
3270     }
3271   } // Unlock AdapterHandlerLibrary_lock
3272 
3273 
3274   // Install the generated code.
3275   if (nm != NULL) {
3276     const char *msg = method-&gt;is_static() ? &quot;(static)&quot; : &quot;&quot;;
3277     CompileTask::print_ul(nm, msg);
3278     if (PrintCompilation) {
3279       ttyLocker ttyl;
3280       CompileTask::print(tty, nm, msg);
3281     }
3282     nm-&gt;post_compiled_method_load_event();
3283   }
3284 }
3285 
3286 JRT_ENTRY_NO_ASYNC(void, SharedRuntime::block_for_jni_critical(JavaThread* thread))
3287   assert(thread == JavaThread::current(), &quot;must be&quot;);
3288   // The code is about to enter a JNI lazy critical native method and
3289   // _needs_gc is true, so if this thread is already in a critical
3290   // section then just return, otherwise this thread should block
3291   // until needs_gc has been cleared.
3292   if (thread-&gt;in_critical()) {
3293     return;
3294   }
3295   // Lock and unlock a critical section to give the system a chance to block
3296   GCLocker::lock_critical(thread);
3297   GCLocker::unlock_critical(thread);
3298 JRT_END
3299 
3300 JRT_LEAF(oopDesc*, SharedRuntime::pin_object(JavaThread* thread, oopDesc* obj))
3301   assert(Universe::heap()-&gt;supports_object_pinning(), &quot;Why we are here?&quot;);
3302   assert(obj != NULL, &quot;Should not be null&quot;);
3303   oop o(obj);
3304   o = Universe::heap()-&gt;pin_object(thread, o);
3305   assert(o != NULL, &quot;Should not be null&quot;);
3306   return o;
3307 JRT_END
3308 
3309 JRT_LEAF(void, SharedRuntime::unpin_object(JavaThread* thread, oopDesc* obj))
3310   assert(Universe::heap()-&gt;supports_object_pinning(), &quot;Why we are here?&quot;);
3311   assert(obj != NULL, &quot;Should not be null&quot;);
3312   oop o(obj);
3313   Universe::heap()-&gt;unpin_object(thread, o);
3314 JRT_END
3315 
3316 // -------------------------------------------------------------------------
3317 // Java-Java calling convention
3318 // (what you use when Java calls Java)
3319 
3320 //------------------------------name_for_receiver----------------------------------
3321 // For a given signature, return the VMReg for parameter 0.
3322 VMReg SharedRuntime::name_for_receiver() {
3323   VMRegPair regs;
3324   BasicType sig_bt = T_OBJECT;
3325   (void) java_calling_convention(&amp;sig_bt, &amp;regs, 1, true);
3326   // Return argument 0 register.  In the LP64 build pointers
3327   // take 2 registers, but the VM wants only the &#39;main&#39; name.
3328   return regs.first();
3329 }
3330 
3331 VMRegPair *SharedRuntime::find_callee_arguments(Symbol* sig, bool has_receiver, bool has_appendix, int* arg_size) {
3332   // This method is returning a data structure allocating as a
3333   // ResourceObject, so do not put any ResourceMarks in here.
3334 
3335   BasicType *sig_bt = NEW_RESOURCE_ARRAY(BasicType, 256);
3336   VMRegPair *regs = NEW_RESOURCE_ARRAY(VMRegPair, 256);
3337   int cnt = 0;
3338   if (has_receiver) {
3339     sig_bt[cnt++] = T_OBJECT; // Receiver is argument 0; not in signature
3340   }
3341 
3342   for (SignatureStream ss(sig); !ss.at_return_type(); ss.next()) {
3343     BasicType type = ss.type();
3344     sig_bt[cnt++] = type;
3345     if (is_double_word_type(type))
3346       sig_bt[cnt++] = T_VOID;
3347   }
3348 
3349   if (has_appendix) {
3350     sig_bt[cnt++] = T_OBJECT;
3351   }
3352 
3353   assert(cnt &lt; 256, &quot;grow table size&quot;);
3354 
3355   int comp_args_on_stack;
3356   comp_args_on_stack = java_calling_convention(sig_bt, regs, cnt, true);
3357 
3358   // the calling convention doesn&#39;t count out_preserve_stack_slots so
3359   // we must add that in to get &quot;true&quot; stack offsets.
3360 
3361   if (comp_args_on_stack) {
3362     for (int i = 0; i &lt; cnt; i++) {
3363       VMReg reg1 = regs[i].first();
3364       if (reg1-&gt;is_stack()) {
3365         // Yuck
3366         reg1 = reg1-&gt;bias(out_preserve_stack_slots());
3367       }
3368       VMReg reg2 = regs[i].second();
3369       if (reg2-&gt;is_stack()) {
3370         // Yuck
3371         reg2 = reg2-&gt;bias(out_preserve_stack_slots());
3372       }
3373       regs[i].set_pair(reg2, reg1);
3374     }
3375   }
3376 
3377   // results
3378   *arg_size = cnt;
3379   return regs;
3380 }
3381 
3382 // OSR Migration Code
3383 //
3384 // This code is used convert interpreter frames into compiled frames.  It is
3385 // called from very start of a compiled OSR nmethod.  A temp array is
3386 // allocated to hold the interesting bits of the interpreter frame.  All
3387 // active locks are inflated to allow them to move.  The displaced headers and
3388 // active interpreter locals are copied into the temp buffer.  Then we return
3389 // back to the compiled code.  The compiled code then pops the current
3390 // interpreter frame off the stack and pushes a new compiled frame.  Then it
3391 // copies the interpreter locals and displaced headers where it wants.
3392 // Finally it calls back to free the temp buffer.
3393 //
3394 // All of this is done NOT at any Safepoint, nor is any safepoint or GC allowed.
3395 
3396 JRT_LEAF(intptr_t*, SharedRuntime::OSR_migration_begin( JavaThread *thread) )
3397 
3398   //
3399   // This code is dependent on the memory layout of the interpreter local
3400   // array and the monitors. On all of our platforms the layout is identical
3401   // so this code is shared. If some platform lays the their arrays out
3402   // differently then this code could move to platform specific code or
3403   // the code here could be modified to copy items one at a time using
3404   // frame accessor methods and be platform independent.
3405 
3406   frame fr = thread-&gt;last_frame();
3407   assert(fr.is_interpreted_frame(), &quot;&quot;);
3408   assert(fr.interpreter_frame_expression_stack_size()==0, &quot;only handle empty stacks&quot;);
3409 
3410   // Figure out how many monitors are active.
3411   int active_monitor_count = 0;
3412   for (BasicObjectLock *kptr = fr.interpreter_frame_monitor_end();
3413        kptr &lt; fr.interpreter_frame_monitor_begin();
3414        kptr = fr.next_monitor_in_interpreter_frame(kptr) ) {
3415     if (kptr-&gt;obj() != NULL) active_monitor_count++;
3416   }
3417 
3418   // QQQ we could place number of active monitors in the array so that compiled code
3419   // could double check it.
3420 
3421   Method* moop = fr.interpreter_frame_method();
3422   int max_locals = moop-&gt;max_locals();
3423   // Allocate temp buffer, 1 word per local &amp; 2 per active monitor
3424   int buf_size_words = max_locals + active_monitor_count * BasicObjectLock::size();
3425   intptr_t *buf = NEW_C_HEAP_ARRAY(intptr_t,buf_size_words, mtCode);
3426 
3427   // Copy the locals.  Order is preserved so that loading of longs works.
3428   // Since there&#39;s no GC I can copy the oops blindly.
3429   assert(sizeof(HeapWord)==sizeof(intptr_t), &quot;fix this code&quot;);
3430   Copy::disjoint_words((HeapWord*)fr.interpreter_frame_local_at(max_locals-1),
3431                        (HeapWord*)&amp;buf[0],
3432                        max_locals);
3433 
3434   // Inflate locks.  Copy the displaced headers.  Be careful, there can be holes.
3435   int i = max_locals;
3436   for (BasicObjectLock *kptr2 = fr.interpreter_frame_monitor_end();
3437        kptr2 &lt; fr.interpreter_frame_monitor_begin();
3438        kptr2 = fr.next_monitor_in_interpreter_frame(kptr2) ) {
3439     if (kptr2-&gt;obj() != NULL) {         // Avoid &#39;holes&#39; in the monitor array
3440       BasicLock *lock = kptr2-&gt;lock();
3441       // Inflate so the displaced header becomes position-independent
3442       if (lock-&gt;displaced_header().is_unlocked())
3443         ObjectSynchronizer::inflate_helper(kptr2-&gt;obj());
3444       // Now the displaced header is free to move
3445       buf[i++] = (intptr_t)lock-&gt;displaced_header().value();
3446       buf[i++] = cast_from_oop&lt;intptr_t&gt;(kptr2-&gt;obj());
3447     }
3448   }
3449   assert(i - max_locals == active_monitor_count*2, &quot;found the expected number of monitors&quot;);
3450 
3451   return buf;
3452 JRT_END
3453 
3454 JRT_LEAF(void, SharedRuntime::OSR_migration_end( intptr_t* buf) )
3455   FREE_C_HEAP_ARRAY(intptr_t, buf);
3456 JRT_END
3457 
3458 bool AdapterHandlerLibrary::contains(const CodeBlob* b) {
3459   AdapterHandlerTableIterator iter(_adapters);
3460   while (iter.has_next()) {
3461     AdapterHandlerEntry* a = iter.next();
3462     if (b == CodeCache::find_blob(a-&gt;get_i2c_entry())) return true;
3463   }
3464   return false;
3465 }
3466 
3467 void AdapterHandlerLibrary::print_handler_on(outputStream* st, const CodeBlob* b) {
3468   AdapterHandlerTableIterator iter(_adapters);
3469   while (iter.has_next()) {
3470     AdapterHandlerEntry* a = iter.next();
3471     if (b == CodeCache::find_blob(a-&gt;get_i2c_entry())) {
3472       st-&gt;print(&quot;Adapter for signature: &quot;);
3473       a-&gt;print_adapter_on(tty);
3474       return;
3475     }
3476   }
3477   assert(false, &quot;Should have found handler&quot;);
3478 }
3479 
3480 void AdapterHandlerEntry::print_adapter_on(outputStream* st) const {
3481   st-&gt;print(&quot;AHE@&quot; INTPTR_FORMAT &quot;: %s&quot;, p2i(this), fingerprint()-&gt;as_string());
3482   if (get_i2c_entry() != NULL) {
3483     st-&gt;print(&quot; i2c: &quot; INTPTR_FORMAT, p2i(get_i2c_entry()));
3484   }
3485   if (get_c2i_entry() != NULL) {
3486     st-&gt;print(&quot; c2i: &quot; INTPTR_FORMAT, p2i(get_c2i_entry()));
3487   }
3488   if (get_c2i_entry() != NULL) {
3489     st-&gt;print(&quot; c2iVE: &quot; INTPTR_FORMAT, p2i(get_c2i_value_entry()));
3490   }
3491   if (get_c2i_entry() != NULL) {
3492     st-&gt;print(&quot; c2iVROE: &quot; INTPTR_FORMAT, p2i(get_c2i_value_ro_entry()));
3493   }
3494   if (get_c2i_unverified_entry() != NULL) {
3495     st-&gt;print(&quot; c2iUE: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_entry()));
3496   }
3497   if (get_c2i_unverified_entry() != NULL) {
3498     st-&gt;print(&quot; c2iUVE: &quot; INTPTR_FORMAT, p2i(get_c2i_unverified_value_entry()));
3499   }
3500   if (get_c2i_no_clinit_check_entry() != NULL) {
3501     st-&gt;print(&quot; c2iNCI: &quot; INTPTR_FORMAT, p2i(get_c2i_no_clinit_check_entry()));
3502   }
3503   st-&gt;cr();
3504 }
3505 
3506 #if INCLUDE_CDS
3507 
3508 void CDSAdapterHandlerEntry::init() {
3509   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
3510   _c2i_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());
3511   _c2i_value_ro_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());
3512   _c2i_value_entry_trampoline = (address)MetaspaceShared::misc_code_space_alloc(SharedRuntime::trampoline_size());
3513   _adapter_trampoline = (AdapterHandlerEntry**)MetaspaceShared::misc_code_space_alloc(sizeof(AdapterHandlerEntry*));
3514 };
3515 
3516 #endif // INCLUDE_CDS
3517 
3518 
3519 #ifndef PRODUCT
3520 
3521 void AdapterHandlerLibrary::print_statistics() {
3522   _adapters-&gt;print_statistics();
3523 }
3524 
3525 #endif /* PRODUCT */
3526 
3527 JRT_LEAF(void, SharedRuntime::enable_stack_reserved_zone(JavaThread* thread))
3528   assert(thread-&gt;is_Java_thread(), &quot;Only Java threads have a stack reserved zone&quot;);
3529   if (thread-&gt;stack_reserved_zone_disabled()) {
3530   thread-&gt;enable_stack_reserved_zone();
3531   }
3532   thread-&gt;set_reserved_stack_activation(thread-&gt;stack_base());
3533 JRT_END
3534 
3535 frame SharedRuntime::look_for_reserved_stack_annotated_method(JavaThread* thread, frame fr) {
3536   ResourceMark rm(thread);
3537   frame activation;
3538   CompiledMethod* nm = NULL;
3539   int count = 1;
3540 
3541   assert(fr.is_java_frame(), &quot;Must start on Java frame&quot;);
3542 
3543   while (true) {
3544     Method* method = NULL;
3545     bool found = false;
3546     if (fr.is_interpreted_frame()) {
3547       method = fr.interpreter_frame_method();
3548       if (method != NULL &amp;&amp; method-&gt;has_reserved_stack_access()) {
3549         found = true;
3550       }
3551     } else {
3552       CodeBlob* cb = fr.cb();
3553       if (cb != NULL &amp;&amp; cb-&gt;is_compiled()) {
3554         nm = cb-&gt;as_compiled_method();
3555         method = nm-&gt;method();
3556         // scope_desc_near() must be used, instead of scope_desc_at() because on
3557         // SPARC, the pcDesc can be on the delay slot after the call instruction.
3558         for (ScopeDesc *sd = nm-&gt;scope_desc_near(fr.pc()); sd != NULL; sd = sd-&gt;sender()) {
3559           method = sd-&gt;method();
3560           if (method != NULL &amp;&amp; method-&gt;has_reserved_stack_access()) {
3561             found = true;
3562       }
3563     }
3564       }
3565     }
3566     if (found) {
3567       activation = fr;
3568       warning(&quot;Potentially dangerous stack overflow in &quot;
3569               &quot;ReservedStackAccess annotated method %s [%d]&quot;,
3570               method-&gt;name_and_sig_as_C_string(), count++);
3571       EventReservedStackActivation event;
3572       if (event.should_commit()) {
3573         event.set_method(method);
3574         event.commit();
3575       }
3576     }
3577     if (fr.is_first_java_frame()) {
3578       break;
3579     } else {
3580       fr = fr.java_sender();
3581     }
3582   }
3583   return activation;
3584 }
3585 
3586 void SharedRuntime::on_slowpath_allocation_exit(JavaThread* thread) {
3587   // After any safepoint, just before going back to compiled code,
3588   // we inform the GC that we will be doing initializing writes to
3589   // this object in the future without emitting card-marks, so
3590   // GC may take any compensating steps.
3591 
3592   oop new_obj = thread-&gt;vm_result();
3593   if (new_obj == NULL) return;
3594 
3595   BarrierSet *bs = BarrierSet::barrier_set();
3596   bs-&gt;on_slowpath_allocation_exit(thread, new_obj);
3597 }
3598 
3599 // We are at a compiled code to interpreter call. We need backing
3600 // buffers for all value type arguments. Allocate an object array to
3601 // hold them (convenient because once we&#39;re done with it we don&#39;t have
3602 // to worry about freeing it).
3603 oop SharedRuntime::allocate_value_types_impl(JavaThread* thread, methodHandle callee, bool allocate_receiver, TRAPS) {
3604   assert(ValueTypePassFieldsAsArgs, &quot;no reason to call this&quot;);
3605   ResourceMark rm;
3606 
3607   int nb_slots = 0;
3608   InstanceKlass* holder = callee-&gt;method_holder();
3609   allocate_receiver &amp;= !callee-&gt;is_static() &amp;&amp; holder-&gt;is_value();
3610   if (allocate_receiver) {
3611     nb_slots++;
3612   }
3613   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {
3614     if (ss.type() == T_VALUETYPE) {
3615       nb_slots++;
3616     }
3617   }
3618   objArrayOop array_oop = oopFactory::new_objectArray(nb_slots, CHECK_NULL);
3619   objArrayHandle array(THREAD, array_oop);
3620   int i = 0;
3621   if (allocate_receiver) {
3622     ValueKlass* vk = ValueKlass::cast(holder);
3623     oop res = vk-&gt;allocate_instance(CHECK_NULL);
3624     array-&gt;obj_at_put(i, res);
3625     i++;
3626   }
3627   for (SignatureStream ss(callee-&gt;signature()); !ss.at_return_type(); ss.next()) {
3628     if (ss.type() == T_VALUETYPE) {
3629       ValueKlass* vk = ss.as_value_klass(holder);
3630       oop res = vk-&gt;allocate_instance(CHECK_NULL);
3631       array-&gt;obj_at_put(i, res);
3632       i++;
3633     }
3634   }
3635   return array();
3636 }
3637 
3638 JRT_ENTRY(void, SharedRuntime::allocate_value_types(JavaThread* thread, Method* callee_method, bool allocate_receiver))
3639   methodHandle callee(thread, callee_method);
3640   oop array = SharedRuntime::allocate_value_types_impl(thread, callee, allocate_receiver, CHECK);
3641   thread-&gt;set_vm_result(array);
3642   thread-&gt;set_vm_result_2(callee()); // TODO: required to keep callee live?
3643 JRT_END
3644 
3645 // TODO remove this once the AARCH64 dependency is gone
3646 // Iterate over the array of heap allocated value types and apply the GC post barrier to all reference fields.
3647 // This is called from the C2I adapter after value type arguments are heap allocated and initialized.
3648 JRT_LEAF(void, SharedRuntime::apply_post_barriers(JavaThread* thread, objArrayOopDesc* array))
3649 {
3650   assert(ValueTypePassFieldsAsArgs, &quot;no reason to call this&quot;);
3651   assert(oopDesc::is_oop(array), &quot;should be oop&quot;);
3652   for (int i = 0; i &lt; array-&gt;length(); ++i) {
3653     instanceOop valueOop = (instanceOop)array-&gt;obj_at(i);
3654     ValueKlass* vk = ValueKlass::cast(valueOop-&gt;klass());
3655     if (vk-&gt;contains_oops()) {
3656       const address dst_oop_addr = ((address) (void*) valueOop);
3657       OopMapBlock* map = vk-&gt;start_of_nonstatic_oop_maps();
3658       OopMapBlock* const end = map + vk-&gt;nonstatic_oop_map_count();
3659       while (map != end) {
3660         address doop_address = dst_oop_addr + map-&gt;offset();
3661         barrier_set_cast&lt;ModRefBarrierSet&gt;(BarrierSet::barrier_set())-&gt;
3662           write_ref_array((HeapWord*) doop_address, map-&gt;count());
3663         map++;
3664       }
3665     }
3666   }
3667 }
3668 JRT_END
3669 
3670 // We&#39;re returning from an interpreted method: load each field into a
3671 // register following the calling convention
3672 JRT_LEAF(void, SharedRuntime::load_value_type_fields_in_regs(JavaThread* thread, oopDesc* res))
3673 {
3674   assert(res-&gt;klass()-&gt;is_value(), &quot;only value types here&quot;);
3675   ResourceMark rm;
3676   RegisterMap reg_map(thread);
3677   frame stubFrame = thread-&gt;last_frame();
3678   frame callerFrame = stubFrame.sender(&amp;reg_map);
3679   assert(callerFrame.is_interpreted_frame(), &quot;should be coming from interpreter&quot;);
3680 
3681   ValueKlass* vk = ValueKlass::cast(res-&gt;klass());
3682 
3683   const Array&lt;SigEntry&gt;* sig_vk = vk-&gt;extended_sig();
3684   const Array&lt;VMRegPair&gt;* regs = vk-&gt;return_regs();
3685 
3686   if (regs == NULL) {
3687     // The fields of the value klass don&#39;t fit in registers, bail out
3688     return;
3689   }
3690 
3691   int j = 1;
3692   for (int i = 0; i &lt; sig_vk-&gt;length(); i++) {
3693     BasicType bt = sig_vk-&gt;at(i)._bt;
3694     if (bt == T_VALUETYPE) {
3695       continue;
3696     }
3697     if (bt == T_VOID) {
3698       if (sig_vk-&gt;at(i-1)._bt == T_LONG ||
3699           sig_vk-&gt;at(i-1)._bt == T_DOUBLE) {
3700         j++;
3701       }
3702       continue;
3703     }
3704     int off = sig_vk-&gt;at(i)._offset;
3705     assert(off &gt; 0, &quot;offset in object should be positive&quot;);
3706     VMRegPair pair = regs-&gt;at(j);
3707     address loc = reg_map.location(pair.first());
3708     switch(bt) {
3709     case T_BOOLEAN:
3710       *(jboolean*)loc = res-&gt;bool_field(off);
3711       break;
3712     case T_CHAR:
3713       *(jchar*)loc = res-&gt;char_field(off);
3714       break;
3715     case T_BYTE:
3716       *(jbyte*)loc = res-&gt;byte_field(off);
3717       break;
3718     case T_SHORT:
3719       *(jshort*)loc = res-&gt;short_field(off);
3720       break;
3721     case T_INT: {
3722       *(jint*)loc = res-&gt;int_field(off);
3723       break;
3724     }
3725     case T_LONG:
3726 #ifdef _LP64
3727       *(intptr_t*)loc = res-&gt;long_field(off);
3728 #else
3729       Unimplemented();
3730 #endif
3731       break;
3732     case T_OBJECT:
3733     case T_ARRAY: {
3734       *(oop*)loc = res-&gt;obj_field(off);
3735       break;
3736     }
3737     case T_FLOAT:
3738       *(jfloat*)loc = res-&gt;float_field(off);
3739       break;
3740     case T_DOUBLE:
3741       *(jdouble*)loc = res-&gt;double_field(off);
3742       break;
3743     default:
3744       ShouldNotReachHere();
3745     }
3746     j++;
3747   }
3748   assert(j == regs-&gt;length(), &quot;missed a field?&quot;);
3749 
3750 #ifdef ASSERT
3751   VMRegPair pair = regs-&gt;at(0);
3752   address loc = reg_map.location(pair.first());
3753   assert(*(oopDesc**)loc == res, &quot;overwritten object&quot;);
3754 #endif
3755 
3756   thread-&gt;set_vm_result(res);
3757 }
3758 JRT_END
3759 
3760 // We&#39;ve returned to an interpreted method, the interpreter needs a
3761 // reference to a value type instance. Allocate it and initialize it
3762 // from field&#39;s values in registers.
3763 JRT_BLOCK_ENTRY(void, SharedRuntime::store_value_type_fields_to_buf(JavaThread* thread, intptr_t res))
3764 {
3765   ResourceMark rm;
3766   RegisterMap reg_map(thread);
3767   frame stubFrame = thread-&gt;last_frame();
3768   frame callerFrame = stubFrame.sender(&amp;reg_map);
3769 
3770 #ifdef ASSERT
3771   ValueKlass* verif_vk = ValueKlass::returned_value_klass(reg_map);
3772 #endif
3773 
3774   if (!is_set_nth_bit(res, 0)) {
3775     // We&#39;re not returning with value type fields in registers (the
3776     // calling convention didn&#39;t allow it for this value klass)
3777     assert(!Metaspace::contains((void*)res), &quot;should be oop or pointer in buffer area&quot;);
3778     thread-&gt;set_vm_result((oopDesc*)res);
3779     assert(verif_vk == NULL, &quot;broken calling convention&quot;);
3780     return;
3781   }
3782 
3783   clear_nth_bit(res, 0);
3784   ValueKlass* vk = (ValueKlass*)res;
3785   assert(verif_vk == vk, &quot;broken calling convention&quot;);
3786   assert(Metaspace::contains((void*)res), &quot;should be klass&quot;);
3787 
3788   // Allocate handles for every oop field so they are safe in case of
3789   // a safepoint when allocating
3790   GrowableArray&lt;Handle&gt; handles;
3791   vk-&gt;save_oop_fields(reg_map, handles);
3792 
3793   // It&#39;s unsafe to safepoint until we are here
3794   JRT_BLOCK;
3795   {
3796     Thread* THREAD = thread;
3797     oop vt = vk-&gt;realloc_result(reg_map, handles, CHECK);
3798     thread-&gt;set_vm_result(vt);
3799   }
3800   JRT_BLOCK_END;
3801 }
3802 JRT_END
3803 
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
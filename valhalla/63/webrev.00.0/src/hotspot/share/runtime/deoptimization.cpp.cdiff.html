<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/runtime/deoptimization.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arguments.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/deoptimization.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1074,10 ***</span>
<span class="line-new-header">--- 1074,84 ---</span>
    return_oops.clear();
    return_oops.push(Handle(THREAD, new_vt));
    return false;
  }
  
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * For primitive types whose kind gets &quot;erased&quot; at runtime (shorts become stack ints),</span>
<span class="line-added">+  * we need to somehow be able to recover the actual kind to be able to write the correct</span>
<span class="line-added">+  * amount of bytes.</span>
<span class="line-added">+  * For that purpose, this method assumes that, for an entry spanning n bytes at index i,</span>
<span class="line-added">+  * the entries at index n + 1 to n + i are &#39;markers&#39;.</span>
<span class="line-added">+  * For example, if we were writing a short at index 4 of a byte array of size 8, the</span>
<span class="line-added">+  * expected form of the array would be:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * {b0, b1, b2, b3, INT, marker, b6, b7}</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Thus, in order to get back the size of the entry, we simply need to count the number</span>
<span class="line-added">+  * of marked entries</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @param virtualArray the virtualized byte array</span>
<span class="line-added">+  * @param i index of the virtual entry we are recovering</span>
<span class="line-added">+  * @return The number of bytes the entry spans</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static int count_number_of_bytes_for_entry(ObjectValue *virtualArray, int i) {</span>
<span class="line-added">+   int index = i;</span>
<span class="line-added">+   while (++index &lt; virtualArray-&gt;field_size() &amp;&amp;</span>
<span class="line-added">+            virtualArray-&gt;field_at(index)-&gt;is_marker()) {}</span>
<span class="line-added">+   return index - i;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * If there was a guarantee for byte array to always start aligned to a long, we could</span>
<span class="line-added">+  * do a simple check on the parity of the index. Unfortunately, that is not always the</span>
<span class="line-added">+  * case. Thus, we check alignment of the actual address we are writing to.</span>
<span class="line-added">+  * In the unlikely case index 0 is 5-aligned for example, it would then be possible to</span>
<span class="line-added">+  * write a long to index 3.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static jbyte* check_alignment_get_addr(typeArrayOop obj, int index, int expected_alignment) {</span>
<span class="line-added">+     jbyte* res = obj-&gt;byte_at_addr(index);</span>
<span class="line-added">+     assert((((intptr_t) res) % expected_alignment) == 0, &quot;Non-aligned write&quot;);</span>
<span class="line-added">+     return res;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void byte_array_put(typeArrayOop obj, intptr_t val, int index, int byte_count) {</span>
<span class="line-added">+   switch (byte_count) {</span>
<span class="line-added">+     case 1:</span>
<span class="line-added">+       obj-&gt;byte_at_put(index, (jbyte) *((jint *) &amp;val));</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case 2:</span>
<span class="line-added">+       *((jshort *) check_alignment_get_addr(obj, index, 2)) = (jshort) *((jint *) &amp;val);</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case 4:</span>
<span class="line-added">+       *((jint *) check_alignment_get_addr(obj, index, 4)) = (jint) *((jint *) &amp;val);</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case 8: {</span>
<span class="line-added">+ #ifdef _LP64</span>
<span class="line-added">+         jlong res = (jlong) *((jlong *) &amp;val);</span>
<span class="line-added">+ #else</span>
<span class="line-added">+ #ifdef SPARC</span>
<span class="line-added">+       // For SPARC we have to swap high and low words.</span>
<span class="line-added">+       jlong v = (jlong) *((jlong *) &amp;val);</span>
<span class="line-added">+       jlong res = 0;</span>
<span class="line-added">+       res |= ((v &amp; (jlong) 0xffffffff) &lt;&lt; 32);</span>
<span class="line-added">+       res |= ((v &gt;&gt; 32) &amp; (jlong) 0xffffffff);</span>
<span class="line-added">+ #else</span>
<span class="line-added">+       jlong res = (jlong) *((jlong *) &amp;val);</span>
<span class="line-added">+ #endif // SPARC</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+       *((jlong *) check_alignment_get_addr(obj, index, 8)) = res;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+   }</span>
<span class="line-added">+     default:</span>
<span class="line-added">+       ShouldNotReachHere();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // INCLUDE_JVMCI</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  // restore elements of an eliminated type array
  void Deoptimization::reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, typeArrayOop obj, BasicType type) {
    int index = 0;
    intptr_t val;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1151,30 ***</span>
        assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
        val = value-&gt;get_int();
        obj-&gt;char_at_put(index, (jchar)*((jint*)&amp;val));
        break;
  
<span class="line-modified">!     case T_BYTE:</span>
        assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
        val = value-&gt;get_int();
        obj-&gt;byte_at_put(index, (jbyte)*((jint*)&amp;val));
        break;
  
<span class="line-modified">!     case T_BOOLEAN:</span>
        assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
        val = value-&gt;get_int();
        obj-&gt;bool_at_put(index, (jboolean)*((jint*)&amp;val));
        break;
  
        default:
          ShouldNotReachHere();
      }
      index++;
    }
  }
  
<span class="line-removed">- </span>
  // restore fields of an eliminated object array
  void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj) {
    for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
      StackValue* value = StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(i));
      assert(value-&gt;type() == T_OBJECT, &quot;object element expected&quot;);
<span class="line-new-header">--- 1225,42 ---</span>
        assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
        val = value-&gt;get_int();
        obj-&gt;char_at_put(index, (jchar)*((jint*)&amp;val));
        break;
  
<span class="line-modified">!     case T_BYTE: {</span>
        assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
<span class="line-added">+       // The value we get is erased as a regular int. We will need to find its actual byte count &#39;by hand&#39;.</span>
        val = value-&gt;get_int();
<span class="line-added">+ #if INCLUDE_JVMCI</span>
<span class="line-added">+       int byte_count = count_number_of_bytes_for_entry(sv, i);</span>
<span class="line-added">+       byte_array_put(obj, val, index, byte_count);</span>
<span class="line-added">+       // According to byte_count contract, the values from i + 1 to i + byte_count are illegal values. Skip.</span>
<span class="line-added">+       i += byte_count - 1; // Balance the loop counter.</span>
<span class="line-added">+       index += byte_count;</span>
<span class="line-added">+       // index has been updated so continue at top of loop</span>
<span class="line-added">+       continue;</span>
<span class="line-added">+ #else</span>
        obj-&gt;byte_at_put(index, (jbyte)*((jint*)&amp;val));
        break;
<span class="line-added">+ #endif // INCLUDE_JVMCI</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     case T_BOOLEAN: {</span>
        assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
        val = value-&gt;get_int();
        obj-&gt;bool_at_put(index, (jboolean)*((jint*)&amp;val));
        break;
<span class="line-added">+     }</span>
  
        default:
          ShouldNotReachHere();
      }
      index++;
    }
  }
  
  // restore fields of an eliminated object array
  void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj) {
    for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
      StackValue* value = StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(i));
      assert(value-&gt;type() == T_OBJECT, &quot;object element expected&quot;);
</pre>
<center><a href="arguments.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="deoptimization.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
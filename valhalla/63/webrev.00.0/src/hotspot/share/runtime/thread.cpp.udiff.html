<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/runtime/thread.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -4430,10 +4430,20 @@</span>
  
    before_exit(thread);
  
    thread-&gt;exit(true);
  
<span class="udiff-line-added">+   // We are no longer on the main thread list but could still be in a</span>
<span class="udiff-line-added">+   // secondary list where another thread may try to interact with us.</span>
<span class="udiff-line-added">+   // So wait until all such interactions are complete before we bring</span>
<span class="udiff-line-added">+   // the VM to the termination safepoint. Normally this would be done</span>
<span class="udiff-line-added">+   // using thread-&gt;smr_delete() below where we delete the thread, but</span>
<span class="udiff-line-added">+   // we can&#39;t call that after the termination safepoint is active as</span>
<span class="udiff-line-added">+   // we will deadlock on the Threads_lock. Once all interactions are</span>
<span class="udiff-line-added">+   // complete it is safe to directly delete the thread at any time.</span>
<span class="udiff-line-added">+   ThreadsSMRSupport::wait_until_not_protected(thread);</span>
<span class="udiff-line-added">+ </span>
    // Stop VM thread.
    {
      // 4945125 The vm thread comes to a safepoint during exit.
      // GC vm_operations can get caught at the safepoint, and the
      // heap is unparseable if they are caught. Grab the Heap_lock
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4469,25 +4479,13 @@</span>
    notify_vm_shutdown();
  
    // exit_globals() will delete tty
    exit_globals();
  
<span class="udiff-line-modified-removed">-   // We are here after VM_Exit::set_vm_exited() so we can&#39;t call</span>
<span class="udiff-line-modified-removed">-   // thread-&gt;smr_delete() or we will block on the Threads_lock. We</span>
<span class="udiff-line-modified-removed">-   // must check that there are no active references to this thread</span>
<span class="udiff-line-removed">-   // before attempting to delete it. A thread could be waiting on</span>
<span class="udiff-line-removed">-   // _handshake_turn_sem trying to execute a direct handshake with</span>
<span class="udiff-line-removed">-   // this thread.</span>
<span class="udiff-line-removed">-   if (!ThreadsSMRSupport::is_a_protected_JavaThread(thread)) {</span>
<span class="udiff-line-removed">-     delete thread;</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-removed">-     // Clear value for _thread_key in TLS to prevent, depending</span>
<span class="udiff-line-removed">-     // on pthreads implementation, possible execution of</span>
<span class="udiff-line-removed">-     // thread-specific destructor in infinite loop at thread</span>
<span class="udiff-line-removed">-     // exit.</span>
<span class="udiff-line-removed">-     Thread::clear_thread_current();</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   // Deleting the shutdown thread here is safe. See comment on</span>
<span class="udiff-line-modified-added">+   // wait_until_not_protected() above.</span>
<span class="udiff-line-modified-added">+   delete thread;</span>
  
  #if INCLUDE_JVMCI
    if (JVMCICounterSize &gt; 0) {
      FREE_C_HEAP_ARRAY(jlong, JavaThread::_jvmci_old_thread_counters);
    }
</pre>
<center><a href="sharedRuntime.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
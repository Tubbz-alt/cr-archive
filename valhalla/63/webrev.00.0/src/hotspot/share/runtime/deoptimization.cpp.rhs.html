<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/runtime/deoptimization.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 
   2 
   3 /*
   4  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   5  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   6  *
   7  * This code is free software; you can redistribute it and/or modify it
   8  * under the terms of the GNU General Public License version 2 only, as
   9  * published by the Free Software Foundation.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  *
  25  */
  26 
  27 #include &quot;precompiled.hpp&quot;
  28 #include &quot;jvm.h&quot;
  29 #include &quot;classfile/symbolTable.hpp&quot;
  30 #include &quot;classfile/systemDictionary.hpp&quot;
  31 #include &quot;code/codeCache.hpp&quot;
  32 #include &quot;code/debugInfoRec.hpp&quot;
  33 #include &quot;code/nmethod.hpp&quot;
  34 #include &quot;code/pcDesc.hpp&quot;
  35 #include &quot;code/scopeDesc.hpp&quot;
  36 #include &quot;compiler/compilationPolicy.hpp&quot;
  37 #include &quot;interpreter/bytecode.hpp&quot;
  38 #include &quot;interpreter/interpreter.hpp&quot;
  39 #include &quot;interpreter/oopMapCache.hpp&quot;
  40 #include &quot;memory/allocation.inline.hpp&quot;
  41 #include &quot;memory/oopFactory.hpp&quot;
  42 #include &quot;memory/resourceArea.hpp&quot;
  43 #include &quot;memory/universe.hpp&quot;
  44 #include &quot;oops/constantPool.hpp&quot;
  45 #include &quot;oops/method.hpp&quot;
  46 #include &quot;oops/objArrayKlass.hpp&quot;
  47 #include &quot;oops/objArrayOop.inline.hpp&quot;
  48 #include &quot;oops/oop.inline.hpp&quot;
  49 #include &quot;oops/fieldStreams.inline.hpp&quot;
  50 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  51 #include &quot;oops/valueArrayKlass.hpp&quot;
  52 #include &quot;oops/valueArrayOop.hpp&quot;
  53 #include &quot;oops/valueKlass.inline.hpp&quot;
  54 #include &quot;oops/verifyOopClosure.hpp&quot;
  55 #include &quot;prims/jvmtiThreadState.hpp&quot;
  56 #include &quot;runtime/atomic.hpp&quot;
  57 #include &quot;runtime/biasedLocking.hpp&quot;
  58 #include &quot;runtime/deoptimization.hpp&quot;
  59 #include &quot;runtime/fieldDescriptor.hpp&quot;
  60 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  61 #include &quot;runtime/frame.inline.hpp&quot;
  62 #include &quot;runtime/handles.inline.hpp&quot;
  63 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  64 #include &quot;runtime/jniHandles.inline.hpp&quot;
  65 #include &quot;runtime/safepointVerifiers.hpp&quot;
  66 #include &quot;runtime/sharedRuntime.hpp&quot;
  67 #include &quot;runtime/signature.hpp&quot;
  68 #include &quot;runtime/stubRoutines.hpp&quot;
  69 #include &quot;runtime/thread.hpp&quot;
  70 #include &quot;runtime/threadSMR.hpp&quot;
  71 #include &quot;runtime/vframe.hpp&quot;
  72 #include &quot;runtime/vframeArray.hpp&quot;
  73 #include &quot;runtime/vframe_hp.hpp&quot;
  74 #include &quot;utilities/events.hpp&quot;
  75 #include &quot;utilities/macros.hpp&quot;
  76 #include &quot;utilities/preserveException.hpp&quot;
  77 #include &quot;utilities/xmlstream.hpp&quot;
  78 #if INCLUDE_JFR
  79 #include &quot;jfr/jfrEvents.hpp&quot;
  80 #include &quot;jfr/metadata/jfrSerializer.hpp&quot;
  81 #endif
  82 
  83 bool DeoptimizationMarker::_is_active = false;
  84 
  85 Deoptimization::UnrollBlock::UnrollBlock(int  size_of_deoptimized_frame,
  86                                          int  caller_adjustment,
  87                                          int  caller_actual_parameters,
  88                                          int  number_of_frames,
  89                                          intptr_t* frame_sizes,
  90                                          address* frame_pcs,
  91                                          BasicType return_type,
  92                                          int exec_mode) {
  93   _size_of_deoptimized_frame = size_of_deoptimized_frame;
  94   _caller_adjustment         = caller_adjustment;
  95   _caller_actual_parameters  = caller_actual_parameters;
  96   _number_of_frames          = number_of_frames;
  97   _frame_sizes               = frame_sizes;
  98   _frame_pcs                 = frame_pcs;
  99   _register_block            = NEW_C_HEAP_ARRAY(intptr_t, RegisterMap::reg_count * 2, mtCompiler);
 100   _return_type               = return_type;
 101   _initial_info              = 0;
 102   // PD (x86 only)
 103   _counter_temp              = 0;
 104   _unpack_kind               = exec_mode;
 105   _sender_sp_temp            = 0;
 106 
 107   _total_frame_sizes         = size_of_frames();
 108   assert(exec_mode &gt;= 0 &amp;&amp; exec_mode &lt; Unpack_LIMIT, &quot;Unexpected exec_mode&quot;);
 109 }
 110 
 111 
 112 Deoptimization::UnrollBlock::~UnrollBlock() {
 113   FREE_C_HEAP_ARRAY(intptr_t, _frame_sizes);
 114   FREE_C_HEAP_ARRAY(intptr_t, _frame_pcs);
 115   FREE_C_HEAP_ARRAY(intptr_t, _register_block);
 116 }
 117 
 118 
 119 intptr_t* Deoptimization::UnrollBlock::value_addr_at(int register_number) const {
 120   assert(register_number &lt; RegisterMap::reg_count, &quot;checking register number&quot;);
 121   return &amp;_register_block[register_number * 2];
 122 }
 123 
 124 
 125 
 126 int Deoptimization::UnrollBlock::size_of_frames() const {
 127   // Acount first for the adjustment of the initial frame
 128   int result = _caller_adjustment;
 129   for (int index = 0; index &lt; number_of_frames(); index++) {
 130     result += frame_sizes()[index];
 131   }
 132   return result;
 133 }
 134 
 135 
 136 void Deoptimization::UnrollBlock::print() {
 137   ttyLocker ttyl;
 138   tty-&gt;print_cr(&quot;UnrollBlock&quot;);
 139   tty-&gt;print_cr(&quot;  size_of_deoptimized_frame = %d&quot;, _size_of_deoptimized_frame);
 140   tty-&gt;print(   &quot;  frame_sizes: &quot;);
 141   for (int index = 0; index &lt; number_of_frames(); index++) {
 142     tty-&gt;print(INTX_FORMAT &quot; &quot;, frame_sizes()[index]);
 143   }
 144   tty-&gt;cr();
 145 }
 146 
 147 
 148 // In order to make fetch_unroll_info work properly with escape
 149 // analysis, The method was changed from JRT_LEAF to JRT_BLOCK_ENTRY and
 150 // ResetNoHandleMark and HandleMark were removed from it. The actual reallocation
 151 // of previously eliminated objects occurs in realloc_objects, which is
 152 // called from the method fetch_unroll_info_helper below.
 153 JRT_BLOCK_ENTRY(Deoptimization::UnrollBlock*, Deoptimization::fetch_unroll_info(JavaThread* thread, int exec_mode))
 154   // It is actually ok to allocate handles in a leaf method. It causes no safepoints,
 155   // but makes the entry a little slower. There is however a little dance we have to
 156   // do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro
 157 
 158   // fetch_unroll_info() is called at the beginning of the deoptimization
 159   // handler. Note this fact before we start generating temporary frames
 160   // that can confuse an asynchronous stack walker. This counter is
 161   // decremented at the end of unpack_frames().
 162   if (TraceDeoptimization) {
 163     tty-&gt;print_cr(&quot;Deoptimizing thread &quot; INTPTR_FORMAT, p2i(thread));
 164   }
 165   thread-&gt;inc_in_deopt_handler();
 166 
 167   return fetch_unroll_info_helper(thread, exec_mode);
 168 JRT_END
 169 
 170 #if COMPILER2_OR_JVMCI
 171 static bool eliminate_allocations(JavaThread* thread, int exec_mode, CompiledMethod* compiled_method,
 172                                   frame&amp; deoptee, RegisterMap&amp; map, GrowableArray&lt;compiledVFrame*&gt;* chunk) {
 173   bool realloc_failures = false;
 174   assert (chunk-&gt;at(0)-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 175 
 176   GrowableArray&lt;ScopeValue*&gt;* objects = chunk-&gt;at(0)-&gt;scope()-&gt;objects();
 177 
 178   // The flag return_oop() indicates call sites which return oop
 179   // in compiled code. Such sites include java method calls,
 180   // runtime calls (for example, used to allocate new objects/arrays
 181   // on slow code path) and any other calls generated in compiled code.
 182   // It is not guaranteed that we can get such information here only
 183   // by analyzing bytecode in deoptimized frames. This is why this flag
 184   // is set during method compilation (see Compile::Process_OopMap_Node()).
 185   // If the previous frame was popped or if we are dispatching an exception,
 186   // we don&#39;t have an oop result.
 187   ScopeDesc* scope = chunk-&gt;at(0)-&gt;scope();
 188   bool save_oop_result = scope-&gt;return_oop() &amp;&amp; !thread-&gt;popframe_forcing_deopt_reexecution() &amp;&amp; (exec_mode == Deoptimization::Unpack_deopt);
 189   // In case of the return of multiple values, we must take care
 190   // of all oop return values.
 191   GrowableArray&lt;Handle&gt; return_oops;
 192   ValueKlass* vk = NULL;
 193   if (save_oop_result &amp;&amp; scope-&gt;return_vt()) {
 194     vk = ValueKlass::returned_value_klass(map);
 195     if (vk != NULL) {
 196       vk-&gt;save_oop_fields(map, return_oops);
 197       save_oop_result = false;
 198     }
 199   }
 200   if (save_oop_result) {
 201     // Reallocation may trigger GC. If deoptimization happened on return from
 202     // call which returns oop we need to save it since it is not in oopmap.
 203     oop result = deoptee.saved_oop_result(&amp;map);
 204     assert(oopDesc::is_oop_or_null(result), &quot;must be oop&quot;);
 205     return_oops.push(Handle(thread, result));
 206     assert(Universe::heap()-&gt;is_in_or_null(result), &quot;must be heap pointer&quot;);
 207     if (TraceDeoptimization) {
 208       ttyLocker ttyl;
 209       tty-&gt;print_cr(&quot;SAVED OOP RESULT &quot; INTPTR_FORMAT &quot; in thread &quot; INTPTR_FORMAT, p2i(result), p2i(thread));
 210     }
 211   }
 212   if (objects != NULL || vk != NULL) {
 213     bool skip_internal = (compiled_method != NULL) &amp;&amp; !compiled_method-&gt;is_compiled_by_jvmci();
 214     JRT_BLOCK
 215       if (vk != NULL) {
 216         realloc_failures = Deoptimization::realloc_value_type_result(vk, map, return_oops, THREAD);
 217       }
 218       if (objects != NULL) {
 219         realloc_failures = realloc_failures || Deoptimization::realloc_objects(thread, &amp;deoptee, &amp;map, objects, THREAD);
 220         Deoptimization::reassign_fields(&amp;deoptee, &amp;map, objects, realloc_failures, skip_internal, THREAD);
 221       }
 222     JRT_END
 223 #ifndef PRODUCT
 224     if (TraceDeoptimization) {
 225       ttyLocker ttyl;
 226       tty-&gt;print_cr(&quot;REALLOC OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));
 227       if (objects != NULL) {
 228         Deoptimization::print_objects(objects, realloc_failures);
 229       } else {
 230         Handle obj = realloc_failures ? Handle() : return_oops.first();
 231         Deoptimization::print_object(vk, obj, realloc_failures);
 232       }
 233     }
 234 #endif
 235   }
 236   if (save_oop_result || vk != NULL) {
 237     // Restore result.
 238     assert(return_oops.length() == 1, &quot;no value type&quot;);
 239     deoptee.set_saved_oop_result(&amp;map, return_oops.pop()());
 240   }
 241   return realloc_failures;
 242 }
 243 
 244 static void eliminate_locks(JavaThread* thread, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
 245 #ifndef PRODUCT
 246   bool first = true;
 247 #endif
 248   for (int i = 0; i &lt; chunk-&gt;length(); i++) {
 249     compiledVFrame* cvf = chunk-&gt;at(i);
 250     assert (cvf-&gt;scope() != NULL,&quot;expect only compiled java frames&quot;);
 251     GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
 252     if (monitors-&gt;is_nonempty()) {
 253       Deoptimization::relock_objects(monitors, thread, realloc_failures);
 254 #ifndef PRODUCT
 255       if (PrintDeoptimizationDetails) {
 256         ttyLocker ttyl;
 257         for (int j = 0; j &lt; monitors-&gt;length(); j++) {
 258           MonitorInfo* mi = monitors-&gt;at(j);
 259           if (mi-&gt;eliminated()) {
 260             if (first) {
 261               first = false;
 262               tty-&gt;print_cr(&quot;RELOCK OBJECTS in thread &quot; INTPTR_FORMAT, p2i(thread));
 263             }
 264             if (mi-&gt;owner_is_scalar_replaced()) {
 265               Klass* k = java_lang_Class::as_Klass(mi-&gt;owner_klass());
 266               tty-&gt;print_cr(&quot;     failed reallocation for klass %s&quot;, k-&gt;external_name());
 267             } else {
 268               tty-&gt;print_cr(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; locked&quot;, p2i(mi-&gt;owner()));
 269             }
 270           }
 271         }
 272       }
 273 #endif // !PRODUCT
 274     }
 275   }
 276 }
 277 #endif // COMPILER2_OR_JVMCI
 278 
 279 // This is factored, since it is both called from a JRT_LEAF (deoptimization) and a JRT_ENTRY (uncommon_trap)
 280 Deoptimization::UnrollBlock* Deoptimization::fetch_unroll_info_helper(JavaThread* thread, int exec_mode) {
 281 
 282   // Note: there is a safepoint safety issue here. No matter whether we enter
 283   // via vanilla deopt or uncommon trap we MUST NOT stop at a safepoint once
 284   // the vframeArray is created.
 285   //
 286 
 287   // Allocate our special deoptimization ResourceMark
 288   DeoptResourceMark* dmark = new DeoptResourceMark(thread);
 289   assert(thread-&gt;deopt_mark() == NULL, &quot;Pending deopt!&quot;);
 290   thread-&gt;set_deopt_mark(dmark);
 291 
 292   frame stub_frame = thread-&gt;last_frame(); // Makes stack walkable as side effect
 293   RegisterMap map(thread, true);
 294   RegisterMap dummy_map(thread, false);
 295   // Now get the deoptee with a valid map
 296   frame deoptee = stub_frame.sender(&amp;map);
 297   // Set the deoptee nmethod
 298   assert(thread-&gt;deopt_compiled_method() == NULL, &quot;Pending deopt!&quot;);
 299   CompiledMethod* cm = deoptee.cb()-&gt;as_compiled_method_or_null();
 300   thread-&gt;set_deopt_compiled_method(cm);
 301 
 302   if (VerifyStack) {
 303     thread-&gt;validate_frame_layout();
 304   }
 305 
 306   // Create a growable array of VFrames where each VFrame represents an inlined
 307   // Java frame.  This storage is allocated with the usual system arena.
 308   assert(deoptee.is_compiled_frame(), &quot;Wrong frame type&quot;);
 309   GrowableArray&lt;compiledVFrame*&gt;* chunk = new GrowableArray&lt;compiledVFrame*&gt;(10);
 310   vframe* vf = vframe::new_vframe(&amp;deoptee, &amp;map, thread);
 311   while (!vf-&gt;is_top()) {
 312     assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
 313     chunk-&gt;push(compiledVFrame::cast(vf));
 314     vf = vf-&gt;sender();
 315   }
 316   assert(vf-&gt;is_compiled_frame(), &quot;Wrong frame type&quot;);
 317   chunk-&gt;push(compiledVFrame::cast(vf));
 318 
 319   bool realloc_failures = false;
 320 
 321 #if COMPILER2_OR_JVMCI
 322 #if INCLUDE_JVMCI
 323   bool jvmci_enabled = true;
 324 #else
 325   bool jvmci_enabled = false;
 326 #endif
 327 
 328   // Reallocate the non-escaping objects and restore their fields. Then
 329   // relock objects if synchronization on them was eliminated.
 330   if (jvmci_enabled COMPILER2_PRESENT( || (DoEscapeAnalysis &amp;&amp; EliminateAllocations) )) {
 331     realloc_failures = eliminate_allocations(thread, exec_mode, cm, deoptee, map, chunk);
 332   }
 333 #endif // COMPILER2_OR_JVMCI
 334 
 335   // Revoke biases, done with in java state.
 336   // No safepoints allowed after this
 337   revoke_from_deopt_handler(thread, deoptee, &amp;map);
 338 
 339   // Ensure that no safepoint is taken after pointers have been stored
 340   // in fields of rematerialized objects.  If a safepoint occurs from here on
 341   // out the java state residing in the vframeArray will be missed.
 342   // Locks may be rebaised in a safepoint.
 343   NoSafepointVerifier no_safepoint;
 344 
 345 #if COMPILER2_OR_JVMCI
 346   if (jvmci_enabled COMPILER2_PRESENT( || ((DoEscapeAnalysis || EliminateNestedLocks) &amp;&amp; EliminateLocks) )) {
 347     eliminate_locks(thread, chunk, realloc_failures);
 348   }
 349 #endif // COMPILER2_OR_JVMCI
 350 
 351   ScopeDesc* trap_scope = chunk-&gt;at(0)-&gt;scope();
 352   Handle exceptionObject;
 353   if (trap_scope-&gt;rethrow_exception()) {
 354     if (PrintDeoptimizationDetails) {
 355       tty-&gt;print_cr(&quot;Exception to be rethrown in the interpreter for method %s::%s at bci %d&quot;, trap_scope-&gt;method()-&gt;method_holder()-&gt;name()-&gt;as_C_string(), trap_scope-&gt;method()-&gt;name()-&gt;as_C_string(), trap_scope-&gt;bci());
 356     }
 357     GrowableArray&lt;ScopeValue*&gt;* expressions = trap_scope-&gt;expressions();
 358     guarantee(expressions != NULL &amp;&amp; expressions-&gt;length() &gt; 0, &quot;must have exception to throw&quot;);
 359     ScopeValue* topOfStack = expressions-&gt;top();
 360     exceptionObject = StackValue::create_stack_value(&amp;deoptee, &amp;map, topOfStack)-&gt;get_obj();
 361     guarantee(exceptionObject() != NULL, &quot;exception oop can not be null&quot;);
 362   }
 363 
 364   vframeArray* array = create_vframeArray(thread, deoptee, &amp;map, chunk, realloc_failures);
 365 #if COMPILER2_OR_JVMCI
 366   if (realloc_failures) {
 367     pop_frames_failed_reallocs(thread, array);
 368   }
 369 #endif
 370 
 371   assert(thread-&gt;vframe_array_head() == NULL, &quot;Pending deopt!&quot;);
 372   thread-&gt;set_vframe_array_head(array);
 373 
 374   // Now that the vframeArray has been created if we have any deferred local writes
 375   // added by jvmti then we can free up that structure as the data is now in the
 376   // vframeArray
 377 
 378   if (thread-&gt;deferred_locals() != NULL) {
 379     GrowableArray&lt;jvmtiDeferredLocalVariableSet*&gt;* list = thread-&gt;deferred_locals();
 380     int i = 0;
 381     do {
 382       // Because of inlining we could have multiple vframes for a single frame
 383       // and several of the vframes could have deferred writes. Find them all.
 384       if (list-&gt;at(i)-&gt;id() == array-&gt;original().id()) {
 385         jvmtiDeferredLocalVariableSet* dlv = list-&gt;at(i);
 386         list-&gt;remove_at(i);
 387         // individual jvmtiDeferredLocalVariableSet are CHeapObj&#39;s
 388         delete dlv;
 389       } else {
 390         i++;
 391       }
 392     } while ( i &lt; list-&gt;length() );
 393     if (list-&gt;length() == 0) {
 394       thread-&gt;set_deferred_locals(NULL);
 395       // free the list and elements back to C heap.
 396       delete list;
 397     }
 398 
 399   }
 400 
 401   // Compute the caller frame based on the sender sp of stub_frame and stored frame sizes info.
 402   CodeBlob* cb = stub_frame.cb();
 403   // Verify we have the right vframeArray
 404   assert(cb-&gt;frame_size() &gt;= 0, &quot;Unexpected frame size&quot;);
 405   intptr_t* unpack_sp = stub_frame.sp() + cb-&gt;frame_size();
 406 
 407   // If the deopt call site is a MethodHandle invoke call site we have
 408   // to adjust the unpack_sp.
 409   nmethod* deoptee_nm = deoptee.cb()-&gt;as_nmethod_or_null();
 410   if (deoptee_nm != NULL &amp;&amp; deoptee_nm-&gt;is_method_handle_return(deoptee.pc()))
 411     unpack_sp = deoptee.unextended_sp();
 412 
 413 #ifdef ASSERT
 414   assert(cb-&gt;is_deoptimization_stub() ||
 415          cb-&gt;is_uncommon_trap_stub() ||
 416          strcmp(&quot;Stub&lt;DeoptimizationStub.deoptimizationHandler&gt;&quot;, cb-&gt;name()) == 0 ||
 417          strcmp(&quot;Stub&lt;UncommonTrapStub.uncommonTrapHandler&gt;&quot;, cb-&gt;name()) == 0,
 418          &quot;unexpected code blob: %s&quot;, cb-&gt;name());
 419 #endif
 420 
 421   // This is a guarantee instead of an assert because if vframe doesn&#39;t match
 422   // we will unpack the wrong deoptimized frame and wind up in strange places
 423   // where it will be very difficult to figure out what went wrong. Better
 424   // to die an early death here than some very obscure death later when the
 425   // trail is cold.
 426   // Note: on ia64 this guarantee can be fooled by frames with no memory stack
 427   // in that it will fail to detect a problem when there is one. This needs
 428   // more work in tiger timeframe.
 429   guarantee(array-&gt;unextended_sp() == unpack_sp, &quot;vframe_array_head must contain the vframeArray to unpack&quot;);
 430 
 431   int number_of_frames = array-&gt;frames();
 432 
 433   // Compute the vframes&#39; sizes.  Note that frame_sizes[] entries are ordered from outermost to innermost
 434   // virtual activation, which is the reverse of the elements in the vframes array.
 435   intptr_t* frame_sizes = NEW_C_HEAP_ARRAY(intptr_t, number_of_frames, mtCompiler);
 436   // +1 because we always have an interpreter return address for the final slot.
 437   address* frame_pcs = NEW_C_HEAP_ARRAY(address, number_of_frames + 1, mtCompiler);
 438   int popframe_extra_args = 0;
 439   // Create an interpreter return address for the stub to use as its return
 440   // address so the skeletal frames are perfectly walkable
 441   frame_pcs[number_of_frames] = Interpreter::deopt_entry(vtos, 0);
 442 
 443   // PopFrame requires that the preserved incoming arguments from the recently-popped topmost
 444   // activation be put back on the expression stack of the caller for reexecution
 445   if (JvmtiExport::can_pop_frame() &amp;&amp; thread-&gt;popframe_forcing_deopt_reexecution()) {
 446     popframe_extra_args = in_words(thread-&gt;popframe_preserved_args_size_in_words());
 447   }
 448 
 449   // Find the current pc for sender of the deoptee. Since the sender may have been deoptimized
 450   // itself since the deoptee vframeArray was created we must get a fresh value of the pc rather
 451   // than simply use array-&gt;sender.pc(). This requires us to walk the current set of frames
 452   //
 453   frame deopt_sender = stub_frame.sender(&amp;dummy_map); // First is the deoptee frame
 454   deopt_sender = deopt_sender.sender(&amp;dummy_map);     // Now deoptee caller
 455 
 456   // It&#39;s possible that the number of parameters at the call site is
 457   // different than number of arguments in the callee when method
 458   // handles are used.  If the caller is interpreted get the real
 459   // value so that the proper amount of space can be added to it&#39;s
 460   // frame.
 461   bool caller_was_method_handle = false;
 462   if (deopt_sender.is_interpreted_frame()) {
 463     methodHandle method(thread, deopt_sender.interpreter_frame_method());
 464     Bytecode_invoke cur = Bytecode_invoke_check(method, deopt_sender.interpreter_frame_bci());
 465     if (cur.is_invokedynamic() || cur.is_invokehandle()) {
 466       // Method handle invokes may involve fairly arbitrary chains of
 467       // calls so it&#39;s impossible to know how much actual space the
 468       // caller has for locals.
 469       caller_was_method_handle = true;
 470     }
 471   }
 472 
 473   //
 474   // frame_sizes/frame_pcs[0] oldest frame (int or c2i)
 475   // frame_sizes/frame_pcs[1] next oldest frame (int)
 476   // frame_sizes/frame_pcs[n] youngest frame (int)
 477   //
 478   // Now a pc in frame_pcs is actually the return address to the frame&#39;s caller (a frame
 479   // owns the space for the return address to it&#39;s caller).  Confusing ain&#39;t it.
 480   //
 481   // The vframe array can address vframes with indices running from
 482   // 0.._frames-1. Index  0 is the youngest frame and _frame - 1 is the oldest (root) frame.
 483   // When we create the skeletal frames we need the oldest frame to be in the zero slot
 484   // in the frame_sizes/frame_pcs so the assembly code can do a trivial walk.
 485   // so things look a little strange in this loop.
 486   //
 487   int callee_parameters = 0;
 488   int callee_locals = 0;
 489   for (int index = 0; index &lt; array-&gt;frames(); index++ ) {
 490     // frame[number_of_frames - 1 ] = on_stack_size(youngest)
 491     // frame[number_of_frames - 2 ] = on_stack_size(sender(youngest))
 492     // frame[number_of_frames - 3 ] = on_stack_size(sender(sender(youngest)))
 493     frame_sizes[number_of_frames - 1 - index] = BytesPerWord * array-&gt;element(index)-&gt;on_stack_size(callee_parameters,
 494                                                                                                     callee_locals,
 495                                                                                                     index == 0,
 496                                                                                                     popframe_extra_args);
 497     // This pc doesn&#39;t have to be perfect just good enough to identify the frame
 498     // as interpreted so the skeleton frame will be walkable
 499     // The correct pc will be set when the skeleton frame is completely filled out
 500     // The final pc we store in the loop is wrong and will be overwritten below
 501     frame_pcs[number_of_frames - 1 - index ] = Interpreter::deopt_entry(vtos, 0) - frame::pc_return_offset;
 502 
 503     callee_parameters = array-&gt;element(index)-&gt;method()-&gt;size_of_parameters();
 504     callee_locals = array-&gt;element(index)-&gt;method()-&gt;max_locals();
 505     popframe_extra_args = 0;
 506   }
 507 
 508   // Compute whether the root vframe returns a float or double value.
 509   BasicType return_type;
 510   {
 511     methodHandle method(thread, array-&gt;element(0)-&gt;method());
 512     Bytecode_invoke invoke = Bytecode_invoke_check(method, array-&gt;element(0)-&gt;bci());
 513     return_type = invoke.is_valid() ? invoke.result_type() : T_ILLEGAL;
 514   }
 515 
 516   // Compute information for handling adapters and adjusting the frame size of the caller.
 517   int caller_adjustment = 0;
 518 
 519   // Compute the amount the oldest interpreter frame will have to adjust
 520   // its caller&#39;s stack by. If the caller is a compiled frame then
 521   // we pretend that the callee has no parameters so that the
 522   // extension counts for the full amount of locals and not just
 523   // locals-parms. This is because without a c2i adapter the parm
 524   // area as created by the compiled frame will not be usable by
 525   // the interpreter. (Depending on the calling convention there
 526   // may not even be enough space).
 527 
 528   // QQQ I&#39;d rather see this pushed down into last_frame_adjust
 529   // and have it take the sender (aka caller).
 530 
 531   if (deopt_sender.is_compiled_frame() || caller_was_method_handle) {
 532     caller_adjustment = last_frame_adjust(0, callee_locals);
 533   } else if (callee_locals &gt; callee_parameters) {
 534     // The caller frame may need extending to accommodate
 535     // non-parameter locals of the first unpacked interpreted frame.
 536     // Compute that adjustment.
 537     caller_adjustment = last_frame_adjust(callee_parameters, callee_locals);
 538   }
 539 
 540   // If the sender is deoptimized we must retrieve the address of the handler
 541   // since the frame will &quot;magically&quot; show the original pc before the deopt
 542   // and we&#39;d undo the deopt.
 543 
 544   frame_pcs[0] = deopt_sender.raw_pc();
 545 
 546   assert(CodeCache::find_blob_unsafe(frame_pcs[0]) != NULL, &quot;bad pc&quot;);
 547 
 548 #if INCLUDE_JVMCI
 549   if (exceptionObject() != NULL) {
 550     thread-&gt;set_exception_oop(exceptionObject());
 551     exec_mode = Unpack_exception;
 552   }
 553 #endif
 554 
 555   if (thread-&gt;frames_to_pop_failed_realloc() &gt; 0 &amp;&amp; exec_mode != Unpack_uncommon_trap) {
 556     assert(thread-&gt;has_pending_exception(), &quot;should have thrown OOME&quot;);
 557     thread-&gt;set_exception_oop(thread-&gt;pending_exception());
 558     thread-&gt;clear_pending_exception();
 559     exec_mode = Unpack_exception;
 560   }
 561 
 562 #if INCLUDE_JVMCI
 563   if (thread-&gt;frames_to_pop_failed_realloc() &gt; 0) {
 564     thread-&gt;set_pending_monitorenter(false);
 565   }
 566 #endif
 567 
 568   UnrollBlock* info = new UnrollBlock(array-&gt;frame_size() * BytesPerWord,
 569                                       caller_adjustment * BytesPerWord,
 570                                       caller_was_method_handle ? 0 : callee_parameters,
 571                                       number_of_frames,
 572                                       frame_sizes,
 573                                       frame_pcs,
 574                                       return_type,
 575                                       exec_mode);
 576   // On some platforms, we need a way to pass some platform dependent
 577   // information to the unpacking code so the skeletal frames come out
 578   // correct (initial fp value, unextended sp, ...)
 579   info-&gt;set_initial_info((intptr_t) array-&gt;sender().initial_deoptimization_info());
 580 
 581   if (array-&gt;frames() &gt; 1) {
 582     if (VerifyStack &amp;&amp; TraceDeoptimization) {
 583       ttyLocker ttyl;
 584       tty-&gt;print_cr(&quot;Deoptimizing method containing inlining&quot;);
 585     }
 586   }
 587 
 588   array-&gt;set_unroll_block(info);
 589   return info;
 590 }
 591 
 592 // Called to cleanup deoptimization data structures in normal case
 593 // after unpacking to stack and when stack overflow error occurs
 594 void Deoptimization::cleanup_deopt_info(JavaThread *thread,
 595                                         vframeArray *array) {
 596 
 597   // Get array if coming from exception
 598   if (array == NULL) {
 599     array = thread-&gt;vframe_array_head();
 600   }
 601   thread-&gt;set_vframe_array_head(NULL);
 602 
 603   // Free the previous UnrollBlock
 604   vframeArray* old_array = thread-&gt;vframe_array_last();
 605   thread-&gt;set_vframe_array_last(array);
 606 
 607   if (old_array != NULL) {
 608     UnrollBlock* old_info = old_array-&gt;unroll_block();
 609     old_array-&gt;set_unroll_block(NULL);
 610     delete old_info;
 611     delete old_array;
 612   }
 613 
 614   // Deallocate any resource creating in this routine and any ResourceObjs allocated
 615   // inside the vframeArray (StackValueCollections)
 616 
 617   delete thread-&gt;deopt_mark();
 618   thread-&gt;set_deopt_mark(NULL);
 619   thread-&gt;set_deopt_compiled_method(NULL);
 620 
 621 
 622   if (JvmtiExport::can_pop_frame()) {
 623 #ifndef CC_INTERP
 624     // Regardless of whether we entered this routine with the pending
 625     // popframe condition bit set, we should always clear it now
 626     thread-&gt;clear_popframe_condition();
 627 #else
 628     // C++ interpreter will clear has_pending_popframe when it enters
 629     // with method_resume. For deopt_resume2 we clear it now.
 630     if (thread-&gt;popframe_forcing_deopt_reexecution())
 631         thread-&gt;clear_popframe_condition();
 632 #endif /* CC_INTERP */
 633   }
 634 
 635   // unpack_frames() is called at the end of the deoptimization handler
 636   // and (in C2) at the end of the uncommon trap handler. Note this fact
 637   // so that an asynchronous stack walker can work again. This counter is
 638   // incremented at the beginning of fetch_unroll_info() and (in C2) at
 639   // the beginning of uncommon_trap().
 640   thread-&gt;dec_in_deopt_handler();
 641 }
 642 
 643 // Moved from cpu directories because none of the cpus has callee save values.
 644 // If a cpu implements callee save values, move this to deoptimization_&lt;cpu&gt;.cpp.
 645 void Deoptimization::unwind_callee_save_values(frame* f, vframeArray* vframe_array) {
 646 
 647   // This code is sort of the equivalent of C2IAdapter::setup_stack_frame back in
 648   // the days we had adapter frames. When we deoptimize a situation where a
 649   // compiled caller calls a compiled caller will have registers it expects
 650   // to survive the call to the callee. If we deoptimize the callee the only
 651   // way we can restore these registers is to have the oldest interpreter
 652   // frame that we create restore these values. That is what this routine
 653   // will accomplish.
 654 
 655   // At the moment we have modified c2 to not have any callee save registers
 656   // so this problem does not exist and this routine is just a place holder.
 657 
 658   assert(f-&gt;is_interpreted_frame(), &quot;must be interpreted&quot;);
 659 }
 660 
 661 // Return BasicType of value being returned
 662 JRT_LEAF(BasicType, Deoptimization::unpack_frames(JavaThread* thread, int exec_mode))
 663 
 664   // We are already active in the special DeoptResourceMark any ResourceObj&#39;s we
 665   // allocate will be freed at the end of the routine.
 666 
 667   // It is actually ok to allocate handles in a leaf method. It causes no safepoints,
 668   // but makes the entry a little slower. There is however a little dance we have to
 669   // do in debug mode to get around the NoHandleMark code in the JRT_LEAF macro
 670   ResetNoHandleMark rnhm; // No-op in release/product versions
 671   HandleMark hm;
 672 
 673   frame stub_frame = thread-&gt;last_frame();
 674 
 675   // Since the frame to unpack is the top frame of this thread, the vframe_array_head
 676   // must point to the vframeArray for the unpack frame.
 677   vframeArray* array = thread-&gt;vframe_array_head();
 678 
 679 #ifndef PRODUCT
 680   if (TraceDeoptimization) {
 681     ttyLocker ttyl;
 682     tty-&gt;print_cr(&quot;DEOPT UNPACKING thread &quot; INTPTR_FORMAT &quot; vframeArray &quot; INTPTR_FORMAT &quot; mode %d&quot;,
 683                   p2i(thread), p2i(array), exec_mode);
 684   }
 685 #endif
 686   Events::log_deopt_message(thread, &quot;DEOPT UNPACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT &quot; mode %d&quot;,
 687               p2i(stub_frame.pc()), p2i(stub_frame.sp()), exec_mode);
 688 
 689   UnrollBlock* info = array-&gt;unroll_block();
 690 
 691   // Unpack the interpreter frames and any adapter frame (c2 only) we might create.
 692   array-&gt;unpack_to_stack(stub_frame, exec_mode, info-&gt;caller_actual_parameters());
 693 
 694   BasicType bt = info-&gt;return_type();
 695 
 696   // If we have an exception pending, claim that the return type is an oop
 697   // so the deopt_blob does not overwrite the exception_oop.
 698 
 699   if (exec_mode == Unpack_exception)
 700     bt = T_OBJECT;
 701 
 702   // Cleanup thread deopt data
 703   cleanup_deopt_info(thread, array);
 704 
 705 #ifndef PRODUCT
 706   if (VerifyStack) {
 707     ResourceMark res_mark;
 708     // Clear pending exception to not break verification code (restored afterwards)
 709     PRESERVE_EXCEPTION_MARK;
 710 
 711     thread-&gt;validate_frame_layout();
 712 
 713     // Verify that the just-unpacked frames match the interpreter&#39;s
 714     // notions of expression stack and locals
 715     vframeArray* cur_array = thread-&gt;vframe_array_last();
 716     RegisterMap rm(thread, false);
 717     rm.set_include_argument_oops(false);
 718     bool is_top_frame = true;
 719     int callee_size_of_parameters = 0;
 720     int callee_max_locals = 0;
 721     for (int i = 0; i &lt; cur_array-&gt;frames(); i++) {
 722       vframeArrayElement* el = cur_array-&gt;element(i);
 723       frame* iframe = el-&gt;iframe();
 724       guarantee(iframe-&gt;is_interpreted_frame(), &quot;Wrong frame type&quot;);
 725 
 726       // Get the oop map for this bci
 727       InterpreterOopMap mask;
 728       int cur_invoke_parameter_size = 0;
 729       bool try_next_mask = false;
 730       int next_mask_expression_stack_size = -1;
 731       int top_frame_expression_stack_adjustment = 0;
 732       methodHandle mh(thread, iframe-&gt;interpreter_frame_method());
 733       OopMapCache::compute_one_oop_map(mh, iframe-&gt;interpreter_frame_bci(), &amp;mask);
 734       BytecodeStream str(mh, iframe-&gt;interpreter_frame_bci());
 735       int max_bci = mh-&gt;code_size();
 736       // Get to the next bytecode if possible
 737       assert(str.bci() &lt; max_bci, &quot;bci in interpreter frame out of bounds&quot;);
 738       // Check to see if we can grab the number of outgoing arguments
 739       // at an uncommon trap for an invoke (where the compiler
 740       // generates debug info before the invoke has executed)
 741       Bytecodes::Code cur_code = str.next();
 742       if (Bytecodes::is_invoke(cur_code)) {
 743         Bytecode_invoke invoke(mh, iframe-&gt;interpreter_frame_bci());
 744         cur_invoke_parameter_size = invoke.size_of_parameters();
 745         if (i != 0 &amp;&amp; !invoke.is_invokedynamic() &amp;&amp; MethodHandles::has_member_arg(invoke.klass(), invoke.name())) {
 746           callee_size_of_parameters++;
 747         }
 748       }
 749       if (str.bci() &lt; max_bci) {
 750         Bytecodes::Code next_code = str.next();
 751         if (next_code &gt;= 0) {
 752           // The interpreter oop map generator reports results before
 753           // the current bytecode has executed except in the case of
 754           // calls. It seems to be hard to tell whether the compiler
 755           // has emitted debug information matching the &quot;state before&quot;
 756           // a given bytecode or the state after, so we try both
 757           if (!Bytecodes::is_invoke(cur_code) &amp;&amp; cur_code != Bytecodes::_athrow) {
 758             // Get expression stack size for the next bytecode
 759             InterpreterOopMap next_mask;
 760             OopMapCache::compute_one_oop_map(mh, str.bci(), &amp;next_mask);
 761             next_mask_expression_stack_size = next_mask.expression_stack_size();
 762             if (Bytecodes::is_invoke(next_code)) {
 763               Bytecode_invoke invoke(mh, str.bci());
 764               next_mask_expression_stack_size += invoke.size_of_parameters();
 765             }
 766             // Need to subtract off the size of the result type of
 767             // the bytecode because this is not described in the
 768             // debug info but returned to the interpreter in the TOS
 769             // caching register
 770             BasicType bytecode_result_type = Bytecodes::result_type(cur_code);
 771             if (bytecode_result_type != T_ILLEGAL) {
 772               top_frame_expression_stack_adjustment = type2size[bytecode_result_type];
 773             }
 774             assert(top_frame_expression_stack_adjustment &gt;= 0, &quot;stack adjustment must be positive&quot;);
 775             try_next_mask = true;
 776           }
 777         }
 778       }
 779 
 780       // Verify stack depth and oops in frame
 781       // This assertion may be dependent on the platform we&#39;re running on and may need modification (tested on x86 and sparc)
 782       if (!(
 783             /* SPARC */
 784             (iframe-&gt;interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_size_of_parameters) ||
 785             /* x86 */
 786             (iframe-&gt;interpreter_frame_expression_stack_size() == mask.expression_stack_size() + callee_max_locals) ||
 787             (try_next_mask &amp;&amp;
 788              (iframe-&gt;interpreter_frame_expression_stack_size() == (next_mask_expression_stack_size -
 789                                                                     top_frame_expression_stack_adjustment))) ||
 790             (is_top_frame &amp;&amp; (exec_mode == Unpack_exception) &amp;&amp; iframe-&gt;interpreter_frame_expression_stack_size() == 0) ||
 791             (is_top_frame &amp;&amp; (exec_mode == Unpack_uncommon_trap || exec_mode == Unpack_reexecute || el-&gt;should_reexecute()) &amp;&amp;
 792              (iframe-&gt;interpreter_frame_expression_stack_size() == mask.expression_stack_size() + cur_invoke_parameter_size))
 793             )) {
 794         {
 795           ttyLocker ttyl;
 796 
 797           // Print out some information that will help us debug the problem
 798           tty-&gt;print_cr(&quot;Wrong number of expression stack elements during deoptimization&quot;);
 799           tty-&gt;print_cr(&quot;  Error occurred while verifying frame %d (0..%d, 0 is topmost)&quot;, i, cur_array-&gt;frames() - 1);
 800           tty-&gt;print_cr(&quot;  Fabricated interpreter frame had %d expression stack elements&quot;,
 801                         iframe-&gt;interpreter_frame_expression_stack_size());
 802           tty-&gt;print_cr(&quot;  Interpreter oop map had %d expression stack elements&quot;, mask.expression_stack_size());
 803           tty-&gt;print_cr(&quot;  try_next_mask = %d&quot;, try_next_mask);
 804           tty-&gt;print_cr(&quot;  next_mask_expression_stack_size = %d&quot;, next_mask_expression_stack_size);
 805           tty-&gt;print_cr(&quot;  callee_size_of_parameters = %d&quot;, callee_size_of_parameters);
 806           tty-&gt;print_cr(&quot;  callee_max_locals = %d&quot;, callee_max_locals);
 807           tty-&gt;print_cr(&quot;  top_frame_expression_stack_adjustment = %d&quot;, top_frame_expression_stack_adjustment);
 808           tty-&gt;print_cr(&quot;  exec_mode = %d&quot;, exec_mode);
 809           tty-&gt;print_cr(&quot;  cur_invoke_parameter_size = %d&quot;, cur_invoke_parameter_size);
 810           tty-&gt;print_cr(&quot;  Thread = &quot; INTPTR_FORMAT &quot;, thread ID = %d&quot;, p2i(thread), thread-&gt;osthread()-&gt;thread_id());
 811           tty-&gt;print_cr(&quot;  Interpreted frames:&quot;);
 812           for (int k = 0; k &lt; cur_array-&gt;frames(); k++) {
 813             vframeArrayElement* el = cur_array-&gt;element(k);
 814             tty-&gt;print_cr(&quot;    %s (bci %d)&quot;, el-&gt;method()-&gt;name_and_sig_as_C_string(), el-&gt;bci());
 815           }
 816           cur_array-&gt;print_on_2(tty);
 817         } // release tty lock before calling guarantee
 818         guarantee(false, &quot;wrong number of expression stack elements during deopt&quot;);
 819       }
 820       VerifyOopClosure verify;
 821       iframe-&gt;oops_interpreted_do(&amp;verify, &amp;rm, false);
 822       callee_size_of_parameters = mh-&gt;size_of_parameters();
 823       callee_max_locals = mh-&gt;max_locals();
 824       is_top_frame = false;
 825     }
 826   }
 827 #endif /* !PRODUCT */
 828 
 829 
 830   return bt;
 831 JRT_END
 832 
 833 class DeoptimizeMarkedClosure : public HandshakeClosure {
 834  public:
 835   DeoptimizeMarkedClosure() : HandshakeClosure(&quot;Deoptimize&quot;) {}
 836   void do_thread(Thread* thread) {
 837     JavaThread* jt = (JavaThread*)thread;
 838     jt-&gt;deoptimize_marked_methods();
 839   }
 840 };
 841 
 842 void Deoptimization::deoptimize_all_marked(nmethod* nmethod_only) {
 843   ResourceMark rm;
 844   DeoptimizationMarker dm;
 845 
 846   // Make the dependent methods not entrant
 847   if (nmethod_only != NULL) {
 848     nmethod_only-&gt;mark_for_deoptimization();
 849     nmethod_only-&gt;make_not_entrant();
 850   } else {
 851     MutexLocker mu(SafepointSynchronize::is_at_safepoint() ? NULL : CodeCache_lock, Mutex::_no_safepoint_check_flag);
 852     CodeCache::make_marked_nmethods_not_entrant();
 853   }
 854 
 855   DeoptimizeMarkedClosure deopt;
 856   if (SafepointSynchronize::is_at_safepoint()) {
 857     Threads::java_threads_do(&amp;deopt);
 858   } else {
 859     Handshake::execute(&amp;deopt);
 860   }
 861 }
 862 
 863 Deoptimization::DeoptAction Deoptimization::_unloaded_action
 864   = Deoptimization::Action_reinterpret;
 865 
 866 
 867 
 868 #if INCLUDE_JVMCI || INCLUDE_AOT
 869 template&lt;typename CacheType&gt;
 870 class BoxCacheBase : public CHeapObj&lt;mtCompiler&gt; {
 871 protected:
 872   static InstanceKlass* find_cache_klass(Symbol* klass_name, TRAPS) {
 873     ResourceMark rm;
 874     char* klass_name_str = klass_name-&gt;as_C_string();
 875     Klass* k = SystemDictionary::find(klass_name, Handle(), Handle(), THREAD);
 876     guarantee(k != NULL, &quot;%s must be loaded&quot;, klass_name_str);
 877     InstanceKlass* ik = InstanceKlass::cast(k);
 878     guarantee(ik-&gt;is_initialized(), &quot;%s must be initialized&quot;, klass_name_str);
 879     CacheType::compute_offsets(ik);
 880     return ik;
 881   }
 882 };
 883 
 884 template&lt;typename PrimitiveType, typename CacheType, typename BoxType&gt; class BoxCache  : public BoxCacheBase&lt;CacheType&gt; {
 885   PrimitiveType _low;
 886   PrimitiveType _high;
 887   jobject _cache;
 888 protected:
 889   static BoxCache&lt;PrimitiveType, CacheType, BoxType&gt; *_singleton;
 890   BoxCache(Thread* thread) {
 891     InstanceKlass* ik = BoxCacheBase&lt;CacheType&gt;::find_cache_klass(CacheType::symbol(), thread);
 892     objArrayOop cache = CacheType::cache(ik);
 893     assert(cache-&gt;length() &gt; 0, &quot;Empty cache&quot;);
 894     _low = BoxType::value(cache-&gt;obj_at(0));
 895     _high = _low + cache-&gt;length() - 1;
 896     _cache = JNIHandles::make_global(Handle(thread, cache));
 897   }
 898   ~BoxCache() {
 899     JNIHandles::destroy_global(_cache);
 900   }
 901 public:
 902   static BoxCache&lt;PrimitiveType, CacheType, BoxType&gt;* singleton(Thread* thread) {
 903     if (_singleton == NULL) {
 904       BoxCache&lt;PrimitiveType, CacheType, BoxType&gt;* s = new BoxCache&lt;PrimitiveType, CacheType, BoxType&gt;(thread);
 905       if (!Atomic::replace_if_null(&amp;_singleton, s)) {
 906         delete s;
 907       }
 908     }
 909     return _singleton;
 910   }
 911   oop lookup(PrimitiveType value) {
 912     if (_low &lt;= value &amp;&amp; value &lt;= _high) {
 913       int offset = value - _low;
 914       return objArrayOop(JNIHandles::resolve_non_null(_cache))-&gt;obj_at(offset);
 915     }
 916     return NULL;
 917   }
 918   oop lookup_raw(intptr_t raw_value) {
 919     // Have to cast to avoid little/big-endian problems.
 920     if (sizeof(PrimitiveType) &gt; sizeof(jint)) {
 921       jlong value = (jlong)raw_value;
 922       return lookup(value);
 923     }
 924     PrimitiveType value = (PrimitiveType)*((jint*)&amp;raw_value);
 925     return lookup(value);
 926   }
 927 };
 928 
 929 typedef BoxCache&lt;jint, java_lang_Integer_IntegerCache, java_lang_Integer&gt; IntegerBoxCache;
 930 typedef BoxCache&lt;jlong, java_lang_Long_LongCache, java_lang_Long&gt; LongBoxCache;
 931 typedef BoxCache&lt;jchar, java_lang_Character_CharacterCache, java_lang_Character&gt; CharacterBoxCache;
 932 typedef BoxCache&lt;jshort, java_lang_Short_ShortCache, java_lang_Short&gt; ShortBoxCache;
 933 typedef BoxCache&lt;jbyte, java_lang_Byte_ByteCache, java_lang_Byte&gt; ByteBoxCache;
 934 
 935 template&lt;&gt; BoxCache&lt;jint, java_lang_Integer_IntegerCache, java_lang_Integer&gt;* BoxCache&lt;jint, java_lang_Integer_IntegerCache, java_lang_Integer&gt;::_singleton = NULL;
 936 template&lt;&gt; BoxCache&lt;jlong, java_lang_Long_LongCache, java_lang_Long&gt;* BoxCache&lt;jlong, java_lang_Long_LongCache, java_lang_Long&gt;::_singleton = NULL;
 937 template&lt;&gt; BoxCache&lt;jchar, java_lang_Character_CharacterCache, java_lang_Character&gt;* BoxCache&lt;jchar, java_lang_Character_CharacterCache, java_lang_Character&gt;::_singleton = NULL;
 938 template&lt;&gt; BoxCache&lt;jshort, java_lang_Short_ShortCache, java_lang_Short&gt;* BoxCache&lt;jshort, java_lang_Short_ShortCache, java_lang_Short&gt;::_singleton = NULL;
 939 template&lt;&gt; BoxCache&lt;jbyte, java_lang_Byte_ByteCache, java_lang_Byte&gt;* BoxCache&lt;jbyte, java_lang_Byte_ByteCache, java_lang_Byte&gt;::_singleton = NULL;
 940 
 941 class BooleanBoxCache : public BoxCacheBase&lt;java_lang_Boolean&gt; {
 942   jobject _true_cache;
 943   jobject _false_cache;
 944 protected:
 945   static BooleanBoxCache *_singleton;
 946   BooleanBoxCache(Thread *thread) {
 947     InstanceKlass* ik = find_cache_klass(java_lang_Boolean::symbol(), thread);
 948     _true_cache = JNIHandles::make_global(Handle(thread, java_lang_Boolean::get_TRUE(ik)));
 949     _false_cache = JNIHandles::make_global(Handle(thread, java_lang_Boolean::get_FALSE(ik)));
 950   }
 951   ~BooleanBoxCache() {
 952     JNIHandles::destroy_global(_true_cache);
 953     JNIHandles::destroy_global(_false_cache);
 954   }
 955 public:
 956   static BooleanBoxCache* singleton(Thread* thread) {
 957     if (_singleton == NULL) {
 958       BooleanBoxCache* s = new BooleanBoxCache(thread);
 959       if (!Atomic::replace_if_null(&amp;_singleton, s)) {
 960         delete s;
 961       }
 962     }
 963     return _singleton;
 964   }
 965   oop lookup_raw(intptr_t raw_value) {
 966     // Have to cast to avoid little/big-endian problems.
 967     jboolean value = (jboolean)*((jint*)&amp;raw_value);
 968     return lookup(value);
 969   }
 970   oop lookup(jboolean value) {
 971     if (value != 0) {
 972       return JNIHandles::resolve_non_null(_true_cache);
 973     }
 974     return JNIHandles::resolve_non_null(_false_cache);
 975   }
 976 };
 977 
 978 BooleanBoxCache* BooleanBoxCache::_singleton = NULL;
 979 
 980 oop Deoptimization::get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, TRAPS) {
 981    Klass* k = java_lang_Class::as_Klass(bv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
 982    BasicType box_type = SystemDictionary::box_klass_type(k);
 983    if (box_type != T_OBJECT) {
 984      StackValue* value = StackValue::create_stack_value(fr, reg_map, bv-&gt;field_at(box_type == T_LONG ? 1 : 0));
 985      switch(box_type) {
 986        case T_INT:     return IntegerBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());
 987        case T_CHAR:    return CharacterBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());
 988        case T_SHORT:   return ShortBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());
 989        case T_BYTE:    return ByteBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());
 990        case T_BOOLEAN: return BooleanBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());
 991        case T_LONG:    return LongBoxCache::singleton(THREAD)-&gt;lookup_raw(value-&gt;get_int());
 992        default:;
 993      }
 994    }
 995    return NULL;
 996 }
 997 #endif // INCLUDE_JVMCI || INCLUDE_AOT
 998 
 999 #if COMPILER2_OR_JVMCI
1000 bool Deoptimization::realloc_objects(JavaThread* thread, frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, TRAPS) {
1001   Handle pending_exception(THREAD, thread-&gt;pending_exception());
1002   const char* exception_file = thread-&gt;exception_file();
1003   int exception_line = thread-&gt;exception_line();
1004   thread-&gt;clear_pending_exception();
1005 
1006   bool failures = false;
1007 
1008   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1009     assert(objects-&gt;at(i)-&gt;is_object(), &quot;invalid debug information&quot;);
1010     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1011 
1012     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1013     oop obj = NULL;
1014 
1015     if (k-&gt;is_instance_klass()) {
1016 #if INCLUDE_JVMCI || INCLUDE_AOT
1017       CompiledMethod* cm = fr-&gt;cb()-&gt;as_compiled_method_or_null();
1018       if (cm-&gt;is_compiled_by_jvmci() &amp;&amp; sv-&gt;is_auto_box()) {
1019         AutoBoxObjectValue* abv = (AutoBoxObjectValue*) sv;
1020         obj = get_cached_box(abv, fr, reg_map, THREAD);
1021         if (obj != NULL) {
1022           // Set the flag to indicate the box came from a cache, so that we can skip the field reassignment for it.
1023           abv-&gt;set_cached(true);
1024         }
1025       }
1026 #endif // INCLUDE_JVMCI || INCLUDE_AOT
1027       InstanceKlass* ik = InstanceKlass::cast(k);
1028       if (obj == NULL) {
1029         obj = ik-&gt;allocate_instance(THREAD);
1030       }
1031     } else if (k-&gt;is_valueArray_klass()) {
1032       ValueArrayKlass* ak = ValueArrayKlass::cast(k);
1033       // Value type array must be zeroed because not all memory is reassigned
1034       obj = ak-&gt;allocate(sv-&gt;field_size(), THREAD);
1035     } else if (k-&gt;is_typeArray_klass()) {
1036       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1037       assert(sv-&gt;field_size() % type2size[ak-&gt;element_type()] == 0, &quot;non-integral array length&quot;);
1038       int len = sv-&gt;field_size() / type2size[ak-&gt;element_type()];
1039       obj = ak-&gt;allocate(len, THREAD);
1040     } else if (k-&gt;is_objArray_klass()) {
1041       ObjArrayKlass* ak = ObjArrayKlass::cast(k);
1042       obj = ak-&gt;allocate(sv-&gt;field_size(), THREAD);
1043     }
1044 
1045     if (obj == NULL) {
1046       failures = true;
1047     }
1048 
1049     assert(sv-&gt;value().is_null(), &quot;redundant reallocation&quot;);
1050     assert(obj != NULL || HAS_PENDING_EXCEPTION, &quot;allocation should succeed or we should get an exception&quot;);
1051     CLEAR_PENDING_EXCEPTION;
1052     sv-&gt;set_value(obj);
1053   }
1054 
1055   if (failures) {
1056     THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), failures);
1057   } else if (pending_exception.not_null()) {
1058     thread-&gt;set_pending_exception(pending_exception(), exception_file, exception_line);
1059   }
1060 
1061   return failures;
1062 }
1063 
1064 // We&#39;re deoptimizing at the return of a call, value type fields are
1065 // in registers. When we go back to the interpreter, it will expect a
1066 // reference to a value type instance. Allocate and initialize it from
1067 // the register values here.
1068 bool Deoptimization::realloc_value_type_result(ValueKlass* vk, const RegisterMap&amp; map, GrowableArray&lt;Handle&gt;&amp; return_oops, TRAPS) {
1069   oop new_vt = vk-&gt;realloc_result(map, return_oops, THREAD);
1070   if (new_vt == NULL) {
1071     CLEAR_PENDING_EXCEPTION;
1072     THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), true);
1073   }
1074   return_oops.clear();
1075   return_oops.push(Handle(THREAD, new_vt));
1076   return false;
1077 }
1078 
<a name="1" id="anc1"></a><span class="line-added">1079 #if INCLUDE_JVMCI</span>
<span class="line-added">1080 /**</span>
<span class="line-added">1081  * For primitive types whose kind gets &quot;erased&quot; at runtime (shorts become stack ints),</span>
<span class="line-added">1082  * we need to somehow be able to recover the actual kind to be able to write the correct</span>
<span class="line-added">1083  * amount of bytes.</span>
<span class="line-added">1084  * For that purpose, this method assumes that, for an entry spanning n bytes at index i,</span>
<span class="line-added">1085  * the entries at index n + 1 to n + i are &#39;markers&#39;.</span>
<span class="line-added">1086  * For example, if we were writing a short at index 4 of a byte array of size 8, the</span>
<span class="line-added">1087  * expected form of the array would be:</span>
<span class="line-added">1088  *</span>
<span class="line-added">1089  * {b0, b1, b2, b3, INT, marker, b6, b7}</span>
<span class="line-added">1090  *</span>
<span class="line-added">1091  * Thus, in order to get back the size of the entry, we simply need to count the number</span>
<span class="line-added">1092  * of marked entries</span>
<span class="line-added">1093  *</span>
<span class="line-added">1094  * @param virtualArray the virtualized byte array</span>
<span class="line-added">1095  * @param i index of the virtual entry we are recovering</span>
<span class="line-added">1096  * @return The number of bytes the entry spans</span>
<span class="line-added">1097  */</span>
<span class="line-added">1098 static int count_number_of_bytes_for_entry(ObjectValue *virtualArray, int i) {</span>
<span class="line-added">1099   int index = i;</span>
<span class="line-added">1100   while (++index &lt; virtualArray-&gt;field_size() &amp;&amp;</span>
<span class="line-added">1101            virtualArray-&gt;field_at(index)-&gt;is_marker()) {}</span>
<span class="line-added">1102   return index - i;</span>
<span class="line-added">1103 }</span>
<span class="line-added">1104 </span>
<span class="line-added">1105 /**</span>
<span class="line-added">1106  * If there was a guarantee for byte array to always start aligned to a long, we could</span>
<span class="line-added">1107  * do a simple check on the parity of the index. Unfortunately, that is not always the</span>
<span class="line-added">1108  * case. Thus, we check alignment of the actual address we are writing to.</span>
<span class="line-added">1109  * In the unlikely case index 0 is 5-aligned for example, it would then be possible to</span>
<span class="line-added">1110  * write a long to index 3.</span>
<span class="line-added">1111  */</span>
<span class="line-added">1112 static jbyte* check_alignment_get_addr(typeArrayOop obj, int index, int expected_alignment) {</span>
<span class="line-added">1113     jbyte* res = obj-&gt;byte_at_addr(index);</span>
<span class="line-added">1114     assert((((intptr_t) res) % expected_alignment) == 0, &quot;Non-aligned write&quot;);</span>
<span class="line-added">1115     return res;</span>
<span class="line-added">1116 }</span>
<span class="line-added">1117 </span>
<span class="line-added">1118 static void byte_array_put(typeArrayOop obj, intptr_t val, int index, int byte_count) {</span>
<span class="line-added">1119   switch (byte_count) {</span>
<span class="line-added">1120     case 1:</span>
<span class="line-added">1121       obj-&gt;byte_at_put(index, (jbyte) *((jint *) &amp;val));</span>
<span class="line-added">1122       break;</span>
<span class="line-added">1123     case 2:</span>
<span class="line-added">1124       *((jshort *) check_alignment_get_addr(obj, index, 2)) = (jshort) *((jint *) &amp;val);</span>
<span class="line-added">1125       break;</span>
<span class="line-added">1126     case 4:</span>
<span class="line-added">1127       *((jint *) check_alignment_get_addr(obj, index, 4)) = (jint) *((jint *) &amp;val);</span>
<span class="line-added">1128       break;</span>
<span class="line-added">1129     case 8: {</span>
<span class="line-added">1130 #ifdef _LP64</span>
<span class="line-added">1131         jlong res = (jlong) *((jlong *) &amp;val);</span>
<span class="line-added">1132 #else</span>
<span class="line-added">1133 #ifdef SPARC</span>
<span class="line-added">1134       // For SPARC we have to swap high and low words.</span>
<span class="line-added">1135       jlong v = (jlong) *((jlong *) &amp;val);</span>
<span class="line-added">1136       jlong res = 0;</span>
<span class="line-added">1137       res |= ((v &amp; (jlong) 0xffffffff) &lt;&lt; 32);</span>
<span class="line-added">1138       res |= ((v &gt;&gt; 32) &amp; (jlong) 0xffffffff);</span>
<span class="line-added">1139 #else</span>
<span class="line-added">1140       jlong res = (jlong) *((jlong *) &amp;val);</span>
<span class="line-added">1141 #endif // SPARC</span>
<span class="line-added">1142 #endif</span>
<span class="line-added">1143       *((jlong *) check_alignment_get_addr(obj, index, 8)) = res;</span>
<span class="line-added">1144       break;</span>
<span class="line-added">1145   }</span>
<span class="line-added">1146     default:</span>
<span class="line-added">1147       ShouldNotReachHere();</span>
<span class="line-added">1148   }</span>
<span class="line-added">1149 }</span>
<span class="line-added">1150 #endif // INCLUDE_JVMCI</span>
<span class="line-added">1151 </span>
<span class="line-added">1152 </span>
1153 // restore elements of an eliminated type array
1154 void Deoptimization::reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, typeArrayOop obj, BasicType type) {
1155   int index = 0;
1156   intptr_t val;
1157 
1158   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
1159     StackValue* value = StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(i));
1160     switch(type) {
1161     case T_LONG: case T_DOUBLE: {
1162       assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1163       StackValue* low =
1164         StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(++i));
1165 #ifdef _LP64
1166       jlong res = (jlong)low-&gt;get_int();
1167 #else
1168 #ifdef SPARC
1169       // For SPARC we have to swap high and low words.
1170       jlong res = jlong_from((jint)low-&gt;get_int(), (jint)value-&gt;get_int());
1171 #else
1172       jlong res = jlong_from((jint)value-&gt;get_int(), (jint)low-&gt;get_int());
1173 #endif //SPARC
1174 #endif
1175       obj-&gt;long_at_put(index, res);
1176       break;
1177     }
1178 
1179     // Have to cast to INT (32 bits) pointer to avoid little/big-endian problem.
1180     case T_INT: case T_FLOAT: { // 4 bytes.
1181       assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1182       bool big_value = false;
1183       if (i + 1 &lt; sv-&gt;field_size() &amp;&amp; type == T_INT) {
1184         if (sv-&gt;field_at(i)-&gt;is_location()) {
1185           Location::Type type = ((LocationValue*) sv-&gt;field_at(i))-&gt;location().type();
1186           if (type == Location::dbl || type == Location::lng) {
1187             big_value = true;
1188           }
1189         } else if (sv-&gt;field_at(i)-&gt;is_constant_int()) {
1190           ScopeValue* next_scope_field = sv-&gt;field_at(i + 1);
1191           if (next_scope_field-&gt;is_constant_long() || next_scope_field-&gt;is_constant_double()) {
1192             big_value = true;
1193           }
1194         }
1195       }
1196 
1197       if (big_value) {
1198         StackValue* low = StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(++i));
1199   #ifdef _LP64
1200         jlong res = (jlong)low-&gt;get_int();
1201   #else
1202   #ifdef SPARC
1203         // For SPARC we have to swap high and low words.
1204         jlong res = jlong_from((jint)low-&gt;get_int(), (jint)value-&gt;get_int());
1205   #else
1206         jlong res = jlong_from((jint)value-&gt;get_int(), (jint)low-&gt;get_int());
1207   #endif //SPARC
1208   #endif
1209         obj-&gt;int_at_put(index, (jint)*((jint*)&amp;res));
1210         obj-&gt;int_at_put(++index, (jint)*(((jint*)&amp;res) + 1));
1211       } else {
1212         val = value-&gt;get_int();
1213         obj-&gt;int_at_put(index, (jint)*((jint*)&amp;val));
1214       }
1215       break;
1216     }
1217 
1218     case T_SHORT:
1219       assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1220       val = value-&gt;get_int();
1221       obj-&gt;short_at_put(index, (jshort)*((jint*)&amp;val));
1222       break;
1223 
1224     case T_CHAR:
1225       assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1226       val = value-&gt;get_int();
1227       obj-&gt;char_at_put(index, (jchar)*((jint*)&amp;val));
1228       break;
1229 
<a name="2" id="anc2"></a><span class="line-modified">1230     case T_BYTE: {</span>
1231       assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
<a name="3" id="anc3"></a><span class="line-added">1232       // The value we get is erased as a regular int. We will need to find its actual byte count &#39;by hand&#39;.</span>
1233       val = value-&gt;get_int();
<a name="4" id="anc4"></a><span class="line-added">1234 #if INCLUDE_JVMCI</span>
<span class="line-added">1235       int byte_count = count_number_of_bytes_for_entry(sv, i);</span>
<span class="line-added">1236       byte_array_put(obj, val, index, byte_count);</span>
<span class="line-added">1237       // According to byte_count contract, the values from i + 1 to i + byte_count are illegal values. Skip.</span>
<span class="line-added">1238       i += byte_count - 1; // Balance the loop counter.</span>
<span class="line-added">1239       index += byte_count;</span>
<span class="line-added">1240       // index has been updated so continue at top of loop</span>
<span class="line-added">1241       continue;</span>
<span class="line-added">1242 #else</span>
1243       obj-&gt;byte_at_put(index, (jbyte)*((jint*)&amp;val));
1244       break;
<a name="5" id="anc5"></a><span class="line-added">1245 #endif // INCLUDE_JVMCI</span>
<span class="line-added">1246     }</span>
1247 
<a name="6" id="anc6"></a><span class="line-modified">1248     case T_BOOLEAN: {</span>
1249       assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1250       val = value-&gt;get_int();
1251       obj-&gt;bool_at_put(index, (jboolean)*((jint*)&amp;val));
1252       break;
<a name="7" id="anc7"></a><span class="line-added">1253     }</span>
1254 
1255       default:
1256         ShouldNotReachHere();
1257     }
1258     index++;
1259   }
1260 }
1261 
<a name="8" id="anc8"></a>
1262 // restore fields of an eliminated object array
1263 void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj) {
1264   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
1265     StackValue* value = StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(i));
1266     assert(value-&gt;type() == T_OBJECT, &quot;object element expected&quot;);
1267     obj-&gt;obj_at_put(i, value-&gt;get_obj()());
1268   }
1269 }
1270 
1271 class ReassignedField {
1272 public:
1273   int _offset;
1274   BasicType _type;
1275   InstanceKlass* _klass;
1276 public:
1277   ReassignedField() {
1278     _offset = 0;
1279     _type = T_ILLEGAL;
1280     _klass = NULL;
1281   }
1282 };
1283 
1284 int compare(ReassignedField* left, ReassignedField* right) {
1285   return left-&gt;_offset - right-&gt;_offset;
1286 }
1287 
1288 // Restore fields of an eliminated instance object using the same field order
1289 // returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)
1290 static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal, int base_offset, TRAPS) {
1291 
1292   GrowableArray&lt;ReassignedField&gt;* fields = new GrowableArray&lt;ReassignedField&gt;();
1293   InstanceKlass* ik = klass;
1294   while (ik != NULL) {
1295     for (AllFieldStream fs(ik); !fs.done(); fs.next()) {
1296       if (!fs.access_flags().is_static() &amp;&amp; (!skip_internal || !fs.access_flags().is_internal())) {
1297         ReassignedField field;
1298         field._offset = fs.offset();
1299         field._type = Signature::basic_type(fs.signature());
1300         if (field._type == T_VALUETYPE) {
1301           field._type = T_OBJECT;
1302         }
1303         if (fs.is_flattened()) {
1304           // Resolve klass of flattened value type field
1305           Klass* vk = klass-&gt;get_value_field_klass(fs.index());
1306           field._klass = ValueKlass::cast(vk);
1307           field._type = T_VALUETYPE;
1308         }
1309         fields-&gt;append(field);
1310       }
1311     }
1312     ik = ik-&gt;superklass();
1313   }
1314   fields-&gt;sort(compare);
1315   for (int i = 0; i &lt; fields-&gt;length(); i++) {
1316     intptr_t val;
1317     ScopeValue* scope_field = sv-&gt;field_at(svIndex);
1318     StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);
1319     int offset = base_offset + fields-&gt;at(i)._offset;
1320     BasicType type = fields-&gt;at(i)._type;
1321     switch (type) {
1322       case T_OBJECT:
1323       case T_ARRAY:
1324         assert(value-&gt;type() == T_OBJECT, &quot;Agreement.&quot;);
1325         obj-&gt;obj_field_put(offset, value-&gt;get_obj()());
1326         break;
1327 
1328       case T_VALUETYPE: {
1329         // Recursively re-assign flattened value type fields
1330         InstanceKlass* vk = fields-&gt;at(i)._klass;
1331         assert(vk != NULL, &quot;must be resolved&quot;);
1332         offset -= ValueKlass::cast(vk)-&gt;first_field_offset(); // Adjust offset to omit oop header
1333         svIndex = reassign_fields_by_klass(vk, fr, reg_map, sv, svIndex, obj, skip_internal, offset, CHECK_0);
1334         continue; // Continue because we don&#39;t need to increment svIndex
1335       }
1336 
1337       // Have to cast to INT (32 bits) pointer to avoid little/big-endian problem.
1338       case T_INT: case T_FLOAT: { // 4 bytes.
1339         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1340         bool big_value = false;
1341         if (i+1 &lt; fields-&gt;length() &amp;&amp; fields-&gt;at(i+1)._type == T_INT) {
1342           if (scope_field-&gt;is_location()) {
1343             Location::Type type = ((LocationValue*) scope_field)-&gt;location().type();
1344             if (type == Location::dbl || type == Location::lng) {
1345               big_value = true;
1346             }
1347           }
1348           if (scope_field-&gt;is_constant_int()) {
1349             ScopeValue* next_scope_field = sv-&gt;field_at(svIndex + 1);
1350             if (next_scope_field-&gt;is_constant_long() || next_scope_field-&gt;is_constant_double()) {
1351               big_value = true;
1352             }
1353           }
1354         }
1355 
1356         if (big_value) {
1357           i++;
1358           assert(i &lt; fields-&gt;length(), &quot;second T_INT field needed&quot;);
1359           assert(fields-&gt;at(i)._type == T_INT, &quot;T_INT field needed&quot;);
1360         } else {
1361           val = value-&gt;get_int();
1362           obj-&gt;int_field_put(offset, (jint)*((jint*)&amp;val));
1363           break;
1364         }
1365       }
1366         /* no break */
1367 
1368       case T_LONG: case T_DOUBLE: {
1369         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1370         StackValue* low = StackValue::create_stack_value(fr, reg_map, sv-&gt;field_at(++svIndex));
1371 #ifdef _LP64
1372         jlong res = (jlong)low-&gt;get_int();
1373 #else
1374 #ifdef SPARC
1375         // For SPARC we have to swap high and low words.
1376         jlong res = jlong_from((jint)low-&gt;get_int(), (jint)value-&gt;get_int());
1377 #else
1378         jlong res = jlong_from((jint)value-&gt;get_int(), (jint)low-&gt;get_int());
1379 #endif //SPARC
1380 #endif
1381         obj-&gt;long_field_put(offset, res);
1382         break;
1383       }
1384 
1385       case T_SHORT:
1386         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1387         val = value-&gt;get_int();
1388         obj-&gt;short_field_put(offset, (jshort)*((jint*)&amp;val));
1389         break;
1390 
1391       case T_CHAR:
1392         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1393         val = value-&gt;get_int();
1394         obj-&gt;char_field_put(offset, (jchar)*((jint*)&amp;val));
1395         break;
1396 
1397       case T_BYTE:
1398         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1399         val = value-&gt;get_int();
1400         obj-&gt;byte_field_put(offset, (jbyte)*((jint*)&amp;val));
1401         break;
1402 
1403       case T_BOOLEAN:
1404         assert(value-&gt;type() == T_INT, &quot;Agreement.&quot;);
1405         val = value-&gt;get_int();
1406         obj-&gt;bool_field_put(offset, (jboolean)*((jint*)&amp;val));
1407         break;
1408 
1409       default:
1410         ShouldNotReachHere();
1411     }
1412     svIndex++;
1413   }
1414   return svIndex;
1415 }
1416 
1417 // restore fields of an eliminated value type array
1418 void Deoptimization::reassign_value_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, valueArrayOop obj, ValueArrayKlass* vak, TRAPS) {
1419   ValueKlass* vk = vak-&gt;element_klass();
1420   assert(vk-&gt;flatten_array(), &quot;should only be used for flattened value type arrays&quot;);
1421   // Adjust offset to omit oop header
1422   int base_offset = arrayOopDesc::base_offset_in_bytes(T_VALUETYPE) - ValueKlass::cast(vk)-&gt;first_field_offset();
1423   // Initialize all elements of the flattened value type array
1424   for (int i = 0; i &lt; sv-&gt;field_size(); i++) {
1425     ScopeValue* val = sv-&gt;field_at(i);
1426     int offset = base_offset + (i &lt;&lt; Klass::layout_helper_log2_element_size(vak-&gt;layout_helper()));
1427     reassign_fields_by_klass(vk, fr, reg_map, val-&gt;as_ObjectValue(), 0, (oop)obj, false /* skip_internal */, offset, CHECK);
1428   }
1429 }
1430 
1431 // restore fields of all eliminated objects and arrays
1432 void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures, bool skip_internal, TRAPS) {
1433   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1434     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1435     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1436     Handle obj = sv-&gt;value();
1437     assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1438     if (PrintDeoptimizationDetails) {
1439       tty-&gt;print_cr(&quot;reassign fields for object of type %s!&quot;, k-&gt;name()-&gt;as_C_string());
1440     }
1441     if (obj.is_null()) {
1442       continue;
1443     }
1444 #if INCLUDE_JVMCI || INCLUDE_AOT
1445     // Don&#39;t reassign fields of boxes that came from a cache. Caches may be in CDS.
1446     if (sv-&gt;is_auto_box() &amp;&amp; ((AutoBoxObjectValue*) sv)-&gt;is_cached()) {
1447       continue;
1448     }
1449 #endif // INCLUDE_JVMCI || INCLUDE_AOT
1450     if (k-&gt;is_instance_klass()) {
1451       InstanceKlass* ik = InstanceKlass::cast(k);
1452       reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal, 0, CHECK);
1453     } else if (k-&gt;is_valueArray_klass()) {
1454       ValueArrayKlass* vak = ValueArrayKlass::cast(k);
1455       reassign_value_array_elements(fr, reg_map, sv, (valueArrayOop) obj(), vak, CHECK);
1456     } else if (k-&gt;is_typeArray_klass()) {
1457       TypeArrayKlass* ak = TypeArrayKlass::cast(k);
1458       reassign_type_array_elements(fr, reg_map, sv, (typeArrayOop) obj(), ak-&gt;element_type());
1459     } else if (k-&gt;is_objArray_klass()) {
1460       reassign_object_array_elements(fr, reg_map, sv, (objArrayOop) obj());
1461     }
1462   }
1463 }
1464 
1465 
1466 // relock objects for which synchronization was eliminated
1467 void Deoptimization::relock_objects(GrowableArray&lt;MonitorInfo*&gt;* monitors, JavaThread* thread, bool realloc_failures) {
1468   for (int i = 0; i &lt; monitors-&gt;length(); i++) {
1469     MonitorInfo* mon_info = monitors-&gt;at(i);
1470     if (mon_info-&gt;eliminated()) {
1471       assert(!mon_info-&gt;owner_is_scalar_replaced() || realloc_failures, &quot;reallocation was missed&quot;);
1472       if (!mon_info-&gt;owner_is_scalar_replaced()) {
1473         Handle obj(thread, mon_info-&gt;owner());
1474         markWord mark = obj-&gt;mark();
1475         if (UseBiasedLocking &amp;&amp; mark.has_bias_pattern()) {
1476           // New allocated objects may have the mark set to anonymously biased.
1477           // Also the deoptimized method may called methods with synchronization
1478           // where the thread-local object is bias locked to the current thread.
1479           assert(mark.is_biased_anonymously() ||
1480                  mark.biased_locker() == thread, &quot;should be locked to current thread&quot;);
1481           // Reset mark word to unbiased prototype.
1482           markWord unbiased_prototype = markWord::prototype().set_age(mark.age());
1483           obj-&gt;set_mark(unbiased_prototype);
1484         }
1485         BasicLock* lock = mon_info-&gt;lock();
1486         ObjectSynchronizer::enter(obj, lock, thread);
1487         assert(mon_info-&gt;owner()-&gt;is_locked(), &quot;object must be locked now&quot;);
1488       }
1489     }
1490   }
1491 }
1492 
1493 
1494 #ifndef PRODUCT
1495 // print information about reallocated objects
1496 void Deoptimization::print_objects(GrowableArray&lt;ScopeValue*&gt;* objects, bool realloc_failures) {
1497   fieldDescriptor fd;
1498   for (int i = 0; i &lt; objects-&gt;length(); i++) {
1499     ObjectValue* sv = (ObjectValue*) objects-&gt;at(i);
1500     Klass* k = java_lang_Class::as_Klass(sv-&gt;klass()-&gt;as_ConstantOopReadValue()-&gt;value()());
1501     print_object(k, sv-&gt;value(), realloc_failures);
1502   }
1503 }
1504 
1505 void Deoptimization::print_object(Klass* k, Handle obj, bool realloc_failures) {
1506   tty-&gt;print(&quot;     object &lt;&quot; INTPTR_FORMAT &quot;&gt; of type &quot;, p2i(obj()));
1507   k-&gt;print_value();
1508   assert(obj.not_null() || realloc_failures, &quot;reallocation was missed&quot;);
1509   if (obj.is_null()) {
1510     tty-&gt;print(&quot; allocation failed&quot;);
1511   } else {
1512     tty-&gt;print(&quot; allocated (%d bytes)&quot;, obj-&gt;size() * HeapWordSize);
1513   }
1514   tty-&gt;cr();
1515 
1516   if (Verbose &amp;&amp; !obj.is_null()) {
1517     k-&gt;oop_print_on(obj(), tty);
1518   }
1519 }
1520 #endif
1521 #endif // COMPILER2_OR_JVMCI
1522 
1523 vframeArray* Deoptimization::create_vframeArray(JavaThread* thread, frame fr, RegisterMap *reg_map, GrowableArray&lt;compiledVFrame*&gt;* chunk, bool realloc_failures) {
1524   Events::log_deopt_message(thread, &quot;DEOPT PACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT, p2i(fr.pc()), p2i(fr.sp()));
1525 
1526 #ifndef PRODUCT
1527   if (PrintDeoptimizationDetails) {
1528     ttyLocker ttyl;
1529     tty-&gt;print(&quot;DEOPT PACKING thread &quot; INTPTR_FORMAT &quot; &quot;, p2i(thread));
1530     fr.print_on(tty);
1531     tty-&gt;print_cr(&quot;     Virtual frames (innermost first):&quot;);
1532     for (int index = 0; index &lt; chunk-&gt;length(); index++) {
1533       compiledVFrame* vf = chunk-&gt;at(index);
1534       tty-&gt;print(&quot;       %2d - &quot;, index);
1535       vf-&gt;print_value();
1536       int bci = chunk-&gt;at(index)-&gt;raw_bci();
1537       const char* code_name;
1538       if (bci == SynchronizationEntryBCI) {
1539         code_name = &quot;sync entry&quot;;
1540       } else {
1541         Bytecodes::Code code = vf-&gt;method()-&gt;code_at(bci);
1542         code_name = Bytecodes::name(code);
1543       }
1544       tty-&gt;print(&quot; - %s&quot;, code_name);
1545       tty-&gt;print_cr(&quot; @ bci %d &quot;, bci);
1546       if (Verbose) {
1547         vf-&gt;print();
1548         tty-&gt;cr();
1549       }
1550     }
1551   }
1552 #endif
1553 
1554   // Register map for next frame (used for stack crawl).  We capture
1555   // the state of the deopt&#39;ing frame&#39;s caller.  Thus if we need to
1556   // stuff a C2I adapter we can properly fill in the callee-save
1557   // register locations.
1558   frame caller = fr.sender(reg_map);
1559   int frame_size = caller.sp() - fr.sp();
1560 
1561   frame sender = caller;
1562 
1563   // Since the Java thread being deoptimized will eventually adjust it&#39;s own stack,
1564   // the vframeArray containing the unpacking information is allocated in the C heap.
1565   // For Compiler1, the caller of the deoptimized frame is saved for use by unpack_frames().
1566   vframeArray* array = vframeArray::allocate(thread, frame_size, chunk, reg_map, sender, caller, fr, realloc_failures);
1567 
1568   // Compare the vframeArray to the collected vframes
1569   assert(array-&gt;structural_compare(thread, chunk), &quot;just checking&quot;);
1570 
1571 #ifndef PRODUCT
1572   if (PrintDeoptimizationDetails) {
1573     ttyLocker ttyl;
1574     tty-&gt;print_cr(&quot;     Created vframeArray &quot; INTPTR_FORMAT, p2i(array));
1575   }
1576 #endif // PRODUCT
1577 
1578   return array;
1579 }
1580 
1581 #if COMPILER2_OR_JVMCI
1582 void Deoptimization::pop_frames_failed_reallocs(JavaThread* thread, vframeArray* array) {
1583   // Reallocation of some scalar replaced objects failed. Record
1584   // that we need to pop all the interpreter frames for the
1585   // deoptimized compiled frame.
1586   assert(thread-&gt;frames_to_pop_failed_realloc() == 0, &quot;missed frames to pop?&quot;);
1587   thread-&gt;set_frames_to_pop_failed_realloc(array-&gt;frames());
1588   // Unlock all monitors here otherwise the interpreter will see a
1589   // mix of locked and unlocked monitors (because of failed
1590   // reallocations of synchronized objects) and be confused.
1591   for (int i = 0; i &lt; array-&gt;frames(); i++) {
1592     MonitorChunk* monitors = array-&gt;element(i)-&gt;monitors();
1593     if (monitors != NULL) {
1594       for (int j = 0; j &lt; monitors-&gt;number_of_monitors(); j++) {
1595         BasicObjectLock* src = monitors-&gt;at(j);
1596         if (src-&gt;obj() != NULL) {
1597           ObjectSynchronizer::exit(src-&gt;obj(), src-&gt;lock(), thread);
1598         }
1599       }
1600       array-&gt;element(i)-&gt;free_monitors(thread);
1601 #ifdef ASSERT
1602       array-&gt;element(i)-&gt;set_removed_monitors();
1603 #endif
1604     }
1605   }
1606 }
1607 #endif
1608 
1609 static void collect_monitors(compiledVFrame* cvf, GrowableArray&lt;Handle&gt;* objects_to_revoke) {
1610   GrowableArray&lt;MonitorInfo*&gt;* monitors = cvf-&gt;monitors();
1611   Thread* thread = Thread::current();
1612   for (int i = 0; i &lt; monitors-&gt;length(); i++) {
1613     MonitorInfo* mon_info = monitors-&gt;at(i);
1614     if (!mon_info-&gt;eliminated() &amp;&amp; mon_info-&gt;owner() != NULL) {
1615       objects_to_revoke-&gt;append(Handle(thread, mon_info-&gt;owner()));
1616     }
1617   }
1618 }
1619 
1620 static void get_monitors_from_stack(GrowableArray&lt;Handle&gt;* objects_to_revoke, JavaThread* thread, frame fr, RegisterMap* map) {
1621   // Unfortunately we don&#39;t have a RegisterMap available in most of
1622   // the places we want to call this routine so we need to walk the
1623   // stack again to update the register map.
1624   if (map == NULL || !map-&gt;update_map()) {
1625     StackFrameStream sfs(thread, true);
1626     bool found = false;
1627     while (!found &amp;&amp; !sfs.is_done()) {
1628       frame* cur = sfs.current();
1629       sfs.next();
1630       found = cur-&gt;id() == fr.id();
1631     }
1632     assert(found, &quot;frame to be deoptimized not found on target thread&#39;s stack&quot;);
1633     map = sfs.register_map();
1634   }
1635 
1636   vframe* vf = vframe::new_vframe(&amp;fr, map, thread);
1637   compiledVFrame* cvf = compiledVFrame::cast(vf);
1638   // Revoke monitors&#39; biases in all scopes
1639   while (!cvf-&gt;is_top()) {
1640     collect_monitors(cvf, objects_to_revoke);
1641     cvf = compiledVFrame::cast(cvf-&gt;sender());
1642   }
1643   collect_monitors(cvf, objects_to_revoke);
1644 }
1645 
1646 void Deoptimization::revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map) {
1647   if (!UseBiasedLocking) {
1648     return;
1649   }
1650   GrowableArray&lt;Handle&gt;* objects_to_revoke = new GrowableArray&lt;Handle&gt;();
1651   get_monitors_from_stack(objects_to_revoke, thread, fr, map);
1652 
1653   int len = objects_to_revoke-&gt;length();
1654   for (int i = 0; i &lt; len; i++) {
1655     oop obj = (objects_to_revoke-&gt;at(i))();
1656     BiasedLocking::revoke_own_lock(objects_to_revoke-&gt;at(i), thread);
1657     assert(!obj-&gt;mark().has_bias_pattern(), &quot;biases should be revoked by now&quot;);
1658   }
1659 }
1660 
1661 
1662 void Deoptimization::deoptimize_single_frame(JavaThread* thread, frame fr, Deoptimization::DeoptReason reason) {
1663   assert(fr.can_be_deoptimized(), &quot;checking frame type&quot;);
1664 
1665   gather_statistics(reason, Action_none, Bytecodes::_illegal);
1666 
1667   if (LogCompilation &amp;&amp; xtty != NULL) {
1668     CompiledMethod* cm = fr.cb()-&gt;as_compiled_method_or_null();
1669     assert(cm != NULL, &quot;only compiled methods can deopt&quot;);
1670 
1671     ttyLocker ttyl;
1672     xtty-&gt;begin_head(&quot;deoptimized thread=&#39;&quot; UINTX_FORMAT &quot;&#39; reason=&#39;%s&#39; pc=&#39;&quot; INTPTR_FORMAT &quot;&#39;&quot;,(uintx)thread-&gt;osthread()-&gt;thread_id(), trap_reason_name(reason), p2i(fr.pc()));
1673     cm-&gt;log_identity(xtty);
1674     xtty-&gt;end_head();
1675     for (ScopeDesc* sd = cm-&gt;scope_desc_at(fr.pc()); ; sd = sd-&gt;sender()) {
1676       xtty-&gt;begin_elem(&quot;jvms bci=&#39;%d&#39;&quot;, sd-&gt;bci());
1677       xtty-&gt;method(sd-&gt;method());
1678       xtty-&gt;end_elem();
1679       if (sd-&gt;is_top())  break;
1680     }
1681     xtty-&gt;tail(&quot;deoptimized&quot;);
1682   }
1683 
1684   // Patch the compiled method so that when execution returns to it we will
1685   // deopt the execution state and return to the interpreter.
1686   fr.deoptimize(thread);
1687 }
1688 
1689 void Deoptimization::deoptimize(JavaThread* thread, frame fr, DeoptReason reason) {
1690   // Deoptimize only if the frame comes from compiled code.
1691   // Do not deoptimize the frame which is already patched
1692   // during the execution of the loops below.
1693   if (!fr.is_compiled_frame() || fr.is_deoptimized_frame()) {
1694     return;
1695   }
1696   ResourceMark rm;
1697   DeoptimizationMarker dm;
1698   deoptimize_single_frame(thread, fr, reason);
1699 }
1700 
1701 #if INCLUDE_JVMCI
1702 address Deoptimization::deoptimize_for_missing_exception_handler(CompiledMethod* cm) {
1703   // there is no exception handler for this pc =&gt; deoptimize
1704   cm-&gt;make_not_entrant();
1705 
1706   // Use Deoptimization::deoptimize for all of its side-effects:
1707   // gathering traps statistics, logging...
1708   // it also patches the return pc but we do not care about that
1709   // since we return a continuation to the deopt_blob below.
1710   JavaThread* thread = JavaThread::current();
1711   RegisterMap reg_map(thread, false);
1712   frame runtime_frame = thread-&gt;last_frame();
1713   frame caller_frame = runtime_frame.sender(&amp;reg_map);
1714   assert(caller_frame.cb()-&gt;as_compiled_method_or_null() == cm, &quot;expect top frame compiled method&quot;);
1715   Deoptimization::deoptimize(thread, caller_frame, Deoptimization::Reason_not_compiled_exception_handler);
1716 
1717   MethodData* trap_mdo = get_method_data(thread, methodHandle(thread, cm-&gt;method()), true);
1718   if (trap_mdo != NULL) {
1719     trap_mdo-&gt;inc_trap_count(Deoptimization::Reason_not_compiled_exception_handler);
1720   }
1721 
1722   return SharedRuntime::deopt_blob()-&gt;unpack_with_exception_in_tls();
1723 }
1724 #endif
1725 
1726 void Deoptimization::deoptimize_frame_internal(JavaThread* thread, intptr_t* id, DeoptReason reason) {
1727   assert(thread == Thread::current() || SafepointSynchronize::is_at_safepoint(),
1728          &quot;can only deoptimize other thread at a safepoint&quot;);
1729   // Compute frame and register map based on thread and sp.
1730   RegisterMap reg_map(thread, false);
1731   frame fr = thread-&gt;last_frame();
1732   while (fr.id() != id) {
1733     fr = fr.sender(&amp;reg_map);
1734   }
1735   deoptimize(thread, fr, reason);
1736 }
1737 
1738 
1739 void Deoptimization::deoptimize_frame(JavaThread* thread, intptr_t* id, DeoptReason reason) {
1740   if (thread == Thread::current()) {
1741     Deoptimization::deoptimize_frame_internal(thread, id, reason);
1742   } else {
1743     VM_DeoptimizeFrame deopt(thread, id, reason);
1744     VMThread::execute(&amp;deopt);
1745   }
1746 }
1747 
1748 void Deoptimization::deoptimize_frame(JavaThread* thread, intptr_t* id) {
1749   deoptimize_frame(thread, id, Reason_constraint);
1750 }
1751 
1752 // JVMTI PopFrame support
1753 JRT_LEAF(void, Deoptimization::popframe_preserve_args(JavaThread* thread, int bytes_to_save, void* start_address))
1754 {
1755   thread-&gt;popframe_preserve_args(in_ByteSize(bytes_to_save), start_address);
1756 }
1757 JRT_END
1758 
1759 MethodData*
1760 Deoptimization::get_method_data(JavaThread* thread, const methodHandle&amp; m,
1761                                 bool create_if_missing) {
1762   Thread* THREAD = thread;
1763   MethodData* mdo = m()-&gt;method_data();
1764   if (mdo == NULL &amp;&amp; create_if_missing &amp;&amp; !HAS_PENDING_EXCEPTION) {
1765     // Build an MDO.  Ignore errors like OutOfMemory;
1766     // that simply means we won&#39;t have an MDO to update.
1767     Method::build_interpreter_method_data(m, THREAD);
1768     if (HAS_PENDING_EXCEPTION) {
1769       assert((PENDING_EXCEPTION-&gt;is_a(SystemDictionary::OutOfMemoryError_klass())), &quot;we expect only an OOM error here&quot;);
1770       CLEAR_PENDING_EXCEPTION;
1771     }
1772     mdo = m()-&gt;method_data();
1773   }
1774   return mdo;
1775 }
1776 
1777 #if COMPILER2_OR_JVMCI
1778 void Deoptimization::load_class_by_index(const constantPoolHandle&amp; constant_pool, int index, TRAPS) {
1779   // In case of an unresolved klass entry, load the class.
1780   // This path is exercised from case _ldc in Parse::do_one_bytecode,
1781   // and probably nowhere else.
1782   // Even that case would benefit from simply re-interpreting the
1783   // bytecode, without paying special attention to the class index.
1784   // So this whole &quot;class index&quot; feature should probably be removed.
1785 
1786   if (constant_pool-&gt;tag_at(index).is_unresolved_klass()) {
1787     Klass* tk = constant_pool-&gt;klass_at_ignore_error(index, CHECK);
1788     return;
1789   }
1790 
1791   assert(!constant_pool-&gt;tag_at(index).is_symbol(),
1792          &quot;no symbolic names here, please&quot;);
1793 }
1794 
1795 
1796 void Deoptimization::load_class_by_index(const constantPoolHandle&amp; constant_pool, int index) {
1797   EXCEPTION_MARK;
1798   load_class_by_index(constant_pool, index, THREAD);
1799   if (HAS_PENDING_EXCEPTION) {
1800     // Exception happened during classloading. We ignore the exception here, since it
1801     // is going to be rethrown since the current activation is going to be deoptimized and
1802     // the interpreter will re-execute the bytecode.
1803     CLEAR_PENDING_EXCEPTION;
1804     // Class loading called java code which may have caused a stack
1805     // overflow. If the exception was thrown right before the return
1806     // to the runtime the stack is no longer guarded. Reguard the
1807     // stack otherwise if we return to the uncommon trap blob and the
1808     // stack bang causes a stack overflow we crash.
1809     assert(THREAD-&gt;is_Java_thread(), &quot;only a java thread can be here&quot;);
1810     JavaThread* thread = (JavaThread*)THREAD;
1811     bool guard_pages_enabled = thread-&gt;stack_guards_enabled();
1812     if (!guard_pages_enabled) guard_pages_enabled = thread-&gt;reguard_stack();
1813     assert(guard_pages_enabled, &quot;stack banging in uncommon trap blob may cause crash&quot;);
1814   }
1815 }
1816 
1817 #if INCLUDE_JFR
1818 
1819 class DeoptReasonSerializer : public JfrSerializer {
1820  public:
1821   void serialize(JfrCheckpointWriter&amp; writer) {
1822     writer.write_count((u4)(Deoptimization::Reason_LIMIT + 1)); // + Reason::many (-1)
1823     for (int i = -1; i &lt; Deoptimization::Reason_LIMIT; ++i) {
1824       writer.write_key((u8)i);
1825       writer.write(Deoptimization::trap_reason_name(i));
1826     }
1827   }
1828 };
1829 
1830 class DeoptActionSerializer : public JfrSerializer {
1831  public:
1832   void serialize(JfrCheckpointWriter&amp; writer) {
1833     static const u4 nof_actions = Deoptimization::Action_LIMIT;
1834     writer.write_count(nof_actions);
1835     for (u4 i = 0; i &lt; Deoptimization::Action_LIMIT; ++i) {
1836       writer.write_key(i);
1837       writer.write(Deoptimization::trap_action_name((int)i));
1838     }
1839   }
1840 };
1841 
1842 static void register_serializers() {
1843   static int critical_section = 0;
1844   if (1 == critical_section || Atomic::cmpxchg(&amp;critical_section, 0, 1) == 1) {
1845     return;
1846   }
1847   JfrSerializer::register_serializer(TYPE_DEOPTIMIZATIONREASON, true, new DeoptReasonSerializer());
1848   JfrSerializer::register_serializer(TYPE_DEOPTIMIZATIONACTION, true, new DeoptActionSerializer());
1849 }
1850 
1851 static void post_deoptimization_event(CompiledMethod* nm,
1852                                       const Method* method,
1853                                       int trap_bci,
1854                                       int instruction,
1855                                       Deoptimization::DeoptReason reason,
1856                                       Deoptimization::DeoptAction action) {
1857   assert(nm != NULL, &quot;invariant&quot;);
1858   assert(method != NULL, &quot;invariant&quot;);
1859   if (EventDeoptimization::is_enabled()) {
1860     static bool serializers_registered = false;
1861     if (!serializers_registered) {
1862       register_serializers();
1863       serializers_registered = true;
1864     }
1865     EventDeoptimization event;
1866     event.set_compileId(nm-&gt;compile_id());
1867     event.set_compiler(nm-&gt;compiler_type());
1868     event.set_method(method);
1869     event.set_lineNumber(method-&gt;line_number_from_bci(trap_bci));
1870     event.set_bci(trap_bci);
1871     event.set_instruction(instruction);
1872     event.set_reason(reason);
1873     event.set_action(action);
1874     event.commit();
1875   }
1876 }
1877 
1878 #endif // INCLUDE_JFR
1879 
1880 JRT_ENTRY(void, Deoptimization::uncommon_trap_inner(JavaThread* thread, jint trap_request)) {
1881   HandleMark hm;
1882 
1883   // uncommon_trap() is called at the beginning of the uncommon trap
1884   // handler. Note this fact before we start generating temporary frames
1885   // that can confuse an asynchronous stack walker. This counter is
1886   // decremented at the end of unpack_frames().
1887   thread-&gt;inc_in_deopt_handler();
1888 
1889   // We need to update the map if we have biased locking.
1890 #if INCLUDE_JVMCI
1891   // JVMCI might need to get an exception from the stack, which in turn requires the register map to be valid
1892   RegisterMap reg_map(thread, true);
1893 #else
1894   RegisterMap reg_map(thread, UseBiasedLocking);
1895 #endif
1896   frame stub_frame = thread-&gt;last_frame();
1897   frame fr = stub_frame.sender(&amp;reg_map);
1898   // Make sure the calling nmethod is not getting deoptimized and removed
1899   // before we are done with it.
1900   nmethodLocker nl(fr.pc());
1901 
1902   // Log a message
1903   Events::log_deopt_message(thread, &quot;Uncommon trap: trap_request=&quot; PTR32_FORMAT &quot; fr.pc=&quot; INTPTR_FORMAT &quot; relative=&quot; INTPTR_FORMAT,
1904               trap_request, p2i(fr.pc()), fr.pc() - fr.cb()-&gt;code_begin());
1905 
1906   {
1907     ResourceMark rm;
1908 
1909     DeoptReason reason = trap_request_reason(trap_request);
1910     DeoptAction action = trap_request_action(trap_request);
1911 #if INCLUDE_JVMCI
1912     int debug_id = trap_request_debug_id(trap_request);
1913 #endif
1914     jint unloaded_class_index = trap_request_index(trap_request); // CP idx or -1
1915 
1916     vframe*  vf  = vframe::new_vframe(&amp;fr, &amp;reg_map, thread);
1917     compiledVFrame* cvf = compiledVFrame::cast(vf);
1918 
1919     CompiledMethod* nm = cvf-&gt;code();
1920 
1921     ScopeDesc*      trap_scope  = cvf-&gt;scope();
1922 
1923     if (TraceDeoptimization) {
1924       ttyLocker ttyl;
1925       tty-&gt;print_cr(&quot;  bci=%d pc=&quot; INTPTR_FORMAT &quot;, relative_pc=&quot; INTPTR_FORMAT &quot;, method=%s&quot; JVMCI_ONLY(&quot;, debug_id=%d&quot;), trap_scope-&gt;bci(), p2i(fr.pc()), fr.pc() - nm-&gt;code_begin(), trap_scope-&gt;method()-&gt;name_and_sig_as_C_string()
1926 #if INCLUDE_JVMCI
1927           , debug_id
1928 #endif
1929           );
1930     }
1931 
1932     methodHandle    trap_method(THREAD, trap_scope-&gt;method());
1933     int             trap_bci    = trap_scope-&gt;bci();
1934 #if INCLUDE_JVMCI
1935     jlong           speculation = thread-&gt;pending_failed_speculation();
1936     if (nm-&gt;is_compiled_by_jvmci() &amp;&amp; nm-&gt;is_nmethod()) { // Exclude AOTed methods
1937       nm-&gt;as_nmethod()-&gt;update_speculation(thread);
1938     } else {
1939       assert(speculation == 0, &quot;There should not be a speculation for methods compiled by non-JVMCI compilers&quot;);
1940     }
1941 
1942     if (trap_bci == SynchronizationEntryBCI) {
1943       trap_bci = 0;
1944       thread-&gt;set_pending_monitorenter(true);
1945     }
1946 
1947     if (reason == Deoptimization::Reason_transfer_to_interpreter) {
1948       thread-&gt;set_pending_transfer_to_interpreter(true);
1949     }
1950 #endif
1951 
1952     Bytecodes::Code trap_bc     = trap_method-&gt;java_code_at(trap_bci);
1953     // Record this event in the histogram.
1954     gather_statistics(reason, action, trap_bc);
1955 
1956     // Ensure that we can record deopt. history:
1957     // Need MDO to record RTM code generation state.
1958     bool create_if_missing = ProfileTraps || UseCodeAging RTM_OPT_ONLY( || UseRTMLocking );
1959 
1960     methodHandle profiled_method;
1961 #if INCLUDE_JVMCI
1962     if (nm-&gt;is_compiled_by_jvmci()) {
1963       profiled_method = methodHandle(THREAD, nm-&gt;method());
1964     } else {
1965       profiled_method = trap_method;
1966     }
1967 #else
1968     profiled_method = trap_method;
1969 #endif
1970 
1971     MethodData* trap_mdo =
1972       get_method_data(thread, profiled_method, create_if_missing);
1973 
1974     JFR_ONLY(post_deoptimization_event(nm, trap_method(), trap_bci, trap_bc, reason, action);)
1975 
1976     // Log a message
1977     Events::log_deopt_message(thread, &quot;Uncommon trap: reason=%s action=%s pc=&quot; INTPTR_FORMAT &quot; method=%s @ %d %s&quot;,
1978                               trap_reason_name(reason), trap_action_name(action), p2i(fr.pc()),
1979                               trap_method-&gt;name_and_sig_as_C_string(), trap_bci, nm-&gt;compiler_name());
1980 
1981     // Print a bunch of diagnostics, if requested.
1982     if (TraceDeoptimization || LogCompilation) {
1983       ResourceMark rm;
1984       ttyLocker ttyl;
1985       char buf[100];
1986       if (xtty != NULL) {
1987         xtty-&gt;begin_head(&quot;uncommon_trap thread=&#39;&quot; UINTX_FORMAT &quot;&#39; %s&quot;,
1988                          os::current_thread_id(),
1989                          format_trap_request(buf, sizeof(buf), trap_request));
1990 #if INCLUDE_JVMCI
1991         if (speculation != 0) {
1992           xtty-&gt;print(&quot; speculation=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, speculation);
1993         }
1994 #endif
1995         nm-&gt;log_identity(xtty);
1996       }
1997       Symbol* class_name = NULL;
1998       bool unresolved = false;
1999       if (unloaded_class_index &gt;= 0) {
2000         constantPoolHandle constants (THREAD, trap_method-&gt;constants());
2001         if (constants-&gt;tag_at(unloaded_class_index).is_unresolved_klass()) {
2002           class_name = constants-&gt;klass_name_at(unloaded_class_index);
2003           unresolved = true;
2004           if (xtty != NULL)
2005             xtty-&gt;print(&quot; unresolved=&#39;1&#39;&quot;);
2006         } else if (constants-&gt;tag_at(unloaded_class_index).is_symbol()) {
2007           class_name = constants-&gt;symbol_at(unloaded_class_index);
2008         }
2009         if (xtty != NULL)
2010           xtty-&gt;name(class_name);
2011       }
2012       if (xtty != NULL &amp;&amp; trap_mdo != NULL &amp;&amp; (int)reason &lt; (int)MethodData::_trap_hist_limit) {
2013         // Dump the relevant MDO state.
2014         // This is the deopt count for the current reason, any previous
2015         // reasons or recompiles seen at this point.
2016         int dcnt = trap_mdo-&gt;trap_count(reason);
2017         if (dcnt != 0)
2018           xtty-&gt;print(&quot; count=&#39;%d&#39;&quot;, dcnt);
2019         ProfileData* pdata = trap_mdo-&gt;bci_to_data(trap_bci);
2020         int dos = (pdata == NULL)? 0: pdata-&gt;trap_state();
2021         if (dos != 0) {
2022           xtty-&gt;print(&quot; state=&#39;%s&#39;&quot;, format_trap_state(buf, sizeof(buf), dos));
2023           if (trap_state_is_recompiled(dos)) {
2024             int recnt2 = trap_mdo-&gt;overflow_recompile_count();
2025             if (recnt2 != 0)
2026               xtty-&gt;print(&quot; recompiles2=&#39;%d&#39;&quot;, recnt2);
2027           }
2028         }
2029       }
2030       if (xtty != NULL) {
2031         xtty-&gt;stamp();
2032         xtty-&gt;end_head();
2033       }
2034       if (TraceDeoptimization) {  // make noise on the tty
2035         tty-&gt;print(&quot;Uncommon trap occurred in&quot;);
2036         nm-&gt;method()-&gt;print_short_name(tty);
2037         tty-&gt;print(&quot; compiler=%s compile_id=%d&quot;, nm-&gt;compiler_name(), nm-&gt;compile_id());
2038 #if INCLUDE_JVMCI
2039         if (nm-&gt;is_nmethod()) {
2040           const char* installed_code_name = nm-&gt;as_nmethod()-&gt;jvmci_name();
2041           if (installed_code_name != NULL) {
2042             tty-&gt;print(&quot; (JVMCI: installed code name=%s) &quot;, installed_code_name);
2043           }
2044         }
2045 #endif
2046         tty-&gt;print(&quot; (@&quot; INTPTR_FORMAT &quot;) thread=&quot; UINTX_FORMAT &quot; reason=%s action=%s unloaded_class_index=%d&quot; JVMCI_ONLY(&quot; debug_id=%d&quot;),
2047                    p2i(fr.pc()),
2048                    os::current_thread_id(),
2049                    trap_reason_name(reason),
2050                    trap_action_name(action),
2051                    unloaded_class_index
2052 #if INCLUDE_JVMCI
2053                    , debug_id
2054 #endif
2055                    );
2056         if (class_name != NULL) {
2057           tty-&gt;print(unresolved ? &quot; unresolved class: &quot; : &quot; symbol: &quot;);
2058           class_name-&gt;print_symbol_on(tty);
2059         }
2060         tty-&gt;cr();
2061       }
2062       if (xtty != NULL) {
2063         // Log the precise location of the trap.
2064         for (ScopeDesc* sd = trap_scope; ; sd = sd-&gt;sender()) {
2065           xtty-&gt;begin_elem(&quot;jvms bci=&#39;%d&#39;&quot;, sd-&gt;bci());
2066           xtty-&gt;method(sd-&gt;method());
2067           xtty-&gt;end_elem();
2068           if (sd-&gt;is_top())  break;
2069         }
2070         xtty-&gt;tail(&quot;uncommon_trap&quot;);
2071       }
2072     }
2073     // (End diagnostic printout.)
2074 
2075     // Load class if necessary
2076     if (unloaded_class_index &gt;= 0) {
2077       constantPoolHandle constants(THREAD, trap_method-&gt;constants());
2078       load_class_by_index(constants, unloaded_class_index);
2079     }
2080 
2081     // Flush the nmethod if necessary and desirable.
2082     //
2083     // We need to avoid situations where we are re-flushing the nmethod
2084     // because of a hot deoptimization site.  Repeated flushes at the same
2085     // point need to be detected by the compiler and avoided.  If the compiler
2086     // cannot avoid them (or has a bug and &quot;refuses&quot; to avoid them), this
2087     // module must take measures to avoid an infinite cycle of recompilation
2088     // and deoptimization.  There are several such measures:
2089     //
2090     //   1. If a recompilation is ordered a second time at some site X
2091     //   and for the same reason R, the action is adjusted to &#39;reinterpret&#39;,
2092     //   to give the interpreter time to exercise the method more thoroughly.
2093     //   If this happens, the method&#39;s overflow_recompile_count is incremented.
2094     //
2095     //   2. If the compiler fails to reduce the deoptimization rate, then
2096     //   the method&#39;s overflow_recompile_count will begin to exceed the set
2097     //   limit PerBytecodeRecompilationCutoff.  If this happens, the action
2098     //   is adjusted to &#39;make_not_compilable&#39;, and the method is abandoned
2099     //   to the interpreter.  This is a performance hit for hot methods,
2100     //   but is better than a disastrous infinite cycle of recompilations.
2101     //   (Actually, only the method containing the site X is abandoned.)
2102     //
2103     //   3. In parallel with the previous measures, if the total number of
2104     //   recompilations of a method exceeds the much larger set limit
2105     //   PerMethodRecompilationCutoff, the method is abandoned.
2106     //   This should only happen if the method is very large and has
2107     //   many &quot;lukewarm&quot; deoptimizations.  The code which enforces this
2108     //   limit is elsewhere (class nmethod, class Method).
2109     //
2110     // Note that the per-BCI &#39;is_recompiled&#39; bit gives the compiler one chance
2111     // to recompile at each bytecode independently of the per-BCI cutoff.
2112     //
2113     // The decision to update code is up to the compiler, and is encoded
2114     // in the Action_xxx code.  If the compiler requests Action_none
2115     // no trap state is changed, no compiled code is changed, and the
2116     // computation suffers along in the interpreter.
2117     //
2118     // The other action codes specify various tactics for decompilation
2119     // and recompilation.  Action_maybe_recompile is the loosest, and
2120     // allows the compiled code to stay around until enough traps are seen,
2121     // and until the compiler gets around to recompiling the trapping method.
2122     //
2123     // The other actions cause immediate removal of the present code.
2124 
2125     // Traps caused by injected profile shouldn&#39;t pollute trap counts.
2126     bool injected_profile_trap = trap_method-&gt;has_injected_profile() &amp;&amp;
2127                                  (reason == Reason_intrinsic || reason == Reason_unreached);
2128 
2129     bool update_trap_state = (reason != Reason_tenured) &amp;&amp; !injected_profile_trap;
2130     bool make_not_entrant = false;
2131     bool make_not_compilable = false;
2132     bool reprofile = false;
2133     switch (action) {
2134     case Action_none:
2135       // Keep the old code.
2136       update_trap_state = false;
2137       break;
2138     case Action_maybe_recompile:
2139       // Do not need to invalidate the present code, but we can
2140       // initiate another
2141       // Start compiler without (necessarily) invalidating the nmethod.
2142       // The system will tolerate the old code, but new code should be
2143       // generated when possible.
2144       break;
2145     case Action_reinterpret:
2146       // Go back into the interpreter for a while, and then consider
2147       // recompiling form scratch.
2148       make_not_entrant = true;
2149       // Reset invocation counter for outer most method.
2150       // This will allow the interpreter to exercise the bytecodes
2151       // for a while before recompiling.
2152       // By contrast, Action_make_not_entrant is immediate.
2153       //
2154       // Note that the compiler will track null_check, null_assert,
2155       // range_check, and class_check events and log them as if they
2156       // had been traps taken from compiled code.  This will update
2157       // the MDO trap history so that the next compilation will
2158       // properly detect hot trap sites.
2159       reprofile = true;
2160       break;
2161     case Action_make_not_entrant:
2162       // Request immediate recompilation, and get rid of the old code.
2163       // Make them not entrant, so next time they are called they get
2164       // recompiled.  Unloaded classes are loaded now so recompile before next
2165       // time they are called.  Same for uninitialized.  The interpreter will
2166       // link the missing class, if any.
2167       make_not_entrant = true;
2168       break;
2169     case Action_make_not_compilable:
2170       // Give up on compiling this method at all.
2171       make_not_entrant = true;
2172       make_not_compilable = true;
2173       break;
2174     default:
2175       ShouldNotReachHere();
2176     }
2177 
2178     // Setting +ProfileTraps fixes the following, on all platforms:
2179     // 4852688: ProfileInterpreter is off by default for ia64.  The result is
2180     // infinite heroic-opt-uncommon-trap/deopt/recompile cycles, since the
2181     // recompile relies on a MethodData* to record heroic opt failures.
2182 
2183     // Whether the interpreter is producing MDO data or not, we also need
2184     // to use the MDO to detect hot deoptimization points and control
2185     // aggressive optimization.
2186     bool inc_recompile_count = false;
2187     ProfileData* pdata = NULL;
2188     if (ProfileTraps &amp;&amp; !is_client_compilation_mode_vm() &amp;&amp; update_trap_state &amp;&amp; trap_mdo != NULL) {
2189       assert(trap_mdo == get_method_data(thread, profiled_method, false), &quot;sanity&quot;);
2190       uint this_trap_count = 0;
2191       bool maybe_prior_trap = false;
2192       bool maybe_prior_recompile = false;
2193       pdata = query_update_method_data(trap_mdo, trap_bci, reason, true,
2194 #if INCLUDE_JVMCI
2195                                    nm-&gt;is_compiled_by_jvmci() &amp;&amp; nm-&gt;is_osr_method(),
2196 #endif
2197                                    nm-&gt;method(),
2198                                    //outputs:
2199                                    this_trap_count,
2200                                    maybe_prior_trap,
2201                                    maybe_prior_recompile);
2202       // Because the interpreter also counts null, div0, range, and class
2203       // checks, these traps from compiled code are double-counted.
2204       // This is harmless; it just means that the PerXTrapLimit values
2205       // are in effect a little smaller than they look.
2206 
2207       DeoptReason per_bc_reason = reason_recorded_per_bytecode_if_any(reason);
2208       if (per_bc_reason != Reason_none) {
2209         // Now take action based on the partially known per-BCI history.
2210         if (maybe_prior_trap
2211             &amp;&amp; this_trap_count &gt;= (uint)PerBytecodeTrapLimit) {
2212           // If there are too many traps at this BCI, force a recompile.
2213           // This will allow the compiler to see the limit overflow, and
2214           // take corrective action, if possible.  The compiler generally
2215           // does not use the exact PerBytecodeTrapLimit value, but instead
2216           // changes its tactics if it sees any traps at all.  This provides
2217           // a little hysteresis, delaying a recompile until a trap happens
2218           // several times.
2219           //
2220           // Actually, since there is only one bit of counter per BCI,
2221           // the possible per-BCI counts are {0,1,(per-method count)}.
2222           // This produces accurate results if in fact there is only
2223           // one hot trap site, but begins to get fuzzy if there are
2224           // many sites.  For example, if there are ten sites each
2225           // trapping two or more times, they each get the blame for
2226           // all of their traps.
2227           make_not_entrant = true;
2228         }
2229 
2230         // Detect repeated recompilation at the same BCI, and enforce a limit.
2231         if (make_not_entrant &amp;&amp; maybe_prior_recompile) {
2232           // More than one recompile at this point.
2233           inc_recompile_count = maybe_prior_trap;
2234         }
2235       } else {
2236         // For reasons which are not recorded per-bytecode, we simply
2237         // force recompiles unconditionally.
2238         // (Note that PerMethodRecompilationCutoff is enforced elsewhere.)
2239         make_not_entrant = true;
2240       }
2241 
2242       // Go back to the compiler if there are too many traps in this method.
2243       if (this_trap_count &gt;= per_method_trap_limit(reason)) {
2244         // If there are too many traps in this method, force a recompile.
2245         // This will allow the compiler to see the limit overflow, and
2246         // take corrective action, if possible.
2247         // (This condition is an unlikely backstop only, because the
2248         // PerBytecodeTrapLimit is more likely to take effect first,
2249         // if it is applicable.)
2250         make_not_entrant = true;
2251       }
2252 
2253       // Here&#39;s more hysteresis:  If there has been a recompile at
2254       // this trap point already, run the method in the interpreter
2255       // for a while to exercise it more thoroughly.
2256       if (make_not_entrant &amp;&amp; maybe_prior_recompile &amp;&amp; maybe_prior_trap) {
2257         reprofile = true;
2258       }
2259     }
2260 
2261     // Take requested actions on the method:
2262 
2263     // Recompile
2264     if (make_not_entrant) {
2265       if (!nm-&gt;make_not_entrant()) {
2266         return; // the call did not change nmethod&#39;s state
2267       }
2268 
2269       if (pdata != NULL) {
2270         // Record the recompilation event, if any.
2271         int tstate0 = pdata-&gt;trap_state();
2272         int tstate1 = trap_state_set_recompiled(tstate0, true);
2273         if (tstate1 != tstate0)
2274           pdata-&gt;set_trap_state(tstate1);
2275       }
2276 
2277 #if INCLUDE_RTM_OPT
2278       // Restart collecting RTM locking abort statistic if the method
2279       // is recompiled for a reason other than RTM state change.
2280       // Assume that in new recompiled code the statistic could be different,
2281       // for example, due to different inlining.
2282       if ((reason != Reason_rtm_state_change) &amp;&amp; (trap_mdo != NULL) &amp;&amp;
2283           UseRTMDeopt &amp;&amp; (nm-&gt;as_nmethod()-&gt;rtm_state() != ProfileRTM)) {
2284         trap_mdo-&gt;atomic_set_rtm_state(ProfileRTM);
2285       }
2286 #endif
2287       // For code aging we count traps separately here, using make_not_entrant()
2288       // as a guard against simultaneous deopts in multiple threads.
2289       if (reason == Reason_tenured &amp;&amp; trap_mdo != NULL) {
2290         trap_mdo-&gt;inc_tenure_traps();
2291       }
2292     }
2293 
2294     if (inc_recompile_count) {
2295       trap_mdo-&gt;inc_overflow_recompile_count();
2296       if ((uint)trap_mdo-&gt;overflow_recompile_count() &gt;
2297           (uint)PerBytecodeRecompilationCutoff) {
2298         // Give up on the method containing the bad BCI.
2299         if (trap_method() == nm-&gt;method()) {
2300           make_not_compilable = true;
2301         } else {
2302           trap_method-&gt;set_not_compilable(&quot;overflow_recompile_count &gt; PerBytecodeRecompilationCutoff&quot;, CompLevel_full_optimization);
2303           // But give grace to the enclosing nm-&gt;method().
2304         }
2305       }
2306     }
2307 
2308     // Reprofile
2309     if (reprofile) {
2310       CompilationPolicy::policy()-&gt;reprofile(trap_scope, nm-&gt;is_osr_method());
2311     }
2312 
2313     // Give up compiling
2314     if (make_not_compilable &amp;&amp; !nm-&gt;method()-&gt;is_not_compilable(CompLevel_full_optimization)) {
2315       assert(make_not_entrant, &quot;consistent&quot;);
2316       nm-&gt;method()-&gt;set_not_compilable(&quot;give up compiling&quot;, CompLevel_full_optimization);
2317     }
2318 
2319   } // Free marked resources
2320 
2321 }
2322 JRT_END
2323 
2324 ProfileData*
2325 Deoptimization::query_update_method_data(MethodData* trap_mdo,
2326                                          int trap_bci,
2327                                          Deoptimization::DeoptReason reason,
2328                                          bool update_total_trap_count,
2329 #if INCLUDE_JVMCI
2330                                          bool is_osr,
2331 #endif
2332                                          Method* compiled_method,
2333                                          //outputs:
2334                                          uint&amp; ret_this_trap_count,
2335                                          bool&amp; ret_maybe_prior_trap,
2336                                          bool&amp; ret_maybe_prior_recompile) {
2337   bool maybe_prior_trap = false;
2338   bool maybe_prior_recompile = false;
2339   uint this_trap_count = 0;
2340   if (update_total_trap_count) {
2341     uint idx = reason;
2342 #if INCLUDE_JVMCI
2343     if (is_osr) {
2344       idx += Reason_LIMIT;
2345     }
2346 #endif
2347     uint prior_trap_count = trap_mdo-&gt;trap_count(idx);
2348     this_trap_count  = trap_mdo-&gt;inc_trap_count(idx);
2349 
2350     // If the runtime cannot find a place to store trap history,
2351     // it is estimated based on the general condition of the method.
2352     // If the method has ever been recompiled, or has ever incurred
2353     // a trap with the present reason , then this BCI is assumed
2354     // (pessimistically) to be the culprit.
2355     maybe_prior_trap      = (prior_trap_count != 0);
2356     maybe_prior_recompile = (trap_mdo-&gt;decompile_count() != 0);
2357   }
2358   ProfileData* pdata = NULL;
2359 
2360 
2361   // For reasons which are recorded per bytecode, we check per-BCI data.
2362   DeoptReason per_bc_reason = reason_recorded_per_bytecode_if_any(reason);
2363   assert(per_bc_reason != Reason_none || update_total_trap_count, &quot;must be&quot;);
2364   if (per_bc_reason != Reason_none) {
2365     // Find the profile data for this BCI.  If there isn&#39;t one,
2366     // try to allocate one from the MDO&#39;s set of spares.
2367     // This will let us detect a repeated trap at this point.
2368     pdata = trap_mdo-&gt;allocate_bci_to_data(trap_bci, reason_is_speculate(reason) ? compiled_method : NULL);
2369 
2370     if (pdata != NULL) {
2371       if (reason_is_speculate(reason) &amp;&amp; !pdata-&gt;is_SpeculativeTrapData()) {
2372         if (LogCompilation &amp;&amp; xtty != NULL) {
2373           ttyLocker ttyl;
2374           // no more room for speculative traps in this MDO
2375           xtty-&gt;elem(&quot;speculative_traps_oom&quot;);
2376         }
2377       }
2378       // Query the trap state of this profile datum.
2379       int tstate0 = pdata-&gt;trap_state();
2380       if (!trap_state_has_reason(tstate0, per_bc_reason))
2381         maybe_prior_trap = false;
2382       if (!trap_state_is_recompiled(tstate0))
2383         maybe_prior_recompile = false;
2384 
2385       // Update the trap state of this profile datum.
2386       int tstate1 = tstate0;
2387       // Record the reason.
2388       tstate1 = trap_state_add_reason(tstate1, per_bc_reason);
2389       // Store the updated state on the MDO, for next time.
2390       if (tstate1 != tstate0)
2391         pdata-&gt;set_trap_state(tstate1);
2392     } else {
2393       if (LogCompilation &amp;&amp; xtty != NULL) {
2394         ttyLocker ttyl;
2395         // Missing MDP?  Leave a small complaint in the log.
2396         xtty-&gt;elem(&quot;missing_mdp bci=&#39;%d&#39;&quot;, trap_bci);
2397       }
2398     }
2399   }
2400 
2401   // Return results:
2402   ret_this_trap_count = this_trap_count;
2403   ret_maybe_prior_trap = maybe_prior_trap;
2404   ret_maybe_prior_recompile = maybe_prior_recompile;
2405   return pdata;
2406 }
2407 
2408 void
2409 Deoptimization::update_method_data_from_interpreter(MethodData* trap_mdo, int trap_bci, int reason) {
2410   ResourceMark rm;
2411   // Ignored outputs:
2412   uint ignore_this_trap_count;
2413   bool ignore_maybe_prior_trap;
2414   bool ignore_maybe_prior_recompile;
2415   assert(!reason_is_speculate(reason), &quot;reason speculate only used by compiler&quot;);
2416   // JVMCI uses the total counts to determine if deoptimizations are happening too frequently -&gt; do not adjust total counts
2417   bool update_total_counts = true JVMCI_ONLY( &amp;&amp; !UseJVMCICompiler);
2418   query_update_method_data(trap_mdo, trap_bci,
2419                            (DeoptReason)reason,
2420                            update_total_counts,
2421 #if INCLUDE_JVMCI
2422                            false,
2423 #endif
2424                            NULL,
2425                            ignore_this_trap_count,
2426                            ignore_maybe_prior_trap,
2427                            ignore_maybe_prior_recompile);
2428 }
2429 
2430 Deoptimization::UnrollBlock* Deoptimization::uncommon_trap(JavaThread* thread, jint trap_request, jint exec_mode) {
2431   if (TraceDeoptimization) {
2432     tty-&gt;print(&quot;Uncommon trap &quot;);
2433   }
2434   // Still in Java no safepoints
2435   {
2436     // This enters VM and may safepoint
2437     uncommon_trap_inner(thread, trap_request);
2438   }
2439   return fetch_unroll_info_helper(thread, exec_mode);
2440 }
2441 
2442 // Local derived constants.
2443 // Further breakdown of DataLayout::trap_state, as promised by DataLayout.
2444 const int DS_REASON_MASK   = ((uint)DataLayout::trap_mask) &gt;&gt; 1;
2445 const int DS_RECOMPILE_BIT = DataLayout::trap_mask - DS_REASON_MASK;
2446 
2447 //---------------------------trap_state_reason---------------------------------
2448 Deoptimization::DeoptReason
2449 Deoptimization::trap_state_reason(int trap_state) {
2450   // This assert provides the link between the width of DataLayout::trap_bits
2451   // and the encoding of &quot;recorded&quot; reasons.  It ensures there are enough
2452   // bits to store all needed reasons in the per-BCI MDO profile.
2453   assert(DS_REASON_MASK &gt;= Reason_RECORDED_LIMIT, &quot;enough bits&quot;);
2454   int recompile_bit = (trap_state &amp; DS_RECOMPILE_BIT);
2455   trap_state -= recompile_bit;
2456   if (trap_state == DS_REASON_MASK) {
2457     return Reason_many;
2458   } else {
2459     assert((int)Reason_none == 0, &quot;state=0 =&gt; Reason_none&quot;);
2460     return (DeoptReason)trap_state;
2461   }
2462 }
2463 //-------------------------trap_state_has_reason-------------------------------
2464 int Deoptimization::trap_state_has_reason(int trap_state, int reason) {
2465   assert(reason_is_recorded_per_bytecode((DeoptReason)reason), &quot;valid reason&quot;);
2466   assert(DS_REASON_MASK &gt;= Reason_RECORDED_LIMIT, &quot;enough bits&quot;);
2467   int recompile_bit = (trap_state &amp; DS_RECOMPILE_BIT);
2468   trap_state -= recompile_bit;
2469   if (trap_state == DS_REASON_MASK) {
2470     return -1;  // true, unspecifically (bottom of state lattice)
2471   } else if (trap_state == reason) {
2472     return 1;   // true, definitely
2473   } else if (trap_state == 0) {
2474     return 0;   // false, definitely (top of state lattice)
2475   } else {
2476     return 0;   // false, definitely
2477   }
2478 }
2479 //-------------------------trap_state_add_reason-------------------------------
2480 int Deoptimization::trap_state_add_reason(int trap_state, int reason) {
2481   assert(reason_is_recorded_per_bytecode((DeoptReason)reason) || reason == Reason_many, &quot;valid reason&quot;);
2482   int recompile_bit = (trap_state &amp; DS_RECOMPILE_BIT);
2483   trap_state -= recompile_bit;
2484   if (trap_state == DS_REASON_MASK) {
2485     return trap_state + recompile_bit;     // already at state lattice bottom
2486   } else if (trap_state == reason) {
2487     return trap_state + recompile_bit;     // the condition is already true
2488   } else if (trap_state == 0) {
2489     return reason + recompile_bit;          // no condition has yet been true
2490   } else {
2491     return DS_REASON_MASK + recompile_bit;  // fall to state lattice bottom
2492   }
2493 }
2494 //-----------------------trap_state_is_recompiled------------------------------
2495 bool Deoptimization::trap_state_is_recompiled(int trap_state) {
2496   return (trap_state &amp; DS_RECOMPILE_BIT) != 0;
2497 }
2498 //-----------------------trap_state_set_recompiled-----------------------------
2499 int Deoptimization::trap_state_set_recompiled(int trap_state, bool z) {
2500   if (z)  return trap_state |  DS_RECOMPILE_BIT;
2501   else    return trap_state &amp; ~DS_RECOMPILE_BIT;
2502 }
2503 //---------------------------format_trap_state---------------------------------
2504 // This is used for debugging and diagnostics, including LogFile output.
2505 const char* Deoptimization::format_trap_state(char* buf, size_t buflen,
2506                                               int trap_state) {
2507   assert(buflen &gt; 0, &quot;sanity&quot;);
2508   DeoptReason reason      = trap_state_reason(trap_state);
2509   bool        recomp_flag = trap_state_is_recompiled(trap_state);
2510   // Re-encode the state from its decoded components.
2511   int decoded_state = 0;
2512   if (reason_is_recorded_per_bytecode(reason) || reason == Reason_many)
2513     decoded_state = trap_state_add_reason(decoded_state, reason);
2514   if (recomp_flag)
2515     decoded_state = trap_state_set_recompiled(decoded_state, recomp_flag);
2516   // If the state re-encodes properly, format it symbolically.
2517   // Because this routine is used for debugging and diagnostics,
2518   // be robust even if the state is a strange value.
2519   size_t len;
2520   if (decoded_state != trap_state) {
2521     // Random buggy state that doesn&#39;t decode??
2522     len = jio_snprintf(buf, buflen, &quot;#%d&quot;, trap_state);
2523   } else {
2524     len = jio_snprintf(buf, buflen, &quot;%s%s&quot;,
2525                        trap_reason_name(reason),
2526                        recomp_flag ? &quot; recompiled&quot; : &quot;&quot;);
2527   }
2528   return buf;
2529 }
2530 
2531 
2532 //--------------------------------statics--------------------------------------
2533 const char* Deoptimization::_trap_reason_name[] = {
2534   // Note:  Keep this in sync. with enum DeoptReason.
2535   &quot;none&quot;,
2536   &quot;null_check&quot;,
2537   &quot;null_assert&quot; JVMCI_ONLY(&quot;_or_unreached0&quot;),
2538   &quot;range_check&quot;,
2539   &quot;class_check&quot;,
2540   &quot;array_check&quot;,
2541   &quot;intrinsic&quot; JVMCI_ONLY(&quot;_or_type_checked_inlining&quot;),
2542   &quot;bimorphic&quot; JVMCI_ONLY(&quot;_or_optimized_type_check&quot;),
2543   &quot;profile_predicate&quot;,
2544   &quot;unloaded&quot;,
2545   &quot;uninitialized&quot;,
2546   &quot;initialized&quot;,
2547   &quot;unreached&quot;,
2548   &quot;unhandled&quot;,
2549   &quot;constraint&quot;,
2550   &quot;div0_check&quot;,
2551   &quot;age&quot;,
2552   &quot;predicate&quot;,
2553   &quot;loop_limit_check&quot;,
2554   &quot;speculate_class_check&quot;,
2555   &quot;speculate_null_check&quot;,
2556   &quot;speculate_null_assert&quot;,
2557   &quot;rtm_state_change&quot;,
2558   &quot;unstable_if&quot;,
2559   &quot;unstable_fused_if&quot;,
2560 #if INCLUDE_JVMCI
2561   &quot;aliasing&quot;,
2562   &quot;transfer_to_interpreter&quot;,
2563   &quot;not_compiled_exception_handler&quot;,
2564   &quot;unresolved&quot;,
2565   &quot;jsr_mismatch&quot;,
2566 #endif
2567   &quot;tenured&quot;
2568 };
2569 const char* Deoptimization::_trap_action_name[] = {
2570   // Note:  Keep this in sync. with enum DeoptAction.
2571   &quot;none&quot;,
2572   &quot;maybe_recompile&quot;,
2573   &quot;reinterpret&quot;,
2574   &quot;make_not_entrant&quot;,
2575   &quot;make_not_compilable&quot;
2576 };
2577 
2578 const char* Deoptimization::trap_reason_name(int reason) {
2579   // Check that every reason has a name
2580   STATIC_ASSERT(sizeof(_trap_reason_name)/sizeof(const char*) == Reason_LIMIT);
2581 
2582   if (reason == Reason_many)  return &quot;many&quot;;
2583   if ((uint)reason &lt; Reason_LIMIT)
2584     return _trap_reason_name[reason];
2585   static char buf[20];
2586   sprintf(buf, &quot;reason%d&quot;, reason);
2587   return buf;
2588 }
2589 const char* Deoptimization::trap_action_name(int action) {
2590   // Check that every action has a name
2591   STATIC_ASSERT(sizeof(_trap_action_name)/sizeof(const char*) == Action_LIMIT);
2592 
2593   if ((uint)action &lt; Action_LIMIT)
2594     return _trap_action_name[action];
2595   static char buf[20];
2596   sprintf(buf, &quot;action%d&quot;, action);
2597   return buf;
2598 }
2599 
2600 // This is used for debugging and diagnostics, including LogFile output.
2601 const char* Deoptimization::format_trap_request(char* buf, size_t buflen,
2602                                                 int trap_request) {
2603   jint unloaded_class_index = trap_request_index(trap_request);
2604   const char* reason = trap_reason_name(trap_request_reason(trap_request));
2605   const char* action = trap_action_name(trap_request_action(trap_request));
2606 #if INCLUDE_JVMCI
2607   int debug_id = trap_request_debug_id(trap_request);
2608 #endif
2609   size_t len;
2610   if (unloaded_class_index &lt; 0) {
2611     len = jio_snprintf(buf, buflen, &quot;reason=&#39;%s&#39; action=&#39;%s&#39;&quot; JVMCI_ONLY(&quot; debug_id=&#39;%d&#39;&quot;),
2612                        reason, action
2613 #if INCLUDE_JVMCI
2614                        ,debug_id
2615 #endif
2616                        );
2617   } else {
2618     len = jio_snprintf(buf, buflen, &quot;reason=&#39;%s&#39; action=&#39;%s&#39; index=&#39;%d&#39;&quot; JVMCI_ONLY(&quot; debug_id=&#39;%d&#39;&quot;),
2619                        reason, action, unloaded_class_index
2620 #if INCLUDE_JVMCI
2621                        ,debug_id
2622 #endif
2623                        );
2624   }
2625   return buf;
2626 }
2627 
2628 juint Deoptimization::_deoptimization_hist
2629         [Deoptimization::Reason_LIMIT]
2630     [1 + Deoptimization::Action_LIMIT]
2631         [Deoptimization::BC_CASE_LIMIT]
2632   = {0};
2633 
2634 enum {
2635   LSB_BITS = 8,
2636   LSB_MASK = right_n_bits(LSB_BITS)
2637 };
2638 
2639 void Deoptimization::gather_statistics(DeoptReason reason, DeoptAction action,
2640                                        Bytecodes::Code bc) {
2641   assert(reason &gt;= 0 &amp;&amp; reason &lt; Reason_LIMIT, &quot;oob&quot;);
2642   assert(action &gt;= 0 &amp;&amp; action &lt; Action_LIMIT, &quot;oob&quot;);
2643   _deoptimization_hist[Reason_none][0][0] += 1;  // total
2644   _deoptimization_hist[reason][0][0]      += 1;  // per-reason total
2645   juint* cases = _deoptimization_hist[reason][1+action];
2646   juint* bc_counter_addr = NULL;
2647   juint  bc_counter      = 0;
2648   // Look for an unused counter, or an exact match to this BC.
2649   if (bc != Bytecodes::_illegal) {
2650     for (int bc_case = 0; bc_case &lt; BC_CASE_LIMIT; bc_case++) {
2651       juint* counter_addr = &amp;cases[bc_case];
2652       juint  counter = *counter_addr;
2653       if ((counter == 0 &amp;&amp; bc_counter_addr == NULL)
2654           || (Bytecodes::Code)(counter &amp; LSB_MASK) == bc) {
2655         // this counter is either free or is already devoted to this BC
2656         bc_counter_addr = counter_addr;
2657         bc_counter = counter | bc;
2658       }
2659     }
2660   }
2661   if (bc_counter_addr == NULL) {
2662     // Overflow, or no given bytecode.
2663     bc_counter_addr = &amp;cases[BC_CASE_LIMIT-1];
2664     bc_counter = (*bc_counter_addr &amp; ~LSB_MASK);  // clear LSB
2665   }
2666   *bc_counter_addr = bc_counter + (1 &lt;&lt; LSB_BITS);
2667 }
2668 
2669 jint Deoptimization::total_deoptimization_count() {
2670   return _deoptimization_hist[Reason_none][0][0];
2671 }
2672 
2673 void Deoptimization::print_statistics() {
2674   juint total = total_deoptimization_count();
2675   juint account = total;
2676   if (total != 0) {
2677     ttyLocker ttyl;
2678     if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;deoptimization&#39;&quot;);
2679     tty-&gt;print_cr(&quot;Deoptimization traps recorded:&quot;);
2680     #define PRINT_STAT_LINE(name, r) \
2681       tty-&gt;print_cr(&quot;  %4d (%4.1f%%) %s&quot;, (int)(r), ((r) * 100.0) / total, name);
2682     PRINT_STAT_LINE(&quot;total&quot;, total);
2683     // For each non-zero entry in the histogram, print the reason,
2684     // the action, and (if specifically known) the type of bytecode.
2685     for (int reason = 0; reason &lt; Reason_LIMIT; reason++) {
2686       for (int action = 0; action &lt; Action_LIMIT; action++) {
2687         juint* cases = _deoptimization_hist[reason][1+action];
2688         for (int bc_case = 0; bc_case &lt; BC_CASE_LIMIT; bc_case++) {
2689           juint counter = cases[bc_case];
2690           if (counter != 0) {
2691             char name[1*K];
2692             Bytecodes::Code bc = (Bytecodes::Code)(counter &amp; LSB_MASK);
2693             if (bc_case == BC_CASE_LIMIT &amp;&amp; (int)bc == 0)
2694               bc = Bytecodes::_illegal;
2695             sprintf(name, &quot;%s/%s/%s&quot;,
2696                     trap_reason_name(reason),
2697                     trap_action_name(action),
2698                     Bytecodes::is_defined(bc)? Bytecodes::name(bc): &quot;other&quot;);
2699             juint r = counter &gt;&gt; LSB_BITS;
2700             tty-&gt;print_cr(&quot;  %40s: &quot; UINT32_FORMAT &quot; (%.1f%%)&quot;, name, r, (r * 100.0) / total);
2701             account -= r;
2702           }
2703         }
2704       }
2705     }
2706     if (account != 0) {
2707       PRINT_STAT_LINE(&quot;unaccounted&quot;, account);
2708     }
2709     #undef PRINT_STAT_LINE
2710     if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
2711   }
2712 }
2713 #else // COMPILER2_OR_JVMCI
2714 
2715 
2716 // Stubs for C1 only system.
2717 bool Deoptimization::trap_state_is_recompiled(int trap_state) {
2718   return false;
2719 }
2720 
2721 const char* Deoptimization::trap_reason_name(int reason) {
2722   return &quot;unknown&quot;;
2723 }
2724 
2725 void Deoptimization::print_statistics() {
2726   // no output
2727 }
2728 
2729 void
2730 Deoptimization::update_method_data_from_interpreter(MethodData* trap_mdo, int trap_bci, int reason) {
2731   // no udpate
2732 }
2733 
2734 int Deoptimization::trap_state_has_reason(int trap_state, int reason) {
2735   return 0;
2736 }
2737 
2738 void Deoptimization::gather_statistics(DeoptReason reason, DeoptAction action,
2739                                        Bytecodes::Code bc) {
2740   // no update
2741 }
2742 
2743 const char* Deoptimization::format_trap_state(char* buf, size_t buflen,
2744                                               int trap_state) {
2745   jio_snprintf(buf, buflen, &quot;#%d&quot;, trap_state);
2746   return buf;
2747 }
2748 
2749 #endif // COMPILER2_OR_JVMCI
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
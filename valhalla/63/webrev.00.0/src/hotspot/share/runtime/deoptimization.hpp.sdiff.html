<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/deoptimization.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="deoptimization.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/deoptimization.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
120   };
121 
122   enum {
123     _action_bits = 3,
124     _reason_bits = 5,
125     _debug_id_bits = 23,
126     _action_shift = 0,
127     _reason_shift = _action_shift+_action_bits,
128     _debug_id_shift = _reason_shift+_reason_bits,
129     BC_CASE_LIMIT = PRODUCT_ONLY(1) NOT_PRODUCT(4) // for _deoptimization_hist
130   };
131 
132   enum UnpackType {
133     Unpack_deopt                = 0, // normal deoptimization, use pc computed in unpack_vframe_on_stack
134     Unpack_exception            = 1, // exception is pending
135     Unpack_uncommon_trap        = 2, // redo last byte code (C2 only)
136     Unpack_reexecute            = 3, // reexecute bytecode (C1 only)
137     Unpack_LIMIT                = 4
138   };
139 





140   // Make all nmethods that are marked_for_deoptimization not_entrant and deoptimize any live
141   // activations using those nmethods.  If an nmethod is passed as an argument then it is
142   // marked_for_deoptimization and made not_entrant.  Otherwise a scan of the code cache is done to
143   // find all marked nmethods and they are made not_entrant.
144   static void deoptimize_all_marked(nmethod* nmethod_only = NULL);
145 
146  private:
147   // Revoke biased locks at deopt.
148   static void revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map);
149 
150  public:
151   // Deoptimizes a frame lazily. Deopt happens on return to the frame.
152   static void deoptimize(JavaThread* thread, frame fr, DeoptReason reason = Reason_constraint);
153 
154 #if INCLUDE_JVMCI
155   static address deoptimize_for_missing_exception_handler(CompiledMethod* cm);
156   static oop get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, TRAPS);
157 #endif
158 
159   private:
</pre>
</td>
<td>
<hr />
<pre>
120   };
121 
122   enum {
123     _action_bits = 3,
124     _reason_bits = 5,
125     _debug_id_bits = 23,
126     _action_shift = 0,
127     _reason_shift = _action_shift+_action_bits,
128     _debug_id_shift = _reason_shift+_reason_bits,
129     BC_CASE_LIMIT = PRODUCT_ONLY(1) NOT_PRODUCT(4) // for _deoptimization_hist
130   };
131 
132   enum UnpackType {
133     Unpack_deopt                = 0, // normal deoptimization, use pc computed in unpack_vframe_on_stack
134     Unpack_exception            = 1, // exception is pending
135     Unpack_uncommon_trap        = 2, // redo last byte code (C2 only)
136     Unpack_reexecute            = 3, // reexecute bytecode (C1 only)
137     Unpack_LIMIT                = 4
138   };
139 
<span class="line-added">140 #if INCLUDE_JVMCI</span>
<span class="line-added">141   // Can reconstruct virtualized unsafe large accesses to byte arrays.</span>
<span class="line-added">142   static const int _support_large_access_byte_array_virtualization = 1;</span>
<span class="line-added">143 #endif</span>
<span class="line-added">144 </span>
145   // Make all nmethods that are marked_for_deoptimization not_entrant and deoptimize any live
146   // activations using those nmethods.  If an nmethod is passed as an argument then it is
147   // marked_for_deoptimization and made not_entrant.  Otherwise a scan of the code cache is done to
148   // find all marked nmethods and they are made not_entrant.
149   static void deoptimize_all_marked(nmethod* nmethod_only = NULL);
150 
151  private:
152   // Revoke biased locks at deopt.
153   static void revoke_from_deopt_handler(JavaThread* thread, frame fr, RegisterMap* map);
154 
155  public:
156   // Deoptimizes a frame lazily. Deopt happens on return to the frame.
157   static void deoptimize(JavaThread* thread, frame fr, DeoptReason reason = Reason_constraint);
158 
159 #if INCLUDE_JVMCI
160   static address deoptimize_for_missing_exception_handler(CompiledMethod* cm);
161   static oop get_cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, TRAPS);
162 #endif
163 
164   private:
</pre>
</td>
</tr>
</table>
<center><a href="deoptimization.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globals.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/jvmci/jvmciCodeInstaller.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../interpreter/linkResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs_jvmci.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/jvmci/jvmciCodeInstaller.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  27 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  28 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  29 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  30 #include &quot;memory/universe.hpp&quot;
  31 #include &quot;oops/compressedOops.inline.hpp&quot;
  32 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  33 #include &quot;runtime/jniHandles.inline.hpp&quot;
  34 #include &quot;runtime/sharedRuntime.hpp&quot;
  35 #include &quot;utilities/align.hpp&quot;
  36 
  37 // frequently used constants
  38 // Allocate them with new so they are never destroyed (otherwise, a
  39 // forced exit could destroy these objects while they are still in
  40 // use).
  41 ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantOopWriteValue(NULL);
  42 ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(-1);
  43 ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue((jint)0);
  44 ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(1);
  45 ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(2);
  46 LocationValue*         CodeInstaller::_illegal_value = new (ResourceObj::C_HEAP, mtJVMCI) LocationValue(Location());

  47 
  48 VMReg CodeInstaller::getVMRegFromLocation(JVMCIObject location, int total_frame_size, JVMCI_TRAPS) {
  49   if (location.is_null()) {
  50     JVMCI_THROW_NULL(NullPointerException);
  51   }
  52 
  53   JVMCIObject reg = jvmci_env()-&gt;get_code_Location_reg(location);
  54   jint offset = jvmci_env()-&gt;get_code_Location_offset(location);
  55 
  56   if (reg.is_non_null()) {
  57     // register
  58     jint number = jvmci_env()-&gt;get_code_Register_number(reg);
  59     VMReg vmReg = CodeInstaller::get_hotspot_reg(number, JVMCI_CHECK_NULL);
  60     if (offset % 4 == 0) {
  61       return vmReg-&gt;next(offset / 4);
  62     } else {
  63       JVMCI_ERROR_NULL(&quot;unaligned subregister offset %d in oop map&quot;, offset);
  64     }
  65   } else {
  66     // stack slot
</pre>
<hr />
<pre>
 403       if (0 &lt;= id &amp;&amp; id &lt; objects-&gt;length()) {
 404         ScopeValue* object = objects-&gt;at(id);
 405         if (object != NULL) {
 406           return object;
 407         }
 408       }
 409       JVMCI_ERROR_NULL(&quot;unknown virtual object id %d&quot;, id);
 410     } else {
 411       JVMCI_ERROR_NULL(&quot;unexpected virtual object, expected %s&quot;, basictype_to_str(type));
 412     }
 413   }
 414 
 415   JVMCI_ERROR_NULL(&quot;unexpected value in scope: %s&quot;, jvmci_env()-&gt;klass_name(value))
 416 }
 417 
 418 void CodeInstaller::record_object_value(ObjectValue* sv, JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS) {
 419   JVMCIObject type = jvmci_env()-&gt;get_VirtualObject_type(value);
 420   int id = jvmci_env()-&gt;get_VirtualObject_id(value);
 421   Klass* klass = JVMCIENV-&gt;asKlass(type);
 422   bool isLongArray = klass == Universe::longArrayKlassObj();

 423 
 424   JVMCIObjectArray values = jvmci_env()-&gt;get_VirtualObject_values(value);
 425   JVMCIObjectArray slotKinds = jvmci_env()-&gt;get_VirtualObject_slotKinds(value);
 426   for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(values); i++) {
 427     ScopeValue* cur_second = NULL;
 428     JVMCIObject object = JVMCIENV-&gt;get_object_at(values, i);
 429     BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);
<span class="line-modified"> 430     ScopeValue* value = get_scope_value(object, type, objects, cur_second, JVMCI_CHECK);</span>

















 431 
 432     if (isLongArray &amp;&amp; cur_second == NULL) {
 433       // we&#39;re trying to put ints into a long array... this isn&#39;t really valid, but it&#39;s used for some optimizations.
 434       // add an int 0 constant
 435       cur_second = _int_0_scope_value;
 436     }
 437 






 438     if (cur_second != NULL) {
 439       sv-&gt;field_values()-&gt;append(cur_second);
 440     }
 441     assert(value != NULL, &quot;missing value&quot;);
 442     sv-&gt;field_values()-&gt;append(value);
 443   }
 444 }
 445 
 446 MonitorValue* CodeInstaller::get_monitor_value(JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS) {
 447   if (value.is_null()) {
 448     JVMCI_THROW_NULL(NullPointerException);
 449   }
 450   if (!jvmci_env()-&gt;isa_StackLockValue(value)) {
 451     JVMCI_ERROR_NULL(&quot;Monitors must be of type StackLockValue, got %s&quot;, jvmci_env()-&gt;klass_name(value));
 452   }
 453 
 454   ScopeValue* second = NULL;
 455   ScopeValue* owner_value = get_scope_value(jvmci_env()-&gt;get_StackLockValue_owner(value), T_OBJECT, objects, second, JVMCI_CHECK_NULL);
 456   assert(second == NULL, &quot;monitor cannot occupy two stack slots&quot;);
 457 
</pre>
</td>
<td>
<hr />
<pre>
  27 #include &quot;jvmci/jvmciCodeInstaller.hpp&quot;
  28 #include &quot;jvmci/jvmciCompilerToVM.hpp&quot;
  29 #include &quot;jvmci/jvmciRuntime.hpp&quot;
  30 #include &quot;memory/universe.hpp&quot;
  31 #include &quot;oops/compressedOops.inline.hpp&quot;
  32 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  33 #include &quot;runtime/jniHandles.inline.hpp&quot;
  34 #include &quot;runtime/sharedRuntime.hpp&quot;
  35 #include &quot;utilities/align.hpp&quot;
  36 
  37 // frequently used constants
  38 // Allocate them with new so they are never destroyed (otherwise, a
  39 // forced exit could destroy these objects while they are still in
  40 // use).
  41 ConstantOopWriteValue* CodeInstaller::_oop_null_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantOopWriteValue(NULL);
  42 ConstantIntValue*      CodeInstaller::_int_m1_scope_value = new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(-1);
  43 ConstantIntValue*      CodeInstaller::_int_0_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue((jint)0);
  44 ConstantIntValue*      CodeInstaller::_int_1_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(1);
  45 ConstantIntValue*      CodeInstaller::_int_2_scope_value =  new (ResourceObj::C_HEAP, mtJVMCI) ConstantIntValue(2);
  46 LocationValue*         CodeInstaller::_illegal_value = new (ResourceObj::C_HEAP, mtJVMCI) LocationValue(Location());
<span class="line-added">  47 MarkerValue*           CodeInstaller::_virtual_byte_array_marker = new (ResourceObj::C_HEAP, mtJVMCI) MarkerValue();</span>
  48 
  49 VMReg CodeInstaller::getVMRegFromLocation(JVMCIObject location, int total_frame_size, JVMCI_TRAPS) {
  50   if (location.is_null()) {
  51     JVMCI_THROW_NULL(NullPointerException);
  52   }
  53 
  54   JVMCIObject reg = jvmci_env()-&gt;get_code_Location_reg(location);
  55   jint offset = jvmci_env()-&gt;get_code_Location_offset(location);
  56 
  57   if (reg.is_non_null()) {
  58     // register
  59     jint number = jvmci_env()-&gt;get_code_Register_number(reg);
  60     VMReg vmReg = CodeInstaller::get_hotspot_reg(number, JVMCI_CHECK_NULL);
  61     if (offset % 4 == 0) {
  62       return vmReg-&gt;next(offset / 4);
  63     } else {
  64       JVMCI_ERROR_NULL(&quot;unaligned subregister offset %d in oop map&quot;, offset);
  65     }
  66   } else {
  67     // stack slot
</pre>
<hr />
<pre>
 404       if (0 &lt;= id &amp;&amp; id &lt; objects-&gt;length()) {
 405         ScopeValue* object = objects-&gt;at(id);
 406         if (object != NULL) {
 407           return object;
 408         }
 409       }
 410       JVMCI_ERROR_NULL(&quot;unknown virtual object id %d&quot;, id);
 411     } else {
 412       JVMCI_ERROR_NULL(&quot;unexpected virtual object, expected %s&quot;, basictype_to_str(type));
 413     }
 414   }
 415 
 416   JVMCI_ERROR_NULL(&quot;unexpected value in scope: %s&quot;, jvmci_env()-&gt;klass_name(value))
 417 }
 418 
 419 void CodeInstaller::record_object_value(ObjectValue* sv, JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS) {
 420   JVMCIObject type = jvmci_env()-&gt;get_VirtualObject_type(value);
 421   int id = jvmci_env()-&gt;get_VirtualObject_id(value);
 422   Klass* klass = JVMCIENV-&gt;asKlass(type);
 423   bool isLongArray = klass == Universe::longArrayKlassObj();
<span class="line-added"> 424   bool isByteArray = klass == Universe::byteArrayKlassObj();</span>
 425 
 426   JVMCIObjectArray values = jvmci_env()-&gt;get_VirtualObject_values(value);
 427   JVMCIObjectArray slotKinds = jvmci_env()-&gt;get_VirtualObject_slotKinds(value);
 428   for (jint i = 0; i &lt; JVMCIENV-&gt;get_length(values); i++) {
 429     ScopeValue* cur_second = NULL;
 430     JVMCIObject object = JVMCIENV-&gt;get_object_at(values, i);
 431     BasicType type = jvmci_env()-&gt;kindToBasicType(JVMCIENV-&gt;get_object_at(slotKinds, i), JVMCI_CHECK);
<span class="line-modified"> 432     ScopeValue* value;</span>
<span class="line-added"> 433     if (JVMCIENV-&gt;equals(object, jvmci_env()-&gt;get_Value_ILLEGAL())) {</span>
<span class="line-added"> 434       if (isByteArray &amp;&amp; type == T_ILLEGAL) {</span>
<span class="line-added"> 435         /*</span>
<span class="line-added"> 436          * The difference between a virtualized large access and a deferred write is the kind stored in the slotKinds</span>
<span class="line-added"> 437          * of the virtual object: in the virtualization case, the kind is illegal, in the deferred write case, the kind</span>
<span class="line-added"> 438          * is access stack kind (an int).</span>
<span class="line-added"> 439          */</span>
<span class="line-added"> 440         value = _virtual_byte_array_marker;</span>
<span class="line-added"> 441       } else {</span>
<span class="line-added"> 442         value = _illegal_value;</span>
<span class="line-added"> 443         if (type == T_DOUBLE || type == T_LONG) {</span>
<span class="line-added"> 444             cur_second = _illegal_value;</span>
<span class="line-added"> 445         }</span>
<span class="line-added"> 446       }</span>
<span class="line-added"> 447     } else {</span>
<span class="line-added"> 448       value = get_scope_value(object, type, objects, cur_second, JVMCI_CHECK);</span>
<span class="line-added"> 449     }</span>
 450 
 451     if (isLongArray &amp;&amp; cur_second == NULL) {
 452       // we&#39;re trying to put ints into a long array... this isn&#39;t really valid, but it&#39;s used for some optimizations.
 453       // add an int 0 constant
 454       cur_second = _int_0_scope_value;
 455     }
 456 
<span class="line-added"> 457     if (isByteArray &amp;&amp; cur_second != NULL &amp;&amp; (type == T_DOUBLE || type == T_LONG)) {</span>
<span class="line-added"> 458       // we are trying to write a long in a byte Array. We will need to count the illegals to restore the type of</span>
<span class="line-added"> 459       // the thing we put inside.</span>
<span class="line-added"> 460       cur_second = NULL;</span>
<span class="line-added"> 461     }</span>
<span class="line-added"> 462 </span>
 463     if (cur_second != NULL) {
 464       sv-&gt;field_values()-&gt;append(cur_second);
 465     }
 466     assert(value != NULL, &quot;missing value&quot;);
 467     sv-&gt;field_values()-&gt;append(value);
 468   }
 469 }
 470 
 471 MonitorValue* CodeInstaller::get_monitor_value(JVMCIObject value, GrowableArray&lt;ScopeValue*&gt;* objects, JVMCI_TRAPS) {
 472   if (value.is_null()) {
 473     JVMCI_THROW_NULL(NullPointerException);
 474   }
 475   if (!jvmci_env()-&gt;isa_StackLockValue(value)) {
 476     JVMCI_ERROR_NULL(&quot;Monitors must be of type StackLockValue, got %s&quot;, jvmci_env()-&gt;klass_name(value));
 477   }
 478 
 479   ScopeValue* second = NULL;
 480   ScopeValue* owner_value = get_scope_value(jvmci_env()-&gt;get_StackLockValue_owner(value), T_OBJECT, objects, second, JVMCI_CHECK_NULL);
 481   assert(second == NULL, &quot;monitor cannot occupy two stack slots&quot;);
 482 
</pre>
</td>
</tr>
</table>
<center><a href="../interpreter/linkResolver.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmStructs_jvmci.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
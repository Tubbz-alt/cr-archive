<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/cpCache.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/cpCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/resolutionErrors.hpp&quot;
 27 #include &quot;interpreter/bytecodeStream.hpp&quot;
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/linkResolver.hpp&quot;
 31 #include &quot;interpreter/rewriter.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;

 33 #include &quot;memory/heapShared.hpp&quot;
 34 #include &quot;memory/metadataFactory.hpp&quot;
 35 #include &quot;memory/metaspaceClosure.hpp&quot;
 36 #include &quot;memory/metaspaceShared.hpp&quot;
 37 #include &quot;memory/resourceArea.hpp&quot;
 38 #include &quot;oops/access.inline.hpp&quot;
 39 #include &quot;oops/compressedOops.hpp&quot;
 40 #include &quot;oops/constantPool.inline.hpp&quot;
 41 #include &quot;oops/cpCache.inline.hpp&quot;
 42 #include &quot;oops/objArrayOop.inline.hpp&quot;
 43 #include &quot;oops/oop.inline.hpp&quot;
 44 #include &quot;prims/methodHandles.hpp&quot;
 45 #include &quot;runtime/atomic.hpp&quot;
 46 #include &quot;runtime/handles.inline.hpp&quot;
 47 #include &quot;utilities/macros.hpp&quot;
 48 
 49 // Implementation of ConstantPoolCacheEntry
 50 
 51 void ConstantPoolCacheEntry::initialize_entry(int index) {
 52   assert(0 &lt; index &amp;&amp; index &lt; 0x10000, &quot;sanity check&quot;);
</pre>
<hr />
<pre>
401     guarantee(index &gt;= 0, &quot;Didn&#39;t find cpCache entry!&quot;);
402     int encoded_index = ResolutionErrorTable::encode_cpcache_index(
403                           ConstantPool::encode_invokedynamic_index(index));
404     Thread* THREAD = Thread::current();
405     ConstantPool::throw_resolution_error(cpool, encoded_index, THREAD);
406     return;
407   }
408 
409   Method* adapter            = call_info.resolved_method();
410   const Handle appendix      = call_info.resolved_appendix();
411   const bool has_appendix    = appendix.not_null();
412 
413   // Write the flags.
414   // MHs and indy are always sig-poly and have a local signature.
415   set_method_flags(as_TosState(adapter-&gt;result_type()),
416                    ((has_appendix    ? 1 : 0) &lt;&lt; has_appendix_shift        ) |
417                    (                   1      &lt;&lt; has_local_signature_shift ) |
418                    (                   1      &lt;&lt; is_final_shift            ),
419                    adapter-&gt;size_of_parameters());
420 
<span class="line-modified">421   if (TraceInvokeDynamic) {</span>
<span class="line-modified">422     ttyLocker ttyl;</span>
<span class="line-modified">423     tty-&gt;print_cr(&quot;set_method_handle bc=%d appendix=&quot; PTR_FORMAT &quot;%s method=&quot; PTR_FORMAT &quot; (local signature) &quot;,</span>
<span class="line-modified">424                   invoke_code,</span>
<span class="line-modified">425                   p2i(appendix()),</span>
<span class="line-modified">426                   (has_appendix ? &quot;&quot; : &quot; (unused)&quot;),</span>
<span class="line-modified">427                   p2i(adapter));</span>
<span class="line-modified">428     adapter-&gt;print();</span>
<span class="line-modified">429     if (has_appendix)  appendix()-&gt;print();</span>



430   }
431 
432   // Method handle invokes and invokedynamic sites use both cp cache words.
433   // refs[f2], if not null, contains a value passed as a trailing argument to the adapter.
434   // In the general case, this could be the call site&#39;s MethodType,
435   // for use with java.lang.Invokers.checkExactType, or else a CallSite object.
436   // f1 contains the adapter method which manages the actual call.
437   // In the general case, this is a compiled LambdaForm.
438   // (The Java code is free to optimize these calls by binding other
439   // sorts of methods and appendices to call sites.)
440   // JVM-level linking is via f1, as if for invokespecial, and signatures are erased.
441   // The appendix argument (if any) is added to the signature, and is counted in the parameter_size bits.
442   // Even with the appendix, the method will never take more than 255 parameter slots.
443   //
444   // This means that given a call site like (List)mh.invoke(&quot;foo&quot;),
445   // the f1 method has signature &#39;(Ljl/Object;Ljl/invoke/MethodType;)Ljl/Object;&#39;,
446   // not &#39;(Ljava/lang/String;)Ljava/util/List;&#39;.
447   // The fact that String and List are involved is encoded in the MethodType in refs[f2].
448   // This allows us to create fewer Methods, while keeping type safety.
449   //
450 
451   // Store appendix, if any.
452   if (has_appendix) {
453     const int appendix_index = f2_as_index();
454     assert(appendix_index &gt;= 0 &amp;&amp; appendix_index &lt; resolved_references-&gt;length(), &quot;oob&quot;);
455     assert(resolved_references-&gt;obj_at(appendix_index) == NULL, &quot;init just once&quot;);
456     resolved_references-&gt;obj_at_put(appendix_index, appendix());
457   }
458 
459   release_set_f1(adapter);  // This must be the last one to set (see NOTE above)!
460 
461   // The interpreter assembly code does not check byte_2,
462   // but it is used by is_resolved, method_if_resolved, etc.
463   set_bytecode_1(invoke_code);
464   NOT_PRODUCT(verify(tty));
<span class="line-modified">465   if (TraceInvokeDynamic) {</span>
<span class="line-modified">466     ttyLocker ttyl;</span>
<span class="line-modified">467     this-&gt;print(tty, 0);</span>
468   }
469 
470   assert(has_appendix == this-&gt;has_appendix(), &quot;proper storage of appendix flag&quot;);
471   assert(this-&gt;has_local_signature(), &quot;proper storage of signature flag&quot;);
472 }
473 
474 bool ConstantPoolCacheEntry::save_and_throw_indy_exc(
475   const constantPoolHandle&amp; cpool, int cpool_index, int index, constantTag tag, TRAPS) {
476 
477   assert(HAS_PENDING_EXCEPTION, &quot;No exception got thrown!&quot;);
478   assert(PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass()),
479          &quot;No LinkageError exception&quot;);
480 
481   // Use the resolved_references() lock for this cpCache entry.
482   // resolved_references are created for all classes with Invokedynamic, MethodHandle
483   // or MethodType constant pool cache entries.
484   objArrayHandle resolved_references(Thread::current(), cpool-&gt;resolved_references());
485   assert(resolved_references() != NULL,
486          &quot;a resolved_references array should have been created for this class&quot;);
487   ObjectLocker ol(resolved_references, THREAD);
</pre>
</td>
<td>
<hr />
<pre>
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;classfile/resolutionErrors.hpp&quot;
 27 #include &quot;interpreter/bytecodeStream.hpp&quot;
 28 #include &quot;interpreter/bytecodes.hpp&quot;
 29 #include &quot;interpreter/interpreter.hpp&quot;
 30 #include &quot;interpreter/linkResolver.hpp&quot;
 31 #include &quot;interpreter/rewriter.hpp&quot;
 32 #include &quot;logging/log.hpp&quot;
<span class="line-added"> 33 #include &quot;logging/logStream.hpp&quot;</span>
 34 #include &quot;memory/heapShared.hpp&quot;
 35 #include &quot;memory/metadataFactory.hpp&quot;
 36 #include &quot;memory/metaspaceClosure.hpp&quot;
 37 #include &quot;memory/metaspaceShared.hpp&quot;
 38 #include &quot;memory/resourceArea.hpp&quot;
 39 #include &quot;oops/access.inline.hpp&quot;
 40 #include &quot;oops/compressedOops.hpp&quot;
 41 #include &quot;oops/constantPool.inline.hpp&quot;
 42 #include &quot;oops/cpCache.inline.hpp&quot;
 43 #include &quot;oops/objArrayOop.inline.hpp&quot;
 44 #include &quot;oops/oop.inline.hpp&quot;
 45 #include &quot;prims/methodHandles.hpp&quot;
 46 #include &quot;runtime/atomic.hpp&quot;
 47 #include &quot;runtime/handles.inline.hpp&quot;
 48 #include &quot;utilities/macros.hpp&quot;
 49 
 50 // Implementation of ConstantPoolCacheEntry
 51 
 52 void ConstantPoolCacheEntry::initialize_entry(int index) {
 53   assert(0 &lt; index &amp;&amp; index &lt; 0x10000, &quot;sanity check&quot;);
</pre>
<hr />
<pre>
402     guarantee(index &gt;= 0, &quot;Didn&#39;t find cpCache entry!&quot;);
403     int encoded_index = ResolutionErrorTable::encode_cpcache_index(
404                           ConstantPool::encode_invokedynamic_index(index));
405     Thread* THREAD = Thread::current();
406     ConstantPool::throw_resolution_error(cpool, encoded_index, THREAD);
407     return;
408   }
409 
410   Method* adapter            = call_info.resolved_method();
411   const Handle appendix      = call_info.resolved_appendix();
412   const bool has_appendix    = appendix.not_null();
413 
414   // Write the flags.
415   // MHs and indy are always sig-poly and have a local signature.
416   set_method_flags(as_TosState(adapter-&gt;result_type()),
417                    ((has_appendix    ? 1 : 0) &lt;&lt; has_appendix_shift        ) |
418                    (                   1      &lt;&lt; has_local_signature_shift ) |
419                    (                   1      &lt;&lt; is_final_shift            ),
420                    adapter-&gt;size_of_parameters());
421 
<span class="line-modified">422   LogStream* log_stream = NULL;</span>
<span class="line-modified">423   LogStreamHandle(Debug, methodhandles, indy) lsh_indy;</span>
<span class="line-modified">424   if (lsh_indy.is_enabled()) {</span>
<span class="line-modified">425     ResourceMark rm;</span>
<span class="line-modified">426     log_stream = &amp;lsh_indy;</span>
<span class="line-modified">427     log_stream-&gt;print_cr(&quot;set_method_handle bc=%d appendix=&quot; PTR_FORMAT &quot;%s method=&quot; PTR_FORMAT &quot; (local signature) &quot;,</span>
<span class="line-modified">428                          invoke_code,</span>
<span class="line-modified">429                          p2i(appendix()),</span>
<span class="line-modified">430                          (has_appendix ? &quot;&quot; : &quot; (unused)&quot;),</span>
<span class="line-added">431                          p2i(adapter));</span>
<span class="line-added">432     adapter-&gt;print_on(log_stream);</span>
<span class="line-added">433     if (has_appendix)  appendix()-&gt;print_on(log_stream);</span>
434   }
435 
436   // Method handle invokes and invokedynamic sites use both cp cache words.
437   // refs[f2], if not null, contains a value passed as a trailing argument to the adapter.
438   // In the general case, this could be the call site&#39;s MethodType,
439   // for use with java.lang.Invokers.checkExactType, or else a CallSite object.
440   // f1 contains the adapter method which manages the actual call.
441   // In the general case, this is a compiled LambdaForm.
442   // (The Java code is free to optimize these calls by binding other
443   // sorts of methods and appendices to call sites.)
444   // JVM-level linking is via f1, as if for invokespecial, and signatures are erased.
445   // The appendix argument (if any) is added to the signature, and is counted in the parameter_size bits.
446   // Even with the appendix, the method will never take more than 255 parameter slots.
447   //
448   // This means that given a call site like (List)mh.invoke(&quot;foo&quot;),
449   // the f1 method has signature &#39;(Ljl/Object;Ljl/invoke/MethodType;)Ljl/Object;&#39;,
450   // not &#39;(Ljava/lang/String;)Ljava/util/List;&#39;.
451   // The fact that String and List are involved is encoded in the MethodType in refs[f2].
452   // This allows us to create fewer Methods, while keeping type safety.
453   //
454 
455   // Store appendix, if any.
456   if (has_appendix) {
457     const int appendix_index = f2_as_index();
458     assert(appendix_index &gt;= 0 &amp;&amp; appendix_index &lt; resolved_references-&gt;length(), &quot;oob&quot;);
459     assert(resolved_references-&gt;obj_at(appendix_index) == NULL, &quot;init just once&quot;);
460     resolved_references-&gt;obj_at_put(appendix_index, appendix());
461   }
462 
463   release_set_f1(adapter);  // This must be the last one to set (see NOTE above)!
464 
465   // The interpreter assembly code does not check byte_2,
466   // but it is used by is_resolved, method_if_resolved, etc.
467   set_bytecode_1(invoke_code);
468   NOT_PRODUCT(verify(tty));
<span class="line-modified">469 </span>
<span class="line-modified">470   if (log_stream != NULL) {</span>
<span class="line-modified">471     this-&gt;print(log_stream, 0);</span>
472   }
473 
474   assert(has_appendix == this-&gt;has_appendix(), &quot;proper storage of appendix flag&quot;);
475   assert(this-&gt;has_local_signature(), &quot;proper storage of signature flag&quot;);
476 }
477 
478 bool ConstantPoolCacheEntry::save_and_throw_indy_exc(
479   const constantPoolHandle&amp; cpool, int cpool_index, int index, constantTag tag, TRAPS) {
480 
481   assert(HAS_PENDING_EXCEPTION, &quot;No exception got thrown!&quot;);
482   assert(PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass()),
483          &quot;No LinkageError exception&quot;);
484 
485   // Use the resolved_references() lock for this cpCache entry.
486   // resolved_references are created for all classes with Invokedynamic, MethodHandle
487   // or MethodType constant pool cache entries.
488   objArrayHandle resolved_references(Thread::current(), cpool-&gt;resolved_references());
489   assert(resolved_references() != NULL,
490          &quot;a resolved_references array should have been created for this class&quot;);
491   ObjectLocker ol(resolved_references, THREAD);
</pre>
</td>
</tr>
</table>
<center><a href="constantPool.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
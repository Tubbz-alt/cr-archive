<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/klass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="instanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
591     log_debug(cds, mirror)(&quot;%s has raw archived mirror&quot;, external_name());
592     if (HeapShared::open_archive_heap_region_mapped()) {
593       bool present = java_lang_Class::restore_archived_mirror(this, loader, module_handle,
594                                                               protection_domain,
595                                                               CHECK);
596       if (present) {
597         return;
598       }
599     }
600 
601     // No archived mirror data
602     log_debug(cds, mirror)(&quot;No archived mirror data for %s&quot;, external_name());
603     _java_mirror = NULL;
604     this-&gt;clear_has_raw_archived_mirror();
605   }
606 
607   // Only recreate it if not present.  A previous attempt to restore may have
608   // gotten an OOM later but keep the mirror if it was created.
609   if (java_mirror() == NULL) {
610     log_trace(cds, mirror)(&quot;Recreate mirror for %s&quot;, external_name());
<span class="line-modified">611     java_lang_Class::create_mirror(this, loader, module_handle, protection_domain, CHECK);</span>
612   }
613 }
614 
615 #if INCLUDE_CDS_JAVA_HEAP
616 // Used at CDS dump time to access the archived mirror. No GC barrier.
617 oop Klass::archived_java_mirror_raw() {
618   assert(has_raw_archived_mirror(), &quot;must have raw archived mirror&quot;);
619   return CompressedOops::decode(_archived_mirror);
620 }
621 
622 narrowOop Klass::archived_java_mirror_raw_narrow() {
623   assert(has_raw_archived_mirror(), &quot;must have raw archived mirror&quot;);
624   return _archived_mirror;
625 }
626 
627 // No GC barrier
628 void Klass::set_archived_java_mirror_raw(oop m) {
629   assert(DumpSharedSpaces, &quot;called only during runtime&quot;);
630   _archived_mirror = CompressedOops::encode(m);
631 }
</pre>
<hr />
<pre>
655 
656 Klass* Klass::array_klass_impl(bool or_null, TRAPS) {
657   fatal(&quot;array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass&quot;);
658   return NULL;
659 }
660 
661 void Klass::check_array_allocation_length(int length, int max_length, TRAPS) {
662   if (length &gt; max_length) {
663     if (!THREAD-&gt;in_retryable_allocation()) {
664       report_java_out_of_memory(&quot;Requested array size exceeds VM limit&quot;);
665       JvmtiExport::post_array_size_exhausted();
666       THROW_OOP(Universe::out_of_memory_error_array_size());
667     } else {
668       THROW_OOP(Universe::out_of_memory_error_retry());
669     }
670   } else if (length &lt; 0) {
671     THROW_MSG(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
672   }
673 }
674 














675 // In product mode, this function doesn&#39;t have virtual function calls so
676 // there might be some performance advantage to handling InstanceKlass here.
677 const char* Klass::external_name() const {
678   if (is_instance_klass()) {
679     const InstanceKlass* ik = static_cast&lt;const InstanceKlass*&gt;(this);
680     if (ik-&gt;is_unsafe_anonymous()) {
681       char addr_buf[20];
682       jio_snprintf(addr_buf, 20, &quot;/&quot; INTPTR_FORMAT, p2i(ik));
683       size_t addr_len = strlen(addr_buf);
684       size_t name_len = name()-&gt;utf8_length();
685       char*  result   = NEW_RESOURCE_ARRAY(char, name_len + addr_len + 1);
686       name()-&gt;as_klass_external_name(result, (int) name_len + 1);
687       assert(strlen(result) == name_len, &quot;&quot;);
688       strcpy(result + name_len, addr_buf);
689       assert(strlen(result) == name_len + addr_len, &quot;&quot;);
690       return result;




691     }



692   }
693   if (name() == NULL)  return &quot;&lt;unknown&gt;&quot;;
694   return name()-&gt;as_klass_external_name();
695 }
696 
697 const char* Klass::signature_name() const {
698   if (name() == NULL)  return &quot;&lt;unknown&gt;&quot;;












699   return name()-&gt;as_C_string();
700 }
701 
702 const char* Klass::external_kind() const {
703   if (is_interface()) return &quot;interface&quot;;
704   if (is_abstract()) return &quot;abstract class&quot;;
705   return &quot;class&quot;;
706 }
707 
708 // Unless overridden, modifier_flags is 0.
709 jint Klass::compute_modifier_flags(TRAPS) const {
710   return 0;
711 }
712 
713 int Klass::atomic_incr_biased_lock_revocation_count() {
714   return (int) Atomic::add(&amp;_biased_lock_revocation_count, 1);
715 }
716 
717 // Unless overridden, jvmti_class_status has no flags set.
718 jint Klass::jvmti_class_status() const {
</pre>
</td>
<td>
<hr />
<pre>
591     log_debug(cds, mirror)(&quot;%s has raw archived mirror&quot;, external_name());
592     if (HeapShared::open_archive_heap_region_mapped()) {
593       bool present = java_lang_Class::restore_archived_mirror(this, loader, module_handle,
594                                                               protection_domain,
595                                                               CHECK);
596       if (present) {
597         return;
598       }
599     }
600 
601     // No archived mirror data
602     log_debug(cds, mirror)(&quot;No archived mirror data for %s&quot;, external_name());
603     _java_mirror = NULL;
604     this-&gt;clear_has_raw_archived_mirror();
605   }
606 
607   // Only recreate it if not present.  A previous attempt to restore may have
608   // gotten an OOM later but keep the mirror if it was created.
609   if (java_mirror() == NULL) {
610     log_trace(cds, mirror)(&quot;Recreate mirror for %s&quot;, external_name());
<span class="line-modified">611     java_lang_Class::create_mirror(this, loader, module_handle, protection_domain, Handle(), CHECK);</span>
612   }
613 }
614 
615 #if INCLUDE_CDS_JAVA_HEAP
616 // Used at CDS dump time to access the archived mirror. No GC barrier.
617 oop Klass::archived_java_mirror_raw() {
618   assert(has_raw_archived_mirror(), &quot;must have raw archived mirror&quot;);
619   return CompressedOops::decode(_archived_mirror);
620 }
621 
622 narrowOop Klass::archived_java_mirror_raw_narrow() {
623   assert(has_raw_archived_mirror(), &quot;must have raw archived mirror&quot;);
624   return _archived_mirror;
625 }
626 
627 // No GC barrier
628 void Klass::set_archived_java_mirror_raw(oop m) {
629   assert(DumpSharedSpaces, &quot;called only during runtime&quot;);
630   _archived_mirror = CompressedOops::encode(m);
631 }
</pre>
<hr />
<pre>
655 
656 Klass* Klass::array_klass_impl(bool or_null, TRAPS) {
657   fatal(&quot;array_klass should be dispatched to InstanceKlass, ObjArrayKlass or TypeArrayKlass&quot;);
658   return NULL;
659 }
660 
661 void Klass::check_array_allocation_length(int length, int max_length, TRAPS) {
662   if (length &gt; max_length) {
663     if (!THREAD-&gt;in_retryable_allocation()) {
664       report_java_out_of_memory(&quot;Requested array size exceeds VM limit&quot;);
665       JvmtiExport::post_array_size_exhausted();
666       THROW_OOP(Universe::out_of_memory_error_array_size());
667     } else {
668       THROW_OOP(Universe::out_of_memory_error_retry());
669     }
670   } else if (length &lt; 0) {
671     THROW_MSG(vmSymbols::java_lang_NegativeArraySizeException(), err_msg(&quot;%d&quot;, length));
672   }
673 }
674 
<span class="line-added">675 // Replace the last &#39;+&#39; char with &#39;/&#39;.</span>
<span class="line-added">676 static char* convert_hidden_name_to_java(Symbol* name) {</span>
<span class="line-added">677   size_t name_len = name-&gt;utf8_length();</span>
<span class="line-added">678   char* result = NEW_RESOURCE_ARRAY(char, name_len + 1);</span>
<span class="line-added">679   name-&gt;as_klass_external_name(result, (int)name_len + 1);</span>
<span class="line-added">680   for (int index = (int)name_len; index &gt; 0; index--) {</span>
<span class="line-added">681     if (result[index] == &#39;+&#39;) {</span>
<span class="line-added">682       result[index] = JVM_SIGNATURE_SLASH;</span>
<span class="line-added">683       break;</span>
<span class="line-added">684     }</span>
<span class="line-added">685   }</span>
<span class="line-added">686   return result;</span>
<span class="line-added">687 }</span>
<span class="line-added">688 </span>
689 // In product mode, this function doesn&#39;t have virtual function calls so
690 // there might be some performance advantage to handling InstanceKlass here.
691 const char* Klass::external_name() const {
692   if (is_instance_klass()) {
693     const InstanceKlass* ik = static_cast&lt;const InstanceKlass*&gt;(this);
694     if (ik-&gt;is_unsafe_anonymous()) {
695       char addr_buf[20];
696       jio_snprintf(addr_buf, 20, &quot;/&quot; INTPTR_FORMAT, p2i(ik));
697       size_t addr_len = strlen(addr_buf);
698       size_t name_len = name()-&gt;utf8_length();
699       char*  result   = NEW_RESOURCE_ARRAY(char, name_len + addr_len + 1);
700       name()-&gt;as_klass_external_name(result, (int) name_len + 1);
701       assert(strlen(result) == name_len, &quot;&quot;);
702       strcpy(result + name_len, addr_buf);
703       assert(strlen(result) == name_len + addr_len, &quot;&quot;);
704       return result;
<span class="line-added">705 </span>
<span class="line-added">706     } else if (ik-&gt;is_hidden()) {</span>
<span class="line-added">707       char* result = convert_hidden_name_to_java(name());</span>
<span class="line-added">708       return result;</span>
709     }
<span class="line-added">710   } else if (is_objArray_klass() &amp;&amp; ObjArrayKlass::cast(this)-&gt;bottom_klass()-&gt;is_hidden()) {</span>
<span class="line-added">711     char* result = convert_hidden_name_to_java(name());</span>
<span class="line-added">712     return result;</span>
713   }
714   if (name() == NULL)  return &quot;&lt;unknown&gt;&quot;;
715   return name()-&gt;as_klass_external_name();
716 }
717 
718 const char* Klass::signature_name() const {
719   if (name() == NULL)  return &quot;&lt;unknown&gt;&quot;;
<span class="line-added">720   if (is_objArray_klass() &amp;&amp; ObjArrayKlass::cast(this)-&gt;bottom_klass()-&gt;is_hidden()) {</span>
<span class="line-added">721     size_t name_len = name()-&gt;utf8_length();</span>
<span class="line-added">722     char* result = NEW_RESOURCE_ARRAY(char, name_len + 1);</span>
<span class="line-added">723     name()-&gt;as_C_string(result, (int)name_len + 1);</span>
<span class="line-added">724     for (int index = (int)name_len; index &gt; 0; index--) {</span>
<span class="line-added">725       if (result[index] == &#39;+&#39;) {</span>
<span class="line-added">726         result[index] = JVM_SIGNATURE_DOT;</span>
<span class="line-added">727         break;</span>
<span class="line-added">728       }</span>
<span class="line-added">729     }</span>
<span class="line-added">730     return result;</span>
<span class="line-added">731   }</span>
732   return name()-&gt;as_C_string();
733 }
734 
735 const char* Klass::external_kind() const {
736   if (is_interface()) return &quot;interface&quot;;
737   if (is_abstract()) return &quot;abstract class&quot;;
738   return &quot;class&quot;;
739 }
740 
741 // Unless overridden, modifier_flags is 0.
742 jint Klass::compute_modifier_flags(TRAPS) const {
743   return 0;
744 }
745 
746 int Klass::atomic_incr_biased_lock_revocation_count() {
747   return (int) Atomic::add(&amp;_biased_lock_revocation_count, 1);
748 }
749 
750 // Unless overridden, jvmti_class_status has no flags set.
751 jint Klass::jvmti_class_status() const {
</pre>
</td>
</tr>
</table>
<center><a href="instanceKlass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="klass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
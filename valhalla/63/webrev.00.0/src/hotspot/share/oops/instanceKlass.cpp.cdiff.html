<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cpCache.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,10 ***</span>
<span class="line-new-header">--- 29,11 ---</span>
  #include &quot;classfile/classFileStream.hpp&quot;
  #include &quot;classfile/classLoader.hpp&quot;
  #include &quot;classfile/classLoaderData.inline.hpp&quot;
  #include &quot;classfile/javaClasses.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
<span class="line-added">+ #include &quot;classfile/resolutionErrors.hpp&quot;</span>
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/systemDictionaryShared.hpp&quot;
  #include &quot;classfile/verifier.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,10 ***</span>
<span class="line-new-header">--- 134,11 ---</span>
  #define DTRACE_CLASSINIT_PROBE(type, thread_type)
  #define DTRACE_CLASSINIT_PROBE_WAIT(type, thread_type, wait)
  
  #endif //  ndef DTRACE_ENABLED
  
<span class="line-added">+ </span>
  static inline bool is_class_loader(const Symbol* class_name,
                                     const ClassFileParser&amp; parser) {
    assert(class_name != NULL, &quot;invariant&quot;);
  
    if (class_name == vmSymbols::java_lang_ClassLoader()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 152,12 ***</span>
      }
    }
    return false;
  }
  
<span class="line-modified">! // called to verify that k is a member of this nest</span>
  bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {
    if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {
      if (log_is_enabled(Trace, class, nestmates)) {
        ResourceMark rm(THREAD);
        log_trace(class, nestmates)(&quot;Checked nest membership of %s in non-nest-host class %s&quot;,
                                    k-&gt;external_name(), this-&gt;external_name());
<span class="line-new-header">--- 154,15 ---</span>
      }
    }
    return false;
  }
  
<span class="line-modified">! // private: called to verify that k is a static member of this nest.</span>
<span class="line-added">+ // We know that k is an instance class in the same package and hence the</span>
<span class="line-added">+ // same classloader.</span>
  bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {
<span class="line-added">+   assert(!is_hidden(), &quot;unexpected hidden class&quot;);</span>
    if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {
      if (log_is_enabled(Trace, class, nestmates)) {
        ResourceMark rm(THREAD);
        log_trace(class, nestmates)(&quot;Checked nest membership of %s in non-nest-host class %s&quot;,
                                    k-&gt;external_name(), this-&gt;external_name());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,30 ***</span>
    // Check for a resolved cp entry , else fall back to a name check.
    // We don&#39;t want to resolve any class other than the one being checked.
    for (int i = 0; i &lt; _nest_members-&gt;length(); i++) {
      int cp_index = _nest_members-&gt;at(i);
      if (_constants-&gt;tag_at(cp_index).is_klass()) {
<span class="line-modified">!       Klass* k2 = _constants-&gt;klass_at(cp_index, CHECK_false);</span>
        if (k2 == k) {
          log_trace(class, nestmates)(&quot;- class is listed at nest_members[%d] =&gt; cp[%d]&quot;, i, cp_index);
          return true;
        }
      }
      else {
        Symbol* name = _constants-&gt;klass_name_at(cp_index);
        if (name == k-&gt;name()) {
          log_trace(class, nestmates)(&quot;- Found it at nest_members[%d] =&gt; cp[%d]&quot;, i, cp_index);
  
<span class="line-modified">!         // Names match so check actual klass - this may trigger class loading if</span>
<span class="line-modified">!         // it doesn&#39;t match (though that should be impossible). But to be safe we</span>
<span class="line-modified">!         // have to check for a compiler thread executing here.</span>
<span class="line-modified">!         if (!THREAD-&gt;can_call_java() &amp;&amp; !_constants-&gt;tag_at(cp_index).is_klass()) {</span>
<span class="line-modified">!           log_trace(class, nestmates)(&quot;- validation required resolution in an unsuitable thread&quot;);</span>
<span class="line-modified">!           return false;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-removed">-         Klass* k2 = _constants-&gt;klass_at(cp_index, CHECK_false);</span>
          if (k2 == k) {
            log_trace(class, nestmates)(&quot;- class is listed as a nest member&quot;);
            return true;
          }
          else {
<span class="line-new-header">--- 179,31 ---</span>
    // Check for a resolved cp entry , else fall back to a name check.
    // We don&#39;t want to resolve any class other than the one being checked.
    for (int i = 0; i &lt; _nest_members-&gt;length(); i++) {
      int cp_index = _nest_members-&gt;at(i);
      if (_constants-&gt;tag_at(cp_index).is_klass()) {
<span class="line-modified">!       Klass* k2 = _constants-&gt;klass_at(cp_index, THREAD);</span>
<span class="line-added">+       assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass()),</span>
<span class="line-added">+              &quot;Exceptions should not be possible here&quot;);</span>
        if (k2 == k) {
          log_trace(class, nestmates)(&quot;- class is listed at nest_members[%d] =&gt; cp[%d]&quot;, i, cp_index);
          return true;
        }
      }
      else {
        Symbol* name = _constants-&gt;klass_name_at(cp_index);
        if (name == k-&gt;name()) {
          log_trace(class, nestmates)(&quot;- Found it at nest_members[%d] =&gt; cp[%d]&quot;, i, cp_index);
  
<span class="line-modified">!         // Names match so check actual klass. This may trigger class loading if</span>
<span class="line-modified">!         // it doesn&#39;t match though that should be impossible as it means one classloader</span>
<span class="line-modified">!         // has defined two different classes with the same name! A compiler thread won&#39;t be</span>
<span class="line-modified">!         // able to perform that loading but we can&#39;t exclude the compiler threads from</span>
<span class="line-modified">!         // executing this logic. But it should actually be impossible to trigger loading here.</span>
<span class="line-modified">!         Klass* k2 = _constants-&gt;klass_at(cp_index, THREAD);</span>
<span class="line-modified">!         assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass()),</span>
<span class="line-modified">!                &quot;Exceptions should not be possible here&quot;);</span>
          if (k2 == k) {
            log_trace(class, nestmates)(&quot;- class is listed as a nest member&quot;);
            return true;
          }
          else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,171 ***</span>
    log_trace(class, nestmates)(&quot;- class is NOT a nest member!&quot;);
    return false;
  }
  
  // Return nest-host class, resolving, validating and saving it if needed.
<span class="line-modified">! // In cases where this is called from a thread that can not do classloading</span>
  // (such as a native JIT thread) then we simply return NULL, which in turn
  // causes the access check to return false. Such code will retry the access
<span class="line-modified">! // from a more suitable environment later.</span>
<span class="line-modified">! InstanceKlass* InstanceKlass::nest_host(Symbol* validationException, TRAPS) {</span>
    InstanceKlass* nest_host_k = _nest_host;
<span class="line-modified">!   if (nest_host_k == NULL) {</span>
<span class="line-modified">!     // need to resolve and save our nest-host class. This could be attempted</span>
<span class="line-modified">!     // concurrently but as the result is idempotent and we don&#39;t use the class</span>
<span class="line-removed">-     // then we do not need any synchronization beyond what is implicitly used</span>
<span class="line-removed">-     // during class loading.</span>
<span class="line-removed">-     if (_nest_host_index != 0) { // we have a real nest_host</span>
<span class="line-removed">-       // Before trying to resolve check if we&#39;re in a suitable context</span>
<span class="line-removed">-       if (!THREAD-&gt;can_call_java() &amp;&amp; !_constants-&gt;tag_at(_nest_host_index).is_klass()) {</span>
<span class="line-removed">-         if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-removed">-           ResourceMark rm(THREAD);</span>
<span class="line-removed">-           log_trace(class, nestmates)(&quot;Rejected resolution of nest-host of %s in unsuitable thread&quot;,</span>
<span class="line-removed">-                                       this-&gt;external_name());</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return NULL;</span>
<span class="line-removed">-       }</span>
  
<span class="line-modified">!       if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-removed">-         ResourceMark rm(THREAD);</span>
<span class="line-removed">-         log_trace(class, nestmates)(&quot;Resolving nest-host of %s using cp entry for %s&quot;,</span>
<span class="line-removed">-                                     this-&gt;external_name(),</span>
<span class="line-removed">-                                     _constants-&gt;klass_name_at(_nest_host_index)-&gt;as_C_string());</span>
<span class="line-removed">-       }</span>
  
<span class="line-modified">!       Klass* k = _constants-&gt;klass_at(_nest_host_index, THREAD);</span>
<span class="line-modified">!       if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-modified">!         Handle exc_h = Handle(THREAD, PENDING_EXCEPTION);</span>
<span class="line-modified">!         if (exc_h-&gt;is_a(SystemDictionary::NoClassDefFoundError_klass())) {</span>
<span class="line-modified">!           // throw a new CDNFE with the original as its cause, and a clear msg</span>
<span class="line-modified">!           ResourceMark rm(THREAD);</span>
<span class="line-modified">!           char buf[200];</span>
<span class="line-modified">!           CLEAR_PENDING_EXCEPTION;</span>
<span class="line-modified">!           jio_snprintf(buf, sizeof(buf),</span>
<span class="line-modified">!                        &quot;Unable to load nest-host class (%s) of %s&quot;,</span>
<span class="line-modified">!                        _constants-&gt;klass_name_at(_nest_host_index)-&gt;as_C_string(),</span>
<span class="line-modified">!                        this-&gt;external_name());</span>
<span class="line-modified">!           log_trace(class, nestmates)(&quot;%s - NoClassDefFoundError&quot;, buf);</span>
<span class="line-modified">!           THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), buf, exc_h);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // All other exceptions pass through (OOME, StackOverflowError, LinkageErrors etc).</span>
<span class="line-modified">!         return NULL;</span>
        }
  
        // A valid nest-host is an instance class in the current package that lists this
<span class="line-modified">!       // class as a nest member. If any of these conditions are not met we post the</span>
<span class="line-modified">!       // requested exception type (if any) and return NULL</span>
<span class="line-removed">- </span>
        const char* error = NULL;
  
        // JVMS 5.4.4 indicates package check comes first
        if (is_same_class_package(k)) {
<span class="line-removed">- </span>
          // Now check actual membership. We can&#39;t be a member if our &quot;host&quot; is
          // not an instance class.
          if (k-&gt;is_instance_klass()) {
            nest_host_k = InstanceKlass::cast(k);
  
<span class="line-removed">-           bool is_member = nest_host_k-&gt;has_nest_member(this, CHECK_NULL);</span>
<span class="line-removed">-           if (is_member) {</span>
<span class="line-removed">-             // save resolved nest-host value</span>
<span class="line-removed">-             _nest_host = nest_host_k;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-removed">-               ResourceMark rm(THREAD);</span>
                log_trace(class, nestmates)(&quot;Resolved nest-host of %s to %s&quot;,
                                            this-&gt;external_name(), k-&gt;external_name());
              }
<span class="line-modified">!             return nest_host_k;</span>
            }
          }
<span class="line-removed">-         error = &quot;current type is not listed as a nest member&quot;;</span>
        } else {
          error = &quot;types are in different packages&quot;;
        }
  
<span class="line-modified">!       if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-modified">!         ResourceMark rm(THREAD);</span>
<span class="line-modified">!         log_trace(class, nestmates)</span>
<span class="line-modified">!           (&quot;Type %s (loader: %s) is not a nest member of &quot;</span>
<span class="line-modified">!            &quot;resolved type %s (loader: %s): %s&quot;,</span>
<span class="line-modified">!            this-&gt;external_name(),</span>
<span class="line-modified">!            this-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-modified">!            k-&gt;external_name(),</span>
<span class="line-modified">!            k-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-modified">!            error);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!       if (validationException != NULL &amp;&amp; THREAD-&gt;can_call_java()) {</span>
<span class="line-removed">-         ResourceMark rm(THREAD);</span>
<span class="line-removed">-         Exceptions::fthrow(THREAD_AND_LOCATION,</span>
<span class="line-removed">-                            validationException,</span>
<span class="line-removed">-                            &quot;Type %s (loader: %s) is not a nest member of %s (loader: %s): %s&quot;,</span>
<span class="line-removed">-                            this-&gt;external_name(),</span>
<span class="line-removed">-                            this-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-removed">-                            k-&gt;external_name(),</span>
<span class="line-removed">-                            k-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-removed">-                            error</span>
<span class="line-removed">-                            );</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       return NULL;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-removed">-         ResourceMark rm(THREAD);</span>
<span class="line-removed">-         log_trace(class, nestmates)(&quot;Type %s is not part of a nest: setting nest-host to self&quot;,</span>
<span class="line-removed">-                                     this-&gt;external_name());</span>
        }
<span class="line-modified">!       // save resolved nest-host value</span>
<span class="line-modified">!       return (_nest_host = this);</span>
                                  msg);
    }
<span class="line-modified">!   return nest_host_k;</span>
  }
  
  // check if &#39;this&#39; and k are nestmates (same nest_host), or k is our nest_host,
  // or we are k&#39;s nest_host - all of which is covered by comparing the two
<span class="line-modified">! // resolved_nest_hosts</span>
  bool InstanceKlass::has_nestmate_access_to(InstanceKlass* k, TRAPS) {
  
    assert(this != k, &quot;this should be handled by higher-level code&quot;);
  
    // Per JVMS 5.4.4 we first resolve and validate the current class, then
<span class="line-modified">!   // the target class k. Resolution exceptions will be passed on by upper</span>
<span class="line-removed">-   // layers. IncompatibleClassChangeErrors from membership validation failures</span>
<span class="line-removed">-   // will also be passed through.</span>
  
<span class="line-modified">!   Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();</span>
<span class="line-removed">-   InstanceKlass* cur_host = nest_host(icce, CHECK_false);</span>
    if (cur_host == NULL) {
      return false;
    }
  
<span class="line-modified">!   Klass* k_nest_host = k-&gt;nest_host(icce, CHECK_false);</span>
    if (k_nest_host == NULL) {
      return false;
    }
  
    bool access = (cur_host == k_nest_host);
  
<span class="line-modified">!   if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-modified">!     ResourceMark rm(THREAD);</span>
<span class="line-modified">!     log_trace(class, nestmates)(&quot;Class %s does %shave nestmate access to %s&quot;,</span>
<span class="line-modified">!                                 this-&gt;external_name(),</span>
<span class="line-modified">!                                 access ? &quot;&quot; : &quot;NOT &quot;,</span>
<span class="line-removed">-                                 k-&gt;external_name());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    return access;
  }
  
  InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
    const int size = InstanceKlass::size(parser.vtable_size(),
                                         parser.itable_size(),
                                         nonstatic_oop_map_size(parser.total_oop_map_count()),
                                         parser.is_interface(),
                                         parser.is_unsafe_anonymous(),
<span class="line-modified">!                                        should_store_fingerprint(parser.is_unsafe_anonymous()),</span>
                                         parser.has_flattenable_fields() ? parser.java_fields_count() : 0,
                                         parser.is_inline_type());
  
    const Symbol* const class_name = parser.class_name();
    assert(class_name != NULL, &quot;invariant&quot;);
<span class="line-new-header">--- 218,214 ---</span>
    log_trace(class, nestmates)(&quot;- class is NOT a nest member!&quot;);
    return false;
  }
  
  // Return nest-host class, resolving, validating and saving it if needed.
<span class="line-modified">! // In cases where this is called from a thread that cannot do classloading</span>
  // (such as a native JIT thread) then we simply return NULL, which in turn
  // causes the access check to return false. Such code will retry the access
<span class="line-modified">! // from a more suitable environment later. Otherwise the _nest_host is always</span>
<span class="line-modified">! // set once this method returns.</span>
<span class="line-added">+ // Any errors from nest-host resolution must be preserved so they can be queried</span>
<span class="line-added">+ // from higher-level access checking code, and reported as part of access checking</span>
<span class="line-added">+ // exceptions.</span>
<span class="line-added">+ // VirtualMachineErrors are propagated with a NULL return.</span>
<span class="line-added">+ // Under any conditions where the _nest_host can be set to non-NULL the resulting</span>
<span class="line-added">+ // value of it and, if applicable, the nest host resolution/validation error,</span>
<span class="line-added">+ // are idempotent.</span>
<span class="line-added">+ InstanceKlass* InstanceKlass::nest_host(TRAPS) {</span>
    InstanceKlass* nest_host_k = _nest_host;
<span class="line-modified">!   if (nest_host_k != NULL) {</span>
<span class="line-modified">!     return nest_host_k;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   ResourceMark rm(THREAD);</span>
  
<span class="line-modified">!   // need to resolve and save our nest-host class.</span>
<span class="line-modified">!   if (_nest_host_index != 0) { // we have a real nest_host</span>
<span class="line-modified">!     // Before trying to resolve check if we&#39;re in a suitable context</span>
<span class="line-modified">!     if (!THREAD-&gt;can_call_java() &amp;&amp; !_constants-&gt;tag_at(_nest_host_index).is_klass()) {</span>
<span class="line-modified">!       log_trace(class, nestmates)(&quot;Rejected resolution of nest-host of %s in unsuitable thread&quot;,</span>
<span class="line-modified">!                                   this-&gt;external_name());</span>
<span class="line-modified">!       return NULL; // sentinel to say &quot;try again from a different context&quot;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     log_trace(class, nestmates)(&quot;Resolving nest-host of %s using cp entry for %s&quot;,</span>
<span class="line-modified">!                                 this-&gt;external_name(),</span>
<span class="line-modified">!                                 _constants-&gt;klass_name_at(_nest_host_index)-&gt;as_C_string());</span>
<span class="line-modified">! </span>
<span class="line-modified">!     Klass* k = _constants-&gt;klass_at(_nest_host_index, THREAD);</span>
<span class="line-modified">!     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-modified">!       if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass())) {</span>
<span class="line-modified">!         return NULL; // propagate VMEs</span>
        }
<span class="line-added">+       stringStream ss;</span>
<span class="line-added">+       char* target_host_class = _constants-&gt;klass_name_at(_nest_host_index)-&gt;as_C_string();</span>
<span class="line-added">+       ss.print(&quot;Nest host resolution of %s with host %s failed: &quot;,</span>
<span class="line-added">+                this-&gt;external_name(), target_host_class);</span>
<span class="line-added">+       java_lang_Throwable::print(PENDING_EXCEPTION, &amp;ss);</span>
<span class="line-added">+       const char* msg = ss.as_string(true /* on C-heap */);</span>
<span class="line-added">+       constantPoolHandle cph(THREAD, constants());</span>
<span class="line-added">+       SystemDictionary::add_nest_host_error(cph, _nest_host_index, msg);</span>
<span class="line-added">+       CLEAR_PENDING_EXCEPTION;</span>
  
<span class="line-added">+       log_trace(class, nestmates)(&quot;%s&quot;, msg);</span>
<span class="line-added">+     } else {</span>
        // A valid nest-host is an instance class in the current package that lists this
<span class="line-modified">!       // class as a nest member. If any of these conditions are not met the class is</span>
<span class="line-modified">!       // its own nest-host.</span>
        const char* error = NULL;
  
        // JVMS 5.4.4 indicates package check comes first
        if (is_same_class_package(k)) {
          // Now check actual membership. We can&#39;t be a member if our &quot;host&quot; is
          // not an instance class.
          if (k-&gt;is_instance_klass()) {
            nest_host_k = InstanceKlass::cast(k);
<span class="line-added">+           bool is_member = nest_host_k-&gt;has_nest_member(this, THREAD);</span>
<span class="line-added">+           // exception is rare, perhaps impossible</span>
<span class="line-added">+           if (!HAS_PENDING_EXCEPTION) {</span>
<span class="line-added">+             if (is_member) {</span>
<span class="line-added">+               _nest_host = nest_host_k; // save resolved nest-host value</span>
  
                log_trace(class, nestmates)(&quot;Resolved nest-host of %s to %s&quot;,
                                            this-&gt;external_name(), k-&gt;external_name());
<span class="line-added">+               return nest_host_k;</span>
<span class="line-added">+             } else {</span>
<span class="line-added">+               error = &quot;current type is not listed as a nest member&quot;;</span>
<span class="line-added">+             }</span>
<span class="line-added">+           } else {</span>
<span class="line-added">+             if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass())) {</span>
<span class="line-added">+               return NULL; // propagate VMEs</span>
              }
<span class="line-modified">!             stringStream ss;</span>
<span class="line-added">+             ss.print(&quot;exception on member check: &quot;);</span>
<span class="line-added">+             java_lang_Throwable::print(PENDING_EXCEPTION, &amp;ss);</span>
<span class="line-added">+             error = ss.as_string();</span>
            }
<span class="line-added">+         } else {</span>
<span class="line-added">+           error = &quot;host is not an instance class&quot;;</span>
          }
        } else {
          error = &quot;types are in different packages&quot;;
        }
  
<span class="line-modified">!       // something went wrong, so record what and log it</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         stringStream ss;</span>
<span class="line-modified">!         ss.print(&quot;Type %s (loader: %s) is not a nest member of type %s (loader: %s): %s&quot;,</span>
<span class="line-modified">!                  this-&gt;external_name(),</span>
<span class="line-modified">!                  this-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-modified">!                  k-&gt;external_name(),</span>
<span class="line-modified">!                  k-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-modified">!                  error);</span>
<span class="line-modified">!         const char* msg = ss.as_string(true /* on C-heap */);</span>
<span class="line-modified">!         constantPoolHandle cph(THREAD, constants());</span>
<span class="line-modified">!         SystemDictionary::add_nest_host_error(cph, _nest_host_index, msg);</span>
<span class="line-modified">!         log_trace(class, nestmates)(&quot;%s&quot;, msg);</span>
        }
<span class="line-modified">!     }</span>
<span class="line-modified">!   } else {</span>
<span class="line-added">+     log_trace(class, nestmates)(&quot;Type %s is not part of a nest: setting nest-host to self&quot;,</span>
<span class="line-added">+                                 this-&gt;external_name());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Either not in an explicit nest, or else an error occurred, so</span>
<span class="line-added">+   // the nest-host is set to `this`. Any thread that sees this assignment</span>
<span class="line-added">+   // will also see any setting of nest_host_error(), if applicable.</span>
<span class="line-added">+   return (_nest_host = this);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Dynamic nest member support: set this class&#39;s nest host to the given class.</span>
<span class="line-added">+ // This occurs as part of the class definition, as soon as the instanceKlass</span>
<span class="line-added">+ // has been created and doesn&#39;t require further resolution. The code:</span>
<span class="line-added">+ //    lookup().defineHiddenClass(bytes_for_X, NESTMATE);</span>
<span class="line-added">+ // results in:</span>
<span class="line-added">+ //    class_of_X.set_nest_host(lookup().lookupClass().getNestHost())</span>
<span class="line-added">+ // If it has an explicit _nest_host_index or _nest_members, these will be ignored.</span>
<span class="line-added">+ // We also know the &quot;host&quot; is a valid nest-host in the same package so we can</span>
<span class="line-added">+ // assert some of those facts.</span>
<span class="line-added">+ void InstanceKlass::set_nest_host(InstanceKlass* host, TRAPS) {</span>
<span class="line-added">+   assert(is_hidden(), &quot;must be a hidden class&quot;);</span>
<span class="line-added">+   assert(host != NULL, &quot;NULL nest host specified&quot;);</span>
<span class="line-added">+   assert(_nest_host == NULL, &quot;current class has resolved nest-host&quot;);</span>
<span class="line-added">+   assert(nest_host_error(THREAD) == NULL, &quot;unexpected nest host resolution error exists: %s&quot;,</span>
<span class="line-added">+          nest_host_error(THREAD));</span>
<span class="line-added">+   assert((host-&gt;_nest_host == NULL &amp;&amp; host-&gt;_nest_host_index == 0) ||</span>
<span class="line-added">+          (host-&gt;_nest_host == host), &quot;proposed host is not a valid nest-host&quot;);</span>
<span class="line-added">+   // Can&#39;t assert this as package is not set yet:</span>
<span class="line-added">+   // assert(is_same_class_package(host), &quot;proposed host is in wrong package&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-added">+     ResourceMark rm(THREAD);</span>
<span class="line-added">+     const char* msg = &quot;&quot;;</span>
<span class="line-added">+     // a hidden class does not expect a statically defined nest-host</span>
<span class="line-added">+     if (_nest_host_index &gt; 0) {</span>
<span class="line-added">+       msg = &quot;(the NestHost attribute in the current class is ignored)&quot;;</span>
<span class="line-added">+     } else if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {</span>
<span class="line-added">+       msg = &quot;(the NestMembers attribute in the current class is ignored)&quot;;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     log_trace(class, nestmates)(&quot;Injected type %s into the nest of %s %s&quot;,</span>
<span class="line-added">+                                 this-&gt;external_name(),</span>
<span class="line-added">+                                 host-&gt;external_name(),</span>
                                  msg);
    }
<span class="line-modified">!   // set dynamic nest host</span>
<span class="line-added">+   _nest_host = host;</span>
<span class="line-added">+   // Record dependency to keep nest host from being unloaded before this class.</span>
<span class="line-added">+   ClassLoaderData* this_key = class_loader_data();</span>
<span class="line-added">+   this_key-&gt;record_dependency(host);</span>
  }
  
  // check if &#39;this&#39; and k are nestmates (same nest_host), or k is our nest_host,
  // or we are k&#39;s nest_host - all of which is covered by comparing the two
<span class="line-modified">! // resolved_nest_hosts.</span>
<span class="line-added">+ // Any exceptions (i.e. VMEs) are propagated.</span>
  bool InstanceKlass::has_nestmate_access_to(InstanceKlass* k, TRAPS) {
  
    assert(this != k, &quot;this should be handled by higher-level code&quot;);
  
    // Per JVMS 5.4.4 we first resolve and validate the current class, then
<span class="line-modified">!   // the target class k.</span>
  
<span class="line-modified">!   InstanceKlass* cur_host = nest_host(CHECK_false);</span>
    if (cur_host == NULL) {
      return false;
    }
  
<span class="line-modified">!   Klass* k_nest_host = k-&gt;nest_host(CHECK_false);</span>
    if (k_nest_host == NULL) {
      return false;
    }
  
    bool access = (cur_host == k_nest_host);
  
<span class="line-modified">!   ResourceMark rm(THREAD);</span>
<span class="line-modified">!   log_trace(class, nestmates)(&quot;Class %s does %shave nestmate access to %s&quot;,</span>
<span class="line-modified">!                               this-&gt;external_name(),</span>
<span class="line-modified">!                               access ? &quot;&quot; : &quot;NOT &quot;,</span>
<span class="line-modified">!                               k-&gt;external_name());</span>
    return access;
  }
  
<span class="line-added">+ const char* InstanceKlass::nest_host_error(TRAPS) {</span>
<span class="line-added">+   if (_nest_host_index == 0) {</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     constantPoolHandle cph(THREAD, constants());</span>
<span class="line-added">+     return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
<span class="line-added">+   bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();</span>
    const int size = InstanceKlass::size(parser.vtable_size(),
                                         parser.itable_size(),
                                         nonstatic_oop_map_size(parser.total_oop_map_count()),
                                         parser.is_interface(),
                                         parser.is_unsafe_anonymous(),
<span class="line-modified">!                                        should_store_fingerprint(is_hidden_or_anonymous),</span>
                                         parser.has_flattenable_fields() ? parser.java_fields_count() : 0,
                                         parser.is_inline_type());
  
    const Symbol* const class_name = parser.class_name();
    assert(class_name != NULL, &quot;invariant&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,10 ***</span>
<span class="line-new-header">--- 531,11 ---</span>
    _adr_valueklass_fixed_block(NULL)
  {
    set_vtable_length(parser.vtable_size());
    set_kind(kind);
    set_access_flags(parser.access_flags());
<span class="line-added">+   if (parser.is_hidden()) set_is_hidden();</span>
    set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
    set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
                                                      false));
      if (parser.has_flattenable_fields()) {
        set_has_inline_fields();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2410,23 ***</span>
    }
  
    return true;
  }
  
<span class="line-modified">! bool InstanceKlass::should_store_fingerprint(bool is_unsafe_anonymous) {</span>
  #if INCLUDE_AOT
    // We store the fingerprint into the InstanceKlass only in the following 2 cases:
    if (CalculateClassFingerprint) {
      // (1) We are running AOT to generate a shared library.
      return true;
    }
    if (Arguments::is_dumping_archive()) {
      // (2) We are running -Xshare:dump or -XX:ArchiveClassesAtExit to create a shared archive
      return true;
    }
<span class="line-modified">!   if (UseAOT &amp;&amp; is_unsafe_anonymous) {</span>
<span class="line-modified">!     // (3) We are using AOT code from a shared library and see an unsafe anonymous class</span>
      return true;
    }
  #endif
  
    // In all other cases we might set the _misc_has_passed_fingerprint_check bit,
<span class="line-new-header">--- 2460,23 ---</span>
    }
  
    return true;
  }
  
<span class="line-modified">! bool InstanceKlass::should_store_fingerprint(bool is_hidden_or_anonymous) {</span>
  #if INCLUDE_AOT
    // We store the fingerprint into the InstanceKlass only in the following 2 cases:
    if (CalculateClassFingerprint) {
      // (1) We are running AOT to generate a shared library.
      return true;
    }
    if (Arguments::is_dumping_archive()) {
      // (2) We are running -Xshare:dump or -XX:ArchiveClassesAtExit to create a shared archive
      return true;
    }
<span class="line-modified">!   if (UseAOT &amp;&amp; is_hidden_or_anonymous) {</span>
<span class="line-modified">!     // (3) We are using AOT code from a shared library and see a hidden or unsafe anonymous class</span>
      return true;
    }
  #endif
  
    // In all other cases we might set the _misc_has_passed_fingerprint_check bit,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2719,10 ***</span>
<span class="line-new-header">--- 2769,11 ---</span>
    }
  #endif
  
    // Decrement symbol reference counts associated with the unloaded class.
    if (_name != NULL) _name-&gt;decrement_refcount();
<span class="line-added">+ </span>
    // unreference array name derived from this class name (arrays of an unloaded
    // class can&#39;t be referenced anymore).
    if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
    if (_inline_types != NULL) {
      for (int i = 0; i &lt; _inline_types-&gt;length(); i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2777,10 ***</span>
<span class="line-new-header">--- 2828,19 ---</span>
    // Add the actual class name
    for (int src_index = 0; src_index &lt; src_length; ) {
      dest[dest_index++] = src[src_index++];
    }
  
<span class="line-added">+   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.</span>
<span class="line-added">+     for (int index = (int)src_length; index &gt; 0; index--) {</span>
<span class="line-added">+       if (dest[index] == &#39;+&#39;) {</span>
<span class="line-added">+         dest[index] = JVM_SIGNATURE_DOT;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // If we have a hash, append it
    for (int hash_index = 0; hash_index &lt; hash_len; ) {
      dest[dest_index++] = hash_buf[hash_index++];
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2795,10 ***</span>
<span class="line-new-header">--- 2855,29 ---</span>
    if (is_unsafe_anonymous()) {
      assert(unsafe_anonymous_host() != NULL, &quot;unsafe anonymous class must have a host class&quot;);
      return unsafe_anonymous_host()-&gt;module();
    }
  
<span class="line-added">+   if (is_hidden() &amp;&amp;</span>
<span class="line-added">+       in_unnamed_package() &amp;&amp;</span>
<span class="line-added">+       class_loader_data()-&gt;has_class_mirror_holder()) {</span>
<span class="line-added">+     // For a non-strong hidden class defined to an unnamed package,</span>
<span class="line-added">+     // its (class held) CLD will not have an unnamed module created for it.</span>
<span class="line-added">+     // Two choices to find the correct ModuleEntry:</span>
<span class="line-added">+     // 1. If hidden class is within a nest, use nest host&#39;s module</span>
<span class="line-added">+     // 2. Find the unnamed module off from the class loader</span>
<span class="line-added">+     // For now option #2 is used since a nest host is not set until</span>
<span class="line-added">+     // after the instance class is created in jvm_lookup_define_class().</span>
<span class="line-added">+     if (class_loader_data()-&gt;is_boot_class_loader_data()) {</span>
<span class="line-added">+       return ClassLoaderData::the_null_class_loader_data()-&gt;unnamed_module();</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       oop module = java_lang_ClassLoader::unnamedModule(class_loader_data()-&gt;class_loader());</span>
<span class="line-added">+       assert(java_lang_Module::is_instance(module), &quot;Not an instance of java.lang.Module&quot;);</span>
<span class="line-added">+       return java_lang_Module::module_entry(module);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    // Class is in a named package
    if (!in_unnamed_package()) {
      return _package_entry-&gt;module();
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2807,11 ***</span>
  }
  
  void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {
  
    // ensure java/ packages only loaded by boot or platform builtin loaders
<span class="line-modified">!   check_prohibited_package(name(), loader_data, CHECK);</span>
  
    TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() : ClassLoader::package_from_class_name(name());
  
    if (pkg_name != NULL &amp;&amp; loader_data != NULL) {
  
<span class="line-new-header">--- 2886,14 ---</span>
  }
  
  void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {
  
    // ensure java/ packages only loaded by boot or platform builtin loaders
<span class="line-modified">!   // not needed for shared class since CDS does not archive prohibited classes.</span>
<span class="line-added">+   if (!is_shared()) {</span>
<span class="line-added">+     check_prohibited_package(name(), loader_data, CHECK);</span>
<span class="line-added">+   }</span>
  
    TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() : ClassLoader::package_from_class_name(name());
  
    if (pkg_name != NULL &amp;&amp; loader_data != NULL) {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2858,10 ***</span>
<span class="line-new-header">--- 2940,27 ---</span>
                        (loader_data != NULL) ? loader_data-&gt;loader_name_and_id() : &quot;NULL&quot;,
                        UNNAMED_MODULE);
    }
  }
  
<span class="line-added">+ // Function set_classpath_index checks if the package of the InstanceKlass is in the</span>
<span class="line-added">+ // boot loader&#39;s package entry table.  If so, then it sets the classpath_index</span>
<span class="line-added">+ // in the package entry record.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // The classpath_index field is used to find the entry on the boot loader class</span>
<span class="line-added">+ // path for packages with classes loaded by the boot loader from -Xbootclasspath/a</span>
<span class="line-added">+ // in an unnamed module.  It is also used to indicate (for all packages whose</span>
<span class="line-added">+ // classes are loaded by the boot loader) that at least one of the package&#39;s</span>
<span class="line-added">+ // classes has been loaded.</span>
<span class="line-added">+ void InstanceKlass::set_classpath_index(s2 path_index, TRAPS) {</span>
<span class="line-added">+   if (_package_entry != NULL) {</span>
<span class="line-added">+     DEBUG_ONLY(PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()-&gt;packages();)</span>
<span class="line-added">+     assert(pkg_entry_tbl-&gt;lookup_only(_package_entry-&gt;name()) == _package_entry, &quot;Should be same&quot;);</span>
<span class="line-added">+     assert(path_index != -1, &quot;Unexpected classpath_index&quot;);</span>
<span class="line-added">+     _package_entry-&gt;set_classpath_index(path_index);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
  // different versions of is_same_class_package
  
  bool InstanceKlass::is_same_class_package(const Klass* class2) const {
    oop classloader1 = this-&gt;class_loader();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3005,11 ***</span>
        Klass* ok = i_cp-&gt;klass_at(ooff, CHECK_NULL);
        outer_klass = InstanceKlass::cast(ok);
        *inner_is_member = true;
      }
      if (NULL == outer_klass) {
<span class="line-modified">!       // It may be unsafe anonymous; try for that.</span>
        int encl_method_class_idx = enclosing_method_class_index();
        if (encl_method_class_idx != 0) {
          Klass* ok = i_cp-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
          outer_klass = InstanceKlass::cast(ok);
          *inner_is_member = false;
<span class="line-new-header">--- 3104,11 ---</span>
        Klass* ok = i_cp-&gt;klass_at(ooff, CHECK_NULL);
        outer_klass = InstanceKlass::cast(ok);
        *inner_is_member = true;
      }
      if (NULL == outer_klass) {
<span class="line-modified">!       // It may be a local or anonymous class; try for that.</span>
        int encl_method_class_idx = enclosing_method_class_index();
        if (encl_method_class_idx != 0) {
          Klass* ok = i_cp-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
          outer_klass = InstanceKlass::cast(ok);
          *inner_is_member = false;
</pre>
<center><a href="cpCache.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="arrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constantPool.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;


  35 #include &quot;memory/allocation.inline.hpp&quot;
  36 #include &quot;memory/heapShared.hpp&quot;
  37 #include &quot;memory/metadataFactory.hpp&quot;
  38 #include &quot;memory/metaspaceClosure.hpp&quot;
  39 #include &quot;memory/metaspaceShared.hpp&quot;
  40 #include &quot;memory/oopFactory.hpp&quot;
  41 #include &quot;memory/resourceArea.hpp&quot;
  42 #include &quot;memory/universe.hpp&quot;
  43 #include &quot;oops/array.hpp&quot;
  44 #include &quot;oops/constantPool.inline.hpp&quot;
  45 #include &quot;oops/cpCache.inline.hpp&quot;
  46 #include &quot;oops/instanceKlass.hpp&quot;
  47 #include &quot;oops/objArrayKlass.hpp&quot;
  48 #include &quot;oops/objArrayOop.inline.hpp&quot;
  49 #include &quot;oops/oop.inline.hpp&quot;
  50 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  51 #include &quot;oops/valueArrayKlass.hpp&quot;
  52 #include &quot;runtime/atomic.hpp&quot;
  53 #include &quot;runtime/handles.inline.hpp&quot;
  54 #include &quot;runtime/init.hpp&quot;
</pre>
<hr />
<pre>
 961       break;
 962     }
 963 
 964   case JVM_CONSTANT_Dynamic:
 965     {
 966       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.
 967       BootstrapInfo bootstrap_specifier(this_cp, index);
 968 
 969       // The initial step in resolving an unresolved symbolic reference to a
 970       // dynamically-computed constant is to resolve the symbolic reference to a
 971       // method handle which will be the bootstrap method for the dynamically-computed
 972       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
 973       // method fails, then a MethodHandleInError is stored at the corresponding
 974       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
 975       // set a DynamicConstantInError here since any subsequent use of this
 976       // bootstrap method will encounter the resolution of MethodHandleInError.
 977       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,
 978       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()
 979       // for the bootstrap_specifier created above.
 980       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
<span class="line-modified"> 981       Exceptions::wrap_dynamic_exception(THREAD);</span>
 982       if (HAS_PENDING_EXCEPTION) {
 983         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
 984         // will check for a LinkageError and store a DynamicConstantInError.
 985         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
 986       }
 987       result_oop = bootstrap_specifier.resolved_value()();
 988       BasicType type = Signature::basic_type(bootstrap_specifier.signature());
 989       if (!is_reference_type(type)) {
 990         // Make sure the primitive value is properly boxed.
 991         // This is a JDK responsibility.
 992         const char* fail = NULL;
 993         if (result_oop == NULL) {
 994           fail = &quot;null result instead of box&quot;;
 995         } else if (!is_java_primitive(type)) {
 996           // FIXME: support value types via unboxing
 997           fail = &quot;can only handle references and primitives&quot;;
 998         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
 999           fail = &quot;primitive is not properly boxed&quot;;
1000         }
1001         if (fail != NULL) {
1002           // Since this exception is not a LinkageError, throw exception
1003           // but do not save a DynamicInError resolution result.
1004           // See section 5.4.3 of the VM spec.
1005           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
1006         }
1007       }
1008 
<span class="line-modified">1009       if (TraceMethodHandles) {</span>
<span class="line-modified">1010         bootstrap_specifier.print_msg_on(tty, &quot;resolve_constant_at_impl&quot;);</span>


1011       }
1012       break;
1013     }
1014 
1015   case JVM_CONSTANT_String:
1016     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
1017     if (this_cp-&gt;is_pseudo_string_at(index)) {
1018       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
1019       break;
1020     }
1021     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
1022     break;
1023 
1024   case JVM_CONSTANT_DynamicInError:
1025   case JVM_CONSTANT_MethodHandleInError:
1026   case JVM_CONSTANT_MethodTypeInError:
1027     {
1028       throw_resolution_error(this_cp, index, CHECK_NULL);
1029       break;
1030     }
</pre>
</td>
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
<span class="line-added">  35 #include &quot;logging/log.hpp&quot;</span>
<span class="line-added">  36 #include &quot;logging/logStream.hpp&quot;</span>
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  53 #include &quot;oops/valueArrayKlass.hpp&quot;
  54 #include &quot;runtime/atomic.hpp&quot;
  55 #include &quot;runtime/handles.inline.hpp&quot;
  56 #include &quot;runtime/init.hpp&quot;
</pre>
<hr />
<pre>
 963       break;
 964     }
 965 
 966   case JVM_CONSTANT_Dynamic:
 967     {
 968       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.
 969       BootstrapInfo bootstrap_specifier(this_cp, index);
 970 
 971       // The initial step in resolving an unresolved symbolic reference to a
 972       // dynamically-computed constant is to resolve the symbolic reference to a
 973       // method handle which will be the bootstrap method for the dynamically-computed
 974       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
 975       // method fails, then a MethodHandleInError is stored at the corresponding
 976       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
 977       // set a DynamicConstantInError here since any subsequent use of this
 978       // bootstrap method will encounter the resolution of MethodHandleInError.
 979       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,
 980       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()
 981       // for the bootstrap_specifier created above.
 982       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
<span class="line-modified"> 983       Exceptions::wrap_dynamic_exception(/* is_indy */ false, THREAD);</span>
 984       if (HAS_PENDING_EXCEPTION) {
 985         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
 986         // will check for a LinkageError and store a DynamicConstantInError.
 987         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
 988       }
 989       result_oop = bootstrap_specifier.resolved_value()();
 990       BasicType type = Signature::basic_type(bootstrap_specifier.signature());
 991       if (!is_reference_type(type)) {
 992         // Make sure the primitive value is properly boxed.
 993         // This is a JDK responsibility.
 994         const char* fail = NULL;
 995         if (result_oop == NULL) {
 996           fail = &quot;null result instead of box&quot;;
 997         } else if (!is_java_primitive(type)) {
 998           // FIXME: support value types via unboxing
 999           fail = &quot;can only handle references and primitives&quot;;
1000         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
1001           fail = &quot;primitive is not properly boxed&quot;;
1002         }
1003         if (fail != NULL) {
1004           // Since this exception is not a LinkageError, throw exception
1005           // but do not save a DynamicInError resolution result.
1006           // See section 5.4.3 of the VM spec.
1007           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
1008         }
1009       }
1010 
<span class="line-modified">1011       LogTarget(Debug, methodhandles, condy) lt_condy;</span>
<span class="line-modified">1012       if (lt_condy.is_enabled()) {</span>
<span class="line-added">1013         LogStream ls(lt_condy);</span>
<span class="line-added">1014         bootstrap_specifier.print_msg_on(&amp;ls, &quot;resolve_constant_at_impl&quot;);</span>
1015       }
1016       break;
1017     }
1018 
1019   case JVM_CONSTANT_String:
1020     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
1021     if (this_cp-&gt;is_pseudo_string_at(index)) {
1022       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
1023       break;
1024     }
1025     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
1026     break;
1027 
1028   case JVM_CONSTANT_DynamicInError:
1029   case JVM_CONSTANT_MethodHandleInError:
1030   case JVM_CONSTANT_MethodTypeInError:
1031     {
1032       throw_resolution_error(this_cp, index, CHECK_NULL);
1033       break;
1034     }
</pre>
</td>
</tr>
</table>
<center><a href="arrayKlass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
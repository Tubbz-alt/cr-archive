<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cpCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/javaClasses.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;

  34 #include &quot;classfile/symbolTable.hpp&quot;
  35 #include &quot;classfile/systemDictionary.hpp&quot;
  36 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  37 #include &quot;classfile/verifier.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;code/dependencyContext.hpp&quot;
  40 #include &quot;compiler/compileBroker.hpp&quot;
  41 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  42 #include &quot;interpreter/oopMapCache.hpp&quot;
  43 #include &quot;interpreter/rewriter.hpp&quot;
  44 #include &quot;jvmtifiles/jvmti.h&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;logging/logMessage.hpp&quot;
  47 #include &quot;logging/logStream.hpp&quot;
  48 #include &quot;memory/allocation.inline.hpp&quot;
  49 #include &quot;memory/iterator.inline.hpp&quot;
  50 #include &quot;memory/metadataFactory.hpp&quot;
  51 #include &quot;memory/metaspaceClosure.hpp&quot;
  52 #include &quot;memory/metaspaceShared.hpp&quot;
  53 #include &quot;memory/oopFactory.hpp&quot;
</pre>
<hr />
<pre>
 118 #define DTRACE_CLASSINIT_PROBE_WAIT(type, thread_type, wait)     \
 119   {                                                              \
 120     char* data = NULL;                                           \
 121     int len = 0;                                                 \
 122     Symbol* clss_name = name();                                  \
 123     if (clss_name != NULL) {                                     \
 124       data = (char*)clss_name-&gt;bytes();                          \
 125       len = clss_name-&gt;utf8_length();                            \
 126     }                                                            \
 127     HOTSPOT_CLASS_INITIALIZATION_##type(                         \
 128       data, len, (void*)class_loader(), thread_type, wait);      \
 129   }
 130 
 131 #else //  ndef DTRACE_ENABLED
 132 
 133 #define DTRACE_CLASSINIT_PROBE(type, thread_type)
 134 #define DTRACE_CLASSINIT_PROBE_WAIT(type, thread_type, wait)
 135 
 136 #endif //  ndef DTRACE_ENABLED
 137 

 138 static inline bool is_class_loader(const Symbol* class_name,
 139                                    const ClassFileParser&amp; parser) {
 140   assert(class_name != NULL, &quot;invariant&quot;);
 141 
 142   if (class_name == vmSymbols::java_lang_ClassLoader()) {
 143     return true;
 144   }
 145 
 146   if (SystemDictionary::ClassLoader_klass_loaded()) {
 147     const Klass* const super_klass = parser.super_klass();
 148     if (super_klass != NULL) {
 149       if (super_klass-&gt;is_subtype_of(SystemDictionary::ClassLoader_klass())) {
 150         return true;
 151       }
 152     }
 153   }
 154   return false;
 155 }
 156 
<span class="line-modified"> 157 // called to verify that k is a member of this nest</span>


 158 bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {

 159   if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {
 160     if (log_is_enabled(Trace, class, nestmates)) {
 161       ResourceMark rm(THREAD);
 162       log_trace(class, nestmates)(&quot;Checked nest membership of %s in non-nest-host class %s&quot;,
 163                                   k-&gt;external_name(), this-&gt;external_name());
 164     }
 165     return false;
 166   }
 167 
 168   if (log_is_enabled(Trace, class, nestmates)) {
 169     ResourceMark rm(THREAD);
 170     log_trace(class, nestmates)(&quot;Checking nest membership of %s in %s&quot;,
 171                                 k-&gt;external_name(), this-&gt;external_name());
 172   }
 173 
 174   // Check for a resolved cp entry , else fall back to a name check.
 175   // We don&#39;t want to resolve any class other than the one being checked.
 176   for (int i = 0; i &lt; _nest_members-&gt;length(); i++) {
 177     int cp_index = _nest_members-&gt;at(i);
 178     if (_constants-&gt;tag_at(cp_index).is_klass()) {
<span class="line-modified"> 179       Klass* k2 = _constants-&gt;klass_at(cp_index, CHECK_false);</span>


 180       if (k2 == k) {
 181         log_trace(class, nestmates)(&quot;- class is listed at nest_members[%d] =&gt; cp[%d]&quot;, i, cp_index);
 182         return true;
 183       }
 184     }
 185     else {
 186       Symbol* name = _constants-&gt;klass_name_at(cp_index);
 187       if (name == k-&gt;name()) {
 188         log_trace(class, nestmates)(&quot;- Found it at nest_members[%d] =&gt; cp[%d]&quot;, i, cp_index);
 189 
<span class="line-modified"> 190         // Names match so check actual klass - this may trigger class loading if</span>
<span class="line-modified"> 191         // it doesn&#39;t match (though that should be impossible). But to be safe we</span>
<span class="line-modified"> 192         // have to check for a compiler thread executing here.</span>
<span class="line-modified"> 193         if (!THREAD-&gt;can_call_java() &amp;&amp; !_constants-&gt;tag_at(cp_index).is_klass()) {</span>
<span class="line-modified"> 194           log_trace(class, nestmates)(&quot;- validation required resolution in an unsuitable thread&quot;);</span>
<span class="line-modified"> 195           return false;</span>
<span class="line-modified"> 196         }</span>
<span class="line-modified"> 197 </span>
<span class="line-removed"> 198         Klass* k2 = _constants-&gt;klass_at(cp_index, CHECK_false);</span>
 199         if (k2 == k) {
 200           log_trace(class, nestmates)(&quot;- class is listed as a nest member&quot;);
 201           return true;
 202         }
 203         else {
 204           // same name but different klass!
 205           log_trace(class, nestmates)(&quot; - klass comparison failed!&quot;);
 206           // can&#39;t have two names the same, so we&#39;re done
 207           return false;
 208         }
 209       }
 210     }
 211   }
 212   log_trace(class, nestmates)(&quot;- class is NOT a nest member!&quot;);
 213   return false;
 214 }
 215 
 216 // Return nest-host class, resolving, validating and saving it if needed.
<span class="line-modified"> 217 // In cases where this is called from a thread that can not do classloading</span>
 218 // (such as a native JIT thread) then we simply return NULL, which in turn
 219 // causes the access check to return false. Such code will retry the access
<span class="line-modified"> 220 // from a more suitable environment later.</span>
<span class="line-modified"> 221 InstanceKlass* InstanceKlass::nest_host(Symbol* validationException, TRAPS) {</span>








 222   InstanceKlass* nest_host_k = _nest_host;
<span class="line-modified"> 223   if (nest_host_k == NULL) {</span>
<span class="line-modified"> 224     // need to resolve and save our nest-host class. This could be attempted</span>
<span class="line-modified"> 225     // concurrently but as the result is idempotent and we don&#39;t use the class</span>
<span class="line-removed"> 226     // then we do not need any synchronization beyond what is implicitly used</span>
<span class="line-removed"> 227     // during class loading.</span>
<span class="line-removed"> 228     if (_nest_host_index != 0) { // we have a real nest_host</span>
<span class="line-removed"> 229       // Before trying to resolve check if we&#39;re in a suitable context</span>
<span class="line-removed"> 230       if (!THREAD-&gt;can_call_java() &amp;&amp; !_constants-&gt;tag_at(_nest_host_index).is_klass()) {</span>
<span class="line-removed"> 231         if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-removed"> 232           ResourceMark rm(THREAD);</span>
<span class="line-removed"> 233           log_trace(class, nestmates)(&quot;Rejected resolution of nest-host of %s in unsuitable thread&quot;,</span>
<span class="line-removed"> 234                                       this-&gt;external_name());</span>
<span class="line-removed"> 235         }</span>
<span class="line-removed"> 236         return NULL;</span>
<span class="line-removed"> 237       }</span>
 238 
<span class="line-modified"> 239       if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-removed"> 240         ResourceMark rm(THREAD);</span>
<span class="line-removed"> 241         log_trace(class, nestmates)(&quot;Resolving nest-host of %s using cp entry for %s&quot;,</span>
<span class="line-removed"> 242                                     this-&gt;external_name(),</span>
<span class="line-removed"> 243                                     _constants-&gt;klass_name_at(_nest_host_index)-&gt;as_C_string());</span>
<span class="line-removed"> 244       }</span>
 245 
<span class="line-modified"> 246       Klass* k = _constants-&gt;klass_at(_nest_host_index, THREAD);</span>
<span class="line-modified"> 247       if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-modified"> 248         Handle exc_h = Handle(THREAD, PENDING_EXCEPTION);</span>
<span class="line-modified"> 249         if (exc_h-&gt;is_a(SystemDictionary::NoClassDefFoundError_klass())) {</span>
<span class="line-modified"> 250           // throw a new CDNFE with the original as its cause, and a clear msg</span>
<span class="line-modified"> 251           ResourceMark rm(THREAD);</span>
<span class="line-modified"> 252           char buf[200];</span>
<span class="line-modified"> 253           CLEAR_PENDING_EXCEPTION;</span>
<span class="line-modified"> 254           jio_snprintf(buf, sizeof(buf),</span>
<span class="line-modified"> 255                        &quot;Unable to load nest-host class (%s) of %s&quot;,</span>
<span class="line-modified"> 256                        _constants-&gt;klass_name_at(_nest_host_index)-&gt;as_C_string(),</span>
<span class="line-modified"> 257                        this-&gt;external_name());</span>
<span class="line-modified"> 258           log_trace(class, nestmates)(&quot;%s - NoClassDefFoundError&quot;, buf);</span>
<span class="line-modified"> 259           THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), buf, exc_h);</span>
<span class="line-modified"> 260         }</span>
<span class="line-modified"> 261         // All other exceptions pass through (OOME, StackOverflowError, LinkageErrors etc).</span>
<span class="line-modified"> 262         return NULL;</span>
 263       }









 264 


 265       // A valid nest-host is an instance class in the current package that lists this
<span class="line-modified"> 266       // class as a nest member. If any of these conditions are not met we post the</span>
<span class="line-modified"> 267       // requested exception type (if any) and return NULL</span>
<span class="line-removed"> 268 </span>
 269       const char* error = NULL;
 270 
 271       // JVMS 5.4.4 indicates package check comes first
 272       if (is_same_class_package(k)) {
<span class="line-removed"> 273 </span>
 274         // Now check actual membership. We can&#39;t be a member if our &quot;host&quot; is
 275         // not an instance class.
 276         if (k-&gt;is_instance_klass()) {
 277           nest_host_k = InstanceKlass::cast(k);





 278 
<span class="line-removed"> 279           bool is_member = nest_host_k-&gt;has_nest_member(this, CHECK_NULL);</span>
<span class="line-removed"> 280           if (is_member) {</span>
<span class="line-removed"> 281             // save resolved nest-host value</span>
<span class="line-removed"> 282             _nest_host = nest_host_k;</span>
<span class="line-removed"> 283 </span>
<span class="line-removed"> 284             if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-removed"> 285               ResourceMark rm(THREAD);</span>
 286               log_trace(class, nestmates)(&quot;Resolved nest-host of %s to %s&quot;,
 287                                           this-&gt;external_name(), k-&gt;external_name());







 288             }
<span class="line-modified"> 289             return nest_host_k;</span>



 290           }


 291         }
<span class="line-removed"> 292         error = &quot;current type is not listed as a nest member&quot;;</span>
 293       } else {
 294         error = &quot;types are in different packages&quot;;
 295       }
 296 
<span class="line-modified"> 297       if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-modified"> 298         ResourceMark rm(THREAD);</span>
<span class="line-modified"> 299         log_trace(class, nestmates)</span>
<span class="line-modified"> 300           (&quot;Type %s (loader: %s) is not a nest member of &quot;</span>
<span class="line-modified"> 301            &quot;resolved type %s (loader: %s): %s&quot;,</span>
<span class="line-modified"> 302            this-&gt;external_name(),</span>
<span class="line-modified"> 303            this-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-modified"> 304            k-&gt;external_name(),</span>
<span class="line-modified"> 305            k-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-modified"> 306            error);</span>
<span class="line-modified"> 307       }</span>
<span class="line-modified"> 308 </span>
<span class="line-modified"> 309       if (validationException != NULL &amp;&amp; THREAD-&gt;can_call_java()) {</span>
<span class="line-removed"> 310         ResourceMark rm(THREAD);</span>
<span class="line-removed"> 311         Exceptions::fthrow(THREAD_AND_LOCATION,</span>
<span class="line-removed"> 312                            validationException,</span>
<span class="line-removed"> 313                            &quot;Type %s (loader: %s) is not a nest member of %s (loader: %s): %s&quot;,</span>
<span class="line-removed"> 314                            this-&gt;external_name(),</span>
<span class="line-removed"> 315                            this-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-removed"> 316                            k-&gt;external_name(),</span>
<span class="line-removed"> 317                            k-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-removed"> 318                            error</span>
<span class="line-removed"> 319                            );</span>
<span class="line-removed"> 320       }</span>
<span class="line-removed"> 321       return NULL;</span>
<span class="line-removed"> 322     } else {</span>
<span class="line-removed"> 323       if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-removed"> 324         ResourceMark rm(THREAD);</span>
<span class="line-removed"> 325         log_trace(class, nestmates)(&quot;Type %s is not part of a nest: setting nest-host to self&quot;,</span>
<span class="line-removed"> 326                                     this-&gt;external_name());</span>
 327       }
<span class="line-modified"> 328       // save resolved nest-host value</span>
<span class="line-modified"> 329       return (_nest_host = this);</span>










































 330     }
 331   }
<span class="line-modified"> 332   return nest_host_k;</span>




 333 }
 334 
 335 // check if &#39;this&#39; and k are nestmates (same nest_host), or k is our nest_host,
 336 // or we are k&#39;s nest_host - all of which is covered by comparing the two
<span class="line-modified"> 337 // resolved_nest_hosts</span>

 338 bool InstanceKlass::has_nestmate_access_to(InstanceKlass* k, TRAPS) {
 339 
 340   assert(this != k, &quot;this should be handled by higher-level code&quot;);
 341 
 342   // Per JVMS 5.4.4 we first resolve and validate the current class, then
<span class="line-modified"> 343   // the target class k. Resolution exceptions will be passed on by upper</span>
<span class="line-removed"> 344   // layers. IncompatibleClassChangeErrors from membership validation failures</span>
<span class="line-removed"> 345   // will also be passed through.</span>
 346 
<span class="line-modified"> 347   Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();</span>
<span class="line-removed"> 348   InstanceKlass* cur_host = nest_host(icce, CHECK_false);</span>
 349   if (cur_host == NULL) {
 350     return false;
 351   }
 352 
<span class="line-modified"> 353   Klass* k_nest_host = k-&gt;nest_host(icce, CHECK_false);</span>
 354   if (k_nest_host == NULL) {
 355     return false;
 356   }
 357 
 358   bool access = (cur_host == k_nest_host);
 359 
<span class="line-modified"> 360   if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-modified"> 361     ResourceMark rm(THREAD);</span>
<span class="line-modified"> 362     log_trace(class, nestmates)(&quot;Class %s does %shave nestmate access to %s&quot;,</span>
<span class="line-modified"> 363                                 this-&gt;external_name(),</span>
<span class="line-modified"> 364                                 access ? &quot;&quot; : &quot;NOT &quot;,</span>
<span class="line-removed"> 365                                 k-&gt;external_name());</span>
<span class="line-removed"> 366   }</span>
<span class="line-removed"> 367 </span>
 368   return access;
 369 }
 370 









 371 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {

 372   const int size = InstanceKlass::size(parser.vtable_size(),
 373                                        parser.itable_size(),
 374                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 375                                        parser.is_interface(),
 376                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 377                                        should_store_fingerprint(parser.is_unsafe_anonymous()),</span>
 378                                        parser.has_flattenable_fields() ? parser.java_fields_count() : 0,
 379                                        parser.is_inline_type());
 380 
 381   const Symbol* const class_name = parser.class_name();
 382   assert(class_name != NULL, &quot;invariant&quot;);
 383   ClassLoaderData* loader_data = parser.loader_data();
 384   assert(loader_data != NULL, &quot;invariant&quot;);
 385 
 386   InstanceKlass* ik;
 387 
 388   // Allocation
 389   if (REF_NONE == parser.reference_type()) {
 390     if (class_name == vmSymbols::java_lang_Class()) {
 391       // mirror
 392       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
 393     } else if (is_class_loader(class_name, parser)) {
 394       // class loader
 395       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
 396     } else if (parser.is_inline_type()) {
 397       // inline type
</pre>
<hr />
<pre>
 467 }
 468 
 469 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 470   Klass(id),
 471   _nest_members(NULL),
 472   _nest_host_index(0),
 473   _nest_host(NULL),
 474   _record_components(NULL),
 475   _static_field_size(parser.static_field_size()),
 476   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 477   _itable_len(parser.itable_size()),
 478   _init_thread(NULL),
 479   _init_state(allocated),
 480   _reference_type(parser.reference_type()),
 481   _value_field_klasses(NULL),
 482   _adr_valueklass_fixed_block(NULL)
 483 {
 484   set_vtable_length(parser.vtable_size());
 485   set_kind(kind);
 486   set_access_flags(parser.access_flags());

 487   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 488   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 489                                                     false));
 490     if (parser.has_flattenable_fields()) {
 491       set_has_inline_fields();
 492     }
 493     _java_fields_count = parser.java_fields_count();
 494 
 495     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
 496     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
 497     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
 498 
 499   if (Arguments::is_dumping_archive()) {
 500       SystemDictionaryShared::init_dumptime_info(this);
 501     }
 502 
 503   // Set biased locking bit for all instances of this class; it will be
 504   // cleared if revocation occurs too often for this type
 505   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 506     set_prototype_header(markWord::biased_locking_prototype());
</pre>
<hr />
<pre>
2395     log_trace(class, fingerprint)(&quot;%s : super %s not fingerprinted&quot;, external_name(), java_super()-&gt;external_name());
2396     return false;
2397   }
2398 
2399   Array&lt;InstanceKlass*&gt;* local_interfaces = this-&gt;local_interfaces();
2400   if (local_interfaces != NULL) {
2401     int length = local_interfaces-&gt;length();
2402     for (int i = 0; i &lt; length; i++) {
2403       InstanceKlass* intf = local_interfaces-&gt;at(i);
2404       if (!intf-&gt;has_passed_fingerprint_check()) {
2405         ResourceMark rm;
2406         log_trace(class, fingerprint)(&quot;%s : interface %s not fingerprinted&quot;, external_name(), intf-&gt;external_name());
2407         return false;
2408       }
2409     }
2410   }
2411 
2412   return true;
2413 }
2414 
<span class="line-modified">2415 bool InstanceKlass::should_store_fingerprint(bool is_unsafe_anonymous) {</span>
2416 #if INCLUDE_AOT
2417   // We store the fingerprint into the InstanceKlass only in the following 2 cases:
2418   if (CalculateClassFingerprint) {
2419     // (1) We are running AOT to generate a shared library.
2420     return true;
2421   }
2422   if (Arguments::is_dumping_archive()) {
2423     // (2) We are running -Xshare:dump or -XX:ArchiveClassesAtExit to create a shared archive
2424     return true;
2425   }
<span class="line-modified">2426   if (UseAOT &amp;&amp; is_unsafe_anonymous) {</span>
<span class="line-modified">2427     // (3) We are using AOT code from a shared library and see an unsafe anonymous class</span>
2428     return true;
2429   }
2430 #endif
2431 
2432   // In all other cases we might set the _misc_has_passed_fingerprint_check bit,
2433   // but do not store the 64-bit fingerprint to save space.
2434   return false;
2435 }
2436 
2437 bool InstanceKlass::has_stored_fingerprint() const {
2438 #if INCLUDE_AOT
2439   return should_store_fingerprint() || is_shared();
2440 #else
2441   return false;
2442 #endif
2443 }
2444 
2445 uint64_t InstanceKlass::get_stored_fingerprint() const {
2446   address adr = adr_fingerprint();
2447   if (adr != NULL) {
</pre>
<hr />
<pre>
2704 
2705   assert(_dep_context == NULL,
2706          &quot;dependencies should already be cleaned&quot;);
2707 
2708 #if INCLUDE_JVMTI
2709   // Deallocate breakpoint records
2710   if (breakpoints() != 0x0) {
2711     methods_do(clear_all_breakpoints);
2712     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2713   }
2714 
2715   // deallocate the cached class file
2716   if (_cached_class_file != NULL) {
2717     os::free(_cached_class_file);
2718     _cached_class_file = NULL;
2719   }
2720 #endif
2721 
2722   // Decrement symbol reference counts associated with the unloaded class.
2723   if (_name != NULL) _name-&gt;decrement_refcount();

2724   // unreference array name derived from this class name (arrays of an unloaded
2725   // class can&#39;t be referenced anymore).
2726   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
2727   if (_inline_types != NULL) {
2728     for (int i = 0; i &lt; _inline_types-&gt;length(); i++) {
2729       Symbol* s = _inline_types-&gt;at(i)._class_name;
2730       if (s != NULL) {
2731         s-&gt;decrement_refcount();
2732       }
2733     }
2734   }
2735   FREE_C_HEAP_ARRAY(char, _source_debug_extension);
2736 }
2737 
2738 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2739   if (array == NULL) {
2740     _source_debug_extension = NULL;
2741   } else {
2742     // Adding one to the attribute length in order to store a null terminator
2743     // character could cause an overflow because the attribute length is
</pre>
<hr />
<pre>
2762     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2763     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2764     hash_len = (int)strlen(hash_buf);
2765   }
2766 
2767   // Get the internal name as a c string
2768   const char* src = (const char*) (name()-&gt;as_C_string());
2769   const int src_length = (int)strlen(src);
2770 
2771   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2772 
2773   // Add L or Q as type indicator
2774   int dest_index = 0;
2775   dest[dest_index++] = is_value() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;
2776 
2777   // Add the actual class name
2778   for (int src_index = 0; src_index &lt; src_length; ) {
2779     dest[dest_index++] = src[src_index++];
2780   }
2781 









2782   // If we have a hash, append it
2783   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2784     dest[dest_index++] = hash_buf[hash_index++];
2785   }
2786 
2787   // Add the semicolon and the NULL
2788   dest[dest_index++] = JVM_SIGNATURE_ENDCLASS;
2789   dest[dest_index] = &#39;\0&#39;;
2790   return dest;
2791 }
2792 
2793 ModuleEntry* InstanceKlass::module() const {
2794   // For an unsafe anonymous class return the host class&#39; module
2795   if (is_unsafe_anonymous()) {
2796     assert(unsafe_anonymous_host() != NULL, &quot;unsafe anonymous class must have a host class&quot;);
2797     return unsafe_anonymous_host()-&gt;module();
2798   }
2799 



















2800   // Class is in a named package
2801   if (!in_unnamed_package()) {
2802     return _package_entry-&gt;module();
2803   }
2804 
2805   // Class is in an unnamed package, return its loader&#39;s unnamed module
2806   return class_loader_data()-&gt;unnamed_module();
2807 }
2808 
2809 void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {
2810 
2811   // ensure java/ packages only loaded by boot or platform builtin loaders
<span class="line-modified">2812   check_prohibited_package(name(), loader_data, CHECK);</span>



2813 
2814   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() : ClassLoader::package_from_class_name(name());
2815 
2816   if (pkg_name != NULL &amp;&amp; loader_data != NULL) {
2817 
2818     // Find in class loader&#39;s package entry table.
2819     _package_entry = pkg_entry != NULL ? pkg_entry : loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
2820 
2821     // If the package name is not found in the loader&#39;s package
2822     // entry table, it is an indication that the package has not
2823     // been defined. Consider it defined within the unnamed module.
2824     if (_package_entry == NULL) {
2825 
2826       if (!ModuleEntryTable::javabase_defined()) {
2827         // Before java.base is defined during bootstrapping, define all packages in
2828         // the java.base module.  If a non-java.base package is erroneously placed
2829         // in the java.base module it will be caught later when java.base
2830         // is defined by ModuleEntryTable::verify_javabase_packages check.
2831         assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME &quot; module is NULL&quot;);
2832         _package_entry = loader_data-&gt;packages()-&gt;lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());
</pre>
<hr />
<pre>
2843     }
2844 
2845     if (log_is_enabled(Debug, module)) {
2846       ResourceMark rm(THREAD);
2847       ModuleEntry* m = _package_entry-&gt;module();
2848       log_trace(module)(&quot;Setting package: class: %s, package: %s, loader: %s, module: %s&quot;,
2849                         external_name(),
2850                         pkg_name-&gt;as_C_string(),
2851                         loader_data-&gt;loader_name_and_id(),
2852                         (m-&gt;is_named() ? m-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE));
2853     }
2854   } else {
2855     ResourceMark rm(THREAD);
2856     log_trace(module)(&quot;Setting package: class: %s, package: unnamed, loader: %s, module: %s&quot;,
2857                       external_name(),
2858                       (loader_data != NULL) ? loader_data-&gt;loader_name_and_id() : &quot;NULL&quot;,
2859                       UNNAMED_MODULE);
2860   }
2861 }
2862 

















2863 
2864 // different versions of is_same_class_package
2865 
2866 bool InstanceKlass::is_same_class_package(const Klass* class2) const {
2867   oop classloader1 = this-&gt;class_loader();
2868   PackageEntry* classpkg1 = this-&gt;package();
2869   if (class2-&gt;is_objArray_klass()) {
2870     class2 = ObjArrayKlass::cast(class2)-&gt;bottom_klass();
2871   }
2872 
2873   oop classloader2;
2874   PackageEntry* classpkg2;
2875   if (class2-&gt;is_instance_klass()) {
2876     classloader2 = class2-&gt;class_loader();
2877     classpkg2 = class2-&gt;package();
2878   } else {
2879     assert(class2-&gt;is_typeArray_klass(), &quot;should be type array&quot;);
2880     classloader2 = NULL;
2881     classpkg2 = NULL;
2882   }
</pre>
<hr />
<pre>
2990         }
2991       }
2992     }
2993   }
2994   return false;
2995 }
2996 
2997 InstanceKlass* InstanceKlass::compute_enclosing_class(bool* inner_is_member, TRAPS) const {
2998   InstanceKlass* outer_klass = NULL;
2999   *inner_is_member = false;
3000   int ooff = 0, noff = 0;
3001   bool has_inner_classes_attr = find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD);
3002   if (has_inner_classes_attr) {
3003     constantPoolHandle i_cp(THREAD, constants());
3004     if (ooff != 0) {
3005       Klass* ok = i_cp-&gt;klass_at(ooff, CHECK_NULL);
3006       outer_klass = InstanceKlass::cast(ok);
3007       *inner_is_member = true;
3008     }
3009     if (NULL == outer_klass) {
<span class="line-modified">3010       // It may be unsafe anonymous; try for that.</span>
3011       int encl_method_class_idx = enclosing_method_class_index();
3012       if (encl_method_class_idx != 0) {
3013         Klass* ok = i_cp-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3014         outer_klass = InstanceKlass::cast(ok);
3015         *inner_is_member = false;
3016       }
3017     }
3018   }
3019 
3020   // If no inner class attribute found for this class.
3021   if (NULL == outer_klass) return NULL;
3022 
3023   // Throws an exception if outer klass has not declared k as an inner klass
3024   // We need evidence that each klass knows about the other, or else
3025   // the system could allow a spoof of an inner class to gain access rights.
3026   Reflection::check_for_inner_class(outer_klass, this, *inner_is_member, CHECK_NULL);
3027   return outer_klass;
3028 }
3029 
3030 jint InstanceKlass::compute_modifier_flags(TRAPS) const {
</pre>
</td>
<td>
<hr />
<pre>
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;aot/aotLoader.hpp&quot;
  28 #include &quot;classfile/classFileParser.hpp&quot;
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/javaClasses.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
<span class="line-added">  34 #include &quot;classfile/resolutionErrors.hpp&quot;</span>
  35 #include &quot;classfile/symbolTable.hpp&quot;
  36 #include &quot;classfile/systemDictionary.hpp&quot;
  37 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  38 #include &quot;classfile/verifier.hpp&quot;
  39 #include &quot;classfile/vmSymbols.hpp&quot;
  40 #include &quot;code/dependencyContext.hpp&quot;
  41 #include &quot;compiler/compileBroker.hpp&quot;
  42 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  43 #include &quot;interpreter/oopMapCache.hpp&quot;
  44 #include &quot;interpreter/rewriter.hpp&quot;
  45 #include &quot;jvmtifiles/jvmti.h&quot;
  46 #include &quot;logging/log.hpp&quot;
  47 #include &quot;logging/logMessage.hpp&quot;
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.inline.hpp&quot;
  51 #include &quot;memory/metadataFactory.hpp&quot;
  52 #include &quot;memory/metaspaceClosure.hpp&quot;
  53 #include &quot;memory/metaspaceShared.hpp&quot;
  54 #include &quot;memory/oopFactory.hpp&quot;
</pre>
<hr />
<pre>
 119 #define DTRACE_CLASSINIT_PROBE_WAIT(type, thread_type, wait)     \
 120   {                                                              \
 121     char* data = NULL;                                           \
 122     int len = 0;                                                 \
 123     Symbol* clss_name = name();                                  \
 124     if (clss_name != NULL) {                                     \
 125       data = (char*)clss_name-&gt;bytes();                          \
 126       len = clss_name-&gt;utf8_length();                            \
 127     }                                                            \
 128     HOTSPOT_CLASS_INITIALIZATION_##type(                         \
 129       data, len, (void*)class_loader(), thread_type, wait);      \
 130   }
 131 
 132 #else //  ndef DTRACE_ENABLED
 133 
 134 #define DTRACE_CLASSINIT_PROBE(type, thread_type)
 135 #define DTRACE_CLASSINIT_PROBE_WAIT(type, thread_type, wait)
 136 
 137 #endif //  ndef DTRACE_ENABLED
 138 
<span class="line-added"> 139 </span>
 140 static inline bool is_class_loader(const Symbol* class_name,
 141                                    const ClassFileParser&amp; parser) {
 142   assert(class_name != NULL, &quot;invariant&quot;);
 143 
 144   if (class_name == vmSymbols::java_lang_ClassLoader()) {
 145     return true;
 146   }
 147 
 148   if (SystemDictionary::ClassLoader_klass_loaded()) {
 149     const Klass* const super_klass = parser.super_klass();
 150     if (super_klass != NULL) {
 151       if (super_klass-&gt;is_subtype_of(SystemDictionary::ClassLoader_klass())) {
 152         return true;
 153       }
 154     }
 155   }
 156   return false;
 157 }
 158 
<span class="line-modified"> 159 // private: called to verify that k is a static member of this nest.</span>
<span class="line-added"> 160 // We know that k is an instance class in the same package and hence the</span>
<span class="line-added"> 161 // same classloader.</span>
 162 bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {
<span class="line-added"> 163   assert(!is_hidden(), &quot;unexpected hidden class&quot;);</span>
 164   if (_nest_members == NULL || _nest_members == Universe::the_empty_short_array()) {
 165     if (log_is_enabled(Trace, class, nestmates)) {
 166       ResourceMark rm(THREAD);
 167       log_trace(class, nestmates)(&quot;Checked nest membership of %s in non-nest-host class %s&quot;,
 168                                   k-&gt;external_name(), this-&gt;external_name());
 169     }
 170     return false;
 171   }
 172 
 173   if (log_is_enabled(Trace, class, nestmates)) {
 174     ResourceMark rm(THREAD);
 175     log_trace(class, nestmates)(&quot;Checking nest membership of %s in %s&quot;,
 176                                 k-&gt;external_name(), this-&gt;external_name());
 177   }
 178 
 179   // Check for a resolved cp entry , else fall back to a name check.
 180   // We don&#39;t want to resolve any class other than the one being checked.
 181   for (int i = 0; i &lt; _nest_members-&gt;length(); i++) {
 182     int cp_index = _nest_members-&gt;at(i);
 183     if (_constants-&gt;tag_at(cp_index).is_klass()) {
<span class="line-modified"> 184       Klass* k2 = _constants-&gt;klass_at(cp_index, THREAD);</span>
<span class="line-added"> 185       assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass()),</span>
<span class="line-added"> 186              &quot;Exceptions should not be possible here&quot;);</span>
 187       if (k2 == k) {
 188         log_trace(class, nestmates)(&quot;- class is listed at nest_members[%d] =&gt; cp[%d]&quot;, i, cp_index);
 189         return true;
 190       }
 191     }
 192     else {
 193       Symbol* name = _constants-&gt;klass_name_at(cp_index);
 194       if (name == k-&gt;name()) {
 195         log_trace(class, nestmates)(&quot;- Found it at nest_members[%d] =&gt; cp[%d]&quot;, i, cp_index);
 196 
<span class="line-modified"> 197         // Names match so check actual klass. This may trigger class loading if</span>
<span class="line-modified"> 198         // it doesn&#39;t match though that should be impossible as it means one classloader</span>
<span class="line-modified"> 199         // has defined two different classes with the same name! A compiler thread won&#39;t be</span>
<span class="line-modified"> 200         // able to perform that loading but we can&#39;t exclude the compiler threads from</span>
<span class="line-modified"> 201         // executing this logic. But it should actually be impossible to trigger loading here.</span>
<span class="line-modified"> 202         Klass* k2 = _constants-&gt;klass_at(cp_index, THREAD);</span>
<span class="line-modified"> 203         assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass()),</span>
<span class="line-modified"> 204                &quot;Exceptions should not be possible here&quot;);</span>

 205         if (k2 == k) {
 206           log_trace(class, nestmates)(&quot;- class is listed as a nest member&quot;);
 207           return true;
 208         }
 209         else {
 210           // same name but different klass!
 211           log_trace(class, nestmates)(&quot; - klass comparison failed!&quot;);
 212           // can&#39;t have two names the same, so we&#39;re done
 213           return false;
 214         }
 215       }
 216     }
 217   }
 218   log_trace(class, nestmates)(&quot;- class is NOT a nest member!&quot;);
 219   return false;
 220 }
 221 
 222 // Return nest-host class, resolving, validating and saving it if needed.
<span class="line-modified"> 223 // In cases where this is called from a thread that cannot do classloading</span>
 224 // (such as a native JIT thread) then we simply return NULL, which in turn
 225 // causes the access check to return false. Such code will retry the access
<span class="line-modified"> 226 // from a more suitable environment later. Otherwise the _nest_host is always</span>
<span class="line-modified"> 227 // set once this method returns.</span>
<span class="line-added"> 228 // Any errors from nest-host resolution must be preserved so they can be queried</span>
<span class="line-added"> 229 // from higher-level access checking code, and reported as part of access checking</span>
<span class="line-added"> 230 // exceptions.</span>
<span class="line-added"> 231 // VirtualMachineErrors are propagated with a NULL return.</span>
<span class="line-added"> 232 // Under any conditions where the _nest_host can be set to non-NULL the resulting</span>
<span class="line-added"> 233 // value of it and, if applicable, the nest host resolution/validation error,</span>
<span class="line-added"> 234 // are idempotent.</span>
<span class="line-added"> 235 InstanceKlass* InstanceKlass::nest_host(TRAPS) {</span>
 236   InstanceKlass* nest_host_k = _nest_host;
<span class="line-modified"> 237   if (nest_host_k != NULL) {</span>
<span class="line-modified"> 238     return nest_host_k;</span>
<span class="line-modified"> 239   }</span>












 240 
<span class="line-modified"> 241   ResourceMark rm(THREAD);</span>





 242 
<span class="line-modified"> 243   // need to resolve and save our nest-host class.</span>
<span class="line-modified"> 244   if (_nest_host_index != 0) { // we have a real nest_host</span>
<span class="line-modified"> 245     // Before trying to resolve check if we&#39;re in a suitable context</span>
<span class="line-modified"> 246     if (!THREAD-&gt;can_call_java() &amp;&amp; !_constants-&gt;tag_at(_nest_host_index).is_klass()) {</span>
<span class="line-modified"> 247       log_trace(class, nestmates)(&quot;Rejected resolution of nest-host of %s in unsuitable thread&quot;,</span>
<span class="line-modified"> 248                                   this-&gt;external_name());</span>
<span class="line-modified"> 249       return NULL; // sentinel to say &quot;try again from a different context&quot;</span>
<span class="line-modified"> 250     }</span>
<span class="line-modified"> 251 </span>
<span class="line-modified"> 252     log_trace(class, nestmates)(&quot;Resolving nest-host of %s using cp entry for %s&quot;,</span>
<span class="line-modified"> 253                                 this-&gt;external_name(),</span>
<span class="line-modified"> 254                                 _constants-&gt;klass_name_at(_nest_host_index)-&gt;as_C_string());</span>
<span class="line-modified"> 255 </span>
<span class="line-modified"> 256     Klass* k = _constants-&gt;klass_at(_nest_host_index, THREAD);</span>
<span class="line-modified"> 257     if (HAS_PENDING_EXCEPTION) {</span>
<span class="line-modified"> 258       if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass())) {</span>
<span class="line-modified"> 259         return NULL; // propagate VMEs</span>
 260       }
<span class="line-added"> 261       stringStream ss;</span>
<span class="line-added"> 262       char* target_host_class = _constants-&gt;klass_name_at(_nest_host_index)-&gt;as_C_string();</span>
<span class="line-added"> 263       ss.print(&quot;Nest host resolution of %s with host %s failed: &quot;,</span>
<span class="line-added"> 264                this-&gt;external_name(), target_host_class);</span>
<span class="line-added"> 265       java_lang_Throwable::print(PENDING_EXCEPTION, &amp;ss);</span>
<span class="line-added"> 266       const char* msg = ss.as_string(true /* on C-heap */);</span>
<span class="line-added"> 267       constantPoolHandle cph(THREAD, constants());</span>
<span class="line-added"> 268       SystemDictionary::add_nest_host_error(cph, _nest_host_index, msg);</span>
<span class="line-added"> 269       CLEAR_PENDING_EXCEPTION;</span>
 270 
<span class="line-added"> 271       log_trace(class, nestmates)(&quot;%s&quot;, msg);</span>
<span class="line-added"> 272     } else {</span>
 273       // A valid nest-host is an instance class in the current package that lists this
<span class="line-modified"> 274       // class as a nest member. If any of these conditions are not met the class is</span>
<span class="line-modified"> 275       // its own nest-host.</span>

 276       const char* error = NULL;
 277 
 278       // JVMS 5.4.4 indicates package check comes first
 279       if (is_same_class_package(k)) {

 280         // Now check actual membership. We can&#39;t be a member if our &quot;host&quot; is
 281         // not an instance class.
 282         if (k-&gt;is_instance_klass()) {
 283           nest_host_k = InstanceKlass::cast(k);
<span class="line-added"> 284           bool is_member = nest_host_k-&gt;has_nest_member(this, THREAD);</span>
<span class="line-added"> 285           // exception is rare, perhaps impossible</span>
<span class="line-added"> 286           if (!HAS_PENDING_EXCEPTION) {</span>
<span class="line-added"> 287             if (is_member) {</span>
<span class="line-added"> 288               _nest_host = nest_host_k; // save resolved nest-host value</span>
 289 







 290               log_trace(class, nestmates)(&quot;Resolved nest-host of %s to %s&quot;,
 291                                           this-&gt;external_name(), k-&gt;external_name());
<span class="line-added"> 292               return nest_host_k;</span>
<span class="line-added"> 293             } else {</span>
<span class="line-added"> 294               error = &quot;current type is not listed as a nest member&quot;;</span>
<span class="line-added"> 295             }</span>
<span class="line-added"> 296           } else {</span>
<span class="line-added"> 297             if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass())) {</span>
<span class="line-added"> 298               return NULL; // propagate VMEs</span>
 299             }
<span class="line-modified"> 300             stringStream ss;</span>
<span class="line-added"> 301             ss.print(&quot;exception on member check: &quot;);</span>
<span class="line-added"> 302             java_lang_Throwable::print(PENDING_EXCEPTION, &amp;ss);</span>
<span class="line-added"> 303             error = ss.as_string();</span>
 304           }
<span class="line-added"> 305         } else {</span>
<span class="line-added"> 306           error = &quot;host is not an instance class&quot;;</span>
 307         }

 308       } else {
 309         error = &quot;types are in different packages&quot;;
 310       }
 311 
<span class="line-modified"> 312       // something went wrong, so record what and log it</span>
<span class="line-modified"> 313       {</span>
<span class="line-modified"> 314         stringStream ss;</span>
<span class="line-modified"> 315         ss.print(&quot;Type %s (loader: %s) is not a nest member of type %s (loader: %s): %s&quot;,</span>
<span class="line-modified"> 316                  this-&gt;external_name(),</span>
<span class="line-modified"> 317                  this-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-modified"> 318                  k-&gt;external_name(),</span>
<span class="line-modified"> 319                  k-&gt;class_loader_data()-&gt;loader_name_and_id(),</span>
<span class="line-modified"> 320                  error);</span>
<span class="line-modified"> 321         const char* msg = ss.as_string(true /* on C-heap */);</span>
<span class="line-modified"> 322         constantPoolHandle cph(THREAD, constants());</span>
<span class="line-modified"> 323         SystemDictionary::add_nest_host_error(cph, _nest_host_index, msg);</span>
<span class="line-modified"> 324         log_trace(class, nestmates)(&quot;%s&quot;, msg);</span>

















 325       }
<span class="line-modified"> 326     }</span>
<span class="line-modified"> 327   } else {</span>
<span class="line-added"> 328     log_trace(class, nestmates)(&quot;Type %s is not part of a nest: setting nest-host to self&quot;,</span>
<span class="line-added"> 329                                 this-&gt;external_name());</span>
<span class="line-added"> 330   }</span>
<span class="line-added"> 331 </span>
<span class="line-added"> 332   // Either not in an explicit nest, or else an error occurred, so</span>
<span class="line-added"> 333   // the nest-host is set to `this`. Any thread that sees this assignment</span>
<span class="line-added"> 334   // will also see any setting of nest_host_error(), if applicable.</span>
<span class="line-added"> 335   return (_nest_host = this);</span>
<span class="line-added"> 336 }</span>
<span class="line-added"> 337 </span>
<span class="line-added"> 338 // Dynamic nest member support: set this class&#39;s nest host to the given class.</span>
<span class="line-added"> 339 // This occurs as part of the class definition, as soon as the instanceKlass</span>
<span class="line-added"> 340 // has been created and doesn&#39;t require further resolution. The code:</span>
<span class="line-added"> 341 //    lookup().defineHiddenClass(bytes_for_X, NESTMATE);</span>
<span class="line-added"> 342 // results in:</span>
<span class="line-added"> 343 //    class_of_X.set_nest_host(lookup().lookupClass().getNestHost())</span>
<span class="line-added"> 344 // If it has an explicit _nest_host_index or _nest_members, these will be ignored.</span>
<span class="line-added"> 345 // We also know the &quot;host&quot; is a valid nest-host in the same package so we can</span>
<span class="line-added"> 346 // assert some of those facts.</span>
<span class="line-added"> 347 void InstanceKlass::set_nest_host(InstanceKlass* host, TRAPS) {</span>
<span class="line-added"> 348   assert(is_hidden(), &quot;must be a hidden class&quot;);</span>
<span class="line-added"> 349   assert(host != NULL, &quot;NULL nest host specified&quot;);</span>
<span class="line-added"> 350   assert(_nest_host == NULL, &quot;current class has resolved nest-host&quot;);</span>
<span class="line-added"> 351   assert(nest_host_error(THREAD) == NULL, &quot;unexpected nest host resolution error exists: %s&quot;,</span>
<span class="line-added"> 352          nest_host_error(THREAD));</span>
<span class="line-added"> 353   assert((host-&gt;_nest_host == NULL &amp;&amp; host-&gt;_nest_host_index == 0) ||</span>
<span class="line-added"> 354          (host-&gt;_nest_host == host), &quot;proposed host is not a valid nest-host&quot;);</span>
<span class="line-added"> 355   // Can&#39;t assert this as package is not set yet:</span>
<span class="line-added"> 356   // assert(is_same_class_package(host), &quot;proposed host is in wrong package&quot;);</span>
<span class="line-added"> 357 </span>
<span class="line-added"> 358   if (log_is_enabled(Trace, class, nestmates)) {</span>
<span class="line-added"> 359     ResourceMark rm(THREAD);</span>
<span class="line-added"> 360     const char* msg = &quot;&quot;;</span>
<span class="line-added"> 361     // a hidden class does not expect a statically defined nest-host</span>
<span class="line-added"> 362     if (_nest_host_index &gt; 0) {</span>
<span class="line-added"> 363       msg = &quot;(the NestHost attribute in the current class is ignored)&quot;;</span>
<span class="line-added"> 364     } else if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {</span>
<span class="line-added"> 365       msg = &quot;(the NestMembers attribute in the current class is ignored)&quot;;</span>
<span class="line-added"> 366     }</span>
<span class="line-added"> 367     log_trace(class, nestmates)(&quot;Injected type %s into the nest of %s %s&quot;,</span>
<span class="line-added"> 368                                 this-&gt;external_name(),</span>
<span class="line-added"> 369                                 host-&gt;external_name(),</span>
 370                                 msg);
 371   }
<span class="line-modified"> 372   // set dynamic nest host</span>
<span class="line-added"> 373   _nest_host = host;</span>
<span class="line-added"> 374   // Record dependency to keep nest host from being unloaded before this class.</span>
<span class="line-added"> 375   ClassLoaderData* this_key = class_loader_data();</span>
<span class="line-added"> 376   this_key-&gt;record_dependency(host);</span>
 377 }
 378 
 379 // check if &#39;this&#39; and k are nestmates (same nest_host), or k is our nest_host,
 380 // or we are k&#39;s nest_host - all of which is covered by comparing the two
<span class="line-modified"> 381 // resolved_nest_hosts.</span>
<span class="line-added"> 382 // Any exceptions (i.e. VMEs) are propagated.</span>
 383 bool InstanceKlass::has_nestmate_access_to(InstanceKlass* k, TRAPS) {
 384 
 385   assert(this != k, &quot;this should be handled by higher-level code&quot;);
 386 
 387   // Per JVMS 5.4.4 we first resolve and validate the current class, then
<span class="line-modified"> 388   // the target class k.</span>


 389 
<span class="line-modified"> 390   InstanceKlass* cur_host = nest_host(CHECK_false);</span>

 391   if (cur_host == NULL) {
 392     return false;
 393   }
 394 
<span class="line-modified"> 395   Klass* k_nest_host = k-&gt;nest_host(CHECK_false);</span>
 396   if (k_nest_host == NULL) {
 397     return false;
 398   }
 399 
 400   bool access = (cur_host == k_nest_host);
 401 
<span class="line-modified"> 402   ResourceMark rm(THREAD);</span>
<span class="line-modified"> 403   log_trace(class, nestmates)(&quot;Class %s does %shave nestmate access to %s&quot;,</span>
<span class="line-modified"> 404                               this-&gt;external_name(),</span>
<span class="line-modified"> 405                               access ? &quot;&quot; : &quot;NOT &quot;,</span>
<span class="line-modified"> 406                               k-&gt;external_name());</span>



 407   return access;
 408 }
 409 
<span class="line-added"> 410 const char* InstanceKlass::nest_host_error(TRAPS) {</span>
<span class="line-added"> 411   if (_nest_host_index == 0) {</span>
<span class="line-added"> 412     return NULL;</span>
<span class="line-added"> 413   } else {</span>
<span class="line-added"> 414     constantPoolHandle cph(THREAD, constants());</span>
<span class="line-added"> 415     return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);</span>
<span class="line-added"> 416   }</span>
<span class="line-added"> 417 }</span>
<span class="line-added"> 418 </span>
 419 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
<span class="line-added"> 420   bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();</span>
 421   const int size = InstanceKlass::size(parser.vtable_size(),
 422                                        parser.itable_size(),
 423                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 424                                        parser.is_interface(),
 425                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 426                                        should_store_fingerprint(is_hidden_or_anonymous),</span>
 427                                        parser.has_flattenable_fields() ? parser.java_fields_count() : 0,
 428                                        parser.is_inline_type());
 429 
 430   const Symbol* const class_name = parser.class_name();
 431   assert(class_name != NULL, &quot;invariant&quot;);
 432   ClassLoaderData* loader_data = parser.loader_data();
 433   assert(loader_data != NULL, &quot;invariant&quot;);
 434 
 435   InstanceKlass* ik;
 436 
 437   // Allocation
 438   if (REF_NONE == parser.reference_type()) {
 439     if (class_name == vmSymbols::java_lang_Class()) {
 440       // mirror
 441       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
 442     } else if (is_class_loader(class_name, parser)) {
 443       // class loader
 444       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
 445     } else if (parser.is_inline_type()) {
 446       // inline type
</pre>
<hr />
<pre>
 516 }
 517 
 518 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 519   Klass(id),
 520   _nest_members(NULL),
 521   _nest_host_index(0),
 522   _nest_host(NULL),
 523   _record_components(NULL),
 524   _static_field_size(parser.static_field_size()),
 525   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 526   _itable_len(parser.itable_size()),
 527   _init_thread(NULL),
 528   _init_state(allocated),
 529   _reference_type(parser.reference_type()),
 530   _value_field_klasses(NULL),
 531   _adr_valueklass_fixed_block(NULL)
 532 {
 533   set_vtable_length(parser.vtable_size());
 534   set_kind(kind);
 535   set_access_flags(parser.access_flags());
<span class="line-added"> 536   if (parser.is_hidden()) set_is_hidden();</span>
 537   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 538   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 539                                                     false));
 540     if (parser.has_flattenable_fields()) {
 541       set_has_inline_fields();
 542     }
 543     _java_fields_count = parser.java_fields_count();
 544 
 545     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);
 546     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);
 547     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);
 548 
 549   if (Arguments::is_dumping_archive()) {
 550       SystemDictionaryShared::init_dumptime_info(this);
 551     }
 552 
 553   // Set biased locking bit for all instances of this class; it will be
 554   // cleared if revocation occurs too often for this type
 555   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 556     set_prototype_header(markWord::biased_locking_prototype());
</pre>
<hr />
<pre>
2445     log_trace(class, fingerprint)(&quot;%s : super %s not fingerprinted&quot;, external_name(), java_super()-&gt;external_name());
2446     return false;
2447   }
2448 
2449   Array&lt;InstanceKlass*&gt;* local_interfaces = this-&gt;local_interfaces();
2450   if (local_interfaces != NULL) {
2451     int length = local_interfaces-&gt;length();
2452     for (int i = 0; i &lt; length; i++) {
2453       InstanceKlass* intf = local_interfaces-&gt;at(i);
2454       if (!intf-&gt;has_passed_fingerprint_check()) {
2455         ResourceMark rm;
2456         log_trace(class, fingerprint)(&quot;%s : interface %s not fingerprinted&quot;, external_name(), intf-&gt;external_name());
2457         return false;
2458       }
2459     }
2460   }
2461 
2462   return true;
2463 }
2464 
<span class="line-modified">2465 bool InstanceKlass::should_store_fingerprint(bool is_hidden_or_anonymous) {</span>
2466 #if INCLUDE_AOT
2467   // We store the fingerprint into the InstanceKlass only in the following 2 cases:
2468   if (CalculateClassFingerprint) {
2469     // (1) We are running AOT to generate a shared library.
2470     return true;
2471   }
2472   if (Arguments::is_dumping_archive()) {
2473     // (2) We are running -Xshare:dump or -XX:ArchiveClassesAtExit to create a shared archive
2474     return true;
2475   }
<span class="line-modified">2476   if (UseAOT &amp;&amp; is_hidden_or_anonymous) {</span>
<span class="line-modified">2477     // (3) We are using AOT code from a shared library and see a hidden or unsafe anonymous class</span>
2478     return true;
2479   }
2480 #endif
2481 
2482   // In all other cases we might set the _misc_has_passed_fingerprint_check bit,
2483   // but do not store the 64-bit fingerprint to save space.
2484   return false;
2485 }
2486 
2487 bool InstanceKlass::has_stored_fingerprint() const {
2488 #if INCLUDE_AOT
2489   return should_store_fingerprint() || is_shared();
2490 #else
2491   return false;
2492 #endif
2493 }
2494 
2495 uint64_t InstanceKlass::get_stored_fingerprint() const {
2496   address adr = adr_fingerprint();
2497   if (adr != NULL) {
</pre>
<hr />
<pre>
2754 
2755   assert(_dep_context == NULL,
2756          &quot;dependencies should already be cleaned&quot;);
2757 
2758 #if INCLUDE_JVMTI
2759   // Deallocate breakpoint records
2760   if (breakpoints() != 0x0) {
2761     methods_do(clear_all_breakpoints);
2762     assert(breakpoints() == 0x0, &quot;should have cleared breakpoints&quot;);
2763   }
2764 
2765   // deallocate the cached class file
2766   if (_cached_class_file != NULL) {
2767     os::free(_cached_class_file);
2768     _cached_class_file = NULL;
2769   }
2770 #endif
2771 
2772   // Decrement symbol reference counts associated with the unloaded class.
2773   if (_name != NULL) _name-&gt;decrement_refcount();
<span class="line-added">2774 </span>
2775   // unreference array name derived from this class name (arrays of an unloaded
2776   // class can&#39;t be referenced anymore).
2777   if (_array_name != NULL)  _array_name-&gt;decrement_refcount();
2778   if (_inline_types != NULL) {
2779     for (int i = 0; i &lt; _inline_types-&gt;length(); i++) {
2780       Symbol* s = _inline_types-&gt;at(i)._class_name;
2781       if (s != NULL) {
2782         s-&gt;decrement_refcount();
2783       }
2784     }
2785   }
2786   FREE_C_HEAP_ARRAY(char, _source_debug_extension);
2787 }
2788 
2789 void InstanceKlass::set_source_debug_extension(const char* array, int length) {
2790   if (array == NULL) {
2791     _source_debug_extension = NULL;
2792   } else {
2793     // Adding one to the attribute length in order to store a null terminator
2794     // character could cause an overflow because the attribute length is
</pre>
<hr />
<pre>
2813     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2814     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2815     hash_len = (int)strlen(hash_buf);
2816   }
2817 
2818   // Get the internal name as a c string
2819   const char* src = (const char*) (name()-&gt;as_C_string());
2820   const int src_length = (int)strlen(src);
2821 
2822   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2823 
2824   // Add L or Q as type indicator
2825   int dest_index = 0;
2826   dest[dest_index++] = is_value() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;
2827 
2828   // Add the actual class name
2829   for (int src_index = 0; src_index &lt; src_length; ) {
2830     dest[dest_index++] = src[src_index++];
2831   }
2832 
<span class="line-added">2833   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.</span>
<span class="line-added">2834     for (int index = (int)src_length; index &gt; 0; index--) {</span>
<span class="line-added">2835       if (dest[index] == &#39;+&#39;) {</span>
<span class="line-added">2836         dest[index] = JVM_SIGNATURE_DOT;</span>
<span class="line-added">2837         break;</span>
<span class="line-added">2838       }</span>
<span class="line-added">2839     }</span>
<span class="line-added">2840   }</span>
<span class="line-added">2841 </span>
2842   // If we have a hash, append it
2843   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2844     dest[dest_index++] = hash_buf[hash_index++];
2845   }
2846 
2847   // Add the semicolon and the NULL
2848   dest[dest_index++] = JVM_SIGNATURE_ENDCLASS;
2849   dest[dest_index] = &#39;\0&#39;;
2850   return dest;
2851 }
2852 
2853 ModuleEntry* InstanceKlass::module() const {
2854   // For an unsafe anonymous class return the host class&#39; module
2855   if (is_unsafe_anonymous()) {
2856     assert(unsafe_anonymous_host() != NULL, &quot;unsafe anonymous class must have a host class&quot;);
2857     return unsafe_anonymous_host()-&gt;module();
2858   }
2859 
<span class="line-added">2860   if (is_hidden() &amp;&amp;</span>
<span class="line-added">2861       in_unnamed_package() &amp;&amp;</span>
<span class="line-added">2862       class_loader_data()-&gt;has_class_mirror_holder()) {</span>
<span class="line-added">2863     // For a non-strong hidden class defined to an unnamed package,</span>
<span class="line-added">2864     // its (class held) CLD will not have an unnamed module created for it.</span>
<span class="line-added">2865     // Two choices to find the correct ModuleEntry:</span>
<span class="line-added">2866     // 1. If hidden class is within a nest, use nest host&#39;s module</span>
<span class="line-added">2867     // 2. Find the unnamed module off from the class loader</span>
<span class="line-added">2868     // For now option #2 is used since a nest host is not set until</span>
<span class="line-added">2869     // after the instance class is created in jvm_lookup_define_class().</span>
<span class="line-added">2870     if (class_loader_data()-&gt;is_boot_class_loader_data()) {</span>
<span class="line-added">2871       return ClassLoaderData::the_null_class_loader_data()-&gt;unnamed_module();</span>
<span class="line-added">2872     } else {</span>
<span class="line-added">2873       oop module = java_lang_ClassLoader::unnamedModule(class_loader_data()-&gt;class_loader());</span>
<span class="line-added">2874       assert(java_lang_Module::is_instance(module), &quot;Not an instance of java.lang.Module&quot;);</span>
<span class="line-added">2875       return java_lang_Module::module_entry(module);</span>
<span class="line-added">2876     }</span>
<span class="line-added">2877   }</span>
<span class="line-added">2878 </span>
2879   // Class is in a named package
2880   if (!in_unnamed_package()) {
2881     return _package_entry-&gt;module();
2882   }
2883 
2884   // Class is in an unnamed package, return its loader&#39;s unnamed module
2885   return class_loader_data()-&gt;unnamed_module();
2886 }
2887 
2888 void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {
2889 
2890   // ensure java/ packages only loaded by boot or platform builtin loaders
<span class="line-modified">2891   // not needed for shared class since CDS does not archive prohibited classes.</span>
<span class="line-added">2892   if (!is_shared()) {</span>
<span class="line-added">2893     check_prohibited_package(name(), loader_data, CHECK);</span>
<span class="line-added">2894   }</span>
2895 
2896   TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry-&gt;name() : ClassLoader::package_from_class_name(name());
2897 
2898   if (pkg_name != NULL &amp;&amp; loader_data != NULL) {
2899 
2900     // Find in class loader&#39;s package entry table.
2901     _package_entry = pkg_entry != NULL ? pkg_entry : loader_data-&gt;packages()-&gt;lookup_only(pkg_name);
2902 
2903     // If the package name is not found in the loader&#39;s package
2904     // entry table, it is an indication that the package has not
2905     // been defined. Consider it defined within the unnamed module.
2906     if (_package_entry == NULL) {
2907 
2908       if (!ModuleEntryTable::javabase_defined()) {
2909         // Before java.base is defined during bootstrapping, define all packages in
2910         // the java.base module.  If a non-java.base package is erroneously placed
2911         // in the java.base module it will be caught later when java.base
2912         // is defined by ModuleEntryTable::verify_javabase_packages check.
2913         assert(ModuleEntryTable::javabase_moduleEntry() != NULL, JAVA_BASE_NAME &quot; module is NULL&quot;);
2914         _package_entry = loader_data-&gt;packages()-&gt;lookup(pkg_name, ModuleEntryTable::javabase_moduleEntry());
</pre>
<hr />
<pre>
2925     }
2926 
2927     if (log_is_enabled(Debug, module)) {
2928       ResourceMark rm(THREAD);
2929       ModuleEntry* m = _package_entry-&gt;module();
2930       log_trace(module)(&quot;Setting package: class: %s, package: %s, loader: %s, module: %s&quot;,
2931                         external_name(),
2932                         pkg_name-&gt;as_C_string(),
2933                         loader_data-&gt;loader_name_and_id(),
2934                         (m-&gt;is_named() ? m-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE));
2935     }
2936   } else {
2937     ResourceMark rm(THREAD);
2938     log_trace(module)(&quot;Setting package: class: %s, package: unnamed, loader: %s, module: %s&quot;,
2939                       external_name(),
2940                       (loader_data != NULL) ? loader_data-&gt;loader_name_and_id() : &quot;NULL&quot;,
2941                       UNNAMED_MODULE);
2942   }
2943 }
2944 
<span class="line-added">2945 // Function set_classpath_index checks if the package of the InstanceKlass is in the</span>
<span class="line-added">2946 // boot loader&#39;s package entry table.  If so, then it sets the classpath_index</span>
<span class="line-added">2947 // in the package entry record.</span>
<span class="line-added">2948 //</span>
<span class="line-added">2949 // The classpath_index field is used to find the entry on the boot loader class</span>
<span class="line-added">2950 // path for packages with classes loaded by the boot loader from -Xbootclasspath/a</span>
<span class="line-added">2951 // in an unnamed module.  It is also used to indicate (for all packages whose</span>
<span class="line-added">2952 // classes are loaded by the boot loader) that at least one of the package&#39;s</span>
<span class="line-added">2953 // classes has been loaded.</span>
<span class="line-added">2954 void InstanceKlass::set_classpath_index(s2 path_index, TRAPS) {</span>
<span class="line-added">2955   if (_package_entry != NULL) {</span>
<span class="line-added">2956     DEBUG_ONLY(PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()-&gt;packages();)</span>
<span class="line-added">2957     assert(pkg_entry_tbl-&gt;lookup_only(_package_entry-&gt;name()) == _package_entry, &quot;Should be same&quot;);</span>
<span class="line-added">2958     assert(path_index != -1, &quot;Unexpected classpath_index&quot;);</span>
<span class="line-added">2959     _package_entry-&gt;set_classpath_index(path_index);</span>
<span class="line-added">2960   }</span>
<span class="line-added">2961 }</span>
2962 
2963 // different versions of is_same_class_package
2964 
2965 bool InstanceKlass::is_same_class_package(const Klass* class2) const {
2966   oop classloader1 = this-&gt;class_loader();
2967   PackageEntry* classpkg1 = this-&gt;package();
2968   if (class2-&gt;is_objArray_klass()) {
2969     class2 = ObjArrayKlass::cast(class2)-&gt;bottom_klass();
2970   }
2971 
2972   oop classloader2;
2973   PackageEntry* classpkg2;
2974   if (class2-&gt;is_instance_klass()) {
2975     classloader2 = class2-&gt;class_loader();
2976     classpkg2 = class2-&gt;package();
2977   } else {
2978     assert(class2-&gt;is_typeArray_klass(), &quot;should be type array&quot;);
2979     classloader2 = NULL;
2980     classpkg2 = NULL;
2981   }
</pre>
<hr />
<pre>
3089         }
3090       }
3091     }
3092   }
3093   return false;
3094 }
3095 
3096 InstanceKlass* InstanceKlass::compute_enclosing_class(bool* inner_is_member, TRAPS) const {
3097   InstanceKlass* outer_klass = NULL;
3098   *inner_is_member = false;
3099   int ooff = 0, noff = 0;
3100   bool has_inner_classes_attr = find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD);
3101   if (has_inner_classes_attr) {
3102     constantPoolHandle i_cp(THREAD, constants());
3103     if (ooff != 0) {
3104       Klass* ok = i_cp-&gt;klass_at(ooff, CHECK_NULL);
3105       outer_klass = InstanceKlass::cast(ok);
3106       *inner_is_member = true;
3107     }
3108     if (NULL == outer_klass) {
<span class="line-modified">3109       // It may be a local or anonymous class; try for that.</span>
3110       int encl_method_class_idx = enclosing_method_class_index();
3111       if (encl_method_class_idx != 0) {
3112         Klass* ok = i_cp-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3113         outer_klass = InstanceKlass::cast(ok);
3114         *inner_is_member = false;
3115       }
3116     }
3117   }
3118 
3119   // If no inner class attribute found for this class.
3120   if (NULL == outer_klass) return NULL;
3121 
3122   // Throws an exception if outer klass has not declared k as an inner klass
3123   // We need evidence that each klass knows about the other, or else
3124   // the system could allow a spoof of an inner class to gain access rights.
3125   Reflection::check_for_inner_class(outer_klass, this, *inner_is_member, CHECK_NULL);
3126   return outer_klass;
3127 }
3128 
3129 jint InstanceKlass::compute_modifier_flags(TRAPS) const {
</pre>
</td>
</tr>
</table>
<center><a href="cpCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
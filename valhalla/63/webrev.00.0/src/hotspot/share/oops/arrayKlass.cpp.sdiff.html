<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/arrayKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/metaspace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/arrayKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
129       InstanceKlass* ik = InstanceKlass::cast(element_klass);
130       ik-&gt;set_array_name(name);
131     }
132   }
133 
134   return name;
135 }
136 
137 // Initialization of vtables and mirror object is done separatly from base_create_array_klass,
138 // since a GC can happen. At this point all instance variables of the ArrayKlass must be setup.
139 void ArrayKlass::complete_create_array_klass(ArrayKlass* k, Klass* super_klass, ModuleEntry* module_entry, TRAPS) {
140   k-&gt;initialize_supers(super_klass, NULL, CHECK);
141   k-&gt;vtable().initialize_vtable(false, CHECK);
142 
143   // During bootstrapping, before java.base is defined, the module_entry may not be present yet.
144   // These classes will be put on a fixup list and their module fields will be patched once
145   // java.base is defined.
146   assert((module_entry != NULL) || ((module_entry == NULL) &amp;&amp; !ModuleEntryTable::javabase_defined()),
147          &quot;module entry not available post &quot; JAVA_BASE_NAME &quot; definition&quot;);
148   oop module = (module_entry != NULL) ? module_entry-&gt;module() : (oop)NULL;
<span class="line-modified">149   java_lang_Class::create_mirror(k, Handle(THREAD, k-&gt;class_loader()), Handle(THREAD, module), Handle(), CHECK);</span>
150 }
151 
152 GrowableArray&lt;Klass*&gt;* ArrayKlass::compute_secondary_supers(int num_extra_slots,
153                                                             Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
154   // interfaces = { cloneable_klass, serializable_klass };
155   assert(num_extra_slots == 0, &quot;sanity of primitive array type&quot;);
156   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
157   // Must share this for correct bootstrapping!
158   set_secondary_supers(Universe::the_array_interfaces_array());
159   return NULL;
160 }
161 
162 objArrayOop ArrayKlass::allocate_arrayArray(int n, int length, TRAPS) {
163   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_ARRAY), CHECK_NULL);
164   int size = objArrayOopDesc::object_size(length);
165   Klass* k = array_klass(n+dimension(), CHECK_NULL);
166   ArrayKlass* ak = ArrayKlass::cast(k);
167   objArrayOop o = (objArrayOop)Universe::heap()-&gt;array_allocate(ak, size, length,
168                                                                 /* do_zero */ true, CHECK_NULL);
169   // initialization to NULL not necessary, area already cleared
</pre>
</td>
<td>
<hr />
<pre>
129       InstanceKlass* ik = InstanceKlass::cast(element_klass);
130       ik-&gt;set_array_name(name);
131     }
132   }
133 
134   return name;
135 }
136 
137 // Initialization of vtables and mirror object is done separatly from base_create_array_klass,
138 // since a GC can happen. At this point all instance variables of the ArrayKlass must be setup.
139 void ArrayKlass::complete_create_array_klass(ArrayKlass* k, Klass* super_klass, ModuleEntry* module_entry, TRAPS) {
140   k-&gt;initialize_supers(super_klass, NULL, CHECK);
141   k-&gt;vtable().initialize_vtable(false, CHECK);
142 
143   // During bootstrapping, before java.base is defined, the module_entry may not be present yet.
144   // These classes will be put on a fixup list and their module fields will be patched once
145   // java.base is defined.
146   assert((module_entry != NULL) || ((module_entry == NULL) &amp;&amp; !ModuleEntryTable::javabase_defined()),
147          &quot;module entry not available post &quot; JAVA_BASE_NAME &quot; definition&quot;);
148   oop module = (module_entry != NULL) ? module_entry-&gt;module() : (oop)NULL;
<span class="line-modified">149   java_lang_Class::create_mirror(k, Handle(THREAD, k-&gt;class_loader()), Handle(THREAD, module), Handle(), Handle(), CHECK);</span>
150 }
151 
152 GrowableArray&lt;Klass*&gt;* ArrayKlass::compute_secondary_supers(int num_extra_slots,
153                                                             Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
154   // interfaces = { cloneable_klass, serializable_klass };
155   assert(num_extra_slots == 0, &quot;sanity of primitive array type&quot;);
156   assert(transitive_interfaces == NULL, &quot;sanity&quot;);
157   // Must share this for correct bootstrapping!
158   set_secondary_supers(Universe::the_array_interfaces_array());
159   return NULL;
160 }
161 
162 objArrayOop ArrayKlass::allocate_arrayArray(int n, int length, TRAPS) {
163   check_array_allocation_length(length, arrayOopDesc::max_array_length(T_ARRAY), CHECK_NULL);
164   int size = objArrayOopDesc::object_size(length);
165   Klass* k = array_klass(n+dimension(), CHECK_NULL);
166   ArrayKlass* ak = ArrayKlass::cast(k);
167   objArrayOop o = (objArrayOop)Universe::heap()-&gt;array_allocate(ak, size, length,
168                                                                 /* do_zero */ true, CHECK_NULL);
169   // initialization to NULL not necessary, area already cleared
</pre>
</td>
</tr>
</table>
<center><a href="../memory/metaspace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="constantPool.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/interpreter/linkResolver.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../gc/parallel/psParallelCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jvmci/jvmciCodeInstaller.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/interpreter/linkResolver.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 419   if (vtable_index == Method::invalid_vtable_index) {
 420     // get vtable_index for miranda methods
 421     klassVtable vt = ik-&gt;vtable();
 422     vtable_index = vt.index_of_miranda(name, signature);
 423   }
 424   return vtable_index;
 425 }
 426 
 427 Method* LinkResolver::lookup_method_in_interfaces(const LinkInfo&amp; cp_info) {
 428   InstanceKlass *ik = InstanceKlass::cast(cp_info.resolved_klass());
 429 
 430   // Specify &#39;true&#39; in order to skip default methods when searching the
 431   // interfaces.  Function lookup_method_in_klasses() already looked for
 432   // the method in the default methods table.
 433   return ik-&gt;lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);
 434 }
 435 
 436 Method* LinkResolver::lookup_polymorphic_method(const LinkInfo&amp; link_info,
 437                                                 Handle *appendix_result_or_null,
 438                                                 TRAPS) {

 439   Klass* klass = link_info.resolved_klass();
 440   Symbol* name = link_info.name();
 441   Symbol* full_signature = link_info.signature();

 442 
 443   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
<span class="line-modified"> 444   if (TraceMethodHandles) {</span>
<span class="line-modified"> 445     ResourceMark rm(THREAD);</span>
<span class="line-modified"> 446     tty-&gt;print_cr(&quot;lookup_polymorphic_method iid=%s %s.%s%s&quot;,</span>
<span class="line-removed"> 447                   vmIntrinsics::name_at(iid), klass-&gt;external_name(),</span>
<span class="line-removed"> 448                   name-&gt;as_C_string(), full_signature-&gt;as_C_string());</span>
<span class="line-removed"> 449   }</span>
 450   if ((klass == SystemDictionary::MethodHandle_klass() ||
 451        klass == SystemDictionary::VarHandle_klass()) &amp;&amp;
 452       iid != vmIntrinsics::_none) {
 453     if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
 454       // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
 455       // Do not erase last argument type (MemberName) if it is a static linkTo method.
 456       bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
 457       TempNewSymbol basic_signature =
 458         MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
<span class="line-modified"> 459       if (TraceMethodHandles) {</span>
<span class="line-modified"> 460         ResourceMark rm(THREAD);</span>
<span class="line-modified"> 461         tty-&gt;print_cr(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,</span>
<span class="line-modified"> 462                       name-&gt;as_C_string(),</span>
<span class="line-removed"> 463                       full_signature-&gt;as_C_string(),</span>
<span class="line-removed"> 464                       basic_signature-&gt;as_C_string());</span>
<span class="line-removed"> 465       }</span>
 466       Method* result = SystemDictionary::find_method_handle_intrinsic(iid,
 467                                                               basic_signature,
 468                                                               CHECK_NULL);
 469       if (result != NULL) {
 470         assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
 471         assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
 472         assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
<span class="line-modified"> 473         if (TraceMethodHandles) {</span>
<span class="line-modified"> 474           ttyLocker ttyl;</span>
<span class="line-modified"> 475           tty-&gt;print(&quot;lookup_polymorphic_method =&gt; intrinsic &quot;);</span>
<span class="line-modified"> 476           result-&gt;print_on(tty);</span>
 477         }
 478       }
 479       return result;
 480     } else if (iid == vmIntrinsics::_invokeGeneric
 481                &amp;&amp; THREAD-&gt;can_call_java()
 482                &amp;&amp; appendix_result_or_null != NULL) {
 483       // This is a method with type-checking semantics.
 484       // We will ask Java code to spin an adapter method for it.
 485       if (!MethodHandles::enabled()) {
 486         // Make sure the Java part of the runtime has been booted up.
 487         Klass* natives = SystemDictionary::MethodHandleNatives_klass();
 488         if (natives == NULL || InstanceKlass::cast(natives)-&gt;is_not_initialized()) {
 489           SystemDictionary::resolve_or_fail(vmSymbols::java_lang_invoke_MethodHandleNatives(),
 490                                             Handle(),
 491                                             Handle(),
 492                                             true,
 493                                             CHECK_NULL);
 494         }
 495       }
 496 
 497       Handle appendix;
 498       Handle method_type;
 499       Method* result = SystemDictionary::find_method_handle_invoker(
 500                                                             klass,
 501                                                             name,
 502                                                             full_signature,
 503                                                             link_info.current_klass(),
 504                                                             &amp;appendix,
 505                                                             CHECK_NULL);
<span class="line-modified"> 506       if (TraceMethodHandles) {</span>
<span class="line-modified"> 507         ttyLocker ttyl;</span>
<span class="line-modified"> 508         tty-&gt;print(&quot;lookup_polymorphic_method =&gt; (via Java) &quot;);</span>
<span class="line-modified"> 509         result-&gt;print_on(tty);</span>
<span class="line-modified"> 510         tty-&gt;print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);</span>
<span class="line-modified"> 511         if (appendix.is_null())  tty-&gt;print_cr(&quot;(none)&quot;);</span>
<span class="line-removed"> 512         else                     appendix-&gt;print_on(tty);</span>
 513       }
 514       if (result != NULL) {
 515 #ifdef ASSERT
 516         ResourceMark rm(THREAD);
 517 
 518         TempNewSymbol basic_signature =
 519           MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);
 520         int actual_size_of_params = result-&gt;size_of_parameters();
 521         int expected_size_of_params = ArgumentSizeComputer(basic_signature).size();
 522         // +1 for MethodHandle.this, +1 for trailing MethodType
 523         if (!MethodHandles::is_signature_polymorphic_static(iid))  expected_size_of_params += 1;
 524         if (appendix.not_null())                                   expected_size_of_params += 1;
 525         if (actual_size_of_params != expected_size_of_params) {
 526           tty-&gt;print_cr(&quot;*** basic_signature=%s&quot;, basic_signature-&gt;as_C_string());
 527           tty-&gt;print_cr(&quot;*** result for %s: &quot;, vmIntrinsics::name_at(iid));
 528           result-&gt;print();
 529         }
 530         assert(actual_size_of_params == expected_size_of_params,
 531                &quot;%d != %d&quot;, actual_size_of_params, expected_size_of_params);
 532 #endif //ASSERT
 533 
 534         assert(appendix_result_or_null != NULL, &quot;&quot;);
 535         (*appendix_result_or_null) = appendix;
 536       }
 537       return result;
 538     }
 539   }
 540   return NULL;
 541 }
 542 















 543 void LinkResolver::check_method_accessability(Klass* ref_klass,
 544                                               Klass* resolved_klass,
 545                                               Klass* sel_klass,
 546                                               const methodHandle&amp; sel_method,
 547                                               TRAPS) {
 548 
 549   AccessFlags flags = sel_method-&gt;access_flags();
 550 
 551   // Special case:  arrays always override &quot;clone&quot;. JVMS 2.15.
 552   // If the resolved klass is an array class, and the declaring class
 553   // is java.lang.Object and the method is &quot;clone&quot;, set the flags
 554   // to public.
 555   //
 556   // We&#39;ll check for the method name first, as that&#39;s most likely
 557   // to be false (so we&#39;ll short-circuit out of these tests).
 558   if (sel_method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 559       sel_klass == SystemDictionary::Object_klass() &amp;&amp;
 560       resolved_klass-&gt;is_array_klass()) {
 561     // We need to change &quot;protected&quot; to &quot;public&quot;.
 562     assert(flags.is_protected(), &quot;clone not protected?&quot;);
 563     jint new_flags = flags.as_int();
 564     new_flags = new_flags &amp; (~JVM_ACC_PROTECTED);
 565     new_flags = new_flags | JVM_ACC_PUBLIC;
 566     flags.set_flags(new_flags);
 567   }
 568 //  assert(extra_arg_result_or_null != NULL, &quot;must be able to return extra argument&quot;);
 569 
 570   bool can_access = Reflection::verify_member_access(ref_klass,
 571                                                      resolved_klass,
 572                                                      sel_klass,
 573                                                      flags,
 574                                                      true, false, CHECK);
<span class="line-modified"> 575   // Any existing exceptions that may have been thrown, for example LinkageErrors</span>
<span class="line-modified"> 576   // from nest-host resolution, have been allowed to propagate.</span>
 577   if (!can_access) {
 578     ResourceMark rm(THREAD);

 579     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
<span class="line-modified"> 580     Exceptions::fthrow(</span>
<span class="line-modified"> 581       THREAD_AND_LOCATION,</span>
<span class="line-modified"> 582       vmSymbols::java_lang_IllegalAccessError(),</span>
<span class="line-modified"> 583       &quot;class %s tried to access %s%s%smethod &#39;%s&#39; (%s%s%s)&quot;,</span>
<span class="line-modified"> 584       ref_klass-&gt;external_name(),</span>
<span class="line-modified"> 585       sel_method-&gt;is_abstract()  ? &quot;abstract &quot;  : &quot;&quot;,</span>
<span class="line-modified"> 586       sel_method-&gt;is_protected() ? &quot;protected &quot; : &quot;&quot;,</span>
<span class="line-modified"> 587       sel_method-&gt;is_private()   ? &quot;private &quot;   : &quot;&quot;,</span>
<span class="line-modified"> 588       sel_method-&gt;external_name(),</span>
<span class="line-modified"> 589       (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),</span>
<span class="line-modified"> 590       (same_module) ? &quot;&quot; : &quot;; &quot;,</span>
<span class="line-modified"> 591       (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()</span>
<span class="line-modified"> 592     );</span>









 593     return;
 594   }
 595 }
 596 
 597 Method* LinkResolver::resolve_method_statically(Bytecodes::Code code,
 598                                                 const constantPoolHandle&amp; pool, int index, TRAPS) {
 599   // This method is used only
 600   // (1) in C2 from InlineTree::ok_to_inline (via ciMethod::check_call),
 601   // and
 602   // (2) in Bytecode_invoke::static_target
 603   // It appears to fail when applied to an invokeinterface call site.
 604   // FIXME: Remove this method and ciMethod::check_call; refactor to use the other LinkResolver entry points.
 605   // resolve klass
 606   if (code == Bytecodes::_invokedynamic) {
 607     Klass* resolved_klass = SystemDictionary::MethodHandle_klass();
 608     Symbol* method_name = vmSymbols::invoke_name();
 609     Symbol* method_signature = pool-&gt;signature_ref_at(index);
 610     Klass*  current_klass = pool-&gt;pool_holder();
 611     LinkInfo link_info(resolved_klass, method_name, method_signature, current_klass);
 612     return resolve_method(link_info, code, THREAD);
</pre>
<hr />
<pre>
 891 }
 892 
 893 //------------------------------------------------------------------------------------------------------------------------
 894 // Field resolution
 895 
 896 void LinkResolver::check_field_accessability(Klass* ref_klass,
 897                                              Klass* resolved_klass,
 898                                              Klass* sel_klass,
 899                                              const fieldDescriptor&amp; fd,
 900                                              TRAPS) {
 901   bool can_access = Reflection::verify_member_access(ref_klass,
 902                                                      resolved_klass,
 903                                                      sel_klass,
 904                                                      fd.access_flags(),
 905                                                      true, false, CHECK);
 906   // Any existing exceptions that may have been thrown, for example LinkageErrors
 907   // from nest-host resolution, have been allowed to propagate.
 908   if (!can_access) {
 909     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
 910     ResourceMark rm(THREAD);
<span class="line-modified"> 911     Exceptions::fthrow(</span>
<span class="line-modified"> 912       THREAD_AND_LOCATION,</span>
<span class="line-modified"> 913       vmSymbols::java_lang_IllegalAccessError(),</span>
<span class="line-modified"> 914       &quot;class %s tried to access %s%sfield %s.%s (%s%s%s)&quot;,</span>
<span class="line-modified"> 915       ref_klass-&gt;external_name(),</span>
<span class="line-modified"> 916       fd.is_protected() ? &quot;protected &quot; : &quot;&quot;,</span>
<span class="line-modified"> 917       fd.is_private()   ? &quot;private &quot;   : &quot;&quot;,</span>
<span class="line-modified"> 918       sel_klass-&gt;external_name(),</span>
<span class="line-modified"> 919       fd.name()-&gt;as_C_string(),</span>
<span class="line-modified"> 920       (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),</span>
<span class="line-modified"> 921       (same_module) ? &quot;&quot; : &quot;; &quot;,</span>
<span class="line-modified"> 922       (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()</span>
<span class="line-modified"> 923     );</span>








 924     return;
 925   }
 926 }
 927 
 928 void LinkResolver::resolve_field_access(fieldDescriptor&amp; fd, const constantPoolHandle&amp; pool, int index, const methodHandle&amp; method, Bytecodes::Code byte, TRAPS) {
 929   LinkInfo link_info(pool, index, method, CHECK);
 930   resolve_field(fd, link_info, byte, true, CHECK);
 931 }
 932 
 933 void LinkResolver::resolve_field(fieldDescriptor&amp; fd,
 934                                  const LinkInfo&amp; link_info,
 935                                  Bytecodes::Code byte, bool initialize_class,
 936                                  TRAPS) {
 937   assert(byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic ||
 938          byte == Bytecodes::_getfield  || byte == Bytecodes::_putfield  ||
 939          byte == Bytecodes::_withfield ||
 940          byte == Bytecodes::_nofast_getfield  || byte == Bytecodes::_nofast_putfield  ||
 941          (byte == Bytecodes::_nop &amp;&amp; !link_info.check_access()), &quot;bad field access bytecode&quot;);
 942 
 943   bool is_static = (byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic);
</pre>
<hr />
<pre>
1669 void LinkResolver::resolve_invokevirtual(CallInfo&amp; result, Handle recv,
1670                                           const constantPoolHandle&amp; pool, int index,
1671                                           TRAPS) {
1672 
1673   LinkInfo link_info(pool, index, CHECK);
1674   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1675   resolve_virtual_call(result, recv, recvrKlass, link_info, /*check_null_or_abstract*/true, CHECK);
1676 }
1677 
1678 
1679 void LinkResolver::resolve_invokeinterface(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, TRAPS) {
1680   LinkInfo link_info(pool, index, CHECK);
1681   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1682   resolve_interface_call(result, recv, recvrKlass, link_info, true, CHECK);
1683 }
1684 
1685 
1686 void LinkResolver::resolve_invokehandle(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1687   // This guy is reached from InterpreterRuntime::resolve_invokehandle.
1688   LinkInfo link_info(pool, index, CHECK);
<span class="line-modified">1689   if (TraceMethodHandles) {</span>
1690     ResourceMark rm(THREAD);
<span class="line-modified">1691     tty-&gt;print_cr(&quot;resolve_invokehandle %s %s&quot;, link_info.name()-&gt;as_C_string(),</span>
<span class="line-modified">1692                   link_info.signature()-&gt;as_C_string());</span>
1693   }
1694   resolve_handle_call(result, link_info, CHECK);
1695 }
1696 
1697 void LinkResolver::resolve_handle_call(CallInfo&amp; result,
1698                                        const LinkInfo&amp; link_info,
1699                                        TRAPS) {
1700   // JSR 292:  this must be an implicitly generated method MethodHandle.invokeExact(*...) or similar
1701   Klass* resolved_klass = link_info.resolved_klass();
1702   assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||
1703          resolved_klass == SystemDictionary::VarHandle_klass(), &quot;&quot;);
1704   assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), &quot;&quot;);
1705   Handle       resolved_appendix;
1706   Method* resolved_method = lookup_polymorphic_method(link_info, &amp;resolved_appendix, CHECK);
1707   result.set_handle(resolved_klass, methodHandle(THREAD, resolved_method), resolved_appendix, CHECK);
1708 }
1709 
1710 void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int indy_index, TRAPS) {
1711   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(indy_index);
1712   int pool_index = cpce-&gt;constant_pool_index();
1713 
1714   // Resolve the bootstrap specifier (BSM + optional arguments).
1715   BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);
1716 
1717   // Check if CallSite has been bound already or failed already, and short circuit:
1718   {
1719     bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1720     if (is_done) return;
1721   }
1722 
1723   // The initial step in Call Site Specifier Resolution is to resolve the symbolic
1724   // reference to a method handle which will be the bootstrap method for a dynamic
1725   // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap
1726   // method fails, then a MethodHandleInError is stored at the corresponding bootstrap
1727   // method&#39;s CP index for the CONSTANT_MethodHandle_info.  So, there is no need to
1728   // set the indy_rf flag since any subsequent invokedynamic instruction which shares
1729   // this bootstrap method will encounter the resolution of MethodHandleInError.
1730 
1731   resolve_dynamic_call(result, bootstrap_specifier, CHECK);
1732 
<span class="line-modified">1733   if (TraceMethodHandles) {</span>
<span class="line-modified">1734     bootstrap_specifier.print_msg_on(tty, &quot;resolve_invokedynamic&quot;);</span>


1735   }
1736 
1737   // The returned linkage result is provisional up to the moment
1738   // the interpreter or runtime performs a serialized check of
1739   // the relevant CPCE::f1 field.  This is done by the caller
1740   // of this method, via CPCE::set_dynamic_call, which uses
1741   // an ObjectLocker to do the final serialization of updates
1742   // to CPCE state, including f1.
1743 }
1744 
1745 void LinkResolver::resolve_dynamic_call(CallInfo&amp; result,
1746                                         BootstrapInfo&amp; bootstrap_specifier,
1747                                         TRAPS) {
1748   // JSR 292:  this must resolve to an implicitly generated method
1749   // such as MH.linkToCallSite(*...) or some other call-site shape.
1750   // The appendix argument is likely to be a freshly-created CallSite.
1751   // It may also be a MethodHandle from an unwrapped ConstantCallSite,
1752   // or any other reference.  The resolved_method as well as the appendix
1753   // are both recorded together via CallInfo::set_handle.
1754   SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
<span class="line-modified">1755   Exceptions::wrap_dynamic_exception(THREAD);</span>
1756 
1757   if (HAS_PENDING_EXCEPTION) {
1758     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
1759       // Let any random low-level IE or SOE or OOME just bleed through.
1760       // Basically we pretend that the bootstrap method was never called,
1761       // if it fails this way:  We neither record a successful linkage,
1762       // nor do we memorize a LE for posterity.
1763       return;
1764     }
1765     // JVMS 5.4.3 says: If an attempt by the Java Virtual Machine to resolve
1766     // a symbolic reference fails because an error is thrown that is an
1767     // instance of LinkageError (or a subclass), then subsequent attempts to
1768     // resolve the reference always fail with the same error that was thrown
1769     // as a result of the initial resolution attempt.
1770      bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);
1771      if (!recorded_res_status) {
1772        // Another thread got here just before we did.  So, either use the method
1773        // that it resolved or throw the LinkageError exception that it threw.
1774        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1775        if (is_done) return;
</pre>
</td>
<td>
<hr />
<pre>
 419   if (vtable_index == Method::invalid_vtable_index) {
 420     // get vtable_index for miranda methods
 421     klassVtable vt = ik-&gt;vtable();
 422     vtable_index = vt.index_of_miranda(name, signature);
 423   }
 424   return vtable_index;
 425 }
 426 
 427 Method* LinkResolver::lookup_method_in_interfaces(const LinkInfo&amp; cp_info) {
 428   InstanceKlass *ik = InstanceKlass::cast(cp_info.resolved_klass());
 429 
 430   // Specify &#39;true&#39; in order to skip default methods when searching the
 431   // interfaces.  Function lookup_method_in_klasses() already looked for
 432   // the method in the default methods table.
 433   return ik-&gt;lookup_method_in_all_interfaces(cp_info.name(), cp_info.signature(), Klass::skip_defaults);
 434 }
 435 
 436 Method* LinkResolver::lookup_polymorphic_method(const LinkInfo&amp; link_info,
 437                                                 Handle *appendix_result_or_null,
 438                                                 TRAPS) {
<span class="line-added"> 439   ResourceMark rm(THREAD);</span>
 440   Klass* klass = link_info.resolved_klass();
 441   Symbol* name = link_info.name();
 442   Symbol* full_signature = link_info.signature();
<span class="line-added"> 443   LogTarget(Info, methodhandles) lt_mh;</span>
 444 
 445   vmIntrinsics::ID iid = MethodHandles::signature_polymorphic_name_id(name);
<span class="line-modified"> 446   log_info(methodhandles)(&quot;lookup_polymorphic_method iid=%s %s.%s%s&quot;,</span>
<span class="line-modified"> 447                           vmIntrinsics::name_at(iid), klass-&gt;external_name(),</span>
<span class="line-modified"> 448                           name-&gt;as_C_string(), full_signature-&gt;as_C_string());</span>



 449   if ((klass == SystemDictionary::MethodHandle_klass() ||
 450        klass == SystemDictionary::VarHandle_klass()) &amp;&amp;
 451       iid != vmIntrinsics::_none) {
 452     if (MethodHandles::is_signature_polymorphic_intrinsic(iid)) {
 453       // Most of these do not need an up-call to Java to resolve, so can be done anywhere.
 454       // Do not erase last argument type (MemberName) if it is a static linkTo method.
 455       bool keep_last_arg = MethodHandles::is_signature_polymorphic_static(iid);
 456       TempNewSymbol basic_signature =
 457         MethodHandles::lookup_basic_type_signature(full_signature, keep_last_arg, CHECK_NULL);
<span class="line-modified"> 458       log_info(methodhandles)(&quot;lookup_polymorphic_method %s %s =&gt; basic %s&quot;,</span>
<span class="line-modified"> 459                               name-&gt;as_C_string(),</span>
<span class="line-modified"> 460                               full_signature-&gt;as_C_string(),</span>
<span class="line-modified"> 461                               basic_signature-&gt;as_C_string());</span>



 462       Method* result = SystemDictionary::find_method_handle_intrinsic(iid,
 463                                                               basic_signature,
 464                                                               CHECK_NULL);
 465       if (result != NULL) {
 466         assert(result-&gt;is_method_handle_intrinsic(), &quot;MH.invokeBasic or MH.linkTo* intrinsic&quot;);
 467         assert(result-&gt;intrinsic_id() != vmIntrinsics::_invokeGeneric, &quot;wrong place to find this&quot;);
 468         assert(basic_signature == result-&gt;signature(), &quot;predict the result signature&quot;);
<span class="line-modified"> 469         if (lt_mh.is_enabled()) {</span>
<span class="line-modified"> 470           LogStream ls(lt_mh);</span>
<span class="line-modified"> 471           ls.print(&quot;lookup_polymorphic_method =&gt; intrinsic &quot;);</span>
<span class="line-modified"> 472           result-&gt;print_on(&amp;ls);</span>
 473         }
 474       }
 475       return result;
 476     } else if (iid == vmIntrinsics::_invokeGeneric
 477                &amp;&amp; THREAD-&gt;can_call_java()
 478                &amp;&amp; appendix_result_or_null != NULL) {
 479       // This is a method with type-checking semantics.
 480       // We will ask Java code to spin an adapter method for it.
 481       if (!MethodHandles::enabled()) {
 482         // Make sure the Java part of the runtime has been booted up.
 483         Klass* natives = SystemDictionary::MethodHandleNatives_klass();
 484         if (natives == NULL || InstanceKlass::cast(natives)-&gt;is_not_initialized()) {
 485           SystemDictionary::resolve_or_fail(vmSymbols::java_lang_invoke_MethodHandleNatives(),
 486                                             Handle(),
 487                                             Handle(),
 488                                             true,
 489                                             CHECK_NULL);
 490         }
 491       }
 492 
 493       Handle appendix;
 494       Handle method_type;
 495       Method* result = SystemDictionary::find_method_handle_invoker(
 496                                                             klass,
 497                                                             name,
 498                                                             full_signature,
 499                                                             link_info.current_klass(),
 500                                                             &amp;appendix,
 501                                                             CHECK_NULL);
<span class="line-modified"> 502       if (lt_mh.is_enabled()) {</span>
<span class="line-modified"> 503         LogStream ls(lt_mh);</span>
<span class="line-modified"> 504         ls.print(&quot;lookup_polymorphic_method =&gt; (via Java) &quot;);</span>
<span class="line-modified"> 505         result-&gt;print_on(&amp;ls);</span>
<span class="line-modified"> 506         ls.print(&quot;  lookup_polymorphic_method =&gt; appendix = &quot;);</span>
<span class="line-modified"> 507         appendix.is_null() ? ls.print_cr(&quot;(none)&quot;) : appendix-&gt;print_on(&amp;ls);</span>

 508       }
 509       if (result != NULL) {
 510 #ifdef ASSERT
 511         ResourceMark rm(THREAD);
 512 
 513         TempNewSymbol basic_signature =
 514           MethodHandles::lookup_basic_type_signature(full_signature, CHECK_NULL);
 515         int actual_size_of_params = result-&gt;size_of_parameters();
 516         int expected_size_of_params = ArgumentSizeComputer(basic_signature).size();
 517         // +1 for MethodHandle.this, +1 for trailing MethodType
 518         if (!MethodHandles::is_signature_polymorphic_static(iid))  expected_size_of_params += 1;
 519         if (appendix.not_null())                                   expected_size_of_params += 1;
 520         if (actual_size_of_params != expected_size_of_params) {
 521           tty-&gt;print_cr(&quot;*** basic_signature=%s&quot;, basic_signature-&gt;as_C_string());
 522           tty-&gt;print_cr(&quot;*** result for %s: &quot;, vmIntrinsics::name_at(iid));
 523           result-&gt;print();
 524         }
 525         assert(actual_size_of_params == expected_size_of_params,
 526                &quot;%d != %d&quot;, actual_size_of_params, expected_size_of_params);
 527 #endif //ASSERT
 528 
 529         assert(appendix_result_or_null != NULL, &quot;&quot;);
 530         (*appendix_result_or_null) = appendix;
 531       }
 532       return result;
 533     }
 534   }
 535   return NULL;
 536 }
 537 
<span class="line-added"> 538 static void print_nest_host_error_on(stringStream* ss, Klass* ref_klass, Klass* sel_klass, TRAPS) {</span>
<span class="line-added"> 539   assert(ref_klass-&gt;is_instance_klass(), &quot;must be&quot;);</span>
<span class="line-added"> 540   assert(sel_klass-&gt;is_instance_klass(), &quot;must be&quot;);</span>
<span class="line-added"> 541   InstanceKlass* ref_ik = InstanceKlass::cast(ref_klass);</span>
<span class="line-added"> 542   InstanceKlass* sel_ik = InstanceKlass::cast(sel_klass);</span>
<span class="line-added"> 543   const char* nest_host_error_1 = ref_ik-&gt;nest_host_error(THREAD);</span>
<span class="line-added"> 544   const char* nest_host_error_2 = sel_ik-&gt;nest_host_error(THREAD);</span>
<span class="line-added"> 545   if (nest_host_error_1 != NULL || nest_host_error_2 != NULL) {</span>
<span class="line-added"> 546     ss-&gt;print(&quot;, (%s%s%s)&quot;,</span>
<span class="line-added"> 547               (nest_host_error_1 != NULL) ? nest_host_error_1 : &quot;&quot;,</span>
<span class="line-added"> 548               (nest_host_error_1 != NULL &amp;&amp; nest_host_error_2 != NULL) ? &quot;, &quot; : &quot;&quot;,</span>
<span class="line-added"> 549               (nest_host_error_2 != NULL) ? nest_host_error_2 : &quot;&quot;);</span>
<span class="line-added"> 550   }</span>
<span class="line-added"> 551 }</span>
<span class="line-added"> 552 </span>
 553 void LinkResolver::check_method_accessability(Klass* ref_klass,
 554                                               Klass* resolved_klass,
 555                                               Klass* sel_klass,
 556                                               const methodHandle&amp; sel_method,
 557                                               TRAPS) {
 558 
 559   AccessFlags flags = sel_method-&gt;access_flags();
 560 
 561   // Special case:  arrays always override &quot;clone&quot;. JVMS 2.15.
 562   // If the resolved klass is an array class, and the declaring class
 563   // is java.lang.Object and the method is &quot;clone&quot;, set the flags
 564   // to public.
 565   //
 566   // We&#39;ll check for the method name first, as that&#39;s most likely
 567   // to be false (so we&#39;ll short-circuit out of these tests).
 568   if (sel_method-&gt;name() == vmSymbols::clone_name() &amp;&amp;
 569       sel_klass == SystemDictionary::Object_klass() &amp;&amp;
 570       resolved_klass-&gt;is_array_klass()) {
 571     // We need to change &quot;protected&quot; to &quot;public&quot;.
 572     assert(flags.is_protected(), &quot;clone not protected?&quot;);
 573     jint new_flags = flags.as_int();
 574     new_flags = new_flags &amp; (~JVM_ACC_PROTECTED);
 575     new_flags = new_flags | JVM_ACC_PUBLIC;
 576     flags.set_flags(new_flags);
 577   }
 578 //  assert(extra_arg_result_or_null != NULL, &quot;must be able to return extra argument&quot;);
 579 
 580   bool can_access = Reflection::verify_member_access(ref_klass,
 581                                                      resolved_klass,
 582                                                      sel_klass,
 583                                                      flags,
 584                                                      true, false, CHECK);
<span class="line-modified"> 585   // Any existing exceptions that may have been thrown</span>
<span class="line-modified"> 586   // have been allowed to propagate.</span>
 587   if (!can_access) {
 588     ResourceMark rm(THREAD);
<span class="line-added"> 589     stringStream ss;</span>
 590     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
<span class="line-modified"> 591     ss.print(&quot;class %s tried to access %s%s%smethod &#39;%s&#39; (%s%s%s)&quot;,</span>
<span class="line-modified"> 592              ref_klass-&gt;external_name(),</span>
<span class="line-modified"> 593              sel_method-&gt;is_abstract()  ? &quot;abstract &quot;  : &quot;&quot;,</span>
<span class="line-modified"> 594              sel_method-&gt;is_protected() ? &quot;protected &quot; : &quot;&quot;,</span>
<span class="line-modified"> 595              sel_method-&gt;is_private()   ? &quot;private &quot;   : &quot;&quot;,</span>
<span class="line-modified"> 596              sel_method-&gt;external_name(),</span>
<span class="line-modified"> 597              (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),</span>
<span class="line-modified"> 598              (same_module) ? &quot;&quot; : &quot;; &quot;,</span>
<span class="line-modified"> 599              (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()</span>
<span class="line-modified"> 600              );</span>
<span class="line-modified"> 601 </span>
<span class="line-modified"> 602     // For private access see if there was a problem with nest host</span>
<span class="line-modified"> 603     // resolution, and if so report that as part of the message.</span>
<span class="line-added"> 604     if (sel_method-&gt;is_private()) {</span>
<span class="line-added"> 605       print_nest_host_error_on(&amp;ss, ref_klass, sel_klass, THREAD);</span>
<span class="line-added"> 606     }</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608     Exceptions::fthrow(THREAD_AND_LOCATION,</span>
<span class="line-added"> 609                        vmSymbols::java_lang_IllegalAccessError(),</span>
<span class="line-added"> 610                        &quot;%s&quot;,</span>
<span class="line-added"> 611                        ss.as_string()</span>
<span class="line-added"> 612                        );</span>
 613     return;
 614   }
 615 }
 616 
 617 Method* LinkResolver::resolve_method_statically(Bytecodes::Code code,
 618                                                 const constantPoolHandle&amp; pool, int index, TRAPS) {
 619   // This method is used only
 620   // (1) in C2 from InlineTree::ok_to_inline (via ciMethod::check_call),
 621   // and
 622   // (2) in Bytecode_invoke::static_target
 623   // It appears to fail when applied to an invokeinterface call site.
 624   // FIXME: Remove this method and ciMethod::check_call; refactor to use the other LinkResolver entry points.
 625   // resolve klass
 626   if (code == Bytecodes::_invokedynamic) {
 627     Klass* resolved_klass = SystemDictionary::MethodHandle_klass();
 628     Symbol* method_name = vmSymbols::invoke_name();
 629     Symbol* method_signature = pool-&gt;signature_ref_at(index);
 630     Klass*  current_klass = pool-&gt;pool_holder();
 631     LinkInfo link_info(resolved_klass, method_name, method_signature, current_klass);
 632     return resolve_method(link_info, code, THREAD);
</pre>
<hr />
<pre>
 911 }
 912 
 913 //------------------------------------------------------------------------------------------------------------------------
 914 // Field resolution
 915 
 916 void LinkResolver::check_field_accessability(Klass* ref_klass,
 917                                              Klass* resolved_klass,
 918                                              Klass* sel_klass,
 919                                              const fieldDescriptor&amp; fd,
 920                                              TRAPS) {
 921   bool can_access = Reflection::verify_member_access(ref_klass,
 922                                                      resolved_klass,
 923                                                      sel_klass,
 924                                                      fd.access_flags(),
 925                                                      true, false, CHECK);
 926   // Any existing exceptions that may have been thrown, for example LinkageErrors
 927   // from nest-host resolution, have been allowed to propagate.
 928   if (!can_access) {
 929     bool same_module = (sel_klass-&gt;module() == ref_klass-&gt;module());
 930     ResourceMark rm(THREAD);
<span class="line-modified"> 931     stringStream ss;</span>
<span class="line-modified"> 932     ss.print(&quot;class %s tried to access %s%sfield %s.%s (%s%s%s)&quot;,</span>
<span class="line-modified"> 933              ref_klass-&gt;external_name(),</span>
<span class="line-modified"> 934              fd.is_protected() ? &quot;protected &quot; : &quot;&quot;,</span>
<span class="line-modified"> 935              fd.is_private()   ? &quot;private &quot;   : &quot;&quot;,</span>
<span class="line-modified"> 936              sel_klass-&gt;external_name(),</span>
<span class="line-modified"> 937              fd.name()-&gt;as_C_string(),</span>
<span class="line-modified"> 938              (same_module) ? ref_klass-&gt;joint_in_module_of_loader(sel_klass) : ref_klass-&gt;class_in_module_of_loader(),</span>
<span class="line-modified"> 939              (same_module) ? &quot;&quot; : &quot;; &quot;,</span>
<span class="line-modified"> 940              (same_module) ? &quot;&quot; : sel_klass-&gt;class_in_module_of_loader()</span>
<span class="line-modified"> 941              );</span>
<span class="line-modified"> 942     // For private access see if there was a problem with nest host</span>
<span class="line-modified"> 943     // resolution, and if so report that as part of the message.</span>
<span class="line-added"> 944     if (fd.is_private()) {</span>
<span class="line-added"> 945       print_nest_host_error_on(&amp;ss, ref_klass, sel_klass, THREAD);</span>
<span class="line-added"> 946     }</span>
<span class="line-added"> 947     Exceptions::fthrow(THREAD_AND_LOCATION,</span>
<span class="line-added"> 948                        vmSymbols::java_lang_IllegalAccessError(),</span>
<span class="line-added"> 949                        &quot;%s&quot;,</span>
<span class="line-added"> 950                        ss.as_string()</span>
<span class="line-added"> 951                        );</span>
 952     return;
 953   }
 954 }
 955 
 956 void LinkResolver::resolve_field_access(fieldDescriptor&amp; fd, const constantPoolHandle&amp; pool, int index, const methodHandle&amp; method, Bytecodes::Code byte, TRAPS) {
 957   LinkInfo link_info(pool, index, method, CHECK);
 958   resolve_field(fd, link_info, byte, true, CHECK);
 959 }
 960 
 961 void LinkResolver::resolve_field(fieldDescriptor&amp; fd,
 962                                  const LinkInfo&amp; link_info,
 963                                  Bytecodes::Code byte, bool initialize_class,
 964                                  TRAPS) {
 965   assert(byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic ||
 966          byte == Bytecodes::_getfield  || byte == Bytecodes::_putfield  ||
 967          byte == Bytecodes::_withfield ||
 968          byte == Bytecodes::_nofast_getfield  || byte == Bytecodes::_nofast_putfield  ||
 969          (byte == Bytecodes::_nop &amp;&amp; !link_info.check_access()), &quot;bad field access bytecode&quot;);
 970 
 971   bool is_static = (byte == Bytecodes::_getstatic || byte == Bytecodes::_putstatic);
</pre>
<hr />
<pre>
1697 void LinkResolver::resolve_invokevirtual(CallInfo&amp; result, Handle recv,
1698                                           const constantPoolHandle&amp; pool, int index,
1699                                           TRAPS) {
1700 
1701   LinkInfo link_info(pool, index, CHECK);
1702   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1703   resolve_virtual_call(result, recv, recvrKlass, link_info, /*check_null_or_abstract*/true, CHECK);
1704 }
1705 
1706 
1707 void LinkResolver::resolve_invokeinterface(CallInfo&amp; result, Handle recv, const constantPoolHandle&amp; pool, int index, TRAPS) {
1708   LinkInfo link_info(pool, index, CHECK);
1709   Klass* recvrKlass = recv.is_null() ? (Klass*)NULL : recv-&gt;klass();
1710   resolve_interface_call(result, recv, recvrKlass, link_info, true, CHECK);
1711 }
1712 
1713 
1714 void LinkResolver::resolve_invokehandle(CallInfo&amp; result, const constantPoolHandle&amp; pool, int index, TRAPS) {
1715   // This guy is reached from InterpreterRuntime::resolve_invokehandle.
1716   LinkInfo link_info(pool, index, CHECK);
<span class="line-modified">1717   if (log_is_enabled(Info, methodhandles)) {</span>
1718     ResourceMark rm(THREAD);
<span class="line-modified">1719     log_info(methodhandles)(&quot;resolve_invokehandle %s %s&quot;, link_info.name()-&gt;as_C_string(),</span>
<span class="line-modified">1720                             link_info.signature()-&gt;as_C_string());</span>
1721   }
1722   resolve_handle_call(result, link_info, CHECK);
1723 }
1724 
1725 void LinkResolver::resolve_handle_call(CallInfo&amp; result,
1726                                        const LinkInfo&amp; link_info,
1727                                        TRAPS) {
1728   // JSR 292:  this must be an implicitly generated method MethodHandle.invokeExact(*...) or similar
1729   Klass* resolved_klass = link_info.resolved_klass();
1730   assert(resolved_klass == SystemDictionary::MethodHandle_klass() ||
1731          resolved_klass == SystemDictionary::VarHandle_klass(), &quot;&quot;);
1732   assert(MethodHandles::is_signature_polymorphic_name(link_info.name()), &quot;&quot;);
1733   Handle       resolved_appendix;
1734   Method* resolved_method = lookup_polymorphic_method(link_info, &amp;resolved_appendix, CHECK);
1735   result.set_handle(resolved_klass, methodHandle(THREAD, resolved_method), resolved_appendix, CHECK);
1736 }
1737 
1738 void LinkResolver::resolve_invokedynamic(CallInfo&amp; result, const constantPoolHandle&amp; pool, int indy_index, TRAPS) {
1739   ConstantPoolCacheEntry* cpce = pool-&gt;invokedynamic_cp_cache_entry_at(indy_index);
1740   int pool_index = cpce-&gt;constant_pool_index();
1741 
1742   // Resolve the bootstrap specifier (BSM + optional arguments).
1743   BootstrapInfo bootstrap_specifier(pool, pool_index, indy_index);
1744 
1745   // Check if CallSite has been bound already or failed already, and short circuit:
1746   {
1747     bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1748     if (is_done) return;
1749   }
1750 
1751   // The initial step in Call Site Specifier Resolution is to resolve the symbolic
1752   // reference to a method handle which will be the bootstrap method for a dynamic
1753   // call site.  If resolution for the java.lang.invoke.MethodHandle for the bootstrap
1754   // method fails, then a MethodHandleInError is stored at the corresponding bootstrap
1755   // method&#39;s CP index for the CONSTANT_MethodHandle_info.  So, there is no need to
1756   // set the indy_rf flag since any subsequent invokedynamic instruction which shares
1757   // this bootstrap method will encounter the resolution of MethodHandleInError.
1758 
1759   resolve_dynamic_call(result, bootstrap_specifier, CHECK);
1760 
<span class="line-modified">1761   LogTarget(Debug, methodhandles, indy) lt_indy;</span>
<span class="line-modified">1762   if (lt_indy.is_enabled()) {</span>
<span class="line-added">1763     LogStream ls(lt_indy);</span>
<span class="line-added">1764     bootstrap_specifier.print_msg_on(&amp;ls, &quot;resolve_invokedynamic&quot;);</span>
1765   }
1766 
1767   // The returned linkage result is provisional up to the moment
1768   // the interpreter or runtime performs a serialized check of
1769   // the relevant CPCE::f1 field.  This is done by the caller
1770   // of this method, via CPCE::set_dynamic_call, which uses
1771   // an ObjectLocker to do the final serialization of updates
1772   // to CPCE state, including f1.
1773 }
1774 
1775 void LinkResolver::resolve_dynamic_call(CallInfo&amp; result,
1776                                         BootstrapInfo&amp; bootstrap_specifier,
1777                                         TRAPS) {
1778   // JSR 292:  this must resolve to an implicitly generated method
1779   // such as MH.linkToCallSite(*...) or some other call-site shape.
1780   // The appendix argument is likely to be a freshly-created CallSite.
1781   // It may also be a MethodHandle from an unwrapped ConstantCallSite,
1782   // or any other reference.  The resolved_method as well as the appendix
1783   // are both recorded together via CallInfo::set_handle.
1784   SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
<span class="line-modified">1785   Exceptions::wrap_dynamic_exception(/* is_indy */ true, THREAD);</span>
1786 
1787   if (HAS_PENDING_EXCEPTION) {
1788     if (!PENDING_EXCEPTION-&gt;is_a(SystemDictionary::LinkageError_klass())) {
1789       // Let any random low-level IE or SOE or OOME just bleed through.
1790       // Basically we pretend that the bootstrap method was never called,
1791       // if it fails this way:  We neither record a successful linkage,
1792       // nor do we memorize a LE for posterity.
1793       return;
1794     }
1795     // JVMS 5.4.3 says: If an attempt by the Java Virtual Machine to resolve
1796     // a symbolic reference fails because an error is thrown that is an
1797     // instance of LinkageError (or a subclass), then subsequent attempts to
1798     // resolve the reference always fail with the same error that was thrown
1799     // as a result of the initial resolution attempt.
1800      bool recorded_res_status = bootstrap_specifier.save_and_throw_indy_exc(CHECK);
1801      if (!recorded_res_status) {
1802        // Another thread got here just before we did.  So, either use the method
1803        // that it resolved or throw the LinkageError exception that it threw.
1804        bool is_done = bootstrap_specifier.resolve_previously_linked_invokedynamic(result, CHECK);
1805        if (is_done) return;
</pre>
</td>
</tr>
</table>
<center><a href="../gc/parallel/psParallelCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../jvmci/jvmciCodeInstaller.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
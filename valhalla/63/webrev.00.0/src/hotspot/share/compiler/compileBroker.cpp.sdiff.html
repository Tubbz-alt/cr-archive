<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/compiler/compileBroker.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/parallel/psParallelCompact.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/compiler/compileBroker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 575   }
 576   st-&gt;cr();
 577 }
 578 
 579 void CompileQueue::print_tty() {
 580   ResourceMark rm;
 581   stringStream ss;
 582   // Dump the compile queue into a buffer before locking the tty
 583   print(&amp;ss);
 584   {
 585     ttyLocker ttyl;
 586     tty-&gt;print(&quot;%s&quot;, ss.as_string());
 587   }
 588 }
 589 
 590 CompilerCounters::CompilerCounters() {
 591   _current_method[0] = &#39;\0&#39;;
 592   _compile_type = CompileBroker::no_compile;
 593 }
 594 
<span class="line-modified"> 595 #if INCLUDE_JFR</span>
 596 // It appends new compiler phase names to growable array phase_names(a new CompilerPhaseType mapping
 597 // in compiler/compilerEvent.cpp) and registers it with its serializer.
 598 //
 599 // c2 uses explicit CompilerPhaseType idToPhase mapping in opto/phasetype.hpp,
 600 // so if c2 is used, it should be always registered first.
 601 // This function is called during vm initialization.
 602 void register_jfr_phasetype_serializer(CompilerType compiler_type) {
 603   ResourceMark rm;
 604   static bool first_registration = true;
 605   if (compiler_type == compiler_jvmci) {
 606     // register serializer, phases will be added later lazily.
 607     GrowableArray&lt;const char*&gt;* jvmci_phase_names = new GrowableArray&lt;const char*&gt;(1);
 608     jvmci_phase_names-&gt;append(&quot;NOT_A_PHASE_NAME&quot;);
 609     CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);
 610     first_registration = false;

 611   } else if (compiler_type == compiler_c2) {
 612     assert(first_registration, &quot;invariant&quot;); // c2 must be registered first.
 613     GrowableArray&lt;const char*&gt;* c2_phase_names = new GrowableArray&lt;const char*&gt;(PHASE_NUM_TYPES);
 614     for (int i = 0; i &lt; PHASE_NUM_TYPES; i++) {
 615       c2_phase_names-&gt;append(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));
 616     }
 617     CompilerEvent::PhaseEvent::register_phases(c2_phase_names);
 618     first_registration = false;

 619   }
 620 }
<span class="line-modified"> 621 #endif // INCLUDE_JFR</span>
 622 
 623 // ------------------------------------------------------------------
 624 // CompileBroker::compilation_init
 625 //
 626 // Initialize the Compilation object
 627 void CompileBroker::compilation_init_phase1(Thread* THREAD) {
 628   // No need to initialize compilation system if we do not use it.
 629   if (!UseCompiler) {
 630     return;
 631   }
 632   // Set the interface to the current compiler(s).
 633   _c1_count = CompilationPolicy::policy()-&gt;compiler_count(CompLevel_simple);
 634   _c2_count = CompilationPolicy::policy()-&gt;compiler_count(CompLevel_full_optimization);
 635 
 636 #if INCLUDE_JVMCI
 637   if (EnableJVMCI) {
 638     // This is creating a JVMCICompiler singleton.
 639     JVMCICompiler* jvmci = new JVMCICompiler();
 640 
 641     if (UseJVMCICompiler) {
</pre>
</td>
<td>
<hr />
<pre>
 575   }
 576   st-&gt;cr();
 577 }
 578 
 579 void CompileQueue::print_tty() {
 580   ResourceMark rm;
 581   stringStream ss;
 582   // Dump the compile queue into a buffer before locking the tty
 583   print(&amp;ss);
 584   {
 585     ttyLocker ttyl;
 586     tty-&gt;print(&quot;%s&quot;, ss.as_string());
 587   }
 588 }
 589 
 590 CompilerCounters::CompilerCounters() {
 591   _current_method[0] = &#39;\0&#39;;
 592   _compile_type = CompileBroker::no_compile;
 593 }
 594 
<span class="line-modified"> 595 #if INCLUDE_JFR &amp;&amp; COMPILER2_OR_JVMCI</span>
 596 // It appends new compiler phase names to growable array phase_names(a new CompilerPhaseType mapping
 597 // in compiler/compilerEvent.cpp) and registers it with its serializer.
 598 //
 599 // c2 uses explicit CompilerPhaseType idToPhase mapping in opto/phasetype.hpp,
 600 // so if c2 is used, it should be always registered first.
 601 // This function is called during vm initialization.
 602 void register_jfr_phasetype_serializer(CompilerType compiler_type) {
 603   ResourceMark rm;
 604   static bool first_registration = true;
 605   if (compiler_type == compiler_jvmci) {
 606     // register serializer, phases will be added later lazily.
 607     GrowableArray&lt;const char*&gt;* jvmci_phase_names = new GrowableArray&lt;const char*&gt;(1);
 608     jvmci_phase_names-&gt;append(&quot;NOT_A_PHASE_NAME&quot;);
 609     CompilerEvent::PhaseEvent::register_phases(jvmci_phase_names);
 610     first_registration = false;
<span class="line-added"> 611 #ifdef COMPILER2</span>
 612   } else if (compiler_type == compiler_c2) {
 613     assert(first_registration, &quot;invariant&quot;); // c2 must be registered first.
 614     GrowableArray&lt;const char*&gt;* c2_phase_names = new GrowableArray&lt;const char*&gt;(PHASE_NUM_TYPES);
 615     for (int i = 0; i &lt; PHASE_NUM_TYPES; i++) {
 616       c2_phase_names-&gt;append(CompilerPhaseTypeHelper::to_string((CompilerPhaseType)i));
 617     }
 618     CompilerEvent::PhaseEvent::register_phases(c2_phase_names);
 619     first_registration = false;
<span class="line-added"> 620 #endif // COMPILER2</span>
 621   }
 622 }
<span class="line-modified"> 623 #endif // INCLUDE_JFR &amp;&amp; COMPILER2_OR_JVMCI</span>
 624 
 625 // ------------------------------------------------------------------
 626 // CompileBroker::compilation_init
 627 //
 628 // Initialize the Compilation object
 629 void CompileBroker::compilation_init_phase1(Thread* THREAD) {
 630   // No need to initialize compilation system if we do not use it.
 631   if (!UseCompiler) {
 632     return;
 633   }
 634   // Set the interface to the current compiler(s).
 635   _c1_count = CompilationPolicy::policy()-&gt;compiler_count(CompLevel_simple);
 636   _c2_count = CompilationPolicy::policy()-&gt;compiler_count(CompLevel_full_optimization);
 637 
 638 #if INCLUDE_JVMCI
 639   if (EnableJVMCI) {
 640     // This is creating a JVMCICompiler singleton.
 641     JVMCICompiler* jvmci = new JVMCICompiler();
 642 
 643     if (UseJVMCICompiler) {
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/vmSymbols.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../gc/parallel/psParallelCompact.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>